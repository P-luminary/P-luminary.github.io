
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 软件设计师刷题考点</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>软件设计师刷题考点 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/16
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/软考" style=color:#1bccbc>
                    软考
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h2 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h2><p>@@ 如果”2x”的补码是”90H”, 那么x的真值是 <u><strong>-56</strong></u><br>90H 拆开根据8 4 2 1由十六进制转换为二进制：10010000；补码最高位为符号位, 1代表负号, 所以说明此数为<strong>负数</strong>，可以根据口诀直接得源码(注意符号位不变)：1111 0000 即 -112；故2X&#x3D;-112  X&#x3D;-56</p>
<p>@@ 计算机中CPU对其访问速度最快的是<u><strong>通用寄存器</strong></u><br>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的 其次是Cache 再次是内存 最慢的是作为外存的硬盘</p>
<p>@@ 属于CPU中算术逻辑单元的部位是**<u>加法器</u>**<br>控制单元部件：<strong>指</strong>令寄存器、<strong>程</strong>序计数器、地<strong>址</strong>寄存器、<strong>数</strong>据寄存器[紫橙子树]                                                                                                                                                                                                                                                                                                                                                                                                                                         加法器是算数逻辑运算单元的部件</p>
<p>@@ 在CPU中，常用来为ALU执行算数逻辑运算提供数据并暂存运算结果的寄存器是<strong>累加寄存器</strong>[是专门存放算术或逻辑运算的一个操作数和运算结果的寄存器(加 减 读出 移位)]</p>
<p>@@ 所谓定点数，就是表示数据时小数点的位置固定不变。<br>小数点的位置通常由两种约定方式：<br>①定点整数(纯整数, 小数点在最低有效数值位之后)<br>②定点小数(纯小数, 小数点在最高有效数值位之前)<br>当机器字长为n时, 定点数的补码和移码可表示$2^n$个数, 而其源码和反码只能表示$2^n-1$个数(0占用了两个编码), 所以定点数所能表示的数值范围比较小, 运算中很容易因结果超出范围而溢出<br>数的浮点表示的一般形式为：N&#x3D;F×$2^E$, 其中E称为阶码，F为尾数。<br>尾数部分F的位数越多↑，数的精度越高↑；指数部分E的位数越多↑，能表示的范围越大↑<br><strong>阶码</strong>通常为带符号的纯整数<br><strong>尾数</strong>为带符号的纯小数<br>在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同<br>当<strong>1&#x2F;2 ≤ |F|＜ 1</strong>时，应有0.1xx…x形式；<br>当**-1 ≤ M ＜ -1&#x2F;2<strong>时，应有1.0xx…x形式<br>当</strong>M&#x3D;-1&#x2F;2**时，对于源码来说是规格化数，而对于补码来说不是规格化数</p>
<p>@@ <strong>寄存器</strong>既可以用来存放<u>数据</u>和<u>地址</u>，也可以存放<u>控制信息</u>或<u>CPU工作时的状态</u><br>在CPU中增加寄存器的数量，可以使CPU把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行速度</p>
<p>@@ 程序计数器(PC)用于存放<strong>下一条指令所在单元的地址</strong>的地方</p>
<p>@@ 计算机系统中采用补码来表示和运算数据，原因是采用补码可以<strong>简化计算机运算部件的设计</strong><br>使用补码表示数据时，可以将符号位和其他位统一处理，减法也可按加法来处理，从而简化运算部件的设计</p>
<p>@@ 为了使一个系统能检查和纠正一个差错，间码最小距离必须至少是3<br><strong>海明码</strong>是一种可以纠正一位差错的编码，是<u>利用奇偶性来检错和纠错的一种校验方法</u>；海明码的基本意思是給传输的数据增加r个校验位，从而增加两个合法消息的不同位的个数。海明码利用奇偶性进行<u>检错</u>和<u>纠错</u>；其码距最小为<u>2n+1</u> [海明校验码只有在代码中只存在一个错误的前提下，才能实现纠错 ]<br>**循环冗余校验码(CRC)**编码方法是在k位信息码后再拼接r位的校验码，形成长度位n位的编码，其特点是检错能力极强且开销小，用于<u>编码器</u>及<u>检测电路实现</u><br><strong>奇偶校验</strong>是由若干位有效信息，再加上1  一个二进制位(校验位)组成校验码；奇偶校验只能查错不能纠错，<u>只有奇数个数发生错误，才能发现错误</u>；若有奇数个数据位出错，则可以检测出该错误但无法纠正错误</p>
<p>@@ 冗余技术：<br>1.结构冗余，按其工作方法可以分位<strong>静态</strong>、<strong>动态</strong>和<strong>混合</strong>冗余<br>2.信息冗余，指的是为了<strong>检测</strong>或<strong>纠正</strong>信息在运算或传输中的错误另外附加的一部分信息<br>3.时间冗余，指的是以重复执行指令或程序来消除顺时错误带来的影响<br>4.冗余附件技术，指的是为实现上述冗余技术所需的资源和技术</p>
<p>@@ CPU依据<strong>指令周期的不同阶段</strong>来区分在内存中以二进制编码形式存放的指令和数据<br>指令周期是执行一条指令所需时间，一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间</p>
<p>@@ 浮点数相加，对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。将小阶向大阶对齐，同时将尾数右移n位</p>
<p>@@ 在CPU的寄存器中，<strong>指令寄存器</strong>对用户是完全透明的</p>
<p>@@ 程序计数器是用于存放下一条指令所在单元的地址的地方</p>
<p>@@ 属于CPU中算数逻辑单元的部件是<strong>加法器</strong></p>
<p>@@ 高速缓存地址是为了高速缓存的读取和写入而使用的地址，在CPU和高速缓存之间进行数据传输时使用的；当CPU需要读取数据时，DMA控制器和中断CPU发出的数据地址是<strong>主存的物理地址</strong>[<u>中断向量</u>提供的是<strong>中断服务程序的入口地址</strong>]；硬盘的扇区地址是用于访问硬盘上指定扇区的地址，并不直接与CPU进行数据交互；虚拟地址，是指在操作系统中使用的地址，它需要通过地址映射和页表等机制转换为物理地址才能被CPU使用</p>
<p>@@ <strong>相联存储器</strong>是指<u>按内容访问</u>的存储器<br>按<strong>构成存储器</strong>的材料：磁存储器、半导体存储器、光存储器<br>按存储器的<strong>工作方式</strong>：读写存储器、只读存储器<br>按<strong>访问</strong>方式：按地址访问的存储器、按内容访问的存储器<br>按**[寻]地址**访问的存储器：随机存储器、顺序存储器、直接存储器</p>
<p>@@ ±0编码相同的是<strong>补码和移码</strong></p>
<p>@@ 计算机感染特洛伊木马后的典型现象是<strong>有未知程序试图建立网络连接</strong>。特洛伊木马是一种通过网络传播的病毒，分为客户端和服务器端两部分，服务器端位于被感染的计算机，特洛伊木马服务器端运行后会<strong>试图建立网络连接</strong>，所以计算机感染特洛伊木马后的典型现象是有未知程序试图建立网络连接</p>
<p>@@ 再微型计算机中，管理键盘最适合采用的1&#x2F;0控制方式是<strong>中断方式</strong></p>
<p>@@    在移臂调度算法中，<strong>先来先服务</strong>和<strong>最短寻找时间优先</strong>(<u>根据当前磁臂到要请求访问磁道的距离，誰短满足誰的请求</u>)算法可能会随时改变移动臂的运动方向</p>
<p>@@ 计算机中，系统总线用于<strong>CPU、主存及外设部件</strong>连接</p>
<p>@@ 双核是指<strong>在一个CPU中集成两个运算核心以提高运算能力</strong></p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong></p>
<p>@@ 在程序执行过程中，Cache与主存的地址映射是由<strong>硬件自动</strong>完成的</p>
<p>@@ 关于软件著作权产生的时间是<strong>自作品完成创作之日</strong></p>
<p>@@ 人耳：20Hz ~ 20kHz。 说话：300 ~ 3400Hz。音乐：20 ~ 20kHz。白噪音：20 ~ 20kHz</p>
<p>@@ <strong>存储动画</strong>的文件格式有<strong>FLC、GIF、SWF</strong></p>
<p>@@ <strong>网络视频格式</strong>包括<strong>MOV、RM、ASF、WMV</strong>&#x3D;&#x3D;</p>
<p>@@ <strong>多媒体视频图像文件</strong>格式有<strong>AVI、MPG、ASF、MP4</strong></p>
<p>@@ <strong>声音、音频文件</strong>格式有<strong>WAV、WMA、MP3、MIDI、RA、APE</strong></p>
<p>@@ 属于<strong>图像文件</strong>格式有<strong>GIF、BMP、JPG、PNG、TIF</strong></p>
<blockquote>
<p><strong>.wma</strong>微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</p>
</blockquote>
<p>@@ 位图（Bitmap）&#x3D;&gt; <strong>BMP</strong></p>
<p>@@ <strong>语音识别技术</strong>体现了<u><strong>多媒体技术</strong>与<strong>人工智能技术</strong></u>相结合</p>
<p>@@ 计算机系统的主存主要是由<strong>DRAM</strong>构成的。<br>随机访问存储器(<strong>RAM</strong>)有两类：静态的(SRAM) 和 动态的(DRAM)</p>
<p>@@ 存储系统采用Cache技术的主要目的是提高存储器的访问速度，因此是由<strong>硬件自动完成</strong>Cache与主存之间的操作</p>
<p>@@ 主存与Cache的地址映射方式中，<strong>全相联</strong>方式可以实现主存任意一块装入Cache中任意位置，只有装满才需要替换<br><strong>全相联地址映射：</strong>主存的任意一块可以映射到Cache中的<strong>任意</strong>一块<br><strong>直接相联映射：</strong>主存中一块只能映射到到Cache的一个<strong>特定</strong>的块中<br><strong>组相联的映射：</strong>各区中的某一块只能存入缓存的同组号的空间内，但组内各块地址之间则可以任意存放。即从<strong>主存</strong>的组到Cache的组之间采用直接映像方式，在两个对应的<strong>组内部</strong>采用全相联映像方式</p>
<p>@@ 常用的虚拟存储器由<strong>主存-赋存</strong>两级存储器构成<br>虚拟存储技术使辅助存储器和主存储器密切配合。虚拟存储器的地址称为虚地址或逻辑地址  </p>
<p>@@ 虚拟存储体系由<strong>主存-赋存</strong>两级存储器构成<br>一般计算机系统中主要由两种存储体系：<br><u><strong>Cache存储体系</strong></u>由<strong>Cache</strong>和<strong>主存储器</strong>构成，主要目的是提高存储器速度，对系统程序员以上均透明<br><u><strong>虚拟存储体系</strong></u>由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明</p>
<p>@@ Cache的地址映像方式中，发生块冲突次数最小的是<strong>全相联映像</strong><br>Cache的地址映射方法主要有三种：全相联地址映射、直接相联地址映射、组相联地址映射<br>**全相联地址映射 **[意味着主存的任意一块可以映射到Cache中的任意一块，特点：块冲突概率低，Cache空间利用率高，但相联目录表容量大导致成本高、查表速度慢]<br><strong>直接映像方式</strong> [指主存的每一块只能映像到Cache的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同，其特点是硬件简单，不需要相联存储器，访问速度快，Cache块冲突概率高，Cache控件利用率低]<br><strong>组相联映射</strong> [是上面两种方法的这种处理]</p>
<p>@@ 计算机采用分级存储体系的主要目的是为了解决<strong>存储容量、成本和速度之间的矛盾</strong>问题<br>高速缓存一般用SRAM[速度快,成本高]<br>内存一般用DRAM[集成度高,动态刷新]<br>外存一般用磁存储器[速度慢,容量大,价格便宜]</p>
<p>@@ Cache的设计思想是在合理成本下提高命中率</p>
<p>@@ <strong>并行总线</strong>适合<strong>近距离高速数据传输</strong>、<strong>串行总线</strong>适合<strong>长距离数据传输</strong><br>在单总线结构中，CPU与主存之间、CPU与I&#x2F;O设备之间、I&#x2F;O设备与主存之间、各种设备之间都通过系统总线交换信息。单总线结构的优点是控制简单方便，扩充方便</p>
<p>@@ 处理机主要由处理器、存储器和总线组成</p>
<p>@@ 总线：数(数据总线) 控(控制总线) 地(地址总线) ISA EISA PCI MCA<br>SCSI是一种用于计算机和智能设备之间系统级接口的独立处理器标准</p>
<p>@@ 总线复用方式可以<strong>减少总线中信号线的数量</strong><br>总线式一组能为多个部件分时共享的信息传送线，用来连接多个部件并为之提供信息交换通路，通过<strong>总线复用方式</strong><u>可以减少总线中信号线的数量，以较少的信号线传输更多的消息</u></p>
<p>@@ 在计算机系统中采用总线结构，便于实现系统的积木化结构，同时可以<strong>减少总线中信号线的数量</strong> </p>
<p>@@ <strong><u>直接主存存取</u></strong>(<strong>DMA</strong>)[Direct Memory Access]控制方式是在<strong>主存与外设</strong>之间直接建立数据通路进行数据的交换处理</p>
<p>@@ 在I&#x2F;O设备与主机间进行数据传输时，CPU只需在开始和结束时作少量处理，而无需干预数据传送过程的是<strong>直接存储器存取 [DMA]<strong>方式。[直接内存存取(Direct Memory Access)方式的基本思想是通过</strong>硬件控制</strong>实现<u><strong>主存</strong></u>与**<u>I&#x2F;O设备</u>**间的直接数据传送，数据的传递过程由DMA控制器进行控制，不需要CPU的干预。在DMA方式下由CPU启动传送过程，即向设备发出”传送一块数据”的命令，在传送过程结束时，DMAC通过中断方式通知CPU进行一些后续处理工作]</p>
<p>@@ 在微机系统中，BIOS(基本输入输出系统)保存在<strong>主板上的ROM</strong>中 [BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从<strong>CMOS</strong>中读写系统设置的具体信息]</p>
<p>@@ 计算机运行过程中，遇到突发事件，要求CPU暂时停止正在运行的程序，转去为突发事件服务，服务完毕，再自动返回原程序继续执行，这个过程成为<strong>中断</strong>，其处理过程中保存现场的目的是<strong>返回去继续执行原程序</strong></p>
<p>@@ CPU是再<strong>一个总线周期</strong>结束时响应DMA请求的 [DMA请求的检测点设置在每个机器周期也即总线周期结束时执行，这样使得总线利用率最高]</p>
<p>@@ 计算机中CPU的中断响应时间指的是<strong>从发出中断请求到开始进入中断处理程序</strong>的时间</p>
<p>@@ 中断向量可提供<strong>中断服务程序的入口地址</strong>[为了提高响应中断的速度，通常把所有<u>中断服务<strong>程序的入口地址</strong></u>[称中断向量]汇聚为<strong>中断向量表</strong>]</p>
<p>@@ 为了便于实现多级中断嵌套，使用<strong>堆栈</strong>来保护断点和现场最有效 【<u>实现中断嵌套<strong>后进先出</strong>的栈来保护断点和现场最有效(当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为<strong>中断嵌套</strong>)</u>】</p>
<p>@@ <strong>由I&#x2F;O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断</strong><br>可将中断分为两大类：<br><strong>不可屏蔽中断</strong>(非屏蔽中断) 和 <strong>可屏蔽中断</strong><br><strong>不可屏蔽中断源</strong>[断电]一旦提出请求，CPU必须无条件响应，而对<strong>可屏蔽中断源</strong>[打印机中断(处于等待请求响应)]的请求，CPU可以响应，也可以不响应。</p>
<p>@@ 计算机在一个指令周期过程中，为从内存读取指令操作码，首先要将**程序计数器(PC)**的内容送到地址总线上<br>CPU首先从程序计数器获得需要执行的指令地址，从内存(或高速缓存)读取到的指令则暂存在指令寄存器(IR)，然后进行分析和执行</p>
<p><strong>程序计数器</strong>是PC用于存放下一条指令所在单元的地址的地方<br><strong>指令寄存器</strong>是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一套指令<br><strong>地址寄存器</strong>用来保存当前CPU所访问的内存单元的地址<br><strong>指令译码器</strong>从内存中取出一条指令经数据总线送往指令寄存器中</p>
<p>@@ 对于只有单条指令的情况下，流水线方式与顺序执行时没有区别的。流水线的原理是在某一时刻可以让多个部件同时处理多条指令，避免各部件等待空闲，由此提高了各部件的利用率，也提高了系统的吞吐率</p>
<p>@@ 流水线的吞吐率是指单位时间流水线处理机输出的结果的数目，因此流水线的吞吐率为一个流水级时间的倒数，即最长流水级时间的倒数</p>
<p>@@ CPU执行算术运算或者逻辑运算时，常将源操作数和结果暂存在<strong>累加器(AC)<strong>中<br>CPU中常设置多个寄存器，其中，<u><strong>程序计数器</strong>的作用是保存<em>待读取</em> 指令在内存中的地址</u>，</strong>累加器(AC)<strong>是算数逻辑运算单位中用来<u><strong>暂存</strong>源操作数</u>和<u>计算结果的寄存器</u>，</strong>指令寄存器</strong>暂存从内存读取的指令，<strong>地址寄存器</strong>暂存要访问的内存单元的地址。</p>
<p>@@ <strong>VLIW</strong>(Very Long Instruction Word, 超长指令字) 一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度</p>
<p>@@ 在机器指令的地址字段中，直接指出操作数本身的寻址方式称为<strong>立即寻址</strong>[是一种特殊的寻址方式 指令中在操作码字段后面的部分不是通常意义的操作数，而是操作数本身，也就是说数据就包含在指令中，只要取出指令，也就是去除了可以立即使用的操作数]</p>
<p>@@ 若CPU要执行的指令为：MOV R1，#45(即将数值45传递到寄存器R1中)，则该指令中采用的寻址方式是<strong>寄存器寻址和立即寻址</strong> [45是立即数，R1是寄存器]<br><strong>立即寻址：</strong>操作数就包含在指令中<br><strong>直接寻址：</strong>操作数存放在内存单元中，指令中直接給处操作数所在内存单元的地址<br><strong>寄存器寻址：</strong>操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名<br><strong>寄存器间接寻址：</strong>操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中<br><strong>间接寻址：</strong>指令中给出操作数地址的地址<br><strong>相对寻址：</strong>指令地址码给出的是一个偏移量可正可负，操作数地址等于本条指令的地址加上该偏移量<br><strong>变址寻址：</strong>操作数地址等于变址寄存器的内容加偏移量</p>
<p>@@ CISC(Complex Instruction Set Computer)是<strong>复杂指令系统计算机</strong>的简称 其基本思想是：<u>进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上</u><br>RISC(Reduced  Instruction Set Computer <strong>精简指令集计算机</strong>) 其基本思想是：<u>通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用<strong>硬布线</strong>控制逻辑优化编译程序。</u> 通常会比CISC配置更多的寄存器、RISC编译器的子程序库通常要比CISC编译器的子程序库大很多、RISC比CISC更加适合VLSI工艺的规整性要求。</p>
<p>@@ Flynn分类法基于信息流特征将计算机分成4类，其中<strong>MISD</strong>只有理论意义而无实例<br>Flynn主要根据指令流和数据流来分类：<br>① 单指令流单数据流机器(SISD)<br>② 单指令流多数据流机器(SIMD)<br>③ 多指令流单数据流机器(MISD)[<strong>M</strong>ulti <strong>I</strong>nstruction <strong>S</strong>ingle <strong>D</strong>ata] [采用多个指令流来处理单个数据流 在实际情况中，采用多指令流处理多数据流才是最有效的方法，因此MISD<strong>只是作为理论模型出现，没有投入实际应用</strong>]<br>④ 多指令流多数据流机器(MIMD)</p>
<p>@@ 取指令时间4Δt，分析时间为2Δt，执行时间为3Δt，按顺序方式从头到尾执行完600条指令所需时间为<strong>5400</strong>Δt，使用流水线从头到尾执行完600条指令所需的时间为<strong>2405</strong>Δt [未说流水线就普通乘法计算 流水线则按公式计算]<br>① 指令顺序执行时，每条指令需要(4Δt+2Δt+3Δt)&#x3D;9Δt     9Δt×600&#x3D;5400Δt<br>② (4Δt+2Δt+3Δt) + (600-1) × 4 &#x3D; 2405Δt</p>
<p>@@ 指令系统中采用不同寻址方式的目的是<strong>扩大寻址控件并提高编程灵活性</strong></p>
<p>@@ 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>操作码和地址吗都应存入指令寄存器(IR)</strong> [程序被加载到内存后开始运行，当CPU执行一条指令时，<u><strong>先把它从内存器取到缓冲寄存器DR中，再送入IR暂存</strong></u>，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所有功能。]</p>
<p>@@ CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制、CPU中的控制器决定计算机运行过程的自动化、指令译码器是CPU控制器中的部件<br>CPU是计算机的控制中心，主要由运算器、控制器、寄存器组、和内部总线等部件组成。<br><strong>控制器</strong>由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成</p>
<p>@@ 可靠度串并联：串联系统可靠度为R1×R2，并联系统可靠度为R1&#x2F;R2&#x3D;1-(1-R)</p>
<p>@@ 计算机系统的<strong>可靠性</strong>可以用**MTBF &#x2F; (1+MTBF)**来度量，其中MTBF为平衡失效间隔时间 [又称平均无敌故障时间] 是衡量一个产品(尤其是电器产品)的可靠性指标，单位为”小时”</p>
<p>@@ 软件产品的可靠性并不取决于<strong>软件产品的开发方式</strong> 而取决于<strong>潜在的错误数量和位置，软件产品的使用方式</strong>；软件可靠性指的是一个系统对于给定的时间间隔内，在给定条件下**<u>无失效运作的概率</u>**。</p>
<p>@@ <u>软件<strong>可靠性</strong></u>是指一个系统在给定时间间隔内和给定条件下<strong>无失败运行的概率</strong>，一个软件系统能够按照规格说明正确运行的概率。<u>软件<strong>可维护性</strong></u>是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源<strong>完成维护活动的概率</strong></p>
<p>@@ <strong>应用级网关</strong>防火墙是内部网和外部网的隔离点，它可对应用层的通信数据流进行监控和过滤。应用级网关可以工作在OSI七层模型上的任意一层，能够检查进出的数据包，通过网关复制传递数据，防止在受信任服务器和客户机与不受信任的主机之间直接建立联系。</p>
<p>@@ 用户A和B要进行安全通信，通信过程需确认双方身份和消息不可否认，A和B通信时使用<strong>数字证书</strong>来对用户的身份进行认证；使用<strong>数字签名</strong>确保消息不可否认。数字签名是对<strong>真实性</strong>的保护</p>
<p>@@ <strong>震网</strong>病毒是一种破坏工业基础设施的恶意代码，利用系统漏洞攻击工业控制系统，是一种危害性极大的<strong>蠕虫病毒</strong>。<strong>蠕虫(Worm)<strong>是一个程序或程序序列。它利用网络进行复制和传播，传染途径是通过网络、移动存储设备和电子邮件。最初的蠕虫病毒定义是在DOS环境下，病毒发作时会在频幕上出现一条类似虫子的东西，胡乱吞吃屏幕上的字母并将其改正。常见的蠕虫病毒有：</strong>快乐时光、红色代码、爱虫病毒、熊猫烧香、Nimda病毒、爱丽兹病毒</strong>。<strong>CIH</strong>：系统病毒      <strong>X卧底</strong>：以木马形式传播目标为智能手机的病毒<br><strong>引导区病毒</strong>：破坏的是引导盘、文件目录<br><strong>宏病毒</strong>[<strong>Macro</strong>]：破坏的是OFFICE文件相关(病毒宏将自身复制至Word的通用Normal模板中)<br><strong>木马</strong>：一般强调控制操控 [<strong>冰河</strong>是木马软件，主要用于远程监控。冰河木马后经其他人多次改写形成多种变种，并被用于入侵其他用户的计算机木马程序]</p>
<p>@@ Sniffer(<strong>嗅探器</strong>)是一种基于被动侦听原理的网络分析方式。使用这种技术方式可以监视网络的状态、数据流动情况以及网上传输的信息。它不是木马程序</p>
<p>@@ 属于DoS攻击的是<strong>SYN Flooding攻击</strong> [<u>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</u>]<br>① <strong>特洛伊木马</strong>[Trojan]是附着在应用程序中或者单独存在的一些恶意程序，它可以利用网络远程控制网络的另一端的安装有服务端服务的主机，实现对被植入了木马程序的计算机的控制，或者窃取被植入了木马程序的计算机上的机密资料。<br>② <strong>拒绝服务攻击</strong>通过网络的内外部用户来发动攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务器攻击；外部黑客也可以通过占用网络连接使其他用户得不到网络服务   <strong>SYN Flooding攻击</strong>以多个随机的源主机地址向目的路由器发送SYN包，在收到目的路由器的SYN ACK后并不回应，于是目的路由器就为这些源主机建立大量的连接队列，由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致服务器崩溃。服务器要等待超时才能断开已分配的资源，所以SYN Flooding攻击是一种DOS攻击<br>③ <strong>端口欺骗攻击</strong>是采用端口扫描到系统漏洞从而实施攻击<br>④ <strong>IP欺骗攻击</strong>是产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份</p>
<p>@@ DES是<strong>共享密钥加密</strong>算法；常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES<br><u>共享密钥加密</u>指<u><strong>对称加密</strong></u>；<br><u>非共享密钥</u>加密指<u><strong>公开密钥加密</strong></u></p>
<p>@@ 计算机病毒的特征：<strong>隐蔽性、传染性、潜伏性、触发性、破坏性</strong></p>
<p>@@ MD5是<strong>摘要</strong>算法，对任意长度的输入计算得到的结果长度是<strong>128未散列值</strong></p>
<p>@@ 攻击者通过发送一个目的主机已经接受过的报文来达到攻击目的，这种攻击方式属于<strong>重放</strong>攻击<br>**重放攻击(Replay Attacks)**又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行</p>
<p>@@ kerberos系统中可通过在报文中加入<strong>时间戳</strong>来防止重放攻击。发送的数据包带时间戳的，服务器可以根据时间戳来判断是否为重放包，以此防止重放攻击</p>
<p>@@  防火墙最基本的功能就是控制在计算机网络中，不同信任程度区域间传送的数据流。防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可也关闭不适用的端口，屏蔽内部细节。所有的访问都经过防火墙，防火墙就能记录下这些访问并做出日志记录，同时也能提供网络使用情况的统计数据</p>
<p>@@ 防火墙的性能及特点：<br>① <strong>工作层次：</strong>决定防火墙效率及安全的主要因素，<u><strong>工作层次越低，则工作效率越高，其安全性就越低</strong></u><br>② <strong>防火墙机制：</strong>采用代理机制，则防火墙具有内部信息隐藏的特点，相对而言，安全性越高，效率越低。如果采用<strong>过滤机制</strong>，则效率高，安全性却降低</p>
<p>@@ 包过滤防火墙和代理服务防火墙的叙述中正确的是<strong>包过滤技术对应用和用户是透明的</strong>。包过滤技术是一种基于网络层、传输层的安全技术，优点是简单实用，实现成本较低同时，<strong>包过滤操作对于应用层来说是透明的</strong>，使用此类防火墙时外部网络与内部网络之间不存在直接连接，即使防火墙发生了问题，外部网络也无法被保护的网络连接。</p>
<p>@@ 包过滤防火墙对数据包的过滤依据包括<strong>源IP地址、源端口号、目标IP地址、目标端口号</strong> 而不是<del>MAC地址</del></p>
<p>@@ 防火墙通常分为<strong>内网、外网、DMZ</strong>三个区域<br>按照<u>受保护程序</u>[安全级别]从高到低正确排列顺序依次为<strong>内网、DMZ、外网</strong>；<br>① 内网可以访问外网、内网可以访问DMZ<br>② 外网可以访问DMZ、外网不能访问内网<br>③ DMZ不能访问外网、DMZ不能访问内网</p>
<p>@@ 入侵检测技术包括<strong>专家系统、模型检测、简单匹配</strong> [<u>入侵检测</u>和<u>流量控制</u>属于网络安全措施]</p>
<p>@@ 这四种加密算法均能对明文进行加密。<br><strong>RSA</strong>是一种非对称加密算法，由于加密和解密的密钥不同，因此便于密钥管理和发放，同时用户或机构之间进行身份认证方面有较好的应用 [基于大数定律，通常用于对消息摘要进行签名(<strong>数字签名算法</strong>) 而IDEA和RC4适用于对数据传输加密]<br><strong>SHA-1</strong>是一种安全散列算法，常用于对接接收到的明文输入产生固定长度的输出，来确保明文在传输过程中不会被篡改<br><strong>MD5</strong>是一种使用最为广泛的报文摘要算法(<strong>摘要算法</strong>)<br><strong>RC5</strong>是一种用于对明文进行加密的算法，在加密速度和强度上均较为合适，适用于大量明文进行加密并传输</p>
<p>@@ 假定用户A、B分别为I1和I2两个CA处取得了各自的证书，下面<strong>I1、I2互换公钥</strong>是A、B互信的必要条件</p>
<p>@@ <strong>MIME</strong>是一个互联网标准，<u>扩展了电子邮件标准</u>，使其能够支持，与安全无关。<br><strong>SSL</strong>和<strong>HTTPS</strong>涉及到<u>邮件传输过程的安全</u><br><strong>PGP</strong>是一套用于信息加密、验证的应用程序，可用于<u>加密电子邮件内容</u></p>
<p>@@ 数字签名用于通信的A、B双方，使得A向B发送签名的消息P，提供以下服务：<br>① B可以验证消息P确实是来源于A<br>② A不能否认发送过消息P<br>③ B不能便在或修改消息P<br>数字签名首先需要生成消息摘要，使用非对称加密算法以及私钥对摘要进行加密。接收方使用发送方的公钥对消息摘要进行验证。</p>
<p>@@ 用户B收到用户A带数字签名的消息M，为了验证M的真实性，<span style = "color : red">首先需要从CA获取用户A的数字证书，并利用<strong>CA的公钥</strong>验证该证书的<strong>真伪</strong></span>，然后利用<strong>A的公钥</strong>验证M的真实性 [<u>验证证书的真伪需要用CA的公钥验证CA的签名，验证M的真实性需要用用户A的公钥验证用户A的签名</u>]</p>
<p>@@ <span style = "color : red">从认证中心CA获取用户B的数字证书，该证书用<strong>CA的私钥</strong>作<strong>数字签名</strong></span>：<u>从用户B的数字证书中可以获得B的公钥</u> 【<strong>CA公钥→合法性、CA签名→真伪、CA私钥→数字签名</strong>】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/030ab484289fb8237b38a9a6a073451c201af8c5/data/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p>
<p>@@ 公钥体系中，<strong>私钥用于<u>解密和签名</u>，公钥用于<u>加密和认证</u></strong></p>
<p>@@ 某网站向CA申请了数字证书，用户通过<strong>CA的签名</strong>来验证网站的<strong>真伪</strong>，通过使用<strong>CA的公钥</strong>来确定该网站的<strong>合法性</strong></p>
<p>@@ <strong>设置防雷击</strong>属于物理线路安全措施、<strong>入侵检测, 流量控制</strong>属于网络安全措施、<strong>漏洞发现于补丁管理</strong>属于系统安全措施</p>
<p>@@ <strong>网络攻击</strong>有<strong>主动攻击</strong>和<strong>被动攻击</strong>两类，主动攻击是指通过一系列方法主动向被攻击对象试试破坏的一种攻击方式，<strong>主动攻击</strong>有：<u>重放攻击、IP地址欺骗、拒绝服务</u>。<strong>流量分析攻击</strong>[被动攻击]是通过持续检测现有网络中的流量变化或者变化趋势，而得到相应信息的一种被动攻击方式</p>
<p>@@ 端口443明确用于<strong>HTTPS服务</strong>，因此是HTTPS（加密）流量的标准端口。 它也称为HTTPS端口443，因此所有受保护的事务都是使用端口443进行的。 您可能会惊讶地发现，几乎95％的安全站点都使用端口443进行安全传输。80端口是<strong>HTTP超文本传输协议</strong>。</p>
<table>
<thead>
<tr>
<th align="center">Proto</th>
<th align="center">Local Address</th>
<th align="center">Foreign Address</th>
<th align="center">State</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2011</td>
<td align="center">202.100.112.12:443</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2052</td>
<td align="center">128.105.129.30:80</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2038</td>
<td align="center">100.29.200.110:110</td>
<td align="center">TIME_WAIT</td>
</tr>
</tbody></table>
<p>① 其中已经与主机202.100.112.12的443端口建立连接，由于443端口主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP协议，是建立了<strong>安全连接</strong>。<br>② 其中已经与主机128.105.129.30的80端口建立了普通连接。<br>③ 其中与主机100.29.200.110的110端口正在等待建立连接</p>
<p>@@ <strong>SSH</strong>(Secure Shell)是<strong>终端设备</strong>与<strong>远程站点</strong>之间建立安全连接的协议，是专为远程登录会话和其他网络服务提供安全性的协议，利用SSH协议可以有效防止远程管理过程中的信息泄露问题，SSH最初是UNIX上的程序</p>
<p>@@ <strong>机房安全</strong>属于物理安全、<strong>入侵检测</strong>属于网络安全、<strong>漏洞补丁管理</strong>属于系统安全、<strong>数据库安全</strong>属于应用安全</p>
<p>@@ 网络系统中，通常把<strong>Web服务器</strong>置于DMZ区 [DMZ是为了<u>解决安装防火墙后外部网络不能访问内部网络服务器的问题</u>，而设立的一个非安全系统与安全系统之间的缓冲区。这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以防止一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛]</p>
<p>@@ 拒绝服务攻击即攻击者想办法让目标机器停止提供服务，这是黑客常用的攻击手段之一，其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于<strong>拒绝服务攻击</strong>。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是<u><strong>迫使服务器的缓冲区满</strong></u>，不接收新的请求。二是<u><strong>使用IP欺骗</strong></u>，迫使服务器把合法用户的连接复位，影响合法用户的连接</p>
<p>@@ PKI体制中，保证数字证书不被篡改的方法是<strong>用CA的私钥对数字证书签名</strong>[防伪造,不可抵赖]</p>
<p>@@ <strong>ECC、DSA、RSA</strong>属于公开密钥加密算法     <strong>DES</strong>属于<strong>私钥加密体制</strong></p>
<p>@@ 利用<strong>报文摘要算法</strong>生成报文主要的目的是<strong>防止发送的报文被篡改</strong> [报文摘要是用来保证数据完整性的，传输的数据一旦被修改，摘要就不同了，只要对比两次摘要就可以确定数据是否被修改过]</p>
<p>@@ <strong>TLS</strong>是安全传输层协议的简称，用于在两个通信应用程序之间提供保密性和数据完整性<br><strong>SSL</strong>是安全套接层协议的简称，是一种为网络通信提供安全和数据完整性的协议，它与TLS非常相似，它们都是在<u>传输层</u>对网络连接进行加密<br><strong>PGP</strong>是基于RSA公钥加密体系的邮件加密软件，用它可以对邮件保密以防止非授权者阅读<br><strong>HTTPS</strong>即安全版的<strong>HTTP</strong>(超文本传输协议)，它是在HTTP下加入SSL层，HTTPS的安全基础就是SSL<br><strong>IPSec</strong>是<u>网络层</u>的安全协议，它通过使用加密的安全服务来确保在网络上进行保密而安全的通讯</p>
<p>@@ 在Windows系统中，默认权限最低的用户组是<strong>everyone</strong><br>用户组默认权限由高到低的顺序是<strong>administrators &gt; power users &gt; users &gt; everyone</strong></p>
<p>@@ IIS6.0支持的身份验证安全机制有[<u>.NET Passport身份验证、集成Windows身份验证、摘要式身份验证、基本身份验证</u>]安全级别最高的验证方法是<strong>集成Windows身份验证</strong></p>
<p>@@ 利用<strong>漏洞扫描系统</strong>可以获取某FTP服务器中是否存在可写目录的信息 [通过与目标主机TCP&#x2F;IP端口建立连接并请求某些服务(TELNET、FTP)，记录目标主机的应答，搜索目标主机相关信息，从而发现目标主机某些内在的安全弱点]</p>
<p>@@ FTP服务器的控制端口为<strong>21</strong>，上传文件时的端口为<strong>20</strong></p>
<p>@@ 防范网络监听最有效的方法是<strong>数据加密</strong></p>
<p>@@ “三网合一”的三网是指<strong>电信网、广播电视网、互联网</strong></p>
<h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>@@ <strong>LISP</strong>是一种通用高级计算机程序语言、<strong>C</strong>是命令式过程式语言、<strong>Java</strong>面向对象语言、<strong>C#<strong>结构化程序设计语言、</strong>Java,Python,JavaScript</strong>都是解释型程序设计语言[其中python[弱类型语言]和javascript是<u>脚本语言</u>(主要采用<strong>解释方式实现</strong>)]<br>强&#x2F;弱类型指的是语言类型系统的类型检查的严格程度。弱类型相对于强类型来说类型检查<strong>更不严格</strong>, 比如<u>允许变量类型的隐式转换，允许强制类型转换</u>等</p>
<p>@@ <strong><u>语法制导翻译</u><strong>是一种</strong>静态语义分析</strong>方法。程序设计语言的语义分为<strong>静态语义</strong>和<strong>动态语义</strong>，其中静态语义分析方法是语法制导翻译，其基本思想是将语言结构的语义以属性的形式赋予代表此结构的文法符号，而属性的计算以语义规则的形式赋予文法的产生式。</p>
<p>@@ 常用的函数参数传递方式有<strong>传值</strong>与<strong>传引用</strong>两种；<strong>在传引用方式下，修改形参实质上改变了实参的值</strong>。[<u>在<strong>传值</strong>调用方式下，是将实参的值传递给形参，该传递是单方向的，结束调用后不会再将形参的值传递給实参</u>。<u>在<strong>引用</strong>调用方式下，实质上是将实参的地址传递給形参，借助指针的间接访问数据方式下(或者将形参看作是实参的别名)，在被调用函数中对形参的修改实质上是对实参的修改。</u>]</p>
<p>@@ 在<strong>值调用</strong>方式下是将参数的值传給形参。在<strong>引用调用</strong>方式下是将实参的地址传递给形参                 </p>
<p>@@ 在<strong>传值调用</strong>方式下，实参可以是变量，也可以是常数和表达式<br>在<strong>引用调用</strong>方式下，可以是实现形参和实参间双向传递数据的效果          </p>
<p>@@ 传地址方式下，<u>将<strong>实参</strong>的地址传給<strong>形参</strong></u>，因此，实参必须有地址                                                                       </p>
<p>@@ 函数中print(x)执行后输出的值为<strong>40</strong></p>
<pre><code class="C">main()&#123;                      f(int x, int &amp;a)&#123;
  int x = 5;                    x = x * x - 1;
  f(x+1,x);                        a = x + a;
  print(x);                        return;
&#125;                               &#125;
</code></pre>
<p>@@ 函数中return(a-x)执行后输出的值为<strong>33</strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/92ef1aa18e2abcd24f114fb254939f65a6933028/data/%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80.png" style="zoom:50%;" /></p>
<p>@@ 编译器对高级语言源程序的处理过程：<br><u>源程序 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 代码优化 → 目标代码生成 → 目标代码</u>；<br>其中<strong>中间代码生成和代码优化</strong>并不是每个编译器都必需的，与编译器相比，解释器<strong>参与运行控制，程序执行的速度慢</strong></p>
<p><strong>词法分析</strong>：根据语言的词法规则，对源程序进行逐个字符地描述，从中识别出一个个单词符号，针对词汇的检查<br><strong>语法分析</strong>：在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位；<br><strong>语义分析</strong>：分析各语法结构的含义，检查源程序是否包含语义错误，主要针对句子含义的检查；</p>
<p>@@ <strong>语法分析阶段</strong>的输入是<strong>记号流</strong>，若程序中的符号不匹配，则会在<strong>语法分析阶段</strong>检查出错误<br><strong>记号流</strong>：词法分析的输出是记号流，也就是语法分析的输入。<br><strong>源程序</strong>：词法分析的任务是把源程序的字符串转换成单词符号序列<br><strong>分析树</strong>：如果没有语法错误，语法分析后就能正常的构造出语法树</p>
<p>@@ <strong>语法错误</strong>是指语言结构上的使用错误，是指编译时所发现的程序错误，如<strong>单词拼写错误、标点符号错误、表达式中缺少操作数、符号不匹配</strong>等有关语言结构上的错误 [<u>语法分析阶段可以发现程序中所有的语法错误、但是不能在语义分析阶段发现程序中的所有语义错误(循环越界)</u>]</p>
<p>@@ 若程序在运行时陷入死循环，则情况属于<strong>动态的语义错误</strong>；在编译过程中，进行类型分析和检查是<strong>语义分析</strong>阶段的一个主要工作。**<u>死循环，零除数，其他逻辑错误</u><strong>是属于</strong>动态语义错误<strong>。语义检查时不检查动态语义，因此</strong><u>编译正确的程序不包含语法错误</u>**</p>
<p>@@ 高级程序设计语言不依赖具体的<strong>机器硬件</strong>；程序中局部变量的值在运行时<u>可以改变</u>，局部函数只能在函数内部使用，其作用域是从定义位置起至函数体或复合语句体结束位置。</p>
<p>@@ 在编写C&#x2F;C++时，若表达式中引用的变量从定义到使用始终没有赋值，则该变量中的值表现为一个<strong>随机数</strong>，这样对表达式的求值结果就是不确定的了。故[可以通过编译并运行，但运行结果不一定是期望的结果]</p>
<p>@@ 关于高级程序设计语言翻译的叙述中正确的是<strong>目标代码生成阶段的工作与目标机器的体系结构密切相关</strong></p>
<p>@@ 变量与常量：<strong>变量具有类型属性，常量则没有</strong> [<u>常量在程序运行过程中不能修改</u>]</p>
<p>@@ 可视化程序设计是以”<strong>所见即所得</strong>“的编程思想为原创，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。可视化程序设计仅通过直观的操作方式即可完成界面的设计工作[其基于面向对象的思想，引入了控件的概念和事件驱动；程序开发遵循步骤：即<u>先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作</u>]。可视化程序设计最大的有点是设计人员可以不用编写或只需要编写很少程序代码，就能完成应用程序的设计，极大提高设计人员的工作效率</p>
<p>@@ PHP不是标记语言，PHP，全称 Hypertext Preprocessor ，中文翻译“超文本预处理器”。是在 服务器 端执行的 脚本语言 ，尤其适用于 Web 开发并可嵌入 HTML 中。 </p>
<p>@@ 创建指向邮箱地址的连接**<code>&lt;a href = &quot;mailto:test@test.com&quot;&gt; test@test.com &lt;/a&gt;</code>** 使用**<code>&lt;mailto&gt;</code>**标签定义一个指向电子邮件地址的超级链接</p>
<p>@@ <strong>指针变量</strong>可以是全局变量也可以是局部变量 </p>
<p>@@ 若一个程序语言可以提供链表的定义和运算，则其运算时的<strong>数据空间必须采用堆存储分配策略</strong></p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等，在结构上的变化。动态语言的类型检查是在运行时进行的。优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解。事实上脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言 ；C语言属于<strong>静态语言</strong>，其所有成分可在编译时确定</p>
<p>@@ HTML<code>&lt;body&gt;</code>元素中，<strong>vlink</strong>属性用于定义超链接被鼠标点击后所显示的颜色<br><strong>alink</strong>：用于设置正在被击中的链接的颜色<br><strong>vlink</strong>：用于设置已使用的链接的颜色<br><strong>bgcolor</strong>：用于设置文档整体背景颜色<br><strong>background</strong>：用于设置背景图片的URL</p>
<p>@@ XML文档语法规范中：<strong>标记之间不可以交叉嵌套</strong></p>
<p>@@ <strong>动态</strong>绑定是指在运行时把过程调用和响应调用所需要执行的代码加以结合。<strong>运行时结合</strong>是<strong>动态绑定</strong>、<strong>编译时结合</strong>是<strong>静态绑定</strong></p>
<p>@@ 汇编程序的功能是将用<strong>汇编语言</strong>写的源程序翻译成机器指令程序。汇编程序的基本工作包括将一条可执行汇编语句转换成对应的机器指令；处理源程序中出现的伪指令。由于汇编指令中形成操作数指令的部分可能出现后面才会定义的符号，所以汇编程序一般需要两次扫描源程序才能完成翻译过程</p>
<p>@@ 对高级语言源程序进行编译或解释处理的过程中，需要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入<strong>符号表</strong> [这些信息一般以表格形式存储于系统中]</p>
<p>@@ 将高级语言源程序翻译称目标程序的是<strong>编译程序</strong></p>
<p>@@ 将高级语言源程序翻译为可在计算机上执行的形式有多种不同的方式，其中<strong>编译方式生成逻辑上与源程序等价的目标程序，解释方式不生成</strong>[为源程序中变量所分配的存储单元的地址属于<strong>逻辑地址</strong>]<br>编译语言是一种以编译器来实现的编程语言，它不像直译语言一样，由解释器将代码一句一句运行，而是以编译器，先将代码编译为机器码，再加以运行。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称为编译程序</p>
<p>@@ 将高级语言源程序通过编译或解释方式进行翻译时，可以先生成与源程序等价的某种中间代码。<strong>后缀式和三地址码是常用的中间代码</strong>。[不同高级程序语言可以产生同一种中间代码]<br><strong>中间代码</strong>的作用是<u>可使程序的结构再逻辑上更为简单明确</u>(<strong>有利于进行与机器无关的优化处理，优化一般建立在对程序的控制流和数据流分析的基础之上, 与机器无关</strong>)，特别是可以使目标代码的优化比较容易实现。中间代码由很多形式，常见的由**<u>逆波兰记号(后缀式)、四元式、三元式(三地址码)、语法树</u><strong>，它们的共同特点是与具体的机器无关，不依赖于具体的计算机。</strong>中间代码**是源程序的一种内部表示，称中间语言。<u>中间代码不依赖于具体的机器、使用中间代码可提高编译程序的可移植性、中间代码可以用树或图表示</u></p>
<p>@@ 编译程序不参加与用户程序的运行控制，而解释程序则参与。编译程序(编译器)则是将源程序翻译成目标语言程序，然后再计算机上运行目的程序。再解释方式下。翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p>
<p>@@ 编译和解释是实现高级程序设计语言翻译的两种基本形式，<u><strong>在编译方式下，必须进行词法、语法和语义分析，然后再产生源程序的目标代码</strong></u></p>
<p>@@ 对高级语言源程序进行编译的过程可分为多个阶段，分配寄存器的工作再<strong>目标代码生成</strong>阶段进行。[<strong>目标代码生成</strong>是编译器工作的最后一个阶段，这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、了重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关，因此在目标代码生成阶段分配寄存器。]</p>
<p>@@ 汇编程序输入的是用汇编语法书写的源程序，输出的是用机器语言表示的目标程序[<u>汇编语言源程序中的指令语句将被翻译成机器代码</u>、<u>汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</u>、<u>汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</u>]</p>
<p>@@ 编译过程中，对高级语言程序语句的翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需要的信息正确地填入合理组织的<strong>符号表</strong>中；对可执行语句，则是<strong>翻译成中间代码或目标代码</strong></p>
<p>@@ <strong>编译</strong>和<strong>解释</strong>是语言处理的两种基本方式：<br><strong>编译过程</strong>包括(词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等阶段)，以及**<u>符号表管理</u><strong>和</strong><u>出错处理模块</u>**<br><strong>解释过程</strong>在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行<strong>源程序或源程序的内部形式</strong><br>这两种语言处理程序的根本区别：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需要将源程序翻译成独立的目标程序</p>
<p>@@ <strong>移进—归约</strong>分析法是编译程序(解释程序)对高级语言源程序进行语法分析的一种方法，属于<strong>自下而上</strong>的语法分析方法<br><strong>递归下降分析法、预测分析法</strong> → 是<u><strong>自上而下</strong></u>分析法<br><strong>移进-归约分析法</strong> → 是**<u>自下而上</u>**分析法</p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong><br>编译是将高级语言源程序翻译成机器语言程序，<u>反编译是编译的逆过程</u>，<u><strong>反编译</strong>通常不能把可执行文件还原成高级语言源程序，只能转换成功能上等价的汇编程序</u></p>
<p>@@ 对于表达式<code>a or ((c&lt;d) and b)</code>，当<strong>a为true</strong>时可进行<strong>短路计算</strong>，最后计算的是or，对 <strong>或运算</strong> ，只要有一个真则结果为真，此题当a为true时，可进行短路计算，直接得到后面的结果</p>
<p>@@ 文法分为4种类型，程序设计语言的大多数语法现象可用<strong>乔姆斯基</strong>的<strong>上下文无关文法</strong>描述</p>
<p>@@ 在仅由字符a、b构成的所有字符串种，其中<u>以b结尾的<strong>字符串集合</strong></u>可用正则表达式为<br>$(b|ab)^<em>b$表示的<strong>字符串集合</strong>为<code>&#123;b,bb,abb,bbb,abab,bbbb,abbb,babb,...&#125;</code><u>除了以b结尾, 还要求每个a后面至少有1个b</u> 不符合题意只要有b结尾的！！<br>$(a|b)^</em>b$ 表示的<strong>字符串集合</strong><code>&#123;b,ab,bb,aab,abb,bab,bbb,aaab,aabb,abab,abbb,baab,babb,bbab,...&#125;</code></p>
<p>@@ 表达式采用逆波兰式表示时，利用<strong>栈</strong>进行求值<br>后缀式(逆波兰式)表达方式把运算符写在运算对象后面，**把a+b写成ab+**，所以也称为后缀式。借助栈可以方便地对后缀式进行求职。</p>
<p>@@ 与算术表达式**(a+(b-c))*d**对应的树是  求值运算处理顺序是：先进行b-c，然后与a相加，最后再与d相乘[中序遍历二叉树即可得出]</p>
<p>@@ 算数表达式**(a-b)<em>(c+d)<strong>的后缀式是</strong>ab-cd+**</em>  后缀式(逆波兰式)</p>
<p>@@ 算术表达式<em>*a+(b-C)*d**的后缀式是</em><em>abc-d</em>+** 利用逆波兰式，但是要把得到的步骤式子当成整体<br>原式&#x3D;<code>a+bC-*d</code> &#x3D;<code>a+bC-d*</code>&#x3D;<code>abC-d*+</code>  其中的着重点在于把bC-变成一个整体<strong>bC- * d</strong>再用逆波兰式 <strong>bC-d</strong>*<br>算术表达式**(a-b)<em>c+d<strong>的后缀式是</strong>ab-c</em>d+**</p>
<p>@@ 逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code> 的后缀式是**<code>ab^cbx0&gt;v^v</code>**<br>此题有大坑   <code>^是&quot;与&quot;门的意思、v是异&quot;或&quot;门的意思</code>；<br><u>逻辑与运算</u>的优先级高于<u>逻辑或运算</u><br>“<strong>逻辑与运算</strong>“ 表达式 “<code>x^y</code>“的短路求值逻辑是：若x为假，则可知”<code>x^y</code>“的值为假，无需再对y求值。因此只有在x为真时继续对y求值<br>“<strong>逻辑或运算</strong>“ 表达式 “<code>xvy</code>“的短路求值逻辑是：若x为真，则可知”<code>xvy</code>“的值为真，无需再对y求值。因此只有在x为假时继续对y求值<br>对于逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code>，从运算符的优先级方面考虑需先对”<code>a^b</code>“求值。然后对”<code>c^(b^x&gt;0)</code>“求值，最后进行对<code>&quot;v&quot;</code>运算，因此后缀式是**<code>ab^cbx0&gt;v^v</code>**</p>
<p>@@ 递归下降分析方法是一种<strong>自上而下的语法分析</strong><br>程序式设计语言的绝大多数语法规则可以采用<strong>上下文无关文法</strong>进行描述。语法分析方法有多种，根据产生语法树的方向，可分为<u><span style = "color:red"><strong>自底向上</strong></span>[算符优先分析法、LR分析法]</u>     <u><strong><span style = "color:red">自顶向下</span></strong>[递归下降分析法、预测分析法]</u>两类。</p>
<p>@@ 对于大多数通用程序设计语言，用<strong>上下文无关文法</strong>描述其语法即可<br>文法分成四种类型：0型、1型、2型、3型。<br><strong>0型文法</strong>也称为短语文法，其能力相当于图灵机，任何0型语言都是递归可枚举的；反之，递归可枚举集也必定是一个0型语言<br><strong>1型文法</strong>也称为上下文有关文法，这种文法意味着对非终结符的替换必须考虑上下文<br><strong>2型文法</strong>也称为上下文无关文法，非终结符的替换无需考虑上下文【通用程序设计语言绝大多数使用上下文无关文法(此文法拥有足够强的表达能力来表示大多数程序设计语言的语法)】<br><strong>3型文法</strong>等价于正规式，因此也被称为正规文法或线性文法。</p>
<p>@@ 在c&#x2F;c++程序种，整型变量a的值为0且应用在表达式”c&#x3D;b&#x2F;a”种，则最可能发生的情形是<strong>运行时产生异常</strong><br>c&#x3D;b&#x2F;a符合c&#x2F;c++语言的语法逻辑，编译时不会报错，运行时，代入a的值，发生错误</p>
<p>@@ 对高级语言源程序进行编译过程中，有限自动机(NFA或DFA)是进行<strong>词法分析</strong>的适当工具<br>词法分析的任务是把构成源程序的字符串转换成单词符号序列。有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：<strong>确定的有限自动机(DFA)<strong>和</strong>不确定的有限自动机(NFA)</strong></p>
<p>@@ L&#x3D;{$a^n$$b^n$|n&gt;&#x3D;1}<strong>不能用正规式表示，也不能通过有限自动机识别</strong>[此字符串的特点是a的个数与b的个数相同，且所有的a都在b之前]，因为该集合不是正规集，不能用正规式表示。而语言**L&#x3D;{$a^m$$b^n$|m≥0, n≥1}**的正规式表达式式<code>a*bb*</code>  因为在此集合中表示，若干个a之后跟若干个b，a可以不出现，b至少出现1次。</p>
<p>@@ 包含8个成员的开发小组的沟通路径最多有<strong>28</strong>条 [任意小组成员之间均可能有沟通路径，则可用完全连通图来对开发小组的沟通路径建模，最多的沟通路径为<strong>完全连通图的边数</strong>，即n个成员的开发小组的沟通路径是<strong>n(n-1)&#x2F;2</strong>，因此8个成员的开发小组沟通路径最多有28条]</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/cbacb3bb4e0bb351d573b25f7a61a12cfdcddc4a/data/%E7%A1%AE%E5%AE%9E_%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A9%E6%9C%BA.png" style="zoom: 67%;" />

<p>@@ 一个文法的语言是从文法能产生的句子的集合。<u><strong>一个文法产生的句子是从文法开始符号发出推导出的所有终结符号串</strong></u></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>@@ 从减少成本和缩短研发周期考虑，要求<strong>嵌入式操作系统</strong>能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置。该要求体现了嵌入式操作系统的<strong>可定制性</strong><br><strong>嵌入式操作系统的特点：</strong><br>① <strong>微型化：</strong>从性能和成本角度考虑，希望占用的资源和系统代码量少<br>② <strong>可定制：</strong>从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置，以满足不同应用的需求<br>③ <strong>实时性：</strong>嵌入式操作性系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高<br>④ <strong>可靠性：</strong>系统构建、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施<br>⑤ <strong>可移植性：</strong>为了提高系统的易移植性，通常采用<strong>硬件抽象层</strong>和<strong>板级支撑包</strong>的底层设计技术</p>
<p>@@ 在Linux中，要更改一个文件的权限设置可使用<strong>chmod</strong>命令，修改文件夹名可使用<strong>modify</strong>命令<br>Linux中只有一个根目录，用”&#x2F;“表示</p>
<p>@@ 计算机系统由<strong>硬件</strong>和<strong>软件</strong>两部分组成，通常把未配置软件的计算机称为裸机。操作系统目的是为了填充人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是使用操作系统所提供的命令和服务去操纵计算机，操作系统已称为现代计算机系统中必不可少的最重要的系统软件，因此<strong>操作系统</strong>是<strong>用户</strong>与<strong>计算机之间</strong>的<u>接口</u><br><img src="https://raw.githubusercontent.com/P-luminary/images/9f871f12e0e525d3f04ed912fcaa537b19f5203a/data/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D.jpg" style="zoom:50%;" /></p>
<p>@@ 实时操作系统主要用于<strong>实时要求的过程控制</strong>等领域，实时系统对于来自外部的事件必须在<strong>被操控对象规定的事件内做出及时响应并对其进行处理</strong>。<br><strong>实时操作系统</strong>与<strong>分时操作系统</strong>的第一点区别就是：<br>① 交互性强弱不同，<u>分时系统</u>交互型强，<u>实时系统</u>交互型弱，但可靠性要求高<br>② 响应事件的敏感性强，对随机发生的外部事件必须在被控制对象规定的时间做出及时响应并对其进行处理<br>③ 系统的设计目的不同，<u>分时系统</u>是设计称一个多用方的通用系统，交互能力强；而<u>实时系统</u>大多数都是专用系统。</p>
<p>@@ <strong>嵌入式系统初始化</strong>过程分为3个主要环节，按照<u>自底向上</u>，<u>从硬件到软件</u>的次序依次为：<u><strong>片级初始化</strong>、<strong>板级初始化</strong>、<strong>系统级初始化</strong></u>。系统初始化主要任务是<strong>以软件初始化为主，主要进行操作系统的初始化</strong><br><strong>片级初始化：</strong><u>片级初始化完成嵌入式微处理器的初始化</u>，包括设置嵌入式微处理器的核心寄存器和控制寄存器、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。片级初始化把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个纯硬件的初始化过程。<br><strong>板级初始化：</strong><u>板级初始化完成嵌入式微处理器以外的其他硬件设备的初始化</u>。另外，还需设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。这是一个同时包含软硬件两部分在内的初始化过程。<br><strong>系统初始化：</strong><u>系统初始化过程以软件初始化为主，主要进行操作系统的初始化</u>。BSP将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创建应用程序环境，并将控制权交给应用程序的入口。</p>
<p>@@ 设计操作系统时不需要考虑的问题是<strong>语言编译器的设计实现</strong><br>操作系统有两个重要作用：<br>① 通过资源管理提高计算机系统的效率，<strong>操作系统</strong>是计算机的资源管理者，它含有对系统软&#x2F;硬件资源实施管理的一组程序<br>② 改善人机界面，向用户提供有好的工作环境</p>
<p>@@ <strong>磁盘格式化</strong>是指把一张空白的盘划分称一个个小区域并编号，以供计算机存储和读取数据，格式化是一种纯物理操作，实在磁盘的所有数据区上写0的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以有在硬盘介质产生错误时才需要进行格式化。<br><strong>磁盘分区</strong>是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。<br>磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连 续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些 空着的磁盘空间，就被称作”磁盘碎片”。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。磁盘清理将删除计算机上所有不需要的文件（这些文件由用户或系统进行确认）。<br><strong>磁盘碎片整理</strong>就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<p>@@ 在WinXP操作系统中，用户利用”<strong>磁盘管理</strong>“程序可以对磁盘进行初始化、创建卷，<strong>可以选择使用FAT、FAT32或NTFS文件系统格式化券</strong>，通常将<code>&quot;C:\Windows\myprogram.exe&quot;</code>文件设置成<strong>只读</strong>和<strong>隐藏</strong>属性，以便控制用户对该文件的访问。这一级安全管理称之为<strong>文件级</strong>安全管理。<br>文件级安全管理是通过系统管理员或文件组对文件设置来控制用户对文件的访问。用户对文件的访问，将由用户<strong>访问权、目录访问权、文件属性</strong>三者的权限所确定。</p>
<p>@@ 假设磁盘臂位于15号柱面上，进程的请求序列如下表表示，如果采用<strong>最短移臂调度算法</strong>，那么系统的响应序列应为<strong>⑤①②④③⑥</strong></p>
<table>
<thead>
<tr>
<th>请求序列</th>
<th>柱面号</th>
<th>磁头号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td>12</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>②</td>
<td>19</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>③</td>
<td>23</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>④</td>
<td>19</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>⑤</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>⑥</td>
<td>28</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p><strong>最短移臂调度算法</strong>，即有限响应距离比较近磁道的申请<br>1.当磁头位于15号柱面 (柱面号即磁道编号)，请求序列分别位于12号柱面(①⑤)、19号柱面(②④)、23号柱面(③)、28号柱面(⑥)<br>2.距离15号柱面最近的应该是12号柱面(①⑤)，优先响应(①⑤)，次序不限；</p>
<p>@@ P(Pass)(通过)消耗一个信号量  V(释放)发送一个信号量<br>V(S1)唤醒P(S1)：<strong>收银员进程操作</strong>只有等待着<strong>购书者</strong>拿出去前台后才能触发</p>
<p>@@ PV操作是操作系统提供的具有特定功能的原语，利用PV操作可以<strong>实现资源的互斥使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">软考必考题型之PV操作_pv操作中p和v各代表什么-CSDN博客</a></p>
<p>@@ 某计算机系统中互斥资源R的可用数为8，系统中有3个进程P1、P2和P3竞争R，且每个进程都需要i个R，该系统可能会发生死锁的最小i值为：<strong>4</strong><br>本题对于R资源可用数为8，分配到3个进程中，为了让最后的i值最小，所以每个进程尽量平均分配，可以得到3、3、2的分配情况，此时如果假设i的取值为3，则必定不会发生死锁，当i&gt;3时系统会产生死锁，此时取整，即最小i值为4</p>
<p>@@ 常用的进程控制块的组织方式有<strong>链接方式</strong>和<strong>索引方式</strong>：<br>采用<span style ="color:red"><strong><u>链接方式</u></strong></span>是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样可以形成<strong>就绪队列</strong>、若干个<strong>阻塞队列</strong>和<strong>空白队列</strong>等。其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O操作完成的队列和等待分配内存的队列等。<br>采用<span style ="color:red"><strong><u>索引方式</u></strong></span>是系统根据所有进程的状态<u><strong>建立若干索引表</strong></u>。例如，<strong>就绪索引表、阻塞索引表</strong>，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。<br><img src="https://raw.githubusercontent.com/P-luminary/images/dddb1b1a79e0de02dd213d846e7b7c8045a9dc70/data/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97.jpg"  /></p>
<p>@@ 某系统中有3个并发进程竞争资源R，每个进程都需要5个R，那么至少有<u><strong>13</strong>个R</u>，才能保证系统不会发生死锁。[<u>每个进程所需资源数-1，再相加，就是发生死锁的临界资源数</u>]<br><code>3(5-1)+1&lt;=y</code> 所以y＝13个</p>
<pre><code class="java">某系统有n个进程，每个进程需要x个同类资源，系统不会产生死锁的最少资源是多少？
★ 设：最少资源数位y个，满足如下表达式即可：★
n(x-1)+1&lt;=y
每个进程需要x个资源，初始时給每个进程x-1个资源，最后再給一个格外的资源，每当一个进程运行完后马上释放其占有的资源，其它进程可以申请资源继续运行
</code></pre>
<p>@@ 某系统中仅有5个并发进程竞争某类资源，且都需要3个该类资源，那么至少有<strong>11</strong>个该类资源，才能保证系统不会发生死锁。5×(3-1)+1&#x3D;11</p>
<p>@@ 某计算机系统页面大小为4k，进程的页面变换表如下。若进程的逻辑地址为2D16H。该地址经过变换后，其物理地址应为<strong>4D16H</strong></p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">物理块号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>根据题意，页面大小为4k，逻辑地址2D16H所在<strong>页号为2</strong>，页内地址为D16H，查看表后可知<strong>物理块号为4</strong>，该地址i过变换后，其物理地址应为物理块号4拼接上页内地址D16H，即十六进制4D16H</p>
<p>@@ <em>让我们来看一下这道13年上半年的软设选择题：</em><span style = "color:red"> <strong>图(a)中<u>B</u>；</strong></span><br><img src="https://raw.githubusercontent.com/P-luminary/images/be02605405d236b87be94947a28e00f477fd4bdf/data/%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9.jpg"></p>
<p><span style = "color:red"><strong>图(b)中<u>C</u></strong></span><br>A. P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的<br>B. P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的<br><span style = "color:red">C. P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的</span><br>D. P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的</p>
<pre><code class="java">★ 如何看进程资源图呢？
P:进程    R:一类资源     R中的圆圈数：该类资源有几个
★ 字母箭头都是啥意思？
R→P(R指向P)：分配一份R类资源給进程P
P→R(P指向R)：进程P申请一份R类资源
★ 判断一个进程节点是否堵塞？
读图时，先看资源分配R→P，再看资源申请P→R
【注意】
读图时，不要将同时存在R→P、P→R双向箭头的情况理解成：
P先申请一个资源，R再分配一个资源给P！

可能存在的情况：
① R中所有资源分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为阻塞节点
② R中所有资源没有全部都分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为非阻塞节点

★ 判断一个进程资源图是否是死锁的？
如果所有节点都是阻塞的———此进程图不可以化简，是死锁的
如果有节点不是阻塞的————此进程图可以花间，是非死锁的
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
</code></pre>
<h6 id="图a"><a href="#图a" class="headerlink" title="图a"></a>图a</h6><pre><code class="java">R1一共有2个资源，给P1、P2各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

同理，R2一共有3个资源，给P1分配1个、P2分配2个，已经无可分配资源
此时P1还向R2申请1个资源，因为没有资源可以申请了，所以P1也会阻塞；

因为P1、P2节点都阻塞了，所以此图无法化简，是死锁的
</code></pre>
<h6 id="图b"><a href="#图b" class="headerlink" title="图b"></a>图b</h6><pre><code class="java">R1一共有2个资源，给P1、P3各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

R2一共有3个资源，给P2、P3各分配一个，还剩1个可分配资源
此时P1向R2申请1个资源，因为还有可分配资源，所以P1不会阻塞；
（此时P3也向R2申请1个资源，同理P3也不会阻塞）
【这里要特别注意：P1、P3虽然同时都在申请剩下的1个资源，但是并不意味着这个资源申请已经被响应了，从而造成死锁的现象】
--------------------------------------------------------------------------
R1出去两个资源，R1资源数为0，此时P2申请R1资源，P2阻塞。R2总资源数3，出去2个资源。P1,P3申请R2资源，P1,P3非阻塞。[R2资源有3个，已分配2个，P3申请1个R2资源可以得到满足，故进程P3可以进行完毕释放其占有的资源。这样可以使得P1、P3都变成非阻塞节点，得到所需资源进行完毕，因此，该进程资源图是可以化简的]
</code></pre>
<p>@@ 在支持多线程的操作系统中，假设进程P创建了若干个线程，那么<strong>该进程中某线程的栈指针</strong>是不能被这些线程共享的。<u>在同一进程中的各个线程都可以共享进程所拥有的资源</u>，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是<u>不能共享进程中某线程的栈指针</u> </p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥。若n个进程<strong>共享两台打印机</strong>，那么信号量S的取值范围为 <strong>-(n-2) ~ 2</strong>。信号量初值等于资源数量，即为2，由于同时最多有2个进程访问打印机，其余进程必须处理等待状态，故S的最小值为 <strong>-(n-2)</strong> </p>
<pre><code class="java">·每个进程开始的时候执行P操作(信号量减一操作)，结束的时候执行V操作(信号量加一操作)。P作挂起阻塞，V为激活唤醒。信号量的原则是从左到右，从上到下。
·假设系统采用PV操作实现进程同步与互斥，若n个进程共享两台打印机，那么信号量S的取值范围为-(n-2)~2。两台打印机，所以最多等待状态的进程数就是(n-2)，
★★如果没有进程申请打印机，打印机的信号量就是2★★
信号量的值小于0，表示没有可用的资源，其绝对值表示阻塞队列中等待该资源的进程数。

·同步信号量，值为可用资源的个数。信号量的值小于0，则线程进行等待；信号量的值大于0，表示值为可用资源的个数。初始值为0。
·互斥信号量，只有两个值：0和1。0表示资源被占用，线程等待；1表示资源没有被占用，线程可以进入。初始值为1。
</code></pre>
<p>@@ 假设系统中有n个进程<strong>共享3台扫描仪</strong>，并采用PV操作实现进程同步与互斥。若系统信号量S的当前值为-1，**<u>进程P1、P2又分别执行了一次P(S)操作</u><strong>，那么信号量S的值应为___。<br>[<strong>当有进程运行时</strong>,其他进程访问信号量,信号量就会减1。S&#x3D;-1-2]<br>[当进程执行P(S)操作时，它试图将信号量S的值减去1。因此，如果</strong><u>进程P1和P2都执行了一次P(S)操作</u>**，并且信号量S的初始值为-1，那么它们会尝试将S的值减去1两次，结果是S的值变为-3。这是因为当信号量S的值为-1时，两个进程都尝试将其减去1，每次减去1后，S的值分别变为-2和-3。所以最终S的值为-3]</p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享一台扫描仪，那么当信号量S的值为-3时，表示系统中有<strong>3</strong>个进程等待使用扫描仪<br>[信号量不用减1是因为<strong>本题并没有进程运行</strong>]</p>
<p>@@ 假设某分时系统采用简单时间片轮转法，当系统中的用户数为n、时间片为q时，系统对每个用户的相应时间T&#x3D;(n*q) [<u>在分时系统中是将把CPU的时间分成很短的时间片轮流地分配給各个终端用户</u>]</p>
<p>@@ 如果系统采用信箱通信方式，当进程调用Send原语被设置为”等信箱”状态时，其原因是<strong>指定的信箱中存满了信件</strong>；因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成”<strong>等信箱</strong>“状态时，意味着指定的信箱存满了信件，无可用空间</p>
<p>@@ <span style = "color:red"><strong>绝对路径</strong>从根目录\开始</span>，本题book2.doc的绝对路径为 <code>\MyDrivers\user2\</code><br><span style = "color:blue"><strong>相对路径</strong>从当前目录下一级开始</span>，本题book2.doc的相对路径为 <code>user2\</code></p>
<p>@@ 直接索引即索引直接指向物理块，可用表示逻辑块号范围：0-4号<br>一级索引即索引节点指向的物理块用来存放地址项，可用表示256个地址项，即256个物理块<br>二级索引即索引节点指向的物理块，存放的是一级索引的地址块地址。一共有256个地址块用来存放以及索引</p>
<p>@@ 某文件系统采用多级索引结构。若磁盘块的大小为1k字节，每个块号占3字节，那么采用二级索引时的文件最大长度为<strong>116281</strong>k字节 。<br>磁盘块的大小为1KB，每个块号需占3B，因此一个磁盘物理块可存放1024&#x2F;3&#x3D;341个块号(取整)<br>采用一级索引时的文件最大长度为：341×1024&#x2F;1024&#x3D;341KB<br>采用二级索引时的文件最大长度为：341×341×1024&#x2F;1024&#x3D;116281KB</p>
<p>@@ 若系统正在将<strong>系统目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。<br>影响文件系统可靠性因素之一是文件系统的一致性问题。<u>很多文件系统是先<strong>读取磁盘块到主存</strong>，在主存进行修改，修改完毕再写回磁盘。</u> <strong>一致性检查</strong>包括 <u>块的一致性检查</u> 和 <u>文件的一致性检查</u></p>
<p>@@ 双击”xxx.jpg”文件名时，系统会自动通过建立的<strong>文件关联</strong>来决定使用什么程序打开该图像文件</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>@@ 若系统正在将<strong>目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。</p>
<p>@@ 若某计算机系统的I&#x2F;O接口与主存采用统一编址，则输入输出操作是通过<strong>访存</strong>指令来完成的。<br>常用的I&#x2F;O接口编制方法有两种：<br>一是<strong>内存单元统一编址</strong>[将I&#x2F;O接口中有关的寄存器或存储部件看作存储器单元，与主存中的存储单元统一编址。内存地址和接口地址统一在一个公共的地址空间里，<u>对I&#x2F;O接口的访问就如同对主存单元的访问一样，可以用访问内存单元的指令访问I&#x2F;O接口</u>]<br>二是<strong>单独编址</strong>[通过设置单独的I&#x2F;O地址空间，为接口中的有关寄存器或存储部件分配地址码，需要设置专门的I&#x2F;O指令进行访问。这种编址方式的优点是不占用主存的地址空间，访问主存的指令和访问接口的指令不同。]</p>
<p>@@ I&#x2F;O设备管理软件一般分为4个层次。具体层次从上往下分别是**<u>用户级I&#x2F;O层、设备无关I&#x2F;O层、设备驱动程序、中断处理程序、硬件</u>** [用户五官射中硬件]</p>
<table>
<thead>
<tr>
<th>用户级I&#x2F;O层：发出I&#x2F;O调用</th>
</tr>
</thead>
<tbody><tr>
<td>设备无关I&#x2F;O层：设备名解析、阻塞进程、分配缓冲区</td>
</tr>
<tr>
<td>设备驱动程序：设置寄存器、检查设备状态</td>
</tr>
<tr>
<td>中断处理程序：I&#x2F;O完成后唤醒设备驱动程序</td>
</tr>
<tr>
<td>硬件：完成具体的I&#x2F;O操作</td>
</tr>
</tbody></table>
<p>@@ DMA工作方式下，在<strong>主存与外设</strong>之间建立了直接的数据链路</p>
<p>@@ 计算机运行过程中，cpu需要与外设进行数据交换。采用**<u>中断方式和DMA方式</u><strong>控制技术时，CPU与外设可并行工作。</strong>程序查询<strong>和</strong>中断方式<strong>都需要CPU来执行程序指令进行数据的输入和输出，DMA方式则不同，这是<u>一种不经过CPU而</strong>直接从内存存取数据**的数据交换模式</u>。[DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传达，数据传达完毕再把信息反馈给CPU即可]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ab1d3a552633777cd974d25748160cc91ad68a5/data/%E7%A3%81%E7%9B%98CT%E9%A2%98.jpg"></p>
<p>@@ 某磁盘有100个磁道，磁头从一个磁道移至另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和20ms，则读取一个100块的文件需要<strong>18000</strong>ms。[访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间之和。根据题意，每块的旋转延迟时间及传输时间共需120ms，磁头从一个磁道移至另一个磁道需要6ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要60ms。通过上述分析，本题访问一个数据块的时间T&#x3D;120ms+60ms&#x3D;180ms，而读取一个100块的文件共需要18000ms。]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5957207201dabc57750a4659ee50c53b8017761/data/%E7%A3%81%E7%9B%98%E8%87%82%E8%86%80%E5%93%8D%E5%BA%94%E5%BA%8F%E5%88%97%E9%A2%98.png"></p>
<p>@@ 假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0,RI,…,R8存放在同一个磁道上，记录的安排顺序如下表所示：如果磁盘的旋转速度为27ms／周，磁头当前处在RO的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为<strong>246ms</strong>：若对信息存储进行优化分布后，处理9个记录的最少时间为<strong>54ms</strong> 。</p>
<table>
<thead>
<tr>
<th align="center">物理块</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑记录</td>
<td align="center">R0</td>
<td align="center">R1</td>
<td align="center">R2</td>
<td align="center">R3</td>
<td align="center">R4</td>
<td align="center">R5</td>
<td align="center">R6</td>
<td align="center">R7</td>
<td align="center">R8</td>
</tr>
</tbody></table>
<p>[因为系统使用的是单缓冲区，且顺序处理9个记录，每个记录处理时间为3ms，加上读写时间，总的时间就超过3ms了。而磁盘旋转一圈的时间为27ms，也就是说，当系统读取第0个记录后，正在处理的过程中，磁盘已经旋过了第1个记录。那么，要读取第1个记录，就需要磁盘再次旋转到第1个记录（即磁盘旋转1圈后，27+3&#x3D;30ms)。同理，要读取第2个记录时，也需要等30ms。这样，要读取后面8个记录，需要8x30&#x3D;240ms，同时加上处理第0个记录的时间（3ms）和处理第8个记录的时间（3ms)，共需246ms。] [对于第二种情况，若对信息进行分布优化的结果如下所示：从上表可以看出，当读出记录RI并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为：<u>9X (3ms （读记录）+3ms （处理记录）)&#x3D;9X6ms&#x3D;54ms</u>]</p>
<p>@@ 在移臂调度算法中，<strong>先来先服务和最短寻找时间优先</strong>算法可能会随时改变移动臂的运动方向</p>
<p>@@ 概要设计文档的内容包括<strong>系统构架、模块划分、系统接口、数据设计</strong>四个方面</p>
<p>@@ 三层C&#x2F;S体系结构由逻辑上互相分离的**<u>表示层、业务层、数据层</u><strong>构成。其中</strong>表示层<strong>向客户提供数据，</strong>业务层<strong>实施业务相关数据规划，</strong>数据层**定义数据访问表中。</p>
<p>@@ 对软件过程的考虑：<u>在整体上按照<strong>瀑布模型</strong>的流程实施项目开发</u>，以方便对项目的管理；但在软件的实际创建中，则将软件系统按照功能分为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。</p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">详情信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>增量</strong>模型</td>
<td align="left">又称渐增模型，也称为有计划的产品改进模型，从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，直到系统完成。每个中间版本都需要执行必需的过程、活动和任务。增量模型是 [<u>瀑布模型+原型</u>] 进化模型的综合<br />[增量模型具有非常显著的优越性，但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成；<strong>不必等到整个系统开发完成就可以使用</strong>、<strong>可以使用较早的增量构件作为原型</strong>、<strong>优先级最高的服务先交付</strong>, 这样<u>最重要的服务接收最多的测试</u>。<span style = "color:red">其<strong>难点</strong>是<u>如何进行模块的划分</u></span>。]<br />融合了瀑布模型的基本成分和原型实现迭代的特征，该模型随着日程时间的进展而交错的线性序列。<br />增量式开发的<strong>主要优点包括</strong>：<br/>1．由于能够在较短的时间内向用户提交一些有用的工作产品，因此能够解决用户的一些急用功能。<br/>2．由于每次只提交用户部分功能，用户有较充分的时间学习和适应新的产品。<br/>3．对系统的可维护性是一个极大的提高，因为整个系统是由一个个构件集成在一起的，当需求变更时只变更部分部件，而不必影响整个系统。<br/><strong>主要缺点包括</strong>：<br/>1．由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。<br/>2．在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。<br/>3．增量包之间存在相交的情况且未很好处理</td>
</tr>
<tr>
<td align="left"><strong>瀑布</strong>模型</td>
<td align="left">将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。将软件生存周期各个活动规定为线性顺序链接的若干阶段的模型[<u>计划、分析、设计、编程、测试、维护</u>]。规定了由前至后，相互衔接的固定次序，如同瀑布流水，逐级下落。是一种理想的开发模式，但<span style = "color:red"><u><strong>缺乏</strong>灵活性，无法解决软件需求不明确或不准确的问题；不适用于开发初期对软件需求缺乏准确全面认识的情况</u></span>；<span style = "color:blue"><strong>优点</strong>：可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的审核。</span></td>
</tr>
<tr>
<td align="left"><strong>原型</strong>模式</td>
<td align="left">开发人员<u>快速地构造整个系统</u>或者<u>系统的一部分以理解或澄清问题</u>。增量模型是把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块组成，并且能够完成特定的功能；并非所有的需求在系统开发之前都能准确地说明和定义。<span style = "color:blue">采用了动态定义需求的方法。适用于需求不明确的开发环境</span>；可以有效地捕获系统需求</td>
</tr>
<tr>
<td align="left"><strong>喷泉</strong>模型</td>
<td align="left">喷泉模型是典型的面向对象生命周期模型，在开发过程中<strong>以用户需求为动力</strong>，以对象为驱动，适合于面向对象的开发方法；<span style = "color:blue">喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性；模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统</span>；”喷泉”一词本身体现了迭代和无间隙特性。<strong>迭代意味着模型中的开发活动常常需要重复多次</strong>，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。</td>
</tr>
<tr>
<td align="left"><strong>螺旋</strong>模型</td>
<td align="left">将开发活动和风险管理结合起来，以减小风险。将<u>瀑布模型</u>与<u>快速原型模型</u>结合起来，还增加了风险分析；螺旋模型包含了四个方面的活动：制订计划、风险分析、实施工程、客户评估，<span style = "color:blue">螺旋模型适用于<strong>复杂的大型软件</strong></span>；</td>
</tr>
</tbody></table>
<p>@@ 若用户<u>需求<strong>不清晰</strong></u>且经常发生变化，但<u>系统规模不太大且不太复杂</u>，则最适宜采用<strong>原型化</strong>开发方法<br>对于<u>数据处理领域不太复杂的软件，若系统规模不太大且不太复杂，需求变化也不大</u>，则最适宜采用<strong>结构化</strong>开发方法</p>
<p>@@ 软件工程的基本要素包括<strong>方法、工具、过程</strong></p>
<p>@@ 在<strong>概要</strong>设计阶段选择适当的解决方案，将系统分解为若干个子系统，建立整个系统的体系结构。<br>软件设计的任务是基于需求分析的结果建立各种设计模型，给出问题的解决方案。<br><strong>从工程管理的角度，可以将软件设计分为两个阶段：</strong><u>概要设计阶段</u>和<u>详细设计阶段</u>。<br><strong>概要设计阶段</strong>进行软件体系结构的设计、数据设计和接口设计；<br><strong>详细设计阶段</strong>进行数据结构和算法的设计。面向对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计&#x2F;数据设计、结构设计：详细设计阶段进行构件设计。结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序：面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p>
<p>@@ “软件产品必须能够在3秒内对用户请求作出响应”属于软件需求中的<strong>非功能需求</strong>。<br>软件需求是软件系统必须完成的事以及必须具备的品质。软件需求包括<strong>功能需求、非功能需求和设计约束</strong>三个方面的内容。功能需求是所开发的软件必须具备什么样的功能：非功能需求是指产品必须具备的属性或品质，如可靠性、性能、响应时间和扩展性等等；设计约束通常对解决方案的一些约束说明。”软件产品必须能够在3秒内对用户请求作出响应”主要表述软件的响应时间，属于非功能需求</p>
<p>@@ 软件复杂性度量是软件度量的一个重要分支。参数有很多主要包括：<br>①<strong>规模</strong>。即指令数或者源程序行数；②<strong>难度</strong>。通常由程序中出现的操作数所决定的量来表示；<br>③<strong>结构</strong>。通常用与程序结构有关的度量来表示；④<strong>智能度</strong>。即算法的难易程度</p>
<p>@@ 基于构件的软件开发，主要强调在构建软件系统时复用已有的软件”构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行<strong>合格性检验、适应性修改</strong>，然后集成到新系统中</p>
<p>@@ 程序的三种基本控制结构式<strong>顺序、选择和重复</strong></p>
<p>@@ 软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>容易修改、模块化和功能独立的目的</strong>出发，评价软件的结构和过程。可维护性式所有软件都具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。</p>
<p>@@ I&#x2F;O软件隐藏了I&#x2F;O操作实现的细节。I&#x2F;O软件向用户提供的式逻辑接口。I&#x2F;O软件将硬件与较高层次的软件隔离开来，而最高层软件向硬件提供一个友好的、清晰的、统一的接口，方便用户使用。</p>
<p>@@ 在面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是<strong>重构</strong>，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为</p>
<p>@@ 软件风险一般包含<strong>不确定性</strong>和<strong>损失</strong>。<strong>救火</strong>和<strong>危机管理</strong>是对不适合但经常采用的软件风险管理策略，<strong>已知风险</strong>和<strong>未知风险</strong>是对软件风险进行分类的一种方式。<strong>员工</strong>和<strong>预算</strong>是在识别项目风险时需要识别的因素</p>
<p>@@ 在传值方式下是将<strong>实参</strong>的值传递给形参，因此实参可以是表达式、常量、变量、数组元素，这种信息传递是单方向的，形参不能再将值传回给实参。在传地址方式下，需要将实参的地址传递给形参，因此实参必须是变量、数组名或数组元素。不能是表达式或常量。在这种方式下，被调用函数中对形式参数的修改实际上就是对实际参数的修改，客观上可以实现数据的双向传递。</p>
<p>@@ 编译是将高级语言源程序翻译成机器语言程序，反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。</p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等在结构上的变化等。动态语言的类型检查是在<strong>运行时进行的</strong>，其有点是方便阅读，不需要非常多的与类型相关的代码；缺点是不方便调试。<strong>脚本语言</strong>代表一套与系统程序设计语言不同的协定。更适合在联系复杂的应用程序中进行胶着(粘合)，一般都是面向字符的。脚本语言都是动态语言，而动态语言都是解释型语言</p>
<p>@@ WinXP支持<strong>FAT、FAT32、NTFS</strong>的文件系统格式化卷，而Win11默认仅提供<strong>NTFS</strong>格式 (ReFS主要面向企业级存储)</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>