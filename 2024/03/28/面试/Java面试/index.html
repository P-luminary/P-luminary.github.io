
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java面试</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java面试 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/3/28
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#00bcd4>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Java面试-——-准备"><a href="#Java面试-——-准备" class="headerlink" title="Java面试 —— 准备"></a>Java面试 —— 准备</h1><h3 id="給职场新人的建议"><a href="#給职场新人的建议" class="headerlink" title="給职场新人的建议"></a>給职场新人的建议</h3><ul>
<li>不要有为老板工作的心态</li>
<li>永远不要敷衍工作</li>
<li>事情做完马上汇报</li>
<li>管理好自己的情绪，做一个可爱的人</li>
<li>接受任务有确认机制</li>
<li>注意工作汇报方式</li>
<li>注重细节</li>
<li>提建议要有数据支撑</li>
<li>給主管选择题 而不是判断题 </li>
<li>要提升自己的价值 [人脉网]</li>
<li>认真对待工作汇报3</li>
</ul>
<h3 id="介绍面试环节中常见问题"><a href="#介绍面试环节中常见问题" class="headerlink" title="介绍面试环节中常见问题"></a>介绍面试环节中常见问题</h3><h5 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h5><ul>
<li><h6 id="我是誰"><a href="#我是誰" class="headerlink" title="我是誰"></a>我是誰</h6></li>
<li><h6 id="我做过什么"><a href="#我做过什么" class="headerlink" title="我做过什么"></a>我做过什么</h6></li>
<li><h6 id="我的优势在哪里"><a href="#我的优势在哪里" class="headerlink" title="我的优势在哪里"></a>我的优势在哪里</h6></li>
</ul>
<blockquote>
<p>张总你好，我叫潘春尧，<strong>今年23岁</strong>，来自河北唐山人，来<strong>应聘贵公司的Java软件工程师职位</strong>，26年毕业于南昌工学院<strong>软件工程专业</strong>，从事Java开发有2年的工作时间了，我<strong>对编程有着浓厚的兴趣</strong>，擅长基于HTML5的互联网应用开发，擅长使用Mysql数据库对大数据量方面的调优有经验，同时具备完整的项目开发能力，具备一定的分布式架构经验，之前<strong>我做过两个项目</strong>，都是独立完成的，<strong>第一个</strong>是XX 在2024年开发，这是一个电商网站，已经运用了一年的时间，我负责底层的架构搭建与前后端开发，技术方面采用了XXXX。架构方面底层使用了XXX，我负责的模块设计XXX，这些都是由我完整开发的，而<strong>第二个</strong>项目是由我开发的xxx，这是一个xxx平台，基于阿里云搭建，技术方面与上一个相似，工作原因产品需要增加XXX，我负责的网站模块主要负责xxx，这也是由我负责开发的，以上是我的个人介绍，有不足的请您多保函。</p>
</blockquote>
<h5 id="现场面对面-要面试官知道我有闪光的价值"><a href="#现场面对面-要面试官知道我有闪光的价值" class="headerlink" title="现场面对面  [要面试官知道我有闪光的价值]"></a>现场面对面  [要面试官知道我有闪光的价值]</h5><ul>
<li><strong>容貌要求</strong> [注意形象(<u>刮胡子,短发,指甲</u>)]</li>
<li><strong>着装要求</strong> [品牌+面料+皮鞋(商务休闲)]</li>
<li><strong>面试礼仪</strong> [提前15分钟到达面试场地填写表格、敬语(您好,感谢,再见)、善意的微笑] [和前台了解面试官的称呼和职位 主动握手 张总… ] [跟着面试官进去后 注意关门  进去前注意敲门] [沟通时眼神不要游离] [提交简历调转180°双手呈递] [不要抖腿翘腿] [手放腿上 十指交叉放桌子上 不许靠着椅子靠背]</li>
<li><strong>一对多面试</strong> [一男一女   <strong>男:</strong> 技术主管[考察技术能力]  <strong>女:</strong> HR[根据动作分析本人能力]] [面试紧张的时候要降低语速]</li>
</ul>
<h5 id="面试必知必会"><a href="#面试必知必会" class="headerlink" title="面试必知必会"></a>面试必知必会</h5><ul>
<li><h6 id="谈谈你的职业规划-对未来职业有清晰的规划"><a href="#谈谈你的职业规划-对未来职业有清晰的规划" class="headerlink" title="谈谈你的职业规划 [对未来职业有清晰的规划]"></a>谈谈你的职业规划 [对未来职业有清晰的规划]</h6></li>
</ul>
<blockquote>
<p>我从小对软件技术有着很浓厚的兴趣，在未来我五年内我希望从事于与技术相关的岗位，我给自己定位了一个小目标，在五年的时间内我希望拿下系统架构师的认证，同时在分布式、微服务的领域有自己独道的见识。希望在未来的一段时间里公司能给我提供成长的机会。</p>
</blockquote>
<ul>
<li><h6 id="与同时遇到正面冲突，你会怎么办"><a href="#与同时遇到正面冲突，你会怎么办" class="headerlink" title="与同时遇到正面冲突，你会怎么办"></a>与同时遇到正面冲突，你会怎么办</h6></li>
</ul>
<blockquote>
<p>[不诋毁任何人 不传达任何负面情绪 以大局为重]<br>我很少与别人产生正面的冲突，面对别人对我个人的职责批评，我通常先会反思我是不是真的做错了，如果是我会虚心接受，尽快改正。如果是别人对我无端的诽谤，在公共场合也会保持沉默，我会在私下跟他心平气和的沟通看看之间是不是有什么误会。如果是在工作中就某些问题产生了分歧。在会议时直接打开天窗说亮话，阐述自己的观点，这种是典型的对事不对人，这也是点到为止，如果双方意见僵持不下，这可能需要项目经理在中间做出定夺，他看到的问题可能比我们的更加全面而且更有建设性，总之我处事的原则是对事不对人，做事必须认真，做人还是要谦虚一些</p>
</blockquote>
<ul>
<li><h6 id="你生活中最重要的是什么"><a href="#你生活中最重要的是什么" class="headerlink" title="你生活中最重要的是什么"></a>你生活中最重要的是什么</h6></li>
</ul>
<blockquote>
<p>[考察你对待工作 生活 家庭是什么态度] [<strong>强调以事业为重</strong>]<br>我一个人来到XX打拼，目前是单身，对于我现在而言，事业就是我的全部，我会珍惜每一天，让自己尽快的成长起来</p>
</blockquote>
<ul>
<li><h6 id="这份工作你能遇见哪些问题"><a href="#这份工作你能遇见哪些问题" class="headerlink" title="这份工作你能遇见哪些问题"></a>这份工作你能遇见哪些问题</h6></li>
</ul>
<blockquote>
<p>[不能太过实在 避重就轻 强调自己的特性]<br>我对咱们公司的业务不太了解，经验很少，进入公司以后我会听取领导的指示和要求，尽快的熟悉公司的业务和技能，并且制定一份近期的工作计划并报告給领导批准，最后按照计划展开工作，其实针对这个问题，明眼人都看得出来，都说了一堆套话，废话，但是对于面试官来说，你正面的回答了这些问题。而这些问题肯定是现实中存在的，这样既无伤大雅又巧妙的表达了自己对这份工作的期望</p>
</blockquote>
<ul>
<li><h6 id="你希望与什么样的同事或上级公事"><a href="#你希望与什么样的同事或上级公事" class="headerlink" title="你希望与什么样的同事或上级公事"></a>你希望与什么样的同事或上级公事</h6></li>
</ul>
<blockquote>
<p>[考察情商]<br>作为刚步入社会的新人，我应该要求自己多熟悉工作环境适应环境，而不是对环境提出要求，对于我的工作只要能发挥我的专长就可以了，如果工作中有做的不对的地方还请领导多批评指正</p>
</blockquote>
<ul>
<li><h6 id="你将如何开展工作"><a href="#你将如何开展工作" class="headerlink" title="你将如何开展工作"></a>你将如何开展工作</h6></li>
</ul>
<blockquote>
<p>[面试通过几率已经很大了]<br>每天我会提高工作效率，完成公司交付的工作任务，任务未完成绝不下班，根据领导的指示和工作安排制定好工作计划，提前预备并按照计划完成，多请示领导及时汇报，如果有遇到不明白的地方要向前辈们请教，抓住缝隙时间多学习多提升，尽快的提高自己的专业能力与业务水平</p>
</blockquote>
<ul>
<li><h6 id="你有想过创业吗"><a href="#你有想过创业吗" class="headerlink" title="你有想过创业吗"></a>你有想过创业吗</h6></li>
</ul>
<blockquote>
<p>[面试官喜欢有冲劲的小伙子 给出明确的时间规划 不要说我是来公司学习的]<br>我当然有想过创业，但我觉得不是现在，我计划在30岁前后选择创业，软件行业需要大量的技术积累才能有竞争力，同时呢创业对我来说也需要很多的资金，我是一名刚走出校园的新人，在这两方面都不成熟，所以在未来的5年时间内，我会努力的工作，在经验和资金方面做好准备，同时之所以来贵公司，是因为贵公司在XXX行业是一个知名的企业，我想在为公司创造价值的同时，也能进一步的掌握咱们行业最新的动向，希望您能给我一次证明自己的机会，我肯定不会让公司失望的。</p>
</blockquote>
<ul>
<li><h6 id="你还应聘了哪些公司"><a href="#你还应聘了哪些公司" class="headerlink" title="你还应聘了哪些公司"></a>你还应聘了哪些公司</h6></li>
</ul>
<blockquote>
<p>[千万不能说海投 也不能说hr打了电话才来 最好不要跨行业]<br>做一些准备了</p>
</blockquote>
<ul>
<li><h6 id="为什么你的学历是专科"><a href="#为什么你的学历是专科" class="headerlink" title="为什么你的学历是专科"></a>为什么你的学历是专科</h6></li>
</ul>
<blockquote>
<p>[很难回答 送命题 学历非常重要的 话术把劣势转换优势]<br>实话实说上高中的时候我并不是一个好学生，在那时候爱玩电脑，确实也耽误了不少学业。但我认为学历的高低并不代表能力的好坏，在我上了专科以后我更加意识到因为学历比别人落后，自己就更需要努力了，从小对编程感兴趣，上了大学后就更有时间朝着自己喜欢的领域努力。在大学几年的时间里面我没有醉生梦死，自己呢也连续学习了XXX技术内容，我知道有朝一日，这些知识一定能给我带来用处，我一定能成为所向往的软件工程师，我能用实际行动来证明专科不比本科差</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对加班的看法"><a href="#谈谈你对加班的看法" class="headerlink" title="谈谈你对加班的看法"></a>谈谈你对加班的看法</h6></li>
</ul>
<blockquote>
<p>[测试你是否能为公司奉献 要强调上班提高效率 强调加班并不是我的工作效率低下]<br>上班时间我会提高效率，做到当日事当日毕，但是如果当天的事没有按时完成，我会义不容辞的加班，现在我是单身，没有家庭的负担，可以全身心的工作</p>
</blockquote>
<ul>
<li><h6 id="你的薪资的要求"><a href="#你的薪资的要求" class="headerlink" title="你的薪资的要求"></a>你的薪资的要求</h6></li>
</ul>
<blockquote>
<p>[提前有明确主张 自己能赚多少钱 给出hr谈薪资的余地期待8k 可以报价8.5k 千万不要说区间6-8k]<br>我期望的薪资是8.5k，每一个公司都有自己的薪资结构，咱们公司是xxx行业中是非常有实力的企业，相对于薪资来说我更看重技术和行业本身，如果您觉得薪资水平超出了公司的预期的话，这个咱们可以谈</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对跳槽的看法"><a href="#谈谈你对跳槽的看法" class="headerlink" title="谈谈你对跳槽的看法"></a>谈谈你对跳槽的看法</h6></li>
</ul>
<blockquote>
<p>[千万不要说负面话语 也不能说工资太低、福利太差、没有晋升空间]<br>我这个人稳定性很好，本身反对频繁跳槽，但是有一种情况我会选择跳槽，就是公司的发展对于我的事业规划不符，我之前在进入xxx公司的时候，公司主要从事金融行业的项目开发，后来该行业金融不理想改作了电信行业了，当我的长期规划是想成为长期的金融软件工程师与架构师，如果遇到这种情况我会好不容易的选择离开。</p>
</blockquote>
<h1 id="Java面试——Java基础面试技巧"><a href="#Java面试——Java基础面试技巧" class="headerlink" title="Java面试——Java基础面试技巧"></a>Java面试——Java基础面试技巧</h1><h3 id="JDK、JRE、JVM有什么区别"><a href="#JDK、JRE、JVM有什么区别" class="headerlink" title="JDK、JRE、JVM有什么区别"></a>JDK、JRE、JVM有什么区别</h3><ul>
<li><strong>JDK：</strong>Java Development Kit 针对Java程序员的产品</li>
<li><strong>JRE：</strong>Java Runtime Environment是运行Java的环境集合</li>
<li><strong>JVM</strong>：Java虚拟机用于运行Java字节码文件[class]，跨平台的核心。通过JVM隐藏了操作系统最底层的API，对于我们java工程师只需要面对jvm层面进行开发，再转移到其他就可以了</li>
</ul>
<h5 id="为什么可以跨平台？"><a href="#为什么可以跨平台？" class="headerlink" title="为什么可以跨平台？"></a>为什么可以跨平台？</h5><p>因为JVM可以跨平台，JVM只认识<strong>字节码</strong>，能够解释到系统的API调用，对于不同的系统有不同的JVM实现。Windows和Linux有不同的JVM实现，但是编成字节码后都是一样的。</p>
<h3 id="常用数字类型的区别"><a href="#常用数字类型的区别" class="headerlink" title="常用数字类型的区别"></a>常用数字类型的区别</h3><table>
<thead>
<tr>
<th align="center">名次</th>
<th align="center">取值范围</th>
<th align="center">存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节(byte)</td>
<td align="center">-$2^7$ ~ $2^7$-1<br />-128 ~ 127</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center">短整数(short)</td>
<td align="center">-$2^{15}$ ~ $2^{15}$-1 <br />-32768 ~ 32767</td>
<td align="center">2个字节</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>整数(int)</strong></span></td>
<td align="center"><span style = "color:red"> -$2^{31}$ ~ $2^{31}$-1<br />-2147483648 ~ 2147483647</span></td>
<td align="center"><span style = "color:red">4个字节</span></td>
</tr>
<tr>
<td align="center">长整数(long)</td>
<td align="center">-$2^{63}$ ~ $2^{63}$-1</td>
<td align="center">8个字节</td>
</tr>
<tr>
<td align="center">单精度(float)</td>
<td align="center">$2^{-149}$ ~ $2^{128}$-1</td>
<td align="center">4个字节</td>
</tr>
<tr>
<td align="center">双精度(double)</td>
<td align="center">$2^{-1074}$ ~ $2^{1024}$-1</td>
<td align="center">8个字节</td>
</tr>
</tbody></table>
<h3 id="Float在JVM的表达方式及使用陷阱"><a href="#Float在JVM的表达方式及使用陷阱" class="headerlink" title="Float在JVM的表达方式及使用陷阱"></a>Float在JVM的表达方式及使用陷阱</h3><pre><code class="java">float d1 = 423432423f;
float d2 = d1 + 1;
if(d1 == d2)&#123;
    System.out.println(&quot;d1==d2&quot;);
&#125;else&#123;
    System.out.println(&quot;d1!=d2&quot;);
&#125;

答案：d1 == d2
对于单精度浮点型float d1在内存中是采用科学计数法表示
表达为：4.2343242E7 保留小数点后七位 [如果更高精度的用double]
d1是八位数
无论是d1还是d2不考虑最后一位
d2用科学计数法表示同样为4.2343242E7
因此 d1 == d2

银行业务数值精确计算要用BigDecimal类进行加减乘除的计算
</code></pre>
<h3 id="随机数的使用"><a href="#随机数的使用" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><pre><code class="java">编程题：随机生成30~100之间的整数
==========================================================
package com.example.demo12;

import java.util.Random;

public class RandomSample &#123;
    public Integer randomInt1()&#123;
        int min = 30;
        int max = 100;
        //生成正整数范围0-70的随机数 =&gt; 30~100
        int result = new Random().nextInt(max - min) + min;
        return  result;
    &#125;
    public Integer randomInt2()&#123;
        int min = 30;
        int max = 100;
        int result = (int)(Math.random() * (max-min)) + min;
        return result;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(new RandomSample().randomInt1());
        System.out.println(new RandomSample().randomInt2());
    &#125;
&#125;
</code></pre>
<pre><code class="java">编程题：列出1-1000的质数[大于1的情况下 只能被1和自身整除的数]
==========================================================
package com.example.demo12;

public class PrimeNumber &#123;
    public static void main(String[] args) &#123;
        for (int i = 2; i &lt;= 1000; i++)&#123;
            boolean flag = true;
            for (int j = 2; j &lt; i; j++)&#123;
                if(i % j == 0)&#123;
                    flag = false;
                    break;
                &#125;
            &#125;
            if (flag)&#123;
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="面向对象的三大特征是什么"><a href="#面向对象的三大特征是什么" class="headerlink" title="面向对象的三大特征是什么"></a>面向对象的三大特征是什么</h3><ul>
<li><p><strong>封装</strong><br>对同一类事务的特征和功能包装到一起，只对外暴露需要调用接口而已<br>[我想让你看到的你能看到 不想让你看到的不能看到]。作用：对接口进行实现的过程中每一个接口的实现类对接口进行了实现，但是在调用的时候通常是面对接口的，对于使用者来说只需要知道接口对应的哪些方法做什么用的就可以了，对内部的什么是不需要理解的。接口是体现封装的常见方法<br><strong>封装的好处</strong>：</p>
<ol>
<li>实现专业的分工</li>
<li>减少代码耦合</li>
<li>可以自由修改类的内部结构</li>
</ol>
</li>
<li><p><strong>继承</strong><br>是Java中面向对象最显著的特征，继承是从已有的类中派生出新的类，新的类能够吸收原有属性的属性和行为并扩展新的类，<u>Java中类是不支持多继承的，接口可以，一个接口可以继承多个其他接口</u> 父类是子类的抽象化，子类是父类的具体化。<br><strong>接口与抽象类有那些异同？</strong></p>
<table>
<thead>
<tr>
<th align="center">相同点</th>
<th align="center">不同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">都是上层的抽象</td>
<td align="center">抽象类可包含方法的实现<br />接口则只能包含方法的声明</td>
</tr>
<tr>
<td align="center">不能被实例化 [不可new]</td>
<td align="center">继承类只能继承一个抽象类<br />实现类可以实现多个接口</td>
</tr>
<tr>
<td align="center">都可以包含抽象发发</td>
<td align="center">抽象级别：接口&gt;抽象类&gt;实现类</td>
</tr>
</tbody></table>
<p><span style = "color : red"><strong>作用不同</strong>：接口用于约束程序行为。继承则用于代码复用</span><br>注意：JDK8以上版本，接口可以有default方法，包含方法实现</p>
</li>
<li><p><strong>多态</strong><br>最重要的特性 前面是为多态服务的<br>多态是三大特性中最重要的操作<br>多态是同一个行为具有多个不同表现形式或形态的能力<br>多态是同一个接口，使用不同的实例而执行不同操作</p>
</li>
</ul>
<h3 id="静态和实例变量-方法-的区别"><a href="#静态和实例变量-方法-的区别" class="headerlink" title="静态和实例变量(方法)的区别"></a>静态和实例变量(方法)的区别</h3><ul>
<li><strong>语法区别</strong>：静态变量前要加static关键字，实例则不用</li>
<li><strong>隶属区别</strong>：实例变量属于某个对象的属性，而静态属于类</li>
<li><strong>运行区别</strong>：<u>静态变量</u>在JVM加载类字节码创建，<u>实例变量</u>在实例化对象时创建</li>
</ul>
<h6 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h6><p>在类中定义，使用static关键字修饰<br>静态方法：可以通过类名直接访问，也可以通过对象访问<br>调用上下文：不依赖于类的实例，不能访问实例变量和实例方法<br>生命周期：从类加载到类卸载，生命周期与类相同</p>
<h6 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h6><p>在类中定义，不适用static关键字修饰<br>实例方法：只能通过对象访问<br>调用上下文：依赖于类的实例，可以访问实例变量和实例方法<br>生命周期：从对象创建到对象被垃圾回收，生命周期与对象相同</p>
<h3 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h3><pre><code class="java">package com.example.text;
//请写出程序输出结果
//1. 静态优先
//2. 父类优先
//3. 非静态块优先于构造函数
public class ExecutionSequence &#123;
    public static void main(String[] args) &#123;
        new GeneralClass();
    &#125;
&#125;
class ParentClass&#123;
    static &#123;
        System.out.println(&quot;①我是父类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;②我是父类非静态块&quot;);
    &#125;
    public ParentClass()&#123;
        System.out.println(&quot;③我是父类构造函数&quot;);
    &#125;
&#125;

class GeneralClass extends ParentClass&#123;
    static&#123;
        System.out.println(&quot;④我是子类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;⑤我是子类非静态块&quot;);
    &#125;

    public GeneralClass()&#123;
        System.out.println(&quot;⑥我是子类构造函数&quot;);
    &#125;
&#125;
/*
①我是父类静态块
④我是子类静态块
②我是父类非静态块
③我是父类构造函数
⑤我是子类非静态块
⑥我是子类构造函数
*/
</code></pre>
<blockquote>
<p>总结<br>静态块：静态块在类加载时执行，且父类静态块先于子类静态块执行。<br>非静态块和构造函数：在对象创建时，先执行父类的非静态块和构造函数，再执行子类的非静态块和构造函数。</p>
</blockquote>
<h3 id="请说明java的异常体系"><a href="#请说明java的异常体系" class="headerlink" title="请说明java的异常体系"></a>请说明java的异常体系</h3><p>Error → Throwable<br>RuntimeException → Exception → Throwable<br>运行时产生的异常不要求对其强制try catch…</p>
<h5 id="Error和Exception的区别和联系"><a href="#Error和Exception的区别和联系" class="headerlink" title="Error和Exception的区别和联系"></a>Error和Exception的区别和联系</h5><table>
<thead>
<tr>
<th align="center">Exception</th>
<th align="center">Error</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以是可被控制或不可控制的</td>
<td align="center">总是不可控制的</td>
</tr>
<tr>
<td align="center">表示一个由程序员导致的错误</td>
<td align="center">经常用来用于表示系统错误或低层资源的错误</td>
</tr>
<tr>
<td align="center">表示在应用程序级被处理</td>
<td align="center">如果可能的话，应该在系统级被捕捉</td>
</tr>
</tbody></table>
<h3 id="String与字符串常量池-比较内存地址"><a href="#String与字符串常量池-比较内存地址" class="headerlink" title="String与字符串常量池 [比较内存地址]"></a>String与字符串常量池 [比较内存地址]</h3><pre><code class="java">String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
String s3 = &quot;abc&quot;+&quot;def&quot;;
String s4 = &quot;abcdef&quot;;
String s5 = s2 + &quot;def&quot;;
String s6 = new String(&quot;abc&quot;);
System.ouut.println(s1==s2); //true
System.ouut.println(s3==s4); //true 相等的都保存到常量池
System.ouut.println(s4==s5); //false 
//s5中的s2属于引用类型 在java编译期间无法确定其类型 只有在运行时才能确定具体的值 会产生一个新的内存地址给s5 所以不相等
System.ouut.println(s4.equals(s5));//true equals比较的是内容
System.ouut.println(s1==s6); //false
//s1是在常量池的常量 new String(&quot;abc&quot;);创建的东西不在常量池 存储的地方是完全不同的
</code></pre>
<h3 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h3><table>
<thead>
<tr>
<th></th>
<th align="center">String</th>
<th align="center">StringBuffer</th>
<th align="center">StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>执行速度</td>
<td align="center">最差</td>
<td align="center">其次</td>
<td align="center">最高</td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程不安全</td>
</tr>
<tr>
<td>使用场景</td>
<td align="center">少量字符串操作</td>
<td align="center">多线程环境下的大量操作</td>
<td align="center">单线程环境下的大量操作</td>
</tr>
</tbody></table>
<blockquote>
<p>优先使用哪个？<br><strong>单线程环境</strong>：优先使用 <strong>StringBuilder</strong>。因为 StringBuilder 没有线程同步开销，性能更高。<br><strong>多线程环境</strong>：优先使用 <strong>StringBuffer</strong>。因为 StringBuffer 提供了线程安全的保证，避免了多线程环境下的并发问题</p>
</blockquote>
<h3 id="List与Set的区别"><a href="#List与Set的区别" class="headerlink" title="List与Set的区别"></a>List与Set的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">Set</th>
</tr>
</thead>
<tbody><tr>
<td align="center">允许重复</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否允许null</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否有序</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">常用类</td>
<td align="center">ArrayList<br />LinkedList</td>
<td align="center">HashSet<br />LinkedHashSet<br />TreeSet</td>
</tr>
</tbody></table>
<h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ArrayList</th>
<th align="center">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">基于动态数组</td>
<td align="center">基于链表</td>
</tr>
<tr>
<td align="center">遍历方式</td>
<td align="center">连续读取</td>
<td align="center">基于指针</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">大数据量读取</td>
<td align="center">频繁新增、插入[写入类型]</td>
</tr>
</tbody></table>
<h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HashSet</th>
<th align="center">TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排序方式</td>
<td align="center">不能保证顺序</td>
<td align="center">按预置规则顺序</td>
</tr>
<tr>
<td align="center">底层存储</td>
<td align="center">基于HashMap</td>
<td align="center">基于TreeMap</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="center">基于Hash表实现</td>
<td align="center">基于二叉树实现</td>
</tr>
</tbody></table>
<h3 id="List排序的编码实现"><a href="#List排序的编码实现" class="headerlink" title="List排序的编码实现"></a>List排序的编码实现</h3><pre><code class="java">编程题：List排序
Employee.java
package com.example.text;

public class Employee &#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;

    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
</code></pre>
<pre><code class="java">ListSorter.java
package com.example.text;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ListSorter &#123;
    public static void main(String[] args) &#123;
        List&lt;Employee&gt; emps = new ArrayList&lt;&gt;();
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        Collections.sort(emps, new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                //以薪资排序 如果是以年龄的话o1.getAge() - o2.getAge();
                return (int) (o1.getSalary() - o2.getSalary());
                //返回正数 第一个大于第二个
            &#125;
        &#125;);
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="TreeSet排序的编码实现"><a href="#TreeSet排序的编码实现" class="headerlink" title="TreeSet排序的编码实现"></a>TreeSet排序的编码实现</h3><pre><code class="java">编程题:TreeSet排序
Employee.java 同上
[自定义排序]
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;(new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                return (int)(o2.getSalary() - o1.getSalary());
            &#125;
        &#125;);
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
    &#125;
&#125;
</code></pre>
<pre><code class="java">[自然排序]
package com.example.text;

public class Employee implements Comparable&lt;Employee&gt;&#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Employee o)&#123;
 //如果返回-1 Employee对象返回到红黑树的左边 采用降序排列
 //如果返回1
        return this.getAge().compareTo(o.getAge());
//      return o.getAge().compareTo(this.getAge()); 输出降序
//如果前面比后面大 返回1 反之返回-1 如果两者相等返回0
    &#125;
    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
=============================================================
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="hashCode与equals的联系与区别"><a href="#hashCode与equals的联系与区别" class="headerlink" title="hashCode与equals的联系与区别"></a>hashCode与equals的联系与区别</h3><h5 id="Object类hashCode-和equals-的区别"><a href="#Object类hashCode-和equals-的区别" class="headerlink" title="Object类hashCode()和equals()的区别"></a>Object类hashCode()和equals()的区别</h5><ul>
<li><p>equals()方法用来判断两个对象是否”相同”</p>
</li>
<li><p>hashCode()返回一个int，代表”将该对象的内部地址” [如果不相等肯定不是同一个对象] [小概率情况下不同的对象也产生相同的hashCode(), 之后再用equals()去比较]</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">两个对象如果equals()成立, hashcode()一定成立</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">如果equals()不成立, hashcode()可能成立</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">如果hashcode()成立, equals()不一定成立</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">hashcode()不相等, equals()一定不成立</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>hashCode 方法用于快速定位哈希表中的桶（bucket），而 equals 方法用于确认桶中的具体对象。通过 hashCode 快速过滤掉大部分不相等的对象，可以显著提高查找效率。<br>通常是先调用 hashCode 方法来定位桶，然后再调用 equals 方法来确认具体对象。equals 方法不会直接调用 hashCode 方法，而是依赖于 hashCode 方法的一致性。</p>
</blockquote>
<h3 id="Java-IO中有集中类型的流"><a href="#Java-IO中有集中类型的流" class="headerlink" title="Java IO中有集中类型的流"></a>Java IO中有集中类型的流</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">InputStream[父类]<br />     FileInputStream<br />BufferedInputStream[缓存]</td>
<td align="center">OutputStream[父类]<br />      FileOutputStream<br />  BufferedOutputStream[缓存]</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">Reader<br />FileReader<br />InputStreamReader<br />BufferedReader</td>
<td align="center">Writer<br />FileWeiter<br />OutputStreamWriter<br />BufferedWeiter</td>
</tr>
</tbody></table>
<h3 id="★-利用IO实现文件复制-★-笔试"><a href="#★-利用IO实现文件复制-★-笔试" class="headerlink" title="★ 利用IO实现文件复制 ★ [笔试]"></a>★ 利用IO实现文件复制 ★ [笔试]</h3><pre><code class="java">编程题：复制文件到指定文件夹
package com.example.text.FileCopy;

import java.io.*;

public class FileCopy &#123;
    public static void main(String[] args) &#123;
        //1. 利用JavaIo
        File source = new File(&quot;D:/application.rar&quot;);
        File target = new File(&quot;D:/target/application.rar&quot;);
        InputStream input = null;
        OutputStream output = null;
        try &#123;
            input = new FileInputStream(source);
            output = new FileOutputStream(target);
            byte[] buf = new byte[1024];
            int byteRead;
            while((byteRead = input.read(buf)) != -1)&#123;
                output.write(buf,0,byteRead);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            try &#123;
                input.close();
                output.close();
            &#125; catch (IOException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
        //2. 利用FileChannel实现文件复制
        //3. Commons Io组件实现文件复制
        //FileUtils.copyFile(Source,Target);
    &#125;
&#125;
</code></pre>
<h3 id="请介绍JVM的内存组成"><a href="#请介绍JVM的内存组成" class="headerlink" title="请介绍JVM的内存组成"></a>请介绍JVM的内存组成</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c2c6b396e3573fda209d5b4db42d40799b0be3f1/data/JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90.png"></p>
<blockquote>
<p>[共享区：供所有对象共享 所有线程都访问到的地方]<br><strong>堆</strong>：垃圾回收销毁处理区<br><strong>方法区</strong>：虚拟机加载的类的信息、常量、静态变量等信息</p>
<p>[私有区：所有对象都是私有的]<br><strong>程序计数器PC</strong>： 当前线程所执行的字节码指令的行号指示器[<strong>分值、跳转</strong>、循环、异常处理、线程恢复] 每个线程都有单独的程序计数器 [私有的]<br><strong>虚拟机栈VM Stack</strong>：为Java的方法服务 当线程创建的时候虚拟机栈会为线程分配一个虚拟机栈，在线程执行的时候创建的每个方法都会创建一个栈针，用于存放局部变量、操作方法等 [入栈+出栈]<br><strong>本地方法栈</strong>：类似于虚拟机栈，本地方法栈是执行<u>本地方法使用</u>的</p>
</blockquote>
<h3 id="请简述Java的垃圾回收-GC"><a href="#请简述Java的垃圾回收-GC" class="headerlink" title="请简述Java的垃圾回收(GC)"></a>请简述Java的垃圾回收(GC)</h3><ul>
<li>GC(Garbage Collection)用于回收不再使用的内存</li>
<li>GC负责3项任务：分配内存、确保引用、回收内存</li>
<li>GC回收的依据某对象没有任何引用、则可以被回收</li>
</ul>
<h5 id="垃圾回收-GC-算法"><a href="#垃圾回收-GC-算法" class="headerlink" title="垃圾回收(GC)算法"></a>垃圾回收(GC)算法</h5><ul>
<li><strong>引用计数算法</strong> [计数器 引用到这个对象的时候+1  被释放或断开计数器-1  当计数器变成0就可以被垃圾回收]<br>若两个对象相互引用就会产生循环计数器 这个对于引用计数算法是无效的</li>
<li><strong>跟踪回收算法</strong> [利用JVM维护的对象引用图 每个对象彼此依赖和引用 从根节点标记对象引用图和可以被标记的对象 遍历结束以后未被标记的对象是不能够使用的对象可以被回收]</li>
<li><strong>压缩回收算法</strong> [将JVM堆中活动的对象放到一个集中的区域中 另外一大块留出一个活动的区域 对堆中的碎片进行集中的处理]</li>
<li><strong>复制回收算法</strong> [把堆分成两个相同大小的区域 只有其中的一个区域被使用 直到这个区域被消耗完 垃圾回收器就会中断这个程序的运行 以遍历的方式把活动的对象移动到另一个区域 移动的过程中对象是紧密挨在一起的 可以消除其中的碎片 【在复制的同时也对对象进行重新复制和安排 一次性解决了内存碎片的问题】【需要两倍大小的内存空间 降低了效率】]</li>
<li><strong>按代回收算法</strong> [把堆分成多个子堆，每个堆命名成一代，算法优先收集年幼年轻的对象，在这其中对象仍然存活的就把它移动到高级堆中 【减少扫描次数和范围 提高回收效益】]</li>
</ul>
<h3 id="Java的内存泄露的场景"><a href="#Java的内存泄露的场景" class="headerlink" title="Java的内存泄露的场景"></a>Java的内存泄露的场景</h3><h5 id="请列举Java中内存泄漏的场景"><a href="#请列举Java中内存泄漏的场景" class="headerlink" title="请列举Java中内存泄漏的场景"></a>请列举Java中内存泄漏的场景</h5><p>一个不需要使用的对象还在内存中占用并使用其内存空间，忘记释放就会存在内存泄露</p>
<ul>
<li><strong>静态集合类</strong> static描述对象 存储在方法区 垃圾回收器不会对其扫描回收</li>
<li><strong>各种连接</strong> JVM一直可达不会被回收</li>
<li><strong>监听器</strong> 全局存在的</li>
<li><strong>不合理的作用域</strong> 能用在方法中public 不要用在方法外private</li>
<li>没有把对象及时设置为null【极少发生】</li>
</ul>
<h3 id="请实现对象的浅复制与深复制"><a href="#请实现对象的浅复制与深复制" class="headerlink" title="请实现对象的浅复制与深复制"></a>请实现对象的浅复制与深复制</h3><ul>
<li><strong>浅复制</strong>：只对对象及变量值进行复制，引用对象地址不变</li>
<li><strong>深复制</strong>[序列化方式]：创建一个新的对象，并且复制所有引用类型字段的对象。修改新对象的引用类型字段不会影响原对象。[彼此互不干扰]</li>
</ul>
<pre><code class="java">com/example/text/clone/Dancer.java
package com.example.text.clone;

import java.io.*;

public class Dancer implements Cloneable,Serializable&#123;
    private String name;
    private Dancer partner;

    public Dancer() &#123;
    &#125;

    public Dancer(String name, Dancer partner) &#123;
        this.name = name;
        this.partner = partner;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Dancer getPartner() &#123;
        return partner;
    &#125;

    public void setPartner(Dancer partner) &#123;
        this.partner = partner;
    &#125;
    public Dancer deepClone() throws IOException, ClassNotFoundException &#123;
        //序列化, 将内存中的对象序列化为字节数组
        //序列化要注意加Serializable接口
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//字节数组
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //反序列化, 将字节数组转回到对象, 同时完成深复制的任务
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis); //字节数组还原成对象
        return (Dancer) ois.readObject();
    &#125;
    //初始化一下
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;
        Dancer d1 = new Dancer();
        d1.setName(&quot;小明&quot;);
        Dancer d2 = new Dancer();
        d2.setName(&quot;小红&quot;);
        d1.setPartner(d2);
        //hashCode()是内存地址转化后的一个整数
        System.out.println(&quot;Partner:&quot; + d2.hashCode());
        //浅复制
        Dancer shallow =  (Dancer)d1.clone();
        System.out.println(&quot;浅复制：&quot; + shallow.getPartner().hashCode());
        //深复制
        Dancer deep = (Dancer) d1.deepClone();
        System.out.println(&quot;深复制：&quot; + deep.getPartner().hashCode());
    &#125;
&#125;
</code></pre>
<h5 id="简述一下equalsIgnoreCase和equals的区别"><a href="#简述一下equalsIgnoreCase和equals的区别" class="headerlink" title="简述一下equalsIgnoreCase和equals的区别"></a>简述一下equalsIgnoreCase和equals的区别</h5><pre><code class="java">equalsIgnoreCase：比较两个字符串的内容是否相等, 忽略大小写
equals：比较两个字符的内容是否完全相等, 包括大小写
equalsIgnoreCase 和 equals 都是 String 类的方法，用于比较两个字符串是否相等(返回值都是Boolean)。它们的主要区别在于对大小写的处理方式。
</code></pre>
<h1 id="Java面试——Web基础与数据处理"><a href="#Java面试——Web基础与数据处理" class="headerlink" title="Java面试——Web基础与数据处理"></a>Java面试——Web基础与数据处理</h1><h3 id="请说明Servlet执行流程"><a href="#请说明Servlet执行流程" class="headerlink" title="请说明Servlet执行流程"></a>请说明Servlet执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/94561f5b5984c6a6ac9be3dd6a81d295e2955040/data/Servlet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<h6 id="问：Servlet什么时候被实例化的呢？"><a href="#问：Servlet什么时候被实例化的呢？" class="headerlink" title="问：Servlet什么时候被实例化的呢？"></a>问：Servlet什么时候被实例化的呢？</h6><blockquote>
<p>Servlet默认情况下是<u>第一次访问的时候</u><strong>实例化</strong>的<br>也可以通过web.xml配置load-on-startup，使其在服务启动的时候实例化</p>
</blockquote>
<h6 id="问：Servlet在并发条件下如何处理的？"><a href="#问：Servlet在并发条件下如何处理的？" class="headerlink" title="问：Servlet在并发条件下如何处理的？"></a>问：Servlet在并发条件下如何处理的？</h6><blockquote>
<p>基于<strong>单例多线程</strong>技术提供web服务<br>使用servlet时不允许使用存在状态改变的变量</p>
</blockquote>
<blockquote>
<p>补充：</p>
<p><strong><u>单例多线程技术</u></strong><br><strong>单例模式</strong>：Servlet 实例在 Web 容器中通常是单例的，即一个 Servlet 类只有一个实例。这意味着所有的请求都会共享同一个 Servlet 实例。<br>优点：减少了对象的创建和销毁开销，提高了性能。<br>缺点：需要特别注意线程安全问题，因为多个请求可能会同时访问同一个 Servlet 实例。</p>
<p><strong>多线程</strong>：Web 容器为每个请求分配一个独立的线程来处理。当多个请求同时到达时，这些请求会被分配到不同的线程中，但这些线程都共享同一个 Servlet 实例。<br>线程安全：由于多个线程共享同一个 Servlet 实例，因此必须确保 Servlet 实例中的代码是线程安全的。</p>
<p><u><strong>状态改变的变量</strong></u><br><strong>状态改变的变量</strong>：指的是在 Servlet 实例中定义的成员变量（实例变量），这些变量在不同请求之间可能会被修改。</p>
<p><strong>线程安全问题</strong>：<u>如果多个线程同时访问和修改同一个成员变量，可能会导致数据不一</u>致、<strong>竞态条件</strong>等问题。<br>竞态条件（Race Condition）是指在多线程或多进程环境中，由于多个线程或进程对共享资源的访问顺序不确定，导致程序的行为依赖于这些线程或进程的执行顺序，从而产生不可预测的结果。简单来说，竞态条件发生在多个线程或进程竞争同一资源时，如果这些线程或进程的执行顺序不同，会导致不同的结果。</p>
</blockquote>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ul>
<li><h6 id="启动时装载-web-xml"><a href="#启动时装载-web-xml" class="headerlink" title="启动时装载 - web.xml"></a>启动时装载 - web.xml</h6></li>
<li><h6 id="创建-构造函数"><a href="#创建-构造函数" class="headerlink" title="创建 - 构造函数"></a>创建 - 构造函数</h6></li>
<li><h6 id="初始化-init-专门的初始化资源"><a href="#初始化-init-专门的初始化资源" class="headerlink" title="初始化 - init()  [专门的初始化资源]"></a>初始化 - init()  [专门的初始化资源]</h6></li>
<li><h6 id="提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost"><a href="#提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost" class="headerlink" title="提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]"></a>提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]</h6></li>
<li><h6 id="停止时销毁-destory-销毁资源"><a href="#停止时销毁-destory-销毁资源" class="headerlink" title="停止时销毁 - destory() [销毁资源]"></a>停止时销毁 - destory() [销毁资源]</h6></li>
</ul>
<pre><code class="java">com/example/text/servlet/SampleServlet.java
package com.example.text.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class SampleServlet extends HttpServlet &#123;
    public SampleServlet()&#123;
        System.out.println(&quot;正在创建Servlet&quot;);
    &#125;

    @Override
    public void init() throws ServletException &#123;
        System.out.println(&quot;正在初始化Servlet&quot;);
    &#125;

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;
        System.out.println(this.hashCode() + &quot;: Service()正在提供服务&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().print(this.hashCode() + &quot;: Service()正在提供服务&quot;);
    &#125;

    @Override
    public void destroy()&#123;
        System.out.println(&quot;正在销毁Servlet&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.example.text.servlet.SampleServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/sample&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

=================================================
http://localhost:8080/sample

正在创建Servlet 【启动时】
正在初始化Servlet
1025518765: Service()正在提供服务
正在销毁Servlet 【停止时】
</code></pre>
<h3 id="请求与响应的结构"><a href="#请求与响应的结构" class="headerlink" title="请求与响应的结构"></a>请求与响应的结构</h3><ul>
<li>HTTP请求包含三部分：请求行、请求头、请求体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/22dcc798c61eeec0f74ca5dd6e7372dfa0fa135e/data/HTTP%E8%AF%B7%E6%B1%82%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP请求三部分"></p>
<ul>
<li>HTTP响应包含三部分：响应行、响应头、响应体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP响应三部分"></p>
<h3 id="请求转发与响应重定向的区别"><a href="#请求转发与响应重定向的区别" class="headerlink" title="请求转发与响应重定向的区别"></a>请求转发与响应重定向的区别</h3><h5 id="请求转发-一次请求"><a href="#请求转发-一次请求" class="headerlink" title="请求转发 [一次请求]"></a>请求转发 [一次请求]</h5><ul>
<li>请求转发是<strong>服务器跳转</strong>，只会产生一次请求</li>
<li>请求转发语句是：<code>request.getRequestDispatcher().forward()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="请求转发"></p>
<blockquote>
<p>网页请求Tomcat的Servlet1，Servlet1请求Servlet2，Servlet2响应给网页，网页收到响应</p>
</blockquote>
<h5 id="响应重定向-两次请求"><a href="#响应重定向-两次请求" class="headerlink" title="响应重定向 [两次请求]"></a>响应重定向 [两次请求]</h5><ul>
<li>重定向则是<strong>浏览器端跳转</strong>，会产生两次请求</li>
<li>响应重定向语句是：<code>response.sendRedirect()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/de72ec8d8af2b71272c785f5fb04bad0df88d78f/data/%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%911.jpg" alt="响应重定向"></p>
<blockquote>
<p>网页$请求_1$Tomcat的Servlet1，Servlet1直接$响应_1$给网页，网页收到$响应_1$[让网页创建一个新的$请求_2$]<br>网页新创了一个$请求_2$Tomcat的Servlet2，Servlet2只对请求进行处理返回给$响应_2$网页</p>
</blockquote>
<h3 id="请阐述Session的原理"><a href="#请阐述Session的原理" class="headerlink" title="请阐述Session的原理"></a>请阐述Session的原理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e69d245dd6d92882f32e9bee19e85bb5646a145c/data/%E7%AE%80%E8%BF%B0Session%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="简述Session的原理"></p>
<blockquote>
<p>浏览器第一次向Tomcat发送请求，Tomcat收到请求自动在tomcat运行内存中生成一个存储空间并赋予一个SessionId:7U809J唯一编号，<strong>若使用了session.setAttribute(name,小潘)<strong>，会在那个运行内存中存放一个</strong>小潘</strong>的内存属性[name:小潘] 当程序处理完后返回给浏览器其中包含了一个特殊信息SessionId:7U809J，浏览器收到响应后把SessionId:7U809J保存到浏览器的Cookie中SessionId:7U809J[只要当前浏览器没有被关闭的话 Cookie会一直存在 会在发送请求的时候一并发送给服务器]，当第二次发送请求的时候浏览器会把SessionId:7U809J第二次发送给Tomcat，<strong>若使用了session.getAttribute(name) &#x3D; 小潘</strong>，得到的结果就出现了小潘 返回浏览器响应</p>
</blockquote>
<h3 id="JSP九大内置对象是什么"><a href="#JSP九大内置对象是什么" class="headerlink" title="JSP九大内置对象是什么"></a>JSP九大内置对象是什么</h3><table>
<thead>
<tr>
<th align="left">内置对象</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">request</td>
<td align="left">请求对象 - HttpServletRequest</td>
</tr>
<tr>
<td align="left">response</td>
<td align="left">响应对象 - HttpServletResponse</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">用户会话 - HttpSession</td>
</tr>
<tr>
<td align="left">application [全局实例]</td>
<td align="left">应用全局对象 - ServletContext</td>
</tr>
<tr>
<td align="left">out</td>
<td align="left">输出对象 - PrintWriter</td>
</tr>
<tr>
<td align="left">page</td>
<td align="left">当前页面对象 - this [Object实例]</td>
</tr>
<tr>
<td align="left">pageContext</td>
<td align="left">页面上下文对象 - PageContext</td>
</tr>
<tr>
<td align="left">config [全局参数]</td>
<td align="left">应用配置对象 - ServletConfig</td>
</tr>
<tr>
<td align="left">exception</td>
<td align="left">应用异常对象 - Throwable</td>
</tr>
</tbody></table>
<h3 id="Statement-和-PreparedStatement的区别"><a href="#Statement-和-PreparedStatement的区别" class="headerlink" title="Statement 和 PreparedStatement的区别"></a>Statement 和 PreparedStatement的区别</h3><ul>
<li>PreparedStatement是预编译的SQL语句，效率高于Statement</li>
<li>PreparedStatement支持 ‘?’ 操作符，相对于Statement更加灵活</li>
<li>PreparedStatement可以防止SQL注入，安全性高于Statement</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;
    //使用Statement sql语句解释N多次
    //SQL注入攻击：  &#39; or 1=1 or &#39;
    public void findByEname1(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);
            Statement ps = conn.createStatement();
            //使用Statement
            String sql = &quot;SELECT * FROM emp where ename = &#39;&quot; + ename + &quot;&#39; &quot;;
            System.out.println(sql);
            ResultSet rs = ps.executeQuery(sql);

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;

    //使用预编译PreparedStatement sql语句解释一次
    public void findByEname2(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;

        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);

            //使用预编译PreparedStatement
            String sql = &quot;SELECT * FROM emp where ename = ?&quot;;
            System.out.println(sql);
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setString(1, ename);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        StatementSample sample = new StatementSample();
        sample.findByEname1(&quot;SMITH&#39; or 1=1 or &#39;&quot;); //SQL注入攻击
        sample.findByEname2(&quot;SMITH&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="请说明JDBC的使用步骤"><a href="#请说明JDBC的使用步骤" class="headerlink" title="请说明JDBC的使用步骤"></a>请说明JDBC的使用步骤</h3><ul>
<li>加载JDBC驱动</li>
<li>创建数据库连接(Connection)</li>
<li>创建命令(Statement)</li>
<li>处理结果(ResultSet)</li>
<li>关闭连接</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class MysqlJDBC &#123;
    public static void main(String[] args) &#123;
        //连接需要提前下载好包   mysql-connector-java-5.1.47.jar
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String sql = &quot;SELECT * FROM emp&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            //1.加载JDBC驱动
            Class.forName(driverName);
            //2.建立连接
            conn = DriverManager.getConnection(URL, username, password);
            //3.创建命令（Statement)
            Statement ps = conn.createStatement();
            //4.处理结果
            ResultSet rs = ps.executeQuery(sql);
            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="SQL编程训练"><a href="#SQL编程训练" class="headerlink" title="SQL编程训练"></a>SQL编程训练</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bc48ea2eefeb9921758f69d1ee9d506366d73753/data/scott_sql%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<pre><code class="sql">scott.sql文件已准备好

★按部门编号升序、工资倒序的排列员工信息
SELECT * FROM emp ORDER BY deptno ASC, sal DESC

★列出deptno=30的部门名称及员工[关联查询]
SELECT dept.dname, emp.* FROM emp,dept
WHERE emp.deptno = dept.deptno
AND dept.deptno = 30

★列出每个部门最高、最低、平均工资 #若再列出人数只需要再SELECT后面加 COUNT(*)
SELECT deptno, max(sal), min(sal), avg(sal)
FROM emp 
GROUP BY deptno  

★列出市场部(SALES)及研发部(RESEARCH)的员工
SELECT * FROM dept d, emp e
WHERE d.deptno = e.deptno 
AND (d.dname = &#39;SALES&#39; or d.dname = &#39;RESEARCH&#39;)

★列出人数超过3人的部门 #按照部门分组 
# WHERE对原始数据进行筛选[在GROUP BY之前进行的] 
# HAVING对分组后的进行二次筛选[在GROUP BY之后进行的]
SELECT d.dname, count(*)
FROM dept d, emp e
WHERE d.deptno = e.deptno 
GROUP BY d.dname 
HAVING count(*)&gt;3

★计算MILLER年薪比SMITH高多少
SELECT a.a_sal, b.b_sal, a.a_sal - b.b_sal FROM 
(SELECT sal * 12 a_sal FROM emp WHERE ename = &#39;MILLER&#39;) a,
(SELECT sal * 12 b_sal FROM emp WHERE ename = &#39;SMITH&#39;) b

★★列出直接向King汇报的员工
SELECT * FROM emp
WHERE mgr = (SELECT empno FROM emp WHERE ename = &#39;KING&#39;)
#或
SELECT e.* FROM emp e, (SELECT empno FROM emp WHERE ename = &#39;KING&#39;) k
WHERE e.mgr = k.empno

★★列出公司所有员工的工龄，并倒序排列 
# NOW获取当前时间 
# SELECT DATE_FORMAT(date,format)   DATE_FORMAT只对日期形式的数据生效
SELECT * FROM(
    SELECT emp.*, DATE_FORMAT(NOW(),&quot;%Y&quot;) - DATE_FORMAT(hiredate,&quot;%Y&quot;) yg 
    FROM emp
)d 
ORDER BY d.yg DESC

★★计算管理者与基层员工平均薪资差额
SELECT a_avg - b_avg 
FROM
 (SELECT avg(sal) a_avg 
 FROM emp
 WHERE job = &#39;MANAGER&#39; OR job = &#39;PRESIDENT&#39;) a,
  (SELECT avg(sal) b_avg
  FROM emp
  WHERE job IN (&#39;CLERK&#39;,&#39;SALESMAN&#39;,&#39;ANALYST&#39;))b
</code></pre>
<h1 id="Java面试-——-主流框架"><a href="#Java面试-——-主流框架" class="headerlink" title="Java面试 —— 主流框架"></a>Java面试 —— 主流框架</h1><h3 id="谈谈你对IOC和DI的理解"><a href="#谈谈你对IOC和DI的理解" class="headerlink" title="谈谈你对IOC和DI的理解"></a>谈谈你对IOC和DI的理解</h3><ul>
<li><h6 id="IOC控制反转，设计理念，由第三方来管理与控制对象"><a href="#IOC控制反转，设计理念，由第三方来管理与控制对象" class="headerlink" title="IOC控制反转，设计理念，由第三方来管理与控制对象"></a>IOC控制反转，设计理念，由第三方来管理与控制对象</h6></li>
<li><h6 id="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"><a href="#DI依赖注入，具体实现，由对象容器在运行时动态注入对象" class="headerlink" title="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"></a>DI依赖注入，具体实现，由对象容器在运行时动态注入对象</h6></li>
</ul>
<p>[<strong><u>DI是一种具体的技术实现，是对宏观IOC里面的一种技术上的形式，在Spring中使用了反射+工厂模式来实现DI</u></strong>]</p>
<pre><code class="java">IDAO dao = new UserDao(); //原始版本 原本的容器控制器

运行时Spring动态进行创建 对程序进行有效的解耦 //将控制权交给第三方控制容器  IOC容器
// applicationContext最底层是类工厂模式
IDAO dao = (IDAO)applicationContext.getBean(&quot;userDAO&quot;); //ICO容器 动态实例化DAO
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserDAO&quot;/&gt;
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserExtDAO&quot;/&gt; //方便随时更改
</code></pre>
<h3 id="Spring中Bean实例化有几种方式"><a href="#Spring中Bean实例化有几种方式" class="headerlink" title="Spring中Bean实例化有几种方式"></a>Spring中Bean实例化有几种方式</h3><ul>
<li>使用<strong>类构造器</strong>实例化</li>
<li>使用<strong>静态工厂方法</strong>实例化</li>
<li>使用<strong>实例工厂方法</strong>实例化</li>
</ul>
<pre><code class="java">com/example/text/spring/Person.java
package com.example.text.spring;

public class Person &#123;

    private String name;
    private Integer age;


    public Person() &#123;
        System.out.println(&quot;Person默认构造函数&quot;);
    &#125;

    public Person(String name, Integer age) &#123;
        this.name = name;
        this.age = age;

        System.out.println(&quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonStaticFactory.java
package com.example.text.spring;

/**
 * Person静态工厂
 */
public class PersonStaticFactory &#123;
    public static Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonFactory.java
package com.example.text.spring;

/**
 * Person实例工厂 实例化以后才可以调用
 */
public class PersonFactory &#123;
    public Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">C:\Users\Pluminary\Desktop\text\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--构造函数实例化--&gt;
    &lt;!-- 1.调用无参构造函数 --&gt;
    &lt;bean id=&quot;person1&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;&lt;/bean&gt;

    &lt;!-- 2.调用有参构造函数 --&gt;
    &lt;bean id=&quot;person2&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;枫叶(构造函数)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;/bean&gt;


    &lt;!-- 通过静态工厂创建对象--&gt;
    &lt;bean id=&quot;person3&quot; class=&quot;com.imooc.spring.instance.PersonStaticFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;蓝天(静态工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;27&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 通过实例工厂创建对象--&gt;
&lt;!-- 实例化PersonFactory--&gt;
    &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.imooc.spring.instance.PersonFactory&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;person4&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;绿地(实例工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;29&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/example/text/Application.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
===================================================================
Person默认构造函数
Person&#123;name=&#39;枫叶(构造函数)&#39;,age=23&#125;
Person&#123;name=&#39;蓝天(静态工厂)&#39;,age=27&#125;
Person&#123;name=&#39;绿地(实例工厂)&#39;,age=29&#125;
</code></pre>
<h3 id="Bean注入属性有哪几种方式"><a href="#Bean注入属性有哪几种方式" class="headerlink" title="Bean注入属性有哪几种方式"></a>Bean注入属性有哪几种方式</h3><ul>
<li><h6 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h6></li>
<li><h6 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h6></li>
<li><h6 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h6></li>
<li><h6 id="Java-Config注入"><a href="#Java-Config注入" class="headerlink" title="Java Config注入"></a>Java Config注入</h6></li>
</ul>
<h6 id="setter注入-1"><a href="#setter注入-1" class="headerlink" title="setter注入"></a>setter注入</h6><blockquote>
<p>在UserService使用的时候依赖于UserDao，目前UserDao是空的，要想运行时通过setter方法注入的话，我们需要在injection.xml中<br>&lt;context:component-scan base-package&#x3D;”com.imooc.spring”&#x2F;&gt;<br><bean id="userDAO" class="com.imooc.spring.injection.UserDAOImpl"/><br><bean id="userService" class="com.imooc.spring.injection.UserService"><br>    <property name="userDAO" ref="userDAO"/><br>    <constructor-arg name="userDAO" ref="userDAO"/><br>前面的name&#x3D;”userDAO”对应着UserService.java中的userDAO属性 <code>private UserDAO userDAO</code><br>后面的ref&#x3D;”userDAO”对应着当前文件中的bean id &#x3D; “userDAO”<br></bean></p>
</blockquote>
<pre><code class="java">com/example/text/injection/UserDAO.java
package com.example.text.injection;

public interface UserDAO &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserDAOImpl.java
package com.example.text.injection;

import org.springframework.stereotype.Repository;

//@Repository(&quot;userDAO&quot;) ★注解方式注入
public class UserDAOImpl implements UserDAO&#123;
    public UserDAOImpl()&#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
    public void insert() &#123;
        System.out.println(this + &quot;:正在调用UserDAOImpl.insert()&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserService.java
package com.example.text.injection;

import org.springframework.stereotype.Service;

import javax.annotation.Resource;

//@Service(&quot;userService&quot;) ★注解方式注入
//spring需要动态将userDao注入到UserService上
public class UserService &#123;
//  @Resource(name=&quot;userDAO&quot;)  注解方式注入 可以把原始的bean都注释掉
    private UserDAO userDAO;

    public UserService() &#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
/* 注解方式这些可以抛弃 并且摒弃了xml的那些bean 只需要增加个扫描的注解方式注入
    //通过构造函数注入
    public UserService(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用构造函数注入，UserService(&quot; + userDAO + &quot;)&quot;);
    &#125;

    //通过Setter方法注入
    public void setUserDAO(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用Setter方法注入，setUserDAO(&quot; + userDAO + &quot;)&quot;);
    &#125;
*/

    public void createUser()&#123;
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        userDAO.insert();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/InjectionRunner.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class InjectionRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:injection.xml&quot;);
        UserService userService = (UserService)ctx.getBean(&quot;userService&quot;);
        userService.createUser();
    &#125;
&#125;

==============================================================
UserDAOImpl@531be3c5对象已创建
UserService@5034c75a对象已创建
UserService@5034c75a:正在调用Setter方法注入,setUserDAO
UserService@5034c75a:正在调用UserService.createUser()
UserDAOImpl@531be3c5:正在调用UserDAOImpl.insert()
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\text\src\main\resources\injection.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.spring&quot;/&gt; //★扫描注解方式注入
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.injection.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.injection.UserService&quot;&gt;
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是setter注入
        &lt;constructor-arg name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是构造函数注入
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="Java-config注入"><a href="#Java-config注入" class="headerlink" title="Java config注入"></a>Java config注入</h6><pre><code class="java">Appconfig.java 
[配置文件 在原有代码之外的东西 优点：不用破坏原始代码去达到效果 比xml优点在于java可以及时检查]
package com.imooc.spring.injection;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig &#123; //类似创建对象的方法
    @Bean(name=&quot;userDAO&quot;)
    public UserDAO userDAO()&#123;
        return new UserDAOImpl();
    &#125;

    @Bean(name=&quot;userService&quot;)
    public UserService userService()&#123;
        UserService userService = new UserService();
        userService.setUserDAO(this.userDAO());
        return userService;
    &#125;
&#125;
</code></pre>
<h3 id="Spring常见面试问题"><a href="#Spring常见面试问题" class="headerlink" title="Spring常见面试问题"></a>Spring常见面试问题</h3><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.scope.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.scope.UserService&quot; scope=&quot;prototype&quot; lazy-init=&quot;false&quot;&gt;  
//scope是控制对象的数量是单例(singleton)还是多例(prototype)[每一次创建getbean创建对象]
//还有两个不常见的值 request[同一个对象是同一个请求 不同对象ICO容器创建不同对象] 和 
//session[调用多个getbean是同一个对象 不同session是不同对象] [SpringMVC时用]
        //lazy-init=&quot;true&quot; 延迟初始化 需要的时候才会加载 若getBean被注释则不会加载
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ScopeRunner.java
package com.imooc.spring.scope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScopeRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:scope.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        UserService userService2 = (UserService)ctx.getBean(&quot;userService&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDAO.java   UserDAOImpl.java   UserService.java 与上方相同
</code></pre>
<h6 id="两个注解"><a href="#两个注解" class="headerlink" title="两个注解"></a>两个注解</h6><p><code>@Autowired</code>[第三方] 和 <code>@Resource</code>[官方推荐]</p>
<blockquote>
<p>@Resource(name&#x3D;”userDAO”) &#x2F;&#x2F;设置了则进行精准匹配<br>private UserDAO userDAO;&#x2F;&#x2F;没设置则优先将名字userDAO在beanId内查找, 再没有就按照UserDAO类型在IOC容器中查找</p>
</blockquote>
<h3 id="AOP有几种通知类型"><a href="#AOP有几种通知类型" class="headerlink" title="AOP有几种通知类型"></a>AOP有几种通知类型</h3><h6 id="在不修改原始程序的前提下使用通知来对程序进行扩展"><a href="#在不修改原始程序的前提下使用通知来对程序进行扩展" class="headerlink" title="在不修改原始程序的前提下使用通知来对程序进行扩展"></a>在不修改原始程序的前提下使用通知来对程序进行扩展</h6><ul>
<li><h6 id="前置通知-Before"><a href="#前置通知-Before" class="headerlink" title="前置通知[Before]"></a>前置通知[Before]</h6></li>
<li><h6 id="返回通知-After-returning"><a href="#返回通知-After-returning" class="headerlink" title="返回通知[After returning]"></a>返回通知[After returning]</h6></li>
<li><h6 id="异常通知-After-throwing"><a href="#异常通知-After-throwing" class="headerlink" title="异常通知[After throwing]"></a>异常通知[After throwing]</h6></li>
<li><h6 id="后置通知-After"><a href="#后置通知-After" class="headerlink" title="后置通知[After]"></a>后置通知[After]</h6></li>
<li><h6 id="环绕通知-Around-统统实现"><a href="#环绕通知-Around-统统实现" class="headerlink" title="环绕通知[Around] (统统实现)"></a><span style = "color:red">环绕通知[Around]</span> (统统实现)</h6></li>
</ul>
<pre><code class="java">SampleAspect.java
package com.imooc.spring.aop;

import java.util.Date;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;

//切面类
public class SampleAspect &#123;
    
    //1.前置通知
    public void doBefore(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        Object args = jp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
    &#125;
    
    //2.后置通知
    public void doAfter(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method );

    &#125;
    
    //3.返回通知
    public void doAfterReturning(JoinPoint jp , Object ret)&#123;
        System.out.println(&quot;【返回后通知】&quot; + ret);
        
    &#125;
    //4.异常通知
    public void doAfterThrowing(JoinPoint jp , Throwable t)&#123;
        System.out.println(&quot;【异常通知】&quot; + t.getMessage());
    &#125;

    //5.环绕通知
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable&#123;
        String clzName = pjp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = pjp.getSignature().getName();//即将要执行的方法
        Object args = pjp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
        Object ret = null;
        try &#123;
            ret = pjp.proceed();//执行目标方法
            System.out.println(&quot;【返回后通知】&quot; + ret);
        &#125; catch (Throwable t) &#123;
            // TODO Auto-generated catch block
            System.out.println(&quot;【异常通知】&quot; + t.getMessage());
            throw t;
        &#125;finally&#123;
            System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method + &quot;()&quot;);
        &#125;
        return ret;
    &#125;
    
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;

    public String createUser()&#123;
        //打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //提交事务
        //catch块中回滚事务 - RuntimeException
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">AOPRunner.java
package com.imooc.spring.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:aop.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        userService1.createUser();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">aop.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd
 http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 定义类被Spring IOC容器管理 --&gt;
    &lt;bean name=&quot;sampleAspect&quot; class=&quot;com.imooc.spring.aop.SampleAspect&quot;&gt;&lt;/bean&gt;
    &lt;bean name=&quot;userService&quot; class=&quot;com.imooc.spring.aop.UserService&quot;&gt;&lt;/bean&gt;
    &lt;!-- 配置Spring AOP --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置过程中引用切面类  sampleAspect是切面 扩展--&gt;
        &lt;aop:aspect ref=&quot;sampleAspect&quot;&gt;
            &lt;!-- PointCut(切点) 限制了切面应用的范围 ↓↓aop作用了哪些方法上↓↓--&gt;
            &lt;aop:pointcut id=&quot;samplePC&quot; expression=&quot;execution(* com.imooc.spring.aop.*Service.create*(..))&quot; /&gt;
            &lt;!-- 定义通知 --&gt;
            &lt;!-- 前置通知 method=对应着SampleAspect.java中的doBefore--&gt;
            &lt;aop:before pointcut-ref=&quot;samplePC&quot; method=&quot;doBefore&quot;/&gt;
            &lt;!-- 后置通知 --&gt;
            &lt;aop:after pointcut-ref=&quot;samplePC&quot; method=&quot;doAfter&quot;/&gt;
            &lt;!-- 返回后通知，注意：返回后通知需要增加retruning属性
            指向doAfterReturning的名为ret的参数，使用ret参数获取方法的返回值 --&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; pointcut-ref=&quot;samplePC&quot; returning=&quot;ret&quot;/&gt; 
&lt;!--3.ret是返回通知里面的参数 public void doAfterReturning(JoinPoint jp , Object ret)--&gt;
             &lt;!-- 异常通知 --&gt;
&lt;!--public void doAfterThrowing(JoinPoint jp , Throwable t)中的Throwable的参数是目标方法所抛出的异常  throwing=&quot;t&quot;相关噢~ --&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; pointcut-ref=&quot;samplePC&quot; throwing=&quot;t&quot;/&gt;
            --&gt;
            &lt;!-- ★★★★ 环绕通知 ★★★★ --&gt;
            &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;samplePC&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="请介绍Spring的声明式事务"><a href="#请介绍Spring的声明式事务" class="headerlink" title="请介绍Spring的声明式事务"></a>请介绍Spring的声明式事务</h3><p>Spring的声明式事务是Spring框架提供的一种管理事务的方法，它允许开发者通过声明的方式管理事务，而不是通过编写繁琐的事务管理代码。这种方式使得事务管理更加解耦，业务逻辑代码不需要直接处理事务的开启、提交、回滚等操作，从而使得代码更加简洁和易于维护。</p>
<ul>
<li>在执行方法前自动开启的事务</li>
<li>声明式事务式指利用AOP自动提交、回滚数据库事务</li>
<li>声明式事务式规则进入方法打开事务，成功提交，<strong>运行时异常</strong>回滚</li>
<li><code>@Transactional</code>是声明式事务的注解 放在类上则所有方法执行此事务 放在方法上则单独方法执行此事务</li>
<li>propagation &#x3D; 确定方法是否启动事务[Propagation.REQUIRED]执行的方法自动使用事务<br>rollbackFor &#x3D; Exception.class在什么时机进行回滚  readOnly &#x3D; true 方法只读</li>
<li>通过程序打开或关闭事务属于<strong>编程式事务</strong></li>
</ul>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;
    public String createUser()&#123;
        //进入方法 → 打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //方法执行成功 → 提交事务
        
        //方法抛出运行时异常 → 回滚事务
        //catch块中回滚事务 - RuntimeException[及其子类会自动回滚]
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="使用SpringMVC实现REST风格"><a href="#使用SpringMVC实现REST风格" class="headerlink" title="使用SpringMVC实现REST风格"></a>使用SpringMVC实现REST风格</h3><ul>
<li>REST(表述性状态传递)以URL表示要访问的资源</li>
<li><strong>GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</strong>对应<strong>查询、新增、更新、删除</strong>操作[浏览器不支持PUT和DELETE操作]<br><span style = "color:red"><strong>[用GET对应查询操作(写)、用POST对应新增、更新、删除操作(写)]</strong></span></li>
<li><u>REST风格<strong>只响应的数据</strong>，通常是以JSON形式体现</u></li>
</ul>
<p>以下是一些常用的HTTP方法及其在REST中的用途：</p>
<ul>
<li><strong>GET</strong>：检索资源的表示。</li>
<li><strong>POST</strong>：创建新的资源或子资源。</li>
<li><strong>PUT</strong>：更新或替换资源。</li>
<li><strong>DELETE</strong>：删除资源。</li>
</ul>
<p>REST风格的API通常被称为RESTful API，它们通过使用标准的HTTP方法、状态代码和URI来提供一种简单、一致和可预测的方式来访问和操作网络资源。RESTful API的设计通常遵循一些最佳实践，比如使用名词而不是动词来命名资源，使用HTTP状态码来传达操作的结果等。</p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.54&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">interview-springmvc\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 配置扫描的包 --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.interview&quot;/&gt;
    &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 开启注解模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.rest;

public class Employee &#123;
    private String name;
    private int age;
    private String department;

    public Employee(String name, int age, String department) &#123;
        this.name = name;
        this.age = age;
        this.department = department;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getDepartment() &#123;
        return department;
    &#125;

    public void setDepartment(String department) &#123;
        this.department = department;
    &#125;
&#125;
</code></pre>
<pre><code class="java">RestfulController.java
package com.imooc.interview.rest;

import com.alibaba.fastjson.JSON;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
@Controller //在IOC容器初始化的情况下自动扫描这个类进行加载并且通知IOC容器 这个是一个MVC中的控制类
//@RestController
public class RestfulController &#123; //&#123;XXX&#125;是路径变量 随时产生变化的 注解@PathVariable(&quot;DEPT&quot;)
    @GetMapping(&quot;/emp/list/&#123;DEPT&#125;&quot;) //响应GET请求 前面的是响应URL输入这个的时候响应下面的方法
    @ResponseBody
    public String list(@PathVariable(&quot;DEPT&quot;) String department) &#123;
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        if (department.equals(&quot;RESEARCH&quot;)) &#123;
            list.add(new Employee(&quot;JAMES&quot;, 38, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;ANDY&quot;, 23, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;SMITH&quot;, 31, &quot;RESEARCH&quot;));
        &#125;
        return JSON.toJSONString(list);//只返回纯粹的JSON数据 只返回页面名称
        //如何只返回数据不跳转页面呢？ 用 @RespondBoday 直接将返回的数据输出到客户端
//但是可以简化使用 @RestController 所有的可以直接不用写 @RespondBoday
    &#125;
&#125;//前端使用AJAX技术接收数据
</code></pre>
<h3 id="请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术"><a href="#请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术" class="headerlink" title="请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]"></a>请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]</h3><ul>
<li>SpringMVC拦截器用于对控制器方法进行前置、后置处理</li>
<li>拦截器的底层实现技术是AOP(面向切面编程)</li>
<li>拦截器必须实现HandlerInterceptor接口</li>
</ul>
<pre><code class="java">★★ 上一个代码通用 ★★
interview-springmvc\src\main\java\com\imooc\interview\rest\MyInterceptor.java
package com.imooc.interview.rest;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.logging.Logger;

public class MyInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;进入 preHandle 方法...&quot; + request.getRequestURL().toString());
        return true;
    &#125;
 

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;进入 postHandle 方法...&quot; + request.getRequestURL().toString());
    &#125;
 

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;进入 afterCompletion 方法...&quot; + request.getRequestURL().toString());
    &#125;
&#125;
====================================================================================
查看上面的applicationContext.xml
&lt;bean&gt;
&lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt; 
            //对上面这个类进行处理和拦截
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bfd26ff021aa3755cfc43c62bfa86e0b3ef77144/data/SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<h3 id="说明Mybatis的开发过程"><a href="#说明Mybatis的开发过程" class="headerlink" title="说明Mybatis的开发过程"></a>说明Mybatis的开发过程</h3><blockquote>
<p>案例沿用之前的scott.sql表</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
             
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-mybatis&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.46&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">mybatis.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;!-- 配置数据库连接信息 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接池的方式--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/scott&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.mybatis.entity;

import java.io.Serializable;
import java.util.Date;

public class Employee implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Float sal;
    private Float comm;
    private Integer deptno;
&#125;Getter + Setter
</code></pre>
<pre><code class="xml">用于查询的配置文件 emp.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- 命名空间是个虚拟的类 --&gt;
&lt;mapper namespace=&quot;com.imooc.interview.mybatis.mapper.EmpMapper&quot;&gt; 
    &lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
        select * from emp
    &lt;/select&gt;
&lt;!-- 类型是int 把传入的int代入到#&#123;value&#125;中 --&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; 
            resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;true&quot;&gt;
        select * from emp where empno = #&#123;value&#125;
&lt;!--查询数据 根据数据自动创建Employee对象 根据字段名把值一一的设置到属性中--&gt;
&lt;!--记得写完以后再mybatis.xml中注册 通知mybatis 有个&lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;--&gt;
&lt;!--至此mybatis的配置全部完成 --&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">MybatisRunner.java
package com.imooc.interview.mybatis.entity;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class MybatisRunner &#123;
    public static void main(String[] args) &#123;
        //mybatis的配置文件 核心配置文件↓
        String resource = &quot;mybatis.xml&quot;;
        InputStream is = MybatisRunner.class.getClassLoader().getResourceAsStream(resource);
        //构建sqlSession的工厂(对Mybatis进行解析)  build(is)是初始化
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);
//com.imooc.interview.mybatis.mapper.EmpMapper前面是命名空间
        //.findById对应着select的Id
        String statement = &quot;com.imooc.interview.mybatis.mapper.EmpMapper.findById&quot;;
        SqlSession session = sessionFactory.openSession();
//selectOne获取唯一的查询结果  之前定义了要传入整数int
        Employee emp1 = session.selectOne(statement, 7566);
        System.out.println(emp1);
        session.close();
    &#125;
&#125;
</code></pre>
<h3 id="Mybatis的缓存机制"><a href="#Mybatis的缓存机制" class="headerlink" title="Mybatis的缓存机制"></a>Mybatis的缓存机制</h3><h6 id="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"><a href="#把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率" class="headerlink" title="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"></a>把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率</h6><ul>
<li><p>Mybatis存在两级缓存</p>
<ul>
<li><p>一级缓存与SqlSession会话绑定，默认开启 [巨大的HashMap] [默认开启]</p>
</li>
<li><p>二级缓存是应用全局缓存，所有SqlSession共享 [分布式数据库等]</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">//一级缓存验证结果
Employee emp1 = session.selectOne(statement, 7566);
Employee emp2 = session.selectOne(statement, 7566);
System.out.println(emp1);
System.out.println(emp2);
======================打印结果========================
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
从缓存中将这个7566提出来，所以对象是一样的
随着session的关闭 → session.close(); 一级缓存也随着消失; 输出的对象结果就不相同了
</code></pre>
<pre><code class="java">//二级缓存验证结果  让7566全局缓存 默认是不开启的 需要在mapper中开启 → emp.xml
//在缓存中最大容纳512个对象 缓存多余清除策略[FIFO先进先出算法 LRU访问最少的对象清除] 
//flushInterval=&gt;时间间隔定时清理缓存[毫秒数 每60秒]
&lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
//若对全部查找 则不适合使用缓存 因为每次都变化 这样就可以设置useCache=&quot;false&quot;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
//对数据进行新增、修改、删除也会对缓存进行强制更新 上面设置 readOnly=&quot;true&quot; 保存在缓存中的数据都是只读的
//二级缓存要对工具类Employee进行接口的实现
public class Employee implements Serializable &#123;...&#125;
</code></pre>
<h3 id="Spring、SpringMVC与SpringBoot的区别"><a href="#Spring、SpringMVC与SpringBoot的区别" class="headerlink" title="Spring、SpringMVC与SpringBoot的区别"></a>Spring、SpringMVC与SpringBoot的区别</h3><ul>
<li>Spring是所有应用的基础，提供了IOC与AOP特性实现对对象轻松的管理</li>
<li>SpringMVC是Spring的子项目用于提供Web支持 替代传统的Servlet [<u>提高兼容性和可维护性</u>]</li>
<li>SpringBoot是Spring体系的敏捷开发框架，提高了开发效率 [<u>对Spring整个体系都有良好的支撑</u>]<ul>
<li>Spring Framework是整个Spring的框架基础</li>
<li>Spring Cloud对分布式架构与微服务提供了良好的支持</li>
<li>Spring Data简化关系型数据库 非关系型数据库 大数据源</li>
<li>Spring Batch提供高效率的批处理任务</li>
<li>Spring Security超级牛逼的安全框架 登录验证之类的</li>
<li>Spring Amqp消息队列进行支持 统一的接口进行适配</li>
<li>Spring Mobile手机开发特性</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h3><ul>
<li><p>Spring Initializr是创建SpringBoot Project的唯一方法吗？</p>
<blockquote>
<p>否！也可以用Maven进行手动创建，也可以官网创建</p>
</blockquote>
</li>
<li><p>SpringBoot支持几种配置文件？</p>
<blockquote>
<p>只有两种</p>
<pre><code class="xml">一种
server.port=80
debug=false
server.servlet.context-path=/myspringboot
logging.file=d:/logs/msb.log
spring.mvc.date-format=yyyy-MM-dd
</code></pre>
<pre><code class="xml">二种 [按层级进行区分 yml 对程序维护有很大帮助]
debug:false
server:
  port:8000
  servlet:
    context-path:/
spring:
  mvc:
    date-format:yyyy-MM-dd
</code></pre>
</blockquote>
</li>
<li><p>请列举至少五个SpringBoot中配置选项</p>
<table>
<thead>
<tr>
<th>配置名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>server.port</td>
<td>8080</td>
<td>端口号</td>
</tr>
<tr>
<td>server.servlet.context-path</td>
<td>&#x2F;</td>
<td>设置应用上下文</td>
</tr>
<tr>
<td>logging.file</td>
<td>无</td>
<td>日志文件输出路径</td>
</tr>
<tr>
<td>logging.level</td>
<td>info</td>
<td>最低日志输出级别</td>
</tr>
<tr>
<td>debug</td>
<td>false</td>
<td>开启&#x2F;关闭调试模式</td>
</tr>
<tr>
<td>spring.datasource.*</td>
<td></td>
<td>与数据库相关的设置</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Maven的构建生命周期"><a href="#Maven的构建生命周期" class="headerlink" title="Maven的构建生命周期"></a>Maven的构建生命周期</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mvn archetype:generate</td>
<td align="center">创建Maven工程构建</td>
</tr>
<tr>
<td align="center">mvn validate</td>
<td align="center">验证工程结构</td>
</tr>
<tr>
<td align="center">mvn compile</td>
<td align="center">编译源代码</td>
</tr>
<tr>
<td align="center">mvn test</td>
<td align="center">执行测试用例</td>
</tr>
<tr>
<td align="center">mvn package</td>
<td align="center">项目打包</td>
</tr>
<tr>
<td align="center">mvn install</td>
<td align="center">安装至本地仓库</td>
</tr>
<tr>
<td align="center">mvn deploy</td>
<td align="center">发布至远程仓库</td>
</tr>
</tbody></table>
<h3 id="请简述一下Java反射的作用和原理"><a href="#请简述一下Java反射的作用和原理" class="headerlink" title="请简述一下Java反射的作用和原理"></a>请简述一下Java反射的作用和原理</h3><p><strong>作用：</strong><br>Java反射(Reflection)允许程序在运行时检查和操作类、接口、字段和方法的信息<br>① 动态获取类的信息：获取类的名称、父类、实现的接口等；获取类的构造方法、字段和方法的信息<br>② 动态创建和访问对象：创建类的实例；访问和修改对象的字段；调用对象的方法<br>③ 动态调用方法：调用私有方法、静态方法、实例方法等；传递参数和处理返回值<br>④ 动态代理：创建动态代理类，实现接口和动态代理</p>
<p><strong>原理：</strong><br>① 获取Class对象：<br>   Ⅰ. 通过类名获取：Class.forName(“类的路径”)；<br>  Ⅱ. 通过类字面常量获取：类名.class；<br> Ⅲ. 通过对象获取：对象名.getClass();<br>② 获取类的信息：<br>   Ⅰ. 获取类名：类名.getName;<br>  Ⅱ. 获取父名：类名.getSuperclass();<br> Ⅲ. 获取实现的接口：类名.getInterfaces();<br> Ⅳ. 获取构造方法：类名.getConstructors();<br>  Ⅴ. 获取字段：类名.getFields();<br> Ⅵ. 获取方法：类名.getMethods();</p>
<p><strong>优点和缺点</strong>：<br>优点：能够运行时动态获取类的实例，提高灵活性；与动态编译结合<br>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析<br>  解决办法→通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时有缓存会快很多</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>；；；；；；；；；；；；；；；；；；；；<strong>洪哥面试题分隔符</strong>；；；；；；；；；；；；；；；；；；；；；；</p>
<h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.继承Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.实现Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。<br>3.实现 Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。<br>4.使用线程池创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li>异步任务处理：将任务提交到线程池异步执行，而不阻塞主线程</li>
</ul>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在URL之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，敏感数据不应通过过GET请求发送</li>
<li>URL长度限制通常在2000个字符左右，这意味着GET请求能够传输的数据有限</li>
<li>可以被缓存，也会被浏览器保存在历史记录中</li>
<li>常用于信息查询、数据检索等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上没有大小限制，适用于传输大量数据.</li>
<li>不会被缓存，且不会保存在浏觉器历史记录中</li>
<li>常用于数据提交、表单提交等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br>发展前景？表明上家公司不好<br>太想进步？表名上家公司提供的技术不好 自己技术不好<br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据属性名称去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据属性类型去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和@Autowired类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> 不可多个方法都加@Autowired  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
</li>
<li><p><strong>普通方法注入</strong></p>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时且数组长度大于64时，将链表转化为红黑树，以减少搜索时间。扩容 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对数组长度取模 eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcde值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是hash冲突  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单项链表[linkedlist才是双向链表]。拉链法的解决哈希冲突。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高，</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p>底层是包装了一个hashmap，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。计算hashcode会比equals更快，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，所以先判断hashcode 再判断equals   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个 ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用ConcurrentHashMap、Collections.synchronizedMap()、<strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>hashtable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了ConcurrentHashMap读不加锁 写加锁。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是log(n)<br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p>WebSocket【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component<br>定义切点 <code>@Pointcut</code> 声明切点表达式</p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.BigDecimal</p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

    @Autowired
    private MyService self; // 注入自身代理实例

    public void methodA() &#123;
        // ... 业务逻辑 ...

        self.methodB(); // 通过代理实例调用，事务注解将生效
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() &#123;
        // ... 业务逻辑 ...
    &#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><ul>
<li><strong>String</strong>：存储对象信息(转JSON)、</li>
<li><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构</li>
<li><strong>Hash</strong>：获取局部属性，小key不能设置过期时间</li>
<li><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)</li>
<li><strong>Zset</strong>：排序场景，排行榜，姓名排序</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除</li>
<li>定时删除：设置键的过期时间，当键过期时，立即删除</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br> [商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p>try catch 在里面继续再去查mysql数据库</p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中</p>
<ul>
<li><h6 id="JDK动态代理是基于接口实现来实现增强"><a href="#JDK动态代理是基于接口实现来实现增强" class="headerlink" title="JDK动态代理是基于接口实现来实现增强"></a>JDK动态代理是基于接口实现来实现增强</h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是基于继承目标类并覆写其方法来实现</h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的代理类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，有一些简单的需求是没有的[沟通成本太高了]<br>稍微复杂的需求会有需求文档，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当参数是用户输入时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会自动转义参数。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
</ul>
<h4 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚这个技术是解决什么领域的问题，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);
            getData(&quot;t1&quot;);
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);
            getData(&quot;t2&quot;);
        &#125;, &quot;t1&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p>成员变量是在jvm的堆<br>局部变量是在jvm的栈<br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行代码审查，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行单元测试，确保代码的功能正确无误。</li>
<li>进行代码优化，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，它将现实世界的事物抽象成程序中的对象。Java面向对象的主要特征包括：</p>
<ul>
<li>封装：将对象的属性和行为封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li>继承：允许子类继承父类的属性和行为，实现代码的复用。</li>
<li>多态：同一个接口可以有多个不同的实现，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较基本数据类型时，比较的是值；比较引用数据类型时，比较的是对象的内存地址。</li>
<li>equals：是Object类的一个方法，默认比较的是对象的内存地址。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：读多写少 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：写多读少 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br>**<u>工厂模式</u>**：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过递归调用来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><p>第一个是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br>第二个是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br>第三个是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。<br>第四个是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁</p>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p>insert不带查询筛选条件  上行锁<del>底层是索引，b+树底层叶子</del><br>update看where后面的条件 带索引加行锁<del>构建b+树</del> 不带索引的加表锁<br>表锁的速度比行锁速度快</p>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的基本数据类型和引用类型地址，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于启动一个新线程，并执行该线程的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并不会启动一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程暂停执行并释放当前对象上的锁，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是基于内存的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持数据持久化，可以将内存中的数据保存到磁盘中，防止数据丢失。<br><strong>分布式</strong>：Redis支持主从复制、哨兵和集群模式，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，服务消费者，注册中心，服务提供者提供者在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务，默认为轮询，还有加权轮询，随机。同时服务消费者还会定时去注册中心拉取服务提供者的信息如果我们的服务挂掉了怎么办?<br>服务提供者会每隔一段时间去向注册中心报告自己的状态，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><strong>公平锁</strong>：多个线程按照它们请求锁的顺序来获取锁，先来先得。这种方式不会产生饥饿现象，但可能会降低吞吐量，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></li>
<li><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></li>
</ul>
<p>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持<br>Synchronized 公平锁</p>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java 动态代理技术，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证可见性和有序性。</p>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的<br>定义了一个并发情况下一些抽象的资源 资源能否共享&#x2F;独享 定义了公平和非公平<br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p>一段很长的时间内都只被一个线程使用锁 <strong>偏向锁</strong><br>有线程交替或线程加锁的时间是错开的 <strong>轻量级锁</strong><br>有很多线程来抢 <strong>重量级锁</strong></p>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是用对象头找个地方存一把锁，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(自旋锁64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以自动加锁和解锁，而 <code>ReentrantLock</code> 需要手动加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方，分别锁的是什么"><a href="#synchronized可以作用在哪些地方，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方，分别锁的是什么"></a>synchronized可以作用在哪些地方，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>