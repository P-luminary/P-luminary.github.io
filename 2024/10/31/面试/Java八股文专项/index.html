
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java面试专项</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java面试专项 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/31
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/面试" style=color:#879cff>
                    面试
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h6 id="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"><a href="#我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？" class="headerlink" title="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"></a><span style = "color:red">我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？</span></h6><ul>
<li>验证你项目场景的真实性，二是为了深入发问的切入点</li>
<li><strong>缓存</strong> 缓存三兄弟(穿透、击穿、雪崩)、双写一致、持久化、数据过期策略、数据淘汰策略</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li><strong>消息队列、延迟队列</strong> 何种数据类型</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><p><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong><br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</p>
</li>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p><strong>bitmap（位图）</strong>：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大    </p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给<strong>某一个key设置了过期时间</strong>，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[不设置过期时间] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】<br>也可以搞个<u><strong>永不过期</strong></u> 具体是先在业务里写好某种情况下 某些时候不会过期 比如疫情卖口罩时期</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值</li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<pre><code class="java">《缓存三兄弟》
穿透无中生有key，布隆过滤null隔离。
缓存击穿过期key，锁与非期解难题。
雪崩大量过期key，过期时间要随机。
面试必考三兄弟，可用限流来保底。
</code></pre>
<h6 id="redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性"><a href="#redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性" class="headerlink" title="redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)"></a><span style = "color:red">redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)</span></h6><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行</p>
<p><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。<br>或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】</p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知</strong>&#x3D;&#x3D;： <u>异步通知保证数据的最终一致性</u>(需要保证<strong>MQ</strong>的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先<u>将数据写入Redis</u>，然后通过<u>异步通知机制触发数据库的更新</u>操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h6 id="Redis作为缓存，数据的持久化是怎么做的？"><a href="#Redis作为缓存，数据的持久化是怎么做的？" class="headerlink" title="Redis作为缓存，数据的持久化是怎么做的？"></a><span style = "color:red">Redis作为缓存，数据的持久化是怎么做的？</span></h6><p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h6 id="假如Redis的key过期之后，会立即删除吗"><a href="#假如Redis的key过期之后，会立即删除吗" class="headerlink" title="假如Redis的key过期之后，会立即删除吗"></a><span style = "color:red">假如Redis的key过期之后，会立即删除吗</span></h6><p>Redis对数据设置数据的有效时间，数据过期以后就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略(数据过期策略)</p>
<p>&#x3D;&#x3D;<strong>Redis数据删除策略-惰性删除</strong>&#x3D;&#x3D;</p>
<p>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p>
<pre><code class="mysql">set name zhangsan 10
get name # 发现name过期了，直接删除key
</code></pre>
<p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不会浪费时间进行过期检查<br><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p>
<p><strong>&#x3D;&#x3D;Redis数据删除策略-定期删除&#x3D;&#x3D;</strong></p>
<p>定期删除：每隔一段时间，我们就会对一些key进行检查，删除里面过期的key (从一定数量的数据库中取出一定数量的<strong>随机key</strong>进行检查，并删除其中的过期key)</p>
<p><strong>定期清理的两种模式：</strong></p>
<ul>
<li><strong>SLOW模式</strong>是定时模式，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件<code>redis.conf</code>的hz选项来调整这个次数</li>
<li><strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存<br><strong>难点：</strong>难以确定删除操作执行的时长和频率</p>
<p><strong>Redis过期删除策略：</strong> <strong><u>惰性删除 + 定期删除</u></strong> 两种策略进行配合使用</p>
<h6 id="假如缓存过多，内存是有限的，内存被占满了怎么办？"><a href="#假如缓存过多，内存是有限的，内存被占满了怎么办？" class="headerlink" title="假如缓存过多，内存是有限的，内存被占满了怎么办？"></a><span style = "color:red">假如缓存过多，内存是有限的，内存被占满了怎么办？</span></h6><p>&#x3D;&#x3D;<strong>数据淘汰策略</strong>&#x3D;&#x3D;</p>
<p>当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据制除掉，这种数据的制除规则被称之为内存的淘汰策略</p>
<p><strong>Redis支持8种不同策略来选择要删除的key:</strong></p>
<ul>
<li><p><strong>noeviction：</strong>不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong></p>
<blockquote>
<h6 id="maxmemory-policy-noeviction"><a href="#maxmemory-policy-noeviction" class="headerlink" title="maxmemory-policy noeviction"></a>maxmemory-policy noeviction</h6></blockquote>
</li>
<li><p><strong>volatile-ttl</strong>：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰 (<u>TTL:过期时间的key</u>)</p>
</li>
<li><p><strong>allkeys-random</strong>：对全体key，随机进行淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：对设置了TTL的key，随机进行淘汰</p>
</li>
<li><p><strong>allkeys-lru</strong>：对全体key，基于LRU算法进行淘汰</p>
<blockquote>
<p><strong>LRU</strong>(Least <strong>Recently</strong> Used)：<strong>最近最少使用</strong>，用当前时间减去最后一次访问时间，这个值越大测淘汰优先级越高 [逐出访问时间最少的]<br><strong>LFU</strong>(Least <strong>Frequently</strong> Used)：<strong>最少频率使用</strong>。会统计每个key的访问频率，值越小淘汰优先级越高。[逐出频率最低的] 【电商会应用】</p>
</blockquote>
</li>
<li><p><strong>allkeys-lfu</strong>：对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p><strong>volatile-lfu</strong>：对设置了TTL的key，基于LFU算法进行淘汰</p>
</li>
</ul>
<p><strong>淘汰策略 - 使用建议</strong></p>
<p>1.优先使用 <code>allkeys-lru</code> 策略。充分利用LRU算法的优势，把最近最常访问的数据留在缓存中，如果业务有明显的冷热数据区分，建议使用。<br>2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用<code>allkeys-random</code>，随机选择淘汰<br>3.如果业务中有置顶的需求，可以使用<code>volatile-lru</code>策略，同时<strong>置顶数据不设置过期时间</strong>，这些数据就一直不会被删除，会淘汰其他设置过期时间的数据<br>4.如果业务中有<strong>短时高频</strong>访问的数据，可以使用<code>allkeys-lfu</code>或<code>volatile-lfu</code>策略</p>
<h6 id="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"><a href="#数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？" class="headerlink" title="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"></a>数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？</h6><ul>
<li>使用<code>allkeys-lru</code>(挑选最近最少使用的数据淘汰) 淘汰策略，留下来的都是经常访问的热点数据</li>
</ul>
<h6 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h6><ul>
<li>主要看数据淘汰策略是什么？如果是默认的配置(noeviction)，会直接报错</li>
</ul>
<h6 id="redis分布式锁，是如何实现的？"><a href="#redis分布式锁，是如何实现的？" class="headerlink" title="redis分布式锁，是如何实现的？"></a><span style = "color:red">redis分布式锁，是如何实现的？</span></h6><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题<br><img src="https://raw.githubusercontent.com/P-luminary/images/0f81d6fe238b4774d88facda4329c5ebe4921aa0/Redis%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg"></p>
<p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写<br>在同一时刻，只有一个线程&#x2F;进程&#x2F;服务节点能拿到锁，执行关键代码。其他的只能等或者失败退出。</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、PX是设置超时时间<br><strong>SET lock value NX PX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h6 id="Redis实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redis实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redis实现分布式锁如何合理的控制锁的有效时长？"></a><span style = "color:red">Redis实现分布式锁如何合理的控制锁的有效时长？</span></h6><ul>
<li>根据业务执行时间预估</li>
<li><strong>给锁续期</strong></li>
</ul>
<h5 id="你“自己用-Redis-实现分布式锁”-vs-用-Redisson-实现锁-——-有哪些区别？"><a href="#你“自己用-Redis-实现分布式锁”-vs-用-Redisson-实现锁-——-有哪些区别？" class="headerlink" title="你“自己用 Redis 实现分布式锁” vs 用 Redisson 实现锁 —— 有哪些区别？"></a>你“自己用 Redis 实现分布式锁” vs 用 <strong>Redisson</strong> 实现锁 —— 有哪些区别？</h5><table>
<thead>
<tr>
<th>对比点</th>
<th>手动实现（自己用 Redis 命令）</th>
<th>✅ Redisson 实现</th>
</tr>
</thead>
<tbody><tr>
<td>🛠 实现方式</td>
<td>使用 <code>SET key value NX PX</code>、<code>GET</code> + <code>DEL</code></td>
<td>内部封装好，直接调用 <code>.lock()</code>、<code>.unlock()</code></td>
</tr>
<tr>
<td>🔐 安全性</td>
<td>容易写错，不易保证“<strong>只有加锁者能解锁</strong>”</td>
<td>Redisson 自动做到了“加锁者才能解锁”</td>
</tr>
<tr>
<td>💣 死锁处理</td>
<td>自己必须手动加过期时间（PX），否则会死锁</td>
<td>自动设置超时时间，支持 watchdog 自动续命</td>
</tr>
<tr>
<td>🧵 可重入锁</td>
<td>不支持，需要自己实现复杂逻辑</td>
<td>✅ 内建支持可重入锁（ReentrantLock）</td>
</tr>
<tr>
<td>⚠ 主从不一致</td>
<td>Redis 主从复制延迟下可能“锁丢失”</td>
<td>Redisson 有 RedLock 模式，可用多个实例容错</td>
</tr>
<tr>
<td>🚦 阻塞等待</td>
<td>需要自己写轮询逻辑（比如 while循环）</td>
<td>✅ Redisson 支持阻塞、等待、超时等参数</td>
</tr>
<tr>
<td>⏱ 自动续租</td>
<td>没有，需要自己定时续约</td>
<td>✅ 有“看门狗机制”自动续租防止业务太长释放锁</td>
</tr>
<tr>
<td>🔁 分布式支持</td>
<td>支持有限，自己写 RedLock 非常麻烦</td>
<td>✅ 内置 RedLock、联锁、多锁等高级功能</td>
</tr>
<tr>
<td>✅ 使用体验</td>
<td>复杂，代码易错</td>
<td>✅ 简单、线程安全、功能全面</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;<br>✅ 只有在 <strong>你没指定超时时间</strong> 时，Watchdog 才会自动开启</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="要加依赖"><a href="#要加依赖" class="headerlink" title="要加依赖"></a>要加依赖</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="❌-如果你这样写："><a href="#❌-如果你这样写：" class="headerlink" title="❌ 如果你这样写："></a>❌ 如果你这样写：</h3><pre><code class="java">lock.lock(10, TimeUnit.SECONDS);
</code></pre>
<p>就不会有自动续命，看门狗不会工作。这种锁就是严格 10 秒后自动释放，不管你业务是否完成。</p>
<h3 id="🔄-Watchdog-自动续命流程图"><a href="#🔄-Watchdog-自动续命流程图" class="headerlink" title="🔄 Watchdog 自动续命流程图"></a>🔄 Watchdog 自动续命流程图</h3><pre><code class="yaml">lock.lock() 被调用
     ↓
Redisson 设置锁为30秒过期
     ↓
启动看门狗线程，每10秒刷新一次锁 TTL
     ↓
如果线程还持有锁 → Redis.expire(lockKey, 30秒)
     ↓
直到 unlock() 调用 → 结束看门狗 + 删除锁
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责 <strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h6 id="Redis集群有哪些方案？"><a href="#Redis集群有哪些方案？" class="headerlink" title="Redis集群有哪些方案？"></a><span style = "color:red">Redis集群有哪些方案？</span></h6><ul>
<li><p>&#x3D;&#x3D;<strong>主从复制</strong>&#x3D;&#x3D; </p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离<br><u>主节点写操作→增删改</u>     <u>从节点读操作→查</u></p>
<h6 id="介绍一下redis的主从同步"><a href="#介绍一下redis的主从同步" class="headerlink" title="介绍一下redis的主从同步"></a><span style = "color:red">介绍一下redis的主从同步</span></h6><blockquote>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p>
</blockquote>
<p><strong>主从数据同步原理：</strong></p>
<ul>
<li><span style="color:blue"><u>主从<strong>全量同步</strong></u>：</span></li>
</ul>
<p>slave从节点执行<code>replicaof</code>命令建立链接 → 请求master主节点数据同步(<u>replid+offset</u>) → master判断是否是第一次同步(判断replid是否一致) → 是第一次, 返回master的数据版本信息(<u>replid+offset</u>)  → slave保存版本信息 → master执行<strong>bgsave</strong>, 生成RDB → 发送RDB文件给slave → slave清空本地数据加载RDB数据 → 此时master记录RDB期间所有命令<code>repl_balklog</code> → 发送repl_backlog中的命令 → slave执行接收到的命令</p>
<p><strong>Replication ld</strong>: 简称<u>replid</u>，是数据集的标记，id一致则说明是同一<strong>数据集</strong>。每一个master都有唯一的replid,slave则会继承master节点的replid<br><strong>offset</strong>: 偏移量，随着记录在repl baklog中的数据增多而逐渐增大。save完成同步时也会记录当前同步的offset，<strong>如果slave的offset小于master的offset，说明slave数据落后于master</strong>，需要更新。</p>
<blockquote>
<p>简述全量同步的流程？</p>
<p>• slave节点请求增量同步</p>
<p>• master节点判断replid，发现不一致，拒绝增量同步</p>
<p>• master将完整内存数据生成RDB，发送RDB到slave</p>
<p>• slave清空本地数据，加载master的RDB</p>
<p>• master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p>
<p>• slave执行接收到的命令，保持与master之间的同步</p>
</blockquote>
<p><span style = "color:red"><strong>能说一下，主从同步数据的流程吗？</strong></span></p>
<p><span style="color:pink"><strong>全量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据(replication id、offset)<br>2.主节点判断是否为第一次请求，是第一次就与从节点同步版本信息(replication id和offset)<br>3.主节点执行bgsave, 生成RDB文件后, 发送给从节点去执行<br>4.在RDB生成执行期间, 主节点会从命令的方式记录到缓冲区(日志文件)</p>
</blockquote>
<ul>
<li><span style="color:blue"><u>主从<strong>增量同步</strong></u></span><br>主从增量同步(slave重启或后期数据变化)</li>
</ul>
<p>① slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 是第一次, 返回主节点replid和offset → 保存版本信息<br>② slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 不是第一次, 回复continue向slave → master 去repl_baklog中<strong>获取offset后的数据</strong> → 发送offset后的命令给slave → 执行命令</p>
<p><span style="color:pink"><strong>增量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值<br>2.主节点从命令日志中获取offset值后的数据，发送给节点进行数据同步</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>简述全量同步和增量同步区别？</p>
<p>•全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p>
<p>•增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</p>
<p>什么时候执行全量同步？</p>
<p>•slave节点第一次连接master节点时</p>
<p>•slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</p>
<p>什么时候执行增量同步？</p>
<p>•slave节点断开又恢复，并且在repl_baklog中能找到offset时</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>哨兵模式</strong>&#x3D;&#x3D;<del>搭过集群，具体多少个节点是组长那边，不太清楚</del>[并发量不是太多 搭哨兵可以节省一点资源]~<br>Redis提供了<strong>哨兵</strong>(Sentinel)机制来实现主从集群的自动故障恢复</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为一个master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<p><span style="color:blue"><strong>服务状态监控</strong></span><br>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令 <code>期待回复pong</code></p>
<ul>
<li><strong>主观下线</strong>：如果某sentinel节点发现或某实例未在规定时间相应，则认为该实例<strong>主观下线</strong></li>
<li><strong>客观下线</strong>：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>，quorum值最好超过Sentinel实例数量的一半</li>
</ul>
<p><span style="color:blue"><strong>哨兵选主规则</strong></span></p>
<ul>
<li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li>
<li>然后判断从节点的slave-priority值，越小优先级越高</li>
<li><strong><u>如果slave-priority值一样，则判断slave节点的offset值，越大优先级越高</u></strong> (数据是最全的)</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<p><strong><span style="color:blue">redis集群(哨兵模式) 脑裂</span></strong><br>因网络问题 主节点和从节点分别在不同的网络分区 这样sentinel只会监控到一部分从节点网络分区 导致RedisClient继续写主节点的数据，这时网络恢复了，哨兵会将老的master强制降级到slave(携带着脑裂前的最新数据)，这个时候slave就会把自己数据清空去同步master数据，这时就存在真正的数据丢失了</p>
<p><strong>怎么解决</strong>？</p>
<blockquote>
<p>redis中有两个配置参数：【若不能达成就拒绝客户端请求 这样就会避免大量数据丢失】<br>min-replicas-to-write 1      <strong>表示最少的salve节点为1</strong><br>min-replicas-max-lag 5      <strong>表示数据复制和同步的延迟不能超过5秒</strong><br>达不到这两个条件就拒绝写入，从而避免数据丢失。</p>
</blockquote>
<p><span style = "color:red"><strong>怎么保证Redis的高并发高可用呢？</strong></span></p>
<blockquote>
<p>哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)</p>
</blockquote>
<p><span style = "color:red"><strong>你们使用redis是单点还是集群，哪种集群？</strong></span></p>
<blockquote>
<p>主从(1主1从) + 哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点</p>
</blockquote>
<p><span style = "color:red"><strong>redis集群脑裂，该怎么解决？</strong></span></p>
<blockquote>
<p><strong>集群脑裂</strong>是由于主节点和从节点和sentinel处于不同网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当为网络恢复后，sentinel会将老的主节点降为从节点，此时再从新master同步数据，就会导致数据丢失<br><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，这样就会避免大量数据丢失。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>分片集群</strong>&#x3D;&#x3D;</p>
<p>主从和哨兵可以解决高可用、高并发读的问题，但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可用解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可用有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<p><strong><span style="color:blue">分片集群结果 - 数据读写</span></strong></p>
<p>Redis分片集群引入了<strong>哈希槽</strong>的概念，Redis集群有16384个哈希值，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<blockquote>
<p>存数据流程：<br>set name itheima → CRC16计算name的hash值(666666) → 666666%16384&#x3D;11306 → 根据11306找寻所对应哈希槽的范围 并且插入数据</p>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群有什么用？</strong></span></p>
<blockquote>
<ul>
<li>集群中有多个master，每个master保存不同数据。(解决高并发<strong>写</strong>的问题)</li>
<li>每个master都可以有多个slave节点。(解决高并发<strong>读</strong>的问题)</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群中数据是怎么存储和读取的？</strong></span></p>
<blockquote>
<ul>
<li>Redis 分片集群引入了哈希槽的概念，Redis 集群有16384个哈槽</li>
<li>将16384个插槽分配到不同的实例</li>
<li>读写数据:根据key的**<u>有效部分</u>**计算哈希值，对16384取余(有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分)余数做为播槽，寻找插所在的实例</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="🚀-Redis-集群常见三种方式（解决不同问题）"><a href="#🚀-Redis-集群常见三种方式（解决不同问题）" class="headerlink" title="🚀 Redis 集群常见三种方式（解决不同问题）"></a>🚀 Redis 集群常见三种方式（解决不同问题）</h2><table>
<thead>
<tr>
<th>模式</th>
<th>主要解决问题</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>① 主从复制（+读写分离）</td>
<td><strong>读写压力分担</strong></td>
<td>一主多从，主写从读，不能自动故障转移</td>
</tr>
<tr>
<td>② 哨兵模式（Sentinel）</td>
<td><strong>高可用（自动故障转移）</strong></td>
<td>在主从基础上，Sentinel 实现监控、自动选主、通知客户端</td>
</tr>
<tr>
<td>③ 分片集群（Cluster）</td>
<td><strong>海量数据、高写吞吐</strong></td>
<td>数据分片+多主多从，每个主分管部分槽位（16384 slots）</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>Redis是单线程的，但是为什么还那么快</strong></span></p>
<blockquote>
<ul>
<li>Redis是<strong>纯内存操作</strong>，执行速度非常快</li>
<li>采用单线程，<strong>避免不必要的上下文切换</strong>可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用<strong>I&#x2F;O多路复用</strong>模型，非阻塞IO</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下I&#x2F;O多路复用模型？</strong></span></p>
<blockquote>
<p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li><p>是指利用单个线程来同时监听多个Socket ，并在某个Socket<strong>可读、可写</strong>时得到通知，从而避免无效的等待，充分利用CPU资源，目前的I&#x2F;O多路复用都是采用的epol模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要换个Socket来判断是否就绪，提升了性能</p>
</li>
<li><p><strong>Redis网络模型</strong>:</p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li><p>连接应答处理器</p>
</li>
<li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
</li>
<li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>用户空间和内核空间</strong>&#x3D;&#x3D;</p>
<ul>
<li>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></li>
<li><strong>用户空间</strong>只能执行受限的命令Ring3，而且不能直接调用系统资源必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令Ring0，调用一切系统资源</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p>
<ul>
<li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
</li>
<li><p><strong>常见的IO模型</strong></p>
<ul>
<li><p><strong>&#x3D;&#x3D;阻塞IO&#x3D;&#x3D;</strong></p>
<p>阻塞IO就是两个阶段都必须阻塞等待：<br><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据(网卡数据等)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>非阻塞</strong>IO&#x3D;&#x3D;</p>
<p><strong>阶段一</strong>：</p>
<ul>
<li>用户进程尝试读取数据(比如网卡数据)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;IO<strong>多路复用</strong>&#x3D;&#x3D;</p>
<p>是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><strong>IO多路复用</strong>是利用单个线程来同步监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现</p>
<ul>
<li><strong>select</strong></li>
<li><strong>poll</strong></li>
<li><strong>epoll</strong></li>
</ul>
<p><strong>差异:</strong><br>★ select和polI只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个历Socket来确认<br>★ epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间,</p>
<p><strong>阶段一</strong>:</p>
<ul>
<li>用户进程调用select，指定要监听的Socket集合</li>
<li>内核监听对应的多个socket</li>
<li>任意一个或多个sacket数据就绪则返回readable</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>用户进程找别就格的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis网络模型</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9490d2cd8e67cb8fae7520ad15c0849821dbfac0/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p>
<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span></p>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、Skywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>那这个SQL语句执行很慢，如何分析呢？</strong></span></p>
<blockquote>
<p>可以采用MySQL自带的分析工具 <code>explain</code></p>
<ul>
<li>通过<strong>key</strong>和<strong>key_len</strong>检查是否命中了索引(索引本身存在是否有失效的情况)</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在<strong>全索引扫描</strong>或<strong>全盘扫描</strong></li>
<li>通过<strong>extra</strong>建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询 → <strong><u>新增临时表的数据</u></strong></li>
<li>多表查询 → <strong><u>优化SQL语句结构</u></strong></li>
<li>表数据量过大查询 → <strong><u>添加索引</u></strong></li>
<li>深度分页查询</li>
</ul>
</blockquote>
<h5 id="一个SQL语句执行很慢，如何分析？"><a href="#一个SQL语句执行很慢，如何分析？" class="headerlink" title="一个SQL语句执行很慢，如何分析？"></a>一个SQL语句执行很慢，如何分析？</h5><p>可以采用<code>EXPLAIN</code>或者<code>DESC</code>命令获取MySQL如何执行SELECT语句的信息</p>
<pre><code class="mysql"># 直接在select语句之前加上关键字 explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
</code></pre>
<blockquote>
<p>mysql &gt; explain select * from t_user where id &#x3D; ‘1’</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>98</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<ul>
<li><strong>possible_key</strong>：当前sql可能会使用到的索引</li>
<li><strong>key：</strong>当前sql实际命中的索引     <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>key_len</strong>：<strong>索引占用的大小</strong>          <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>Extra</strong>：额外的优化建议 看是否走过覆盖索引或回表查询</li>
</ul>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; <strong>Using Index</strong></td>
<td>查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</td>
</tr>
<tr>
<td>Using <strong>index condition</strong></td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<ul>
<li><strong>type：</strong>这条sql的<strong>连接的类型</strong>，性能由好到差为 <ul>
<li>NULL</li>
<li>system：查询系统中的表</li>
<li>const：根据主键查询</li>
<li>eq_ref：主键索引查询或唯一索引查询</li>
<li>ref：索引查询</li>
<li>range：范围查询</li>
<li>index：索引树扫描</li>
<li>all：全盘扫描</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>了解过索引吗？（什么是索引）</strong></span></p>
<blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)，在数据之外，数据库系统还维护着满足特定查找算法的数据结构**(B+树)**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<ul>
<li>索引(index)是帮助MySQL高效获取数据的数据结构(有序)</li>
<li>提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;  B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：<u><strong>数据</strong>与</strong>索引</strong></u>放到一块，B+树的叶子节点保存了整行数据，有且只有一个</li>
<li><strong>非聚簇索引(二级索引)<strong>：<u><strong>数据</strong>与</strong>索引</strong></u>分开存储，B+树的叶子节点保存对应的主键，可以有多个</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<h3 id="聚集索引和非聚集索引的具体区别"><a href="#聚集索引和非聚集索引的具体区别" class="headerlink" title="聚集索引和非聚集索引的具体区别"></a>聚集索引和非聚集索引的具体区别</h3><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">聚集索引</th>
<th align="left">非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储方式</strong></td>
<td align="left">数据与索引存储在一起，叶子节点存储整行数据。</td>
<td align="left">数据与索引分开存储，叶子节点存储指针或主键值。</td>
</tr>
<tr>
<td align="left"><strong>物理排序</strong></td>
<td align="left">数据按索引键的顺序物理排序。</td>
<td align="left">数据的物理顺序与索引无关。</td>
</tr>
<tr>
<td align="left"><strong>索引数量</strong></td>
<td align="left">一个表只能有一个聚集索引。</td>
<td align="left">一个表可以有多个非聚集索引。</td>
</tr>
<tr>
<td align="left"><strong>查询性能</strong></td>
<td align="left">查询效率高，尤其是范围查询和排序操作。</td>
<td align="left">查询效率相对较低，可能需要“回表”操作。</td>
</tr>
<tr>
<td align="left"><strong>更新操作影响</strong></td>
<td align="left">插入、删除或更新数据可能需要重新排序。</td>
<td align="left">更新操作影响较小，仅修改索引和指针。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">范围查询、排序、分组等操作频繁的列。</td>
<td align="left">查询条件筛选、快速定位数据的列。</td>
</tr>
</tbody></table>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<p><span style = "color:red"><strong>知道什么叫覆盖索引吗？</strong></span></p>
<blockquote>
<p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引描述，直接返回数据，性能高</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用 **select *** <del>[除非用的聚簇索引(主键)]</del></li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>覆盖索引</strong>&#x3D;&#x3D;是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p>
<table>
<thead>
<tr>
<th align="center"><span style = "color:red">id</span></th>
<th align="center"><span style = "color:red">name</span></th>
<th align="center">gender</th>
<th align="center">createdate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Arm</td>
<td align="center">1</td>
<td align="center">2021-01-01</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Lily</td>
<td align="center">0</td>
<td align="center">2021-05-04</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Rose</td>
<td align="center">0</td>
<td align="center">2021-04-21</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Zoo</td>
<td align="center">1</td>
<td align="center">2021-07-31</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Doc</td>
<td align="center">1</td>
<td align="center">2021-02-26</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">Lee</td>
<td align="center">1</td>
<td align="center">2021-09-11</td>
</tr>
</tbody></table>
<ul>
<li><strong>id为主键，默认是主键索引</strong></li>
<li><strong>name字段为普通索引</strong></li>
</ul>
<pre><code class="mysql">select * from tb_user where id = 1;                     【覆盖索引】
select id, name from tb_user where name = &#39;Arm&#39;         【覆盖索引】
select id, name, gender from tb_user where name = &#39;Arm&#39; 【非覆盖索引】(需要回表查询)
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9b20975f94b299a861457b2214bd985ff4b2625d/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.jpg"></p>
<p><span style = "color:red"><strong>MySQL超大分页怎么处理？</strong></span></p>
<blockquote>
<p>问题：再数据量比较大时，limit分页查询，需要对数据进行排序，效率低<br><strong>解决方案：</strong>可以用<strong>覆盖索引</strong> + <strong>子查询</strong>处理<br>[我们先分页查询获取表中的id 并且对表的id进行排序 就能筛选出分页后的id集合(因为id是覆盖索引效率高)  最后再根据id集合到原来的表中做关联查询就可以得到提升了]</p>
</blockquote>
<p>在数据量比较大时，如果用limit分页查询，在查询时，越往后，分页查询效率越低</p>
<pre><code class="mysql">mysql &gt; select * from tb_sku limit 0,10;
10 rows in set (0.00 sec)

mysql &gt; select * from tb_sku limit 9000000,10;
10 rows in set (11.05 sec)
</code></pre>
<p>因为，当在进行分页查询时，如果执行 limit  9000000,10，此时需要MySQL排序前9000010记录，仅仅返回9000000 - 9000010 的记录，其他记录丢失，查询排序的代价非常大。</p>
<p>&#x3D;&#x3D;<strong>MySQL超大分页查询优化思路</strong>&#x3D;&#x3D;：一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p>
<pre><code class="mysql"># 超大分页处理：先通过覆盖索引找到符合条件的id，再通过这个id的覆盖索引查询到所有的列
select * 
from tb_sku t,
(select id from tb_sku order by id limit 9000000,10) a
where t.id = a.id

# 10 rows in set (7.15 sec)
</code></pre>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong><br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><br>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<h6 id="创建索引的方式1"><a href="#创建索引的方式1" class="headerlink" title="创建索引的方式1"></a>创建索引的方式1</h6><pre><code class="mysql">① SQL的方式
ALTER TABLE user_innodb ADD INDEX idx_name(name)

② 在建表的时候 去指定索引
...
PRIMARY KEY(&#39;id&#39;),
KEY &#39;idx_name&#39; (&#39;name&#39;) USING HASH

③ 通过界面化工具去指定索引
字段旁边有个`索引` 可以去添加

=============================================
单个字段的索引 → 单列索引
多个字段的索引 → 联合索引
</code></pre>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><u>索引可以增加查询速度 同时也增加了更新&#x2F;修改速度</u><del>因为更新的第一步就是查询</del></p>
<blockquote>
<p>① <strong>普通索引</strong>   经过特殊设计的数据结构<br>② <strong>唯一索引</strong>   唯一约束<br>[索引必须是唯一的 比如name就不行 因为名字可以很多建立普通索引]<br>③ <strong>主键索引</strong>   在主键索引上添加了<strong>非空约束</strong><br>④ <strong>全文索引</strong>   一般使用搜索引擎，因为对中文的搜索不太友好<del>美国英文开发的</del><br>[特殊的sql：select * from 表名 where match(字段名) against(‘马士兵教育’ IN NATURAL LANGUAGE MODE);]</p>
<p>AVL树 右右型左旋 <strong><u>左子树与右子树的深度差绝对值不超过1</u></strong><br>树的节点里应该放：<strong>键值</strong>+<strong>Value值</strong>+<strong>左右子树的地址</strong><del>left+right</del><br>Innodb一次会加载16k(<u>16384字节&#x3D;Redis的槽位</u>) 内存到内存<br>不选红黑树是因为它是二叉的，我们需要多叉树<br>要用&#x3D;&#x3D;<strong>B+树</strong>&#x3D;&#x3D;全盘扫描能力更强 叶子节点是双向链表<br>因为稳定性比较好  B树非所见所得 B+树是稳定几层的查找数据<del>因为数据都在最后一层叶子节点上</del><br>Innodb的索引方法是BTREE 不能改成HASH</p>
</blockquote>
<p>**<u><span style = "color:red">数据结构可视化网</span></u>**：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></p>
<ul>
<li>针对数据量较大，且查询比较频繁的表建立索引。<strong>单表超过10万数据(增加用户体验)</strong></li>
<li>针对常作为<strong>查询条件(where)、排序(order by)、分组(group by)</strong> 操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 (比如address都在北京市)</li>
<li>如果是字符串类型的字段，字段的长度越长(描述信息…)，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引(避免回表)，节省存储空间，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ul>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加<strong>单引号</strong>，造成索引失效。(类型转换)</li>
<li>以**%开头的Like模糊查询**，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><strong>怎么哪块读判断索引是否失效了呢</strong>？</p>
<pre><code class="mysql"># 执行计划explain
</code></pre>
<p>【2024最新版MySQL索引讲解！一个视频带你彻底搞懂MySQL索引！！【马士兵】】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3">https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3</a></p>
<p><strong>什么情况下索引会失效？</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：<br><img src="https://github.com/P-luminary/images/blob/master/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png?raw=true" style="zoom:80%;" /></p>
<p><span style = "color:red"><strong>谈谈你对sql的优化经验？</strong></span></p>
<blockquote>
<ul>
<li>表的设计优化，数据类型的选择</li>
<li>索引优化，索引创建原则</li>
<li>sql语句优化，避免索引失效，避免使用select</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ul>
</blockquote>
<ul>
<li><p>表的设计优化(<strong>参考阿里开发手册《嵩山版》</strong>)</p>
<ul>
<li>比如设置合适的数值(tinyint、int、bigint) ，要根据实际情况选择</li>
<li>比如设置合适的字符串类型(char和varchar) char定长效率高，varchar可变长度，效率低</li>
</ul>
<blockquote>
<p>候选人: 这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p>
</blockquote>
</li>
<li><p><strong>索引优化</strong>(参考优化创建原则和索引失效)</p>
</li>
<li><p><strong>SQL语句优化</strong></p>
<ul>
<li><p>SELECT语句务必<strong>指明字段名称</strong> (避免直使用select *)<del>回表</del></p>
</li>
<li><p>SQL语句要<strong>避免造成索引失效</strong>的写法</p>
</li>
<li><p>尽量使用<strong>union all</strong>代替union，union(不会重复)会多一次过滤, 效率低</p>
<pre><code class="mysql">select * from t_user where id &gt; 2
union all | union
select * from t_user where id &lt; 5
</code></pre>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
</li>
<li><p>join优化 能用<strong>inner join</strong> 就不用left join,  right 如必须使用 一定要以小表为驱动；内链接会对两个表进行优化，<strong>优先把小表放到外边，把大表放到里边</strong>。left join 或 right  join，不会重新调整顺序</p>
<pre><code class="java">for(int i = 0; i &lt; 3; i++)&#123; //只链接查询3次
 for(int j = 0; j &lt; 1000; j++)&#123;

 &#125;  
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>主从复制、读写分离</strong>(在生产环境下一般会搭建主库和从库 分开读操作和写操作)</p>
<p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，<strong>数据库的写入</strong>，影响了查询的效率。[Master(写) 和 Slave(读)]</p>
</li>
<li><p><strong>分库分表(后面有介绍)</strong></p>
</li>
</ul>
<p><span style = "color:red"><strong>事务的特性是什么？可以详细的说一下吗？</strong></span>【ACID】</p>
<blockquote>
<p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>候选人：嗯，这个比较清楚，ACID，分别指的是:原子性、一致性、隔离性、持久性;<br><strong>我举个例子</strong>：A向B转账500，转账成功，A扣除500元，B增加500元。<br><strong>原子性</strong>操作体现在<u>要么都成功，要么都失败</u>。<br>在转账的过程中，数据要<strong>一致性</strong>，A扣除了500，B必须增加500<br>在转账的过程中，<strong>隔离性</strong>体现在A像B转账，不能受其他事务干扰<br>在转账的过程中，<strong>持久性</strong>体现在事务提交后，要把数据持久化(可以说是落盘操作)</p>
</blockquote>
<ul>
<li>**原子性(**Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性</strong>(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性</strong>(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行</li>
<li><strong>持久性</strong>(Durabiity)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><span style = "color:red"><strong>并发事务带来哪些问题？怎么解决这些问题？MySQL默认隔离级别是？</strong></span></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;<strong>并发事务问题</strong>&#x3D;&#x3D;：脏读、不可重复读、幻读</li>
<li>&#x3D;&#x3D;<strong>隔离级别</strong>&#x3D;&#x3D;：读未提交、读已提交、<strong>可重复读</strong>、串行化</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td>一个事务先后读取同一条事务，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td align="center">幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，这同时另一个事务B(insert且commit)了事务，此时事务A在插入数据时候，又发现这行数据已经存在了，好像出现了”幻影“</td>
</tr>
</tbody></table>
<h6 id="怎么解决并发事务的问题呢？？"><a href="#怎么解决并发事务的问题呢？？" class="headerlink" title="怎么解决并发事务的问题呢？？"></a>怎么解决并发事务的问题呢？？</h6><p><strong>对事务进行隔离</strong> (× 是代表可以解决此问题)</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted 未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed 读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;<strong>Repeatable Read(默认) 可重复读</strong>&#x3D;&#x3D;</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable 串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>注意：**<u>事务隔离级别越高，数据越安全，但是性能越低</u>**</p>
<p><span style = "color:red"><strong>数据库的undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是<strong>数据页的物理变化</strong>，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是<strong>逻辑日志</strong>，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undolog保证了事务的原子性和一致性</p>
</blockquote>
<p><code>redo log</code> 和 <code>undo log</code> 是 InnoDB 为了实现事务的 <strong>原子性</strong> 和 <strong>持久性</strong> 而设计的两种日志机制：</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>作用</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>redo log</strong></td>
<td>崩溃<strong>恢复</strong>，重做操作（实现<strong>持久性</strong>）【恢复】</td>
<td>保存键 Ctrl+S</td>
</tr>
<tr>
<td><strong>undo log</strong></td>
<td><strong>回滚</strong>事务，撤销操作（实现<strong>原子性</strong>）【撤销】</td>
<td>撤销键 Ctrl+Z</td>
</tr>
</tbody></table>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>假设你执行一条 SQL：</p>
<pre><code>UPDATE account SET balance = balance - 100 WHERE id = 1;
</code></pre>
<p>InnoDB 的执行顺序是：</p>
<ol>
<li>写入 <strong>undo log</strong>（记录原值，便于回滚） ✅</li>
<li>修改内存中的数据（Buffer Pool）✅</li>
<li>写入 <strong>redo log</strong>（记录新的值，崩溃后可重做）✅</li>
<li>提交事务时将 <strong>redo log 落盘（刷到磁盘）</strong></li>
</ol>
<h5 id="🔄-崩溃恢复时如何用它们？"><a href="#🔄-崩溃恢复时如何用它们？" class="headerlink" title="🔄 崩溃恢复时如何用它们？"></a>🔄 崩溃恢复时如何用它们？</h5><ul>
<li>💥 <strong>宕机恢复（crash recovery）时</strong>，MySQL 会用 <code>redo log</code> 把“<strong>已提交但还没写到磁盘的数据</strong>”重做一遍，确保数据不丢失（持久性）。</li>
<li>❌ <strong>事务失败或回滚时</strong>，MySQL 用 <code>undo log</code> 把数据恢复到修改之前的样子，确保事务“要么全做，要么全不做”（原子性）。</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p><strong>重做日志</strong>，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p><strong>回滚日志</strong>，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>**<u>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录</u>**，反之亦然</li>
<li><u>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</u></li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
<p><span style = "color:red"><strong>事务中的隔离性是如何保证的呢？</strong></span></p>
<p>事务的隔离性主要是通过<strong>锁机制</strong>和 <strong>MVCC（多版本并发控制）</strong> 来实现的。</p>
<p><strong>对于更新操作 (写)<strong>，MySQL 会使用加锁机制，比如行级锁中的</strong>排他锁（X锁）</strong>来避免并发写冲突；<br><strong>对于查询操作 (读)<strong>，MySQL 使用 <strong>MVCC</strong> 来避免加锁带来的性能开销，从而支持高并发读操作。<br><strong>MVCC</strong> 的核心思想是：</strong>为同一条数据维护多个版本</strong>，从而实现 “读写不冲突、并发更高效”。</p>
<blockquote>
<p>排他锁 (如果一个事务获取到了一个数据行的排他锁，其他事务就不能再获取该行的其他锁)<br>mvcc: 多版本并发控制  让MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突<br><strong>隐藏字段</strong>:<br>每一行数据都会有两个隐藏字段<br>① trx _id(事务id)，记录每一次操作的事务id，是自增的 [当前这条记录是由哪个事务创建的（事务ID）]<br>② roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址（形成一个版本链）</p>
<p><strong>undo log</strong>:<br>① 回滚日志，存储老版本数据<br>② 版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过rollpointer指针形成一个链表</p>
<p><strong>readView</strong>：解决的是一个事务查询选择版本的问题<br>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据》不同的隔离级别快照读是不一样的，最终的访问的结果不一样RC:每一次执行快照读时生成ReadView<br>RR:仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<blockquote>
<p><strong>面试官</strong>: 事务中的隔离性是如何保证的呢?(你解释一下MVCC)<br><strong>候选人</strong>: 事务的隔离性是由锁和mvcc实现的。<br>其中mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是<u>隐藏字段</u>，第二个是<u>undolog日志</u>，第三个是<u>readView读视图</u><br>隐藏字段是指:在mysq!中给每个表都设置了隐藏字段，有一个是x_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll-pointer(回滚指针)，指向上一个版本的事务版本记录地址<br>undolog主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行探作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表<br>readview解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是r隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
<blockquote>
<h2 id="MVCC底层的三个关键机制"><a href="#MVCC底层的三个关键机制" class="headerlink" title="MVCC底层的三个关键机制"></a>MVCC底层的三个关键机制</h2><h3 id="🔹-1-隐藏字段"><a href="#🔹-1-隐藏字段" class="headerlink" title="🔹 1. 隐藏字段"></a>🔹 1. <strong>隐藏字段</strong></h3><p>每一行数据都会有两个隐藏字段：</p>
<ul>
<li><code>trx_id</code>：当前这条记录是由哪个事务创建的（事务ID）</li>
<li><code>roll_pointer</code>：回滚指针，指向这条记录的上一个版本（形成一个版本链）</li>
</ul>
<hr>
<h3 id="🔹-2-undo-log（回滚日志）"><a href="#🔹-2-undo-log（回滚日志）" class="headerlink" title="🔹 2. undo log（回滚日志）"></a>🔹 2. <strong>undo log（回滚日志）</strong></h3><ul>
<li>当事务对数据进行修改时，会记录修改前的旧数据到 <code>undo log</code></li>
<li>所有旧版本数据通过 <code>roll_pointer</code> 串成一个“版本链”</li>
<li>查询时可以根据版本选择合适的数据版本，从而“读老数据”</li>
</ul>
<hr>
<h3 id="🔹-3-ReadView（读视图）"><a href="#🔹-3-ReadView（读视图）" class="headerlink" title="🔹 3. ReadView（读视图）"></a>🔹 3. <strong>ReadView（读视图）</strong></h3><ul>
<li>在执行快照读时，InnoDB 会生成一个 <strong>ReadView</strong></li>
<li>它记录了当前活跃的事务ID列表，以及当前事务的ID</li>
<li>查询时，会根据 ReadView 判断：这条记录版本是否“可见”</li>
</ul>
</blockquote>
<p>总的来说，<strong>写操作靠加锁，读操作靠 MVCC</strong>。MVCC 通过维护多个版本的数据 + ReadView 机制，让不同事务之间在查询时互不干扰，从而保证隔离性，同时提升并发性能。</p>
<p>🔐 写用锁、📚 读用 MVCC，🔁 多版本 + 🔍 读视图 + 🧾 回滚日志，性能高，隔离强！</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下MVCC？</strong></span></p>
<p>全程 <strong>Multi-Version Concurrency Control</strong>，<u>多版本并发控制</u>。指维护一个数据的多个版本，使得读写操作没有冲突</p>
<h6 id="问题的来源：-橙色的-查询的是哪个事务版本的记录？"><a href="#问题的来源：-橙色的-查询的是哪个事务版本的记录？" class="headerlink" title="问题的来源：(橙色的)查询的是哪个事务版本的记录？"></a>问题的来源：(橙色的)查询的是哪个事务版本的记录？</h6><table>
<thead>
<tr>
<th align="center">事务2</th>
<th align="center">事务3</th>
<th align="center">事务4</th>
<th align="center">事务5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
</tr>
<tr>
<td align="center">修改id为30记录, age改为3</td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">修改id为30记录, name改为A3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提交文件</td>
<td align="center">修改id为30的记录, age改为10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h6><ul>
<li><strong>记录中的隐藏字段</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">age</th>
<th align="center">name</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PTR</th>
<th align="center">DB_ROW_ID</th>
</tr>
</thead>
</table>
<ul>
<li><strong>DB_TRX_ID</strong>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本，用于<strong>配合undo log</strong>, 指向上一个版本</li>
<li><strong>DB_ROW_ID</strong>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</li>
</ul>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><ul>
<li>回滚日志，在<strong>insert、update、delete</strong>的时候产生的便于数据回滚的日志<del>相反的语句</del>。</li>
<li>当insert的时候，产生的undolog日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</li>
</ul>
<h6 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h6><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，<strong>链表的头部是最新的旧记录，链表尾部是最早的旧记录</strong></p>
<ul>
<li><strong>readview</strong></li>
</ul>
<p>ReadView(读视图) 是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id</p>
<p>ReadView中包含了四个核心字段</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_ids</td>
<td align="center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td align="center">min_trx_id</td>
<td align="center">最小活跃事务ID</td>
</tr>
<tr>
<td align="center">max_trx_id</td>
<td align="center">预分配事务ID, 当前最大事务ID+1 (事务ID是自增的)</td>
</tr>
<tr>
<td align="center">creator_trx_id</td>
<td align="center">ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li><strong>当前读</strong></li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select .. lock in share mode(共享锁)，select .. for update、update、insert、delete(排他锁)都是一种当前读。</p>
<ul>
<li><strong>快照读</strong></li>
</ul>
<p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br><strong>Read Committed</strong>：每次select，都生成一个快照读。<br><strong>Repeatable Read</strong>：开启事务后第一个select语句才是快照读的地方。</p>
<p><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></p>
<p><code>主从同步就是主库把所有数据修改写到日志文件（Binlog）里，从库再去“抄作业”——读日志，写自己，中继日志相当于中转站，最终把主库的修改同步过来。</code></p>
<blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 <strong>Binlog</strong> 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 <strong>Relay Log</strong>。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<hr>
<blockquote>
<p>MySQL 主从同步分三步：</p>
<ul>
<li>写日志：主库提交事务 → 写 Binlog</li>
<li>拉日志：从库 I&#x2F;O 线程拉取 Binlog → 写 Relay Log</li>
<li>执行日志：从库 SQL 线程执行 Relay Log → 同步数据</li>
</ul>
</blockquote>
<blockquote>
<p>整个过程就是：<strong>主库写 → 从库拉 → 从库执行</strong></p>
</blockquote>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<pre><code class="text">       +---------------------+
       |      Master 主库     |
       | 写 Binlog（记录变更） |
       +---------------------+
                  ↓
       [ I/O 线程拉取 Binlog ]
                  ↓
       +---------------------+
       |      Slave 从库      |
       | 写 Relay Log（中继） |
       | 执行日志 → 同步数据  |
       +---------------------+
</code></pre>
<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<p><span style = "color:red"><strong>你们项目用过分库分表吗？</strong></span></p>
<blockquote>
<p>是的，我们项目在业务数据达到一定规模后使用了分库分表策略。<br>具体来说，我们在做【举个真实业务：比如订单系统、日志存储系统、会员行为分析系统】时，由于单表数据量突破了 <strong>1000W+<strong>，单表容量超过 <strong>20GB</strong>，查询响应变慢，索引命中率降低，磁盘和网络 I&#x2F;O 成为瓶颈。<br>一开始我们尝试通过</strong>主从读写分离、加索引、缓存优化</strong>等方式缓解，但效果有限，最终采用了分库分表来从根本上解决性能问题。</p>
</blockquote>
<blockquote>
<ul>
<li><p>业务介绍<br>1，根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)<br>2，达到了什么样的量级(单表1000万或超过20G)</p>
</li>
<li><p>具体拆分策略<br>1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题<br>2，水平分表，解决单表存储和性能的问题<br>3，垂直分库，根据业务进行拆分，高并发下提高磁盘I0和网络连接数<br>4，垂直分表，冷热数据分离，多表互不影响</p>
</li>
</ul>
</blockquote>
<p><strong>分担了访问压力、解决存储压力</strong></p>
<p>分库分表的时机：</p>
<p>① <strong>前提</strong>：项目业务数据逐渐增多，业务发展比较迅速【单表数据量达1000W或20G以后】<br>② 优化解决不了性能问题(主从读写分离、查询索引)<br>③ <strong>IO瓶颈</strong>(磁盘IO、网络IO)、<strong>CPU瓶颈</strong>(聚合查询、连接数太多)</p>
<p><strong>拆分策略</strong>【垂直 ≈ 微服务、水平 ≈ 分配数值】</p>
<ul>
<li>&#x3D;&#x3D;<strong>垂直拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中<br>(特点：按业务对数据分级管理、维护、监控、扩展；在高并发下，提高磁盘IO和数据量连接数)<ul>
<li>tb_user → 用户微服务 </li>
<li>tb_order → 订单微服务</li>
<li>tb_sku → 商品微服务</li>
</ul>
</li>
<li><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中<br>(把不常用的字段单独放在一张表；把<strong>text, blob</strong>等大字段[描述]拆分出来放在附表中)<br>(特点：冷热数据分离、减少IO过渡争抢，两表互不影响)</li>
</ul>
</li>
<li>&#x3D;&#x3D;<strong>水平拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>水平分库</strong>：将一个库的数据拆分到多个库中<br>(解决了单库大数量，高并发的性能瓶颈问题；提高了系统的稳定性和可用性)<br><u>路由规则</u><ul>
<li>根据id节点取模</li>
<li>按id也就是范围路由，节点1(1-100万)，节点2(100万-200万)</li>
</ul>
</li>
<li><strong>水平分表</strong>：将一个库的数据拆分到多个表中(可以在同一个库内)<br>(优化单一表数据量过大而产生的性能问题；避免IO争抢并减少锁表的几率)</li>
</ul>
</li>
</ul>
<h6 id="分库后的问题：↓↓"><a href="#分库后的问题：↓↓" class="headerlink" title="分库后的问题：↓↓"></a>分库后的问题：↓↓</h6><ul>
<li>分布式事务一致性问题</li>
<li>跨节点关联查询</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h6 id="使用分库分表中间件"><a href="#使用分库分表中间件" class="headerlink" title="使用分库分表中间件"></a>使用分库分表中间件</h6><ul>
<li><span style = "color:blue"><strong>sharding-sphere</strong></span></li>
<li><span style = "color:blue"><strong>mycat</strong></span></li>
</ul>
<p><span style = "color:red"><strong>Spring框架中的单例bean是线程安全的吗？</strong></span></p>
<blockquote>
<p>不是线程安全的，是这样的</p>
<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑(成员方法)，如果该处理逻辑中有对该单列状态的修改(体现为该单例的成员属性)，则必须考虑线程同步问题。</p>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。<br>比如:我们通常在项目中使用的Springbean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p>
<p>如果你的bean有多种状态的话(比如 View Model对象)，就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton”变更为“prototype”。</p>
</blockquote>
<blockquote>
<p>Spring框架中的bean是单例的</p>
<pre><code class="java">@Service
@Scope(&quot;singleton&quot;)
public class UserServiceImpl implements UserService&#123;

&#125;
</code></pre>
<ul>
<li><strong>singleton</strong>：bean在每个Spring IOC容器中只有一个实例</li>
<li><strong>prototype：</strong>一个bean的定义可以有多个实例</li>
</ul>
<p>Spring bean并没有可变的状态(比如Service类和DAO类), 所以在某种程度上说Spring的单例bean是线程安全的。但要尽可能的少创造可变参数比如count</p>
<pre><code class="java">@Controller
@RequeestMapping(&quot;/user&quot;)
public class UserController&#123;
    private int count; //成员方法需要考虑线程安全问题

    @Autowired
    private UserService userService;

    @GetMapping(&quot;/getById/&#123;id&#125;&quot;)
    public User getById(@PathVariable(&quot;id&quot;) Integer id)&#123;
        count++;
        sout(count);
        return userService.getById(id);
    &#125;
&#125;
</code></pre>
</blockquote>
<blockquote>
<ol>
<li><strong>单例Bean就像共享单车</strong>：<ul>
<li>整个小区（Spring容器）只有一辆共享单车（单例Bean），所有居民（线程）都要轮流骑这辆车。</li>
<li>如果只是骑车（调用无状态方法），不会出问题。</li>
<li>但如果有人在车筐里放东西（修改成员变量），下个人可能就会看到&#x2F;改动这些东西。</li>
</ul>
</li>
<li><strong>什么时候安全？</strong><ul>
<li>比如Service、DAO这类Bean，它们通常只干活不记账（没有成员变量），就像只提供骑行服务的单车，很安全。</li>
<li>这也是为什么我们平时用@Autowired注入的Service不会出问题。</li>
</ul>
</li>
<li><strong>什么时候危险？</strong><ul>
<li>如果Bean里有个计数器count（就像你代码里的例子），多个线程同时”+1”就会乱套。</li>
<li>就像多个人同时往单车筐里放苹果，最后苹果数量肯定对不上。</li>
</ul>
</li>
<li><strong>怎么解决？</strong><ul>
<li>方法一：不记账 → 永远不在Bean里放成员变量（推荐）</li>
<li>方法二：用锁 → 像公共厕所那样，一个人用的时候锁门（加synchronized）</li>
<li>方法三：每人发一辆车 → 改用@Scope(“prototype”)，每次请求都新建Bean（但浪费资源）</li>
</ul>
</li>
<li><strong>实际开发建议</strong>：<ul>
<li>大多数情况下，Service&#x2F;Dao写成单例完全没问题</li>
<li>遇到要记录状态的场景（比如计数器），要么改成prototype，要么把变量存在ThreadLocal里</li>
<li>绝对不要在Controller里定义成员变量！你代码里的count就是个典型反例</li>
</ul>
</li>
</ol>
<p>简单说：单例Bean本身不是线程安全的，但只要我们遵守”不用成员变量记事情”的原则，就能安全使用。就像共享单车，只要大家都不往车筐里放私人物品，就不会有问题。</p>
</blockquote>
<p><span style = "color:red"><strong>什么是AOP，你们项目中有没有用到AOP？</strong></span></p>
<p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<h6 id="常见AOP使用场景："><a href="#常见AOP使用场景：" class="headerlink" title="常见AOP使用场景："></a>常见AOP使用场景：</h6><ul>
<li><p><strong>拒绝策略记录操作日志</strong></p>
<blockquote>
<p>nginx → 新增用户 → @Around(“pointcut()”) <u><strong>环绕通知</strong></u></p>
</blockquote>
</li>
<li><p><strong>缓存处理</strong></p>
</li>
<li><p><strong>Spring中内置的事务处理</strong></p>
</li>
</ul>
<p><strong>Spring中的事务是如何实现的</strong><br><span style = "color:blue"><u>Spring支持 <strong>编程式事务管理</strong> 和 <strong>声明式事务</strong> 管理两种方式</u></span>。</p>
<ul>
<li><strong>编程式事务控制</strong>：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li><strong>声明式事务管理</strong>：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<blockquote>
<p>AOP（面向切面编程）可以理解为 <strong>“在不修改原有代码的情况下，给程序动态添加功能”</strong>。</p>
<h5 id="生活中的例子："><a href="#生活中的例子：" class="headerlink" title="生活中的例子："></a><strong>生活中的例子：</strong></h5><ul>
<li>假设你开了一家咖啡店，主要业务是 <strong>做咖啡</strong>（核心业务）。</li>
<li>但除了做咖啡，你还要 <strong>记录销售日志、检查权限、处理异常</strong>（如咖啡机坏了）等（<strong>横切关注点</strong>）。</li>
<li>如果用传统OOP（面向对象编程），你需要在每个做咖啡的方法里都写日志、权限检查代码，这样代码会变得臃肿且难以维护。</li>
<li>而AOP的做法是：<strong>把这些公共逻辑（如日志、权限）抽出来，做成一个“切面”</strong>，然后“织入”到需要的地方，<strong>不影响原有业务代码</strong>。</li>
</ul>
<hr>
<h5 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a><strong>AOP的核心概念</strong></h5><ol>
<li><strong>切面（Aspect）</strong>：封装横切逻辑的模块（比如日志、事务）。</li>
<li><strong>连接点（Join Point）</strong>：程序执行的点（如方法调用、异常抛出）。</li>
<li><strong>通知（Advice）</strong>：切面在连接点执行的动作（如方法执行前、后、异常时做什么）。</li>
<li><strong>切点（Pointcut）</strong>：定义哪些连接点会被切面影响（如“所有Service层的方法”）。</li>
<li><strong>织入（Weaving）</strong>：把切面应用到目标对象的过程（编译期、类加载期、运行时）。</li>
</ol>
</blockquote>
<p><span style = "color:red"><strong>Spring中事务失效的场景有哪些？</strong></span></p>
<blockquote>
<p>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出<br>抛出检查异常，配置rollbackFor属性为Exception<br>非public方法导致的事务失效，改为public</p>
</blockquote>
<p>考察对spring框架的深入理解、复杂业务的编码经验</p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>异常捕获处理</strong>&#x3D;&#x3D;【异常被try-catch吃掉】</p>
<p><strong>原因</strong>：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉【Spring 的事务是基于 AOP 的，只有方法抛出异常，事务管理器才能感知并触发回滚；你在方法内部 <code>try-catch</code> 了异常，但没有再往外抛，就会导致事务<strong>不能回滚</strong>】</p>
<p><strong>解决</strong>：<u>在catch块添加throw new RuntimeException(“转账失败”)</u> 抛出</p>
</li>
<li><p>&#x3D;&#x3D;<strong>抛出检查异常</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring 默认只对 非检查异常（RuntimeException 及其子类）、 进行回滚</p>
<pre><code class="java">@Transactional
public void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>解决：</strong>配置<code>rollbackFor</code>属性</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
</code></pre>
</li>
<li><p>&#x3D;&#x3D;<strong>非public方法</strong>&#x3D;&#x3D;<br>Spring 的事务本质是基于 AOP 代理实现的，而 AOP 默认只对 <code>public</code> 方法生效。</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>原因：</strong>Spring为方法创建代理、添加事务通知、<u>前提条件都是该方法是<strong>public</strong>的</u><br><strong>解决：</strong>把方法改为<code>public</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>同类内部调用，导致代理失效</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring AOP 基于代理机制。如果类内部方法调用类内的另一个 <code>@Transactional</code> 方法，实际上不会经过代理，事务不会生效。</p>
<pre><code class="java">// ❌ 会失效
public void methodA() &#123;
    methodB(); // 不经过代理
&#125;
  
@Transactional
public void methodB() &#123;
    // 无效
&#125;
</code></pre>
<ul>
<li><strong>解决</strong>：<ul>
<li>将方法调用抽出到另一个 bean 中；</li>
<li>或使用 <code>AopContext.currentProxy()</code> 获取当前代理对象执行调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>Spring的bean的生命周期？</strong></span></p>
<blockquote>
<p>Spring容器是如何管理和创建bean实例<br>方便调试和解决问题</p>
<p>① 通过BeanDefinition获取bean的定义信息 [Spring 会将 XML 或注解配置的 Bean 信息封装成 <code>BeanDefinition</code> 对象，用于描述 Bean 的元数据信息，如 class 类型、作用域、是否懒加载等]<br>② 调用构造函数实例化bean [通过构造函数或工厂方法创建 Bean 对象，还没进行依赖注入]<br>③ bean的依赖注入 [Spring 根据 BeanDefinition 中的配置信息，进行依赖注入，例如通过 <code>@Autowired</code>、<code>@Resource</code> 等注解注入其它 Bean]<br>④ 处理Aware接囗回调(BeanNameAware、BeanFactoryAware、ApplicationContextAware)<br>⑤ Bean的后置处理器BeanPostProcessor-前置<br>⑥ 初始化方法(InitializingBean、init-method)<br>⑦ Bean的后置处理器BeanPostProcessor-后置<br>⑧ 销毁bean</p>
</blockquote>
<p><strong>BeanDefinition</strong></p>
<p>Spring容器在进行实例化时，会将xml配置的&lt; bean &gt;的信息封装成一个<strong>BeanDefinition</strong>对象，<u>Spring根据BeanDefinition来创建Bean对象，里面有很多的属性来描述Bean</u></p>
<pre><code class="java">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaolmpl&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.UserServicelmpl&quot; scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://github.com/P-luminary/images/blob/master/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true"></p>
<p><span style = "color:red"><strong>Spring中的循环引用？</strong></span></p>
<blockquote>
<p>★ <strong>循环依赖</strong>：循环依赖其实就是循环引用, 也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A<br>★ 循环依赖在spring中是允许存在，spring框架**<u>依据三级缓存已经解决了大部分的循环依赖</u>**<br>☆ <strong>一级缓存</strong>：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象<br>☆ <strong>二级缓存</strong>：缓存早期的<strong>bean</strong>对象(生命周期还没走完)<br>☆ <strong>三级缓存</strong>：缓存的是<strong>ObjectFactory</strong>，表示对象工厂，用来创建某个对象的</p>
<h4 id="✅-处理流程简要说明："><a href="#✅-处理流程简要说明：" class="headerlink" title="✅ 处理流程简要说明："></a>✅ 处理流程简要说明：</h4><ol>
<li>Spring 创建 A → A 依赖 B → 创建 B</li>
<li>B 依赖 A，发现 A 还没完成创建</li>
<li>Spring 把 A 的 <strong>半成品（early reference）</strong> 暴露到二级缓存，让 B 先注入用</li>
<li>最后 A 初始化完成，加入一级缓存</li>
</ol>
<blockquote>
<p>✅ 这样就解决了大多数基于 <strong>setter 注入 &#x2F; 字段注入</strong> 的循环依赖问题。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>构造方法出现了循环依赖怎么解决？</strong></span></p>
<blockquote>
<p>A依赖于B，B依赖于A，注入的方式是<strong>构造函数</strong><br><strong>原因</strong>：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br><strong>解决方案</strong>：使用**@Lazy<strong>进行</strong>懒加载**，什么时候需要对象再进行bean对象的创建</p>
<p>public A(@Lazy B b){<br> sout(“A的构造方法执行了”);<br> this.b&#x3D;b;<br>}</p>
</blockquote>
<blockquote>
<p>@Component                                     @Component<br>public class A{          →      ←             public class B{<br>    @Autowired         ↑          ↑                 @Autowired<br>    private B b;       →↑          ↑←                private A a;<br>}                                                             } </p>
<h4 id="🧠-三大缓存："><a href="#🧠-三大缓存：" class="headerlink" title="🧠 三大缓存："></a>🧠 三大缓存：</h4><table>
<thead>
<tr>
<th>缓存级别</th>
<th>对应源码字段名</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td><code>singletonObjects</code></td>
<td>已完全初始化的 Bean（生命周期完成），正式放入单例池</td>
</tr>
<tr>
<td>二级缓存</td>
<td><code>earlySingletonObjects</code></td>
<td>暂时暴露的半成品 Bean 实例（未执行初始化方法）</td>
</tr>
<tr>
<td>三级缓存</td>
<td><code>singletonFactories</code></td>
<td>存的是创建代理对象的 ObjectFactory，用于解决代理类循环依赖</td>
</tr>
</tbody></table>
<h6 id="Spring-把-A-的-半成品（early-reference）-暴露到二级缓存，让-B-先注入用为啥要放到二级缓存-而不是一级呢？"><a href="#Spring-把-A-的-半成品（early-reference）-暴露到二级缓存，让-B-先注入用为啥要放到二级缓存-而不是一级呢？" class="headerlink" title="Spring 把 A 的 半成品（early reference） 暴露到二级缓存，让 B 先注入用为啥要放到二级缓存 而不是一级呢？"></a><span style = "color:blue">Spring 把 A 的 半成品（early reference） 暴露到二级缓存，让 B 先注入用为啥要放到二级缓存 而不是一级呢？</span></h6><h2 id="✅-答案核心："><a href="#✅-答案核心：" class="headerlink" title="✅ 答案核心："></a>✅ 答案核心：</h2><p>因为此时 A 只是一个 <strong>尚未完成初始化的半成品对象</strong>，它还没有执行：</p>
<ul>
<li>属性填充（依赖注入）</li>
<li>Aware 接口回调</li>
<li>初始化方法（如 <code>@PostConstruct</code>、<code>afterPropertiesSet()</code>）</li>
</ul>
<p>➡️ <strong>这个 Bean 还不“完整”，不能放入正式的一级缓存！</strong>🔍 为什么不能直接放入一级缓存？</p>
<p>一级缓存是 <code>singletonObjects</code>，是 Spring 的“成品仓库”：</p>
<ul>
<li>放入这个缓存意味着：<ul>
<li>Bean 已经完成生命周期（包括依赖注入、初始化）</li>
<li>可以被别人安全引用</li>
</ul>
</li>
</ul>
<p>但在处理循环依赖时，我们是<strong>中途打断流程，把未初始化完成的 Bean 暴露出来</strong>给另一个 Bean 注入（比如 A 注入给 B）</p>
<h3 id="🔴-如果此时放入一级缓存，有两个风险："><a href="#🔴-如果此时放入一级缓存，有两个风险：" class="headerlink" title="🔴 如果此时放入一级缓存，有两个风险："></a>🔴 如果此时放入一级缓存，有两个风险：</h3><ol>
<li><strong>状态不一致风险</strong><br> 其他 Bean 拿到这个未初始化完成的 Bean，会误以为它是“成品”，使用后可能报错或引发不一致。</li>
<li><strong>生命周期混乱</strong><br> BeanPostProcessor、InitializingBean、@PostConstruct 等生命周期操作可能被跳过或错乱，严重破坏 Spring 的生命周期管理逻辑。</li>
</ol>
<h2 id="✅-二级缓存的作用正是：-”暴露早期引用”，但不当成成品！"><a href="#✅-二级缓存的作用正是：-”暴露早期引用”，但不当成成品！" class="headerlink" title="✅ 二级缓存的作用正是：**”暴露早期引用”，但不当成成品！**"></a>✅ 二级缓存的作用正是：**”暴露早期引用”，但不当成成品！**</h2><pre><code class="java">// 二级缓存 earlySingletonObjects：仅仅作为“抢先使用”的通道
this.earlySingletonObjects.put(beanName, earlyReference);
</code></pre>
<p>它是 Spring 对“对象未完成但又必须提前使用”这个两难问题的妥协方案。✅ 最终完整的 Bean 放入一级缓存：</p>
<p>当整个 Bean 初始化完成（属性注入 + 初始化方法 + 后置处理器都执行完），才会放入一级缓存：</p>
<pre><code class="java">addSingleton(beanName, exposedObject); // 放入 singletonObjects
</code></pre>
<hr>
<hr>
<p><span style = "color:blue"><strong>那按照你这样说 三级缓存又是干啥的?你问得非常到位！</strong></span><br>✅ 我们已经知道：</p>
<ul>
<li>一级缓存：<strong>成品 Bean 的正式仓库</strong>；</li>
<li>二级缓存：<strong>未初始化完成的“早期引用”</strong>，暴露给依赖它的 Bean 使用。</li>
</ul>
<h5 id="✅-简明结论（先记住）："><a href="#✅-简明结论（先记住）：" class="headerlink" title="✅ 简明结论（先记住）："></a>✅ 简明结论（先记住）：</h5><p><strong>三级缓存的本质作用是：为了解决“代理对象”在循环依赖中的提前暴露问题。</strong></p>
<h2 id="🎯-三级缓存的角色是什么？"><a href="#🎯-三级缓存的角色是什么？" class="headerlink" title="🎯 三级缓存的角色是什么？"></a>🎯 三级缓存的角色是什么？</h2><p>三级缓存存的是：</p>
<pre><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories
</code></pre>
<p>也就是说：它<strong>不是直接存 Bean 实例本身</strong>，而是存一个<strong>对象工厂 ObjectFactory</strong>，这个工厂可以在需要的时候返回一个 Bean（甚至是它的代理对象）。</p>
<h4 id="🧠-为什么需要三级缓存？——解决AOP-代理对象的提前暴露"><a href="#🧠-为什么需要三级缓存？——解决AOP-代理对象的提前暴露" class="headerlink" title="🧠 为什么需要三级缓存？——解决AOP 代理对象的提前暴露"></a>🧠 为什么需要三级缓存？——解决<strong>AOP 代理对象的提前暴露</strong></h4><p>Spring 在三级缓存里放一个 <code>ObjectFactory</code>，用于 <strong>延迟构建代理对象</strong></p>
<p>等到别的 Bean（比如 B）需要注入 A 时，先从二级缓存找不到，就用三级缓存的 <code>ObjectFactory.getObject()</code> 来构造这个 Bean，此时可以通过 <code>SmartInstantiationAwareBeanPostProcessor</code>（比如 AOP 后置处理器）提前生成代理。</p>
</blockquote>
<h6 id="什么是Spring的循环依赖？？"><a href="#什么是Spring的循环依赖？？" class="headerlink" title="什么是Spring的循环依赖？？"></a>什么是Spring的循环依赖？？</h6><p><u>&#x3D;&#x3D;<strong>一级缓存</strong>&#x3D;&#x3D;作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/14e03913c1c2b7ca24702d5d2226a886bcc373de/%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg"></p>
<p><u>如果想打破循环依赖，就需要一个中间人的参与，这个中间人就是&#x3D;&#x3D;<strong>二级缓存</strong>&#x3D;&#x3D;</u><del>如果一个对象是代理对象(被增强了)就不行</del><br><img src="https://github.com/P-luminary/images/blob/master/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%962.jpg?raw=true"></p>
<p><u>针对如果是代理对象的话如何解决呢？</u> → &#x3D;&#x3D;<strong>三级缓存</strong>&#x3D;&#x3D;<br><img src="https://github.com/P-luminary/images/blob/master/%E4%B8%89%E6%AC%A1%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg?raw=true"></p>
<h6 id="那如果构造方法出现了循环依赖怎么解决？"><a href="#那如果构造方法出现了循环依赖怎么解决？" class="headerlink" title="那如果构造方法出现了循环依赖怎么解决？"></a>那如果构造方法出现了循环依赖怎么解决？</h6><blockquote>
<p>@Component                                                                   @Component<br>public class A{                           →      ←                          public class B{<br>    private B b;                             ↑          ↑                             private A a;<br>    public A(B c){                       →↑          ↑←                        public B(A c){<br>       sout(“A的构造方法执行了”)                                          sout(“B的构造方法执行了”)<br>       this.b&#x3D;b;                                                                                 this.b&#x3D;b;<br> }                                                                                               }<br>}                                                                                            } </p>
<p>报错信息：Is there an unresolvable circular reference?<br>解决：<code>@Lazy </code> 延迟加载→什么时候需要对象的时候什么时候实例化对象</p>
<pre><code class="java">public A(@Lazy B b)&#123;
 sout(&quot;A的构造方法执行了&quot;);
 this.b=b;
&#125;
</code></pre>
</blockquote>
<p><strong>Spring解决循环依赖是通过三级缓存</strong></p>
<pre><code class="java">// 单实例对象注册器
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;
private static final int SUPPRESSED EXCEPTIONS LIMIT= 100;  
private final Map&lt;String, Object&gt;singletonObjects = new ConcurrentHashMap(256); 一级缓存
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16); 三级缓存
private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16); 二级缓存 
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObject</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象(生命周期还没走完)</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC的执行流程知道吗？</strong></span></p>
<blockquote>
<ul>
<li>视图阶段(老旧JSP等)</li>
<li>前后端分离阶段(接口开发，异步)</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/67d750afe8d0ece9e5cc289483dc164a9897e165/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<p>&#x3D;&#x3D;<strong>视图阶段(jsp)</strong>&#x3D;&#x3D; </p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器<strong>对象</strong>及处理器<strong>拦截器</strong>(如果有)</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)Controller执行完成返回</li>
<li>ModelAndView对象HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)</li>
<li>ViewReslover解析后返回具体View(视图)</li>
<li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)</li>
<li>DispatcherServlet响应用户</li>
</ul>
<p>&#x3D;&#x3D;<strong>前后端分离阶段(接口开发，异步请求)</strong>&#x3D;&#x3D;</p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)</li>
<li>HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)</li>
</ul>
<blockquote>
<h3 id="✅-一、SpringMVC-是什么？"><a href="#✅-一、SpringMVC-是什么？" class="headerlink" title="✅ 一、SpringMVC 是什么？"></a>✅ 一、SpringMVC 是什么？</h3><blockquote>
<p>SpringMVC 是基于<strong>Servlet 的原生请求处理模型</strong>封装的一套 MVC Web 框架，它通过 DispatcherServlet 实现请求分发，解耦了控制器、视图解析器等组件之间的关系。</p>
</blockquote>
<h3 id="🚀-1-用户发起请求"><a href="#🚀-1-用户发起请求" class="headerlink" title="🚀 1. 用户发起请求"></a>🚀 1. 用户发起请求</h3><p>浏览器访问一个 URL，例如：<code>http://localhost:8080/user/list</code>，请求会先到达 <strong>前端控制器 DispatcherServlet</strong>。</p>
<hr>
<h3 id="🔄-2-DispatcherServlet-接收到请求"><a href="#🔄-2-DispatcherServlet-接收到请求" class="headerlink" title="🔄 2. DispatcherServlet 接收到请求"></a>🔄 2. DispatcherServlet 接收到请求</h3><p>DispatcherServlet 是 SpringMVC 的核心入口，用于请求分发和生命周期管理。</p>
<hr>
<h3 id="🔎-3-查找-HandlerMapping（处理器映射器）"><a href="#🔎-3-查找-HandlerMapping（处理器映射器）" class="headerlink" title="🔎 3. 查找 HandlerMapping（处理器映射器）"></a>🔎 3. 查找 HandlerMapping（处理器映射器）</h3><ul>
<li>DispatcherServlet 调用 HandlerMapping 来<strong>查找当前请求所匹配的 Handler（Controller 方法）</strong>；</li>
<li>会封装成 <code>HandlerExecutionChain</code>，里面包含目标处理器和拦截器链。</li>
</ul>
<hr>
<h3 id="⚙️-4-调用-HandlerAdapter（处理器适配器）"><a href="#⚙️-4-调用-HandlerAdapter（处理器适配器）" class="headerlink" title="⚙️ 4. 调用 HandlerAdapter（处理器适配器）"></a>⚙️ 4. 调用 HandlerAdapter（处理器适配器）</h3><p>SpringMVC 不直接调用 Handler，而是交给 HandlerAdapter 来统一调用逻辑（比如支持 @RequestMapping&#x2F;@RestController 方法）。</p>
<hr>
<h3 id="🧠-5-执行-Handler（也就是-Controller-方法）"><a href="#🧠-5-执行-Handler（也就是-Controller-方法）" class="headerlink" title="🧠 5. 执行 Handler（也就是 Controller 方法）"></a>🧠 5. 执行 Handler（也就是 Controller 方法）</h3><p>通过适配器调用具体的 Controller 中的业务处理方法，如：</p>
<pre><code>java复制代码@GetMapping(&quot;/user/list&quot;)
public List&lt;User&gt; list() &#123;
    return userService.findAll();
&#125;
</code></pre>
<hr>
<h3 id="📦-6-返回-ModelAndView（传统视图模式）或-ResponseBody-数据（前后端分离）"><a href="#📦-6-返回-ModelAndView（传统视图模式）或-ResponseBody-数据（前后端分离）" class="headerlink" title="📦 6. 返回 ModelAndView（传统视图模式）或 @ResponseBody 数据（前后端分离）"></a>📦 6. 返回 ModelAndView（传统视图模式）或 @ResponseBody 数据（前后端分离）</h3><ul>
<li>传统 MVC 场景下，Controller 返回一个 <code>ModelAndView</code>；</li>
<li>如果是前后端分离，通常会返回 JSON 数据，经过 <code>HttpMessageConverter</code> 处理后直接写入响应体。</li>
</ul>
<hr>
<h3 id="🪞-7-调用-ViewResolver（视图解析器）【视图模式专属】"><a href="#🪞-7-调用-ViewResolver（视图解析器）【视图模式专属】" class="headerlink" title="🪞 7. 调用 ViewResolver（视图解析器）【视图模式专属】"></a>🪞 7. 调用 ViewResolver（视图解析器）【视图模式专属】</h3><ul>
<li>如果返回的是视图名（如 “userList”），SpringMVC 会调用 ViewResolver 解析为具体的 JSP 或 Thymeleaf 模板。</li>
</ul>
<hr>
<h3 id="🎨-8-渲染视图-View（视图模式专属）"><a href="#🎨-8-渲染视图-View（视图模式专属）" class="headerlink" title="🎨 8. 渲染视图 View（视图模式专属）"></a>🎨 8. 渲染视图 View（视图模式专属）</h3><ul>
<li>将模型数据（Model）填充进视图模板，生成 HTML 页面。</li>
</ul>
<hr>
<h3 id="📤-9-DispatcherServlet-返回响应给浏览器"><a href="#📤-9-DispatcherServlet-返回响应给浏览器" class="headerlink" title="📤 9. DispatcherServlet 返回响应给浏览器"></a>📤 9. DispatcherServlet 返回响应给浏览器</h3><ul>
<li>前后端分离下是 JSON 响应；</li>
<li>传统模式下是完整渲染后的 HTML。</li>
</ul>
<pre><code class="text">  [用户请求]
       ↓
 DispatcherServlet
       ↓
 HandlerMapping → 找到 Handler + 拦截器链
       ↓
 HandlerAdapter  → 统一执行 Handler
       ↓
 Controller      → 执行业务逻辑
       ↓
 返回 ModelAndView / JSON
       ↓
（传统）ViewResolver → 找视图模板
       ↓
 渲染视图 / 写入 JSON 响应体
       ↓
 DispatcherServlet 响应浏览器
</code></pre>
<h2 id="✅-四、不同开发阶段下的区别"><a href="#✅-四、不同开发阶段下的区别" class="headerlink" title="✅ 四、不同开发阶段下的区别"></a>✅ 四、不同开发阶段下的区别</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>返回值</th>
<th>是否走视图解析器</th>
<th>常见注解</th>
</tr>
</thead>
<tbody><tr>
<td>JSP 阶段</td>
<td>ModelAndView</td>
<td>✅ 是</td>
<td><code>@Controller</code></td>
</tr>
<tr>
<td>前后端分离</td>
<td>JSON 数据</td>
<td>❌ 否</td>
<td><code>@RestController</code> + <code>@ResponseBody</code></td>
</tr>
</tbody></table>
<h2 id="🎯-五、总结金句（可背）："><a href="#🎯-五、总结金句（可背）：" class="headerlink" title="🎯 五、总结金句（可背）："></a>🎯 五、总结金句（可背）：</h2><blockquote>
<p>SpringMVC 核心就是一个请求经过 DispatcherServlet，根据 HandlerMapping 找到处理器，由 HandlerAdapter 调用 Controller 执行逻辑，最终通过视图解析或消息转换，返回结果给客户端。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>SpringBoot自动配置原理？</strong></span></p>
<pre><code class="java">@SpringBootApplication = 
    @SpringBootConfiguration +
    @EnableAutoConfiguration +
    @ComponentScan
</code></pre>
<blockquote>
<p>SpringBoot中最高频的一道面试题，也是框架最核心的思想<br>&#x3D;&#x3D;<code>@SpringBootConfiguration</code>&#x3D;&#x3D;：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类<br>&#x3D;&#x3D;<code>@EnableAutoConfiguration</code>&#x3D;&#x3D;：SpringBoot实现自动化配置的核心注解，通过配置选择器导入自动配置类<br>&#x3D;&#x3D;<code>@ComponentScan</code>&#x3D;&#x3D;：组件扫描，默认扫描当前引导类所在包及其子包</p>
<p>1，在Spring Boot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是:</p>
<ul>
<li><code>@SpringBootConfiquration</code></li>
<li><code>@EnableAutoConfiquration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
<p>2，其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。<u>该注解通过<code>@Import</code>注解导入对应的<strong>配置选择器</strong>。内部就是读取了该项目和该项目引用的jar包的classpath路径下<code>META-INF/spring.factories</code>文件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解<strong>所指定的条件来决定</strong>是否需要将其导入到Spring容器中</u>。</p>
<p>3，条件判断会有像<code>@ConditionalOnClass</code>这样的注解，<u>判断是否有对应的class文件</u>，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>
</blockquote>
<pre><code class="java">package com.itheima;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// SpringBoot的启动类
// 注意: 我们写的代码要在启动类的包或者子包中
// @SpringBootApplication注解中包含了 @ComponentScan，没有指定扫描哪个包，默认扫描当前类所在的包和子包
@SpringBootApplication
public class Day15TliasManagement01IocDiApplication &#123;
    // 启动项目, 内嵌的Tomcat会启动, 把项目部署到这个内嵌Tomcat中
    public static void main(String[] args) &#123;
        SpringApplication.run(Day15TliasManagement01IocDiApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@SpringBootApplication</code>会弹到<code>SpringBootApplication.class</code>界面</p>
</blockquote>
<pre><code class="mysql">@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@EnableAutoConfiguration</code>会弹到<code>EnableAutoConfiguration.class</code>界面</p>
</blockquote>
<pre><code class="mysql"># @Import(&#123;AutoConfigurationImportSelector.class&#125;)
# AutoConfigurationImportSelector是自动配置的选择器 
# 会加载META-INF中的spring.factories文件的自动配置类...AutoConfiguration...
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Import;

@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(&#123;AutoConfigurationImportSelector.class&#125;)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<p><span style = "color:red"><strong>Spring框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围<del>默认单例的</del></td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定Spring在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程(AOP)</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则标识类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径中获取请求参数(<code>/user/&#123;id&#125;</code>)，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将Controller方法返回对象转换成json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @RequestBody</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringBoot常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了 <code>-@Configuration注解</code>，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选项</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/aa2405d532d8e6606845f6a1a4da8456b797e115/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>MyBatis执行流程？</strong></span></p>
<blockquote>
<ul>
<li>读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ul>
<p>执行流程从读取配置文件、创建 SqlSession、查找 MappedStatement、参数映射、执行 SQL 到结果映射，每个环节都有对应的组件协作完成。</p>
</blockquote>
<ul>
<li>理解了各个组件的关系</li>
<li>Sql的执行过程(参数映射、sql解析、执行和结果处理)</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/7263f0a583711bca127933c0053e2b1fef476cb7/MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" style="zoom:80%;" />



<p><span style = "color:red"><strong>MyBatis是否支持延迟加载？</strong></span></p>
<blockquote>
<ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</li>
<li>Mybatis支持<strong>一对一关联对象</strong>和<strong>一对多关联集合对象</strong>的延迟加载</li>
<li>在<code>Mybatis配置文件</code>中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true/false</code>，默认是关闭的</li>
</ul>
<pre><code class="yaml">&lt;settings&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>延迟加载(懒加载)：<strong>查询主对象时不立即加载关联对象，而是在访问关联属性时再去执行查询语句加载数据</strong>。<br>查询 <code>User</code> 时不查 <code>Order</code>，只有调用 <code>user.getOrders()</code> 时，才执行 <code>select * from order where user_id = ?</code></p>
</blockquote>
<p><span style = "color:red"><strong>延迟加载的底层原理知道吗？</strong></span></p>
<p>MyBatis <strong>延迟加载的核心是代理模式 + 拦截器机制</strong>，底层主要通过 <strong>CGLIB 创建目标对象的代理对象</strong></p>
<blockquote>
<ul>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象</li>
<li>当调用目标方法时，进入拦截器<strong>invoke</strong>方法，发现目标方法是nul值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ul>
</blockquote>
<blockquote>
<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是&#x3D;&#x3D;<strong>立即加载</strong>&#x3D;&#x3D;<br>查询**<u>用户的(sql)</u><strong>时候，暂时不查询订单数据，当需要订单的时候，再查询</strong><u>订单(sql)</u>**，这个就是&#x3D;&#x3D;<strong>延迟加载</strong>&#x3D;&#x3D;</p>
<h3 id="执行流程-👇"><a href="#执行流程-👇" class="headerlink" title="执行流程 👇"></a>执行流程 👇</h3><ol>
<li><strong>查询主对象时</strong>，不会立即查关联对象，而是用 CGLIB 创建一个代理对象（继承目标类）</li>
<li><strong>当访问关联属性时</strong>，进入代理类的 <code>intercept</code> 方法（拦截器）</li>
<li><strong>拦截器判断属性是否已加载</strong>：<ul>
<li>没加载 → 执行对应的 SQL（如 <code>selectOrdersForUser</code>）</li>
<li>查出结果后 → 通过 <code>setXxx()</code> 方法注入属性值</li>
</ul>
</li>
<li><strong>属性值设置好之后</strong>，后续访问就是直接取值，不再触发数据库查询</li>
</ol>
</blockquote>
<blockquote>
<h3 id="延迟加载的实现步骤："><a href="#延迟加载的实现步骤：" class="headerlink" title="延迟加载的实现步骤："></a>延迟加载的实现步骤：</h3><ol>
<li><strong>配置开启延迟加载</strong>： 在MyBatis的配置文件中（通常是<code>mybatis-config.xml</code>），需要设置两个属性：<ul>
<li><code>lazyLoadingEnabled=true</code>：开启延迟加载。</li>
<li><code>aggressiveLazyLoading=false</code>：关闭积极的延迟加载，即访问对象的时候不会立即加载其所有属性。</li>
</ul>
</li>
<li><strong>映射文件配置</strong>： 在对应的Mapper映射文件中，对于需要延迟加载的关联查询，使用<code>select</code>标签定义延迟加载的SQL语句，并通过<code>fetchType=&quot;lazy&quot;</code>属性明确指定使用延迟加载。</li>
<li><strong>创建代理对象</strong>： 当执行查询操作时，MyBatis不会立即执行关联查询的SQL，而是返回一个代理对象。这个代理对象是使用CGLIB库创建的，它继承自目标对象。</li>
<li><strong>拦截器方法调用</strong>： 当我们首次访问这个代理对象的某个方法（比如访问订单详情）时，实际上会调用CGLIB生成的代理对象的拦截器方法（<code>intercept</code>方法）。在拦截器方法中，会判断当前要访问的属性是否已经被加载：<ul>
<li>如果属性已经被加载，则直接返回属性值。</li>
<li>如果属性未被加载，则会执行之前定义好的延迟加载SQL语句，从数据库中查询数据。</li>
</ul>
</li>
<li><strong>设置属性值</strong>： 查询得到数据后，MyBatis会将这些数据设置到目标对象的相应属性上，这样下次访问该属性时，就不需要再次查询数据库了。</li>
</ol>
<h3 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h3><ul>
<li><strong>CGLIB代理</strong>：MyBatis使用CGLIB库创建目标对象的代理，当调用目标方法时，实际上会进入拦截器（Interceptor）的<code>intercept</code>方法。</li>
<li><strong>拦截器逻辑</strong>：在拦截器中，会判断当前调用的方法是否需要触发延迟加载。如果需要，则执行延迟加载的SQL查询。</li>
<li><strong>结果处理</strong>：查询结果会被处理并设置到目标对象的属性上，这样目标对象的相关属性就持有了数据，后续访问将直接返回这些数据，而无需再次查询。<code>MyBatis在执行完延迟加载的SQL查询后，会获取查询结果，并将这些结果映射到目标对象的相应属性中</code></li>
</ul>
<h3 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h3><p>假设有一个用户<code>User</code>和订单<code>Order</code>的关系，在查询用户时，通常不会立即加载其订单信息，而是当需要时再加载。以下是简化的代码示例：</p>
<pre><code class="xml">&lt;!-- UserMapper.xml --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
  &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
  &lt;!-- 延迟加载订单信息 --&gt;
  &lt;collection property=&quot;orders&quot; column=&quot;id&quot; ofType=&quot;Order&quot; select=&quot;selectOrdersForUser&quot; fetchType=&quot;lazy&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectUser&quot; resultMap=&quot;userMap&quot;&gt;
  SELECT * FROM user WHERE id = #&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;selectOrdersForUser&quot; resultType=&quot;Order&quot;&gt;
  SELECT * FROM order WHERE user_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>在上述配置中，当调用<code>selectUser</code>查询用户信息时，不会立即查询订单信息。只有当程序中访问<code>User</code>对象的<code>orders</code>属性时，才会执行<code>selectOrdersForUser</code>查询，这就是延迟加载的具体实现。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/1fdf519599da660621e27393d18b48f4b2bdb802/MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86.png"  />

<p><span style = "color:red"><strong>MyBatis的一级、二级缓存用过吗？</strong></span></p>
<blockquote>
<ul>
<li>一级缓存:基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>MyBatis的二级缓存什么时候会清理缓存中的数据？</strong></span></p>
<blockquote>
<ul>
<li>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
</blockquote>
<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li><strong>一级缓存</strong>：作用域是session级别<ul>
<li>基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，<strong>默认打开一级缓存</strong></li>
</ul>
</li>
<li><strong>二级缓存</strong>：作用域是namespace和mapper的作用域，不依赖于session<ul>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用 PerpetualCache<br>HashMap 存储</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5f133abb10da579732fe734073e28b0713a3b63/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ul>
<h2 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a><span style = "color:blue">SpringCloud篇</span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/a556069d277599cc45e30c8e2e719fba7ff392cb/SpringCloud%E9%9D%A2%E8%AF%95%E9%A2%98.jpg"></p>
<p><span style = "color:red"><strong>SpringCloud 5大组件有哪些？</strong></span></p>
<p>回答原则：简单的问题不能答错</p>
<table>
<thead>
<tr>
<th>通常情况</th>
<th>SpringCloudAlibba</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka：注册中心</td>
<td>Nacos：注册中心&#x2F;配置中心</td>
</tr>
<tr>
<td><strong>Ribbon：负载均衡</strong></td>
<td><strong>Ribbon：负载均衡</strong></td>
</tr>
<tr>
<td><strong>Feign：远程调用</strong></td>
<td><strong>Feign：远程调用</strong></td>
</tr>
<tr>
<td>Hystrix：服务熔断</td>
<td>sentinel：服务保护</td>
</tr>
<tr>
<td>Zuul&#x2F;<strong>Gateway：网关</strong></td>
<td><strong>Gateway：服务网关</strong></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/39f10dd62358b96346cdf42dd3f893f0d0920bcc/SpringCloud5%E5%A4%A7%E7%BB%84%E4%BB%B6.jpg"></p>
<p><span style = "color:red"><strong>服务注册和发现是什么意思？ SpringCloud 如何实现服务注册发现？</strong></span></p>
<blockquote>
<ul>
<li>我们当时项目采用的<code>eureka</code>作为注册中心，这个也是SpringCloud体系的一个核心组件</li>
<li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka来保存这些信息，比如**<u>服务名称、ip、端口</u>**等等</li>
<li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者利用<strong>负载均衡</strong>算法，选择一个发起调用</li>
<li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有收到心跳，从eureka中剔除</li>
</ul>
</blockquote>
<ul>
<li>微服务中必须要使用的组件，考虑我们使用微服务的程度</li>
<li>注册中心的核心作用是：服务注册和发现</li>
<li>常见的注册中心：<strong>eureka、nocas</strong>、zookeeper</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4f4fe573949c4168cd4114f6cc6a28679f84181/Eureka%E4%BD%9C%E7%94%A8.jpg"></p>
<p><span style = "color:red"><strong>请你说一下nacos与eureka的区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>Nacos与Eureka的共同点</strong> (<u>注册中心</u>)<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务者心跳方式做健康检测</li>
</ul>
</li>
<li><strong>Nacos与Eureka的区别</strong> (<u>注册中心</u>)<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>
<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被提出</strong></li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式<del>高可用模式</del>，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，Eureka只有注册中心，也是选择选用nacos的一个重要原因</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3c304f59104d2917c35ecb658f95f7073365ed9c/Eureka%E5%92%8CNacos%E5%8C%BA%E5%88%AB.jpg"></p>
<p><span style = "color:red"><strong>把RestTemplate替换成OpenFeign后它们的底层还是一样的吗？</strong></span><del>OpenFeign是远程调用</del></p>
<p>OpenFeign的底层原理也是根据服务名称，首先去远程注册中心拉取服务列表，底层也会在本地缓存一份，也会根据负载均衡选出一个实例，又运用了jdk的动态代理生成代理类，也会涉及到反射机制，最终拼出完整的url，发起http远程调用</p>
<pre><code class="java">@FeignClient(name = &quot;service-provider&quot;)
public interface ServiceProviderClient &#123;
    // 定义接口方法，映射到服务提供者的具体API
    @GetMapping(&quot;/api/resource&quot;)
    String getResource();
&#125;
</code></pre>
<blockquote>
<h3 id="✅-一、使用方式不同"><a href="#✅-一、使用方式不同" class="headerlink" title="✅ 一、使用方式不同"></a>✅ 一、使用方式不同</h3><ul>
<li><p><strong>RestTemplate</strong> 是显式调用（自己写 URL，拼参数）</p>
<pre><code>restTemplate.getForObject(&quot;http://user-service/user/1&quot;, String.class);
</code></pre>
</li>
<li><p><strong>OpenFeign</strong> 是声明式调用（只写接口 + 注解，SpringBoot自动帮你拼URL发请求）</p>
<pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient &#123;
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    String getUser(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="✅-二、底层原理差不多，但实现机制不同"><a href="#✅-二、底层原理差不多，但实现机制不同" class="headerlink" title="✅ 二、底层原理差不多，但实现机制不同"></a>✅ 二、底层原理差不多，但实现机制不同</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>RestTemplate</th>
<th>OpenFeign</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发起方式</strong></td>
<td>手动构造 URL + 参数</td>
<td>注解接口 + 动态代理自动拼 URL</td>
</tr>
<tr>
<td><strong>底层通信方式</strong></td>
<td>HttpClient &#x2F; OKHttp &#x2F; JDK Http</td>
<td>同样也是基于 HttpClient 或 OKHttp</td>
</tr>
<tr>
<td><strong>注册中心拉取服务</strong></td>
<td>可搭配 Ribbon 手动实现服务发现</td>
<td>默认集成 Spring Cloud <strong>LoadBalancer</strong> 自动发现服务</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>手动配置 Ribbon 或 LoadBalancer</td>
<td>自动内置 <strong>LoadBalancer</strong>，基于服务名均衡选择</td>
</tr>
<tr>
<td><strong>动态代理</strong></td>
<td>无</td>
<td>有，基于 <strong>JDK 动态代理</strong>生成接口实现类</td>
</tr>
<tr>
<td><strong>扩展能力</strong></td>
<td>灵活性高，配置复杂</td>
<td>扩展性强，统一规范，支持熔断&#x2F;重试&#x2F;拦截器等</td>
</tr>
</tbody></table>
<h3 id="✅-三、OpenFeign-更高级，集成更好"><a href="#✅-三、OpenFeign-更高级，集成更好" class="headerlink" title="✅ 三、OpenFeign 更高级，集成更好"></a>✅ 三、OpenFeign 更高级，集成更好</h3><p>OpenFeign 是对 RestTemplate 的一层封装 + 声明式远程调用：</p>
<ul>
<li>内置了服务注册发现（Eureka&#x2F;Nacos）</li>
<li>内置了负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）</li>
<li>可配合 Hystrix &#x2F; Sentinel 实现熔断降级</li>
<li>支持拦截器、日志、重试、压缩等功能</li>
<li>统一异常处理、超时配置更方便</li>
</ul>
<h3 id="✅-四、结论一句话总结："><a href="#✅-四、结论一句话总结：" class="headerlink" title="✅ 四、结论一句话总结："></a>✅ 四、结论一句话总结：</h3><blockquote>
<p><strong>虽然最终底层都是通过 HTTP 客户端发起请求（如 OkHttp &#x2F; HttpClient），但 <span style = "color:red">OpenFeign 是基于动态代理+注解的声明式封装，实现了更强大的远程调用能力和集成能力，远比 RestTemplate 更高级、更易维护。</span></strong></p>
</blockquote>
<h5 id="如果面试官继续追问：“你们项目是怎么替换的？”，你可以说："><a href="#如果面试官继续追问：“你们项目是怎么替换的？”，你可以说：" class="headerlink" title="如果面试官继续追问：“你们项目是怎么替换的？”，你可以说："></a>如果面试官继续追问：“你们项目是怎么替换的？”，你可以说：</h5><blockquote>
<p>我们之前用 RestTemplate 是在业务代码里拼 URL，很冗余。后来统一封装为 OpenFeign，只保留接口定义，调用方更清晰，服务注册与发现、负载均衡也变成自动处理，配合 Sentinel 做了服务熔断与限流，提升了整体的系统健壮性。</p>
<h6 id="怎么个自动处理法？"><a href="#怎么个自动处理法？" class="headerlink" title="怎么个自动处理法？"></a>怎么个自动处理法？</h6><h2 id="默认情况下-——-OpenFeign-自动处理"><a href="#默认情况下-——-OpenFeign-自动处理" class="headerlink" title="默认情况下 —— OpenFeign 自动处理"></a>默认情况下 —— OpenFeign 自动处理</h2><h3 id="✅-默认配置时："><a href="#✅-默认配置时：" class="headerlink" title="✅ 默认配置时："></a>✅ 默认配置时：</h3><ul>
<li><strong>服务注册与发现</strong>：依赖 Nacos &#x2F; Eureka 等注册中心，OpenFeign 会根据服务名自动从注册中心拉取可用实例。</li>
<li><strong>负载均衡</strong>：默认通过 Spring Cloud LoadBalancer（以前是 Ribbon）对服务列表进行轮询或权重等策略选择一个实例。</li>
<li><strong>HTTP请求</strong>：通过 <code>HttpClient</code> &#x2F; <code>OkHttp</code> 等客户端执行。</li>
</ul>
<p><strong>你只写：</strong></p>
<pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient &#123;
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    User getUser(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<p><strong>OpenFeign 会自动做：</strong></p>
<ul>
<li>拉取 <code>user-service</code> 的服务列表</li>
<li>选出一个实例（负载均衡）</li>
<li>拼接 URL 发起 HTTP 请求</li>
</ul>
<blockquote>
<h2 id="🧠-一、什么叫“选出一个实例”？"><a href="#🧠-一、什么叫“选出一个实例”？" class="headerlink" title="🧠 一、什么叫“选出一个实例”？"></a>🧠 一、什么叫“选出一个实例”？</h2><p>在 <strong>微服务架构</strong> 中，一个服务往往会 <strong>部署多个实例</strong> 来应对高并发或容灾，例如：</p>
<table>
<thead>
<tr>
<th>服务名</th>
<th>实例地址</th>
</tr>
</thead>
<tbody><tr>
<td>user-service</td>
<td>10.0.0.1:8080</td>
</tr>
<tr>
<td>user-service</td>
<td>10.0.0.2:8080</td>
</tr>
<tr>
<td>user-service</td>
<td>10.0.0.3:8080</td>
</tr>
</tbody></table>
<p>当你通过 OpenFeign 发送请求：</p>
<pre><code>@FeignClient(&quot;user-service&quot;)
User getUser(...);
</code></pre>
<p>你只写了一个服务名 <code>user-service</code>，但后台其实有多个实例，<strong>必须从这些实例中选出一个具体地址来发请求</strong>，比如选中 <code>10.0.0.2:8080</code>。</p>
<hr>
<h2 id="⚖️-二、这就是负载均衡要干的事！"><a href="#⚖️-二、这就是负载均衡要干的事！" class="headerlink" title="⚖️ 二、这就是负载均衡要干的事！"></a>⚖️ 二、这就是负载均衡要干的事！</h2><h3 id="✅-负载均衡做的事："><a href="#✅-负载均衡做的事：" class="headerlink" title="✅ 负载均衡做的事："></a>✅ 负载均衡做的事：</h3><p>就是 <strong>从多个可用实例中选择一个</strong>。</p>
<h3 id="✅-为什么要选？不选行不行？"><a href="#✅-为什么要选？不选行不行？" class="headerlink" title="✅ 为什么要选？不选行不行？"></a>✅ 为什么要选？不选行不行？</h3><p>如果不做选择，就不知道到底该请求哪个服务器，容易：</p>
<ul>
<li>总是访问同一个实例 → 某一个实例过载</li>
<li>有的实例空闲，有的压力大 → 资源利用不均衡</li>
<li>某些实例宕机，没人检测 → 请求失败</li>
</ul>
<h3 id="✅-所以负载均衡的作用是："><a href="#✅-所以负载均衡的作用是：" class="headerlink" title="✅ 所以负载均衡的作用是："></a>✅ 所以负载均衡的作用是：</h3><ul>
<li><strong>分摊压力</strong>：让不同请求打到不同实例，防止某一个服务器崩掉</li>
<li><strong>提高可用性</strong>：某个实例挂了，下一次选择其他实例，系统还能继续用</li>
<li><strong>自动切换</strong>：负载均衡组件还能感知服务状态变化，动态更新可用实例列表</li>
</ul>
<hr>
<h2 id="🧮-三、OpenFeign-背后使用了什么做负载均衡？"><a href="#🧮-三、OpenFeign-背后使用了什么做负载均衡？" class="headerlink" title="🧮 三、OpenFeign 背后使用了什么做负载均衡？"></a>🧮 三、OpenFeign 背后使用了什么做负载均衡？</h2><p>在 Spring Cloud 中，OpenFeign 默认集成了：</p>
<h3 id="✅-Spring-Cloud-LoadBalancer（或老版-Ribbon）"><a href="#✅-Spring-Cloud-LoadBalancer（或老版-Ribbon）" class="headerlink" title="✅ Spring Cloud LoadBalancer（或老版 Ribbon）"></a>✅ Spring Cloud LoadBalancer（或老版 Ribbon）</h3><p>它的核心就是在每次请求前调用：</p>
<pre><code>choose(&quot;user-service&quot;)
</code></pre>
<p>然后根据你配置的策略，比如：</p>
<ul>
<li>轮询（RoundRobin）👉 按顺序一个一个来</li>
<li>随机（Random）👉 随机挑一个</li>
<li>最少连接数（LeastConnections）</li>
<li>权重（Weighted）</li>
</ul>
<p>最终得到一个实例，例如 <code>10.0.0.2:8080</code>，然后拼接成最终 URL：</p>
<pre><code>http://10.0.0.2:8080/api/user/1
</code></pre>
<p>再发起 HTTP 请求。</p>
<hr>
<h2 id="🎯-总结一句话："><a href="#🎯-总结一句话：" class="headerlink" title="🎯 总结一句话："></a>🎯 总结一句话：</h2><blockquote>
<p>OpenFeign 中的“选出一个实例”就是 <strong>从多个服务实例中选择一个合适的来发送请求的过程</strong>，这个选择过程就是“负载均衡”负责的。它的目标是为了 <strong>提升性能、避免单点压力、实现高可用</strong>。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>你们项目负载均衡如何实现的？</strong></span><del>图1.1</del></p>
<blockquote>
<p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们再使用feign远程调用的过程中，底层的负载均衡就是使用了Ribbon 【<u>与RestTemplate不同，OpenFeign默认是LoadBalancer</u>】</p>
</blockquote>
<ul>
<li>负载均衡Ribbon，发起远程调用feign就会使用Ribbon</li>
<li>Ribbon负载均衡策略有哪些？</li>
<li>如果想自定义负载均衡策略如何实现？</li>
</ul>
<h6 id="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"><a href="#Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进" class="headerlink" title="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"></a>Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/2a6397006f0e74e16de4222ac7ab2758e98aa96c/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0.png"></p>
<p><span style = "color:red"><strong>Ribbon负载均衡策略有哪些？</strong></span><del>简单、权重、随机、区域</del></p>
<ul>
<li><span style="color:blue"><strong>RoundRobinRule</strong>：<strong>简单</strong><u>轮询服务列表</u>来选择服务器</span></li>
<li><span style="color:blue"><strong>WeightedResponseTimeRule</strong>：按照<u><strong>权重</strong></u>来选择服务器，响应时间越长，权重越小</span></li>
<li><span style="color:blue"><strong>RandomRule</strong>：<u><strong>随机</strong>选择</u>一个可用的服务器</span></li>
<li>BestAvaliableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li>
<li>RetryRule：重试机制的选择逻辑</li>
<li>AvaliabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li>
<li><span style="color:blue"><strong>ZoneAvoidanceRule</strong>：以<u><strong>区域</strong>可用</u>的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可用理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</span></li>
</ul>
<blockquote>
<h5 id="✅-Ribbon-常见负载均衡策略一览"><a href="#✅-Ribbon-常见负载均衡策略一览" class="headerlink" title="✅ Ribbon 常见负载均衡策略一览"></a>✅ Ribbon 常见负载均衡策略一览</h5><table>
<thead>
<tr>
<th>策略名</th>
<th>简介</th>
<th>核心逻辑</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RoundRobinRule</strong></td>
<td>轮询策略</td>
<td>依次选择服务列表中的每个实例，循环使用</td>
<td>简单、适用于服务性能相当、请求量均匀的场景</td>
</tr>
<tr>
<td><strong>RandomRule</strong></td>
<td>随机策略</td>
<td>随机选一个可用实例</td>
<td>测试环境、低并发系统或对分布无要求的场景</td>
</tr>
<tr>
<td><strong>WeightedResponseTimeRule</strong></td>
<td>权重 + 响应时间</td>
<td>根据服务实例响应时间动态调整权重，响应快的被选中几率高</td>
<td>适用于实例性能差异明显，希望高性能实例被优先选中</td>
</tr>
<tr>
<td><strong>RetryRule</strong></td>
<td>带重试机制的轮询</td>
<td>每次选择失败后会在一段时间内重试其他实例（默认使用 RoundRobinRule）</td>
<td>适用于请求容错性强、临时性网络波动频繁的情况</td>
</tr>
<tr>
<td><strong>BestAvailableRule</strong></td>
<td>最少并发策略</td>
<td>忽略短路（熔断）的实例，选择并发数最少的可用实例</td>
<td>适用于高并发下控制服务压力</td>
</tr>
<tr>
<td><strong>AvailabilityFilteringRule</strong></td>
<td>可用性过滤策略</td>
<td>过滤掉连接失败次数多的和并发高的实例，避免访问不健康服务</td>
<td>适用于系统对可用性要求高、网络波动大的场景</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong>（默认）</td>
<td>区域感知策略</td>
<td>综合评估 zone（区域）内实例的可用性和负载（Zone可以理解为机房或机架），选出最优 zone 再轮询选择服务</td>
<td>适用于跨机房、跨地域部署，希望优先选择本地&#x2F;低延迟实例的系统</td>
</tr>
</tbody></table>
<h2 id="📌-补充小Tips"><a href="#📌-补充小Tips" class="headerlink" title="📌 补充小Tips"></a>📌 补充小Tips</h2><ul>
<li>Spring Cloud 2020 后 Ribbon 官方不再维护，<strong>推荐用 Spring Cloud LoadBalancer</strong> 替代，但思想类似。</li>
<li>如果你项目还用 Ribbon，<strong>推荐配合 Hystrix 或 Sentinel 做服务熔断和限流</strong>。</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>如果想自定义负载均衡策略如何实现？</strong></span><del>图1.2</del></p>
<blockquote>
<ul>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡（局部）</li>
</ul>
</blockquote>
<blockquote>
<p>首先，你需要创建一个类来实现 <code>IRule</code> 接口，这样就能自定义负载均衡的策略。<br><strong>实现 IRule 接口</strong>：</p>
<pre><code class="java">import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.Server;
import com.netflix.loadbalancer.ZoneAwareLoadBalancer;
import com.netflix.loadbalancer.RandomRule;

import java.util.List;

public class CustomLoadBalancerRule implements IRule &#123;

private IRule delegate = new RandomRule();  // 默认策略

@Override
public Server choose(Object key) &#123;
  // 在这里实现自己的负载均衡算法
  // 比如，你可以使用 RoundRobin、Random 或者基于健康检查的策略
  return delegate.choose(key);
&#125;

@Override
public void setLoadBalancer(ZoneAwareLoadBalancer&lt;?&gt; lb) &#123;
  delegate.setLoadBalancer(lb);
&#125;

@Override
public ZoneAwareLoadBalancer&lt;?&gt; getLoadBalancer() &#123;
  return delegate.getLoadBalancer();
&#125;
&#125;
</code></pre>
<p>然后，你需要在 Spring 配置类或者启动类上注入该自定义的负载均衡策略。<br><strong>配置 Bean 注册到容器（全局策略）</strong>：</p>
<pre><code class="java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RibbonConfig &#123;

@Bean
public IRule customLoadBalancerRule() &#123;
  return new CustomLoadBalancerRule();
&#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>SpringCloud中什么是服务雪崩，怎么解决这个问题？</strong></span></p>
<ul>
<li>什么是&#x3D;&#x3D;<strong>服务雪崩</strong>&#x3D;&#x3D;？<del>一个服务失败，导致整条链路的服务都失败的情形</del></li>
</ul>
<blockquote>
<ul>
<li>服务雪崩：当某个服务因为故障不可用，导致依赖它的上游服务纷纷失败，进而整个系统连锁崩溃的现象<ul>
<li>常发生在<strong>服务调用链路较长</strong>时</li>
<li>一个服务挂了，所有调用它的服务都会超时挂起，<strong>线程资源被耗尽，最终整个系统瘫痪</strong></li>
</ul>
</li>
</ul>
<p>📌 <strong>通俗比喻</strong>：你访问淘宝商品详情页面 → 商品服务依赖库存服务 → 库存服务挂了 → 商品服务一直卡着等 → 网页加载失败 → 淘宝崩了</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9900715f7f6943c509f9312dc31f4cf581e0af49/%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9.jpg"></p>
<ul>
<li>&#x3D;&#x3D;<u><strong>熔断降级</strong></u>&#x3D;&#x3D; &amp;&amp; &#x3D;&#x3D;<strong>服务熔断</strong>&#x3D;&#x3D;（解决）<strong>Hystix 服务熔断降级</strong></li>
</ul>
<blockquote>
<p><strong><u>服务降级</u></strong><del>部分服务不可用</del>：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<span style = "color:orange"><strong>一般在实际开发中与Feign接口整合，编写降级逻辑 <strong></span>(<strong>某个服务挂了或响应慢</strong>，不让请求卡住，而是返回</strong>预设的“备胎数据”</strong>，用户体验不会很差)</p>
</blockquote>
<blockquote>
<p><strong><u>服务熔断</u></strong><del>整个服务不可用</del>：默认关闭，需要手动打开，如果监测到<span style = "color:orange"><strong>10秒内请求的失败率超过50%</strong></span>，就触发熔断机制。之后<span style = "color:orange"><strong>每隔5秒重新尝试请求</strong></span>微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3195c4ca2d1f63815e09a802354a9c28209893b/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5.jpg"></p>
<ul>
<li><p><strong>限流（预防）</strong><del>微服务限流(漏桶算法、令牌桶算法)</del></p>
<blockquote>
<p>限制单位时间的请求数，避免流量洪峰打垮服务</p>
<ul>
<li>漏桶算法：匀速出水，适合平滑限流</li>
<li>令牌桶算法：按需取令牌，适合突发流量控制</li>
</ul>
<p>📍 实现工具：Sentinel、Gateway限流、Bucket4j、RateLimiter</p>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>你们项目中有没有做到限流？怎么做的？&amp;&amp; 限流常见的算法有哪些？？</strong></span></p>
<blockquote>
<p>① 先来介绍一下业务，什么情况下去做限流，需要说明<strong>QPS</strong>具体是多少</p>
<ul>
<li>我们有一个活动，到了假期就会抢购优惠券，QPS最高可以达到2000，平时10-50之间，为了应对突发流量，需要做限流</li>
<li>常规限流，为了防止恶意攻击，保护系统正常运行，我们当时系统能够承受最大的QPS是多少(压测结果)</li>
</ul>
<p>② <strong>nginx限流</strong></p>
<ul>
<li>控制速率(突发流量)，使用的<strong>漏桶算法</strong>来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的连接数和并发链接的总数</li>
</ul>
<p>③ <strong>网关限流</strong></p>
<ul>
<li>在SpringCloudGateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</blockquote>
<blockquote>
<h4 id="解释原理："><a href="#解释原理：" class="headerlink" title="解释原理："></a>解释原理：</h4><p>QPS（Queries Per Second，每秒查询率）是衡量一个系统处理请求能力的指标，它表示服务器在一秒钟内能够处理的查询数量。这个指标常用于数据库和web服务器等应用，以评估系统在高并发情况下的性能。<br>以下是对您提到的两句话的分析：</p>
<ol>
<li><strong>活动期间的高并发处理：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> 在电子商务等应用中，促销活动往往会引起用户的大量点击和购买行为，导致短时间内流量剧增。</li>
<li><strong>限流原理：</strong> 为了应对这种突发的高流量，系统需要实施限流措施。限流是为了保护系统资源不被过度消耗，确保系统的稳定性和可靠性。常见的限流算法有固定窗口、滑动窗口、令牌桶和漏桶等。</li>
</ul>
<p><code>固定窗口： 假设每 1 分钟允许 100 次请求，10:00:00 到 10:01:00 期间的 100 次请求被允许，超出 100 次则会被限流，10:01:00 到 10:02:00 则重新开始计算。</code></p>
<p><code>滑动窗口： 每 60 秒内最多允许 100 次请求，滑动窗口的时间长度为 60 秒，窗口内的请求数会随着时间滑动更新，防止请求在时间边界上积压</code></p>
<p><code>令牌桶：假设每秒生成 10 个令牌，令牌桶的容量为 100 个令牌。如果 1 秒内有 15 个请求到达，则前 10 个请求能获得令牌并继续执行，剩余的 5 个请求需要等到下一个时间窗口令牌生成后再执行。</code></p>
<p><code>漏桶：假设每秒钟流出 10 个请求，漏桶的容量为 100 个请求。如果 1 秒钟内接收了 30 个请求，系统只会处理 10 个请求，剩余的 20 个请求被丢弃，直到下一个时间点。</code></p>
<ul>
<li><strong>实施方式：</strong> 在您提到的情况下，可以采用以下策略：<ul>
<li><strong>预判性扩容：</strong> 根据历史数据和活动规模预测流量，提前进行服务器资源的扩容。</li>
<li><strong>动态限流：</strong> 在活动期间，根据实时监控的QPS数据动态调整限流阈值，保证系统平稳运行。</li>
<li><strong>排队处理：</strong> 对于超出系统处理能力的请求，可以采用队列进行缓冲，分批次处理。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>常规限流与系统最大承受QPS：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> <strong>常规限流</strong>是为了在日常运行中防止恶意攻击（如<strong>DDoS攻击</strong>）和保护系统资源不被滥用。</li>
<li><strong>压测结果：</strong> 系统的最大承受QPS是通过压力测试得出的。压力测试（也称为负载测试）是通过模拟高并发访问来测试系统的极限性能，以确定系统在保证稳定运行的前提下能够承受的最大QPS。</li>
<li><strong>原理分析：</strong> <ul>
<li><strong>保护系统：</strong> 通过设定一个QPS上限，可以防止系统过载，保障系统的正常运行。</li>
<li><strong>资源分配：</strong> 了解系统的最大承受QPS有助于合理分配资源，如数据库连接、内存和CPU等。</li>
<li><strong>用户体验：</strong> 适当的限流可以保证用户的体验，避免因系统过载导致的响应缓慢或服务不可用。<br>在实施限流策略时，还需要考虑以下因素：</li>
</ul>
</li>
<li><strong>业务优先级：</strong> 对于不同的业务请求，可能需要有不同的限流策略，优先保证核心功能的可用性。</li>
<li><strong>用户体验：</strong> 限流策略应尽量减少对用户体验的影响，例如通过友好的错误提示或降级方案。</li>
<li><strong>数据监控：</strong> 实时监控系统的QPS和其他关键指标，以便快速响应并调整限流策略。<br> 综上所述，限流是确保系统在高并发情况下稳定运行的重要措施，而了解系统的最大承受QPS是制定合理限流策略的基础。</li>
</ul>
</blockquote>
<p>为什么要限流？</p>
<ul>
<li><strong>并发业务量大</strong>(突发流量)</li>
<li>防止用户<strong>恶意刷接口</strong></li>
</ul>
<h6 id="限流的实现方式："><a href="#限流的实现方式：" class="headerlink" title="限流的实现方式："></a>限流的实现方式：</h6><ul>
<li><p>&#x3D;&#x3D;<strong>Tomcat</strong>&#x3D;&#x3D;<del>单体项目可以,分布式不行</del>：可以设置最大连接数 <code>&lt;Connector port=&quot;8080&quot;...maxThreads=&quot;150&quot;...&gt;</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>Nginx</strong>&#x3D;&#x3D;：<strong>漏桶算法</strong><del>固定速率露出(平滑)</del></p>
<p>控制速率(突发流量)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/8090ab914e03e67198de3dd121167624b5c3a541/Nginx%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81.png" style="zoom: 200%;" />
</li>
<li><p>&#x3D;&#x3D;<strong>网关</strong>&#x3D;&#x3D;：<strong>令牌桶算法</strong></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/e32511e92db5c1c27f7fad58f5078039014016a6/%E7%BD%91%E5%85%B3%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" style="zoom: 200%;" />
</li>
<li><p>自定义拦截器</p>
</li>
</ul>
<blockquote>
<h5 id="echos-gateway真实案例"><a href="#echos-gateway真实案例" class="headerlink" title="echos-gateway真实案例"></a>echos-gateway真实案例</h5><h3 id="🔷-1-网关服务名称-动态发现配置"><a href="#🔷-1-网关服务名称-动态发现配置" class="headerlink" title="🔷 1. 网关服务名称 + 动态发现配置"></a>🔷 1. 网关服务名称 + 动态发现配置</h3><pre><code>spring:
  application:
    name: ech-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.188.120:8848
</code></pre>
<ul>
<li><strong>知识点</strong>：Gateway 是 Spring Cloud 架构中的 API 网关，用于请求路由、统一鉴权、日志跟踪、限流、熔断等功能。</li>
<li><strong>动态路由注册中心配置</strong>：接入 Nacos 注册中心，自动发现服务实例。</li>
</ul>
<hr>
<h3 id="🔷-2-Gateway-路由规则（重点）"><a href="#🔷-2-Gateway-路由规则（重点）" class="headerlink" title="🔷 2. Gateway 路由规则（重点）"></a>🔷 2. Gateway 路由规则（重点）</h3><pre><code>spring:
  cloud:
    gateway:
      routes:
        - id: zk-sam-service
          uri: lb://ech-sam-cs
          predicates:
            - Path=/iclock/**
</code></pre>
<h4 id="🧠-面试要点："><a href="#🧠-面试要点：" class="headerlink" title="🧠 面试要点："></a>🧠 面试要点：</h4><ul>
<li><code>id</code>: 路由唯一标识</li>
<li><code>uri: lb://xxx</code>: 表示使用 <strong>负载均衡方式</strong> 路由到注册中心中 <code>xxx</code> 的实例（通过 Ribbon&#x2F;LoadBalancer 实现）</li>
<li><code>Path</code>: 路径断言，匹配路径开头为 <code>/iclock/**</code> 的请求</li>
<li><code>filters: StripPrefix=1</code>: 去除路径中的第一级前缀（如 <code>/ech-service/a/b</code> → <code>/a/b</code>）</li>
</ul>
<hr>
<h3 id="🔷-3-自动路由发现开启"><a href="#🔷-3-自动路由发现开启" class="headerlink" title="🔷 3. 自动路由发现开启"></a>🔷 3. 自动路由发现开启</h3><pre><code>discovery:
  locator:
    enabled: true
    lower-case-service-id: true
</code></pre>
<h4 id="🧠-面试延申："><a href="#🧠-面试延申：" class="headerlink" title="🧠 面试延申："></a>🧠 面试延申：</h4><ul>
<li><strong>enabled&#x3D;true</strong>：允许网关根据注册中心中注册的服务自动创建路由（简化配置）</li>
<li><strong>lower-case-service-id&#x3D;true</strong>：将服务名小写化，避免大小写不一致导致路由失败</li>
</ul>
<blockquote>
<p>面试官可能问：<br> “你们项目中是手动配置路由还是用 locator 自动发现？哪种方式更推荐？”</p>
</blockquote>
<p>✅ <strong>回答思路：</strong></p>
<ul>
<li>自动发现适合内部测试环境，快速接入新服务</li>
<li>生产建议手动配置，便于管理、加权限、加限流、避免误暴露</li>
</ul>
<hr>
<h2 id="✅-三、Feign配置部分（Gateway下游调用）"><a href="#✅-三、Feign配置部分（Gateway下游调用）" class="headerlink" title="✅ 三、Feign配置部分（Gateway下游调用）"></a>✅ 三、Feign配置部分（Gateway下游调用）</h2><pre><code>feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: full
  httpclient:
    enabled: false
  okhttp:
    enabled: false
</code></pre>
<h3 id="✅-面试可延申："><a href="#✅-面试可延申：" class="headerlink" title="✅ 面试可延申："></a>✅ 面试可延申：</h3><ul>
<li>Feign 的连接&#x2F;读取超时时间如何设置？</li>
<li>loggerLevel 有哪些级别（NONE&#x2F;BASIC&#x2F;HEADERS&#x2F;FULL）？</li>
<li>Feign 支持哪几种底层 HTTP 客户端？为什么要关掉 HttpClient&#x2F;OkHttp？</li>
</ul>
<hr>
<h2 id="✅-四、Redis连接池配置（网关限流、缓存常用）"><a href="#✅-四、Redis连接池配置（网关限流、缓存常用）" class="headerlink" title="✅ 四、Redis连接池配置（网关限流、缓存常用）"></a>✅ 四、Redis连接池配置（网关限流、缓存常用）</h2><pre><code>spring:
  redis:
    database: 12
    host: 192.168.188.120
    port: 6379
    lettuce:
      pool:
        max-active: 1000
        max-idle: 10
        min-idle: 5
</code></pre>
<h3 id="✅-面试展开："><a href="#✅-面试展开：" class="headerlink" title="✅ 面试展开："></a>✅ 面试展开：</h3><ul>
<li><p>为什么使用 Redis？</p>
<blockquote>
<p>作为 <strong>限流、缓存、黑名单过滤、Token 存储</strong> 后端，具备高性能分布式能力</p>
</blockquote>
</li>
<li><p>你们用 Lettuce 还是 Jedis？区别在哪？</p>
</li>
</ul>
<hr>
<h2 id="✅-五、Actuator配置（服务监控）"><a href="#✅-五、Actuator配置（服务监控）" class="headerlink" title="✅ 五、Actuator配置（服务监控）"></a>✅ 五、Actuator配置（服务监控）</h2><pre><code>management:
  server:
    port: 9090
</code></pre>
<ul>
<li>暴露 Spring Boot Actuator 指标信息，常用于结合 Prometheus&#x2F;Grafana 做监控</li>
<li>可暴露如 <code>/actuator/health</code>、<code>/metrics</code>、<code>/gateway/routes</code> 等</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>你们的微服务是怎么监控的？</strong></span></p>
<blockquote>
<p><strong>我们项目中采用的skywalking进行监控的</strong></p>
<ul>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ul>
</blockquote>
<h6 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h6><p>一个分布式系统的应用程序性能监控工具(Application Performance Management), 提供了完善的链路追踪能力，apache的顶级项目(前华为产品经理吴晟主导开源)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/889f98186e8bf25ea018e80457f9333fef009d07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A71.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/33749d5ca478f04bee93c83339a877330485f51a/skywalking%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p>
<blockquote>
<h4 id="✅-面试追问题-amp-答法建议"><a href="#✅-面试追问题-amp-答法建议" class="headerlink" title="✅ 面试追问题 &amp; 答法建议"></a>✅ 面试追问题 &amp; 答法建议</h4><table>
<thead>
<tr>
<th>面试官可能追问的问题</th>
<th>答题建议</th>
</tr>
</thead>
<tbody><tr>
<td>🔸SkyWalking 是怎么接入项目的？</td>
<td>我们使用 Java Agent 的方式，启动时通过 <code>-javaagent:/path/to/skywalking-agent.jar</code> 加载探针，同时在 <code>agent.config</code> 中配置服务名、采集后端等</td>
</tr>
<tr>
<td>🔸和 Zipkin、Prometheus 相比有什么优劣？</td>
<td>SkyWalking 支持 UI 更强，适合链路分析；Prometheus 更适合指标监控配合 Grafana；Zipkin 更轻量但功能少。SkyWalking 是综合性最强的一款</td>
</tr>
<tr>
<td>🔸SkyWalking 的数据存储用的什么？</td>
<td>默认是 ElasticSearch，也支持 H2（测试环境），生产建议搭配 ES 做查询与聚合</td>
</tr>
<tr>
<td>🔸你怎么通过 SkyWalking 优化过接口？</td>
<td>我们发现某个接口 RT 超过 1 秒，通过 Trace 发现是 MySQL 多表 Join 查询导致，优化了 SQL 才解决的</td>
</tr>
<tr>
<td>🔸SkyWalking 能采集哪些组件的数据？</td>
<td>HTTP请求、Dubbo、MySQL、Redis、Kafka、RocketMQ、Elasticsearch 等主流中间件都有探针支持</td>
</tr>
</tbody></table>
<h4 id="✅-加分拓展：如何实现全链路追踪？"><a href="#✅-加分拓展：如何实现全链路追踪？" class="headerlink" title="✅ 加分拓展：如何实现全链路追踪？"></a>✅ 加分拓展：如何实现全链路追踪？</h4><p>SkyWalking 通过在每个服务部署时<strong>挂载探针（agent）</strong>，实现对请求头中 traceId 的自动传递，采集：</p>
<ul>
<li>入参出参（拦截 Controller 层、Feign、RestTemplate）</li>
<li>RPC调用（如Dubbo&#x2F;Feign）</li>
<li>数据库执行耗时</li>
<li>Redis访问</li>
<li>MQ消息链路</li>
</ul>
<p>最终统一聚合在 SkyWalking OAP 端，再通过 Web UI 展示，形成完整的 <strong>“调用链 + 指标 + 日志”</strong> 三位一体监控体系。</p>
<h2 id="✅-项目答题串联建议"><a href="#✅-项目答题串联建议" class="headerlink" title="✅ 项目答题串联建议"></a>✅ 项目答题串联建议</h2><p>你可以在项目介绍环节自然引入这段内容，例如👇：</p>
<blockquote>
<p>为了保障我们微服务系统的稳定性，我们在项目中接入了 SkyWalking 作为 APM 工具。通过它我们做到了链路追踪、性能分析、异常预警等。特别在压测和上线之后，能第一时间通过短信和邮件告警通知我们，提升了系统稳定性和定位效率。</p>
</blockquote>
<p>探针（<strong>Agent</strong>）本质上是一个<strong>Java 程序运行时的字节码增强器</strong>，可以在<strong>不修改源码的前提下</strong>，对目标应用的类和方法进行增强，从而实现请求数据的“埋点采集”。</p>
<hr>
<h3 id="✅-简单理解：探针干了啥？"><a href="#✅-简单理解：探针干了啥？" class="headerlink" title="✅ 简单理解：探针干了啥？"></a>✅ 简单理解：探针干了啥？</h3><p>可以这样比喻👇</p>
<blockquote>
<p>你写的业务代码是演员<br> 探针就是藏在台下的摄像机<br> 它在你表演的时候偷偷把你的一举一动都记录下来（记录你调了哪个接口，用了多久，是不是出错了）</p>
</blockquote>
<hr>
<h3 id="✅-具体工作原理："><a href="#✅-具体工作原理：" class="headerlink" title="✅ 具体工作原理："></a>✅ 具体工作原理：</h3><ol>
<li><strong>运行时注入字节码</strong><ul>
<li>探针是以 <code>-javaagent</code> 参数的形式加载到 JVM 中</li>
<li>JVM 启动时，探针会监听所有类的加载过程，选择特定的类（如 <code>Controller</code>、<code>RestTemplate</code>、<code>JdbcTemplate</code>、<code>RedisTemplate</code>）进行增强</li>
</ul>
</li>
<li><strong>插入监控逻辑</strong><ul>
<li>在方法的前后插入监控逻辑：<ul>
<li>方法开始时记录时间</li>
<li>方法执行完记录耗时、返回值</li>
<li>如果抛出异常，也能捕获异常堆栈</li>
</ul>
</li>
</ul>
</li>
<li><strong>traceId 传递</strong><ul>
<li>每个请求入口（比如 SpringMVC Controller）会生成一个全局 <code>traceId</code></li>
<li>这个 ID 会自动透传到下游服务，比如 Feign 调用、MQ 发送、数据库访问等</li>
<li>最终串成一条完整的调用链路</li>
</ul>
</li>
</ol>
<h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><p>比如你访问这个接口：</p>
<pre><code class="java">@GetMapping(&quot;/user/&#123;id&#125;&quot;)
public User getUser(@PathVariable Long id) &#123;
    return userService.getById(id);
&#125;
</code></pre>
<blockquote>
<p>探针实际会在你这个方法前后<strong>偷偷插入逻辑</strong>（伪代码）：</p>
</blockquote>
<pre><code class="java">// 前置逻辑：记录 traceId、时间戳
recordTrace(&quot;traceId-xxx&quot;);
startTime = System.currentTimeMillis();

User result = userService.getById(id);

// 后置逻辑：记录耗时
long cost = System.currentTimeMillis() - startTime;
sendToSkywalking(traceId, methodName, cost);
</code></pre>
<p>探针就是自动化“打点采集 + 数据上传”的代码增强器，开箱即用，不入侵业务代码。</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下CAP和BASE<del>分布式系统理论</del></strong></span></p>
<blockquote>
<ul>
<li>CAP 定理(一致性、可用性、分区容错性)</li>
</ul>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题(P)</li>
<li>当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足</li>
</ol>
<ul>
<li>BASE理论</li>
</ul>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<ul>
<li>解决分布式事务的思想和模型</li>
</ul>
<ol>
<li><u>最终一致思想</u>：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)</li>
<li><u>强一致思想</u>：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</li>
</ol>
</blockquote>
<ul>
<li>分布式事务方案的指导</li>
<li>分布式系统设计方向</li>
<li>根据业务指导使用正确的技术选择</li>
</ul>
<h5 id="x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标"><a href="#x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标" class="headerlink" title="&#x3D;&#x3D;CAP定理&#x3D;&#x3D;分布式系统无法同时满足三个指标"></a>&#x3D;&#x3D;CAP定理&#x3D;&#x3D;<del>分布式系统无法同时满足三个指标</del></h5><p>CAP 定理是 <strong>数学证明出来的分布式理论限制</strong>，<strong>不是人为规定的规则，而是无法回避的“物理规律”</strong></p>
<ul>
<li>&#x3D;&#x3D;<strong>Consistency</strong>&#x3D;&#x3D;（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。<del>主从一致</del></li>
<li>&#x3D;&#x3D;<strong>Availability</strong>&#x3D;&#x3D;（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li>
<li>&#x3D;&#x3D;<strong>Partition</strong> tolerance&#x3D;&#x3D;（分区容错性）：当出现网络分区现象后，系统能够继续运行<ul>
<li>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点失去链接，形成独立分区</li>
<li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>分布式系统节点之间肯定是需要网络链接的，<strong>分区 (P) 必然存在</strong></li>
<li><u>如果保证访问的高可用性（<strong>A</strong>）可以持续对外提供服务</u>，但不能保证数据的强一致性 <strong>AP</strong></li>
<li><u>如果保证访问的数据强一致性（C）就要放弃高可用性</u> <strong>CP</strong></li>
</ul>
<blockquote>
<h3 id="🎯-CAP-的结论："><a href="#🎯-CAP-的结论：" class="headerlink" title="🎯 CAP 的结论："></a>🎯 CAP 的结论：</h3><blockquote>
<p><strong>在分布式系统中，</strong>由于网络问题不可避免（P必选），所以只能在 C 和 A 之间选其一：</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP 系统</strong></td>
<td>放弃可用性，保证一致性</td>
<td>银行&#x2F;支付系统（宁可服务不可用，也不能出错）</td>
</tr>
<tr>
<td><strong>AP 系统</strong></td>
<td>放弃一致性，保证可用性</td>
<td>电商商品浏览、社交系统（稍微不一致无所谓）</td>
</tr>
</tbody></table>
<h2 id="为什么-CAP-无法同时满足？"><a href="#为什么-CAP-无法同时满足？" class="headerlink" title="为什么 CAP 无法同时满足？"></a>为什么 CAP 无法同时满足？</h2><p>我们来看一个例子理解「<strong>一致性（C） vs 可用性（A）</strong> 在分区故障（P）下的矛盾」：</p>
<hr>
<h3 id="❗-场景设定："><a href="#❗-场景设定：" class="headerlink" title="❗ 场景设定："></a>❗ 场景设定：</h3><ul>
<li>系统有两个节点：<strong>节点A 和 节点B</strong></li>
<li>正常时，A 和 B 通过网络通信同步数据</li>
<li>现在发生了网络分区（<strong>P</strong>）：A 和 B 之间<strong>断网了！</strong></li>
</ul>
<hr>
<h3 id="🧩-你怎么选？C-和-A-只能二选一："><a href="#🧩-你怎么选？C-和-A-只能二选一：" class="headerlink" title="🧩 你怎么选？C 和 A 只能二选一："></a>🧩 你怎么选？C 和 A 只能二选一：</h3><h4 id="✅-如果你要保证【一致性-C】："><a href="#✅-如果你要保证【一致性-C】：" class="headerlink" title="✅ 如果你要保证【一致性 C】："></a>✅ 如果你要保证【<strong>一致性 C</strong>】：</h4><ul>
<li>当客户端向 A 节点写数据时，为了保证一致性，A <strong>必须等待 B 同步成功</strong></li>
<li>但现在 A 和 B 网络断了，同步不了</li>
<li>所以 A 只能拒绝请求：<strong>不响应</strong> —— ❌ 违反了<strong>可用性 A</strong></li>
</ul>
<h4 id="✅-如果你要保证【可用性-A】："><a href="#✅-如果你要保证【可用性-A】：" class="headerlink" title="✅ 如果你要保证【可用性 A】："></a>✅ 如果你要保证【<strong>可用性 A</strong>】：</h4><ul>
<li>A 收到写请求就立刻接受并返回成功</li>
<li>但 B 此时拿到的还是老数据</li>
<li>数据就不一致了 —— ❌ 违反了<strong>一致性 C</strong></li>
</ul>
<hr>
<h3 id="🎯-所以：在【网络分区-P】已发生的前提下-——"><a href="#🎯-所以：在【网络分区-P】已发生的前提下-——" class="headerlink" title="🎯 所以：在【网络分区 P】已发生的前提下 ——"></a>🎯 所以：在【网络分区 P】已发生的前提下 ——</h3><p><strong>你只能选：C+A ❌，C+P ✅，A+P ✅</strong></p>
<p>这就是 CAP 定理的本质逻辑。<br>所以我们在设计系统时必须做<strong>权衡</strong> —— 这正是分布式架构的难点和美感所在。</p>
</blockquote>
<h5 id="x3D-x3D-BASE理论-x3D-x3D"><a href="#x3D-x3D-BASE理论-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;BASE理论&#x3D;&#x3D;"></a>&#x3D;&#x3D;BASE理论&#x3D;&#x3D;</h5><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>&#x3D;&#x3D;<strong>Basically Avaliable</strong>&#x3D;&#x3D;（基本可用）：分布式系统在出现故时，允许损失部分可用性，即保证核心可用</li>
<li>&#x3D;&#x3D;<strong>Soft State</strong>&#x3D;&#x3D;（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>&#x3D;&#x3D;<strong>Eventually Consistent</strong>&#x3D;&#x3D;（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3f0f7a676a51ce6dded96d7c6a910a7c6b763d99/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%92%88%E5%AF%B9CAP%E7%9A%84BASE%E7%90%86%E8%AE%BA.jpg"></p>
<blockquote>
<h4 id="🎯-举个通俗易懂的例子："><a href="#🎯-举个通俗易懂的例子：" class="headerlink" title="🎯 举个通俗易懂的例子："></a>🎯 举个通俗易懂的例子：</h4><p>你去银行转账，系统提示：“<strong>资金将在2小时内到账</strong>”。这就是：</p>
<ul>
<li>✅ 系统可用（你能转账）</li>
<li>✅ 软状态（中间状态是“处理中”）</li>
<li>✅ 最终一致（2小时内一定到账）</li>
</ul>
<p>这就符合 BASE 理论。</p>
<hr>
<h4 id="✅-BASE-与-CAP-的关系？"><a href="#✅-BASE-与-CAP-的关系？" class="headerlink" title="✅ BASE 与 CAP 的关系？"></a>✅ BASE 与 CAP 的关系？</h4><table>
<thead>
<tr>
<th>理论</th>
<th>类型</th>
<th>强调</th>
</tr>
</thead>
<tbody><tr>
<td>CAP</td>
<td>理论限制</td>
<td>三选二原则，强调不可能同时满足一致性、可用性、分区容错</td>
</tr>
<tr>
<td>BASE</td>
<td>实践理念</td>
<td>放弃强一致性，追求最终一致，以换取系统可用性与性能</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/data/CAP%E5%AE%9A%E7%90%86.jpg?raw=true"></p>
<p><span style = "color:red"><strong>你们采用哪种分布式事务解决方案？</strong></span></p>
<blockquote>
<p>● 简历上写的微服务，只要是发生了多个服务之间的<strong>写操作</strong>，都需要进行分布式事务控制</p>
<p>● 描述项目中采用的哪种方案(seataMQ)<br>⚪ seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ seata的AT模式，AP，底层使用undolog 实现，性能好 (<span style = "color:red"><strong>互联网业务</strong></span> )<br>⚪ seata的TCC模式，AP，性能较好，不过需要人工编码实现 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务异步，性能最好 (<span style = "color:red"><strong>互联网业务</strong></span> )</p>
</blockquote>
<ul>
<li>Seata框架(XA、AT、TCC)</li>
<li>MQ</li>
</ul>
<h4 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h4><ul>
<li><strong>TC</strong>(Transaction Coordinator) - <strong>事务协调者</strong>：<u>维护全局和分支事务的状态，协调全局事务提交或回滚</u></li>
<li><strong>TM</strong>(Transaction Manager) - <strong>事务管理器</strong>：定义全局事务的范围、开启全局事务、提交或回滚全局事务</li>
<li><strong>RM</strong>(Resource Manager) - <strong>资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/30dd6983ec4340d3f3f4118f3d5ccf89e4199555/XA%2CAT%2CTCC.png"></p>
<p><span style = "color:red"><strong>分布式服务的<u>接口幂等性</u>如何设计？</strong></span></p>
<blockquote>
<ul>
<li>幕等：多次调用方法或者接口不务状态，可以<strong>保证重复调用的结果和单次调用的结果一致</strong>；常用于支付、下单等关键业务防止<strong>重复提交</strong>。</li>
<li>如果是**<u>新增数据</u>**，可以使用数据库的唯一索引</li>
<li>如果是**<u>新增或修改数据</u>**<ul>
<li>分布式锁，性能较低</li>
<li>使用token+redis来实现，性能较好<br>●  第一次请求，生成一个唯一token存入redis，返回给前端<br>●  第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token; 如果不存在，则直接返回，不处理业务</li>
</ul>
</li>
</ul>
<h4 id="🧠-一、什么是幂等性？"><a href="#🧠-一、什么是幂等性？" class="headerlink" title="🧠 一、什么是幂等性？"></a>🧠 一、什么是幂等性？</h4><ul>
<li>幂等性是指：<strong>一次和多次请求同一个接口，对资源的影响是相同的</strong></li>
<li>幂等操作的特性是：<strong>无副作用（No Side Effect）</strong></li>
</ul>
<h4 id="📌-二、幂等性为什么重要？"><a href="#📌-二、幂等性为什么重要？" class="headerlink" title="📌 二、幂等性为什么重要？"></a>📌 二、幂等性为什么重要？</h4><h5 id="会出现重复调用的原因："><a href="#会出现重复调用的原因：" class="headerlink" title="会出现重复调用的原因："></a>会出现重复调用的原因：</h5><ul>
<li>网络抖动、页面重复点击</li>
<li>分布式事务重试机制</li>
<li>网关重试、MQ重复投递</li>
<li>前端误操作（如双击支付按钮）</li>
</ul>
<h4 id="🎯-三、幂等性保障方案（重点）"><a href="#🎯-三、幂等性保障方案（重点）" class="headerlink" title="🎯 三、幂等性保障方案（重点）"></a>🎯 三、幂等性保障方案（重点）</h4><table>
<thead>
<tr>
<th>场景</th>
<th>适用范围</th>
<th>实现方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 数据库唯一约束</td>
<td>新增接口</td>
<td>通过唯一索引防止重复插入</td>
<td>简单高效</td>
</tr>
<tr>
<td>✅ Token机制 + Redis</td>
<td>提交类（订单、支付）</td>
<td>一次性Token防止重复提交</td>
<td>推荐，效率高</td>
</tr>
<tr>
<td>✅ 分布式锁</td>
<td>修改、转账等接口</td>
<td>基于Redisson、ZK等实现同步控制</td>
<td>精准，但性能稍差</td>
</tr>
<tr>
<td>✅ 接口幂等表</td>
<td>所有需幂等接口</td>
<td>记录请求唯一标识 + 状态</td>
<td>控制最强，适合高并发</td>
</tr>
<tr>
<td>✅ 乐观锁（版本号机制）</td>
<td>更新操作</td>
<td>防止并发更新，CAS思想</td>
<td>要求带版本号字段</td>
</tr>
<tr>
<td>✅ 幂等组件中间件</td>
<td>通用接口平台</td>
<td>拦截层统一幂等处理</td>
<td>企业封装，灵活可控</td>
</tr>
</tbody></table>
<h4 id="🔨-Token-Redis-实现幂等（推荐）"><a href="#🔨-Token-Redis-实现幂等（推荐）" class="headerlink" title="🔨 Token+Redis 实现幂等（推荐）"></a>🔨 Token+Redis 实现幂等（推荐）</h4><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol>
<li>客户端请求创建订单，先调用接口获取 <code>幂等Token</code></li>
<li>后续提交时在请求头中携带该 Token</li>
<li>服务端收到请求：<ul>
<li>判断 Redis 中是否存在该 Token</li>
<li>若存在，则处理业务并删除 Token</li>
<li>若不存在，说明已处理或重复请求，直接返回</li>
</ul>
</li>
</ol>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>轻量级，无锁高并发</li>
<li>可扩展性强，适用于 POST&#x2F;PUT 等需要控制的接口</li>
</ul>
</blockquote>
<p><strong>幂等</strong>：<u>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</u></p>
<h6 id="需要幂等场景"><a href="#需要幂等场景" class="headerlink" title="需要幂等场景"></a>需要幂等场景</h6><ul>
<li>用户重复点击(网络波动)</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时</li>
</ul>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>说明</th>
<th>是否天然幂等</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查询操作，天然幂等</td>
<td>✅ 是</td>
</tr>
<tr>
<td>POST</td>
<td>新增操作，请求一次与请求多次造成的结果不同，<strong>不是幂等的</strong></td>
<td>❌ 否</td>
</tr>
<tr>
<td>PUT</td>
<td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则<strong>不是幂等的</strong></td>
<td>✅ 是（全量）或❌ 否（增量）</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除操作，根据唯一值删除，是幂等的</td>
<td>✅ 是（按主键）</td>
</tr>
</tbody></table>
<pre><code class="mysql">-- 幂等更新：将余额设置为固定值
UPDATE account SET money = 500 WHERE id = 1;

-- 非幂等更新：余额加上500
UPDATE account SET money = money + 500 WHERE id = 1;
</code></pre>
<ul>
<li><p><strong>数据库唯一索引</strong>【新增】</p>
</li>
<li><p><strong>&#x3D;&#x3D;token + redis&#x3D;&#x3D;</strong> 【新增+修改】**<u>AND</u>**  <strong>&#x3D;&#x3D;分布式锁&#x3D;&#x3D;</strong> 【新增+修改】</p>
<blockquote>
<h2 id="🧠-面试答题思路模板"><a href="#🧠-面试答题思路模板" class="headerlink" title="🧠 面试答题思路模板"></a>🧠 面试答题思路模板</h2><p>我们项目中对于需要幂等性的接口（如支付、下单等），主要采用了<strong>Token + Redis机制</strong>：</p>
<ul>
<li>请求前由前端向后端申请一次性 Token</li>
<li>后续接口请求中携带该 Token</li>
<li>后端通过 Redis 判断 Token 是否存在，从而保证接口只被处理一次</li>
</ul>
<p>此外，对于批量创建类操作，还会结合<strong>数据库唯一索引</strong>控制幂等，对于状态更新类操作会使用<strong>乐观锁</strong>或<strong>分布式锁</strong>。</p>
</blockquote>
<h6 id="创建商品、提交订单、转账、支付等操作"><a href="#创建商品、提交订单、转账、支付等操作" class="headerlink" title="创建商品、提交订单、转账、支付等操作"></a>创建商品、提交订单、转账、支付等操作</h6></li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/58b8b5385bf3e40c1661e824f613b15f57686549/token+redis%20AND%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" style="zoom:200%;" />



<p><span style = "color:red"><strong>你们项目中使用了什么分布式任务调度</strong></span></p>
<p><code>xxl-job</code> 是一个分布式任务调度平台，它致力于解决分布式场景下的任务调度问题，主要由调度中心和执行器两部分组成。调度中心负责统一管理任务调度，而执行器则是负责接收调度并执行任务逻辑的客户端。</p>
<blockquote>
<h2 id="🎯-一句话总结"><a href="#🎯-一句话总结" class="headerlink" title="🎯 一句话总结"></a>🎯 一句话总结</h2><blockquote>
<p>我们项目使用的是 <strong>XXL-Job</strong> 分布式任务调度平台，用来实现定时任务管理，比如取消订单、同步库存、发送通知等，解决了分布式环境下定时任务重复、不可控的问题。</p>
</blockquote>
</blockquote>
<ul>
<li><p><span style = "color:red"><strong>xxl-job路由策略有哪些？</strong></span></p>
<blockquote>
<p>xxl-job提供了很多的路由策略，我们平时用的较多的就是：<strong>轮询、故障转移、分片广播</strong></p>
<h2 id="🚦-路由策略有哪些？（面试重点）"><a href="#🚦-路由策略有哪些？（面试重点）" class="headerlink" title="🚦 路由策略有哪些？（面试重点）"></a>🚦 路由策略有哪些？（面试重点）</h2><blockquote>
<p>路由策略就是调度中心选 <strong>哪个执行器节点去执行任务</strong> 的方式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>路由策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round）</strong> ✅</td>
<td>多个节点轮流执行任务，负载均衡常用</td>
</tr>
<tr>
<td><strong>故障转移（Failover）</strong> ✅</td>
<td>优先使用健康节点，失败时自动切换执行</td>
</tr>
<tr>
<td><strong>分片广播（Broadcast）</strong> ✅</td>
<td>每个节点都执行一次任务，适合大数据并行处理</td>
</tr>
<tr>
<td><strong>随机（Random）</strong></td>
<td>随机选取一个可用节点</td>
</tr>
<tr>
<td><strong>一致性哈希</strong></td>
<td>根据任务参数哈希选节点，适合状态保持</td>
</tr>
<tr>
<td><strong>最少运行节点</strong></td>
<td>选当前执行任务最少的机器</td>
</tr>
<tr>
<td><strong>指定机器</strong></td>
<td>手动指定执行器</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>xxl-job任务执行失败怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>路由策略选择<strong>故障转移</strong>，使用健康的实例来执行任务</li>
<li>设置重试次数</li>
<li>查看<strong>日志+邮件</strong>警告来通知相关负责人解决</li>
<li>配置 <strong>任务超时时间 + 告警通知（邮件、短信）</strong></li>
<li>失败日志可在调度中心查看，有堆栈信息</li>
</ul>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>如果有大数据量的任务同时都现需要执行，怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>让多个实例一块去执行(部署集群)，路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行；通过 <code>ShardingContext</code> 拿到当前分片信息</li>
</ul>
<pre><code class="java">@JobHandler(&quot;xxxHandler&quot;)
public ReturnT&lt;String&gt; execute(ShardingContext context) &#123;
    int totalShards = context.getTotalShardCount();
    int shardIndex = context.getShardIndex();

    List&lt;Data&gt; allData = getData();
    for (int i = 0; i &lt; allData.size(); i++) &#123;
        if (i % totalShards == shardIndex) &#123;
            process(allData.get(i));
        &#125;
    &#125;
    return SUCCESS;
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<h2 id="💡-面试高频问法总结"><a href="#💡-面试高频问法总结" class="headerlink" title="💡 面试高频问法总结"></a>💡 面试高频问法总结</h2><table>
<thead>
<tr>
<th>面试问题</th>
<th>回答提示</th>
</tr>
</thead>
<tbody><tr>
<td>你们怎么做定时任务调度？</td>
<td>我们使用 XXL-Job 做分布式定时调度，支持失败重试、分片执行、失败告警</td>
</tr>
<tr>
<td>XXL-Job 怎么实现任务分片？</td>
<td>配置为广播策略，任务中使用 ShardingContext 获取分片信息</td>
</tr>
<tr>
<td>路由策略都有哪些？你们用哪个？</td>
<td>常用<strong>轮询、故障转移、分片广播</strong>；我们大任务用广播，小任务轮询</td>
</tr>
<tr>
<td>如果一个任务执行失败怎么办？</td>
<td>设置了最大重试次数、使用了 Failover 策略、并配置了邮件告警通知</td>
</tr>
<tr>
<td>为什么不用 @Scheduled？</td>
<td>@Scheduled 适用于单体项目，不能解决多实例下重复执行问题；XXL-Job 支持分布式调度、管理界面、执行日志等</td>
</tr>
</tbody></table>
</blockquote>
<h6 id="xxl-job解决的问题"><a href="#xxl-job解决的问题" class="headerlink" title="xxl-job解决的问题"></a>xxl-job解决的问题</h6><ul>
<li>解决集群任务的重复执行问题                   xxl-job路由策略有哪些？</li>
<li>cron表达式定义灵活<del>在页面上</del>                      xxl-job任务执行失败怎么解决？</li>
<li>定时任务失败了，重试和统计                   如果有大数据量的任务同时都需要执行，怎么解决？</li>
<li>任务量大，分片执行</li>
</ul>
<blockquote>
<h4 id="场景-1-定时处理过期订单"><a href="#场景-1-定时处理过期订单" class="headerlink" title="场景 1: 定时处理过期订单"></a>场景 1: <strong>定时处理过期订单</strong></h4><p>假设用户下单后如果订单超过了某个时间没有支付，平台需要自动取消该订单并释放库存。这个任务需要在每天的某个固定时间（比如凌晨 2 点）运行。</p>
<h5 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务调度</strong>：XXL-Job 可以轻松管理该任务的执行时间和周期，确保每天准时执行，不需要开发者手动触发。</li>
<li><strong>任务失败重试</strong>：如果该任务因为某些原因执行失败，XXL-Job 可以自动进行重试，并设置重试次数，确保任务最终被执行。</li>
<li><strong>分布式执行</strong>：假设电商平台是一个分布式系统，订单数据存储在多个数据库中，XXL-Job 可以通过分布式执行确保每个数据库的订单都被正确处理</li>
</ol>
<p><u>假设每晚 2 点有一个任务需要取消未支付的订单</u>：</p>
<pre><code class="java">public class OrderJob &#123;
    @JobHandler(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 查询所有未支付的订单
        List&lt;Order&gt; unpaidOrders = orderService.findUnpaidOrders();
        for (Order order : unpaidOrders) &#123;
            if (order.isExpired()) &#123;
                orderService.cancelOrder(order);
                inventoryService.releaseStock(order.getProductId(), order.getQuantity());
                // 发送订单取消通知给用户
                notificationService.sendOrderCancelledNotification(order.getUserId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-2-定时更新商品库存"><a href="#场景-2-定时更新商品库存" class="headerlink" title="场景 2: 定时更新商品库存"></a>场景 2: <strong>定时更新商品库存</strong></h4><p>假设电商平台上销售的是一些有时效性的商品，商家需要定期更新商品的库存状态（例如，库存数量达到一定阈值时，自动下架商品，或者增加库存数量）。这个任务同样需要定时执行。</p>
<h5 id="解决的问题：-1"><a href="#解决的问题：-1" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>任务分片</strong>：在商品很多的情况下，XXL-Job 可以通过任务分片的方式并行处理不同商品的库存更新，提升任务的执行效率。</li>
<li><strong>任务优先级</strong>：根据不同商品的重要程度，XXL-Job 可以设置任务的优先级，确保关键商品的库存更新优先执行。</li>
</ol>
<pre><code class="java">public class InventoryJob &#123;
    @JobHandler(&quot;inventoryUpdateJobHandler&quot;)
    public void updateProductInventory() &#123;
        // 获取需要更新库存的商品
        List&lt;Product&gt; productsToUpdate = productService.findProductsForInventoryUpdate();
        for (Product product : productsToUpdate) &#123;
            inventoryService.updateInventory(product);
            if (product.getStockQuantity() &lt;= product.getLowStockThreshold()) &#123;
                productService.deactivateProduct(product);
                // 发送商品下架通知
                notificationService.sendOutOfStockNotification(product.getId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-3-定时发送促销活动通知"><a href="#场景-3-定时发送促销活动通知" class="headerlink" title="场景 3: 定时发送促销活动通知"></a>场景 3: <strong>定时发送促销活动通知</strong></h4><p>假设电商平台有一个促销活动，每个活动的开始和结束时间都由后台系统控制。需要在活动开始前 1 小时、活动结束时发送通知给用户。这些通知可以是短信、邮件或 APP 推送通知。</p>
<h5 id="解决的问题：-2"><a href="#解决的问题：-2" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务管理</strong>：XXL-Job 可以定时触发通知任务，确保用户在活动前后及时收到通知。</li>
<li><strong>高并发支持</strong>：在促销活动开始或结束时，平台可能会有大量的通知需要发送，XXL-Job 支持任务的并行处理，可以帮助我们高效地分发通知，避免性能瓶颈。</li>
<li><strong>任务状态监控</strong>：XXL-Job 提供任务的实时监控功能，平台可以随时查看任务的执行情况，确保通知任务按时执行。</li>
</ol>
<pre><code class="java">public class PromotionJob &#123;
    @JobHandler(&quot;promotionNotifyJobHandler&quot;)
    public void sendPromotionNotifications() &#123;
        // 获取当前正在进行的促销活动
        List&lt;Promotion&gt; activePromotions = promotionService.findActivePromotions();
        for (Promotion promotion : activePromotions) &#123;
            if (promotion.isStartingSoon()) &#123;
                notificationService.sendStartNotification(promotion);
            &#125; else if (promotion.isEndingSoon()) &#123;
                notificationService.sendEndNotification(promotion);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="✅-这段代码做了什么？"><a href="#✅-这段代码做了什么？" class="headerlink" title="✅ 这段代码做了什么？"></a>✅ 这段代码做了什么？</h2><pre><code>java复制编辑@JobHandler(&quot;orderCancelJobHandler&quot;)
public void cancelUnpaidOrders() &#123; ... &#125;
</code></pre>
<p>这是一个 XXL-Job 的定时任务处理方法，任务名叫 <code>orderCancelJobHandler</code>，作用是：</p>
<blockquote>
<p><strong>定时扫描所有未支付订单，判断是否过期，过期则取消订单、释放库存并通知用户</strong></p>
</blockquote>
<hr>
<h2 id="🔧-XXL-Job-是怎么运行这个方法的？"><a href="#🔧-XXL-Job-是怎么运行这个方法的？" class="headerlink" title="🔧 XXL-Job 是怎么运行这个方法的？"></a>🔧 XXL-Job 是怎么运行这个方法的？</h2><h3 id="🧩-步骤-1：添加依赖"><a href="#🧩-步骤-1：添加依赖" class="headerlink" title="🧩 步骤 1：添加依赖"></a>🧩 步骤 1：添加依赖</h3><p>在你的 <code>pom.xml</code> 中，需要加入 XXL-Job 的执行器依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
    &lt;version&gt;2.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h3 id="🧩-步骤-2：执行器配置（application-yml）"><a href="#🧩-步骤-2：执行器配置（application-yml）" class="headerlink" title="🧩 步骤 2：执行器配置（application.yml）"></a>🧩 步骤 2：执行器配置（application.yml）</h3><pre><code class="java">xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin
    executor:
      appname: order-job-executor
      address:
      ip:
      port: 9999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken:
</code></pre>
<p>说明：</p>
<ul>
<li><code>admin.addresses</code>: 调度中心地址</li>
<li><code>executor.*</code>: 当前服务是执行器，配置端口、日志路径等</li>
</ul>
<hr>
<h3 id="🧩-步骤-3：启动类开启执行器功能"><a href="#🧩-步骤-3：启动类开启执行器功能" class="headerlink" title="🧩 步骤 3：启动类开启执行器功能"></a>🧩 步骤 3：启动类开启执行器功能</h3><pre><code class="java">@EnableXxlJob
@SpringBootApplication
public class OrderJobExecutorApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderJobExecutorApplication.class, args);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="🧩-步骤-4：创建-JobHandler-并注册到容器"><a href="#🧩-步骤-4：创建-JobHandler-并注册到容器" class="headerlink" title="🧩 步骤 4：创建 JobHandler 并注册到容器"></a>🧩 步骤 4：创建 JobHandler 并注册到容器</h3><pre><code class="java">@Component
public class OrderJob &#123;

    @XxlJob(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 执行任务逻辑
    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>注意</strong>：你用的是 <code>@JobHandler</code>，它是旧版本用法，新版本统一改为 <code>@XxlJob</code>（推荐）</p>
</blockquote>
<hr>
<h3 id="🧩-步骤-5：在调度中心页面注册该任务"><a href="#🧩-步骤-5：在调度中心页面注册该任务" class="headerlink" title="🧩 步骤 5：在调度中心页面注册该任务"></a>🧩 步骤 5：在调度中心页面注册该任务</h3><p>登录调度中心（xxl-job-admin）</p>
<ul>
<li>新建任务<ul>
<li>执行器：选择 <code>order-job-executor</code></li>
<li>JobHandler名称：<code>orderCancelJobHandler</code></li>
<li>调度类型：如“CRON”</li>
<li>执行方式：BEAN 模式</li>
<li>CRON 表达式：比如每天凌晨 2 点 <code>0 0 2 * * ?</code></li>
</ul>
</li>
<li>保存并启动任务</li>
</ul>
</blockquote>
<h6 id="xxl-job路由策略有哪些？"><a href="#xxl-job路由策略有哪些？" class="headerlink" title="xxl-job路由策略有哪些？"></a>xxl-job路由策略有哪些？</h6><p>实例找任务项执行任务 这种<strong>找机器的方式</strong>就是路由策略</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ee1e805b34b443e5fed49434ec33e59c264894b/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5.png"></p>
<h3 id="消息中间件RabbitMQ-Kafka"><a href="#消息中间件RabbitMQ-Kafka" class="headerlink" title="消息中间件RabbitMQ+Kafka"></a><span style = "color:blue">消息中间件<del>RabbitMQ+Kafka</del></span></h3><h6 id="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"><a href="#消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦" class="headerlink" title="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"></a>消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦</h6><p><strong>RabbitMQ</strong>：**<u>消息不丢失、消息重复消费、消息堆积、延迟队列、死信队列、高可用机制</u>**<br><strong>Kafka</strong>：**<u>消息不丢失、消息重复消费、高可用机制、高性能设计</u><del>吞吐量达到百万级</del>、<u>数据存储和清理</u>**</p>
<p><span style = "color:red"><strong>RabbitMQ-如何保证消息不丢失？</strong></span></p>
<blockquote>
<ul>
<li><p><u>开启<strong>生产者确认机制</strong>，确保生产者的消息能到达队列</u><br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
<blockquote>
<p>达到队列成功返回<code>ack</code>，失败返回<code>nack</code>【<u><strong>n</strong>egative <strong>ack</strong>nowledgment</u>】</p>
<ol>
<li>生产者发送消息到交换机。</li>
<li>交换机收到消息后，根据绑定规则（是否有匹配的队列）决定消息是否被正确路由。</li>
<li>如果消息成功路由到队列，交换机会向生产者返回 <code>ack</code> 确认。</li>
<li>如果消息没有成功路由到任何队列，交换机会通过 <code>return</code> 将消息退回给生产者。</li>
<li>生产者收到 <code>ack</code> 或 <code>nack</code>，可以处理消息确认或重试逻辑。</li>
</ol>
</blockquote>
</li>
<li><p><u>开启<strong>持久化功能</strong>，确保消息未消费前在队列中不会丢失</u>   <code>durable = True</code><br>万一broker挂掉就惨了 保证至少成功一次消费<br>MQ是默认内存存储信息，开启持久化功能可以确保缓存在MQ中的消息不丢失[把数据存在磁盘上]</p>
<pre><code class="python"># 声明持久化交换器
channel.exchange_declare(exchange=&#39;exchange_name&#39;, durable=True)
      
# 声明持久化队列
channel.queue_declare(queue=&#39;queue_name&#39;, durable=True)
      
# 发送持久化消息
channel.basic_publish(exchange=&#39;exchange_name&#39;,
                      routing_key=&#39;routing_key&#39;,
                      body=&#39;Hello World!&#39;,
                      properties=pika.BasicProperties(
                         delivery_mode=2,  # 使消息持久化
                      ))
</code></pre>
</li>
<li><p><u>开启<strong>消费者确认机制</strong>为auto，由spring确认消息处理成功后完成ack</u><br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：**<u>消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息</u>**，而Spring AMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h5 id="x3D-x3D-生产者确认机制-x3D-x3D"><a href="#x3D-x3D-生产者确认机制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;</h5><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ad3b4f558db898d6e3a53744beb5512a958f9f57/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>RabbitMQ消息的重复消费问题如何解决的？</strong></span></p>
<blockquote>
<p>我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息，这样就重复消费了<br><u>因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。<strong>如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</strong></u>。</p>
</blockquote>
<h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>解决方案：<del>适用于任何MQ(Kafka，RabbitMQ，RocketMQ)</del></p>
<ul>
<li><strong>每条消息设置一个唯一的标识id</strong></li>
<li>幂等方案：【<strong>分布式锁</strong>、数据库锁(悲观锁、乐观锁)】</li>
</ul>
<p><span style = "color:red"><strong>RabbitMQ中死信交换机？(RabbitMQ延迟队列有了解过吗)</strong></span></p>
<p>如果用原来的定时任务 也可以但是 可能会有订单空窗期 如果没人消费的时候 它内部还是回去sql查询<strong>已下单</strong> +(now()-下单时间)?15min : true, false</p>
<blockquote>
<ul>
<li>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布）</li>
<li>其中<strong>延迟队列</strong>就用到了<strong>死信交换机</strong>和<strong>TTL</strong>（消息存活时间）实现的</li>
<li>消息超时未消费就会变成死信（死信的其他情况：<strong>拒绝被消费，队列满了</strong>）</li>
</ul>
<blockquote>
<p><strong>我们用延迟队列处理未支付订单</strong>：用户下单后 15 分钟未付款，自动取消订单+释放库存；其他场景也用到延迟队列，比如限时促销、定时发布文章、定时发通知等。</p>
</blockquote>
<p>延迟队列插件实现延迟队列<code>DelayExchange</code><br><strong>延迟队列</strong>的底层实现就是通过 TTL（消息存活时间）+ 死信交换机（DLX）组合完成的。</p>
<ul>
<li>声明一个交换机，添加delayed属性为true</li>
<li>发送消息时，添加<code>x-delay</code>头，值为超过时间</li>
</ul>
<pre><code class="java">什么样的消息会成为死信？
★ 消费者返回reject或者nack，且requeue参数设置为false【消息被拒绝并且不重入队列】
★ 消息超时未消费
★ 队列满了

如何给队列绑定死信交换机？
★ 给队列设置dead-letter-exchange属性，指定一个交换机
★ 给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey

------------------------------------------------------------------------
★ ★ ★ 使用 Spring AMQP 配置 ★ ★ ★ 
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig &#123;

    // 定义普通队列
    @Bean
    public Queue normalQueue() &#123;
        return new Queue(&quot;normalQueue&quot;, true, false, false, 
                Map.of(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;, 
                       &quot;x-dead-letter-routing-key&quot;, &quot;dlx_routing_key&quot;));
    &#125;

    // 定义死信队列
    @Bean
    public Queue dlxQueue() &#123;
        return new Queue(&quot;dlxQueue&quot;, true);
    &#125;

    // 定义普通交换机
    @Bean
    public Exchange normalExchange() &#123;
        return new TopicExchange(&quot;normal_exchange&quot;);
    &#125;

    // 定义死信交换机
    @Bean
    public Exchange dlxExchange() &#123;
        return new TopicExchange(&quot;dlx_exchange&quot;);
    &#125;

    // 将普通队列与交换机绑定
    @Bean
    public Binding bindNormalQueue() &#123;
        return BindingBuilder.bind(normalQueue()).to(normalExchange()).with(&quot;normal.routing.key&quot;).noargs();
    &#125;

    // 将死信队列与死信交换机绑定
    @Bean
    public Binding bindDLXQueue() &#123;
        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(&quot;dlx_routing_key&quot;).noargs();
    &#125;
&#125;
------------------------------------------------------------------------
如果你希望将死信队列配置成带有过期时间或其他特殊属性的队列，可以在定义 dlxQueue 时增加更多的设置，例如 TTL（过期时间）。
例如，设置死信队列的 TTL：

@Bean
public Queue dlxQueue() &#123;
    return QueueBuilder.durable(&quot;dlxQueue&quot;)
            .withArgument(&quot;x-message-ttl&quot;, 60000) // 设置TTL为60秒
            .build();
&#125;
</code></pre>
<pre><code class="java">✅ Spring AMQP 中配置延迟队列 + 死信队列（简洁版）

@Bean
public Queue orderQueue() &#123;
    return QueueBuilder.durable(&quot;order.queue&quot;)
            .ttl(15 * 60 * 1000) // 15分钟TTL
            .deadLetterExchange(&quot;dlx.exchange&quot;) // 超时后投递到死信交换机
            .deadLetterRoutingKey(&quot;order.dlx&quot;)  // 指定死信路由key
            .build();
&#125;

@Bean
public Queue orderDLXQueue() &#123;
    return new Queue(&quot;order.dlx.queue&quot;);
&#125;
</code></pre>
</blockquote>
<h6 id="延迟队列-x3D-死信交换机-TTL-生存时间"><a href="#延迟队列-x3D-死信交换机-TTL-生存时间" class="headerlink" title="延迟队列 &#x3D; 死信交换机 + TTL (生存时间)"></a><span style = "color:blue">延迟队列 &#x3D; 死信交换机 + TTL (生存时间)</span></h6><ul>
<li><strong>延迟队列</strong>：进入队列的消息会被延迟消费的队列</li>
<li><strong>场景</strong>：超时订单、限时优惠，定时发布</li>
</ul>
<h6 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h6><p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>(dead letter)：</p>
<ul>
<li>消费者使用basic.reject 或 basic.nack声明消费失败，并且信息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>(Dead Letter Exchange，简称DLX)</p>
<pre><code class="java">@Bean
public QUeue ttlQueue()&#123;
    return QueueBuilder.durable(&quot;simple.queue&quot;) // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间 10秒
        .deadLetterExchange(&quot;dl.direct&quot;) // 指定死信交换机
        .build();
&#125;
</code></pre>
<pre><code class="yaml">✅ 死信交换机配置核心属性（面试考点）

x-dead-letter-exchange: 死信交换机名称
x-dead-letter-routing-key: 投递死信用的路由key
x-message-ttl: 消息过期时间（单位：毫秒）
</code></pre>
<h6 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h6><p>TTL(Time-To-Live)。如果一个队列中的消息TTL结束仍未消费，则会变成死信，ttl超时分为两种情况：</p>
<ul>
<li><strong>消息所在的队列设置了存活时间</strong></li>
<li><strong>消息本身设置了存活时间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/50eb7d1338c4fdae6ee9c65274b3116ac361514d/%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="死信图片"></p>
<p><span style = "color:red"><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决(消息堆积怎么解决)？</strong><br></span></p>
<p>消息堆积的本质是消费能力不足，解决重点是提升消费者处理能力 + 降低系统压力。</p>
<blockquote>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li><strong>增加更多消费者</strong>，提高消费速度</li>
<li>在消费者内<strong>开启线程池</strong>加快消息处理速度</li>
<li><strong>扩大队列容积</strong>，提高堆积上限<ul>
<li>在声明队列的时候可以设置<code>x-queue-model</code>为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
</blockquote>
<p>当<strong>生产者发送消息的速度超过了消费者处理消息的速度</strong>，就会导致队列中的<strong>消息堆积</strong>，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h6 id="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？"><a href="#达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？" class="headerlink" title="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？"></a>达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？</h6><blockquote>
<p>使用死信交换机（DLX, Dead Letter Exchange）是另一种处理消息堆积的方式，但它的作用更偏向于“消息过期”或“处理失败”的情况下将消息转发到另一个队列。并不直接解决生产者发送消息过快或消费者处理速度过慢的问题。通过死信交换机，你可以将无法处理的消息转发到其他队列，方便你后续进行分析或处理，但它并不能提高消费者处理消息的速度。</p>
<p>针对消息堆积的本质问题，解决方式更多的是优化消费者处理能力，而不是仅依赖死信交换机。具体而言，死信交换机和你的三种思路的关系如下：</p>
<ol>
<li><strong>死信交换机（DLX）</strong>：当消息达到队列上限或无法消费时，消息被转发到死信队列。你可以分析死信队列中的消息，了解原因，并决定是重试、丢弃还是进行其他处理。它的作用是<strong>不丢失消息</strong>，但并不能帮助消除堆积。</li>
<li><strong>增加消费者</strong>：这是直接针对堆积的根本解决方案，通过增加消费者数量来加速消息的处理。死信交换机无法直接解决消费者处理能力不足的问题。</li>
<li><strong>开启消费者线程池</strong>：在单个消费者上开启线程池，可以提高消费者的处理能力，减少堆积。死信交换机并不能增加消息处理速度，它只是用来应对消费失败的情况。</li>
<li><strong>扩大队列容量并使用惰性队列</strong>：惰性队列可以将消息存储在磁盘上，而非内存中，减轻内存压力，但这也会降低时效性，并不能解决生产者生产过快或消费者消费过慢的问题。死信交换机同样无法直接解决这一点。</li>
</ol>
<p>总结来说，死信交换机是处理消息丢失或无法消费的方式，它和通过增加消费者、线程池、队列优化这些手段并不冲突，但也无法替代这些更直接的解决方案。你可以结合这两者，使用死信交换机来保障消息不丢失，同时采取上述方法来提高消息消费速度。</p>
<p>死信交换机主要作用是<strong>保底机制</strong>，用于<strong>处理失败的消息</strong>，比如超时、拒绝、队列满。它不能真正解决堆积问题，只能<strong>帮我们兜底不丢消息</strong>。<br>所以，我们会<strong>搭配使用</strong>：前面是用多线程和惰性队列来<strong>压堆积</strong>，后面用死信队列来<strong>兜住异常消息</strong>，保障系统稳定。</p>
</blockquote>
<h6 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h6><p>惰性队列特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<pre><code class="java">@Bean
public Queue lazyQueue()&#123;
    return QueueBuilder
            .durable(&quot;lazy.queue&quot;)
            .lazy() // 设置为惰性队列，落盘存储
            .build();
&#125;

// 惰性队列是 RabbitMQ 提供的一种机制，消息直接写入磁盘，内存消耗小，堆积能力强，适合处理海量不紧急消息。但缺点是消费速度会稍慢，因为要从磁盘读。
</code></pre>
<pre><code class="java">@RabbitListener(queuesToDeclare = @Queue)&#123;
    name = &quot;lazy.queue&quot;,
    durable = &quot;true&quot;,
    arguments = @Argument(name = &quot;x-queue-mode&quot;), value=&quot;lazy&quot;
&#125;
public void listenLazyQUeue(String msg)&#123;
    log.info(&quot;接收到lazy.queue的消息：&#123;&#125;&quot;,msg);
&#125;
</code></pre>
<p>提高消费能力是解决堆积的根本；惰性队列能缓解内存压力，死信机制是辅助保障不丢消息。三者应配合使用。</p>
<p><strong><span style = "color:red">RabbitMQ高可用机制有了解过吗？ &amp;&amp;  请描述 RabbitMQ 镜像队列的工作原理及其在高可用性场景下的优缺点<br></span></strong></p>
<blockquote>
<p>在我们项目中，为了保障消息队列的高可用性，我们采用了 RabbitMQ 的镜像队列集群部署方案，后来也了解并测试了仲裁队列来提升一致性保障。</p>
<p>我们当时的项目在生产环境下，采用的是镜像模式搭建的集群，共有3个节点<br>镜像队列结构是一主多从(从就是镜像)，所有(写)操作都是主节点完成，然后同步给镜像节点<br>主宕机后，镜像节点会代替成为新的主(如果在主从同步完成前，主就已经宕机，可能出现数据丢失)</p>
<h5 id="🔹-RabbitMQ-高可用机制对比三种："><a href="#🔹-RabbitMQ-高可用机制对比三种：" class="headerlink" title="🔹 RabbitMQ 高可用机制对比三种："></a>🔹 RabbitMQ 高可用机制对比三种：</h5><table>
<thead>
<tr>
<th>模式</th>
<th>原理</th>
<th>是否同步消息</th>
<th>容灾能力</th>
<th>是否强一致</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>普通集群</td>
<td>共享元数据，不同步消息内容</td>
<td>❌</td>
<td>弱</td>
<td>❌</td>
<td>测试、非关键业务</td>
</tr>
<tr>
<td>镜像队列</td>
<td>主节点写入，同步到镜像节点</td>
<td>✅</td>
<td>中</td>
<td>弱~中</td>
<td>读多写少</td>
</tr>
<tr>
<td>仲裁队列</td>
<td>Raft 协议选主，多节点确认写入</td>
<td>✅</td>
<td>强</td>
<td>✅（强一致）</td>
<td>关键数据、支付</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>那出现丢数据怎么解决呢？</strong><br></span></p>
<blockquote>
<p>我们可以采用<strong>仲裁队列</strong>，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于<span style = "color:blue"><u><strong>wwwwwwwwwwwwwwwwwwwww</strong></u></span>，强一致性，并且使用起来也非常简单，不需要格外的配置，<strong>在声明队列的时候只需要指定这个是仲裁队列即可</strong></p>
<blockquote>
<p>Raft 协议 是一种 <strong>共识算法（Consensus Algorithm）</strong>；<br>🔴 <strong>在分布式系统中，让多个节点就某个值达成一致（即使有部分节点故障）</strong><br>Raft 就是“几个节点如何选出一个 Leader，让它来统筹所有更新，然后让大多数节点<strong>都确认成功后</strong>再算真正提交成功”。<br>为了避免这些 <strong>“脑裂、数据冲突”</strong> 问题，就需要一种 <strong>“大家达成共识”</strong> 的机制，<strong>Raft 协议就是这种机制</strong>🏗️ Raft 核心角色和流程</p>
<h3 id="✅-Raft-有三种角色："><a href="#✅-Raft-有三种角色：" class="headerlink" title="✅ Raft 有三种角色："></a>✅ Raft 有三种角色：</h3><table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Leader</td>
<td>主节点，唯一能接收客户端写请求</td>
</tr>
<tr>
<td>Follower</td>
<td>跟随者，接受 Leader 同步数据</td>
</tr>
<tr>
<td>Candidate</td>
<td>候选人，用于选举新 Leader</td>
</tr>
</tbody></table>
<h3 id="✅-正常流程："><a href="#✅-正常流程：" class="headerlink" title="✅ 正常流程："></a>✅ 正常流程：</h3><ol>
<li>所有节点刚启动时，都是 Follower。</li>
<li>一段时间内没收到 Leader 的心跳，会变成 Candidate，发起投票选举。</li>
<li>多数投票成功后，变成新的 Leader。</li>
<li><strong>所有写请求只能由 Leader 处理</strong>，然后同步给其他节点（Follower）。</li>
<li>如果 <strong>大多数节点都确认写入成功</strong>，则这条数据才算真正提交成功。</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、<strong>镜像集群</strong>、仲裁队列(Raft协议)</li>
</ul>
<h5 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h5><p>普通集群，或者叫标准集群(classic cluster)</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的信息</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<h5 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h5><p>镜像集群：本质是<strong>主从模式</strong>，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其他节点叫做该队列的<strong>镜像</strong>节点</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<blockquote>
<h2 id="🔹-镜像队列原理（项目中实际使用）"><a href="#🔹-镜像队列原理（项目中实际使用）" class="headerlink" title="🔹 镜像队列原理（项目中实际使用）"></a>🔹 镜像队列原理（项目中实际使用）</h2><blockquote>
<p>在我们的生产环境中，RabbitMQ 集群采用的是 <strong>镜像队列（Classic Mirrored Queue）</strong> 模式，有以下特点：</p>
</blockquote>
<ul>
<li><strong>主从同步：</strong> 队列存在一个主节点，多个镜像节点。</li>
<li><strong>所有写操作都落在主节点，随后同步给镜像节点</strong>。</li>
<li>如果主节点宕机，镜像节点会被选举为新主。</li>
<li>同步存在延迟，一旦主节点宕机且尚未同步完，就可能<strong>出现数据丢失</strong>。</li>
</ul>
<h3 id="💡-镜像队列优点："><a href="#💡-镜像队列优点：" class="headerlink" title="💡 镜像队列优点："></a>💡 镜像队列优点：</h3><ul>
<li>数据有副本，具备一定容灾能力</li>
<li>节点可切换，保证服务不中断</li>
</ul>
<h3 id="⚠-镜像队列缺点："><a href="#⚠-镜像队列缺点：" class="headerlink" title="⚠ 镜像队列缺点："></a>⚠ 镜像队列缺点：</h3><ul>
<li>主从同步可能延迟 → <strong>存在数据丢失风险</strong></li>
<li>配置复杂、资源开销大，<strong>大集群下性能差</strong></li>
</ul>
<hr>
<h2 id="🔹-那出现丢数据怎么办？"><a href="#🔹-那出现丢数据怎么办？" class="headerlink" title="🔹 那出现丢数据怎么办？"></a>🔹 那出现丢数据怎么办？</h2><blockquote>
<p>我们后来开始测试和使用了 <strong>仲裁队列（Quorum Queue）</strong>，它在 3.8+ 中推出，作为镜像队列的替代方案，<strong>支持强一致性</strong>。</p>
</blockquote>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/59b655f55c1f3031f72c5790425b8ae8e76e9d1f/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" style="zoom:150%;" />

<h5 id="仲裁队列：-quorum"><a href="#仲裁队列：-quorum" class="headerlink" title="仲裁队列：.quorum()"></a>仲裁队列：<del>.quorum()</del></h5><p>仲裁队列是<strong>3.8版本</strong>以后才有的新功能，用来替代镜像队列</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于<strong>Raft</strong>协议，强一致性</li>
</ul>
<p>仲裁队列的工作原理如下：</p>
<ol>
<li><strong>主从模式</strong>：仲裁队列也是主从模式，支持主从数据同步。</li>
<li><strong>Raft 协议</strong>：主从同步基于 Raft 协议，确保数据的一致性和可靠性。</li>
<li><strong>强一致性</strong>：所有写操作必须得到大多数节点的确认后才能完成，避免了数据丢失。</li>
</ol>
<p>仲裁队列通过以下机制保证数据不丢失：</p>
<ul>
<li><strong>多数派确认</strong>：<u>每次写操作需要得到大多数节点的确认，确保数据已经成功复制到多个节点</u>。</li>
<li><strong>自动故障转移</strong>：如果主节点宕机，<strong>Raft 协议</strong>会自动选举新的主节点，确保服务的连续性。</li>
<li><strong>数据一致性</strong>：<u>Raft 协议保证了数据的<strong>强一致性</strong></u>，即使在网络分区或节点宕机的情况下，也不会出现数据不一致的问题。</li>
</ul>
<p>仲裁队列的优点是配置简单、数据强一致，但需要至少 3 个节点，并且在写操作上的延迟和资源消耗可能会比镜像队列高。</p>
<pre><code class="java">@Bean
public Queue quorumQueue()&#123;
    return QueueBuilder
            .durable(&quot;quorum.queue&quot;) // 持久化
            .quorum() // 仲裁队列
            .build();
&#125;
</code></pre>
<p><span style = "color:red"><strong>Kafka是如何保证消息不丢失？</strong><br></span></p>
<blockquote>
<p>需要从三个层面去解决这个问题</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数消息</li>
</ul>
</li>
<li><p>在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式：最好是<strong>同步+异步提交</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>使用Kafka在消息的收发过程中都会出现消息丢失，Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
</blockquote>
<p>kafka-高产出的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065">分布式消息系统</a>(A high-throughput distributed messaging system)。</p>
<p>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统，利用Kafka技术可以在廉价的PC Server上搭建起大规模消息系统。</p>
<h5 id="Kafka的特性："><a href="#Kafka的特性：" class="headerlink" title="Kafka的特性："></a><strong>Kafka的特性：</strong></h5><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作；</li>
<li>可扩展性：kafka集群支持热扩展；</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/backup?from_column=20065&from=20065">数据备份</a>防止数据丢失；</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）；</li>
<li>高并发：支持数千个客户端同时读写；</li>
<li>支持实时在线处理和离线处理：可以使用Storm这种实时流处理系统对消息进行实时进行处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</li>
</ul>
<p>Kafka和其他组件比较，具有消息持久化、高吞吐、分布式、多客户端支持、实时等特性，适用于离线和在线的消息消费，如常规的消息收集、网站活性跟踪、聚合统计系统运营数据（监控数据）、日志收集等大量数据的互联网服务的数据收集场景。</p>
<ol>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如Hadoop、Hbase、Solr等；</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等；</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到Hadoop、数据仓库中做离线分析和挖掘；</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</li>
<li>流式处理：比如spark streaming和storm；</li>
<li>事件源；</li>
<li>kafka在FusionInsight中的位置：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fcebf13cb4e2d12dc10727d9d5942720bbd114e6/Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>Kafka是如何保证消费的顺序性？</strong><br></span></p>
<blockquote>
<p>Kafka 保证消息不丢失需要从 <strong>生产者、Broker、消费者</strong> 三个维度考虑：</p>
<ol>
<li><strong>生产者侧</strong>：通过设置 <code>acks=all</code>、启用 <code>幂等性（enable.idempotence=true）</code>、配置 <code>重试机制</code> 等，确保消息可靠送达 Kafka。</li>
<li><strong>Broker 侧</strong>：通过消息持久化、<code>副本同步机制（ISR）</code>、故障转移机制等，确保存储端可靠。</li>
<li><strong>消费者侧</strong>：通过 <code>关闭自动提交 offset</code>，使用手动同步&#x2F;异步提交，并搭配幂等消费逻辑，避免消息处理丢失。</li>
</ol>
<p>多项机制结合，共同保障 Kafka 在高吞吐、高并发下仍具备良好的可靠性与稳定性。</p>
</blockquote>
<blockquote>
<p><strong>问题原因：</strong><br>一个topic的数据可能存储在不同的分区中 ，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>&#x3D;&#x3D;<strong>解决方案：</strong>&#x3D;&#x3D;</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行金额变更，短信通知必须要有顺序</li>
</ul>
</blockquote>
<p>承接上图<code>消费者从Brocker接收消息丢失</code>：<br><strong>如何做</strong>？→ topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<pre><code class="java">// 指定分区
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,0,&quot;key-001&quot;,&quot;value-001&quot;);
// 相同的业务key
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,&quot;key-001&quot;,&quot;value-001&quot;);
</code></pre>
<p>会计算key的hashcode值推断出它在哪个分区，如果要求有顺序性 就可以设置同一个key，此时hash值都是一样的 就可以在同一个分区存储</p>
<p><span style = "color:red"><strong>Kafka的高可用机制有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>集群模式</strong>&#x3D;&#x3D;</p>
<p>一个kafka集群由多个broker实例组成，即使某一台宕机，也不会耽误其他broker继续对外提供服务</p>
</li>
<li><p>&#x3D;&#x3D;<strong>分区备份机制</strong>&#x3D;&#x3D;</p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="✅-真实业务场景案例：订单创建消息流的高可用设计（基于-Kafka）"><a href="#✅-真实业务场景案例：订单创建消息流的高可用设计（基于-Kafka）" class="headerlink" title="✅ 真实业务场景案例：订单创建消息流的高可用设计（基于 Kafka）"></a>✅ 真实业务场景案例：订单创建消息流的高可用设计（基于 Kafka）</h5><blockquote>
<h6 id="🟡-业务背景"><a href="#🟡-业务背景" class="headerlink" title="🟡 业务背景"></a>🟡 业务背景</h6><p>你在做一个电商平台系统，其中<strong>订单创建之后</strong>，需要进行如下异步操作：</p>
<ol>
<li>通知库存中心扣减库存</li>
<li>通知积分服务赠送用户积分</li>
<li>通知数据中心写入大数据平台（如 HDFS）</li>
</ol>
<p>为了解耦服务、削峰填谷，并保障消息不丢失，我们决定使用 Kafka 进行消息中转。</p>
<hr>
<h6 id="🟧-Kafka-高可用设计"><a href="#🟧-Kafka-高可用设计" class="headerlink" title="🟧 Kafka 高可用设计"></a>🟧 Kafka 高可用设计</h6><h6 id="▶-架构图概览（文字版）"><a href="#▶-架构图概览（文字版）" class="headerlink" title="▶ 架构图概览（文字版）"></a>▶ 架构图概览（文字版）</h6><pre><code class="java">[订单服务 OrderService] 
    |
    | 生产消息 send(order_id=1001)
    ▼
[Kafka集群 topic=order-create partition=0,1,2]        
    |  partition-0：leader 在 broker1，follower 在 broker2,3
    |  partition-1：leader 在 broker2，follower 在 broker1,3
    |  partition-2：leader 在 broker3，follower 在 broker1,2
    ▼
[消费者集群]
  ├── 库存服务（group=stock）
  ├── 积分服务（group=points）
  └── 数据服务（group=bigdata）
</code></pre>
<h6 id="🔵-Kafka-高可用机制在这里怎么体现？"><a href="#🔵-Kafka-高可用机制在这里怎么体现？" class="headerlink" title="🔵 Kafka 高可用机制在这里怎么体现？"></a>🔵 Kafka 高可用机制在这里怎么体现？</h6><h5 id="✅-1-Kafka-集群部署（Broker-多节点）"><a href="#✅-1-Kafka-集群部署（Broker-多节点）" class="headerlink" title="✅ 1. Kafka 集群部署（Broker 多节点）"></a>✅ 1. Kafka <strong>集群部署</strong>（Broker 多节点）</h5><p>部署 3 个 Kafka Broker：</p>
<pre><code>broker.id=1,2,3 分别配置在三台服务器上
</code></pre>
<blockquote>
<p>即便其中任意一台 Broker 宕机，剩下两台仍然可以继续服务。</p>
</blockquote>
<h5 id="✅-2-Topic-分区-副本机制"><a href="#✅-2-Topic-分区-副本机制" class="headerlink" title="✅ 2. Topic 分区 + 副本机制"></a>✅ 2. <strong>Topic 分区 + 副本机制</strong></h5><p>创建 topic 时设定副本数：</p>
<pre><code class="java">bin/kafka-topics.sh --create \
  --topic order-create \
  --partitions 3 \
  --replication-factor 3 \
  --zookeeper zk1:2181
</code></pre>
<ul>
<li><p>每个分区会有 <strong>1 个 leader + 2 个 follower</strong></p>
</li>
<li><p>Leader 负责读写，follower 同步数据</p>
</li>
<li><p>当 Leader 所在 Broker 宕机时，Kafka 会<strong>自动从 ISR 列表中选一个 follower 升级为 leader</strong><br>🔁 例如：</p>
</li>
<li><p>原来 partition-0 的 leader 是 broker1</p>
</li>
<li><p>broker1 崩了 → Kafka Controller 会选 broker2 或 broker3 提升为新 leader</p>
</li>
</ul>
<h5 id="✅-3-生产者配置-acks-x3D-all-幂等性"><a href="#✅-3-生产者配置-acks-x3D-all-幂等性" class="headerlink" title="✅ 3. 生产者配置 acks&#x3D;all + 幂等性"></a>✅ 3. <strong>生产者配置 acks&#x3D;all + 幂等性</strong></h5><p>为了保障消息可靠写入 Kafka：</p>
<pre><code class="java">props.put(&quot;acks&quot;, &quot;all&quot;); // 所有副本都确认才算成功
props.put(&quot;enable.idempotence&quot;, &quot;true&quot;); // 避免重复投递
</code></pre>
<p>📝 所以生产者即便 retry 了，也不会生成重复消息。</p>
<h5 id="✅-4-消费者使用手动提交-offset"><a href="#✅-4-消费者使用手动提交-offset" class="headerlink" title="✅ 4. 消费者使用手动提交 offset"></a>✅ 4. <strong>消费者使用手动提交 offset</strong></h5><p>为了保证消费者处理完消息再提交 offset，避免消息处理失败却误提交偏移量：</p>
<pre><code class="java">props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);

while (true) &#123;
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord&lt;String, String&gt; record : records) &#123;
        // 处理消息
        process(record);
    &#125;
    consumer.commitSync(); // 处理完手动提交
&#125;
</code></pre>
<h6 id="🔻-模拟突发事件：Kafka-Broker-宕机，系统是否正常？"><a href="#🔻-模拟突发事件：Kafka-Broker-宕机，系统是否正常？" class="headerlink" title="🔻 模拟突发事件：Kafka Broker 宕机，系统是否正常？"></a>🔻 模拟突发事件：Kafka Broker 宕机，系统是否正常？</h6><h6 id="❓-假设-Broker1-宕机，会发生什么？"><a href="#❓-假设-Broker1-宕机，会发生什么？" class="headerlink" title="❓ 假设 Broker1 宕机，会发生什么？"></a>❓ 假设 Broker1 宕机，会发生什么？</h6><ul>
<li>partition-0 的 leader 在 broker1 → Kafka Controller 自动将 broker2 提升为新的 leader</li>
<li>生产者发送消息依然正常（因为 follower 已同步数据）</li>
<li>消费者照常消费 partition-0 的数据</li>
</ul>
<h2 id="✅-总结一波这个真实案例带来的知识点"><a href="#✅-总结一波这个真实案例带来的知识点" class="headerlink" title="✅ 总结一波这个真实案例带来的知识点"></a>✅ 总结一波这个真实案例带来的知识点</h2><table>
<thead>
<tr>
<th>组件</th>
<th>高可用机制</th>
<th>关键作用</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka 集群</td>
<td>多 Broker + Controller</td>
<td>任一节点挂掉不影响整体服务</td>
</tr>
<tr>
<td>Topic 分区副本</td>
<td>leader + follower</td>
<td>保证消息副本安全、自动故障转移</td>
</tr>
<tr>
<td>Producer</td>
<td>acks&#x3D;all + 幂等性</td>
<td>防止生产过程中消息丢失或重复</td>
</tr>
<tr>
<td>Consumer</td>
<td>手动提交 offset</td>
<td>避免处理失败误提交偏移量</td>
</tr>
</tbody></table>
<h2 id="❓面试模拟追问"><a href="#❓面试模拟追问" class="headerlink" title="❓面试模拟追问"></a>❓面试模拟追问</h2><blockquote>
<p>面试官：你们 Kafka 的 leader 挂了会不会影响消费者？</p>
</blockquote>
<p>你可以回答：</p>
<blockquote>
<p>Kafka 的消费者是从分区的 <strong>leader</strong> 拉取消息的，如果 leader 节点挂了，Kafka 会自动从 <span style = "color:blue"><strong>ISR 列表</strong></span>中挑选新的 follower 作为 leader，整个过程对消费者来说是无感知的，消费过程会自动恢复。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>解释一下复制机制中的ISR？</strong><br></span></p>
<blockquote>
<p>ISR (in-sync replica) 需要同步复制保存的follower；<strong>跟 Leader 保持同步</strong> 的副本集合<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉后，会优先从ISR副本列表中选取一个作为leader</p>
<p>Kafka 每个分区（Partition）都会有多个副本（Replicas）：</p>
<ul>
<li>一个 Leader</li>
<li>若干个 Follower</li>
</ul>
<p>这些副本被分成两类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ISR 副本</strong></td>
<td>与 Leader 保持数据同步的副本（<strong>最健康的副本集</strong>）</td>
</tr>
<tr>
<td><strong>OSR（Out-of-Sync Replicas）</strong></td>
<td>落后太多，未能及时同步 Leader 数据的副本</td>
</tr>
</tbody></table>
<h2 id="🧠-工作机制详解"><a href="#🧠-工作机制详解" class="headerlink" title="🧠 工作机制详解"></a>🧠 工作机制详解</h2><h3 id="1️⃣-消息写入"><a href="#1️⃣-消息写入" class="headerlink" title="1️⃣ 消息写入"></a>1️⃣ 消息写入</h3><ul>
<li><strong>Producer 只写 Leader</strong></li>
<li>Leader 负责将数据同步到 ISR 中的所有 Follower</li>
<li>所有 ISR 成员都成功写入后，才向 Producer 发送 <code>ack</code></li>
</ul>
<p>如果 Leader 挂了：</p>
<ul>
<li>Kafka <strong>只会从 ISR 列表</strong>中挑选一个副本晋升为新的 Leader</li>
<li>这样可以确保<strong>新 Leader 中的数据是完整的</strong></li>
</ul>
<h2 id="🟩-举个例子助记"><a href="#🟩-举个例子助记" class="headerlink" title="🟩 举个例子助记"></a>🟩 举个例子助记</h2><p>假设 topic 有 3 个副本：</p>
<pre><code>Partition-0:
  - broker1 (Leader)
  - broker2 (Follower)
  - broker3 (Follower)
</code></pre>
<p>此时，**ISR &#x3D; [broker1, broker2]**（broker3 落后太多，暂不在 ISR 中）</p>
<p>如果 broker1 挂掉了 → Kafka 会从 broker2 中选一个当 Leader（因为它是同步副本）</p>
<p>📌 broker3 不在 ISR 中，就算数据多，也不会被选为 leader（因为可能数据不一致）</p>
<hr>
<blockquote>
<p>Kafka 中每个分区都会有多个副本，其中 ISR（In-Sync Replicas）表示与 Leader 保持同步的副本集合。</p>
<p>ISR 是 Kafka 高可用的重要保障，Kafka 只会从 ISR 中选 leader，避免使用落后副本导致数据丢失。</p>
<p>可以通过配置 <code>min.insync.replicas</code> 来控制 ISR 最小数量，从而配合 <code>acks=all</code> 确保数据写入可靠性。</p>
</blockquote>
</blockquote>
<pre><code class="java">// 一个topic默认分区的replication个数，不能大于集群中broker的个数。默认为1
default.replication.factor=3
// 最小的ISR副本个数
min.insync.replicas=2
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b273ced4f6ca9b43b9fb5279e651199e7ad52e9f/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6(%E9%9B%86%E7%BE%A4+%E5%88%86%E5%8C%BA%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6).png"></p>
<p><span style = "color:red"><strong>Kafka数据清理机制了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li>kafka文件存储机制<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理</li>
</ul>
</li>
<li>数据清理机制<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认168小时(7天)</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息(默认关闭)</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dbab52581ab3ed1350e8310825216f279c66d7f7/Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86.png"></p>
<h2 id="✅-Kafka-和-RabbitMQ-对比"><a href="#✅-Kafka-和-RabbitMQ-对比" class="headerlink" title="✅ Kafka 和 RabbitMQ 对比"></a>✅ <span style ="color:orange">Kafka 和 RabbitMQ 对比</span></h2><table>
<thead>
<tr>
<th>对比维度</th>
<th>Kafka</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心模型</strong></td>
<td>发布-订阅模型（Pub-Sub）</td>
<td>基于消息队列（Queue）</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>分布式、高吞吐、日志存储</td>
<td>面向消息、消息中间人</td>
</tr>
<tr>
<td><strong>消息存储</strong></td>
<td>持久化日志，磁盘为主，保留时间可配</td>
<td>内存为主，结合磁盘，可配置 TTL</td>
</tr>
<tr>
<td><strong>性能吞吐量</strong></td>
<td>非常高（百万级）</td>
<td>相对较低（万级）</td>
</tr>
<tr>
<td><strong>消息顺序性</strong></td>
<td>同一个分区内有序</td>
<td>默认无序（队列先进先出 FIFO）</td>
</tr>
<tr>
<td><strong>消息重复消费</strong></td>
<td>可能（需要幂等性）</td>
<td>通过消息确认机制避免</td>
</tr>
<tr>
<td><strong>消息确认机制</strong></td>
<td>Offset 手动提交或自动提交（可恢复）</td>
<td>Ack 机制、可配置手动&#x2F;自动确认</td>
</tr>
<tr>
<td><strong>可靠性机制</strong></td>
<td>副本机制 + ISR 保证</td>
<td>持久化、确认机制、死信队列、重试机制</td>
</tr>
<tr>
<td><strong>高可用性</strong></td>
<td>分区副本机制 + Leader选举（Raft）</td>
<td>镜像队列或仲裁队列</td>
</tr>
<tr>
<td><strong>消息丢失保护</strong></td>
<td><code>acks=all</code> + <code>min.insync.replicas</code></td>
<td>confirm机制 + durable队列 + ack</td>
</tr>
<tr>
<td><strong>延迟队列支持</strong></td>
<td>原生不支持（需要定时调度或借助外部插件）</td>
<td>原生支持延迟队列（TTL + 死信队列）</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>日志采集、行为跟踪、数据管道、实时流处理</td>
<td>任务异步处理、延迟任务、订单超时处理等</td>
</tr>
<tr>
<td><strong>管理界面</strong></td>
<td>UI界面较弱，需要依赖第三方</td>
<td>自带 Web 管理后台，功能强大</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>略陡峭，需要理解 partition、offset、consumer group 等</td>
<td>简单易上手，文档丰富</td>
</tr>
<tr>
<td><strong>协议支持</strong></td>
<td>Kafka 自有协议</td>
<td>支持 AMQP、MQTT、STOMP 等多种协议</td>
</tr>
<tr>
<td><strong>成熟度</strong></td>
<td>大数据生态首选，社区活跃，企业常用</td>
<td>轻量级场景常用，灵活扩展，适合中小型应用</td>
</tr>
</tbody></table>
<h2 id="🧠-总结一句话对比"><a href="#🧠-总结一句话对比" class="headerlink" title="🧠 总结一句话对比"></a>🧠 总结一句话对比</h2><ul>
<li>🔥 <strong>Kafka 更适合</strong>：<strong>高吞吐、日志&#x2F;流式处理、大数据实时系统</strong></li>
<li>🔧 <strong>RabbitMQ 更适合</strong>：<strong>业务系统间的解耦、任务异步处理、延迟消息机制</strong></li>
</ul>
<p>Kafka 和 RabbitMQ 都是消息中间件，但定位不同：</p>
<ul>
<li>Kafka 是<strong>高吞吐、分布式日志系统</strong>，更适合大数据场景和实时流式处理，使用 Partition 和 Offset 保证扩展性。</li>
<li>RabbitMQ 是<strong>传统的消息队列中间件</strong>，支持 AMQP 协议，适合轻量级业务异步解耦，原生支持延迟队列和消息确认机制。</li>
</ul>
<p>我们项目中如果要处理高并发日志或用户行为采集就选 Kafka，如果是下单通知、订单超时等场景就更适合 RabbitMQ。</p>
<p><span style = "color:red"><strong>Kafka中实现高性能的设计有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><span style = "color:blue">消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</span></li>
<li><span style = "color:blue">顺序读写：磁盘顺序读写，提升读写效率</span></li>
<li><span style = "color:blue">页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</span></li>
<li><span style = "color:blue">零拷贝：减少上下文切换及数据拷贝</span></li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/86a930ef22442fc6b9460ee88b64b21983cc9847/kafka%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p>
<h2 id="集合面试篇"><a href="#集合面试篇" class="headerlink" title="集合面试篇"></a><span style = "color:red"><strong>集合面试篇</strong></span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/9f0a0968283f4255bf0047d1761499c7b493ed97/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BBpng.png"></p>
<p><span style = "color:orange"><strong>算法复杂度分析</strong><br></span></p>
<blockquote>
<p>什么是算法时间复杂度？</p>
<ul>
<li>时间复杂度表示了算法的<strong>执行时间</strong>与<strong>数据规模</strong>之间的增长关系</li>
</ul>
<p>常见的时间复杂度有哪些？<del>口诀：常对幂指阶</del></p>
<ul>
<li>O(1)、O(n)、O(n^2)、O(logn)</li>
</ul>
<p>什么是算法的空间复杂度？</p>
<ul>
<li>表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系<br>常见的空间复杂度：O(1)、O(n)、O(n^2)</li>
</ul>
</blockquote>
<h6 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h6><ul>
<li>指导你编写出性能更优的代码</li>
<li>评判别人写的代码的好坏</li>
</ul>
<h6 id="时间复杂度分析：来评估代码的执行耗时的"><a href="#时间复杂度分析：来评估代码的执行耗时的" class="headerlink" title="时间复杂度分析：来评估代码的执行耗时的"></a>时间复杂度分析：来评估代码的执行耗时的</h6><ul>
<li><p>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></p>
</li>
<li><p>只要代码的执行时间**<u>不随着n的增大而增大</u><strong>，这样的代码复杂度都是</strong>O(1)**</p>
</li>
<li><p>复杂度分析就是要弄清楚代码的<strong>执行次数</strong>和<strong>数据规模n</strong>之间的关系</p>
</li>
</ul>
<h6 id="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"><a href="#时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系" class="headerlink" title="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"></a>时间复杂度：全称是<code>渐进空间复杂度</code>，表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0d4930dbc47574f03c8f4db7b995944fb4418e3/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png"></p>
<h3 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a><span style = "color:red"><strong>List相关面试题</strong></span></h3><blockquote>
<ul>
<li><p>数组是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数组的线性数据结构</p>
</li>
<li><p>数组下标为什么从0开始</p>
<p>寻址公式是：<code>baseAddress + i * data TypeSize</code> 计算下标的内存地址效率较高</p>
</li>
<li><p>查找的时间复杂度</p>
<ul>
<li>随机(<strong>通过下标</strong>)查询的时间复杂度是O(1)</li>
<li>查找元素(<strong>未知下标</strong>)的时间复杂度是O(n)</li>
<li>查找元素(<strong>未知下标但排序</strong>)通过二分查找的时间复杂度是O(logn)</li>
</ul>
</li>
<li><p>插入和删除时间复杂度</p>
<p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均复杂度为O(n)</p>
</li>
</ul>
</blockquote>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><ul>
<li>数据结构—数组</li>
<li>ArrayList源码分析</li>
</ul>
<h6 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h6><ul>
<li>ArrayList底层的实现原理是什么</li>
<li>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</li>
<li>如何实现数组和List之间的转换</li>
<li>ArrayList和LinkedList的区别是什么</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9c400fc7d26d51223654eb4c997ae331fed38ac8/%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%880%E5%BC%80%E5%A7%8B.png"></p>
<p><span style = "color:red"><strong>ArrayList源码分析</strong></span></p>
<blockquote>
<p>List&lt; Integer &gt; list &#x3D; new ArrayList&lt; Integer &gt;();<br>list.add(1)</p>
</blockquote>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;

    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 用于空实例的共享空数组实例
     */
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

    /**
     * 用于默认大小的空实例的共享空数组实例
     * 与上面的区分开，以了解添加第一个元素时要膨胀多少
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
  
    /* 存储ArrayList元素的数组缓冲区，ArrayList的容量就是这个数组缓冲区的长度 */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小(包含的元素数量)
     * @serial
     */
    private int size;
...
&#125;

--------------------------------------------------------------------------------

public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
       // 创建一个真正存储集合位置的数组
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
    // 如果容量是0则创建一个新的数组给elementData
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;
    public ArrayList() &#123; 
         // 无参构造函数，默认创建空集合
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

-------------------------------------------------------------------------------
// Collection是所有单列集合的父接口
// 将 Collection 对象转换成数组，然后将数组的地址赋给 elementData
 public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        elementData = c.toArray();
        if ((size = elementData.length) != 0) &#123;
            // 判断集合类型是否为不为object[] 
            // 在其他jdk此处是 ?? == ArrayList.class
            if (elementData.getClass() != Object[].class)
                // 不是的话就拷贝到数组elementData中
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;
</code></pre>
<h6 id="ArrayList源码分析-添加和扩容操作-第1次添加数据"><a href="#ArrayList源码分析-添加和扩容操作-第1次添加数据" class="headerlink" title="ArrayList源码分析-添加和扩容操作(第1次添加数据)"></a>ArrayList源码分析-添加和扩容操作(第1次添加数据)</h6><img src="https://raw.githubusercontent.com/P-luminary/images/94991acfd36ad12ca17dfd7578011cfeffe34022/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>ArrayList底层的实现原理是什么</strong></span></p>
<ul>
<li>ArrayList底层是用<strong>动态数组</strong>实现的</li>
<li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</li>
<li>ArrayList在添加数据的时候<ul>
<li>确保数组已使用长度(size)加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用<code>grow</code>方法扩容<del>(原来的1.5倍)</del></li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</strong></span></p>
<ul>
<li>该语句只是声明和实例了一个<code>ArrayList</code>，指定了容量为10，未扩容</li>
</ul>
<p><span style = "color:red"><strong>如何实现数组和List之间的转换</strong></span></p>
<ul>
<li>数组转List，使用JDK中<code>java.util.Arrays</code>工具类的<code>asList</code>方法</li>
<li>List转数组，使用List的<code>toArray</code>方法，无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组</li>
</ul>
<blockquote>
<p>使用 Hutool 工具库可以非常方便地实现数组和 <code>List</code> 之间的转换。Hutool 提供了 <code>ArrayUtil</code> 和 <code>CollUtil</code> 工具类来处理数组和集合之间的转换。</p>
<p>问：我不能用BeanUtil吗？<br>答：<code>BeanUtil</code> 是 Hutool 工具库中用于 <strong>Java Bean 操作</strong>的工具类，主要用于 <strong>对象属性拷贝</strong>、<strong>Bean 转 Map</strong>、<strong>Map 转 Bean</strong> 等操作。它并不适用于 <strong>数组和 List 之间的转换</strong>。</p>
<p>如果你误以为 <code>BeanUtil</code> 可以用于数组和 List 的转换，可能是因为它的名字容易让人误解。实际上，数组和 List 的转换应该使用 <code>ArrayUtil</code> 或 <code>CollUtil</code>。</p>
<h3 id="正确的工具类选择"><a href="#正确的工具类选择" class="headerlink" title="正确的工具类选择"></a>正确的工具类选择</h3><ol>
<li><strong>数组转 List</strong>：使用 <code>ArrayUtil.toList</code>。</li>
<li><strong>List 转数组</strong>：使用 <code>CollUtil.toArray</code>。</li>
<li><strong>Bean 属性拷贝</strong>：使用 <code>BeanUtil.copyProperties</code>。</li>
<li><strong>Bean 转 Map</strong>：使用 <code>BeanUtil.beanToMap</code>。</li>
<li><strong>Map 转 Bean</strong>：使用 <code>BeanUtil.fillBeanWithMap</code>。</li>
</ol>
<h6 id="更多的Hutool工具使用高能预警"><a href="#更多的Hutool工具使用高能预警" class="headerlink" title="更多的Hutool工具使用高能预警"></a>更多的Hutool工具使用<del>高能预警</del></h6><h5 id="1-字符串工具类：StrUtil"><a href="#1-字符串工具类：StrUtil" class="headerlink" title="1. 字符串工具类：StrUtil"></a>1. <strong>字符串工具类：<code>StrUtil</code></strong></h5><ul>
<li><strong>功能</strong>：字符串操作，如判空、格式化、截取、替换等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>StrUtil.isEmpty()</code>：判断字符串是否为空。</li>
<li><code>StrUtil.format()</code>：格式化字符串。</li>
<li><code>StrUtil.split()</code>：拆分字符串。</li>
<li><code>StrUtil.join()</code>：连接字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-日期时间工具类：DateUtil"><a href="#2-日期时间工具类：DateUtil" class="headerlink" title="2. 日期时间工具类：DateUtil"></a>2. <strong>日期时间工具类：<code>DateUtil</code></strong></h5><ul>
<li><strong>功能</strong>：日期和时间的格式化、解析、计算等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>DateUtil.now()</code>：获取当前时间。</li>
<li><code>DateUtil.format()</code>：格式化日期。</li>
<li><code>DateUtil.parse()</code>：解析字符串为日期。</li>
<li><code>DateUtil.offsetDay()</code>：日期加减。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-文件工具类：FileUtil"><a href="#3-文件工具类：FileUtil" class="headerlink" title="3. 文件工具类：FileUtil"></a>3. <strong>文件工具类：<code>FileUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件和目录的操作，如读写、复制、删除等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>FileUtil.readUtf8String()</code>：读取文件内容为字符串。</li>
<li><code>FileUtil.writeUtf8String()</code>：将字符串写入文件。</li>
<li><code>FileUtil.copy()</code>：复制文件或目录。</li>
<li><code>FileUtil.del()</code>：删除文件或目录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-JSON-工具类：JSONUtil"><a href="#4-JSON-工具类：JSONUtil" class="headerlink" title="4. JSON 工具类：JSONUtil"></a>4. <strong>JSON 工具类：<code>JSONUtil</code></strong></h5><ul>
<li><strong>功能</strong>：JSON 的解析和生成。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>JSONUtil.parseObj()</code>：将 JSON 字符串解析为 JSON 对象。</li>
<li><code>JSONUtil.parseArray()</code>：将 JSON 字符串解析为 JSON 数组。</li>
<li><code>JSONUtil.toJsonStr()</code>：将对象转换为 JSON 字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-集合工具类：CollUtil"><a href="#5-集合工具类：CollUtil" class="headerlink" title="5. 集合工具类：CollUtil"></a>5. <strong>集合工具类：<code>CollUtil</code></strong></h5><ul>
<li><strong>功能</strong>：集合操作，如创建集合、判空、过滤、分组等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CollUtil.newArrayList()</code>：快速创建 ArrayList。</li>
<li><code>CollUtil.isEmpty()</code>：判断集合是否为空。</li>
<li><code>CollUtil.filter()</code>：过滤集合。</li>
<li><code>CollUtil.group()</code>：对集合进行分组。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-反射工具类：ReflectUtil"><a href="#6-反射工具类：ReflectUtil" class="headerlink" title="6. 反射工具类：ReflectUtil"></a>6. <strong>反射工具类：<code>ReflectUtil</code></strong></h5><ul>
<li><strong>功能</strong>：反射操作，如调用方法、获取字段、创建对象等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ReflectUtil.invoke()</code>：调用方法。</li>
<li><code>ReflectUtil.getFieldValue()</code>：获取字段值。</li>
<li><code>ReflectUtil.newInstance()</code>：创建对象实例。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-HTTP-工具类：HttpUtil"><a href="#7-HTTP-工具类：HttpUtil" class="headerlink" title="7. HTTP 工具类：HttpUtil"></a>7. <strong>HTTP 工具类：<code>HttpUtil</code></strong></h5><ul>
<li><strong>功能</strong>：HTTP 请求的发送和响应处理。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>HttpUtil.get()</code>：发送 GET 请求。</li>
<li><code>HttpUtil.post()</code>：发送 POST 请求。</li>
<li><code>HttpUtil.downloadFile()</code>：下载文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-加密解密工具类：SecureUtil"><a href="#8-加密解密工具类：SecureUtil" class="headerlink" title="8. 加密解密工具类：SecureUtil"></a>8. <strong>加密解密工具类：<code>SecureUtil</code></strong></h5><ul>
<li><strong>功能</strong>：常见的加密解密操作，如 MD5、SHA、AES 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>SecureUtil.md5()</code>：计算 MD5 值。</li>
<li><code>SecureUtil.sha256()</code>：计算 SHA-256 值。</li>
<li><code>SecureUtil.aes()</code>：AES 加密解密。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-IO-工具类：IoUtil"><a href="#9-IO-工具类：IoUtil" class="headerlink" title="9. IO 工具类：IoUtil"></a>9. <strong>IO 工具类：<code>IoUtil</code></strong></h5><ul>
<li><strong>功能</strong>：IO 流操作，如读写、关闭流等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>IoUtil.read()</code>：读取流内容。</li>
<li><code>IoUtil.write()</code>：写入流内容。</li>
<li><code>IoUtil.close()</code>：关闭流。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="10-随机工具类：RandomUtil"><a href="#10-随机工具类：RandomUtil" class="headerlink" title="10. 随机工具类：RandomUtil"></a>10. <strong>随机工具类：<code>RandomUtil</code></strong></h5><ul>
<li><strong>功能</strong>：生成随机数、随机字符串等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>RandomUtil.randomInt()</code>：生成随机整数。</li>
<li><code>RandomUtil.randomString()</code>：生成随机字符串。</li>
<li><code>RandomUtil.randomEle()</code>：从集合中随机选择一个元素。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="11-验证工具类：Validator"><a href="#11-验证工具类：Validator" class="headerlink" title="11. 验证工具类：Validator"></a>11. <strong>验证工具类：<code>Validator</code></strong></h5><ul>
<li><strong>功能</strong>：数据验证，如邮箱、手机号、身份证等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Validator.isEmail()</code>：验证是否为邮箱。</li>
<li><code>Validator.isMobile()</code>：验证是否为手机号。</li>
<li><code>Validator.isCitizenId()</code>：验证是否为身份证号。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="12-缓存工具类：CacheUtil"><a href="#12-缓存工具类：CacheUtil" class="headerlink" title="12. 缓存工具类：CacheUtil"></a>12. <strong>缓存工具类：<code>CacheUtil</code></strong></h5><ul>
<li><strong>功能</strong>：简单的缓存操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CacheUtil.newTimedCache()</code>：创建定时缓存。</li>
<li><code>CacheUtil.put()</code>：添加缓存。</li>
<li><code>CacheUtil.get()</code>：获取缓存。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="13-线程工具类：ThreadUtil"><a href="#13-线程工具类：ThreadUtil" class="headerlink" title="13. 线程工具类：ThreadUtil"></a>13. <strong>线程工具类：<code>ThreadUtil</code></strong></h5><ul>
<li><strong>功能</strong>：线程操作，如睡眠、创建线程池等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ThreadUtil.sleep()</code>：线程睡眠。</li>
<li><code>ThreadUtil.newExecutor()</code>：创建线程池。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="14-Excel-工具类：ExcelUtil"><a href="#14-Excel-工具类：ExcelUtil" class="headerlink" title="14. Excel 工具类：ExcelUtil"></a>14. <strong>Excel 工具类：<code>ExcelUtil</code></strong></h5><ul>
<li><strong>功能</strong>：Excel 文件的读写操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ExcelUtil.getReader()</code>：读取 Excel 文件。</li>
<li><code>ExcelUtil.getWriter()</code>：写入 Excel 文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="15-压缩工具类：ZipUtil"><a href="#15-压缩工具类：ZipUtil" class="headerlink" title="15. 压缩工具类：ZipUtil"></a>15. <strong>压缩工具类：<code>ZipUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件或目录的压缩和解压缩。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ZipUtil.zip()</code>：压缩文件或目录。</li>
<li><code>ZipUtil.unzip()</code>：解压缩文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="16-日志工具类：Log"><a href="#16-日志工具类：Log" class="headerlink" title="16. 日志工具类：Log"></a>16. <strong>日志工具类：<code>Log</code></strong></h5><ul>
<li><strong>功能</strong>：简化日志操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Log.get()</code>：获取日志对象。</li>
<li><code>Log.info()</code>：输出日志信息。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="17-数学工具类：MathUtil"><a href="#17-数学工具类：MathUtil" class="headerlink" title="17. 数学工具类：MathUtil"></a>17. <strong>数学工具类：<code>MathUtil</code></strong></h5><ul>
<li><strong>功能</strong>：数学计算，如四舍五入、最大值、最小值等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>MathUtil.round()</code>：四舍五入。</li>
<li><code>MathUtil.max()</code>：获取最大值。</li>
<li><code>MathUtil.min()</code>：获取最小值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="18-网络工具类：NetUtil"><a href="#18-网络工具类：NetUtil" class="headerlink" title="18. 网络工具类：NetUtil"></a>18. <strong>网络工具类：<code>NetUtil</code></strong></h5><ul>
<li><strong>功能</strong>：网络相关操作，如获取本机 IP、Ping 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>NetUtil.getLocalhost()</code>：获取本机 IP。</li>
<li><code>NetUtil.ping()</code>：Ping 测试。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>用<code>Arrays.asList</code>转List后，如果修改了数组内容，list受影响吗</li>
<li>List用<code>toArray</code>转数组后，如果修改了List内容，数组受影响吗</li>
</ul>
<h6 id="再答："><a href="#再答：" class="headerlink" title="再答："></a>再答：</h6><ul>
<li>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</li>
<li>list用了toArray转数组后，如果修改了list内容，数组不会受影响，当调用了toArray以后，在底层是它进行了数组拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a0e6fcd9e82104de79aeb269b64bee2fe250a37/%E6%95%B0%E7%BB%84%E5%92%8Clist%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>LinkedList的数据结构—链表</strong></span></p>
<p><strong>单向链表</strong></p>
<ul>
<li>链表中的每一个元素称之为结点(Node)</li>
<li>物理存储单元上，非连续、非顺序的存储结构</li>
<li>单向链表：每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</li>
</ul>
<h6 id="1-单向链表和双向链表的区别是什么"><a href="#1-单向链表和双向链表的区别是什么" class="headerlink" title="1.单向链表和双向链表的区别是什么"></a>1.单向链表和双向链表的区别是什么</h6><ul>
<li>单向链表只有一个方向，结点只有一个后继指针 next。</li>
<li>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</li>
</ul>
<h6 id="2-链表操作数据的时间复杂度是多少"><a href="#2-链表操作数据的时间复杂度是多少" class="headerlink" title="2.链表操作数据的时间复杂度是多少"></a>2.链表操作数据的时间复杂度是多少</h6><table>
<thead>
<tr>
<th></th>
<th>查询</th>
<th>新增删除</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>头O(1), 其他O(n)</td>
<td>头O(1), 其他O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/89cd60c5af783394daee166cbfce512c0b796d0f/LinkedList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E9%93%BE%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>ArrayList和LinkedList的区别</strong></span></p>
<ul>
<li><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a><span style = "color:blue">底层数据结构</span></h5><ul>
<li>ArrayList 是<strong>动态数组</strong>的数据结构实现</li>
<li>LinkedList 是<strong>双向链表</strong>的数据结构实现</li>
</ul>
</li>
<li><p><strong>操作数组效率</strong></p>
<ul>
<li><p>ArrayList  按照下标查询的时间复杂度O(1);【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</p>
</li>
<li><p>查找(未知索引)：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</p>
</li>
<li><p><strong>新增</strong>和<strong>删除</strong>【查询多用<code>ArrayList</code>；插入&#x2F;删除多用<code>LinkedList</code>】</p>
<ul>
<li>ArrayList 尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList 头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存空间占用</strong></p>
<ul>
<li>ArrayList 底层是数组，内存连续，节省内存</li>
<li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li><p><span style = "color:blue"><strong><u>ArrayList和LinkedList都不是线程安全的</u></strong></span></p>
</li>
<li><p>如果要保证线程安全，有两种方法</p>
<ul>
<li><p>在<strong>方法内使用</strong>，局部变量则是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<pre><code class="java">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());
List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(new LinkedList&lt;&gt;());
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a><span style = "color:red"><strong>HashMap相关面试题</strong></span></h3><ul>
<li><p><strong>二叉树</strong></p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
<p>二叉搜索树又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
</li>
<li><p><strong>红黑树</strong></p>
</li>
<li><p><strong>散列表</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/678118180d1bda0ac019f934c04c3db01eff5cf8/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<blockquote>
<h3 id="✅-1-二叉树（Binary-Tree）"><a href="#✅-1-二叉树（Binary-Tree）" class="headerlink" title="✅ 1. 二叉树（Binary Tree）"></a>✅ 1. 二叉树（Binary Tree）</h3><p>每个节点最多有两个子节点，称为左子节点和右子节点。</p>
<hr>
<h3 id="✅-2-满二叉树（Full-Binary-Tree）"><a href="#✅-2-满二叉树（Full-Binary-Tree）" class="headerlink" title="✅ 2. 满二叉树（Full Binary Tree）"></a>✅ 2. 满二叉树（Full Binary Tree）</h3><p>每个节点要么是叶子节点，要么恰好有两个子节点，且<strong>所有叶子都在同一层</strong>。</p>
<hr>
<h3 id="✅-3-完全二叉树（Complete-Binary-Tree）"><a href="#✅-3-完全二叉树（Complete-Binary-Tree）" class="headerlink" title="✅ 3. 完全二叉树（Complete Binary Tree）"></a>✅ 3. 完全二叉树（Complete Binary Tree）</h3><p>除了最后一层，其他每一层的节点数都达到最大值，且<strong>最后一层节点集中在左侧</strong>。</p>
<hr>
<h3 id="✅-4-二叉搜索树（Binary-Search-Tree，BST）"><a href="#✅-4-二叉搜索树（Binary-Search-Tree，BST）" class="headerlink" title="✅ 4. 二叉搜索树（Binary Search Tree，BST）"></a>✅ 4. 二叉搜索树（Binary Search Tree，BST）</h3><blockquote>
<p>又叫：<strong>二叉查找树、有序二叉树</strong></p>
</blockquote>
<p>特点：</p>
<ul>
<li>对于任意一个节点 <code>node</code>：<ul>
<li>左子树中所有节点值 &lt; <code>node</code> 值</li>
<li>右子树中所有节点值 &gt; <code>node</code> 值</li>
</ul>
</li>
<li>中序遍历是<strong>升序排列</strong></li>
</ul>
<p>用途：</p>
<ul>
<li>用于快速查找、插入、删除（时间复杂度平均为 O(log n)，最坏为 O(n)）</li>
</ul>
<hr>
<h3 id="✅-5-红黑树（Red-Black-Tree）"><a href="#✅-5-红黑树（Red-Black-Tree）" class="headerlink" title="✅ 5. 红黑树（Red-Black Tree）"></a>✅ 5. 红黑树（Red-Black Tree）</h3><p>红黑树是<strong>自平衡的二叉搜索树</strong>，在多种语言的底层集合结构（如 Java 的 <code>TreeMap</code>、<code>TreeSet</code>，C++ 的 <code>map</code>、<code>set</code>）都有使用。</p>
<p>特点：</p>
<ul>
<li>每个节点是红或黑</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL）是黑色</li>
<li>红色节点不能有红色子节点（即不能连续两个红）</li>
<li>任意一节点到其所有后代叶子节点的路径上，<strong>黑色节点数量相同</strong></li>
</ul>
<p>目的：</p>
<ul>
<li>保证在最坏情况下，查找、插入、删除的时间复杂度是 O(log n)</li>
</ul>
<hr>
<h3 id="✅-6-散列表（Hash-Table）"><a href="#✅-6-散列表（Hash-Table）" class="headerlink" title="✅ 6. 散列表（Hash Table）"></a>✅ 6. 散列表（Hash Table）</h3><p>与树不同，散列表是通过<strong>哈希函数（Hash Function）</strong>将键映射到数组下标进行查找。</p>
<p>特点：</p>
<ul>
<li>查找时间接近 O(1)</li>
<li>冲突处理方式如链地址法、开放定址法等</li>
<li>用于实现如 Java 的 <code>HashMap</code>、<code>HashSet</code>、Python 的 <code>dict</code>、<code>set</code> 等结构</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>数据结构—红黑树 什么是红黑树？</strong></span></p>
<ul>
<li>红黑树：也是一种自平衡的二叉搜索树(BST)</li>
<li>所有的红黑规则都是希望红黑树能够保证平衡</li>
<li>红黑树的时间复杂度：查找、添加、删除都是O(logn)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d52e3005e6dbb2c546a407bdb237c51cbdab9694/%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><span style = "color:red"><strong>散列表</strong></span></h4><p><span style = "color:red"><strong>什么是散列表？</strong></span></p>
<blockquote>
<ul>
<li>散列表(Hash Table)又叫哈希表&#x2F;Hash表</li>
<li>根据键(Key)直接访问再内存存储位置值(Value)的数据结构</li>
<li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突</strong></span></p>
<blockquote>
<ul>
<li>散列冲突又成为<strong>哈希冲突</strong>，哈希碰撞</li>
<li>指多个key映射到同一个数组下标位置</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突—链表法(拉链)</strong></span></p>
<blockquote>
<ul>
<li>数组的每个下标位置称之为<strong>桶</strong>(bucket) 或者 <strong>槽</strong>(slot)</li>
<li>每个桶(槽)会对应一条链表</li>
<li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li>
</ul>
</blockquote>
<p>在<strong>HashMap</strong>中的最重要的一个数据结构就是散列表，在散列表中又用到了<strong>红黑树</strong>和<strong>链表</strong><br>散列表(Hash Table)又名为<strong>哈希表</strong>&#x2F;Hash表，是<strong>根据键(Key)直接访问</strong>在内存存储位置<strong>值(value)<strong>的数据结构，它是</strong>由数组演化而来的</strong>，利用了数组支持按照下标进行随机访问数据的特性<del>[根据寻址公式,时间复杂度O(1)]</del></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6dd0e10d2aaa9a064fde0c973b9d942ae149d17c/%E6%95%A3%E5%88%97%E8%A1%A8.png"></p>
<h4 id="说一下HashMap的实现原理"><a href="#说一下HashMap的实现原理" class="headerlink" title="说一下HashMap的实现原理"></a><span style = "color:red"><strong>说一下HashMap的实现原理</strong></span></h4><blockquote>
<p>1.说一下HashMap的实现原理</p>
<ul>
<li><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p>
</li>
<li><p>添加数据时，计算key的值确定元素在数组中的下标</p>
<ul>
<li>key相同则替换</li>
<li>不同则存入链表或红黑树中</li>
</ul>
<p>获取数据通过key的hash计算数组下标获取元素</p>
</li>
</ul>
<p>2.<span style = "color:blue"><strong>HashMap的jdk1.7和jdk1.8有什么区别</strong></span></p>
<ul>
<li>JDK1.8之前采用的拉链法，数组+链表</li>
<li>JDK1.8之后采用数组+链表+红黑树<br>链表长度大于8且数组长度大于64则会从链表转化为红黑树</li>
</ul>
</blockquote>
<p>当我们往HashMap中put元素时(扰动函数)，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/27826dde4b711105a212f30f6381f8097eca69ba/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<h4 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a><span style = "color:red"><strong>HashMap的put方法的具体流程</strong></span></h4><blockquote>
<p>1.判断键值对数组table是否为空或为null，否则执行resize()进行扩容 [初始化]<br>2.根据键值key计算hash值得到数组索引<br>3.判断table[i] &#x3D;&#x3D; null，条件成立，直接新建节点添加<br>4.如果table[i] &#x3D;&#x3D; null，不成立<br>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value<br>4.2 判断table[i]是否为<strong>treeNode</strong>，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对<br>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d2fa5788e2f2f5c7e75e724c8bef242b6661c10c/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>讲一下HashMap的扩容机制</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c4e2b5bca4f89ece679358c70cdb042f8028aa81/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png"></p>
<p><span style = "color:red"><strong>HashMap源码分析</strong></span></p>
<p>桶下标是hash值取模数组(长度)下标 capacity</p>
<p><span style = "color:red"><strong>HashMap的寻址算法</strong></span></p>
<p>Hash值右移16位后与原来的hash值进行异或运算【扰动算法<del>hash值更加均匀,减少hash冲突</del>】<br>数组长度必须是2的n次幂 按位<strong>与运算</strong>的效果才能代替取模</p>
<blockquote>
<p>int hash &#x3D; h ^ (h &gt;&gt;&gt; 16);                 &#x2F;&#x2F; hashCode 的扰动处理<br>index &#x3D; hash &amp; (table.length - 1);   &#x2F;&#x2F; 更快的取模运算</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/85bdc4d076df91ec3d29294926d65f55713b2d26/HashMap%E5%AF%BB%E5%9D%80%E7%AE%97w%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>HashMap在1.7情况下的多线程死循环问题</strong></span></p>
<p>jdk7的数据结构是：数组+链表<br>在数组进行扩容的时候，因为链表是<strong>头插法</strong>(在并发情况下可能出现<strong>链表反转成环形结构</strong>)，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1be6d73360d8cdf5baa6b2fea0b1fc8fa8b7fadc/HashMap%E5%9C%A81.7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98.png"></p>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a><span style = "color:red">进程和线程的区别？</span></h4><blockquote>
<h6 id="两者对比："><a href="#两者对比：" class="headerlink" title="两者对比："></a>两者对比：</h6><ul>
<li><u><strong>进程</strong>是整个在运行程序的实例</u>，<u>进程中包含了<strong>线程</strong></u>，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>简要定义</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>程序的执行实例，<strong>资源分配的最小单位</strong></td>
</tr>
<tr>
<td>线程</td>
<td>进程内的执行单元，<strong>cpu调度的最小单位</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>项目</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>概念</td>
<td>正在运行的程序实例</td>
<td>进程中的执行单元</td>
</tr>
<tr>
<td>所属关系</td>
<td>进程可包含多个线程</td>
<td>线程依附于进程存在</td>
</tr>
<tr>
<td>内存空间</td>
<td>拥有独立地址空间</td>
<td>共享所属进程的内存空间</td>
</tr>
<tr>
<td>创建开销</td>
<td>创建&#x2F;销毁成本高（需要资源分配）</td>
<td>创建&#x2F;销毁成本低（共享资源）</td>
</tr>
<tr>
<td>通信方式</td>
<td>进程间通信较复杂（如管道&#x2F;套接字）</td>
<td>线程通信简单（共享变量）</td>
</tr>
<tr>
<td>崩溃影响</td>
<td>一个进程崩溃不会影响其他进程</td>
<td>一个线程崩溃可能影响整个进程</td>
</tr>
<tr>
<td>切换开销</td>
<td>上下文切换开销大</td>
<td>上下文切换开销小</td>
</tr>
<tr>
<td>资源隔离</td>
<td>资源独立，安全性高</td>
<td>资源共享，效率高但易出错</td>
</tr>
</tbody></table>
<pre><code class="css">[ 进程A ]
 ├── 线程1：负责计算
 ├── 线程2：负责文件IO
 └── 线程3：负责网络通信

[ 进程B ]
 └── 线程1：完全独立
</code></pre>
</blockquote>
<p>程序由<strong>指令</strong>和<strong>数据</strong>组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，<strong>进程</strong>就是用来加载指令、管理内存、管理IO的。<br>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个**<u>进程</u>**</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。一个进程之内可以分为一到多个线程</p>
<blockquote>
<p>core → 线程1[指令1，指令2，指令3…]   线程2[指令1，指令2，指令3…] </p>
</blockquote>
<h4 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a><span style = "color:red">并行和并发的区别？</span></h4><blockquote>
<p>现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是<strong>同一时间</strong>应对多件事情的能力，多个线程<strong>轮流使用</strong>一个或多个CPU</li>
<li>并行是<strong>同一时间</strong>动手做多件事的能力，4核CPU<strong>同时执行</strong>4个线程</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>并发</td>
<td>同一时间段<strong>处理多个任务的能力</strong>（任务<strong>轮流切片</strong>执行）</td>
</tr>
<tr>
<td>并行</td>
<td>同一时刻<strong>真正同时执行多个任务</strong>（多个核同时执行）</td>
</tr>
</tbody></table>
</blockquote>
<p>&#x3D;&#x3D;<strong>单核CPU</strong>&#x3D;&#x3D; → 单核CPU下线程实际还是串行执行的</p>
<ul>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15ms)分给不同的程序使用，只是由于cpu在线程间(时间片很短)的切换非常快，人类感觉是同时运行的</li>
<li>每个时间片只能用有一个线程被执行</li>
<li>总结一句话：**<u>微观串行，宏观并行</u>**</li>
<li>一般会将这种线程轮流使用CPU的做法称为并发(concurrent)</li>
</ul>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
</tr>
</thead>
<tbody><tr>
<td>core</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
</tr>
</tbody></table>
<p><strong>&#x3D;&#x3D;多核CPU&#x3D;&#x3D;</strong> → 每个核(core)都可以调度运行线程，这个时候线程是可以并行的</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
<th>时间片4</th>
</tr>
</thead>
<tbody><tr>
<td>core1</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
<td>线程3</td>
</tr>
<tr>
<td>core2</td>
<td>线程2</td>
<td>线程4</td>
<td>线程2</td>
<td>线程4</td>
</tr>
</tbody></table>
<blockquote>
<p>并发 (concurrent) 是同一时间<strong>应对</strong> (dealing with) 多件事情的能力<br>并行 (parallel) 是同一时间<strong>动手做</strong> (doing) 多件事情的能力</p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这么多件事，这就是<strong>并发</strong>【单核CPU】</li>
<li>家庭主妇雇了个保姆，她们一起做这些事，这时既有并发，也有并行【会产生竞争，例如锅只有一个，一个人用锅时，另一个人就要等待】</li>
<li>雇了3个保姆，一个专门做饭，一个专门打扫卫生，一个专门喂奶，互不干扰，这就是<strong>并行</strong></li>
</ul>
</blockquote>
<h4 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a><span style = "color:red">创建线程的方式有哪些？</span></h4><ul>
<li><h5 id="继承Thread类，重写run方法"><a href="#继承Thread类，重写run方法" class="headerlink" title="继承Thread类，重写run方法"></a>继承Thread类，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyThread...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建MyThread对象
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口，重写run方法"><a href="#实现Runnable接口，重写run方法" class="headerlink" title="实现Runnable接口，重写run方法"></a>实现Runnable接口，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyRunnable implements Runnable &#123;

    @Override
    public void run() &#123;
        // 在这里编写要执行的任务
        System.out.println(&quot;线程正在执行任务...&quot;);
    &#125;
    public static void main(String[] args) &#123;
        // 创建MyRunnable实例
        MyRunnable myRunnable = new MyRunnable();
        
        // 创建线程并启动
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致"><a href="#实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致" class="headerlink" title="实现Callable&lt; T &gt;接口，重写call方法泛型和重写方法一致"></a>实现Callable&lt; T &gt;接口，重写call方法<del>泛型和重写方法一致</del></h5></li>
</ul>
<pre><code class="java">public class MyCallable implements Callable&lt;String&gt; &#123;
 @Override
    public String call() throws Exception &#123;
        sout(Thread.currentThread().getName());
        return &quot;ok&quot;;
    &#125;
     public static void main(String[] args) &#123;
        // 创建MyCallable实例
        MyCallable myCallable = new MyCallable();
        
        // 使用FutureTask来包装Callable对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(myCallable);
        
        // 创建并启动线程
        Thread t1 = new Thread(ft);
        t1.start();
        // 调用ft的get方法获取执行结果
        String result = ft.get();
        sout(result)
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="线程池创建线程-项目中使用的方式"><a href="#线程池创建线程-项目中使用的方式" class="headerlink" title="线程池创建线程 (项目中使用的方式)"></a><span style = "color:blue">线程池创建线程 (项目中使用的方式)</span></h5></li>
</ul>
<pre><code class="java">public class MyExecutors implements Runnable&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyRunnable...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()); 
        //submit用来提交线程
        
        // 关闭线程池
        threadPool.shutdown();
    &#125;
&#125;
</code></pre>
<h6 id="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"><a href="#刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？" class="headerlink" title="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"></a><span style = "color:red">刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？</span></h6><blockquote>
<ul>
<li>Runnable接口run方法<strong>没有返回值</strong></li>
<li><strong>Callable</strong>接口call方法<strong>有返回值</strong>，要结合FutureTask配合可以用来获取异步执行的结果</li>
</ul>
<blockquote>
<p><strong><code>FutureTask</code></strong> 是 <strong><code>Future</code></strong> 的实现类，它可以包装一个 <code>Callable</code> 或 <code>Runnable</code> 对象，并允许我们在任务执行完毕后获取执行结果或取消任务。</p>
<p><strong><code>FutureTask</code></strong> 可以在子线程中异步执行任务，而主线程可以通过调用 <code>FutureTask.get()</code> 方法获取任务执行的结果。</p>
</blockquote>
<ul>
<li>Callable接口的call()方法<strong>允许抛出异常</strong>；而Runnabble接口的run()方法的异常只能在<strong>内部消化</strong>，不能继续上抛</li>
</ul>
<pre><code class="java">import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableExample &#123;

    public static void main(String[] args) throws Exception &#123;
        // 创建一个Callable任务
        Callable&lt;Integer&gt; task = new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                System.out.println(&quot;Task is running in the background...&quot;);
                // 模拟耗时操作
                Thread.sleep(2000);
                return 42; // 返回计算结果
            &#125;
        &#125;;

        // 创建FutureTask对象，包装Callable任务
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);

        // 启动线程执行FutureTask
        Thread thread = new Thread(futureTask);
        thread.start();

        // 主线程可以做一些其他工作
        System.out.println(&quot;Main thread is doing something else...&quot;);

        // 获取异步执行结果，阻塞直到任务完成
        Integer result = futureTask.get(); // 这会阻塞主线程直到获取到结果
        System.out.println(&quot;Task result: &quot; + result); // 打印任务执行结果
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>在启动线程的时候，可以使用run方法吗？run()和start()有什么区别？</strong></span></p>
<p>start()是开启一个线程   run()跟开启普通方法一样</p>
<blockquote>
<p><strong>start()：</strong>用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。<strong>start方法只能被调用一次</strong><br><strong>run()：</strong>封装了要被线程执行的代码，<strong>可以被调用多次</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/807ae461bb166b0aa6a755a66e43d57c0166323c/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9.png"></p>
<h4 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a><span style = "color:red"><strong>线程包括哪些状态，状态之间是如何变化的？</strong></span></h4><blockquote>
<p>状态：<br><strong>新建</strong>New、<strong>可运行</strong>Runnable、<strong>阻塞</strong>Blocked、<strong>等待</strong>Waiting、<strong>时间等待</strong>Timed_waiting、<strong>终止</strong>Terminated</p>
<p>线程状态之间如何变化：</p>
<ul>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了<strong>start()<strong>方法转变为</strong>可执行状态</strong></li>
<li>线程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁(<strong>synchronized</strong>或lock) 进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了<strong>wait()<strong>方法进入</strong>等待状态</strong>，其他线程调用notify()唤醒后可转换为可执行状态</li>
<li>如果线程调用了<strong>sleep(50)<strong>方法，进入</strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="java">Thread.java
public enum State &#123;
    /**
     * 新建状态。线程已经被创建，但尚未启动。
     */
    NEW,

    /**
     * 可运行状态。线程在JVM中是可运行的，这并不意味着它一定在运行，它可能在等待其他线程或操作系统的资源。
     */
    RUNNABLE,

    /**
     * 阻塞状态。线程正在等待监视器锁，以进入一个同步块/方法，或者在调用Object.wait后等待重新进入同步块/方法。
     */
    BLOCKED,

    /**
     * 等待状态。线程在等待另一个线程执行特定操作。例如，一个线程调用了Thread.join，它在等待指定的线程终止。
     */
    WAITING,

    /**
     * 超时等待状态。线程在等待另一个线程执行特定操作，但它设置了超时时间。如果线程在指定时间内没有等待到所需条件，它将自动返回。
     */
    TIMED_WAITING,

    /**
     * 终止状态。线程已经完成了执行。
     */
    TERMINATED;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/981d7e954005439be7e8261b142100e3e87f800b/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</strong></span></p>
<p>可以使用线程中的<strong>join</strong>方法解决<br><code>join() 等待线程运行结束</code></p>
<pre><code class="java">t.join() 阻塞调用此方法的线程进入timed_waiting 直到线程t执行完毕后，此线程再继续执行
</code></pre>
<pre><code class="java">Thread t1 = new Thread(()-&gt;&#123;
    sout(&quot;t1&quot;);
&#125;);
Thread t2 = new Thread(()-&gt;&#123;
    try&#123;
        t1.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t2&quot;);
&#125;)
Thread t3 = new Thread(()-&gt;&#123;
    try&#123;
        t2.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t3&quot;);
&#125;);
// 启动线程
t1.start();
t2.start();
t3.start();
</code></pre>
<p><span style = "color:red"><strong>notify() 和 notifyAll() 有什么区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>notifyAll</strong>：唤醒所有wait的线程</li>
<li><strong>notify</strong>：只随机唤醒一个wait线程</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>java中wait和sleep方法有什么区别？</strong></span><del>wait要和synchronized一起使用</del></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>归属类</th>
<th>是否释放锁</th>
<th>唤醒方式</th>
<th>使用前提</th>
</tr>
</thead>
<tbody><tr>
<td><code>sleep()</code></td>
<td><code>Thread</code></td>
<td>❌ 不释放锁</td>
<td>时间到、被打断</td>
<td>直接调用即可</td>
</tr>
<tr>
<td><code>wait()</code></td>
<td><code>Object</code></td>
<td>✅ 释放锁</td>
<td><code>notify()</code>&#x2F;时间到&#x2F;被打断</td>
<td>必须配合 <code>synchronized</code> 使用</td>
</tr>
</tbody></table>
<h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul>
<li>方法归属不同<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait()，wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li><strong>wait(long)和wait()还可以被notify唤醒</strong>，wait()如果不唤醒就一直等下去<del>wait要和synchronized一起使用</del></li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><strong>锁特性不同</strong>【重点】<ul>
<li><strong>wait方法的调用必须先获取wait对象的锁</strong>，而sleep则无此限制</li>
<li>wait方法执行后会释放锁对象，允许其他线程获得该锁对象 (我放弃cpu，但你们还可以用)</li>
<li>而sleep如果在synchronized代码块中执行，并不会释放锁对象 (我放弃cpu，你们也用不了)</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="✅-核心区别（面试高频）"><a href="#✅-核心区别（面试高频）" class="headerlink" title="✅ 核心区别（面试高频）"></a>✅ 核心区别（面试高频）</h2><table>
<thead>
<tr>
<th>维度</th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属类</td>
<td><code>Thread</code> 静态方法</td>
<td><code>Object</code> 实例方法</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>❌ 不释放锁</td>
<td>✅ 释放当前对象锁</td>
</tr>
<tr>
<td>是否需要锁</td>
<td>❌ 不需要任何锁</td>
<td>✅ 必须持有该对象的锁（<code>synchronized</code>）</td>
</tr>
<tr>
<td>唤醒方式</td>
<td>到时间&#x2F;中断</td>
<td>到时间&#x2F;中断&#x2F;<code>notify</code> &#x2F; <code>notifyAll</code></td>
</tr>
<tr>
<td>使用目的</td>
<td><strong>让线程暂停执行</strong>，但持有锁不让别人进</td>
<td><strong>让线程等待并释放锁，协调多线程通信</strong></td>
</tr>
</tbody></table>
<h2 id="✅-场景对比"><a href="#✅-场景对比" class="headerlink" title="✅ 场景对比"></a>✅ 场景对比</h2><table>
<thead>
<tr>
<th>场景</th>
<th>使用方法</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>想暂停线程几秒钟（不释放锁）</td>
<td><code>Thread.sleep(ms)</code></td>
<td>常用于模拟网络延迟&#x2F;定时任务</td>
</tr>
<tr>
<td>多线程协作（生产者-消费者模型）</td>
<td><code>wait()</code> &#x2F; <code>notify()</code></td>
<td>用于线程间通信，让出锁资源</td>
</tr>
</tbody></table>
<h2 id="✅-通俗类比-🌰"><a href="#✅-通俗类比-🌰" class="headerlink" title="✅ 通俗类比 🌰"></a>✅ 通俗类比 🌰</h2><ul>
<li><code>sleep()</code>：你在<strong>厕所里睡觉</strong>，门上锁了（别人不能进），你虽然休息了，但别人也进不来。</li>
<li><code>wait()</code>：你说“我出去抽根烟（释放锁）”，别人可以进去用厕所（释放资源），抽完烟再回来（被唤醒）继续工作。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5541d691652184639a4936426271a2f6ea03d2fb/wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.png"></p>
<p><span style = "color:red"><strong>如何停止一个正在运行的线程？</strong></span></p>
<h6 id="有三种方式可以停止线程"><a href="#有三种方式可以停止线程" class="headerlink" title="有三种方式可以停止线程"></a>有三种方式可以停止线程</h6><ul>
<li>使用<strong>退出标志位</strong>，使线程<strong>正常退出</strong>，也就是当run方法完成后线程终止</li>
<li>使用<strong>stop方法</strong>强行终止(不推荐，方法已作废)</li>
<li>使用<strong>interrupt</strong>方法中断线程<ul>
<li>打断阻塞的线程(sleep, wait, join)的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/64f320ea60791a6cc20d9e238d50be95345d1485/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理？</strong></span><del>底层：Monitor</del></p>
<blockquote>
<ul>
<li>synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li>
<li>它的底层由monitor实现的，monitor**是jvm级别的现象(C++实现)**，线程获得锁需要使用对象(锁)关联monitor</li>
<li>在monitor内部有三个属性，分别是<code>owner、entrylist、waitset</code><ul>
<li>owner是关联的获得锁的线程，并且只能关联一个线程；</li>
<li>entrylist关联的是处于阻塞状态的线程；</li>
<li>waitset关联的是处于Waiting状态的线程；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理—进阶</strong></span></p>
<p><span style = "color:red"><strong><u>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</u></strong></span></p>
<blockquote>
<h4 id="一旦锁发生了竞争，都会升级为重量级锁"><a href="#一旦锁发生了竞争，都会升级为重量级锁" class="headerlink" title="一旦锁发生了竞争，都会升级为重量级锁"></a>一旦锁发生了竞争，都会升级为重量级锁</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 【有多个线程来抢】</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争)可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<blockquote>
<p>每一个 Java 对象在 JVM 中都有一个对象头，其中包含 <strong>MarkWord</strong>，用于存储锁信息。<br>当线程访问 <code>synchronized</code> 方法或代码块时，会尝试获取对象关联的 <strong>Monitor</strong>，进入临界区：Monitor 中包含：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>owner</td>
<td>当前持有锁的线程</td>
</tr>
<tr>
<td>entryList</td>
<td>等待获取锁（阻塞）的线程队列</td>
</tr>
<tr>
<td>waitSet</td>
<td>调用 <code>wait()</code> 被挂起的线程队列</td>
</tr>
</tbody></table>
<h3 id="获取锁流程（简化）："><a href="#获取锁流程（简化）：" class="headerlink" title="获取锁流程（简化）："></a>获取锁流程（简化）：</h3><ol>
<li>检查对象头中的 MarkWord；</li>
<li>如果未被锁，尝试通过 CAS 设置为当前线程（偏向或轻量级）；</li>
<li>如果竞争失败 → 升级为重量级锁（Monitor）；</li>
<li>等待唤醒或抢占锁。</li>
</ol>
<h5 id="锁升级过程（从偏向锁-→-轻量级锁-→-重量级锁）"><a href="#锁升级过程（从偏向锁-→-轻量级锁-→-重量级锁）" class="headerlink" title="锁升级过程（从偏向锁 → 轻量级锁 → 重量级锁）"></a>锁升级过程（从偏向锁 → 轻量级锁 → 重量级锁）</h5><table>
<thead>
<tr>
<th>锁类型</th>
<th>触发条件</th>
<th>优点</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>只有一个线程访问（无竞争）</td>
<td>几乎无开销，不用 CAS</td>
<td>单线程长时间持有的锁</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多线程访问，但加锁时间错开</td>
<td>使用 CAS，无阻塞，性能较高</td>
<td>少量线程短时间交替访问</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多线程同时竞争同一把锁</td>
<td>线程阻塞 + 唤醒，开销大</td>
<td>并发激烈，必须互斥的场景</td>
</tr>
</tbody></table>
<h5 id="偏向锁-x2F-轻量级锁-x2F-重量级锁细节图解（简述）"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁细节图解（简述）" class="headerlink" title="偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁细节图解（简述）"></a>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁细节图解（简述）</h5><h3 id="🚀-偏向锁原理："><a href="#🚀-偏向锁原理：" class="headerlink" title="🚀 偏向锁原理："></a>🚀 偏向锁原理：</h3><ul>
<li>第一次访问：CAS 记录当前线程 ID 到对象头</li>
<li>再次访问时：只判断对象头的线程 ID 是否是自己</li>
<li>如果有竞争，偏向锁就会被撤销，升级为轻量级锁</li>
</ul>
<h3 id="🚀-轻量级锁原理："><a href="#🚀-轻量级锁原理：" class="headerlink" title="🚀 轻量级锁原理："></a>🚀 轻量级锁原理：</h3><ul>
<li>在 <strong>线程栈中创建 LockRecord</strong>；</li>
<li>尝试 CAS 将 LockRecord 指针复制到对象头；</li>
<li>成功 → 获取锁；失败 → 说明竞争，升级为重量级锁</li>
</ul>
<h3 id="🚀-重量级锁原理（Monitor）："><a href="#🚀-重量级锁原理（Monitor）：" class="headerlink" title="🚀 重量级锁原理（Monitor）："></a>🚀 重量级锁原理（Monitor）：</h3><ul>
<li>Monitor 的实现是基于 <strong>操作系统的互斥量（mutex）</strong></li>
<li>涉及线程的挂起、唤醒（用户态 → 内核态切换，开销大）</li>
</ul>
</blockquote>
<h6 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h6><p>每个Java对象都可以关联一个Monitor对象，如果使用 synchronized 给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><ul>
<li>在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</li>
<li>通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为nul，起到了一个重入计数器的作用。</li>
<li>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</li>
</ul>
<h6 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h6><ul>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record.</li>
<li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的 Mark Word不为nul，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</li>
</ul>
<h6 id="偏向锁性能比轻量级锁好"><a href="#偏向锁性能比轻量级锁好" class="headerlink" title="偏向锁性能比轻量级锁好"></a>偏向锁<del>性能比轻量级锁好</del></h6><ul>
<li>轻量级锁在没有竞争时(就自己这个线程)每次重入仍然需要执行 CAS 操作。</li>
<li>Java6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d930bb7ad0d897e72b69faa5bb15fa1f387b728a/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%5B%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%5D%E2%80%94%E8%BF%9B%E9%98%B6%E7%AF%87.png"></p>
<h4 id="你谈谈JMM-Java内存模型"><a href="#你谈谈JMM-Java内存模型" class="headerlink" title="你谈谈JMM (Java内存模型)"></a><span style = "color:red"><strong>你谈谈JMM (Java内存模型)</strong></span></h4><h6 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h6><ul>
<li>JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域(工作内存)，一块是所有线程的共享区域(主内存)</li>
<li>线程跟线程之间是相互隔离，线程跟线程相互需要通过主内存</li>
</ul>
<p><span style = "color:red"><strong>CAS你知道吗？</strong></span><del>乐观锁</del></p>
<blockquote>
<ul>
<li>CAS全称是：Compare And Swap(比较再交换)，它体现的一种无锁（<strong>乐观锁</strong>）的思想，在无锁情况下保证线程操作共享数据的原子性。</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li>
</ul>
<p>比较内存值是否与预期值相等，如果相等则更新为新值；否则不做操作，重新尝试（一般配合自旋）</p>
<pre><code class="java">// 伪代码
if (value == expectedValue) &#123;
  value = newValue;
&#125;
</code></pre>
<h3 id="💡-应用场景："><a href="#💡-应用场景：" class="headerlink" title="💡 应用场景："></a>💡 应用场景：</h3><ul>
<li><code>java.util.concurrent.atomic</code> 包下的 <code>AtomicInteger</code> 等</li>
<li><code>ReentrantLock</code> 的底层 AQS</li>
<li><code>ConcurrentHashMap</code> 局部并发控制</li>
</ul>
</blockquote>
<p>在JUC(java.util.concurrent)包下实现的很多类都用到了CAS操作</p>
<ul>
<li>AbstractQueuedSynchronizer (AQS框架)</li>
<li>AtomicXXX类</li>
</ul>
<p><span style = "color:red"><strong>乐观锁和悲观锁的区别？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ed89cde4cab6a88d6f2a86f3430be2b28a5e3626/JMM%20(Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)+CAS.png"></p>
<h4 id="乐观锁-vs-悲观锁（对比表）"><a href="#乐观锁-vs-悲观锁（对比表）" class="headerlink" title="乐观锁 vs 悲观锁（对比表）"></a>乐观锁 vs 悲观锁（对比表）</h4><table>
<thead>
<tr>
<th>特性</th>
<th>乐观锁（CAS）</th>
<th>悲观锁（synchronized&#x2F;Lock）</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>默认不会冲突，失败后重试</td>
<td>默认可能冲突，先加锁</td>
</tr>
<tr>
<td>开销</td>
<td>CPU 开销高（自旋）</td>
<td>上下文切换成本高</td>
</tr>
<tr>
<td>性能</td>
<td>高并发下优于悲观锁</td>
<td>并发低时更稳定</td>
</tr>
<tr>
<td>实现方式</td>
<td>CAS，自旋锁，版本号控制</td>
<td>synchronized, ReentrantLock等</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>谈一谈你对volatile的理解？</strong></span><del>轻量级的同步机制</del></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><h5 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h5><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
<blockquote>
<p>当一个线程修改了被 <code>volatile</code> 修饰的变量，<strong>新值会立即同步到主内存中</strong>，其他线程读取这个变量时也会<strong>立即从主内存中刷新</strong>，而不是使用线程工作内存中的旧副本。</p>
<ul>
<li>✅ <strong>保证多个线程看到的是同一个值</strong></li>
<li>❌ 但是 <strong>不能保证原子性</strong></li>
</ul>
</blockquote>
</li>
<li><h5 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h5><p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
<blockquote>
<ul>
<li><p>Java 编译器 &amp; CPU <u>为了提高性能可能会对指令进行优化</u>，造成<strong>代码执行顺序</strong>与<strong>书写顺序</strong>不一致。</p>
</li>
<li><p><code>volatile</code> 能在变量读写操作前插入内存屏障（Memory Barrier）：</p>
<ul>
<li><p>写屏障：防止写操作后面的指令重排到前面</p>
</li>
<li><p>读屏障：防止读操作前面的指令被排到后面</p>
</li>
</ul>
</li>
</ul>
<h5 id="JMM-是理论模型，volatile-是其具体体现。"><a href="#JMM-是理论模型，volatile-是其具体体现。" class="headerlink" title="JMM 是理论模型，volatile 是其具体体现。"></a>JMM 是理论模型，<code>volatile</code> 是其具体体现。</h5><blockquote>
<p>🔄 <code>volatile</code> 是 JMM（Java内存模型）在语义上的一个重要实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th>JMM 内容</th>
<th><code>volatile</code> 实现作用</th>
</tr>
</thead>
<tbody><tr>
<td>主内存 &amp; 工作内存</td>
<td>强制将值立即刷新到主内存</td>
</tr>
<tr>
<td>可见性保证</td>
<td>✅ volatile 提供</td>
</tr>
<tr>
<td>原子性保证</td>
<td>❌ volatile 不提供</td>
</tr>
<tr>
<td>禁止指令重排</td>
<td>✅ volatile 提供（内存屏障）</td>
</tr>
</tbody></table>
<h5 id="这几个进行一下比较"><a href="#这几个进行一下比较" class="headerlink" title="这几个进行一下比较"></a>这几个进行一下比较</h5><table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code> &#x2F; <code>Lock</code></th>
<th>CAS (<code>AtomicXXX</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>原子性</td>
<td>❌</td>
<td>✅</td>
<td>✅（通过硬件指令）</td>
</tr>
<tr>
<td>重排序控制</td>
<td>✅（内存屏障）</td>
<td>✅（通过锁的语义）</td>
<td>✅（内存屏障）</td>
</tr>
<tr>
<td>是否加锁</td>
<td>否，轻量，性能高</td>
<td>是，重量级，性能相对低</td>
<td>否，自旋CAS</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标志、单例双检锁等</td>
<td>临界区互斥、大块同步场景</td>
<td>高并发下原子计数&#x2F;计量等操作</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ce52eb544e19cacdc7c7d22cb6fa3135b27e6a3/volatile%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3[%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81+%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F].png"></p>
<p><span style = "color:red"><strong>什么是AQS？</strong></span></p>
<blockquote>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个**<u>先进先出的双向队列</u>**，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无所状态)，如果队列中有一个线程修改成功了state为1，则当前线程就相当于获取了资源。</li>
<li>在对state修改的时候使用<strong>CAS</strong>(compare and swap)操作，保证多个线程修改的情况下<strong>原子性</strong></li>
</ul>
</blockquote>
<p>AQS(<strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer)，即抽象队列同步器。它是构建锁或者其他同步组件的<strong>基础框架</strong></p>
<h6 id="AQS与Synchronized的区别"><a href="#AQS与Synchronized的区别" class="headerlink" title="AQS与Synchronized的区别"></a>AQS与Synchronized的区别</h6><table>
<thead>
<tr>
<th align="center">AQS</th>
<th align="center">synchronized</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java语言实现</td>
<td align="center">关键字，C++语言实现</td>
</tr>
<tr>
<td align="center">悲观锁，手动开启和关闭</td>
<td align="center">悲观锁，自动释放锁</td>
</tr>
<tr>
<td align="center">锁竞争激烈的情况下，提供了多种解决方案</td>
<td align="center">锁竞争激励都会升级为<strong>重量级锁</strong>，性能差</td>
</tr>
</tbody></table>
<blockquote>
<h4 id="CAS和AQS的区别"><a href="#CAS和AQS的区别" class="headerlink" title="CAS和AQS的区别"></a>CAS和AQS的区别</h4><p><strong>CAS(Compare And Swap)</strong><del>乐观锁</del>：一种<strong>无锁的原子操作机制</strong>，用于实现<strong>数据层面的原子性</strong>，是底层原语。</p>
<p><strong>AQS(AbstractQueuedSynchronizer)</strong><del>悲观锁</del>：一种<strong>同步器框架</strong>，用于构建<strong>锁和同步器</strong>（如 ReentrantLock、Semaphore 等），是结构设计。</p>
<h4 id="表格对比：CAS-vs-AQS"><a href="#表格对比：CAS-vs-AQS" class="headerlink" title="表格对比：CAS vs AQS"></a>表格对比：CAS vs AQS</h4><table>
<thead>
<tr>
<th>对比点</th>
<th>CAS</th>
<th>AQS</th>
</tr>
</thead>
<tbody><tr>
<td>全称</td>
<td>Compare And Swap</td>
<td>AbstractQueuedSynchronizer</td>
</tr>
<tr>
<td>概念类型</td>
<td>原子操作机制（CPU指令级别）</td>
<td>同步器框架（Java并发包核心）</td>
</tr>
<tr>
<td>功能目的</td>
<td>保证<strong>共享变量原子性更新</strong></td>
<td>实现<strong>线程同步控制</strong>（排队、阻塞、唤醒等）</td>
</tr>
<tr>
<td>属于哪一层</td>
<td>底层原子操作</td>
<td>高层并发框架</td>
</tr>
<tr>
<td>是否加锁</td>
<td>否（无锁）</td>
<td>是（加锁或排队等待）</td>
</tr>
<tr>
<td>底层依赖</td>
<td>CPU的 CAS 指令（如 <code>cmpxchg</code>）</td>
<td>CAS、LockSupport、队列、模板方法</td>
</tr>
<tr>
<td>应用场景</td>
<td>AtomicXXX、线程安全计数器、乐观锁等</td>
<td>ReentrantLock、Semaphore、CountDownLatch、FutureTask 等</td>
</tr>
<tr>
<td>是否自带阻塞&#x2F;唤醒</td>
<td>❌ 不具备阻塞机制</td>
<td>✅ 自带阻塞&#x2F;唤醒机制（如 condition.await&#x2F;signal）</td>
</tr>
<tr>
<td>实现原理</td>
<td>通过比较内存值 + 原子更新</td>
<td>模板方法 + 状态位 state + FIFO 等待队列</td>
</tr>
<tr>
<td>失败机制</td>
<td>自旋重试（乐观锁）</td>
<td>阻塞挂起，进入等待队列</td>
</tr>
</tbody></table>
<h4 id="各自常见应用场景"><a href="#各自常见应用场景" class="headerlink" title="各自常见应用场景"></a>各自常见应用场景</h4><table>
<thead>
<tr>
<th>场景</th>
<th>用的是谁？</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>实现原子操作</td>
<td>CAS</td>
<td><code>AtomicInteger.incrementAndGet()</code></td>
</tr>
<tr>
<td>实现线程排队获取锁</td>
<td>AQS</td>
<td><code>ReentrantLock.lock()</code></td>
</tr>
<tr>
<td>信号量控制</td>
<td>AQS</td>
<td><code>Semaphore.acquire()</code></td>
</tr>
<tr>
<td>倒计时器</td>
<td>AQS</td>
<td><code>CountDownLatch.await()</code></td>
</tr>
<tr>
<td>实现 Future 机制</td>
<td>AQS</td>
<td><code>FutureTask.run()</code></td>
</tr>
<tr>
<td>高并发无锁计数器</td>
<td>CAS</td>
<td><code>LongAdder.add()</code>（改进版</td>
</tr>
</tbody></table>
<p><strong>CAS 是 AQS 的底层基础</strong>之一：AQS 内部更新同步状态（<code>state</code>）时就用的是 CAS。<br><strong>AQS 是基于 CAS + FIFO 队列实现的线程同步框架</strong>，比 CAS 更复杂、能力更强。</p>
<pre><code class="java">// AQS 内部设置状态的关键方法
protected final boolean compareAndSetState(int expect, int update) &#123;
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update); // 使用CAS
&#125;
</code></pre>
<h4 id="举个例子：ReentrantLock"><a href="#举个例子：ReentrantLock" class="headerlink" title="举个例子：ReentrantLock"></a>举个例子：ReentrantLock</h4><pre><code class="java">lock.lock();
</code></pre>
<ul>
<li><strong>内部结构：</strong><ul>
<li>使用 <strong>AQS 实现公平&#x2F;非公平锁的排队机制</strong></li>
<li>使用 <strong>CAS 来设置 state &#x3D; 1（加锁）</strong></li>
</ul>
</li>
</ul>
<p>CAS 是一种基于硬件的原子操作指令，用于在无锁环境下保证共享变量的线程安全，常用于 <code>AtomicInteger</code> 等类。而 AQS 是 Java 并发包中用于构建同步器（如锁、信号量等）的框架，它通过 CAS 操作来维护内部状态 <code>state</code>，并通过一个基于 FIFO 的等待队列来实现线程的阻塞与唤醒。因此，<strong>CAS 是底层原语，而 AQS 是上层的并发框架，AQS 内部正是基于 CAS 实现的</strong>。</p>
</blockquote>
<h6 id="AQS常见的实现类"><a href="#AQS常见的实现类" class="headerlink" title="AQS常见的实现类"></a>AQS常见的实现类</h6><ul>
<li><strong>ReentrantLock 阻塞式锁</strong></li>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dd56a7110e36eebc67c093ce454bd7052a1ad30/%E4%BB%80%E4%B9%88%E6%98%AFAQS.png"></p>
<p><span style = "color:red"><strong>ReentrantLock [rɪ’entrənt]lock 的实现原理？</strong></span><del>[关联HashMap线程不安全需加锁(synchronized或ReentrantLock)]</del></p>
<blockquote>
<p>ReentrantLock主要利用<strong>CAS+AQS队列</strong><del>CompareAndSwap+AbstractQueuedSynchronized</del>来实现。**<u>它支持公平锁和非公平锁</u><strong>，两者的实现类似构造方法接受一个可选的公平参数(<strong>默认非公平锁</strong>)，</strong><u>当设置为true时，表示公平锁，否则为非公平锁</u>**。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
</blockquote>
<p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断<del>synchronized不可中断</del></li>
<li>可设置超时时间<del>没有获得锁时只能进入等待</del>[<u>没有获取锁可以放弃锁</u>]</li>
<li>可以设置公平锁<del>synchronized只有非公平锁</del>[也支持非公平锁]</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9279a890a6163298e551a9f594f3c0b921a438ad/ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized和Lock有什么区别？</strong></span></p>
<ul>
<li><strong>语法层面</strong></li>
</ul>
<p><strong>synchronized是关键字</strong>，源码在jvm中，用<strong>c++<strong>语言实现<br><strong>Lock是接口</strong>，源码由jdk提供，用</strong>java</strong>语言实现<br>使用synchronized时，退出同步代码块锁会<strong>自动释放</strong>，而使用Lock时，需要<strong>手动</strong>调用unlock方法<strong>释放锁</strong></p>
<ul>
<li><strong>功能层面</strong></li>
</ul>
<p><strong>二者均属于悲观锁</strong>、都具备基本的互斥、同步、锁重入功能<br>Lock提供了许多synchronized不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong><br>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWeiteLock(读写锁)</p>
<p><span style = "color:red"><strong>死锁产生的条件是什么</strong></span></p>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<h6 id="如何进行死锁诊断-？"><a href="#如何进行死锁诊断-？" class="headerlink" title="如何进行死锁诊断 ？"></a>如何进行死锁诊断 ？</h6><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：<strong>jps</strong>和<strong>jstack</strong></p>
<ul>
<li><strong>jps</strong>：输出JVM中运行的<strong>进程状态</strong>信息</li>
<li><strong>jstack</strong>：查看java进程内<strong>线程的堆栈</strong>信息</li>
</ul>
<p>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack -l &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h6 id="其他解决工具，可视化工具"><a href="#其他解决工具，可视化工具" class="headerlink" title="其他解决工具，可视化工具"></a>其他解决工具，可视化工具</h6><ul>
<li><strong>jconsole</strong></li>
</ul>
<p>用于对jvm的 <u>内存，线程，类</u>  的监控，是一个基于jmx的GUI性能监控工具<br>打开方式：java安装目录 bin目录下 直接启动 <code>jconsole.exe</code>就行</p>
<ul>
<li><strong>VisualVM</strong>：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的cpu时间和内存中的对象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java安装目录 bin目录下 直接启动 <code>jvisualvm.exe</code>就行</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e76fa529b0f5ed6e555f615f22b4ad646e02f0d6/%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"><a href="#在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"></a>在实际操作中，以下是一些打破死锁的具体方法：<del>银行家算法可以避免死锁</del></h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<p><span style = "color:red"><strong>聊一下ConcurrentHashMap</strong></span></p>
<p><code>ConcurrentHashMap</code>是一种线程安全的高效Map集合<br><strong>底层数据结构</strong>：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8采用的数数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：<code>数组+红黑树+链表</code>，采用CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升</li>
</ul>
</li>
</ul>
<p><strong>加锁的方式</strong>：</p>
<ul>
<li>JDK1.7采用<code>Segment</code>分段锁，底层使用的是<code>ReentrantLock</code></li>
<li>JDK1.8采用<code>CAS</code><del>自旋锁</del>添加新节点，采用<code>synchronized</code>锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
<blockquote>
<p>在 <strong>JDK1.7</strong> 的 <code>ConcurrentHashMap</code> 实现中：</p>
<ul>
<li><code>ConcurrentHashMap</code> 底层被分成了多个 <strong>Segment</strong>（段）。</li>
<li>每个 Segment 本质上就是一个小型的 HashMap + 一把锁（<code>ReentrantLock</code>）。</li>
<li>整个 Map 是由多个 Segment 组成的数组：<code>Segment&lt;K, V&gt;[] segments;</code></li>
<li>每个 Segment 管理自己那部分的数据，<strong>互不干扰</strong>，从而实现高并发。</li>
</ul>
<p><strong>提高并发性，减小锁竞争：</strong></p>
<ul>
<li>将一个大的 <strong>HashMap</strong> 拆成多个 Segment（默认16个），每个 Segment 单独加锁。</li>
<li>这样多个线程并发访问不同 Segment 的数据时，就不会互相阻塞，从而提升性能。</li>
<li>线程只会锁定自己需要访问的那个 Segment，不会锁全表。</li>
</ul>
<h5 id="【下列图中针对于整体和put的解释】"><a href="#【下列图中针对于整体和put的解释】" class="headerlink" title="【下列图中针对于整体和put的解释】"></a>【下列图中针对于整体和put的解释】</h5><h3 id="📌-1-整体结构"><a href="#📌-1-整体结构" class="headerlink" title="📌 1. 整体结构"></a>📌 1. 整体结构</h3><ul>
<li>外部是一个 <strong>Segment 数组</strong>：每个 Segment 是独立加锁的。</li>
<li>每个 Segment 内部又是一个 HashEntry 数组（就像 HashMap 的结构）。</li>
</ul>
<h3 id="📌-2-put-操作流程（以-JDK1-7-为例）："><a href="#📌-2-put-操作流程（以-JDK1-7-为例）：" class="headerlink" title="📌 2. put 操作流程（以 JDK1.7 为例）："></a>📌 2. put 操作流程（以 JDK1.7 为例）：</h3><ol>
<li>根据 key 的 hash 计算出 Segment 的<strong>下标</strong>（如 Segment[5]）。</li>
<li>进入对应的 Segment，获<strong>取其锁</strong>（<code>ReentrantLock.lock()</code>）。</li>
<li>再在该 Segment 中，查找对应的<strong>桶位</strong>（HashEntry 数组）。</li>
<li>找到位置后：<ul>
<li>如果该位置已有数据，做链表遍历、替换或追加。</li>
<li>如果链表过长，在 JDK1.7 仍然是链表（没有红黑树）。</li>
</ul>
</li>
<li>插入完成后释放锁。</li>
</ol>
<h5 id="✅-JDK1-8-为什么放弃-Segment？"><a href="#✅-JDK1-8-为什么放弃-Segment？" class="headerlink" title="✅ JDK1.8 为什么放弃 Segment？"></a>✅ JDK1.8 为什么放弃 Segment？</h5><p>JDK1.8 里，<strong>取消了 Segment 分段锁结构，改为节点粒度的同步控制</strong>：</p>
<ul>
<li>使用 <strong>CAS + synchronized</strong> 替代了 Segment + ReentrantLock。</li>
<li>好处：<ul>
<li>不再有 Segment 的内存占用与操作复杂度。</li>
<li>粒度更细，性能更好。</li>
<li>数据结构与 HashMap 接轨，统一维护。</li>
</ul>
</li>
</ul>
<p>在 JDK1.7 中，<code>ConcurrentHashMap</code> 使用 <strong>Segment 分段锁机制</strong> 提高并发性能，将 Map 拆成多个小的 Segment，每个 Segment 内部结构类似 HashMap，通过加锁控制并发。而在 JDK1.8 中，放弃 Segment，采用 <strong>CAS + synchronized 锁节点的方式</strong>，结构变为数组 + 链表 + 红黑树，性能与简洁性双双提升。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fc8e6e126e8fff5692b8c53102ac3237b913310d/%E8%81%8A%E4%B8%80%E8%81%8AConcurrentHashMap.png"></p>
<h4 id="导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全"><a href="#导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全" class="headerlink" title="导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)"></a><span style = "color:red"><strong>导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)</strong></span></h4><h6 id="Java并发编程三大特性"><a href="#Java并发编程三大特性" class="headerlink" title="Java并发编程三大特性"></a>Java并发编程三大特性</h6><ul>
<li><span style = "color:blue"><strong>原子性<del>synchronized、lock</del></strong></span>：一个线程在CPU中操作不可暂停，也不可中断，要么执行完成，要么不执行</li>
</ul>
<pre><code class="java">int ticketNum = 10;
public void getTicket()&#123;
    if(ticketNum &lt;= 0)&#123;
        return;
    &#125;
    sout(Thread.currentThread().getName() + &quot;抢到一张票，剩余：&quot; + ticketNum);
    // 非原子性操作
    ticketNum--;
&#125;
main&#123;
    TicketDemo demo = new TicketDemo();
    for(int i = 0; i &lt; 20; i++)&#123;
        new Thread(demo::getTicket).start();
    &#125;
&#125;
</code></pre>
<h6 id="不是原子操作，怎么保证原子操作呢？"><a href="#不是原子操作，怎么保证原子操作呢？" class="headerlink" title="不是原子操作，怎么保证原子操作呢？"></a>不是原子操作，怎么保证原子操作呢？</h6><ol>
<li>synchronized：同步加锁</li>
<li>JUC里面的lock：加锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<ul>
<li><strong><span style = "color:blue">可见性<del>volatile、synchronized、lock</del></span></strong></li>
</ul>
<h6 id="内存可见性：让一个线程对共享变量的修改对另一个线程可见"><a href="#内存可见性：让一个线程对共享变量的修改对另一个线程可见" class="headerlink" title="内存可见性：让一个线程对共享变量的修改对另一个线程可见"></a>内存可见性：让一个线程对共享变量的修改对另一个线程可见</h6><pre><code class="java">public class VolatileDemo&#123;
    private static boolean flag = false;
    public static void main(String[] args) throws InterruptedException&#123;
        new Thread(()-&gt;&#123;
            while(!flag)&#123;
                sout(&quot;第一个线程执行完毕...&quot;);
            &#125;
        &#125;).start();
        Thread.sleep(100);
        new Thread(()-&gt;&#123;
            flag = true;
            sout(&quot;第二个线程执行完毕...&quot;);
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p><strong>解决方案：synchronized、<u>volatile</u>、LOCK</strong> </p>
<p>volatile：加在共享变量上面即可 →  private static <strong>volatile</strong> boolean flag &#x3D; false;</p>
<ul>
<li><strong><span style = "color:blue">有序性<del>volatile</del></span></strong></li>
</ul>
<p><strong>指令重排</strong>：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<pre><code class="java">int x;
int y;
@Actor
public void actor1()&#123;
    x = 1;
    y = 1;
&#125;
@Actor
public void actor2(II_Result r)&#123;
    r.r1 = y;
    r.r2 = x;
&#125;
</code></pre>
<p><strong>解决办法</strong>：在前面加上<code>volatile</code></p>
<p><span style = "color:red"><strong>说一下线程池的核心参数</strong></span></p>
<p>为什么要创建线程池 因为每次创建线程的时候就要占用一定的内存空间 无限创建线程会浪费内存<del>严重会导致内存溢出</del><br>CPU有限的同一时刻只能同时处理一个线程 大量线程来的话就没有线程权 会造成线程等待 造成大量线程在之间切换也会导致性能变慢</p>
<pre><code class="java">在这个例子中，我们创建了一个线程池，核心线程数为5，最大线程数为10，如果线程池中的线程数大于核心线程数，则空闲线程在60秒后会被终止。工作队列使用ArrayBlockingQueue，其容量为100。

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample &#123;
    public static void main(String[] args) &#123;
        // 核心线程数
        int corePoolSize = 5;
        // 最大线程数 = （核心线程 + 救急线程的最大数目）
        int maximumPoolSize = 10;
        // 线程池中超过 corePoolSize 数量的空闲线程最大存活时间
        long keepAliveTime = 60L;
        // 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
        TimeUnit unit = TimeUnit.SECONDS;
        // 工作队列，用于存放提交的任务 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
        ArrayBlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(100);
        // 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
        ThreadFactory threadFactory = new ThreadFactory;
        // 拒绝策略 - 当所有线程都繁忙，workQueue也繁忙时，会触发拒绝策略
        RejectedExecutionHandler handler = new RejectedExecutionHandler;
        
        // 创建线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maximumPoolSize,
                keepAliveTime,
                unit,
                workQueue
        );

        // 示例：向线程池提交任务  threadPoolExecutor.submit()/.execute()
        for (int i = 0; i &lt; 20; i++) &#123;
            int taskNumber = i;
            threadPoolExecutor.execute(() -&gt; &#123;
                System.out.println(&quot;Executing task &quot; + taskNumber);
                // 模拟任务执行时间
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;

        // 关闭线程池
        threadPoolExecutor.shutdown();
    &#125;
&#125;
</code></pre>
<p>一开始new的时候没有是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<h6 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h6><ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><span style = "color:red"><strong>线程池中有哪些常见的阻塞队列</strong></span></p>
<p><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>workQueue - 阻塞队列常用的队列</u>：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
<li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ArrayBlockingQueue</th>
<th align="center"><span style = "color:red">LinkedBlockingQueue<del>不给值默认最大值</del></span></th>
</tr>
</thead>
<tbody><tr>
<td align="center">强制有界</td>
<td align="center">默认无界，支持有界</td>
</tr>
<tr>
<td align="center">底层是数组</td>
<td align="center">底层是链表</td>
</tr>
<tr>
<td align="center">提前初始化Node数组</td>
<td align="center">是懒惰的，创建节点的时候添加数据</td>
</tr>
<tr>
<td align="center">Node需要是提前创建好的</td>
<td align="center">入队会生成新Node</td>
</tr>
<tr>
<td align="center">一把锁</td>
<td align="center">两把锁(头尾)<del>可以一边入队,一边出队</del></td>
</tr>
</tbody></table>
<blockquote>
<h4 id="ArrayBlockingQueue（数组有界队列）"><a href="#ArrayBlockingQueue（数组有界队列）" class="headerlink" title="ArrayBlockingQueue（数组有界队列）"></a><strong>ArrayBlockingQueue（数组有界队列）</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>有界队列（必须指定容量）</td>
</tr>
<tr>
<td>底层结构</td>
<td>数组（先进先出 FIFO）</td>
</tr>
<tr>
<td>线程安全</td>
<td>内部使用一把锁（ReentrantLock）实现</td>
</tr>
<tr>
<td>性能</td>
<td>读写快，结构稳定</td>
</tr>
<tr>
<td>应用场景</td>
<td>可以<strong>准确预估任务数量</strong>的场景，推荐用于<strong>生产环境</strong>保障系统稳定</td>
</tr>
<tr>
<td>特点</td>
<td>不支持扩容，满了会阻塞或抛异常</td>
</tr>
</tbody></table>
<p>✅ <strong>适用于：生产环境中任务量可控，保证内存稳定，不希望触发OOM。</strong></p>
<h4 id="LinkedBlockingQueue（链表无界队列）"><a href="#LinkedBlockingQueue（链表无界队列）" class="headerlink" title="LinkedBlockingQueue（链表无界队列）"></a><strong>LinkedBlockingQueue（链表无界队列）</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>默认无界队列（最大为 Integer.MAX_VALUE，可设置为有界）</td>
</tr>
<tr>
<td>底层结构</td>
<td>链表（FIFO）</td>
</tr>
<tr>
<td>线程安全</td>
<td>使用两把锁（put锁 + take锁），可以同时入队出队</td>
</tr>
<tr>
<td>性能</td>
<td>插入删除性能好，随机访问性能差（O(n)）</td>
</tr>
<tr>
<td>应用场景</td>
<td>任务流量大、不可预估任务量的场景</td>
</tr>
<tr>
<td>特点</td>
<td>不容易触发拒绝策略，但容易造成内存溢出（OOM）</td>
</tr>
</tbody></table>
<p>✅ <strong>适用于：高并发日志、事件处理等消费速度快但生产不确定的情况。</strong></p>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>有界性</th>
<th>底层结构</th>
<th>锁机制</th>
<th>特点描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>有界</td>
<td>数组</td>
<td>一把锁</td>
<td>性能稳定，适合任务量可控场景</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>默认无界</td>
<td>链表</td>
<td>两把锁（头尾）</td>
<td>插入删除效率高，容易堆积任务造成内存压力</td>
</tr>
</tbody></table>
<h4 id="线程池中选择哪个阻塞队列？"><a href="#线程池中选择哪个阻塞队列？" class="headerlink" title="线程池中选择哪个阻塞队列？"></a>线程池中选择哪个阻塞队列？</h4><table>
<thead>
<tr>
<th>使用场景</th>
<th>推荐队列类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>普通后台异步任务</td>
<td><code>ArrayBlockingQueue</code></td>
<td>稳定、安全，可预估任务量</td>
</tr>
<tr>
<td>高并发任务，消费快但产量不可控</td>
<td><code>LinkedBlockingQueue</code></td>
<td>适合吞吐量大场景，注意内存风险</td>
</tr>
</tbody></table>
<h4 id="守护线程补充"><a href="#守护线程补充" class="headerlink" title="守护线程补充"></a>守护线程补充</h4><p>你提到的这段也非常好，总结如下：</p>
<ul>
<li><strong>守护线程（daemon）</strong>：依附主线程存在，主线程结束，守护线程也自动终止。如：GC线程。</li>
<li><strong>非守护线程（user thread）</strong>：默认类型，主线程结束后仍会继续运行。</li>
</ul>
<p>可通过：</p>
<pre><code class="java">Thread thread = new Thread(...);
thread.setDaemon(true); // 设置为守护线程
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>如何确定核心线程数</strong></span></p>
<blockquote>
<p>① 高并发、任务执行时间短 → (CPU核数 + 1)，减少线程上下文的切换<br>② 并发不高、任务执行时间长</p>
<ul>
<li><strong>IO密集型任务 → (CPU核数 * 2 + 1)</strong></li>
<li>计算密集型任务 → (CPU核数 + 1)</li>
</ul>
<p>③ <strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置参考②</p>
</blockquote>
<ul>
<li>IO密集型任务：文件读写、DB读写、网络请求等                            <span style = "color:blue"><strong>核心线程数大小设置为2N+1</strong></span></li>
<li>CPU密集型任务：计算型代码、Bitmap转换、Gson转换等            <span style = "color:blue"><strong>核心线程数大小设置为N+1</strong></span></li>
</ul>
<pre><code class="java">// 查看机器的CPU核数
public static void main(String[] args)&#123;
    // 查看机器的CPU核数
    System.out.println(Runtime.getRuntime().avaliableProcessors());
&#125;
</code></pre>
<p><span style = "color:red"><strong>线程池的种类有哪些</strong></span></p>
<p>在<code>java.util.concurrent.Executors</code>类中提供了大量创建线程池的静态方法，常见的有四种</p>
<h6 id="①-创建使用固定线程数的线程池"><a href="#①-创建使用固定线程数的线程池" class="headerlink" title="① 创建使用固定线程数的线程池"></a>① 创建使用固定线程数的线程池</h6><p><span style = "color:blue">适用于任务已知，相对耗时的任务</span></p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads)&#123;
    return new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS.new LinkedBlockingQueue&lt;Runnable&gt;)
&#125;
</code></pre>
<ul>
<li>核心线程数与最大线程数一样，没有<code>救急线程 = 最大线程数 - 核心线程数</code></li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<h6 id="②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出"><a href="#②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出" class="headerlink" title="② 单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]"></a>② 单线程化的线程池<del>它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]</del></h6><p><span style = "color:blue">适用于按照顺序执行的任务</span></p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor()&#123;
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
</code></pre>
<ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code></li>
</ul>
<h6 id="③-可缓存线程池"><a href="#③-可缓存线程池" class="headerlink" title="③ 可缓存线程池"></a>③ 可缓存线程池</h6><pre><code class="java">public static ExecutorService newCachedThreadPool()&#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<ul>
<li>核心线程数为0</li>
<li>最大线程数是<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>SynchronousQueue</code>: 不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ul>
<h6 id="④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor"><a href="#④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor" class="headerlink" title="④ 提供了 延迟 和 周期执行 功能的ThreadPoolExecutor"></a>④ 提供了 <code>延迟</code> 和 <code>周期执行</code> 功能的ThreadPoolExecutor</h6><pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize)&#123;
    super(corePoolSize, Integer.MAX_VALUE,0,NANOSECONDS,new DelayedWorkQueue());
&#125;
</code></pre>
<p><span style = "color:red"><strong>为什么不建议使用Executors创建线程池？</strong></span></p>
<p>参考阿里开发手册</p>
<pre><code class="java">【强制】 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors返回的线程池对象的弊端如下：
1. FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
2. CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
    
    
在实际开发中，不建议使用 Executors 创建线程池，因为其底层默认参数具有潜在的 OOM 风险。例如 FixedThreadPool 使用无界队列、CachedThreadPool 最大线程数为 Integer.MAX_VALUE，容易在高并发场景下造成内存溢出。因此建议通过 ThreadPoolExecutor 显式指定核心参数，做到资源可控，避免系统风险。
</code></pre>
<p><span style = "color:red"><strong>线程池的使用场景①：ES数据批量导入</strong></span></p>
<h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><p>CountDownLatch(闭锁&#x2F;倒计时锁)用来进行线程同步协作，等待所有线程完成倒计时时(一个或多个线程，等待其他多个线程完成某件事情之后才能执行)</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li><code>await()</code>用来等待计数归零</li>
<li><code>countDown()</code>用来让计数减一</li>
</ul>
<h6 id="多线程使用场景一-es数据批量导入"><a href="#多线程使用场景一-es数据批量导入" class="headerlink" title="多线程使用场景一 (es数据批量导入)"></a>多线程使用场景一 (es数据批量导入)</h6><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右一次性读取数据肯定不行(oom异常)，当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制就能避免一次性加载过多，防止内存溢出</p>
<blockquote>
<p>在我们项目中，曾有一次需要把MySQL中的一千万条历史文章同步到ES。为了避免一次性加载引发OOM，我将数据分页为每页2000条，使用线程池批量提交导入任务，同时使用 <code>CountDownLatch</code> 控制主线程阻塞等待所有子任务完成，再统一执行收尾逻辑。这样做极大优化了内存占用和同步效率。</p>
</blockquote>
<p>DB(一千万) → 线程池(CountDownLatch) → Elasticearch</p>
<pre><code class="java">       批量导入  →  查询总条数   →       DB
                      ↓               ↑          批量导入到ES中     →   ES
(固定每页2000条)        计算总页数            ↑  (countDownLatch.countDown())
                        ↓               ↑                ↑
(总页数)         CountDownLatch        ↑                ↑
                        ↓               ↑                ↑
                分页查询文章数据 → [查询当前页的文章 → 创建任务批量导入ES → 提交到线程池执行]循环
                                             (文章列表, countDownLatch)
                                                          ↓
                                                countDownLatch.await()
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a8e33cd1bf93eca7f789f20cee1a67770b426f68/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-CountDownLatch%E7%94%A8ES%E6%89%B9%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景②：数据汇总</strong></span></p>
<ul>
<li>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息;这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢?<ul>
<li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口(或部分接口)的没有依赖关系，就可以使用线程池+future来提升性能<br>[<u>统计的图文发布量、点赞数量、收藏数量、评论数量若不在同一台微服务下 或者 部分没有依赖关系</u>]</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="并发数据汇总（如订单数据聚合）"><a href="#并发数据汇总（如订单数据聚合）" class="headerlink" title="并发数据汇总（如订单数据聚合）"></a><strong>并发数据汇总（如订单数据聚合）</strong></h4><blockquote>
<p>关键词：<strong>接口无依赖、加速响应、Future并发调用</strong></p>
</blockquote>
<h4 id="📌-适用场景"><a href="#📌-适用场景" class="headerlink" title="📌 适用场景"></a>📌 适用场景</h4><ul>
<li>一个接口需要聚合多个来源服务（如订单服务、商品服务、物流服务）</li>
<li>服务之间<strong>无强依赖</strong>，可并发发起请求提升响应速度</li>
</ul>
<h4 id="✅-技术点"><a href="#✅-技术点" class="headerlink" title="✅ 技术点"></a>✅ 技术点</h4><ul>
<li><code>线程池 + Future + Callable</code></li>
<li>三个子任务并发发起 → <code>.get()</code>阻塞获取返回值</li>
<li>总响应时间 ≈ 最慢的那个接口，而不是三个之和</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b9ec7c6d685bab18893fbfa3b6637c48f3384ecf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景③：异步调用</strong></span></p>
<p>为了避免下一级方法影响上一级方法(性能考虑)，可使用<strong>异步线程调用</strong>下一个方法(不需要下一级方法返回值)，可以提升方法相应时间</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8b9788570956b65f8073f31b82bada34a8ddb799/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png"></p>
<p><span style = "color:red"><strong>如何控制某个方法允许并发访问线程的数量</strong></span></p>
<p>Semaphore信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br><strong>适用场景</strong>：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流</p>
<h6 id="Semaphore使用步骤"><a href="#Semaphore使用步骤" class="headerlink" title="Semaphore使用步骤"></a>Semaphore使用步骤</h6><ul>
<li>创建Semaphore对象，可以给一个容器</li>
<li>semaphore.acquire()：请求一个信号量，这时候的信号量个数 -1 (<u>一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量</u>)</li>
<li>semaphore.release()：释放一个信号量，此时信号量个数 +1</li>
</ul>
<blockquote>
<h3 id="使用-Semaphore-信号量"><a href="#使用-Semaphore-信号量" class="headerlink" title="使用 Semaphore 信号量"></a>使用 <code>Semaphore</code> 信号量</h3><ul>
<li><code>Semaphore</code> 是 JUC 包下的并发工具类，用于<strong>控制同时访问某个资源的线程数量</strong></li>
<li>底层基于 AQS（AbstractQueuedSynchronizer）实现</li>
<li>常用于<strong>限流、并发资源控制、连接池管理、接口控制等场景</strong></li>
</ul>
<pre><code class="yaml">Semaphore 就像操作系统中的“通行证/信号灯”，只有拿到令牌（acquire）才能进入方法执行，执行完后必须释放令牌（release），否则其他线程会一直阻塞在那等令牌释放。
</code></pre>
<ul>
<li><code>new Semaphore(n)</code>：设置可同时访问的线程数量为 n</li>
<li><code>semaphore.acquire()</code>：申请令牌，获取不到则阻塞</li>
<li><code>semaphore.release()</code>：释放令牌，通知其他线程</li>
</ul>
<blockquote>
<p>Semaphore 可以限制方法的并发访问线程数，常用于限流或控制资源并发度。通过 <code>acquire()</code> 获取访问许可、<code>release()</code> 释放许可，从而确保同时最多只有固定数量的线程能访问目标方法或资源。</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76cde79a53b36086d940f2874f8aa7ffd93ce6ef/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>谈一谈你对ThreadLocal的理解</strong></span></p>
<p><code>ThreadLocal</code> 是 Java 提供的<strong>线程本地变量工具类</strong>，用于实现<strong>线程间的数据隔离</strong>，也可理解为线程级别的“共享变量”。</p>
<blockquote>
<h3 id="🌟-一句话总结（记住这个）"><a href="#🌟-一句话总结（记住这个）" class="headerlink" title="🌟 一句话总结（记住这个）"></a>🌟 一句话总结（记住这个）</h3><blockquote>
<p><strong>ThreadLocal 实现线程间变量隔离，让每个线程拥有一份自己的变量副本，常用于解决共享变量的线程安全问题。</strong></p>
</blockquote>
<h3 id="📌-附加：ThreadLocal-≠-线程安全"><a href="#📌-附加：ThreadLocal-≠-线程安全" class="headerlink" title="📌 附加：ThreadLocal ≠ 线程安全"></a>📌 附加：ThreadLocal ≠ 线程安全</h3><blockquote>
<p>ThreadLocal 并不是让对象变“线程安全”，只是让每个线程用自己那份数据，<strong>避免共享</strong>导致的问题。</p>
</blockquote>
<h3 id="🚀-作用与优势"><a href="#🚀-作用与优势" class="headerlink" title="🚀 作用与优势"></a>🚀 作用与优势</h3><ul>
<li><strong>线程隔离</strong>：每个线程持有一份独立变量，互不干扰，解决并发线程对共享资源读写冲突的问题。</li>
<li><strong>线程内共享</strong>：同一线程中可以在不同方法、组件间共享数据（如事务控制、用户上下文等）。</li>
</ul>
<h3 id="🧠-原理说明（核心）"><a href="#🧠-原理说明（核心）" class="headerlink" title="🧠 原理说明（核心）"></a>🧠 原理说明（核心）</h3><p>每个线程内部都维护一个 <code>ThreadLocalMap</code>（它是 Thread 类的成员变量）：</p>
<ul>
<li>当调用 <code>threadLocal.set(value)</code> 时：<ul>
<li>当前线程的 <code>ThreadLocalMap</code> 中以 <code>threadLocal</code> 实例作为 key，<code>value</code> 作为值进行存储。</li>
</ul>
</li>
<li>当调用 <code>threadLocal.get()</code> 时：<ul>
<li>会从当前线程中以 <code>threadLocal</code> 为 key 查找对应的值。</li>
</ul>
</li>
<li><code>remove()</code> 用于手动移除，防止内存泄漏。</li>
</ul>
<p>✅ 本质上：ThreadLocal 并不是把值保存在自己内部，而是保存在当前线程的 <code>ThreadLocalMap</code> 中。</p>
<h3 id="☢️-内存泄漏问题"><a href="#☢️-内存泄漏问题" class="headerlink" title="☢️ 内存泄漏问题"></a>☢️ 内存泄漏问题</h3><ul>
<li><code>ThreadLocalMap</code> 中的 key 是 <code>ThreadLocal</code> 的<strong>弱引用</strong>，但 value 是<strong>强引用</strong></li>
<li>当 ThreadLocal 实例被 GC 回收后，key 变成 null，**<u>value 仍存在，若不手动 remove，就会造成内存泄漏</u>**</li>
<li><strong>最佳实践：用完一定要调用 <code>remove()</code> 方法清除数据</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
<li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线<br>程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中査找关联的资源值</li>
<li>调用remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>ThreadLocal内存泄漏问题ThreadLocalMap 中的key是弱引用，值为强引用; key会被Gc释放内存，关联 value的内存并不会释放。建议主动remove 释放 key，value</li>
</ul>
</blockquote>
<h6 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h6><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会<strong>为每个线程都分配一个独立的线程副本</strong>从而解决了变量并发访问冲突的问题。ThreadLocal同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><strong>ThreadLocal基本使用</strong></p>
<ul>
<li>set(value) 设置值</li>
<li>get() 获取值</li>
<li>remove() 清除值</li>
</ul>
<h6 id="ThreadLocal的实现原理-amp-源码解析"><a href="#ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="ThreadLocal的实现原理 &amp; 源码解析"></a>ThreadLocal的实现原理 &amp; 源码解析</h6><p>ThreadLocal本质来说就是一个<strong>线程内部存储类</strong>，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="https://raw.githubusercontent.com/P-luminary/images/4471cf0ff69616926ff6fab93392d3d9fa5aba32/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3.png"></p>
<h2 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h2><p><span style = "color:red"><strong>什么是JVM？</strong></span></p>
<p>JVM &#x3D; <code>Java Virtual Machine</code>  是java程序的运行环境<br>JVM是运行在操作系统中的 屏蔽了操作系统的差异</p>
<p><strong>好处</strong>：</p>
<ul>
<li>一次编码，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a325bf161b1cdb5a49058d007d4e21a05f2a1fc5/JVM%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png"></p>
<p><span style = "color:red"><strong>什么是程序计数器？</strong></span></p>
<p><strong>程序计数器</strong>：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址</p>
<p><code>javap -v xx.class</code>：打印堆栈大小，局部变量的数量和方法的参数</p>
<blockquote>
<p>找到Application的class文件后 → Build → Rebuild Project<del>编译一下</del> → 找到该Application的class文件<del>黄色的</del> → Open in → Terminal → javap -v Application.class</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f1c8f0c34bb891c12d945dd852ab575a787a2112/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>你能给我详细介绍Java堆吗？</strong></span></p>
<p><strong>线程共享的区域：</strong>主要用来保存<strong>对象实例、数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展，则抛出<code>OutOfMemoryError</code>异常</p>
<ul>
<li>组成：<strong>年轻代 + 老年代</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区<del>幸存者区</del></li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
</li>
<li>jdk1.7和1.8的区别<ul>
<li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5e6f155423b028b82378d40f63a3713073b75410/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86.png"></p>
<p><span style = "color:red"><strong>什么是虚拟机栈？</strong></span></p>
<p><code>Java Virtual machine Stacks</code>(Java虚拟机栈)</p>
<ul>
<li>每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong>，先进后出</li>
<li>每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p><span style = "color:blue">垃圾回收是否涉及栈内存？</span></p>
<p>不涉及，因为垃圾回收主要指的是<strong>堆内存</strong>。<br>这里当栈帧弹栈后，内存就会释放</p>
<p><span style = "color:blue">栈内存分配越大越好吗？</span></p>
<p>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
<p><span style = "color:blue">方法内的局部变量是否线程安全？</span></p>
<p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的<br>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p>
<p><span style = "color:blue">什么情况下会导致栈内存溢出？</span></p>
<p>栈帧过多导致栈内存溢出，经典问题：递归调用<br>栈帧过大导致栈内存溢出</p>
<p><span style = "color:blue">堆栈的区别是什么？</span></p>
<p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会<br>栈内存是线程私有的，而堆内存是线程共有的。<br>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<br>  栈空间不足:java.lang.StackOverFlowError。<br>  堆空间不足:java.ang.OutOfMemoryError。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/420de72ff7c225960e7aff5d59f20c14e93ecb0a/%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p>
<p><span style = "color:red"><strong>能不能解释一下方法区</strong></span></p>
<ul>
<li>方法区(Method Area)是各个线程<strong>共享的内存区域</strong></li>
<li>主要存储类的信息、运行时常量池</li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace</code></li>
</ul>
<h6 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h6><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>在<strong>Terminal</strong>中执行：<code>javap -v Application.class</code><br>可以查看字节码结构 (<strong><u>类的基本信息、常量池、方法定义</u></strong>)<br>当类被加载，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dea620655b2b4c7234ba3b2f4fcedbf76a0bb9a8/%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><span style = "color:red"><strong>你听过直接内存吗？</strong></span></p>
<p><strong>直接内存</strong>：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写能力高。[平时的是BIO]</p>
<p>直接内存并不属于JVM中的内存结构，不由VM进行管理。是虚拟机的系统内存常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5823b0e711a3e4029e411438f0a85468af5dfa3f/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png"></p>
<p><span style = "color:red"><strong>什么是类加载器，类加载器有哪些？</strong></span></p>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来</p>
<ol>
<li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库</del><ul>
<li>这是最顶层的类加载器，它用于加载Java的核心库，这些库位于<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录（比如<code>rt.jar</code>、<code>resources.jar</code>等），或者被<code>-Xbootclasspath</code>参数指定的路径中。</li>
<li><u><strong>引导类加载器是用原生代码（如C&#x2F;C++）实现的</strong></u>，它属于JVM的一部分。</li>
<li>它并不继承自<code>java.lang.ClassLoader</code>，而是由JVM自身实现。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类</del><ul>
<li>它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录中，或者由系统属性<code>java.ext.dirs</code>指定的路径中的类库。</li>
<li>它是<code>sun.misc.Launcher$ExtClassLoader</code>类的实例。</li>
</ul>
</li>
<li><strong>系统类加载器（System ClassLoader）</strong>：<del>用于加载classPath下的类</del><ul>
<li>也称为应用类加载器（Application ClassLoader），它负责加载用户类路径（Classpath）上的所有类库。</li>
<li>系统类加载器是<code>sun.misc.Launcher$AppClassLoader</code>类的实例。</li>
<li>它是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取。</li>
</ul>
</li>
<li><strong>自定义加载器（CustomizeClassLoader）</strong><del>自定义继承ClassLoader，实现自定义类加载规则</del><ul>
<li>用户还可以自定义类加载器。自定义类加载器通过继承<code>java.lang.ClassLoader</code>类并重写相应的方法来实现。自定义类加载器可以用于特定的需求，例如在Web容器中加载类，或者在运行时从网络或其他地方动态加载类。</li>
</ul>
</li>
</ol>
<p><span style = "color:red"><strong>什么是双亲委派模型？</strong></span></p>
<p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p>
<h6 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h6><ul>
<li>通过双亲委派机制可以<strong>避免某一个类被重复加载</strong>，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/994e5705a6bdb7a164308d3496942d154c877b36/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p><span style = "color:red"><strong>说一下类装载的执行过程？</strong></span></p>
<blockquote>
<p><strong>加载</strong>：查找和导入class文件<br><strong>验证</strong>：保证加载类的准确性<br><strong>准备</strong>：为类变量分配内存并设置类变量初始值<br><strong>解析</strong>：把类中的符号引用转换为直接引用<br><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作<br><strong>使用</strong>：JVM 开始从入口方法开始执行用户的程序代码<br><strong>卸载</strong>：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用</strong>和<strong>卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为连接(linking)</p>
<ul>
<li>通过类的全名，获得类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6e58e968ea6bb8bb002556d37d5cc31b73f820e3/%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.png"></p>
<p><span style = "color:red"><strong>对象什么时候可以被垃圾器回收</strong></span></p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong></p>
<p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e29795c3537bdedf4f596d20c78cda8b7f8abc8c/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6.png"></p>
<p><span style = "color:red"><strong>JVM垃圾回收算法有哪些？</strong></span></p>
<ul>
<li><p><strong>标记清除算法</strong></p>
<p>是将垃圾回收分为2个阶段，分别为<strong>标记</strong>和<strong>清除</strong></p>
<ul>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ul>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收；无碎片，内存使用率低</p>
</li>
<li><p><strong>标记清理算法</strong><del>一般用于老年代</del></p>
<p>标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/da45a9b399c0614bb286b0dfef59d0d737ee7b38/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>JVM的分代回收是什么？</strong></span></p>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>在java8时，堆被分为了两份：<strong>新生代和老年代</strong>[1:2]<br>对于新生代，内部又分为了三个区域，Eden区，幸存者区survivor(分成from和to)【8:1:1】</p>
<h6 id="MinorGC、MixedGC、FullGC的区别是什么"><a href="#MinorGC、MixedGC、FullGC的区别是什么" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么"></a>MinorGC、MixedGC、FullGC的区别是什么</h6><ul>
<li>MinorGC<del>(youngGC)</del>发生在新生代的垃圾回收，暂停时间短(STW)</li>
<li>MixedGC：新生代 + 老年代 <strong>部分</strong>区域的垃圾回收，G1收集器特有</li>
<li>FullGC：新生代 + 老年代 <strong>完整</strong>垃圾回收，暂停时间长(STW)，应尽力避免</li>
</ul>
<p><code>STW(Stop-The-World)</code>：<u>暂停所有应用程序线程，等待垃圾回收的完成</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3cf5dfdf35165c472440a0b24f3561c6bef9b81a/JVM%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88.png"></p>
<p><span style = "color:red"><strong>JVM有哪些垃圾回收器？</strong></span></p>
<p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li><p><strong>串行垃圾收集器</strong></p>
<p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial 作用于新生代，采用复制算法</li>
<li>Serial Old 作用于老年代，采用标记-整理算法垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成</li>
</ul>
</li>
<li><p><strong>并行垃圾收集器</strong></p>
<p>Parallel New和Parallel Old是一个<strong>并行</strong>垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><p>Parallel New作用于新生代，采用复制算法</p>
</li>
<li><p>Parallel Old作用于老年代，采用标记-整理算法</p>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成。</p>
</li>
</ul>
</li>
<li><p><strong>CMS(并发)垃圾收集器</strong></p>
<p>CMS全称 Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记-清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
</li>
<li><p><strong>G1垃圾收集器</strong></p>
<p>作用在新生代和老年代</p>
</li>
</ul>
<p><span style = "color:red"><strong>详细聊一下G1垃圾回收器</strong></span></p>
<ul>
<li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li>
<li>划分成多个区域，每个区域都可以充当<strong>eden，survivor，old，humongous</strong>，其中<code>humongous</code>专为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集</li>
<li>如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1a968a17f25b1bbd6bdde1c89b08cb064802b868/%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>强引用、软引用、弱引用、虚引用的区别</strong></span></p>
<blockquote>
<p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，内存依然不够时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，只要进行了垃圾回收，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
</blockquote>
<ul>
<li><strong>强引用</strong>：只有所有 <code>GCRoots</code> 对象都不通过【强引用】 引用该对象，该对象才能被垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
</code></pre>
<p>  <u>GC Root → User对象</u></p>
<ul>
<li><strong>软引用</strong>：仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足</strong>时会再次触发垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
SoftReference softReference = new SoftReference(user);
</code></pre>
<p>  <u>GC Root → SoftReference对象 →→<del>虚线</del> User对象</u><br>  一开始并不会对User对象进行回收 此时User对象就是软引用 如果内存还是不够 马上又再次进行了垃    圾回收 此时软引用的User就会被回收</p>
<ul>
<li><strong>弱引用</strong>：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
</ul>
<pre><code class="java">User user = new User();
WeakReference weakReference = new WeakReference(user)
</code></pre>
<p>  <u>GC Root → WeakReference对象 →→<del>虚线</del> User对象</u></p>
<blockquote>
<p>延申话题：ThreadLocal内存泄露问题</p>
<pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;&#123;
    Object value;
 Entry(ThreadLocal&lt;?&gt;k, Object v)&#123;
     super(k); // k是弱引用
     value = v; // 强引用，不会被回收
 &#125;
&#125;
</code></pre>
</blockquote>
<ul>
<li><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</li>
</ul>
<pre><code class="java">User user = new User();
ReferenceQueue referenceQueue = new ReferenceQueue();
PhantomReference phantomReference = new PhantomReference(user, queue);
</code></pre>
<p><span style = "color:red"><strong>JVM调优的参数可以在哪里设置？</strong></span></p>
<ul>
<li><p><code>war包</code>部署在<code>tomcat</code>中设置</p>
<p>修改 <code>TOMCAT_HOME/bin/catalina.sh</code> 文件<br><code>D:\apache-tomcat-8.5.93\bin\catalina.sh</code></p>
<pre><code class="mysql"># OS specific support.  $var _must_ be set to either true or false.
JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;
cygwin=false
darwin=false
os400=false
hpux=false
</code></pre>
</li>
<li><p><code>jar包</code>部署在<code>启动参数</code>设置</p>
<p>通常在linux系统下直接加参数启动SpringBoot项目<del>—VM</del></p>
<p><code>nohup java -Xms512m -Xmx1024n -jar xxxx.jar --spring.profiles.active=prod &amp;</code></p>
</li>
</ul>
<p><strong>nohup</strong>：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>**参数<code>&amp;</code>**：让命令在后台执行，终端退出后命令仍然执行</p>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<p>对于JVM调优，主要就是调整 <code>年轻代、老年代、元空间</code> 的内存大小及使用的垃圾回收器类型</p>
<ul>
<li><p><strong>设置堆空间大小</strong></p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<pre><code class="java">-Xms: 设置堆的初始化大小
-Xmx: 设置堆的最大大小
// 不指定单位默认为字节
-Xms：1024
-Xms：1024k
</code></pre>
<p>堆内存设置多少合适？</p>
<ul>
<li>最大大小的默认值是物理内存的1&#x2F;4，<strong>初始大小是物理内存的1&#x2F;64</strong><del>【不设置的情况下】</del></li>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生STW，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc，它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p><strong>虚拟机栈的设置</strong></p>
<p>虚拟机栈的设置：<strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<p><code>-Xss 对每个线程stack大小的调整，-Xss128k</code></p>
</li>
<li><p><strong>年轻代中Eden区和两个Survivor区的大小比例</strong></p>
<p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。通过增大Eden区的大小来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<p><code>-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor:eden = 2:8</code></p>
</li>
<li><p><strong>年前代晋升老年代阈值</strong>【默认值为15，取值范围0-15】</p>
<p><code>-XX:MaxTenuringThreshold=threshold</code></p>
</li>
<li><p><strong>设置垃圾回收收集器</strong></p>
<p>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器</p>
<p><code>-XX:+UseParallelGC</code><br><code>-XX:+UseParallelOldGC</code></p>
<p><code>-XX:+UserG1GC</code></p>
</li>
</ul>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<ul>
<li><p><strong>命令工具</strong></p>
<ul>
<li><p><strong>jps</strong> 进程状态信息</p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
</li>
<li><p><strong>jmap</strong> 查看堆栈信息[生成堆转内存快照,内存使用信息]</p>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid
</code></pre>
<ul>
<li><p>format&#x3D;b 表示以hprof二进制格式存储Java堆的内存</p>
</li>
<li><p>file&#x3D;&lt; filename  &gt; 用于指定快照dump文件的文件名</p>
<p><code>dump</code>：它是我们都可以通过工个进程或系统在某一给定的时间的快照。比如在进程崩溃时，甚至是任何时候，具将系统或某进程的内存备份出来供调试分析用，dump文件中包含了程序运行的模块信息、线程信息、堆调用信息、异常信息等数据，方便系统技术人品进行错误排查</p>
</li>
</ul>
</li>
<li><p><strong>jhat</strong> 堆转储快照分析工具</p>
</li>
<li><p><strong>jstat</strong> JVM统计监测工具[可以用来显示垃圾回收信息、类加载信息、新生代统计信息等]</p>
<ul>
<li>总结垃圾回收统计：<code>jstat -gcutil pid</code></li>
<li>垃圾回收统计：<code>jstat -gc pid</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可视化工具</strong></p>
<ul>
<li><strong>jconsole</strong> 用于对jvm的内存，线程，类的监控, 是一个可视化工具<br><code>D:\java\jdk-11.0.20\bin\jconsole.exe</code></li>
<li><strong>VisualVM</strong> 能够监控线程，内存情况<del>只有jdk1.8有</del><br><code>D:\java\jdk1.8.0_181\bin\jvisualvm.exe</code></li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>Java内存泄露的排查思路？</strong></span></p>
<blockquote>
<p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
</blockquote>
<p>JVM  Stacks <strong>虚拟机栈</strong> → <code>StackOverFlowError</code><br>Heap <strong>堆</strong> → <code>OutOfMemoryError：java heap space</code><br>Method Are&#x2F; MateSpace <strong>方法区&#x2F;元空间</strong> → <code>OutOfMemoryError: Metaspace</code></p>
<p>模拟堆空间溢出场景：-VM设置参数 → <code>-Xmx10m</code></p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
while(true)&#123;
    list.add(&quot;北京&quot;);
&#125;
-------------------------------------------
// OutOfMemoryError：java heap space
</code></pre>
<h6 id="如何排查启动闪退、运行一段时间宕机"><a href="#如何排查启动闪退、运行一段时间宕机" class="headerlink" title="如何排查启动闪退、运行一段时间宕机"></a>如何排查启动闪退、运行一段时间宕机</h6><ul>
<li><p>获取堆内存快照dump</p>
<ul>
<li>使用jmap命令获取运行中程序的dump文件<del>【只有在项目运行时候才可以用】</del></li>
</ul>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid 【只有在项目运行时候才可以用】
</code></pre>
<ul>
<li><p><strong>使用vm参数获取dump文件</strong></p>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成dump文件</p>
</li>
</ul>
<pre><code class="java">-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/home/app/dumps/
</code></pre>
</li>
<li><p>VisualVM区分析dump文件</p>
</li>
<li><p>通过查看堆内存的信息，定位内存溢出问题</p>
</li>
</ul>
<p><span style = "color:red"><strong>CPU飙高排查方案与思路？</strong></span></p>
<blockquote>
<p>1.使用top命令查看占用cpu的情况<br>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>3.使用ps命令查看进程中的线程信息<br>4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
</blockquote>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程转换十六进程<br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><span style = "color:red">设计模式</span></h2><h5 id="框架中的设计模式-项目中的设计模式"><a href="#框架中的设计模式-项目中的设计模式" class="headerlink" title="框架中的设计模式 + 项目中的设计模式"></a>框架中的设计模式 + 项目中的设计模式</h5><p><span style = "color:red"><strong>简单工厂模式</strong></span></p>
<p>简单工厂包含如下角色</p>
<ul>
<li><strong>抽象产品</strong>：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li><strong>具体产品</strong> ：实现或者继承抽象产品的子类</li>
<li><strong>具体工厂</strong>：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<p>需求：设计一个咖啡店点餐系统。<br>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCofee】和拿铁咖啡【LatteCoffee】); 再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d91b96f4466457e253dd9a8b298f99c098e4501c/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>工厂方法模式</strong></span><del>完全遵循开闭原则</del></p>
<p>方法模式的主要角色:<br><strong>抽象工厂</strong>(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br><strong>具体工厂</strong>(ConcreteFactory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br><strong>抽象产品</strong>(Product)：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品</strong>(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一 一对应。</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/55e41a4a745af324a0d0a18d0af0694fb0d319e9/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>抽象工厂模式</strong></span></p>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理等级产品的生产<br>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产–个等级的产品，而抽象工厂模式可生产多个等级的产品<strong>。一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dc778be8350e592f74d23beeee7c256826204f4/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>策略模式</strong></span></p>
<ul>
<li>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</li>
<li>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</li>
</ul>
<p>策略模式的主要角色如下:<br><strong>抽象策略(Strategy)类</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口<br><strong>具体策略(Concrete Strategy)类</strong>：实现了抽象策略定义的接口，提供具体的算法实现或行为。<br><strong>环境(Context)类</strong>：持有一个策略类的引用，最终给客户端调用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b29eac1685bcdf60e7adde25286c276ddbeb43a7/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA.png"></p>
<h4 id="策略模式—登录案例-工厂模式-策略模式"><a href="#策略模式—登录案例-工厂模式-策略模式" class="headerlink" title="策略模式—登录案例 (工厂模式 + 策略模式)"></a><span style = "color:red"><strong>策略模式—登录案例 (工厂模式 + 策略模式)</strong></span></h4><blockquote>
<ul>
<li><p>什么是策略模式</p>
<ul>
<li><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</p>
</li>
</ul>
</li>
<li><p>案例(工厂方法+策略)</p>
<ul>
<li>介绍业务(登录、支付、解析excel、优惠等级…)</li>
<li>提供了很多种策略，都让spring容器管理</li>
<li>提供一个工厂：准备策略对象，根据参数提供对象</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一句话总结</strong>：只要代码中有冗长的if-else 或switch 分支判断都可以采用策略模式优化</p>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>订单的支付策略(支付宝、微信、银行卡..)</li>
<li>解析不同类型excel(xls格式、xlsx格式)</li>
<li>打折促销(满300元9折、满500元8折、满1000元7折..)</li>
<li>物流运费阶梯计算(5kg以下、5-10kg、10-20kg、20kg以上)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/69c802f411142a1bdabf991a27b8a48662cc8ca9/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9F.png" alt="策略模式和工厂方法模拟.png"></p>
<p><span style = "color:red"><strong>责任链模式—概述及案例</strong></span></p>
<p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<ul>
<li><strong>抽象处理者(Handler)角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li><strong>具体处理者(Concrete Handler)角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类(Cient)角色</strong>：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>内容审核(视频、文章、课程)</li>
<li>订单创建</li>
<li>简易流程审批</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c73c212f673d69975c55ad134b045e433a6f1e23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F2.png"></p>
<h3 id="常见技术场景题"><a href="#常见技术场景题" class="headerlink" title="常见技术场景题"></a><span style = "color:red">常见技术场景题</span></h3><h6 id="单点登录这块怎么实现的？"><a href="#单点登录这块怎么实现的？" class="headerlink" title="单点登录这块怎么实现的？"></a><span style = "color:red">单点登录这块怎么实现的？</span></h6><p>单点登录的英文名：Single Sign On (<strong>SSO</strong>)，只需要登录一次，就可以访问所有信任的应用系统</p>
<p>① 先解释什么是单点登录：单点登录的英文名叫做:Single SignOn(简称SSO)<br>② 介绍自己项目中涉及到的单点登录(即使没涉及过，也可以说实现的思路)<br>③ 介绍单点登录的解决方案，以JWT为例<br>    用户访问其他系统，会在网关判断token是否有效<br>    如果token无效则会返回401(认证失败)前端跳转到登录页面<br>    用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie<br>    再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3389992651a50673831641a3ae5dd61aa8e344a/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.png"></p>
<h6 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a><span style = "color:red">权限认证是如何实现的？</span></h6><p>后台的管理系统，更注重权限控制，最常见的就是<strong>RBAC</strong>模型来指导实现权限<br>RBAC(Role-Based Access Control)基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：<strong>用户、角色、权限</strong></li>
<li>具体实现：<ul>
<li>5张表：<strong>用户表、角色表、权限表、用户角色中间表、角色权限中间表</strong></li>
<li>7张表：<strong>用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表</strong></li>
</ul>
</li>
</ul>
<p>张三具有什么权限呢？<br>流程：张三登录系统 → 查询张三拥有的角色列表 → 再根据角色查询拥有的权限</p>
<p>权限框架：<code>Apache shiro</code>、<code>Spring Security（推荐）</code><br><img src="https://raw.githubusercontent.com/P-luminary/images/ed40dce8c09b42689021c6ee66a4565a314acc69/RBAC%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h6 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a><span style = "color:red">上传数据的安全性你们怎么控制？</span></h6><p>主要说的是数据在网络上传输如何保证安全</p>
<p>使用**非对称加密(或对称加密)**，给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p>
<h6 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h6><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9886840e455bef1ee39b93c8c75495b6e80fe6fb/%E5%AF%B9%E7%A7%B0+%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png"></p>
<h6 id="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3"><a href="#你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1+3"></a><span style = "color:red">你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？</span><del>1+3</del></h6><blockquote>
<p>其次你也可以说说aop的实现，比如你们操作日志记录等，利用aop切面思想，通过环绕通知等但需封装出出个切面工具类。建议你们说说sql调优，比如商品列表页需要分页查询，但是几百万商品导致查询慢，如何优化的，这是一个</p>
</blockquote>
<h6 id="①-设计模式在项目中的应用"><a href="#①-设计模式在项目中的应用" class="headerlink" title="① 设计模式在项目中的应用"></a><span style = "color:blue">① 设计模式在项目中的应用</span></h6><p>是为了遵循一系列的开发原则【工厂、策略、责任链】</p>
<ul>
<li>什么背景[技术问题] → 登录的例子</li>
<li>过程[解决问题的过程]</li>
<li>最终落地方案</li>
</ul>
<h6 id="②-线上BUGJVM-多线程"><a href="#②-线上BUGJVM-多线程" class="headerlink" title="② 线上BUGJVM+多线程"></a><span style = "color:blue">② 线上BUG<del>JVM+多线程</del></span></h6><ul>
<li>CPU飙高</li>
<li>内存泄露</li>
<li>线程死锁</li>
</ul>
<h6 id="③-调优"><a href="#③-调优" class="headerlink" title="③ 调优"></a><span style = "color:blue">③ 调优</span></h6><ul>
<li>慢接口</li>
<li>慢SQL</li>
<li>缓存方案</li>
</ul>
<p><span style = "color:blue"><strong>④ 组件封装</strong></span></p>
<ul>
<li>分布式锁</li>
<li>接口幂等</li>
<li>分布式事务</li>
<li>支付通用</li>
</ul>
<h6 id="你们项目中日志怎么采集的？"><a href="#你们项目中日志怎么采集的？" class="headerlink" title="你们项目中日志怎么采集的？"></a><span style = "color:red">你们项目中日志怎么采集的？</span></h6><blockquote>
<p>我们搭建了ELK日志采集系统<br>介绍**<u>ELK</u>**的三个组件:<br><strong>Elasticsearch</strong>是全文搜索分析引擎，可以对数据存储、搜索、分析<br><strong>Logstash</strong>是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置<br><strong>Kibana</strong>是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</p>
</blockquote>
<ul>
<li><strong>为什么要采集日志</strong>？</li>
</ul>
<p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p>
<ul>
<li><strong>采集日志的方式有哪些</strong><ul>
<li><span style = "color:orange"><strong>ELK</strong>：即<code>ElasticSearch、LogStash、Kibanna</code>三个软件的首字母</span></li>
<li><strong>常规采集</strong>：按天保存到一个日志文件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b737bd7a31bb44363954ebefe0f32095096a3793/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84.png"></p>
<h6 id="查看日志的命令？查看是否在线查看过日志"><a href="#查看日志的命令？查看是否在线查看过日志" class="headerlink" title="查看日志的命令？查看是否在线查看过日志"></a><span style = "color:red">查看日志的命令？</span><del>查看是否在线查看过日志</del></h6><ul>
<li><p><strong>实时监控日志的变化</strong><br>实时监控某一个日志文件的变化：<code>tail -f xx.log</code><br>实时监控日志文件最后100行的变化：<code>tail -n 100 -f xx.log</code></p>
</li>
<li><p><strong>按照行号查询</strong><br>查询日志尾部最后100行日志：<code>tail -n 100 xx.log</code><br>查询日志头部开始100行日志：<code>head -n 100 xx.log</code><br>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code>(查询100行至200行的日志)</p>
</li>
<li><p><strong>按照关键字找日志的信息</strong><br>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p><strong>按照日期查询</strong><del>日期必须在日志中出现过</del></p>
<p><code>sed -n &#39;/2025-01-14 14:22:31.070/,/ 2025-01-14 14:27:18.158/p&#39; xx.log</code></p>
</li>
<li><p><strong>日志太多，处理方式</strong></p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log | grep &quot;debug&quot; | more</code></li>
<li>筛选过滤后，输出到一个文件：<code>cat -n xx.log | grep &quot;debug&quot; &gt; debug.txt</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9ee9064d3f9fa8ae290a4ccfe1da9af84b88e584/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4.png"></p>
<h6 id="上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码"><a href="#上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码" class="headerlink" title="上线的项目远程Debug —— 生产问题怎么排查？本地调试远程代码"></a><span style = "color:red">上线的项目远程Debug —— 生产问题怎么排查？</span><del>本地调试远程代码</del></h6><p>已经上线的bug排查的思路:</p>
<ul>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(通常公司的正式环境(生产环境)是<strong>不允许远程debug的</strong>。一般远程debug都是公司的测试环<br>境，方便调试代码)</li>
</ul>
<p><strong>远程debug</strong></p>
<p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p>
<p><strong>①</strong> 远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</code></p>
<p><strong>②</strong> idea中设置远程debug，找到idea中的<code>Edit Configurations...</code> → 添加一个<code>Remote JVM debug</code> → 右侧要配置<code>Configuration</code>的Host → 添加上面的代码…</p>
<p><strong>③</strong> 在项目中点debug(绿色小虫子)</p>
<p><strong>④</strong> 访问远程服务器，在本地代码中打断点即可调试远程</p>
<p><span style = "color:red"><strong>怎么快速定位系统的瓶颈？</strong></span></p>
<ul>
<li><p>压测(性能测试)，<strong>项目上线之前测评系统的压力</strong></p>
<ul>
<li>压测目的：给出系统当前的性能状况;定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、QPS、并发数、吞吐量、CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端工程师：根据压测的结果进行解决或调优(接口、代码报错、并发达不到要求.)</li>
</ul>
</li>
<li><p>监控工具、链路追踪工具，<strong>项目上线之后监控</strong></p>
<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li><p>线上诊断工具Arthas(阿尔萨斯)，<strong>项目上线之后监控、排查</strong></p>
<ul>
<li><p>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p>
</li>
<li><p>核心功能:Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。<br>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决:</p>
<ul>
<li><p>这个类从哪个jar 包加载的?为什么会报各种类相关的 Exception?</p>
</li>
<li><p>我改的代码为什么没有执行到?难道是我没 commit?分支搞错了?</p>
</li>
<li><p>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗?</p>
</li>
<li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现!</p>
</li>
<li><p>是否有一个全局视角来查看系统的运行状况?</p>
</li>
<li><p>有什么办法可以监控到 JVM 的实时运行状态?</p>
</li>
<li><p>怎么快速定位应用的热点，生成火焰图?</p>
</li>
<li><p>怎样直接从 JVM 内查找某个类的实例?</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>怎么解决cpu飙高?</strong></span></p>
<p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息    使用<code>top -H -p 进程Id</code> [找线程哪个使用多]<br>记住要打印<code>%X十六进制</code>的<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题<br><code>jstack 进程PID | grep 16进制线程PID -A 20</code></p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h3 id="2025-x2F-1-x2F-14-20-35-地点广州-完结撒花"><a href="#2025-x2F-1-x2F-14-20-35-地点广州-完结撒花" class="headerlink" title="2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花"></a><span style = "color:red">2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花</span></h3><p><span style = "color:red"><strong>项目难点？</strong></span><del>四方保险——day11-数据中心：时序数据库、看板展示【实战】</del></p>
<p>技术上的难点：<strong>时序数据库</strong>、<strong>看板展示</strong></p>
<p><span style = "color:red"><strong>秒杀系统如何优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96a974e196f2d93a561775732ddf415ee4b401cd/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF.png"></p>
<h6 id="痛点描述："><a href="#痛点描述：" class="headerlink" title="痛点描述："></a>痛点描述：</h6><ul>
<li><strong>瞬时并发量大</strong><ul>
<li>大量用户会在同一时间进行抢购</li>
<li>网站瞬时访问流量激增</li>
</ul>
</li>
<li><strong>库存少</strong><ul>
<li>访问请求数量远远大于库存数量</li>
<li>只有少部分用户能够秒杀成功</li>
</ul>
</li>
</ul>
<p><strong>Ⅰ. 访问层 — 商品页</strong></p>
<ul>
<li>可以将<strong>静态秒杀页面</strong>放在cdn上[用户访问速度↑   减轻服务器压力++]</li>
</ul>
<p><strong>Ⅱ. 访问层 — 秒杀按钮</strong></p>
<ul>
<li>活动前禁用按钮、点击后禁用按钮、滑动验证码[防羊毛党]、排队体验[提升用户体验]</li>
</ul>
<p><strong>Ⅲ. 中间转换层 — 多级负载均衡 &amp; 限流 &amp; 自动伸缩</strong></p>
<ul>
<li>通常会通过Nginx来进行负载均衡【单台Ng处理的并发量是两三万左右】</li>
<li>在它上层要做到硬件级别的隔离器 【F5&#x2F;LVS】</li>
<li>通过Ng负载均衡到网关之后 通过客户端的负载均衡器Ribbon</li>
<li>4级的负载均衡 可以处理每秒上10W以上的QPS并发量</li>
<li>通过<strong>Docker</strong>或<strong>K8S</strong>来进行云服务器的<strong>动态伸缩</strong>的部署[秒杀开始自动扩容 秒杀结束自动缩减]</li>
<li>注意要在Ng上做好限流 防止一些绕过了我们前端的DDOS攻击 还需要在网关层通过<code>Sentinel</code>对不同的服务节点去设置限流以及熔断的机制</li>
<li>可以在秒杀中通过MQ做削锋填股 通过MQ可以减轻下游的压力 防止激增流量打垮下游数据库</li>
</ul>
<p><strong>Ⅳ. 服务端 — 用Redis做缓存减轻数据库压力</strong></p>
<ul>
<li>秒杀商品信息预热到Redis中 防止Redis被击穿我们的数据库</li>
<li>通过Redis的<strong>Lua脚本</strong>[保证多个操作的原子性]操作库存</li>
<li>防重 可以通过 redis的SETNX → 用 <strong><u>Token + 商品URL</u></strong> &#x2F;&#x2F; <strong><u>IP + 商品URL</u></strong> 只能有一个有效</li>
<li>分布式锁保证请求的原子性 → Redisson的分布式锁</li>
</ul>
<p>**Ⅴ. 数据库 — 读写分离 **</p>
<ul>
<li>数据量很大就分库分表</li>
</ul>
<blockquote>
<h4 id="✅-一张图理清：秒杀系统全链路优化流程"><a href="#✅-一张图理清：秒杀系统全链路优化流程" class="headerlink" title="✅ 一张图理清：秒杀系统全链路优化流程"></a>✅ 一张图理清：秒杀系统全链路优化流程</h4><pre><code class="java"> [用户点击秒杀按钮]
        ↓
   【前端防刷】
      - 限制频繁点击
      - 滑动验证码
      - 倒计时、按钮控制
        ↓
   【网关 &amp; Nginx】
      - 黑名单拦截（IP、UA）
      - Sentinel 限流 + 降级 + 熔断
        ↓
   【秒杀服务】
      - 判断秒杀状态、时间、库存是否存在
      - 生成秒杀Token（防重）
      - Redis 原子性扣减库存（Lua脚本）
      - 发送下单消息至 MQ 异步处理
        ↓
   【MQ异步削峰】
      - 持久化队列（RocketMQ / Kafka）
      - 消费者异步落库
        ↓
   【数据库层】
      - MySQL最终扣减库存 + 创建订单（事务）
      - 数据库读写分离 / 分库分表
</code></pre>
<h2 id="🧩-各模块详细优化方案"><a href="#🧩-各模块详细优化方案" class="headerlink" title="🧩 各模块详细优化方案"></a>🧩 <strong>各模块详细优化方案</strong></h2><h3 id="①-前端层（第一道防线）"><a href="#①-前端层（第一道防线）" class="headerlink" title="① 前端层（第一道防线）"></a>① 前端层（第一道防线）</h3><ul>
<li><p>✅ <strong>活动页静态化</strong>：部署在 CDN，秒开页面，减少服务器并发压力。</p>
<blockquote>
<p><strong>CDN域名</strong>是指通过内容分发网络（CDN）技术加速访问的域名。CDN的全称是<strong>Content Delivery Network</strong>，即内容分发网络。它通过将源站内容分发到分布在全球各地的加速节点，使用户可以从离自己最近的节点获取内容，从而提升访问速度和体验。</p>
<p>CDN域名的工作原理是将用户的访问请求通过DNS解析，指向最优的CDN节点。如果节点上已有缓存内容，则直接返回给用户；如果没有缓存，则从源站拉取内容并缓存到节点，供后续用户访问。</p>
</blockquote>
</li>
<li><p>✅ <strong>JS 控制按钮状态</strong>：倒计时期间按钮禁用；点击后立即禁用防止重复提交。</p>
</li>
<li><p>✅ <strong>防刷机制</strong>：</p>
<ul>
<li>滑动验证码（极验、腾讯滑动等）</li>
<li>限制频繁请求（客户端节流 + 后端拦截）</li>
<li>秒杀路径动态化（通过接口获取临时随机URL）</li>
</ul>
</li>
</ul>
<h3 id="②-网关层（第二道防线）"><a href="#②-网关层（第二道防线）" class="headerlink" title="② 网关层（第二道防线）"></a>② 网关层（第二道防线）</h3><ul>
<li>✅ <strong>Nginx限流</strong> + F5&#x2F;LVS 硬件负载均衡</li>
<li>✅ <strong>Sentinel限流</strong>：<ul>
<li>QPS限流、线程数限制</li>
<li>降级策略（服务不稳定时快速失败）</li>
</ul>
</li>
<li>✅ <strong>灰度发布</strong> + 金丝雀策略防雪崩</li>
</ul>
<h3 id="③-服务层（核心逻辑）"><a href="#③-服务层（核心逻辑）" class="headerlink" title="③ 服务层（核心逻辑）"></a>③ 服务层（核心逻辑）</h3><ul>
<li>✅ <strong>Redis预热商品库存</strong>：<ul>
<li><code>key: seckill:stock:123 =&gt; 10</code></li>
</ul>
</li>
<li>✅ <strong>Lua脚本保证扣减原子性</strong></li>
</ul>
<pre><code class="java">if redis.call(&quot;get&quot;, KEYS[1]) &gt;= tonumber(ARGV[1]) then
   return redis.call(&quot;decrby&quot;, KEYS[1], ARGV[1])
else
   return -1
end
</code></pre>
<ul>
<li>✅ <strong>Token校验防重</strong>（防止同一用户多次提交）<ul>
<li>用户下发秒杀Token</li>
<li>下单时校验 token 是否存在</li>
</ul>
</li>
<li>✅ <strong>幂等性处理</strong>：幂等令牌、Redis标记等手段防止重复下单</li>
<li>✅ <strong>Redisson分布式锁</strong>（用于控制某些全局状态，如每秒限量）</li>
</ul>
<h3 id="④-MQ-消息队列层（削峰填谷）"><a href="#④-MQ-消息队列层（削峰填谷）" class="headerlink" title="④ MQ 消息队列层（削峰填谷）"></a>④ MQ 消息队列层（削峰填谷）</h3><ul>
<li>✅ 典型架构：RocketMQ &#x2F; RabbitMQ &#x2F; Kafka</li>
<li>✅ 一进一出，异步下单逻辑<ul>
<li>消息格式：包含<code>userId</code>, <code>productId</code>, <code>token</code></li>
</ul>
</li>
<li>✅ 消息失败怎么办？<ul>
<li><strong>死信队列</strong> + 重试机制 + 日志报警</li>
</ul>
</li>
</ul>
<h3 id="⑤-数据库层（最终一致性）"><a href="#⑤-数据库层（最终一致性）" class="headerlink" title="⑤ 数据库层（最终一致性）"></a>⑤ 数据库层（最终一致性）</h3><ul>
<li>✅ <strong>分库分表</strong>：<ul>
<li>订单表按用户ID或时间范围分表</li>
<li>库存表按商品类型分表</li>
</ul>
</li>
<li>✅ <strong>读写分离</strong>：<ul>
<li>MySQL主从复制</li>
<li>下单写入主库，查询走从库</li>
</ul>
</li>
<li>✅ <strong>事务处理</strong>：<ul>
<li>扣库存 + 创建订单需要事务包裹</li>
</ul>
</li>
<li>✅ <strong>补偿机制</strong>：<ul>
<li>MQ失败回滚机制 + 自动重试 or 人工介入</li>
</ul>
</li>
</ul>
<h2 id="🎯-秒杀系统关键点总结（重点记忆）"><a href="#🎯-秒杀系统关键点总结（重点记忆）" class="headerlink" title="🎯 秒杀系统关键点总结（重点记忆）"></a>🎯 秒杀系统关键点总结（重点记忆）</h2><table>
<thead>
<tr>
<th>优化维度</th>
<th>关键点</th>
</tr>
</thead>
<tbody><tr>
<td>防刷防作弊</td>
<td>滑动验证码、动态路径、限流、IP黑名单</td>
</tr>
<tr>
<td>限流削峰</td>
<td>Sentinel、MQ异步下单、排队</td>
</tr>
<tr>
<td>高性能扣减</td>
<td>Redis + Lua 脚本，原子扣减库存</td>
</tr>
<tr>
<td>数据一致性</td>
<td>MQ消息可靠投递、事务补偿机制</td>
</tr>
<tr>
<td>分布式扩展</td>
<td>分库分表、读写分离、动态扩容</td>
</tr>
<tr>
<td>安全性</td>
<td>Token校验、防重、防止超卖</td>
</tr>
</tbody></table>
<p>我将为你详细讲解和设计一个真实的<strong>秒杀系统完整优化方案</strong>，从 Redis 预热、限流、库存扣减、异步下单、订单状态回写等关键步骤一一展开说明，并配上示意代码。</p>
<hr>
<h2 id="🔧-一、整体秒杀流程概览图"><a href="#🔧-一、整体秒杀流程概览图" class="headerlink" title="🔧 一、整体秒杀流程概览图"></a>🔧 一、整体秒杀流程概览图</h2><pre><code class="java">用户请求 → 接入层限流 → Redis预扣库存（Lua脚本） → 发送MQ消息 → 异步下单 → 数据库落库 → 回写订单状态
</code></pre>
<hr>
<h2 id="🧱-二、Redis缓存预热（秒杀前的准备工作）"><a href="#🧱-二、Redis缓存预热（秒杀前的准备工作）" class="headerlink" title="🧱 二、Redis缓存预热（秒杀前的准备工作）"></a>🧱 二、Redis缓存预热（秒杀前的准备工作）</h2><blockquote>
<p>提前将商品库存加载到 Redis，避免高并发时频繁访问数据库。</p>
</blockquote>
<pre><code class="java">// Redis结构设计
// key: seckill:stock:&lt;skuId&gt;
// val: 商品库存数量

public void preloadSeckillStock(Long skuId, Integer stock) &#123;
    String key = &quot;seckill:stock:&quot; + skuId;
    redisTemplate.opsForValue().set(key, stock);
&#125;
</code></pre>
<hr>
<h2 id="🛡-三、限流-防刷-验签（接入层）"><a href="#🛡-三、限流-防刷-验签（接入层）" class="headerlink" title="🛡 三、限流 + 防刷 + 验签（接入层）"></a>🛡 三、限流 + 防刷 + 验签（接入层）</h2><blockquote>
<p>使用网关 Sentinel 限流，前端限制点击频率，后端防刷接口做风控。</p>
</blockquote>
<pre><code class="java">@GetMapping(&quot;/doSeckill&quot;)
public ResponseEntity&lt;?&gt; doSeckill(@RequestParam Long skuId) &#123;
    // 判断是否登录
    Long userId = getLoginUserId();
    
    // 判断是否重复请求（防重）
    String repeatKey = &quot;seckill:user:&quot; + userId + &quot;:sku:&quot; + skuId;
    Boolean hasBought = redisTemplate.opsForValue().setIfAbsent(repeatKey, &quot;1&quot;, 5, TimeUnit.MINUTES);
    if (!hasBought) return ResponseEntity.status(429).body(&quot;请勿重复抢购&quot;);

    // 执行扣库存的 Lua 脚本
    Long result = redisTemplate.execute(luaScript, Collections.singletonList(&quot;seckill:stock:&quot; + skuId), &quot;1&quot;);
    if (result == 0L) return ResponseEntity.status(410).body(&quot;库存不足&quot;);

    // 发送消息至 MQ 进行异步处理
    SeckillMessage msg = new SeckillMessage(userId, skuId);
    mqTemplate.convertAndSend(&quot;seckill.queue&quot;, msg);

    return ResponseEntity.ok(&quot;下单请求已提交&quot;);
&#125;
</code></pre>
<hr>
<h2 id="📜-四、Lua脚本操作-Redis（保证原子性）"><a href="#📜-四、Lua脚本操作-Redis（保证原子性）" class="headerlink" title="📜 四、Lua脚本操作 Redis（保证原子性）"></a>📜 四、Lua脚本操作 Redis（保证原子性）</h2><pre><code class="java">-- KEYS[1]: 库存key
-- ARGV[1]: 扣减数量
local stock = redis.call(&quot;get&quot;, KEYS[1])
if tonumber(stock) &gt;= tonumber(ARGV[1]) then
    return redis.call(&quot;decrby&quot;, KEYS[1], ARGV[1])
end
return 0
</code></pre>
<hr>
<h2 id="📦-五、MQ异步消费-创建订单（核心业务）"><a href="#📦-五、MQ异步消费-创建订单（核心业务）" class="headerlink" title="📦 五、MQ异步消费 + 创建订单（核心业务）"></a>📦 五、MQ异步消费 + 创建订单（核心业务）</h2><blockquote>
<p>用 RabbitMQ、RocketMQ、Kafka 等异步落库下单，减轻主线程压力。</p>
</blockquote>
<pre><code class="java">@RabbitListener(queues = &quot;seckill.queue&quot;)
public void handleSeckill(SeckillMessage msg) &#123;
    Long userId = msg.getUserId();
    Long skuId = msg.getSkuId();

    // 检查数据库是否已下单（防止重复下单）
    boolean exists = orderMapper.existsByUserAndSku(userId, skuId);
    if (exists) return;

    // 创建订单
    Order order = new Order();
    order.setUserId(userId);
    order.setSkuId(skuId);
    order.setStatus(&quot;WAIT_PAY&quot;);
    orderMapper.insert(order);
&#125;
</code></pre>
<hr>
<h2 id="🧨-六、下单后定时关闭未支付订单（延迟消息）"><a href="#🧨-六、下单后定时关闭未支付订单（延迟消息）" class="headerlink" title="🧨 六、下单后定时关闭未支付订单（延迟消息）"></a>🧨 六、下单后定时关闭未支付订单（延迟消息）</h2><blockquote>
<p>利用 RabbitMQ 的延迟队列（或用 Redis 的 ZSet+定时任务轮询）。</p>
</blockquote>
<pre><code class="java">// 下单后发送延迟消息
rabbitTemplate.convertAndSend(&quot;order.ttl.exchange&quot;, &quot;order.ttl&quot;, orderId);

// 死信队列处理超时未支付订单
@RabbitListener(queues = &quot;order.dlx.queue&quot;)
public void closeOrder(String orderId) &#123;
    Order order = orderMapper.selectById(orderId);
    if (&quot;WAIT_PAY&quot;.equals(order.getStatus())) &#123;
        order.setStatus(&quot;CLOSED&quot;);
        orderMapper.updateById(order);

        // 回滚库存
        redisTemplate.opsForValue().increment(&quot;seckill:stock:&quot; + order.getSkuId());
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="📊-七、数据一致性考虑"><a href="#📊-七、数据一致性考虑" class="headerlink" title="📊 七、数据一致性考虑"></a>📊 七、数据一致性考虑</h2><table>
<thead>
<tr>
<th>场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>Redis库存扣减成功但消息发送失败</td>
<td>使用本地事务 + MQ事务消息机制</td>
</tr>
<tr>
<td>订单超时未支付但库存没回滚</td>
<td>MQ死信队列 + 回滚库存</td>
</tr>
<tr>
<td>秒杀重复下单</td>
<td>Redis防重 + DB唯一约束</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-八、技术选型建议"><a href="#✅-八、技术选型建议" class="headerlink" title="✅ 八、技术选型建议"></a>✅ 八、技术选型建议</h2><table>
<thead>
<tr>
<th>模块</th>
<th>技术</th>
</tr>
</thead>
<tbody><tr>
<td>缓存</td>
<td>Redis</td>
</tr>
<tr>
<td>消息队列</td>
<td>RabbitMQ&#x2F;RocketMQ</td>
</tr>
<tr>
<td>限流防刷</td>
<td>Sentinel、滑动窗口</td>
</tr>
<tr>
<td>延迟任务</td>
<td>MQ延迟队列、定时任务轮询</td>
</tr>
<tr>
<td>锁</td>
<td>Redisson 分布式锁</td>
</tr>
<tr>
<td>脚本原子性</td>
<td>Lua脚本</td>
</tr>
</tbody></table>
<hr>
<hr>
<h4 id="你说的很好-我想更进一步了解一下-你说的-Nginx限流-F5-x2F-LVS硬件负载均衡；网关-amp-nginx黑名单拦截-IP、UA-；生成秒杀Token；灰度发布-金丝雀策略"><a href="#你说的很好-我想更进一步了解一下-你说的-Nginx限流-F5-x2F-LVS硬件负载均衡；网关-amp-nginx黑名单拦截-IP、UA-；生成秒杀Token；灰度发布-金丝雀策略" class="headerlink" title="你说的很好 我想更进一步了解一下 你说的 Nginx限流+F5&#x2F;LVS硬件负载均衡；网关&amp;nginx黑名单拦截(IP、UA)；生成秒杀Token；灰度发布+金丝雀策略"></a>你说的很好 我想更进一步了解一下 你说的 Nginx限流+F5&#x2F;LVS硬件负载均衡；网关&amp;nginx黑名单拦截(IP、UA)；生成秒杀Token；灰度发布+金丝雀策略</h4><h2 id="✅-一、Nginx-限流-F5-x2F-LVS-硬件负载均衡"><a href="#✅-一、Nginx-限流-F5-x2F-LVS-硬件负载均衡" class="headerlink" title="✅ 一、Nginx 限流 + F5&#x2F;LVS 硬件负载均衡"></a>✅ 一、Nginx 限流 + F5&#x2F;LVS 硬件负载均衡</h2><h3 id="1-Nginx-限流"><a href="#1-Nginx-限流" class="headerlink" title="1. Nginx 限流"></a>1. Nginx 限流</h3><h4 id="✨目的："><a href="#✨目的：" class="headerlink" title="✨目的："></a>✨目的：</h4><ul>
<li>限制单位时间的请求数，防止恶意刷接口、瞬间高并发导致服务崩溃。</li>
</ul>
<h4 id="✨配置方式："><a href="#✨配置方式：" class="headerlink" title="✨配置方式："></a>✨配置方式：</h4><pre><code>http &#123;
    limit_req_zone $binary_remote_addr zone=req_limit_per_ip:10m rate=1r/s;
    ...
    server &#123;
        location /seckill &#123;
            limit_req zone=req_limit_per_ip burst=5 nodelay;
            proxy_pass http://seckill-server;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul>
<li><code>rate=1r/s</code>：每秒允许一个请求。</li>
<li><code>burst=5</code>：允许瞬间突发5个请求。</li>
<li><code>nodelay</code>：立即处理突发请求，不排队。</li>
</ul>
<h4 id="✅应用场景："><a href="#✅应用场景：" class="headerlink" title="✅应用场景："></a>✅应用场景：</h4><ul>
<li>秒杀接口、登录接口、验证码接口等敏感接口的访问频控。</li>
</ul>
<hr>
<h3 id="2-F5-x2F-LVS-硬件负载均衡"><a href="#2-F5-x2F-LVS-硬件负载均衡" class="headerlink" title="2. F5 &#x2F; LVS 硬件负载均衡"></a>2. F5 &#x2F; LVS 硬件负载均衡</h3><h4 id="✨作用："><a href="#✨作用：" class="headerlink" title="✨作用："></a>✨作用：</h4><ul>
<li>F5&#x2F;LVS 作为物理网络设备层面的高性能负载均衡系统，位于企业最外层（防火墙之后，Nginx之前），进行<strong>四层(TCP&#x2F;UDP)转发</strong>，性能远高于 Nginx。</li>
</ul>
<h4 id="✅典型架构："><a href="#✅典型架构：" class="headerlink" title="✅典型架构："></a>✅典型架构：</h4><pre><code>markdown复制编辑             用户请求
                 ↓
       ┌────────────────┐
       │  F5 / LVS  (L4)│
       └────────────────┘
                 ↓
       ┌────────────────┐
       │   Nginx (L7)    │
       └────────────────┘
                 ↓
            应用服务层
</code></pre>
<h4 id="✅优势："><a href="#✅优势：" class="headerlink" title="✅优势："></a>✅优势：</h4><ul>
<li>性能高、吞吐量大（每秒几十万 QPS）。</li>
<li>更稳定，更适合企业级大并发业务。</li>
<li>通常和 Nginx 搭配使用，分别处理 L4 &#x2F; L7 流量调度。</li>
</ul>
<hr>
<h2 id="✅-二、网关-amp-Nginx-黑名单拦截（IP-x2F-UA）"><a href="#✅-二、网关-amp-Nginx-黑名单拦截（IP-x2F-UA）" class="headerlink" title="✅ 二、网关 &amp; Nginx 黑名单拦截（IP&#x2F;UA）"></a>✅ 二、网关 &amp; Nginx 黑名单拦截（IP&#x2F;UA）</h2><h3 id="✅-目标："><a href="#✅-目标：" class="headerlink" title="✅ 目标："></a>✅ 目标：</h3><p>防止恶意攻击、秒杀脚本、爬虫工具参与秒杀。</p>
<h3 id="1-拦截策略"><a href="#1-拦截策略" class="headerlink" title="1. 拦截策略"></a>1. 拦截策略</h3><ul>
<li><strong>IP 黑白名单</strong>：将恶意访问源加入黑名单。</li>
<li><strong>UA 校验</strong>：不允许 curl、httpclient、python 等工具模拟请求。</li>
<li><strong>访问频率统计</strong>：单位时间内访问频率超过阈值即封禁。</li>
</ul>
<h3 id="2-网关层实现（如-SpringCloud-Gateway）"><a href="#2-网关层实现（如-SpringCloud-Gateway）" class="headerlink" title="2. 网关层实现（如 SpringCloud Gateway）"></a>2. 网关层实现（如 SpringCloud Gateway）</h3><pre><code class="java">// 伪代码：过滤器中处理
if (blackList.contains(ip) || suspiciousUA(ua)) &#123;
    return 403 Forbidden;
&#125;
</code></pre>
<hr>
<h2 id="✅-三、生成秒杀Token（防黄牛、刷请求）"><a href="#✅-三、生成秒杀Token（防黄牛、刷请求）" class="headerlink" title="✅ 三、生成秒杀Token（防黄牛、刷请求）"></a>✅ 三、生成秒杀Token（防黄牛、刷请求）</h2><h3 id="✅-核心思想："><a href="#✅-核心思想：" class="headerlink" title="✅ 核心思想："></a>✅ 核心思想：</h3><p><strong>用户先请求一个随机 Token，再带着这个 Token 才能参与秒杀，且只能用一次</strong>。</p>
<h3 id="✅-实现流程："><a href="#✅-实现流程：" class="headerlink" title="✅ 实现流程："></a>✅ 实现流程：</h3><h4 id="🔁-第一步：获取秒杀Token"><a href="#🔁-第一步：获取秒杀Token" class="headerlink" title="🔁 第一步：获取秒杀Token"></a>🔁 第一步：获取秒杀Token</h4><pre><code class="javascript">GET /seckill/token?productId=123
Header: Authorization: Bearer 用户登录Token
</code></pre>
<p>返回：</p>
<pre><code class="java">&#123; &quot;token&quot;: &quot;a8729f03-6a22-4cdb-8ad4-e19932cf&quot; &#125;
</code></pre>
<blockquote>
<p>Redis 存储 token → <code>seckill:token:uid:productId -&gt; token</code></p>
</blockquote>
<h4 id="🏃-第二步：用户秒杀请求带上Token"><a href="#🏃-第二步：用户秒杀请求带上Token" class="headerlink" title="🏃 第二步：用户秒杀请求带上Token"></a>🏃 第二步：用户秒杀请求带上Token</h4><pre><code class="java">POST /seckill/submit
Body: &#123; productId: 123, token: &quot;a8729f03-6a22-4cdb-8ad4-e19932cf&quot; &#125;
</code></pre>
<h4 id="✅-服务端校验："><a href="#✅-服务端校验：" class="headerlink" title="✅ 服务端校验："></a>✅ 服务端校验：</h4><ul>
<li>token是否存在；</li>
<li>token是否属于当前用户；</li>
<li>校验通过后删除 token（一次性）；</li>
<li>进入库存扣减逻辑。</li>
</ul>
<hr>
<h2 id="✅-四、灰度发布-金丝雀策略（保障系统稳定性）"><a href="#✅-四、灰度发布-金丝雀策略（保障系统稳定性）" class="headerlink" title="✅ 四、灰度发布 + 金丝雀策略（保障系统稳定性）"></a>✅ 四、灰度发布 + 金丝雀策略（保障系统稳定性）</h2><h3 id="✅-区别："><a href="#✅-区别：" class="headerlink" title="✅ 区别："></a>✅ 区别：</h3><table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>灰度发布</td>
<td>指在小范围（如某些用户&#x2F;机器）上逐步发布新功能</td>
</tr>
<tr>
<td>金丝雀发布</td>
<td>类似灰度，但更强调监控与回滚能力</td>
</tr>
</tbody></table>
<hr>
<h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><h4 id="1-灰度规则："><a href="#1-灰度规则：" class="headerlink" title="1. 灰度规则："></a>1. 灰度规则：</h4><ul>
<li>仅对北京地区、特定用户ID段、Android设备开放新功能；</li>
<li>灰度用户看到的是新接口，其他人访问旧接口。</li>
</ul>
<h4 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2. 实现方式："></a>2. 实现方式：</h4><ul>
<li>在网关中增加灰度判断逻辑，如基于用户ID、设备类型、地理位置等维度；</li>
<li>配合 Nacos &#x2F; Apollo 实现灰度配置动态下发。</li>
</ul>
<pre><code class="java">if (grayUser(userId)) &#123;
    routeTo(newServiceV2);
&#125; else &#123;
    routeTo(oldServiceV1);
&#125;
</code></pre>
<h4 id="3-金丝雀监控："><a href="#3-金丝雀监控：" class="headerlink" title="3. 金丝雀监控："></a>3. 金丝雀监控：</h4><ul>
<li>接入 Prometheus + Grafana；</li>
<li>实时监控新版本的接口成功率、响应时间、异常率；</li>
<li>若指标异常，立即自动或手动回滚。</li>
</ul>
<hr>
<h2 id="🧠-总结：秒杀防护层层递进"><a href="#🧠-总结：秒杀防护层层递进" class="headerlink" title="🧠 总结：秒杀防护层层递进"></a>🧠 总结：秒杀防护层层递进</h2><table>
<thead>
<tr>
<th>层级</th>
<th>技术 &#x2F; 策略</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>网络层</td>
<td>F5&#x2F;LVS、Nginx限流</td>
<td>硬抗高并发</td>
</tr>
<tr>
<td>网关层</td>
<td>黑名单拦截、UA过滤、灰度&#x2F;金丝雀</td>
<td>防刷 + 风控</td>
</tr>
<tr>
<td>应用层</td>
<td>秒杀Token、验证码、人机校验</td>
<td>精准控制用户行为</td>
</tr>
<tr>
<td>缓存层</td>
<td>Redis库存控制、Lua原子操作、布隆过滤器</td>
<td>高性能、数据一致</td>
</tr>
<tr>
<td>后端层</td>
<td>MQ异步削峰、数据库分库分表</td>
<td>解耦 + 弹性架构</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>订单超时自动取消是怎么实现的？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/743d8b7cd78b5a1fe4023554fee8d62726435cb2/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88.png"></p>
<h5 id="①-JDK自带的延时队列"><a href="#①-JDK自带的延时队列" class="headerlink" title="① JDK自带的延时队列"></a>① JDK自带的延时队列</h5><p><strong>优点</strong>：简单，不需要借助其他第三方组件，成本低。<br><strong>缺点</strong>：所有超时处理订单都要加入到<code>DelayQueue</code>中，占用内存大，没办法做到分布式处理，之恶能在集群中挑选一台leader专门处理，效率低<br>不适合订单量比较大的</p>
<h5 id="②-基于RocketMQ的定时消息-—-延时消息"><a href="#②-基于RocketMQ的定时消息-—-延时消息" class="headerlink" title="② 基于RocketMQ的定时消息 — 延时消息"></a>② 基于RocketMQ的定时消息 — 延时消息</h5><p><strong>优点</strong>：使用简单，和使用普通消息一样，支持分布式。精度高，支持任意时刻</p>
<p><strong>缺点</strong>：<strong>使用限制</strong>：定时时长最大值24小时。<br><strong>成本高</strong>：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。<br>同一个时刻大量消息会导致<u>消息延迟:</u>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>
<h5 id="③-基于Redis的过期监听"><a href="#③-基于Redis的过期监听" class="headerlink" title="③ 基于Redis的过期监听"></a>③ 基于Redis的过期监听</h5><p>设置过期时间：24小时内没有支付就会自动取消<br><strong>缺点</strong>：(也是所有中间件的缺点)</p>
<ul>
<li>不可靠 Redis在过期通知的时候，如果应用<strong>正好重启了</strong>，那么就有可能<strong>通知事件就丢了，会导致订单一直无法关闭</strong>，有稳定性问题。如果一定要使用Redis过期监听方案，建议再通过定时任务做补偿机制。</li>
<li>如果订单量大需要占用中间件大量的存储空间，需要额外维护成本。</li>
</ul>
<h5 id="④-定时任务分布式处理【要按照成本思维的思考方式】"><a href="#④-定时任务分布式处理【要按照成本思维的思考方式】" class="headerlink" title="④ 定时任务分布式处理【要按照成本思维的思考方式】"></a>④ 定时任务分布式处理【要按照成本思维的思考方式】</h5><p>通过定时任务(任务调度)的批量处理 → 一次性把所有超时的订单全部捞出来 处理完再全部执行更新<br>如果使用中间件都要单独存储那些数据，如果存储压力大就要涉及到集群</p>
<blockquote>
<p>如果对于超时精度比较高，超时时间在24小时内，且不会有峰值压力的场景下，推荐使用RocketMQ的定时消息解决方案<br>在电商业务下，许多订单超时场景都在24小时以上，对于超时精度没那么敏感，并且有海量订单需要批处理，推荐使用基于定时任务的<strong>跑批</strong>解决方案。</p>
</blockquote>
<blockquote>
<h2 id="✅-最佳实践对比表"><a href="#✅-最佳实践对比表" class="headerlink" title="✅ 最佳实践对比表"></a>✅ 最佳实践对比表</h2><table>
<thead>
<tr>
<th>方案</th>
<th>分布式支持</th>
<th>精度</th>
<th>可靠性</th>
<th>适用场景</th>
<th>优缺点总结</th>
</tr>
</thead>
<tbody><tr>
<td>DelayQueue</td>
<td>❌ 否</td>
<td>秒级</td>
<td>❌ 低</td>
<td>单体项目&#x2F;小订单量</td>
<td>简单、无需中间件，但不支持分布式和高可用</td>
</tr>
<tr>
<td>RocketMQ延时消息</td>
<td>✅ 是</td>
<td>秒级</td>
<td>✅ 高</td>
<td>秒杀、限时抢购、延迟关闭等</td>
<td>精度高、支持分布式，但时长限制 &amp; 消息堆积</td>
</tr>
<tr>
<td>Redis过期监听</td>
<td>✅ 是</td>
<td>秒级</td>
<td>❌ 较低</td>
<td>轻量业务、有兜底机制的场景</td>
<td>实时、方便，但事件容易丢失，不适合重要任务</td>
</tr>
<tr>
<td>定时任务跑批</td>
<td>✅ 是</td>
<td>分钟级</td>
<td>✅ 高</td>
<td>电商订单系统、大量订单处理</td>
<td>稳定、灵活、适合大业务，容忍分钟级延迟</td>
</tr>
</tbody></table>
<h2 id="🔄-常见混合策略推荐"><a href="#🔄-常见混合策略推荐" class="headerlink" title="🔄 常见混合策略推荐"></a>🔄 常见混合策略推荐</h2><ul>
<li><strong>秒杀业务 &#x2F; 限时订单</strong>：RocketMQ 延时消息为主 + 补偿机制（定时任务兜底）</li>
<li><strong>电商平台</strong>：定时任务跑批为主 + MQ 异步通知用户（取消成功推送）</li>
<li><strong>轻量小应用</strong>：Redis 过期监听 + 手动补偿兜底</li>
<li><strong>单体项目或demo</strong>：DelayQueue 简单可用</li>
</ul>
<h2 id="🧠-思考：为什么不用-cron-来做？"><a href="#🧠-思考：为什么不用-cron-来做？" class="headerlink" title="🧠 思考：为什么不用 cron 来做？"></a>🧠 思考：为什么不用 cron 来做？</h2><blockquote>
<p>cron 固定执行时间点，而订单创建是动态的，<strong>无法精确知道每个订单的30分钟是哪一刻。</strong></p>
</blockquote>
<p>举例：</p>
<ul>
<li>cron表达式只能写 <code>每隔5分钟扫描</code> 或 <code>每天0点执行</code></li>
<li>订单创建时间是不确定的 → <strong>用cron不能实时取消30分钟后的每个订单</strong></li>
</ul>
<p>所以，动态调度任务（MQ&#x2F;DelayQueue）或带参数处理（定时扫描数据库）更合适。</p>
</blockquote>
<p><span style = "color:red"><strong>如何防止重复下单？</strong></span></p>
<h5 id="方案一：提交订单按钮置灰-防止用户无意点击多次"><a href="#方案一：提交订单按钮置灰-防止用户无意点击多次" class="headerlink" title="方案一：提交订单按钮置灰 [防止用户无意点击多次]"></a>方案一：提交订单按钮置灰 [防止用户无意点击多次]</h5><h5 id="方案二：后端采用redis的setnx-来保证它的唯一幂等性"><a href="#方案二：后端采用redis的setnx-来保证它的唯一幂等性" class="headerlink" title="方案二：后端采用redis的setnx 来保证它的唯一幂等性"></a>方案二：后端采用redis的<span style = "color:red">setnx</span> 来保证它的唯一幂等性</h5><p>setnx：当我们调用setnx来去保存一个key和value的时候，如果这个value没有值的话，那么就会返回<strong>true</strong>保存成功；如果有值就会返回<strong>false</strong> → 保证多次存储只能存储一个值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be8debbe9711d790569ea62e3954dca9e6f2937b/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95.png"></p>
<blockquote>
<h4 id="业务幂等号（如唯一Token机制）"><a href="#业务幂等号（如唯一Token机制）" class="headerlink" title="业务幂等号（如唯一Token机制）"></a>业务幂等号（如唯一Token机制）</h4><ul>
<li>用户点击下单前，后端下发一个<code>token</code>（存 Redis），用户下单时带上这个 token。</li>
<li>后端验证 token 是否存在，使用后即删除。</li>
</ul>
<pre><code class="java">// 伪代码
if (redisToken == null || !redisToken.equals(requestToken)) &#123;
    throw new RuntimeException(&quot;重复请求或非法请求&quot;);
&#125;
redisTemplate.delete(redisToken);
</code></pre>
<blockquote>
<p>✅ 优点：</p>
<ul>
<li>通用幂等机制，不局限订单；</li>
<li>可防止表单重复提交、支付回调重复通知等场景；</li>
</ul>
<p>✅ 使用场景：</p>
<ul>
<li>秒杀下单、提交表单、支付回调。</li>
</ul>
</blockquote>
<hr>
<h4 id="🔐-方案四：消息队列去重（异步场景）"><a href="#🔐-方案四：消息队列去重（异步场景）" class="headerlink" title="🔐 方案四：消息队列去重（异步场景）"></a>🔐 方案四：消息队列去重（异步场景）</h4><ul>
<li>使用 RocketMQ 的幂等机制，确保同一消息只消费一次（消费端做去重处理），适用于下单流程是异步的情况。</li>
</ul>
<hr>
<h3 id="✅-三、多手段组合更安全"><a href="#✅-三、多手段组合更安全" class="headerlink" title="✅ 三、多手段组合更安全"></a>✅ <strong>三、多手段组合更安全</strong></h3><table>
<thead>
<tr>
<th>层级</th>
<th>技术手段</th>
<th>是否强制</th>
</tr>
</thead>
<tbody><tr>
<td>前端</td>
<td>按钮置灰&#x2F;节流</td>
<td>否</td>
</tr>
<tr>
<td>应用层</td>
<td>Redis + setnx 或 Token</td>
<td>是</td>
</tr>
<tr>
<td>数据层</td>
<td>唯一约束字段</td>
<td>是</td>
</tr>
<tr>
<td>异步处理</td>
<td>MQ消费幂等处理</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="📌-典型实践示意图："><a href="#📌-典型实践示意图：" class="headerlink" title="📌 典型实践示意图："></a>📌 典型实践示意图：</h3><ul>
<li><strong>用户点击下单</strong> ➜ <strong>获取唯一Token&#x2F;Redis锁</strong> ➜ <strong>请求成功后释放</strong> ➜ <strong>写入订单表时校验唯一性</strong>。</li>
</ul>
<hr>
<h3 id="💡-小贴士："><a href="#💡-小贴士：" class="headerlink" title="💡 小贴士："></a>💡 小贴士：</h3><ul>
<li>并发高推荐：<strong>Redis方案（+Redisson分布式锁）</strong></li>
<li>最后兜底：<strong>数据库唯一索引</strong></li>
<li>支付类、接口幂等推荐：<strong>Token机制</strong></li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>怎么防止刷单？【人肉机刷单！！】</strong></span></p>
<h5 id="业务风控"><a href="#业务风控" class="headerlink" title="业务风控"></a>业务风控</h5><p>提高羊毛门槛：实名认证、消费门槛、随机优惠<br>限制用户参与、中奖、奖励次数<br>根据用户的历史行为和忠诚度，提供不同层次的优惠，优待忠实用户<br>奖池(优惠券数量)限制上限</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3850683ae318970983834aa03ac35168bbf52a8/%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E4%BA%BA%E8%82%89%E5%88%B7%E5%8D%95%EF%BC%9F.png"></p>
<p><span style="color:red"><strong>分布式集群架构下怎么保证并发安全？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/48788978d525bf16e52bb10180e63022de6a5ea3/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8.png"></p>
<blockquote>
<h3 id="✅-一、为什么分布式架构下更容易出现并发问题？"><a href="#✅-一、为什么分布式架构下更容易出现并发问题？" class="headerlink" title="✅ 一、为什么分布式架构下更容易出现并发问题？"></a>✅ 一、为什么分布式架构下更容易出现并发问题？</h3><p>在单体应用中，所有请求在同一个进程内处理，天然可以用<code>synchronized</code>等方式控制并发。</p>
<p>而在<strong>分布式集群架构</strong>中：</p>
<ul>
<li>请求会打到多个节点 → 本地锁失效</li>
<li>数据可能分库分表 → 数据不在一个数据库</li>
<li>多线程 + 多机器 + 多服务 → 并发成倍放大</li>
</ul>
<p>所以需要一整套<strong>分布式并发安全</strong>解决方案。</p>
<h3 id="✅-二、并发安全常见场景"><a href="#✅-二、并发安全常见场景" class="headerlink" title="✅ 二、并发安全常见场景"></a>✅ 二、并发安全常见场景</h3><ul>
<li>秒杀&#x2F;抢购：多个用户同时抢一件商品</li>
<li>下单：防止重复下单、超卖</li>
<li>支付：防止重复支付</li>
<li>分布式调度：防止定时任务重复执行</li>
<li>分布式ID生成：避免重复ID</li>
</ul>
<h3 id="✅-三、总结：解决并发的“组合拳”"><a href="#✅-三、总结：解决并发的“组合拳”" class="headerlink" title="✅ 三、总结：解决并发的“组合拳”"></a>✅ 三、总结：解决并发的“组合拳”</h3><table>
<thead>
<tr>
<th>组件&#x2F;策略</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>Redis分布式锁</td>
<td>跨节点并发控制，控制共享资源</td>
</tr>
<tr>
<td>乐观锁（version）</td>
<td>控制数据库并发更新冲突</td>
</tr>
<tr>
<td>消息队列MQ</td>
<td>异步削峰，提高系统吞吐</td>
</tr>
<tr>
<td>唯一Token机制</td>
<td>防止重复提交</td>
</tr>
<tr>
<td>限流 &amp; 黑名单机制</td>
<td>拦截恶意请求，保护系统</td>
</tr>
<tr>
<td>本地+分布式缓存</td>
<td>缓解数据库压力，提高响应速度</td>
</tr>
<tr>
<td>灰度发布</td>
<td>降低风险，平稳上线</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>让你设计一个扫码登录怎么实现？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3bbc19e0da554166000933c31bf749e2f6d3313/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>
<h6 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h6><p>请求登录页生成二维码，PC端请求后端生成一个二维码，此时在后端就会生成一个全局唯一的二维码ID，主要保存二维码的状态[二维码ID, NEW]，状态设置到Redis设置过期时间，然后把当前的二维码ID返回给前端，然后生成二维码 【前后端都可以生成 → 返回Base64的编码给前端】此时的二维码就绑定了用户的ID让用户扫描。</p>
<h6 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h6><p>PC端和后端会建立一个轮询的请求，不断的根据二维码ID去查询二维码状态，一旦状态改变页面也会改变。也可以通过长连接<strong>WebSocket</strong>获取状态 <code>淘宝用的轮询、抖音用的长连接</code>，此时就可以扫码。<br>扫码前保证手机是登录状态 没有登录肯定是不能扫码的，登录后进行扫码就会携带手机端的用户token以及二维码的ID在后端去校验请求Token，如果校验成功就代表手机可以登录，此时可以变更二维码状态为扫描。前端就可以根据这个把页面变为<code>待确认</code>状态</p>
<blockquote>
<h2 id="✅-一、整体流程概述"><a href="#✅-一、整体流程概述" class="headerlink" title="✅ 一、整体流程概述"></a>✅ 一、整体流程概述</h2><p><strong>目标：</strong> 用户在 PC 端扫码并登录系统，安全、高效、用户体验好。</p>
<p><strong>参与者：</strong></p>
<ul>
<li>PC 浏览器（Web）</li>
<li>手机 App（用户已登录）</li>
<li>后端服务（Web + API）</li>
<li>Redis（状态存储）</li>
<li>前端轮询&#x2F;长连接</li>
</ul>
<hr>
<h2 id="🧩-二、关键技术点拆解"><a href="#🧩-二、关键技术点拆解" class="headerlink" title="🧩 二、关键技术点拆解"></a>🧩 二、关键技术点拆解</h2><h3 id="1️⃣-二维码生成（PC端发起）"><a href="#1️⃣-二维码生成（PC端发起）" class="headerlink" title="1️⃣ 二维码生成（PC端发起）"></a>1️⃣ 二维码生成（PC端发起）</h3><ul>
<li>用户打开 PC 登录页面，请求后端接口 <code>/api/qr/generate</code></li>
<li>后端逻辑：<ul>
<li>生成唯一的二维码ID（一般用 UUID、Snowflake 或 Redis Incr）</li>
<li>创建二维码状态：<code>[qrCodeId: &#123;status: NEW, userId: null&#125;]</code> 存入 Redis，设置过期时间（如：3分钟）</li>
<li>把 <code>qrCodeId</code> 返回给前端（前端将其转成二维码图像）</li>
</ul>
</li>
</ul>
<p><strong>二维码状态定义：</strong></p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>二维码已生成，待扫码</td>
</tr>
<tr>
<td>SCANNED</td>
<td>手机已扫码，待确认</td>
</tr>
<tr>
<td>CONFIRMED</td>
<td>用户已确认登录</td>
</tr>
<tr>
<td>EXPIRED</td>
<td>二维码过期</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-轮询-or-WebSocket-监听状态（PC端）"><a href="#2️⃣-轮询-or-WebSocket-监听状态（PC端）" class="headerlink" title="2️⃣ 轮询 or WebSocket 监听状态（PC端）"></a>2️⃣ 轮询 or WebSocket 监听状态（PC端）</h3><ul>
<li>前端定时调用 <code>/api/qr/status?qrCodeId=xxx</code> 或使用 WebSocket 长连接订阅状态变更。</li>
<li>后端通过 Redis 获取二维码状态，响应当前状态值给前端；</li>
<li>前端根据状态更新 UI：<ul>
<li><code>NEW</code>：显示二维码提示扫码</li>
<li><code>SCANNED</code>：显示“请确认登录”</li>
<li><code>CONFIRMED</code>：跳转系统首页</li>
<li><code>EXPIRED</code>：提示“二维码已失效”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣-手机扫码（App-端发起）"><a href="#3️⃣-手机扫码（App-端发起）" class="headerlink" title="3️⃣ 手机扫码（App 端发起）"></a>3️⃣ 手机扫码（App 端发起）</h3><ul>
<li>用户打开手机 App，扫码得到 <code>qrCodeId</code></li>
<li>App 发起请求 <code>/api/qr/scan</code>，携带：<ul>
<li><code>qrCodeId</code></li>
<li>当前用户登录 Token（说明谁在扫码）</li>
</ul>
</li>
<li>后端校验 Token 合法性 + 校验二维码状态是否是 <code>NEW</code></li>
<li>如果校验通过：<ul>
<li>更新 Redis 状态为 <code>SCANNED</code></li>
<li>保存扫码用户ID（用于确认登录）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4️⃣-手机端确认登录（App-端）"><a href="#4️⃣-手机端确认登录（App-端）" class="headerlink" title="4️⃣ 手机端确认登录（App 端）"></a>4️⃣ 手机端确认登录（App 端）</h3><ul>
<li>用户点击“确认登录”按钮，App 发起请求 <code>/api/qr/confirm</code></li>
<li>后端再次校验 Token、状态、qrCodeId</li>
<li>如果合法：<ul>
<li>更新 Redis 状态为 <code>CONFIRMED</code></li>
<li>后端为 PC 端生成登录凭证（JWT 或 Session ID）</li>
<li>可以将 token 写入 Redis，让 PC 端后续使用</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5️⃣-PC端轮询到-CONFIRMED-状态后"><a href="#5️⃣-PC端轮询到-CONFIRMED-状态后" class="headerlink" title="5️⃣ PC端轮询到 CONFIRMED 状态后"></a>5️⃣ PC端轮询到 CONFIRMED 状态后</h3><ul>
<li>前端收到 CONFIRMED 状态</li>
<li>发起请求 <code>/api/qr/login?qrCodeId=xxx</code></li>
<li>后端从 Redis 中取出对应用户信息</li>
<li>为 PC 创建 Session 或返回 JWT Token</li>
<li>登录成功，跳转首页</li>
</ul>
<h2 id="🔐-三、安全要点"><a href="#🔐-三、安全要点" class="headerlink" title="🔐 三、安全要点"></a>🔐 三、安全要点</h2><ul>
<li>二维码应设置过期时间，防止被反复使用</li>
<li>Token 校验要严谨，确保扫码者是本人</li>
<li>Redis 里状态更新使用 Lua 脚本或事务 CAS 保证一致性</li>
<li>后端二维码状态需加密传输或限制频繁请求（防刷）</li>
</ul>
<h2 id="🚀-四、技术选型小结"><a href="#🚀-四、技术选型小结" class="headerlink" title="🚀 四、技术选型小结"></a>🚀 四、技术选型小结</h2><table>
<thead>
<tr>
<th>功能</th>
<th>技术</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>二维码生成</td>
<td>UUID + Redis</td>
<td>可快速唯一生成并记录状态</td>
</tr>
<tr>
<td>状态存储</td>
<td>Redis（带 TTL）</td>
<td>快速响应，高并发，易过期处理</td>
</tr>
<tr>
<td>实时通知</td>
<td>轮询 &#x2F; WebSocket</td>
<td>淘宝用轮询、抖音用 WS</td>
</tr>
<tr>
<td>登录授权</td>
<td>JWT &#x2F; Session</td>
<td>生成 PC 端登录凭证</td>
</tr>
<tr>
<td>防刷限流</td>
<td>接口限流 + 签名校验</td>
<td>避免恶意轮询&#x2F;伪造请求</td>
</tr>
</tbody></table>
<h2 id="✅-五、流程图（配合讲解）"><a href="#✅-五、流程图（配合讲解）" class="headerlink" title="✅ 五、流程图（配合讲解）"></a>✅ 五、流程图（配合讲解）</h2><pre><code>text复制编辑[PC端]        [后端]                   [App端]
  |                      |                         |
  |--&gt; 请求生成二维码 --&gt;|                         |
  |                      |-- 生成qrCodeId + Redis存储
  |&lt;-- 返回二维码Base64--|                         |
  |                      |                         |
  |==轮询/WS监听状态====&gt;|                         |
  |                      |                         |
  |                      |&lt;--扫码携带Token + qrCodeId
  |                      |--校验后标记为SCANNED     |
  |&lt;==收到SCANNED状态== |                         |
  |                      |&lt;--确认登录               |
  |                      |--更新为CONFIRMED +登录信息
  |&lt;==收到CONFIRMED==   |                         |
  |-- 请求登录状态凭证 --&gt;|                         |
  |&lt;-- 返回JWT/Session--|                         |
</code></pre>
<hr>
</blockquote>
<p><span style = "color:red"><strong>如何设计分布式日志存储架构？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/38bcadd4a99fd1093a4d7ab6e39c60340bfc73a8/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png"></p>
<p><span style = "color:red"><strong>使用redis出现缓存三兄弟如何解决？</strong></span><del>减轻数据库的压力</del></p>
<p><span style = "color:blue"><strong>你在项目中用到了Redis对吧 介绍一下有没有遇到关于redis的什么问题？</strong></span></p>
<p>暂时还没看！<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV176KpeiEXF?spm_id_from=333.788.videopod.episodes&vd_source=a4d980c3208d51858f08b3025a6ab2d9&p=12">12.使用redis出现缓存击穿雪崩穿透怎么解决_哔哩哔哩_bilibili</a></p>
<p><span style = "color:red"><strong>如何使用Redis记录用户连续登录了多少天？</strong></span><del>放在数据库里不合适</del></p>
<p>放在数据库不合适因为你要创建一个表 记录用户哪一天进行了签到 如果用户量很多就会很大的量</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9db550cabe345faff24a1fccba0d9d0f5e59faf9/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%E4%BA%86%E5%A4%9A%E5%B0%91%E5%A4%A9.png"></p>
<blockquote>
<p>这个问题其实就是一个<strong>连续签到&#x2F;登录统计</strong>问题，数据库不适合是因为：</p>
<ul>
<li>每签到一天就插一行 → 数据量巨大，I&#x2F;O压力大。</li>
<li>查询连续签到天数复杂，SQL不好写，效率低。</li>
</ul>
<p>所以使用 Redis 的 <strong>位图（bitmap）</strong> 来解决，是一种<strong>低存储+高性能</strong>的方案。</p>
<hr>
<h3 id="🎯-场景目标"><a href="#🎯-场景目标" class="headerlink" title="🎯 场景目标"></a>🎯 场景目标</h3><p>统计用户<strong>连续登录天数</strong>、<strong>本月第几天登录过</strong>，实现类似：</p>
<pre><code>复制编辑用户A 7月签到状态 = 01111100010001000（1表示登录，0表示没登录）
查询当前用户是否今天登录过？
查询用户本月连续登录天数？
</code></pre>
<hr>
<h3 id="🧠-技术选型：使用-Redis-Bitmap"><a href="#🧠-技术选型：使用-Redis-Bitmap" class="headerlink" title="🧠 技术选型：使用 Redis Bitmap"></a>🧠 技术选型：使用 Redis Bitmap</h3><h4 id="什么是-Bitmap？"><a href="#什么是-Bitmap？" class="headerlink" title="什么是 Bitmap？"></a>什么是 Bitmap？</h4><p>Redis 的 Bitmap 本质上是字符串（<code>String</code> 类型），但你可以对它的每一位 bit 操作：</p>
<pre><code class="java"># 设置偏移量为 5 的位置为 1（签到）
SETBIT user:sign:1001:202507 5 1

# 查询偏移量为 5 的位置是否为 1（是否登录）
GETBIT user:sign:1001:202507 5
</code></pre>
<hr>
<h3 id="✅-实现思路"><a href="#✅-实现思路" class="headerlink" title="✅ 实现思路"></a>✅ 实现思路</h3><h4 id="1-登录-x2F-签到时"><a href="#1-登录-x2F-签到时" class="headerlink" title="1. 登录&#x2F;签到时"></a>1. 登录&#x2F;签到时</h4><pre><code class="java">int offset = today - 1; // 7月19日 → offset = 18，从0开始
String key = &quot;user:sign:&quot; + userId + &quot;:&quot; + yyyyMM;
redisTemplate.opsForValue().setBit(key, offset, true);
</code></pre>
<h4 id="2-查询某天是否登录"><a href="#2-查询某天是否登录" class="headerlink" title="2. 查询某天是否登录"></a>2. 查询某天是否登录</h4><pre><code class="javascript">Boolean isLogin = redisTemplate.opsForValue().getBit(key, offset);
</code></pre>
<h4 id="3-查询本月累计登录多少天"><a href="#3-查询本月累计登录多少天" class="headerlink" title="3. 查询本月累计登录多少天"></a>3. 查询本月累计登录多少天</h4><pre><code class="java">BitCountOptions options = BitCountOptions.defaults();
Long total = redisTemplate.execute((RedisCallback&lt;Long&gt;) conn -&gt; 
    conn.bitCount(key.getBytes(), options)
);
</code></pre>
<h4 id="4-查询连续登录天数（重点）"><a href="#4-查询连续登录天数（重点）" class="headerlink" title="4. 查询连续登录天数（重点）"></a>4. 查询连续登录天数（重点）</h4><p>假设今天是第19天，从 offset &#x3D; 18 开始向前看：</p>
<pre><code class="java">int count = 0;
for (int i = offset; i &gt;= 0; i--) &#123;
    if (redisTemplate.opsForValue().getBit(key, i)) &#123;
        count++;
    &#125; else &#123;
        break; // 一旦中断，退出循环
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="🚀-优势"><a href="#🚀-优势" class="headerlink" title="🚀 优势"></a>🚀 优势</h3><ul>
<li>Redis Bitmap 单月只占用 31 bit，超省空间（一个用户一年只用 372 bit ≈ 47 字节）</li>
<li>查询效率高，O(1)</li>
<li>写入也快，支持并发</li>
</ul>
<hr>
<h3 id="🔐-注意点"><a href="#🔐-注意点" class="headerlink" title="🔐 注意点"></a>🔐 注意点</h3><ul>
<li><p><strong>设置过期时间</strong>：避免内存占用过大</p>
<pre><code class="java">redisTemplate.expire(key, Duration.ofDays(60));
</code></pre>
</li>
<li><p>如果需要“补签”功能，操作相应的 bit 位即可</p>
</li>
</ul>
<h3 id="📌-示例-Redis-数据结构（7月）"><a href="#📌-示例-Redis-数据结构（7月）" class="headerlink" title="📌 示例 Redis 数据结构（7月）"></a>📌 示例 Redis 数据结构（7月）</h3><pre><code class="java">Key: user:sign:1001:202507

Value (bit位)：0111110000000000000000000000000
日期：1 2 3 4 5 6 7 ... 31
含义：从左往右，第i位是第i+1天
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>给你一亿个Redis keys统计双方的共同好友？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a917027faf313dfaee955c52361c8f711309fb43/%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BA%BF%E4%B8%AARedis%20keys%E7%BB%9F%E8%AE%A1%E5%8F%8C%E6%96%B9%E7%9A%84%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B.png"></p>
<blockquote>
<h2 id="🧩-题目解析"><a href="#🧩-题目解析" class="headerlink" title="🧩 题目解析"></a>🧩 题目解析</h2><p>假设：</p>
<ul>
<li>每个用户的好友列表存储在 Redis 的 Set 结构中，例如：<br> <code>SADD friends:user1 A B C D</code><br> <code>SADD friends:user2 B C E F</code></li>
</ul>
<p>目标：</p>
<ul>
<li>快速统计两个人共同的好友，即集合交集数量。</li>
</ul>
<hr>
<h2 id="✅-常规解法：Redis-SINTER-命令"><a href="#✅-常规解法：Redis-SINTER-命令" class="headerlink" title="✅ 常规解法：Redis SINTER 命令"></a>✅ 常规解法：Redis <code>SINTER</code> 命令</h2><p>Redis 支持对多个集合求交集：</p>
<pre><code class="java">SINTER friends:user1 friends:user2
</code></pre>
<p>返回结果即为双方的共同好友。</p>
<p>如果只要交集数量，可以使用：</p>
<pre><code class="java">SINTERCARD 2 friends:user1 friends:user2
</code></pre>
<p>这是 Redis 7.0 新增的命令，<strong>效率更高</strong>。</p>
<h2 id="🧠-问题难点：一亿个-keys-怎么办？"><a href="#🧠-问题难点：一亿个-keys-怎么办？" class="headerlink" title="🧠 问题难点：一亿个 keys 怎么办？"></a>🧠 问题难点：一亿个 keys 怎么办？</h2><p>一亿个 keys 说明用户量巨大或好友数量极多，可能涉及以下挑战：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Redis 内存压力</td>
<td>如果所有好友关系都存在 Redis Set 中，消耗大量内存</td>
</tr>
<tr>
<td>网络 IO 开销</td>
<td>获取或计算时大量命令交互</td>
</tr>
<tr>
<td>集合元素巨大</td>
<td>每个 Set 元素多（例如几千好友），单次 <code>SINTER</code> 代价大</td>
</tr>
<tr>
<td>频繁交集操作</td>
<td>如果这是一个高频功能（如社交推荐），需要高效方案</td>
</tr>
</tbody></table>
<h2 id="🧠-实战建议"><a href="#🧠-实战建议" class="headerlink" title="🧠 实战建议"></a>🧠 实战建议</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody><tr>
<td>精确共同好友、数量不大</td>
<td><code>SINTER</code> &#x2F; <code>SINTERCARD</code></td>
</tr>
<tr>
<td>只需估算交集数量</td>
<td><code>PFCOUNT</code>（HyperLogLog）</td>
</tr>
<tr>
<td>只需交集数量 + 数据量很大</td>
<td>Bitmap + <code>BITOP</code> + <code>BITCOUNT</code></td>
</tr>
<tr>
<td>数据量超大，追求压缩极致</td>
<td>Roaring Bitmap、Redis Module</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>如何做一亿用户实时积分排行榜？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2be2ea44cfd98cb3669dcc098f4790f2ad0780d1/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%BA%BF%E7%94%A8%E6%88%B7%E5%AE%9E%E6%97%B6%E7%A7%AF%E5%88%86%E6%8E%92%E8%A1%8C%E6%A6%9C.png"></p>
<blockquote>
<p>做“一亿用户实时积分排行榜”时，面临的挑战是：<strong>高并发写入、高频读、排序性能、排行榜分页、内存管理等</strong>。使用传统数据库难以胜任，我们通常结合 <strong>Redis 的 ZSet（有序集合）结构 + 分布式架构</strong> 来高效实现。</p>
<h4 id="💡-核心思路"><a href="#💡-核心思路" class="headerlink" title="💡 核心思路"></a>💡 核心思路</h4><ul>
<li>使用 Redis 的 <code>ZSet</code> 存储用户积分（ZSet天然支持有序集合）。</li>
<li>使用 <strong>用户ID为 member，积分为 score</strong>，自动排序。</li>
<li>按业务场景设置多个排行榜（<strong>总榜、日榜、周榜</strong>等）。</li>
<li>使用分片&#x2F;分区 + 多 Redis 实例缓解内存压力。</li>
</ul>
<h3 id="🚀-性能优化方案"><a href="#🚀-性能优化方案" class="headerlink" title="🚀 性能优化方案"></a>🚀 性能优化方案</h3><table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>高并发写入</td>
<td>异步批处理写入积分变化（Kafka &#x2F; MQ）</td>
</tr>
<tr>
<td>高并发读榜</td>
<td>热榜分页结果缓存（Redis 二级缓存）</td>
</tr>
<tr>
<td>大数据量</td>
<td>分片存储排行榜（按地域&#x2F;业务线）</td>
</tr>
<tr>
<td>数据持久化</td>
<td>后台定期将 ZSet 持久化至 MySQL（定时备份）</td>
</tr>
<tr>
<td>用户查自己排名</td>
<td>排名反查缓存 + 异步修正（定时刷新）</td>
</tr>
</tbody></table>
<h3 id="⚙️-分布式架构下的挑战与解决"><a href="#⚙️-分布式架构下的挑战与解决" class="headerlink" title="⚙️ 分布式架构下的挑战与解决"></a>⚙️ 分布式架构下的挑战与解决</h3><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>单机内存不足</td>
<td>Redis 分布式集群 + 按 key 做水平分区</td>
</tr>
<tr>
<td>网络波动</td>
<td>Redis 哨兵或主从架构容灾</td>
</tr>
<tr>
<td>跨机房</td>
<td>使用 Kafka MQ 异步同步数据</td>
</tr>
<tr>
<td>并发冲突</td>
<td>ZINCRBY 原子操作，确保并发安全</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>内存200M读取1G文件并统计内容重复次数？<del>内存受限时</del></strong></span></p>
<p>一次性读取肯定会OOM<br>可以根据缓冲区分块读取<br><img src="https://raw.githubusercontent.com/P-luminary/images/f791667943446b731b86a4123b2fc03c812dabf1/%E5%86%85%E5%AD%98200M%E8%AF%BB%E5%8F%961G%E6%96%87%E4%BB%B6%E5%B9%B6%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AE%B9%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0.png"></p>
<blockquote>
<h3 id="📌-方案核心：“分治-磁盘中间结果-再归并统计”"><a href="#📌-方案核心：“分治-磁盘中间结果-再归并统计”" class="headerlink" title="📌 方案核心：“分治 + 磁盘中间结果 + 再归并统计”"></a>📌 方案核心：<strong>“分治 + 磁盘中间结果 + 再归并统计”</strong></h3><hr>
<h3 id="📍第一步：分片预处理（Hash-分桶）"><a href="#📍第一步：分片预处理（Hash-分桶）" class="headerlink" title="📍第一步：分片预处理（Hash 分桶）"></a>📍第一步：分片预处理（Hash 分桶）</h3><ul>
<li><p>遍历文件，<strong>每条记录用 hash 函数映射到 N 个临时小文件中</strong>（如 100 个文件）。</p>
</li>
<li><p>例如：</p>
<pre><code>hash(line) % 100 -&gt; 选择第 i 个 bucket_i.txt 写入
</code></pre>
</li>
<li><p>每个桶的数据量 &lt;&lt; 1GB，<strong>避免某一个桶数据过大</strong>（可以动态调节桶数）。</p>
</li>
</ul>
<p>📝 <strong>实现要点</strong>：</p>
<ul>
<li>不能直接把 key 存在内存中，而是用 <code>BufferedWriter</code> 把行写入不同的中间文件。</li>
<li>临时文件名如 <code>bucket_0.txt</code>, <code>bucket_1.txt</code>, …, <code>bucket_99.txt</code>。</li>
</ul>
<hr>
<h3 id="📍第二步：小文件内统计（Map-阶段）"><a href="#📍第二步：小文件内统计（Map-阶段）" class="headerlink" title="📍第二步：小文件内统计（Map 阶段）"></a>📍第二步：小文件内统计（Map 阶段）</h3><ul>
<li><p>每个小文件都可以用内存加载（一般几十 MB），然后用 <code>Map&lt;String, Integer&gt;</code> 来做频次统计。</p>
</li>
<li><p>统计完毕后，<strong>结果写入新的临时文件</strong>，如：</p>
<pre><code>result_bucket_0.txt:
word1 -&gt; 5
word2 -&gt; 3
...
</code></pre>
</li>
</ul>
<hr>
<h3 id="📍第三步：归并所有桶（Reduce-阶段）"><a href="#📍第三步：归并所有桶（Reduce-阶段）" class="headerlink" title="📍第三步：归并所有桶（Reduce 阶段）"></a>📍第三步：归并所有桶（Reduce 阶段）</h3><ul>
<li>如果需要所有数据的总频率（跨桶汇总），则可以：<ul>
<li>对所有结果文件做归并统计（Map 合并）。</li>
<li>比如 <code>word1</code> 在 <code>result_bucket_0.txt</code> 是 5，<code>result_bucket_1.txt</code> 是 2，总共就是 7。</li>
<li>这一步可再次用 hashmap 缓存 + 写磁盘防止内存爆掉。</li>
</ul>
</li>
</ul>
<h2 id="📘-总结一句话"><a href="#📘-总结一句话" class="headerlink" title="📘 总结一句话"></a>📘 总结一句话</h2><p><strong>“把大象装进冰箱，需要分步来——分桶写临时文件 → 每桶局部统计 → 全局归并或提取 Top-N。”</strong></p>
</blockquote>
<p><span style = "color:red"><strong>查询200条数据耗时200ms，怎么在500ms内查询1000条数据？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/af425172c9777d99374c270ea1bb12daf6c9a886/%E6%9F%A5%E8%AF%A2200%E6%9D%A1%E6%95%B0%E6%8D%AE%E8%80%97%E6%97%B6200ms%EF%BC%8C%E6%80%8E%E4%B9%88%E5%9C%A8500ms%E5%86%85%E6%9F%A5%E8%AF%A21000%E6%9D%A1%E6%95%B0%E6%8D%AE.png"></p>
<p><span style = "color:red"><strong>SpringBoot如果有百万数据插入怎么优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/819db0a99867d7dea55c079cd88561676d73d2cd/SpringBoot%E5%A6%82%E6%9E%9C%E6%9C%89%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96.png"></p>
<p><span style = "color:red"><strong>SpringBoot可以同时处理多少请求？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3872a89aa8e4de272a70a38c33d71e854708610/SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E5%A4%9A%E5%B0%91%E8%AF%B7%E6%B1%82.png"></p>
<p><span style = "color:red"><strong>volatile的应用场景？</strong></span></p>
<p>为了保证我们并发编程的<strong>可见性</strong>和<strong>有序性</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7a43484ced62d5727e9d6636d98a72d5bc8e4306/volatile%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png"></p>
<p><span style = "color:red"><strong>SQL的执行流程</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d1cb7430ecba8b881cca73c71d320e672975fae1/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>单表最多数据量需要多大才涉及到分表？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c6f0c5d08eac3f278743c748ff2ce3fe0849bcf9/%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%9A%E6%95%B0%E6%8D%AE%E9%87%8F%E9%9C%80%E8%A6%81%E5%A4%9A%E5%A4%A7%E6%89%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E5%88%86%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>Mysql引擎层BufferPool工作过程原理？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a2eabbfa570efb5cce42f6fa8a3ea77cab621618/Mysql%E5%BC%95%E6%93%8E%E5%B1%82BufferPool%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>什么是聚集索引和非聚集索引？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0aece273ba1eea943a48d6ed472c7bab462058fe/%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png"></p>
<p><span style = "color:red"><strong>count(*)、count(1)、count(字段) 谁更快？有什么区别？</strong></span></p>
<h6 id="tb-user"><a href="#tb-user" class="headerlink" title="tb_user"></a>tb_user</h6><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>潘春尧</td>
</tr>
<tr>
<td>2</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>张三</td>
</tr>
</tbody></table>
<pre><code class="mysql">Ⅰ. SELECT count(*) FROM tb_user;                → 3
Ⅱ. SELECT count(1) FROM tb_user;                → 3
Ⅲ. SELECT count(name) FROM tb_user;             → 2
</code></pre>
<p><strong>在功能上没有区别</strong>       Ⅲ.<u>如果你统计的数据需要排除NULL 就可以用count(指定字段)</u><br><strong>在性能上没有任何区别</strong> 非要比较就是<code>count(1)</code>更胜一筹 因为不需要mysql在底层做任何的sql优化</p>
<p><span style = "color:red"><strong>SQL语句中使用了前模糊会导致索引失效？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c0b61b722ea0ee0990611ae568ee2ca082677ee/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%89%8D%E6%A8%A1%E7%B3%8A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"></p>
<p><span style = "color:red"><strong>分库分表id冲突解决方案？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/379b852cebfc3bf8b34e24670994a54443885b21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8id%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></p>
<blockquote>
<h2 id="✅-解决方案详解"><a href="#✅-解决方案详解" class="headerlink" title="✅ 解决方案详解"></a>✅ 解决方案详解</h2><h3 id="1-数据库主键自增（不推荐）"><a href="#1-数据库主键自增（不推荐）" class="headerlink" title="1. 数据库主键自增（不推荐）"></a>1. <strong>数据库主键自增（不推荐）</strong></h3><ul>
<li>每个分库或分表自己用数据库的自增主键生成 ID。</li>
<li>缺点：跨库表合并数据时会重复，<strong>不具备全局唯一性</strong>。</li>
</ul>
<hr>
<h3 id="2-UUID-作为主键"><a href="#2-UUID-作为主键" class="headerlink" title="2. UUID 作为主键"></a>2. <strong>UUID 作为主键</strong></h3><ul>
<li>使用 Java 的 <code>UUID.randomUUID().toString()</code> 等方式。</li>
<li>优点：<strong>天然全局唯一</strong>。</li>
<li>缺点：<ul>
<li>不适合做主键（无序、冗长，影响数据库索引性能）。</li>
<li>可读性差，调试困难。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-数据库主键段（Segment）模式（推荐）"><a href="#3-数据库主键段（Segment）模式（推荐）" class="headerlink" title="3. 数据库主键段（Segment）模式（推荐）"></a>3. <strong>数据库主键段（Segment）模式（推荐）</strong></h3><ul>
<li>思路：中心服务维护一张 ID 号段表，为每个业务系统分配一个号段。</li>
<li>实现：<ul>
<li>表中记录：<code>biz_tag, max_id, step, version</code></li>
<li>应用请求号段：<code>SELECT max_id, step FROM id_segment WHERE biz_tag = &#39;order&#39;</code></li>
<li>然后更新 max_id 为 <code>max_id + step</code></li>
</ul>
</li>
<li>优点：<ul>
<li>性能高（本地生成，无需每次访问数据库）</li>
<li>避免重复（由号段控制）</li>
</ul>
</li>
<li>缺点：需要一个中心服务（如美团 Leaf）</li>
</ul>
<hr>
<h3 id="4-雪花算法（Snowflake）"><a href="#4-雪花算法（Snowflake）" class="headerlink" title="4. 雪花算法（Snowflake）"></a>4. <strong>雪花算法（Snowflake）</strong></h3><ul>
<li><p>Twitter 出品，用于生成 64 位整数 ID。</p>
</li>
<li><p>格式如下：</p>
<pre><code class="java">0 - 41位时间戳 - 10位机器ID - 12位自增序列
</code></pre>
</li>
<li><p>优点：</p>
<ul>
<li>单机高性能、趋势递增、可分布式部署</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>依赖机器时钟，<strong>系统时间回拨可能导致重复 ID 或服务挂掉</strong></li>
<li>需要保证机器 ID 唯一（通常通过配置或 ZooKeeper 分配）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-Redis-生成自增-ID"><a href="#5-Redis-生成自增-ID" class="headerlink" title="5. Redis 生成自增 ID"></a>5. <strong>Redis 生成自增 ID</strong></h3><ul>
<li><p>利用 Redis 的 <code>INCR</code> 命令，生成全局递增 ID：</p>
<pre><code class="java">INCR order:id
</code></pre>
</li>
<li><p>可配合时间戳、业务前缀等拼接成全局唯一 ID。</p>
</li>
<li><p>优点：</p>
<ul>
<li>简单、轻量、分布式支持</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>Redis 挂掉或主从切换期间可能丢失或重复</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🏁-总结推荐"><a href="#🏁-总结推荐" class="headerlink" title="🏁 总结推荐"></a>🏁 总结推荐</h2><table>
<thead>
<tr>
<th>方案</th>
<th>唯一性</th>
<th>性能</th>
<th>实现复杂度</th>
<th>推荐使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>UUID</td>
<td>✅</td>
<td>高</td>
<td>简单</td>
<td>临时标识、测试用途</td>
</tr>
<tr>
<td>自增主键</td>
<td>❌</td>
<td>高</td>
<td>简单</td>
<td>单库表内可用</td>
</tr>
<tr>
<td>Segment</td>
<td>✅</td>
<td>✅</td>
<td>中等</td>
<td>企业级 ID 服务（如 Leaf）</td>
</tr>
<tr>
<td>雪花算法</td>
<td>✅</td>
<td>✅</td>
<td>中等</td>
<td>分布式高并发业务</td>
</tr>
<tr>
<td>Redis INCR</td>
<td>✅</td>
<td>高</td>
<td>简单</td>
<td>轻量级全局 ID 需求</td>
</tr>
</tbody></table>
<p>如果你是在<strong>高并发、微服务、分布式环境下</strong>，强烈推荐使用：</p>
<ul>
<li>雪花算法 + Redis 搭配</li>
<li>或引入一个中心 ID 生成服务（如 Leaf、TinyId、美团 UID Generator）</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>深分页为什么慢，怎么优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c3a969f374bebb04ca5858c2ab7ef750ac4296af/%E6%B7%B1%E5%88%86%E9%A1%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2%2C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96.png"></p>
<blockquote>
<h3 id="❓-问题背景：什么是深分页？"><a href="#❓-问题背景：什么是深分页？" class="headerlink" title="❓ 问题背景：什么是深分页？"></a>❓ 问题背景：什么是深分页？</h3><blockquote>
<p>深分页 &#x3D; 当前页数很大，比如 <code>page=100000 &amp; size=10</code><br> 对应 SQL：</p>
</blockquote>
<pre><code>SELECT * FROM table LIMIT 1000000, 10;
</code></pre>
<ul>
<li><code>LIMIT offset, size</code> 这种分页方式，在 <strong>offset 特别大时非常慢</strong>。</li>
<li>根因：数据库在处理时，<strong>仍然会扫描前面 offset 条记录，然后丢弃它们，仅返回后面的 size 条</strong>。</li>
</ul>
<hr>
<h3 id="🐌-为什么慢？"><a href="#🐌-为什么慢？" class="headerlink" title="🐌 为什么慢？"></a>🐌 为什么慢？</h3><p>数据库执行过程（如MySQL）：</p>
<pre><code>LIMIT 1000000, 10
</code></pre>
<p>数据库内部会：</p>
<ol>
<li>先从磁盘&#x2F;缓冲中 <strong>取出前 1000000 条记录</strong>；</li>
<li>然后只返回第 1000001 ~ 1000010 条；</li>
<li><strong>前面的全丢了</strong>，但依然耗费 CPU、IO 和内存资源。</li>
</ol>
<p>当数据量大时：</p>
<ul>
<li>IO开销大（全表扫描）</li>
<li>CPU开销大（排序、过滤）</li>
<li>数据库响应延迟高</li>
</ul>
<hr>
<h3 id="🚀-如何优化深分页？"><a href="#🚀-如何优化深分页？" class="headerlink" title="🚀 如何优化深分页？"></a>🚀 如何优化深分页？</h3><h4 id="✅-方案一：使用-覆盖索引"><a href="#✅-方案一：使用-覆盖索引" class="headerlink" title="✅ 方案一：使用 覆盖索引"></a>✅ 方案一：使用 <strong>覆盖索引</strong></h4><pre><code>SELECT id FROM table ORDER BY id LIMIT 1000000, 10;
</code></pre>
<p>如果 <code>id</code> 是索引字段，数据库可以直接从索引树上读取，无需回表。</p>
<p>但这个优化能力有限，适合某些查询字段很少、又刚好有索引的情况。</p>
<hr>
<h4 id="✅-方案二：记录上次的游标（Keyset-Pagination）"><a href="#✅-方案二：记录上次的游标（Keyset-Pagination）" class="headerlink" title="✅ 方案二：记录上次的游标（Keyset Pagination）"></a>✅ 方案二：记录上次的游标（<strong>Keyset Pagination</strong>）</h4><blockquote>
<p>又叫 <strong>基于条件的分页</strong>，避免使用 offset。</p>
</blockquote>
<p>例如：</p>
<pre><code>SELECT * FROM table 
WHERE id &gt; 上一页最后一条记录id 
ORDER BY id 
LIMIT 10;
</code></pre>
<p>优点：</p>
<ul>
<li>快！数据库利用索引跳过前面的数据</li>
<li>没有 offset，性能非常稳定</li>
</ul>
<p>适用场景：</p>
<ul>
<li>id 或时间戳等字段是自增或顺序的</li>
<li>不要求用户可以跳到任意页，只支持“向前&#x2F;向后翻页”</li>
</ul>
<hr>
<h4 id="✅-方案三：缓存-异步预处理"><a href="#✅-方案三：缓存-异步预处理" class="headerlink" title="✅ 方案三：缓存 + 异步预处理"></a>✅ 方案三：缓存 + 异步预处理</h4><p>对于排行榜、热点数据等：</p>
<ul>
<li>查询结果提前生成并缓存（Redis 等）</li>
<li>用户点页数 → 直接读缓存，避免实时查询</li>
</ul>
<hr>
<h4 id="✅-方案四：使用临时表或中间结果表"><a href="#✅-方案四：使用临时表或中间结果表" class="headerlink" title="✅ 方案四：使用临时表或中间结果表"></a>✅ 方案四：使用临时表或中间结果表</h4><ul>
<li>查询结果太大 → 先异步存入临时表</li>
<li>分页从临时表中读取数据（配合游标分页）</li>
</ul>
<p>适用于复杂 SQL 查询 + 多表连接</p>
<hr>
<h3 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>offset 分页</td>
<td>简单</td>
<td>深分页慢</td>
<td>小数据量</td>
</tr>
<tr>
<td>覆盖索引</td>
<td>快</td>
<td>限制大</td>
<td>查询字段少</td>
</tr>
<tr>
<td>游标分页</td>
<td>性能高</td>
<td>不支持跳页</td>
<td>流式阅读&#x2F;时间线</td>
</tr>
<tr>
<td>缓存分页</td>
<td>快</td>
<td>一致性差</td>
<td>热点排行榜等</td>
</tr>
<tr>
<td>临时表分页</td>
<td>灵活</td>
<td>复杂</td>
<td>大查询分页导出</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>MySQL的隔离级别实现原理MVCC ？</strong></span></p>
<ul>
<li><p>**MVCC ** (Multiversion Concurrency Control) <u>多版本并发控制器</u> </p>
<p>它是事务隔离级别的无锁的实现方式，用于提高事务的并发性能</p>
</li>
</ul>
<h5 id="事务隔离级别-isolation"><a href="#事务隔离级别-isolation" class="headerlink" title="事务隔离级别 (isolation)"></a>事务隔离级别 (isolation)</h5><p>用来解决并发事务所产生一些问题：<br><strong>并发</strong>：同一个时间，多个线程同时进行请求。<br>什么时候会发生并发问题：在并发情况下，对同一个数据(变量、对象)进行读写操作才会产生并发问题<br>并发会产生什么问题?<br>1.脏读一读已提交(行锁，读不会加锁)<br>2.不可重复度–重复读(行锁，读和写都会上锁)<br>3.幻影读–串行化(表锁)概念: 通过设置隔离级别可解决在并发过程中产生的那些问题</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eba483783b9cb58dca90497f85013b9f66e86dc0/MySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86MVCC.png"></p>
<p><span style="color:red"><strong>用户忘记密码，系统为什么不直接提供原密码，而让改密码</strong></span></p>
<h5 id="因为系统它也不知道我们的原密码是什么"><a href="#因为系统它也不知道我们的原密码是什么" class="headerlink" title="因为系统它也不知道我们的原密码是什么"></a>因为系统它也不知道我们的原密码是什么</h5><p>服务端在保存密码的时候绝不会<strong>明文</strong>存到数据库，怕有数据库权限的人或者黑客恶意利用<br>必须用不可逆的加密算法</p>
<h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><ul>
<li>只能加密不可解密 但是它是hash算法 可能会有哈希冲突 至少加密2^128次方才有可能发生<strong>哈希碰撞</strong></li>
<li>每次生成的密文都一样，不管加密多少次生成的密文都是一样的 可以通过<strong>暴力破解</strong><ul>
<li><u>解决暴力破解 就要在里面加<strong>盐</strong> 每次加密 解密 都要加入<strong>盐</strong></u></li>
</ul>
</li>
</ul>
<h5 id="HS256"><a href="#HS256" class="headerlink" title="HS256"></a>HS256</h5><ul>
<li>增加加密字符长度 目前没有碰撞性</li>
<li>最好加入随机盐</li>
</ul>
<h5 id="BCrypt-→-加入spring-security-core依赖"><a href="#BCrypt-→-加入spring-security-core依赖" class="headerlink" title="BCrypt → 加入spring-security-core依赖"></a>BCrypt → 加入<code>spring-security-core</code>依赖</h5><ul>
<li>盐是随机的 </li>
<li>无法通过暴力破解</li>
</ul>
<p><span style="color:red"><strong>Git怎么修复线上的突发BUG</strong></span><del>线上突发Bug要修复,本地正在开发新需求</del></p>
<p>在git里我们通常会用一个单独的分支来进行管理<br>本地开发也会有一个单独的分支<br>可以将线上代码的分支签出来单独进行修复</p>
<ul>
<li>正在开发的代码 → 暂存dev分支</li>
<li><strong>严重故障</strong>：回滚上一个版本<br><strong>非严重故障</strong>：在fix分支修复紧急Bug</li>
<li><strong>非常紧急</strong>：直接合并master分支上线</li>
<li><strong>一般急</strong>：合并release分支，走测试、上线流程</li>
<li><strong>非紧急</strong>：合并dev分支，走测试、线上流程</li>
</ul>
<p><span style = "color:red"><strong>RestTemplate如何优化连接池</strong></span></p>
<p>默认是没有连接池的<br>要用框架<code>HTTPClient</code>、<code>OKHTTP</code></p>
<blockquote>
<p><strong>RestTemplate</strong> 是Spring框架中用于简化HTTP请求的一个类，它提供了多种方法来处理HTTP请求和响应。RestTemplate可以用于发送GET、POST、PUT、DELETE等HTTP请求，并且可以处理请求头、请求体、URL参数等。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/6fd3855adcf37a9b9b26fd5173c0b8b9c549724d/RestTemplate%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%BF%9E%E6%8E%A5%E6%B1%A0.png"  />

<p><span style = "color:red"><strong>Synchronized怎么提升性能</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a85c2658ee0266db182e0570b1f861ee2933bfa9/Synchronized%E6%80%8E%E4%B9%88%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD.png"></p>
<blockquote>
<h2 id="🧠-实际开发中如何用好-synchronized？"><a href="#🧠-实际开发中如何用好-synchronized？" class="headerlink" title="🧠 实际开发中如何用好 synchronized？"></a>🧠 实际开发中如何用好 synchronized？</h2><h3 id="✅-尽量减少锁的粒度"><a href="#✅-尽量减少锁的粒度" class="headerlink" title="✅ 尽量减少锁的粒度"></a>✅ 尽量减少锁的粒度</h3><pre><code class="java">// ❌ 锁了整个方法
public synchronized void update() &#123; ... &#125;

// ✅ 只锁关键代码段
public void update() &#123;
    // 非关键代码
    synchronized (this) &#123;
        // 只锁关键部分
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="✅-使用局部锁对象代替类锁"><a href="#✅-使用局部锁对象代替类锁" class="headerlink" title="✅ 使用局部锁对象代替类锁"></a>✅ 使用局部锁对象代替类锁</h3><pre><code class="java">private final Object lock = new Object();

public void doTask() &#123;
    synchronized (lock) &#123;
        // 更细粒度的锁，避免不必要的争用
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="✅-使用并发类替代锁（性能更高）"><a href="#✅-使用并发类替代锁（性能更高）" class="headerlink" title="✅ 使用并发类替代锁（性能更高）"></a>✅ 使用并发类替代锁（性能更高）</h3><ul>
<li><code>ConcurrentHashMap</code></li>
<li><code>ReadWriteLock</code></li>
<li><code>ReentrantLock</code></li>
<li><code>AtomicInteger</code> 等</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>开发中有没有用到设计模式？怎么用的</strong></span></p>
<h5 id="策略模式-简单工厂-模板方法"><a href="#策略模式-简单工厂-模板方法" class="headerlink" title="策略模式 + 简单工厂 + 模板方法"></a>策略模式 + 简单工厂 + 模板方法</h5><img src="https://raw.githubusercontent.com/P-luminary/images/16704bb551d4c6a51ba6023f3d9370cbb7d02cc8/%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84.png" style="zoom:150%;" />



<p><span style = "color:red"><strong>SpringBoot如何防止反编译</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0e89c453cdc642a63ce8455ad04f9ff07f6010b0/SpringBoot%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91.png"></p>
<p><span style = "color:red"><strong>有没有出现过Spring正常SpringBoot报错的情况？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4fd9547c5d460bcf571303b13c67ef3958a5972/%E6%9C%89%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E8%BF%87Spring%E6%AD%A3%E5%B8%B8SpringBoot%E6%8A%A5%E9%94%99%E7%9A%84%E6%83%85%E5%86%B5.png"></p>
<p><span style = "color:red"><strong>SpringBoot配置文件敏感信息如何加密？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3d0323ce17742f53366f8c69b6675ddb5bc14ac4/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%EF%BC%9F.png"></p>
<p><span style = "color:red"><strong>一个需求来了怎么办</strong></span>！<br>首先看这个需求 进行一个分析 分析这个需求跟哪些功能有关联 比如说在我做过的xxx里面 和什么关联 要思考怎么去做这个关联 数据库 代码层面 思考好之后 再去ER画图 写接口文档 再去开始写代码</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>