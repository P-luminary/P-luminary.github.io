
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Stream模板+Lambda常用+@注释+常用方法模板集合</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Stream模板+Lambda常用+@注释+常用方法模板集合 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/22
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#879cff>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Stream模板"><a href="#Stream模板" class="headerlink" title="Stream模板"></a>Stream模板</h1><h6 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h6><p>中间方法的特点惰性求值：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。可以链式调用：多个中间操作可以链接在一起，形成一个操作链。返回类型：所有的中间操作返回的都是一个 Stream 对象。</p>
<h6 id="Stream中间代码"><a href="#Stream中间代码" class="headerlink" title="Stream中间代码"></a>Stream中间代码</h6><pre><code class="java">功能：过滤流中的元素，仅保留满足给定条件的元素。
// 示例：
Stream.of(1, 2, 3, 4, 5)
      .filter(n -&gt; n % 2 == 0) // 只保留偶数
      .forEach(System.out::println);//打印功能：将流中的元素映射为其他形式（通常是不同类型）。
// 示例：
Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。示例：Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);功能：去除流中的重复元素。示例：Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4功能：对流中的元素进行排序。示例：Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);功能：截取流中的前 maxSize 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);功能：跳过流中的前 n 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5下面是一个示例，展示了多种中间方法的使用：import java.util.Arrays;
import java.util.List;
</code></pre>
<details class="lake-collapse"><summary id="u41427c34"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 16px">中间方法：</span></strong></summary><ol class="ne-ol"><li id="ue6d895fe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">中间方法的特点<br /></span></strong><a href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">惰性求值</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">可以</span></strong><a href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">链式调用</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：多个中间操作可以链接在一起，形成一个操作链。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">返回类型：所有的中间操作返回的都是一个 Stream 对象。</span></strong></li></ol></details>
<details class="lake-collapse"><summary id="ueec7bf3e"><strong><span class="ne-text" style="color: #DF2A3F">stream中间操作</span></strong></summary><p id="u9155c15c" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：过滤流中的元素，仅保留满足给定条件的元素。</span></strong></p><p id="ue9508648" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oyHwt" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
.filter(n -&gt; n % 2 == 0) // 只保留偶数
.forEach(System.out::println);//打印</code></pre><p id="u7087b579" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素映射为其他形式（通常是不同类型）。</span></strong></p><p id="uec5be4e7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="rVrS1" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写</code></pre><p id="ufc5f99d4" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。</span></strong></p><p id="ub40cb3ec" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="NUaVI" class="ne-codeblock language-java"><code>Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);</code></pre><p id="u9bb719ff" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F">功能：去除流中的重复元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="Q888J" class="ne-codeblock language-java"><code>Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4</code></pre><p id="u18f09612" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">功能：对流中的元素进行排序。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">示例：</span></strong></p><pre data-language="java" id="JLF00" class="ne-codeblock language-java"><code>Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);</code></pre><p id="ue50c0c95" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：截取流中的前 maxSize 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="OdjlP" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);</code></pre><p id="u5c024d35" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：跳过流中的前 n 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="fN4RR" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5</code></pre><p id="u05623b28" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种中间方法的使用：</span></strong></p><pre data-language="java" id="wLvBv" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
public class StreamIntermediateOperations &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;);

<pre><code>    // 使用中间方法
    names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;)) // 过滤以 &#39;A&#39; 开头的名字
        .map(String::toUpperCase) // 将名字转换为大写
        .sorted() // 排序
        .forEach(System.out::println); // 输出结果
&#125;
</code></pre>
<p>}</code></pre><p id="ud6df2a51" class="ne-p"><br></p></details></p>
<details class="lake-collapse"><summary id="u8303321d"><strong><span class="ne-text">终结方法</span></strong></summary><p id="u6620a2d6" class="ne-p"><strong><span class="ne-text">在 Java Stream API 中，终结方法（Terminal Operations）是指那些会触发流的计算并最终产生结果的方法。与中间操作不同，终结方法会结束流的操作链，并返回一个具体的结果或副作用。以下是对终结方法的详细介绍：</span></strong></p><p id="ued92678c" class="ne-p"><strong><span class="ne-text">1. 终结方法的特点</span></strong></p><p id="u4f276cc4" class="ne-p"><strong><span class="ne-text">触发计算：终结方法会对流中的数据进行处理并生成结果，通常会遍历流中的所有元素。</span></strong></p><p id="u06c9bbef" class="ne-p"><strong><span class="ne-text">返回类型：终结方法可以返回不同类型的结果，包括：</span></strong></p><p id="ucfcd69c3" class="ne-p"><strong><span class="ne-text">基本类型（如 int、double）</span></strong></p><p id="u477c4769" class="ne-p"><strong><span class="ne-text">对象（如 List、Set、Map）</span></strong></p><p id="u935ad81e" class="ne-p"><strong><span class="ne-text">特殊值（如 Optional、Void）</span></strong></p></details>
<details class="lake-collapse"><summary id="u2b491d90"><strong><span class="ne-text" style="color: #DF2A3F">终结方法</span></strong></summary><p id="u6772e1b1" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：对流中的每个元素执行指定的操作。</span></strong></p><p id="udd84ed9a" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oUmRF" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);</code></pre><p id="u8e4efc31" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素收集到集合或其他形式。</span></strong></p><p id="u5b5cf4d3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="zF3zf" class="ne-codeblock language-java"><code>List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());</code></pre><p id="u76f88dab" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F; font-size: 14px">功</span></strong><strong><span class="ne-text" style="color: #DF2A3F">能：对流中的元素进行归约，返回一个单一的结果。</span></strong></p><p id="ue96e0ab3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="H9hY0" class="ne-codeblock language-java"><code>int sum = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</code></pre><p id="uab6649eb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中元素的数量。</span></strong></p><p id="u88fba7fd" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="ATK6U" class="ne-codeblock language-java"><code>long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).count();</code></pre><p id="u2f406546" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中是否有任何元素满足给定的条件。</span></strong></p><p id="uc612e6ba" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="yGMii" class="ne-codeblock language-java"><code>boolean hasA = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).anyMatch(s -&gt; s.equals(&quot;a&quot;));</code></pre><p id="u371b5ce7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中所有元素是否满足给定的条件。</span></strong></p><p id="ufd1731bb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="O6I5A" class="ne-codeblock language-java"><code>boolean allMatch = Stream.of(1, 2, 3).allMatch(n -&gt; n &lt; 5);</code></pre><p id="u5928384b" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中的第一个元素（如果存在）。</span></strong></p><p id="ufe6ffdc2" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="qh5FK" class="ne-codeblock language-java"><code>Optional&lt;String&gt; first = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).findFirst();</code></pre><p id="ub4cf4986" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种终结方法的使用：</span></strong></p><pre data-language="java" id="dakWh" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


<p>public class StreamTerminalOperations &#123;<br>    public static void main(String[] args) &#123;<br>        List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);</p>
<pre><code>    // forEach
    names.stream().forEach(System.out::println);

    // collect
    List&amp;lt;String&amp;gt; filteredNames = names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;))
        .collect(Collectors.toList());
    System.out.println(filteredNames);

    // reduce
    String concatenated = names.stream()
        .reduce(&amp;quot;&amp;quot;, (a, b) -&amp;gt; a + b);
    System.out.println(concatenated);
    
    // count
    long count = names.stream().count();
    System.out.println(&amp;quot;Count: &amp;quot; + count);
    
    // findFirst
    String firstName = names.stream().findFirst().orElse(&amp;quot;No Name&amp;quot;);
    System.out.println(&amp;quot;First Name: &amp;quot; + firstName);
&#125;
</code></pre>
<p>}</code></pre></details></p>
<h3 id="stream流超强引用"><a href="#stream流超强引用" class="headerlink" title="stream流超强引用"></a>stream流超强引用</h3><pre><code class="java">package com.itheima.pojo.test;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Arrays.asList 是 Java 中 java.util.Arrays 类的一个静态方法，
 * 用于将指定的数组或可变数量的参数转换为一个固定大小的 List。
 * 这个 List 是 ArrayList 的一个内部实现类，
 * 但它不是 java.util.ArrayList，
 * 而是一个不可变的列表
 */
public class Test2 &#123;
    public static void main(String[] args) &#123;
        // List&lt;String&gt; list：将上述列表赋值给 list 变量
        List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
        // 定义一个映射，键为整数，值为字符串列表 = 创建一个新的空哈希映射
        // 键的类型是 Integer，值的类型是 List&lt;String&gt; 表示具有相同长度的字符串列表
        // 用HashMap  允许 null 值：键和值都可以为 null，但键只能有一个 null。
        Map&lt;Integer, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : list) &#123;
            int length = s.length();
            // 检查 groups 映射中是否已经存在键为 length 的条目
            if (!groups.containsKey(length)) &#123;
                // 将新创建的列表作为值，以 length 为键添加到 groups 映射中
                // 创建一个新的 ArrayList，并将当前字符串 s 添加到其中
                groups.put(length, new ArrayList&lt;&gt;(Arrays.asList(s)));
            &#125; else &#123;
                // 从 groups 映射中获取键为 length 的列表
                List&lt;String&gt; group = groups.get(length);
                group.add(s);
            &#125;
            System.out.println(groups);
        &#125;

        // 使用 Stream API 进行分组
        // 使用 Collectors.groupingBy 方法按字符串长度进行分组
        // 将分组结果收集到一个新的映射 group2 中。
        Map&lt;Integer, List&lt;String&gt;&gt; group2 = list.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(group2);
    &#125;
&#125;
</code></pre>
<h1 id="Lambda-Stream实用方法"><a href="#Lambda-Stream实用方法" class="headerlink" title="Lambda+Stream实用方法"></a>Lambda+Stream实用方法</h1><pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.for循环输出
for (String s : list)&#123;
System.out.println(s);&#125;

2.表达式输出   
list.forEach(s -&gt;
System.out.println(s);&#125;);

3.表达式最简洁输出
List.forEach(System.out::println);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.使用重写Collections 排序
Collections.sort(list,new Comparator&lt;String&gt;（） &#123;
@override
public int compare(String o1, String o2) &#123;
return o1.compareTo(o2);
&#125;
&#125;);

2.使用lambda表达式排序
Collections.sort(list,(o1,o2) -&gt;&#123;
    return o1.compareTo(o2)
&#125;);

3.使用最简洁的表达式
Collections.sort(list,(o1,o2) -&gt;&#123;o1.compareTo(o2)&#125;);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式过滤
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;String s : list2)&#123;
if(s.startsWith(&quot;a&quot;))&#123;
     list2.add(s);
&#125; &#125;

2.使用 Stream API 进行过滤和收集,过滤以 &#39;a&#39; 开头的字符串,收集结果到一个新的 List 中
List&lt;String&gt;list3 = list.stream().filter(s - &gt; s.startsWith(&quot;a&quot;)).collect(Collectrs.toList());
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式获取长度
List&lt;Integer&gt; List2 = new ArrayList&lt;&gt;();
for （String s:list)&#123;
    
list2.add(s.length());&#125;

2.Lambda表达式+stream流获取长度
(map)这个函数对我们管道中的每个元素做了处理，在此处为把string转换为Integer类型 主要进行转换作用
List&lt;Integer&gt; list3 = list.stream().map(s -&gt; s.length()).collect(Collectors.toList());
</code></pre>
<pre><code class="java">//新建一个List集合
List&lt;Integer&gt; list = Arrays.asList（1,2, 3, 4, 5);
1.普通方式相加操作
int sum =0;
for (Integer v : list) &#123;
SUm +=V  &#125;
System.out.println(sum);

2.Lambda+stream
(表达式含义)：【0】操作的起始值，【a = a+b】 循环下去
int sum2 = list.stream().reduce( identity: 0, (a, b) -&gt; a + b);
System.out.println(sum2)
</code></pre>
<pre><code class="java">//新建一个集合
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);

Map&lt;Integer,List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();

1.普通方式分组
for （String s:list)&#123;
int length = s.length();
if (!groups.containsKey(length))&#123;
groups.put(length,new ArrayList&lt;&gt;());
&#125;
groups.get(Length) .add(s);
&#125;
    System.out.println(groups);

2.Lambda+stream分组
Map&lt;Integer,List&lt;String&gt;&gt; groups2 = list.stream().collect(Collectors.groupingBy(String::length));
System.out.println（groups2）
</code></pre>
<pre><code class="java">1.普通方式创建线程

Thread thread = newThread(new Runnable()&#123;
@Override
public void run()&#123;
System.out.println(&quot;hello world&quot;);
&#125;
&#125;);
thread.start();

2.Lambda表达式

Thread thread1 = new Threal(() -&gt; System.out.println(hello world&quot;));
thread1.start();
</code></pre>
<pre><code class="java">1.创建接口
interface  MyInterface&#123;
public void doSomething(String s);&#125;

2.普通实现接口
MyInterface myInterface = new MyInterface&#123;
    @override
    public void doSomething(String s)&#123;
    System.out.println(s);
    &#125;
&#125;;
myInterface.doSomething( s:&quot;hello world&quot;);

3.Lambda表达式实现接口
MyInterface myInterface1 = (s) -&gt; System.out.println(s);
myInterface1.doSomething( s:&quot;hello worLd&quot;)
</code></pre>
<pre><code class="java">String str = &quot;hello world&quot;;

1.普通方式
if（str !=null）&#123;
System.out.println(str.toUpperCase());&#125;

2.Lambda表达式
Optional.ofNuLlable(str).map(String::toUpperCase).ifPresent(System.out::println);
</code></pre>
<pre><code class="java">List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.普通方式
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
for （String s:list2)&#123; //遍历循环
    if （s.startsWith(&quot;a&quot;))&#123; //取出 包含a的元素
        list2.add(s.toUpperCase());//添加到list2中然后转换为大写
    &#125;
&#125;       Collections.sort(list2); //排序

2.Lambda+stream方式

List&lt;String&gt; list3 = list.stream().filter(s -&gt; s.startsWith(&quot;a&quot;))
.map(String::toupperCase).sorted().collect(collectors.toList());
</code></pre>
<pre><code class="java">public class Dept &#123;
    private int id;

    public Dept(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dept&#123;id=&quot; + id + &quot;&#125;&quot;;
    &#125;
&#125;

public class TestCollectStopOptions &#123;

    public void testCollectStopOptions() &#123;
        // 创建一个包含 Dept 对象的列表
        List&lt;Dept&gt; ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 List 中
        List&lt;Dept&gt; collectList = ids.stream()
                                   .filter(dept -&gt; dept.getId() &gt; 20)
                                   .collect(Collectors.toList());
        System.out.println(&quot;collectList: &quot; + collectList);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Set 中
        Set&lt;Dept&gt; collectSet = ids.stream()
                                 .filter(dept -&gt; dept.getId() &gt; 20)
                                 .collect(Collectors.toSet());
        System.out.println(&quot;collectSet: &quot; + collectSet);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Map 中，key 为 id，value 为 Dept 对象
        Map&lt;Integer, Dept&gt; collectMap = ids.stream()
                                          .filter(dept -&gt; dept.getId() &gt; 20)
                                          .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));
        System.out.println(&quot;collectMap: &quot; + collectMap);
    &#125;

    public static void main(String[] args) &#123;
        new TestCollectStopOptions().testCollectStopOptions();
    &#125;
&#125;

结果

collectList:[Dept&#123;id=22&#125;, Dept&#123;id=23&#125;]
collectSet:[Dept&#123;id=23&#125;, Dept&#123;id=22&#125;]
collectMap:&#123;22=Dept&#123;id=22&#125;, 23=Dept&#123;id=23&#125;&#125;
</code></pre>
<pre><code class="java">import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class User &#123;
    private String id;

    public User() &#123;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;id=&#39;&quot; + id + &#39;\&#39;&#39; + &#39;&#125;&#39;;
    &#125;
&#125;

public class TestStringToIntMap &#123;

    /**
     * 演示map的用途：一对一转换
     */
    public void stringToIntMap() &#123;
        // 创建一个包含字符串 ID 的列表
        List&lt;String&gt; ids = Arrays.asList(&quot;205&quot;, &quot;105&quot;, &quot;308&quot;, &quot;469&quot;, &quot;627&quot;, &quot;193&quot;, &quot;111&quot;);

        // 使用流操作
        List&lt;User&gt; results = ids.stream()
                               .map(id -&gt; &#123;
                                   // 创建一个新的 User 对象
                                   User user = new User();
                                   // 设置 User 对象的 id 属性
                                   user.setId(id);
                                   // 返回 User 对象
                                   return user;
                               &#125;)
                               .collect(Collectors.toList()); // 收集结果到一个新的 List 中

        // 打印结果
        System.out.println(results);
    &#125;

    public static void main(String[] args) &#123;
        new TestStringToIntMap().stringToIntMap();
    &#125;
&#125;
</code></pre>
<h1 id="注释笔记"><a href="#注释笔记" class="headerlink" title="@注释笔记"></a>@注释笔记</h1><p>@RequestBody ：获取请全体json字符串数据 封装给java对象，封装的前提是 json字符串属性要与实体类属性名一致才可以封装。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>#{name} 占位符 会从方法参数 对象里面调用getname封装方法获取数据映射到占位符位置。</p>
<p>#{参数名} 是Mybatis的参数占位符，可以自动将参数映射到SQL语句去执行</p>
<p>参数名要与接口方法的参数名要一致，但是方法只有一个参数时，参数名可以是任意的。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>Spring MVC 的 <font style="color:#DF2A3F;">@RequestMapping </font>注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的请求默认都会是 HTTP GET 类型的。比如<font style="color:#DF2A3F;">@GetMapping </font></p>
<p><font style="color:#DF2A3F;">加入路径处理前端响应</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>注解<font style="color:#DF2A3F;">@RequiredArgsConstructor</font> 是 Lombok 提供的一个注解，其主要作用在于简化 @Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;"> ：</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">的作用与</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Controller&lt;/font&gt;</code><font style="color:#000000;">，</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Service&lt;/font&gt;</code><font style="color:#000000;">的作用都是把对象交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">是标注在</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Dao&lt;/font&gt;</code><font style="color:#000000;">层接口上，作用是将接口的一个实现类交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Mapper</font></p>
<p><font style="color:#000000;">@Mapper: 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。</font></p>
<p><font style="color:#000000;">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中</font></p>
<p><font style="color:#000000;">注意：</font></p>
<p><font style="color:#000000;">在Dao层不要存在相同名字的接口，也就是在Dao不要写重载。因为mapper文件是通过id与接口进行对应的，如果写了两个同名的接口，就会导致mapper文件映射出错。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Transactional </font></p>
<p><font style="color:#000000;">Spring事务管理-控制事务 注解:@Transactional</font></p>
<p><font style="color:#000000;">作用:将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务  放在类上 则是整个类都会启动事务  放在接口上 接口的实现类都会去启动事务。放在方法上此方法中的代码会启动事务。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>规则:JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>MultipartFile  接收文件接口</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@Service 表明这个是逻辑层 可以被调用</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ConfigurationPropertise（）</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#000000;">@Autowired 注入bean</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;background-color:#131314;">集合:@RequestParam[List<Integer> ids</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>是一个在Java项目中常用的注解，特别是在使用日志框架如SLF4J时，通过在你的类上使用<code>@Slf4j</code>注解，Lombok会自动为你的类生成一个静态的日志字段，这个字段通常是<code>org.slf4j.Logger</code>类型的，并且通常命名为<code>log</code>。这样，你就可以在类中直接使用<code>log.info()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.error()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.debug()</code>等方法来记录日志，而无需手动声明和初始化<code>Logger</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">对象。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">@PathVariable  是 Spring MVC 中用于将 URL 模板变量绑定到你控制器处理器方法参数上的注解。这个注解使得你可以从 URL 中提取出变量值，并将其作为参数传递给控制器的方法。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RequestParam(defaultValue &#x3D; “1”)  给参数设置默认值  如果前端没有参数传进来 默认值为1 可自己设置</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@RequestBody 注解  使用对象去接收 的时候使用的注解  </p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RestControllerAdvice</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@ExceptionHandler</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">限制请求的方式</font></p>
<p><font style="color:#DF2A3F;">@RequestMapping  可以放在类上，获取的路径可以当做所有方法的父路径</font></p>
<p>@PostMapping(value&#x3D;”&#x2F;depts”,method&#x3D;RequestMethod.GET)注解 可以放方法上，获取前端的路径。</p>
<p>@GetMapping（”&#x2F;depts”）</p>
<p>@PutMapping</p>
<p>@DeleteMapping</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">junnit5</font></p>
<p>@Test</p>
<p><font style="color:#DF2A3F;">@ParameterizedTest</font></p>
<p><font style="color:#DF2A3F;">@BeforeEach</font></p>
<p>@AfterEach</p>
<p>@BeforeAll  标识静态方法</p>
<p>@AfterAll  标识静态方法</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@RestController &#x3D;  @Controller+@ResponseBody</font></p>
<p>标识当前控制类所有方法都有了@ResponseBody</p>
<p>@ResponseBody 将控制器方法直接输出给前端，将java对象转换为json字符串输出给前端</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>lombok</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;@WebFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，并指定属性</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;urlPatterns&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，通过这个属性指定过滤器要拦截哪些请求。</font></p>
<p><font style="color:rgb(51, 51, 51);">当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</font></p>
<p><font style="color:rgb(51, 51, 51);">@Order注解 控制过滤器优先级数字越小 优先级越高</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">Spring Boot 中注解的作用</font></p>
<p><font style="color:#DF2A3F;"></font></p>
<p><font style="color:#000000;">Spring Boot 利用注解来简化配置和提高开发效率。主要注解包括但不限于：</font></p>
<p><font style="color:#000000;">@SpringBootApplication: 启动 Spring Boot 应用程序。</font></p>
<p><font style="color:#000000;">@Component, @Service, @Repository, @Controller: 标记组件，以便 Spring 容器可以自动检测和管理它们。</font></p>
<p><font style="color:#000000;">@Bean 该方法会在spring项目启动时自动调用，并将方法的返回值交给IOC容器管理 – bean对象</font></p>
<p><font style="color:#000000;">@Autowired: 用于自动装配 Bean。</font></p>
<p><font style="color:#000000;">@Bean: 在配置类中定义 Bean。</font></p>
<p><font style="color:#000000;">@Configuration: 定义配置类。</font></p>
<p><font style="color:#000000;">@EnableAutoConfiguration: 开启自动配置。</font></p>
<p><font style="color:#000000;">这些注解通常被组合使用，以提供一个高度可配置且易于扩展的应用程序结构。</font></p>
<p><font style="color:#000000;">12. @PathVariable, @RequestParam, @ModelAttribute, @RequestBody, @ResponseBody</font></p>
<p><font style="color:#000000;">参数绑定</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">这些注解用于从 HTTP 请求中提取参数，并将它们绑定到方法参数上。</font></p>
<p><font style="color:#000000;">@PathVariable: 用于从 URL 中提取路径变量。</font></p>
<p><font style="color:#000000;">@RequestParam: 用于从查询字符串中提取参数。</font></p>
<p><font style="color:#000000;">@ModelAttribute: 用于将多个请求参数绑定到一个对象上。</font></p>
<p><font style="color:#000000;">@RequestBody: 用于将请求体中的数据绑定到方法参数上。 获取请求体json字符串数据封装给java对象</font></p>
<p><font style="color:#000000;">@ResponseBody: 用于将方法的结果直接写入响应体。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">13. @RestController</font></p>
<p><font style="color:#000000;">控制器注解</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">@RestController 注解是一个组合注解，它等价于 @Controller 和 @ResponseBody 的组合。它表示这是一个 REST 控制器，所有返回值都将被序列化为 JSON 格式并直接写入 HTTP 响应体。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">全局异常处理</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@ControllerAdvice&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于定义全局异常处理类，它可以捕获控制器方法抛出的所有异常，并提供统一的错误响应。</font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class)</font></p>
<p><font style="color:rgb(77, 77, 77);">测试运行器</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class) 注解告诉 JUnit 使用 Spring 测试运行器 (SpringRunner) 来运行测试。Spring 测试运行器提供了一种方便的方式来加载 Spring 上下文并管理测试生命周期。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">整体测试</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@SpringBootTest&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于执行整体测试，它会加载整个 Spring 应用上下文，包括所有自动配置的 Bean。这对于集成测试非常有用，因为它可以模拟完整的 Spring Boot 应用程序。</font></p>
<p>@Configuration 用于定义配置类，<font style="color:rgb(77, 77, 77);">配置类中的bean可以自动装配到其他bean中</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类可以使用其他Spring注解，如@ComponentScan和@Import，来扫描组件或导入其他配置类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类在Spring容器启动时会通过CGLIB动态代理机制生成代理类，以确保@Bean方法只被调用一次，从而保证单例bean的行为</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">环境和属性配置：</font></strong><font style="color:rgb(77, 77, 77);"><br></font><font style="color:rgb(77, 77, 77);">使用@PropertySource和@Value注解可以将外部属性文件中的值注入到配置类中</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">作用:按照一定的条件进行判断，在满足给定条件才会注册对应的bean对象到Spring IOC容器中。</font></p>
<p><font style="color:rgb(77, 77, 77);">位置:方法、类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Conditional 本身是一个父注解，派生出大量子注解</font></p>
<p><font style="color:rgb(77, 77, 77);">@ConditionalonClass:判断环境中是否有对应节码文件才注册bean到IOC容器</font></p>
<p><font style="color:rgb(77, 77, 77);">对应的bean(类型或名称)，才注册bean到IOC容器@ConditionalOnMissingBean:判断环境中没@ConditionalonProperty:判断配置文件中有应属性和值，才注册bean到IOC容器。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">SpringBoot 底层原理</font></p>
<p><font style="color:rgb(77, 77, 77);">bean获取。</font></p>
<p><font style="color:rgb(77, 77, 77);">@singleton   默认容器内同名称的bean只有一个实例（单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@prototype  每次使用该bean时会创建新的实例（非单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@request 每个请求范围内会创建新的实例（web环境中，了解即可）</font></p>
<p><font style="color:rgb(77, 77, 77);">@session 每个会话范围内都会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:rgb(77, 77, 77);">@application 每个应用范围内会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:#DF2A3F;">@Scope 设置bean的作用域 </font><font style="color:rgb(77, 77, 77);"> </font></p>
<p><font style="color:rgb(77, 77, 77);">@Lazy 延迟加载 会延迟到第一次使用的时候才会去加载</font></p>
<p><font style="color:rgb(77, 77, 77);">默认singleton的bean，在容器启动时被创建，可以使用aLazy注解来延迟初始化(延迟到第一次使用时)</font></p>
<p><font style="color:rgb(77, 77, 77);">prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</font></p>
<p><font style="color:rgb(77, 77, 77);">– 非单例是每次使用时会创建一个全新的bean</font></p>
<p><font style="color:rgb(77, 77, 77);">@Import  </font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">是 Java 中 Spring 框架（特别是 Spring Framework 和 Spring Boot）中用于配置类的一个注解。它主要用于导入其他配置类，使得当前的配置类能够复用其他配置类中的配置信息，从而避免重复的配置代码。</font></p>
<p><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Conditional&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 是 Spring Framework 中的一个注解，它用于在自动配置类（@Configuration 类）中或者通过 </font><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Bean&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 方法定义 bean 时，根据特定的条件来决定是否创建某个 bean 或配置。这个注解使得 Spring 的自动配置更加灵活和强大，因为它允许开发者基于特定的条件（如类路径上的特定类、操作系统属性、环境变量等）来启用或禁用配置。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">@Transactional注解书写位置：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">方法</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前方法交给spring进行事务管理</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">类</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前类中所有的方法都交由spring进行事务管理 （推荐）</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">接口</font><ul>
<li><font style="color:rgb(51, 51, 51);">接口下所有的实现类当中所有的方法都交给spring 进行事务管理</font></li>
</ul>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<ul>
<li><p><font style="color:rgb(51, 51, 51);">@Data是lombok注解,可以生成getter&#x2F;setter方法,tostring&#x2F;hashcode&#x2F;equals等方法重写</font></p>
<pre><code>@NoArgsConstructor /添加无参构造

@AllArgsConstructor //添加全参构造
</code></pre>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ResponseBody: 将控制器方法返回值直接输出给前端，将java对象转换为json字符串输出给前端@RestController &#x3D; @controller + @ResponseBody</p>
<p>标识了当前控制器类所有方法就都有了@ResponseBody</p>
<p>@Controller : spring框架的ioc注解，用于给当前类创建实例对象，也就是加入ioc容器中。</p>
<p>@Autowired ：依赖注入注解:在运行时会从spring容器中找当前接口实现类对象并注入</p>
<p>@Qualifier(“Bean对象”)：指定Bean别名这与对象</p>
<p>@Qualifier常与@Autowired一起使用</p>
<p>@0ptions(useGeneratedKeys &#x3D; true，keyProperty &#x3D;”id”)&#x2F;&#x2F;需要获取数据库赋值的id属性 并赋值给对象的id</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<h1 id="常用方法模板集合"><a href="#常用方法模板集合" class="headerlink" title="常用方法模板集合"></a>常用方法模板集合</h1><pre><code class="java">@Test
1:JsONUtil.toJsonStr(paramMap)//将任意对象转换为json字符串形式
                     
//使用hutool工具类把BedDto类型转换成Bed实体类 类型
2:Bed bean = BeanUtil.toBean(bedDto, Bed.class);

//判断对象是否为null 如果为null 返回true
3:Objects.isNull(xx)

//判断对象是否不为null 如果不为null 返回true
4:Objects.nonNull(xx)
                  
//工具类Objects 专门用来解决空指针异常 意思 先判断s1！=null 在调用s1.equals(s2)
5:Objects.equals(s1,s2)

//强转方法
6:String.valueOf() 

//整个对象的转换方法
7:BeanUtils.copyProperties(user,userPojo) 

8:StringUtils.toStringArray(把括号中的内容转换为一个字符串类型数组)

//在java中，JSONOBject类中的get（String key）方法接收一个字符串参数作为键名，用于从JSON对象中获取对应的值，这种方法运行通过建模来检索特定的数据项
//当我们调用JSONOBject.get(&quot;acces_token&quot;)的时候，实际上是在告诉程序：请查找名为“access_token”的键，并返回其关键的值，
//如果找到匹配的键，则返回相应的值，如果没有找到，则返回null
9:JSONOBject.get(&quot;acces_token&quot;)
//建造者设计模式：利用各种组件（各种属性）随意组合生成对象，目的是创建对象更加灵活
//与直接调用构造函数对比
//类一般要提供很多构造函数才可以灵活构建对象，这种方式很麻烦
//建造者模式创建对象底层只需需要提供一个构造函数即可，在使用的时候想设置哪个属性就设置哪个属性，最终都调用同一个构造函数
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder给当前类添加建造者设计模式创建对象    这几个注解都要有
10：member = Member.builder()
.openId(openid)
.build();
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>