
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 苍穹外卖</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>苍穹外卖 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/9/28
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#1bccbc>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><h3 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h3><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h4><h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><ul>
<li>需求规格说明书(word)、产品原型</li>
</ul>
<h6 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h6><ul>
<li>UI设计、数据库设计、接口设计</li>
</ul>
<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><ul>
<li>项目代码、单元测试</li>
</ul>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><ul>
<li>测试用例、测试报告</li>
</ul>
<h6 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h6><ul>
<li>软件环境安装、配置</li>
</ul>
<h5 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h5><ul>
<li><strong>项目经理</strong>：对整个项目负责，任务分配、把控进度</li>
<li><strong>产品经理</strong>：进行需求调研，输出需求调研文档、产品原型等</li>
<li><strong>UI设计师</strong>：根据产品原型输出界面效果图</li>
<li><strong>架构师</strong>：项目整体架构设计、技术选型等</li>
<li><span style = "color:red"><strong>开发工程师</strong></span>：代码实现</li>
<li><strong>测试工程师</strong>：编写测试用例，输出测试报告</li>
<li><strong>运维工程师</strong>：软件环境搭建、项目上线</li>
</ul>
<h5 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h5><ul>
<li><p>开发环境：开发人员在开发阶段使用的环境</p>
</li>
<li><p>测试环境：专门给测试人员使用的环境，用于项目测试</p>
</li>
<li><p>生产环境：线上环境</p>
</li>
</ul>
<h2 id="第二轮补充知识点复习-会以橙色标注"><a href="#第二轮补充知识点复习-会以橙色标注" class="headerlink" title="第二轮补充知识点复习 会以橙色标注"></a><span style = "color:orange"><strong>第二轮补充知识点复习 会以橙色标注</strong></span></h2><h3 id="苍穹外卖项目介绍"><a href="#苍穹外卖项目介绍" class="headerlink" title="苍穹外卖项目介绍"></a>苍穹外卖项目介绍</h3><h5 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h5><ul>
<li>定位：专门为餐饮制定的一款软件产品[<strong>管理端</strong> 与 <strong>用户端</strong>]</li>
</ul>
<h5 id="功能架构-体现项目中的业务功能模块"><a href="#功能架构-体现项目中的业务功能模块" class="headerlink" title="功能架构 (体现项目中的业务功能模块)"></a>功能架构 (体现项目中的业务功能模块)</h5><ul>
<li><strong>管理端</strong>：员工、分类、菜品、套餐、订单管理、工作台、数据统计、来单提醒</li>
<li><strong>用户端</strong>：微信登录、商品浏览、购物车、用户下单、微信支付、历史订单、地址管理、用户催单</li>
</ul>
<h5 id="产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计"><a href="#产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计" class="headerlink" title="产品原型“在文件里有用户端和管理端” (用于展示项目的业务功能 一般由产品经理进行设计)"></a><span style = "color:red">产品原型<del>“在文件里有用户端和管理端”</del></span> (用于展示项目的业务功能 一般由产品经理进行设计)</h5><h5 id="技术选型-展示项目中使用到的技术框架和中间件"><a href="#技术选型-展示项目中使用到的技术框架和中间件" class="headerlink" title="技术选型 (展示项目中使用到的技术框架和中间件)"></a>技术选型 (展示项目中使用到的技术框架和中间件)</h5><ul>
<li><p><strong>用户层</strong>：node.js、VUE.js、ElementUI、微信小程序、apache echarts</p>
</li>
<li><p><strong>网关层</strong>：Nginx</p>
</li>
<li><p><strong>应用层</strong>：SpringBoot、SpringMVC、SpringTask、httpclient、SpringCache、JWT、阿里云OSS、Swagger、POI(操作excel表格)、WebSocket(网络协议&lt;催单…&gt;)</p>
</li>
<li><p><strong>数据层</strong>：MySQL、Redis、MyBatis、PageHelper、Spring Data Redis</p>
</li>
<li><p><strong>工具</strong>：Git、Maven、Junit、PostMan</p>
</li>
</ul>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p><strong>前端</strong>：管理端(Web<del>基于Nginx</del>)、用户端(小程序)</p>
<blockquote>
<p>前端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\前端运行环境\nginx-1.20.2\html\sky</p>
<p>D:\nginx-1.20.2 [放在英文目录下 双击 nginx.exe] 默认端口号80</p>
<p><strong>[苍穹外卖]</strong> (<a target="_blank" rel="noopener" href="http://localhost/#/login">http://localhost/#/login</a>) 如果被其他占用(比如RAGFlow)就把 <code>localhost</code> 换成 <strong>127.0.0.1</strong></p>
</blockquote>
<p><strong>后端</strong>：后端服务(Java)</p>
<blockquote>
<p>后端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\后端初始工程\sky-take-out</p>
<p>把sky-take-out导入到idea</p>
</blockquote>
<ul>
<li><strong>sky-take-out</strong> [maven父工程，<strong>统一管理依赖版本</strong>，<strong>聚合其他子模块</strong>]<ul>
<li>sky-common [子模块，存放公共类(工具类、常量类、异常类)]</li>
<li>sky-pojo [子模块，存放实体类、VO、DTO等]</li>
<li>sky-server [子模块，后端服务，存放配置文件、Controller、Service、Mapper等]</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Entity</td>
<td>实体，通常和数据库中的表对应</td>
</tr>
<tr>
<td>DTO</td>
<td>数据传输对象，通常用程序中各层之间传递数据</td>
</tr>
<tr>
<td>VO</td>
<td>视图对象，为前端展示数据提供的对象</td>
</tr>
<tr>
<td>POJO</td>
<td>普通Java对象，只有属性和对应的Getter和Setter</td>
</tr>
</tbody></table>
<p><span style = "color:orange"><strong>深刻理解POJO</strong></span></p>
<blockquote>
<p><strong>POJO</strong>的内在含义是指：那些没有继承任何类、也没有实现任何接口[可以实现]，更没有被其它框架侵入的java对象。<br><strong>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等</strong>不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。 <strong><u>可以包含类似与JavaBean属性和对属性访问的setter和getter方法的</u></strong><br>一般在web应用程序中建立一个<strong>数据库</strong>的映射对象时，我们只能称它为POJO。</p>
<ul>
<li><strong>POJO持久化之后</strong>&#x3D;&#x3D;〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</li>
<li><strong>POJO传输过程中</strong>&#x3D;&#x3D;&gt; DTO</li>
<li><strong>POJO用作表示层</strong>&#x3D;&#x3D;&gt; VO</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解PO、DTO、VO</strong></span></p>
<blockquote>
<p><strong>PO</strong>(persistent object)：就是将对象与关系数据库绑定，用对象来表示关系数据，<br>最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p>
<ul>
<li>有时也被称为Data对象，对应数据库的entity，简单认为一个PO对应数据库中的一条记录</li>
<li>PO中不应该包含任何对数据库的操作</li>
<li><strong>PO的属性是跟数据表的字段一一对应的</strong></li>
<li>PO对象需要实现序列化接口</li>
</ul>
<hr>
<p><strong>DTO</strong>(<u>Data Transfer Object</u>)： → 数据传输对象<br>主要用于远程调用需要大量传输对象的地方<br>我们可以将PO中的部分属性抽取出来，就形成了DTO<br><strong>举例说明</strong>：<br>比如我们有一张表有100个字段，那么对应的PO就有100个属性<br>但是我们界面上需要显示10个字段，客户端用WEB service来获取数据，没必要把整个PO对象传递到客户端，这时<u>我们就可以用只有这10个属性的DTO来传递结果到客户端</u>，这样就<u><strong>不会暴露服务端表结构</strong></u>，到达客户端后，<u>如果用这个对象来对应界面显示，那么此时它的身份就转为了<strong>VO</strong>(View Object)</u></p>
<hr>
<p><strong>VO</strong><br>VO(value object) 是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。<br><strong>重点</strong>：<br>一个VO可以只是PO的一部分，也可以是多个PO构成，同样也等同于一个PO(指的是属性)。正因为这样，PO独立出来，<u>数据持久层</u>也就独立出来了，它不会受到任何业务的影响和干涉。又因为这样，<u>业务逻辑层</u>也独立开来，它不会受到数据持久层的影响，业务层只关心业务逻辑的处理，怎么存和读都交给别人。</p>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解什么是DAO</strong></span></p>
<blockquote>
<p><strong>DAO</strong>(Data Access Object)：数据访问对象<br>主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。<br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD操作…</p>
<ul>
<li><p>主要用来封装对DB（数据库）的访问（CRUD操作）。</p>
</li>
<li><p>通过接收业务层的数据，把POJO持久化为PO。</p>
</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解JavaBean</strong></span></p>
<blockquote>
<p><strong>JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定：</strong></p>
<p><strong>1、这个类必须具有一个公共的(public)无参构造函数；</strong><br><strong>2、所有属性私有化（private）；</strong><br><strong>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</strong><br><strong>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</strong><br>JavaBean在JavaEE开发中，通常用于<strong>封装数据</strong><br>许多开发者会把<strong>JavaBean</strong>看作村从特定命名约定的<strong>POJO</strong><del>POJO按照JavaBean的规则来就可以变成JavaBean</del><br><strong>当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean</strong><br>JavaBean是一种组件技术，就好像你做了一个扳手，而这个扳手会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</p>
</blockquote>
<p><span style = "color:orange"><strong>common里的constant、context、properties代表什么意思</strong></span></p>
<pre><code class="java">constant:
用于存放常量类。这些常量可能是项目中频繁使用的固定值，如状态码、错误码、系统配置项等。
常量类中的变量一般使用public static final修饰，确保其不可变性。
    
context:
用于存放上下文类。上下文类通常用来保存和传递运行时环境信息或状态。
在Spring框架中，ApplicationContext就是一个典型的上下文对象，它提供了对Bean的访问以及配置信息的管理。
    
properties:
用于存放属性文件。这些文件通常以.properties为扩展名，用于存储配置信息，如数据库连接字符串、系统参数等。
属性文件可以通过Properties类来读取和写入，方便在运行时动态调整系统行为。
</code></pre>
<p><span style = "color:orange"><strong>Final的巩固</strong></span></p>
<pre><code class="java">问：对于引用类型（如String、Object等），final变量的引用不能被改变，但引用的对象内部状态可以改变。 这句话是什么意思？

答：当一个引用类型的变量被声明为final时，这个变量的引用（即指向的对象）不能被改变，但该对象的内部状态是可以改变的。我们可以通过具体的例子来理解这一点。
public class Example &#123;
    public static final String EMP_ID = &quot;empId&quot;;
    public static void main(String[] args)&#123;
        // 下面这行代码会编译失败，因为EMP_ID是final的
        // EMP_ID = &quot;newEmpId&quot;; // 编译错误
        
// 但是可以创建一个新的String对象并使用EMP_ID内容
    String anotherId = EMP_ID + &quot;123&quot;;
    sout(anotherId) =&gt; empId123;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>解析context (实现上下类的逻辑原理) 内的代码</strong></span></p>
<pre><code class="java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
//ThreadLocal 是一个线程局部变量，每个线程都有自己的独立副本。这意味着不同线程之间不会共享同一个 ThreadLocal实例的数据，从而避免了多线程环境下的数据竞争问题。
    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
/*
这个类通常用于需要在多线程环境中传递和管理线程上下文信息的场景。例如：

Web应用：在处理HTTP请求时，可能需要将用户ID或其他上下文信息绑定到当前线程，以便在整个请求处理过程中都能访问到这些信息。

日志记录：在日志记录中，可能需要记录每个操作的执行者ID，通过 ThreadLocal 可以方便地在日志记录器中获取当前操作者的ID。

事务管理：在分布式事务中，可能需要将事务ID绑定到当前线程，以便在事务的各个阶段都能访问到这个ID。

内存泄漏：如果 ThreadLocal 中存储的对象没有及时释放，可能会导致内存泄漏。因此，建议在不再需要 ThreadLocal 中的数据时，调用 remove 方法将其移除。

线程池：在使用线程池时，特别需要注意 ThreadLocal 的管理。线程池中的线程是复用的，如果不及时清理 ThreadLocal 中的数据，可能会导致数据混淆或内存泄漏。
*/
</code></pre>
<p><span style = "color:orange"><strong>静态变量解析</strong></span></p>
<pre><code class="java">//静态变量 (static)
静态变量：在 Java 中，静态变量属于类而不是类的实例。这意味着无论创建多少个类的实例，静态变量都只有一份拷贝，并且所有实例共享这份拷贝。
作用域：静态变量在类加载时初始化，并且在类卸载时销毁。它们存在于类的生命周期内，而不是实例的生命周期内。

//结合 static 和 ThreadLocal
在 BaseContext 类中，threadLocal 被声明为 static，这意味着所有 BaseContext 实例共享同一个 ThreadLocal 实例。但这并不意味着所有线程共享同一个 ThreadLocal 实例的数据。相反，每个线程都有自己独立的 ThreadLocal 数据副本。
    
静态变量：
public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
这行代码声明了一个静态的 ThreadLocal 变量 threadLocal，所有 BaseContext 实例共享这个 ThreadLocal 实例。
</code></pre>
<h3 id="使用Git进行版本控制"><a href="#使用Git进行版本控制" class="headerlink" title="使用Git进行版本控制"></a>使用Git进行版本控制</h3><ul>
<li>创建Git本地仓库</li>
<li>创建Git远程仓库[GitHub、Gitee]</li>
<li>将本地文件推送到Git远程仓库</li>
</ul>
<pre><code class="java">.gitignore[文件设置]
    
//忽略git管理的文件
**/target/
.idea
*.iml
*.class
*Test.java
**/test/
</code></pre>
<blockquote>
<p><strong>创建远程仓库流程</strong>：【提交到本地】<br>VCS → Create Git Repository → sky-take-out → √ → Unversinoed Files(All)  → Commit</p>
<p><strong>去创建一个仓库</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
<p><strong>推送代码到Gitee远程仓库</strong>：Idea右上角的↗ → 定义一下本地和远程仓库关联 点击Define remote → Name: origin<br>URL: <a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out.git">https://gitee.com/Pluminary/sky-take-out.git</a> (这个是在Gitee上创建仓库后复制的代码)</p>
<p><strong>推送成功</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
</blockquote>
<h3 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h3><h6 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h6><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42914989/article/details/113155204">Unknown collation: ‘utf8mb4_0900_ai_ci‘的解决方法_unknown collation utf8mb4-CSDN博客</a></p>
<h6 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h6><pre><code class="java">浏览器

↓
Controller:
1.接收并封装参数
2.调用service方法查询数据库
3.封装结果并相应

↓
Service：
1.调用mapper查询数据库
2.密码对比
3.返回结果

↓
Mapper：
1.select * from employee where username = ? 

↓
数据库
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tlk20071/article/details/103629336">IDEA中导入多module的Maven项目无法识别module的解决办法_idea modules太多 mvn clean 对某个module不起作用-CSDN博客</a></p>
<blockquote>
<p>Maven → <strong>compile</strong>(编译聚合模块 )</p>
<p>[INFO] ————————————————————————<br>[INFO] Reactor Summary for sky-take-out 1.0-SNAPSHOT:<br>[INFO]<br>[INFO] sky-take-out ………………………………… SUCCESS [  0.003 s]<br>[INFO] sky-common ………………………………….. SUCCESS [  2.761 s]<br>[INFO] sky-pojo ……………………………………. SUCCESS [  2.227 s]<br>[INFO] sky-server ………………………………….. SUCCESS [  1.294 s]<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS</p>
</blockquote>
<p><span style="color:red">在数据库中 <u>新建查询</u> <strong>→</strong> <u>SELECT VERSION()</u>; <strong>→</strong> 引擎是8.0.33的是正规操作mysql此时对应的任务管理器<strong>服务</strong>里搜索mysql(名称:MySQL80)开启这个 <strong>→</strong> 如果开启了服务里的MySQL那<u>SELECT VERSION()</u>查询就是11.0.5-MariaDB</span></p>
<blockquote>
<p>handler：全局异常处理器</p>
</blockquote>
<p><span style = "color:orange"><strong>右侧Maven的具体用途</strong></span></p>
<blockquote>
<ol>
<li><p><strong>clean</strong><br> 功能：<strong>清除项目构建过程中生成的所有文件，通常包括 target 目录下的内容</strong>。<br> 命令：mvn clean<br> 使用场景：<br> 在每次构建之前，确保没有旧的构建产物干扰新构建。<br> 清理项目目录，准备进行新的构建。</p>
</li>
<li><p><strong>validate</strong><br> 功能：<strong>验证项目的正确性，确保所有必要的信息都已就绪</strong>。<br> 命令：mvn validate<br> 使用场景：<br> 在构建过程的早期阶段，检查项目配置是否正确。<br> **<u>确保所有依赖项和资源都可用</u>**。</p>
</li>
<li><p><span style = "color:red"><strong>compile</strong></span><br> 功能：<strong>编译项目的源代码</strong>。<br> 命令：mvn compile<br> 使用场景：<br> <u>编译项目源代码，生成 .class 文件。</u><br> <u><strong>通常在开发过程中频繁使用</strong>，<strong>确保代码可以成功编译</strong>。</u></p>
</li>
<li><p><strong>test</strong><br> 功能：运行项目的单元测试。<br> 命令：mvn test<br> 使用场景：<br> 在代码提交前，确保所有单元测试通过。<br> 持续集成（CI）过程中，自动运行测试以确保代码质量。</p>
</li>
<li><p><span style = "color:red"><strong>package</strong></span><br> 功能：<strong>将编译后的代码打包成可分发的格式，如 JAR、WAR 等</strong>。<br> 命令：mvn package<br> 使用场景：<br> 构建项目并生成可部署的包。<br> <strong>通常在开发和部署过程中使用，生成最终的可发布版本。</strong></p>
</li>
<li><p><strong>verify</strong><br> 功能：<strong>运行任何检查以验证包的完整性和有效性。</strong><br> 命令：mvn verify<br> 使用场景：<br> 在发布前，进行更严格的验证，确保包的质量。<br> <strong>运行集成测试、性能测试</strong>等。</p>
</li>
<li><p><span style = "color:red"><strong>install</strong></span><br> <strong>功能：将包安装到本地 Maven 仓库，供其他项目使用</strong>。<br> 命令：mvn install<br> 使用场景：<br> 将项目依赖安装到本地仓库，以便其他项目可以引用。<br> 通常在开发和测试环境中使用，确保依赖项可用。</p>
</li>
<li><p><strong>site</strong><br> 功能：生成项目的站点文档，包括项目报告、测试覆盖率等。<br> 命令：mvn site<br> 使用场景：<br> 生成项目文档，供团队成员和外部用户查阅。<br> 文档生成和发布，提高项目的透明度和可维护性。</p>
</li>
<li><p><strong>deploy</strong><br> 功能：将最终的包部署到远程仓库，如 Nexus、Artifactory 等。<br> 命令：mvn deploy<br> 使用场景：<br> 将项目发布到远程仓库，供其他团队或项目使用。<br> 通常在持续集成和持续部署（CI&#x2F;CD）流程中使用，确保发布的版本可用。</p>
</li>
</ol>
<p>  <strong>总结</strong><br>  clean：清理构建产物。<br>  validate：验证项目配置。<br>  compile：编译源代码。<br>  test：运行单元测试。<br>  package：打包项目。<br>  verify：验证包的完整性和有效性。<br>  install：安装到本地仓库。<br>  site：生成项目文档。<br>  deploy：部署到远程仓库。</p>
</blockquote>
<h6 id="思考：前端发送的请求，是如何请求到后端服务的？"><a href="#思考：前端发送的请求，是如何请求到后端服务的？" class="headerlink" title="思考：前端发送的请求，是如何请求到后端服务的？"></a>思考：前端发送的请求，是如何请求到后端服务的？</h6><pre><code class="java">前端请求地址：http://localhost/api/employee/login
后端接口地址：http://localhost:8080/admin/employee/login
</code></pre>
<ul>
<li><p><strong>nginx</strong>反向代理，就是将前端发送的动态请求由nginx转发到后端服务器</p>
</li>
<li><p><strong>浏览器</strong> → <a target="_blank" rel="noopener" href="http://localhost/api/employee/login">http://localhost/api/employee/login</a> → <strong>Nginx</strong> → <a target="_blank" rel="noopener" href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a> → <strong>Tomcat</strong></p>
</li>
<li><p>nginx反向代理的好处：提高访问速度、进行负载均衡<del>(否则前端就只能访问一台服务器)</del>、保证后端服务安全<del>(不对外开放)</del></p>
</li>
</ul>
<h6 id="nginx-反向代理的配置方式"><a href="#nginx-反向代理的配置方式" class="headerlink" title="nginx 反向代理的配置方式"></a>nginx 反向代理的配置方式</h6><pre><code class="java">nginx.conf

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://localhost:8080/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡的配置方法-平均转发到多台后端服务器"><a href="#nginx-负载均衡的配置方法-平均转发到多台后端服务器" class="headerlink" title="nginx 负载均衡的配置方法(平均转发到多台后端服务器)"></a>nginx 负载均衡的配置方法(平均转发到多台后端服务器)</h6><pre><code class="java">nginx.conf

upstream webservers&#123;
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
&#125;

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://webservers/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡策略："><a href="#nginx-负载均衡策略：" class="headerlink" title="nginx 负载均衡策略："></a>nginx 负载均衡策略：</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td>
</tr>
<tr>
<td>fair</td>
<td>依据相应时间方式，响应时间短的服务将会被优先分配</td>
</tr>
</tbody></table>
<h3 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h3><h6 id="问题：员工表中的密码是明文存储，安全性太低"><a href="#问题：员工表中的密码是明文存储，安全性太低" class="headerlink" title="问题：员工表中的密码是明文存储，安全性太低"></a>问题：员工表中的密码是明文存储，安全性太低</h6><ul>
<li><p>将密码加密后存储，提高安全性</p>
</li>
<li><p>使用<strong>MD5</strong>加密方式对明文密码加密 <strong>[不可逆]</strong></p>
</li>
<li><p>修改数据库中的明文代码，改为MD5加密后的密文</p>
</li>
<li><p>修改Java代码，前端提交的代码进行MD5加密后再跟数据库中密码比对</p>
</li>
</ul>
<p><span style = "color:yellow"><strong>在Idea中有 “&#x2F;&#x2F;TODO” 这代表着标记处 此处还未完成一些操作 标记后可以在idea的下面快速定位到TODO</strong></span></p>
<blockquote>
<p>MD5密码加密后 也区分大小写 如果相同的密文但是大小写不同 结果还是不同的</p>
</blockquote>
<h6 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a><span style ="color:orange">修改密码</span></h6><pre><code class="java">com/sky/controller/admin/EmployeeController.java
 @PutMapping(&quot;/editPassword&quot;)
    @ApiOperation(&quot;修改密码&quot;)
    public Result editPassword(@RequestBody PasswordEditDTO passwordEditDTO) &#123;
        log.info(&quot;修改密码：&#123;&#125;&quot;, passwordEditDTO);
        employeeService.updatePassword(passwordEditDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/EmployeeService.java
/**
     * 更改密码
     * @param passwordEditDTO
     */
    void updatePassword(PasswordEditDTO passwordEditDTO);
</code></pre>
<pre><code class="java">com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 更改密码
     * @param passwordEditDTO
     */
    @Override
    public void updatePassword(PasswordEditDTO passwordEditDTO) &#123;
    //getCurrentId 方法：public static Long getCurrentId() 方法用于获取当前线程的用户ID。

        Long empId = BaseContext.getCurrentId();
    //select * from employee where id = #&#123;id&#125;   根据id查员工的所有
        Employee employee = employeeMapper.getById(empId);
    //用md根据从前端传来的oldpassword 去判断employee的原始代码是否相同
        if (!employee.getPassword().equals(DigestUtils.md5DigestAsHex(passwordEditDTO.getOldPassword().getBytes()))) &#123; 
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        &#125;
        String newPassword = DigestUtils.md5DigestAsHex(passwordEditDTO.getNewPassword().getBytes());
        employee.setPassword(newPassword);
        employeeMapper.update(employee);
    &#125;
</code></pre>
<h3 id="导入接口文档"><a href="#导入接口文档" class="headerlink" title="导入接口文档"></a>导入接口文档</h3><h6 id="前后端分离开发流程"><a href="#前后端分离开发流程" class="headerlink" title="前后端分离开发流程"></a>前后端分离开发流程</h6><ul>
<li><strong>定制接口</strong>(定义规范) → <strong>前端开发</strong>(mock数据) + <strong>后端开发</strong>(后端自测) → <strong>连调</strong>(校验格式) → <strong>提测</strong>(自动化测试)</li>
</ul>
<h6 id="操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台"><a href="#操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台" class="headerlink" title="操作步骤 YApi Pro-高效、易用、功能强大的可视化接口管理平台"></a>操作步骤 <a target="_blank" rel="noopener" href="https://yapi.pro/">YApi Pro-高效、易用、功能强大的可视化接口管理平台</a></h6><blockquote>
<p>将课程资料中提供的项目接口导入YApi<br>苍穹外卖-管理端接口.json<br>苍穹外卖-用户端接口.json<br>苍穹外卖-管理端+用户端接口 → 数据管理 → 数据导入(json 随后把json文件拖入) → 点击接口可查看</p>
</blockquote>
<h3 id="Swagger介绍和使用方式"><a href="#Swagger介绍和使用方式" class="headerlink" title="Swagger介绍和使用方式"></a>Swagger介绍和使用方式</h3><p><strong>Knife4j</strong>是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><ul>
<li>导入knife4j的maven坐标</li>
<li>在配置类中加入knife4j相关配置</li>
</ul>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
/**
 * 通过knife4j生成接口文档
 * @return
*/ 
@Bean
    public Docket docket() &#123;
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                    //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))
                .paths(PathSelectors.any())
                .build();
        return docket;
    &#125;
</code></pre>
<ul>
<li>设置静态资源映射，否则接口文档页面无法访问</li>
</ul>
<pre><code class="java">/**
 * 设置静态资源映射
 * @param registry
*/
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
</code></pre>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a>) 这个文档是解析<code>EmployeeController</code>来的</p>
<h6 id="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"><a href="#通过Swagger就可以生成接口文档，那么我们不需要Yapi了？" class="headerlink" title="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"></a>通过Swagger就可以生成接口文档，那么我们不需要Yapi了？</h6><ul>
<li>Yapi是设计阶段使用的工具，管理和维护接口</li>
<li>Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</li>
</ul>
<p><strong>编写接口文档 在企业中需要注意：</strong></p>
<pre><code class="java">测试：
为每个API编写单元测试和集成测试，确保API的正确性和稳定性。
使用自动化测试工具（如Postman, JUnit等）来定期验证API的行为。
</code></pre>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Api</strong></td>
<td>用在类上，例如<strong>Controller</strong>，表明对类的说明</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>用在类上，例如entity、DTO、VO</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>用在属性上，描述属性信息</td>
</tr>
<tr>
<td><strong>@ApiOperation</strong></td>
<td>用在方法上，例如Controller的方法，说明方法的用途、作用</td>
</tr>
</tbody></table>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
package com.sky.controller.admin;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.EmployeeService;
import com.sky.utils.JwtUtil;
import com.sky.vo.EmployeeLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 员工管理
 */
@RestController
@RequestMapping(&quot;/admin/employee&quot;)
@Slf4j
@Api(tags = &quot;员工相关接口&quot;)
public class EmployeeController &#123;

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(value = &quot;员工登录&quot;)
    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;
        log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    &#125;

    /**
     * 退出
     *
     * @return
     */
    @PostMapping(&quot;/logout&quot;)
    @ApiOperation(value = &quot;员工退出&quot;)
    public Result&lt;String&gt; logout() &#123;
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/EmployeeLoginVO.java
// 这里是最后返回的数据vo [已经经历过由po→DTO→vo的过程] 这里的po应该就是Employee
package com.sky.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(description = &quot;员工登录返回的数据格式&quot;)
public class EmployeeLoginVO implements Serializable &#123;

    @ApiModelProperty(&quot;主键值&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String userName;

    @ApiModelProperty(&quot;姓名&quot;)
    private String name;

    @ApiModelProperty(&quot;jwt令牌&quot;)
    private String token;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeLoginDTO.java
// 这里的DTO是传输中的数据
package com.sky.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)
public class EmployeeLoginDTO implements Serializable &#123;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

&#125;
</code></pre>
<p><span style = "color:orange"><strong>Getter与Setter无中生有？？    以及快速创建对象builder</strong>  </span></p>
<blockquote>
<p>在上述VO和DTO代码中很显然没有看到常见的Getter和Setter<br>这是因为代码使用了 Lombok 注解，Lombok 是一个 Java 库，可以通过注解自动生成常见的样板代码，如 getter、setter、toString、equals 和 hashCode 等方法。</p>
<p><u>Lombok 注解解释</u>：<br>@<strong>Data</strong>：<br>作用：这是一个组合注解，包含了 @ToString、@EqualsAndHashCode、<u>@Getter、@Setter</u> 和 @RequiredArgsConstructor。<br><span style = "color:pink"><strong>效果：自动生成所有字段的 getter 和 setter 方法，toString 方法，equals 和 hashCode 方法，以及一个包含所有 final 字段和 @NonNull 字段的构造函数。</strong></span></p>
<p>@<strong>Builder</strong>：<br>作用：生成一个构建器模式的类，使得对象的创建更加灵活和可读。<br>效果：自动生成一个静态内部类 EmployeeLoginVO.EmployeeLoginVOBuilder，并提供构建方法。</p>
<ul>
<li><p>生成的构建器类包含所有字段的设置方法，并提供一个 build 方法来最终构建对象</p>
</li>
<li><p>使用构建器模式可以让你在创建对象时更清晰地指定各个字段的值，特别是在对象有很多字段时。<br>构建器模式允许你按需设置字段，而不需要为每个字段组合创建多个构造函数。</p>
</li>
<li><p>生成的构建器类：<br>Lombok 会自动生成一个静态内部类 EmployeeLoginVOBuilder，包含所有字段的设置方法和一个 build 方法。</p>
<ul>
<li>设置字段：<br>你可以按需调用构建器的设置方法来设置字段值，例如 id(1L)、userName(“john_doe”) 等。</li>
<li>构建对象：<br>最后调用 build 方法来创建 EmployeeLoginVO 对象。</li>
</ul>
</li>
</ul>
<pre><code class="java"> // 使用构建器创建 EmployeeLoginVO 对象
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(1L)
                .userName(&quot;john_doe&quot;)
                .name(&quot;John Doe&quot;)
                .token(&quot;eyJhbGciOiJIUzI1NiJ9...&quot;)
                .build();

        System.out.println(employeeLoginVO);
</code></pre>
<p>@<strong>NoArgsConstructor</strong>：<br>作用：生成一个无参构造函数。<br>效果：自动生成一个不带任何参数的构造函数。</p>
<p>@<strong>AllArgsConstructor</strong>：<br>作用：生成一个全参构造函数。<br>效果：自动生成一个包含所有字段的构造函数。</p>
</blockquote>
<p><span style = "color:orange"><strong>详细解析@GetMapping 与 @PostMapping</strong></span></p>
<blockquote>
<p>选择使用 @GetMapping 还是 @PostMapping 主要取决于Http请求的性质和用途<br><strong>@GetMapping</strong></p>
<p>作用：</p>
<ul>
<li><p>@GetMapping专门用于处理HTTP GET请求</p>
</li>
<li><p>GET请求通常用于从服务器获取资源，不会对服务器上的数据进行修改</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数通常附加在URL中 <code>@GetMapping(&quot;/xxx/&#123;id&#125;&quot;)</code> 底下会跟 <code>@PathVariable</code></li>
<li>请求是安全的不会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>查询数据：获取<strong>用户列表、搜索结果</strong></li>
<li>获取静态资源：图片、css文件</li>
<li>获取单个资源：获取某个用户的详细信息</li>
</ul>
<p>@<strong>PostMapping</strong></p>
<p>作用：</p>
<ul>
<li>@PostMapping专门用于处理HTTP POST请求</li>
<li>POST请求通常用于向服务器发送数据，可能会对服务器上的数据进行修改</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数放在请求体中，不会显示在URL这种 <code>@PostMapping(&quot;/users&quot;)</code>底下会跟<code>@RequestBody</code></li>
<li>请求体的大小没有固定限制，可以发送大量数据</li>
<li>多次相同的POST请求可能会产生不同的结果，可能会修改服务器状态</li>
<li>请求是不安全的，可能会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>创建新资源：注册新用户、添加新订单</li>
<li>更新现有资源：修改用户信息、更新订单状态</li>
<li>发送表单数据：登录、提交评论</li>
<li>上传文件：图片、文档</li>
</ul>
</blockquote>
<blockquote>
<p>以下是一些可能的原因，解释了为什么您看到的前端项目代码不是“正经的网页代码”：</p>
<ul>
<li><strong>构建过程</strong>：现代前端项目通常有一个构建过程，使用工具如Webpack、Rollup或Parcel等将源代码转换和打包。原始的代码可能在<code>src</code>目录中，而您看到的是构建后的<code>dist</code>目录，其中包含了转换和压缩后的文件。</li>
<li><strong>模块化和组件化</strong>：前端框架和库鼓励开发者将UI拆分成可复用的模块和组件。这意味着不再有传统的HTML、CSS和JavaScript混合在一起的代码，而是分别在不同的文件中定义。</li>
<li><strong>框架和库的使用</strong>：现代前端开发往往依赖于各种框架和库，这些框架和库有自己的文件结构和编写方式，可能和您熟悉的传统网页代码写法有很大不同。</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>根据@PutMapping(“&#x2F;{Id}”)提问</strong></span></p>
<h6 id="我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢"><a href="#我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢" class="headerlink" title="我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢"></a>我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢</h6><blockquote>
<p>在RESTful API设计中，资源通常通过其唯一标识符（如ID）来访问和操作。<code>@PutMapping(&quot;/&#123;id&#125;&quot;)</code>使用<code>&#123;id&#125;</code>作为路径变量是因为ID是数据库中记录的唯一标识，这使得通过ID查找和更新特定的记录变得直接和高效。</p>
<p>如果你想要通过<code>name</code>来查询和更新记录，这在理论上是可行的，但需要注意以下几点：</p>
<ol>
<li><code>name</code>字段可能不是唯一的，这意味着可能有多条记录具有相同的名称。</li>
<li>使用非唯一字段作为更新依据可能会导致数据不一致或错误更新。</li>
</ol>
</blockquote>
<p><span style = "color:orange"><strong>更新员工 前后端联调原理</strong></span></p>
<pre><code class="javascript">★ 在前端使用Ajax与后端URL对应时，你需要确保Ajax请求的URL与后端控制器中定义的映射相匹配。在你提供的例子中，后端使用@PutMapping(&quot;/&#123;id&#125;&quot;)来定义更新员工信息的端点，因此前端的Ajax URL应该包含员工的ID

// 绑定更新按钮的点击事件
$(&#39;#updateBtn&#39;).click(function() &#123;
    var employee = &#123;
        id: $(&#39;#id&#39;).val(), // 假设这是员工的唯一标识符
        name: $(&#39;#name&#39;).val(),
        email: $(&#39;#email&#39;).val(),
        department: $(&#39;#department&#39;).val()
    &#125;;

    // 发起Ajax PUT请求，URL中包含员工的ID
    $.ajax(&#123;
        url: `/api/employees/$&#123;employee.id&#125;`, // 注意这里的URL与后端的@PutMapping(&quot;/&#123;id&#125;&quot;)对应
        type: &#39;PUT&#39;,
        contentType: &#39;application/json&#39;, // 指定发送给服务器的数据类型
        data: JSON.stringify(employee), // 将JavaScript对象转换为JSON字符串
        success: function(response) &#123;
            // 请求成功，可以在这里处理响应数据
            alert(&#39;Employee information updated successfully!&#39;);
            // 如果需要，可以在这里更新页面上的表单数据
        &#125;,
        error: function(xhr, status, error) &#123;
            // 请求失败，可以在这里处理错误信息
            alert(&#39;Error updating employee information: &#39; + xhr.responseText);
        &#125;
    &#125;);
&#125;);

//在这个例子中，employee.id是从表单中获取的员工ID，它被拼接到URL字符串中，以形成完整的请求URL。这个URL应该与后端控制器中定义的@PutMapping(&quot;/&#123;id&#125;&quot;)相对应。当点击更新按钮时，Ajax请求会被发送到后端，后端会根据提供的ID找到对应的员工记录并进行更新。
</code></pre>
<pre><code class="java"> @PutMapping(&quot;/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) &#123;
        Employee employee = employeeService.getEmployeeById(id);
        if (employee != null) &#123;
            employee.setName(employeeDetails.getName());
            employee.setEmail(employeeDetails.getEmail());
            employee.setDepartment(employeeDetails.getDepartment());
            Employee updatedEmployee = employeeService.updateEmployee(employee);
            return ResponseEntity.ok(updatedEmployee);
        &#125; else &#123;
            return ResponseEntity.notFound().build();
        &#125;
    &#125;
&#125;
//这里&#123;id&#125;是路径变量，它会匹配Ajax请求URL中的employee.id。这样，前后端的URL就正确对应起来了。
</code></pre>
<h3 id="新增员工-Post-Json提交格式"><a href="#新增员工-Post-Json提交格式" class="headerlink" title="新增员工(Post+Json提交格式)"></a>新增员工(Post+Json提交格式)</h3><h4 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h4><h6 id="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"><a href="#账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456" class="headerlink" title="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"></a>账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456</h6><p><strong>本项目约定</strong>：</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用 <strong>&#x2F;admin</strong> 作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用 <strong>&#x2F;user</strong> 作为前缀</li>
</ul>
<h4 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h4><p>根据新增员工接口设计对应的DTO<br>注意：当前提交的数据和实体类中对应的属性差别比较大时，建议使用DTO(数据传输)来封装数据</p>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeDTO.java
package com.sky.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class EmployeeDTO implements Serializable &#123;

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 新增员工
     * @param employeeDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增员工&quot;)
    public Result save(@RequestBody  EmployeeDTO employeeDTO)&#123;
    // 因为是JSON格式 要加@RequestBody
        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);
        employeeService.save(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
package com.sky.service;

import com.sky.dto.EmployeeDTO;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;

public interface EmployeeService &#123;

    /**
     * 员工登录
     * @param employeeLoginDTO
     * @return
     */
    Employee login(EmployeeLoginDTO employeeLoginDTO);

    /**
     * 新增员工
     * @param employeeDTO
     */
    void save(EmployeeDTO employeeDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        //employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setUpdateUser(10L);

        employeeMapper.insert(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/Employee.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;

    private Integer status;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;

    private Long createUser;

    private Long updateUser;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
 * 插入员工数据
*/
    @Insert(&quot;insert into employee (name,username,password,phone,sex,id_number,create_time,update_time,create_user,update_user))&quot; +
            &quot;values&quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    void insert(Employee employee);
</code></pre>
<p><span style = "color:orange"><strong>@Builder 和 @JsonFormat</strong></span></p>
<blockquote>
<p>@Builder 是 Lombok 提供的一个注解，用于自动生成构建器模式的代码。<br>它会在编译时生成一个静态的 Builder 类和相关的方法，使得对象的创建更加灵活和可读。<br>需要<strong>创建不可变对象</strong>时，可以使用 @Builder 结合 @Value 注解。<br>需要<strong>创建复杂的对象</strong>时，可以通过构建器模式逐步设置属性，提高代码的可读性和可维护性</p>
<p>@JsonFormat 是 Jackson 库提供的注解，用于指定日期时间字段在 JSON 序列化和反序列化时的格式。<br>通过设置 pattern 属性，可以控制日期时间字段的格式化方式。<br>当需要将 LocalDateTime、Date 等日期时间类型的字段转换为特定格式的字符串时。<br>在 RESTful API 中，返回的 JSON 数据需要符合特定的日期时间格式要求。</p>
<h6 id="使用-Builder-的场景"><a href="#使用-Builder-的场景" class="headerlink" title="使用 @Builder 的场景"></a>使用 @Builder 的场景</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用 @Builder 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(employee);
    &#125;
&#125;
</code></pre>
<h6 id="使用-JsonFormat-的场景"><a href="#使用-JsonFormat-的场景" class="headerlink" title="使用 @JsonFormat 的场景"></a>使用 @JsonFormat 的场景</h6><pre><code class="java">//创建 RESTful API
Employee里面的pojo就不详细写了
    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;
==========================================================================

@RestController
public class EmployeeController &#123;

    @GetMapping(&quot;/employee&quot;)
    public ResponseEntity&lt;String&gt; getEmployee() throws Exception &#123;
        // 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        // 使用 ObjectMapper 将 Employee 对象转换为 JSON 字符串
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(employee);

        return ResponseEntity.ok(json);
    &#125;
&#125;
===========================================================================
// 除了 @JsonFormat 注解，还有其他方式可以指定日期时间格式，具体取决于你的需求和使用的库。
 public static void main(String[] args) &#123;
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String formattedDateTime = now.format(formatter);

        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(now)
                .updateTime(now)
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(&quot;Formatted Create Time: &quot; + formattedDateTime);
        System.out.println(&quot;Formatted Update Time: &quot; + formattedDateTime);
    &#125;
</code></pre>
<p>@<strong>Builder</strong>：<br>通过 Employee.builder() 创建了一个构建器对象。<br>使用链式调用设置各个属性，最后调用 build() 方法生成 Employee 实例。<br>这种方式使得创建对象的代码更加简洁和易读，特别是当对象属性较多时。</p>
<p>@<strong>JsonFormat</strong>：<br>在 createTime 和 updateTime 字段上使用了 @JsonFormat 注解，指定了日期时间的格式为 “yyyy-MM-dd HH:mm:ss”。<br><u><strong>当 Employee 对象被转换为 JSON 字符串</strong></u>时，这两个字段会被格式化为指定的日期时间格式。<br>这样可以确保返回的 JSON 数据符合预期的格式要求。</p>
</blockquote>
<p><span style = "color:orange"><strong>RESTful风</strong></span></p>
<blockquote>
<p><strong>可缓存性：</strong><br>RESTful API 可以利用 HTTP 缓存机制，减少网络请求，提高性能。<br>客户端可以缓存响应，减少服务器的负载。</p>
<p>易于集成：<br>RESTful API 使用标准的 HTTP 协议，几乎所有的编程语言和框架都支持 HTTP 请求。<br>这使得不同系统之间的集成变得更加容易。</p>
<p>可读性强：<br>RESTful API 的 URL 设计通常非常直观，易于理解和记忆。<br>例如，&#x2F;users&#x2F;123 表示用户 ID 为 123 的资源，&#x2F;users&#x2F;123&#x2F;orders 表示该用户的订单资源。</p>
<p>灵活性：<br>RESTful API 支持多种数据格式（如 JSON、XML 等），可以根据需要选择合适的格式。<br>客户端和服务器可以通过协商确定数据格式，提高了灵活性。</p>
<p>  GET &#x2F;users<br>  GET &#x2F;users&#x2F;{id}<br>  POST &#x2F;users<br>  PUT &#x2F;users&#x2F;{id}</p>
</blockquote>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><h6 id="功能测试方式："><a href="#功能测试方式：" class="headerlink" title="功能测试方式："></a>功能测试方式：</h6><ul>
<li>通过接口文档测试</li>
<li>通过前后端联调测试</li>
</ul>
<p>注意：由于开发阶段前后端是并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主</p>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/documentManager/GlobalParameters-default">http://localhost:8080/doc.html#/documentManager/GlobalParameters-default</a>)</p>
<p><span style = "color:red">首先要拿到<strong>JWT令牌</strong>(去接口进行一次登录测试后会有) → 全局参数设置 → 添加参数</span><br><strong>注意</strong>：这个jwt→json是有有效期的(2小时&#x3D;7200000秒)</p>
<pre><code class="xml">sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
</code></pre>
<blockquote>
<p>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: {<br>    “id”: 1,<br>    “userName”: “admin”,<br>    “name”: “管理员”,<br>    “token”: “eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc”<br>  }<br>}</p>
<hr>
<p>新增参数：<br>  参数名称：token<br>  参数值：eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc<br>  参数类型：header</p>
<p>新增员工接口<br>{<br>  “idNumber”: “1321321312”,<br>  “name”: “张三”,<br>  “phone”: “11111111111”,<br>  “sex”: “1”,<br>  “username”: “zhangsan”<br>}</p>
<p>响应内容：<br>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component  //将该类注册为 Spring 管理的 Bean。
@Slf4j //使用 Lombok 自动生成日志记录器
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;
// 包含 JWT 相关的配置属性，如令牌名称和密钥
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
//检查当前拦截到的是否是 Controller 的方法。如果不是，直接放行
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/properties/JwtProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)
@Data
public class JwtProperties &#123;

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;
&#125;
</code></pre>
<h4 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h4><h6 id="程序存在的问题："><a href="#程序存在的问题：" class="headerlink" title="程序存在的问题："></a>程序存在的问题：</h6><ul>
<li>录入的用户名已存在，抛出异常后没有处理</li>
<li>新增员工时，创建人id和修改人id设置了固定值</li>
</ul>
<blockquote>
<p>当你在 Maven 中执行 compile 命令时，它会强制 Maven 重新编译整个项目，包括所有的类和资源。这一过程会清除任何旧的编译结果，确保所有的依赖和代码都是最新的。这可能导致以下几种情况，从而解决了你的问题：</p>
<p>**<u>重新编译：</u>**Maven 会重新编译所有的源代码，包括你修改或新增的类，这样就能解决因为旧的编译缓存而引起的引用问题。<br>**<u>更新依赖：</u>**如果你在项目中添加或修改了依赖，执行 compile 可以确保这些依赖被正确加载和引用。<br><u><strong>清理旧缓存</strong>：</u>在编译过程中，Maven 会清理旧的缓存和临时文件，避免由于这些文件造成的潜在冲突。<br>**<u>IDE 同步：</u>**有时候，IDE 的状态可能与 Maven 项目状态不一致，执行 Maven 命令可以帮助 IDE 重新同步项目的状态。</p>
</blockquote>
<h6 id="问题①"><a href="#问题①" class="headerlink" title="问题①"></a>问题①</h6><pre><code class="java">sky-server  com/sky/handler/GlobalExceptionHandler.java
package com.sky.handler;

import com.sky.constant.MessageConstant;
import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器，处理项目中抛出的业务异常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler &#123;

    /**
     * 捕获业务异常
     * @param ex
     * @return
     */
    @ExceptionHandler
    public Result exceptionHandler(BaseException ex)&#123;
        log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage());
        return Result.error(ex.getMessage());
    &#125;

    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) &#123;
        String message = ex.getMessage();
        if (message.contains(&quot;Duplicate entry&quot;)) &#123;
            // Duplicate entry &#39;zhangsan&#39; for key &#39;employee.idx_username&#39;
// 在这里，我们使用 split(&quot;&#39;&quot;) 将字符串分割为多个部分。这样，parts[1] 将得到 zhangsan，因为它位于单引号之间。这种方式可以正确提取用户名。
            String[] split = message.split(&quot;&#39;&quot;);
            String username = split[1];
//            String msg = username + &quot;已存在&quot;;
            String msg = username + MessageConstant.ALREADY_EXISTS;
            return Result.error(msg);
        &#125;else &#123;
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>Split的深入学习</strong></span></p>
<blockquote>
<ul>
<li><strong>正则表达式</strong></li>
</ul>
<p>split 方法接受一个<strong>正则表达式</strong>作为参数，因此分隔符可以是复杂的模式，而不仅仅是单个字符。<br>例如，<strong>split(“\s+”)</strong> 可以用来按一个或多个空白字符（包括空格、制表符、换行符等）进行分割。</p>
<ul>
<li><strong>限制分割次数</strong></li>
</ul>
<p>split 方法还有一个重载版本 split(String regex, int limit)，可以限制分割的次数。<br>例如，split(“‘“, 3) 只会进行两次分割，结果数组最多包含三个元素。</p>
</blockquote>
<h3 id="问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal"><a href="#问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal" class="headerlink" title="问题②  解析出员工登录id后，如何转递给Service的save方法？→ ThreadLocal"></a>问题②  <span style = "color:orange"><strong>解析出员工登录id后，如何转递给Service的save方法？</strong></span>→ <span style = "color:red">ThreadLocal</span></h3><img src="https://raw.githubusercontent.com/P-luminary/images/2dd9f9e12ba173719123c685949c277632af5ce4/data/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%99%BB%E5%BD%95%E5%8F%8A%E6%A0%A1%E9%AA%8C.jpg" style="zoom:150%;" />

<h6 id="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："><a href="#前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：" class="headerlink" title="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："></a>前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：</h6><pre><code class="java">        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
</code></pre>
<h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>ThreadLocal并不是一个Thread，Thread的局部变量<br><strong>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获得到对应的值，线程外则不能访问</strong></p>
<pre><code class="java">sky-common  com/sky/context/BaseContext.java
package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            BaseContext.setCurrentId(empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
//        employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
//        employee.setCreateUser(10L);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        employee.setCreateUser(BaseContext.getCurrentId());
        employee.setUpdateUser(BaseContext.getCurrentId());
    
        employeeMapper.insert(employee);
    &#125;

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如果想单独针对22行代码 测试部分的值是多少 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
// 左键选中&#39;BaseContext.getCurrentId()&#39; 右键Evaluate Expression单独计算即可
</code></pre>
<p><span style = "color:orange"><strong>将员工登录ID放在 ThreadLocal 中的原因</strong></span></p>
<blockquote>
<p>在多线程环境中，使用 ThreadLocal 来存储和传递员工的完整信息是一个常见的做法。这样可以确保每个线程都有独立的变量副本，避免并发问题。以下是一些步骤和最佳实践，帮助你在 ThreadLocal 中安全地传递和存储员工的完整信息。<br>ThreadLocal 主要用于在同一个线程内传递和存储数据，确保每个线程都有独立的变量副本。在你的例子中，ThreadLocal 用于存储员工ID，确保在多线程环境下员工ID的安全传递。</p>
<ul>
<li><strong>线程隔离</strong>：ThreadLocal 确保每个线程都有独立的员工ID副本，避免了多线程环境下的并发问题。<br>防止篡改：<u><strong>只有当前线程可以访问和修改 ThreadLocal 中的员工ID</strong></u>，其他线程无法访问，确保了ID的安全性。</li>
<li><strong>员工其他信息的安全性</strong><br><u>数据库查询</u>：员工的其他信息是从数据库中查询的，而不是从 ThreadLocal 中获取的。数据库查询本身是安全的，只要数据库连接和查询操作是安全的。<br><u>权限控制</u>：确保只有经过认证的用户才能执行查询操作，防止未授权访问。<br><u>数据加密</u>：敏感信息（如密码）在存储和传输过程中应进行加密，确保数据的安全性。</li>
</ul>
<p><strong>线程安全</strong>：<br>ThreadLocal 为每个线程提供独立的变量副本，避免了多线程环境下的并发问题。每个线程都可以安全地读取和修改自己的 ThreadLocal 变量，而不会影响其他线程。</p>
<p><strong>简化代码</strong>：<br>在 Web 应用中，通常需要在多个方法或组件之间传递用户身份信息（如员工登录ID）。使用 ThreadLocal 可以避免在每个方法调用中显式传递这些信息，从而简化代码。</p>
<p><strong>全局访问</strong>：<br>在同一个线程内，任何地方都可以访问 ThreadLocal 中存储的值，这使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
<p><strong>避免传递参数</strong>：<br>在多层调用中，如果需要传递员工登录ID，通常需要在每个方法签名中添加相应的参数。使用 ThreadLocal 可以避免这种繁琐的参数传递，提高代码的可读性和可维护性。</p>
<pre><code class="java">// 设置员工登录ID：
在用户登录成功后，将员工登录ID设置到 ThreadLocal 中。
@PostMapping(&quot;/login&quot;)
public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequest loginRequest) &#123;
    // 验证用户名和密码
    User user = userService.validateUser(loginRequest.getUsername(), loginRequest.getPassword());
    if (user != null) &#123;
        // 设置当前线程的员工登录ID
        BaseContext.setCurrentId(user.getId());
        // 返回登录成功信息
        return ResponseEntity.ok(&quot;Login successful&quot;);
    &#125; else &#123;
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(&quot;Invalid username or password&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 获取员工登录ID
在需要使用员工登录ID的地方，直接从 ThreadLocal 中获取
@Service
public class OrderService &#123;

    public void createOrder(Order order) &#123;
        Long currentUserId = BaseContext.getCurrentId();
        if (currentUserId != null) &#123;
            order.setCreatedBy(currentUserId);
            orderRepository.save(order);
        &#125; else &#123;
            throw new RuntimeException(&quot;User ID not found in context&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>将员工登录ID放在 ThreadLocal 中，可以确保每个线程都有独立的变量副本，避免多线程环境下的并发问题。同时，这种方式简化了代码，提供了全局访问的能力，避免了繁琐的参数传递，使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
</blockquote>
<h3 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h3><h5 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则：-查询-→-get"><a href="#业务规则：-查询-→-get" class="headerlink" title="业务规则：(查询 → get)"></a>业务规则：(查询 → get)</h6><ul>
<li>根据页码展示员工信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要，输入员工姓名进行查询</li>
</ul>
<h5 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h5><h6 id="根据分页查询接口设计对应的DTO"><a href="#根据分页查询接口设计对应的DTO" class="headerlink" title="根据分页查询接口设计对应的DTO:"></a>根据分页查询接口设计对应的DTO:</h6><p><strong>Query</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>是否必须</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>否</td>
<td>张三</td>
<td>员工姓名</td>
</tr>
<tr>
<td>page</td>
<td>是</td>
<td>1</td>
<td>页码</td>
</tr>
<tr>
<td>pageSize</td>
<td>是</td>
<td>10</td>
<td>每页记录数</td>
</tr>
</tbody></table>
<pre><code class="java">@Data
public class EmployeePageQueryDTO implements Serializable&#123;
    private String name;
    private int page;
    private int pageSize;
&#125;
</code></pre>
<h6 id="后面所有的分页查询，统一都封装成PageResult对象"><a href="#后面所有的分页查询，统一都封装成PageResult对象" class="headerlink" title="后面所有的分页查询，统一都封装成PageResult对象"></a>后面所有的分页查询，统一都封装成PageResult对象</h6><pre><code class="java">/*封装分页查询结果*/
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable&#123;
    private long total; 
    private List records;
&#125;
</code></pre>
<h6 id="员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt"><a href="#员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt" class="headerlink" title="员工信息分页查询后端返回的对象类型为：Result &lt; PageResult &gt;"></a>员工信息分页查询后端返回的对象类型为：<strong>Result &lt; PageResult &gt;</strong></h6><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;
        //格式不是JSON不用加 @RequestBody
        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;
        // select * from employee limit 0,10
        // 开始分页查询 动态拼接
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        Page&lt;Employee&gt; page =  employeeMapper.pageQuery(employeePageQueryDTO);

        long total = page.getTotal();
        List&lt;Employee&gt; records = page.getResult();

        return new PageResult(total, records);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>逐行研究分页查询</strong></span></p>
<blockquote>
<ul>
<li><p>PageHelper.startPage 是 MyBatis 分页插件提供的方法，用于开启分页功能</p>
<ul>
<li><p>employeePageQueryDTO.getPage() 获取当前页码。</p>
</li>
<li><p>employeePageQueryDTO.getPageSize() 获取每页显示的记录数</p>
<p>这一行代码的作用是告诉 MyBatis 在接下来的查询中启用分页，并设置分页参数</p>
</li>
</ul>
</li>
<li><p>employeeMapper.pageQuery(employeePageQueryDTO) 是调用 MyBatis 的 Mapper 接口方法，执行分页查询。</p>
<ul>
<li>employeePageQueryDTO 包含了查询条件，如关键字、排序字段等。</li>
<li>查询结果会被封装成 Page<Employee> 对象，其中包含了分页数据和分页元数据。</li>
</ul>
</li>
<li><p>page.getTotal() 获取分页查询的总记录数。</p>
<ul>
<li>总记录数用于计算总页数和其他分页相关的计算</li>
</ul>
</li>
<li><p>List<Employee> records &#x3D; page.getResult();</p>
<ul>
<li>page.getResult() 获取分页查询的实际数据列表。</li>
<li>这个列表包含了当前页的员工记录</li>
</ul>
</li>
<li><p>return new PageResult(total, records);</p>
</li>
<li><p>new PageResult(total, records) 创建一个新的 PageResult 对象，将总记录数和分页数据列表封装起来</p>
</li>
<li><p>PageResult 类通常包含 total 和 records 属性，用于返回给客户端</p>
</li>
<li><p>假设 employeePageQueryDTO.getPage() 返回 2，employeePageQueryDTO.getPageSize() 返回 10，那么 MyBatis 生成的 SQL 可能类似于：</p>
</li>
</ul>
<pre><code class="mysql">SELECT * FROM employee
WHERE ... -- 根据 employeePageQueryDTO 中的查询条件
LIMIT 10 OFFSET 10;
</code></pre>
<p>LIMIT 10：表示每页显示 10 条记录。<br>OFFSET 10：表示从第 11 条记录开始（因为页码从 1 开始，所以第 2 页的偏移量是 10）。</p>
<ul>
<li><p><strong>PageResult 类</strong>：用于封装分页查询的结果，包括总记录数和当前页的数据集合。<br>使用场景：在分页查询服务中，将查询结果封装为 PageResult 对象，通过控制器返回给客户端。</p>
</li>
<li><p><strong>Serializable 接口</strong>：是 Java 中的一个标记接口，没有定义任何方法。实现 Serializable 接口的类的对象可以被序列化，即将对象的状态转换为字节流，以便在网络上传输或持久化存储。反序列化则是将字节流恢复为对象的过程。 </p>
<ul>
<li><strong>序列化</strong></li>
</ul>
<p><u>对象状态转换</u>：将对象的状态（即对象的字段值）转换为字节流。<br>默认序列化机制：Java 提供了默认的序列化机制，通过 ObjectOutputStream 类的 writeObject 方法实现。<br><u>自定义序列化</u>：可以通过实现 writeObject 和 readObject 方法来自定义序列化和反序列化过程。</p>
<ul>
<li><strong>持久化</strong></li>
</ul>
<p>持久化：序列化的主要目的是将对象的状态保存到存储介质中，或者通过网络传输对象。</p>
</li>
</ul>
<p>查询结果会被封装到 PageResult 对象中，其中 total 表示总记录数，records 表示当前页的数据集合。</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="xml">sky-server  mapper/EmployeeMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;
        select * from employee
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
        &lt;/where&gt;
        order by create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
&lt;!--
and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)：
如果条件成立，生成的 SQL 条件为 AND name LIKE &#39;%$&#123;name&#125;%&#39;，实现名称的模糊匹配
--&gt;
</code></pre>
<p>[员工管理] (<a target="_blank" rel="noopener" href="http://localhost/#/employee">http://localhost/#/employee</a>)</p>
<h5 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h5><h6 id="问题：创建-x2F-更新时间那边传入的数据不是想要的"><a href="#问题：创建-x2F-更新时间那边传入的数据不是想要的" class="headerlink" title="问题：创建&#x2F;更新时间那边传入的数据不是想要的"></a>问题：创建&#x2F;更新时间那边传入的数据不是想要的</h6><pre><code class="java">// 2024929214237
&quot;createTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
        &quot;updateTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
</code></pre>
<h6 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h6><ul>
<li><p><strong>方法一</strong>：在属性上加注解，对日期进行格式化<del>(只能处理单独一个属性)</del></p>
<pre><code class="java">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
private LocalDateTime updateTime;
------------------------------------------------------------------------
 &quot;createTime&quot;: &quot;2024-09-29 22:10:37&quot;,
</code></pre>
</li>
<li><p><strong>方法二</strong>：在<code>WebMvcConfiguration</code>中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理</p>
</li>
</ul>
<blockquote>
<p>重写父类方法 去扩展 消息转换器</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
 /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
</code></pre>
<pre><code class="java">package com.sky.json;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper &#123;

    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    public JacksonObjectMapper() &#123;
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    &#125;
&#125;
</code></pre>
<h3 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h3><h5 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则："><a href="#业务规则：" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以对状态为 “启用” 的员工账号进行 “禁用” 操作</li>
<li>可以对状态为 “禁用” 的员工账号进行 “启用” 操作</li>
<li>状态为 “禁用” 的员工账号不能登录系统</li>
</ul>
<pre><code class="java">sky-server
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用员工账号&quot;)
    //因为上面的和下面的参数都是一致 不然需要@PathVariable(&quot;status&quot;)解释一下
    public Result startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id) &#123;
        log.info(&quot;启用禁用员工账号: &#123;&#125;,&#123;&#125;&quot;,status,id);
        employeeService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
 /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        // update employee set status = ? where id = ?
        Employee employee = new Employee();
        employee.setStatus(status);
        employee.setId(id);

/** 要在Employee.java中添加@Builder 才能使用这种风格
 *      Employee employee = Employee.builder()
 *              .status(status)
 *              .id(id)
 *              .build();
 */
        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);
</code></pre>
<pre><code class="java">sky-server  mapper/EmployeeMapper.xml
&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;
        update employee
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;
            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;
            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;
            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;
            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;
            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h3><h4 id="需求分析和设计-回写数据"><a href="#需求分析和设计-回写数据" class="headerlink" title="需求分析和设计[回写数据]"></a>需求分析和设计[回写数据]</h4><h6 id="编辑员工功能涉及到两个接口："><a href="#编辑员工功能涉及到两个接口：" class="headerlink" title="编辑员工功能涉及到两个接口："></a>编辑员工功能涉及到两个接口：</h6><ul>
<li>根据id查询员工信息</li>
<li>编辑员工信息</li>
</ul>
<h4 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h4><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;编辑员工信息&quot;)
    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;
        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);
        employeeService.update(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    Employee getById(Long id);

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    void update(EmployeeDTO employeeDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    public Employee getById(Long id) &#123;
        Employee employee = employeeMapper.getById(id);
        employee.setPassword(&quot;****&quot;);
        return employee;
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    public void update(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO, employee);

        //employee.setUpdateTime(LocalDateTime.now());
        //employee.setUpdateUser(BaseContext.getCurrentId());

        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);

    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)
    Employee getById(Long id);
</code></pre>
<blockquote>
<ul>
<li>前端提交表单：<br>用户在前端页面编辑员工信息并提交表单。<br>表单数据被序列化为 JSON 格式，通过 HTTP PUT 请求发送到后端。</li>
<li>后端接收数据：<br>控制器方法 update 接收到 EmployeeDTO 对象。<br>记录日志，输出接收到的员工信息。<br>调用服务层的 update 方法，处理员工信息的更新。</li>
<li>服务层处理：<br>创建一个新的 Employee 对象。<br>使用 BeanUtils.copyProperties 将 EmployeeDTO 的属性复制到 Employee 对象中。<br>调用 MyBatis 的 employeeMapper，执行更新操作。</li>
<li>MyBatis 更新操作：<br>生成动态 SQL 语句，只更新传入的非 null 属性。<br>例如，如果 name 和 phone 不为 null，生成的 SQL 语句如下：</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>数据回写的具体过程</strong></span></p>
<blockquote>
<ul>
<li>前端请求获取员工信息   &#x2F;&#x2F; 根据id查询员工信息<br>当你点击编辑按钮时，前端会发起一个 HTTP GET 请求，从后端获取员工的详细信息。这些信息将被用来填充表单字段。</li>
<li>后端处理 GET 请求<br>后端需要提供一个接口来处理这个 GET 请求，并返回员工的详细信息。</li>
<li>前端处理响应并填充表单<br>前端接收到后端返回的员工信息后，将其填充到表单字段中</li>
</ul>
<pre><code class="java">/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;&#123;/id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id) &#123;
        log.info(&quot;根据id查询员工信息：&#123;&#125;&quot;, id);
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;
</code></pre>
<pre><code class="vue">&lt;script&gt;export default &#123;
  data() &#123;
    return &#123;
      employee: &#123;
        id: null,
        name: &#39;&#39;,
        username: &#39;&#39;,
        password: &#39;&#39;,
        phone: &#39;&#39;,
        sex: &#39;&#39;,
        idNumber: &#39;&#39;
      &#125;
    &#125;;
  &#125;,
  methods: &#123;
    async fetchEmployee(id) &#123;
      try &#123;
        const response = await this.$axios.get(`/employees/$&#123;id&#125;`);
        this.employee = response.data.data;
      &#125; catch (error) &#123;
        console.error(&#39;获取员工信息失败&#39;, error);
      &#125;
    &#125;,
    async updateEmployee() &#123;
      try &#123;
        await this.$axios.put(&#39;/employees&#39;, this.employee);
        alert(&#39;员工信息更新成功&#39;);
      &#125; catch (error) &#123;
        console.error(&#39;更新员工信息失败&#39;, error);
      &#125;
    &#125;
  &#125;,
  mounted() &#123;
    const id = this.$route.params.id; // 假设通过路由参数传递员工ID
    this.fetchEmployee(id);
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>提交表单<br>当用户编辑完表单并点击保存按钮时，前端会发起一个 HTTP PUT 请求，将更新后的员工信息发送到后端进行处理</li>
</ul>
<p><strong>总结</strong><br>前端请求获取员工信息：点击编辑按钮时，前端发起 GET 请求获取员工的详细信息。<br>后端处理 GET 请求：后端提供一个接口处理 GET 请求，返回员工的详细信息。<br>前端处理响应并填充表单：前端接收到员工信息后，将其填充到表单字段中。<br>提交表单：用户编辑完表单并点击保存按钮，前端发起 PUT 请求，将更新后的员工信息发送到后端进行处理。</p>
</blockquote>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/%E5%91%98%E5%B7%A5%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/updateUsingPUT">http://localhost:8080/doc.html#/default/员工相关接口/updateUsingPUT</a>)</p>
<h4 id="导入分类管理功能代码"><a href="#导入分类管理功能代码" class="headerlink" title="导入分类管理功能代码"></a>导入分类管理功能代码</h4><h6 id="业务规则：-1"><a href="#业务规则：-1" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>分类名称必须是<strong>唯一</strong>的</li>
<li>分类按章类型可分为<strong>菜品分类</strong>和<strong>套餐分类</strong></li>
<li>新添加的分类状态默认认为 “<strong>禁用</strong>“</li>
</ul>
<h6 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>新增分类</li>
<li>分类分页查询</li>
<li>根据id删除分类</li>
<li>修改分类</li>
<li>启用禁止分类</li>
<li>根据类型调查分类</li>
</ul>
<p><strong>数据库设计(category表)</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/CategoryController.java
package com.sky.controller.admin;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

/**
 * 分类管理
 */
@RestController
@RequestMapping(&quot;/admin/category&quot;)
@Api(tags = &quot;分类相关接口&quot;)
@Slf4j
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param categoryDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增分类&quot;)
    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;
        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);
        categoryService.save(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 分类分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分类分页查询&quot;)
    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;
        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 删除分类
     * @param id
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;删除分类&quot;)
    public Result&lt;String&gt; deleteById(Long id)&#123;
        log.info(&quot;删除分类：&#123;&#125;&quot;, id);
        categoryService.deleteById(id);
        return Result.success();
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改分类&quot;)
    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;
        categoryService.update(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用分类&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;
        categoryService.startOrStop(status,id);
        return Result.success();
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据类型查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);

        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人
        category.setUpdateTime(LocalDateTime.now());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status)
                .updateTime(LocalDateTime.now())
                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;
        select * from category
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                and type = #&#123;type&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by sort asc , create_time desc
    &lt;/select&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;
        update category
        &lt;set&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                type = #&#123;type&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;sort != null&quot;&gt;
                sort = #&#123;sort&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;
        select * from category
        where status = 1
        &lt;if test=&quot;type != null&quot;&gt;
            and type = #&#123;type&#125;
        &lt;/if&gt;
        order by sort asc,create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

&#125;
</code></pre>
<h2 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h2><h4 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h4><p>业务表中的公共字段：(后期会很多[菜品&#x2F;套餐管理])</p>
<h6 id="问题：代码冗余不利于后期维护"><a href="#问题：代码冗余不利于后期维护" class="headerlink" title="问题：代码冗余不利于后期维护"></a>问题：代码冗余不利于后期维护</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
</tr>
</tbody></table>
<h6 id="解决：技术点-→-枚举、注解、AOP、反射"><a href="#解决：技术点-→-枚举、注解、AOP、反射" class="headerlink" title="解决：技术点 → 枚举、注解、AOP、反射"></a>解决：技术点 → 枚举、注解、AOP、反射</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
<th>操作类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
<td>insert</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
<td>insert</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
<td>insert、update</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
<td>insert、update</td>
</tr>
</tbody></table>
<ul>
<li>自定义注解 <strong>AutoFill</strong>，用于标识需要进行公共字段自动填充的方法</li>
<li>自定义切面 <strong>AutoFillAspect</strong>，统一拦截加入了 <strong>AutoFill</strong> 注解的方法，通过反射为公共字段赋值</li>
<li>在 <strong>Mapper</strong> 的方法上加入 <strong>AutoFill</strong> 注解</li>
</ul>
<h4 id="代码开发1"><a href="#代码开发1" class="headerlink" title="代码开发1"></a>代码开发1</h4><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill &#123;
// 枚举数据库操作类型：UPDATE INSERT [只要在这情况才有必要设置]
    OperationType value();
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
//只在update和insert里加
@Mapper
public interface EmployeeMapper &#123;
 /**
     * 插入员工数据
     * @param employee
     */
    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +
            &quot;values &quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    @AutoFill(value = OperationType.INSERT)
    void insert(Employee employee);
/**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
    @AutoFill(value = OperationType.UPDATE)
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;
@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>详细讲解@AutoFill</strong></span></p>
<blockquote>
<p><strong><u>@Target(ElementType.<em>METHOD</em>)</u></strong><br>使用<code>@Target</code>注解指定自定义注解@AutoFill可以应用的目标元素类，这里指定了<code>ElementType.METHOD</code>，表示@AutoFill**<u>只能应用于方法上</u>**</p>
<p><strong><u>@Retention(RetentionPolicy.RUNTIME)</u></strong><br>使用 <code>@Retention</code> 注解指定自定义注解 @AutoFill 的保留策略。这里指定了 <code>RetentionPolicy.RUNTIME</code>，表示 @AutoFill 注解会在运行时保留，可以通过反射获取到。</p>
<p><strong><u>public @interface AutoFill {…}</u></strong><br>@interface：关键字，用于定义一个新的注解类型。<br>AutoFill：注解的名称，表示这个注解就叫做AutoFill</p>
<p>区分普通接口：<code>@interface</code> 与普通的 <code>interface</code> 不同，普通的interface用于定义接口，而@interface用于定义注解，@符号帮助编译器区分这两者</p>
<pre><code class="java">package com.sky.enumeration;

/**
 * 数据库操作类型
 */
public enum OperationType &#123;
    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT
&#125;
</code></pre>
<hr>
<p>@<strong><u>Aspect</u></strong><br>使用<code>@Aspect</code>注解将这个类标记为一个切面，切面是AOP(面向切面编程)，用于定义切面关注点(日志记录、事务管理)</p>
<p>@<strong><u>Component</u></strong><br>使用<code>@Component</code>注解将这个类标记为Spring管理的Bean，这样Spring容器会自动扫描并管理这个类的实例</p>
<p>@<strong><u>Slf4j</u></strong><br>使用 <code>@Slf4j</code> 注解生成一个日志记录器（Logger）实例。这个注解来自 Lombok 库，可以简化日志记录器的创建</p>
<pre><code class="java">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;
</code></pre>
<p>使用<code>@Pointcut</code>注解定义一个切入点<code>autoFillPointCut</code></p>
<ul>
<li><code>execution(* com.sky.mapper.*.*(..))</code>：匹配<code>com.sky.mapper</code>包下所有类的所有方法</li>
<li><code>&amp;&amp; @annotation(com.sky.annotation.AutoFill)</code>：并且这些方法必须带有<code>@AutoFill</code>注解</li>
<li>public void autoFillPointCut()：定义一个空的方法，用于标识这个切入点</li>
</ul>
<pre><code class="java">/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<p>使用<code>@Before</code>注解定义一个前置通知<code>autoFill</code>，这个通知会在切入点方法执行前被调用</p>
<ul>
<li><code>@Before(&quot;autoFillPointCut()&quot;)</code>：指定这个通知应用于<code>autoFillPointCut</code>切入点</li>
<li><code>public void autoFill(JoinPoint joinPoint)</code>：定义通知方法，接收一个<code>JoinPoint</code>参数，<code>JoinPoint</code>包含了连接点的信息，如被拦截的方法、参数等</li>
</ul>
</blockquote>
<h4 id="代码开发2"><a href="#代码开发2" class="headerlink" title="代码开发2"></a>代码开发2</h4><blockquote>
<p>公共属性赋值后 Service里的 save(Employee employee) → employee.setCreateUser(BaseContext.getCurrentId())就不用再去赋值了</p>
</blockquote>
<h6 id="这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill"><a href="#这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill" class="headerlink" title="这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill"></a>这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill</h6><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java 不变
sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);

        // 获取当前被拦截的方法上的数据库操作类型(Update/Insert)
        MethodSignature signature = (MethodSignature)joinPoint.getSignature(); //方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); //获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        // 获取当当前被拦截的方法的参数--实体对象 (Employee employee)
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) &#123; //没有参数不执行
            return;
        &#125;
        Object entity = args[0]; //获得第一个

        // 准备赋值数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        // 根据当前不同的操作类型，对对应的属性通过反射来赋值
        if (operationType == OperationType.INSERT) &#123;
            // 为4个公共字段赋值
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);


            //通过反射对对象赋值属性
            setCreateTime.invoke(entity,now);
            setCreateUser.invoke(entity,currentId);
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125; else if (operationType == OperationType.UPDATE) &#123;
            // 为2个公共字段赋值
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            //通过反射对对象赋值属性
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><h6 id="业务规则：-2"><a href="#业务规则：-2" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>菜品名称必须是唯一的</li>
<li>菜品必须属于某个分类下，不能单独存在</li>
<li>新增菜品时可以根据选择情况菜品的口味</li>
<li>每个菜品必须对应一张图片</li>
</ul>
<h6 id="接口设计：-1"><a href="#接口设计：-1" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>根据类型查询分类(已完成) <code>/admin/category/list    GET</code></p>
<p><u>这里要注意数据返回 因为它里面的口味算一个集合</u></p>
</li>
<li><p>文件上传 <code>/admin/common/upload    POST</code>   </p>
</li>
<li><p>新增菜品 <code>/admin/dish    POST</code></p>
</li>
</ul>
<h6 id="数据库设计："><a href="#数据库设计：" class="headerlink" title="数据库设计："></a>数据库设计：</h6><ul>
<li>dish菜品表 [一个菜品对应着多种口味]</li>
<li>dish_flavour口味表</li>
</ul>
<h6 id="开发文件上传接口："><a href="#开发文件上传接口：" class="headerlink" title="开发文件上传接口："></a>开发文件上传接口：</h6><p>浏览器 → 后端服务 → 阿里云OSS</p>
<pre><code class="java">sky-common  com/sky/utils/AliOssUtil.java
package com.sky.utils;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;


import java.io.ByteArrayInputStream;

@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil &#123;
// 通过配置类初始化这些数据
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) &#123;

 // 创建OSSClient实例。 将字节数组转换为输入流，并将其上传到指定的bucket和objectName
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try &#123;
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        &#125; catch (OSSException oe) &#123;
            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;
                    + &quot;but was rejected with an error response for some reason.&quot;);
            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());
            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());
            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());
            System.out.println(&quot;Host ID:&quot; + oe.getHostId());
        &#125; catch (ClientException ce) &#123;
            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;
                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;
                    + &quot;such as not being able to access the network.&quot;);
            System.out.println(&quot;Error Message:&quot; + ce.getMessage());
        &#125; finally &#123;
            if (ossClient != null) &#123;
                ossClient.shutdown();
            &#125;
        &#125;

        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);
        stringBuilder
                .append(bucketName)
                .append(&quot;.&quot;)
                .append(endpoint)
                .append(&quot;/&quot;)
                .append(objectName);
        log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, stringBuilder);

        return stringBuilder.toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-common  com/sky/constant/AutoFillConstant.java
package com.sky.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant &#123;
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = &quot;setCreateTime&quot;;
    public static final String SET_UPDATE_TIME = &quot;setUpdateTime&quot;;
    public static final String SET_CREATE_USER = &quot;setCreateUser&quot;;
    public static final String SET_UPDATE_USER = &quot;setUpdateUser&quot;;
&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    host: localhost
    port: 3306
    database: sky_take_out
    username: root
    password: root
  alioss:
    endpoint: XXXXXXXXX
    access-key-id: XXXXXXXXXXXX
    access-key-secret: XXXXXXXXXXX
    bucketName: XXXXXXXXX
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/CommonController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.utils.AliOssUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.UUID;

/**
 * 通用接口
 */
@RestController
@RequestMapping(&quot;/admin/common&quot;)
@Api(tags = &quot;通用接口&quot;)
@Slf4j
public class CommonController &#123;
    @Autowired
    private AliOssUtil aliOssUtil;
    @PostMapping(&quot;/upload&quot;)
    @ApiOperation(&quot;文件上传&quot;)
    // 如果要测试文件上传 只能用postman或者前后端联调
    public Result&lt;String&gt; upload(MultipartFile file) &#123;
        log.info(&quot;文件上传：&#123;&#125;&quot;, file);
        // 防止重名覆盖
        try &#123;
            // 原始文件名
            String filename = file.getOriginalFilename();
            // 截取原始文件名的后缀
            String extension = filename.substring(filename.lastIndexOf(&quot;.&quot;));
            // 构造新文件名UUID
            String objectName = UUID.randomUUID().toString() + extension;

            // 文件的请求路径
            String filepath = aliOssUtil.upload(file.getBytes(), objectName);
            log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, filepath);
            return Result.success(filepath);
        &#125; catch (IOException e) &#123;
            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);
        &#125;
        return Result.error(MessageConstant.UPLOAD_FAILED);
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>如何让application.yml识别到我在application-dev.yml里设置的值呢？</strong></span></p>
<pre><code class="yaml">server:
  port: 8080

spring:
  profiles:
    active: dev

你已经在 application.yml 中指定了 spring.profiles.active: dev，这样在启动应用程序时，Spring Boot 会自动加载 application-dev.yml 中的配置

如果你使用的是 IDE（如 IntelliJ IDEA 或 Eclipse），你可以在运行配置中指定激活的环境配置文件。例如，在 IntelliJ IDEA 中：
打开 Run -&gt; Edit Configurations。
选择你的应用程序配置。
在 VM options 中添加 -Dspring.profiles.active=dev。

# 在 VM options 中配置的原理：
在 VM options 中添加 -Dspring.profiles.active=dev 的原理是通过 Java 虚拟机（JVM）的系统属性来设置 Spring Boot 应用程序的活动配置文件。以下是详细的解释：
原理
JVM 系统属性：
JVM 提供了一种机制，允许你在启动时通过命令行参数传递系统属性。这些系统属性可以在应用程序中通过 System.getProperty 方法访问。
-D 前缀用于设置系统属性。例如，-Dkey=value 会将 key 设置为 value。
Spring Boot 配置：
Spring Boot 会读取 spring.profiles.active 系统属性来确定当前激活的配置文件。
当你通过 -Dspring.profiles.active=dev 设置系统属性时，Spring Boot 会在启动时读取这个属性，并根据其值加载相应的配置文件（如 application-dev.yml）。
</code></pre>
<h6 id="新增菜品重要代码"><a href="#新增菜品重要代码" class="headerlink" title="新增菜品重要代码"></a>新增菜品重要代码</h6><pre><code class="java">sky-pojo  com/sky/dto/DishDTO.java
package com.sky.dto;

import com.sky.entity.DishFlavor;
import lombok.Data;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDTO implements Serializable &#123;
    //dish属性封装成dto

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //口味[因为有多种口味要区分]
    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/DishFlavor.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 菜品口味
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishFlavor implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;
    //菜品id
    private Long dishId;

    //口味名称
    private String name;

    //口味数据list
    private String value;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
package com.sky.controller.admin;

import com.sky.dto.DishDTO;
import com.sky.result.Result;
import com.sky.service.DishService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);
&#125;
</code></pre>
<pre><code class="java">com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.sky.dto.DishDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import com.sky.annotation.AutoFill;
import com.sky.entity.Dish;
import com.sky.enumeration.OperationType;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

    /**
     * 插入菜品数据
     */
    @AutoFill(value = OperationType.INSERT)
    void insert(Dish dish);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
package com.sky.mapper;

import com.sky.entity.DishFlavor;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface DishFlavorMapper &#123;
    /**
     * 批量插入口味数据
     */
    void insertBatch(List&lt;DishFlavor&gt; flavors);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/DishFlavorMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish_flavor (dish_id, name, value) values
        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;
            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h3><blockquote>
<p>菜品名称[         ]     菜品分类[         ]     售卖状态[         ]         [搜索]<br>菜品名称、图片、菜品分类、售价、售卖状态、最后操作事件、操作[修改 删除 启售,停售]<br>                                                                                                                            右下角 分页操作</p>
</blockquote>
<h6 id="业务规则：-3"><a href="#业务规则：-3" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>根据页码展示菜品信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要输入<strong>菜品名称、菜品分类、菜品状态</strong>进行查询</li>
</ul>
<h6 id="接口设计：-2"><a href="#接口设计：-2" class="headerlink" title="接口设计："></a>接口设计：</h6><p><strong>Path</strong>：&#x2F;admin&#x2F;dish&#x2F;page<br><strong>Method</strong>：GET</p>
<h6 id="代码开发："><a href="#代码开发：" class="headerlink" title="代码开发："></a>代码开发：</h6><p>根据菜品分页查询接口定义设计对应的<strong>DTO</strong><br>根据菜品分页查询接口定义设计对应的<strong>VO</strong>[转成Json数据给前端]</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
@GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;菜品分页查询&quot;)
    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO)&#123;
        log.info(&quot;菜品分页查询：&#123;&#125;&quot;, dishPageQueryDTO);
        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.result.PageResult;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
@Service
@Slf4j
public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
 @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
  // 1. 开启分页功能，设置当前页和每页显示的数量
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
 // 2. 调用 dishMapper 的 pageQuery 方法进行分页查询，返回一个 Page&lt;DishVO&gt; 对象
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
     // 3. 创建并返回 PageResult 对象，包含总记录数和查询结果列表
        return new PageResult(page.getTotal(), page.getResult());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);
</code></pre>
<pre><code class="mysql">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><span style="color:orange"><strong>分页查询SQL语句分析</strong></span></p>
<blockquote>
<pre><code class="mysql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
</code></pre>
<p>从 dish 表中选择所有列，并从 category 表中选择 name 列，别名为 categoryName。<br>使用左连接 (left join) 将 dish 表和 category 表连接起来，连接条件是 d.category_id &#x3D; c.id。</p>
<p>动态生成WHERE子句，&lt; where &gt;标签会自动处理AND和OR关键字的添加，并且会忽略第一个条件前的ADN和OR</p>
</blockquote>
<h3 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h3><blockquote>
<p>单个删除、批量删除、先停售后删除</p>
</blockquote>
<h6 id="业务规则：-4"><a href="#业务规则：-4" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以一次删除一个菜品，也可以批量删除菜品</li>
</ul>
<blockquote>
<p><strong>Path</strong>: &#x2F;admin&#x2F;dish<br><strong>Method</strong>: DELETE<br><strong>数据库设计</strong>：<br>dish表 → id 【菜品】<br>dish_flavor表 → dish_id 【口味】<br>setmeal_dish表 → dish_id</p>
</blockquote>
<ul>
<li>起售中的菜品不能删除</li>
<li>被套餐关联的菜品不能删除</li>
<li>删除菜品后，关联的口味数据也需要删除</li>
</ul>
<h6 id="代码开发：-1"><a href="#代码开发：-1" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Override
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishId(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据主键删除菜品数据
     */

    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id删除对应的 口味数据
     * @param id
     */
    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    void deleteByDishId(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealDishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishId(List&lt;Long&gt; dishIds);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealDishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;

    &lt;select id=&quot;getSetmealIdsByDishId&quot; resultType=&quot;java.lang.Long&quot;&gt;
        SELECT setmeal_id
        FROM setmeal_dish
        WHERE dish_id IN
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
           #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;/mapper&gt;

&lt;!--
★ foreach 标签用于遍历集合，并生成相应的 SQL 语句。
★ collection=&quot;dishIds&quot;：指定要遍历的集合名称，即传入的参数 dishIds。
★ item=&quot;dishId&quot;：指定集合中的每个元素的别名，即每次迭代时的变量名。
★ separator=&quot;,&quot;：指定每个元素之间的分隔符，这里是逗号 ,。
★ open=&quot;(&quot; 和 close=&quot;)&quot;：指定生成的 SQL 语句的开始和结束符号，这里是括号 ( 和 )。
--&gt;
</code></pre>
<p><span style="color:orange">@<strong>RequestParm详细分析</strong></span></p>
<blockquote>
<p><code>public Result delete(@RequestParam List&lt;Long&gt; ids)</code></p>
<p><code>@RequestParam</code>：注解用于将请求参数绑定到方法参数上。具体来说，它可以从请求的查询参数中提取出指定的参数值，并将其转换为方法参数的类型；在这个例子中，@RequestParam List<Long> ids 表示从请求的查询参数中提取 ids 参数，并将其转换为 List<Long> 类型。</p>
</blockquote>
<h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><h6 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h6><p><strong>接口设计：</strong></p>
<ul>
<li>根据id查询菜品</li>
</ul>
<blockquote>
<p>口味也要回显<br><strong>Path:</strong>  &#x2F;admin&#x2F;dish&#x2F;{id}<br><strong>Method：</strong>GET</p>
</blockquote>
<ul>
<li>根据类型查询分类(已实现)</li>
<li>文件上传(已实现)</li>
<li>修改菜品</li>
</ul>
<blockquote>
<p>根据ID修改<br><strong>Path：</strong>&#x2F;admin&#x2F;dish<br><strong>Method：</strong>PUT</p>
</blockquote>
<h6 id="代码开发：-2"><a href="#代码开发：-2" class="headerlink" title="代码开发："></a>代码开发：</h6><p><strong>根据id查询菜品进行信息回显</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询菜品&quot;)
//  @PathVariable 注解用于从 URL 路径中的占位符参数中提取值，并将其绑定到方法参数上
    public Result&lt;DishVO&gt; getById(@PathVariable long id) &#123;
        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);
        DishVO dishVO = dishService.getByIdWithFlavor(id);
        return Result.success(dishVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id查询对应的口味数据
     * @param id
     * @return
     */
    @Select(&quot;select * from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    List&lt;DishFlavor&gt; getByDishId(long id);
</code></pre>
<p><strong>修改菜品接口</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
/*
这段代码中，将 dishDTO 的属性复制到 dish 对象的主要原因有以下几点：
数据模型分离：
dishDTO 通常用于数据传输，包含前端传来的所有数据。
dish 是数据库实体类，只包含数据库表中的字段。
安全性：
使用 BeanUtils.copyProperties 可以避免将不必要的字段（如前端传来的额外属性）写入数据库。
确保只有预期的字段被更新。
数据校验：
dishDTO 可以包含更多的验证逻辑或额外的属性，而 dish 对象则严格遵循数据库模型。
通过这种方式，可以在更新前对数据进行进一步校验。
事务管理：
添加 @Transactional 注解确保整个更新过程在一个事务中完成。
如果任何一步出错，整个事务都会回滚，保证数据一致性。
*/
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dish
     */
    //有时间和修改人 不要忘记自动填充
    @AutoFill(value = OperationType.UPDATE)
    void update(Dish dish);
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;update id=&quot;update&quot;&gt;
        update dish
        &lt;set&gt;
            &lt;if
                test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h5 id="菜品起售停售"><a href="#菜品起售停售" class="headerlink" title="菜品起售停售"></a>菜品起售停售</h5><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品起售停售
     * @param status
     * @param id
     */
@Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java

    /**
     * 根据套餐id查询菜品
     * @param setmealId
     * @return
     */
    @Select(&quot;select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;Dish&gt; getBySetmealId(Long setmealId);
/*
在 SQL 查询中添加筛选条件。
确保返回的结果集中，setmeal_dish 表中的 setmeal_id 字段值与传入的 setmealId 参数值相匹配，从而获取与指定套餐 ID 相关的菜品列表。
*/
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);
</code></pre>
<pre><code class="xml">SetmealDishMapper.xml
&lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;
        select setmeal_id from setmeal_dish where dish_id in
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
<h4 id="修改套餐那些事"><a href="#修改套餐那些事" class="headerlink" title="修改套餐那些事"></a>修改套餐<del>那些事</del></h4><pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java
package com.sky.controller.admin;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.SetmealVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分页查询&quot;)
    public Result&lt;PageResult&gt; page(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        PageResult pageResult = setmealService.pageQuery(setmealPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;

    /**
     * 根据id查询套餐，用于修改页面回显数据
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询套餐&quot;)
    public Result&lt;SetmealVO&gt; getById(@PathVariable Long id) &#123;
        SetmealVO setmealVO = setmealService.getByIdWithDish(id);
        return Result.success(setmealVO);
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;
/**
ids.forEach(id -&gt; &#123; ... &#125;)：对ids集合中的每个元素id执行大括号内的操作。
id -&gt; &#123; ... &#125;：定义了一个接受单个参数id的函数，并执行大括号内的逻辑。
在大括号内，根据id查询数据库获取套餐信息，并检查其状态，若状态符合启用条件，则抛出异常。
**/
    
    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.enumeration.OperationType;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;
import java.util.Map;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     *
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

    /**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);

    /**
     * 新增套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.INSERT)
    void insert(Setmeal setmeal);

    /**
     * 分页查询
     * @param setmealPageQueryDTO
     * @return
     */
    Page&lt;SetmealVO&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 根据id查询套餐
     * @param id
     * @return
     */
    @Select(&quot;select * from setmeal where id = #&#123;id&#125;&quot;)
    Setmeal getById(Long id);

    /**
     * 根据id删除套餐
     * @param setmealId
     */
    @Delete(&quot;delete from setmeal where id = #&#123;id&#125;&quot;)
    void deleteById(Long setmealId);

    /**
     * 根据id查询套餐和套餐菜品关系
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 动态条件查询套餐
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据套餐id查询菜品选项
     * @param setmealId
     * @return
     */
    @Select(&quot;select sd.name, sd.copies, d.image, d.description &quot; +
            &quot;from setmeal_dish sd left join dish d on sd.dish_id = d.id &quot; +
            &quot;where sd.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;DishItemVO&gt; getDishItemBySetmealId(Long setmealId);

    /**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

&lt;!--
    &lt;insert&gt;：表示这是一个插入操作。
    id=&quot;insert&quot;：指定这个 SQL 语句的唯一标识符，通常用于在 MyBatis 映射文件中引用此 SQL 语句。
    parameterType=&quot;Setmeal&quot;：指定插入操作的参数类型为 Setmeal 类型。
    useGeneratedKeys=&quot;true&quot;：指示 MyBatis 在执行插入操作后自动获取自动生成的主键。
    keyProperty=&quot;id&quot;：指定将自动生成的主键值设置到对象的 id 属性上。
--&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;Setmeal&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into setmeal
        (category_id, name, price, status, description, image, create_time, update_time, create_user, update_user)
        values (#&#123;categoryId&#125;, #&#123;name&#125;, #&#123;price&#125;, #&#123;status&#125;, #&#123;description&#125;, #&#123;image&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;,
                #&#123;createUser&#125;, #&#123;updateUser&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.SetmealVO&quot;&gt;
        select
        s.*,c.name categoryName
        from
        setmeal s
        left join
        category c
        on
        s.category_id = c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and s.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and s.status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and s.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by s.create_time desc
    &lt;/select&gt;

    &lt;select id=&quot;getByIdWithDish&quot; parameterType=&quot;long&quot; resultMap=&quot;setmealAndDishMap&quot;&gt;
        select a.*,
               b.id    sd_id,
               b.setmeal_id,
               b.dish_id,
               b.name  sd_name,
               b.price sd_price,
               b.copies
        from setmeal a
                 left join
             setmeal_dish b
             on
                 a.id = b.setmeal_id
        where a.id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;list&quot; parameterType=&quot;Setmeal&quot; resultType=&quot;Setmeal&quot;&gt;
        select * from setmeal
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;

    &lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="Redis入门-调整营业状态"><a href="#Redis入门-调整营业状态" class="headerlink" title="Redis入门 [调整营业状态]"></a>Redis入门 [调整营业状态]</h3><p>Redis是一个基于<strong>内存</strong>的 key-value 结构数据库</p>
<ul>
<li>基于内存存储，读写性能高</li>
<li>适合存储热点数据 (热点商品、资讯、新闻) 访问量较大</li>
<li>企业应用广泛</li>
</ul>
<h3 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h3><h5 id="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："><a href="#Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：" class="headerlink" title="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："></a>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</h5><ul>
<li>字符串 string：普通字符串</li>
<li>哈希 hash：散列，类似于java中的HashMap结构</li>
<li>列表 list：按照插入顺序排序，可以有重复元素，类似于java中的LinkedList</li>
<li>集合 set：无序集合，没有重复元素，类似于java中的HashSet</li>
<li>有序集合 sorted set &#x2F; zset：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li>
</ul>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><ul>
<li><p><strong>字符串操作命令</strong></p>
<blockquote>
<p>ValueOperations valueOperations &#x3D; redisTemplate.opsForValue();</p>
</blockquote>
<ul>
<li>SET key value                      设置指定key的值</li>
<li>GET key                                获取指定key的值</li>
<li>SETEX key seconds value  设置指定key的值，并将key的过期时间设为 seconds秒</li>
<li>SETNX key value                 只有在key不存在时设置key的值</li>
</ul>
</li>
<li><p><strong>哈希操作命令</strong> [<strong>key → value(field1 value1,  field2 value2)</strong>]</p>
<blockquote>
<p>HashOperations hashOperations &#x3D; redisTemplate.opsForHash();</p>
</blockquote>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<ul>
<li>HSET key field value   将哈希表key中的字段field的值设为value</li>
<li>HGET key field             获取存储在哈希表中指定字段的值</li>
<li>HDEL key field             删除存储在哈希表中的指定字段</li>
<li>HKEYS key                    获取哈希表中所有字段</li>
<li>HVALS key                    获取哈希表中所有值</li>
</ul>
</li>
<li><p><strong>列表操作命令</strong></p>
<blockquote>
<p>ListOperations listOperations &#x3D; redisTemplate.opsForList();</p>
</blockquote>
<ul>
<li>LPUSH key value1 [value2]      将一个或多个值插入到列表头部</li>
<li>LRANGE key start stop             获取列表指定范围内的元素</li>
<li>RPOP key                                    移除并获取列表最后一个元素</li>
<li>LLEN key                                     获取列表长度</li>
</ul>
</li>
<li><p><strong>集合操作命令</strong></p>
<blockquote>
<p>SetOperations setOperations &#x3D; redisTemplate.opsForSet();</p>
</blockquote>
<p>Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据</p>
<ul>
<li>SADD key member1 [member2]           向集合添加一个或多个成员 [无序插入]</li>
<li>SMEMBERS key                                         返回集合中的所有成员</li>
<li>SCARD key                                                  获取集合的成员数</li>
<li>SINTER key1 [key2]                                   返回给定所有集合的交集</li>
<li>SUNION key1 [key2]                                 返回所有给定集合的并集</li>
<li>SREM key member1 [member2]            删除集合中一个或多个成员</li>
</ul>
</li>
<li><p><strong>有序列表操作命令</strong></p>
<blockquote>
<p>ZSetOperations zSetOperations &#x3D; redisTemplate.opsForZSet();</p>
</blockquote>
<p>Redis有序集合是string类型元素的集合，且不允许重复成员。每个元素都会关联一个double类型的分数</p>
<ul>
<li>ZADD key score1 member1 [score2 member2]  向有序集合添加一个或多个成员</li>
<li>ZRANGE key start stop [WITHSCORES]                 通过索引区间返回有序集合中指定区间内的成员</li>
<li>ZINCRBY key increment member                          有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]                            移除有序集合中的一个或多个成员</li>
</ul>
</li>
<li><p><strong>通用命令</strong></p>
<p>Redis的通用命令是不分数据类型的，都可以使用的命令</p>
<ul>
<li>KEYS pattern            查找所有符合给定模式(pattern)的key</li>
<li>EXISTS key                检查给定key是否存在</li>
<li>TYPE key                   返回key所存储的值的类型</li>
<li>DEL key                     该命令用于在key存在是删除key</li>
</ul>
</li>
</ul>
<h3 id="在java中操作Redis-SpringDataRedis"><a href="#在java中操作Redis-SpringDataRedis" class="headerlink" title="在java中操作Redis_SpringDataRedis"></a>在java中操作Redis_SpringDataRedis</h3><p><span style = "color:red">序列化器：<strong>redisTemplate.setKeySerializer(new StringRedisSerializer());</strong></span></p>
<h6 id="Redis的Java客户端很多"><a href="#Redis的Java客户端很多" class="headerlink" title="Redis的Java客户端很多"></a>Redis的Java客户端很多</h6><ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Spring Data Redis</li>
</ul>
<p>Spring Data Redis 是 Spring 的一部分，对Redis底层开发包进行了高度封装<br>在Spring项目中，可以使用Spring Data Redis来简化操作</p>
<h5 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h5><ul>
<li><p>导入Spring Data Redis的maven坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置Redis数据源</p>
<pre><code class="yaml">spring:
 redis:
  host: localhost
  port: 6379
  password:
</code></pre>
</li>
<li><p>编写配置类，创建RedisTemplate对象</p>
<pre><code class="java">package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
</li>
<li><p>通过RedisTemplate对象操作Redis</p>
</li>
</ul>
<h6 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h6><pre><code class="yaml">application.yml
  redis:
    host: $&#123;sky.redis.host&#125;
    port: $&#123;sky.redis.port&#125;
    database: $&#123;sky.redis.database&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  redis:
    host: localhost
    port: 6379
    database: 1
</code></pre>
<pre><code class="java">sky-server  com/sky/config/RedisConfiguration.java
package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器 在图形化界面不出现乱码
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server【测试类】 com/sky/test/SpringDataRedisTest.java
package com.sky.test;

import com.mysql.cj.util.TimeUtil;
import net.sf.jsqlparser.statement.select.KSQLWindow;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.*;

import java.util.concurrent.TimeUnit;

@SpringBootTest //测试完记得注释 不然每次启动类就会运行这个测试类
public class SpringDataRedisTest &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testRedisTemplate()&#123;
        System.out.println(redisTemplate);
        //创建根据字符串、哈希、列表、集合、有序列表、通用命令的代码
        ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        SetOperations setOperations = redisTemplate.opsForSet();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
    &#125;

    /**
     * 操作字符串类型的数据
     */
    @Test
    public void testString()&#123;
        // set get setex setnx
        redisTemplate.opsForValue().set(&quot;city&quot;,&quot;北京&quot;);
        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);
        System.out.println(city); // 北京

        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);
        // 第一次调用可以设置成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);
        // 第二次不可以成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);
        Object lock = redisTemplate.opsForValue().get(&quot;lock&quot;);
        System.out.println(lock); // 1

        Object lock2 = redisTemplate.opsForValue().get(&quot;locwwk&quot;);
        System.out.println(lock2);// null
    &#125;
    
    /**
     * 操作哈希类型的数据
     */
    @Test
    public void testHash()&#123;
        //hset hget hdel hkeys havls
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.put(&quot;100&quot;,&quot;name&quot;,&quot;tom&quot;);
        hashOperations.put(&quot;100&quot;,&quot;age&quot;,&quot;20&quot;);

        String name = (String) hashOperations.get(&quot;100&quot;,&quot;name&quot;);
        System.out.println(name);

        Set keys = hashOperations.keys(&quot;100&quot;);
        System.out.println(keys);

        List values = hashOperations.values(&quot;100&quot;);
        System.out.println(values);

        hashOperations.delete(&quot;100&quot;,&quot;age&quot;);
/**
     * 操作列表类型的数据
     */
    @Test
    public void testList()&#123;
        //lpush lrange rpop llen
        ListOperations listOperations = redisTemplate.opsForList();

        listOperations.leftPushAll(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
        listOperations.leftPush(&quot;mylist&quot;,&quot;d&quot;);

        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);
        System.out.println(mylist);

        listOperations.rightPop(&quot;mylist&quot;);

        Long size = listOperations.size(&quot;mylist&quot;);
        System.out.println(size);
    &#125;

    /**
     * 操作集合类型的数据
     */
    @Test
    public void testSet()&#123;
        //sadd smembers scard sinter sunion srem
        SetOperations setOperations = redisTemplate.opsForSet();

        setOperations.add(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
        setOperations.add(&quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);

        Set members = setOperations.members(&quot;set1&quot;);
        System.out.println(members);

        Long size = setOperations.size(&quot;set1&quot;);
        System.out.println(size);

        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(intersect);

        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(union);

        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 操作有序集合类型的数据
     */
    @Test
    public void testZset()&#123;
        //zadd zrange zincrby zrem
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();

        zSetOperations.add(&quot;zset1&quot;,&quot;a&quot;,10);
        zSetOperations.add(&quot;zset1&quot;,&quot;b&quot;,12);
        zSetOperations.add(&quot;zset1&quot;,&quot;c&quot;,9);

        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);
        System.out.println(zset1);

        zSetOperations.incrementScore(&quot;zset1&quot;,&quot;c&quot;,10);

        zSetOperations.remove(&quot;zset1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 通用命令操作
     */
    @Test
    public void testCommon()&#123;
        //keys exists type del
        Set keys = redisTemplate.keys(&quot;*&quot;);
        System.out.println(keys);

        Boolean name = redisTemplate.hasKey(&quot;name&quot;);
        Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;);

        for (Object key : keys) &#123;
            DataType type = redisTemplate.type(key);
            System.out.println(type.name());
        &#125;

        redisTemplate.delete(&quot;mylist&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="店铺营业状态设置-【存入Redis】"><a href="#店铺营业状态设置-【存入Redis】" class="headerlink" title="店铺营业状态设置 【存入Redis】"></a>店铺营业状态设置 【存入Redis】</h3><h6 id="接口设计：-3"><a href="#接口设计：-3" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>设置营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;admin&#x2F;shop&#x2F;{status}<br><strong>Method</strong>：PUT<br>status   1    店铺营业状态：1为营业，0为打样</p>
</blockquote>
</li>
<li><p>管理端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>admin</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
<li><p>用户端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>user</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
</ul>
<p>★ ★ <strong>本项目约定</strong> ★ ★</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用**&#x2F;admin**作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用**&#x2F;user**作为前缀</li>
</ul>
<p>营业状态数据存储方式：基于Redis的字符串来进行存储<br>key: SHOP_STATUS     value: 1                1为营业，0为打样</p>
<h6 id="代码开发：-3"><a href="#代码开发：-3" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/ShopController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;

@RestController(&quot;adminShopController&quot;)
@RequestMapping(&quot;/admin/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 设置店铺营业状态
     * @param status
     * @return
     */
    @PutMapping(&quot;/&#123;status&#125;&quot;) //动态取到status
    @ApiOperation(&quot;设置店铺营业状态&quot;)
    public Result setStatus(@PathVariable Integer status) &#123;
        log.info(&quot;设置店铺的营业状态为：&#123;&#125;&quot;, status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    &#125;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShopController.java
package com.sky.controller.user;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
//@RestController(&quot;userShopController&quot;) 指定了这个控制器的名称为 userShopController
//这有助于在应用中唯一标识这个控制器，便于管理和调用
@RestController(&quot;userShopController&quot;)
@RequestMapping(&quot;/user/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
// 设置两个接口文档方便在前端文档处调试【管理端+用户端】
package com.sky.config;

import com.sky.interceptor.JwtTokenAdminInterceptor;
import com.sky.interceptor.JwtTokenUserInterceptor;
import com.sky.json.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

import java.util.List;

/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;

    @Bean
    public Docket docket1()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;管理端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.admin&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    @Bean
    public Docket docket2()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;用户端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.user&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射，主要是访问接口文档（html、js、css）
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;

    /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
&#125;
</code></pre>
<p><span style="color:orange"><strong>回顾拦截器原理</strong></span></p>
<h3 id="HttpClient-amp-微信小程序开发"><a href="#HttpClient-amp-微信小程序开发" class="headerlink" title="HttpClient &amp; 微信小程序开发"></a>HttpClient &amp; 微信小程序开发</h3><h5 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h5><p>HttpClient 是 Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.5.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>核心API：</p>
<ul>
<li>HttpClient</li>
<li><strong>HttpClients</strong></li>
<li>CloseableHttpClient</li>
<li>HttpGet</li>
<li>HttpPost</li>
</ul>
<p>发送请求步骤：</p>
<ul>
<li>创建HttpClient对象</li>
<li>创建Http请求对象</li>
<li>调用HttpClient的execute方法发送请求</li>
</ul>
<h5 id="发送GET方式请求-要先把项目跑起来"><a href="#发送GET方式请求-要先把项目跑起来" class="headerlink" title="发送GET方式请求 [要先把项目跑起来]"></a>发送GET方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server  com/sky/test/HttpClientTest.java
package com.sky.test;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HttpClientTest &#123;
    /**
     * 测试通过httpclient发送GET方式的请求
     */

    @Test
    public void testGET() throws IOException &#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象接口 (GET请求方式+请求地址)
        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);

        // 发送请求，接受响应结果
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 获取服务端返回的状态码
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;服务端返回的状态码为：&quot; + statusCode);


        HttpEntity entity = response.getEntity();// 获得请求体
        String body = EntityUtils.toString(entity);
        System.out.println(&quot;服务端返回的数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;

    /**
     * 测试通过httpclient发送POST方式的请求
     */
&#125;
--------------------------------------------------------------------------------
服务端返回的状态码为：200
服务端返回的数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:0&#125;
</code></pre>
<h5 id="发送POST方式请求-要先把项目跑起来"><a href="#发送POST方式请求-要先把项目跑起来" class="headerlink" title="发送POST方式请求 [要先把项目跑起来]"></a>发送POST方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server   com/sky/test/HttpClientTest.java
/**
     * 测试通过httpclient发送POST方式的请求
     */
    @Test
    public void testPOST() throws Exception&#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象
        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);
        // 以json方式请求提交参数
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);
        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);

        StringEntity entity = new StringEntity(jsonObject.toString());
        // 指定请求编码方式
        entity.setContentEncoding(&quot;utf-8&quot;);
        // 数据格式
        entity.setContentType(&quot;application/json&quot;);
        httpPost.setEntity(entity);

        // 发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);

        // 解析返回结果
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;响应码为：&quot; + statusCode);

        HttpEntity entity1 = response.getEntity();
        String body = EntityUtils.toString(entity1);
        System.out.println(&quot;响应数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;
--------------------------------------------------------------------------------
响应码为：200
响应数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:&#123;&quot;id&quot;:1,&quot;userName&quot;:&quot;admin&quot;,&quot;name&quot;:&quot;管理员&quot;,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI4MTMyMzczfQ.8M2nIkgtHx8wpORNfhKEWjbprBV6OwC82wgYjAMxe2I&quot;&#125;&#125;
</code></pre>
<h6 id="封装后的HttpClientUtil"><a href="#封装后的HttpClientUtil" class="headerlink" title="封装后的HttpClientUtil"></a>封装后的HttpClientUtil</h6><pre><code class="java">package com.sky.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Http工具类
 */
public class HttpClientUtil &#123;

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map&lt;String,String&gt; paramMap)&#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = &quot;&quot;;
        CloseableHttpResponse response = null;

        try&#123;
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null)&#123;
                for (String key : paramMap.keySet()) &#123;
                    builder.addParameter(key,paramMap.get(key));
                &#125;
            &#125;
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200)&#123;
                result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                response.close();
                httpClient.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return result;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) &#123;
                List&lt;NameValuePair&gt; paramList = new ArrayList();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                &#125;
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) &#123;
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    jsonObject.put(param.getKey(),param.getValue());
                &#125;
                StringEntity entity = new StringEntity(jsonObject.toString(),&quot;utf-8&quot;);
                //设置请求编码
                entity.setContentEncoding(&quot;utf-8&quot;);
                //设置数据类型
                entity.setContentType(&quot;application/json&quot;);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;
    private static RequestConfig builderRequestConfig() &#123;
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    &#125;
&#125;
</code></pre>
<h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&token=244469372">小程序 (qq.com)</a></p>
<blockquote>
<p>详情 → 本地设置 → [取消勾选]不校验合法域名…</p>
</blockquote>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ul>
<li><p>了解小程序目录结构</p>
<p>小程序包含一个<strong>描述整体程序</strong>的<u>app</u>和多个和<strong>描述各自页面</strong>的<u>page</u>，一个小程序主体部分由三个文件组村，必须放在项目的根目录</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>app.js</td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td>app.wxss</td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody></table>
<h6 id="一个小程序页面由四个文件组成-pages-→-index-→-…"><a href="#一个小程序页面由四个文件组成-pages-→-index-→-…" class="headerlink" title="一个小程序页面由四个文件组成 [pages → index → …]"></a>一个小程序页面由四个文件组成 [pages → index → …]</h6><table>
<thead>
<tr>
<th>文件类型</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>wxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody></table>
</li>
<li><p>编写测试小程序代码</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23385943/article/details/142336381?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-142336381-blog-119914069.235%5Ev43%5Epc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=3">微信getUserProfile不弹出授权框_wx.getuserprofile没有弹窗-CSDN博客</a></p>
<pre><code class="json">app.json 【外面一层】
&#123;
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;: &#123;
    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
    &quot;navigationBarTitleText&quot;: &quot;Sky-Delivery&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;
  &#125;,
  &quot;style&quot;: &quot;v2&quot;,
  &quot;componentFramework&quot;: &quot;glass-easel&quot;,
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,
  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;
&#125;
</code></pre>
<pre><code class="xml">pages/index/index.wxml
&lt;view class=&quot;container&quot;&gt;
  &lt;view&gt;
    &#123;&#123;msg&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;getUserInfo&quot; type=&quot;primary&quot;&gt;获取用户信息&lt;/button&gt;
    昵称：&#123;&#123;nickName&#125;&#125;
    &lt;image src=&quot;&#123;&#123;url&#125;&#125;&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/image&gt;
    &lt;button bindtap=&quot;wxLogin&quot; type=&quot;warn&quot;&gt;微信登录&lt;/button&gt;
    授权码：&#123;&#123;code&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;sendRequest&quot; type=&quot;default&quot;&gt;发送请求&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="js">pages/index/index.js
Page(&#123;
  data: &#123;
    msg: &#39;hello world&#39;,
    nickName: &#39;&#39;,
    url:&#39;&#39;,
    code:&#39;&#39;,
  &#125;,

  // 获取微信用户的头像和昵称
  getUserInfo(e)&#123;
    wx.getUserProfile(&#123;
      desc: &#39;获取用户信息&#39;,
      success: (res) =&gt; &#123;
        console.log(res.userInfo);
        // 为数据赋值
        this.setData(&#123;
          nickName: res.userInfo.nickName,
          url: res.userInfo.avatarUrl
        &#125;)
      &#125;,
      fail:(err) =&gt; &#123;
        console.error(&#39;获取用户信息失败&#39;, err);
      &#125;
    &#125;);
  &#125;,
  
  //微信登录，获取微信用户的授权码 
  //拿到后可以去请求微信服务器获得openId
  //授权码提交到后端去调用服务器
  wxLogin()&#123;
    wx.login(&#123;
      success: (res) =&gt; &#123;
        console.log(res.code)
        this.setData(&#123;
          code: res.code
        &#125;)
      &#125;
    &#125;)
  &#125;,

  //发送请求
  sendRequest()&#123;
    wx.request(&#123;
      url: &#39;http://localhost:8080/user/shop/status&#39;,
      method: &#39;GET&#39;,
      success: (res)=&gt;&#123;
        // data是后端响应回来的整个数据
        console.log(res.data)
      &#125;
    &#125;)
  &#125;
&#125;);
</code></pre>
</li>
<li><p>编译小程序</p>
</li>
</ul>
<h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><h5 id="导入小程序代码"><a href="#导入小程序代码" class="headerlink" title="导入小程序代码"></a>导入小程序代码</h5><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day06\微信小程序代码\mp-weixin<br>【注意：导入后有很多包名错误common、components】</p>
</blockquote>
<h5 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">开放能力 &#x2F; 用户信息 &#x2F; 小程序登录 (qq.com)</a><br><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg"></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appid</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appId</td>
</tr>
<tr>
<td>secret</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appSecret</td>
</tr>
<tr>
<td>js_code</td>
<td>string</td>
<td></td>
<td>是</td>
<td>登录时获取的 code</td>
</tr>
<tr>
<td>grant_type</td>
<td>string</td>
<td></td>
<td>是</td>
<td>授权类型，此处只需填写 authorization_code</td>
</tr>
</tbody></table>
<blockquote>
<p>PostMan测试 →<br>GET：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code</a></p>
<p>返回：<br>{“session_key”:”HsYD32ryqarcnrCXbEyWhg&#x3D;&#x3D;”,”openid”:”obaex5N3w1_oAP6a4h-c-CkQBsZQ”}</p>
</blockquote>
<h6 id="需求分析和设计-3"><a href="#需求分析和设计-3" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h6><p>数据库设计(user表)</p>
<h6 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h6><pre><code class="yaml">sky-server  application.yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    user-secret-key: itheima
    user-ttl: 7200000
    user-token-name: authentication
  alioss:
    endpoint: $&#123;sky.alioss.endpoint&#125;
    access-key-id: $&#123;sky.alioss.access-key-id&#125;
    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;
    bucket: $&#123;sky.alioss.bucket&#125;
  wechat:
    appid: $&#123;sky.wechat.appid&#125;
    secret: $&#123;sky.wechat.secret&#125;
</code></pre>
<pre><code class="java">sky-server  application-dev.yml
  wechat:
    appid: xxxxxxx
    secret: xxxxxxx
</code></pre>
<pre><code class="java">sky-common  com/sky/properties/WeChatProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.wechat&quot;)
@Data
public class WeChatProperties &#123;

    private String appid; //小程序的appid
    private String secret; //小程序的秘钥
    private String mchid; //商户号
    private String mchSerialNo; //商户API证书的证书序列号
    private String privateKeyFilePath; //商户私钥文件
    private String apiV3Key; //证书解密的密钥
    private String weChatPayCertFilePath; //平台证书
    private String notifyUrl; //支付成功的回调地址
    private String refundNotifyUrl; //退款成功的回调地址
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/UserController.java
package com.sky.controller.user;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.UserService;
import com.sky.utils.JwtUtil;
import com.sky.vo.UserLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/user/user&quot;)
@Api(tags = &quot;C端用户相关接口&quot;)
@Slf4j
public class UserController &#123;
    @Autowired
    private UserService userService;
    @Autowired
    private JwtProperties jwtProperties;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(&quot;微信登录&quot;)
    public Result&lt;UserLoginVO&gt; login(@RequestBody UserLoginDTO userLoginDTO) &#123;
        log.info(&quot;微信登录：&#123;&#125;&quot;, userLoginDTO.getCode());
        //微信登录
        User user = userService.wxLogin(userLoginDTO);

        //为微信用户生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.USER_ID, user.getId());
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(),jwtProperties.getUserTtl(),claims);
        UserLoginVO userLoginVO = UserLoginVO.builder()
                .id(user.getId())
                .openid(user.getOpenid())
                .token(token)
                .build();
        return Result.success(userLoginVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/UserService.java
package com.sky.service;

import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;

public interface UserService &#123;
    /**
     * 微信登录
     * @return
     */
    User wxLogin(UserLoginDTO userLoginDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/UserServiceImpl.java
package com.sky.service.impl;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.constant.MessageConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.exception.LoginFailedException;
import com.sky.mapper.UserMapper;
import com.sky.properties.WeChatProperties;
import com.sky.service.UserService;
import com.sky.utils.HttpClientUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class UserServiceImpl implements UserService &#123;
    // 微信服务接口地址
    public static final String WX_LOGIN = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;

    @Autowired
    private WeChatProperties weChatProperties;
    @Autowired
    private UserMapper userMapper;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @Override
    public User wxLogin(UserLoginDTO userLoginDTO) &#123;
        String openid = getOpenid(userLoginDTO.getCode());
        // 判断openId是否真的获取到 如果为空代表失败 业务异常
        if (openid == null)&#123;
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
        &#125;
        // openId是否在表里 可判断是否为新用户
        User user = userMapper.getByOpenid(openid);
        // 如果是新用户，自动完成注册
        if (user == null) &#123;
            user = User.builder()
                    .openid(openid)
                    .createTime(LocalDateTime.now())
                    .build();
            userMapper.insert(user);
        &#125;
        // 返回这个用户对象
        return user;
    &#125;

    /**
     * 调用微信接口服务，获取微信用户的openid
     * @param code
     * @return
     */
    //只有当前类用到
    private String getOpenid(String code) &#123;
        // 调用微信服务器接口 获得当前用户的openid
        // 四个请求参数
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;appid&quot;, weChatProperties.getAppid());
        map.put(&quot;secret&quot;, weChatProperties.getSecret());
        map.put(&quot;js_code&quot;, code);
        map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);
        String json = HttpClientUtil.doGet(WX_LOGIN, map);

        // 获得json对象
        JSONObject jsonObject = JSON.parseObject(json);
        String openid = jsonObject.getString(&quot;openid&quot;);
        return openid;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
package com.sky.mapper;

import com.sky.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface UserMapper &#123;
    /**
     * 根据openid查询用户
     * @param openid
     * @return
     */
    @Select(&quot;select * from user where openid = #&#123;openid&#125;&quot;)
    User getByOpenid(String openid);

    /**
     * 新增用户
     * @param user
     */
    void insert(User user);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.UserMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into user (openid, name, phone, sex, id_number, avatar, create_time)
        values (#&#123;openid&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;avatar&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">【检测小程序用户是否登陆性】
sky-server  com/sky/interceptor/JwtTokenUserInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenUserInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getUserTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
            log.info(&quot;当前用户的id：&quot;, userId);
            BaseContext.setCurrentId(userId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java 【增加jwtTokenUserInterceptor】
/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="导入商品浏览功能代码"><a href="#导入商品浏览功能代码" class="headerlink" title="导入商品浏览功能代码"></a>导入商品浏览功能代码</h4><h6 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h6><ul>
<li><p>查询分类</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;category&#x2F;list<br>Method：GET<br>请求参数<br>Type： 分类类型→1.菜品分类  2.套餐分类</p>
</blockquote>
</li>
<li><p>根据分类id查询菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;dish&#x2F;list<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据分类id查询套餐</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;list?category&#x3D;111<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据套餐id查询包含的菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;dish&#x2F;10<br>Method：GET<br>请求参数<br>id 套餐id<br>返回数据：<br>copies 份数<br>description 菜品描述<br>image 菜品图片<br>name 菜品名称</p>
</blockquote>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;
        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        List&lt;DishVO&gt; list = dishService.listWithFlavor(dish);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.result.PageResult;
import com.sky.vo.DishVO;

import java.util.List;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);

    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);

    /**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    List&lt;Dish&gt; list(Long categoryId);

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    List&lt;DishVO&gt; listWithFlavor(Dish dish);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.entity.Setmeal;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;



    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品起售停售
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    public List&lt;Dish&gt; list(Long categoryId) &#123;
        Dish dish = Dish.builder()
                .categoryId(categoryId)
                .status(StatusConstant.ENABLE)
                .build();
        return dishMapper.list(dish);
    &#125;

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    public List&lt;DishVO&gt; listWithFlavor(Dish dish) &#123;
        List&lt;Dish&gt; dishList = dishMapper.list(dish);

        List&lt;DishVO&gt; dishVOList = new ArrayList&lt;&gt;();

        for (Dish d : dishList) &#123;
            DishVO dishVO = new DishVO();
            BeanUtils.copyProperties(d,dishVO);

            //根据菜品id查询对应的口味
            List&lt;DishFlavor&gt; flavors = dishFlavorMapper.getByDishId(d.getId());

            dishVO.setFlavors(flavors);
            dishVOList.add(dishVO);
        &#125;

        return dishVOList;
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Setmeal;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;

    /**
     * 根据套餐id查询包含的菜品列表
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/dish/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)
    public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(@PathVariable(&quot;id&quot;) Long id) &#123;
        List&lt;DishItemVO&gt; list = setmealService.getDishItemById(id);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;

    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/CategoryController.java
package com.sky.controller.user;

import com.sky.entity.Category;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userCategoryController&quot;)
@RequestMapping(&quot;/user/category&quot;)
@Api(tags = &quot;C端-分类接口&quot;)
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.annotation.AutoFill;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);
    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);
/**  公共属性
        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());
 **/

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人 (公共属性)
//        category.setUpdateTime(LocalDateTime.now());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status) // 下面注释是公共属性AOP有写
//                .updateTime(LocalDateTime.now())
//                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<h3 id="缓存菜品-【redis】"><a href="#缓存菜品-【redis】" class="headerlink" title="缓存菜品 【redis】"></a>缓存菜品 【redis】</h3><h5 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h5><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大</p>
<h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>通过Redis来缓存菜品数据，减少数据库查询操作</p>
<p>开始→(查询菜品)→后端服务→缓存是否存在→(是)→读取缓存<br>                                                                               (否)→查询数据库→载入缓存</p>
<h5 id="缓存逻辑分析："><a href="#缓存逻辑分析：" class="headerlink" title="缓存逻辑分析："></a>缓存逻辑分析：</h5><ul>
<li><p>每个分类下的菜品保存一份缓存数据</p>
<p><strong>key</strong>：dish_1<br><strong>value</strong>：string(…) [List集合]</p>
</li>
</ul>
<pre><code class="java">sky-server com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;

        //构造redis中的key，规则：dish_分类id
        String key = &quot;dish_&quot; + categoryId;

        //查询redis中是否存在菜品数据
        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);
        if(list != null &amp;&amp; list.size() &gt; 0)&#123;
            //如果存在，直接返回，无须查询数据库
            return Result.success(list);
        &#125;

        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        //如果不存在，查询数据库，将查询到的数据放入redis中
        list = dishService.listWithFlavor(dish);
        redisTemplate.opsForValue().set(key, list);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<h5 id="清理缓存数据"><a href="#清理缓存数据" class="headerlink" title="清理缓存数据"></a>清理缓存数据</h5><h6 id="防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收"><a href="#防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收" class="headerlink" title="防止 新增&#x2F;更改&#x2F;删除&#x2F;起售停售 后无法及时在用户手机端接收"></a>防止 <u>新增&#x2F;更改&#x2F;删除&#x2F;起售停售</u> 后无法及时在用户手机端接收</h6><p>修改管理端接口 <code>DishController</code> 加入清理缓存的逻辑 (新增菜品、修改菜品、批量删除菜品、起售停售菜品)</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);

        //清理缓存数据(精确查询)
        String key = &quot;dish_&quot; + dishDTO.getCategoryId();
        cleanCache(key);
        return Result.success();
    &#125;
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);
        return Result.success();
    &#125;
/**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);;
        return Result.success();
    &#125;
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);

        return Result.success();
    &#125;
private void cleanCache(String pattern)&#123;
        /** 因为单独清理每个菜品可能会有关联套餐 就直接清理全部
         * 1. 先获取到所有的key
         * 2. 遍历key，判断是否以pattern开头
         * 3. 删除所有的key
         */
        Set keys = redisTemplate.keys(pattern);
        redisTemplate.delete(keys);
    &#125;
&#125;
</code></pre>
<h2 id="缓存套餐-【SpringCache】"><a href="#缓存套餐-【SpringCache】" class="headerlink" title="缓存套餐 【SpringCache】"></a>缓存套餐 【SpringCache】</h2><p>Spring Cache 是一个框架，实现了基于<strong>注解</strong>的缓存功能，只需要简单地加一个<strong>注解</strong>，就能实现缓存功能<br>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现</p>
<ul>
<li>EHCache</li>
<li>Caffeine</li>
<li>Redis</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red">@<strong>EnableCaching</strong></span></td>
<td>开启缓存注解功能，通常加在<strong>启动类</strong>上</td>
</tr>
<tr>
<td><span style="color:red">@<strong>Cacheable</strong></span></td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CachePut</strong></span></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CacheEvict</strong></span></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<pre><code class="java">@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

     @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
</code></pre>
<h5 id="SpringCache入门案例"><a href="#SpringCache入门案例" class="headerlink" title="SpringCache入门案例"></a>SpringCache入门案例</h5><h6 id="初始资源："><a href="#初始资源：" class="headerlink" title="初始资源："></a>初始资源：</h6><pre><code class="java">package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

    @Autowired
    private UserMapper userMapper;

    @PostMapping
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.mapper;

import com.itheima.entity.User;
import org.apache.ibatis.annotations.*;

@Mapper
public interface UserMapper&#123;

    @Insert(&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;)
    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    void insert(User user);

    @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    @Delete(&quot;delete from user&quot;)
    void deleteAll();

    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
    User getById(Long id);
&#125;
</code></pre>
<pre><code class="java">package com.itheima.entity;

import lombok.Data;
import java.io.Serializable;

@Data
public class User implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String name;

    private int age;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    /**
     * 生成接口文档配置
     * @return
     */
    @Bean
    public Docket docket()&#123;
        log.info(&quot;准备生成接口文档...&quot;);

        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itheima.controller&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.yml
server:
  port: 8888
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/spring_cache_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true
      username: root
      password: root
  redis:
    host: localhost
    port: 6379
    database: 1
logging:
  level:
    com:
      itheima:
        mapper: debug
        service: info
        controller: info
</code></pre>
<pre><code class="sql">springcachedemo.sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(45) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcache-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.76&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.7.3&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<hr>
<hr>
<h5 id="开始调试咯"><a href="#开始调试咯" class="headerlink" title="开始调试咯"></a>开始调试咯</h5><pre><code class="java">com/itheima/CacheDemoApplication.java
package com.itheima;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
//@EnableCaching 放在 Application 类上，这样整个应用就启用了缓存支持
@Slf4j
@SpringBootApplication
@EnableCaching
public class CacheDemoApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(CacheDemoApplication.class,args);
        log.info(&quot;项目启动成功...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/controller/UserController.java
package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;
    /*
    set a:b:c:d: itheima 这个就是树形结构在Redis里面 文件夹包着文件夹
    */
    @Autowired
    private UserMapper userMapper;

    @PostMapping
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#result.id&quot;) 对象导航
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#p0.id&quot;)
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;)
    @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;


    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
&#125;
</code></pre>
<h4 id="缓存套餐-代码开发"><a href="#缓存套餐-代码开发" class="headerlink" title="缓存套餐_代码开发"></a>缓存套餐_代码开发</h4><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><ul>
<li>导入 <strong>Spring Cache</strong> 和 <strong>Redis</strong> 相关maven坐标</li>
<li>在<u><strong>启动类</strong></u>上加入 <strong>@EnableCaching</strong> 注解，开启缓存注解功能</li>
<li>在<u><strong>用户端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>list</strong> 方法上加入 <strong>@Cacheable</strong> 注解</li>
<li>在<u><strong>管理端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>save、delete、update、startOrStop</strong> 等方法上<br>加入**@CacheEvict** 注解<del>保证数据一致性</del></li>
</ul>
<pre><code class="java">com/sky/SkyApplication.java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@Slf4j
@EnableCaching //开启缓存注解
public class SkyApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SkyApplication.class, args);
        log.info(&quot;server started&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    @Cacheable(cacheNames = &quot;setmealCache&quot;,key = &quot;#categoryId&quot;) //key: setmealCache::100
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;
 /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;
/**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<h3 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a>添加购物车</h3><blockquote>
<p>套餐直接点击加号<br>菜品＋ 或者有口味数据的选择后才可以加入购物车</p>
</blockquote>
<h6 id="接口设计：-4"><a href="#接口设计：-4" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>请求方式：<strong>POST</strong></li>
<li>请求路径：&#x2F;user&#x2F;shoppingCart&#x2F;add</li>
<li>请求参数：<strong>菜品id</strong>(dish_id)、<strong>口味</strong>(dish_flavor) 或 <strong>套餐id</strong>(setmeal_id) (JSON请求体)</li>
<li>返回结果：code、data、msg</li>
</ul>
<h6 id="数据库设计-shopping-cart表-设置冗余字段可提高数据库效率"><a href="#数据库设计-shopping-cart表-设置冗余字段可提高数据库效率" class="headerlink" title="数据库设计(shopping_cart表):设置冗余字段可提高数据库效率"></a>数据库设计(shopping_cart表):<del>设置冗余字段可提高数据库效率</del></h6><ul>
<li>作用：暂时存放所选商品的地方</li>
<li>选的什么商品</li>
<li>每个商品都买了几个</li>
<li>不同用户的购物车需要区分开</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/dto/ShoppingCartDTO.java
package com.sky.dto;

import lombok.Data;
import java.io.Serializable;

@Data
public class ShoppingCartDTO implements Serializable &#123;

    private Long dishId;
    private Long setmealId;
    private String dishFlavor;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
package com.sky.controller.user;

import com.sky.dto.ShoppingCartDTO;
import com.sky.result.Result;
import com.sky.service.ShoppingCartService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/user/shoppingCart&quot;)
@Slf4j
@Api(tags = &quot;C端添加购物车接口&quot;)
public class ShoppingCartController &#123;
    @Autowired
    private ShoppingCartService shoppingCartService;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加购物车&quot;)
    public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;添加购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.addShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
package com.sky.service;

import com.sky.dto.ShoppingCartDTO;
import org.springframework.stereotype.Service;

public interface ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
package com.sky.service.impl;

import com.sky.context.BaseContext;
import com.sky.dto.ShoppingCartDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.ShoppingCart;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.ShoppingCartService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
@Service
@Slf4j
public class ShoppingCartServiceImpl implements ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    @Override
    public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        // 判断当前加入购物车中的商品是否已经存在了 (user_id + setmeal_id)
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        Long userId = BaseContext.getCurrentId();
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);

        // 如果已经存在了，只需要将数量+1
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            cart.setNumber(cart.getNumber() + 1);
            // update shopping_cart set number = ? where id = ?
            shoppingCartMapper.updateNumberById(cart);
        &#125; else &#123;
            // 如果不存在，需要插入一条购物车数据
            // [先确定套餐or菜品]
            // 判断本次添加到购物车的是菜品还是套餐
            Long dishId = shoppingCartDTO.getDishId();
            if (dishId != null) &#123;
                //本次添加到购物车的是菜品
                Dish dish = dishMapper.getById(dishId);
                shoppingCart.setName(dish.getName());
                shoppingCart.setImage(dish.getImage());
                shoppingCart.setAmount(dish.getPrice());
            &#125; else &#123;
                //本次添加到购物车的是套餐 查菜品表
                Long setmealId = shoppingCartDTO.getSetmealId();
                Setmeal setmeal = setmealMapper.getById(setmealId);
                shoppingCart.setName(setmeal.getName());
                shoppingCart.setImage(setmeal.getImage());
                shoppingCart.setAmount(setmeal.getPrice());

            &#125;
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartMapper.insert(shoppingCart);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
package com.sky.mapper;

import com.sky.entity.ShoppingCart;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Update;

import java.util.List;

@Mapper
public interface ShoppingCartMapper &#123;
    List&lt;ShoppingCart&gt; list(ShoppingCart shoppingCart);

    /**
     * 根据id修改商品数量
     * @param shoppingCart
     */
    @Update(&quot;update shopping_cart set number = #&#123;number&#125; where id = #&#123;id&#125;&quot;)
    void updateNumberById(ShoppingCart shoppingCart);

    /**
     * 插入购物车数据
     * @param shoppingCart
     */
    @Insert(&quot;insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) &quot; +
            &quot; values (#&#123;name&#125;,#&#123;userId&#125;,#&#123;dishId&#125;,#&#123;setmealId&#125;,#&#123;dishFlavor&#125;,#&#123;number&#125;,#&#123;amount&#125;,#&#123;image&#125;,#&#123;createTime&#125;)&quot;)
    void insert(ShoppingCart shoppingCart);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/ShoppingCartMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.ShoppingCartMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.sky.entity.ShoppingCart&quot;&gt;
        select * from shopping_cart
        &lt;where&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishId != null&quot;&gt;
                and dish_id = #&#123;dishId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;setmealId != null&quot;&gt;
                and setmeal_id = #&#123;setmealId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishFlavor != null&quot;&gt;
                and dish_flavor = #&#123;dishFlavor&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="删除购物车"><a href="#删除购物车" class="headerlink" title="删除购物车"></a>删除购物车</h3><pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 删除购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/sub&quot;)
    @ApiOperation(&quot;删除购物车&quot;)
    public Result sub(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;删除购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.subShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 删除购物车
     * @param shoppingCartDTO
     */
    void subShoppingCart(ShoppingCartDTO shoppingCartDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 删除购物车中的商品
     * @param shoppingCartDTO
     */
    @Override
    public void subShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            if (cart.getNumber() &gt; 1) &#123;
                // 如果 number &gt;1， 则需要将 number - 1
                cart.setNumber(cart.getNumber() - 1);
                shoppingCartMapper.updateNumberById(cart);
            &#125; else &#123;
                // 如果 number &lt;=1，则直接删除该购物车数据
                shoppingCartMapper.deleteById(cart.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据id删除购物车数据
     * @param id
     */
    @Delete(&quot;delete from shopping_cart where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<h3 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h3><blockquote>
<p>名称、价格、商品、数量<br>Path：&#x2F;user&#x2F;shoppingCart&#x2F;list<br>            PUT</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 查看购物车
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查看购物车&quot;)
    public Result&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;
       List&lt;ShoppingCart&gt; list = shoppingCartService.showShoppingCart();
       return Result.success(list);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 查看购物车
     * @return
     */
    List&lt;ShoppingCart&gt; showShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 查看购物车
     * @return
     */
    @Override
    public List&lt;ShoppingCart&gt; showShoppingCart() &#123;
        // 获取到当前微信用户的id
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = ShoppingCart.builder()
                .userId(userId)
                .build();
        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        return list;
    &#125;
</code></pre>
<h3 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h3><blockquote>
<p>Path：user&#x2F;shoppingCart&#x2F;clean<br>Method：DELETE<br>返回：code <strong>date</strong> msg</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 清空购物车
     * @return
     */
    @DeleteMapping(&quot;/clean&quot;)
    @ApiOperation(&quot;清空购物车&quot;)
    public Result clean() &#123;
        shoppingCartService.cleanShoppingCart();
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
/**
     * 清空购物车 删除自己的购物车
     */
    void cleanShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 清空购物车
     */
    @Override
    public void cleanShoppingCart() &#123;
        //获取到当前用户的id
        Long userId = BaseContext.getCurrentId();
        shoppingCartMapper.deleteByUserId(userId);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据用户id清空购物车
     * @param userId
     */
    @Delete(&quot;delete from shopping_cart where user_id = #&#123;userId&#125;&quot;)
    void deleteByUserId(Long userId);
</code></pre>
<h3 id="支付接口"><a href="#支付接口" class="headerlink" title="支付接口"></a>支付接口</h3><h5 id="导入地址簿功能代码"><a href="#导入地址簿功能代码" class="headerlink" title="导入地址簿功能代码"></a>导入地址簿功能代码</h5><p><strong>业务功能：</strong></p>
<ul>
<li><p>查询地址列表</p>
</li>
<li><p>新增地址</p>
</li>
<li><p>修改地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：PUT</p>
</blockquote>
</li>
<li><p>删除地址</p>
</li>
<li><p>设置默认地址</p>
</li>
<li><p>查询默认地址</p>
</li>
</ul>
<p><strong>接口设计：</strong></p>
<ul>
<li><p>新增地址</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook<br>Method: POST</p>
</blockquote>
</li>
<li><p>查询当前登录用户的所有地址信息</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook&#x2F;list<br>Method: GET</p>
</blockquote>
</li>
<li><p>查询默认地址</p>
</li>
<li><p>根据id修改地址</p>
</li>
<li><p>根据id删除地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：DELETE</p>
</blockquote>
</li>
<li><p>根据id查询地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;{id}<br>Method：GET</p>
</blockquote>
</li>
<li><p>设置默认地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;default<br>Method：PUT</p>
</blockquote>
</li>
</ul>
<h6 id="数据库设计-address-book表"><a href="#数据库设计-address-book表" class="headerlink" title="数据库设计(address_book表)"></a>数据库设计(address_book表)</h6><h4 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h4><h6 id="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"><a href="#在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货" class="headerlink" title="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"></a>在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货</h6><p>用户下单后会产生订单相关数据，订单数据需要体现信息：</p>
<ul>
<li><strong>订单总金额是多少</strong>？</li>
<li><strong>哪个用户下的单</strong>？</li>
<li><strong>买的哪些商品</strong>？</li>
<li><strong>每个商品数量是多少</strong>？</li>
<li><strong>收货地址是哪</strong>？</li>
<li><strong>用户手机号是多少</strong>？</li>
</ul>
<p>餐盒费：用数量算</p>
<h5 id="用户下单接口设计"><a href="#用户下单接口设计" class="headerlink" title="用户下单接口设计"></a>用户下单接口设计</h5><blockquote>
<p><strong>请求方式</strong>：POST<br><strong>请求路径：</strong>&#x2F;user&#x2F;order&#x2F;submit</p>
<p><strong>参数：</strong></p>
<ul>
<li>地址簿id<del>addressBookId</del></li>
<li>配送状态(立即送出、选择送出时间)<del>deliveryStatus</del></li>
<li>打包费<del>packAmount</del></li>
<li>总金额<del>amount</del></li>
<li>备注<del>remark</del></li>
<li>餐具数量<del>tablewareNumber</del></li>
</ul>
</blockquote>
<h5 id="支付订单接口设计"><a href="#支付订单接口设计" class="headerlink" title="支付订单接口设计"></a>支付订单接口设计</h5><blockquote>
<p><strong>返回数据：</strong></p>
<ul>
<li>下单时间</li>
<li>订单总金额</li>
<li>订单号</li>
<li>订单id</li>
</ul>
</blockquote>
<h5 id="数据库设计订单表orders、订单明细表order-detail"><a href="#数据库设计订单表orders、订单明细表order-detail" class="headerlink" title="数据库设计订单表orders、订单明细表order_detail"></a>数据库设计<del>订单表orders、订单明细表order_detail</del></h5><ul>
<li>订单表 <strong>orders</strong><ul>
<li>谁的订单？</li>
<li>送哪去？</li>
<li>打哪个电话联系？</li>
<li>多少钱？</li>
<li>什么时间下的单？</li>
<li>什么时间支付的？</li>
<li>订单的状态？</li>
<li>订单号是多少？</li>
</ul>
</li>
<li>订单明细表 <strong>order_detail</strong><ul>
<li>当前明细属于哪个订单？</li>
<li>具体点的是什么商品？</li>
<li>这个商品点了几份？</li>
</ul>
</li>
</ul>
<h4 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h4><h6 id="用户下单1"><a href="#用户下单1" class="headerlink" title="用户下单1"></a>用户下单1</h6><h5 id="根据用户下单接口的参数设计DTO："><a href="#根据用户下单接口的参数设计DTO：" class="headerlink" title="根据用户下单接口的参数设计DTO："></a>根据用户下单接口的参数设计DTO：</h5><pre><code class="java">sky-pojo  com/sky/dto/OrdersSubmitDTO.java
package com.sky.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class OrdersSubmitDTO implements Serializable &#123;
    //地址簿id
    private Long addressBookId;
    //付款方式
    private int payMethod;
    //备注
    private String remark;
    //预计送达时间
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime estimatedDeliveryTime;
    //配送状态  1立即送出  0选择具体时间
    private Integer deliveryStatus;
    //餐具数量
    private Integer tablewareNumber;
    //餐具数量状态  1按餐量提供  0选择具体数量
    private Integer tablewareStatus;
    //打包费
    private Integer packAmount;
    //总金额
    private BigDecimal amount;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/OrdersSubmitVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
package com.sky.controller.user;

import com.sky.dto.OrdersSubmitDTO;
import com.sky.result.Result;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController(&quot;userOrderController&quot;)
@RequestMapping(&quot;/user/order&quot;)
@Api(tags = &quot;用户订单相关接口&quot;)
@Slf4j
public class OrderController &#123;
    @Autowired
    private OrderService orderService;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @PostMapping(&quot;/submit&quot;)
    @ApiOperation(&quot;用户下单&quot;)
    public Result&lt;OrderSubmitVO&gt; submit(@RequestBody OrdersSubmitDTO ordersSubmitDTO) &#123;
        log.info(&quot;用户下单,参数为：&#123;&#125;&quot;, ordersSubmitDTO);
        OrderSubmitVO orderSubmitVO = orderService.submitOrder(ordersSubmitDTO);
        return Result.success(orderSubmitVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<h6 id="用户下单2"><a href="#用户下单2" class="headerlink" title="用户下单2"></a>用户下单2</h6><pre><code class="java">sky-pojo  com/sky/entity/AddressBook.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 地址簿
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AddressBook implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    //用户id
    private Long userId;

    //收货人
    private String consignee;

    //手机号
    private String phone;

    //性别 0 女 1 男
    private String sex;

    //省级区划编号
    private String provinceCode;

    //省级名称
    private String provinceName;

    //市级区划编号
    private String cityCode;

    //市级名称
    private String cityName;

    //区级区划编号
    private String districtCode;

    //区级名称
    private String districtName;

    //详细地址
    private String detail;

    //标签
    private String label;

    //是否默认 0否 1是
    private Integer isDefault;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Override
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        // 3.向订单明细表插入n条数据

        // 4,清空当前用户的购物车数据

        // 5.封装VO返回结果
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface OrderMapper &#123;
    /**
     * 用户下单
     * @param orders
     */
    void insert(Orders orders);
&#125;
</code></pre>
<h5 id="代码开发3"><a href="#代码开发3" class="headerlink" title="代码开发3"></a>代码开发3</h5><pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.OrderDetail;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Transactional
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        //批量插入订单明细数据
        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();
        // 3.向订单明细表插入n条数据
        for (ShoppingCart cart : shoppingCartList) &#123;
            OrderDetail orderDetail = new OrderDetail(); //订单明细
            BeanUtils.copyProperties(cart, orderDetail);
            orderDetail.setOrderId(orders.getId()); //设置当前订单明细关联的订单id
            orderDetailList.add(orderDetail);
        &#125;
        orderDetailMapper.insertBatch(orderDetailList);
        // 4.清空当前用户的购物车数据
        shoppingCartMapper.deleteByUserId(userId);
        // 5.封装VO返回结果
        OrderSubmitVO ordersubmitVO = OrderSubmitVO.builder()
                .id(orders.getId())
                .orderNumber(orders.getNumber())
                .orderAmount(orders.getAmount())
                .orderTime(orders.getOrderTime())
                .build();
        return ordersubmitVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderDetailMapper.java
package com.sky.mapper;

import com.sky.entity.OrderDetail;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface OrderDetailMapper &#123;
    /**
     * 批量插入订单明细数据
     */
    void insertBatch(List&lt;OrderDetail&gt; orderDetailList);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderDetailMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderDetailMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot;&gt;
        insert into order_detail (name, image, order_id, dish_id, setmeal_id, dish_flavor, number, amount)
        values
        &lt;foreach collection=&quot;orderDetailList&quot; item=&quot;od&quot; separator=&quot;,&quot;&gt;
            (#&#123;od.name&#125;,#&#123;od.image&#125;,#&#123;od.orderId&#125;,#&#123;od.dishId&#125;,#&#123;od.setmealId&#125;,#&#123;od.dishFlavor&#125;,#&#123;od.number&#125;,#&#123;od.amount&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><h5 id="微信支付产品-微信支付"><a href="#微信支付产品-微信支付" class="headerlink" title="微信支付产品 + 微信支付"></a>微信支付产品 + 微信支付</h5><p>参考：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p>
<h5 id="微信支付接入流程："><a href="#微信支付接入流程：" class="headerlink" title="微信支付接入流程："></a>微信支付接入流程：</h5><p>提交资料 → 签署协议 → 绑定场景</p>
<h6 id="微信小程序支付时序图："><a href="#微信小程序支付时序图：" class="headerlink" title="微信小程序支付时序图："></a>微信小程序支付时序图：</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0ad040fbbc2a25f299e2b9b93c5386ced4068ea/data/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg"></p>
<p><strong>JSAPI下单：</strong>商户系统调用该接口在微信支付服务后台生成预支付交易单</p>
<blockquote>
<p><strong>请求URL</strong>：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></p>
</blockquote>
<h5 id="获取微信支付平台证书、商户私钥文件："><a href="#获取微信支付平台证书、商户私钥文件：" class="headerlink" title="获取微信支付平台证书、商户私钥文件："></a>获取微信支付平台证书、商户私钥文件：</h5><h4 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h4><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day08\安装包<code>cpolar_amd64.msi</code></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dashboard.cpolar.com/auth">cpolar - secure introspectable tunnels to localhost</a><br>验证<br>你的隧道<br>[复制token] → 在cpolar文件里&#x2F;cmd[C:\Program Files\cpolar] → cpolar.exe authtoken xxxx[Authtoken：这个是在网站验证里复制的] → cpolar.exe http 8080</p>
<p>cpolar by @bestexpresser                                                                                (Ctrl+C to quit)</p>
<p>Tunnel Status       online<br>Account             Pluminary (Plan: Free)<br>Version             2.86.16&#x2F;3.18<br>Web Interface       127.0.0.1:4042<br>Forwarding          <a target="_blank" rel="noopener" href="http://22d34b67.r9.cpolar.top/">http://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>Forwarding          <a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/">https://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Conn              0</p>
<p>Avg Conn Time       0.00ms</p>
<p>启动穿透地址：[22d34b67.r9.cpolar.top&#x2F;doc.html] (<a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/doc.html">https://22d34b67.r9.cpolar.top/doc.html</a>)</p>
<p>此时正在下载资源<br>HTTP Requests</p>
<hr>
<p>GET &#x2F;v2&#x2F;api-docs              200<br>GET &#x2F;swagger-resources        200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-3b888a6 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-589faee 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-2d0bd79 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0fd6771 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0c58d94 200<br>GET &#x2F;webjars&#x2F;css&#x2F;chunk-62d2fe 200<br>GET &#x2F;webjars&#x2F;js&#x2F;app.0f2f48b5. 200</p>
<p>随后就可以访问到接口文档了！！<br><strong>原理：使用内网穿透工具临时获得一个域名</strong></p>
</blockquote>
<blockquote>
<p><strong>CPolar</strong> 和 <strong>SwitchHosts</strong> 是两种不同类型的软件，它们的功能和用途有所区别。</p>
<p>CPolar 是一款内网穿透软件，主要用于将本地运行的服务暴露到公网上，使得外网可以访问。它通过在本地和公网服务器之间建立一个安全的隧道，使得用户可以在任何地方通过互联网访问到本地的服务，比如网站、SSH、数据库等。</p>
<p>SwitchHosts 则是一款用于管理和切换本地hosts文件的软件。Hosts文件是操作系统用于将一些域名解析到特定的IP地址的一个文本文件。SwitchHosts 允许用户方便地添加、切换、备份不同的hosts规则，对于开发者来说，这在开发过程中进行域名映射和测试非常有用。</p>
<p>总结来说，CPolar主要用于内网穿透，而SwitchHosts用于hosts文件管理。两者解决的问题和适用场景不同，不是同一种软件。</p>
<hr>
<p>内网、公网、外网和CPolar这几个概念在网络通信中扮演着不同的角色，以下是它们的定义和它们之间的联系：</p>
<ol>
<li>内网（Local Network 或 Intranet）： 内网是指一个私有网络，通常是在家庭、办公室或企业内部使用。内网中的设备通常通过路由器连接，并使用私有IP地址（如192.168.x.x或10.x.x.x）。内网中的设备一般不能直接从外部互联网访问，它们之间的通信受到防火墙和NAT（网络地址转换）的保护。</li>
<li>公网（Public Network 或 Internet）： 公网是指全球范围内的开放网络，即互联网。公网上的设备使用公网IP地址，这些地址是全球唯一的，可以通过互联网被其他设备访问。网站、电子邮件服务器和其他在线服务都部署在公网上。</li>
<li>外网（External Network）： 外网通常是指相对于内网而言的任何外部网络，特别是指互联网。当说“外网”时，通常是指从内网之外访问的资源或服务。</li>
<li>CPolar： CPolar是一款内网穿透工具，它的主要作用是帮助内网中的设备暴露服务到公网上，使得这些服务可以被外网访问。以下是CPolar与内网、公网、外网之间的联系：</li>
</ol>
<ul>
<li>内网到公网：CPolar在本地设备上运行一个客户端，该客户端与CPolar的服务器建立连接。当外部网络（公网）尝试访问CPolar服务器上配置的特定端口时，CPolar服务器会将这些请求转发到运行CPolar客户端的内网设备上。</li>
<li>公网访问：通过CPolar，内网中的服务可以被赋予一个公网可访问的地址（通常是CPolar服务器的一个子域名或自定义域名），这样外网的任何用户都可以通过这个地址访问到内网的服务。</li>
</ul>
<p>简而言之，CPolar是实现内网服务与公网之间通信的桥梁，它使得原本只能在局域网内部访问的服务能够被外网的用户访问。这对于远程工作、调试、以及需要在公网上提供服务的内网应用来说非常有用</p>
</blockquote>
<h5 id="导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】"><a href="#导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】" class="headerlink" title="导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】"></a>导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】</h5><pre><code class="yaml">sky-server  application-dev.yml
 wechat:
    appid: wxffb3637a228223b8
    secret: 84311df9199ecacdf4f12d27b6b9522d
    mchid : 1561414331
    mchSerialNo: 4B3B3DC35414AD50B1B755BAF8DE9CC7CF407606
    privateKeyFilePath: D:\pay\apiclient_key.pem
    apiV3Key: CZBK51236435wxpay435434323FFDuv3
    weChatPayCertFilePath: D:\pay\wechatpay_166D96F876F45C7D07CE98952A96EC980368ACFC.pem
    notifyUrl: https://58869fb.r2.cpolar.top/notify/paySuccess
    refundNotifyUrl: https://58869fb.r2.cpolar.top/notify/refundSuccess
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
/**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    @PutMapping(&quot;/payment&quot;)
    @ApiOperation(&quot;订单支付&quot;)
    public Result&lt;OrderPaymentVO&gt; payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        log.info(&quot;订单支付：&#123;&#125;&quot;, ordersPaymentDTO);
        OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
        log.info(&quot;生成预支付交易单：&#123;&#125;&quot;, orderPaymentVO);
        return Result.success(orderPaymentVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
/**
     * 订单支付
     * @param ordersPaymentDTO
     * @return
     */
    OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception;

    /**
     * 支付成功，修改订单状态
     * @param outTradeNo
     */
    void paySuccess(String outTradeNo);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 @Autowired
    private UserMapper userMapper;
 @Autowired
    private WeChatPayUtil weChatPayUtil;

    
    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.CONFIRMED);

        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;
    &#125;
    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) &#123;
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();

        // 根据订单号查询当前用户的订单
        Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        orderMapper.update(orders);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.dto.GoodsSalesDTO;
import com.sky.dto.OrdersPageQueryDTO;
import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Mapper
public interface OrderMapper &#123;
    /**
     * 插入订单数据
     * @param order
     */
    void insert(Orders order);

    /**
     * 根据订单号和用户id查询订单
     * @param orderNumber
     * @param userId
     */
    @Select(&quot;select * from orders where number = #&#123;orderNumber&#125; and user_id= #&#123;userId&#125;&quot;)
    Orders getByNumberAndUserId(String orderNumber, Long userId);

    /**
     * 修改订单信息
     * @param orders
     */
    void update(Orders orders);
    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id = #&#123;id&#125;&#125;&quot;)
    Orders getById(Long id);
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
        
        &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
  @Select(&quot;select * from user where id = #&#123;id&#125;&#125;&quot;)
    User getById(Long userId);
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/notify/PayNotifyController.java
package com.sky.controller.notify;

import com.alibaba.druid.support.json.JSONUtils;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
//import com.sky.annotation.IgnoreToken;
import com.sky.properties.WeChatProperties;
import com.sky.service.OrderService;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.entity.ContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * 支付回调相关接口
 */
@RestController
@RequestMapping(&quot;/notify&quot;)
@Slf4j
public class PayNotifyController &#123;
    @Autowired
    private OrderService orderService;
    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 支付成功回调
     *
     * @param request
     */
//  @IgnoreToken
    @RequestMapping(&quot;/paySuccess&quot;)
    public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        //读取数据
        String body = readData(request);
        log.info(&quot;支付成功回调：&#123;&#125;&quot;, body);

        //数据解密
        String plainText = decryptData(body);
        log.info(&quot;解密后的文本：&#123;&#125;&quot;, plainText);

        JSONObject jsonObject = JSON.parseObject(plainText);
        String outTradeNo = jsonObject.getString(&quot;out_trade_no&quot;);//商户平台订单号
        String transactionId = jsonObject.getString(&quot;transaction_id&quot;);//微信支付交易号

        log.info(&quot;商户平台订单号：&#123;&#125;&quot;, outTradeNo);
        log.info(&quot;微信支付交易号：&#123;&#125;&quot;, transactionId);

        //业务处理，修改订单状态、来单提醒
        orderService.paySuccess(outTradeNo);

        //给微信响应
        responseToWeixin(response);
    &#125;

    /**
     * 读取数据
     *
     * @param request
     * @return
     * @throws Exception
     */
    private String readData(HttpServletRequest request) throws Exception &#123;
        BufferedReader reader = request.getReader();
        StringBuilder result = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) &#123;
            if (result.length() &gt; 0) &#123;
                result.append(&quot;\n&quot;);
            &#125;
            result.append(line);
        &#125;
        return result.toString();
    &#125;

    /**
     * 数据解密
     *
     * @param body
     * @return
     * @throws Exception
     */
    private String decryptData(String body) throws Exception &#123;
        JSONObject resultObject = JSON.parseObject(body);
        JSONObject resource = resultObject.getJSONObject(&quot;resource&quot;);
        String ciphertext = resource.getString(&quot;ciphertext&quot;);
        String nonce = resource.getString(&quot;nonce&quot;);
        String associatedData = resource.getString(&quot;associated_data&quot;);

        AesUtil aesUtil = new AesUtil(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));
        //密文解密
        String plainText = aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),
                nonce.getBytes(StandardCharsets.UTF_8),
                ciphertext);

        return plainText;
    &#125;

    /**
     * 给微信响应
     * @param response
     */
    private void responseToWeixin(HttpServletResponse response) throws Exception&#123;
        response.setStatus(200);
        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;SUCCESS&quot;);
        map.put(&quot;message&quot;, &quot;SUCCESS&quot;);
        response.setHeader(&quot;Content-type&quot;, ContentType.APPLICATION_JSON.toString());
        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));
        response.flushBuffer();
    &#125;
&#125;
</code></pre>
<h3 id="查询历史订单"><a href="#查询历史订单" class="headerlink" title="查询历史订单"></a>查询历史订单</h3><p>业务规则</p>
<ul>
<li>分页查询历史订单</li>
<li>可以根据订单状态查询</li>
<li>展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）</li>
</ul>
<p>接口设计：参见接口文档</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><h4 id="1-2-1-user-x2F-OrderController"><a href="#1-2-1-user-x2F-OrderController" class="headerlink" title="1.2.1 user&#x2F;OrderController"></a>1.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 历史订单查询
     *
     * @param page
     * @param pageSize
     * @param status   订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
     * @return
     */
    @GetMapping(&quot;/historyOrders&quot;)
    @ApiOperation(&quot;历史订单查询&quot;)
    public Result&lt;PageResult&gt; page(int page, int pageSize, Integer status) &#123;
        PageResult pageResult = orderService.pageQuery4User(page, pageSize, status);
        return Result.success(pageResult);
    &#125;
</code></pre>
<h4 id="1-2-2-OrderService"><a href="#1-2-2-OrderService" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户端订单分页查询
     * @param page
     * @param pageSize
     * @param status
     * @return
     */
    PageResult pageQuery4User(int page, int pageSize, Integer status);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl"><a href="#1-2-3-OrderServiceImpl" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">/**
     * 用户端订单分页查询
     *
     * @param pageNum
     * @param pageSize
     * @param status
     * @return
     */
    public PageResult pageQuery4User(int pageNum, int pageSize, Integer status) &#123;
        // 设置分页
        PageHelper.startPage(pageNum, pageSize);

        OrdersPageQueryDTO ordersPageQueryDTO = new OrdersPageQueryDTO();
        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());
        ordersPageQueryDTO.setStatus(status);

        // 分页条件查询
        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        List&lt;OrderVO&gt; list = new ArrayList();

        // 查询出订单明细，并封装入OrderVO进行响应
        if (page != null &amp;&amp; page.getTotal() &gt; 0) &#123;
            for (Orders orders : page) &#123;
                Long orderId = orders.getId();// 订单id

                // 查询订单明细
                List&lt;OrderDetail&gt; orderDetails = orderDetailMapper.getByOrderId(orderId);

                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                orderVO.setOrderDetailList(orderDetails);

                list.add(orderVO);
            &#125;
        &#125;
        return new PageResult(page.getTotal(), list);
    &#125;
</code></pre>
<h4 id="1-2-4-OrderMapper"><a href="#1-2-4-OrderMapper" class="headerlink" title="1.2.4 OrderMapper"></a>1.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 分页条件查询并按下单时间排序
     * @param ordersPageQueryDTO
     */
    Page&lt;Orders&gt; pageQuery(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-5-OrderMapper-xml"><a href="#1-2-5-OrderMapper-xml" class="headerlink" title="1.2.5 OrderMapper.xml"></a>1.2.5 OrderMapper.xml</h4><pre><code class="xml">    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
</code></pre>
<h4 id="1-2-6-OrderDetailMapper"><a href="#1-2-6-OrderDetailMapper" class="headerlink" title="1.2.6 OrderDetailMapper"></a>1.2.6 OrderDetailMapper</h4><pre><code class="java">    /**
     * 根据订单id查询订单明细
     * @param orderId
     * @return
     */
    @Select(&quot;select * from order_detail where order_id = #&#123;orderId&#125;&quot;)
    List&lt;OrderDetail&gt; getByOrderId(Long orderId);
</code></pre>
<h3 id="查询订单详情"><a href="#查询订单详情" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><h6 id="2-2-1-user-x2F-OrderController"><a href="#2-2-1-user-x2F-OrderController" class="headerlink" title="2.2.1 user&#x2F;OrderController"></a>2.2.1 user&#x2F;OrderController</h6><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/orderDetail/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService"><a href="#2-2-2-OrderService" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 查询订单详情
     * @param id
     * @return
     */
    OrderVO details(Long id);
</code></pre>
<h4 id="2-2-3-OrderServiceImpl"><a href="#2-2-3-OrderServiceImpl" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    public OrderVO details(Long id) &#123;
        // 根据id查询订单
        Orders orders = orderMapper.getById(id);

        // 查询该订单对应的菜品/套餐明细
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将该订单及其详情封装到OrderVO并返回
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(orders, orderVO);
        orderVO.setOrderDetailList(orderDetailList);

        return orderVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper"><a href="#2-2-4-OrderMapper" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id=#&#123;id&#125;&quot;)
    Orders getById(Long id);
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><p>业务规则：</p>
<ul>
<li>待支付和待接单状态下，用户可直接取消订单</li>
<li>商家已接单状态下，用户取消订单需电话沟通商家</li>
<li>派送中状态下，用户取消订单需电话沟通商家</li>
<li>如果在待接单状态下取消订单，需要给用户退款</li>
<li>取消订单后需要将订单状态修改为“已取消”</li>
</ul>
<h4 id="3-2-1-user-x2F-OrderController"><a href="#3-2-1-user-x2F-OrderController" class="headerlink" title="3.2.1 user&#x2F;OrderController"></a>3.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel/&#123;id&#125;&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@PathVariable(&quot;id&quot;) Long id) throws Exception &#123;
        orderService.userCancelById(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="3-2-2-OrderService"><a href="#3-2-2-OrderService" class="headerlink" title="3.2.2 OrderService"></a>3.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户取消订单
     * @param id
     */
    void userCancelById(Long id) throws Exception;
</code></pre>
<h4 id="3-2-3-OrderServiceImpl"><a href="#3-2-3-OrderServiceImpl" class="headerlink" title="3.2.3 OrderServiceImpl"></a>3.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @param id
     */
    public void userCancelById(Long id) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
        &#125;

        //订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
        if (ordersDB.getStatus() &gt; 2) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());

        // 订单处于待接单状态下取消，需要进行退款
        if (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            //调用微信支付退款接口
            weChatPayUtil.refund(
                    ordersDB.getNumber(), //商户订单号
                    ordersDB.getNumber(), //商户退款单号
                    new BigDecimal(0.01),//退款金额，单位 元
                    new BigDecimal(0.01));//原订单金额

            //支付状态修改为 退款
            orders.setPayStatus(Orders.REFUND);
        &#125;

        // 更新订单状态、取消原因、取消时间
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(&quot;用户取消&quot;);
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="再来一单"><a href="#再来一单" class="headerlink" title="再来一单"></a>再来一单</h3><h4 id="4-2-1-user-x2F-OrderController"><a href="#4-2-1-user-x2F-OrderController" class="headerlink" title="4.2.1 user&#x2F;OrderController"></a>4.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     * @return
     */
    @PostMapping(&quot;/repetition/&#123;id&#125;&quot;)
    @ApiOperation(&quot;再来一单&quot;)
    public Result repetition(@PathVariable Long id) &#123;
        orderService.repetition(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService"><a href="#4-2-2-OrderService" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
    void repetition(Long id);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl"><a href="#4-2-3-OrderServiceImpl" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
   @Override
    public void repetition(Long id) &#123;
        //查询当前用户id
        Long userId = BaseContext.getCurrentId();
        //根据订单id查询当前订单详情
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(id);

        // 将订单详情对象转换为购物车对象
        // 这一行使用 map 方法对每个 OrderDetail 对象进行转换操作，x 是当前遍历的 OrderDetail 对象
        List&lt;ShoppingCart&gt; shoppingCartList = orderDetailList.stream().map(x -&gt; &#123;
            //表示一个函数，该函数接受一个参数 x 并返回一个新对象
            ShoppingCart shoppingCart = new ShoppingCart();

            // 将原订单详情里面的菜品信息重新复制到购物车对象中
            BeanUtils.copyProperties(x, shoppingCart, &quot;id&quot;);
            shoppingCart.setUserId(userId);
            shoppingCart.setCreateTime(LocalDateTime.now());

            return shoppingCart;
        &#125;).collect(Collectors.toList());
// 使用 collect 方法将转换后的 ShoppingCart 对象收集到一个新的 List&lt;ShoppingCart&gt; 列表中
        // 将购物车对象批量添加到数据库
        shoppingCartMapper.insertBatch(shoppingCartList);
    &#125;
</code></pre>
<h4 id="4-2-4-ShoppingCartMapper"><a href="#4-2-4-ShoppingCartMapper" class="headerlink" title="4.2.4 ShoppingCartMapper"></a>4.2.4 ShoppingCartMapper</h4><pre><code class="java">    /**
     * 批量插入购物车数据
     *
     * @param shoppingCartList
     */
    void insertBatch(List&lt;ShoppingCart&gt; shoppingCartList);
</code></pre>
<h4 id="4-2-5-ShoppingCartMapper-xml"><a href="#4-2-5-ShoppingCartMapper-xml" class="headerlink" title="4.2.5 ShoppingCartMapper.xml"></a>4.2.5 ShoppingCartMapper.xml</h4><pre><code class="xml">&lt;insert id=&quot;insertBatch&quot; parameterType=&quot;list&quot;&gt;
        insert into shopping_cart
        (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)
        values
        &lt;foreach collection=&quot;shoppingCartList&quot; item=&quot;sc&quot; separator=&quot;,&quot;&gt;
            
        &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>
<h3 id="订单搜索"><a href="#订单搜索" class="headerlink" title="订单搜索"></a>订单搜索</h3><h4 id="1-2-1-admin-x2F-OrderController"><a href="#1-2-1-admin-x2F-OrderController" class="headerlink" title="1.2.1 admin&#x2F;OrderController"></a>1.2.1 admin&#x2F;OrderController</h4><p>在admin包下创建OrderController</p>
<pre><code class="java">/**
 * 订单管理
 */
@RestController(&quot;adminOrderController&quot;)
@RequestMapping(&quot;/admin/order&quot;)
@Slf4j
@Api(tags = &quot;订单管理接口&quot;)
public class OrderController &#123;

    @Autowired
    private OrderService orderService;

    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/conditionSearch&quot;)
    @ApiOperation(&quot;订单搜索&quot;)
    public Result&lt;PageResult&gt; conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageResult pageResult = orderService.conditionSearch(ordersPageQueryDTO);
        return Result.success(pageResult);
    &#125;
&#125;
</code></pre>
<h4 id="1-2-2-OrderService-1"><a href="#1-2-2-OrderService-1" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 条件搜索订单
     * @param ordersPageQueryDTO
     * @return
     */
    PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl-1"><a href="#1-2-3-OrderServiceImpl-1" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    public PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());

        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        // 部分订单状态，需要额外返回订单菜品信息，将Orders转化为OrderVO
        List&lt;OrderVO&gt; orderVOList = getOrderVOList(page);

        return new PageResult(page.getTotal(), orderVOList);
    &#125;

    private List&lt;OrderVO&gt; getOrderVOList(Page&lt;Orders&gt; page) &#123;
        // 需要返回订单菜品信息，自定义OrderVO响应结果
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();

        List&lt;Orders&gt; ordersList = page.getResult();
        if (!CollectionUtils.isEmpty(ordersList)) &#123;
            for (Orders orders : ordersList) &#123;
                // 将共同字段复制到OrderVO
                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                String orderDishes = getOrderDishesStr(orders);

                // 将订单菜品信息封装到orderVO中，并添加到orderVOList
                orderVO.setOrderDishes(orderDishes);
                orderVOList.add(orderVO);
            &#125;
        &#125;
        return orderVOList;
    &#125;

    /**
     * 根据订单id获取菜品信息字符串
     *
     * @param orders
     * @return
     */
    private String getOrderDishesStr(Orders orders) &#123;
        // 查询订单菜品详情信息（订单中的菜品和数量）
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）
        List&lt;String&gt; orderDishList = orderDetailList.stream().map(x -&gt; &#123;
            String orderDish = x.getName() + &quot;*&quot; + x.getNumber() + &quot;;&quot;;
            return orderDish;
        &#125;).collect(Collectors.toList());

        // 将该订单对应的所有菜品信息拼接在一起
        return String.join(&quot;&quot;, orderDishList);
    &#125;
</code></pre>
<h3 id="各个状态的订单数量统计"><a href="#各个状态的订单数量统计" class="headerlink" title="各个状态的订单数量统计"></a>各个状态的订单数量统计</h3><h4 id="2-2-1-admin-x2F-OrderController"><a href="#2-2-1-admin-x2F-OrderController" class="headerlink" title="2.2.1 admin&#x2F;OrderController"></a>2.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    @GetMapping(&quot;/statistics&quot;)
    @ApiOperation(&quot;各个状态的订单数量统计&quot;)
    public Result&lt;OrderStatisticsVO&gt; statistics() &#123;
        OrderStatisticsVO orderStatisticsVO = orderService.statistics();
        return Result.success(orderStatisticsVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService-1"><a href="#2-2-2-OrderService-1" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     * @return
     */
    OrderStatisticsVO statistics();
</code></pre>
<h4 id="2-2-3-OrderServiceImpl-1"><a href="#2-2-3-OrderServiceImpl-1" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    public OrderStatisticsVO statistics() &#123;
        // 根据状态，分别查询出待接单、待派送、派送中的订单数量
        Integer toBeConfirmed = orderMapper.countStatus(Orders.TO_BE_CONFIRMED);
        Integer confirmed = orderMapper.countStatus(Orders.CONFIRMED);
        Integer deliveryInProgress = orderMapper.countStatus(Orders.DELIVERY_IN_PROGRESS);

        // 将查询出的数据封装到orderStatisticsVO中响应
        OrderStatisticsVO orderStatisticsVO = new OrderStatisticsVO();
        orderStatisticsVO.setToBeConfirmed(toBeConfirmed);
        orderStatisticsVO.setConfirmed(confirmed);
        orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);
        return orderStatisticsVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper-1"><a href="#2-2-4-OrderMapper-1" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据状态统计订单数量
     * @param status
     */
    @Select(&quot;select count(id) from orders where status = #&#123;status&#125;&quot;)
    Integer countStatus(Integer status);
</code></pre>
<h3 id="查询订单详情-1"><a href="#查询订单详情-1" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><p>业务规则：</p>
<ul>
<li>订单详情页面需要展示订单基本信息（状态、订单号、下单时间、收货人、电话、收货地址、金额等）</li>
<li>订单详情页面需要展示订单明细数据（商品名称、数量、单价）</li>
</ul>
<h4 id="3-2-1-admin-x2F-OrderController"><a href="#3-2-1-admin-x2F-OrderController" class="headerlink" title="3.2.1 admin&#x2F;OrderController"></a>3.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/details/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h3 id="接单"><a href="#接单" class="headerlink" title="接单"></a>接单</h3><p>业务规则：</p>
<ul>
<li>商家接单其实就是将订单的状态修改为“已接单”</li>
</ul>
<h4 id="4-2-1-admin-x2F-OrderController"><a href="#4-2-1-admin-x2F-OrderController" class="headerlink" title="4.2.1 admin&#x2F;OrderController"></a>4.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 接单
     *
     * @return
     */
    @PutMapping(&quot;/confirm&quot;)
    @ApiOperation(&quot;接单&quot;)
    public Result confirm(@RequestBody OrdersConfirmDTO ordersConfirmDTO) &#123;
        orderService.confirm(ordersConfirmDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService-1"><a href="#4-2-2-OrderService-1" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    void confirm(OrdersConfirmDTO ordersConfirmDTO);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl-1"><a href="#4-2-3-OrderServiceImpl-1" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    public void confirm(OrdersConfirmDTO ordersConfirmDTO) &#123;
        Orders orders = Orders.builder()
                .id(ordersConfirmDTO.getId())
                .status(Orders.CONFIRMED)
                .build();

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="拒单"><a href="#拒单" class="headerlink" title="拒单"></a>拒单</h3><p>业务规则：</p>
<ul>
<li>商家拒单其实就是将订单状态修改为“已取消”</li>
<li>只有订单处于“待接单”状态时可以执行拒单操作</li>
<li>商家拒单时需要指定拒单原因</li>
<li>商家拒单时，如果用户已经完成了支付，需要为用户退款</li>
</ul>
<h4 id="5-2-1-admin-x2F-OrderController"><a href="#5-2-1-admin-x2F-OrderController" class="headerlink" title="5.2.1 admin&#x2F;OrderController"></a>5.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 拒单
     *
     * @return
     */
    @PutMapping(&quot;/rejection&quot;)
    @ApiOperation(&quot;拒单&quot;)
    public Result rejection(@RequestBody OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        orderService.rejection(ordersRejectionDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="5-2-2-OrderService"><a href="#5-2-2-OrderService" class="headerlink" title="5.2.2 OrderService"></a>5.2.2 OrderService</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception;
</code></pre>
<h4 id="5-2-3-OrderServiceImpl"><a href="#5-2-3-OrderServiceImpl" class="headerlink" title="5.2.3 OrderServiceImpl"></a>5.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    public void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersRejectionDTO.getId());

        // 订单只有存在且状态为2（待接单）才可以拒单
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == Orders.PAID) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());
        orders.setCancelTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="取消订单-1"><a href="#取消订单-1" class="headerlink" title="取消订单"></a>取消订单</h3><h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><h4 id="6-2-1-admin-x2F-OrderController"><a href="#6-2-1-admin-x2F-OrderController" class="headerlink" title="6.2.1 admin&#x2F;OrderController"></a>6.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@RequestBody OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        orderService.cancel(ordersCancelDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="6-2-2-OrderService"><a href="#6-2-2-OrderService" class="headerlink" title="6.2.2 OrderService"></a>6.2.2 OrderService</h4><pre><code class="java">    /**
     * 商家取消订单
     *
     * @param ordersCancelDTO
     */
    void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception;
</code></pre>
<h4 id="6-2-3-OrderServiceImpl"><a href="#6-2-3-OrderServiceImpl" class="headerlink" title="6.2.3 OrderServiceImpl"></a>6.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @param ordersCancelDTO
     */
    public void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersCancelDTO.getId());

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == 1) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersCancelDTO.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(ordersCancelDTO.getCancelReason());
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="派送订单"><a href="#派送订单" class="headerlink" title="派送订单"></a>派送订单</h3><p>业务规则：</p>
<ul>
<li>派送订单其实就是将订单状态修改为“派送中”</li>
<li>只有状态为“待派送”的订单可以执行派送订单操作</li>
</ul>
<h4 id="7-2-1-admin-x2F-OrderController"><a href="#7-2-1-admin-x2F-OrderController" class="headerlink" title="7.2.1 admin&#x2F;OrderController"></a>7.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @return
     */
    @PutMapping(&quot;/delivery/&#123;id&#125;&quot;)
    @ApiOperation(&quot;派送订单&quot;)
    public Result delivery(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.delivery(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="7-2-2-OrderService"><a href="#7-2-2-OrderService" class="headerlink" title="7.2.2 OrderService"></a>7.2.2 OrderService</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    void delivery(Long id);
</code></pre>
<h4 id="7-2-3-OrderServiceImpl"><a href="#7-2-3-OrderServiceImpl" class="headerlink" title="7.2.3 OrderServiceImpl"></a>7.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    public void delivery(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为3
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为派送中
        orders.setStatus(Orders.DELIVERY_IN_PROGRESS);

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="完成订单"><a href="#完成订单" class="headerlink" title="完成订单"></a>完成订单</h3><p>业务规则：</p>
<ul>
<li>完成订单其实就是将订单状态修改为“已完成”</li>
<li>只有状态为“派送中”的订单可以执行订单完成操作</li>
</ul>
<h4 id="8-2-1-admin-x2F-OrderController"><a href="#8-2-1-admin-x2F-OrderController" class="headerlink" title="8.2.1 admin&#x2F;OrderController"></a>8.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @return
     */
    @PutMapping(&quot;/complete/&#123;id&#125;&quot;)
    @ApiOperation(&quot;完成订单&quot;)
    public Result complete(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.complete(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="8-2-2-OrderService"><a href="#8-2-2-OrderService" class="headerlink" title="8.2.2 OrderService"></a>8.2.2 OrderService</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    void complete(Long id);
</code></pre>
<h4 id="8-2-3-OrderServiceImpl"><a href="#8-2-3-OrderServiceImpl" class="headerlink" title="8.2.3 OrderServiceImpl"></a>8.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    public void complete(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为4
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为完成
        orders.setStatus(Orders.COMPLETED);
        orders.setDeliveryTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="校验收货地址是否超出配送范围"><a href="#校验收货地址是否超出配送范围" class="headerlink" title="校验收货地址是否超出配送范围"></a>校验收货地址是否超出配送范围</h3><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>注册账号：<a target="_blank" rel="noopener" href="https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https%3A%2F%2Flbsyun.baidu.com%2Findex.php%3Ftitle%3D%E9%A6%96%E9%A1%B5</a></p>
<p>登录百度地图开放平台：<a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/">https://lbsyun.baidu.com/</a></p>
<p>进入控制台，创建应用，获取AK：</p>
<p>![image-20221222170049729](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170049729.png)</p>
<p>![image-20221222170256927](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170256927.png)</p>
<p>相关接口:</p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p>
<h2 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h2><h3 id="2-1-application-yml"><a href="#2-1-application-yml" class="headerlink" title="2.1 application.yml"></a>2.1 application.yml</h3><p>配置外卖商家店铺地址和百度地图的AK：</p>
<p>![image-20221222170819582](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170819582.png)</p>
<h3 id="2-2-OrderServiceImpl"><a href="#2-2-OrderServiceImpl" class="headerlink" title="2.2 OrderServiceImpl"></a>2.2 OrderServiceImpl</h3><p>改造OrderServiceImpl，注入上面的配置项：</p>
<pre><code class="java">com/sky/properties/BaiDuProperties.java
package com.sky.properties;

import lombok.Data;
import lombok.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
// 多个prefix
@ConfigurationProperties(prefix = &quot;sky.baidu&quot;)
@Data
public class BaiDuProperties &#123;
    private String shopAddress;
    private String ak;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
  baidu:
    ak: $&#123;sky.baidu.ak&#125;
    shopAddress: $&#123;sky.baidu.shopAddress&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  baidu:
    ak: xxxxxxxxx
    shopAddress: 河北省唐山市丰润区燕山路街道美景花园
</code></pre>
<p>在OrderServiceImpl中提供校验方法：</p>
<pre><code class="java">/**
     * 检查客户的收货地址是否超出配送范围
     * @param address
     */
    private void checkOutOfRange(String address) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;address&quot;, baiDuProperties.getShopAddress());
        map.put(&quot;output&quot;, &quot;json&quot;);
        map.put(&quot;ak&quot;, baiDuProperties.getAk());

        //获取店铺的经纬度坐标
        String shopCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        JSONObject jsonObject = JSON.parseObject(shopCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;店铺地址解析失败&quot;);
        &#125;

        //数据解析
        JSONObject location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        String lat = location.getString(&quot;lat&quot;);
        String lng = location.getString(&quot;lng&quot;);
        //店铺经纬度坐标
        String shopLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;address&quot;,address);
        //获取用户收货地址的经纬度坐标
        String userCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        jsonObject = JSON.parseObject(userCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;收货地址解析失败&quot;);
        &#125;

        //数据解析
        location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        lat = location.getString(&quot;lat&quot;);
        lng = location.getString(&quot;lng&quot;);
        //用户收货地址经纬度坐标
        String userLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;origin&quot;,shopLngLat);
        map.put(&quot;destination&quot;,userLngLat);
        map.put(&quot;steps_info&quot;,&quot;0&quot;);

        //路线规划
        String json = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/directionlite/v1/driving&quot;, map);

        jsonObject = JSON.parseObject(json);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;配送路线规划失败&quot;);
        &#125;

        //数据解析
        JSONObject result = jsonObject.getJSONObject(&quot;result&quot;);
        JSONArray jsonArray = (JSONArray) result.get(&quot;routes&quot;);
        Integer distance = (Integer) ((JSONObject) jsonArray.get(0)).get(&quot;distance&quot;);

        if(distance &gt; 5000)&#123;
            //配送距离超过5000米
            throw new OrderBusinessException(&quot;超出配送范围&quot;);
        &#125;
    &#125;
</code></pre>
<p>在OrderServiceImpl的submitOrder方法中调用上面的校验方法：</p>
<pre><code class="java">   // 检查用户的收获地址是否超出配送范围
        checkOutOfRange(addressBook.getCityName() + addressBook.getDistrictName() + addressBook.getDetail());
</code></pre>
<p>![image-20221222171444981](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222171444981.png)</p>
<h3 id="SpringTask-定时任务-定时自动执行某段Java代码"><a href="#SpringTask-定时任务-定时自动执行某段Java代码" class="headerlink" title="SpringTask[定时任务]定时自动执行某段Java代码"></a>SpringTask[定时任务]<del>定时自动执行某段Java代码</del></h3><p>SpringTask是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul>
<li>信用卡每月还款提醒</li>
<li>银行贷款每月还款提醒</li>
<li>火车票售票系统处理未支付订单</li>
<li>入职纪念日为用户发送通知</li>
</ul>
<h5 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h5><p>cron表达式其实就是一个字符串，通过cron表达式可以<strong>定义任务触发时间</strong><br>构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义<br>每个域的含义分别为：<u>秒、分钟、小时、日、月、周、年</u>(可选)</p>
<h6 id="2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）"><a href="#2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）" class="headerlink" title="2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）"></a>2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）</h6><p>0 0 9 12 10 ？ 2022<br><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com</a></p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分钟</th>
<th>小时</th>
<th>日</th>
<th>月</th>
<th>周</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>？</td>
</tr>
</tbody></table>
<h6 id="SpringTask使用步骤："><a href="#SpringTask使用步骤：" class="headerlink" title="SpringTask使用步骤："></a>SpringTask使用步骤：</h6><ul>
<li>导入maven坐标 spring-context（已存在）</li>
<li>启动类添加注解 <code>@EnableScheduling</code> 开启任务调度</li>
<li><strong>自定义定时任务类</strong></li>
</ul>
<pre><code class="java">sky-server  com/sky/task/MyTask.java
package com.sky.task;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.util.Date;

/**
 * 自定义定时任务类
 */
@Component
@Slf4j
public class MyTask &#123;

    /**
     * 定时任务 每隔5秒触发一次
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void executeTask()&#123;
        log.info(&quot;定时任务开始执行：&#123;&#125;&quot;, new Date());
    &#125;
&#125;
</code></pre>
<h3 id="订单状态定时处理"><a href="#订单状态定时处理" class="headerlink" title="订单状态定时处理"></a>订单状态定时处理</h3><h6 id="用户下单后可能存在的情况："><a href="#用户下单后可能存在的情况：" class="headerlink" title="用户下单后可能存在的情况："></a>用户下单后可能存在的情况：</h6><ul>
<li>下单后未支付，订单一直处于”<strong>待支付</strong>“状态</li>
<li>用户收获后管理端未点击完成按钮，订单一直处于<strong>“派送中”</strong>状态<ul>
<li>通过定时任务<strong>每分钟检查一次</strong>是否存在支付超时订单(超过15min)，如果存在则修改订单状态为”已取消”</li>
<li>通过定时任务<strong>每天凌晨1点检查一次</strong>是否存在”派送中”的订单，如果存在则修改订单状态为”已完成”</li>
</ul>
</li>
</ul>
<h5 id="代码开发：-4"><a href="#代码开发：-4" class="headerlink" title="代码开发："></a>代码开发：</h5><pre><code class="java">sky-server  com/sky/task/OrderTask.java
package com.sky.task;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
@Slf4j
public class OrderTask &#123;
    @Autowired
    private OrderMapper orderMapper;

    /**
     * 处理超时订单的方法
     */
    @Scheduled(cron = &quot;0 * * * * ?&quot;)//每分钟触发一次
    public void processTimeoutOrder()&#123;
        log.info(&quot;定时处理超时订单&quot;);
        // select * from orders where status = ? and order_time = (当前时间 - 15分钟)
        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.CANCELLED);
                orders.setCancelReason(&quot;订单超时，自动取消&quot;);
                orders.setCancelTime(LocalDateTime.now());
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;

    /**
     * 处理一直处于派送中状态的订单
     */
    @Scheduled(cron = &quot;0 0 1 * * ?&quot;)//每天凌晨一点
    public void processDeliveryOrder() &#123;
        log.info(&quot;定时处理处于派送中的订单&quot;);
        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.COMPLETED);
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
    /**
     *
     * 根据订单状态和下单时间查询订单
     * @param status
     * @param orderTime
     * @return
     */
    @Select(&quot;select * from orders where status = #&#123;status&#125; and order_time &lt; #&#123;orderTime&#125;&quot;)
    List&lt;Orders&gt; getByStatusAndOrderTimeLT(Integer status, LocalDateTime orderTime);
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是基于TCP的一种新的<strong>网络协议</strong>，它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持续性</strong>连接，并进行<strong>双向</strong>数据传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/edb75e96dfbeebfac80f0c08ad92001201b8754c/data/WebSocket.png"></p>
<h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><ul>
<li>视频弹幕</li>
<li>网页聊天</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
<h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p><strong>实现步骤：</strong></p>
<ul>
<li>直接使用<strong>websocket.html</strong>页面坐位WebSocket客户端</li>
<li>导入<strong>WebSocket</strong>的maven坐标</li>
<li>导入<strong>WebSocket</strong>服务端组件<strong>WebSocketServer</strong>，用于和客户端通信</li>
<li>导入配置类<strong>WebSocketConfiguration</strong>，注册WebSocket的服务端组件</li>
<li>导入定时人物类<strong>WebSocketTask</strong>，定时向客户端推送数据</li>
</ul>
<pre><code class="html">websocket.html
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;WebSocket Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;
    &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;
    &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt;
    &lt;div id=&quot;message&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if(&#39;WebSocket&#39; in window)&#123;
        //连接WebSocket节点
        websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId);
    &#125;
    else&#123;
        alert(&#39;Not support websocket&#39;)
    &#125;

    //连接发生错误的回调方法
    websocket.onerror = function()&#123;
        setMessageInnerHTML(&quot;error&quot;);
    &#125;;

    //连接成功建立的回调方法
    websocket.onopen = function()&#123;
        setMessageInnerHTML(&quot;连接成功&quot;);
    &#125;

    //接收到消息的回调方法
    websocket.onmessage = function(event)&#123;
        setMessageInnerHTML(event.data);
    &#125;

    //连接关闭的回调方法
    websocket.onclose = function()&#123;
        setMessageInnerHTML(&quot;close&quot;);
    &#125;

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function()&#123;
        websocket.close();
    &#125;

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML)&#123;
        document.getElementById(&#39;message&#39;).innerHTML += innerHTML + &#39;&lt;br/&gt;&#39;;
    &#125;

    //发送消息
    function send()&#123;
        var message = document.getElementById(&#39;text&#39;).value;
        websocket.send(message);
    &#125;
    
    //关闭连接
    function closeWebSocket() &#123;
        websocket.close();
    &#125;
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/sky/websocket/WebSocketServer.java
package com.sky.websocket;

import org.springframework.stereotype.Component;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * WebSocket服务
 */
@Component //交给spring容器管理
@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)
public class WebSocketServer &#123;

    //存放会话对象
    private static Map&lt;String, Session&gt; sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;客户端：&quot; + sid + &quot;建立连接&quot;);
        sessionMap.put(sid, session);
    &#125;

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message);
    &#125;

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;连接断开:&quot; + sid);
        sessionMap.remove(sid);
    &#125;

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) &#123;
        Collection&lt;Session&gt; sessions = sessionMap.values();
        for (Session session : sessions) &#123;
            try &#123;
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/config/WebSocketConfiguration.java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration &#123;

    @Bean
    public ServerEndpointExporter serverEndpointExporter() &#123;
        return new ServerEndpointExporter();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/task/WebSocketTask.java
package com.sky.task;

import com.sky.websocket.WebSocketServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class WebSocketTask &#123;
    @Autowired
    private WebSocketServer webSocketServer;

    /**
     * 通过WebSocket每隔5秒向客户端发送消息
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void sendMessageToClient() &#123;
        webSocketServer.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now()));
    &#125;
&#125;
</code></pre>
<h3 id="来单提醒"><a href="#来单提醒" class="headerlink" title="来单提醒"></a>来单提醒</h3><p>用户下单并且支付成功后，需要第一时间通知外卖商家</p>
<ul>
<li><strong>语音播报</strong></li>
<li><strong>弹出提示框</strong></li>
</ul>
<h6 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h6><ul>
<li>通过WebSocket实现管理端页面和服务端保持长连接状态</li>
<li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li>
<li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li>
<li>约定服务器发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul>
<li>type 为消息类型，1为来单提醒  2为客户催单</li>
<li>orderId 为订单id</li>
<li>content 为消息内容</li>
</ul>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.TO_BE_CONFIRMED);

        // 支付成功后通过 WebSocket 向客户端推送消息
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;type&quot;, 1); // 1 表示来单提醒
        map.put(&quot;orderId&quot;, order.getId());
        map.put(&quot;content&quot;, &quot;订单号：&quot; + ordersPaymentDTO.getOrderNumber());

        webSocketServer.sendToAllClient(JSON.toJSONString(map));


        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;

    &#125;
</code></pre>
<h3 id="用户催单"><a href="#用户催单" class="headerlink" title="用户催单"></a>用户催单</h3><pre><code class="java">com/sky/controller/user/OrderController.java 
/**
     * 客户催单
     * @param id
     * @return
     */
    @GetMapping(&quot;/reminder/&#123;id&#125;&quot;)
    @ApiOperation(&quot;客户催单&quot;)
    public Result reminder(@PathVariable(&quot;id&quot;) Long id)&#123;
        orderService.reminder(id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/OrderService.java
 /**
     * 用户催单
     * @param id
     */
    void reminder(Long id);
</code></pre>
<pre><code class="java">com/sky/service/impl/OrderServiceImpl.java
/**
     * 客户催单
     * @param id
     */
    public void reminder(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Map map = new HashMap();
        map.put(&quot;type&quot;,2); //1表示来单提醒 2表示客户催单
        map.put(&quot;orderId&quot;,id);
        map.put(&quot;content&quot;,&quot;订单号：&quot; + ordersDB.getNumber());

        //通过websocket向客户端浏览器推送消息
        webSocketServer.sendToAllClient(JSON.toJSONString(map));
    &#125;
</code></pre>
<h3 id="ApacheECharts"><a href="#ApacheECharts" class="headerlink" title="ApacheECharts"></a>ApacheECharts</h3><p><a target="_blank" rel="noopener" href="http://echarts.apache.org/zh/index.html">http://echarts.apache.org/zh/index.html</a></p>
<ul>
<li><strong>柱形图</strong> bar</li>
<li><strong>饼形图</strong></li>
<li><strong>折线图</strong></li>
</ul>
<p>使用Echarts，重点在于研究当前图标所需<strong>数据格式</strong>，通常是需要后端提供符合格式要求的动态数据，然后相应给前端来展示图表</p>
<h3 id="营业额统计"><a href="#营业额统计" class="headerlink" title="营业额统计"></a>营业额统计</h3><h6 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>营业额指订单状态为已完成的订单金额合计</li>
<li>基于可视化报表的折线图展示营业额数据，x轴为日期，y轴为营业额</li>
<li>根据时间选择区间，展示每天的营业额数据</li>
</ul>
<h5 id="根据接口定义设计对应的vo："><a href="#根据接口定义设计对应的vo：" class="headerlink" title="根据接口定义设计对应的vo："></a>根据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/TurnoverReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03 [开始到结束的每一天]
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0 [营业额一一对应]
    private String turnoverList;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
 * 数据统计相关接口
 */
@RestController
@RequestMapping(&quot;/admin/report&quot;)
@Api(tags = &quot;数据统计接口&quot;)
@Slf4j
public class ReportController &#123;
    @Autowired
    private ReportService reportService;

    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/turnoverStatistics&quot;)
    public Result&lt;TurnoverReportVO&gt; turnoverStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end) &#123;
        log.info(&quot;营业额统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getTurnoverStatistics(begin,end));
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    @Autowired
    private OrderMapper orderMapper;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end) &#123;
        // 当前集合用于存放从begin到end范围内的每天的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天对应的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天的营业额
        List&lt;Double&gt; turnoverList = new ArrayList&lt;&gt;();
        for (LocalDate date : dateList) &#123; //LocalDate只是年月日 而下单的Order有时分秒
            // 查询Date日期对应的营业额数据，数据额是指：订单状态为“已完成”的订单金额合计
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        // select sum(count) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Map map = new HashMap&lt;&gt;();
            map.put(&quot;begin&quot;, beginTime);
            map.put(&quot;end&quot;, endTime);
            map.put(&quot;status&quot;, Orders.COMPLETED);
            Double turnover = orderMapper.sumByMap(map);
            turnover = turnover == null ? 0.0 : turnover;//没有营业额则默认为0
            turnoverList.add(turnover);
        &#125;

        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .turnoverList(StringUtils.join(turnoverList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计营业额数据
     * @param map
     * @return
     */
    Double sumByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
    &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
    &lt;select id=&quot;sumByMap&quot; resultType=&quot;java.lang.Double&quot;&gt;
        select sum(amount) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>业务规则：</p>
<ul>
<li>根据时间选择区间，展示每天的用户总量和新增用户量数据</li>
</ul>
<h5 id="据接口定义设计对应的vo："><a href="#据接口定义设计对应的vo：" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/UserReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/userStatistics&quot;)
    @ApiOperation(&quot;用户统计&quot;)
    public Result&lt;UserReportVO&gt; userStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end)&#123;
        log.info(&quot;用户数据统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getUserStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
   /**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    UserReportVO getUserStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    /**
     * 统计指定时间区间内的用户数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) &#123;
        // 存放从begin 到 end之间的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);
        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天新增用户数量 select count(id) from user where create_time &gt; ? and create_time &lt; ?
        List&lt;Integer&gt; newUserList = new ArrayList&lt;&gt;();
        // 存放每天的总用户数量 select count(id) from user where create_time &lt;= ?
        List&lt;Integer&gt; totalUserList = new ArrayList&lt;&gt;();

        for (LocalDate date : dateList) &#123;
        // 遍历每一天的用户总量和数量
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);

            Map map = new HashMap&lt;&gt;();
            map.put(&quot;end&quot;, endTime);

            // 总用户数量
            Integer integer = userMapper.countByMap(map);

            map.put(&quot;begin&quot;, beginTime);
            //新增用户数量
            Integer newUser = userMapper.countByMap(map);
            totalUserList.add(integer);
            newUserList.add(newUser);
        &#125;
        return UserReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .totalUserList(StringUtils.join(totalUserList, &quot;,&quot;))
                .newUserList(StringUtils.join(newUserList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单统计"><a href="#订单统计" class="headerlink" title="订单统计"></a>订单统计</h3><h6 id="业务规则-1"><a href="#业务规则-1" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>根据时间选择区间，展示每天的订单总数和有效订单数</li>
<li>展示所选时间区间内的有效订单数、总订单数、订单完成率</li>
<li>订单完成率 &#x3D; 有效订单数 &#x2F; 总订单数 * 100%</li>
</ul>
<h6 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h6><ul>
<li>dataList 日期列表以逗号分隔</li>
<li>orderCompletionRate 订单完成率</li>
<li>orderCountList 订单数列表以逗号分隔</li>
<li>totalOrderCount 订单总数</li>
<li>validOrderCount 有效订单数</li>
<li>validOrderCountList 有效订单数列表以逗号分隔</li>
</ul>
<h5 id="据接口定义设计对应的vo：-1"><a href="#据接口定义设计对应的vo：-1" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/OrderReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Integer totalOrderCount;

    //有效订单数
    private Integer validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 订单统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/ordersStatistics&quot;)
    @ApiOperation(&quot;订单统计&quot;)
    public Result&lt;OrderReportVO&gt; ordersStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)  LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;订单数据统计：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getOrderStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end) &#123;
        //存放从begin到end之间的每天对应的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();

        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        //存放每天的订单总数
        List&lt;Integer&gt; orderCountList = new ArrayList&lt;&gt;();
        //存放每天的有效订单数
        List&lt;Integer&gt; validOrderCountList = new ArrayList&lt;&gt;();

        //遍历dateList集合，查询每天的有效订单数和订单总数
        for (LocalDate date : dateList) &#123;
            //查询每天的订单总数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Integer orderCount = getOrderCount(beginTime, endTime, null);

            //查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Integer validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

            orderCountList.add(orderCount);
            validOrderCountList.add(validOrderCount);
        &#125;

        //计算时间区间内的订单总数量
        Integer totalOrderCount = orderCountList.stream().reduce(Integer::sum).get();

        //计算时间区间内的有效订单数量
        Integer validOrderCount = validOrderCountList.stream().reduce(Integer::sum).get();

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0)&#123;
            //计算订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
        &#125;

        return  OrderReportVO.builder()
                .dateList(StringUtils.join(dateList,&quot;,&quot;))
                .orderCountList(StringUtils.join(orderCountList,&quot;,&quot;))
                .validOrderCountList(StringUtils.join(validOrderCountList,&quot;,&quot;))
                .totalOrderCount(totalOrderCount)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .build();
    &#125;
    /**
     * 根据条件统计订单数量
     * @param begin
     * @param end
     * @param status
     * @return
     */
    private Integer getOrderCount(LocalDateTime begin, LocalDateTime end, Integer status)&#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);
        map.put(&quot;status&quot;,status);

        return orderMapper.countByMap(map);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="销量排名Top10"><a href="#销量排名Top10" class="headerlink" title="销量排名Top10"></a>销量排名Top10</h3><h6 id="产品原型-查已完成的数据"><a href="#产品原型-查已完成的数据" class="headerlink" title="产品原型 (查已完成的数据)"></a>产品原型 (查已完成的数据)</h6><ul>
<li>此处的销量为商品销售的份数</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/top10&quot;)
    @ApiOperation(&quot;销量排名top10&quot;)
    public Result&lt;SalesTop10ReportVO&gt; top10(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;销量排名top10：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getSalesTop10(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
    /**
     * 统计指定时间区间内的销量排名前10
     * @param begin
     * @param end
     * @return
     */
    @Override
    public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end) &#123;
        LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);

        List&lt;GoodsSalesDTO&gt; salesTop10 = orderMapper.getSalesTop10(beginTime, endTime);
        List&lt;String&gt; names = salesTop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());
        String nameList = StringUtils.join(names, &quot;,&quot;);

        List&lt;Integer&gt; numbers = salesTop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());
        String numberList = StringUtils.join(numbers, &quot;,&quot;);

        //封装返回结果数据
        return SalesTop10ReportVO
                .builder()
                .nameList(nameList)
                .numberList(numberList)
                .build();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
  /**
     * 统计指定时间内的销量排名
     * @return
     */
    List&lt;GoodsSalesDTO&gt; getSalesTop10(LocalDateTime begin,LocalDateTime end);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;select id=&quot;getSalesTop10&quot; resultType=&quot;com.sky.dto.GoodsSalesDTO&quot;&gt;
        select od.name, sum(od.number) number
        from order_detail od,orders o
        where od.order_id = o.id and o.status = 5
        &lt;if test=&quot;begin != null&quot;&gt;
            and o.order_time &amp;gt; #&#123;begin&#125;
        &lt;/if&gt;
        &lt;if test=&quot;end != null&quot;&gt;
            and o.order_time &amp;lt; #&#123;end&#125;
        &lt;/if&gt;
        group by od.name
        order by number desc
        limit 0,10
    &lt;/select&gt;
</code></pre>
<h6 id="重装数据库"><a href="#重装数据库" class="headerlink" title="重装数据库"></a>重装数据库</h6><pre><code class="mysql">C:\Windows\System32&gt;cd D:\MySQL\MySQL Server 8.0\bin

C:\Windows\System32&gt;mysqld --install MySQL80
Service successfully installed.

C:\Windows\System32&gt;sc query | findstr MySQL

C:\Windows\System32&gt;net start MySQL80
MySQL80 服务正在启动 .
MySQL80 服务已经启动成功。
服务里的MySQL80是Mysql服务
-----------------------------------------------------------------------------------------

C:\Windows\System32&gt;cd D:\MariaDB 11.0\bin

C:\Windows\System32&gt;mysqld --install MariaDB
Service successfully installed.

C:\Windows\System32&gt;net start MariaDB
MariaDB 服务正在启动 .
MariaDB 服务无法启动。
服务里的MariaDB是MariaDB服务
</code></pre>
<h3 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h3><h5 id="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"><a href="#工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率" class="headerlink" title="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"></a>工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率</h5><p>功能工作台展示的数据：</p>
<ul>
<li>今日数据</li>
<li>订单管理</li>
<li>菜品总览</li>
<li>套餐总览</li>
<li>订单信息</li>
</ul>
<h6 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h6><ul>
<li>营业额：已完成订单的总金额</li>
<li>有效订单：已完成订单的数量</li>
<li>订单完成率：有效订单数 &#x2F; 总订单数 * 100%</li>
<li>平均客单价：营业额 &#x2F; 有效订单数</li>
<li>新增用户：新增用户的数量</li>
</ul>
<h6 id="接口设计：-5"><a href="#接口设计：-5" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>今日数据接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;businessData<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单管理接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewOrders<br>Method: Get</p>
</blockquote>
</li>
<li><p>菜品总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewDishes<br>Method: Get</p>
</blockquote>
</li>
<li><p>套餐总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewSetmeals<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单搜索(已完成)</p>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/WorkSpaceController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * 工作台
 */
@RestController
@RequestMapping(&quot;/admin/workspace&quot;)
@Slf4j
@Api(tags = &quot;工作台相关接口&quot;)
public class WorkSpaceController &#123;

    @Autowired
    private WorkspaceService workspaceService;

    /**
     * 工作台今日数据查询
     * @return
     */
    @GetMapping(&quot;/businessData&quot;)
    @ApiOperation(&quot;工作台今日数据查询&quot;)
    public Result&lt;BusinessDataVO&gt; businessData()&#123;
        //获得当天的开始时间
        LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN);
        //获得当天的结束时间
        LocalDateTime end = LocalDateTime.now().with(LocalTime.MAX);

        BusinessDataVO businessDataVO = workspaceService.getBusinessData(begin, end);
        return Result.success(businessDataVO);
    &#125;

    /**
     * 查询订单管理数据
     * @return
     */
    @GetMapping(&quot;/overviewOrders&quot;)
    @ApiOperation(&quot;查询订单管理数据&quot;)
    public Result&lt;OrderOverViewVO&gt; orderOverView()&#123;
        return Result.success(workspaceService.getOrderOverView());
    &#125;

    /**
     * 查询菜品总览
     * @return
     */
    @GetMapping(&quot;/overviewDishes&quot;)
    @ApiOperation(&quot;查询菜品总览&quot;)
    public Result&lt;DishOverViewVO&gt; dishOverView()&#123;
        return Result.success(workspaceService.getDishOverView());
    &#125;

    /**
     * 查询套餐总览
     * @return
     */
    @GetMapping(&quot;/overviewSetmeals&quot;)
    @ApiOperation(&quot;查询套餐总览&quot;)
    public Result&lt;SetmealOverViewVO&gt; setmealOverView()&#123;
        return Result.success(workspaceService.getSetmealOverView());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/WorkspaceService.java
package com.sky.service;

import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import java.time.LocalDateTime;

public interface WorkspaceService &#123;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);

    /**
     * 查询订单管理数据
     * @return
     */
    OrderOverViewVO getOrderOverView();

    /**
     * 查询菜品总览
     * @return
     */
    DishOverViewVO getDishOverView();

    /**
     * 查询套餐总览
     * @return
     */
    SetmealOverViewVO getSetmealOverView();

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/WorkspaceServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.StatusConstant;
import com.sky.entity.Orders;
import com.sky.mapper.DishMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.UserMapper;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService &#123;

    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) &#123;
        /**
         * 营业额：当日已完成订单的总金额
         * 有效订单：当日已完成订单的数量
         * 订单完成率：有效订单数 / 总订单数
         * 平均客单价：营业额 / 有效订单数
         * 新增用户：当日新增用户的数量
         */

        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);

        //查询总订单数
        Integer totalOrderCount = orderMapper.countByMap(map);

        map.put(&quot;status&quot;, Orders.COMPLETED);
        //营业额
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null? 0.0 : turnover;

        //有效订单数
        Integer validOrderCount = orderMapper.countByMap(map);

        Double unitPrice = 0.0;

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0 &amp;&amp; validOrderCount != 0)&#123;
            //订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
            //平均客单价
            unitPrice = turnover / validOrderCount;
        &#125;

        //新增用户数
        Integer newUsers = userMapper.countByMap(map);

        return BusinessDataVO.builder()
                .turnover(turnover)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .unitPrice(unitPrice)
                .newUsers(newUsers)
                .build();
    &#125;


    /**
     * 查询订单管理数据
     *
     * @return
     */
    public OrderOverViewVO getOrderOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;, LocalDateTime.now().with(LocalTime.MIN));
        map.put(&quot;status&quot;, Orders.TO_BE_CONFIRMED);

        //待接单
        Integer waitingOrders = orderMapper.countByMap(map);

        //待派送
        map.put(&quot;status&quot;, Orders.CONFIRMED);
        Integer deliveredOrders = orderMapper.countByMap(map);

        //已完成
        map.put(&quot;status&quot;, Orders.COMPLETED);
        Integer completedOrders = orderMapper.countByMap(map);

        //已取消
        map.put(&quot;status&quot;, Orders.CANCELLED);
        Integer cancelledOrders = orderMapper.countByMap(map);

        //全部订单
        map.put(&quot;status&quot;, null);
        Integer allOrders = orderMapper.countByMap(map);

        return OrderOverViewVO.builder()
                .waitingOrders(waitingOrders)
                .deliveredOrders(deliveredOrders)
                .completedOrders(completedOrders)
                .cancelledOrders(cancelledOrders)
                .allOrders(allOrders)
                .build();
    &#125;

    /**
     * 查询菜品总览
     *
     * @return
     */
    public DishOverViewVO getDishOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = dishMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = dishMapper.countByMap(map);

        return DishOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;

    /**
     * 查询套餐总览
     *
     * @return
     */
    public SetmealOverViewVO getSetmealOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = setmealMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = setmealMapper.countByMap(map);

        return SetmealOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据条件统计菜品数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/DishMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from dish
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/SetmealMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h6 id="在Java中操控Excel文件-读写操作"><a href="#在Java中操控Excel文件-读写操作" class="headerlink" title="在Java中操控Excel文件 [读写操作]"></a>在Java中操控Excel文件 [读写操作]</h6><p>Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目，POI都是用于操作Excel文件</p>
<h6 id="Apache-POI应用场景："><a href="#Apache-POI应用场景：" class="headerlink" title="Apache POI应用场景："></a>Apache POI应用场景：</h6><ul>
<li><strong>银行网银系统</strong>导出交易明细</li>
<li>各种业务系统到出Excel报表</li>
<li>批量导入业务数据</li>
</ul>
<pre><code class="java">sky-server  com/sky/test/POITest.java
package com.sky.test;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

public class POITest &#123;
    /**
     * 通过POI创建Excel文件并且写入文件内容
     */
    public static void write() throws Exception &#123;
        // 在内存中创建一个Excel文件
        XSSFWorkbook excel = new XSSFWorkbook();
        // 在Excel文件中创建一个sheet页
        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);
        // 在Sheet中创建行对象, rownum编号从0开始
        XSSFRow row = sheet.createRow(1);
        // 创建单元格并写入文件内容
        row.createCell(1).setCellValue(&quot;姓名&quot;);
        row.createCell(2).setCellValue(&quot;城市&quot;);

        // 创建一个新行
        row = sheet.createRow(2);
        row.createCell(1).setCellValue(&quot;张三&quot;);
        row.createCell(2).setCellValue(&quot;北京&quot;);

        row = sheet.createRow(3);
        row.createCell(1).setCellValue(&quot;李四&quot;);
        row.createCell(2).setCellValue(&quot;南京&quot;);

        // 通过输出流将内存中的Excel文件写入到磁盘
        FileOutputStream out = new FileOutputStream(new File(&quot;C:\\Users\\Pluminary\\Desktop\\itcast.xlsx&quot;));
        excel.write(out);

        // 关闭资源
        out.close();
        excel.close();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        write();
    &#125;
&#125;
</code></pre>
<h3 id="导出运营数据Excel报表"><a href="#导出运营数据Excel报表" class="headerlink" title="导出运营数据Excel报表"></a>导出运营数据Excel报表</h3><h6 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h6><ul>
<li>设计Excel模板文件</li>
<li>查询近30天的运营数据</li>
<li>将查询到的运营数据写入模板文件</li>
<li>通过输出流将Excel文件下载到客户端浏览器</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/vo/BusinessDataVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 数据概览
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable &#123;

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 导出运营数据报表
     * @param response
     */
    @GetMapping(&quot;/export&quot;)
    @ApiOperation(&quot;导出运营数据报表&quot;)
    public void export(HttpServletResponse response) &#123;
        reportService.exportBusinessData(response);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
 /**
     * 导出运营数据报表
     * @param response
     */
    void exportBusinessData(HttpServletResponse response);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
/**
     * 导出运营数据报表
     * @param response
     */
    @Override
    public void exportBusinessData(HttpServletResponse response) &#123;
        // 查询数据库 获取营业数据 -- 查询最近30天的营业数据
        LocalDate dateBegin = LocalDate.now().minusDays(30);
        LocalDate dateEnd = LocalDate.now().minusDays(1);
        // 查询概览数据
        BusinessDataVO businessDataVO = workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN),LocalDateTime.of(dateEnd, LocalTime.MAX));

        // 查询的数据通过POI写入Excel文件中 (获得对象 获得类加载器 类加载器读取资源)
        InputStream in = this.getClass().getClassLoader().getResourceAsStream(&quot;template/运营数据报表模板.xlsx&quot;);
        try &#123;
            // 基于模板文件创建一个新的Excel文件
            XSSFWorkbook excel = new XSSFWorkbook();

            // 填充数据 [获取标签页]

            XSSFSheet sheet = excel.getSheet(&quot;Sheet1&quot;);
            // 获取第二行[索引是从0开始]
            sheet.getRow(1).createCell(1).setCellValue(&quot;时间：&quot; + dateBegin + &quot;至&quot; + dateEnd);

            // 获得第四行
            XSSFRow row = sheet.getRow(3);
            row.getCell(2).setCellValue(businessDataVO.getTurnover());//营业额
            row.getCell(4).setCellValue(businessDataVO.getOrderCompletionRate());//订单完成率
            row.getCell(6).setCellValue(businessDataVO.getNewUsers());//新增用户数

            // 获得第五行
            row = sheet.getRow(4);
            row.getCell(2).setCellValue(businessDataVO.getValidOrderCount());//有效订单数
            row.getCell(4).setCellValue(businessDataVO.getUnitPrice());//平均单品价格

            // 填充明细数据
            for (int i = 0; i &lt; 30; i++) &#123;
                LocalDate date = dateBegin.plusDays(i);
                // 查询某一天的营业数据
                workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));
                // 获得某一行
                row = sheet.getRow(7 + i);// 利用循环 超越循环
                row.getCell(1).setCellValue(date.toString());
                row.getCell(2).setCellValue(businessDataVO.getTurnover());
                row.getCell(3).setCellValue(businessDataVO.getValidOrderCount());
                row.getCell(6).setCellValue(businessDataVO.getOrderCompletionRate());
                row.getCell(4).setCellValue(businessDataVO.getUnitPrice());
                row.getCell(5).setCellValue(businessDataVO.getNewUsers());
            &#125;

            // 通过输出流将Excel文件下载到客户端浏览器
            ServletOutputStream out = response.getOutputStream();
            excel.write(out);

            // 关闭资源
            out.close();
            excel.close();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>