
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 多线程与分布式</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>多线程与分布式 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/4
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#1bccbc>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="多线程与分布式-周介绍"><a href="#多线程与分布式-周介绍" class="headerlink" title="多线程与分布式 [周介绍]"></a>多线程与分布式 [周介绍]</h1><ul>
<li><h6 id="线程池的基本使用、特点、注意点"><a href="#线程池的基本使用、特点、注意点" class="headerlink" title="线程池的基本使用、特点、注意点"></a>线程池的基本使用、特点、注意点</h6></li>
<li><h6 id="ThreadLoacal的基本使用、原理和注意事项"><a href="#ThreadLoacal的基本使用、原理和注意事项" class="headerlink" title="ThreadLoacal的基本使用、原理和注意事项"></a>ThreadLoacal的基本使用、原理和注意事项</h6></li>
<li><h6 id="分布式基础、核心概念"><a href="#分布式基础、核心概念" class="headerlink" title="分布式基础、核心概念"></a>分布式基础、核心概念</h6></li>
<li><h6 id="docker的下载、安装和基本命令"><a href="#docker的下载、安装和基本命令" class="headerlink" title="docker的下载、安装和基本命令"></a>docker的下载、安装和基本命令</h6></li>
<li><h6 id="独立制作docker容器"><a href="#独立制作docker容器" class="headerlink" title="独立制作docker容器"></a>独立制作docker容器</h6></li>
<li><h6 id="Nginx的安装、基本使用和使用命令"><a href="#Nginx的安装、基本使用和使用命令" class="headerlink" title="Nginx的安装、基本使用和使用命令"></a>Nginx的安装、基本使用和使用命令</h6></li>
<li><h6 id="使用Nginx搭建文件服务"><a href="#使用Nginx搭建文件服务" class="headerlink" title="使用Nginx搭建文件服务"></a>使用Nginx搭建文件服务</h6></li>
<li><h6 id="消息队列RabbitMQ的核心概念queue、message和exchange"><a href="#消息队列RabbitMQ的核心概念queue、message和exchange" class="headerlink" title="消息队列RabbitMQ的核心概念queue、message和exchange"></a>消息队列RabbitMQ的核心概念queue、message和exchange</h6></li>
<li><h6 id="RabbitMQ的四种交换机模式"><a href="#RabbitMQ的四种交换机模式" class="headerlink" title="RabbitMQ的四种交换机模式"></a>RabbitMQ的四种交换机模式</h6></li>
<li><h6 id="SpringBoot整合RabbitMQ案例"><a href="#SpringBoot整合RabbitMQ案例" class="headerlink" title="SpringBoot整合RabbitMQ案例"></a>SpringBoot整合RabbitMQ案例</h6></li>
</ul>
<h2 id="线程池-——-治理线程的法宝"><a href="#线程池-——-治理线程的法宝" class="headerlink" title="线程池 —— 治理线程的法宝"></a>线程池 —— 治理线程的法宝</h2><ul>
<li>线程池的<strong>自我介绍</strong></li>
<li><strong>创建</strong>和停止线程池</li>
<li><strong>常见线程池</strong>的特点和用法</li>
<li>任务太多，怎么<strong>拒绝</strong></li>
<li>钩子方法，给线程池加点料</li>
<li>实现<strong>原理、源码分析</strong></li>
<li>使用线程池的注意点</li>
</ul>
<h5 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h5><ul>
<li>线程池的重要性 [可以复用我们的线程]</li>
<li>什么是”池” – 软件中的”池”，可以理解为计划经济</li>
<li>如果不适用线程池，每个任务都新开一个线程处理<ul>
<li>一个线程</li>
<li>for循环创建线程</li>
<li>当任务数量上升到1000<br><code>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题</code>[多了会报错 内存不足异常]</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/ForLoop.java
package threadpool;
/**
 * 描述：     TODO
 */
public class ForLoop &#123;

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Thread thread = new Thread(new Task());
            thread.start();
        &#125;
    &#125;

    static class Task implements Runnable &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;执行了任务&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>加快响应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h5 id="线程池使用应用的场合"><a href="#线程池使用应用的场合" class="headerlink" title="线程池使用应用的场合"></a>线程池使用应用的场合</h5><ul>
<li>服务器(Tomcat)接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少现成的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h3 id="线程增减的时机"><a href="#线程增减的时机" class="headerlink" title="线程增减的时机"></a>线程增减的时机</h3><h5 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h5><ul>
<li>线程池<strong>构造方法的参数</strong></li>
<li>线程池应该<strong>手动创建</strong>还是自动创建</li>
<li>线程池里的<strong>线程数量</strong>设定为多少比较合适</li>
<li><strong>停止</strong>线程池的方法</li>
</ul>
<h5 id="线程池构造方法的参数"><a href="#线程池构造方法的参数" class="headerlink" title="线程池构造方法的参数"></a>线程池构造方法的参数</h5><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>由于线程池无法接收你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h5 id="参数中的corePoolSize和maxPoolSize"><a href="#参数中的corePoolSize和maxPoolSize" class="headerlink" title="参数中的corePoolSize和maxPoolSize"></a>参数中的corePoolSize和maxPoolSize</h5><ul>
<li><p><strong>corePoolSize</strong>指的是核心线程数<br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新的线程去执行任务</p>
</li>
<li><p>最大量<strong>maxPoolSize</strong><br>在核心线程数的基础上，格外增加的线程数的上限</p>
</li>
</ul>
<h5 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h5><ol>
<li>如果线程数小于corePoolSize，创建一个新线程来运行新任务</li>
<li>如果线程数等于(或大于) corePoolSize但少于maximumPoolSize，则将任务放入<strong>队列</strong></li>
<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个<strong>新线程</strong></li>
<li>如果队列已满，并且线程数大于或等于maxPoolSize，则<strong>拒绝</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4cb2755066dc76e6602ff1110cfc24124f38b42f/data/%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png"></p>
<ul>
<li>是否需要增加线程的判断顺序是：<ul>
<li>corePoolSize</li>
<li>workQueue</li>
<li>maxPoolSize</li>
</ul>
</li>
</ul>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h6><ul>
<li>线程池：核心池大小为5，最大池大小为10，队列为100</li>
<li>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝</li>
</ul>
<h5 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h5><ul>
<li>通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池</li>
<li>线程池<strong>希望保持较小的线程数</strong>，并且只有在负载变得很大时才增加它</li>
<li>通过设置maximumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li>
<li>只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无界队列，那么线程数就不会超过corePoolSize</li>
</ul>
<h3 id="线程存活时间和工作队列"><a href="#线程存活时间和工作队列" class="headerlink" title="线程存活时间和工作队列"></a>线程存活时间和工作队列</h3><h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><ul>
<li>如果线程池当前的线程多余corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止</li>
</ul>
<h5 id="ThreadFactory-用来创建线程"><a href="#ThreadFactory-用来创建线程" class="headerlink" title="ThreadFactory 用来创建线程"></a>ThreadFactory 用来创建线程</h5><ul>
<li>默认使用Executors.defaultThreadFactory()</li>
<li>创建出来的线程都在同一个线程组</li>
<li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等</li>
</ul>
<h5 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h5><ul>
<li>有三种最常见的队列类型<ul>
<li>直接交接：SynchronousQueue</li>
<li>无界队列：LinkedBlockingQueue</li>
<li>有界队列：ArrayBlockingQueue</li>
</ul>
</li>
</ul>
<h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><h5 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h5><ul>
<li>手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险<br>自动创建线程池(即直接调用JDK封装好的构造方法) 可能会带来哪些问题？</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>容易造成大量内存占用，可能会导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/FixedThreadPoolThread.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FixedThreadPoolThread &#123;
    public static void main(String[] args) &#123; //核心线程数量
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
class Task implements Runnable&#123;

    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;
=======================================================================
pool-1-thread-3
pool-1-thread-4
pool-1-thread-1
pool-1-thread-2
    
pool-1-thread-3
pool-1-thread-1
pool-1-thread-4
pool-1-thread-2
因为核心线程数量只规定了4个 这有这四个线程跑程序
</code></pre>
<pre><code class="java">threadpool/FixedThreadPoolOOM.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示nexFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM &#123;
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123;
            executorService.execute(new SubThread());
        &#125;
    &#125;
&#125;
class SubThread implements Runnable&#123;

    @Override
    public void run() &#123;
        try&#123;//一直睡觉 不让它结束
            Thread.sleep(1000000000);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=======================================================================
报错：java.lang.OutOfMemoryError:GC overhead limilt exceeded
</code></pre>
<ul>
<li><strong>newSingleThreadExecutor</strong> [单独的线程]<ul>
<li>当请求堆积的时候，可能会占用大量的内存</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/SingleThreadExecutor.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutor &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
=======================================================================
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
</code></pre>
<ul>
<li><strong>CachedThreadPool</strong> [可缓存线程池]<ul>
<li>特点：具有自动回收多余线程的功能</li>
<li>弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE, 这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/CachedThreadPool.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>newScheduledThreadPool</strong> [跟时间相关的]</li>
</ul>
<pre><code class="java">threadpool/ScheduledThreadPool.java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPool &#123;
    public static void main(String[] args) &#123;
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);//每隔3s运行
    &#125;
&#125;
</code></pre>
<ul>
<li>正确的创建线程池的方法<ul>
<li><strong>根据不同的业务场景</strong>，设置线程池参数</li>
<li>比如：内存有多大，给线程取什么名字等等</li>
</ul>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="线程池里的线程数量设定为多少比较合适？"><a href="#线程池里的线程数量设定为多少比较合适？" class="headerlink" title="线程池里的线程数量设定为多少比较合适？"></a>线程池里的线程数量设定为多少比较合适？</h3><ul>
<li><strong>CPU密集型</strong>(加密、计算hash等)：最佳线程数为CPU核心数的1-2倍左右</li>
<li><strong>耗时IO型</strong>(读写数据库、文件、网络读写等)：最佳线程数一般会大于CPU核心数很多倍<br>参考Brain Goetz推荐的计算方法：<br><span style = "color:red"><strong>线程数 &#x3D; CPU核心数 × (1 + 平均等待时间 &#x2F; 平均工作时间)</strong></span></li>
</ul>
<h3 id="对比各种线程池的特点"><a href="#对比各种线程池的特点" class="headerlink" title="对比各种线程池的特点"></a>对比各种线程池的特点</h3><h5 id="常见的线程池的特点"><a href="#常见的线程池的特点" class="headerlink" title="常见的线程池的特点"></a>常见的线程池的特点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee67f47de97062e593b16348ff148cd52f7b7d6e/data/%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg"></p>
<h5 id="以上4种线程池的构造方法的参数"><a href="#以上4种线程池的构造方法的参数" class="headerlink" title="以上4种线程池的构造方法的参数"></a>以上4种线程池的构造方法的参数</h5><table>
<thead>
<tr>
<th>Parameter</th>
<th>FixedThreadPool</th>
<th>CachedThreadPool</th>
<th>ScheduledThreadPool</th>
<th>SingleThreaded</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>constructor-arg</td>
<td>0</td>
<td>constructor-arg</td>
<td>1</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>same as corePoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>Integer.MAX_VALUE</td>
<td>1</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>0 seconds</td>
<td>60 seconds</td>
<td>0 seconds</td>
<td>0 seconds</td>
</tr>
</tbody></table>
<h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><ul>
<li>FixedThreadPool和SingleThreadExecutor的Queue是<strong>LinedBlockingQueue</strong>？</li>
<li>CachedThreadPool使用的是Queue是<strong>SynchronousQueue</strong>？</li>
<li>ScheduledThreadPool使用延迟队列DelayedWorkQueue</li>
</ul>
<h5 id="workStealingPool是JDK1-8加入的"><a href="#workStealingPool是JDK1-8加入的" class="headerlink" title="workStealingPool是JDK1.8加入的"></a>workStealingPool是JDK1.8加入的</h5><ul>
<li>这个线程池和之前的都有很大不同</li>
<li>子任务</li>
<li>窃取 [并行执行]</li>
</ul>
<h3 id="如何正确关闭线程池"><a href="#如何正确关闭线程池" class="headerlink" title="如何正确关闭线程池"></a>如何正确关闭线程池</h3><h5 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h5><ul>
<li><strong>shutdown</strong> [再给就拒绝 新的任务不会增加了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        executorService.execute(new ShutDownTask());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

=================================================================================
pool-1-thread-4
pool-1-thread-9
pool-1-thread-10
Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpool.ShutDownTask@61bbe9ba rejected from java.util.concurrent.ThreadPoolExecutor@610455d6[Shutting down, pool size = 10, active threads = 10, queued tasks = 970, completed tasks = 20]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
    at threadpool.Shutdown.main(Shutdown.java:18)
pool-1-thread-8
pool-1-thread-1
pool-1-thread-3
</code></pre>
<ul>
<li><strong>isShutdown</strong> [判断是否进入停止状态]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>isTerminated</strong> [线程停止返回 整个程序执行完毕]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
        System.out.println(executorService.isTerminated());
        Thread.sleep(10000);
        System.out.println(executorService.isTerminated());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
==========================================================================
pool-1-thread-5
pool-1-thread-10
false
true
false
pool-1-thread-2
pool-1-thread-6
pool-1-thread-6
pool-1-thread-2
true
</code></pre>
<ul>
<li><strong>awaitTermination</strong> [测试一段时间内线程会不会完全停止的方法 <u>等待的时间进程被打乱了</u> 等待的时间到了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdown();
        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
        System.out.println(b);
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>shutdownNow</strong> [立刻关闭线程池]</li>
</ul>
<pre><code class="java">///正在执行的和不要关闭 正在等待的内容直接返回 如何优雅编写？
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdownNow();//暴力关闭线程
        //这是正在队列中的数据 取了个List集合 都到runnableList里面了 要给它一个交代
        List&lt;Runnable&gt; runnableList = executorService.shutdownNow();
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;被中断了&quot;);
        &#125;
    &#125;
&#125;

=================================================================
pool-1-thread-6
pool-1-thread-4
pool-1-thread-10
pool-1-thread-8
pool-1-thread-3被中断了
pool-1-thread-1被中断了
pool-1-thread-8被中断了
pool-1-thread-2被中断了
</code></pre>
<h3 id="暂停和恢复线程池"><a href="#暂停和恢复线程池" class="headerlink" title="暂停和恢复线程池"></a>暂停和恢复线程池</h3><ul>
<li><strong>拒绝时机</strong><ul>
<li>当Executor关闭时，提交<strong>新任务</strong>会<strong>被拒绝</strong></li>
<li>以及当Executor对最大线程和工作队列容量使用有限边界并且<strong>已经饱和</strong>时</li>
</ul>
</li>
</ul>
<h5 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h5><ul>
<li><strong>AbortPolicy</strong> [直接抛出异常]</li>
<li><strong>DiscardPolicy</strong> [默默的丢弃]</li>
<li><strong>DiscardOldestPolicy</strong> [丢弃最老的]</li>
<li><strong>CallerRunsPolicy</strong> [誰提交任务誰去跑(避免了业务损失 提交任务速度下降 给了线程池缓冲时间)]</li>
</ul>
<h5 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h5><ul>
<li>每个任务执行前后</li>
<li>日志、统计</li>
<li>代码演示</li>
</ul>
<pre><code class="java">threadpool/PauseableThreadPool.java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor &#123;
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;

    @Override //在执行任务之前都会调用这个函数
    protected void beforeExecute(Thread t, Runnable r) &#123;
        super.beforeExecute(t, r);
        lock.lock();
        //如果检测到就暂停休息
        try &#123;
            while (isPaused) &#123;
                unpaused.await();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void pause()&#123;
        lock.lock();
        try&#123;
            isPaused = true;
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    public void resume()&#123;
        lock.lock();
        try&#123;
            isPaused = false;
            unpaused.signalAll(); //唤醒全部
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());
        Runnable runnable = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我被执行&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;;
        for (int i = 0; i &lt; 10000; i++) &#123;
            pauseableThreadPool.execute(runnable);
        &#125;
            Thread.sleep(1500);
            pauseableThreadPool.pause();
            System.out.println(&quot;线程池被暂停了&quot;);
            Thread.sleep(1500);
            pauseableThreadPool.resume();
            System.out.println(&quot;线程池被恢复了&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="线程池实现复用的原因"><a href="#线程池实现复用的原因" class="headerlink" title="线程池实现复用的原因"></a>线程池实现复用的原因</h3><ul>
<li>线程池组成部分<ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口(Task)</li>
</ul>
</li>
</ul>
<h5 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h5><ul>
<li><p>线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，都是什么关系？</p>
<p>Executor ← ExecutorService ← AbstractExecutorService ← ThreadPoolExecutor</p>
</li>
</ul>
<h5 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h5><ul>
<li>相同线程执行不同任务</li>
</ul>
<h3 id="线程池状态和使用注意点"><a href="#线程池状态和使用注意点" class="headerlink" title="线程池状态和使用注意点"></a>线程池状态和使用注意点</h3><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>接收新任务并处理排队任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不接受新任务，但处理排队任务</td>
</tr>
<tr>
<td>STOP</td>
<td>不接受新任务，也不处理排队任务，并中断正在进行的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminate()运行完成</td>
</tr>
</tbody></table>
<h5 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h5><ul>
<li>避免任务<strong>堆积</strong></li>
<li>避免线程数<strong>过度增加</strong></li>
<li>排查<strong>线程泄露</strong></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h6 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h6><ul>
<li>让某个需要用到的对象在<strong>线程间隔离</strong></li>
<li>在任何方法中都可以<strong>轻松获取</strong>到该对象 .get</li>
</ul>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问) 时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是ptivate static类型的，用于关联线程和线程上下文，它的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂性。</p>
<ul>
<li>定义：提供<strong>线程局部</strong>变量；一个线程局部变量在多个线程中，分别由独立的值(副本)</li>
<li>特点：简单(开箱即用)、快速(无格外开销)、安全(线程安全)</li>
<li>场景：多线程场景(<strong>资源持有、线程一致性、并发计算、线程安全</strong>等场景)</li>
<li>实现原理：Java中使用<strong>哈希表</strong>实现</li>
<li>应用范围：几乎<strong>所有</strong>提供多线程特征的语言</li>
<li>设计者追求开箱即用的体验</li>
</ul>
<h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><ul>
<li>构造函数 <strong>ThreadLocal<T>()</strong></li>
<li>初始化 <strong>initialValue()</strong><ul>
<li>该方法会返回当前线程对应的”初始值”，这是一个<strong>延迟加载</strong>的方法，只有在<strong>调用get</strong>的时候，才会触发</li>
<li>当线程<strong>第一次使用get</strong>方法访问变量时，将调用此方法</li>
<li>每个线程最多调用<strong>一次</strong>此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法</li>
<li>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来**重写initialValue()**方法</li>
</ul>
</li>
<li>访问器 T <strong>get</strong>()：得到这个线程对应的value，如果是首次调用get()则会调用initialize来得到这个值 &#x2F;&#x2F; void <strong>set</strong>(T t)：为这个线程设置一个新值</li>
<li>回收 void <strong>remove</strong>(): 删除这个线程</li>
</ul>
<h6 id="根据共享对象的生成时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生成时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生成时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生成时机不同，选择initialValue或set来保存对象</h6><h6 id="场景一：initialValue"><a href="#场景一：initialValue" class="headerlink" title="场景一：initialValue"></a>场景一：initialValue</h6><ul>
<li>在ThreadLocal<strong>第一次get</strong>的时候把对象給初始化出来，对象的初始化时机可以<strong>由我们控制</strong></li>
</ul>
<h6 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h6><ul>
<li>如果需要保存到ThreadLocal里的对象的生成时机<strong>不由我们随机控制</strong>，例如拦截器生成的用户信息</li>
<li>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</li>
</ul>
<h6 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h6><ul>
<li>达到<strong>线程安全</strong></li>
<li><strong>不需要加锁</strong>，提高执行<strong>效率</strong></li>
<li>更高效地<strong>利用内存、节省开销</strong></li>
<li><strong>避免传参</strong>的繁琐</li>
</ul>
<pre><code class="java">threadpool/ThreadLocalAPI.java
package threadpool;

public class ThreadLocalAPI &#123;
    public static ThreadLocal&lt;Long&gt; x = new ThreadLocal()&#123;
        @Override
        protected Long initialValue()&#123;
            System.out.println(&quot;Inital Value run...&quot;);
            return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        new Thread() &#123;
            @Override
            public void run() &#123;
                System.out.println(x.get());
            &#125;
        &#125;.start(); //调用一次initialValue 每个线程单独拥有一个
        x.set(101l);
        x.remove();//清空线程 结果为1 因为 Thread.currentThread().getId();
        System.out.println(x.get());//发现x.remove被移除了 结果去重新触发initialValue
        System.out.println(x.get());
    &#125;
&#125;
========================================================================
Inital Value run...
Inital Value run...
20
1
1

若注释掉x.remove则会出现结果：
Inital Value run...
101
101
20
</code></pre>
<h3 id="ThreadLocal的4种核心场景"><a href="#ThreadLocal的4种核心场景" class="headerlink" title="ThreadLocal的4种核心场景"></a>ThreadLocal的4种核心场景</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e19e3d304bdfe6eeda2ae3a7f83a22ad4b9f274c/data/ThreadLocal%E7%9A%844%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF.png"></p>
<ul>
<li><strong>持有资源</strong>——持有线程资源供线程的各个部分使用，全局获取，减少<strong>编程难度</strong></li>
<li><strong>线程一致</strong>——帮助需要保持线程一致的资源(如数据库事务) 维护一致性，降低<strong>编程难度</strong></li>
<li><strong>线程安全</strong>——帮助只考虑了单线程的程序库，无缝向多线程场景迁移</li>
</ul>
<h3 id="ThreadLocal并发场景分析01"><a href="#ThreadLocal并发场景分析01" class="headerlink" title="ThreadLocal并发场景分析01"></a>ThreadLocal并发场景分析01</h3><h5 id="例1-200QPS压测统计接口"><a href="#例1-200QPS压测统计接口" class="headerlink" title="例1 200QPS压测统计接口"></a>例1 200QPS压测统计接口</h5><ul>
<li>观察200QPS下Spring框架的执行情况</li>
<li>目标：理解并发、竞争条件、临界区等概念</li>
<li>代表场景：交易场景</li>
</ul>
<h5 id="并发、竞争条件和临界区"><a href="#并发、竞争条件和临界区" class="headerlink" title="并发、竞争条件和临界区"></a>并发、竞争条件和临界区</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7abcc6448891d1b18f32a37dcaf90210ca396b58/data/ThreadLocal%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF.jpg" alt="ThreadLocal并发场景"></p>
<ul>
<li>并发：多个程序<strong>同时执行</strong></li>
<li>竞争条件：多个进程(线程)同时访问<strong>同一个内存资源</strong>，最终的执行结果依赖于多个进程执行时的<strong>精确时序</strong></li>
<li>临界区：访问共享内存的程序片段</li>
</ul>
<pre><code class="java">StatController.java
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;
    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Integer&gt; c = new ThreadLocal&lt;Integer&gt;() &#123;
        @Override
        protected Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
    synchronized void _add() throws InterruptedException &#123;
        Thread.sleep(100);
        c.set(c.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return c.get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;

&#125;
</code></pre>
<pre><code class="java">SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>基于线程池模型synchronize(排队操作很危险)</li>
<li>用ThreadLocal收集数据很快速且安全</li>
<li>思考：如何在多个ThreadLocal中收集数据？</li>
</ul>
<h3 id="ThreadLocal场景分析——减少同步"><a href="#ThreadLocal场景分析——减少同步" class="headerlink" title="ThreadLocal场景分析——减少同步"></a>ThreadLocal场景分析——减少同步</h3><h5 id="ThreadLocal-lt-T-gt-同步"><a href="#ThreadLocal-lt-T-gt-同步" class="headerlink" title="ThreadLocal&lt; T &gt;同步"></a>ThreadLocal&lt; T &gt;同步</h5><pre><code class="java">StatController.java    高效解决高并发
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.HashSet;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;

    static HashSet&lt;Val&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
    synchronized static void addSet(Val&lt;Integer&gt; v)&#123;
        set.add(v);
    &#125;

    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = new ThreadLocal&lt;Val&lt;Integer&gt;&gt;() &#123;
        @Override
        protected Val&lt;Integer&gt; initialValue() &#123;
            Val&lt;Integer&gt; v = new Val&lt;&gt;();
            v.set(0);
            //set.add(v);//容易产生同步问题 小锁一下
            return v;
        &#125;
    &#125;;

    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
/*synchronized*/void _add() throws InterruptedException &#123;
        Thread.sleep(100); //高并发
        Val&lt;Integer&gt; v = c.get();
        v.set(v.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return set.stream().map(x -&gt; x.get()).reduce((a, x) -&gt; a + x).get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Val.java
package com.imooc.springbootlearn;

public class Val&lt;T&gt;&#123;
    T v;
    public void set(T _v)&#123;
        v = _v;
    &#125;
    public T get()&#123;
        return v;
    &#125;
&#125;
</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>完全避免同步(<strong>难</strong>)</li>
<li>缩小同步范围(<strong>简单</strong>) + ThreadLocal解决问题</li>
<li>思考：还可以用在哪些场景？</li>
</ul>
<h6 id="源码分析1-Quartz-SimpleSemaphore"><a href="#源码分析1-Quartz-SimpleSemaphore" class="headerlink" title="源码分析1-Quartz SimpleSemaphore"></a>源码分析1-Quartz SimpleSemaphore</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/d20d4cb3a98413a2fb910922671f8a98e6d114a5/data/Quartz%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>Quartz的SimpleSemaphore提供资源隔离(上锁)</li>
<li>SimpleSemaphore中的lockOwners(ThreadLocal)为重度锁操作前置过滤</li>
<li>思考：学易，用难！</li>
</ul>
<h6 id="源码分析2-Mybatis框架保持连接池线程一致"><a href="#源码分析2-Mybatis框架保持连接池线程一致" class="headerlink" title="源码分析2-Mybatis框架保持连接池线程一致"></a>源码分析2-Mybatis框架保持连接池线程一致</h6><h5 id="什么是本地事务"><a href="#什么是本地事务" class="headerlink" title="什么是本地事务"></a>什么是本地事务</h5><ul>
<li>A(Atomic)原子性，操作不可分割</li>
<li>C(Consistency)一致性，任何时刻数据都能保持一致</li>
<li>I(Isolation)隔离性，多事务并发执行的时许不影响结果</li>
<li>D(Durability)持久性，对数据结构的存储是永久的</li>
</ul>
<p>Begin → [本地事务：(更新订单状态 →&lt;订单状态更新成功&gt;→发放资源) → <strong>资源发放成功(提交)</strong> → Commit →&lt;持久化&gt;→DB。**若资源发放失败(回滚)**→Rollback]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9693ffeda32d871b1665958a7febca56da0011bd/data/Mybatis%E6%A1%86%E6%9E%B6%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%BA%BF%E7%A8%8B%E4%B8%80%E8%87%B4.jpg"></p>
<h6 id="源码分析03-Spring框架对分布式事务的支持"><a href="#源码分析03-Spring框架对分布式事务的支持" class="headerlink" title="源码分析03 Spring框架对分布式事务的支持"></a>源码分析03 Spring框架对分布式事务的支持</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/b2cc782319836bb4d81765c38fe5b8de5098bb21/data/Spring%E6%A1%86%E6%9E%B6%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81.jpg"></p>
<h3 id="技术选型——实现自己的ThreadLocal"><a href="#技术选型——实现自己的ThreadLocal" class="headerlink" title="技术选型——实现自己的ThreadLocal"></a>技术选型——实现自己的ThreadLocal</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec226021e343c1f8dbc268e9809361c629e6cb4d/data/threadLocalMap.jpg"></p>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;

class MyThreadLocal&lt;T&gt; &#123;
    static HashMap&lt;Thread, HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this)) &#123;
            map.put(this, initialValue());
        &#125;
        return (T) map.get(this);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this, v);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Test.java
package com.imooc.springbootlearn;

public class Test &#123;
    static MyThreadLocal&lt;Long&gt; v = new MyThreadLocal&lt;Long&gt;()&#123;
        @Override
        protected Long initialValue() &#123;
         return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        for (Integer i = 0; i &lt; 100; i++) &#123;
            new Thread(()-&gt;&#123;
                System.out.println(v.get());
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>HashMap中直接存储了MyThreadLocal的引用，导致内存无法回收</li>
<li>思考：可以用整数ID替代对MyThreadLocal的引用</li>
</ul>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

class MyThreadLocal&lt;T&gt; &#123;
    static AtomicInteger atomic = new AtomicInteger(); //保证数据唯一性
    Integer threadLocalHash = atomic.addAndGet(0x61c88647); //这个值保证hash的更平均性
    static HashMap&lt;Thread, HashMap&lt;Integer, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;Integer, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;Integer, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this.threadLocalHash)) &#123;
            map.put(this.threadLocalHash, initialValue());
        &#125;
        return (T) map.get(this.threadLocalHash);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this.threadLocalHash, v);
    &#125;
&#125;
</code></pre>
<ul>
<li>HashMap无限增加？初始空间分配是否合理？</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h5 id="源码解读——哈希表实现ThreadLocal"><a href="#源码解读——哈希表实现ThreadLocal" class="headerlink" title="源码解读——哈希表实现ThreadLocal"></a>源码解读——哈希表实现ThreadLocal</h5><h6 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h6><p><strong>哈希表</strong>(散列 HashTable) 根据键(Key) 访问&#x2F;设置内存中存储的位置的值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c2851c7bd5792200e8f9af16f6f08a33520c6f2d/data/%E9%80%89%E5%AD%A6HashTable.png"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构是严密且精确的东西(切记夸夸其谈)</li>
<li>并发是一个很危险的场景，提高能力才会获得安全感</li>
<li>保持怀疑，持续学习</li>
<li>会用 → 场景查找 → 轻量实现 → 源码对照 → 场景沉淀</li>
<li>程序架构：低耦合(独立)、高内聚(组合做到开箱即用)</li>
<li>无论达到什么高度，要永远认为自己是个<strong>菜鸡</strong></li>
</ul>
<h2 id="分布式章节"><a href="#分布式章节" class="headerlink" title="分布式章节"></a>分布式章节</h2><ul>
<li><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5></li>
<li><h5 id="分布式的作用"><a href="#分布式的作用" class="headerlink" title="分布式的作用"></a>分布式的作用</h5></li>
<li><h5 id="分布式和单体结构的对比"><a href="#分布式和单体结构的对比" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5></li>
<li><p><strong>CAP</strong>定理</p>
</li>
<li><p><span style = "color:red"><strong>集群、分布式、微服务</strong></span>的区别</p>
</li>
</ul>
<h3 id="什么是分布式-1"><a href="#什么是分布式-1" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><ul>
<li><p>利用物理架构形成多个自治的处理元素，<strong>不共享主内存</strong>，但是通过<strong>发送信息</strong>合作。</p>
</li>
<li><h6 id="饭店初始的例子"><a href="#饭店初始的例子" class="headerlink" title="饭店初始的例子"></a>饭店初始的例子</h6><ul>
<li><strong>一个</strong>厨师 [单例]</li>
<li><strong>多个</strong>厨师 </li>
<li>术业有<strong>专攻</strong>：配菜师、洗菜工</li>
</ul>
</li>
<li><p>实际项目的演进过程</p>
<ul>
<li>一个项目，<strong>大而全</strong></li>
<li><strong>多台机器</strong>，部署相同的应用</li>
<li><strong>分布式</strong>：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h3 id="分布式的作用-1"><a href="#分布式的作用-1" class="headerlink" title="分布式的作用"></a>分布式的作用</h3><h5 id="为什么需要分布式"><a href="#为什么需要分布式" class="headerlink" title="为什么需要分布式"></a>为什么需要分布式</h5><ul>
<li>实际工作中的痛点<ul>
<li>工程<strong>臃肿</strong> [相互耦合 相互冲突]</li>
<li>测试、上线<strong>繁琐</strong></li>
<li>开发<strong>效率低</strong></li>
</ul>
</li>
</ul>
<h5 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h5><ul>
<li>应用代码<strong>耦合</strong>严重，功能扩展难</li>
<li>新需求开发交互周期长，测试工作量大</li>
<li>新加入的开发同事需要很长时间才能熟悉系统</li>
<li>升级维护也很困难(改动任何一点地方都要升级整个系统)</li>
<li>系统性能提升艰难，可用性低，不稳定</li>
</ul>
<h5 id="分布式的好处"><a href="#分布式的好处" class="headerlink" title="分布式的好处"></a>分布式的好处</h5><ul>
<li>增大系统容量</li>
<li>加强系统可用[某个模块出bug 但不影响其他]</li>
<li>因为模块化，所以系统模块重用度更高</li>
<li>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快</li>
<li>系统<strong>扩展性</strong>更高</li>
<li>团队<strong>协作流程</strong>也会得到改善</li>
<li><strong>技术升级</strong></li>
</ul>
<h3 id="单体和分布式的对比"><a href="#单体和分布式的对比" class="headerlink" title="单体和分布式的对比"></a>单体和分布式的对比</h3><h5 id="分布式和单体结构的对比-1"><a href="#分布式和单体结构的对比-1" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体构架</th>
<th>分布式构架</th>
</tr>
</thead>
<tbody><tr>
<td><strong>新人的学习成本</strong></td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td><strong>部署、运维</strong></td>
<td>容易</td>
<td>发布频繁，顺序复杂、运维难</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>难度低</td>
<td>难度指数级上升</td>
</tr>
<tr>
<td><strong>系统性能</strong></td>
<td>响应快、吞吐量小</td>
<td>响应慢、吞吐量大</td>
</tr>
<tr>
<td><strong>测试成本</strong></td>
<td>低</td>
<td>很高</td>
</tr>
<tr>
<td><strong>技术多样性</strong></td>
<td>技术单一且封闭</td>
<td>技术多样且开放</td>
</tr>
<tr>
<td><strong>系统扩展性</strong></td>
<td>扩展性差</td>
<td>扩展性很好</td>
</tr>
<tr>
<td><strong>系统管理成本</strong></td>
<td>成本低</td>
<td>成本高</td>
</tr>
</tbody></table>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>基本概念、用途、核心思想</li>
<li>Docker的组成、架构、重要概念</li>
<li>Docker的安装</li>
<li><strong>第一个Docker容器</strong></li>
<li>运用Nginx镜像，并访问到Docker容器内部 [从外部进行访问]</li>
<li>制作自己的Docker容器，<strong>dockerfile</strong>实战</li>
</ul>
<h3 id="Docker的基本概念、用途、核心思想"><a href="#Docker的基本概念、用途、核心思想" class="headerlink" title="Docker的基本概念、用途、核心思想"></a>Docker的基本概念、用途、核心思想</h3><ul>
<li>Docker应用广泛<br>京东618：15万个Docker实例，所有业务全部容器化</li>
<li>Docker是什么？<br>[以前的图标是大鲸鱼拖着集装箱]<ul>
<li>Docker是一个用来装程序及其环境的<strong>容器</strong>[类似于<u>安装包.exe</u>]，属于Linux容器的一种封装，提供简单易用的容器使用接口。它是目前<strong>最流行</strong>的Linux容器解决方案</li>
<li>比喻：客车可以装人，衣柜可以放衣服 [Windows下写的小游戏也可以放在Docker中]</li>
</ul>
</li>
</ul>
<h3 id="为什么需要Docker"><a href="#为什么需要Docker" class="headerlink" title="为什么需要Docker"></a>为什么需要Docker</h3><ul>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机[资源占用很多 模拟一套完整系统但步骤多(有些步骤无法跳过) 启动慢]</li>
<li>Docker的基础——<strong>Linux容器</strong> [体积小 速度快 轻量级虚拟机]</li>
</ul>
<h3 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h3><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务 [解决双十一淘宝+天猫 数据量剧增问题]</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong> [程序相互之间可以隔离]</li>
<li>部署简单 运维简单 节省服务器资源</li>
</ul>
<h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><h5 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h5><ul>
<li><p><strong>运输方式</strong>(把程序和环境从一个机器运送到另一个机器)</p>
</li>
<li><p><strong>存储方式</strong>(程序和环境的存储)</p>
</li>
<li><p><strong>API接口</strong>(不需要Tomcat等应用的命令了，都标准化了)</p>
</li>
<li><p><strong>灵活</strong>：即使是最复杂的应用也可以集装箱化</p>
</li>
<li><p><strong>轻量级</strong>：容器利用并共享主机内核</p>
</li>
<li><p><strong>便携式</strong>：可以在本地构建，部署到云，并在任何地方运行</p>
</li>
</ul>
<h5 id="Docker带来的好处"><a href="#Docker带来的好处" class="headerlink" title="Docker带来的好处"></a>Docker带来的好处</h5><ul>
<li>开发团队的好处 完全可以控制所有的环境[同一个镜像] 降低了风险</li>
</ul>
<h3 id="image镜像"><a href="#image镜像" class="headerlink" title="image镜像"></a>image镜像</h3><ul>
<li>存储：联合文件系统，UnionFS</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h3 id="容器和仓库"><a href="#容器和仓库" class="headerlink" title="容器和仓库"></a>容器和仓库</h3><ul>
<li><strong>镜像类似于Java中的类，而容器就是实例化</strong></li>
<li>容器的这一层是可以修改的，而镜像是不可以修改的</li>
<li>同一个镜像可以生成多个容器独立运行，而她们之间没有任何的干扰</li>
</ul>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul>
<li><strong>hub.docker.com</strong></li>
<li><a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></li>
<li>共有、私有</li>
</ul>
<h5 id="client和deamon"><a href="#client和deamon" class="headerlink" title="client和deamon"></a>client和deamon</h5><ul>
<li><strong>client</strong>[<strong>客户端</strong>]：提供給用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务器</li>
<li><strong>deamon</strong>：<strong>服务端</strong>守护进程，接收Client发送的命令并执行相应的操作</li>
</ul>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><ul>
<li><h6 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h6><a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop/">Docker Desktop: The #1 Containerization Tool for Developers | Docker</a></li>
</ul>
<h5 id="更换系统镜像"><a href="#更换系统镜像" class="headerlink" title="更换系统镜像"></a>更换系统镜像</h5><p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a> → 实例 → 更多 → 更换操作系统 → CentOS 7.6 64位</p>
<pre><code class="java">C:\Users\Pluminary&gt;ssh root@47.98.225.105
    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:THXnakQ0Se5ee+d7oHO0NYKBTW7mhEKc426m9+rQgnk.
Please contact your system administrator.
Add correct host key in C:\\Users\\Pluminary/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in C:\\Users\\Pluminary/.ssh/known_hosts:7
Host key for 47.98.225.105 has changed and you have requested strict checking.
Host key verification failed.
    
//使用命令或手动删除 C:\\Users\\Pluminary/.ssh/known_hosts 防火墙拦截了
vim C:\\Users\\Pluminary/.ssh/known_hosts

C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:Panchunyao123!

[root@iZbp1dssknxftmjczbtpndZ ~]# cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
//yum地址换成国内yum源
   //wget-O 这是大写的字母O 含义是放到指定目录下 替换本地文件为国内文件
[root@iZbp1dssknxftmjczbtpndZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
[root@iZbp1dssknxftmjczbtpndZ ~]# yum clean all
[root@iZbp1dssknxftmjczbtpndZ ~]# yum makecache //读取新的源

//较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。
[root@iZbp1dssknxftmjczbtpndZ ~]# yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
//如果yum报告未安装这些软件包，也没问题。
    //更新yum 先查看需要更新哪些
[root@iZbp1dssknxftmjczbtpndZ ~]# yum check-update
[root@iZbp1dssknxftmjczbtpndZ ~]# yum update
// 安装所需的软件包
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install -y yum-utils \
                  device-mapper-persistent-data \
                  lvm2
// 使用以下命令来设置稳定的存储库 sudo是用超级管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

// 查看docker版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list docker-ce --showduplicates | sort -r
// 安装指定的版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io
// Docker 是服务器----客户端架构
// 命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl start docker
// 安装完成后，运行下面的命令，验证是否安装成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# docker version 或者 docker info
</code></pre>
<h3 id="第一个Docker容器"><a href="#第一个Docker容器" class="headerlink" title="第一个Docker容器"></a>第一个Docker容器</h3><ul>
<li><span style = "color:red"><strong>下载镜像</strong></span></li>
<li><strong>docker pull [OPTIONS] NAME[:TAG]</strong></li>
<li><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong> 查看本机有没有任何镜像</li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
c1ec31eb5944: Pull complete
Digest: sha256:53641cd209a4fecfc68e21a99871ce8c6920b2e7502df0a20671c6fccc73a7c6
Status: Downloaded newer image for hello-world:latest
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              d2c94e258dcb        11 months ago       13.3kB
</code></pre>
<ul>
<li><span style = "color:red"><strong>运行镜像</strong></span></li>
<li><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello-world
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal. 

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><h5 id="运行Nginx镜像，并访问到Docker容器内部"><a href="#运行Nginx镜像，并访问到Docker容器内部" class="headerlink" title="运行Nginx镜像，并访问到Docker容器内部"></a>运行Nginx镜像，并访问到Docker容器内部</h5><ul>
<li><strong>前台、后台</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker images //查看一下程序镜像是否还在
[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hub.c.163.com/library/nginx:1.13.0
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hub.c.163.com/library/nginx:1.13.0
//上面的没反应是正常情况，再开一个cmd窗口


//第二个窗口：另一个cmd窗口 
C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:
Last login: Sun Apr  7 16:30:40 2024 from 182.102.75.173

Welcome to Alibaba Cloud Elastic Compute Service !
//展示当前容器列表
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED              STATUS              PORTS               NAMES
298f7e19f6a8        hub.c.163.com/library/nginx:1.13.0   &quot;nginx -g &#39;daemon of…&quot;   About a minute ago   Up About a minute   80/tcp              kind_taussig
//这时回到第一个窗口 ctrl+c 关掉运行 这时去第二个窗口docker ps的时候已经没有了
// ↓↓↓↓↓↓ 要把Nginx在后台运行才可以解决上述问题 ↓↓↓↓↓↓
[root@iZbp1dssknxftmjczbtpndZ ~]# docekr run -d hub.c.163.com/library/nginx:1.13.0
f124fc9171824e508639768b800efba5c780385dc1d135ab0ff70d80d3d75510 //返回容器ID
//此时再去第二个窗口 docker ps就会看到 CONTAINER ID 有f124fc917182
//第一个窗口 查看容器内部的风景 -i让容器输入有效 t是給我们分配一个终端 bash是启动终端
[root@iZbp1dssknxftmjczbtpndZ ~]# docker exec -it f124 bash //让docker明白我们让哪个启动
root@f124fc917182:/#  //已经进入到容器内部
root@f124fc917182:/# pwd
/
root@f124fc917182:/# touch 1 //创建了一个1
root@f124fc917182:/# ls
1  bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@f124fc917182:/# which nginx
/usr/sbin/nginx
</code></pre>
<h3 id="Docker三种网络模式-网络会隔离-需要配置进行端口映射"><a href="#Docker三种网络模式-网络会隔离-需要配置进行端口映射" class="headerlink" title="Docker三种网络模式 [网络会隔离 需要配置进行端口映射]"></a>Docker三种网络模式 [网络会隔离 需要配置进行端口映射]</h3><ul>
<li><strong>Bridge</strong> 网卡网络独立的端口</li>
<li><strong>Host</strong> 同步宿主机的端口</li>
<li>None</li>
<li>端口映射技术</li>
</ul>
<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><ul>
<li>访问Docker内的Nginx</li>
</ul>
<pre><code class="java">cmd窗口2
[root@iZbp1dssknxftmjczbtpndZ ~]# docker stop f12
f12
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps //目前没有容器在运行了
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    //-p 本机的8080端口去映射内部的80端口 前面的是本机 后面的是容器内部的
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -p 8080:80 hub.c.163.com/library/nginx:1.13.0
3906129ced72b668581a58dc36595b08734b82e247e2927eb2a8da6fbe7508ae
//拔出端口的信息
[root@iZbp1dssknxftmjczbtpndZ ~]# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在网页上输入 http://47.98.225.105:8080/

Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.
Thank you for using nginx.

这个不是在宿主机启动的nginx 而是在容器中启动的【通过宿主机中转 并通过Bridge实现独立】
★★ 通过一台服务器上去布置多台Docker 而每台docker里面是独立的 并且可以通过一个端口 来实现和外界的映射关系 ★★
//这个与7行代码的区别 这里是大P 将这个容器的所有端口都进行映射
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -P hub.c.163.com/library/nginx:1.13.0
</code></pre>
<h3 id="制作自己的Docker容器，dockerfile实战"><a href="#制作自己的Docker容器，dockerfile实战" class="headerlink" title="制作自己的Docker容器，dockerfile实战"></a>制作自己的Docker容器，dockerfile实战</h3><p>[把自己的软件程序打包好传給别人]</p>
<ul>
<li>dockerfile作用</li>
<li>使用dockerfile的好处[一目了然 哪个环境跑在什么环境下 非常方便知道如何配置]</li>
<li>写一个自己的dockerfile</li>
</ul>
<blockquote>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
</blockquote>
<pre><code class="sql">FROM alpine:latest #继承父类 alpine及其小的环境
MAINTAINER imooc   #描述这个镜像由誰维护的
CMD echo &#39;hello my dockerfile&#39;  #进入任何想要的dockerfile命令
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# touch Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# vim Dockerfile
//按小写i进入编辑模式  按ESC退出编辑模式 :wq会保存
//取名字 .dockerfile现在的路径
[root@iZbp1dssknxftmjczbtpndZ ~]# docker build -t hello_docker .
    //先发送到服务器
Sending build context to Docker daemon  285.7kB
    //从父类中拉取下来
Step 1/3 : FROM alpine:latest
latest: Pulling from library/alpine
4abcf2066143: Pull complete
Digest: sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b
Status: Downloaded newer image for alpine:latest
 ---&gt; 05455a08881e
    //写定它的维护者
Step 2/3 : MAINTAINER imooc
 ---&gt; Running in 38a73abca50e
Removing intermediate container 38a73abca50e
---&gt; f44831f49afe
    //把这个语句写进去
Step 3/3 : CMD echo &#39;hello my dockerfile&#39;
 ---&gt; Running in 1ff431539208
Removing intermediate container 1ff431539208
 ---&gt; f45b88d0cabc
Successfully built f45b88d0cabc
Successfully tagged hello_docker:latest

//运行自己的镜像
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello_docker                  latest              f45b88d0cabc        3 minutes ago       7.38MB
alpine                        latest              05455a08881e        2 months ago        7.38MB
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello_docker
hello my dockerfile
</code></pre>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul>
<li><h6 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h6></li>
<li><h6 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h6></li>
<li><h6 id="常用命令讲解和演示"><a href="#常用命令讲解和演示" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h6></li>
<li><h6 id="配置文件讲解"><a href="#配置文件讲解" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h6></li>
<li><h6 id="场景实战：搭建一个静态文件的Nginx服务"><a href="#场景实战：搭建一个静态文件的Nginx服务" class="headerlink" title="场景实战：搭建一个静态文件的Nginx服务"></a>场景实战：搭建一个静态文件的Nginx服务</h6></li>
</ul>
<h3 id="Nginx介绍-1"><a href="#Nginx介绍-1" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><ul>
<li>Nginx是什么、适用场景</li>
<li>Nginx应用广泛</li>
<li>Nginx优点</li>
</ul>
<h4 id="Nginx是什么、适用场景"><a href="#Nginx是什么、适用场景" class="headerlink" title="Nginx是什么、适用场景"></a>Nginx是什么、适用场景</h4><ul>
<li>HTTP的<strong>反向代理</strong>服务器</li>
<li><strong>动态静态</strong>资源分离</li>
</ul>
<h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><span style = "color:red">正向代理</span></h5><p>普通的请求转发，客户端把信息传递到代理服务器，代理服务器找到信息转发给我们<br>提供安全功能 代理服务器有防火墙，可以隐藏自身的信息 </p>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><span style = "color:red">反向代理</span></h5><p>提供安全和防火墙 在多个服务器后端提供负载均衡 为服务器提供缓存 把来自用户的压力平均分配[负载均衡]</p>
<h5 id="动态静态资源分离-加速访问-整体速度提高"><a href="#动态静态资源分离-加速访问-整体速度提高" class="headerlink" title="动态静态资源分离 [加速访问 整体速度提高]"></a><span style = "color:red">动态静态资源分离</span> [加速访问 整体速度提高]</h5><ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会<strong>直接</strong>获取到当前请求的文件并返回</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx应用广泛"><a href="#Nginx应用广泛" class="headerlink" title="Nginx应用广泛"></a>Nginx应用广泛</h3><h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><ul>
<li>高并发、高性能</li>
<li>可扩展性好</li>
<li>高可靠性 [服务器运行可以达到数年之久]</li>
<li>热部署</li>
<li>开源、可商用</li>
</ul>
<h3 id="Nginx的安装-1"><a href="#Nginx的安装-1" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h5 id="Nginx在CentOs安装"><a href="#Nginx在CentOs安装" class="headerlink" title="Nginx在CentOs安装"></a>Nginx在CentOs安装</h5><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# yum install yum-utils
[root@iZbp1dssknxftmjczbtpndZ ~]# vim /etc/yum.repos.d/nginx.repo  //输入源信息 告诉它从哪下载
//输入：3-18行 配置源
[root@iZbp1dssknxftmjczbtpndZ ~]# [nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
    //然后查看源 列出可以使用的ngix地址
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list | grep nginx
    //运行安装命令
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install nginx 1:1.16.1-1.el7.ngx
    //查看版本，若出现版本号，则安装成功
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -v
nginx version: nginx/1.24.0
用whereis nginx可以查看到目录：
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
</code></pre>
<h3 id="常用命令讲解和演示-1"><a href="#常用命令讲解和演示-1" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h3><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# /usr/sbin/ngix 启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl stop docker //把之前的docker关停
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -aux | grep nginx //提取相关进程 80是默认端口
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -h //提取帮助
    
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /etc/nginx
[root@iZbp1dssknxftmjczbtpndZ nginx]# ls //里面有nginx.conf配置文件 conf.d中也有一个defalut.conf
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
[root@iZbp1dssknxftmjczbtpndZ nginx]# cd conf.d/
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c   //读取指定配置文件
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop //停止nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //以这个文件启动nginx

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //发布前的测试
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop
[root@iZbp1dssknxftmjczbtpndZ conf.d]# /usr/sbin/nginx //开启nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //查看使用的哪个配置文件
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -v //打印版本信息
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -V //打印详细参数
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# whereis uginx//找nginx的路径
nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
[root@iZbp1dssknxftmjczbtpndZ conf.d]# ps aux | grep nginx //打印进程信息

    //-s信号 1.stop立即停止 2.quit优雅停止 3.reload重启[优雅停止quit] 4.reopen更换日志文件
</code></pre>
<h3 id="配置文件讲解-1"><a href="#配置文件讲解-1" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h3><ul>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>“; “ 结尾</li>
<li>“{}” 组织多条指令 </li>
<li>“include” 引入</li>
<li>‘’#’’ 注释</li>
</ul>
</li>
<li><h5 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h5></li>
<li><h5 id="默认配置文件分析"><a href="#默认配置文件分析" class="headerlink" title="默认配置文件分析"></a>默认配置文件分析</h5><ul>
<li>nginx.conf</li>
<li>default.conf</li>
</ul>
</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ conf.d]# cat /etc/nginx/nginx.conf //打开文件配置
nginx.conf配置文件讲解
首先我们进入到cd etc/nginx.然后通过ls查看nginx目录的相关内容。在nginx目录下，我们需要关注nginx.conf文件，这个文件是我们的主配置文件，cat打开：
cat nginx.conf 【效果显示在下方分割线后】

[root@iZbp1dssknxftmjczbtpndZ conf.d]# cd /usr/share/nginx/html
[root@iZbp1dssknxftmjczbtpndZ html]# vim stst.html //新建文件
[root@iZbp1dssknxftmjczbtpndZ html]# ls
50x.html     index.html
[root@iZbp1dssknxftmjczbtpndZ html# vim test.html //新建一个html文件保存下来
//i编辑       hello nginx           esc + :wq
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //启动！
//如果不显示一定是服务器规则组的问题  自定义 TCP    目的:1/65535   源:0.0.0.0/0
网址输入：http://47.98.225.105/test.html 
============================================================================
# 运行用户，默认是nginx
user  nginx;
# nginx进程数,一般设置为和cpu核数一样
worker_processes  1;

# 全局错误日志路径
error_log  /var/log/nginx/error.log warn;
# 进程pid路径
pid        /var/run/nginx.pid;
 
events &#123;
# 最大连接数
    worker_connections  1024;
&#125;

# 设置http服务器
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
# 设置日志的格式
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
# 访问日志的路径
    access_log  /var/log/nginx/access.log  main;

# 开启高效传输模式
    sendfile        on;
    #tcp_nopush     on;
# 长连接超时时间，单位是秒
    keepalive_timeout  65;
#传输时是否压缩，压缩的话需要解压，但是传的大小就小了
    #gzip  on;
#加载其他的配置文件，一带多
    include /etc/nginx/conf.d/*.conf;
&#125;
============================================================================
</code></pre>
<h3 id="搭建静态资源服务器"><a href="#搭建静态资源服务器" class="headerlink" title="搭建静态资源服务器"></a>搭建静态资源服务器</h3><h5 id="搭建一个静态文件的Nginx服务"><a href="#搭建一个静态文件的Nginx服务" class="headerlink" title="搭建一个静态文件的Nginx服务"></a>搭建一个静态文件的Nginx服务</h5><ul>
<li>实操演示</li>
<li>配置和网页文件作为教辅提供 [静态网页]</li>
</ul>
<pre><code class="java">//scp传输文件 -r每一个文件夹都传递归 /usr/share/nginx/web/ 上传到这个文件夹
cmd本机框
C:\Users\Pluminary&gt; scp -r /Users/Pluminary/Desktop/静态资源/静态网页/ root@47.98.225.105:/usr/share/nginx/web/

cmd服务器框
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/share/nginx/web/
[root@iZbp1dssknxftmjczbtpndZ web]# pwd //查看现在位置
/usr/share/nginx/web
[root@iZbp1dssknxftmjczbtpndZ web]# ls
css  fonts  images  index.html  js
//修改文件 可以让nginx访问到文件 访问web下面的内容
[root@iZbp1dssknxftmjczbtpndZ web]# vim /etc/nginx/conf.d/default.conf  
//修改location：.../web
===============================================================
location / &#123;
        root   /usr/share/nginx/web;
        index  index.html index.htm;
    &#125;

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html &#123;
        root   /usr/share/nginx/web;
    &#125;
===============================================================
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -t //测试一下是否有问题
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -s reload //重启服务
//浏览器访问：http://47.98.225.105/index.html
[root@iZbp1dssknxftmjczbtpndZ web]# cat /etc/nginx/nginx.conf
//进去看到 access_log  /var/log/nginx/access.log  main; 打开它
[root@iZbp1dssknxftmjczbtpndZ web]# cat /var/log/nginx/access.log //打开日志文件
</code></pre>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><ul>
<li><h5 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h5></li>
<li><h5 id="RabbitMQ的安装和启动-Erlang语言"><a href="#RabbitMQ的安装和启动-Erlang语言" class="headerlink" title="RabbitMQ的安装和启动 [Erlang语言]"></a>RabbitMQ的安装和启动 [Erlang语言]</h5></li>
<li><h5 id="RabbitMQ管理后台"><a href="#RabbitMQ管理后台" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5></li>
<li><h5 id="实战案例演示"><a href="#实战案例演示" class="headerlink" title="实战案例演示"></a>实战案例演示</h5></li>
<li><h5 id="交换机工作模式-fanout、direct、topic、headers"><a href="#交换机工作模式-fanout、direct、topic、headers" class="headerlink" title="交换机工作模式 [fanout、direct、topic、headers]"></a>交换机工作模式 [fanout、direct、topic、headers]</h5></li>
<li><h5 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h5></li>
</ul>
<h3 id="初识RabbitMQ-1"><a href="#初识RabbitMQ-1" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h3><ul>
<li><p>核心思想：<strong>接收并转发消息</strong>。类似于<strong>邮局</strong></p>
</li>
<li><p><strong>producer</strong>：<u>信息生产者</u></p>
</li>
<li><p><strong>queue</strong>：<u>队列</u></p>
</li>
<li><p><strong>consumer</strong>：<u>会从queue中获取消息</u></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ca2883b4e8981a89118a71e0e1590f837b4300de/data/RabbitMQ.jpg"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>什么是消息队列</li>
<li><strong>MQ</strong>(Message Queue)</li>
</ul>
<h5 id="消息队列的性质"><a href="#消息队列的性质" class="headerlink" title="消息队列的性质"></a>消息队列的性质</h5><ul>
<li>业务无关 [不需要考虑上层业务模型]</li>
<li>FIFO [先进先出]</li>
<li>容灾 [对于消息队列可以持久化 断电后也可以保存数据后重新发送]</li>
<li>性能</li>
</ul>
<h5 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h5><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用 [我告诉你要做 我可以不等你做完 我再返回 <u>相互不影响</u>]<br>[点外卖 用户发送外卖请求給中间件，随后MQ帮助分发后续流程(扣钱、召唤骑手 计算天气、时间等)]</li>
<li>流量<strong>削峰</strong> [MQ把请求先存在队列中 以合适的速度发送 化解压力]</li>
</ul>
<h3 id="RabbitMQ的特点和核心概念"><a href="#RabbitMQ的特点和核心概念" class="headerlink" title="RabbitMQ的特点和核心概念"></a>RabbitMQ的特点和核心概念</h3><ul>
<li>开源、跨语言</li>
<li>Erlang语言编写 [交换机、通信方面] [数据复制与转发性能好]</li>
<li>应用广泛</li>
<li>社区活跃、API丰富</li>
</ul>
<h5 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h5><ul>
<li>Advanced Message Queuing Protocol 高级消息队列协议</li>
</ul>
<h5 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h5><ul>
<li><strong>Server</strong>：服务</li>
<li><strong>connection</strong>：与Server建立连接</li>
<li><strong>channel</strong>：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道</li>
<li><strong>message</strong>：消息，由properties和body组成</li>
<li><strong>virtual host</strong>：虚拟主机，顶层隔离。同一个虚拟主机下，不能由重复的交换机和queue</li>
<li><strong>Exchange</strong>：交换机，接收生产者的信息的，然后根据指定的路由器把消息转发到所绑定的队列上</li>
<li><strong>binding</strong>：绑定交换机和队列</li>
<li><strong>routing key</strong>：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由</li>
<li><strong>queue</strong>：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange</li>
<li>Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h3 id="RabbitMQ的安装和启动"><a href="#RabbitMQ的安装和启动" class="headerlink" title="RabbitMQ的安装和启动"></a>RabbitMQ的安装和启动</h3><ul>
<li>安装<strong>Erlang</strong></li>
<li><strong>安装</strong>RabbitMQ</li>
<li><strong>启动</strong>RabbitMQ</li>
</ul>
<h5 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h5><ul>
<li>安装erlang-rpm包，该包经过RabbitMQ官方处理</li>
<li>使用Erlang Solutions源进行安装</li>
<li>使用EPEL(“Extra Packages for Enterprise Linux”)进行安装</li>
</ul>
<pre><code class="java">我们先准备两个安装包：//★★★★别看下面胡咧咧 直接教辅中有erlang和rabbitmq与教材相同★★★★
RabbitMQ： https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.13
Erlang：https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm

注意： 如果说你选的是最新的版本那么你就要选取对应支持的 erlang 的版本才行，具体看下面的连接
https://www.rabbitmq.com/which-erlang.html

这些都准备好之后我们使用 Xptf 软件把这个安装包传输到 linux 端对应文件下（自己建一个文件夹）即可。

安装
第一步：
我们第一步先要对 linux 端进行一个 erlang 的环境配置，所以我们要先解压 erlang 包。
    # rpm -Uvh erlang-solutions-2.0-1.noarch.rpm
    # yum install -y erlang
安装完成后，查看一下版本号，能查到说明就是安装好了
    # erl -v

第二步：
在安装一下
    # yum install -y socat

第三步：
接下来我们就需要进行 RabbitMQ 的安装了

    # rpm -Uvh rabbitmq-server-3.8.33-1.el8.noarch.rpm 
    # yum install rabbitmq-server -y

安装完之后我们来启动测试一下：

    # systemctl start rabbitmq-server
    # systemctl status rebbitmq-server

最后一步：
安装跑起来之后我们设置一下开机自启动

    # systemctl enable rabbitmq-server
    # systemctl stop rabbitmq-server   # 关闭开机自起
=========================================================
可以在这些目录中查找RabbitMQ的配置文件、启动脚本等。另外，RabbitMQ的启动脚本通常会被安装到/usr/sbin或/usr/bin目录下。你可以尝试使用以下命令来查找RabbitMQ的启动脚本位置：

find /usr/sbin /usr/bin -name &#39;rabbitmq*&#39;
=========================================================
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/sbin
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl start rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl status rabbitmq-server
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since Mon 2024-04-08 23:24:39 CST; 38min ago
 Main PID: 3570 (beam.smp)
===================================================================================
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl enable rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl stop rabbitmq-server   # 关闭开机自起
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57828911/article/details/131777471?ops_request_misc=%7B%22request_id%22:%22171259388816800186514596%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171259388816800186514596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-131777471-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E5%8D%B8%E8%BD%BDrabbitmq&spm=1018.2226.3001.4187">Linux环境如何彻底卸载感干净RabbitMQ_linux卸载rabbitmq-CSDN博客</a></p>
<pre><code class="java">停止RabbitMQ
$rabbitmqctl stop

设置开机启动
$ systemctl enable rabbitmq-server 

启动RabbitMQ
$ systemctl start rabbitmq-server

看看端口有没有起来，查看状态

$ rabbitmqctl status 

要检查RabbitMQ服务器的状态，请运行：

systemctl status rabbitmq-server

开启web管理界面
rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h3 id="RabbitMQ管理后台-1"><a href="#RabbitMQ管理后台-1" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h3><h5 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h5><ul>
<li>启动RabbitMQ：<code>systemctl start rabbitmq-server</code></li>
<li>查看状态：<code>rabbitmqctl status</code></li>
<li>启动管理台</li>
<li>配置admin用户</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@iZbp1dssknxftmjczbtpndZ:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@iZbp1dssknxftmjczbtpndZ...
Plugin configuration unchanged. ##添加账户
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl add_user admin password
Adding user &quot;admin&quot; ...            ##设置管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl set_user_tags admin administrator
Setting tags for user &quot;admin&quot; to [administrator] ...
浏览器进入RabbitMQ管理后台 输入 http://47.98.225.105:15672/
</code></pre>
<h5 id="RabbitMQ管理后台-2"><a href="#RabbitMQ管理后台-2" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5><ul>
<li>浏览页面</li>
<li>添加用户</li>
<li>创建虚拟主机(Virtual Hosts) &#x3D;&gt; 都有各自的队列、交换机</li>
</ul>
<h3 id="第一个生产者"><a href="#第一个生产者" class="headerlink" title="第一个生产者"></a>第一个生产者</h3><h5 id="实战案例演示-1"><a href="#实战案例演示-1" class="headerlink" title="实战案例演示"></a>实战案例演示</h5><ul>
<li>新建项目</li>
<li>Hello World<br>P(生产者)→hello→C(消费者)</li>
<li>创建一个rabbitmq(Maven)新项目</li>
<li>rabbitmq支持多语言</li>
</ul>
<pre><code class="java">登录上RabbitMQ后台 上面Admin 右面Virtual Hosts 
点表里的 /  下面增加一个admin

pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;20&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;20&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
            &lt;version&gt;1.7.29&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">helloworld/send.java
package helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Hello World的发送类，连接到RabbitMQ服务端，然后发送一条消息后退出
 */
public class send &#123;
    //队列名字
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        //发布消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">helloworld/Recv.java
package helloworld;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收消息，并打印，持续运行
 */
public class Recv &#123;
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        //接收消息并消费 2:是否确认收到(快递签收 自动消息确认) 3：消息收到后进行处理
        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            //收到信息后会执行的函数
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot; + message);
            &#125;
        &#125;);
    &#125;
&#125;
=======================================================
//由于是持续接收消息的 若将send.java中改为Hello World2 将会持续打印到控制台
开始接收消息
收到消息：Hello World!
收到消息：Hello World2!
</code></pre>
<h3 id="根据消息内容做处理"><a href="#根据消息内容做处理" class="headerlink" title="根据消息内容做处理"></a>根据消息内容做处理</h3><h5 id="多个消费者分担压力"><a href="#多个消费者分担压力" class="headerlink" title="多个消费者分担压力"></a>多个消费者分担压力</h5><p><strong>RabbitMQ后台</strong><a target="_blank" rel="noopener" href="http://47.98.225.105:15672/">http://47.98.225.105:15672/</a></p>
<h6 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h6><pre><code class="java">workqueues/NewTask.java
package workqueues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 生产者：生产批量消息
 */
public class NewTask &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME,true,false,false,null);
        for (int i = 0; i &lt; 10; i++) &#123;
            String message = i + &quot;...&quot;;
            channel.basicPublish(&quot;&quot;,TAKS_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;发送了消息：&quot; + message);
        &#125;
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================================
发送了消息：0...
发送了消息：1...
发送了消息：2...
发送了消息：3...
发送了消息：4...
发送了消息：5...
发送了消息：6...
发送了消息：7...
发送了消息：8...
发送了消息：9...
</code></pre>
<pre><code class="java">workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicConsume(TAKS_QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==========================================================================================
收到了消息：0...
完成消息处理
收到了消息：1...
完成消息处理
收到了消息：2...
完成消息处理
收到了消息：3...
完成消息处理
收到了消息：4...
完成消息处理
收到了消息：5...
完成消息处理
收到了消息：6...
完成消息处理
收到了消息：7...
完成消息处理
收到了消息：8...
完成消息处理
收到了消息：9...
完成消息处理
</code></pre>
<h5 id="并行-多个消费者平均压力！！！"><a href="#并行-多个消费者平均压力！！！" class="headerlink" title="并行 多个消费者平均压力！！！"></a>并行 多个消费者平均压力！！！</h5><h6 id="公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】"><a href="#公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】" class="headerlink" title="公平派遣[因为奇数偶数压力不同] + 消息确认 【以工作量的程度去分任务】"></a>公平派遣[因为奇数偶数压力不同] + 消息确认 【<u>以工作量的程度去分任务</u>】</h6><pre><code class="java">//在Worker消费方打开并行消费 Run/Debug Configurations → Modify options蓝字 → Allow multiple instances             此时两个woker开始配合平均压力 一起工作
workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicQos(1); //最希望处理的数量 处理完之前不会接收下一个任务
        channel.basicConsume(TAKS_QUEUE_NAME, false, new DefaultConsumer(channel) &#123; //关掉自动接收 要手动确认false
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                    channel.basicAck(envelope.getDeliveryTag(), false); //false 不同时一起确认 手动确认消息
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
=======================================================================================
开始接收消息
收到了消息：1
消息处理完成
收到了消息：2...
消息处理完成
......
</code></pre>
<h3 id="交换机工作模式"><a href="#交换机工作模式" class="headerlink" title="交换机工作模式"></a>交换机工作模式</h3><ul>
<li><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</li>
<li><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列</li>
<li><strong>topic</strong>：生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发</li>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h5 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h5><h6 id="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送"><a href="#广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送" class="headerlink" title="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]"></a>广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3aa53b6e78e1fd67145c5d2acf905c22eee0b44a/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-fanout.png"></p>
<pre><code class="java">fanout/EmitLog.java【生产者】
package fanout;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 发送日志信息
 */
public class EmitLog &#123;
    //创建交换机
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        String message = &quot;info: Hello World！&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">fanout/ReceiveLogs.java【消费者】
package fanout;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 描述：接收日志消息 有多个接收同样的消息
 */
public class ReceiveLogs &#123;
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        //非持久会自动删除的队列 在同一个类中多次启动 每一次队列名字都不一样
        String queueName = channel.queueDeclare().getQueue();
        //交换机和队列的绑定
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;开始接收消息&quot;);
        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
</code></pre>
<h5 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h5><h6 id="根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致"><a href="#根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致" class="headerlink" title="根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]"></a>根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<pre><code class="java">direct/ReceiveLogsDirect1.java
package direct;

import com.rabbitmq.client.*;

import java.io.IOException;

/**
 * 接收3个等级的日志
 */
public class ReceiveLogsDirect1 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定三个queue
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);

        System.out.println(&quot; 开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/ReceiveLogsDirect2.java
package direct;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收1个等级的日志
 */
public class ReceiveLogsDirect2 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定两个queue，比刚第一个Receiver少接收了一个error等级
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/EmitLogDirect.java
package direct;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class EmitLogDirect &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机 DIRECT
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        String message = &quot;Hello World！&quot;;
        //发送第一个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;info&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为info,消息内容：&quot; + message);

        //发送第二个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;warning&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为warning,消息内容：&quot; + message);

        //发送第三个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;error&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为error,消息内容：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================
发送了消息：等级为info,消息内容：Hello World！
发送了消息：等级为warning,消息内容：Hello World！
发送了消息：等级为error,消息内容：Hello World！
</code></pre>
<h5 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a><span style = "color:red"><strong>topic模式</strong></span></h5><h6 id="比如消息严重性怎么样、只想记录error模块的用户信息"><a href="#比如消息严重性怎么样、只想记录error模块的用户信息" class="headerlink" title="比如消息严重性怎么样、只想记录error模块的用户信息"></a>比如消息严重性怎么样、只想记录error模块的用户信息</h6><ul>
<li>***** 可以替代一个单词</li>
<li><strong>#</strong> 可以替代零个或多个单词</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<pre><code class="java">【发送者/生产者】
topic/EmitLogTopic.java
package topic;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

/**
 * topic模式交换机，发送消息
 */
public class EmitLogTopic &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) &#123;
        Connection connection = null;
        Channel channel = null;
        try &#123;
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost(&quot;47.98.225.105&quot;);
            factory.setUsername(&quot;admin&quot;);
            factory.setPassword(&quot;password&quot;);

            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

            String message = &quot;Animal WorldroutingKey&quot;;

            String[] routingKeys = new String[9];
            routingKeys[0] = &quot;quick.orange.rabbit&quot;;
            routingKeys[1] = &quot;lazy.orange.elephant&quot;;
            routingKeys[2] = &quot;quick.orange.fox&quot;;
            routingKeys[3] = &quot;lazy.brown.fox&quot;;
            routingKeys[4] = &quot;lazy.pink.rabbit&quot;;
            routingKeys[5] = &quot;quick.brown.fox&quot;;
            routingKeys[6] = &quot;orange&quot;;
            routingKeys[7] = &quot;quick.orange.male.rabbit&quot;;
            routingKeys[8] = &quot;lazy.orange.male.rabbit&quot;;
            for (int i = 0; i &lt; routingKeys.length; i++) &#123;
                channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null,
                        message.getBytes(&quot;UTF-8&quot;));
                System.out.println(&quot;发送了：&quot; + message + &quot;:&quot; + routingKeys[i]);
            &#125;


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (connection != null) &#123;
                try &#123;
                    connection.close();
                &#125; catch (Exception ignore) &#123;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==================================================================================
发送了：Animal WorldroutingKey:quick.orange.rabbit
发送了：Animal WorldroutingKey:lazy.orange.elephant
发送了：Animal WorldroutingKey:quick.orange.fox
发送了：Animal WorldroutingKey:lazy.brown.fox
发送了：Animal WorldroutingKey:lazy.pink.rabbit
发送了：Animal WorldroutingKey:quick.brown.fox
发送了：Animal WorldroutingKey:orange
发送了：Animal WorldroutingKey:quick.orange.male.rabbit
发送了：Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<pre><code class="java">【接收者/消费者Ⅰ(对&quot;*.orange.*&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.*;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic1 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey 最重要的一步！
        String bindingKey = &quot;*.orange.*&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:quick.orange.fox
</code></pre>
<pre><code class="java">【接收者/消费者Ⅱ(对&quot;*.*.rabbit&quot; 和 &quot;lazy.#&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic2 &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey
        String bindingKey1 = &quot;*.*.rabbit&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey1);
        String bindingKey2 = &quot;lazy.#&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey2);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:lazy.brown.fox
 接收消息： Animal WorldroutingKey:lazy.pink.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<ul>
<li><h6 id="headers：根据发送消息内容中的headers属性来匹配"><a href="#headers：根据发送消息内容中的headers属性来匹配" class="headerlink" title="headers：根据发送消息内容中的headers属性来匹配"></a>headers：根据发送消息内容中的headers属性来匹配</h6></li>
</ul>
<h3 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h3><ul>
<li><h6 id="实操代码演示"><a href="#实操代码演示" class="headerlink" title="实操代码演示"></a>实操代码演示</h6></li>
</ul>
<blockquote>
<p>创建两个Springboot项目<br>spring-boot-rabbitmq-consumer 和 spring-boot-rabbitmq-consumer<br>在application.properties中设置 如果是本机用户名和密码都是guest<br>spring.rabbitmq.username&#x3D;guest</p>
</blockquote>
<h6 id="项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者"><a href="#项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者" class="headerlink" title="项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]"></a>项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-producer
server.port=8080
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/MsgSender.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 发送消息
 */
//@Component让springboot发现
@Component
public class MsgSender &#123;
    @Autowired
    private AmqpTemplate rabbitmqTemplate;
    public void send1()&#123;
        String message = &quot;This is message 1, routing key is dog.red&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.red&quot;,message);
    &#125;
    public void send2()&#123;
        String message = &quot;This is message 2, routing key is dog.black&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.black&quot;,message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/TopicRabbitConfig.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


/**
 * rabbitmq配置类
 */
@Configuration
public class TopicRabbitConfig &#123;
    @Bean
    public Queue queue1()&#123;
        return new Queue(&quot;queue1&quot;);
    &#125;
    @Bean
    public Queue queue2()&#123;
        return new Queue(&quot;queue2&quot;);
    &#125;
    //用一个Bean定义交换机
    @Bean
    TopicExchange exchange()&#123;
        return new TopicExchange(&quot;bootExchange&quot;);
    &#125;

    //有了Q1 Q2后去指定一个topic交换机
    //绑定到交换机上
    @Bean
    Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue1()).to(exchange).with(&quot;dog.red&quot;);
    &#125;
    @Bean
    Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue2()).to(exchange).with(&quot;dog.#&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">用test的测试类
com/imooc/springbootrabbitmqproducer/SpringBootRabbitmqProducerApplicationTests.java
package com.imooc.springbootrabbitmqproducer;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootRabbitmqProducerApplicationTests &#123;

    @Autowired
    MsgSender msgSender;

    @Test
    public void send1()&#123;
        msgSender.send1();
    &#125;
    @Test
    public void send2()&#123;
        msgSender.send2();
    &#125;
&#125;
</code></pre>
<h6 id="项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者"><a href="#项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者" class="headerlink" title="项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]"></a>项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-consumer
server.port=8081
spring.rabbitmq.addresses=127.0.0.1:15672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">Receiver1.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者1
 */
@Component
@RabbitListener(queues = &quot;queue1&quot;)
public class Receiver1 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver1：&quot; + message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Receiver2.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者2
 */
@Component
@RabbitListener(queues = &quot;queue2&quot;)
public class Receiver2 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver2：&quot; + message);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>先启动消费者 然后再启动生产者test中的测试<br>就可以发现<br>send1() → 发送了：This is message 1, routing key is dog.red<br>send2() → 发送了：This is message 2, routing key is dog.black</p>
</blockquote>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>