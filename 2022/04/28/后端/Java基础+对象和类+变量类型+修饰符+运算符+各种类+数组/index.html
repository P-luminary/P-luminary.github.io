
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/28
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#ff7d73>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><ul>
<li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、吃、叫等。</p>
</li>
<li><p><strong>类</strong>：类[class]是一个<strong>模板</strong>，它描述一类对象的<span style =" color : red">行为和状态</span>。</p>
</li>
<li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。</p>
</li>
<li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
</li>
<li><p>编写java时应注意几点：</p>
<p><strong>大小写敏感</strong></p>
<p><strong>类名</strong>：对所有类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写：MyFirstJavaClass</p>
<p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
<p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件时，你应该使用类名作为文件名保存(切记Java是大小写敏感的)，文件名的后缀为java。</p>
<p><strong>主方法入口</strong>：所有的Java程序由<span style =" color : red">public static void main(String[] args)</span>方法开始执行。</p>
</li>
<li><p><strong>Java变量</strong>：局部变量、类变量(静态[static]变量)、成员变量(非静态变量)</p>
</li>
<li><p><strong>方法</strong>：访问权限符 返回值 方法名(参数列表){  方法体  }</p>
<p>​            public          void    method()    {sout(“Hello”);}</p>
<p><strong>interface：</strong>接口，一种抽象的类型，仅有方法和常量的定义</p>
<p><strong>implements</strong>：表示一个类实现了接口</p>
<p><strong>abstract</strong>：抽象方法，抽象类的修饰符</p>
<p><strong>extends：</strong>表示一个类是另一个类的子类(继承)</p>
<p><strong>private：</strong>表示私有字段，或者方法等，只能从类内部访问</p>
<p><strong>protected：</strong>表示字段只能通过类或者子类访问，子类或者在同一个包内的其他类</p>
<p><strong>public：</strong>表示共有属性或方法</p>
<p><strong>static：</strong>表示在类级别定义，所有实例共享的</p>
<p><strong>throw：</strong>抛出异常</p>
<p><strong>throws：</strong>定义方法可能抛出的异常</p>
</li>
<li><p><strong>继承</strong>：在Java中，一个类可以由其他类派生，如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类，利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类(super class)，派生类称为子类(subclass)</p>
</li>
<li><p><strong>接口</strong>：在Java中，接口可理解为对象间互相通信的协议。接口在继承中扮演着很重要的角色。接口值定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
</li>
</ul>
<h1 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h1><ul>
<li>Java中的类和方法[方法就是行为，一个类可以有很多方法]</li>
</ul>
<pre><code class="jaVA">public class Dog&#123;
    String breed;
    int age;
    String color;
    
    void barking()&#123;
        
    &#125;
    void hungry()&#123;
        
    &#125;
    void sleeping()&#123;
        
    &#125;
&#125;
</code></pre>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()、sleeping() 都是Dog类的方法</p>
<hr>
<p><strong>构造方法</strong></p>
<p>每个类都有构造方法，不主动创建编译器将会为该类提供一个默认的构造方法，在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<pre><code class="java">public class Puppy&#123;
    public Puppy()&#123;
        
    &#125;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数：name
    &#125;
&#125;
</code></pre>
<hr>
<p><strong>创建对象</strong></p>
<p>对象是根据类创建的。在java中，使用关键字new来创建一个新的对象。</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型</li>
<li><strong>实例化</strong>：使用关键字new来创建一个对象</li>
<li><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象</li>
</ul>
<pre><code class="java">public class Puppy&#123;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数:name
        sout(&quot;Puppy Name is :&quot; + name);
    &#125;
    public static void main(String[] args)&#123;
        //下面的语句将创建一个Puppy对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
    &#125;
&#125;

打印出下面结果：
Puppy Name is : tommy
</code></pre>
<hr>
<p><strong>访问实例变量和方法</strong></p>
<pre><code class="java">//实例化对象
ObjectReference = new Constructor();
//访问其中的变量
ObjectReference.variableName;
//访问类中的方法
ObjectReference.MethodName();
</code></pre>
<hr>
<p><strong>实例</strong></p>
<p>访问实例变量和调用成员方法：</p>
<pre><code class="java">public class Puppy&#123;
    int puppyAge;
    public Puppy(String name)&#123;
        sout(&quot;Passed Name is :&quot; + name);
    &#125;
    public void setAge(int age)&#123;
        puppyAge = age;
    &#125;
    public int getAge()&#123;
        sout(&quot;Puppy&#39;s age is :&quot; + puppyAge);
        return puppyAge;
    &#125;
    
    public static void main(String[] args)&#123;
        //创建对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
        //通过方法来设定age
        myPuppy.setAge(2);
        //调用另一个方法获取age
        myPuppy.getAge();
        //也可以这样访问成员变量
        sout(&quot;Variable Value :&quot; + myPuppy.puppyAge);
    &#125;
&#125;

输出结果：
Passed Name is :tommy
   &#39;s age is :2
PuppyVariable Value :2
</code></pre>
<hr>
<p><strong>源文件声明规则</strong></p>
<ul>
<li><p>一个源文件中只能有一个public类</p>
</li>
<li><p>一个源文件可以有多个非public类</p>
</li>
<li><p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java</p>
</li>
<li><p>特殊的转义字符序列</p>
</li>
</ul>
<pre><code class="java">\n 换行
\r 回车
\f 换页符
\b 退格
\0 空字符
\s 字符串
\t 制表符
</code></pre>
<hr>
<h1 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h1><p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量称之为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用(类方法中的变量)(局部变量的作用域仅限制在被创造的方法中)</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。(独立于方法之外的变量，不过没有static修饰)</li>
<li><strong>类变量</strong>：类变量(静态变量)也声明在类中，方法体之外，但必须声明为static类型。无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。静态变量除了被声明为常量外很少使用，常量是指声明为public&#x2F;private，final和static类型的变量，常量初始化后不能改变。静态变量存储在静态存储区，经常被声明为常量，很少单独使用static声明变量。类变量被声明为public static final 类型时，类变量名称必须使用大写字母，如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。(独立于方法之外的变量，用static修饰)</li>
</ul>
<p><strong>然后是static</strong></p>
<p><strong>static在java中表示静态</strong></p>
<p><strong>但是这个静态又是什么意思呢？</strong></p>
<p><strong>最开始接触static的时候看书上的概念根本没弄懂！</strong></p>
<p><strong>接触有一段时间java了，在这里面要总结一下我对static的理解：</strong></p>
<p>（概念）static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>
<p>这句话是说，你会用到static修饰一些个变量、方法、方法块什么的，这是你用到static的地方；“但是，java中没有全局变量的概念”，怎么理解这句话？你时刻要记住java是一个面向对象的语言，万事万物皆对象，无论你做什么都需要创建一个对象，然后再调用这个对象的方法，java怎么能允许存在一个在全局都通用的“全局变量”的概念存在呢？所以java中压根就没有所谓的“全局变量”，但是没有这个概念，不代表你不可以实现这个功能，java存在的目的就是让人们使用它去达到人们想要的效果，所以static value就可以达到全局变量的作用，所以，你现在应该可以理解下面这句话了吧。</p>
<p>（概念）用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>现在进一步理解下面两段概念：</p>
<p>（概念）只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //salary是静态的私有变量
    private static double salary;
    //DEPARTMENT是一个常量
    public static final String DEPARTMENT = &quot;Development &quot;;
    public static void main(String args[])&#123;
        salary = 1000;
        sout(DEPARTMENT + &quot;average salary:&quot; + salary);
    &#125;
&#125;
输出结果：
Develment average salary：1000
</code></pre>
<pre><code class="java">public class Variable&#123;
    static int allClicks = 0;    //类变量
    String str = &quot;hello world&quot;; //实例变量
    public void method()&#123;
        int i = 0; //局部变量
    &#125;
&#125;
</code></pre>
<p>实例：</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //这个成员变量对子类可见
    public String name;
    //私有变量，仅在该类可见
    private double salary;
    //在构造器中对name赋值
    public Employee(String empName)&#123;
        name = empName;
    &#125;
    //设定salary的值
    public void setSalary(double empSal)&#123;
        salary = empSal;
    &#125;
    //打印信息
    public void printEmp()&#123;
        sout(&quot;name :&quot; + name);
        sout(&quot;salary :&quot; + salary);
&#125;
    public ststic void main(String args[])&#123;
        Employee empOne = new Employee(&quot;Ransika&quot;);
        empOne.setSalary(1000);
        empOne.printEmp();
    &#125;
&#125;
输出结果：
name : Ransika
salary :1000.0
</code></pre>
<hr>
<h1 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h1><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li><strong>default 默认的：</strong>在同一包内可见，不使用任何修饰符</li>
<li><strong>private 私有的：</strong>在同一类内可见。私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。private访问修饰符的作用主要用来隐藏类的实现细节和保护类的数据</li>
</ul>
<pre><code class="java">public class Logger&#123;
    private String format;
    public String getFormat()&#123;
        return this.format;
    &#125;
    public void setFormat(String format)&#123;
        this.format = format;
    &#125;
&#125;
</code></pre>
<p>实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：<strong>getFormat()</strong> (返回format的值) 和 <strong>setFormat(String)</strong> (设置format的值)</p>
<ul>
<li><strong>public 公有的：</strong>对所有类可见，被声明public的类、方法、构造方法和接口能够被任何其他类访问。如果几个互相访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的共有方法和变量都能被子类继承</li>
</ul>
<pre><code class="java">public static void main(String[] arguments)&#123;
    //...(公有访问控制)
&#125;
</code></pre>
<p>Java程序的main()方法必须设置成共有的，否则，不能运行该类</p>
<ul>
<li><strong>proteed 受保护的：</strong>对同一包内的类和所有子类可见</li>
</ul>
<p>被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。protected访问修饰符不能修饰类和接口，方法和成员变量能够声明protected，但是接口的成员变量和成员方法不能声明为protected，子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了protected访问修饰符，子类重载了父类的openSpeaker()方法。</p>
<pre><code class="java">class AudioPlayer&#123;
    protected boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
class StreamingAudioPlayer&#123;
    boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
</code></pre>
<p>如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法</p>
<p>如果把openSpeaker()方法声明为public，那么所有的类都能够访问该方法</p>
<p>如果我们只想让该方法对其所在的类的子类可见，则将该方法声明为protected</p>
<ul>
<li><strong>访问控制和继承</strong>规则：<ul>
<li>父类中声明为public的方法在子类中也必须为public</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private</li>
<li>父类中声明为private的方法，不能够被继承</li>
</ul>
</li>
</ul>
<h4 id="控制非访问修饰符"><a href="#控制非访问修饰符" class="headerlink" title="控制非访问修饰符"></a>控制非访问修饰符</h4><ul>
<li><p><strong>static 修饰符：</strong>用来创建类方法和类变量</p>
<ul>
<li><strong>静态变量：</strong>static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也成为类变量。局部变量不能被声明为static变量</li>
<li><strong>静态方法：</strong>static关键词用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据</li>
</ul>
<p>对类变量和方法的访问可以直接使用classname.variablename 和 classname.methodname的方式访问 </p>
<p>下面为static修饰符用来创建类方法和类变量</p>
</li>
</ul>
<pre><code class="java">public class InstanceCounter&#123;
    private static int numInstances = 0;
    protected static int getCount()&#123;
        return numInstances;
    &#125;
    
    private static void addInstance()&#123;
        numInstances++;
    &#125;
    
    InstanceCounter()&#123;
        InstanceCounter.addInstance();
    &#125;
    
    public static void main(String[] arguments)&#123;
        sout(&quot;Starting with&quot; + InstanceCounter.getCount() + &quot; instances&quot;);
        for(int i = 0; i &lt; 500; ++i)&#123;
            new InstanceCounter();
        &#125;
        sout(&quot;Created &quot; + InstanceCounter.getCount() + &quot;instances&quot;);
    &#125;
&#125;
输出结果：
Started with 0 instances
Created 500 instances
</code></pre>
<ul>
<li><p><strong>final 修饰符：</strong>用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</p>
<ul>
<li><strong>final变量：</strong>能被显示地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。final修饰符通常和static修饰符一起使用来创建类常量。</li>
</ul>
<pre><code class="java">public class Test&#123;
    final int value = 10;
    //下面是声明常量的实例
    public static final int BOXWIDTH = 6;
    static final String TITLE = &quot;Manger&quot;;
    
    public void changeValue()&#123;
        value = 12; //将输出一个错误
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final方法：</strong> 类中的final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改</li>
</ul>
<p>如图为final修饰符声明方法</p>
<pre><code class="java">public class Test&#123;
    public final void changeName()&#123;
        //方法体
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final类：</strong> final类不能被继承，没有类能够继承final类的任何特性</li>
</ul>
<pre><code class="java">public final class Test&#123;
    //类体
&#125;
</code></pre>
</li>
<li><p><strong>abstrat 修饰符：</strong>用来创建抽象类和抽象方法</p>
<ul>
<li><strong>抽象类：</strong>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被abstract和final修饰，如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则编译错误。抽象类包含抽象方法和非抽象方法。</li>
<li><strong>抽象方法：</strong>是一种没有任何实现的方法，该方法的具体实现由子类提供，抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非子类也是抽象类。抽象类可以不包含抽象方法。</li>
</ul>
<pre><code class="java">abstract class Caraven&#123;
    private double price;
    private String model;
    private String year;
    public abstract void goFast(); //抽象方法
    public abstract void changeColor();
&#125;
</code></pre>
<pre><code class="java">public abstract class SuperClass&#123;
    abstract void m(); //抽象方法
&#125;
class SubClass extends SuperClass&#123;
    //实现抽象方法
    void m()&#123;
        // ......
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>synchronized和volatile 修饰符：</strong> 主要用于线程的编程 （这里不具体研究）</p>
</li>
</ul>
<hr>
<h1 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h1><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>假设a&#x3D;60，b&#x3D;13；</p>
<pre><code class="java">    a = 0011 1100
    b = 0000 1101
----------------------
a &amp; b = 0000 1100
a | b = 0011 1101
a ^ b = 0011 0001
~ a   = 1100 0011
</code></pre>
<h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型(类类型 或 接口类型)</p>
<p>instanof运算符使用格式如下：</p>
<pre><code class="java">(Object reference variable)instanceof(class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真</p>
<pre><code class="java">String name = &quot;James&quot;;
boolean result = name instanceof String;
//由于name是String类型，所以返回真
</code></pre>
<pre><code class="java">class Vehicle&#123;&#125;
public class Car extends Vehicle&#123;
    public static void main(String args[])&#123;
        Vehicle a = new Car();
        boolean result = a instanceof Car;
        sout(result);
    &#125;
&#125;
输出结果：
true
</code></pre>
<h4 id="continue关键字-增强型for循环"><a href="#continue关键字-增强型for循环" class="headerlink" title="continue关键字 + 增强型for循环"></a>continue关键字 + 增强型for循环</h4><p>continue适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代</p>
<p>在<strong>for循环</strong>中，continue语句使程序立刻跳转到更新语句</p>
<p>在<strong>while</strong>或者<strong>do…while循环</strong>中，程序立刻跳转到布尔表达式的判断语句</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        int &#123;&#125; numbers = &#123;10, 20, 30, 40, 50&#125;;
        for(int x : numbers)&#123;
            if(x == 30)&#123;
                continue;
            &#125;
            sout(x);
            sout(&quot;\n&quot;);
        &#125;
    &#125;
&#125;
输出结果：
10
20
40
50
</code></pre>
<h1 id="Java-Number类、Math类、Character类"><a href="#Java-Number类、Math类、Character类" class="headerlink" title="Java Number类、Math类、Character类"></a>Java Number类、Math类、Character类</h1><h4 id="Number包装类型"><a href="#Number包装类型" class="headerlink" title="Number包装类型"></a>Number包装类型</h4><pre><code class="java">byte -&gt; Byte        int -&gt; Integer        short -&gt; Short        long -&gt; Long
double -&gt; Double    float -&gt; Float        boolean -&gt; Boolean    char -&gt; Character
</code></pre>
<p>包装类型都是用final声明了，不可能被继承重写。在实际情况中编译器会自动的将基本类型数据<strong>装箱</strong>成对象类型，或者将对象类型<strong>拆箱</strong>成基本类型</p>
<pre><code class="java">public static void main(String[] args)&#123;
    int num1 = 1;
    //将基本类型数据装箱成对象包装类型
    Integer num2 = num1;
    Integer num3 = 3;
    //将对象数据类拆箱
    int num4 = num3;
&#125;
</code></pre>
<p>下面是一个装箱与拆箱的例子：</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        Integer x = 5;
        x = x + 10;
        sout(x);
    &#125;
&#125;
输出结果：
15
</code></pre>
<h4 id="Math类型"><a href="#Math类型" class="headerlink" title="Math类型"></a>Math类型</h4><p>Java的Math包含了用于执行基本数学运算的属性和方法：初等指数、对数、平方根和三角函数</p>
<p>Math的方法都被定义为static形式，通过Math类可以在主函数中直接调用 sout(“90°正弦值：” + Math.sin(Math.PI &#x2F; 2))；</p>
<p>下表是常用的Number类和Math类的方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>xxxValue()：将number对象转换为xxx数据类型的值并返回</td>
</tr>
<tr>
<td>2</td>
<td>compareTo()：将number对象与参数比较</td>
</tr>
<tr>
<td>3</td>
<td>equals()：判断number对象是否与参数相等</td>
</tr>
<tr>
<td>4</td>
<td>valueOf()：返回一个Integer对象指定的内置数据类型</td>
</tr>
<tr>
<td>5</td>
<td>toString()：以字符串形式返回值</td>
</tr>
<tr>
<td>6</td>
<td>parseInt()：将字符串解析为int类型</td>
</tr>
<tr>
<td>7</td>
<td>abs()：返回参数的绝对值</td>
</tr>
<tr>
<td>8</td>
<td>floor()：返回小于等于给定参数的最大整数</td>
</tr>
<tr>
<td>9</td>
<td>round()：返回一个最接近的int、long型值</td>
</tr>
<tr>
<td>10</td>
<td>exp()：返回自然数底数e的参数次方</td>
</tr>
<tr>
<td>11</td>
<td>log()：返回参数的自然数底数的对数值</td>
</tr>
<tr>
<td>12</td>
<td>pow()：返回第一个参数的第二个参数次方</td>
</tr>
<tr>
<td>13</td>
<td>sqrt()：求参数的算术平方个</td>
</tr>
<tr>
<td>14</td>
<td>random()：返回一个随机数</td>
</tr>
</tbody></table>
<h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>使用字符时，我们通常使用的是内置数据类型char</p>
<ul>
<li>Character类的用法：可以使用Character的构造方法创建一个Character类对象</li>
</ul>
<pre><code class="java">Character ch = new Character(&#39;a&#39;);
----------------------------------
Character ch = &#39;a&#39;;
char c = test(&#39;x&#39;);
</code></pre>
<pre><code class="java">isLetter()是否是一个字母        isDigit()是否是一个数字字符
isUpperCase()是否是大写字母    isLowCase()是否是小写字母
toUpperCase()指定字母的大写形式 isLowerCase()指定字母的小写形式
toString()返回字符的字符串形式，字符串的长度仅为1
</code></pre>
<p>注意：String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</p>
<p>可以通过StringBuffer类 和 StringBuilder类(能够被多次的修改，并且不产生新的未使用对象)</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        StringBuffer sBuffer = new StringBuffer(&quot;test&quot;);
        sBuffer.append(&quot;String Buffer&quot;);
        sout(sBuffer);
    &#125;
&#125;
输出结果：
test String Buffer
</code></pre>
<pre><code class="java">public StringBuffer append(String s) 将指定的字符串追加到此字符序列
public StringBuffer reverse() 将此字符序列用其反转形式取代
public delete(int start, int end) 移除此序列的子字符串中的字符
public insert(int offset, int i) 将int参数的字符串表示形式插入此序列中
replace(int start, int end, String str) 使用给定String中的字符替换此序列的子字符串中的字符
</code></pre>
<h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><h4 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h4><pre><code class="java">dataType[] arrayRefVar;
double[] myList;
</code></pre>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>Java语言使用new操作符来创建数组</p>
<pre><code class="java">arrayRefVar = new dataType[arraySize];
此语法语句做了两件事：
    ①：使用dataType[arraySize]创建了一个数组
    ②：把新创建的数组的应用赋值给变量arrayRefVar
</code></pre>
<p>所以<strong>数组的变量声明</strong>和<strong>创建数组</strong>可以用一条语句完成</p>
<pre><code class="java">dataType[] arrayRefVar = new dataType[arraySize]
</code></pre>
<p>数组的元素时通过索引来访问的，数组索引从0开始，所以索引值从0到arrayRefVar.length-1</p>
<p>定义一个int类型的数组</p>
<pre><code class="java">public class ArrayDemo&#123;
    public static void main(String args[])&#123;
        int data[] = new int[3]; //开辟了一个长度为3的数组
        //在数组使用之前一定要开辟空间(实例化)
        data[0] = 10;
        data[1] = 20;
        data[2] = 30;
        for(int x = 0; x &lt; data.length; x++)&#123;
            sout(data[x]);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h4><p>数组可以作为参数传递给方法</p>
<pre><code class="java">public static void printArray(int[] array)&#123;
    for(int i = 0; i &lt; array.length; i++)&#123;
        sout(array[i] + &quot; &quot;);
    &#125;
&#125;

printArray(new int[]&#123;3, 1, 2, 6, 4, 2&#125;);
</code></pre>
<h4 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h4><pre><code class="java">public static int[] reverse(int[] list)&#123;
    int[] result = new int[list.length];
    for(int i = 0, j = result.length - 1; i &lt; list.length; i++, j--)&#123;
        result[j] = list[i];
    &#125;
    return result;
&#125;
</code></pre>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的</p>
<ul>
<li>给数组赋值：通过<strong>fill</strong>方法</li>
<li>对数组排序：通过<strong>sort</strong>方法，按升序</li>
<li>比较数组：通过<strong>equals</strong>方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过<strong>binarySearch</strong>方法能对排序好的数组进行二分查找法操作</li>
</ul>
<pre><code class="java">public static int binarySearch(Object[], Object key) 
用二分查找算法在给定数组中搜索给定值的对象(Byte,int,double等)
public static boolean equals(long[] a, long[] a2)
如果两个指定的long型数组彼此相等，则返回true。如果两个数组包含相同数量的元素
并且两个元素中的所有相应元素对都是相等的，则认为这两个数组是相等的
public static void fill(int[] a, int val)
将指定的int值分配给指定int型数组指定范围中的每个元素
public static void sort(Object[] a)
对指定对象数组根据其元素的自然顺序进行升序排序
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>