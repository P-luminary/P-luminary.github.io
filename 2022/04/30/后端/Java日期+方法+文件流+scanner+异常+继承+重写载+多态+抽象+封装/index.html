
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/30
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#ffa2c4>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Java日期时间"><a href="#Java日期时间" class="headerlink" title="Java日期时间"></a>Java日期时间</h1><h4 id="java-uti包提供了Date类来封装当前的日期和时间"><a href="#java-uti包提供了Date类来封装当前的日期和时间" class="headerlink" title="java.uti包提供了Date类来封装当前的日期和时间"></a>java.uti包提供了Date类来封装当前的日期和时间</h4><pre><code class="java">Data() 构造函数使用当前日期和时间来初始化对象
Data(long millisec) 构造函数接收一个参数从1970年1月1日起的毫秒数
</code></pre>
<h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><pre><code class="java">import java.util.Date;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        //初始化Date对象
        Date date = new Date();
        //使用toString()函数显示日期时间
        sout(data.toString());
    &#125;
&#125;
运行结果：
Mon May 04 09:51:52 CDT 2013
</code></pre>
<h4 id="使用SimpleDateFormat格式化时间"><a href="#使用SimpleDateFormat格式化时间" class="headerlink" title="使用SimpleDateFormat格式化时间"></a>使用SimpleDateFormat格式化时间</h4><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。允许你选择任何用户自定义日期时间格式来运行</p>
<pre><code class="java">import java.util.*;
import java.test.*;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        Date dNow = new Date();                     //DateFormat格式化编码
        SimpleDateFormat ft = new SimpleDateFormat(&quot;E yyyy.MM.dd &#39;at&#39; hh:mm:ss a zzz&quot;);
        sout(&quot;Current Date: &quot; + ft.format(dNow));
    &#125;
&#125;
运行结果：
Current Date: Sun 2004.07.18 at 04:14:09 PM PDT
</code></pre>
<h4 id="Java休眠-sleep"><a href="#Java休眠-sleep" class="headerlink" title="Java休眠(sleep)"></a>Java休眠(sleep)</h4><p>下面的程序会休眠3秒</p>
<pre><code class="java">import java.util.*;
public static void main(String args[])&#123;
    try&#123;
        sout(new Date() + &quot;\n&quot;);
        Thread.sleep(5*60*10); //1秒 = 1000毫秒
        sout(new Date() + &quot;\n&quot;);
    &#125; catch(Exception e)&#123;
        sout(&quot;Got an exception!&quot;);
    &#125;
   &#125;
&#125;
</code></pre>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程只需要使用getInstance方法创建即可</p>
<p>创建一个代表系统当前日期的Calendar对象</p>
<ul>
<li><strong>Get设置</strong></li>
</ul>
<pre><code class="java">//获得年份
int year = c1.get(Calendar.YEAR);
</code></pre>
<ul>
<li><strong>Set设置</strong></li>
</ul>
<pre><code class="java">Calendar c1 = Calendar.getInstance(); //默认是当前日期
public void set(int field, int value)
c1.set(Calendar.DATE, 10);
c1.set(Calendar.YEAR, 2008);
</code></pre>
<ul>
<li><strong>Add设置</strong></li>
</ul>
<p>把c1对象的日期加上10，也就是c1所表的日期的10天后的日期，其他所有的数值都会被重新计算</p>
<pre><code class="java">c1.add(Calendar.DATE, 10);
</code></pre>
<ul>
<li><h5 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h5></li>
</ul>
<p>Calendar类实现了公历日历，GregorianCalenda是Calendar类的一个具体实现</p>
<pre><code class="java">import java.util.*;
public class GregorianCalendarDemo&#123;
    public static void main(String args[])&#123;
        String months[] = &#123;&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;&#125;;
        int year;
        //初始化Gregorian日历
        //使用当前时间和日期
        //默认为本地时间和时区
        GergorianCalendar gcalendar = new GergorianCalendar();
        //显示当前时间和日期的信息 sout 为 print 不是 println
        sout(&quot;Date: &quot;);
        sout(&quot;months[gcalendar.get(Calendar.MONTH)]&quot;);
        sout(&quot; &quot; + gcalendar.get(Calendar.DATE) + &quot; &quot;);
        sout(year = gcalendar.get(Calendar.YEAR));
        sout(&quot;Time: &quot;);
        sout(gcalendar.get(Calendar.HOUR) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.MINUTE) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.SECOND));
        //测试当前年份是否为闰年
        if(gcalendar.isLeapYeay(year))&#123;
            sout(&quot;当前年份是闰年&quot;);
        &#125;
        else &#123;
            sout(&quot;当前年份不是闰年&quot;);
          &#125;
    &#125;
&#125;
运行结果：
Date: Apr 22 2009
Time: 11:25:27
当前年份不是闰年
</code></pre>
<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>System.out.println()</p>
<p>println()是一个方法(Method)，而System是系统类(Class)，out是标准输出对象(Object)</p>
<p>这句话的用法是调用系统类System中的标准输出对象out中的方法println()</p>
<h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><pre><code class="java">修饰符 返回值类型 方法名 (参数类型 参数名)&#123;
    ...
    方法体
    ...
    return 返回值:
&#125;
</code></pre>
<ul>
<li>修饰符：是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型</li>
<li>返回值类型：方法可能会返回值。returnValueType是关键字void</li>
<li>方法名：是方法的实际名称</li>
<li>参数类型：当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数</li>
<li>方法体：方法体包括具体的语句，定义该方法的功能</li>
</ul>
<p>void方法的调用一定是一个语句，没有返回值，像任何以分号结束的语句一样</p>
<h4 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h4><p>连续n次打印一个消息：</p>
<pre><code class="java">public static void nPrintln(String message, int n)&#123;
    for(int i = 0; i &lt; n; i++)
        sout(message);
&#125;
</code></pre>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>一个类的两个方法拥有相同的名字，但是有不同的参数列表</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其他必要的步骤来创建一个完整的对象</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它会把所有成员初始化为0</p>
<pre><code class="java">//一个简单的构造函数
static class Myclass&#123;
    int x;
    //以下是构造函数
    MyClass(int i)&#123;
        x = i;
    &#125;
&#125;
//调用构造方法来初始化一个对象
public class ConsDemo&#123;
    public static void main(String args[])&#123;
        MyClass t1 = new MyClass(10);
        MyClass t2 = new MyClass(20);
        sout(t1.x + &quot; &quot; + t2.x);
    &#125;
&#125;
运行结果：
10 20
</code></pre>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>Java支持传递同类型的可变参数给一个方法</p>
<pre><code class="java">typeName...parameterName
</code></pre>
<p>在方法声明中，在指定参数类型后加一个省略号(…)</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的<strong>最后一个参数</strong>，任何普通的参数必须在它之前声明</p>
<pre><code class="java">public calss VarageDemo&#123;
    public static void main(String args[])&#123;
        //调用可变参数的方法
        printMax&#123;34,3,3,2,56.5&#125;;
        printMax(new double[]&#123;1,2,3&#125;);
    &#125;
    
    public static void printMax(double...numbers)&#123;
        if(numbers.length == 0)&#123;
            sout(&quot;No argument passed&quot;);
            return;
        &#125;
        double result = numbers[0];
        for(int i = 1; i &lt; number.length; i++)
            if(number[i] &gt; result)&#123;
                result = numbers[i];
            &#125;
        sout(&quot;The max value is &quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Java流-Stream-、文件-File-和-IO"><a href="#Java流-Stream-、文件-File-和-IO" class="headerlink" title="Java流(Stream)、文件(File) 和 IO"></a>Java流(Stream)、文件(File) 和 IO</h1><p>Java.io包几乎包括了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标</p>
<p>一个流可以理解为一个数据的序列、<strong>输入流</strong>表示<u>一个源读取数据</u>，<strong>输出流</strong>表示<u>一个目标写数据</u>。</p>
<h5 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h5><p>Java的控制台输入由System.in完成</p>
<p>为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个BufferedReader对象中创建一个字符流</p>
<pre><code class="java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</code></pre>
<p>BufferedReader对象创建后，我们可以使用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串</p>
<h5 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h5><p>从BufferedReader对象读取一个字符要使用**read()**方法</p>
<p>从BufferedReader对象读取一个字符串要使用**readLine()**方法</p>
<pre><code class="java">int read() throws IOException
</code></pre>
<p>每次调用read()方法，它从输入流读取<strong>一个字符</strong>并把该字符作为整数值返回。当流结束的时候返回-1。该方法抛出IOException</p>
<p>下面的程序用read()方法从控制台不断读取字符知道用户输入”q”</p>
<pre><code class="java">//使用BufferedReader 在控制台读取字符
import java.io.*;
public class BRRead&#123;
    public static void main(String args[]) throws IOException&#123;
        char c;
        //使用System.in创建BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        sout(&quot;输入字符，按下&#39;q&#39;键退出.&quot;);
        //读取字符
        do&#123;
            c = (char) br.read();
          //c = br.readLine();
            sout(c);
        &#125; while(c != &#39;q&#39;);
    &#125;
&#125;

运行结果：
输入字符，按下&#39;q&#39;键退出.
123abcq
1
2
3
a
b
c
q
</code></pre>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>该流用于从文件<strong>读取数据</strong>，它的对象可以用关键字new来创建，有多重构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<pre><code class="java">InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输入流对象来<strong>读取文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
InputStream f = new FileInputStream(f);
</code></pre>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>该类用来创建一个文件并向文件中<strong>写数据</strong></p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件</p>
<p>有两个构造方法可以用来创建FileOutputStream对象</p>
<p>使用字符串类型的文件名来创建一个输出流对象</p>
<pre><code class="java">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输出流来<strong>写文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
OutputStream f = new FileOutputStream(f);
</code></pre>
<h5 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h5><h5 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h5><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li>**mkdir()**方法创建一个文件夹，成功则返回true，失败则返回false，失败表明File对象指定的路径已经存在，或者由于整个路径害不存在，该文件夹不能被创建</li>
<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹</li>
</ul>
<h1 id="Java-Scanner类"><a href="#Java-Scanner类" class="headerlink" title="Java Scanner类"></a>Java Scanner类</h1><p>Scanner对象的基本语法：</p>
<pre><code class="java">Scanner s = new Scanner(System.in);
</code></pre>
<p>通过Scanner类的<strong>next()</strong> 与 **nextLine()**方法获取输入的字符串</p>
<p>在读取前我们需要使用 <strong>hasNext</strong> 与 <strong>hasNextLine</strong> 判断是否还有输入数据。</p>
<p><strong>使用next方法：</strong></p>
<pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;next方式接收：&quot;);
        //判断是否还有输入
        if(scan.hasNext())&#123;
            String str1 = scan.next();
            sout(&quot;输入的数据为: &quot; + str1);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj
</code></pre>
<h5 id="使用nextLine方法："><a href="#使用nextLine方法：" class="headerlink" title="使用nextLine方法："></a>使用nextLine方法：</h5><pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String[] args)&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;nextLine方式接收: &quot;);
      //判断是否还有输入
        if(scan.hasNextLine())&#123;
            String str2 = scan.nextLine();
            sout(&quot;输入的数据为: &quot; + str2);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj com
</code></pre>
<h5 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h5><p><u>next():</u></p>
<ul>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next()方法胡自动将其去掉</li>
<li>只有输入有效字符才能将其后面输入的空白作为分隔符或结束符</li>
<li>next()不能得到带有空格的字符串</li>
</ul>
<p><u>nextLine()：</u></p>
<ul>
<li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白</li>
</ul>
<p>如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用hasNextXxx() 方法进行验证，再使用 nextXxx()来读取：</p>
<pre><code class="java">import java.util.Scanner;
public calss ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        int i = 0;
        float f = 0.0f;
        sout(&quot;输入整数： &quot;);
        if(scan.hasNextInt())&#123;
            //判断输入的是否是整数
            i = scan.nextInt();
            sout(&quot;整数数据: &quot; + i);
        &#125; else&#123;
            sout(&quot;输入的不是整数！&quot;);
        &#125;
        sout(&quot;输入小数: &quot;);
        if(scan.hasNextFloat())&#123;
            //判断输入的是否是小数
            f = scan.nextFloat();
            sout(&quot;小数数据: &quot; + f);
        &#125; else&#123;
            sout(&quot;输入的不是小数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h5 id="捕获异常-try-x2F-catch"><a href="#捕获异常-try-x2F-catch" class="headerlink" title="捕获异常 try&#x2F;catch"></a>捕获异常 try&#x2F;catch</h5><p>使用 try 和 catch关键字可以捕获异常，try&#x2F;catch 代码块中的代码成为保护代码</p>
<pre><code class="java">try&#123;
    //见识代码执行过程，一旦发现异常则直接跳转至catch，
    //如果没有异常则直接跳转至finally
&#125; catch (ExceptionName e1)&#123;
    //Catch快 可选执行的代码块，如果没有任何异常发生不会执行
    //如果发现异常则进行处理或向上抛出
&#125; finally&#123;
    //必选执行的代码块，不管是否有异常发生
    //及时发生内存溢出异常也会执行，通常用于处理善后清理工作
&#125;
</code></pre>
<h5 id="throws-x2F-throw关键字"><a href="#throws-x2F-throw关键字" class="headerlink" title="throws&#x2F;throw关键字"></a>throws&#x2F;throw关键字</h5><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用throws关键字来声明</p>
<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开</p>
<pre><code class="java">import java.io.*;
public class className&#123;
    public void withdraw(double amount) throws RemoteException, InsufficientFundsException&#123;
        //...
    &#125;
&#125;
</code></pre>
<h5 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h5><p>用来创建在try代码块后面执行的最后一个 代码块，无论是否发生异常，finally代码块中的代码总会被执行</p>
<h5 id="小综合"><a href="#小综合" class="headerlink" title="小综合"></a>小综合</h5><pre><code class="java">public class ExcepTest&#123;
    public static void main(String args[])&#123;
        int a[] = new int[2];
        try&#123;
            sout(&quot;Access element three :&quot; + a[3]);
        &#125; catch(ArrayIndexOutOfBoundsException e)&#123;
            sout(&quot;Exception thrown :&quot; + e);
        &#125; finally&#123;
            a[0] = 6;
            sout(&quot;First element value: &quot; + a[0]);
            sout(&quot;The finally statement is executed&quot;);
        &#125;
    &#125;
&#125;
运行结果：
Exception thrown :java.l
</code></pre>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><p>如果类A是类B的父亲，而类B是类C的父亲，我们也称类C是A的子类，类C是从类A继承而来的，在Java中，类的继承是单一继承，一个子类只能拥有一个父类。</p>
<p>继承中最常使用的两个关键词是<strong>extends</strong>和<strong>implements</strong></p>
<p>这两个关键字的使用决定了一个对象和另一个对象是否是一个关系，我们能实现一个对象获取另一个对象的属性</p>
<p>所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，而除了Object外，所有类必须有一个父类。</p>
<p>通过<strong>extends关键字</strong>可以申明一个类是继承另一个类而来的</p>
<pre><code class="java">public class A&#123;
    private int i;
    protected int j;
    
    public void func()&#123;
        
    &#125;
&#125;

public class B extends A&#123;
    public int z;
    public void fund()&#123;
        
    &#125;
&#125;
类B由类A继承而来的，类B是类A的子类，而类A是Object的子类，这里可以不显示地声明
作为子类，类B的实例拥有类A所有的成员变量，但对于private类型的成员变量类B却没有访问权限
这保障了类A的封装性
</code></pre>
<pre><code class="java">public class Animal&#123;&#125;
public class Mammal extends Animal&#123;&#125;  Animal类是Mammal类的父类
public class Reptile extends Animal&#123;&#125; Animal类是Reptile类的父类
                                       Mammal类和Reptile类是Animal类的子类   
public class Dog extends Mammal&#123;&#125; Dog类既是Mammal类的子类 又是 Animal类的子类
//通过使用关键字 extends,子类可以继承父类的除privat属性外所有的属性
//通过使用 instanceof 操作符,能够确定左边的对象是不是右边类的实例
public class Dog extends Mammal&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Mammal m = new Mammal();
        Dog d = new Dog();
        sout(m instanceof Animal);
        sout(d instanceof Mammal);
        sout(d instanceof Animal);
    &#125;
&#125;
运行结果
true
true
true
</code></pre>
<h4 id="HAS-A关系"><a href="#HAS-A关系" class="headerlink" title="HAS-A关系"></a>HAS-A关系</h4><p>HAS-A代表类和它的成员之间的从属关系，有助于代码的重用和减少代码的错误。</p>
<pre><code class="java">public class Vehicle&#123;&#125;
public class Speed&#123;&#125;
public class Van extends Vehicle&#123;
    private Speed sp;
&#125;
//Van类将实现的细节对用户隐藏起来，因此，用户只需要知道怎样调用Van类来完成某一功能
//而不必知道Van类是自己来做还是调用其他类来做这些工作
</code></pre>
<p>Java只支持单继承，一个类不能继承多个类</p>
<pre><code class="java">（×） public class test extends Animal, Mammal&#123;&#125;  (×)
</code></pre>
<p>Java只支持单继承(<u><strong>继承基本类</strong></u>和<u><strong>抽象类</strong></u>)，可以用接口来实现(<u><strong>多继承接口实现</strong></u>)</p>
<pre><code class="java">public class Apple extends Fruit implements Fruit1, Fruit2&#123;&#125;
一般继承基本类和抽象类用extends关键字，实现接口类的继承用implements关键字。
</code></pre>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写重要的地方是<u>返回值</u>和<u>形参</u>都不能改变，外壳不变，核心重写！</p>
<p>重写的好处在于子类可以根据需要，定义特定与自己的行为。</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        sout(&quot;狗可以跑和走&quot;);
    &#125;
  /*  
      public void bark()&#123;
        sout(&quot;狗可以吠叫&quot;);
    &#125; 
  */
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Animal b = new Dog();
        a.move();
        b.move();
       // a.bark();//此处会报错,因为a的引用类型Animal没有bark方法
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<p>尽管b属于Animal类型，但是它可以运行Dog类的move方法</p>
<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>参数列表与被重写方法的参数列表必须完全相同</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>子类方法的访问权限必须大于或等于父类方法的访问权限：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>声明为static的方法不能被重写，但可以被再次声明</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法</li>
<li>子类和父类不在同一个包中，那么子类可以重写父类的声明为public和protected的非final方法</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
<li>权限受阻：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
</ul>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><p>当需要在子类中调用父类的被重写方法时，要使用super关键字</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        super.move();
        sout(&quot;狗可以跑和走&quot;);
    &#125;
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal b = new Dog();
        b.move();
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载是在一个类里面，<u>方法名字</u>相同，而<u>参数</u>不同，<u>返回类型</u>可以相同也可以不同</p>
<p>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表</p>
<p>重载规则：</p>
<ul>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ul>
<h4 id="重写和重载的区分"><a href="#重写和重载的区分" class="headerlink" title="重写和重载的区分"></a>重写和重载的区分</h4><pre><code class="java">重写 bark(方法名和参数都一样)
class Dog&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
&#125;
class Hound extends Dog&#123;
    public void sniff()&#123;
        sout(&quot;sniff &quot;);
    &#125;
    public void bark()&#123;
        sout(&quot;bowl&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">重载 bark(方法名相同，参数不同)
class DOg&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
    public void bark(int num)&#123;
        for(int i = 0; i &lt; num; i++)&#123;
            sout(&quot;woof &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制(可以降低限制)</td>
</tr>
</tbody></table>
<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>多态是同一种行为具有不同表现形式或形态的能力</p>
<p>多态性是对象多种表现形式的体现</p>
<p>宠物&#x3D;小猫+小狗+蜥蜴</p>
<pre><code class="java">public interface Vegetarian&#123;&#125;
public class Animal&#123;&#125;
public class Deer extends Animal implements Vegetarian&#123;&#125;
</code></pre>
<p>当我们将引用型变量应用于Deer对象的引用</p>
<pre><code class="java">Deer d = new Deer();
Animal a = d;
Vegetarian v = d;
Object o = d;
所有的引用型变量d,a,v,o都指向堆中想通的Deer对象
</code></pre>
<h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><ul>
<li><strong>重写</strong></li>
<li><strong>接口</strong></li>
<li><strong>抽象类和抽象方法</strong></li>
</ul>
<h1 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h1><p>在Java面向对象的概念中，所有的对象都是通过类来秒回的</p>
<p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类除了不能实例化对象之外，类的其他功能依旧存在：成员变量、成员方法、构造方法</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用(通常在设计阶段决定要不要设计抽象类)</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>如果你想设计一个类：包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract关键词同样可以声明抽象方法，抽象方法只包含一个方法名，没有方法体</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号</p>
<pre><code class="java">public abstract class Employee&#123;
    private String name;
    private String address;
    private int number;
    public abstract double computePay();
    //其余代码
&#125;
</code></pre>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么这个类必须是抽象类</li>
<li>任何子类必须重写父亲的抽象方法，或者声明自身为抽象类</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法</p>
<pre><code class="java">public class Salary extends Employee&#123;
    private double salary;
    public double computePay()&#123;
        sout(&quot;Computing salary pay for &quot; + getName());
        return salary/52;
    &#125;
&#125;
</code></pre>
<h1 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h1><p>封装是一种将抽象性函式接口的实作细节部分包装、隐藏起来的方法</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</p>
<p>要访问该类代码和数据，必须通过严格的接口控制</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</p>
<p>适当的粉装可以让代码更容易理解和维护，也增强了代码的安全性</p>
<pre><code class="java">public class EncapTest&#123;
    private String name;
    private String idNum;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIdNum() &#123;
        return idNum;
    &#125;

    public void setIdNum(String idNum) &#123;
        this.idNum = idNum;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>public方法是外部类访问该类成员变量的入口，这些方法称为getter和setter方法</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法</p>
<pre><code class="java">public class RunEncap&#123;
    public static void main(String args[])&#123;
        EncapTest encap = new EncapTest();
        encap.setName(&quot;James&quot;);
        encap.setAge(20);
        encap.setIdNum(&quot;12343ms&quot;);
        sout(&quot;Name : &quot; + encap.getName() 
           + &quot;Age: &quot; + encap.getAge());
    &#125;
&#125;
运行结果：
Name : James Age : 20
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>