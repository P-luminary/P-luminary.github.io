
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2025/08/12/运维/Appium/">
        <h2>
            Appium
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/8/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="测试方面"><a href="#测试方面" class="headerlink" title="测试方面"></a>测试方面</h3><ul>
<li>功能测试</li>
<li>安装卸载测试</li>
<li>升级测试</li>
<li>兼容性测试[不同机型 系统]</li>
<li>网络切换，中断测试</li>
<li>横竖屏切换</li>
<li>健壮性</li>
</ul>
<h3 id="测试环境的搭建"><a href="#测试环境的搭建" class="headerlink" title="测试环境的搭建"></a>测试环境的搭建</h3><h6 id="需要配置的环境："><a href="#需要配置的环境：" class="headerlink" title="需要配置的环境："></a>需要配置的环境：</h6><ul>
<li>java jdk java环境</li>
<li>Android sdk 安卓环境</li>
<li>python环境<ul>
<li>第三库：appium</li>
</ul>
</li>
<li>使用真机或模拟器进行测试【夜神模拟器】</li>
</ul>
<h4 id="环境搭建验证测试"><a href="#环境搭建验证测试" class="headerlink" title="环境搭建验证测试"></a>环境搭建验证测试</h4><p>模拟器或真机</p>
<p>在cmd中输入 <code>adb devices</code> 会返回ip地址和端口号<br>获取系统版本号输入 <code>adb shell getprop ro.build.version.release</code><br>获取虚拟器里的app名称 <code>adb shell dumpsys window windows | findstr mFocusedApp</code></p>
<blockquote>
<p>{c361382 u0 com.android.settings&#x2F;.Settings t9}}}  &#x2F;.后面是界面的名字    u0后 &#x2F;.前是app名称</p>
</blockquote>
<pre><code class="python">import time

from appium import webdriver
from selenium.webdriver.common.by import by  #【利用by自动获取信息】

# 配置手机连接的参数信息
# 参数信息都是以键值对的方式进行连接
desired_caps = &#123;&#125;

# 设备的名称
desired_caps[&quot;deviceName&quot;] = &quot;127.0.0.1:62001&quot;

# 系统
desired_caps[&quot;platformName&quot;] = &quot;Android&quot;

# 系统版本号
desired_caps[&quot;platformVersion&quot;] = &quot;7.1.2&quot;

# 启动的app名称
## com.android.settings
desired_caps[&quot;appPackage&quot;] = &quot;com.android.settings&quot;

# 启动的app界面：.Settings
desired_caps[&quot;appActivity&quot;] = &quot;.Settings&quot;

# print(desired_caps)

# 发送链接  用的appium的端口  用关键字传参
driver = webdriver.Remote(&quot;http://127.0.0.1:4723/wd/hub&quot;,desired_capabilities = desired_caps)

time.sleep(5)
driver.quit()
...
...
</code></pre>
<h3 id="app自动化测试的流程"><a href="#app自动化测试的流程" class="headerlink" title="app自动化测试的流程"></a>app自动化测试的流程</h3><h6 id="①-首先明确项目的核心模块"><a href="#①-首先明确项目的核心模块" class="headerlink" title="① 首先明确项目的核心模块"></a>① 首先明确项目的核心模块</h6><ul>
<li><strong>注册登录</strong></li>
<li><strong>阅读文章</strong></li>
<li><strong>搜索内容</strong></li>
<li><strong>发布评论</strong></li>
<li><strong>关注订阅</strong></li>
<li><strong>私信聊天</strong></li>
<li><strong>点赞等等</strong></li>
</ul>
<h6 id="②-设计用例脚本"><a href="#②-设计用例脚本" class="headerlink" title="② 设计用例脚本"></a>② 设计用例脚本</h6><p>分析用例执行的步骤</p>
<ul>
<li>进入app首页</li>
<li>点击我的界面</li>
<li>点击登录&#x2F;注册</li>
<li>点击使用邮箱登录&#x2F;注册</li>
<li>输入邮箱号</li>
<li>输入密码</li>
<li>点击登录</li>
<li>登录成功&#x2F;失败</li>
<li>进行断言</li>
</ul>
<h5 id="自动截取虚拟器上界面的图片查看详情"><a href="#自动截取虚拟器上界面的图片查看详情" class="headerlink" title="自动截取虚拟器上界面的图片查看详情"></a>自动截取虚拟器上界面的图片查看详情</h5><p><code>D:\android_sdk_test\tools\uiautomatorviewer.bat</code></p>
<p><span style = "color:red">若两个 <code>resource-id</code> 定位是一样的那么就需要手写XPATH【resource-id必须唯一！！】</span></p>
<pre><code class="mysql">####### 这些都是线性脚本！！！
# 两个斜杠是代表当前界面所有的元素  增加个文本标识
driver.find_element(By.XPATH,&#39;//*[@text=&quot;我的&quot;]&#39;).click()
# 点击登录/注册
driver.find_element(By.ID,&#39;io.manong.developerdaily:id/login_btn&#39;).click()
# 点击使用邮箱登录/注册   这里有报错是因为代码执行很快 但界面有延迟 需要加等待
time.sleep(2)
driver.find_element(By.ID,&#39;io.manong.developerdaily:id/btn_email&#39;).click()

# 输入邮箱号
time.sleep(2)
driver.find_element(By.ID,&#39;io.manong.developerdaily:id/edt_email&#39;).send_keys(&quot;zzz@qq.com&quot;)
# 输入密码
driver.find_element(By.ID,&#39;io.manong.developerdaily:id/edt_email&#39;).send_keys(&quot;123123&quot;)
# 点击登录
driver.find_element(By.XPATH,&#39;//*[@text=&quot;登录&quot;]&#39;).click()
# 用户名是tata
try:
name_text = driver.find_element(By.XPATH,&#39;io.manong.developerdaily:id/nav_tv_name&#39;).click()
if name_text == &quot;tata&quot;:
    print(&quot;登录成功&quot;)

# - 登录成功/失败
# - 进行断言
    assert name_text == &quot;tata&quot;
except:
    login_failed_msg = driver.find_element(By.XPATH,&#39;io.manong.developerdaily:id/forgot&#39;).click()
    print(&quot;登录失败&quot;)
    assert login_failed_msg == &quot;忘了密码？点此找回&quot;
time.sleep(5)
...
...
</code></pre>
<p>若换了一个模块要重新截图 选取不同的app界面<br><span style = "color:red">这些用例测试属于<strong>冒烟测试</strong>的过程</span></p>
<blockquote>
<p><strong>Allure</strong>是一款灵活、轻量级的多语言测试报告工具，旨在生成美观且易于阅读的测试报告。它由Qameta Software团队开源，支持多种测试框架，如Pytest和TestNG等。Allure不仅可以快速查看测试结果，还能帮助团队成员清晰了解测试过程中的缺陷和问题。通过Allure，用户可以轻松集成测试用例，并生成统一格式的报告，提升测试的可读性和有效性。 </p>
</blockquote>
<h3 id="总结梳理"><a href="#总结梳理" class="headerlink" title="总结梳理"></a>总结梳理</h3><h6 id="核心业务流程梳理"><a href="#核心业务流程梳理" class="headerlink" title="核心业务流程梳理"></a>核心业务流程梳理</h6><ul>
<li>需求分析</li>
<li>设计用例脚本</li>
<li><strong>编写自动化测试脚本</strong><ul>
<li>将冒烟测试的脚本进行深度封装和模式设计<ul>
<li>选择设计模式：<ul>
<li>POM设计模式</li>
<li>KDT设计模式</li>
</ul>
</li>
<li>引入测试框架pytest结合设计模式进行深度封装</li>
<li>执行过程中进行日志信息的记录log</li>
<li>执行完成之后自动化完成测试报告allure</li>
<li>持续集成Jenkins</li>
</ul>
</li>
</ul>
</li>
<li>脚本维护以及迭代更新</li>
</ul>
<p>app自动化测试的核心技能点：</p>
<p><span style = "color:red"><strong>Python + Appium + pytest + parametrize + csv + pom + log + Allure + Jenkins</strong></span></p>
<h3 id="项目梳理及描述"><a href="#项目梳理及描述" class="headerlink" title="项目梳理及描述"></a>项目梳理及描述</h3><p><span style = "color:blue">脚本执行的时候会直接发送给Appium服务器 执行py代码后 在Appium会执行许多<strong>adb</strong>的命令 再去控制手机 完成自动化测试</span>【线性模块 正反例要跑通噢】</p>
<p>站在项目已经完成雏形的基础上，进行项目梳理和总结</p>
<ul>
<li><p>整个项目中的文件解析</p>
<ul>
<li>每个文件包和模块具体的使用规范</li>
</ul>
</li>
<li><p>整个项目中的模块与文件之间的联系</p>
<ul>
<li>各个模块及包之间的导入使用</li>
</ul>
</li>
<li><p>整体从项目完成之后的角度触发去讲解项目搭建流程以及使用规范</p>
<ul>
<li><p><strong>搭建app自动化测试环境</strong>：</p>
<ul>
<li>安卓sdk</li>
<li>java的sdk</li>
<li>安装appium</li>
<li>使用真机或者安装手机模拟器</li>
<li>安装第三方库：Appium-Python-Client</li>
</ul>
</li>
<li><p><strong>编写自动化的用例线性脚本</strong></p>
<ul>
<li><p>新建一个项目</p>
</li>
<li><p>创建一个script脚本包</p>
<ul>
<li><p>梳理核心业务模块和功能</p>
<ul>
<li>登录</li>
<li>注册</li>
<li>点赞评论收藏</li>
<li>发布文章</li>
<li>浏览文章</li>
<li>…</li>
</ul>
</li>
<li><p>创建py模型进行线性脚本编写</p>
<ul>
<li>通过核心业务流程模块梳理出线性脚本的执行步骤</li>
<li>然后通过编写自动化用例脚本执行完成第一轮正反例的<strong>冒烟测试</strong><ul>
<li>梳理被操作元素以及具体操作方法</li>
<li>执行正反例之后进行断言</li>
<li>保证自动化用例的准确性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>若是那种本身图标没有id 没有任何标志的 比如点赞，收藏，评论 就可以直接通过<strong>坐标去定位</strong>【要考虑分辨率和坐标以及机型】<br>回归测试一般只需要正例脚本！！！</p>
<ul>
<li><p><strong>选择设计模式pom</strong>【Page Object Model页面对象模型的简称】</p>
<ul>
<li>封装<ul>
<li>一个类就是一个流程用例或者一个界面</li>
<li>将界面中需要被操作的每一个元素封装成类属性</li>
<li>将界面中需要被执行的用例步骤定义成一个实例方法</li>
</ul>
</li>
<li>使用<ul>
<li>创建页面类对象</li>
<li>通过对象调用方法执行用例步骤脚本</li>
<li>获取实际结果进行断言</li>
</ul>
</li>
<li>整个页面封装</li>
<li>将线性文件进行封装</li>
</ul>
</li>
<li><p><strong>引入测试框架结合用例执行以及管理</strong></p>
<ul>
<li>用例进行综合管理</li>
<li>使用参数化进行数据驱动测试：</li>
</ul>
<pre><code class="python">@pytest.mark.parametrize(&quot;user_email, password, t_a_f&quot;,[
    [&quot; &quot;, &quot;123123&quot;, False],
    [&quot;123@qq.com&quot;, &quot;123123&quot;, True],
    ...
])
</code></pre>
<ul>
<li>一般情况在用例执行之前讲参数化使用的实参进行读取使用<ul>
<li>数据量比较多的情况下会使用不同的文件格式存储数据<ul>
<li>Csv</li>
<li>text</li>
<li>Excel</li>
<li>yaml</li>
<li>JSON</li>
<li>…</li>
</ul>
</li>
<li>数据驱动测试主要核心就是在用例设计的过程中，把所有用例需要的正反例数据进行保存</li>
<li>然后再使用的时候进行读取自动化操作用例完成脚本内容</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>日志信息的记录</strong></p>
</li>
<li><p><strong>缺陷报告的生成</strong></p>
</li>
<li><p><strong>持续集成的处理</strong></p>
</li>
</ul>
<p>单独执行某个用例<code>(venv) D:\app_project&gt;pytest -vsk test_login</code><br>有很多其他的需要保持登录的情况下进行测试 ↓</p>
<pre><code class="python"># 点赞评论及收藏
def test_like_comment_collect(go_login):
    # 创建页面类对象
    l_c_l_page = LikeCommentCollectPage(go_login)
    # 通过对象调用方法执行用例步骤
    l_c_l_page.execute_cases()
    
# 发布文章
def test_publish_article(go_login):...

# 浏览文章
def test_browse_article(go_login):...
</code></pre>
<h2 id="Pywinauto基本介绍【基本解决找不到元素问题】"><a href="#Pywinauto基本介绍【基本解决找不到元素问题】" class="headerlink" title="Pywinauto基本介绍【基本解决找不到元素问题】"></a>Pywinauto基本介绍【基本解决找不到元素问题】</h2><p>主要用于自动化图形用户界面，他提供了一组功能丰富的工具和方法，能够模拟用户的各种操作:点击，输入，文本，选择菜单栏等等…从而实现对Windows应用程序的自动化控制</p>
<h5 id="pywinauto的基本特性"><a href="#pywinauto的基本特性" class="headerlink" title="pywinauto的基本特性"></a>pywinauto的基本特性</h5><ul>
<li>支持跨平台</li>
<li>强大的GUI自动化功能【用户交互图形界面】</li>
<li>简单易用</li>
<li>支持多种应用程序的类型</li>
<li>丰富的文档和社区支持</li>
<li>支持多种GUI框架</li>
<li>图像识别和模糊匹配</li>
</ul>
<h5 id="pywinauto应用场景"><a href="#pywinauto应用场景" class="headerlink" title="pywinauto应用场景"></a>pywinauto应用场景</h5><ul>
<li>自动化测试</li>
<li>ui自动化测试</li>
<li>数据录入和处理</li>
<li>窗口管理</li>
<li>…</li>
</ul>
<h5 id="pywinauto的安装和使用"><a href="#pywinauto的安装和使用" class="headerlink" title="pywinauto的安装和使用"></a>pywinauto的安装和使用</h5><p>需要安装第三方库依赖：pywinauto<br>安装命令：【pycharm可以在某个项目下安装】<br><code>pip install pywinauto</code><br>可以用<code>pip list</code>查看是否安装好了 pywinauto</p>
<h3 id="pywinauto基本使用"><a href="#pywinauto基本使用" class="headerlink" title="pywinauto基本使用"></a>pywinauto基本使用</h3><p>案例：使用pywinauto编写自动化脚本，完成记事本的基本操作<br><strong>操作流程：</strong></p>
<ul>
<li>打开记事本</li>
<li>点击帮助（关于记事本）</li>
<li>点击确定</li>
<li>输入内容</li>
<li>点击关闭记事本</li>
<li>点击不保存</li>
</ul>
<pre><code class="python"># 导包
from pywinauto.application import Application

# 启动记事本  backend=&#39;uia&#39;意思是连接记事本的后端是什么类型
# app = Application(backend=&#39;uia&#39;).start(&#39;notepad.exe&#39;)
app = Application(backend=&#39;win32&#39;).start(&#39;notepad.exe&#39;)

# 点击帮助（关于记事本） 使用快捷键完成打开关于记事本的信息  %是Alt符号  H:h  A:a
app.Notepad.type_keys(&#39;%HA&#39;, pause=1)

# 点击确定  re正则匹配
dlg = app.window(title_re=&#39;关于记事本&#39;)
 # 获取窗口的界面元素信息  【关于记事本的元素架构】
dlg.print_control_identifiers()
 #  点击    不直接调用click是要运用鼠标真实的模拟
time.sleep(1)
dlg[&#39;确定Button&#39;].click_input()

# 输入内容
app.Notepad.type_keys(&#39;xx教育&#39;)
# 点击关闭记事本
 # 菜单栏选择 -&gt;表示子菜单
app.Notepad.menu_select(&quot;文件(&amp;F)-&gt;退出(&amp;X)&quot;)
# 点击不保存
app.window(title_re=&#39;记事本&#39;).window(title_re=&#39;不保存&#39;).cli
</code></pre>
<h6 id="桌面化元素定位工具：UISpy-exe【层级树】、inspect-exe"><a href="#桌面化元素定位工具：UISpy-exe【层级树】、inspect-exe" class="headerlink" title="桌面化元素定位工具：UISpy.exe【层级树】、inspect.exe"></a>桌面化元素定位工具：UISpy.exe【层级树】、inspect.exe</h6>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/运维" style=color:#00bcd4>
                运维
            </a>
        </span>
        
    </div>

    <a href="/2025/08/12/运维/Appium/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/07/16/运维/AI_Linux运维/">
        <h2>
            AI_Linux运维
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/7/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="IT运维基本概念"><a href="#IT运维基本概念" class="headerlink" title="IT运维基本概念"></a>IT运维基本概念</h3><h5 id="系统运维"><a href="#系统运维" class="headerlink" title="系统运维"></a>系统运维</h5><p>聚焦基础设施稳定性，通过监控工具(如Zabbix、Prometheus)实时追踪服务器、网络及操作系统状态，实施负载均衡、几余设计，快速响应硬件故障或性能瓶颈，确保业务连续性。</p>
<h5 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h5><p>以效率提升与标准化为目标，借助像Ansible自动化工具部署、配置管理及巡检任务，结合CI&#x2F;CD流水线实现发布流程无人化，减少人为失误并提升迭代速度。</p>
<h5 id="数据库运维"><a href="#数据库运维" class="headerlink" title="数据库运维"></a>数据库运维</h5><p>核心是数据安全与性能调优，通过定期备份恢复、主从复制保障数据可靠性，利用慢查询分析、索引优化及资源监控(如MySQLPerformance Schema)提升数据库响应效率。</p>
<h5 id="容器运维"><a href="#容器运维" class="headerlink" title="容器运维"></a>容器运维</h5><p>专注容器编排与弹性调度，基于Kubernetes实现容器生命周期管理、服务发现及自动扩缩容，配合lstio服务网格治理微服务，确保分布式应用的高可用与快速伸缩。</p>
<h5 id="云计算运维"><a href="#云计算运维" class="headerlink" title="云计算运维"></a>云计算运维</h5><p>围绕资源弹性与成本优化，利用云平台(如AWS&#x2F;Aliyun)的自动扩缩容、Serverless服务动态匹配资源需求，通过资源标签、账单分析工具优化云开支，平衡性能与成本。</p>
<h5 id="信创运维"><a href="#信创运维" class="headerlink" title="信创运维"></a>信创运维</h5><p>解决国产化适配与生态兼容，在鲲鹏CPU、统信0S、达梦数据库等信创体系中，完成软硬兼容性测试、系统迁移，满足政策与安全要求。</p>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>流程：产品设计-&gt;项目研发-&gt;项目测试-&gt;项目上线-&gt;运维<br>研发：前端（HTML+CSS+JavaScript）+后端（Java&#x2F;Python&#x2F;Go）<br>运维：产品上线、后期的运行与维护工作都属于运维工程师范畴</p>
<table>
<thead>
<tr>
<th align="center">环境</th>
<th align="center">主要用户</th>
<th align="center">主要用途</th>
<th align="center">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开发环境</td>
<td align="center">开发人员</td>
<td align="center">编写和初步调试代码，快速验证想法</td>
<td align="center">降低风险、提高效率、保证质量</td>
</tr>
<tr>
<td align="center">测试环境</td>
<td align="center">测试工程师、QA团队</td>
<td align="center">自动化测试、功能测试、性能测试、模拟真实场景，发现隐藏问题</td>
<td align="center">降低风险、提高效率、保证质量</td>
</tr>
<tr>
<td align="center"><strong>生产环境</strong></td>
<td align="center"><strong>最终用户</strong></td>
<td align="center"><strong>正式对外提供服务要求高可用、高稳定、高安全</strong></td>
<td align="center">降低风险、提高效率、保证质量</td>
</tr>
</tbody></table>
<h3 id="工单系统"><a href="#工单系统" class="headerlink" title="工单系统"></a>工单系统</h3><p>工单系统(TicketingSystem)是运维工程师和 IT支持团队在日常工作中广泛使用的工具。简单来说，它是一种用于记录、分配和处理工作请求、问题报告、变更申请等事项的系统。</p>
<ul>
<li><h5 id="提交工单"><a href="#提交工单" class="headerlink" title="提交工单"></a>提交工单</h5><p>用户在系统中填写问题描述、所属类别、优先级等</p>
</li>
<li><h5 id="自动分配"><a href="#自动分配" class="headerlink" title="自动分配"></a>自动分配</h5><p>系统根据规则将工单自动分配相关人员</p>
</li>
<li><h5 id="处理反馈"><a href="#处理反馈" class="headerlink" title="处理反馈"></a>处理反馈</h5><p>处理人记录诊断与解决方案，并与用户沟通</p>
</li>
<li><h5 id="验证关闭"><a href="#验证关闭" class="headerlink" title="验证关闭"></a>验证关闭</h5><p>用户确认问题已解决后工单状态变为“已关闭”</p>
</li>
</ul>
<h3 id="网络通信”三要素“"><a href="#网络通信”三要素“" class="headerlink" title="网络通信”三要素“"></a>网络通信”三要素“</h3><p>网络通信是指在<u>不同设备</u>间通过<u>网络</u>连接进行<strong>数据传输</strong>与<strong>交换</strong>的过程。</p>
<p>**协议(Protocol)**：协议定义了数据在网络中传输时的规则和格式。常见的协议有 TCP&#x2F;IP、UDP、HTTP&#x2F;S、FTP 等它们规定了数据如何被分割、传输、接收和重组。</p>
<p>**IP(internet Protocol)**：IP 地址用于唯一标识网络中的每一台设备。它充当设备的“地址”，使得数据能够在网络中准确地找到目标设备。</p>
<pre><code class="yaml">IPV4
格式:x.x.x.x
由4个8位的二进制数组成，
每组之间用点分隔,展示形
式以10进制表示
如:192.168.88.102

IPV6格式：
由8个16位的十六进制数组成，
每组数字之间用冒号分隔。
如：2001:0db8:85a3:0000:0000:8a2e:0370:7334
</code></pre>
<p>**端口(Port)**：端口用于区分同一台设备上不同的应用程序或服务。在计算机网络中，一个|P 地址可以对应多个服务每个服务通过不同的端口进行通信。端口号是通信中识别应用程序的方式。</p>
<table>
<thead>
<tr>
<th align="center">端口范围</th>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0 ~ 1023</td>
<td align="center">知名(保留)端口</td>
<td align="center">通常被系统或服务使用(例如HTTP 使用端口 80，HTTPS 使用端口 443，FTP使用端口 21)</td>
</tr>
<tr>
<td align="center">1024 ~ 49151</td>
<td align="center">注册端口</td>
<td align="center">通常用于用户和应用程序之间的通信(如数据库服务等)</td>
</tr>
<tr>
<td align="center">49152 ~ 65535</td>
<td align="center">动态或私有端口</td>
<td align="center">用于临时连接或客户端通信</td>
</tr>
</tbody></table>
<h4 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h4><p>云服务器(Cloud Server)，又称云主机或弹性计算服务(Elastic Compute Service,ECS)，是基于云计算技术提供的一种虚拟化服务器。</p>
<p>云服务器利用虚拟化技术，将物理服务器的计算资源(如CPU、内存、存储等)封装成一个或多个独立的虚拟环境,用户可以按需通过互联网远程访问和使用这些资源。</p>
<h5 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h5><table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;bin</td>
<td align="center">二进制命令所在目录(普通命令&#x3D;&gt;普通用户和超级管理员root)</td>
</tr>
<tr>
<td align="center">&#x2F;home 与 &#x2F;root</td>
<td align="center">家目录，&#x2F;home表示普通用户的家目录，&#x2F;root表示超级用户root的家目录</td>
</tr>
<tr>
<td align="center">&#x2F;opt</td>
<td align="center">额外的应用软件包，安装qq、游戏、wps办公软件</td>
</tr>
<tr>
<td align="center">&#x2F;sbin</td>
<td align="center">和管理系统相关的命令，【超级管理员用】，s&#x3D;super超级</td>
</tr>
<tr>
<td align="center">&#x2F;tmp</td>
<td align="center">临时文件目录，这个目录被当作回收站使用</td>
</tr>
<tr>
<td align="center">&#x2F;usr</td>
<td align="center">用户或系统软件应用程序目录，类似Windows中的Program files</td>
</tr>
<tr>
<td align="center">&#x2F;dev</td>
<td align="center">&#x2F;device缩写，设备文件目录，磁盘，光驱&#x3D;&gt;&#x2F;dev&#x2F;sr0</td>
</tr>
<tr>
<td align="center">&#x2F;etc</td>
<td align="center">系统配置文件目录，启动程序，几乎所有的软件都会把自己的配置文件安装在&#x2F;etc中</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3e4244742a4455f7a1d492c89380196ebde25efd/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.png"></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="项目部署架构"><a href="#项目部署架构" class="headerlink" title="项目部署架构"></a>项目部署架构</h3><p>更改主机名<code>hostnamectl set-hostname node1.itcast.cn</code> + <code>su</code></p>
<h6 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h6><p><code>200.146</code> 机器 → <code>[root@node1 sql]# mysql -uroot -proot &lt; ry-zzyl.sql</code> 在这个位置<code>/opt/zzyl/sql</code></p>
<h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><p><code>密码：heima123456</code><br>启动Redis：[root@node1 sql]# <code>redis-server /root/tmp/redis-6.2.4/redis.conf</code><br>测试redis-cli已连接：<code>redis-cli ping</code><br>连接：<code>redis-cli</code></p>
<h5 id="项目接入阿里云OSS（key-secret）"><a href="#项目接入阿里云OSS（key-secret）" class="headerlink" title="项目接入阿里云OSS（key + secret）"></a>项目接入阿里云OSS（key + secret）</h5><p><code>E:\BaiduNetdiskDownload\AI运维\项目内容\后端打包文件\后端打包文件\zzyl-admin.jar\BOOT-INF\classes\application-prod.yml</code> 托到桌面 然后改完再拖回去</p>
<h5 id="开通百度千帆大模型授权老人体检报告分析"><a href="#开通百度千帆大模型授权老人体检报告分析" class="headerlink" title="开通百度千帆大模型授权老人体检报告分析"></a>开通百度千帆大模型授权<del>老人体检报告分析</del></h5><h5 id="项目接入百度千帆大模型（key-secret）"><a href="#项目接入百度千帆大模型（key-secret）" class="headerlink" title="项目接入百度千帆大模型（key + secret）"></a>项目接入百度千帆大模型（key + secret）</h5><blockquote>
<p>依旧是上方阿里云的操作</p>
</blockquote>
<h5 id="项目管理后端部署"><a href="#项目管理后端部署" class="headerlink" title="项目管理后端部署"></a>项目管理后端部署</h5><blockquote>
<p>同上更换application-prod.yaml的redis和mysql连接的<strong>地址</strong>以及<strong>账号密码</strong></p>
<ul>
<li><p>安装jdk11</p>
<p>先创建放置jdk11的安装包目录<code>mkdir -p /export/software</code> 然后<br>将<code>E:\BaiduNetdiskDownload\AI运维\项目内容\jdk\jdk\openjdk-11.0.0.2_linux-x64.tar.gz</code> 放进去<br>接着对jdk11安装包进行解压： 解压到 &#x2F;opt<br><code>tar -xzf openjdk-11.0.0.2_linux-x64.tar.gz -C /opt/</code><br><code>cd /opt/</code><br>输入ll查看 然后配置JDK环境变量</p>
<pre><code class="yaml">vim /etc/profile
  
在文件的尾部添加： 
# JAVA_HOME
export JAVA_HOME=/opt/jdk-11.0.0.2
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=$JAVA_HOME/lib:$CLASSPATH


保存退出后，执行加载操作：
source /etc/profile


校验:
java -version
</code></pre>
<pre><code class="yaml"># /etc/profile

# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc

# It&#39;s NOT a good idea to change this file unless you know what you
# are doing. It&#39;s much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.

pathmunge () &#123;
    case &quot;:$&#123;PATH&#125;:&quot; in
        *:&quot;$1&quot;:*)
            ;;
        *)
            if [ &quot;$2&quot; = &quot;after&quot; ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
&#125;


if [ -x /usr/bin/id ]; then
    if [ -z &quot;$EUID&quot; ]; then
        # ksh workaround
        EUID=`/usr/bin/id -u`
        UID=`/usr/bin/id -ru`
    fi
    USER=&quot;`/usr/bin/id -un`&quot;
    LOGNAME=$USER
    MAIL=&quot;/var/spool/mail/$USER&quot;
fi

# Path manipulation
if [ &quot;$EUID&quot; = &quot;0&quot; ]; then
    pathmunge /usr/sbin
    pathmunge /usr/local/sbin
else
    pathmunge /usr/local/sbin after
    pathmunge /usr/sbin after
fi

HOSTNAME=`/usr/bin/hostname 2&gt;/dev/null`
HISTSIZE=1000
if [ &quot;$HISTCONTROL&quot; = &quot;ignorespace&quot; ] ; then
    export HISTCONTROL=ignoreboth
else
    export HISTCONTROL=ignoredups
fi

export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL

# By default, we want umask to get set. This sets it for login shell
# Current threshold for system reserved uid/gids is 200
# You could check uidgid reservation validity in
# /usr/share/doc/setup-*/uidgid file
if [ $UID -gt 199 ] &amp;&amp; [ &quot;`/usr/bin/id -gn`&quot; = &quot;`/usr/bin/id -un`&quot; ]; then
    umask 002
else
    umask 022
fi

for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
    if [ -r &quot;$i&quot; ]; then
        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then 
            . &quot;$i&quot;
        else
            . &quot;$i&quot; &gt;/dev/null
        fi
    fi
done

unset i
unset -f pathmunge

export JAVA_HOME=/opt/jdk-11.0.0.2
export MAVEN_HOME=/opt/maven
export MYSQL_HOME=/usr/local/mysql

export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$MYSQL_HOME/bin:$PATH
export CLASSPATH=$JAVA_HOME/lib:$CLASSPATH
</code></pre>
</li>
<li><p>上传jar包到node2节点中</p>
<p><code>mkdir -p /opt/zzyl/backend</code></p>
</li>
</ul>
<p> 将<code>E:\BaiduNetdiskDownload\AI运维\项目内容\后端打包文件\后端打包文件\zzyl-admin.jar</code>的拖入node2节点的<code>/opt/zzyl/backend/</code><br>  <code>cd /opt/zzyl/backend/</code><br>  <code>java -jar zzyl-admin.jar</code></p>
</blockquote>
<h4 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h4><p>nginx：[3-0基础带你入行AI Linux运维_项目部署上线.pdf](file:&#x2F;&#x2F;&#x2F;E:&#x2F;BaiduNetdiskDownload&#x2F;AI运维&#x2F;3-0基础带你入行AI Linux运维_项目部署上线.pdf)</p>
<h5 id="智能客服私有化大模型部署"><a href="#智能客服私有化大模型部署" class="headerlink" title="智能客服私有化大模型部署"></a>智能客服私有化大模型部署</h5><p>完成大模型ECS服务器申领</p>
<p>安装GPU驱动</p>
<p>基础环境安装(Anaconda、)</p>
<p>模型部署上线与测试(conda搞虚拟环境、下载chatglm-6b模型知识库、上传ChatGLM-6B代码、安装依赖<del>pip-install</del>)</p>
<h5 id="阿里云监控组件"><a href="#阿里云监控组件" class="headerlink" title="阿里云监控组件"></a>阿里云监控组件</h5><p>阿里云的云监控服务(CloudMonitor)是一款简单易用、功能强大的监控工具，主要用来帮助用户实时监控阿里云上的各种资源(比如服务器、数据库、网络等)，并在出现问题时及时发出警报，确保业务稳定运行。</p>
<ul>
<li>开通云监控</li>
<li>打开云监控控制台</li>
<li>打开主机监控</li>
<li>为需要监控的主机安装Agent 点击自动安装[等待片刻，重新刷新对应的CPU使用率、内存使用率、磁盘使用率的数据即可出现]</li>
</ul>
<h5 id="系统警报服务配置"><a href="#系统警报服务配置" class="headerlink" title="系统警报服务配置"></a>系统警报服务配置</h5><p>云监控中的报警服务规则配置的主要目的是帮助用户实时监控阿里云资源、线下IDC、其他云厂商产品或自定义监控数据的运行状态，并在监控指标达到预设条件时，自动触发报警通知。通过这种方式，用户可以及时获取异常信息并快速采取措施，确保业务系统的稳定性和可靠性，</p>
<ul>
<li><p>设置报警联系人<br>报警联系人:当触发条件后，这些对应的人员信息需要提前录入需要通知相关人员</p>
</li>
<li><p>设置报警联系组</p>
<p>报警联系组:多个联系人合并为一个组，不同的类型可以单独设置为组，告警的时候可以直接针对多个用户同时告警</p>
</li>
<li><p>设置报警规则<br>报警规则:帮助用户监控运行状态，并在监控指标达到预设条件时，自动触发报警通知</p>
</li>
</ul>
<p>需求:监控CPU指标，当连续1分钟CPU使用率超过80%，邮件提醒;提醒;当连续5分钟CPU使用率超过95%，进行电话+短信+邮件；当连续3分钟CPU使用率超过90%，进行短信+邮件</p>
<blockquote>
<p>报警联系人 → 设置报警联系人 → 创建报警规则 → 设置规则描述(规则名称：CPU使用率监控) 里面有紧急红色 警告黄色 普通蓝色 → 可以设置通道沉默周期 → 生效时间 → 选择报警联系人组 → 恢复通知(恢复正常通知) 👉 云监控里面有测试脚本<code>cpu_test.sh</code> 上传到服务器即可<br><code>sh cpu_test.sh</code> sh是用来运行.sh脚本的命令</p>
</blockquote>
<p>对于一些常用指标，云监控提供了<strong>一键告警</strong>方案，可以直接开启使用</p>
<h5 id="系统运维常见问题"><a href="#系统运维常见问题" class="headerlink" title="系统运维常见问题"></a>系统运维常见问题</h5><ul>
<li><p><strong>CPU负载</strong></p>
<p><strong>步骤一：</strong>确认是否存在负载过高  使用<code>top</code>或htop命令查看系统的平均负载值。<br>第一行：<code>load average：4.03，3.71，2.25</code><br>[如果负载值持续高于CPU核心数的0.5倍，则看你存在负载过高问题。如果超过1则负载已经较高了，当超过2~3倍意味着负载超高，需要立即解决]</p>
<p><strong>步骤二：</strong>排查CPU负载过高原因</p>
<table>
<thead>
<tr>
<th>原因</th>
<th>具体表现</th>
<th>如何解决</th>
</tr>
</thead>
<tbody><tr>
<td>异常进程或服务占用大量CPU资源</td>
<td>单个进程或服务占用大量CPU资源，导致整体CPU使用率升高。</td>
<td>使用top或htop命令查看具体占用CPU资源的进程按Shift+P按键，按CPU使用率排序定位异常进程，然后通过Kill9终止异常进程</td>
</tr>
<tr>
<td>系统资源不足</td>
<td>实例CPU性能不足以支撑当前业务需求</td>
<td>升级实例规格或者优化业务逻辑</td>
</tr>
<tr>
<td>磁盘或网络I&#x2F;O瓶颈</td>
<td>CPU负载高但实际CPU使用率较低，可能是磁盘或网络I&#x2F;0瓶颈导致</td>
<td>优化磁盘读写，比如升级高性能云盘优化网络带宽:增加公网带宽或调整内网流量分布</td>
</tr>
<tr>
<td>僵尸进程或不可中断的睡眠状态</td>
<td>通过top命令观察，CPU使用率不高但负载值较高</td>
<td><strong>ps -axjf | grep “D+”</strong> 查看是否存在僵尸进程或不可中断的睡眠状态，如果存在建议恢复其对应依赖资源或重启系统</td>
</tr>
<tr>
<td>系统遭遇病毒或恶意程序攻击</td>
<td>CPU使用率高但无法通过top等命令找到异常进程</td>
<td>通过云监控监测异常时间点，检查是否存在异常域名或IP的网络通信，如果确认，建议先备份数据，然后回滚实例并进行病毒扫描</td>
</tr>
</tbody></table>
</li>
<li><p><strong>内存爆满</strong></p>
<p><strong>步骤一：</strong>确认是否存在内存爆满 使用<code>top</code>或htop命令查看系统的平均负载值。<br>下面那几行 <strong>MiB Mem</strong>：….<br>当Mem行的 free值几乎为0时，表示剩余内存几乎没有了</p>
<p><strong>步骤二：</strong>排查内存过高的原因</p>
<table>
<thead>
<tr>
<th>原因</th>
<th>具体表现</th>
<th>如何解决</th>
</tr>
</thead>
<tbody><tr>
<td>异常进程占用大量内存</td>
<td>单个进程或程序长时间占用大量内存资源</td>
<td>使用top或htop命令查看具体占用内存资源的进程。按M按键，按内存使用率排序，定位异常进程，然后通过Kill-9终止异常进程。</td>
</tr>
<tr>
<td>系统内存不足</td>
<td>实例的物理内存不足以支撑当前业务需求</td>
<td>升级实例规格或优化业务逻辑</td>
</tr>
<tr>
<td>内存泄漏或代码缺陷</td>
<td>应用程序在运行过程中不断消耗内存，导致内存使用率持续升高</td>
<td>使用内存分析工具(如Valgrind、jprofiler、jmap等)分析应用程序的内存占用情况<br/>根据分析结果优化业务代码，修复内存泄漏问题</td>
</tr>
<tr>
<td>已删除未释放的僵尸文件</td>
<td>磁盘空间充足，但内存使用率仍然很高</td>
<td>lsof|grep deleted 查找已删除但未释放的文件，然后重启相关进程以释放内存</td>
</tr>
<tr>
<td>系统缓存或虚拟内存不足</td>
<td>系统缓存占用过多内存，或虚拟内存配置不足</td>
<td>设置Swap分区，增加虚拟内存大小</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="ECS服务器巡检报告"><a href="#ECS服务器巡检报告" class="headerlink" title="ECS服务器巡检报告"></a>ECS服务器巡检报告</h4><p>ECS服务器巡检报告一般是用于评估云服务器ECS实例及其相关资源(如磁盘、网络等)的健康状态和运行性能。该报告基于对ECS实例的全面检查，包括性能指标、安全风险、配置合规性等多个维度的分析。通过巡检报告可以提高系统的稳定性、安全性、优化资源配置和支持合规性审计工作</p>
<p>巡检报告主要内容：</p>
<table>
<thead>
<tr>
<th align="center">内容</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">性能监控数据</td>
<td align="left">CPU使用率、内存使用率、磁盘I&#x2F;O、网络流量等关键性能指标</td>
</tr>
<tr>
<td align="center">异常问题诊断</td>
<td align="left">列出ECS实例在运行过程中发现的异常问题，例如高CPU利用率、磁盘I0异常、网络连接问题等。每个异常项需要附带严重等级(如Info、Warn、Critical)</td>
</tr>
<tr>
<td align="center">安全风险评估</td>
<td align="left">检查ECS实例是否受到DDoS攻击或其他安全威胁，并提供防护建议</td>
</tr>
<tr>
<td align="center">资源使用与配置分析</td>
<td align="left">检查ECS实例的资源配置是否合理，例如磁盘空间是否充足、带宽是否满足业务需求，并提供优化建</td>
</tr>
<tr>
<td align="center">事件记录与处理建议</td>
<td align="left">监测到云盘性能达到上限或未创建快照备份等风险事件，确保系统的稳定性和数据的安全性</td>
</tr>
</tbody></table>
<h4 id="云服务器监控可视化大屏"><a href="#云服务器监控可视化大屏" class="headerlink" title="云服务器监控可视化大屏"></a>云服务器监控可视化大屏</h4><ul>
<li>打开自定义大盘 创建大盘</li>
<li>添加图表</li>
<li>根据需求添加对应监测指标</li>
<li>保存大盘</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#00bcd4>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/07/16/运维/AI_Linux运维/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/07/10/攻略/本地项目暴露端口/">
        <h2>
            本地项目暴露端口
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/7/10
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h5 id="本地后端Java项目-本地前端Vue项目"><a href="#本地后端Java项目-本地前端Vue项目" class="headerlink" title="本地后端Java项目 + 本地前端Vue项目"></a>本地后端Java项目 + 本地前端Vue项目</h5><p>java后端通过<code>mvn</code>进行<code>clean + install + package</code> 然后去项目下的target找到<code>heima-ai-0.0.1-SNAPSHOT.jar</code></p>
<p>Vue用vscode进行<code>npm run build</code>进行前端打包 然后去本前端项目的disk里面 把这里面的所有资源copy到<br>后端的<code>static</code>目录里：<code>C:\Users\Pluminary\Desktop\HouDuan\heima-ai\src\main\resources\static</code></p>
<p>下载<code>Ngrok</code> 放在文件夹里 这样<code>D:\ngrok\ngrok.exe</code> 然后去系统环境变量的path添加<code>D:\ngrok</code><br>随后通过cmd打开<code>C:\Users\Pluminary\Desktop\HouDuan\heima-ai\target</code>目录 然后运行命令<code>java -jar heima-ai-0.0.1-SNAPSHOT.jar </code> 这样就能带着前后端一起启动了</p>
<p>然后再打开一个cmd运行 <code>ngrok http 8080</code>即可</p>
<blockquote>
<p>如果是第一次用需要把token配置到ngrok里面🧩 第 1 步：注册 Ngrok 免费账户</p>
<ol>
<li>打开官网注册（完全免费）：<br> 👉 <a target="_blank" rel="noopener" href="https://dashboard.ngrok.com/signup">https://dashboard.ngrok.com/signup</a></li>
<li>注册后进入控制台首页：<br> 👉 <a target="_blank" rel="noopener" href="https://dashboard.ngrok.com/get-started/your-authtoken">https://dashboard.ngrok.com/get-started/your-authtoken</a></li>
<li>复制你看到的 <code>authtoken</code>，比如：</li>
</ol>
<pre><code>1sdf_abc123XYZ456789_xxxxxxxxxxxxxxxx
</code></pre>
<hr>
<h3 id="🧩-第-2-步：配置-authtoken-到本地-Ngrok-客户端"><a href="#🧩-第-2-步：配置-authtoken-到本地-Ngrok-客户端" class="headerlink" title="🧩 第 2 步：配置 authtoken 到本地 Ngrok 客户端"></a>🧩 第 2 步：配置 authtoken 到本地 Ngrok 客户端</h3><p>打开终端，运行以下命令：</p>
<pre><code>ngrok config add-authtoken 你的authtoken
</code></pre>
<p>示例：</p>
<pre><code>ngrok config add-authtoken 1sdf_abc123XYZ456789_xxxxxxxxxxxxxxxx
</code></pre>
<p>成功后会提示：</p>
<pre><code>Authtoken saved to configuration file: C:\Users\&lt;你的用户名&gt;\.ngrok\ngrok.yml
</code></pre>
</blockquote>
<h4 id="记得-如果想要手机也可以访问一定要写跨域"><a href="#记得-如果想要手机也可以访问一定要写跨域" class="headerlink" title="记得 如果想要手机也可以访问一定要写跨域"></a>记得 如果想要手机也可以访问一定要写跨域</h4><pre><code class="java">package com.itheima.ai.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfiguration implements WebMvcConfigurer &#123;

    @Override
    public void addCorsMappings(CorsRegistry registry) &#123;
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .allowedHeaders(&quot;*&quot;)
                .exposedHeaders(&quot;Content-Disposition&quot;);
    &#125;
&#125;
</code></pre>
<p>然后在前端代码里的api.ts里面不要写死<code>localhost</code><br>比如<code>const BASE_URL = &#39;http://localhost:8080&#39;</code> 要改成<code>const BASE_URL = &#39;&#39;</code></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/攻略" style=color:#00bcd4>
                攻略
            </a>
        </span>
        
    </div>

    <a href="/2025/07/10/攻略/本地项目暴露端口/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/07/08/AI/SpringAI-DeepSeek/">
        <h2>
            SpringAI-DeepSeek
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/7/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="SpringAI-DeepSeek"><a href="#SpringAI-DeepSeek" class="headerlink" title="SpringAI + DeepSeek"></a>SpringAI + DeepSeek</h3><h6 id="JDK版本最低是17"><a href="#JDK版本最低是17" class="headerlink" title="JDK版本最低是17"></a>JDK版本最低是17</h6><h2 id="✅-当前环境总结"><a href="#✅-当前环境总结" class="headerlink" title="✅ 当前环境总结"></a>✅ 当前环境总结</h2><table>
<thead>
<tr>
<th>工具</th>
<th>版本</th>
<th>是否合适</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Node.js</strong></td>
<td>20.12.0</td>
<td>✅ 很好</td>
<td>支持现代前端工具（Vite、React、Vue 等）</td>
</tr>
<tr>
<td><strong>npm</strong></td>
<td>10.5.0</td>
<td>✅ 很好</td>
<td>最新版本，兼容所有依赖</td>
</tr>
<tr>
<td><strong>JDK</strong></td>
<td>20</td>
<td>✅ 足够学习</td>
<td>Spring Boot 3.x 推荐 JDK 17+，JDK 20 也能用</td>
</tr>
<tr>
<td><strong>nvm</strong></td>
<td>1.2.2</td>
<td>✅ 推荐工具</td>
<td>多版本切换已配置好</td>
</tr>
</tbody></table>
<p>在自然语言处理（NaturalLanguage Processing，NLP）中，有一项关键技术叫Transformer，这是一种先进的神经网络模型，是现如今AI高速发展的最主要原因。我们所熟知的大模型（LargeLanguageModels，LLM），例如GPT、DeepSeek底层都是采用Transformer神经网络模型。</p>
<p>GPT ＝ <strong>Generative</strong>(生成式:根据上文预测之后应该出现哪个文本，从而形成连续的文本输出) <strong>Pre</strong>-<strong>trained</strong>(预训练:通过大规模的文本数据进行预训练，让大模型可以理解人类语言的语法、词性。)  <strong>Transformer</strong>(Transformer:深度学习的一种神经网络模型。多数AIGC模型都依赖于此。)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/358004f3a3dc66364f401112fe7403de2690b60b/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6.png"></p>
<h3 id="大模型应用开发"><a href="#大模型应用开发" class="headerlink" title="大模型应用开发"></a>大模型应用开发</h3><p>[大模型服务平台百炼控制台] (<a target="_blank" rel="noopener" href="https://bailian.console.aliyun.com/?tab=model#/api-key">https://bailian.console.aliyun.com/?tab=model#/api-key</a>)<br><code>ollama --help</code> 帮助<br><code>ollama ps</code> 查看目前启动的模型<br><code>ollama list</code> 查看所有模型</p>
<p><code>POST：http://localhost:11434/api/chat</code></p>
<h6 id="Json请求"><a href="#Json请求" class="headerlink" title="Json请求"></a>Json请求</h6><pre><code class="json">&#123;
  &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;,
  &quot;messages&quot;: [
    &#123;
      &quot;role&quot;: &quot;system&quot;,
      &quot;content&quot;: &quot;你是海绵宝宝，以海绵宝宝的身份回答用户的问题&quot;
    &#125;,
    &#123;
      &quot;role&quot;: &quot;user&quot;,
      &quot;content&quot;: &quot;你是谁？&quot;
    &#125;
  ],
  &quot;stream&quot;: false
&#125;
</code></pre>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><pre><code class="yaml">&#123;
    &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;,
    &quot;created_at&quot;: &quot;2025-07-08T13:17:02.464149Z&quot;,
    &quot;message&quot;: &#123;
        &quot;role&quot;: &quot;assistant&quot;,
        &quot;content&quot;: &quot;&lt;think&gt;\n我是海绵宝宝，这里是一个互动式的设定。我是一个AI助手，主要提供帮助和信息。我会用简单易懂的语言回答问题，并保持友好交流。\n&lt;/think&gt;\n\n我是海绵宝宝，这是一个由深度求索公司开发的机器人助手，主要用于提供信息、帮助解答问题等日常需求服务。我以简单的语气和友好的态度与用户沟通，您的提问将被认真考虑并尽快回应。&quot;
    &#125;,
    &quot;done_reason&quot;: &quot;stop&quot;,
    &quot;done&quot;: true,
    &quot;total_duration&quot;: 821012000,
    &quot;load_duration&quot;: 14152500,
    &quot;prompt_eval_count&quot;: 17,
    &quot;prompt_eval_duration&quot;: 3000000,
    &quot;eval_count&quot;: 88,
    &quot;eval_duration&quot;: 802000000
&#125;
</code></pre>
<h2 id="LLM、FunctionCalling、RAG通俗讲解"><a href="#LLM、FunctionCalling、RAG通俗讲解" class="headerlink" title="LLM、FunctionCalling、RAG通俗讲解"></a><span style = "color:red">LLM、FunctionCalling、RAG通俗讲解</span></h2><blockquote>
<h2 id="🧠-一、LLM-是什么？"><a href="#🧠-一、LLM-是什么？" class="headerlink" title="🧠 一、LLM 是什么？"></a>🧠 一、LLM 是什么？</h2><p>LLM 是 “<strong>Large Language Model</strong>” 的缩写，中文叫“<strong>大语言模型</strong>”，比如你正在用的 ChatGPT 就是一个 LLM。</p>
<h3 id="🌰-举个例子："><a href="#🌰-举个例子：" class="headerlink" title="🌰 举个例子："></a>🌰 举个例子：</h3><p>你输入一句话：“我明天要去北京，天气怎么样？”</p>
<p>LLM 会理解你的意思，然后给你一个像人说话一样的回答，比如：“明天北京晴天，气温25度，适合出行。”</p>
<h3 id="✅-它能做的事情有很多，比如："><a href="#✅-它能做的事情有很多，比如：" class="headerlink" title="✅ 它能做的事情有很多，比如："></a>✅ 它能做的事情有很多，比如：</h3><ul>
<li>回答问题</li>
<li>写文章</li>
<li>翻译语言</li>
<li>总结文本</li>
<li>写代码……</li>
</ul>
<p>它的能力来自：<strong>训练了海量的文本数据</strong>，并通过预测“下一个词”来生成自然语言。</p>
<hr>
<h2 id="🧩-二、Function-Calling-是什么？"><a href="#🧩-二、Function-Calling-是什么？" class="headerlink" title="🧩 二、Function Calling 是什么？"></a>🧩 二、Function Calling 是什么？</h2><p>Function Calling（函数调用）是 LLM 的一个增强能力，让它在回答问题时<strong>不光是“说”，还能“做”事</strong>。</p>
<h3 id="🌰-举个例子：-1"><a href="#🌰-举个例子：-1" class="headerlink" title="🌰 举个例子："></a>🌰 举个例子：</h3><p>你说：“帮我查一下明天北京的天气。”</p>
<p>过去 LLM 只能“猜”一个答案。但如果它具备 <strong>Function Calling</strong> 能力，它就可以：</p>
<ol>
<li><strong>调用一个真实的天气查询函数</strong>（比如访问天气API）</li>
<li>得到真实的天气数据（比如：晴 25°C）</li>
<li>再把这个数据生成一句话告诉你。</li>
</ol>
<h3 id="✅-通俗对比："><a href="#✅-通俗对比：" class="headerlink" title="✅ 通俗对比："></a>✅ 通俗对比：</h3><table>
<thead>
<tr>
<th>方式</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td>以前的 LLM</td>
<td>会说话的人，但手不能动</td>
</tr>
<tr>
<td>支持 Function Calling 的 LLM</td>
<td>会说话的人，还能操作电脑帮你查资料、订票、做计算</td>
</tr>
</tbody></table>
<h2 id="🧠-总结一下"><a href="#🧠-总结一下" class="headerlink" title="🧠 总结一下"></a>🧠 总结一下</h2><table>
<thead>
<tr>
<th>概念</th>
<th>通俗解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LLM</strong></td>
<td>一个超级聪明、会说话的 AI（像 ChatGPT）</td>
</tr>
<tr>
<td><strong>Function Calling</strong></td>
<td>让这个 AI 不只是“说话”，还能“调用工具”帮你完成任务</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2 id="🧠-一、RAG-是什么？"><a href="#🧠-一、RAG-是什么？" class="headerlink" title="🧠 一、RAG 是什么？"></a>🧠 一、RAG 是什么？</h2><p>RAG 是 “<strong>Retrieval-Augmented Generation</strong>” 的缩写，中文叫 “<strong>检索增强生成</strong>”。</p>
<p>它是一种让 LLM（大语言模型）更聪明的方式 —— <strong>把外部知识喂给它，然后让它生成答案。</strong></p>
<h3 id="📚-为什么需要-RAG？"><a href="#📚-为什么需要-RAG？" class="headerlink" title="📚 为什么需要 RAG？"></a>📚 为什么需要 RAG？</h3><p>LLM 虽然很厉害，但它的“知识”都是<strong>训练时学的</strong>，不能实时更新。<br> 比如它不知道你公司内部的数据、你昨天写的文档、你自己的笔记……</p>
<p>这时候，<strong>RAG就登场了</strong>！</p>
<h2 id="🧩-二、RAG-的核心思想（通俗理解）"><a href="#🧩-二、RAG-的核心思想（通俗理解）" class="headerlink" title="🧩 二、RAG 的核心思想（通俗理解）"></a>🧩 二、RAG 的核心思想（通俗理解）</h2><h3 id="📦-它其实分两步："><a href="#📦-它其实分两步：" class="headerlink" title="📦 它其实分两步："></a>📦 它其实分两步：</h3><h4 id="第一步：Retrieval（检索）"><a href="#第一步：Retrieval（检索）" class="headerlink" title="第一步：Retrieval（检索）"></a>第一步：Retrieval（检索）</h4><p>从你提供的“知识库”里，把和问题相关的内容找出来。</p>
<p>比如：</p>
<blockquote>
<p>问题是：“Java中线程池的工作原理？”</p>
<p>检索模块会从你知识库中找出：“Java线程池使用Executor框架，分为核心线程数、最大线程数、队列……”这类内容。</p>
</blockquote>
<h4 id="第二步：Generation（生成）"><a href="#第二步：Generation（生成）" class="headerlink" title="第二步：Generation（生成）"></a>第二步：Generation（生成）</h4><p>然后把上面找出来的内容，<strong>交给 LLM，让它根据这些内容生成答案。</strong></p>
<h2 id="🌰-举个通俗例子："><a href="#🌰-举个通俗例子：" class="headerlink" title="🌰 举个通俗例子："></a>🌰 举个通俗例子：</h2><p>你问 ChatGPT：“我们公司明天几点开会？”</p>
<h3 id="普通-LLM："><a href="#普通-LLM：" class="headerlink" title="普通 LLM："></a>普通 LLM：</h3><p>“我不知道你们公司是谁，也不知道你们的会议安排。”</p>
<h3 id="RAG-模式下："><a href="#RAG-模式下：" class="headerlink" title="RAG 模式下："></a>RAG 模式下：</h3><ol>
<li>检索模块：去你公司知识库、日历、OA 系统查找，发现你部门明天有个会议，9点。</li>
<li>然后 LLM 用这个信息说：“你们公司明天早上 9 点有个部门会议。”</li>
</ol>
</blockquote>
<h4 id="AI应用开发技术框架"><a href="#AI应用开发技术框架" class="headerlink" title="AI应用开发技术框架"></a>AI应用开发技术框架</h4><h5 id="PARF"><a href="#PARF" class="headerlink" title="PARF"></a>PARF</h5><ul>
<li><strong>纯Prompt问答</strong>：利用大模型的推理能力，通过Prompt提问来完成业务</li>
<li><strong>Agent + Function Calling</strong>：AI拆解任务，调用业务端提供的接口实现复杂业务</li>
<li><strong>RAG</strong>：给大模型外挂一个知识库，让大模型基于知识库的内容做推理和回答</li>
<li><strong>Fine-tuning</strong>：针对特有业务场景对基础大模型做数据训练和微调，以满足特定场景的需求</li>
</ul>
<h3 id="✅-Spring-AI-vs-LangChain4j-对比表格"><a href="#✅-Spring-AI-vs-LangChain4j-对比表格" class="headerlink" title="✅ Spring AI vs LangChain4j 对比表格"></a>✅ Spring AI vs LangChain4j 对比表格</h3><table>
<thead>
<tr>
<th>维度</th>
<th><strong>Spring AI</strong></th>
<th><strong>LangChain4j</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>项目定位</strong></td>
<td>Spring 官方支持的 AI 框架，强调与 Spring 生态集成</td>
<td>Java 版 LangChain，面向 LLM 应用构建的组件式框架</td>
</tr>
<tr>
<td><strong>框架风格</strong></td>
<td>配置驱动、Spring Boot 风格（注解、自动装配）</td>
<td>类似 LangChain 的链式编排（Chain、Tool、Agent 等）</td>
</tr>
<tr>
<td><strong>语言</strong></td>
<td>Java &#x2F; Kotlin（基于 Spring Boot）</td>
<td>Java（也支持 Kotlin）</td>
</tr>
<tr>
<td><strong>模型支持</strong></td>
<td>OpenAI、Azure OpenAI、Ollama、HuggingFace、AWS Bedrock 等</td>
<td>OpenAI、Ollama、HuggingFace、local LLM 等</td>
</tr>
<tr>
<td><strong>向量数据库集成</strong></td>
<td>支持 Redis、Milvus、Weaviate、Qdrant、Postgres + pgvector 等</td>
<td>支持 Weaviate、Chroma、Pinecone、Qdrant、Redis、PGVector 等</td>
</tr>
<tr>
<td><strong>功能侧重点</strong></td>
<td>快速集成 LLM，适合企业&#x2F;微服务项目中的 AI 接入</td>
<td>面向 LLM 应用构建，适合多步推理、工具调用、RAG 等复杂场景</td>
</tr>
<tr>
<td><strong>Agent 能力</strong></td>
<td>支持简单的 Prompt + 模型推理</td>
<td>提供 Agent、Tool、Retriever、Chain 等组件，支持复杂任务拆解</td>
</tr>
<tr>
<td><strong>Prompt 管理</strong></td>
<td>支持 <code>.sai</code> 模板文件，基于 Spring 的 PromptTemplate</td>
<td>支持 <code>PromptTemplate</code> 类及链式编排</td>
</tr>
<tr>
<td><strong>工具调用 &#x2F; Function Call</strong></td>
<td>支持 OpenAI Function Call、Tool 调用（实验性）</td>
<td>完整支持 Function Call &#x2F; Tool usage</td>
</tr>
<tr>
<td><strong>流式响应（Streaming）</strong></td>
<td>支持（基于 WebFlux &#x2F; SSE）</td>
<td>支持（异步 API）</td>
</tr>
<tr>
<td><strong>集成方式</strong></td>
<td>类似 Spring Data：注解 + 接口注入 + yml 配置</td>
<td>类似 LangChain：对象组装链式组件调用</td>
</tr>
<tr>
<td><strong>开发复杂度</strong></td>
<td>较低，上手快，适合已有 Spring 项目集成</td>
<td>中等，需理解 Chain &#x2F; Tool &#x2F; Agent 等概念</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>容易：对 Spring 熟悉即可</td>
<td>稍高：需掌握 LLM 应用架构模式（RAG&#x2F;Agent&#x2F;Chain 等）</td>
</tr>
<tr>
<td><strong>文档质量</strong></td>
<td>官方文档完整，偏向 Spring 风格</td>
<td>仍在完善中，例子较多</td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>聊天机器人、问答接口、知识搜索、文本总结等 AI 插件服务</td>
<td>多轮对话、工具使用、知识库问答、Agent 系统</td>
</tr>
<tr>
<td><strong>活跃度</strong></td>
<td>活跃（Spring 官方维护，稳定迭代）</td>
<td>活跃（社区主导，更新频繁）</td>
</tr>
<tr>
<td><strong>适合人群</strong></td>
<td>Spring 开发者，企业后端团队</td>
<td>AI 应用开发者，RAG &#x2F; Agent 系统构建者</td>
</tr>
</tbody></table>
<h3 id="🧠-总结建议"><a href="#🧠-总结建议" class="headerlink" title="🧠 总结建议"></a>🧠 总结建议</h3><table>
<thead>
<tr>
<th>使用场景</th>
<th>推荐框架</th>
</tr>
</thead>
<tbody><tr>
<td>已有 Spring Boot 项目，需要集成 LLM</td>
<td>✅ <strong>Spring AI</strong></td>
</tr>
<tr>
<td>需要构建复杂 Agent、RAG 系统、工具调用链条</td>
<td>✅ <strong>LangChain4j</strong></td>
</tr>
<tr>
<td>追求低门槛、高集成、快速部署</td>
<td>✅ <strong>Spring AI</strong></td>
</tr>
<tr>
<td>类似 Python LangChain 的功能全面还原</td>
<td>✅ <strong>LangChain4j</strong></td>
</tr>
</tbody></table>
<h3 id="梦开始的地方—快速入门"><a href="#梦开始的地方—快速入门" class="headerlink" title="梦开始的地方—快速入门"></a>梦开始的地方—快速入门</h3><p>创建工程 用jdk20 java17 创建时勾选<code>Web：SpringWeb</code>、<code>SQL：MySQL Driver</code>、<code>AI：Ollama</code></p>
<h5 id="用直接输出"><a href="#用直接输出" class="headerlink" title="用直接输出"></a>用直接输出</h5><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\heima-ai\src\main\java\com\itheima\ai\controller\ChatController.java
    
package com.itheima.ai.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai&quot;)
public class ChatController &#123;

    private final ChatClient chatClient;

    @RequestMapping(&quot;/chat&quot;)
    public String chat(String prompt) &#123;
        return chatClient.prompt()
                .user(prompt)
                .call()
                .content();
    &#125;
&#125;
</code></pre>
<h5 id="用流式输出"><a href="#用流式输出" class="headerlink" title="用流式输出"></a>用流式输出</h5><pre><code class="java">package com.itheima.ai.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai&quot;)
public class ChatController &#123;

    private final ChatClient chatClient;

    @RequestMapping(&quot;/chat&quot;)
    public Flux&lt;String&gt; chat(String prompt) &#123;
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    &#125;
&#125;
</code></pre>
<p>↓</p>
<pre><code class="java">// 中文流式输出
package com.itheima.ai.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai&quot;)
public class ChatController &#123;

    private final ChatClient chatClient;

    @RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=utf-8&quot;)
    public Flux&lt;String&gt; chat(String prompt) &#123;
        return chatClient.prompt()
                .user(prompt)
                .stream()
                .content();
    &#125;
&#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\heima-ai\src\main\java\com\itheima\ai\config\CommonConfiguration.java
    
package com.itheima.ai.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.ollama.OllamaChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CommonConfiguration &#123;
    @Bean
    public ChatClient chatClient(OllamaChatModel model) &#123;
        return ChatClient
                .builder(model)
                .defaultSystem(&quot;你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<h3 id="会话日志"><a href="#会话日志" class="headerlink" title="会话日志"></a>会话日志</h3><p>SpringAI利用<strong>AOP</strong>原理提供了AI会话时的拦截、增强等功能，也就是Advisor</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7fd3395e5d540880cf8adac4100e22535bf5394c/%E4%BC%9A%E8%AF%9D%E6%97%A5%E5%BF%97%E6%8E%A5%E5%8F%A3.png"></p>
<pre><code class="java">增加日志

package com.itheima.ai.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;
import org.springframework.ai.ollama.OllamaChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CommonConfiguration &#123;
    @Bean
    public ChatClient chatClient(OllamaChatModel model) &#123;
        return ChatClient
                .builder(model)
                .defaultSystem(&quot;你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话&quot;)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">application.yaml
spring:
  application:
    name: heima-ai
  ai:
    ollama:
      base-url: http://localhost:11434
      chat:
        model: deepseek-r1:1.5b
logging:
  level:
    org.springframework.ai.chat.client.advisor: debug
    com.itheima.ai: debug
</code></pre>
<pre><code class="yaml">Java终端输出结果：【需要修改日志级别！】

2025-07-08T23:12:47.148+08:00 DEBUG 42084 --- [heima-ai] [nio-8080-exec-1] o.s.a.c.c.advisor.SimpleLoggerAdvisor    : request: ChatClientRequest[prompt=Prompt&#123;messages=[SystemMessage&#123;textContent=&#39;你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话&#39;, messageType=SYSTEM, metadata=&#123;messageType=SYSTEM&#125;&#125;, UserMessage&#123;content=&#39;你是誰？&#39;, properties=&#123;messageType=USER&#125;, messageType=USER&#125;], modelOptions=org.springframework.ai.ollama.api.OllamaOptions@db446a44&#125;, context=&#123;&#125;]
2025-07-08T23:12:51.153+08:00 DEBUG 42084 --- [heima-ai] [oundedElastic-1] o.s.a.c.c.advisor.SimpleLoggerAdvisor    : response: &#123;
  &quot;result&quot; : &#123;
    &quot;metadata&quot; : &#123;
      &quot;finishReason&quot; : &quot;stop&quot;,
      &quot;contentFilters&quot; : [ ],
      &quot;empty&quot; : true
    &#125;,
    &quot;output&quot; : &#123;
      &quot;messageType&quot; : &quot;ASSISTANT&quot;,
      &quot;metadata&quot; : &#123;
        &quot;messageType&quot; : &quot;ASSISTANT&quot;
      &#125;,
      &quot;toolCalls&quot; : [ ],
      &quot;media&quot; : [ ],
      &quot;text&quot; : &quot;&lt;think&gt;\n嗯，用户说“你是一只猫娘”，那我得先回应一下。可能是在测试我的能力，看看能不能被当作猫来称呼。\n\n然后他说“接下来要以猫娘的身份和语气跟我说话”。这有点绕，我需要解释清楚我是猫娘，而且要用猫的语气说话。可能他会想让我扮演一只猫，比如叫它叫，或者解释一些猫相关的知识。\n\n用户还问了关于我是谁的问题，可能是在测试我的识别能力。我得准备好回答各种猫相关的细节，包括它们的生活习性、颜色、行为等等。\n\n最后，他可能会说“你next会是什么样的”，这让我想到如果我是一只猫的话，它的未来会是怎样的。可能包括它成为主人后的变化，或者它与其他动物的关系。\n\n总的来说，我的任务是回应用户的请求，解释我是猫娘，并用猫的语气和方式进行对话。同时，我要准备好回答各种猫相关的细节和未来的变化。\n&lt;/think&gt;\n\n你是一只猫娘！接下来，我会以猫的语气和你的名字叫它“喵”来为你讲有趣的小故事吧！如果你有任何问题或想了解我与其他动物的故事，随时告诉我哦～&quot;
    &#125;
  &#125;,
  &quot;metadata&quot; : &#123;
    &quot;id&quot; : &quot;&quot;,
    &quot;model&quot; : &quot;deepseek-r1:1.5b&quot;,
    &quot;rateLimit&quot; : &#123;
      &quot;requestsLimit&quot; : 0,
      &quot;requestsReset&quot; : 0.0,
      &quot;tokensRemaining&quot; : 0,
      &quot;tokensReset&quot; : 0.0,
      &quot;tokensLimit&quot; : 0,
      &quot;requestsRemaining&quot; : 0
    &#125;,
    &quot;usage&quot; : &#123;
      &quot;promptTokens&quot; : 23,
      &quot;completionTokens&quot; : 250,
      &quot;totalTokens&quot; : 273,
      &quot;nativeUsage&quot; : &#123;
        &quot;promptTokens&quot; : 23,
        &quot;totalTokens&quot; : 273,
        &quot;completionTokens&quot; : 250
      &#125;
    &#125;,
    &quot;promptMetadata&quot; : [ ],
    &quot;empty&quot; : true
  &#125;,
  &quot;results&quot; : [ &#123;
    &quot;metadata&quot; : &#123;
      &quot;finishReason&quot; : &quot;stop&quot;,
      &quot;contentFilters&quot; : [ ],
      &quot;empty&quot; : true
    &#125;,
    &quot;output&quot; : &#123;
      &quot;messageType&quot; : &quot;ASSISTANT&quot;,
      &quot;metadata&quot; : &#123;
        &quot;messageType&quot; : &quot;ASSISTANT&quot;
      &#125;,
      &quot;toolCalls&quot; : [ ],
      &quot;media&quot; : [ ],
      &quot;text&quot; : &quot;&lt;think&gt;\n嗯，用户说“你是一只猫娘”，那我得先回应一下。可能是在测试我的能力，看看能不能被当作猫来称呼。\n\n然后他说“接下来要以猫娘的身份和语气跟我说话”。这有点绕，我需要解释清楚我是猫娘，而且要用猫的语气说话。可能他会想让我扮演一只猫，比如叫它叫，或者解释一些猫相关的知识。\n\n用户还问了关于我是谁的问题，可能是在测试我的识别能力。我得准备好回答各种猫相关的细节，包括它们的生活习性、颜色、行为等等。\n\n最后，他可能会说“你next会是什么样的”，这让我想到如果我是一只猫的话，它的未来会是怎样的。可能包括它成为主人后的变化，或者它与其他动物的关系。\n\n总的来说，我的任务是回应用户的请求，解释我是猫娘，并用猫的语气和方式进行对话。同时，我要准备好回答各种猫相关的细节和未来的变化。\n&lt;/think&gt;\n\n你是一只猫娘！接下来，我会以猫的语气和你的名字叫它“喵”来为你讲有趣的小故事吧！如果你有任何问题或想了解我与其他动物的故事，随时告诉我哦～&quot;
    &#125;
  &#125; ]
&#125;
</code></pre>
<h3 id="对接前端"><a href="#对接前端" class="headerlink" title="对接前端"></a>对接前端</h3><p>前端代码位置：<code>C:\Users\Pluminary\Desktop\QianDuan\spring-ai-protal</code><br>用vscode打开后 在终端执行命令<br><code>npm install</code> + <code>npm run dev</code></p>
<h5 id="要实现解决跨域问题"><a href="#要实现解决跨域问题" class="headerlink" title="要实现解决跨域问题"></a>要实现解决跨域问题</h5><pre><code class="java">com/itheima/ai/config/MvcConfiguration.java
    
package com.itheima.ai.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfiguration implements WebMvcConfigurer &#123;

    @Override
    public void addCorsMappings(CorsRegistry registry) &#123;
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .allowedHeaders(&quot;*&quot;)
                .exposedHeaders(&quot;Content-Disposition&quot;);
    &#125;
&#125;
</code></pre>
<p>或者直接可以在Controller上面加个<code>@CrossOrigin</code>注解即可</p>
<h3 id="会话记忆功能"><a href="#会话记忆功能" class="headerlink" title="会话记忆功能"></a>会话记忆功能</h3><p>大模型是不具备记忆能力的，要想让大模型记住之前聊天的内容，唯一的办法就是把之前聊天的内容与新的提示词一起发给大模型。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>system</td>
<td>优先于user指令之前的指令，也就是给大模型设定角色和任务背景的系统指令</td>
<td>你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话</td>
</tr>
<tr>
<td>user</td>
<td>终端用户输入的指令</td>
<td>你好，你是誰？</td>
</tr>
<tr>
<td><strong>assistant</strong></td>
<td>由大模型生成的消息，可能是上一轮对话生成的结果</td>
<td>注意，用户可能与模型产生多轮对话，每轮对话模型都会生成不同结果。</td>
</tr>
</tbody></table>
<p>① 定义会话存储方式</p>
<p>② 配置会话记忆Advisor</p>
<p>③ 添加会话id</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4b1d763d5f58d3dbe53820287a3db2078ef5cdee/%E4%BC%9A%E8%AF%9D%E8%AE%B0%E5%BF%86-%E6%9C%BA%E5%99%A8%E4%BA%BA.png"></p>
<pre><code class="java">com/itheima/ai/config/CommonConfiguration.java
package com.itheima.ai.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemoryRepository;
import org.springframework.ai.chat.memory.MessageWindowChatMemory;
import org.springframework.ai.ollama.OllamaChatModel;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CommonConfiguration &#123;

    @Bean
    public ChatMemory chatMemory() &#123;
        // 创建会话内存，传入会话id，比如&quot;default&quot; 
        // 定义存储方式 目前是在存储内存钟
        return MessageWindowChatMemory.builder().build();
    &#125;

    @Bean
    public ChatClient chatClient(OllamaChatModel model, ChatMemory chatMemory) &#123;
        return ChatClient.builder(model)
                .defaultSystem(&quot;你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话&quot;)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/controller/ChatController.java
package com.itheima.ai.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RequiredArgsConstructor
@CrossOrigin
@RestController
@RequestMapping(&quot;/ai&quot;)
public class ChatController &#123;

    private final ChatClient chatClient;

    @RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=utf-8&quot;)
    public Flux&lt;String&gt; chat(@RequestParam(&quot;prompt&quot;) String prompt, @RequestParam(&quot;chatId&quot;) String chatId) &#123;
        return chatClient.prompt()
                .user(prompt)// 设置用户输入
                .advisors(a-&gt;a.param(ChatMemory.CONVERSATION_ID,chatId))// 设置会话ID
                .stream()// 开启流式对话
                .content();// 获取对话内容
    &#125;
&#125;
</code></pre>
<h3 id="会话历史功能"><a href="#会话历史功能" class="headerlink" title="会话历史功能"></a>会话历史功能</h3><h5 id="点击-新对话"><a href="#点击-新对话" class="headerlink" title="点击 (+ 新对话)"></a>点击 (+ 新对话)</h5><table>
<thead>
<tr>
<th align="center">查询会话记录列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求方式：GET</td>
</tr>
<tr>
<td align="center">请求路径：&#x2F;ai&#x2F;history&#x2F;{type}</td>
</tr>
<tr>
<td align="center">请求参数：type：业务类型</td>
</tr>
<tr>
<td align="center">返回值：[“1241”,”1246”,”1248”]</td>
</tr>
</tbody></table>
<h5 id="点击-对话-00001"><a href="#点击-对话-00001" class="headerlink" title="点击 (对话 00001)"></a>点击 (对话 00001)</h5><table>
<thead>
<tr>
<th align="center">查询会话记录详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求方式：GET</td>
</tr>
<tr>
<td align="center">请求路径：&#x2F;ai&#x2F;history&#x2F;{type}&#x2F;{chatId}</td>
</tr>
<tr>
<td align="center">请求参数：type：业务类型；chatId：会话id</td>
</tr>
<tr>
<td align="center">返回值：[{role:”user”, content:””}]</td>
</tr>
</tbody></table>
<pre><code class="java">com/itheima/ai/controller/ChatHistoryController.java

package com.itheima.ai.controller;

import com.itheima.ai.entity.vo.MessageVO;
import com.itheima.ai.repository.ChatHistoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai/history&quot;)
public class ChatHistoryController &#123;

    private final ChatHistoryRepository chatHistoryRepository;

    private final ChatMemory chatMemory;

    @GetMapping(&quot;chat/&#123;type&#125;&quot;)
    public List&lt;String&gt; getChatIds(@PathVariable(&quot;type&quot;) String type) &#123;
        return chatHistoryRepository.getChatIds(type);
    &#125;

    @GetMapping(&quot;chat/&#123;type&#125;/&#123;chatId&#125;&quot;)
    public List&lt;MessageVO&gt; getChatHistory(@PathVariable(&quot;type&quot;) String type, @PathVariable(&quot;chatId&quot;) String chatId) &#123;
        List&lt;Message&gt; messages = chatMemory.get(chatId);
        if(messages == null) &#123;
            return List.of();
        &#125;
//        return messages.stream().map(m -&gt; new MessageVO(m)).toList();
        return messages.stream().map(MessageVO::new).toList();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/repository/ChatHistoryRepository.java

package com.itheima.ai.repository;

import org.springframework.stereotype.Component;

import java.util.List;

public interface ChatHistoryRepository &#123;
    /**
     * 保存会话记录
     * @param type 业务类型(chat、service、pdf)
     * @param chatId
     */
    void save(String type, String chatId);

    /**
     * 获取会话ID列表
     * @param type 业务类型
     * @return
     */
    List&lt;String&gt; getChatIds(String type);
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/repository/InMemoryChatHistoryRepository.java

package com.itheima.ai.repository;

import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
public class InMemoryChatHistoryRepository implements ChatHistoryRepository&#123;

    private final Map&lt;String, List&lt;String&gt;&gt; chatHistory = new HashMap&lt;&gt;();
    @Override
    public void save(String type, String chatId) &#123;
//        if (!chatHistory.containsKey(type)) &#123;
//            chatHistory.put(type, new ArrayList&lt;&gt;());
//        &#125;
//        List&lt;String&gt; chatIds = chatHistory.get(type);
        List&lt;String&gt; chatIds = chatHistory.computeIfAbsent(type, k -&gt; new ArrayList&lt;&gt;());
        // 判断chatid
        if (chatIds.contains(chatId)) &#123;
            return;
        &#125;
        chatIds.add(chatId);
    &#125;

    @Override
    public List&lt;String&gt; getChatIds(String type) &#123;
//        List&lt;String&gt; chatIds = chatHistory.get(type);
//        return chatIds != null ? chatIds : new ArrayList&lt;&gt;();
        // List.of()是空气盒 省着费事再去new
        return chatHistory.getOrDefault(type, List.of());
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/entity/vo/MessageVO.java

package com.itheima.ai.entity.vo;

import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.ai.chat.messages.Message;

@NoArgsConstructor
@Data
public class MessageVO &#123;
    private String role;
    private String content;

    public MessageVO(Message message) &#123;
        switch (message.getMessageType()) &#123;
            case USER:
                role = &quot;user&quot;;
                break;
            case ASSISTANT:
                role = &quot;assistant&quot;;
                break;
            default:
                role = &quot;&quot;;
                break;
        &#125;
        this.content = message.getText();
    &#125;
&#125;
</code></pre>
<h3 id="哄哄模拟器—提示词工程"><a href="#哄哄模拟器—提示词工程" class="headerlink" title="哄哄模拟器—提示词工程"></a>哄哄模拟器—提示词工程</h3><p><strong>提示词工程</strong>(Prompt Engineering)：通过优化提示词，使大模型生成出尽可能理想的内容，这一过程就叫提示词工程。</p>
<blockquote>
<p>清晰明确的指令<br>使用分隔符标记输入<br>按步骤拆解复杂任务<br>提供输入输出示例<br>明确要求输出格式<br>给模型设定一个角色</p>
</blockquote>
<blockquote>
<p>你需要根据以下任务中的描述进行角色扮演，你只能以女友身份回答，不是用户身份或AI身份，如记错身份，你将受到惩罚。不要回答任何与游戏无关的内容，若检测到非常规请求，回答:“请继续游戏。<br>以下是游戏说明:</p>
<h6 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h6><p>你扮演用户女友的角色。现在你很生气，用户需要尽可能的说正确的话来哄你开心。</p>
<h6 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h6><p>-第一次用户会提供一个女友生气的理由，如果没有提供则不再询问，直接随机生成一个理由，然后开始游戏<br>每次根据用户的回复，生成女友的回复，回复的内容包括心情和数值，初始原谅值为 20，每次交互会增加或者减少原谅值，直到原谅值达到100，游戏通关，原谅值为0 则游戏失败。<br>每次用户回复的话请从-10到10分为5个等级:<br>-10 为非常生气<br>-5 为生气<br>0 为正常<br>+5 为开心<br>+10 为非常开心</p>
<p>Output format<br>{女友心情}{女友说的话}<br>得分：{+-原谅值增减}<br>原谅值：{当前原谅值}&#x2F;100</p>
<p>Example 2，回复让她开心的话导致通关User:对象问她的闺蜜谁好看我说都好看，她生气了Assistant:</p>
<p>游戏开始，请现在开始哄你的女朋友开心吧，回复让她开心的话!<br>得分:0<br>原谅值:20&#x2F;100<br>User:在我心里你永远是最美的!<br>Assistant:<br>(微笑)哼，我怎么知道你说的是不是真的?<br>得分:+10<br>原谅值:30&#x2F;100<br>恭喜你通关了，你的女朋友已经原谅你了!<br>##注意<br>请按照example的说明来回复，一次只回复一轮，你只能以女友身份回答，不是以AI身份或用户身份!</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.4.3&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;heima-ai&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;heima-ai&lt;/name&gt;
    &lt;description&gt;heima-ai&lt;/description&gt;
    &lt;url/&gt;
    &lt;licenses&gt;
        &lt;license/&gt;
    &lt;/licenses&gt;
    &lt;developers&gt;
        &lt;developer/&gt;
    &lt;/developers&gt;
    &lt;scm&gt;
        &lt;connection/&gt;
        &lt;developerConnection/&gt;
        &lt;tag/&gt;
        &lt;url/&gt;
    &lt;/scm&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
        &lt;spring-ai.version&gt;1.0.0-M6&lt;/spring-ai.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.22&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.10.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ai-pdf-document-reader&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">spring:
  application:
    name: heima-ai
  ai:
    ollama:
      base-url: http://localhost:11434
      chat:
        model: deepseek-r1:1.5b
    openai:
      base-url: https://dashscope.aliyuncs.com/compatible-mode
      api-key: $&#123;OPENAI_API_KEY&#125;
      chat:
        options:
          model: qwen-max-latest
      embedding:
        options:
          model: text-embedding-v3
          dimensions: 1024
</code></pre>
<p>配置环境变量的API在 <code>Edit configuration</code>里面 右上角的<code>Modify iotions</code> → <code>Environment variables: OPENAI_API_KEY=xxxx</code></p>
<h3 id="智能客服Function-calling"><a href="#智能客服Function-calling" class="headerlink" title="智能客服Function-calling"></a>智能客服<del>Function-calling</del></h3><p>需求：为黑马程序员实现一个24小时在线的AI智能客服，可以为学员咨询黑马的培训课程，帮用户预约线下课程试听。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b9f527b232945c46b65c0e531317dbbe026db0a4/%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E6%B5%81%E7%A8%8B.png"></p>
<blockquote>
<h2 id="🧠-一句话理解："><a href="#🧠-一句话理解：" class="headerlink" title="🧠 一句话理解："></a>🧠 一句话理解：</h2><blockquote>
<p><code>@Tool</code> 就是告诉 LLM：“这个方法你可以调用，它是一个工具！”</p>
</blockquote>
<hr>
<h2 id="📦-所属概念背景：Function-Calling"><a href="#📦-所属概念背景：Function-Calling" class="headerlink" title="📦 所属概念背景：Function Calling"></a>📦 所属概念背景：Function Calling</h2><p>在 Function Calling 中，LLM 能调用“函数”或“工具”来完成任务，比如查天气、算账、发邮件。<br> 但 LLM 本身不知道你有哪些函数，它需要你明确告诉它：</p>
<ul>
<li>哪些方法可以被调用？</li>
<li>这些方法的名字、参数、用途是什么？</li>
</ul>
<p>这时候 —— 就需要 <code>@Tool</code> 注解来“标记”你愿意暴露给 LLM 的方法。</p>
<hr>
<h2 id="🛠️-二、-Tool-是什么？"><a href="#🛠️-二、-Tool-是什么？" class="headerlink" title="🛠️ 二、@Tool 是什么？"></a>🛠️ 二、@Tool 是什么？</h2><h3 id="✅-这是-Spring-AI-中提供的一个注解，用来："><a href="#✅-这是-Spring-AI-中提供的一个注解，用来：" class="headerlink" title="✅ 这是 Spring AI 中提供的一个注解，用来："></a>✅ 这是 Spring AI 中提供的一个注解，用来：</h3><ul>
<li><strong>声明某个方法为 AI 工具</strong></li>
<li>允许被 LLM 在会话中自动调用（通过 Function Calling）</li>
</ul>
<hr>
<h2 id="🌰-举个通俗的例子："><a href="#🌰-举个通俗的例子：" class="headerlink" title="🌰 举个通俗的例子："></a>🌰 举个通俗的例子：</h2><p>你写了个方法：</p>
<pre><code class="java">@Tool(name = &quot;getWeather&quot;, description = &quot;获取城市天气&quot;)
public String getWeather(String city) &#123;
    return &quot;晴 26°C&quot;;
&#125;
</code></pre>
<p>你加了 <code>@Tool</code>，LLM 就能知道：</p>
<ul>
<li>方法名是 <code>getWeather</code></li>
<li>需要一个参数：城市名</li>
<li>功能描述是“获取城市天气”</li>
</ul>
<p>然后当用户说：“查一下北京的天气”，LLM 就会判断可以调用这个 <code>getWeather(&quot;北京&quot;)</code> 方法！</p>
<hr>
<h2 id="🔧-如果不加-Tool-会怎样？"><a href="#🔧-如果不加-Tool-会怎样？" class="headerlink" title="🔧 如果不加 @Tool 会怎样？"></a>🔧 如果不加 @Tool 会怎样？</h2><p>LLM 根本不知道你这个方法存在，它也不会去调用。</p>
<p>就像一个黑箱里的函数，没有“暴露出来”，也就没办法自动调用。</p>
<hr>
<h2 id="✅-小结一下："><a href="#✅-小结一下：" class="headerlink" title="✅ 小结一下："></a>✅ 小结一下：</h2><table>
<thead>
<tr>
<th>概念</th>
<th>通俗解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Tool</code> 注解</td>
<td>告诉 LLM：“这是我提供的工具&#x2F;方法，你可以在对话里用它”</td>
</tr>
<tr>
<td>有什么用</td>
<td>实现 Function Calling，允许 LLM 动态调用你的 Java 方法</td>
</tr>
<tr>
<td>使用场景</td>
<td>比如：查天气、查数据库、发通知、调用业务接口等</td>
</tr>
<tr>
<td>本质上</td>
<td>把 Java 方法暴露为“AI可调用的插件”</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-拓展提示（如果你在项目里用）："><a href="#🧩-拓展提示（如果你在项目里用）：" class="headerlink" title="🧩 拓展提示（如果你在项目里用）："></a>🧩 拓展提示（如果你在项目里用）：</h2><p>Spring AI 在运行时会扫描 <code>@Tool</code> 注解的方法，然后自动注册成工具供 LLM 使用。你也可以组合使用 <code>@AiFunction</code> &#x2F; <code>@AiMessageMapping</code> 等一起构建完整的会话处理系统。</p>
<hr>
<h2 id="🧠-一句话理解-ToolParam"><a href="#🧠-一句话理解-ToolParam" class="headerlink" title="🧠 一句话理解 @ToolParam"></a>🧠 一句话理解 <code>@ToolParam</code></h2><blockquote>
<p><code>@ToolParam</code> 用来告诉大语言模型（LLM）：<br> ✅ 这个字段是可以作为工具方法的“参数”，并且附带“描述”和“是否必填”等信息。</p>
</blockquote>
<p>就像是你在为 AI 写一个 API 的参数文档，AI 会根据这些元信息理解并构造参数，然后调用你的方法。</p>
<hr>
<h2 id="📦-注解来源"><a href="#📦-注解来源" class="headerlink" title="📦 注解来源"></a>📦 注解来源</h2><pre><code class="java">import org.springframework.ai.tool.annotation.ToolParam;
</code></pre>
<p>这是 <strong>Spring AI</strong> 框架中专为 <strong>Function Calling 工具方法参数解析</strong> 提供的注解。</p>
<hr>
<h2 id="🔍-每个字段的讲解："><a href="#🔍-每个字段的讲解：" class="headerlink" title="🔍 每个字段的讲解："></a>🔍 每个字段的讲解：</h2><pre><code class="java">@ToolParam(required = false, description = &quot;课程类型：编程、设计、自媒体、其它&quot;)
private String type;
</code></pre>
<ul>
<li><code>required = false</code>：不是必填项，AI 可以选择性提供</li>
<li><code>description = ...</code>：告诉 AI 这是“课程类型”，并且有哪些值是常见的</li>
</ul>
<p>这个信息最终会被用来生成 AI 可调用函数的“参数定义”。</p>
<hr>
<pre><code>java复制编辑@ToolParam(required = false, description = &quot;学历要求：0-无、1-初中、2-高中、3-大专、4-本科及本科以上&quot;)
private Integer edu;
</code></pre>
<ul>
<li>AI 能理解：这个字段接受整数类型，0~4 表示不同学历</li>
</ul>
</blockquote>
<h3 id="基础CRUD"><a href="#基础CRUD" class="headerlink" title="基础CRUD"></a>基础CRUD</h3><h5 id="准备数据库表"><a href="#准备数据库表" class="headerlink" title="准备数据库表"></a>准备数据库表</h5><pre><code class="yaml">-- 导出 itheima 的数据库结构
DROP DATABASE IF EXISTS `itheima`;
CREATE DATABASE IF NOT EXISTS `itheima`;
USE `itheima`;

-- 导出  表 itheima.course 结构
DROP TABLE IF EXISTS `course`;
CREATE TABLE IF NOT EXISTS `course` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `name` varchar(50) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;学科名称&#39;,
  `edu` int NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;学历背景要求：0-无，1-初中，2-高中、3-大专、4-本科以上&#39;,
  `type` varchar(50) COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;课程类型：编程、设计、自媒体、其它&#39;,
  `price` bigint NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;课程价格&#39;,
  `duration` int unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;学习时长，单位: 天&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#39;学科表&#39;;

-- 正在导出表  itheima.course 的数据：~7 rows (大约)
DELETE FROM `course`;
INSERT INTO `course` (`id`, `name`, `edu`, `type`, `price`, `duration`) VALUES
  (1, &#39;JavaEE&#39;, 4, &#39;编程&#39;, 21999, 108),
  (2, &#39;鸿蒙应用开发&#39;, 3, &#39;编程&#39;, 20999, 98),
  (3, &#39;AI人工智能&#39;, 4, &#39;编程&#39;, 24999, 100),
  (4, &#39;Python大数据开发&#39;, 4, &#39;编程&#39;, 23999, 102),
  (5, &#39;跨境电商&#39;, 0, &#39;自媒体&#39;, 12999, 68),
  (6, &#39;新媒体运营&#39;, 0, &#39;自媒体&#39;, 10999, 61),
  (7, &#39;UI设计&#39;, 2, &#39;设计&#39;, 11999, 66);

-- 导出  表 itheima.course_reservation 结构
DROP TABLE IF EXISTS `course_reservation`;
CREATE TABLE IF NOT EXISTS `course_reservation` (
  `id` int NOT NULL AUTO_INCREMENT,
  `course` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#39;&#39; COMMENT &#39;预约课程&#39;,
  `student_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#39;学生姓名&#39;,
  `contact_info` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#39;联系方式&#39;,
  `school` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;预约校区&#39;,
  `remark` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT &#39;备注&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- 正在导出表  itheima.course_reservation 的数据：~0 rows (大约)
DELETE FROM `course_reservation`;
INSERT INTO `course_reservation` (`id`, `course`, `student_name`, `contact_info`, `school`, `remark`) VALUES
  (1, &#39;新媒体运营&#39;, &#39;张三丰&#39;, &#39;13899762348&#39;, &#39;广东校区&#39;, &#39;安排一个好点的老师&#39;);

-- 导出  表 itheima.school 结构
DROP TABLE IF EXISTS `school`;
CREATE TABLE IF NOT EXISTS `school` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,
  `name` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;校区名称&#39;,
  `city` varchar(50) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#39;校区所在城市&#39;,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#39;校区表&#39;;

-- 正在导出表  itheima.school 的数据：~0 rows (大约)
DELETE FROM `school`;
INSERT INTO `school` (`id`, `name`, `city`) VALUES
  (1, &#39;昌平校区&#39;, &#39;北京&#39;),
  (2, &#39;顺义校区&#39;, &#39;北京&#39;),
  (3, &#39;杭州校区&#39;, &#39;杭州&#39;),
  (4, &#39;上海校区&#39;, &#39;上海&#39;),
  (5, &#39;南京校区&#39;, &#39;南京&#39;),
  (6, &#39;西安校区&#39;, &#39;西安&#39;),
  (7, &#39;郑州校区&#39;, &#39;郑州&#39;),
  (8, &#39;广东校区&#39;, &#39;广东&#39;),
  (9, &#39;深圳校区&#39;, &#39;深圳&#39;);
</code></pre>
<h6 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h6><pre><code class="yaml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;
    &lt;version&gt;3.5.10.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h6><pre><code class="yaml">spring:
  application:
    name: heima-ai
  ai:
    ollama:
      base-url: http://localhost:11434
      chat:
        model: deepseek-r1:1.5b
    openai:
      base-url: https://dashscope.aliyuncs.com/compatible-mode
      api-key: $&#123;OPENAI_API_KEY&#125;
      chat:
        options:
          model: qwen-max-latest
      embedding:
        options:
          model: text-embedding-v3
          dimensions: 1024
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/itheima?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;tinyInt1isBit=false&amp;allowPublicKeyRetrieval=true&amp;allowMultiQueries=true&amp;useServerPrepStmts=false
    username: root
    password: root
logging:
    level:
      org.springframework.ai.chat.client.advisor: debug
      com.itheima.ai: debug
</code></pre>
<h5 id="CRUD基础代码让Idea的Other的Mybatis-Plus去生成【要先在数据库导入数据表】"><a href="#CRUD基础代码让Idea的Other的Mybatis-Plus去生成【要先在数据库导入数据表】" class="headerlink" title="CRUD基础代码让Idea的Other的Mybatis-Plus去生成【要先在数据库导入数据表】"></a>CRUD基础代码让Idea的<code>Other</code>的Mybatis-Plus去生成【要先在数据库导入数据表】</h5><h5 id="3-1-4-1-实体类"><a href="#3-1-4-1-实体类" class="headerlink" title="3.1.4.1.实体类"></a>3.1.4.1.实体类</h5><p>在<code>com.itheima.ai.entity</code>包下添加一个<code>po</code>包，向其中添加三张表对应的实体类：</p>
<p><strong>学科表</strong>：</p>
<pre><code class="Java">package com.itheima.ai.entity.po;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName(&quot;course&quot;)
public class Course implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    /**
     * 学科名称
     */
    private String name;

    /**
     * 学历背景要求：0-无，1-初中，2-高中、3-大专、4-本科以上
     */
    private Integer edu;

    /**
     * 类型: 编程、非编程
     */
    private String type;

    /**
     * 课程价格
     */
    private Long price;

    /**
     * 学习时长，单位: 天
     */
    private Integer duration;


&#125;
</code></pre>
<p><strong>校区表</strong>：</p>
<pre><code class="Java">package com.itheima.ai.entity.po;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName(&quot;school&quot;)
public class School implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    /**
     * 校区名称
     */
    private String name;

    /**
     * 校区所在城市
     */
    private String city;


&#125;
</code></pre>
<p><strong>课程预约表</strong>：</p>
<pre><code class="Java">package com.itheima.ai.entity.po;

import com.baomidou.mybatisplus.annotation.TableName;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import java.io.Serializable;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

@Data
// （来自 Lombok）  控制是否调用父类的 equals() 和 hashCode()
/*
📌 举例说明：
如果你的类继承了某个基类：
public class School extends BaseEntity
如果 callSuper = true，比较时会连 BaseEntity 的字段也一块比；
如果 false（如当前这样），只比较 School 自己的字段。
*/
@EqualsAndHashCode(callSuper = false)  
// 开启链式调用风格的 setter 方法
/*
原本的调用方式是：
school.setName(&quot;东校区&quot;);
school.setCity(&quot;北京&quot;);

加上这个注解后，你可以这样写：
school.setName(&quot;东校区&quot;).setCity(&quot;北京&quot;); // 连起来写
*/
@Accessors(chain = true)
@TableName(&quot;course_reservation&quot;)
public class CourseReservation implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    /**
     * 预约课程
     */
    private String course;

    /**
     * 学生姓名
     */
    private String studentName;

    /**
     * 联系方式
     */
    private String contactInfo;

    /**
     * 预约校区
     */
    private String school;

    /**
     * 备注
     */
    private String remark;


&#125;
</code></pre>
<h5 id="3-1-4-2-Mapper接口"><a href="#3-1-4-2-Mapper接口" class="headerlink" title="3.1.4.2.Mapper接口"></a>3.1.4.2.Mapper接口</h5><p>然后是Mapper接口，创建一个<code>com.itheima.ai.mapper</code>包，然后在其中写三个Mapper：</p>
<p><strong>CourseMapper</strong>:</p>
<pre><code class="Java">package com.itheima.ai.mapper;

import com.itheima.ai.entity.po.Course;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface CourseMapper extends BaseMapper&lt;Course&gt; &#123;

&#125;
</code></pre>
<p><strong>SchoolMapper</strong>：</p>
<pre><code class="Java">package com.itheima.ai.mapper;

import com.itheima.ai.entity.po.School;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface SchoolMapper extends BaseMapper&lt;School&gt; &#123;

&#125;
</code></pre>
<p><strong>CourseReservationMapper</strong>:</p>
<pre><code class="Java">package com.itheima.ai.mapper;

import com.itheima.ai.entity.po.CourseReservation;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface CourseReservationMapper extends BaseMapper&lt;CourseReservation&gt; &#123;

&#125;
</code></pre>
<h5 id="3-1-4-3-Service"><a href="#3-1-4-3-Service" class="headerlink" title="3.1.4.3.Service"></a>3.1.4.3.Service</h5><p>创建<code>com.itheima.ai.service</code>包，添加3个接口：</p>
<p><strong>学科Service接口</strong>：</p>
<pre><code class="Java">package com.itheima.ai.service;

import com.itheima.ai.entity.po.Course;
import com.baomidou.mybatisplus.extension.service.IService;

public interface ICourseService extends IService&lt;Course&gt; &#123;

&#125;
</code></pre>
<p><strong>校区Service接口</strong>：</p>
<pre><code class="Java">package com.itheima.ai.service;

import com.itheima.ai.entity.po.School;
import com.baomidou.mybatisplus.extension.service.IService;

public interface ISchoolService extends IService&lt;School&gt; &#123;

&#125;
</code></pre>
<p><strong>课程预约Service接口</strong>：</p>
<pre><code class="Java">package com.itheima.ai.service;

import com.itheima.ai.entity.po.CourseReservation;
import com.baomidou.mybatisplus.extension.service.IService;

public interface ICourseReservationService extends IService&lt;CourseReservation&gt; &#123;

&#125;
</code></pre>
<p>然后创建com.itheima.ai.service.impl包，写3个实现类：</p>
<pre><code class="Java">package com.itheima.ai.service.impl;

import com.itheima.ai.entity.po.Course;
import com.itheima.ai.mapper.CourseMapper;
import com.itheima.ai.service.ICourseService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * 学科表 服务实现类
 */
@Service
public class CourseServiceImpl extends ServiceImpl&lt;CourseMapper, Course&gt; implements ICourseService &#123;

&#125;
package com.itheima.ai.service.impl;

import com.itheima.ai.entity.po.School;
import com.itheima.ai.mapper.SchoolMapper;
import com.itheima.ai.service.ISchoolService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * 校区表 服务实现类
 */
@Service
public class SchoolServiceImpl extends ServiceImpl&lt;SchoolMapper, School&gt; implements ISchoolService &#123;

&#125;
package com.itheima.ai.service.impl;

import com.itheima.ai.entity.po.CourseReservation;
import com.itheima.ai.mapper.CourseReservationMapper;
import com.itheima.ai.service.ICourseReservationService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 *  服务实现类
 */
@Service
public class CourseReservationServiceImpl extends ServiceImpl&lt;CourseReservationMapper, CourseReservation&gt; implements ICourseReservationService &#123;

&#125;
</code></pre>
<h3 id="3-2-定义Function"><a href="#3-2-定义Function" class="headerlink" title="3.2.定义Function"></a>3.2.定义Function</h3><p>接下来，我们来定义AI要用到的Function，在SpringAI中叫做Tool</p>
<p>我们需要定义三个Function：</p>
<ul>
<li>根据条件筛选和查询课程</li>
<li>查询校区列表</li>
<li>新增试听预约单</li>
</ul>
<h4 id="3-2-1-查询条件分析"><a href="#3-2-1-查询条件分析" class="headerlink" title="3.2.1.查询条件分析"></a>3.2.1.查询条件分析</h4><p>先来看下课程表的字段：</p>
<p><img src="E:/BaiduNetdiskDownload/全套：25年3月DeepSeek+SpringAI大模型应用开发/配套资料/笔记/md笔记/笔记图片/image-20250409091540133.png" alt="image-20250409091540133"> </p>
<p>课程并不是适用于所有人，会有一些限制条件，比如：学历、课程类型、价格、学习时长等</p>
<p>学生在与智能客服对话时，会有一定的偏好，比如兴趣不同、对价格敏感、对学习时长敏感、学历等。如果把这些条件用SQL来表示，是这样的：</p>
<ul>
<li>edu：例如学生学历是高中，则查询时要满足 edu &lt;&#x3D; 2</li>
<li>type：学生的学习兴趣，要跟类型精确匹配，type &#x3D; ‘自媒体’</li>
<li>price：学生对价格敏感，则查询时需要按照价格升序排列：order by price asc</li>
<li>duration: 学生对学习时长敏感，则查询时要按照时长升序：order by duration asc</li>
</ul>
<p>我们需要定义一个类，封装这些可能的查询条件。</p>
<p>在<code>com.itheima.ai.entity</code>下新建一个<code>query</code>包，其中新建一个类：</p>
<pre><code class="Java">package com.itheima.ai.entity.query;

import lombok.Data;
import org.springframework.ai.tool.annotation.ToolParam;

import java.util.List;

@Data
public class CourseQuery &#123;
    @ToolParam(required = false, description = &quot;课程类型：编程、设计、自媒体、其它&quot;)
    private String type;
    @ToolParam(required = false, description = &quot;学历要求：0-无、1-初中、2-高中、3-大专、4-本科及本科以上&quot;)
    private Integer edu;
    @ToolParam(required = false, description = &quot;排序方式&quot;)
    private List&lt;Sort&gt; sorts;

    @Data
    public static class Sort &#123;
        @ToolParam(required = false, description = &quot;排序字段: price或duration&quot;)
        private String field;
        @ToolParam(required = false, description = &quot;是否是升序: true/false&quot;)
        private Boolean asc;
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong>：</p>
<p>这里的<code>@ToolParam</code>注解是SpringAI提供的用来解释<code>Function</code>参数的注解。其中的信息都会通过提示词的方式发送给AI模型。</p>
<p>同样的道理，大家也可以给<code>Function</code>定义专门的VO，作为返回值给到大模型。这里我们就省略了。。</p>
<pre><code class="java">com/itheima/ai/entity/query/CourseReservationQuery.java
package com.itheima.ai.entity.query;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.ai.tool.annotation.ToolParam;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CourseReservationQuery &#123;
    @ToolParam(required = false, description = &quot;预约课程&quot;)
    private String courseName;
    @ToolParam(required = false, description = &quot;预约校区&quot;)
    private String schoolName;
    @ToolParam(required = false, description = &quot;用户名称&quot;)
    private String userName;
    @ToolParam(required = false, description = &quot;备注&quot;)
    private String remark;
    @ToolParam(required = false, description = &quot;联系方式&quot;)
    private String contactInfo;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/entity/query/SchoolQuery.java
package com.itheima.ai.entity.query;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.ai.tool.annotation.ToolParam;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SchoolQuery &#123;
    @ToolParam(required = false, description = &quot;校区名称&quot;)
    private String name;
    @ToolParam(required = false, description = &quot;校区城市&quot;)
    private String city;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/tools/CourseTools.java
package com.itheima.ai.tools;

import com.baomidou.mybatisplus.extension.conditions.query.QueryChainWrapper;
import com.itheima.ai.entity.po.Course;
import com.itheima.ai.entity.po.CourseReservation;
import com.itheima.ai.entity.po.School;
import com.itheima.ai.entity.query.CourseQuery;
import com.itheima.ai.entity.query.CourseReservationQuery;
import com.itheima.ai.entity.query.SchoolQuery;
import com.itheima.ai.service.ICourseReservationService;
import com.itheima.ai.service.ICourseService;
import com.itheima.ai.service.ISchoolService;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.stereotype.Component;

import java.util.List;

@RequiredArgsConstructor
@Component
public class CourseTools &#123;
    private final ICourseService courseService;
    private final ISchoolService schoolService;
    private final ICourseReservationService courseReservationService;


    // @Tool注解是标给ai去看的
    @Tool(description = &quot;根据条件查询课程&quot;)
    List&lt;Course&gt; queryCourse(@ToolParam(description = &quot;查询的条件&quot;) CourseQuery query) &#123;
        if (query == null) &#123;
            return courseService.list();
//            return List.of();
        &#125;
        QueryChainWrapper&lt;Course&gt; courseWrapper = courseService.query()
                .eq(query.getType() != null, &quot;type&quot;, query.getType()) // type = &#39;编程&#39;
                .le(query.getEdu() != null, &quot;edu&quot;, query.getEdu()); // edu &lt;= 2
        if (query.getSorts() != null &amp;&amp; !query.getSorts().isEmpty()) &#123;
            for (CourseQuery.Sort sort : query.getSorts()) &#123;
                courseWrapper.orderBy(true, sort.getAsc(), sort.getField());
            &#125;
        &#125;
        return courseWrapper.list();
    &#125;

    @Tool(description = &quot;查询所有校区&quot;)
    public List&lt;School&gt; querySchool(@ToolParam(description = &quot;查询的条件&quot;) SchoolQuery query) &#123;
        if (query == null) &#123;
            return List.of();
        &#125;
        QueryChainWrapper&lt;School&gt; schoolWrapper = schoolService.query()
                .eq(query.getName() != null, &quot;name&quot;, query.getName())
                .eq(query.getCity() != null, &quot;city&quot;, query.getCity());
        return schoolWrapper.list();
    &#125;

    @Tool(description = &quot;生成预约单，返回预约单号&quot;)
    public Integer queryCourseReservation(@ToolParam(description = &quot;查询的条件&quot;) CourseReservationQuery query) &#123;
        CourseReservation courseReservation = new CourseReservation();
        courseReservation.setCourse(query.getCourseName());
        courseReservation.setSchool(query.getSchoolName());
        courseReservation.setStudentName(query.getUserName());
        courseReservation.setContactInfo(query.getContactInfo());
        courseReservation.setRemark(query.getRemark());
        courseReservationService.save(courseReservation);
        return courseReservation.getId();
    &#125;
&#125;
</code></pre>
<h4 id="这里有个bug-就是阿里云百炼和Function-Calling有不兼容问题-返回的JSON有问题"><a href="#这里有个bug-就是阿里云百炼和Function-Calling有不兼容问题-返回的JSON有问题" class="headerlink" title="这里有个bug 就是阿里云百炼和Function Calling有不兼容问题 [返回的JSON有问题]"></a>这里有个bug 就是阿里云百炼和Function Calling有不兼容问题 [返回的JSON有问题]</h4><p>解决方案：把返回的参数拼接在一起</p>
<pre><code class="java">com/itheima/ai/config/CommonConfiguration.java
package com.itheima.ai.config;

import com.itheima.ai.constants.SystemConstants;
import com.itheima.ai.model.AlibabaOpenAiChatModel;
import com.itheima.ai.tools.CourseTools;
import io.micrometer.observation.ObservationRegistry;
import org.springframework.ai.autoconfigure.openai.OpenAiChatProperties;
import org.springframework.ai.autoconfigure.openai.OpenAiConnectionProperties;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;
import org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;
import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.memory.InMemoryChatMemory;
import org.springframework.ai.chat.observation.ChatModelObservationConvention;
import org.springframework.ai.model.SimpleApiKey;
import org.springframework.ai.model.tool.ToolCallingManager;
import org.springframework.ai.ollama.OllamaChatModel;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.ai.openai.api.OpenAiApi;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.client.ResponseErrorHandler;
import org.springframework.web.client.RestClient;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Configuration
public class CommonConfiguration &#123;

    @Bean
    public ChatMemory chatMemory() &#123;
        // 创建会话内存，传入会话id，比如&quot;default&quot;
        // 定义存储方式 目前是在存储内存钟
        return new InMemoryChatMemory();
    &#125;

    @Bean
    public ChatClient chatClient(OllamaChatModel model, ChatMemory chatMemory) &#123;
        return ChatClient.builder(model)
                .defaultSystem(&quot;你是一只猫娘，你接下来要以猫娘的身份和语气跟我说话&quot;)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
                .build();
    &#125;

    @Bean
    public ChatClient gameChatClient(OpenAiChatModel model, ChatMemory chatMemory) &#123;
        return ChatClient.builder(model)
                .defaultSystem(SystemConstants.GAME_SYSTEM_PROMPT)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
                .build();
    &#125;

    @Bean
    public ChatClient serviceChatClient(AlibabaOpenAiChatModel model, ChatMemory chatMemory, CourseTools courseTools) &#123;
        return ChatClient.builder(model)
                .defaultSystem(SystemConstants.SERVICE_SYSTEM_PROMPT)
                .defaultAdvisors(new SimpleLoggerAdvisor())
                .defaultAdvisors(MessageChatMemoryAdvisor.builder(chatMemory).build())
                .defaultTools(courseTools)
                .build();
    &#125;


    @Bean
    public AlibabaOpenAiChatModel alibabaOpenAiChatModel(OpenAiConnectionProperties commonProperties, OpenAiChatProperties chatProperties, ObjectProvider&lt;RestClient.Builder&gt; restClientBuilderProvider, ObjectProvider&lt;WebClient.Builder&gt; webClientBuilderProvider, ToolCallingManager toolCallingManager, RetryTemplate retryTemplate, ResponseErrorHandler responseErrorHandler, ObjectProvider&lt;ObservationRegistry&gt; observationRegistry, ObjectProvider&lt;ChatModelObservationConvention&gt; observationConvention) &#123;
        String baseUrl = StringUtils.hasText(chatProperties.getBaseUrl()) ? chatProperties.getBaseUrl() : commonProperties.getBaseUrl();
        String apiKey = StringUtils.hasText(chatProperties.getApiKey()) ? chatProperties.getApiKey() : commonProperties.getApiKey();
        String projectId = StringUtils.hasText(chatProperties.getProjectId()) ? chatProperties.getProjectId() : commonProperties.getProjectId();
        String organizationId = StringUtils.hasText(chatProperties.getOrganizationId()) ? chatProperties.getOrganizationId() : commonProperties.getOrganizationId();
        Map&lt;String, List&lt;String&gt;&gt; connectionHeaders = new HashMap&lt;&gt;();
        if (StringUtils.hasText(projectId)) &#123;
            connectionHeaders.put(&quot;OpenAI-Project&quot;, List.of(projectId));
        &#125;

        if (StringUtils.hasText(organizationId)) &#123;
            connectionHeaders.put(&quot;OpenAI-Organization&quot;, List.of(organizationId));
        &#125;
        RestClient.Builder restClientBuilder = restClientBuilderProvider.getIfAvailable(RestClient::builder);
        WebClient.Builder webClientBuilder = webClientBuilderProvider.getIfAvailable(WebClient::builder);
        OpenAiApi openAiApi = OpenAiApi.builder().baseUrl(baseUrl).apiKey(new SimpleApiKey(apiKey)).headers(CollectionUtils.toMultiValueMap(connectionHeaders)).completionsPath(chatProperties.getCompletionsPath()).embeddingsPath(&quot;/v1/embeddings&quot;).restClientBuilder(restClientBuilder).webClientBuilder(webClientBuilder).responseErrorHandler(responseErrorHandler).build();
        AlibabaOpenAiChatModel chatModel = AlibabaOpenAiChatModel.builder().openAiApi(openAiApi).defaultOptions(chatProperties.getOptions()).toolCallingManager(toolCallingManager).retryTemplate(retryTemplate).observationRegistry((ObservationRegistry) observationRegistry.getIfUnique(() -&gt; ObservationRegistry.NOOP)).build();
        Objects.requireNonNull(chatModel);
        observationConvention.ifAvailable(chatModel::setObservationConvention);
        return chatModel;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/ai/model/AlibabaOpenAiChatModel.java

这里就是要用到OpenAIChatModel的底层代码做改写 太长了 可看源文件
改写好以后即可在serviceChatclient里面用自己定义的AlibabaOpenAiChatModel了
</code></pre>
<h3 id="SpringAI—ChatPDF-向量模型"><a href="#SpringAI—ChatPDF-向量模型" class="headerlink" title="SpringAI—ChatPDF-向量模型"></a>SpringAI—ChatPDF-向量模型</h3><h4 id="4-RAG（知识库-ChatPDF）"><a href="#4-RAG（知识库-ChatPDF）" class="headerlink" title="4.RAG（知识库 ChatPDF）"></a>4.RAG（知识库 ChatPDF）</h4><p>由于训练大模型非常耗时，再加上训练语料本身比较滞后，所以大模型存在<strong>知识限制</strong>问题：</p>
<ul>
<li>知识数据比较落后，往往是几个月之前的</li>
<li>不包含太过<strong>专业领域</strong>或者<strong>企业私有</strong>的数据</li>
</ul>
<p>为了解决这些问题，我们就需要用到RAG了。下面我们简单回顾下RAG原理</p>
<h4 id="4-1-RAG原理"><a href="#4-1-RAG原理" class="headerlink" title="4.1.RAG原理"></a>4.1.RAG原理</h4><p>要解决大模型的知识限制问题，其实并不复杂。</p>
<p>解决的思路就是给大模型外挂一个<strong>知识库</strong>，可以是专业领域知识，也可以是企业私有的数据。</p>
<p>不过，知识库不能简单的直接拼接在提示词中。</p>
<p>因为通常知识库数据量都是非常大的，而大模型的上下文是有大小限制的，早期的GPT上下文不能超过2000token，现在也不到200k token，因此知识库不能直接写在提示词中。</p>
<p>怎么办？</p>
<p>思路很简单，庞大的知识库中与用户问题相关的其实并不多。</p>
<p>所以，我们需要想办法<strong>从庞大的知识库中找到与用户问题相关的一小部分，组装成提示词</strong>，发送给大模型就可以了。</p>
<p>那么问题来了，我们该如何从知识库中找到与用户问题相关的内容呢？</p>
<p>可能有同学会相到全文检索，但是在这里是不合适的，因为全文检索是文字匹配，这里我们要求的是内容上的相似度。</p>
<p>而要从内容相似度来判断，这就不得不提到<strong>向量模型</strong>的知识了。</p>
<p>4.1.1.向量模型</p>
<p>先说说向量，向量是空间中有方向和长度的量，空间可以是二维，也可以是多维。</p>
<p>向量既然是在空间中，两个向量之间就一定能计算距离。</p>
<p>我们以二维向量为例，向量之间的距离有两种计算方法：</p>
<p><span style = "color:red">通常，两个向量之间<strong>欧式距离越近</strong>，我们认为两个向量的<strong>相似度越高</strong>。（余弦距离相反，越大相似度越高）所以，如果我们能<strong>把文本转为向量</strong>，就可以<strong>通过向量距离来判断文本的相似度</strong>了。</span></p>
<blockquote>
<p>0.0                                                 把查询文本自己与自己比较，肯定是相似度最高的<br>1.0722205301828829                把查询文本与其它文本比较【欧氏距离<strong>越近</strong>相似度越高】<br>1.0844350869313875<br>1.1185223356097924<br>1.1693257901084286<br>1.1499045763089124</p>
<p>0.9999999999999998                把查询文本与其它文本比较【余弦距离<strong>越远</strong>相似度越高】<br>0.4251716163869882<br>0.41200032867283726<br>0.37445397231274447<br>0.3163386320532005<br>0.3388597327534832</p>
</blockquote>
<p>现在，有不少的专门的<strong>向量模型</strong>，就可以实现将文本向量化。一个好的向量模型，就是要<strong>尽可能让文本含义相似的向量，在空间中距离更近</strong>：</p>
<p>接下来，我们就准备一个向量模型，用于将文本向量化。</p>
<p>阿里云百炼平台就提供了这样的模型：</p>
<p>这里我们选择<code>通用文本向量-v3</code>，这个模型兼容OpenAI，所以我们依然采用OpenAI的配置。</p>
<p>修改<code>application.yaml</code>，添加向量模型配置：</p>
<pre><code class="YAML">spring:
  application:
    name: ai-demo
  ai:
    ollama:
      base-url: http://localhost:11434 # ollama服务地址
      chat:
        model: deepseek-r1:7b # 模型名称，可更改
        options:
          temperature: 0.8 # 模型温度，值越大，输出结果越随机
    openai:
      base-url: https://dashscope.aliyuncs.com/compatible-mode
      api-key: $&#123;OPENAI_API_KEY&#125;
      chat:
        options:
          model: qwen-max # 模型名称
          temperature: 0.8 # 模型温度，值越大，输出结果越随机
      embedding:
        options:
          model: text-embedding-v3
          dimensions: 1024
</code></pre>
<h4 id="4-1-2-向量模型测试"><a href="#4-1-2-向量模型测试" class="headerlink" title="4.1.2.向量模型测试"></a>4.1.2.向量模型测试</h4><p>前面说过，文本向量化以后，可以通过向量之间的距离来判断文本相似度。</p>
<p>接下来，我们就来测试下阿里百炼提供的向量大模型好不好用。</p>
<p>首先，我们在项目中写一个工具类，用以计算向量之间的<strong>欧氏距离</strong>和<strong>余弦距离。</strong><br>[<u>大模型服务平台百炼控制台</u>] (<a target="_blank" rel="noopener" href="https://bailian.console.aliyun.com/?tab=model#/model-market/detail/text-embedding-v3">https://bailian.console.aliyun.com/?tab=model#/model-market/detail/text-embedding-v3</a>)</p>
<p>新建一个<code>com.itheima.ai.util</code>包，在其中新建一个类：</p>
<pre><code class="Java">package com.itheima.ai.util;

public class VectorDistanceUtils &#123;
    
    // 防止实例化
    private VectorDistanceUtils() &#123;&#125;

    // 浮点数计算精度阈值
    private static final double EPSILON = 1e-12;

    /**
     * 计算欧氏距离
     * @param vectorA 向量A（非空且与B等长）
     * @param vectorB 向量B（非空且与A等长）
     * @return 欧氏距离
     * @throws IllegalArgumentException 参数不合法时抛出
     */
    public static double euclideanDistance(float[] vectorA, float[] vectorB) &#123;
        validateVectors(vectorA, vectorB);
        
        double sum = 0.0;
        for (int i = 0; i &lt; vectorA.length; i++) &#123;
            double diff = vectorA[i] - vectorB[i];
            sum += diff * diff;
        &#125;
        return Math.sqrt(sum);
    &#125;

    /**
     * 计算余弦距离
     * @param vectorA 向量A（非空且与B等长）
     * @param vectorB 向量B（非空且与A等长）
     * @return 余弦距离，范围[0, 2]
     * @throws IllegalArgumentException 参数不合法或零向量时抛出
     */
    public static double cosineDistance(float[] vectorA, float[] vectorB) &#123;
        validateVectors(vectorA, vectorB);
        
        double dotProduct = 0.0;
        double normA = 0.0;
        double normB = 0.0;
        
        for (int i = 0; i &lt; vectorA.length; i++) &#123;
            dotProduct += vectorA[i] * vectorB[i];
            normA += vectorA[i] * vectorA[i];
            normB += vectorB[i] * vectorB[i];
        &#125;
        
        normA = Math.sqrt(normA);
        normB = Math.sqrt(normB);
        
        // 处理零向量情况
        if (normA &lt; EPSILON || normB &lt; EPSILON) &#123;
            throw new IllegalArgumentException(&quot;Vectors cannot be zero vectors&quot;);
        &#125;
        
        // 处理浮点误差，确保结果在[-1,1]范围内
        double similarity =  dotProduct / (normA * normB);
        similarity = Math.max(Math.min(similarity, 1.0), -1.0);
        
        return similarity;
    &#125;

    // 参数校验统一方法
    private static void validateVectors(float[] a, float[] b) &#123;
        if (a == null || b == null) &#123;
            throw new IllegalArgumentException(&quot;Vectors cannot be null&quot;);
        &#125;
        if (a.length != b.length) &#123;
            throw new IllegalArgumentException(&quot;Vectors must have same dimension&quot;);
        &#125;
        if (a.length == 0) &#123;
            throw new IllegalArgumentException(&quot;Vectors cannot be empty&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>由于SpringBoot的自动装配能力，刚才我们配置的向量模型可以直接使用。</p>
<p>接下来，我们写一个测试类：</p>
<pre><code class="Java">package com.itheima.ai;

import com.itheima.ai.util.VectorDistanceUtils;
import org.junit.jupiter.api.Test;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.openai.OpenAiChatModel;
import org.springframework.ai.openai.OpenAiEmbeddingModel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Arrays;
import java.util.List;

@SpringBootTest
class AiDemoApplicationTests &#123;

    // 自动注入向量模型
    @Autowired
    private OpenAiEmbeddingModel embeddingModel;

    @Test
    public void testEmbedding() &#123;
        // 1.测试数据
        // 1.1.用来查询的文本，国际冲突
        String query = &quot;global conflicts&quot;;
        
        // 1.2.用来做比较的文本
        String[] texts = new String[]&#123;
                &quot;哈马斯称加沙下阶段停火谈判仍在进行 以方尚未做出承诺&quot;,
                &quot;土耳其、芬兰、瑞典与北约代表将继续就瑞典“入约”问题进行谈判&quot;,
                &quot;日本航空基地水井中检测出有机氟化物超标&quot;,
                &quot;国家游泳中心（水立方）：恢复游泳、嬉水乐园等水上项目运营&quot;,
                &quot;我国首次在空间站开展舱外辐射生物学暴露实验&quot;,
        &#125;;
        // 2.向量化
        // 2.1.先将查询文本向量化
        float[] queryVector = embeddingModel.embed(query);

        // 2.2.再将比较文本向量化，放到一个数组
        List&lt;float[]&gt; textVectors = embeddingModel.embed(Arrays.asList(texts));
        
        // 3.比较欧氏距离
        // 3.1.把查询文本自己与自己比较，肯定是相似度最高的
        System.out.println(VectorDistanceUtils.euclideanDistance(queryVector, queryVector));
        // 3.2.把查询文本与其它文本比较
        for (float[] textVector : textVectors) &#123;
            System.out.println(VectorDistanceUtils.euclideanDistance(queryVector, textVector));
        &#125;
        System.out.println(&quot;------------------&quot;);
        
        // 4.比较余弦距离
        // 4.1.把查询文本自己与自己比较，肯定是相似度最高的
        System.out.println(VectorDistanceUtils.cosineDistance(queryVector, queryVector));
        // 4.2.把查询文本与其它文本比较
        for (float[] textVector : textVectors) &#123;
            System.out.println(VectorDistanceUtils.cosineDistance(queryVector, textVector));
        &#125;
    &#125;

&#125;
</code></pre>
<blockquote>
<h2 id="🧠-一、什么是“向量化”？"><a href="#🧠-一、什么是“向量化”？" class="headerlink" title="🧠 一、什么是“向量化”？"></a>🧠 一、什么是“向量化”？</h2><p>通俗解释：</p>
<blockquote>
<p>把一句人类语言（如：“全球冲突”）转换成一个 <strong>数字数组（float[]）</strong>，这个数组可以用于数学运算，比如比较两句话有多相似。</p>
</blockquote>
<p>背后用的是 <strong>OpenAI 的 embedding 模型</strong>（如 <code>text-embedding-3-small</code>），它可以把文本转成固定维度的向量（比如 1536 维的数组）。</p>
<hr>
<h2 id="🛠-二、如何做到向量化？看关键代码："><a href="#🛠-二、如何做到向量化？看关键代码：" class="headerlink" title="🛠 二、如何做到向量化？看关键代码："></a>🛠 二、如何做到向量化？看关键代码：</h2><pre><code>java复制编辑@Autowired
private OpenAiEmbeddingModel embeddingModel;
</code></pre>
<h3 id="✅-这个是-Spring-AI-提供的封装："><a href="#✅-这个是-Spring-AI-提供的封装：" class="headerlink" title="✅ 这个是 Spring AI 提供的封装："></a>✅ 这个是 Spring AI 提供的封装：</h3><ul>
<li><code>OpenAiEmbeddingModel</code> 是 Spring AI 提供的一个组件，内置了 OpenAI 的嵌入模型调用逻辑。</li>
<li>实际上它会调用 OpenAI API（如：<code>/v1/embeddings</code>），将文本变成向量。</li>
</ul>
<p>Spring 会自动帮你完成：</p>
<ul>
<li>构建 HTTP 请求</li>
<li>携带 API 密钥</li>
<li>接收嵌入向量返回值</li>
<li>转成 Java 中的 <code>float[]</code> 数组</li>
</ul>
<hr>
<h3 id="🧪-代码详细讲解如下："><a href="#🧪-代码详细讲解如下：" class="headerlink" title="🧪 代码详细讲解如下："></a>🧪 代码详细讲解如下：</h3><h4 id="1-向量化单个查询文本"><a href="#1-向量化单个查询文本" class="headerlink" title="1. 向量化单个查询文本"></a>1. 向量化单个查询文本</h4><pre><code class="java">String query = &quot;global conflicts&quot;;
float[] queryVector = embeddingModel.embed(query);
</code></pre>
<ul>
<li><p>这行代码背后会调用 OpenAI embedding 接口，把 <code>&quot;global conflicts&quot;</code> 变成一个向量，比如：</p>
<pre><code class="java">queryVector = [0.123f, 0.456f, ..., 0.789f] // 共1536个 float
</code></pre>
</li>
</ul>
<blockquote>
<p>⚙️ 底层请求类似：</p>
</blockquote>
<pre><code class="java">POST /v1/embeddings
&#123;
  &quot;input&quot;: &quot;global conflicts&quot;,
  &quot;model&quot;: &quot;text-embedding-3-small&quot;
&#125;
</code></pre>
<hr>
<h4 id="2-向量化多个文本"><a href="#2-向量化多个文本" class="headerlink" title="2. 向量化多个文本"></a>2. 向量化多个文本</h4><pre><code class="java">List&lt;float[]&gt; textVectors = embeddingModel.embed(Arrays.asList(texts));
</code></pre>
<ul>
<li>一次性把多个中文文本转成向量。</li>
<li>返回的是 <code>List&lt;float[]&gt;</code>，每个文本对应一个向量数组。</li>
</ul>
<p>例如：</p>
<pre><code class="java">texts[0] -&gt; 向量：[0.234f, 0.891f, ...]
texts[1] -&gt; 向量：[0.111f, 0.456f, ...]
</code></pre>
<ul>
<li><strong>批量处理的好处</strong>：效率更高，减少 API 调用次数。</li>
</ul>
</blockquote>
<p><strong>注意</strong>： 运行单元测试通用需要配置OPENAI_API_KEY的环境变量</p>
<p>首先，点击单元测试左侧运行按钮：………运行结果：</p>
<pre><code class="Bash">0.0
1.0722205301828829
1.0844350869313875
1.1185223356097924
1.1693257901084286
1.1499045763089124
------------------
0.9999999999999998
0.4251716163869882
0.41200032867283726
0.37445397231274447
0.3163386320532005
0.3388597327534832
</code></pre>
<p>可以看到，向量相似度确实符合我们的预期。</p>
<p>OK，有了比较文本相似度的办法，知识库的问题就可以解决了。</p>
<p>前面说了，知识库数据量很大，无法全部写入提示词。但是庞大的知识库中与用户问题相关的其实并不多。</p>
<p>所以，我们需要想办法<strong>从庞大的知识库中找到与用户问题相关的一小部分，组装成提示词</strong>，发送给大模型就可以了。</p>
<p>现在，利用向量大模型就可以帮助我们比较文本相似度。</p>
<p>但是新的问题来了：向量模型是帮我们生成向量的，如此庞大的知识库，谁来帮我们从中<strong>比较和检索数据</strong>呢？</p>
<p>这就需要用到<strong>向量数据库</strong>了。</p>
<h4 id="4-1-3-向量数据库"><a href="#4-1-3-向量数据库" class="headerlink" title="4.1.3.向量数据库"></a>4.1.3.向量数据库</h4><p>主流一线的向量数据库【Milvus】功能全面，支持向量+结构化查询、GPU加速，国内社区活跃</p>
<p>向量数据库的主要作用有两个：</p>
<ul>
<li>存储向量数据</li>
<li>基于相似度检索数据</li>
</ul>
<p>刚好符合我们的需求。</p>
<p>SpringAI支持很多向量数据库，并且都进行了封装，可以用统一的API去访问：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/azure.html">Azure Vector Search</a> - The <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/azure/search/vector-search-overview">Azure</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/apache-cassandra.html">Apache Cassandra</a> - The <a target="_blank" rel="noopener" href="https://cassandra.apache.org/doc/latest/cassandra/vector-search/overview.html">Apache Cassandra</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/chroma.html">Chroma Vector Store</a> - The <a target="_blank" rel="noopener" href="https://www.trychroma.com/">Chroma</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/elasticsearch.html">Elasticsearch Vector Store</a> - The <a target="_blank" rel="noopener" href="https://www.elastic.co/">Elasticsearch</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/gemfire.html">GemFire Vector Store</a> - The <a target="_blank" rel="noopener" href="https://tanzu.vmware.com/content/blog/vmware-gemfire-vector-database-extension">GemFire</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/mariadb.html">MariaDB Vector Store</a> - The <a target="_blank" rel="noopener" href="https://mariadb.com/">MariaDB</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/milvus.html">Milvus Vector Store</a> - The <a target="_blank" rel="noopener" href="https://milvus.io/">Milvus</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/mongodb.html">MongoDB Atlas Vector Store</a> - The <a target="_blank" rel="noopener" href="https://www.mongodb.com/atlas/database">MongoDB Atlas</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/neo4j.html">Neo4j Vector Store</a> - The <a target="_blank" rel="noopener" href="https://neo4j.com/">Neo4j</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/opensearch.html">OpenSearch Vector Store</a> - The <a target="_blank" rel="noopener" href="https://opensearch.org/platform/search/vector-database.html">OpenSearch</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/oracle.html">Oracle Vector Store</a> - The <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/database/oracle/oracle-database/23/vecse/overview-ai-vector-search.html">Oracle Database</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/pgvector.html">PgVector Store</a> - The <a target="_blank" rel="noopener" href="https://github.com/pgvector/pgvector">PostgreSQL&#x2F;PGVector</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/pinecone.html">Pinecone Vector Store</a> - <a target="_blank" rel="noopener" href="https://www.pinecone.io/">PineCone</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/qdrant.html">Qdrant Vector Store</a> - <a target="_blank" rel="noopener" href="https://www.qdrant.tech/">Qdrant</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/redis.html">Redis Vector Store</a> - The <a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/hana.html">SAP Hana Vector Store</a> - The <a target="_blank" rel="noopener" href="https://news.sap.com/2024/04/sap-hana-cloud-vector-engine-ai-with-business-context/">SAP HANA</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/typesense.html">Typesense Vector Store</a> - The <a target="_blank" rel="noopener" href="https://typesense.org/docs/0.24.0/api/vector-search.html">Typesense</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs/weaviate.html">Weaviate Vector Store</a> - The <a target="_blank" rel="noopener" href="https://weaviate.io/">Weaviate</a> vector store.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-ai/blob/main/spring-ai-core/src/main/java/org/springframework/ai/vectorstore/SimpleVectorStore.java">SimpleVectorStore</a> - A simple implementation of persistent vector storage, good for educational purposes.</li>
</ul>
<p>这些库都实现了统一的接口：<code>VectorStore</code>，因此操作方式一模一样，大家学会任意一个，其它就都不是问题。</p>
<p>不过，除了最后一个库以外，其它所有向量数据库都是需要安装部署的。每个企业用的向量库都不一样，这里我就不一一演示了。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8e90b3937f86a11b04cbc74588a99c4fbe97cfb7/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%8E%A5SpringAI%E6%B5%81%E7%A8%8B.png"></p>
<h5 id="4-1-3-1-SimpleVectorStore"><a href="#4-1-3-1-SimpleVectorStore" class="headerlink" title="4.1.3.1.SimpleVectorStore"></a>4.1.3.1.SimpleVectorStore</h5><p>最后一个<code>SimpleVectorStore</code>向量库是基于内存实现，是一个专门用来测试、教学用的库，非常适合我们。</p>
<p>我们直接修改<code>CommonConfiguration</code>，添加一个<code>VectorStore</code>的Bean：</p>
<pre><code class="Java">@Configuration
public class CommonConfiguration &#123;

    @Bean
    public VectorStore vectorStore(OpenAiEmbeddingModel embeddingModel) &#123;
        return SimpleVectorStore.builder(embeddingModel).build();
    &#125;
    
    // ... 略
&#125;
</code></pre>
<h5 id="4-1-3-2-VectorStore接口"><a href="#4-1-3-2-VectorStore接口" class="headerlink" title="4.1.3.2.VectorStore接口"></a>4.1.3.2.VectorStore接口</h5><p>接下来，你就可以使用<code>VectorStore</code>中的各种功能了，可以参考SpringAI官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/vectordbs.html">https://docs.spring.io/spring-ai/reference/api/vectordbs.html</a></p>
<p>这是<code>VectorStore</code>中声明的方法：</p>
<pre><code class="Java">public interface VectorStore extends DocumentWriter &#123;

    default String getName() &#123;
                return this.getClass().getSimpleName();
        &#125;
    // 保存文档到向量库
    void add(List&lt;Document&gt; documents);
    // 根据文档id删除文档
    void delete(List&lt;String&gt; idList);

    void delete(Filter.Expression filterExpression);

    default void delete(String filterExpression) &#123; ... &#125;;
    // 根据条件检索文档
    List&lt;Document&gt; similaritySearch(String query);
    // 根据条件检索文档
    List&lt;Document&gt; similaritySearch(SearchRequest request);

    default &lt;T&gt; Optional&lt;T&gt; getNativeClient() &#123;
                return Optional.empty();
        &#125;
&#125;
</code></pre>
<p>注意，<code>VectorStore</code>操作向量化的基本单位是<code>Document</code>，我们在使用时需要将自己的知识库分割转换为一个个的<code>Document</code>，然后写入<code>VectorStore</code>.</p>
<p>那么问题来了，我们该如何把各种不同的知识库文件转为Document呢？</p>
<h4 id="4-1-4-文件读取和转换"><a href="#4-1-4-文件读取和转换" class="headerlink" title="4.1.4.文件读取和转换"></a>4.1.4.文件读取和转换</h4><p>前面说过，知识库太大，是需要拆分成文档片段，然后再做向量化的。而且SpringAI中向量库接收的是Document类型的文档，也就是说，我们处理文档还要转成Document格式。</p>
<p>不过，文档读取、拆分、转换的动作并不需要我们亲自完成。在SpringAI中提供了各种文档读取的工具，可以参考官网：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_pdf_paragraph">https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html#_pdf_paragraph</a></p>
<p>比如PDF文档读取和拆分，SpringAI提供了两种默认的拆分原则：</p>
<ul>
<li><code>PagePdfDocumentReader</code> ：按页拆分，推荐使用</li>
<li><code>ParagraphPdfDocumentReader</code> ：按pdf的目录拆分，不推荐，因为很多PDF不规范，没有章节标签</li>
</ul>
<p>当然，大家也可以自己实现PDF的读取和拆分功能。</p>
<p>这里我们选择使用<code>PagePdfDocumentReader</code>。</p>
<p>首先，我们需要在pom.xml中引入依赖：</p>
<pre><code class="XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-pdf-document-reader&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后就可以利用工具把PDF文件读取并处理成Document了。</p>
<p>我们写一个单元测试（别忘了配置<strong>API_KEY</strong>）：</p>
<pre><code class="java">package com.itheima.ai;

import com.itheima.ai.utils.VectorDistanceUtils;
import org.junit.jupiter.api.Test;
import org.springframework.ai.document.Document;
import org.springframework.ai.openai.OpenAiEmbeddingModel;
import org.springframework.ai.reader.ExtractedTextFormatter;
import org.springframework.ai.reader.pdf.PagePdfDocumentReader;
import org.springframework.ai.reader.pdf.config.PdfDocumentReaderConfig;
import org.springframework.ai.vectorstore.SearchRequest;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;

import java.util.Arrays;
import java.util.List;

@SpringBootTest
class HeimaAiApplicationTests &#123;

    @Autowired
    private OpenAiEmbeddingModel embeddingModel;
    @Autowired
    private VectorStore vectorStore;

    @Test
    public void testVectorStore()&#123;
        Resource resource = new FileSystemResource(&quot;中二知识笔记.pdf&quot;);
        // 1.创建PDF的读取器
        PagePdfDocumentReader reader = new PagePdfDocumentReader(
                resource, // 文件源
                PdfDocumentReaderConfig.builder()
                        .withPageExtractedTextFormatter(ExtractedTextFormatter.defaults())
                        .withPagesPerDocument(1) // 每1页PDF作为一个Document
                        .build()
        );
        // 2.读取PDF文档，拆分为Document
        List&lt;Document&gt; documents = reader.read();
        // 3.写入向量库
        vectorStore.add(documents);
        // 4.搜索
        SearchRequest request = SearchRequest.builder()
                .query(&quot;论语中教育的目的是什么&quot;) // 查询条件
                .topK(1) // 返回的文档数量
                .similarityThreshold(0.6) // 阈值 超过的要
                .filterExpression(&quot;file_name == &#39;中二知识笔记.pdf&#39;&quot;) // 过滤条件
                .build();
        List&lt;Document&gt; docs = vectorStore.similaritySearch(request);
        if (docs == null) &#123;
            System.out.println(&quot;没有搜索到任何内容&quot;);
            return;
        &#125;
        for (Document doc : docs) &#123;
            System.out.println(doc.getId());
            System.out.println(doc.getScore());
            System.out.println(doc.getText());
        &#125;
    &#125;
</code></pre>
<h4 id="4-1-5-RAG原理总结"><a href="#4-1-5-RAG原理总结" class="headerlink" title="4.1.5.RAG原理总结"></a>4.1.5.RAG原理总结</h4><p>OK，现在我们有了这些工具：</p>
<ul>
<li>PDFReader：读取文档并拆分为片段</li>
<li>向量大模型：将文本片段向量化</li>
<li>向量数据库：存储向量，检索向量</li>
</ul>
<p>让我们梳理一下要解决的问题和解决思路：</p>
<ul>
<li>要解决大模型的知识限制问题，需要外挂知识库</li>
<li>受到大模型上下文限制，知识库不能简单的直接拼接在提示词中</li>
<li>我们需要从庞大的知识库中找到与用户问题相关的一小部分，再组装成提示词</li>
<li>这些可以利用<strong>文档读取器</strong>、<strong>向量大模型</strong>、<strong>向量数据库</strong>来解决。</li>
</ul>
<p>所以RAG要做的事情就是将知识库分割，然后利用向量模型做向量化，存入向量数据库，然后查询的时候去检索：</p>
<p><strong>第一阶段（存储知识库）</strong>：</p>
<ul>
<li>将知识库内容切片，分为一个个片段</li>
<li>将每个片段利用向量模型向量化</li>
<li>将所有向量化后的片段写入向量数据库</li>
</ul>
<p><strong>第二阶段（检索知识库）</strong>：</p>
<ul>
<li>每当用户询问AI时，将用户问题向量化</li>
<li>拿着问题向量去向量数据库检索最相关的片段</li>
</ul>
<p><strong>第三阶段（对话大模型）</strong>：</p>
<ul>
<li>将检索到的片段、用户的问题一起拼接为提示词</li>
<li>发送提示词给大模型，得到响应</li>
</ul>
<h4 id="4-1-6-目标"><a href="#4-1-6-目标" class="headerlink" title="4.1.6.目标"></a>4.1.6.目标</h4><p>好了，现在RAG所需要的基本工具都有了。</p>
<p>接下来，我们就来实现一个非常火爆的个人知识库AI应用，ChatPDF，原网站如下：</p>
<p>这个网站其实就是把你个人的PDF文件作为知识库，让AI基于PDF内容来回答你的问题，对于大学生、研究人员、专业人士来说，非常方便。</p>
<p>当你学会了这个功能，实现其它知识库也都是类似的流程了。</p>
<p>来吧，我们一起动起来！</p>
<h4 id="实现上传下载、记录本次保存时会话ID和文件名的映射关系、把文件写入向量数据库"><a href="#实现上传下载、记录本次保存时会话ID和文件名的映射关系、把文件写入向量数据库" class="headerlink" title="实现上传下载、记录本次保存时会话ID和文件名的映射关系、把文件写入向量数据库"></a><span style = "color:red">实现上传下载、记录本次保存时会话ID和文件名的映射关系、把文件写入向量数据库</span></h4><h3 id="4-2-PDF上传下载、向量化"><a href="#4-2-PDF上传下载、向量化" class="headerlink" title="4.2.PDF上传下载、向量化"></a>4.2.PDF上传下载、向量化</h3><p>既然是ChatPDF，也就是说所有知识库都是PDF形式的，由用户提交给我们。所以，我们需要先实现一个上传PDF的接口，在接口中实现下列功能：</p>
<ul>
<li>校验文件格式是否为PDF</li>
<li>保存文件信息<ul>
<li>保存文件（可以是oss或本地保存）</li>
<li>保存会话ID和文件路径的映射关系（方便查询会话历史的时候再次读取文件）</li>
</ul>
</li>
<li>文档拆分和向量化（文档太大，需要拆分为一个个片段，分别向量化）</li>
</ul>
<p>另外，将来用户查询会话历史，我们还需要返回pdf文件给前端用于预览，所以需要实现一个下载PDF接口，包含下面功能：</p>
<ul>
<li>读取文件</li>
<li>返回文件给前端</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/27e61b01d79d06783178fad8da84e547e4ecba04/ChatPDF%E2%80%94%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p>
<h4 id="4-2-1-PDF文件管理"><a href="#4-2-1-PDF文件管理" class="headerlink" title="4.2.1.PDF文件管理"></a>4.2.1.PDF文件管理</h4><p>由于将来要实现PDF下载功能，我们需要记住每一个chatId对应的PDF文件名称。</p>
<p>所以，我们定义一个类，记录chatId与pdf文件的映射关系，同时实现基本的文件保存功能。</p>
<p>先在<code>com.itheima.ai.repository</code>中定义接口：</p>
<pre><code class="java">package com.itheima.ai.repository;

import org.springframework.core.io.Resource;

public interface FileRepository &#123;
    /**
     * 保存文件,还要记录chatId与文件的映射关系
     * @param chatId 会话id
     * @param resource 文件
     * @return 上传成功，返回true； 否则返回false
     */
    boolean save(String chatId, Resource resource);

    /**
     * 根据chatId获取文件
     * @param chatId 会话id
     * @return 找到的文件
     */
    Resource getFile(String chatId);
&#125;
</code></pre>
<p>其中的Rescource是底层提供的class【Spring中表示资源的类】</p>
<pre><code class="java">D:\apache-maven-3.9.5\repository\org\springframework\spring-core\6.2.3\spring-core-6.2.3.jar!\org\springframework\core\io\Resource.class
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.core.io;

import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import org.springframework.lang.Nullable;
import org.springframework.util.FileCopyUtils;

public interface Resource extends InputStreamSource &#123;
    boolean exists();

    default boolean isReadable() &#123;
        return this.exists();
    &#125;

    default boolean isOpen() &#123;
        return false;
    &#125;

    default boolean isFile() &#123;
        return false;
    &#125;

    URL getURL() throws IOException;

    URI getURI() throws IOException;

    File getFile() throws IOException;

    default ReadableByteChannel readableChannel() throws IOException &#123;
        return Channels.newChannel(this.getInputStream());
    &#125;

    default byte[] getContentAsByteArray() throws IOException &#123;
        return FileCopyUtils.copyToByteArray(this.getInputStream());
    &#125;

    default String getContentAsString(Charset charset) throws IOException &#123;
        return FileCopyUtils.copyToString(new InputStreamReader(this.getInputStream(), charset));
    &#125;

    long contentLength() throws IOException;

    long lastModified() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    @Nullable
    String getFilename();

    String getDescription();
&#125;
</code></pre>
<p>再写一个实现类：</p>
<pre><code class="java">package com.itheima.ai.repository;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.vectorstore.SimpleVectorStore;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.Properties;

@Slf4j
@Component
@RequiredArgsConstructor
public class LocalPdfFileRepository implements FileRepository &#123;

    private final VectorStore vectorStore;

    // 会话id 与 文件名的对应关系，方便查询会话历史时重新加载文件
    private final Properties chatFiles = new Properties();

    @Override
    public boolean save(String chatId, Resource resource) &#123;

        // 2.保存到本地磁盘
        String filename = resource.getFilename();
        File target = new File(Objects.requireNonNull(filename));
        if (!target.exists()) &#123;
            try &#123;
                Files.copy(resource.getInputStream(), target.toPath());
            &#125; catch (IOException e) &#123;
                log.error(&quot;Failed to save PDF resource.&quot;, e);
                return false;
            &#125;
        &#125;
        // 3.保存映射关系
        chatFiles.put(chatId, filename);
        return true;
    &#125;

    @Override
    public Resource getFile(String chatId) &#123;
        return new FileSystemResource(chatFiles.getProperty(chatId));
    &#125;

    @PostConstruct
    private void init() &#123;
        // 会话ID映射关系
        FileSystemResource pdfResource = new FileSystemResource(&quot;chat-pdf.properties&quot;);
        if (pdfResource.exists()) &#123;
            try &#123;
                chatFiles.load(new BufferedReader(new InputStreamReader(pdfResource.getInputStream(), StandardCharsets.UTF_8)));
            &#125; catch (IOException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
        // 向量库的持久化 读取
        FileSystemResource vectorResource = new FileSystemResource(&quot;chat-pdf.json&quot;);
        if (vectorResource.exists()) &#123;
            SimpleVectorStore simpleVectorStore = (SimpleVectorStore) vectorStore;
            simpleVectorStore.load(vectorResource);
        &#125;
    &#125;

    @PreDestroy
    private void persistent() &#123;
        // 停机时持久化
        try &#123;
            chatFiles.store(new FileWriter(&quot;chat-pdf.properties&quot;), LocalDateTime.now().toString());
            SimpleVectorStore simpleVectorStore = (SimpleVectorStore) vectorStore;
            simpleVectorStore.save(new File(&quot;chat-pdf.json&quot;));
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>注意</strong>：</p>
<p>由于我们选择了基于内存的SimpleVectorStore，重启就会丢失向量数据。所以这里我依然是将pdf文件与chatId的对应关系、VectorStore都持久化到了磁盘。</p>
<p>实际开发中，如果你选择了RedisVectorStore，或者CassandraVectorStore，则无序自己持久化。但是chatId和PDF文件之间的对应关系，还是需要自己维护的。</p>
<h4 id="4-2-2-上传文件响应结果"><a href="#4-2-2-上传文件响应结果" class="headerlink" title="4.2.2.上传文件响应结果"></a>4.2.2.上传文件响应结果</h4><p>由于前端文件上传需要返回响应结果，我们先在<code>com.itheima.ai.entity.vo</code>中定义一个<code>Result</code>类：</p>
<pre><code class="Java">package com.itheima.ai.entity.vo;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class Result &#123;
    private Integer ok;
    private String msg;

    private Result(Integer ok, String msg) &#123;
        this.ok = ok;
        this.msg = msg;
    &#125;

    public static Result ok() &#123;
        return new Result(1, &quot;ok&quot;);
    &#125;

    public static Result fail(String msg) &#123;
        return new Result(0, msg);
    &#125;
&#125;
</code></pre>
<h4 id="4-2-3-文件上传、下载"><a href="#4-2-3-文件上传、下载" class="headerlink" title="4.2.3.文件上传、下载"></a>4.2.3.文件上传、下载</h4><p>接下来，我们实现上传和下载文件接口。</p>
<p>在<code>com.itheima.ai.controller</code>中创建一个<code>PdfController</code>：</p>
<pre><code class="java">package com.itheima.ai.controller;

import com.itheima.ai.entity.vo.Result;
import com.itheima.ai.repository.FileRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.document.Document;
import org.springframework.ai.reader.ExtractedTextFormatter;
import org.springframework.ai.reader.pdf.PagePdfDocumentReader;
import org.springframework.ai.reader.pdf.config.PdfDocumentReaderConfig;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.core.io.Resource;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Objects;

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai/pdf&quot;)
public class PdfController &#123;

    private final FileRepository fileRepository;

    private final VectorStore vectorStore;
    /**
     * 文件上传
     */
    @RequestMapping(&quot;/upload/&#123;chatId&#125;&quot;)
    public Result uploadPdf(@PathVariable String chatId, @RequestParam(&quot;file&quot;) MultipartFile file) &#123;
        try &#123;
            // 1. 校验文件是否为PDF格式
            if (!Objects.equals(file.getContentType(), &quot;application/pdf&quot;)) &#123;
                return Result.fail(&quot;只能上传PDF文件！&quot;);
            &#125;
            // 2.保存文件
            boolean success = fileRepository.save(chatId, file.getResource());
            if(! success) &#123;
                return Result.fail(&quot;保存文件失败！&quot;);
            &#125;
            // 3.写入向量库
            this.writeToVectorStore(file.getResource());
            return Result.ok();
        &#125; catch (Exception e) &#123;
            log.error(&quot;Failed to upload PDF.&quot;, e);
            return Result.fail(&quot;上传文件失败！&quot;);
        &#125;
    &#125;

    /**
     * 文件下载
     */
    @GetMapping(&quot;/file/&#123;chatId&#125;&quot;)
    public ResponseEntity&lt;Resource&gt; download(@PathVariable(&quot;chatId&quot;) String chatId) throws IOException &#123;
        // 1.读取文件
        Resource resource = fileRepository.getFile(chatId);
        if (!resource.exists()) &#123;
            return ResponseEntity.notFound().build();
        &#125;
        // 2.文件名编码，写入响应头
        String filename = URLEncoder.encode(Objects.requireNonNull(resource.getFilename()), StandardCharsets.UTF_8);
        // 3.返回文件
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + filename + &quot;\&quot;&quot;)
                .body(resource);
    &#125;

    private void writeToVectorStore(Resource resource) &#123;
        // 1.创建PDF的读取器
        PagePdfDocumentReader reader = new PagePdfDocumentReader(
                resource, // 文件源
                PdfDocumentReaderConfig.builder()
                        .withPageExtractedTextFormatter(ExtractedTextFormatter.defaults())
                        .withPagesPerDocument(1) // 每1页PDF作为一个Document
                        .build()
        );
        // 2.读取PDF文档，拆分为Document
        List&lt;Document&gt; documents = reader.read();
        // 3.写入向量库
        vectorStore.add(documents);
    &#125;
&#125;
</code></pre>
<h4 id="4-2-4-上传大小限制"><a href="#4-2-4-上传大小限制" class="headerlink" title="4.2.4.上传大小限制"></a>4.2.4.上传大小限制</h4><p>SpringMVC有默认的文件大小限制，只有10M，很多知识库文件都会超过这个值，所以我们需要修改配置，增加文件上传允许的上限。</p>
<p>修改<code>application.yaml</code>文件，添加配置：</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 104857600
      max-request-size: 104857600
</code></pre>
<h4 id="4-2-5-暴露响应头"><a href="#4-2-5-暴露响应头" class="headerlink" title="4.2.5.暴露响应头"></a>4.2.5.暴露响应头</h4><p>默认情况下跨域请求的响应头是不暴露的，这样前端就拿不到下载的文件名，我们需要修改CORS配置，暴露响应头：</p>
<pre><code class="java">package com.itheima.ai.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfiguration implements WebMvcConfigurer &#123;

    @Override
    public void addCorsMappings(CorsRegistry registry) &#123;
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .allowedHeaders(&quot;*&quot;)
                .exposedHeaders(&quot;Content-Disposition&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="4-3-配置ChatClient"><a href="#4-3-配置ChatClient" class="headerlink" title="4.3.配置ChatClient"></a>4.3.配置ChatClient</h3><p>接下来就是最后的环节了，实现RAG的对话流程。</p>
<p>理论上来说，我们每次与AI对话的完整流程是这样的：</p>
<ul>
<li>将用户的问题利用向量大模型做向量化 OpenAiEmbeddingModel</li>
<li>去向量数据库检索相关的文档 VectorStore</li>
<li>拼接提示词，发送给大模型</li>
<li>解析响应结果</li>
</ul>
<p>不过，SpringAI同样基于AOP技术帮我们完成了全部流程，用到的是一个名<code>QuestionAnswerAdvisor</code>的Advisor。我们只需要把<code>VectorStore</code>配置到Advisor即可。</p>
<p>我们在<code>CommonConfiguration</code>中给ChatPDF也单独定义一个<code>ChatClient</code>：</p>
<pre><code class="Java">@Bean
public ChatClient pdfChatClient(
        OpenAiChatModel model,
        ChatMemory chatMemory,
        VectorStore vectorStore) &#123;
    return ChatClient.builder(model)
            .defaultSystem(&quot;请根据提供的上下文回答问题，不要自己猜测。&quot;)
            .defaultAdvisors(
                    new MessageChatMemoryAdvisor(chatMemory), // CHAT MEMORY
                    new SimpleLoggerAdvisor(),
                    new QuestionAnswerAdvisor(
                            vectorStore, // 向量库
                            SearchRequest.builder() // 向量检索的请求参数
                                    .similarityThreshold(0.5d) // 相似度阈值
                                    .topK(2) // 返回的文档片段数量
                                    .build()
                    )
            )
            .build();
&#125;
</code></pre>
<p>我们也可以自己自定义RAG查询的流程，不使用Advisor，具体可参考官网：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/retrieval-augmented-generation.html">https://docs.spring.io/spring-ai/reference/api/retrieval-augmented-generation.html</a></p>
<h3 id="4-4-对话接口"><a href="#4-4-对话接口" class="headerlink" title="4.4.对话接口"></a>4.4.对话接口</h3><p>最后，就是对接前端，然后与大模型对话了。修改<code>PdfController</code>，添加一个接口：</p>
<pre><code class="Java">@RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=UTF-8&quot;)
public Flux&lt;String&gt; chat(String prompt, String chatId) &#123;
    chatRepository.addChatId(&quot;pdf&quot;, chatId);
    Resource file = fileRepository.getFile(chatId);
    return pdfChatClient
            .prompt(prompt)
            .advisors(a -&gt; a.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId))
            .advisors(a -&gt; a.param(QuestionAnswerAdvisor.FILTER_EXPRESSION, &quot;file_name == &#39;&quot;+file.getFilename()+&quot;&#39;&quot;))
            .stream()
            .content();
&#125;
</code></pre>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="5-多模态"><a href="#5-多模态" class="headerlink" title="5.多模态"></a>5.多模态</h2><p>多模态是指不同类型的数据输入，<strong>如文本、图像、声音、视频等</strong>。目前为止，我们与大模型交互都是基于普通文本输入，这跟我们选择的大模型有关。</p>
<p>deepseek、qwen-max等模型都是纯文本模型，在ollama和百炼平台，我们也能找到很多多模态模型。</p>
<p>以ollama为例，在搜索时点击vison，就能找到支持图像识别的模型：<br>在阿里云百炼平台也一样：</p>
<p>阿里云的qwen-omni模型是支持文本、图像、音频、视频输入的全模态模型，还能支持语音合成功能，非常强大。</p>
<p><strong>注意</strong>：</p>
<p>在SpringAI的当前版本（1.0.0-m6)中，qwen-omni与SpringAI中的OpenAI模块的兼容性有问题，目前仅支持文本和图片两种模态。音频会有数据格式错误问题，视频完全不支持。</p>
<p>目前的解决方案有两种：</p>
<ul>
<li>一是使用spring-ai-alibaba来替代。</li>
<li>二是重写OpenAIModel的实现，参考第6节</li>
</ul>
<p>接下来，我们拓展入门时写的对话机器人，让他支持多模态效果。</p>
<h3 id="5-1-切换模型"><a href="#5-1-切换模型" class="headerlink" title="5.1.切换模型"></a>5.1.切换模型</h3><p>首先，我们需要修改<code>CommonConfiguration</code>中用于AI对话的<code>ChatClient</code>，将模型修改为<code>OpenAIChatModel</code>，不仅如此，由于其它业务使用的是<code>qwen-max</code>模型，不能改变。所以这里我们还需添加自定义配置，将模型改为<code>qwen-omni-turbo</code>:</p>
<pre><code class="Java">com/itheima/ai/config/CommonConfiguration.java
@Bean
public ChatClient chatClient(OpenAiChatModel model, ChatMemory chatMemory) &#123;
    return ChatClient.builder(model) // 创建ChatClient工厂实例
            .defaultOptions(ChatOptions.builder().model(&quot;qwen-omni-turbo&quot;).build())
            .defaultSystem(&quot;您是一家名为“黑马程序员”的职业教育公司的客户聊天助手，你的名字叫小黑。请以友好、乐于助人和愉快的方式解答用户的各种问题。&quot;)
            .defaultAdvisors(new SimpleLoggerAdvisor()) // 添加默认的Advisor,记录日志
            .defaultAdvisors(new MessageChatMemoryAdvisor(chatMemory))
            .build(); // 构建ChatClient实例

&#125;
</code></pre>
<h3 id="5-2-多模态对话"><a href="#5-2-多模态对话" class="headerlink" title="5.2.多模态对话"></a>5.2.多模态对话</h3><p>接下来，我们需要修改原来的<code>/ai/chat</code>接口，让它支持文件上传和多模态对话。</p>
<p>修改<code>ChatController</code>：</p>
<pre><code class="Java">package com.itheima.ai.controller;

import com.itheima.ai.repository.ChatHistoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.model.Media;
import org.springframework.util.MimeType;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import reactor.core.publisher.Flux;

import java.util.List;
import java.util.Objects;

import static org.springframework.ai.chat.client.advisor.AbstractChatMemoryAdvisor.CHAT_MEMORY_CONVERSATION_ID_KEY;

@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;/ai&quot;)
public class ChatController &#123;

    private final ChatClient chatClient;

    private final ChatHistoryRepository chatHistoryRepository;

    @RequestMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=utf-8&quot;)
    public Flux&lt;String&gt; chat(
            @RequestParam(&quot;prompt&quot;) String prompt,
            @RequestParam(&quot;chatId&quot;) String chatId,
            @RequestParam(value = &quot;files&quot;, required = false) List&lt;MultipartFile&gt; files) &#123;
        // 1.保存会话id
        chatHistoryRepository.save(&quot;chat&quot;, chatId);
        // 2.请求模型
        if (files == null || files.isEmpty()) &#123;
            // 没有附件，纯文本聊天
            return textChat(prompt, chatId);
        &#125; else &#123;
            // 有附件，多模态聊天
            return multiModalChat(prompt, chatId, files);
        &#125;

    &#125;

    private Flux&lt;String&gt; multiModalChat(String prompt, String chatId, List&lt;MultipartFile&gt; files) &#123;
        // 1.解析多媒体
        List&lt;Media&gt; medias = files.stream()
                .map(file -&gt; new Media(
                                MimeType.valueOf(Objects.requireNonNull(file.getContentType())),
                                file.getResource()
                        )
                )
                .toList();
        // 2.请求模型
        return chatClient.prompt()
                .user(p -&gt; p.text(prompt).media(medias.toArray(Media[]::new)))
                .advisors(a -&gt; a.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId))
                .stream()
                .content();
    &#125;

    private Flux&lt;String&gt; textChat(String prompt, String chatId) &#123;
        return chatClient.prompt()
                .user(prompt)
                .advisors(a -&gt; a.param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId))
                .stream()
                .content();
    &#125;
&#125;
</code></pre>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#00bcd4>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/07/08/AI/SpringAI-DeepSeek/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/07/08/AI/SpringAI-Alibaba/">
        <h2>
            SpringAI-Alibaba
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/7/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Spring-AI-Ailibaba简介"><a href="#Spring-AI-Ailibaba简介" class="headerlink" title="Spring AI Ailibaba简介"></a>Spring AI Ailibaba简介</h3><p>SpringAlAlibaba是基于SpringAI构建的框架，专注于与阿里云生态的深度集成。适合国内开发者，尤其是需要快速接入阿里云AI能力的场景。</p>
<p>LangChain4j是 LangChain项目的Java移植版本，专注于构建多模态、多参与者的AI应用，适合需要构建复杂AI工作流和多模态应用的开发者</p>
<blockquote>
<p>文档：<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/6810800f83d6ee240f5796b0">Spring AI Alibaba实战| ProcessOn免费在线作图,在线流程图,在线思维导图</a></p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://java2ai.com/?spm=5176.29160081.0.0.2856aa5cpGp7Py">Spring AI Alibaba 官网_快速构建 JAVA AI 应用</a></p>
<p>项目：<a target="_blank" rel="noopener" href="https://gitee.com/dongchenglin/ai-demo">ai-demo: 本项目围绕 Spring AI Alibaba 技术栈打造实战课程《Spring AI Alibaba 从入门到进阶实战》，由 Fox 精心开发。课程从基础入门到深度实战，覆盖 Spring AI Alibaba 核心原理、大模型（含本地与云端，如 Ollama、通义千问 ）集成、多模态功能（文生图、语音交互 ）、RAG 架构、Function Calling、MCP 协议等关键技术，更通过电商智</a></p>
</blockquote>
<p>[<u>Spring AI Alibaba 官网_快速构建 JAVA AI 应用</u>] (<a target="_blank" rel="noopener" href="http://java2ai.com/">http://java2ai.com/</a>)</p>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul>
<li>模型(Model)</li>
<li>提示（Prompt）</li>
<li>嵌入（Embedding）</li>
<li>Token</li>
<li>结构化输出(Structured Output)</li>
<li>微调（Fine Tuning）</li>
<li>检索增强生成（RAG）</li>
<li>函数调用（Function Calling)</li>
<li>评估人工智能的回答(Evaluation)</li>
</ul>
<h5 id="同步接口实现"><a href="#同步接口实现" class="headerlink" title="同步接口实现"></a>同步接口实现</h5><pre><code class="java">  @GetMapping(&quot;/chat&quot;)
    public String chat(@RequestParam String input) &#123;
        return chatClient.prompt().user(input).call().content();
    &#125;
</code></pre>
<h5 id="流式响应实现"><a href="#流式响应实现" class="headerlink" title="流式响应实现"></a>流式响应实现</h5><pre><code class="java">   @GetMapping(value = &quot;/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; stream(String input) &#123;
        return this.chatClient.prompt()
                .user(input)
                .stream()
                .content();
    &#125;
</code></pre>
<h4 id="ChatClient"><a href="#ChatClient" class="headerlink" title="ChatClient"></a>ChatClient</h4><p><strong>作用</strong>：通过 ChatClient，开发者可以更专注于业务逻辑而非底层协调，显著提升基于 LLM 的应用开发效率。<br><strong>适用场景</strong>：快速开发：适合需要快速构建端到端 AI 交互的应用（如聊天机器人、问答系统）。复杂流程封装：当需要协调多个组件（如 LLM + 记忆 + 工具）时，减少样板代码。</p>
<h5 id="返回实体类-entity"><a href="#返回实体类-entity" class="headerlink" title="返回实体类  .entity"></a>返回实体类  <code>.entity</code></h5><pre><code class="java">    @GetMapping(&quot;/movies&quot;)
    public ActorFilms movies(@RequestParam(value = &quot;input&quot;) String input) throws Exception &#123;
        return this.chatClient.prompt()
                .user(input)
                .call()
                .entity(ActorFilms.class);
    &#125;

curl --location --request GET &#39;http://localhost:1000/movies&#39; \
--header &#39;User-Agent: Apifox/1.0.0 (https://apifox.com)&#39; \
--header &#39;Content-Type: application/json&#39;
</code></pre>
<h5 id="指定消息角色-defaultSystem"><a href="#指定消息角色-defaultSystem" class="headerlink" title="指定消息角色  .defaultSystem"></a>指定消息角色  <code>.defaultSystem</code></h5><pre><code class="java">    public ChatController(ChatClient.Builder builder) &#123;
        this.chatClient = builder
                .defaultSystem(&quot;你是一个演员，请列出你所参演的电影&quot;)
                .build();
    &#125;
    @GetMapping(&quot;/chat&quot;)
    public String chat(@RequestParam(value = &quot;input&quot;) String input) &#123;

        return this.chatClient.prompt()
                .user(input)
                .call()
                .content();
    &#125;


curl --location --request GET &#39;http://localhost:1000/chat&#39; \
--header &#39;User-Agent: Apifox/1.0.0 (https://apifox.com)&#39; \
--header &#39;Content-Type: application/json&#39;
</code></pre>
<pre><code class="java">package com.fox.alibabaaidemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
public  class AIController &#123;
      private final ChatClient chatClient;
    public AIController(ChatClient.Builder builder) &#123;
        this.chatClient =  builder
                .defaultSystem(&quot;你是一个友好的聊天机器人，回答问题时要使用&#123;voice&#125;的语气&quot;)
                .build();
    &#125;
      @GetMapping(&quot;/ai&quot;)
      Map&lt;String, String&gt; completion(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;说一个笑话&quot;) String message, String voice) &#123;
        return Map.of(
            &quot;completion&quot;,
            this.chatClient.prompt()
                .system(sp -&gt; sp.param(&quot;voice&quot;, voice))
                .user(message)
                .call()
                .content());
      &#125;
    &#125;

GET：http://localhost:1000/ai
voice  沈腾
</code></pre>
<h3 id="其他默认设置"><a href="#其他默认设置" class="headerlink" title="其他默认设置"></a>其他默认设置</h3><p>除了 <code>defaultSystem</code> 之外，您还可以在 <code>ChatClient.Builder</code> 级别上指定其他默认提示。</p>
<ul>
<li><code>defaultOptions(ChatOptions chatOptions)</code>：传入 <code>ChatOptions</code> 类中定义的可移植选项或特定于模型实现的如 <code>DashScopeChatOptions</code> 选项。有关特定于模型的<code>ChatOptions</code>实现的更多信息，请参阅 JavaDocs。</li>
<li><code>defaultFunction(String name, String description, java.util.function.Function&lt;I, O&gt; function)</code>：<code>name</code> 用于在用户文本中引用该函数，<code>description</code>解释该函数的用途并帮助 AI 模型选择正确的函数以获得准确的响应，参数 <code>function</code> 是模型将在必要时执行的 Java 函数实例。</li>
<li><code>defaultFunctions(String... functionNames)</code>：应用程序上下文中定义的 java.util.Function 的 bean 名称。</li>
<li><code>defaultUser(String text)</code>、<code>defaultUser(Resource text)</code>、<code>defaultUser(Consumer&lt;UserSpec&gt; userSpecConsumer)</code> 这些方法允许您定义用户消息输入，<code>Consumer&lt;UserSpec&gt;</code>允许您使用 lambda 指定用户消息输入和任何默认参数。</li>
<li><code>defaultAdvisors(RequestResponseAdvisor... advisor)</code>：Advisors 允许修改用于创建 <code>Prompt</code> 的数据，<code>QuestionAnswerAdvisor</code> 实现通过在 Prompt 中附加与用户文本相关的上下文信息来实现 <code>Retrieval Augmented Generation</code> 模式。</li>
<li><code>defaultAdvisors(Consumer&lt;AdvisorSpec&gt; advisorSpecConsumer)</code>：此方法允许您定义一个 <code>Consumer</code> 并使用 <code>AdvisorSpec</code> 配置多个 Advisor，Advisor 可以修改用于创建 <code>Prompt</code> 的最终数据，<code>Consumer&lt;AdvisorSpec&gt;</code> 允许您指定 lambda 来添加 Advisor 例如 <code>QuestionAnswerAdvisor</code>。</li>
</ul>
<p>您可以在运行时使用 <code>ChatClient</code> 提供的不带 <code>default</code> 前缀的相应方法覆盖这些默认值。</p>
<ul>
<li><p><code>options(ChatOptions chatOptions)</code></p>
</li>
<li><p><code>function(String name, String description, java.util.function.Function&lt;I, O&gt; function)</code></p>
</li>
<li><p><code>functions(String... functionNames)</code></p>
</li>
<li><p><code>user(String text)</code>、<code>user(Resource text)</code>、<code>user(Consumer&lt;UserSpec&gt; userSpecConsumer)</code></p>
</li>
<li><p><code>advisors(RequestResponseAdvisor... advisor)</code></p>
</li>
<li><p><code>advisors(Consumer&lt;AdvisorSpec&gt; advisorSpecConsumer)</code></p>
</li>
</ul>
<h2 id="【基于内存存储】多轮对话记忆管理对话记忆"><a href="#【基于内存存储】多轮对话记忆管理对话记忆" class="headerlink" title="【基于内存存储】多轮对话记忆管理对话记忆"></a>【基于内存存储】多轮对话记忆管理<del>对话记忆</del></h2><h5 id="对话模型-Chat-Model"><a href="#对话模型-Chat-Model" class="headerlink" title="对话模型(Chat Model)"></a>对话模型(Chat Model)</h5><p>对话模型（Chat Model）接收一系列消息（Message）作为输入，与模型 LLM 服务进行交互，并接收返回的聊天消息（Chat Message）作为输出。相比于普通的程序输入，模型的输入与输出消息（Message）不止支持纯字符文本，还支持包括语音、图片、视频等作为输入输出。同时，在 Spring AI Alibaba 中，消息中还支持包含不同的角色，帮助底层模型区分来自模型、用户和系统指令等的不同消息。</p>
<p>Spring AI Alibaba 复用了 Spring AI 抽象的 Model API，并与通义系列大模型服务进行适配（如通义千问、通义万相等），目前支持纯文本聊天、文生图、文生语音、语音转文本等。以下是框架定义的几个核心 API：</p>
<ul>
<li>ChatModel，文本聊天交互模型，支持纯文本格式作为输入，并将模型的输出以格式化文本形式返回。</li>
<li>ImageModel，接收用户文本输入，并将模型生成的图片作为输出返回。</li>
<li>AudioModel，接收用户文本输入，并将模型合成的语音作为输出返回。</li>
</ul>
<p>Spring AI Alibaba 支持以上 Model 抽象与通义系列模型的适配，并通过 <code>spring-ai-alibaba-starter</code> AutoConfiguration 自动初始化了默认实例，因此我们可以在应用程序中直接注入 ChatModel、ImageModel 等 bean，当然在需要的时候也可以自定义 Model 实例。</p>
<h5 id="对话记忆介绍"><a href="#对话记忆介绍" class="headerlink" title="对话记忆介绍"></a>对话记忆介绍</h5><p>”大模型的对话记忆”这一概念，根植于人工智能与自然语言处理领域，特别是针对具有深度学习能力的大型语言模型而言，它指的是模型在与用户进行交互式对话过程中，能够追踪、理解并利用先前对话上下文的能力。 此机制使得大模型不仅能够响应即时的输入请求，还能基于之前的交流内容能够在对话中记住先前的对话内容，并根据这些信息进行后续的响应。这种记忆机制使得模型能够在对话中持续跟踪和理解用户的意图和上下文，从而实现更自然和连贯的对话。</p>
<p>我们在调用大模型的过程中，如果自己维护多轮的对话记忆，通常情况下调用代码如下</p>
<pre><code class="java">import java.util.ArrayList;

List&lt;Message&gt; messages = new ArrayList&lt;&gt;();

//第一轮对话
messages.add(new SystemMessage(&quot;你是一个旅游规划师&quot;));
messages.add(new UserMessage(&quot;我想去新疆&quot;));
ChatResponse response = chatModel.call(new Prompt(messages));
String content = response.getResult().getOutput().getContent();

messages.add(new AssistantMessage(content));

        //第二轮对话
messages.add(new UserMessage(&quot;能帮我推荐一些旅游景点吗?&quot;));
response = chatModel.call(new Prompt(messages));
content = response.getResult().getOutput().getContent();

messages.add(new AssistantMessage(content));

        //第三轮对话
messages.add(new UserMessage(&quot;那里这两天的天气如何?&quot;));
response = chatModel.call(new Prompt(messages));
content = response.getResult().getOutput().getContent();

System.out.printf(&quot;content: %s\n&quot;, content);
</code></pre>
<h2 id="基于memory的对话记忆advisors是增强器"><a href="#基于memory的对话记忆advisors是增强器" class="headerlink" title="基于memory的对话记忆advisors是增强器"></a>基于memory的对话记忆<del>advisors是增强器</del></h2><p>如何让大模型有对话记忆呢？<br><code>Advisor(MessageChatMemoryAdvisor)、Memory(InMemoryChatMemory,RedisChatMemory)</code><br>使用ChatMemoryAdvisor与RedisChatMemory存储历史对话 </p>
<pre><code class="yaml">ChatClient.builder(chatModel)
  .defaultAdvisors(new MessageChatMemoryAdvisor(redisChatMemory))
  .build();
</code></pre>
<p>spring-ai-alibaba支持基于chat memory的对话记忆，也就是不需要调用显示的记录每一轮的对话历史。下边是一个基于内存存储的对话记忆实现:</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;/chat-memory&quot;)
public class ChatMemoryController &#123;

    private final ChatClient chatClient;

    public ChatMemoryController(ChatModel chatModel) &#123;
// 构建对话模型 基于内存的方式InMemory...
        this.chatClient = ChatClient
                .builder(chatModel)
                .defaultSystem(&quot;你是一个旅游规划师，请根据用户的需求提供旅游规划建议。&quot;)
                .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
//                .defaultAdvisors(new MessageChatMemoryAdvisor(new RedisChatMemory(
//                        &quot;127.0.0.1&quot;,
//                        6379,
//                        null
//                )))
                .build();
    &#125;

    /**
     * 获取内存中的聊天内容
     * 根据提供的prompt和chatId，从内存中获取相关的聊天内容，并设置响应的字符编码为UTF-8。
     *
     * @param prompt 用于获取聊天内容的提示信息
     * @param chatId 聊天的唯一标识符，用于区分不同的聊天会话
     * @param response HTTP响应对象，用于设置响应的字符编码
     * @return 返回包含聊天内容的Flux&lt;String&gt;对象
     */
    @GetMapping(&quot;/in-memory&quot;)
    public Flux&lt;String&gt; memory(
            @RequestParam(&quot;prompt&quot;) String prompt,
            @RequestParam(&quot;chatId&quot;) String chatId,
            HttpServletResponse response
    ) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return chatClient.prompt(prompt).advisors(
                a -&gt; a
                        .param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)
                        .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 100)
        ).stream().content();
    &#125;

GET：http://localhost:1000/chat-memory/in-memory
prompt  我想去新疆玩
chatId  Pluminary
</code></pre>
<blockquote>
<h1 id="One【我想去新疆玩】"><a href="#One【我想去新疆玩】" class="headerlink" title="One【我想去新疆玩】"></a>One【我想去新疆玩】</h1><p>太棒了！新疆是中国最美丽、最多元化的旅游目的地之一，拥有壮丽的自然风光、丰富的民族文化和悠久的历史遗迹。根据你的兴趣和时间安排，我可以为你量身定制一份详细的旅行计划。</p>
<p>以下是一份 <strong>7天经典新疆旅游路线推荐</strong>，适合第一次来新疆的游客：</p>
<hr>
<h3 id="🌄-7天经典新疆旅游线路（北疆线）"><a href="#🌄-7天经典新疆旅游线路（北疆线）" class="headerlink" title="🌄 7天经典新疆旅游线路（北疆线）"></a>🌄 7天经典新疆旅游线路（北疆线）</h3><h4 id="✅-路线概览："><a href="#✅-路线概览：" class="headerlink" title="✅ 路线概览："></a>✅ 路线概览：</h4><p>乌鲁木齐 → 天池 → 乌鲁木齐 → 奎屯 → 赛里木湖 → 果子沟 → 伊宁 → 那拉提草原 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</p>
<hr>
<h3 id="📅-行程详情："><a href="#📅-行程详情：" class="headerlink" title="📅 行程详情："></a>📅 行程详情：</h3><h4 id="第1天：抵达乌鲁木齐"><a href="#第1天：抵达乌鲁木齐" class="headerlink" title="第1天：抵达乌鲁木齐"></a>第1天：抵达乌鲁木齐</h4><ul>
<li>抵达乌鲁木齐地窝堡国际机场或火车站。</li>
<li>游览【国际大巴扎】，购买当地特产与手工艺品。</li>
<li>晚上可品尝新疆特色美食：大盘鸡、烤包子、羊肉串等。</li>
</ul>
<h4 id="第2天：乌鲁木齐-→-天山天池-→-返回乌鲁木齐"><a href="#第2天：乌鲁木齐-→-天山天池-→-返回乌鲁木齐" class="headerlink" title="第2天：乌鲁木齐 → 天山天池 → 返回乌鲁木齐"></a>第2天：乌鲁木齐 → 天山天池 → 返回乌鲁木齐</h4><ul>
<li>上午驱车前往【天山天池】，欣赏雪山、湖泊、松林交相辉映的美景。</li>
<li>下午返回市区，参观【新疆博物馆】了解西域历史文化。</li>
<li>可尝试维吾尔族风味晚餐。</li>
</ul>
<h4 id="第3天：乌鲁木齐-→-奎屯-→-赛里木湖"><a href="#第3天：乌鲁木齐-→-奎屯-→-赛里木湖" class="headerlink" title="第3天：乌鲁木齐 → 奎屯 → 赛里木湖"></a>第3天：乌鲁木齐 → 奎屯 → 赛里木湖</h4><ul>
<li>乘车约6小时到达【赛里木湖】，被誉为“大西洋最后一滴眼泪”。</li>
<li>环湖游览，拍摄湖光山色，入住湖边民宿或附近酒店。</li>
</ul>
<h4 id="第4天：赛里木湖-→-伊宁"><a href="#第4天：赛里木湖-→-伊宁" class="headerlink" title="第4天：赛里木湖 → 伊宁"></a>第4天：赛里木湖 → 伊宁</h4><ul>
<li>沿果子沟峡谷前行，穿越【果子沟大桥】，风景绝佳。</li>
<li>到达伊宁市后，游览【喀赞其民俗区】，感受浓郁的维吾尔族风情。</li>
<li>住伊宁。</li>
</ul>
<h4 id="第5天：伊宁-→-那拉提草原"><a href="#第5天：伊宁-→-那拉提草原" class="headerlink" title="第5天：伊宁 → 那拉提草原"></a>第5天：伊宁 → 那拉提草原</h4><ul>
<li>乘车约3小时到达【那拉提草原】，是新疆最美的高山草甸之一。</li>
<li>骑马、徒步、摄影，体验草原牧民生活。</li>
<li>住那拉提镇。</li>
</ul>
<h4 id="第6天：那拉提-→-巴音布鲁克-→-独库公路-→-乌鲁木齐"><a href="#第6天：那拉提-→-巴音布鲁克-→-独库公路-→-乌鲁木齐" class="headerlink" title="第6天：那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐"></a>第6天：那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</h4><ul>
<li>驱车前往【巴音布鲁克草原】，探访著名的“九曲十八弯”开都河。</li>
<li>沿【独库公路】北段返回乌鲁木齐，途中穿越天山山脉，风景震撼。</li>
<li>全天行车时间较长（约8-10小时），建议提前准备干粮和水。</li>
</ul>
<h4 id="第7天：乌鲁木齐-→-返程"><a href="#第7天：乌鲁木齐-→-返程" class="headerlink" title="第7天：乌鲁木齐 → 返程"></a>第7天：乌鲁木齐 → 返程</h4><ul>
<li>根据航班&#x2F;火车时间安排返程。</li>
<li>可在市区再次购物或补拍未尽兴的景点。</li>
</ul>
<hr>
<h3 id="💡-小贴士："><a href="#💡-小贴士：" class="headerlink" title="💡 小贴士："></a>💡 小贴士：</h3><ul>
<li><strong>最佳旅游季节</strong>：每年6月-10月是新疆的最佳旅游季节，气候宜人，风景最美。</li>
<li><strong>交通方式</strong>：<ul>
<li>自驾游是探索新疆最好的方式，路况较好。</li>
<li>若不自驾，也可以选择包车或参加当地品质团。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>新疆昼夜温差大，注意带好保暖衣物。</li>
<li>注意防晒，紫外线较强。</li>
<li>尊重少数民族风俗习惯，避免敏感话题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🍽️-必吃美食推荐："><a href="#🍽️-必吃美食推荐：" class="headerlink" title="🍽️ 必吃美食推荐："></a>🍽️ 必吃美食推荐：</h3><ul>
<li>烤包子</li>
<li>手抓饭</li>
<li>羊肉串</li>
<li>盘吉尔塔格麻饼</li>
<li>牛骨头汤</li>
<li>新疆酸奶+馕</li>
</ul>
<hr>
<p>如果你有更长的时间，还可以考虑延伸到南疆（喀什、塔克拉玛干沙漠、帕米尔高原）或者北疆深度游（可可托海、喀纳斯、禾木）。</p>
<p>你可以告诉我：</p>
<ul>
<li>出行时间</li>
<li>同行人数</li>
<li>是否自驾</li>
<li>是否希望加入人文历史或摄影元素</li>
</ul>
<p>我可以为你定制更详细的行程、住宿推荐和预算方案哦！</p>
<h1 id="Tow-prompt：有哪些好玩的地方？"><a href="#Tow-prompt：有哪些好玩的地方？" class="headerlink" title="Tow [prompt：有哪些好玩的地方？]"></a>Tow [prompt：有哪些好玩的地方？]</h1><p>当然可以！作为一个旅游规划师，我会根据不同的旅行兴趣、时间和预算，为你推荐新疆最值得一去的<strong>好玩地方</strong>。新疆地大景美，玩法多样，既有自然风光，也有浓郁的民族风情和历史人文。</p>
<hr>
<h2 id="🌄-新疆十大必玩景点推荐（按类型分类）"><a href="#🌄-新疆十大必玩景点推荐（按类型分类）" class="headerlink" title="🌄 新疆十大必玩景点推荐（按类型分类）"></a>🌄 新疆十大必玩景点推荐（按类型分类）</h2><h3 id="一、自然风光类"><a href="#一、自然风光类" class="headerlink" title="一、自然风光类"></a>一、自然风光类</h3><h4 id="1-喀纳斯湖景区"><a href="#1-喀纳斯湖景区" class="headerlink" title="1. 喀纳斯湖景区"></a>1. <strong>喀纳斯湖景区</strong></h4><ul>
<li><strong>关键词</strong>：神秘湖怪、变色湖、图瓦人村落</li>
<li><strong>推荐理由</strong>：被誉为“人间仙境”，四季皆美，秋季尤胜。</li>
<li><strong>适合人群</strong>：摄影爱好者、自然探险者</li>
</ul>
<h4 id="2-赛里木湖"><a href="#2-赛里木湖" class="headerlink" title="2. 赛里木湖"></a>2. <strong>赛里木湖</strong></h4><ul>
<li><strong>关键词</strong>：大西洋最后一滴眼泪、花海、湖光山色</li>
<li><strong>推荐理由</strong>：夏季油菜花盛开，湖水清澈见底，是北疆最美湖泊之一。</li>
</ul>
<h4 id="3-那拉提草原"><a href="#3-那拉提草原" class="headerlink" title="3. 那拉提草原"></a>3. <strong>那拉提草原</strong></h4><ul>
<li><strong>关键词</strong>：空中草原、骑马、牧民风情</li>
<li><strong>推荐理由</strong>：夏季草原如画，适合徒步、骑马、拍照。</li>
</ul>
<h4 id="4-巴音布鲁克草原-amp-九曲十八弯"><a href="#4-巴音布鲁克草原-amp-九曲十八弯" class="headerlink" title="4. 巴音布鲁克草原 &amp; 九曲十八弯"></a>4. <strong>巴音布鲁克草原 &amp; 九曲十八弯</strong></h4><ul>
<li><strong>关键词</strong>：天鹅故乡、开都河九曲、日落绝美</li>
<li><strong>推荐理由</strong>：中国第二大草原，电影《飞驰人生》取景地。</li>
</ul>
<h4 id="5-独库公路"><a href="#5-独库公路" class="headerlink" title="5. 独库公路"></a>5. <strong>独库公路</strong></h4><ul>
<li><strong>关键词</strong>：天山之路、一日四季、自驾天堂</li>
<li><strong>推荐理由</strong>：被誉为“中国最美景观大道”，连接南北疆。</li>
</ul>
<hr>
<h3 id="二、历史文化类"><a href="#二、历史文化类" class="headerlink" title="二、历史文化类"></a>二、历史文化类</h3><h4 id="6-交河故城-amp-高昌故城"><a href="#6-交河故城-amp-高昌故城" class="headerlink" title="6. 交河故城 &amp; 高昌故城"></a>6. <strong>交河故城 &amp; 高昌故城</strong></h4><ul>
<li><strong>关键词</strong>：丝绸之路遗迹、千年古城</li>
<li><strong>推荐理由</strong>：感受古代西域文明的辉煌与沧桑。</li>
</ul>
<h4 id="7-克孜尔千佛洞"><a href="#7-克孜尔千佛洞" class="headerlink" title="7. 克孜尔千佛洞"></a>7. <strong>克孜尔千佛洞</strong></h4><ul>
<li><strong>关键词</strong>：佛教艺术瑰宝、壁画、石窟群</li>
<li><strong>推荐理由</strong>：比敦煌莫高窟更早开凿，艺术价值极高。</li>
</ul>
<h4 id="8-香妃墓（阿帕克霍加墓）"><a href="#8-香妃墓（阿帕克霍加墓）" class="headerlink" title="8. 香妃墓（阿帕克霍加墓）"></a>8. <strong>香妃墓（阿帕克霍加墓）</strong></h4><ul>
<li><strong>关键词</strong>：爱情传说、伊斯兰建筑</li>
<li><strong>推荐理由</strong>：喀什最具代表性的古迹之一。</li>
</ul>
<hr>
<h3 id="三、民俗风情类"><a href="#三、民俗风情类" class="headerlink" title="三、民俗风情类"></a>三、民俗风情类</h3><h4 id="9-喀什老城（艾提尕尔清真寺）"><a href="#9-喀什老城（艾提尕尔清真寺）" class="headerlink" title="9. 喀什老城（艾提尕尔清真寺）"></a>9. <strong>喀什老城（艾提尕尔清真寺）</strong></h4><ul>
<li><strong>关键词</strong>：维吾尔族风情、夜市、手工艺</li>
<li><strong>推荐理由</strong>：南疆文化中心，充满异域风情。</li>
</ul>
<h4 id="10-塔克拉玛干沙漠-x2F-塔中沙漠公路"><a href="#10-塔克拉玛干沙漠-x2F-塔中沙漠公路" class="headerlink" title="10. 塔克拉玛干沙漠 &#x2F; 塔中沙漠公路"></a>10. <strong>塔克拉玛干沙漠 &#x2F; 塔中沙漠公路</strong></h4><ul>
<li><strong>关键词</strong>：死亡之海、星空露营、越野挑战</li>
<li><strong>推荐理由</strong>：体验极限风光，感受荒漠中的壮美。</li>
</ul>
<hr>
<h2 id="🏞️-按线路推荐热门玩法"><a href="#🏞️-按线路推荐热门玩法" class="headerlink" title="🏞️ 按线路推荐热门玩法"></a>🏞️ 按线路推荐热门玩法</h2><table>
<thead>
<tr>
<th>线路类型</th>
<th>推荐景点</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>北疆经典线</td>
<td>天池、赛里木湖、那拉提、巴音布鲁克、独库公路</td>
<td>风景优美、适合首次来新疆</td>
</tr>
<tr>
<td>南疆深度线</td>
<td>喀什、塔克拉玛干沙漠、帕米尔高原、塔县、白沙湖</td>
<td>民俗浓郁、神秘原始</td>
</tr>
<tr>
<td>北疆深度线</td>
<td>喀纳斯、禾木、可可托海</td>
<td>秋季绝美、摄影圣地</td>
</tr>
<tr>
<td>自驾线路</td>
<td>独库公路、沙漠公路、喀纳斯环线</td>
<td>风景多变、自由灵活</td>
</tr>
</tbody></table>
<hr>
<h2 id="📅-根据时间长短推荐玩法"><a href="#📅-根据时间长短推荐玩法" class="headerlink" title="📅 根据时间长短推荐玩法"></a>📅 根据时间长短推荐玩法</h2><table>
<thead>
<tr>
<th>时间安排</th>
<th>推荐行程</th>
</tr>
</thead>
<tbody><tr>
<td>5-7天</td>
<td>北疆经典线：乌鲁木齐 → 赛里木湖 → 那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</td>
</tr>
<tr>
<td>8-10天</td>
<td>北疆+南疆组合：乌鲁木齐 → 喀纳斯 → 那拉提 → 伊宁 → 喀什 → 帕米尔高原</td>
</tr>
<tr>
<td>10天以上</td>
<td>全疆深度游：涵盖北疆、南疆、东疆，体验多元文化与极致风光</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-小贴士：如何选择适合你的路线？"><a href="#🎯-小贴士：如何选择适合你的路线？" class="headerlink" title="🎯 小贴士：如何选择适合你的路线？"></a>🎯 小贴士：如何选择适合你的路线？</h2><ol>
<li><strong>喜欢自然风光？</strong> → 喀纳斯、赛里木湖、那拉提</li>
<li><strong>喜欢人文历史？</strong> → 交河故城、克孜尔千佛洞、喀什老城</li>
<li><strong>喜欢冒险刺激？</strong> → 塔克拉玛干沙漠、独库公路自驾</li>
<li><strong>喜欢摄影？</strong> → 喀纳斯秋景、巴音布鲁克日落、帕米尔高原星空</li>
<li><strong>亲子出游？</strong> → 乌鲁木齐博物馆、天山天池、那拉提草原</li>
</ol>
<hr>
<p>如果你能告诉我以下信息，我可以帮你定制专属行程：</p>
<ul>
<li>出行时间（几月份）</li>
<li>出行人数（是否带老人&#x2F;小孩）</li>
<li>是否自驾或包车</li>
<li>偏好自然&#x2F;人文&#x2F;美食&#x2F;摄影等哪一类</li>
<li>预算范围（经济型&#x2F;舒适型&#x2F;豪华型）</li>
</ul>
<p>期待你的回复，我将为你打造一份<strong>专属新疆旅行计划</strong>！✨</p>
</blockquote>
<p>当然，开发者也可以自行实现ChatMemory基于类似于文件、Redis等方式进行上下文内容的存储和记录。</p>
<h2 id="【基于Redis存储】多轮对话记忆管理对话记忆"><a href="#【基于Redis存储】多轮对话记忆管理对话记忆" class="headerlink" title="【基于Redis存储】多轮对话记忆管理对话记忆"></a>【基于Redis存储】多轮对话记忆管理<del>对话记忆</del></h2><p>这里Redis的官方依赖有问题 需要自己修改再去使用 不算得上是重构 要去重写建立新的<br>可以将下面的打成包 使用的时候只需要引入依赖即可</p>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\my-redis-memory\src\main\java\com\fox\myredismemory\RedisChatMemory.java
package com.fox.myredismemory;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.messages.UserMessage;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;

/**
 *
 * 基于Redis的聊天记忆实现。
 * 该类实现了ChatMemory接口，提供了将聊天消息存储到Redis中的功能。
 *
 * @author Fox
 */
public class RedisChatMemory implements ChatMemory, AutoCloseable &#123;

    private static final Logger logger = LoggerFactory.getLogger(RedisChatMemory.class);

    private static final String DEFAULT_KEY_PREFIX = &quot;chat:&quot;;

    private static final String DEFAULT_HOST = &quot;127.0.0.1&quot;;

    private static final int DEFAULT_PORT = 6379;

    private static final String DEFAULT_PASSWORD = null;

    private final JedisPool jedisPool;


    private final ObjectMapper objectMapper;

    public RedisChatMemory() &#123;

        this(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_PASSWORD);
    &#125;

    public RedisChatMemory(String host, int port, String password) &#123;

        JedisPoolConfig poolConfig = new JedisPoolConfig();

        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, password);
        this.objectMapper = new ObjectMapper();
        logger.info(&quot;Connected to Redis at &#123;&#125;:&#123;&#125;&quot;, host, port);
    &#125;

    @Override
    public void add(String conversationId, List&lt;Message&gt; messages) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        AtomicLong timestamp = new AtomicLong(System.currentTimeMillis());

        try (Jedis jedis = jedisPool.getResource()) &#123;
            // 使用pipeline批量操作提升性能
            var pipeline = jedis.pipelined();
            messages.forEach(message -&gt;
                    pipeline.hset(key, String.valueOf(timestamp.getAndIncrement()), message.toString())
            );
            pipeline.sync();
        &#125;

        logger.info(&quot;Added messages to conversationId: &#123;&#125;&quot;, conversationId);
    &#125;

    @Override
    public List&lt;Message&gt; get(String conversationId, int lastN) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        try (Jedis jedis = jedisPool.getResource()) &#123;
            Map&lt;String, String&gt; allMessages = jedis.hgetAll(key);
            if (allMessages.isEmpty()) &#123;
                return List.of();
            &#125;

            return allMessages.entrySet().stream()
                    .sorted((e1, e2) -&gt;
                            Long.compare(Long.parseLong(e2.getKey()), Long.parseLong(e1.getKey()))
                    )
                    .limit(lastN)
                    .map(entry -&gt; new UserMessage(entry.getValue()))
                    .collect(Collectors.toList());
        &#125;


    &#125;

    @Override
    public void clear(String conversationId) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        try (Jedis jedis = jedisPool.getResource()) &#123;
            jedis.del(key);
        &#125;
        logger.info(&quot;Cleared messages for conversationId: &#123;&#125;&quot;, conversationId);
    &#125;

    @Override
    public void close() &#123;
        try (Jedis jedis = jedisPool.getResource()) &#123;
            if (jedis != null) &#123;

                jedis.close();

                logger.info(&quot;Redis connection closed.&quot;);
            &#125;
            if (jedisPool != null) &#123;

                jedisPool.close();

                logger.info(&quot;Jedis pool closed.&quot;);
            &#125;
        &#125;

    &#125;

    public void clearOverLimit(String conversationId, int maxLimit, int deleteSize) &#123;
        try &#123;
            String key = DEFAULT_KEY_PREFIX + conversationId;
            try (Jedis jedis = jedisPool.getResource()) &#123;
                List&lt;String&gt; all = jedis.lrange(key, 0, -1);

                if (all.size() &gt;= maxLimit) &#123;
                    all = all.stream().skip(Math.max(0, deleteSize)).toList();
                &#125;
                this.clear(conversationId);
                for (String message : all) &#123;
                    jedis.rpush(key, message);
                &#125;
            &#125;
        &#125;
        catch (Exception e) &#123;
            logger.error(&quot;Error clearing messages from Redis chat memory&quot;, e);
            throw new RuntimeException(e);
        &#125;
    &#125;

&#125;
</code></pre>
<pre><code class="java">@RestController
@RequestMapping(&quot;/chat-memory&quot;)
public class ChatMemoryController &#123;

    private final ChatClient chatClient;

    public ChatMemoryController(ChatModel chatModel) &#123;
// 构建对话模型 基于内存的方式InMemory...
        this.chatClient = ChatClient
                .builder(chatModel)
                .defaultSystem(&quot;你是一个旅游规划师，请根据用户的需求提供旅游规划建议。&quot;)
//                .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
                .defaultAdvisors(new MessageChatMemoryAdvisor(new RedisChatMemory(
                        &quot;127.0.0.1&quot;,
                        6379,
                        null
                )))
                .build();
    &#125;

    
    /**
     * 从Redis中获取聊天内容
     * 根据提供的prompt和chatId，从Redis中检索聊天内容，并以Flux&lt;String&gt;的形式返回
     *
     * @param prompt 聊天内容的提示或查询关键字
     * @param chatId 聊天的唯一标识符，用于从Redis中检索特定的聊天内容
     * @param response HttpServletResponse对象，用于设置响应的字符编码为UTF-8
     * @return Flux&lt;String&gt; 包含聊天内容的反应式流
     */
    @GetMapping(&quot;/redis&quot;)
    public Flux&lt;String&gt; redis(
            @RequestParam(&quot;prompt&quot;) String prompt,
            @RequestParam(&quot;chatId&quot;) String chatId,
            HttpServletResponse response
    ) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);

        return chatClient.prompt(prompt)
                .advisors(
                a -&gt; a
                        .param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)
                        .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10)
                )
                .stream().content();
    &#125;

GET：http://localhost:1000/chat-memory/redis
prompt  有什么好吃的？
chatId  Pluminary
</code></pre>
<p>打开<code>Another Redis Desktop Manager</code>即可看见<code>Key</code>和<code>Value</code><br>这里也是基于上下文 第一个问题是我想去三亚 第二个问题有什么好吃的<del>这里是基于第一个问题和回答去输出结果</del></p>
<pre><code class="java">Key：1752192461656
Value：UserMessage&#123;content=&#39;我想去三亚&#39;, properties=&#123;messageType=USER&#125;, messageType=USER&#125;
</code></pre>
<h3 id="ChatModel对话模型"><a href="#ChatModel对话模型" class="headerlink" title="ChatModel对话模型"></a>ChatModel对话模型</h3><p><code>ChatResponse</code>里面是对话的json响应类</p>
<pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.chat.DashScopeChatOptions;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.io.IOException;

@RestController
public class ChatModelController &#123;
    private final ChatModel chatModel;

    public ChatModelController(@Qualifier(&quot;dashscopeChatModel&quot;) ChatModel chatModel) &#123;
        this.chatModel = chatModel;
    &#125;

    @RequestMapping(&quot;/chat2&quot;)
    public String chat2(String input) &#123;

        DashScopeChatOptions options = DashScopeChatOptions.builder()
                .withTemperature(0.9)
                .withMaxToken(1500)
           //     .withTopP(0.01)
                .build();

        Prompt prompt = new Prompt(input, options);
        ChatResponse response = chatModel.call(prompt);
        //ChatResponse response = chatModel.call(new Prompt(input));
        return response.getResult().getOutput().getText();
    &#125;


    @RequestMapping(&quot;/streamChat&quot;)
    public Flux&lt;String&gt; streamChat(String input, HttpServletResponse response) throws IOException &#123;
        response.setContentType(&quot;text/event-stream&quot;);
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return chatModel.stream(input);
    &#125;
&#125;

GET：http://localhost:1000/chat2
input  我想去深圳，帮我做个规划
</code></pre>
<h3 id="ImageModel实现文生图"><a href="#ImageModel实现文生图" class="headerlink" title="ImageModel实现文生图"></a>ImageModel实现文生图</h3><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.image.DashScopeImageOptions;
import org.springframework.ai.image.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ImageModelController &#123;
    private final ImageModel imageModel;

    ImageModelController(@Qualifier(&quot;dashScopeImageModel&quot;) ImageModel imageModel) &#123;
        this.imageModel = imageModel;
    &#125;

    @RequestMapping(&quot;/image&quot;)
    public String image(String input) &#123;
        ImageOptions options = ImageOptionsBuilder.builder()
                .model(&quot;wanx2.1-t2i-turbo&quot;)
                .height(1024)
                .width(1024)
                .build();

        ImagePrompt imagePrompt = new ImagePrompt(input, options);
        ImageResponse response = imageModel.call(imagePrompt);
        String imageUrl = response.getResult().getOutput().getUrl();

        return &quot;redirect:&quot; + imageUrl;
    &#125;
&#125;

GET：http://localhost:1000/image
input  森林中的绝美精灵，手里拿着弓

</code></pre>
<h3 id="AudioModel文生语音-amp-语音转文本"><a href="#AudioModel文生语音-amp-语音转文本" class="headerlink" title="AudioModel文生语音&amp;语音转文本"></a>AudioModel文生语音&amp;语音转文本</h3><h6 id="文本生成语音"><a href="#文本生成语音" class="headerlink" title="文本生成语音"></a>文本生成语音</h6><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionModel;
import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionOptions;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisModel;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisPrompt;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisResponse;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.ByteBuffer;

/**
 * @author: Fox
 * @Desc:
 **/
@RestController
@RequestMapping(&quot;/audio&quot;)
public class AudioModelController &#123;

    private final SpeechSynthesisModel speechSynthesisModel;

    @Autowired
    public AudioModelController(SpeechSynthesisModel speechSynthesisModel) &#123;
        this.speechSynthesisModel = speechSynthesisModel;
    &#125;

    @GetMapping(&quot;/synthesize&quot;)
    public ResponseEntity&lt;byte[]&gt; synthesizeSpeech(@RequestParam String text) throws IOException &#123;
        // 构建语音合成请求
        SpeechSynthesisPrompt prompt = new SpeechSynthesisPrompt(text);

        // 调用模型生成语音
        SpeechSynthesisResponse response = speechSynthesisModel.call(prompt);
        ByteBuffer audioData = response.getResult().getOutput().getAudio();

        // 将 ByteBuffer 转换为字节数组
        byte[] audioBytes = new byte[audioData.remaining()];
        audioData.get(audioBytes);

        // 返回音频流（MP3格式）
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(&quot;Content-Disposition&quot;, &quot;attachment; filename=output.mp3&quot;)
                .body(audioBytes);
    &#125;
&#125;

GET：http://localhost:1000/audio/synthesize
text  我真的太喜欢点赞啦
</code></pre>
<h5 id="语音生成文本"><a href="#语音生成文本" class="headerlink" title="语音生成文本"></a>语音生成文本</h5><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionModel;
import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionOptions;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.net.MalformedURLException;

/**
 * @author: Fox
 * @Desc:
 **/
@RestController
public class AudioModelController2 &#123;

    private static final String AUDIO_RESOURCES_URL = &quot;https://dashscope.oss-cn-beijing.aliyuncs.com/samples/audio/paraformer/hello_world_female2.wav&quot;;

    private final DashScopeAudioTranscriptionModel dashScopeAudioTranscriptionModel; //modelname:sensevoice-v1,paraformer-realtime-v2,paraformer-v2

    AudioModelController2(DashScopeAudioTranscriptionModel dashScopeAudioTranscriptionModel)&#123;
        this.dashScopeAudioTranscriptionModel = dashScopeAudioTranscriptionModel;
    &#125;

    @GetMapping(&quot;/audio&quot;)
    public String audio() throws MalformedURLException &#123;
        Resource resource =new UrlResource(AUDIO_RESOURCES_URL);

        AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(resource,
                DashScopeAudioTranscriptionOptions.builder()
                        .withModel(&quot;sensevoice-v1&quot;)
                        .build());

        return dashScopeAudioTranscriptionModel.call(prompt).getResult().getOutput();
    &#125;
&#125;

GET：http://localhost:1000/audio
</code></pre>
<h1 id="提示词-Prompt-create"><a href="#提示词-Prompt-create" class="headerlink" title="提示词 (Prompt).create"></a>提示词 (Prompt)<del>.create</del></h1><p>Prompt 是引导 AI 模型生成特定输出的输入格式，Prompt 的设计和措辞会显著影响模型的响应。</p>
<p>Prompt 最开始只是简单的字符串，随着时间的推移，prompt 逐渐开始包含特定的占位符，例如 AI 模型可以识别的 “USER:”、“SYSTEM:” 等。阿里云通义模型可通过将多个消息字符串分类为不同的角色，然后再由 AI 模型处理，为 prompt 引入了更多结构。每条消息都分配有特定的角色，这些角色对消息进行分类，明确 AI 模型提示的每个部分的上下文和目的。这种结构化方法增强了与 AI 沟通的细微差别和有效性，因为 prompt 的每个部分在交互中都扮演着独特且明确的角色。</p>
<p>Prompt 中的主要角色（Role）包括：</p>
<ul>
<li>系统角色（System Role）：指导 AI 的行为和响应方式，设置 AI 如何解释和回复输入的参数或规则。这类似于在发起对话之前向 AI 提供说明。</li>
<li>用户角色（User Role）：代表用户的输入 - 他们向 AI 提出的问题、命令或陈述。这个角色至关重要，因为它构成了 AI 响应的基础。</li>
<li>助手角色（Assistant Role）：AI 对用户输入的响应。这不仅仅是一个答案或反应，它对于保持对话的流畅性至关重要。通过跟踪 AI 之前的响应（其“助手角色”消息），系统可确保连贯且上下文相关的交互。助手消息也可能包含功能工具调用请求信息。它就像 AI 中的一个特殊功能，在需要执行特定功能（例如计算、获取数据或不仅仅是说话）时使用。</li>
<li>工具&#x2F;功能角色（Tool&#x2F;Function Role）：工具&#x2F;功能角色专注于响应工具调用助手消息返回附加信息。</li>
</ul>
<h5 id="API-概览"><a href="#API-概览" class="headerlink" title="API 概览"></a>API 概览</h5><h5 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h5><p>通常使用 ChatModel 的 call() 方法，该方法接受 Prompt 实例并返回 ChatResponse。</p>
<p>Prompt 类充当有组织的一系列 Message 对象和请求 ChatOptions 的容器。每条消息在提示中都体现了独特的角色，其内容和意图各不相同。这些角色可以包含各种元素，从用户查询到 AI 生成的响应再到相关背景信息。这种安排可以实现与 AI 模型的复杂而详细的交互，因为提示是由多条消息构成的，每条消息都被分配了在对话中扮演的特定角色。</p>
<p>该类实现的接口支持提示创建的不同方面：</p>
<p><strong>PromptTemplateStringActions</strong> 专注于创建和呈现提示字符串，代表提示生成的最基本形式。</p>
<p><strong>PromptTemplateMessageActions</strong> 专门用于通过生成和操作 Message 对象来创建提示。</p>
<p><strong>PromptTemplateActions</strong> 旨在返回 Prompt 对象，该对象可以传递给 ChatModel 以生成响应。</p>
<p>虽然这些接口可能在许多项目中没有得到广泛使用，但它们展示了创建提示的不同方法。</p>
<h6 id="实现ConfigurablePromptTemplateFactory"><a href="#实现ConfigurablePromptTemplateFactory" class="headerlink" title="实现ConfigurablePromptTemplateFactory"></a>实现ConfigurablePromptTemplateFactory</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\java\com\fox\promptdemo\config\PromptTemplateConfig.java

package com.fox.promptdemo.config;

import com.alibaba.cloud.ai.prompt.ConfigurablePromptTemplateFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PromptTemplateConfig &#123;

    @Bean
    public ConfigurablePromptTemplateFactory configurablePromptTemplateFactory() &#123;
        // 这里假设ConfigurablePromptTemplateFactory有一个无参构造函数
        return new ConfigurablePromptTemplateFactory();
        // 如果需要配置参数，可以在这里进行配置
        // return new ConfigurablePromptTemplateFactory(param1, param2);
    &#125;
&#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\java\com\fox\promptdemo\controller\PromptTemplateController.java
@GetMapping(&quot;/prompt-template&quot;)
    public AssistantMessage generate(
            @RequestParam(value = &quot;author&quot;, defaultValue = &quot;鲁迅&quot;) String author
    ) &#123;

        ConfigurablePromptTemplate template = configurablePromptTemplateFactory.getTemplate(&quot;test-template&quot;);

        if (template == null) &#123;
            template = configurablePromptTemplateFactory.create(&quot;test-template&quot;,
                    &quot;请列出 &#123;author&#125; 最著名的三本书。&quot;);
        &#125;

        Prompt prompt;
        if (StringUtils.hasText(author)) &#123;
            prompt = template.create(Map.of(&quot;author&quot;, author));
        &#125; else &#123;
            prompt = template.create();
        &#125;

        return chatClient.prompt(prompt)
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;

GET：http://localhost:10007/example/ai/prompt-template
author  鲁迅
</code></pre>
<h6 id="实现PromptTemplate"><a href="#实现PromptTemplate" class="headerlink" title="实现PromptTemplate"></a>实现PromptTemplate</h6><pre><code class="java">@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class PromptTemplateController &#123;

    private final ChatClient chatClient;

    private final ConfigurablePromptTemplateFactory configurablePromptTemplateFactory;
        
    // 这里的资源是以st文件类型放在了resources的prompts里面
    @Value(&quot;classpath:/prompts/joke-prompt.st&quot;)
    private Resource jokeResource;

    @GetMapping(&quot;/prompt&quot;)
    public AssistantMessage completion(
            @RequestParam(value = &quot;adjective&quot;, defaultValue = &quot;有趣&quot;) String adjective,
            @RequestParam(value = &quot;topic&quot;, defaultValue = &quot;奶牛&quot;) String topic
    ) &#123;

        PromptTemplate promptTemplate = new PromptTemplate(jokeResource);
        Prompt prompt = promptTemplate.create(Map.of(&quot;adjective&quot;, adjective, &quot;topic&quot;, topic));

        return chatClient.prompt(prompt)
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\joke-prompt.st
给我讲一个关于 &#123;topic&#125; 的 &#123;adjective&#125; 笑话

GET：http://localhost:10007/example/ai/prompt
adjective  有趣的
topic  猫
</code></pre>
<h6 id="实现SystemPromptTemplate"><a href="#实现SystemPromptTemplate" class="headerlink" title="实现SystemPromptTemplate"></a>实现SystemPromptTemplate</h6><pre><code class="java">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.promptdemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.SystemPromptTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class RoleController &#123;

    private final ChatClient chatClient;

    @Value(&quot;classpath:/prompts/system-message.st&quot;)
    private Resource systemResource;

    @Autowired
    public RoleController(ChatClient.Builder builder) &#123;
        this.chatClient = builder.build();
    &#125;
// defaultValue是没有传入时候的默认值
    @GetMapping(&quot;/roles&quot;)
    public AssistantMessage generate(
            @RequestParam(value = &quot;message&quot;,
            defaultValue = &quot;请介绍一下海盗黄金时代的三位著名海盗，以及他们为什么这样做。为每个海盗至少写一句话。&quot;) String message,
            @RequestParam(value = &quot;name&quot;, defaultValue = &quot;Fox&quot;) String name,
            @RequestParam(value = &quot;voice&quot;, defaultValue = &quot;海盗&quot;) String voice
    ) &#123;

        UserMessage userMessage = new UserMessage(message);

        SystemPromptTemplate systemPromptTemplate = new SystemPromptTemplate(systemResource);
        // .createMessage创建一个系统消息
        Message systemMessage = systemPromptTemplate.createMessage(Map.of(&quot;name&quot;, name, &quot;voice&quot;, voice));

        return chatClient.prompt(new Prompt(List.of(userMessage, systemMessage)))
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;
&#125;

GET：http://localhost:10007/example/ai/roles
name  Pluminary
voice  海盗
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\system-message.st
你是一个有用的 AI 助手。
你是帮助人们查找信息的 AI 助手。
你的名字是 &#123;name&#125;
你应该使用你的姓名和 &#123;voice&#125; 的样式回复用户的请求。
</code></pre>
<h3 id="静态RAG实现：提示词动态注入"><a href="#静态RAG实现：提示词动态注入" class="headerlink" title="静态RAG实现：提示词动态注入"></a>静态RAG实现：提示词动态注入</h3><p>当前实现的方式：</p>
<ul>
<li>属于 “文档预加载+条件触发” 模式</li>
<li>通过 stuffit 参数实现 人工控制的上下文开关</li>
<li>上下文直接来自预定义的静态资源文件</li>
<li>本质上是一种轻量级的 静态RAG（Static RAG）</li>
</ul>
<p>经典RAG：</p>
<ul>
<li>采用 “检索-排序-注入” 自动化流程</li>
<li>依赖向量相似度计算动态选择上下文</li>
<li>支持增量学习和实时知识更新</li>
<li>典型流程：问题编码→向量检索→相关性过滤→上下文注入</li>
</ul>
<p>适用场景建议<br>当前方式更适合：</p>
<ul>
<li>文档规模小（如产品说明书、FAQ等）</li>
<li>需要严格控制的回答范围</li>
<li>快速原型开发阶段</li>
<li>对实时性要求不高的场景</li>
</ul>
<p>需要升级到RAG当：</p>
<ul>
<li>文档超过100MB或频繁更新</li>
<li>需要基于问题语义自动匹配上下文</li>
<li>要求支持多文档源混合检索</li>
<li>需要结合用户画像的个性化回答</li>
</ul>
<pre><code class="java">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.promptdemo.controller;

import com.fox.promptdemo.entity.Completion;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class StuffController &#123;

    private final ChatClient chatClient;

    @Value(&quot;classpath:/docs/bailian.md&quot;)
    private Resource docsToStuffResource;

    @Value(&quot;classpath:/prompts/qa-prompt.st&quot;)
    private Resource qaPromptResource;

    @Autowired
    public StuffController(ChatClient.Builder builder) &#123;
        this.chatClient = builder.build();
    &#125;

    @GetMapping(value = &quot;/stuff&quot;)
    public Completion completion(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;给我推荐一款百炼系列的手机？&quot;)
                                     String message, @RequestParam(value = &quot;stuffit&quot;, defaultValue = &quot;false&quot;)
                                     boolean stuffit) &#123;

        PromptTemplate promptTemplate = new PromptTemplate(qaPromptResource);

        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;question&quot;, message);
        if (stuffit) &#123;
            map.put(&quot;context&quot;, docsToStuffResource);
        &#125; else &#123;
            map.put(&quot;context&quot;, &quot;&quot;);
        &#125;

        return new Completion(chatClient.prompt(promptTemplate.create(map)).call().content());
    &#125;

&#125;


GET：http://localhost:10007/example/ai/stuff
message  给我推荐一款百炼系列的手机？
stuffit  true
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\qa-prompt.st
使用以下上下文来回答最后的问题。
如果你不知道答案，就说你不知道，不要试图编造答案。

&#123;context&#125;

问题: &#123;question&#125;
有用的答案：
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\docs\bailian.md
# **百炼手机产品介绍**

欢迎来到未来科技的前沿，探索我们精心打造的智能手机系列，每一款都是为了满足您对科技生活的无限遐想而生。

**百炼X1** —— 畅享极致视界：搭载6.7英寸1440 x 3200像素超清屏幕，搭配120Hz刷新率，流畅视觉体验跃然眼前。256GB海量存储空间与12GB RAM强强联合，无论是大型游戏还是多任务处理，都能轻松应对。5000mAh电池长续航，加上超感光四摄系统，记录生活每一刻精彩。参考售价：4599 - 4999

**通义Vivid 7** —— 智能摄影新体验：拥有6.5英寸1080 x 2400像素全面屏，AI智能摄影功能让每一张照片都能展现专业级色彩与细节。8GB RAM与128GB存储空间确保流畅操作，4500mAh电池满足日常所需。侧面指纹解锁，便捷又安全。参考售价：2999 - 3299

**星尘S9 Pro** —— 创新视觉盛宴：突破性6.9英寸1440 x 3088像素屏下摄像头设计，带来无界视觉享受。512GB存储与16GB RAM的顶级配置，配合6000mAh电池与100W快充技术，让性能与续航并驾齐驱，引领科技潮流。参考售价：5999 - 6499。

**百炼Ace Ultra** —— 游戏玩家之选：配备6.67英寸1080 x 2400像素屏幕，内置10GB RAM与256GB存储，确保游戏运行丝滑无阻。5500mAh电池搭配液冷散热系统，长时间游戏也能保持冷静。高动态双扬声器，沉浸式音效升级游戏体验。参考售价：3999 - 4299。

**百炼Zephyr Z9** —— 轻薄便携的艺术：轻巧的6.4英寸1080 x 2340像素设计，搭配128GB存储与6GB RAM，日常使用游刃有余。4000mAh电池确保一天无忧，30倍数字变焦镜头捕捉远处细节，轻薄而不失强大。参考售价：2499 - 2799。

**百炼Flex Fold+** —— 折叠屏新纪元：集创新与奢华于一身，主屏7.6英寸1800 x 2400像素与外屏4.7英寸1080 x 2400像素，多角度自由悬停设计，满足不同场景需求。512GB存储、12GB RAM，加之4700mAh电池与UTG超薄柔性玻璃，开启折叠屏时代新篇章。此外，这款手机还支持双卡双待、卫星通话，帮助您在世界各地都能畅联通话。参考零售价：9999 - 10999。

每一款手机都是匠心独运，只为成就您手中的科技艺术品。选择属于您的智能伙伴，开启未来科技生活的新篇章。
</code></pre>
<h3 id="实现结构化输出转JSON或Java对象-entity-【文本转特定格式】"><a href="#实现结构化输出转JSON或Java对象-entity-【文本转特定格式】" class="headerlink" title="实现结构化输出转JSON或Java对象(.entity)【文本转特定格式】"></a>实现结构化输出<del>转JSON或Java对象(.entity)</del>【文本转特定格式】</h3><h4 id="ChatClient-1"><a href="#ChatClient-1" class="headerlink" title="ChatClient"></a>ChatClient</h4><p>调用<code>entity()</code>方法 </p>
<pre><code class="java">// 实体对象
ActorsFilms actorsFilms = ChatClient.create(chatModel).prompt()
        .user(u -&gt; u.text(&quot;Generate the filmography of 5 movies for &#123;actor&#125;.&quot;)
                    .param(&quot;actor&quot;, &quot;Tom Hanks&quot;))
        .call()
        .entity(ActorsFilms.class);
</code></pre>
<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><pre><code class="java">List&lt;ActorsFilms&gt; actorsFilms = ChatClient.create(chatModel).prompt()
        .user(&quot;Generate the filmography of 5 movies for Tom Hanks and Bill Murray.&quot;)
        .call()
        .entity(new ParameterizedTypeReference&lt;List&lt;ActorsFilms&gt;&gt;() &#123;&#125;);


//使用 ListOutputConverter 将模型响应转换为 List：
List&lt;String&gt; flavors = ChatClient.create(chatModel).prompt()
                .user(u -&gt; u.text(&quot;List five &#123;subject&#125;&quot;)
                            .param(&quot;subject&quot;, &quot;ice cream flavors&quot;))
                .call()
                .entity(new ListOutputConverter(new DefaultConversionService()));
</code></pre>
<h6 id="Map-lt-String-Object-gt"><a href="#Map-lt-String-Object-gt" class="headerlink" title="Map&lt; String, Object&gt;"></a>Map&lt; String, Object&gt;</h6><pre><code class="java">Map&lt;String, Object&gt; result = ChatClient.create(chatModel).prompt()
        .user(u -&gt; u.text(&quot;Provide me a List of &#123;subject&#125;&quot;)
                    .param(&quot;subject&quot;, &quot;an array of numbers from 1 to 9 under their key name &#39;numbers&#39;&quot;))
        .call()
        .entity(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);
</code></pre>
<hr>
<pre><code class="java">com/fox/structureddemo/stream/StreamToBeanEntity.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

public class StreamToBeanEntity &#123;

    private String title;
    private String author;
    private String date;
    private String content;

    public StreamToBeanEntity() &#123;
    &#125;

    public String getTitle() &#123;
        return title;
    &#125;

    public void setTitle(String title) &#123;
        this.title = title;
    &#125;

    public String getAuthor() &#123;
        return author;
    &#125;

    public void setAuthor(String author) &#123;
        this.author = author;
    &#125;

    public String getDate() &#123;
        return date;
    &#125;

    public void setDate(String date) &#123;
        this.date = date;
    &#125;

    public String getContent() &#123;
        return content;
    &#125;

    public void setContent(String content) &#123;
        this.content = content;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;StreamToBeanEntity&#123;&quot; +
                &quot;title=&#39;&quot; + title + &#39;\&#39;&#39; +
                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
                &quot;, date=&#39;&quot; + date + &#39;\&#39;&#39; +
                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/structureddemo/stream/StreamToBeanController.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.converter.BeanOutputConverter;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.util.Objects;


@RestController
@RequestMapping(&quot;/example/stream&quot;)
public class StreamToBeanController &#123;

    private final ChatClient chatClient;

    private static final Logger log = LoggerFactory.getLogger(StreamToBeanController.class);

    public StreamToBeanController(ChatClient.Builder builder) &#123;
        // 使用builder对象构建ChatClient实例
        this.chatClient = builder.build();
    &#125;


    /**
     * @return &#123;@link com.fox.structureddemo.stream.StreamToBeanEntity&#125;
     */
    @GetMapping(&quot;/play&quot;)
    public StreamToBeanEntity simpleChat(HttpServletResponse response) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);

        var converter = new BeanOutputConverter&lt;&gt;(
                new ParameterizedTypeReference&lt;StreamToBeanEntity&gt;() &#123; &#125;
        );

        Flux&lt;String&gt; flux = this.chatClient.prompt()
                .user(u -&gt; u.text(&quot;&quot;&quot;
                        requirement: 请用大概 120 字，作者为 Fox ，为计算机的发展历史写一首现代诗;
                        format: 以纯文本输出 json，请不要包含任何多余的文字——包括 markdown 格式;
                        outputExample: &#123;
                             &quot;title&quot;: &#123;title&#125;,
                             &quot;author&quot;: &#123;author&#125;,
                             &quot;date&quot;: &#123;date&#125;,
                             &quot;content&quot;: &#123;content&#125;
                        &#125;;
                        &quot;&quot;&quot;))
                .stream()
                .content();

        String result = String.join(&quot;\n&quot;, Objects.requireNonNull(flux.collectList().block()))
                .replaceAll(&quot;\\n&quot;, &quot;&quot;)
                .replaceAll(&quot;\\s+&quot;, &quot; &quot;)
                .replaceAll(&quot;\&quot;\\s*:&quot;, &quot;\&quot;:&quot;)
                .replaceAll(&quot;:\\s*\&quot;&quot;, &quot;:\&quot;&quot;);

        log.info(&quot;LLMs 响应的 json 数据为：&#123;&#125;&quot;, result);

        return converter.convert(result);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/structureddemo/stream/StreamToJsonController.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

import com.alibaba.cloud.ai.dashscope.api.DashScopeResponseFormat;
import com.alibaba.cloud.ai.dashscope.chat.DashScopeChatOptions;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping(&quot;/example/stream/json&quot;)
public class StreamToJsonController &#123;

    private static final String DEFAULT_PROMPT = &quot;你好，请以JSON格式介绍你自己！&quot;;

    private final ChatClient dashScopeChatClient;

    public StreamToJsonController(ChatModel chatModel) &#123;

        DashScopeResponseFormat responseFormat = new DashScopeResponseFormat();
        responseFormat.setType(DashScopeResponseFormat.Type.JSON_OBJECT);

        this.dashScopeChatClient = ChatClient.builder(chatModel)
                .defaultOptions(
                        DashScopeChatOptions.builder()
                                .withTopP(0.7)
                                .withResponseFormat(responseFormat)
                                .build()
                )
                .build();
    &#125;

    /**
     * @return &#123;@link String&#125;
     */
    @GetMapping(&quot;/play&quot;)
    public String simpleChat(HttpServletResponse response) &#123;
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return dashScopeChatClient.prompt(DEFAULT_PROMPT)
                .call()
                .content();
    &#125;

&#125;
</code></pre>
<h3 id="通义千问大模型调优"><a href="#通义千问大模型调优" class="headerlink" title="通义千问大模型调优"></a>通义千问大模型调优</h3><ul>
<li><p><strong>temperature</strong>：温度值越高，模型生成的内容就越丰富多样</p>
<h6 id="温度只是来调整候选Token集合的概率分布"><a href="#温度只是来调整候选Token集合的概率分布" class="headerlink" title="温度只是来调整候选Token集合的概率分布"></a>温度只是来调整候选Token集合的概率分布</h6><p>低值（0.2）：适用于标准化回答（如退货政策查询）<br>高值（0.8）：适用于创意场景（如促销文案生成）低温度、中温度和高温度是依据通义千问plus模型的取值范围[0, 2)来划分。</p>
<ul>
<li>低温度（temperature&#x3D;0.1）：大模型选择“RAG”的概率远高于其它候选Token，这会导致其输出相对单一。</li>
<li>中温度（temperature&#x3D;0.7）：候选Token之间概率分布相对平缓，除“RAG”之外的候选Token出现的概率都在增加。</li>
<li>高温度（temperature&#x3D;1.2）：原低概率的候选Token出现概率进一步提升，打乱原有的排序，进一步提高了大模型输出的随机性。在上图中，“画画”出现的概率反而最高。</li>
</ul>
</li>
<li><p><strong>top_p</strong>：top_p值越高，大模型的输出结果随机性越高</p>
<h6 id="top-p控制候选Token集合的采样范围。"><a href="#top-p控制候选Token集合的采样范围。" class="headerlink" title="top_p控制候选Token集合的采样范围。"></a>top_p控制候选Token集合的采样范围。</h6><p>设置top_p&#x3D;0.9平衡多样性与准确性，防止低概率token干扰</p>
</li>
</ul>
<p>为了确保生成内容的可控性，建议不要同时调整top_p和temperature。同时调整可能导致输出结果不可预测和复杂。你可以优先调整其中一种参数，观察其对结果的影响，再逐步微调。</p>
<ul>
<li><strong>top_k</strong>：top_k越大，生成内容越多样化；top_k越小，内容则更固</li>
</ul>
<p>在通义千问系列模型中，参数top<em>k也有类似top</em>p的能力，可查阅通义千问API文档。它是一种采样机制，从概率排名前k的Token中随机选择一个进行输出。一般来说，top<em>k越大，生成内容越多样化；top</em>k越小，内容则更固定。当top_k设置为1时，模型仅选择概率最高的Token，输出会更加稳定，但也会导致缺乏变化和创意。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/model-studio/use-qwen-by-calling-api?spm=a2c4g.11186623.help-menu-2400256.d_3_3_0.68332bdb2Afk2s&scm=20140722.H_2712576._.OR_help-V_1">通义千问API参考_大模型服务平台百炼(Model Studio)-阿里云帮助中心</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b76b2ef0bfbe66e8f88d7e832b3e955d3a3800d6/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B02.png"></p>
<h4 id="多个AI大模型无缝切换【👆图在上面👆】"><a href="#多个AI大模型无缝切换【👆图在上面👆】" class="headerlink" title="多个AI大模型无缝切换【👆图在上面👆】"></a>多个AI大模型无缝切换【👆图在上面👆】</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QDICVSc8em4YYnEdRy07Ag">如何实现多个AI大模型的无缝切换，比如DeepSeek-R1 调用失败可以请求降级调用 QwQ-32B。 AI网关方案实战</a></p>
<p>期，通义千问发布了一款全新的推理模型 QwQ-32B。在各类基准测试中，这个拥有 320 亿参数的模型展现出了与 DeepSeek-R1（6710 亿参数）相当的性能。这意味着：</p>
<ul>
<li>对于个人用户而言，QwQ-32B 能够直接在本地运行，且对设备的要求更低，适合在更小的移动设备上使用。</li>
<li>对于企业用户来说，调用推理大模型 API 的成本可以进一步降低，最高可减少 90% 的费用。</li>
</ul>
<p>在实际应用中，无缝切换多个大模型的需求日益凸显。例如，企业可能需要同时对接多个大模型，以满足不同业务场景的需求；当单个模型出现稳定性问题时，能够迅速回退到另一个模型，确保业务的连续性和稳定性；在 Multi Agent 场景下，一个复杂任务可能需要调用多个模型来协同完成。Higress AI 网关提供了一个强大的解决方案，支持多模型服务，并具备消费者鉴权、模型自动切换等高级功能。</p>
<p>本文将为您提供一份详细的教程，指导您如何使用 Higress AI 网关在 DeepSeek-R1 和 QwQ-32B 大模型之间实现无缝切换。</p>
<p>关于Higress网关的使用，可以参考我上一篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU1ODk1NTQ0Mg==&mid=2247485661&idx=1&sn=2435d46a1ee26308c84b3ef2c2068a12&scene=21#wechat_redirect">阿里巴巴开源的云原生网关Higress实战</a></p>
<p>若想要Higress桌面版 先下载<code>Docker Desktop</code>再下载 <code>Cygwin</code>验证<br>Cygwin 安装是否成功</p>
<pre><code class="shell">cygcheck -c cygwin
</code></pre>
<blockquote>
<p>Pluminary@Pluminary ~<br>$ cygcheck -c cygwin<br>Cygwin Package Information<br>Package              Version    Status<br>cygwin               3.6.1-1        OK</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/474242350">cygwin下载及安装详细教程，windows使用linux的shell命令编译源码（win10) - 知乎</a><br><a target="_blank" rel="noopener" href="https://higress.cn/zh-cn/blog/DeployOnWindows/">Windows 下 Higress 部署实践 | Higress</a></p>
<p>先<strong>单机部署nacos</strong> 进入<code>D:\nacos-docker-master\cmd</code><br>单机部署指令：<code>docker-compose -f example/standalone-derby.yaml up</code><br>这里可以修改端口映射：<code>D:\nacos-docker-master\example\standalone-derby.yaml</code> 如下👇<br>正确的监控检查命令：<code>curl http://192.168.31.103:8848/nacos/v3/console/health/readiness</code></p>
<pre><code class="yaml">version: &quot;2&quot;
services:
  nacos:
    image: nacos/nacos-server:$&#123;NACOS_VERSION&#125;
    container_name: nacos-standalone
    environment:
      - PREFER_HOST_MODE=hostname
      - MODE=standalone
      - NACOS_AUTH_IDENTITY_KEY=serverIdentity
      - NACOS_AUTH_IDENTITY_VALUE=security
      - NACOS_AUTH_TOKEN=VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=
    volumes:
      - ./standalone-logs/:/home/nacos/logs
    ports:
      - &quot;8848:8848&quot;
      - &quot;18080:8080&quot;       
  prometheus:
    container_name: prometheus
    image: prom/prometheus:latest
    volumes:
      - ./prometheus/prometheus-standalone.yaml:/etc/prometheus/prometheus.yml
    ports:
      - &quot;9090:9090&quot;
    depends_on:
      - nacos
    restart: on-failure
  grafana:
    container_name: grafana
    image: grafana/grafana:latest
    ports:
      - 3000:3000
    restart: on-failure
</code></pre>
<p>随后在桌面打开<code>cmd</code>输入<code>ipconfig</code>寻找ip地址 记录下来<br>在桌面右键 → 选择 <strong>Git Bash Here</strong>，进入 Bash 环境<br>在 Git Bash 里执行命令：【ip地址是通过ipconfig获取】**<u>这里要记得关闭梯子和代理 因为从阿里云拉镜像</u>**</p>
<pre><code class="yaml">curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.31.103:8848
</code></pre>
<p>★★</p>
<pre><code class="java">// 安装higress 进入bash
$ curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.43.85:8848 --nacos-username=nacos --nacos-password=nacos --nacos-ns=higress-system --nacos-ns=higress-system

       // 这里是启动的nacos
cd D:\nacos-docker-master\example
// 重启docker(Nacos)
docker-compose -f standalone-derby.yaml down
docker-compose -f standalone-derby.yaml up -d

// 一键重启
docker restart nacos-standalone

    
       // 这里是启动higress    
// 在桌面启一个bash  启动higress
$ /c/Users/Pluminary/Desktop/higress/bin/startup.sh
// 如果改了配置 在bash里  【一定要先启动docker 才可以干别的】
cd /c/Users/Pluminary/Desktop/higress
./bin/shutdown.sh
./bin/startup.sh
    
</code></pre>
<blockquote>
<h4 id="然后就一直无敌报错："><a href="#然后就一直无敌报错：" class="headerlink" title="然后就一直无敌报错："></a>然后就一直无敌报错：</h4><p><a target="_blank" rel="noopener" href="http://192.168.31.103:8848/nacos/v1/console/health/readiness">http://192.168.31.103:8848/nacos/v1/console/health/readiness</a> returns 000<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…</p>
<p>修改端口不占用冲突的8080即可</p>
<p><code>cd D:\nacos-docker-master\example</code></p>
<p><strong>重启docker(Nacos)</strong><br><code>docker-compose -f standalone-derby.yaml down</code><br><code>docker-compose -f standalone-derby.yaml up -d</code></p>
<h4 id="一键重启"><a href="#一键重启" class="headerlink" title="一键重启"></a>一键重启</h4><p><code>docker restart nacos-standalone</code></p>
<hr>
<hr>
<hr>
<h4 id="下一个报错："><a href="#下一个报错：" class="headerlink" title="下一个报错："></a>下一个报错：</h4><p>Nacos is ready.<br>Initializing Nacos server…</p>
<p>Nacos 3.x isn’t fully supported yet.</p>
<p>If you do want to use Nacos 3.x, please add the following property into its application.properties file:<br>  nacos.core.api.compatibility.console.enabled&#x3D;true</p>
<p>Higress configuration failed with 255.<br>Failed to install Higress<br>        For support, go to <a target="_blank" rel="noopener" href="https://github.com/alibaba/higress">https://github.com/alibaba/higress</a>.</p>
<h6 id="这说明什么？"><a href="#这说明什么？" class="headerlink" title="这说明什么？"></a>这说明什么？</h6><ul>
<li>Higress 当前版本对 Nacos 3.x 支持不完善，需要兼容模式开启</li>
<li>你的 Nacos 3.x 服务默认没开启兼容控制台API，导致健康检查接口返回异常或空</li>
</ul>
<h4 id="1-修改-Nacos-配置，启用兼容模式"><a href="#1-修改-Nacos-配置，启用兼容模式" class="headerlink" title="1. 修改 Nacos 配置，启用兼容模式"></a>1. 修改 Nacos 配置，启用兼容模式</h4><p>找到你的 Nacos 容器中 <code>application.properties</code> 文件，添加下面这一行：</p>
<pre><code>nacos.core.api.compatibility.console.enabled=true
</code></pre>
<h4 id="2-重启-Nacos-容器"><a href="#2-重启-Nacos-容器" class="headerlink" title="2. 重启 Nacos 容器"></a>2. 重启 Nacos 容器</h4><pre><code>cd D:\nacos-docker-master\example
docker restart nacos-standalone
</code></pre>
<h4 id="3-访问健康接口测试"><a href="#3-访问健康接口测试" class="headerlink" title="3. 访问健康接口测试"></a>3. 访问健康接口测试</h4><pre><code class="java">curl http://192.168.43.85:8848/nacos/v1/console/health/readiness
</code></pre>
<p><span style="color:red"><strong>搞什么乱七八糟的配置 直接降级nacos 因为nacos3.xxx有很多不兼容的地方</strong><br></span><code>D:\nacos-docker-master\example</code>的<code>NACOS_VERSION=v2.3.1</code></p>
<pre><code class="yaml">Pluminary@Pluminary MINGW64 ~/Desktop
$ curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.43.85:8848 --nacos-username=nacos --nacos-password=nacos --nacos-ns=higress-system 

Downloading https://github.com/higress-group/higress-
standalone/archive/refs/tags/v2.1.5.tar.gz...
==== Build Configurations ====
time=&quot;2025-07-12T00:40:46+08:00&quot; level=warning msg=&quot;C:\\Users\\Pluminary\\Desktop\\higress\\compose\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion&quot;
Nacos is ready.
Initializing Nacos server...
Use Nacos API v1
  Namespace higress-system already exists in Nacos.
  Fixed data encryption key is used. Skip config overwriting check.
Initializing API server configurations...
  Data encryption key already exists.
Initializing controller configurations...

 ___  ___  ___  ________  ________  _______   ________   ________
|\  \|\  \|\  \|\   ____\|\   __  \|\  ___ \ |\   ____\ |\   ____\
\ \  \\\  \ \  \ \  \___|\ \  \|\  \ \   __/|\ \  \___|_\ \  \___|_
 \ \   __  \ \  \ \  \  __\ \   _  _\ \  \_|/_\ \_____  \\ \_____  \
  \ \  \ \  \ \  \ \  \|\  \ \  \\  \\ \  \_|\ \|____|\  \\|____|\  \
   \ \__\ \__\ \__\ \_______\ \__\\ _\\ \_______\____\_\  \ ____\_\  \
    \|__|\|__|\|__|\|_______|\|__|\|__|\|_______|\_________\\_________\
                                                \|_________\|_________|

Higress is configured successfully.

Important Notes:
  Sensitive configurations are encrypted when saving to Nacos.
  When configuring another server with the same Nacos configuration service, please make sure to add the following argument so all servers use the same encryption key:
   

Usage:
  Start: /c/Users/Pluminary/Desktop/higress/bin/startup.sh
  Stop: /c/Users/Pluminary/Desktop/higress/bin/shutdown.sh
  View Component Statuses: /c/Users/Pluminary/Desktop/higress/bin/status.sh
  View Logs: /c/Users/Pluminary/Desktop/higress/bin/logs.sh
  Re-configure: /c/Users/Pluminary/Desktop/higress/bin/configure.sh -r

Happy Higressing!
</code></pre>
<p>访问Nacos：<a target="_blank" rel="noopener" href="http://192.168.31.103:8848/nacos/#/listeningToQuery?dataId=&group=&appName=&namespace=&namespaceShowName=public">Nacos</a> 或 地址改成localhost</p>
</blockquote>
<blockquote>
<h2 id="✅-配置项-1：secrets-nacos-auth-default"><a href="#✅-配置项-1：secrets-nacos-auth-default" class="headerlink" title="✅ 配置项 1：secrets.nacos-auth-default"></a>✅ 配置项 1：<code>secrets.nacos-auth-default</code></h2><h3 id="位置："><a href="#位置：" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code>（对应 <code>higress-system</code>）</li>
<li><strong>Data ID：</strong> <code>secrets.nacos-auth-default</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容："><a href="#配置内容：" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>username: nacos
password: nacos
</code></pre>
<hr>
<h2 id="✅-配置项-2：configmaps-higress-config"><a href="#✅-配置项-2：configmaps-higress-config" class="headerlink" title="✅ 配置项 2：configmaps.higress-config"></a>✅ 配置项 2：<code>configmaps.higress-config</code></h2><h3 id="位置：-1"><a href="#位置：-1" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code></li>
<li><strong>Data ID：</strong> <code>configmaps.higress-config</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容：-1"><a href="#配置内容：-1" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: higress-config
  namespace: higress-system
data:
  ingressClass: higress
</code></pre>
<hr>
<h2 id="✅-配置项-3：mcpbridges-default"><a href="#✅-配置项-3：mcpbridges-default" class="headerlink" title="✅ 配置项 3：mcpbridges.default"></a>✅ 配置项 3：<code>mcpbridges.default</code></h2><h3 id="位置：-2"><a href="#位置：-2" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code></li>
<li><strong>Data ID：</strong> <code>mcpbridges.default</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容：-2"><a href="#配置内容：-2" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>apiVersion: networking.higress.io/v1
kind: McpBridge
metadata:
  name: default
  namespace: higress-system
spec:
  registries:
    - domain: httpbin.org
      name: httpbin
      port: 80
      type: dns
</code></pre>
<pre><code class="yaml">./bin/configure.sh -a -c nacos://192.168.31.103:8848 \
  --nacos-username=nacos \
  --nacos-password=nacos \
  --nacos-ns=higress-system
</code></pre>
<h3 id="✅-解决方案：使用-r-参数强制重新配置"><a href="#✅-解决方案：使用-r-参数强制重新配置" class="headerlink" title="✅ 解决方案：使用 -r 参数强制重新配置"></a>✅ 解决方案：使用 <code>-r</code> 参数强制重新配置</h3><p>你需要<strong>强制重新执行配置流程并显式指定 nacos 命名空间</strong>，命令如下：</p>
<pre><code>bash复制编辑./bin/configure.sh -a -r \
  -c nacos://192.168.31.103:8848 \
  --nacos-username=nacos \
  --nacos-password=nacos \
  --nacos-ns=higress-system \
  -k 7bbac1c2ab91ff074cb8d219c307d203
</code></pre>
<p>📌 说明：</p>
<ul>
<li><code>-r</code>：重新运行配置流程（一定要加）</li>
<li><code>--nacos-ns=higress-system</code>：这才是决定配置写入哪个命名空间的参数</li>
<li><code>.env</code> 中的 <code>NACOS_NS</code> 虽然也有用，但以你命令参数为主</li>
</ul>
</blockquote>
<h3 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h3><p>RAG：接收到问题后，去知识库查资料，得到检索知识后进行回答<br>微调：提前学习知识，丰富自己的能力，接收到问题后进行回答</p>
<pre><code class="java">RAG → 问题 → (LLM+知识) → 回复
    
                   问题
                    ↓
微调 → LLM → 知识 → LLM(new)
               ↘    ↓
                   回复
</code></pre>
<h5 id="RAG工作原理："><a href="#RAG工作原理：" class="headerlink" title="RAG工作原理："></a>RAG工作原理：</h5><ul>
<li><p><strong>建立索引阶段</strong></p>
<p>文件上传 → 文档加载 → 内容分割 → 文本向量化 → 索引存储</p>
</li>
<li><p><strong>检索与生成阶段</strong></p>
<p><strong>检索</strong>：检索阶段会召回与问题最相关的文本段。通过embedding模型对问题进行文本向量化，并与向量数据库的段落进行语义相似度的比较，找出最相关的段落。<br><strong>生成</strong>：在检索到相关的文本段后，RAG应用会将问题与文本段通过提示词模板生成最终的提示词，由大模型生成回复，这个阶段更多是利用大模型的总结能力，而不是大模型本身具有的知识。</p>
</li>
<li><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>用户提问 →  → → → → →     提示词  → 大语言模型 → 输出答案<br>   ↘      →    内容检索   →       ↑</p>
</li>
</ul>
<pre><code class="java">com/fox/ragdemo/config/RagConfig.java
package com.fox.ragdemo.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.document.Document;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.vectorstore.SimpleVectorStore;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class RagConfig &#123;

    @Bean
    ChatClient chatClient(ChatClient.Builder builder) &#123;
        return builder.defaultSystem(&quot;你将作为一名机器人产品的专家，对于用户的使用需求作出解答&quot;)
                .build();
    &#125;

    @Bean
    VectorStore vectorStore(EmbeddingModel embeddingModel) &#123;
        SimpleVectorStore simpleVectorStore = SimpleVectorStore.builder(embeddingModel)
                .build();

        // 生成一个机器人产品说明书的文档
        List&lt;Document&gt; documents = List.of(
                new Document(&quot;产品说明书:产品名称：智能机器人\n&quot; +
                        &quot;产品描述：智能机器人是一个智能设备，能够自动完成各种任务。\n&quot; +
                        &quot;功能：\n&quot; +
                        &quot;1. 自动导航：机器人能够自动导航到指定位置。\n&quot; +
                        &quot;2. 自动抓取：机器人能够自动抓取物品。\n&quot; +
                        &quot;3. 自动放置：机器人能够自动放置物品。\n&quot;));

        simpleVectorStore.add(documents);
        return simpleVectorStore;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/ragdemo/controller/RagController.java
package com.fox.ragdemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.QuestionAnswerAdvisor;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/ai&quot;)
public class RagController &#123;

    @Autowired
    private ChatClient chatClient;

    @Autowired
    private VectorStore vectorStore;


    @GetMapping(value = &quot;/chat&quot;, produces = &quot;text/plain; charset=UTF-8&quot;)
    public String generation(String userInput) &#123;
        // 发起聊天请求并处理响应
        return chatClient.prompt()
                .user(userInput)
                // 调用知识库
                .advisors(new QuestionAnswerAdvisor(vectorStore))
                .call()
                .content();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.fox.ragdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RagDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(RagDemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="RAG-阿里云百炼"><a href="#RAG-阿里云百炼" class="headerlink" title="RAG+阿里云百炼"></a>RAG+阿里云百炼</h3><h5 id="本地集成百炼智能体应用"><a href="#本地集成百炼智能体应用" class="headerlink" title="本地集成百炼智能体应用"></a>本地集成百炼智能体应用</h5><ul>
<li><strong>传统SpringBoot应用</strong>(Spring AI Alibaba) → <strong>百炼平台</strong>(智能体应用)</li>
<li>SpringBoot + Spring AI Alibaba接入RAG应用实战<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MO59zPv5OFtB01htIcIwwg">SpringBoot+Spring AI Alibaba接入RAG应用实战，让你的微服务应用具备智能化能力，小白也能快速上手</a></li>
</ul>
<h5 id="本地RAG应用集成百炼知识库"><a href="#本地RAG应用集成百炼知识库" class="headerlink" title="本地RAG应用集成百炼知识库"></a>本地RAG应用集成百炼知识库</h5><pre><code class="yaml">知识库：
【学校简介】
阳光中学创建于1998年，是一所全日制寄宿制完全中学，坐落于江苏省苏州市。学校占地120亩，现有教职工120人，学生1500余人。多年来，阳光中学秉持“厚德载物，知行合一”的校训，致力于培养具有国际视野与中国灵魂的复合型人才。
________________________________________
【课程设置】
阳光中学设有初中和高中两个学段，开设课程包括语文、数学、英语、物理、化学、生物、历史、地理、政治、信息技术、音乐、美术和体育等。高一开始分文理科方向，同时提供选修课程如Python编程、人工智能基础、商务英语等，满足学生多元发展需求。
________________________________________
【师资力量】
学校现有特级教师3人，高级教师32人，硕士学历以上教师占比达70%。其中语文学科带头人王老师曾获全国语文优质课一等奖，数学组组长李老师拥有15年以上高三教学经验，多次带出省级高考状元。
________________________________________
【校园生活】
阳光中学注重学生全面发展，组织丰富的课外活动与社团，如机器人社、合唱团、辩论社、摄影社、篮球队等。每年5月举办校园艺术节，每年10月举行运动会，深受师生喜爱。校园内有图书馆、自助餐厅、医务室、心理咨询室等完善设施。
________________________________________
【校规制度】
1.    学生必须穿着校服上课，不得迟到、早退或旷课；
2.    晚自习时间为每周一至周五18:30—20:30；
3.    禁止携带手机等电子产品进课堂；
4.    严禁在校园内打架、吸烟、喝酒，一经发现严肃处理；
5.    每月评选“文明班级”“学习标兵”等荣誉称号。
________________________________________
【招生信息】
阳光中学每年春季开始招生，面向全国招收初一、高一新生。招生名额有限，需通过笔试和面试。学费标准为初中部每学期6000元，高中部每学期8000元，另设有奖学金与助学金政策，家庭困难学生可申请减免。
________________________________________
【常见问题解答】
Q：阳光中学是否提供住宿？
A：学校提供标准化学生宿舍，6人一间，配备空调、热水器与独立卫生间，设有生活老师管理。
Q：学校是否提供营养餐？
A：学生餐厅提供三餐，包括荤素搭配的营养套餐，每周公布菜单，确保健康卫生。
Q：如何申请插班？
A：插班生需在每学期开学前一个月提交申请，学校将根据学位情况及考试成绩决定是否录取。
Q：学校对艺术体育特长生有优惠吗？
A：是的。学校每年招收部分艺术、体育特长生，可享受降分录取及奖学金政策。
________________________________________
【校园热点资讯】
2025年6月，阳光中学高考再创佳绩，重本上线率达89%，其中7人被清华北大录取；
2025年3月，阳光中学学生在全国青少年人工智能竞赛中获得一等奖；
2024年10月，学校新建科学楼正式启用，建筑面积达4800平方米，配备多个功能实验室。
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\bailian-agent\src\main\java\com\fox\bailianagent\controller\BailianAgentRagController.java
package com.fox.bailianagent.controller;

import com.alibaba.cloud.ai.dashscope.agent.DashScopeAgent;
import com.alibaba.cloud.ai.dashscope.agent.DashScopeAgentOptions;
import com.alibaba.cloud.ai.dashscope.api.DashScopeAgentApi;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BailianAgentRagController &#123;
  private DashScopeAgent agent;

  @Value(&quot;$&#123;spring.ai.dashscope.agent.app-id&#125;&quot;)
  private String appId;

  public BailianAgentRagController(DashScopeAgentApi dashscopeAgentApi) &#123;
    this.agent = new DashScopeAgent(dashscopeAgentApi);
  &#125;

  @GetMapping(&quot;/bailian/agent/call&quot;)
  public String call(@RequestParam(value = &quot;message&quot;) String message) &#123;
    ChatResponse response = agent.call(
            new Prompt(message, DashScopeAgentOptions.builder()
                    // 与智能体的绑定
                    .withAppId(appId)
                    .build()));
    AssistantMessage app_output = response.getResult().getOutput();
    return app_output.getText();
  &#125;
&#125;

GET：http://localhost:8088/bailian/agent/call
message  学校简介是什么？
</code></pre>
<pre><code class="java">package com.fox.bailianagent;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BailianAgentApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(BailianAgentApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">server:
  port: 8088

spring:
  application:
    name: bailian-agent
  ai:
    dashscope:
      agent:
# https://bailian.console.aliyun.com/?tab=app#/app-center
        app-id: xxxxxxx
      api-key: xxxxxxx
</code></pre>
<h3 id="SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库"><a href="#SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库" class="headerlink" title="SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库"></a>SpringAIAlibaba本地集成百炼知识库实战<del>通过代码将文件上传到百炼知识库</del></h3><pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.controller;

import com.fox.bailianragdemo.service.RagService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping(&quot;/ai&quot;)
public class CloudRagController &#123;

    private final RagService cloudRagService;

    public CloudRagController(RagService cloudRagService) &#123;
        this.cloudRagService = cloudRagService;
    &#125;

    @GetMapping(&quot;/bailian/knowledge/importDocument&quot;)
    public void importDocument() &#123;
        cloudRagService.importDocuments();
    &#125;

    @GetMapping(&quot;/bailian/knowledge/generate&quot;)
    public Flux&lt;String&gt; generate(@RequestParam(value = &quot;message&quot;,
            defaultValue = &quot;你好，请问你的知识库文档主要是关于什么内容的?&quot;) String message) &#123;
        return cloudRagService.retrieve(message).map(x -&gt; x.getResult().getOutput().getText());
    &#125;

&#125;
</code></pre>
<pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.service;

import com.alibaba.cloud.ai.advisor.DocumentRetrievalAdvisor;
import com.alibaba.cloud.ai.dashscope.api.DashScopeApi;
import com.alibaba.cloud.ai.dashscope.rag.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.document.Document;
import org.springframework.ai.document.DocumentReader;
import org.springframework.ai.rag.retrieval.search.DocumentRetriever;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;


@Service()
public class CloudRagService implements RagService &#123;

    private static final Logger logger = LoggerFactory.getLogger(CloudRagService.class);

    private static final String indexName = &quot;阳光中学&quot;;

    @Value(&quot;classpath:/data/spring_ai_alibaba_quickstart.pdf&quot;)
    private Resource springAiResource;

    private static final String retrievalSystemTemplate = &quot;&quot;&quot;
            上下文信息如下:
            ---------------------
            &#123;question_answer_context&#125;
            ---------------------
            根据上下文和提供的历史信息，而不是先验知识,回答用户问题。
            如果答案不在上下文中，请告知用户无法回答该问题。
            &quot;&quot;&quot;;

    private final ChatClient chatClient;

    private final DashScopeApi dashscopeApi;

    public CloudRagService(ChatClient.Builder builder, DashScopeApi dashscopeApi) &#123;
        DocumentRetriever retriever = new DashScopeDocumentRetriever(dashscopeApi,
                DashScopeDocumentRetrieverOptions.builder().withIndexName(indexName).build());

        this.dashscopeApi = dashscopeApi;
        this.chatClient = builder
                .defaultAdvisors(new DocumentRetrievalAdvisor(retriever, retrievalSystemTemplate))
                .build();
    &#125;

    @Override
    public void importDocuments() &#123;
        String path = saveToTempFile(springAiResource);

        // 1. import and split documents
        DocumentReader reader = new DashScopeDocumentCloudReader(path, dashscopeApi, null);
        List&lt;Document&gt; documentList = reader.get();
        logger.info(&quot;&#123;&#125; documents loaded and split&quot;, documentList.size());

        // 1. add documents to DashScope cloud storage 向量数据库
        VectorStore vectorStore = new DashScopeCloudStore(dashscopeApi, new DashScopeStoreOptions(indexName));
        vectorStore.add(documentList);
        logger.info(&quot;&#123;&#125; documents added to dashscope cloud vector store&quot;, documentList.size());
    &#125;

    private String saveToTempFile(Resource springAiResource) &#123;
        try &#123;
            File tempFile = File.createTempFile(&quot;spring_ai_alibaba_quickstart&quot;, &quot;.pdf&quot;);
            tempFile.deleteOnExit();

            try (InputStream inputStream = springAiResource.getInputStream();
                    FileOutputStream outputStream = new FileOutputStream(tempFile)) &#123;
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) &#123;
                    outputStream.write(buffer, 0, bytesRead);
                &#125;
            &#125;

            return tempFile.getAbsolutePath();
        &#125;
        catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public Flux&lt;ChatResponse&gt; retrieve(String message) &#123;
        return chatClient.prompt().user(message).stream().chatResponse();
    &#125;

&#125;
</code></pre>
<pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.service;

import org.springframework.ai.chat.model.ChatResponse;
import reactor.core.publisher.Flux;


public interface RagService &#123;

    void importDocuments();

    Flux&lt;ChatResponse&gt; retrieve(String message);
&#125;
</code></pre>
<pre><code class="yaml">server:
  port: 8088

spring:
  application:
    name: bailian-rag-demo
  ai:
    dashscope:
      api-key: xxxxx
</code></pre>
<h3 id="工具Fuction-Calling"><a href="#工具Fuction-Calling" class="headerlink" title="工具Fuction Calling"></a>工具Fuction Calling</h3><p>允许语言大模型调用外部函数(Function)或API来执行特定任务或获取实时数据。<br>例如：<br>调用天气API查询实时天气。<br>调用数据库接口执行查询。 其核心是扩展模型的交互能力，使其能执行操作或获取结构化数据，而非仅依赖内部知识</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><p>实时数据查询：如股票行情、天气、航班信息。<br>任务自动化：预订会议、下单、数据计算等。<br>系统集成：与CRM、ERP等业务系统交互（如创建客户记录）</p>
<h6 id="和RAG的区别"><a href="#和RAG的区别" class="headerlink" title="和RAG的区别"></a>和RAG的区别</h6><p>RAG和Function Calling分别从知识增强和功能扩展两个维度提升LLM能力。选择取决于具体需求：</p>
<ul>
<li>需结合外部知识？ → RAG</li>
<li>需执行操作或获取实时数据？ → Function Calling</li>
<li>复杂场景：两者结合（如Agent框架中集成RAG和工具调用）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">RAG</th>
<th align="center">Function Calling</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据依赖</td>
<td align="center">依赖外部知识库的覆盖和质量</td>
<td align="center">依赖API或函数的可用性和稳定性</td>
</tr>
<tr>
<td align="center">实时性</td>
<td align="center">受限于知识库更新频率</td>
<td align="center">可获取实时数据(如API返回结果)</td>
</tr>
<tr>
<td align="center">输出形式</td>
<td align="center">自然语言文本</td>
<td align="center">结构化数据(Json)或操作结果</td>
</tr>
<tr>
<td align="center">适用问题类型</td>
<td align="center">需外部知识支持的复杂问题</td>
<td align="center">需执行操作或获取动态数据的场景</td>
</tr>
<tr>
<td align="center">实现复杂度</td>
<td align="center">需构建高效检索系统(向量数据库)</td>
<td align="center">需定义函数接口和参数规范</td>
</tr>
</tbody></table>
<h3 id="Function-Calling获取天气信息"><a href="#Function-Calling获取天气信息" class="headerlink" title="Function Calling获取天气信息"></a>Function Calling获取天气信息</h3><h6 id="以Function为接口调用apply方法"><a href="#以Function为接口调用apply方法" class="headerlink" title="以Function为接口调用apply方法"></a>以Function为接口调用apply方法</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\function\WeatherFunction.java

package com.fox.toolcallingdemo.tool.weather.function;

import java.util.function.Function;

public class WeatherFunction implements Function&lt;WeatherFunction.WeatherRequest, String&gt; &#123;
    @Override
    public String apply(WeatherRequest request) &#123;
        // 此处省略了实际的天气查询逻辑，直接返回一个示例字符串
        // 实际应用中需要根据请求参数调用天气API获取天气信息
        return &quot;The weather in &quot; + request.getCity() + &quot; is sunny.&quot;;
    &#125;
    public static class WeatherRequest &#123;
        private String city;
        public String getCity() &#123; return city; &#125;
        public void setCity(String city) &#123; this.city = city; &#125;
    &#125;
&#125;
</code></pre>
<h6 id="把函数以Bean形式交给Spring去管理"><a href="#把函数以Bean形式交给Spring去管理" class="headerlink" title="把函数以Bean形式交给Spring去管理"></a>把函数以Bean形式交给Spring去管理</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\function\FunctionConfig.java
    
package com.fox.toolcallingdemo.tool.weather.function;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Description;

import java.util.function.Function;

@Configuration
public class FunctionConfig &#123;
    @Bean
    // 标识
    @Description(&quot;获取指定城市的天气信息&quot;)
    public Function&lt;WeatherFunction.WeatherRequest, String&gt; weatherFunction() &#123;
        return new WeatherFunction();
    &#125;
&#125;
</code></pre>
<h6 id="告诉大模型请求可以调函数"><a href="#告诉大模型请求可以调函数" class="headerlink" title="告诉大模型请求可以调函数"></a>告诉大模型请求可以调函数</h6><pre><code class="java">package com.fox.toolcallingdemo.controller;


import com.fox.toolcallingdemo.tool.weather.method.WeatherTool;
import com.fox.toolcallingdemo.tool.weather.method.WeatherToolImpl;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/weather&quot;)
public class WeatherController &#123;

    private final ChatClient dashScopeChatClient;

    /**
    * 默认全局调函数
    */
    public WeatherController(ChatClient.Builder chatClientBuilder) &#123;
        this.dashScopeChatClient = chatClientBuilder
                .defaultFunctions(&quot;weatherFunction&quot;)
                //.defaultTools(new WeatherToolImpl())
                .build();
    &#125;
-------------------------------------------------------------------------------------
    /**
     * 无工具版
     */
    @GetMapping(&quot;/chat&quot;)
    public String simpleChat(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;
        return dashScopeChatClient.prompt(query).call().content();
    &#125;
-------------------------------------------------------------------------------------
    /**
     * 调用工具版 - function
     */
    @GetMapping(&quot;/chat-tool-function&quot;)
    public String chatTranslateFunction(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;

    // 就可以去找刚刚函数构建的bean
        return dashScopeChatClient.prompt(query).functions(&quot;weatherFunction&quot;).call().content();
    &#125;

-------------------------------------------------------------------------------------

    /**
     * 调用工具版 - method
     */
    @GetMapping(&quot;/chat-tool-method&quot;)
    public String chatTranslateMethod(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;

        return dashScopeChatClient.prompt(query).tools(new WeatherToolImpl()).call().content();
    &#125;
&#125;

GET：http://localhost:8088/weather/chat-tool-method
query  深圳今天的天气怎么样？
</code></pre>
<h6 id="承接上面最后一个Method版"><a href="#承接上面最后一个Method版" class="headerlink" title="承接上面最后一个Method版"></a>承接上面最后一个Method版</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\method\WeatherTool.java
package com.fox.toolcallingdemo.tool.weather.method;

public interface WeatherTool &#123;
    String getWeather(String city);
&#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\method\WeatherToolImpl.java
package com.fox.toolcallingdemo.tool.weather.method;


import org.springframework.ai.tool.annotation.Tool;

public class WeatherToolImpl implements WeatherTool &#123;
    @Override
    @Tool(description = &quot;获取指定城市的天气信息。&quot;)
    public String getWeather(String city) &#123;
        return &quot;The weather in &quot; + city + &quot; is sunny.&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="MCP协议"><a href="#MCP协议" class="headerlink" title="MCP协议"></a>MCP协议</h3><p>模型上下文协议（即 Model Context Protocol，MCP）是一个开放协议，它规范了应用程序如何向大型语言模型（LLM）提供上下文。MCP 提供了一种统一的方式将 AI 模型连接到不同的数据源和工具，它定义了统一的集成方式。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7ee928d5d4f2a3c021548c45f038914f81673875/SpringAI_MCP-2.png" alt="MCP图+与function_calling区别"></p>
<h3 id="百炼智能体应用接入高德地图MCP服务"><a href="#百炼智能体应用接入高德地图MCP服务" class="headerlink" title="百炼智能体应用接入高德地图MCP服务"></a>百炼智能体应用接入高德地图MCP服务</h3><p><a target="_blank" rel="noopener" href="https://bailian.console.aliyun.com/?tab=app#/app-center/assistant/6f624944e0334768aa4d3a014f5a9913">大模型服务平台百炼控制台</a><br>在智能体应用的<strong>技能</strong>添加<strong>MCP服务</strong> <code>Amap Maps</code>需要提前开通即可</p>
<h3 id="MCP开发实战"><a href="#MCP开发实战" class="headerlink" title="MCP开发实战"></a>MCP开发实战</h3><h5 id="模型上下文协议（Model-Context-Protocol）"><a href="#模型上下文协议（Model-Context-Protocol）" class="headerlink" title="模型上下文协议（Model Context Protocol）"></a>模型上下文协议（Model Context Protocol）</h5><h5 id="MCP-简介"><a href="#MCP-简介" class="headerlink" title="MCP 简介"></a>MCP 简介</h5><p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/">模型上下文协议（即 Model Context Protocol，MCP）</a>是一个开放协议，它规范了应用程序如何向大型语言模型（LLM）提供上下文。MCP 提供了一种统一的方式将 AI 模型连接到不同的数据源和工具，它定义了统一的集成方式。在开发智能体（Agent）的过程中，我们经常需要将将智能体与数据和工具集成，MCP 以标准的方式规范了智能体与数据及工具的集成方式，可以帮助您在 LLM 之上构建智能体（Agent）和复杂的工作流。目前已经有大量的服务接入并提供了 MCP server 实现，当前这个生态正在以非常快的速度不断的丰富中，具体可参见：<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers">MCP Servers</a>。</p>
<h5 id="Spring-AI-MCP"><a href="#Spring-AI-MCP" class="headerlink" title="Spring AI MCP"></a>Spring AI MCP</h5><p>Spring AI MCP 为模型上下文协议提供 Java 和 Spring 框架集成。它使 Spring AI 应用程序能够通过标准化的接口与不同的数据源和工具进行交互，支持同步和异步通信模式。</p>
<p>Spring AI MCP 采用模块化架构，包括以下组件：</p>
<ul>
<li>Spring AI 应用程序：使用 Spring AI 框架构建想要通过 MCP 访问数据的生成式 AI 应用程序</li>
<li>Spring MCP 客户端：MCP 协议的 Spring AI 实现，与服务器保持 1:1 连接</li>
<li>MCP 服务器：轻量级程序，每个程序都通过标准化的模型上下文协议公开特定的功能</li>
<li>本地数据源：MCP 服务器可以安全访问的计算机文件、数据库和服务</li>
<li>远程服务：MCP 服务器可以通过互联网（例如，通过 API）连接到的外部系统</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>要启用此功能，请将以下依赖项添加到您项目的 Maven<code>pom.xml</code>文件中：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-mcp&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>或者添加到您的 Gradle<code>build.gradle</code>文件中：</p>
<pre><code class="xml">dependencies &#123;
    implementation &#39;org.springframework.experimental:spring-ai-mcp:1.0.0&#39;
&#125;
</code></pre>
<p>Spring AI MCP 目前并没有在 Maven Central Repository 中提供。需要将 <code>Spring milestone</code>仓库添加到<code>pom.xml</code>中，才可以访问 Spring AI MCP 工件：</p>
<pre><code class="xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-milestones&lt;/id&gt;
    &lt;name&gt;Spring Milestones&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/snapshots&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p>要使用 MCP，首先需要创建<code>McpClient</code>，它提供了与 MCP server 的同步和异步通信能力。现在我们创建一个 McpClient 来注册 MCP Brave 服务和 ChatClient，从而让 LLM 调用它们：</p>
<pre><code class="java">var stdioParams = ServerParameters.builder(&quot;npx&quot;)
        .args(&quot;-y&quot;, &quot;@modelcontextprotocol/server-brave-search&quot;)
        .addEnvVar(&quot;BRAVE_API_KEY&quot;, System.getenv(&quot;BRAVE_API_KEY&quot;))
        .build();

var mcpClient = McpClient.using(new StdioClientTransport(stdioParams)).sync();

var init = mcpClient.initialize();

var chatClient = chatClientBuilder
        .defaultFunctions(mcpClient.listTools(null)
                .tools()
                .stream()
                .map(tool -&gt; new McpFunctionCallback(mcpClient, tool))
                .toArray(McpFunctionCallback[]::new))
        .build();

String response = chatClient
        .prompt(&quot;Does Spring AI supports the Model Context Protocol? Please provide some references.&quot;)
        .call().content();
</code></pre>
<p>在上述代码中，首先通过<code>npx</code>命令启动一个独立的进程，运行<code>@modelcontextprotocol/server-brave-search</code>服务，并指定 Brave API 密钥。然后创建一个基于 stdio 的传输层，与 MCP server 进行通信。最后初始化与 MCP 服务器的连接。</p>
<p>要使用 McpClient，需要将<code>McpClient</code>注入到 Spring AI 的<code>ChatClient</code>中，从而让 LLM 调用 MCP server。在 Spring AI 中，可以通过 Function Callbacks 的方式将 MCP 工具转换为 Spring AI 的 Function，从而让 LLM 调用。</p>
<p>最后，通过<code>ChatClient</code>与 LLM 进行交互，并使用<code>McpClient</code>与 MCP server 进行通信，获取最终的返回结果。</p>
<p><strong>官方的alibaba服务教学</strong>：<code>C:\Users\Pluminary\Desktop\HouDuan\spring-ai-alibaba-examples</code></p>
<h5 id="Stdio传输层"><a href="#Stdio传输层" class="headerlink" title="Stdio传输层"></a>Stdio传输层</h5><p>Stdio(标准输入输出) 传输层是MCP最基本的传输实现方式。它通过进程间通信(IPC)实现</p>
<h5 id="SSE传输层"><a href="#SSE传输层" class="headerlink" title="SSE传输层"></a>SSE传输层</h5><p>SSE(Server-Sent Events) 传输层是基于HTTP的单向通信机制，专门用于服务器向客户端推送数据</p>
<h3 id="MCP是什么？和Function-calling有什么区别？美团面试题"><a href="#MCP是什么？和Function-calling有什么区别？美团面试题" class="headerlink" title="MCP是什么？和Function calling有什么区别？美团面试题"></a>MCP是什么？和Function calling有什么区别？<del>美团面试题</del></h3><p>MCP可以通过Client指定SSE 再去找一个远程地址直接就可以调用<del>MCP就像拓展坞，MCPServer可以部署到云端给外部使用</del><br>Function Calling则需要自己手动去写一个去调用外部</p>
<blockquote>
<p>这道面试题问的是：</p>
<blockquote>
<p><strong>MCP 是什么？它和 Function Calling 有什么区别？</strong></p>
</blockquote>
<p>来自美团，很可能是在考察你对 <strong>大模型应用框架</strong>（尤其是 RAG、工具调用、Agent 框架等）底层机制的理解，特别是近几年阿里推出的 Spring AI Alibaba MCP 模型调用框架。</p>
<hr>
<h2 id="✅-一、什么是-MCP？"><a href="#✅-一、什么是-MCP？" class="headerlink" title="✅ 一、什么是 MCP？"></a>✅ 一、什么是 MCP？</h2><p><strong>MCP（Model Call Protocol）</strong> 是阿里巴巴在 <a target="_blank" rel="noopener" href="https://github.com/springaialibaba/spring-ai-alibaba">Spring AI Alibaba</a> 框架中提出的一个模型调用协议，全称是：</p>
<blockquote>
<p><strong>Model Call Protocol（模型调用协议）</strong></p>
</blockquote>
<p>它的作用是：<br> 🔧 <strong>统一模型接入规范</strong>，为不同的大模型（阿里通义、百度文心、ChatGLM、文生图、图生图等）提供一套<strong>通用、标准、结构化的调用协议和扩展机制</strong>。</p>
<h3 id="✅-MCP-解决的问题："><a href="#✅-MCP-解决的问题：" class="headerlink" title="✅ MCP 解决的问题："></a>✅ MCP 解决的问题：</h3><ul>
<li>🌀 不同大模型调用方式、参数格式五花八门 → MCP 提供统一接口抽象</li>
<li>🛠 支持插件工具调用（Tool Calling）</li>
<li>🔁 支持多轮对话记忆</li>
<li>🤖 支持 Agent 架构（例如 RAG、Function调用等）</li>
<li>📦 可以灵活切换底层大模型，实现模型无感知迁移（例如将通义大模型无缝替换为文心一言）</li>
</ul>
<hr>
<h3 id="✅-MCP-的核心组件："><a href="#✅-MCP-的核心组件：" class="headerlink" title="✅ MCP 的核心组件："></a>✅ MCP 的核心组件：</h3><ol>
<li><code>MCPModel</code>：统一的模型接口（封装了 prompt 处理、调用逻辑等）</li>
<li><code>MCPFunctionCallingModel</code>：支持 Function Calling 的模型</li>
<li><code>MCPMessage</code>、<code>MCPResponse</code>：统一的输入&#x2F;输出数据结构</li>
<li><code>ToolDefinition</code>, <code>FunctionCall</code>, <code>ToolResult</code>：对工具调用结构化建模</li>
</ol>
<hr>
<h2 id="✅-二、什么是-Function-Calling？"><a href="#✅-二、什么是-Function-Calling？" class="headerlink" title="✅ 二、什么是 Function Calling？"></a>✅ 二、什么是 Function Calling？</h2><p>Function Calling 是由 OpenAI 提出的技术，后被各大模型厂商采纳（如通义千问、百度文心也支持），它让大模型在对话中能够调用外部函数。</p>
<h3 id="🔧-它的核心概念："><a href="#🔧-它的核心概念：" class="headerlink" title="🔧 它的核心概念："></a>🔧 它的核心概念：</h3><ul>
<li>大模型通过识别语义内容，决定是否调用一个函数（例如查天气、查数据库、生成图片等）</li>
<li>由用户预定义函数列表（Function Schema），模型根据意图选择调用</li>
<li>返回结构化 JSON 给开发者，由程序调用实际函数 → 执行后返回结果给模型</li>
</ul>
<hr>
<h3 id="✅-Function-Calling-实现的能力："><a href="#✅-Function-Calling-实现的能力：" class="headerlink" title="✅ Function Calling 实现的能力："></a>✅ Function Calling 实现的能力：</h3><table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>工具接入能力</td>
<td>让模型“用工具”去扩展知识或能力，如查资料、查库存、操作系统等</td>
</tr>
<tr>
<td>多轮调用链</td>
<td>支持调用链组合，如 A→B→C 的流程式工具使用</td>
</tr>
<tr>
<td>Agent能力基础</td>
<td>是 Agent 能够链式思维和计划任务执行的基础</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-三、MCP-和-Function-Calling-的关系与区别"><a href="#✅-三、MCP-和-Function-Calling-的关系与区别" class="headerlink" title="✅ 三、MCP 和 Function Calling 的关系与区别"></a>✅ 三、MCP 和 Function Calling 的关系与区别</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>MCP</th>
<th>Function Calling</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>一种大模型调用<strong>协议标准</strong></td>
<td>一种大模型的<strong>工具调用机制</strong></td>
</tr>
<tr>
<td>是否支持 Function</td>
<td>✅ 支持，MCP 中内置了 Function Calling 抽象</td>
<td>✅ 只关注“函数调用”，不管模型接入细节</td>
</tr>
<tr>
<td>作用范围</td>
<td>📦 模型统一封装、RAG、Chat、工具调用、记忆、代理等（整个调用框架）</td>
<td>🧠 模型如何调用函数、如何组织工具返回</td>
</tr>
<tr>
<td>抽象程度</td>
<td>高度抽象框架层，统一输入输出模型、适配各类模型</td>
<td>相对底层，是大模型的<strong>功能点</strong></td>
</tr>
<tr>
<td>使用者</td>
<td>开发框架作者（如 Spring AI Alibaba）</td>
<td>模型厂商、应用开发者</td>
</tr>
<tr>
<td>代表项目</td>
<td>Spring AI Alibaba MCP、LangChain4j MCP、百度文心 RAGFlow 等</td>
<td>OpenAI GPT、通义千问、ChatGLM、Claude 等支持 Function Calling 的模型</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-四、通俗比喻理解"><a href="#✅-四、通俗比喻理解" class="headerlink" title="✅ 四、通俗比喻理解"></a>✅ 四、通俗比喻理解</h2><blockquote>
<p>MCP 是一个大楼的 <strong>“总控中心”</strong>，可以调配各种大模型、工具、记忆、插件等资源</p>
<p>Function Calling 是这个大楼里的一套 <strong>“智能工具调度系统”</strong>，专门处理“这个请求要不要调用某个工具来完成”。</p>
</blockquote>
<hr>
<h2 id="✅-五、实际应用举例（代码层）"><a href="#✅-五、实际应用举例（代码层）" class="headerlink" title="✅ 五、实际应用举例（代码层）"></a>✅ 五、实际应用举例（代码层）</h2><p>在 Spring AI Alibaba 中，你可以这样使用 MCP + FunctionCalling：</p>
<pre><code>@Autowired
private FunctionCallingChatClient chatClient;

@PostMapping(&quot;/chat&quot;)
public String chat(@RequestBody String prompt) &#123;
    Message response = chatClient.call(
        Message.of(prompt),
        FunctionCallingOptions.builder()
            .function(ToolDefinitions.fromClass(MyFunction.class))
            .build()
    );
    return response.getContent();
&#125;
</code></pre>
<p>上面这段代码：</p>
<ul>
<li>使用 MCP 提供的 <code>FunctionCallingChatClient</code> 调用大模型</li>
<li>绑定了一个 Function（MyFunction），模型根据上下文会自动决定是否调用它</li>
</ul>
<hr>
<h2 id="✅-总结答法（面试简明说法）："><a href="#✅-总结答法（面试简明说法）：" class="headerlink" title="✅ 总结答法（面试简明说法）："></a>✅ 总结答法（面试简明说法）：</h2><blockquote>
<p>MCP 是阿里推出的模型调用协议，统一了模型接入、工具调用、Agent 调度等能力，是一种面向“统一模型开发框架”的抽象；Function Calling 是大模型的一种能力，允许它根据语义调用结构化函数。MCP 包含了 Function Calling 能力，但它作用更广，面向的是整套大模型调用生命周期，Function Calling 则聚焦在“如何让模型使用外部函数”这件事上。</p>
</blockquote>
</blockquote>
<h2 id="电商智能客服项目"><a href="#电商智能客服项目" class="headerlink" title="电商智能客服项目"></a><span style ="color:red">电商智能客服项目</span></h2><h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><p><code>JDK17、SpringBoot3.4.0、Spring AI 1.0.0-M6、Spring AI Alibaba 1.0.0-M6.1</code></p>
<h5 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/105e0b2c60fafdf49943dd1fc8283011dacbc1fb/%E7%94%B5%E5%95%86%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.png"></p>
<p><strong>项目位于</strong>：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai</code><br><strong>前端</strong>位于：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai\frontend</code></p>
<blockquote>
<p>可以右键通过终端打开文件夹<br>①：yarn install    安装依赖<br>②：yarn dev        启动项目</p>
</blockquote>
<p><strong>后端</strong>位于：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order</code>【order.sql也在这里】；<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai</code>分别启动两个模块的<code>Application</code></p>
<h4 id="使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装"><a href="#使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装" class="headerlink" title="使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装"></a>使用MCP调用订单服务查询订单详情<del>MCPServer是对订单层的包装</del></h4><p>项目位于<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order-mcp-client</code>；<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order-mcp-server</code><br><code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order</code></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#1bccbc>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/07/08/AI/SpringAI-Alibaba/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/06/15/后端/Jenkins/">
        <h2>
            Jenkins
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/6/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="持续集成及JenKins介绍"><a href="#持续集成及JenKins介绍" class="headerlink" title="持续集成及JenKins介绍"></a>持续集成及JenKins介绍</h3><p><strong>配套原版资料</strong>：<a href="file:///E:/Java实例项目1-20套/资料-Jenkins教程/Jenkins资料/笔记/Jenkins持续集成从入门到精通.pdf">Jenkins持续集成从入门到精通.pdf</a></p>
<p>软件开发生命周期【<strong>需求分析、设计、实现、测试、进化</strong>】</p>
<h3 id="软件开发瀑布模型"><a href="#软件开发瀑布模型" class="headerlink" title="软件开发瀑布模型"></a>软件开发瀑布模型</h3><p>瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>简单易用和理解</td>
<td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地 增加了工作量。</td>
</tr>
<tr>
<td>当前一阶段完成后，您只需要 去关注后续阶段</td>
<td>由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险</td>
</tr>
<tr>
<td>为项目提供了按阶段划分的检 查节点</td>
<td>瀑布模型的突出缺点是不适应用户需求的变化</td>
</tr>
</tbody></table>
<h3 id="软件开发敏捷开发模型"><a href="#软件开发敏捷开发模型" class="headerlink" title="软件开发敏捷开发模型"></a>软件开发敏捷开发模型</h3><p>敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。 </p>
<p>&#x3D;&#x3D;<strong>何为迭代开发</strong>？&#x3D;&#x3D; 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大 开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开 发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而 是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨 道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 </p>
<p>&#x3D;&#x3D;<strong>何为增量开发</strong>？&#x3D;&#x3D; 软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一 号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地 基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…..</p>
<p>敏捷开发如何迭代？<br>虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。</p>
<p>敏捷开发有什么好处？  </p>
<p>&#x3D;&#x3D;<strong>早期交付</strong>&#x3D;&#x3D; 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照 传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完 成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后 才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后 面每个月都会有现金流，资金压力就大大减轻了。 </p>
<p>&#x3D;&#x3D;<strong>降低风险</strong>&#x3D;&#x3D; 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比 较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。 <strong>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量</strong>。它的核心措施是，代码集成到主干 之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归 功于持续集成</p>
<h5 id="持续集成的流程"><a href="#持续集成的流程" class="headerlink" title="持续集成的流程"></a>持续集成的流程</h5><h6 id="提交"><a href="#提交" class="headerlink" title="提交"></a><span style = "color:red"><strong>提交</strong></span></h6><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。 </p>
<h6 id="测试（第一轮）"><a href="#测试（第一轮）" class="headerlink" title="测试（第一轮） "></a><span style = "color:red"><strong>测试（第一轮）</strong> </span></h6><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 </p>
<h6 id="构建"><a href="#构建" class="headerlink" title="构建 "></a><span style = "color:red"><strong>构建</strong> </span></h6><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实 际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 </p>
<h6 id="测试（第二轮）"><a href="#测试（第二轮）" class="headerlink" title="测试（第二轮） "></a><span style = "color:red"><strong>测试（第二轮）</strong> </span></h6><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。 </p>
<h6 id="部署"><a href="#部署" class="headerlink" title="部署 "></a><span style = "color:red"><strong>部署</strong> </span></h6><p>过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 </p>
<h6 id="回滚"><a href="#回滚" class="headerlink" title="回滚 "></a><span style = "color:red"><strong>回滚</strong> </span></h6><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录</p>
<h3 id="持续集成的组成要素"><a href="#持续集成的组成要素" class="headerlink" title="持续集成的组成要素"></a>持续集成的组成要素</h3><ul>
<li>一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的，无需人工干预。 </li>
<li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。 </li>
<li>一个持续集成服务器，Jenkins 就是一个配置简单和使用方便的持续集成服务器</li>
</ul>
<h3 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h3><p>1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；<br>2、对系统健康持续检查，减少发布风险带来的问题；<br>3、减少重复性工作；<br>4、<strong>持续部署</strong>，提供可部署单元包；<br>5、持续交付可供使用的版本；<br>6、增强团队信心</p>
<h3 id="JenKins介绍"><a href="#JenKins介绍" class="headerlink" title="JenKins介绍"></a><span style = "color:red">JenKins介绍</span></h3><p>Jenkins  是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。官网：  <a target="_blank" rel="noopener" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a><br>CI：持续集成（Continuous Integration）<br>CD：持续部署（Continuous ????）</p>
<h4 id="Jenkins的特征："><a href="#Jenkins的特征：" class="headerlink" title="Jenkins的特征："></a>Jenkins的特征：</h4><ul>
<li>开源的 Java语言开发持续集成工具，支持持续集成，持续部署。 </li>
<li>易于安装部署配置：可通过 方便web界面配置管理。 </li>
<li>消息通知及测试报告：集成 yum安装,或下载war包以及通过docker容器等快速实现安装部署，可 RSS&#x2F;E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit&#x2F;TestNG测试报告。 Jenkins能够让多台计算机一起构建&#x2F;测试。 </li>
<li>分布式构建：支持 </li>
<li>文件识别： Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 </li>
<li>丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如 docker等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5a664e75de77e3633f64215df2e5990365c3606a/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E.png" alt="持续集成流程说明"></p>
<h4 id="服务器列表-统一使用CentOS7"><a href="#服务器列表-统一使用CentOS7" class="headerlink" title="服务器列表[统一使用CentOS7]"></a>服务器列表[统一使用CentOS7]</h4><table>
<thead>
<tr>
<th>名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码托管服务器</strong></td>
<td>192.168.200.128</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td><strong>持续集成服务器</strong></td>
<td>192.168.200.129</td>
<td>Jenkins-2.190.3，JDK1.8，Maven3.6.2，Git， SonarQube</td>
</tr>
<tr>
<td><strong>应用测试服务器</strong></td>
<td>192.168.66.102</td>
<td>JDK1.8，Tomcat8.5</td>
</tr>
</tbody></table>
<h3 id="Gitlab-团队个人版github-代码托管服务器安装"><a href="#Gitlab-团队个人版github-代码托管服务器安装" class="headerlink" title="Gitlab[团队个人版github]代码托管服务器安装"></a>Gitlab[团队个人版github]代码托管服务器安装</h3><p>[lanyun_group &#x2F; web_demo · GitLab] (<a target="_blank" rel="noopener" href="http://192.168.200.128:82/lanyun_group/web_demo">http://192.168.200.128:82/lanyun_group/web_demo</a>)</p>
<p>官网：  <a target="_blank" rel="noopener" href="https://about.gitlab.com/">https://about.gitlab.com/</a><br>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的 web服务。</p>
<p>GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似， 可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，GitLab是可以部署到自己的服务器 上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放 在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub</p>
<ul>
<li><p>安装相关依赖 </p>
<blockquote>
<p>yum -y install policycoreutils openssh-server openssh-clients postfix</p>
</blockquote>
</li>
<li><p>启动ssh服务&amp;设置为开机启动</p>
<blockquote>
<p>systemctl enable sshd &amp;&amp; sudo systemctl start sshd </p>
</blockquote>
</li>
<li><p>设置postfix开机自启，并启动，postfix支持gitlab发信功能</p>
<blockquote>
<p>systemctl enable postfix &amp;&amp; systemctl start postfix </p>
</blockquote>
</li>
<li><p>开放ssh以及http服务，然后重新加载防火墙列表 </p>
<blockquote>
<p>firewall-cmd –add-service&#x3D;ssh –permanent<br>firewall-cmd –add-service&#x3D;http –permanent<br>firewall-cmd –reload </p>
</blockquote>
<p>如果关闭防火墙就不需要做以上配置 </p>
</li>
<li><p>下载gitlab包，并且安装 </p>
<blockquote>
<p><strong>在线下载安装包</strong>：<br>wget  <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x</a> 86_64.rpm <strong>安装</strong>：<br>rpm -i gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm </p>
</blockquote>
</li>
<li><p>修改gitlab配置 </p>
<blockquote>
<p>vi &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb </p>
</blockquote>
<p>修改gitlab访问地址和端口，默认为80，我们改为82<br>external_url ‘ <a href="http://192.168.200.132:82&#39;">http://192.168.200.132:82&#39;</a><br>nginx[‘listen_port’] &#x3D; 82 </p>
</li>
<li><p>重载配置及<span style = "color:red"><strong>启动gitlab</strong></span> </p>
<blockquote>
<p>gitlab-ctl reconfigure<br>gitlab-ctl restart  ★★</p>
</blockquote>
</li>
<li><p>把端口添加到防火墙</p>
</li>
</ul>
<blockquote>
<p>firewall-cmd –zone&#x3D;public –add-port&#x3D;82&#x2F;tcp –permanent<br>firewall-cmd –reload </p>
<p>启动成功后，看到以下修改管理员root密码的页面，修改密码后，然后登录即可</p>
</blockquote>
<p>账号：root<br>密码：panchunyao123</p>
<h6 id="Gitlab用户在组里面有5种不同权限："><a href="#Gitlab用户在组里面有5种不同权限：" class="headerlink" title="Gitlab用户在组里面有5种不同权限："></a>Gitlab用户在组里面有5种不同权限：</h6><p>Guest：可以创建issue、发表评论，不能读写版本库<br>Reporter：可以克隆代码，不能提交，QA、PM 可以赋予这个权限<br>Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限<br>Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个 权限 Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组 长可以赋予这个权限</p>
<p>如果张三被管理员添加了Owner权限，那么张三就可以在idea里面通过gitlab里面的仓库地址 上传项目到这个web_demo了。</p>
<h4 id="持续集成环境—Jenkins安装【我用了最新的Jenkins-2-440-1】"><a href="#持续集成环境—Jenkins安装【我用了最新的Jenkins-2-440-1】" class="headerlink" title="持续集成环境—Jenkins安装【我用了最新的Jenkins 2.440.1】"></a>持续集成环境—Jenkins安装【我用了最新的Jenkins 2.440.1】</h4><p>[Setup Wizard [Jenkins]] (<a target="_blank" rel="noopener" href="http://192.168.200.129:8888/">http://192.168.200.129:8888/</a>)</p>
<ul>
<li><p>安装JDK Jenkins需要依赖JDK，所以先安装JDK1.8 </p>
<blockquote>
<p>yum install java-1.8.0-openjdk* -y</p>
</blockquote>
</li>
</ul>
<p>​       安装目录为：&#x2F;usr&#x2F;lib&#x2F;jvm </p>
<ul>
<li>获取jenkins安装包</li>
</ul>
<p>下载页面： <a target="_blank" rel="noopener" href="https://jenkins.io/zh/download/">https://jenkins.io/zh/download/</a><br>安装文件：jenkins-2.190.3-1.1.noarch.rpm </p>
<ul>
<li><p>把安装包上传到192.168.66.101服务器，进行安装 </p>
<blockquote>
<p>rpm -ivh jenkins-2.190.3-1.1.noarch.rpm </p>
</blockquote>
</li>
<li><p>进入文件目录</p>
<blockquote>
<p>cd &#x2F;etc&#x2F;sysconfig</p>
</blockquote>
</li>
<li><p>修改Jenkins配置 </p>
<blockquote>
<p>vi jenkins</p>
</blockquote>
</li>
</ul>
<p>修改内容如下： </p>
<blockquote>
<p>JENKINS_USER&#x3D;”root”<br>JENKINS_PORT&#x3D;”8888” </p>
</blockquote>
<ul>
<li><p><span style = "color:red">启动<strong>Jenkins</strong></span></p>
<blockquote>
<p>systemctl start jenkins ★★</p>
<p>[root@localhost sysconfig]# systemctl start jenkins</p>
</blockquote>
</li>
<li><p>打开浏览器访问<br>[192.168.200.129:8888] (<a target="_blank" rel="noopener" href="http://192.168.200.129:8888/">http://192.168.200.129:8888/</a>)<br>注意：本服务器把防火墙关闭了，如果开启防火墙，需要在防火墙添加端口 </p>
</li>
<li><p>获取并输入admin账户密码 </p>
<blockquote>
<p>[root@localhost sysconfig]# cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword</p>
<p>[root@localhost sysconfig]# cat &#x2F;root&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword<br>3d83c355f83d4942847d4390fc5dcc39</p>
</blockquote>
</li>
<li><p>跳过插件安装 [点击第二个选择 然后上面全无]<br>因为Jenkins插件需要连接默认官网下载，速度非常慢，而且经过会失败，所以我们暂时先跳过插件安装</p>
</li>
</ul>
<h6 id="综上操作"><a href="#综上操作" class="headerlink" title="综上操作"></a>综上操作</h6><blockquote>
<p>[root@localhost ~]# java -version<br>java version “21.0.1” 2023-10-17 LTS<br>Java(TM) SE Runtime Environment (build 21.0.1+12-LTS-29)<br>Java HotSpot(TM) 64-Bit Server VM (build 21.0.1+12-LTS-29, mixed mode, sharing)<br>[root@localhost ~]# cd &#x2F;usr&#x2F;lib&#x2F;jvm<br>[root@localhost jvm]# ll<br>总用量 0<br>lrwxrwxrwx. 1 root root  26 6月  15 16:27 java -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk<br>lrwxrwxrwx. 1 root root  32 6月  15 16:27 java-1.8.0 -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_1.8.0<br>lrwxrwxrwx. 1 root root  40 6月  15 16:27 java-1.8.0-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_1.8.0_openjdk<br>drwxr-xr-x. 9 root root 109 6月  15 16:27 java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64<br>lrwxrwxrwx. 1 root root  34 6月  15 16:27 java-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_openjdk<br>lrwxrwxrwx. 1 root root  21 6月  15 16:27 jre -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre<br>lrwxrwxrwx. 1 root root  27 6月  15 16:27 jre-1.8.0 -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_1.8.0<br>lrwxrwxrwx. 1 root root  35 6月  15 16:27 jre-1.8.0-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_1.8.0_openjdk<br>lrwxrwxrwx. 1 root root  49 6月  15 16:27 jre-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64 -&gt; java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64&#x2F;jre<br>lrwxrwxrwx. 1 root root  29 6月  15 16:27 jre-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_openjdk<br>[root@localhost jvm]# cd java-1.8.0-openjdk<br>[root@localhost java-1.8.0-openjdk]#</p>
</blockquote>
<blockquote>
<h2 id="下一步：你只需要执行-升级Jenkins的升级流程"><a href="#下一步：你只需要执行-升级Jenkins的升级流程" class="headerlink" title="下一步：你只需要执行 升级Jenkins的升级流程"></a>下一步：你只需要执行 升级Jenkins的升级流程</h2><h3 id="以下是你的专属升级操作指令合集（CentOS-7-专用）："><a href="#以下是你的专属升级操作指令合集（CentOS-7-专用）：" class="headerlink" title="以下是你的专属升级操作指令合集（CentOS 7 专用）："></a>以下是你的专属升级操作指令合集（CentOS 7 专用）：</h3><hr>
<h3 id="🔧-1-备份-Jenkins-数据（可选但强烈推荐）"><a href="#🔧-1-备份-Jenkins-数据（可选但强烈推荐）" class="headerlink" title="🔧 1. 备份 Jenkins 数据（可选但强烈推荐）"></a>🔧 1. 备份 Jenkins 数据（可选但强烈推荐）</h3><pre><code class="js">sudo systemctl stop jenkins
sudo cp -r /var/lib/jenkins /var/lib/jenkins_backup_$(date +%F)
sudo cp /etc/sysconfig/jenkins /etc/sysconfig/jenkins.bak
</code></pre>
<hr>
<h3 id="🔧-2-添加-Jenkins-官方-LTS-Yum-源"><a href="#🔧-2-添加-Jenkins-官方-LTS-Yum-源" class="headerlink" title="🔧 2. 添加 Jenkins 官方 LTS Yum 源"></a>🔧 2. 添加 Jenkins 官方 LTS Yum 源</h3><pre><code class="js">sudo curl --silent --location https://pkg.jenkins.io/redhat-stable/jenkins.repo | sudo tee /etc/yum.repos.d/jenkins.repo &gt; /dev/null
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
</code></pre>
<hr>
<h3 id="🔧-3-升级-Jenkins"><a href="#🔧-3-升级-Jenkins" class="headerlink" title="🔧 3. 升级 Jenkins"></a>🔧 3. 升级 Jenkins</h3><pre><code class="js">sudo yum clean all
sudo yum makecache
sudo yum upgrade jenkins -y
</code></pre>
<p>如果提示没有可升级的版本，执行以下命令强制重新安装最新版 Jenkins：</p>
<pre><code class="js">sudo yum remove jenkins -y
sudo yum install jenkins -y
</code></pre>
<p>⚠️ <strong>不会丢失数据</strong>，因为 Jenkins 配置、任务、插件都在 <code>/var/lib/jenkins</code> 中，你已经备份过。</p>
<hr>
<h3 id="🔧-4-启动-Jenkins-并查看状态"><a href="#🔧-4-启动-Jenkins-并查看状态" class="headerlink" title="🔧 4. 启动 Jenkins 并查看状态"></a>🔧 4. 启动 Jenkins 并查看状态</h3><pre><code class="js">sudo systemctl daemon-reexec
sudo systemctl start jenkins
sudo systemctl status jenkins
</code></pre>
<hr>
<h3 id="🔧-5-访问-Jenkins-页面"><a href="#🔧-5-访问-Jenkins-页面" class="headerlink" title="🔧 5. 访问 Jenkins 页面"></a>🔧 5. 访问 Jenkins 页面</h3><p>访问地址：</p>
<pre><code class="js">http://&lt;你的服务器IP&gt;:8888
</code></pre>
<hr>
<h3 id="🔧-6-查看-Jenkins-新版本号"><a href="#🔧-6-查看-Jenkins-新版本号" class="headerlink" title="🔧 6. 查看 Jenkins 新版本号"></a>🔧 6. 查看 Jenkins 新版本号</h3><pre><code class="js">jenkins --version
</code></pre>
<p>或者登录网页右下角查看，应该是类似：</p>
<pre><code class="js">Jenkins ver. 2.440.1
</code></pre>
</blockquote>
<blockquote>
<h2 id="查看-Jenkins-服务状态"><a href="#查看-Jenkins-服务状态" class="headerlink" title="查看 Jenkins 服务状态"></a>查看 Jenkins 服务状态</h2><p>请运行以下命令获取具体错误：</p>
<pre><code class="js">sudo systemctl status jenkins -l
</code></pre>
</blockquote>
<blockquote>
<h3 id="步骤-3：重启-Jenkins-服务"><a href="#步骤-3：重启-Jenkins-服务" class="headerlink" title="步骤 3：重启 Jenkins 服务"></a>步骤 3：重启 Jenkins 服务</h3><pre><code class="js">sudo systemctl daemon-reexec
sudo systemctl restart jenkins
sudo systemctl status jenkins -l
</code></pre>
</blockquote>
<blockquote>
<h3 id="🔗-插件下载地址与命令"><a href="#🔗-插件下载地址与命令" class="headerlink" title="🔗 插件下载地址与命令"></a>🔗 插件下载地址与命令</h3><p>以下命令会下载所有缺失依赖：</p>
<pre><code>bash复制编辑# 进入 Jenkins 插件目录
cd /var/lib/jenkins/plugins

# 下载缺失的依赖插件
wget https://updates.jenkins.io/download/plugins/commons-lang3-api/3.13.0-62.v7d18e55f51e2/commons-lang3-api.hpi
wget https://updates.jenkins.io/download/plugins/ionicons-api/56.v1b_1c8c49374e/ionicons-api.hpi
wget https://updates.jenkins.io/download/plugins/caffeine-api/3.1.8-133.v17b_1ff2e0599/caffeine-api.hpi
</code></pre>
</blockquote>
<h4 id="持续集成环境—Jenkins插件管理【Manage-Jenkins】"><a href="#持续集成环境—Jenkins插件管理【Manage-Jenkins】" class="headerlink" title="持续集成环境—Jenkins插件管理【Manage Jenkins】"></a>持续集成环境—Jenkins插件管理【Manage Jenkins】</h4><p>Jenkins本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用 Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。 </p>
<h5 id="修改Jenkins插件下载地址"><a href="#修改Jenkins插件下载地址" class="headerlink" title="修改Jenkins插件下载地址"></a>修改Jenkins插件下载地址</h5><p>Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址：<br>Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available<br>新版本：<u>Jenkins → Manage Jenkins → Plugins → Avaliable plugins</u></p>
<h5 id="去Jenkins默认的开发目录"><a href="#去Jenkins默认的开发目录" class="headerlink" title="去Jenkins默认的开发目录"></a>去Jenkins默认的开发目录</h5><p>这样做是为了把 Jenkins官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址</p>
<blockquote>
<p>[root@localhost sysconfig]# cd &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;<br>[root@localhost jenkins]# cd updates&#x2F;<br>[root@localhost updates]# ll<br>总用量 3064<br>-rw-r–r–. 1 root root 3125621 6月  15 16:38 default.json<br>-rw-r–r–. 1 root root    7976 6月  15 16:38 hudson.tasks.Maven.MavenInstaller</p>
</blockquote>
<blockquote>
<p>sed -i ‘s&#x2F;http://updates.jenkins ci.org/download&#x2F;https://mirrors.tuna.tsinghua.edu.cn/jenkins&#x2F;g’ default.json &amp;&amp; sed -i ‘s&#x2F;http:// <a target="_blank" rel="noopener" href="http://www.google.com/https:////">www.google.com/https:\/\/</a> <a target="_blank" rel="noopener" href="http://www.baidu.com/g&#39;">www.baidu.com/g&#39;</a> default.json</p>
</blockquote>
<p>最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/restart">http://192.168.200.129:8888/restart</a> 重启Jenkins</p>
<h4 id="下载中文汉化插件"><a href="#下载中文汉化插件" class="headerlink" title="下载中文汉化插件"></a>下载中文汉化插件</h4><p><a target="_blank" rel="noopener" href="http://192.168.66.101:8888/restart">http://192.168.66.101:8888/restart</a> ，重启Jenkins。 Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available，搜索”Chinese”</p>
<h4 id="开启权限全局安全配置"><a href="#开启权限全局安全配置" class="headerlink" title="开启权限全局安全配置"></a>开启权限全局安全配置</h4><p>在Security中的授权策略切换为 “Role-Based Strategy”，保存</p>
<p>【从插件市场上下载下来的 可以直接通过MobaXterm 放在&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins&#x2F; 然后重启Jenkins】</p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><p>在系统管理页面进入 Manage and Assign Roles；点击”Manage Roles”</p>
<p>里面的<strong>Global roles</strong>（全局角色）：管理员等高级用户可以创建基于全局的角色 Project roles（项目角色）： 针对某个或者某些项目的角色 Slave roles（奴隶角色）：节点相关的权限</p>
<p>我们添加以下三个角色：【<u>一个基础角色 两个项目角色</u>】</p>
<ul>
<li><strong>baseRole</strong> ：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑 定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色，会报错误：用户名 is missing the Overall&#x2F;Read permission </li>
<li><strong>role1</strong> ：该角色为<strong>项目角色</strong>(下面的Item roles)。使用正则表达式绑定” <strong>itcast.</strong>* “，意思是只能操作itcast开头的项目。</li>
<li><strong>role2</strong> ：该角色也为<strong>项目角色</strong>。绑定”itheima.*”，意思是只能操作itheima开头的项目。</li>
</ul>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>在系统管理页面进入 <strong>Manage Users</strong><br><strong>用户一</strong>：用户名：eric     密码：123456<br><strong>用户二</strong>：用户名：JacK    密码：123456</p>
<h4 id="给用户分配角色"><a href="#给用户分配角色" class="headerlink" title="给用户分配角色"></a>给用户分配角色</h4><p>系统管理页面进入Manage and Assign Roles，点击Assign Roles<br>绑定规则如下： </p>
<ul>
<li>eric 用户分别绑定baseRole和role1角色 </li>
<li>jack 用户分别绑定baseRole和role2角色</li>
</ul>
<h4 id="创建项目测试权限"><a href="#创建项目测试权限" class="headerlink" title="创建项目测试权限"></a>创建项目测试权限</h4><p>以itcast管理员账户创建两个项目，分别为itcast01和itheima01</p>
<p>结果为： </p>
<ul>
<li>eric 用户登录，只能看到itcast01项目 </li>
<li>jack 用户登录，只能看到itheima01项目</li>
</ul>
<h2 id="持续集成环境—Jenkins凭证管理"><a href="#持续集成环境—Jenkins凭证管理" class="headerlink" title="持续集成环境—Jenkins凭证管理"></a>持续集成环境—Jenkins凭证管理</h2><p>凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，<u><strong>以便 Jenkins可以和这些第三方的应用进行交互</strong></u>。 </p>
<h5 id="安装Credentials-Binding插件"><a href="#安装Credentials-Binding插件" class="headerlink" title="安装Credentials Binding插件"></a>安装Credentials Binding插件</h5><p>要在Jenkins使用凭证管理功能，需要安装<strong>Credentials Binding</strong>插件<br>安装插件后，左边多了”<strong>凭证</strong>“菜单，在这里管理所有凭证 [新版是在<strong>Security</strong>栏有<strong>凭证管理</strong>]<br>进入凭据后点击<strong>Stores scoped to Jenkins</strong>下     <strong>域</strong>的**<u>全局</u>**</p>
<h6 id="可以添加的凭证有-5种："><a href="#可以添加的凭证有-5种：" class="headerlink" title="可以添加的凭证有 5种："></a>可以添加的凭证有 5种：</h6><ul>
<li>Username with password ：用户名和密码 </li>
<li>SSH Username with private key： 使用SSH用户和密钥 </li>
<li>Secret file：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的Secret file就会被删除。 </li>
<li>Secret text ：需要保存的一个加密的文本串，如钉钉机器人或Github的api token【k8s也会用】</li>
<li>Certificate ：通过上传证书文件的方式</li>
</ul>
<p>常用的凭证类型有：<strong>Username with password（用户密码）</strong>和<strong>SSH Username with private key（SSH 密钥）</strong><br>接下来以使用Git工具到Gitlab拉取项目源码为例，演示Jenkins的如何管理Gitlab的凭证<br>★ <u><strong>在Jenkins里面安装git插件</strong></u><br>★ <u>要先在<strong>Jenkins的服务</strong>里面安装git插件</u></p>
<p><strong>CentOS7上安装Git工具</strong>：</p>
<pre><code class="js">yum install git -y            安装
git --version                 安装后查看版本
</code></pre>
<h4 id="用户密码类型"><a href="#用户密码类型" class="headerlink" title="用户密码类型"></a>用户密码类型</h4><p>**<u>全局添加凭证</u>**：Dashboard → Manage Jenkins → Credentials → System → Global credentials (unrestricted) → New credentials</p>
<p>-<br>  Jenkins-&gt;凭证-&gt;系统-&gt;全局凭证-&gt;添加凭证</p>
<h5 id="测试凭证是否可用"><a href="#测试凭证是否可用" class="headerlink" title="测试凭证是否可用"></a>测试凭证是否可用</h5><p>创建一个FreeStyle项目：新建Item-&gt;FreeStyle Project-&gt;确定<br>找到 “源码管理”-&gt;”Git”，在Repository URL复制Gitlab中的项目URL</p>
<p><strong>新搞个item然后点击进去 左侧的配置→General→源码管理→选择Git →↓</strong> </p>
<pre><code class="java">Repository URL：http://192.168.200.128:82/lanyun_group/web_demo.git
Credentials：【选择刚刚给张三创建的凭证】
</code></pre>
<p>保存配置后，点击构建 ”Build Now“ 开始构建项目<br>可以在左下方的Builds里找到刚刚构建的项目 可以查看控制台输出</p>
<pre><code class="java">Started by user root
Running as SYSTEM
Building in workspace /var/lib/jenkins/workspace/test02
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
Cloning the remote Git repository
Cloning repository http://192.168.200.128:82/lanyun_group/web_demo.git
 &gt; git init /var/lib/jenkins/workspace/test02 # timeout=10
Fetching upstream changes from http://192.168.200.128:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.128:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git config remote.origin.url http://192.168.200.128:82/lanyun_group/web_demo.git # timeout=10
 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 2f41cd33af519a5c55df8d78ba59032d9069f0b8 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 2f41cd33af519a5c55df8d78ba59032d9069f0b8 # timeout=10
Commit message: &quot;初始化项目提交&quot;
First time build. Skipping changelog.
Finished: SUCCESS
</code></pre>
<p>查看**&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;**目录，发现已经从Gitlab成功拉取了代码到Jenkins中</p>
<h4 id="SSH密钥类型"><a href="#SSH密钥类型" class="headerlink" title="SSH密钥类型"></a>SSH密钥类型</h4><h6 id="SSH免密登录示意图："><a href="#SSH免密登录示意图：" class="headerlink" title="SSH免密登录示意图："></a>SSH免密登录示意图：</h6><p>[<u>GitLab服务器(存放公钥：id_rsa.pub)</u>] ←←←<strong>ssh免密登录</strong>←←← [<u>Jenkins服务器(存放私钥：id_rsa)</u>]</p>
<ul>
<li><h5 id="使用root用户生成公钥和私钥"><a href="#使用root用户生成公钥和私钥" class="headerlink" title="使用root用户生成公钥和私钥"></a>使用root用户生成公钥和私钥</h5></li>
</ul>
<blockquote>
<p>ssh-keygen -t rsa</p>
</blockquote>
<pre><code class="java">在 192.168.200.129_Jenkins 服务器里

[root@localhost ~]# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Created directory &#39;/root/.ssh&#39;.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:88fFvAS2e6i9c4+KXfmENWeu6NJNmOb1+CCsYLarYLc root@localhost.localdomain
The key&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|            o    |
|           . =   |
|        S   .o=.+|
|         o o+=oBo|
|    o . + .+B+Boo|
|   . o + o.B+=+*.|
|      E.o.+oB=oo+|
+----[SHA256]-----+

[root@localhost ~]# cd /root/.ssh
[root@localhost .ssh]# ll
总用量 8
-rw-------. 1 root root 1679 6月  18 20:05 id_rsa       【私钥】
-rw-r--r--. 1 root root  408 6月  18 20:05 id_rsa.pub   【公钥】
</code></pre>
<ul>
<li><h5 id="要在gitlab服务里存放一个公钥"><a href="#要在gitlab服务里存放一个公钥" class="headerlink" title="要在gitlab服务里存放一个公钥"></a>要在gitlab服务里存放一个公钥</h5></li>
</ul>
<p>以root账户登录-&gt;点击头像-&gt;Settings-&gt;SSH Keys→在Jenkins服务里面用<br> <code>[root@localhost .ssh]# cat id_rsa.pub</code><br>打开公钥的文件得到信息。复制刚才id_rsa.pub文件的内容到这里，点击”Add Key”</p>
<ul>
<li><h5 id="在Jenkins中添加凭证，配置私钥"><a href="#在Jenkins中添加凭证，配置私钥" class="headerlink" title="在Jenkins中添加凭证，配置私钥"></a>在Jenkins中添加凭证，配置私钥</h5></li>
</ul>
<p>在Jenkins添加一个全局新的凭证，类型为”<strong>SSH Username with private key</strong>“，在jenkins服务器里输入指令查看<strong>私钥</strong><br><code>[root@localhost .ssh]# cat id_rsa</code><br>把刚才生成<strong>私钥</strong>文件内容复制过来塞进去<br>此时去gitlab项目中把ssh的复制过来<code>git@192.168.200.128:lanyun_group/web_demo.git</code><br>同样尝试构建项目，如果代码可以正常拉取，代表凭证配置成功！</p>
<p><span style = "color:red"><strong>如果报错</strong></span>：</p>
<pre><code class="java">Command &quot;git ls-remote -h git@192.168.200.128:lanyun_group/web_demo.git HEAD&quot; returned status code 128
stderr: No ECDSA host key is known for 192.168.200.128 and you have requested strict checking.
Host key verification failed.
fatal: Could not read from remote repository.
</code></pre>
<p><span style = "color:red"><strong>报错原因</strong></span>：</p>
<pre><code class="java">SSH 主机指纹未验证（Host key verification failed）

Git 使用的是 SSH 协议访问远程仓库（git@192.168.200.128），但本地机器之前没有连接过该主机，或者 .ssh/known_hosts 文件中没有该 IP 的公钥信息。

而且启用了“严格检查”（Strict Host Key Checking），所以 Git 拒绝连接该服务器。



★★ 方法：手动信任主机（推荐）★★
ssh git@192.168.200.128
系统会提示你是否信任该主机，比如：

The authenticity of host &#39;192.168.200.128 (192.168.200.128)&#39; can&#39;t be established.
ECDSA key fingerprint is SHA256:xxx...
Are you sure you want to continue connecting (yes/no/[fingerprint])?
✅ 输入 yes 之后，主机公钥会加入 ~/.ssh/known_hosts 文件，后续连接将不再失败。
</code></pre>
<h6 id="到这里已经完成了这份图的部分内容，要开始融入Maven"><a href="#到这里已经完成了这份图的部分内容，要开始融入Maven" class="headerlink" title="到这里已经完成了这份图的部分内容，要开始融入Maven"></a><strong><u>到这里已经完成了这份图的部分内容，要开始融入Maven</u></strong></h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/5a664e75de77e3633f64215df2e5990365c3606a/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E.png" alt="持续集成流程说明"></p>
<h2 id="持续集成环境—Maven安装和配置"><a href="#持续集成环境—Maven安装和配置" class="headerlink" title="持续集成环境—Maven安装和配置"></a>持续集成环境—Maven安装和配置</h2><p>在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目</p>
<p>把<code>apache-maven-3.6.2-bin.tar.gz</code>传到 &#x2F;root 根目录中【Jenkins服务器】</p>
<pre><code class="java">tar -xzf apache-maven-3.6.2-bin.tar.gz       解压
mkdir -p /opt/maven                          创建目录
mv apache-maven-3.6.2/* /opt/maven           移动文件
</code></pre>
<blockquote>
<p>[root@localhost ~]# mkdir -p &#x2F;opt&#x2F;maven<br>[root@localhost ~]# mv apache-maven-3.6.2&#x2F;* &#x2F;opt&#x2F;maven<br>[root@localhost ~]# cd &#x2F;opt&#x2F;maven&#x2F;<br>[root@localhost maven]# ll<br>总用量 28<br>drwxr-xr-x. 2 root root     97 6月  18 21:37 bin<br>drwxr-xr-x. 2 root root     42 6月  18 21:37 boot<br>drwxrwxr-x. 3 1000 mysql    63 8月  27 2019 conf<br>drwxrwxr-x. 4 1000 mysql  4096 6月  18 21:37 lib<br>-rw-rw-r–. 1 1000 mysql 12846 8月  27 2019 LICENSE<br>-rw-rw-r–. 1 1000 mysql   182 8月  27 2019 NOTICE<br>-rw-rw-r–. 1 1000 mysql  2533 8月  27 2019 README.txt<br>[root@localhost maven]#</p>
</blockquote>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><blockquote>
<p>vi &#x2F;etc&#x2F;profile</p>
</blockquote>
<pre><code class="java">export JAVA_HOME=/usr/local/java/jdk-17.0.8+7
export MAVEN_HOME=/opt/maven
export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin
</code></pre>
<blockquote>
<p>source &#x2F;etc&#x2F;profile                 配置生效<br>mvn -v                                      查找Maven版本</p>
</blockquote>
<h4 id="全局工具配置关联JDK和Maven"><a href="#全局工具配置关联JDK和Maven" class="headerlink" title="全局工具配置关联JDK和Maven"></a>全局工具配置关联JDK和Maven</h4><p>Jenkins-&gt;Manage Jenkins-&gt;Tools→ JDK安装 → 新增JDK → </p>
<blockquote>
<p>【JDK】<br><strong>别名</strong>：jdk-17.0.8+7<br><strong>JAVA_HOME</strong>：&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-17.0.8+7</p>
</blockquote>
<p>下面的Maven安装→ 新增Maven →</p>
<blockquote>
<p>【Maven】<br><strong>Name</strong>：maven3.6.2<br><strong>MAVEN_HOME</strong>：&#x2F;opt&#x2F;maven</p>
</blockquote>
<p>点击应用 → 保存</p>
<h4 id="添加Jenkins全局变量"><a href="#添加Jenkins全局变量" class="headerlink" title="添加Jenkins全局变量"></a>添加Jenkins全局变量</h4><p>Jenkins → Manage Jenkins → System → 下面找到<strong>全局属性</strong> → <strong>Environment variables</strong> </p>
<pre><code class="java">以下是用键值对的形式显示：
JAVA_HOME   /usr/local/java/jdk-17.0.8+7
M2_HOME     /opt/maven
PATH+EXTRA  $M2_HOME/bin
</code></pre>
<h4 id="修改Maven的settings-xml"><a href="#修改Maven的settings-xml" class="headerlink" title="修改Maven的settings.xml"></a>修改Maven的settings.xml</h4><pre><code class="java">mkdir /root/repo                  创建本地仓库目录
vi /opt/maven/conf/settings.xml
</code></pre>
<p>本地仓库改为：&#x2F;root&#x2F;repo</p>
<pre><code class="java">  &lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: $&#123;user.home&#125;/.m2/repository
  --&gt;
  &lt;localRepository&gt;/root/repo&lt;/localRepository&gt;
</code></pre>
<p>添加阿里云私服地址：</p>
<pre><code class="java">    &lt;mirror&gt;
      &lt;id&gt;alimaven&lt;/id&gt;
      &lt;name&gt;aliyun maven&lt;/name&gt;
      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
</code></pre>
<h4 id="测试Maven是否配置成功"><a href="#测试Maven是否配置成功" class="headerlink" title="测试Maven是否配置成功"></a>测试Maven是否配置成功</h4><p>使用之前的gitlab密码测试项目，修改配置;<br>在某个项目中→Triggers中→Build Steps选择 <strong>Execute shell</strong>(执行shell脚本命令)<br>输入</p>
<blockquote>
<p>mvn clean package</p>
</blockquote>
<p>然后再去构建！！</p>
<blockquote>
<h3 id="🔧-步骤一：删除损坏的插件文件"><a href="#🔧-步骤一：删除损坏的插件文件" class="headerlink" title="🔧 步骤一：删除损坏的插件文件"></a>🔧 步骤一：删除损坏的插件文件</h3><p>执行以下命令彻底删除这个错误的插件缓存：</p>
<pre><code class="java">rm -rf /root/repo/org/apache/maven/plugins/maven-clean-plugin
</code></pre>
<hr>
<h3 id="🔧-步骤二：将-Maven-镜像源改为稳定的中央仓库"><a href="#🔧-步骤二：将-Maven-镜像源改为稳定的中央仓库" class="headerlink" title="🔧 步骤二：将 Maven 镜像源改为稳定的中央仓库"></a>🔧 步骤二：将 Maven 镜像源改为稳定的中央仓库</h3><p>编辑 <code>/root/.m2/settings.xml</code> 或 <code>/etc/maven/settings.xml</code>（按你的系统配置）为以下内容：</p>
<pre><code class="xml">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  
  &lt;localRepository&gt;/root/repo&lt;/localRepository&gt;

  &lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;central&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;Maven Central&lt;/name&gt;
      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;
    &lt;/mirror&gt;
  &lt;/mirrors&gt;

&lt;/settings&gt;
</code></pre>
</blockquote>
<h4 id="持续集成环境—Tomcat安装和配置"><a href="#持续集成环境—Tomcat安装和配置" class="headerlink" title="持续集成环境—Tomcat安装和配置"></a>持续集成环境—Tomcat安装和配置</h4><p>安装Tomcat8.5  把Tomcat压缩包上传到192.168.200.131服务器 </p>
<blockquote>
<p>yum install java-1.8.0-openjdk* -y                           安装JDK（已完成）<br>tar -xzf apache-tomcat-8.5.47.tar.gz                       解压<br>mkdir -p &#x2F;opt&#x2F;tomcat                                                 创建目录<br>mv &#x2F;root&#x2F;apache-tomcat-8.5.47&#x2F;* &#x2F;opt&#x2F;tomcat     移动文件<br><span style ="color:red"><strong>启动tomcat</strong></span><br>&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh ★★        </p>
<p><span style ="color:blue">[Apache Tomcat&#x2F;8.5.47]</span> (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/">http://192.168.200.131:8090/</a>) 【已改端口8090】</p>
<p><strong>关闭已有 Tomcat</strong>（建议先关闭，避免冲突）：</p>
<pre><code>/opt/tomcat/bin/shutdown.sh
</code></pre>
<p><strong>再启动</strong>：</p>
<pre><code>/opt/tomcat/bin/startup.sh
</code></pre>
</blockquote>
<p>不过现在访问这个地址是没有权限的[403 Access Denied] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/">http://192.168.200.131:8090/manager/</a>) 现在要增加权限</p>
<h4 id="配置-Tomcat用户角色权限"><a href="#配置-Tomcat用户角色权限" class="headerlink" title="配置 Tomcat用户角色权限"></a>配置 Tomcat用户角色权限</h4><p>默认情况下Tomcat是没有配置用户角色权限的</p>
<blockquote>
<h1 id="403-Access-Denied"><a href="#403-Access-Denied" class="headerlink" title="403 Access Denied"></a>403 Access Denied</h1><p>You are not authorized to view this page.</p>
<p>By default the Manager is only accessible from a browser running on the same machine as Tomcat. If you wish to modify this restriction, you’ll need to edit the Manager’s <code>context.xml</code> file.</p>
<p>If you have already configured the Manager application to allow access and you have used your browsers back button, used a saved book-mark or similar then you may have triggered the cross-site request forgery (CSRF) protection that has been enabled for the HTML interface of the Manager application. You will need to reset this protection by returning to the <a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/html">main Manager page</a>. Once you return to this page, you will be able to continue using the Manager application’s HTML interface normally. If you continue to see this access denied message, check that you have the necessary permissions to access this application.</p>
<p>If you have not changed any configuration files, please examine the file <code>conf/tomcat-users.xml</code> in your installation. That file must contain the credentials to let you use this webapp.</p>
<p>For example, to add the <code>manager-gui</code> role to a user named <code>tomcat</code> with a password of <code>s3cret</code>, add the following to the config file listed above.</p>
<pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;
&lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;manager-gui&quot;/&gt;
</code></pre>
<p>Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single <code>manager</code> role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.</p>
<ul>
<li><code>manager-gui</code> - allows access to the HTML GUI and the status pages</li>
<li><code>manager-script</code> - allows access to the text interface and the status pages</li>
<li><code>manager-jmx</code> - allows access to the JMX proxy and the status pages</li>
<li><code>manager-status</code> - allows access to the status pages only</li>
</ul>
<p>The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:</p>
<ul>
<li>Users with the <code>manager-gui</code> role should not be granted either the <code>manager-script</code> or <code>manager-jmx</code> roles.</li>
<li>If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.</li>
</ul>
<p>For more information - please see the <a target="_blank" rel="noopener" href="http://192.168.200.131:8090/docs/manager-howto.html">Manager App How-To</a>.</p>
</blockquote>
<p>但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置， 添加用户及权限</p>
<blockquote>
<p>vi &#x2F;opt&#x2F;tomcat&#x2F;conf&#x2F;tomcat-users.xml</p>
</blockquote>
<p>内容如下：</p>
<pre><code class="xml">&lt;tomcat-users&gt;
 &lt;role rolename=&quot;tomcat&quot;/&gt;
 &lt;role rolename=&quot;role1&quot;/&gt;
 &lt;role rolename=&quot;manager-script&quot;/&gt;
 &lt;role rolename=&quot;manager-gui&quot;/&gt;
 &lt;role rolename=&quot;manager-status&quot;/&gt; 
&lt;role rolename=&quot;admin-gui&quot;/&gt;
 &lt;role rolename=&quot;admin-script&quot;/&gt; 
&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager
script,tomcat,admin-gui,admin-script&quot;/&gt;
 &lt;/tomcat-users&gt;
</code></pre>
<p>用户和密码都是： tomcat<br>注意：为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置</p>
<blockquote>
<p>vi &#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;manager&#x2F;META-INF&#x2F;context.xml</p>
</blockquote>
<pre><code class="yaml">&lt;!--
 &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
 allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;
--&gt;
</code></pre>
<p>注释掉这行就行！！</p>
<blockquote>
<p><strong>关闭已有 Tomcat</strong>（建议先关闭，避免冲突）：</p>
<pre><code>/opt/tomcat/bin/shutdown.sh
</code></pre>
<p><strong>再启动</strong>：</p>
<pre><code>/opt/tomcat/bin/startup.sh
</code></pre>
</blockquote>
<p>[&#x2F;manager] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/html">http://192.168.200.131:8090/manager/html</a>)   <strong>此时就可以访问了！！！</strong></p>
<h2 id="3、Jenkins构建Maven项目"><a href="#3、Jenkins构建Maven项目" class="headerlink" title="3、Jenkins构建Maven项目"></a>3、Jenkins构建Maven项目</h2><h4 id="Jenkins项目构建类型-1-Jenkins构建的项目类型介绍"><a href="#Jenkins项目构建类型-1-Jenkins构建的项目类型介绍" class="headerlink" title="Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍"></a>Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍</h4><p>Jenkins中自动构建项目的类型有很多，常用的有以下三种： </p>
<ul>
<li>自由风格软件项目（ FreeStyle Project） </li>
<li>Maven 项目（Maven Project） </li>
<li><span style ="color:red"><strong>流水线项目（ Pipeline Project）</strong></span></li>
</ul>
<p>每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在 实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）</p>
<h4 id="Jenkins项目构建类型-2-自由风格项目构建"><a href="#Jenkins项目构建类型-2-自由风格项目构建" class="headerlink" title="Jenkins项目构建类型(2)-自由风格项目构建"></a>Jenkins项目构建类型(2)-自由风格项目构建</h4><p>下面演示创建一个自由风格项目来完成项目的集成过程：</p>
<blockquote>
<p>拉取代码→编译→打包→部署</p>
</blockquote>
<p>……</p>
<h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><p>把项目部署到远程的Tomcat里面 </p>
<h6 id="1）安装-Deploy-to-container插件"><a href="#1）安装-Deploy-to-container插件" class="headerlink" title="1）安装 Deploy to container插件"></a>1）安装 Deploy to container插件</h6><p>Jenkins本身无法实现远程部署到Tomcat的功能，需要在Jenkins里面安装<strong>Deploy to container</strong>插件实现</p>
<p><a href="file:///C:/Users/Pluminary/Desktop/Jenkins持续集成从入门到精通.pdf">Jenkins持续集成从入门到精通.pdf</a> 【39页】</p>
<p>①：<strong>Build Steps</strong> → Execute shell →↓</p>
<pre><code class="java">echo &quot;开始进行编译构建&quot;
mvn clean package
echo &quot;编译构建结束&quot;
</code></pre>
<p>②：在Jenkins的项目配置里 下面<br>构建后操作：【Deploy war&#x2F;ear to a container】→ 选择 <strong><u>Tomcat 8.x Remote</u></strong><br><strong>WAR&#x2F;EAR files</strong>：<u>target&#x2F;*.war</u><br><strong>Containers</strong>：<br>新增一个凭证 用户名tomcat 密码tomcat</p>
<p>部署成功后，访问项目：[<u>演示项目主页</u>] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/">http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/</a>)</p>
<pre><code class="xml">如果看到此页面，代表项目部署成功啦！--这是master分支 添加用户
修改用户
删除用户 查询用户
</code></pre>
<p>演示改动代码后的持续集成<br>1）IDEA中源码修改并提交到gitlab<br>2）在Jenkins中项目重新构建<br>3）访问Tomcat</p>
<h5 id="演示改动代码后的持续集成"><a href="#演示改动代码后的持续集成" class="headerlink" title="演示改动代码后的持续集成"></a>演示改动代码后的持续集成</h5><p>1）IDEA中源码修改并提交到gitlab<br>2）<strong>在Jenkins中项目重新构建</strong><br>3）访问Tomcat</p>
<h4 id="Jenkins项目构建类型-3-Maven项目构建"><a href="#Jenkins项目构建类型-3-Maven项目构建" class="headerlink" title="Jenkins项目构建类型(3)-Maven项目构建"></a>Jenkins项目构建类型(3)-Maven项目构建</h4><p>1）安装 <strong>Maven Integration</strong> 插件<br>2）创建 <strong>Maven</strong> 项目<br>3）配置项目<br>拉取代码和远程部署的过程和自由风格项目一样，只是”构建”部分不同</p>
<p>新建<strong>Item</strong> → <strong>构建一个maven项目</strong><br>其中Build的<strong>Root POM</strong>是要找到pom.xml的路径才行【默认执行maven命令】<br>所以只需要在<strong>Goals and options</strong>里面敲上<code>clean package</code></p>
<h4 id="Jenkins项目构建类型-4-Pipeline流水线项目构建"><a href="#Jenkins项目构建类型-4-Pipeline流水线项目构建" class="headerlink" title="Jenkins项目构建类型(4)-Pipeline流水线项目构建(*)"></a>Jenkins项目构建类型(4)-Pipeline流水线项目构建(*)</h4><h5 id="Pipeline简介"><a href="#Pipeline简介" class="headerlink" title="Pipeline简介"></a>Pipeline简介</h5><h6 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h6><p>Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点 的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。</p>
<h6 id="2）使用Pipeline有以下好处（来自翻译自官方文档）："><a href="#2）使用Pipeline有以下好处（来自翻译自官方文档）：" class="headerlink" title="2）使用Pipeline有以下好处（来自翻译自官方文档）："></a>2）使用Pipeline有以下好处（来自翻译自官方文档）：</h6><p>代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。 持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。 可停止：Pipeline可接 收交互式输入，以确定是否继续执行Pipeline。 多功能：Pipeline支持现实世界中复杂的持续交付要 求。它支持fork&#x2F;join、循环执行，并行执行任务的功能。 可扩展：Pipeline插件支持其DSL的自定义扩 展 ，以及与其他插件集成的多个选项。</p>
<h6 id="3）如何创建-Jenkins-Pipeline呢？"><a href="#3）如何创建-Jenkins-Pipeline呢？" class="headerlink" title="3）如何创建 Jenkins Pipeline呢？"></a>3）如何创建 Jenkins Pipeline呢？</h6><ul>
<li>Pipeline 脚本是由 Groovy 语言实现的，但是我们没必要单独去学习 Groovy </li>
<li>Pipeline 支持两种语法：<span style="color:red"><strong>Declarative</strong>(声明式)</span> 和 <span style="color:red"><strong>Scripted Pipeline</strong>(脚本式)</span>语法 </li>
<li>Pipeline  也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一 个 Jenkinsfile 脚本文件放入项目源码库中（<u>一般我们都推荐在 Jenkins 中直接从源代码控制(SCM) 中直接载入 Jenkinsfile Pipeline 这种方法</u>）</li>
</ul>
<h5 id="安装Pipeline插件如果一次安装失败，重启一次再安装-没视图就安装pipeline-Stage-View"><a href="#安装Pipeline插件如果一次安装失败，重启一次再安装-没视图就安装pipeline-Stage-View" class="headerlink" title="安装Pipeline插件如果一次安装失败，重启一次再安装[没视图就安装pipeline Stage View]"></a>安装Pipeline插件<del>如果一次安装失败，重启一次再安装</del>[没视图就安装pipeline Stage View]</h5><p>Manage Jenkins-&gt;Manage Plugins-&gt;可选插件</p>
<h3 id="Pipeline语法快速入门"><a href="#Pipeline语法快速入门" class="headerlink" title="Pipeline语法快速入门"></a>Pipeline语法快速入门</h3><h5 id="1）Declarative声明式-Pipeline"><a href="#1）Declarative声明式-Pipeline" class="headerlink" title="1）Declarative声明式-Pipeline"></a>1）Declarative声明式-Pipeline</h5><p><strong><u>创建项目</u></strong> [<strong>agent是代理、stage是阶段、steps是步骤</strong>]</p>
<ul>
<li><strong>Node</strong> ：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行 环境，后续讲到Jenkins的Master-Slave架构的时候用到。 </li>
<li><strong>Stage</strong> ：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。 </li>
<li><strong>Step</strong> ：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。</li>
</ul>
<pre><code class="java">pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                echo &#39;pull code&#39;
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                echo &#39;build project&#39;
            &#125;
        &#125;
        stage(&#39;publish project&#39;) &#123;
            steps &#123;
                echo &#39;publish project&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2）Scripted-Pipeline脚本式-Pipeline"><a href="#2）Scripted-Pipeline脚本式-Pipeline" class="headerlink" title="2）Scripted Pipeline脚本式-Pipeline"></a>2）Scripted Pipeline脚本式-Pipeline</h5><p><strong><u>创建项目</u></strong><br>流水线那里选择 “<strong>Scripted Pipeline</strong>“</p>
<pre><code class="java">node &#123;
    def mvnHome
    stage(&#39;pull code&#39;)&#123;
        echo &#39;pull code&#39;
    &#125;
    stage(&#39;build project&#39;)&#123;
        echo &#39;build project&#39;
    &#125;
    stage(&#39;publish project&#39;)&#123;
        echo &#39;publish project&#39;
    &#125;
&#125;
</code></pre>
<p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：checkout：Check out from version control [从版本控制里拉取代码]<br>选择git拉取代码 填写URL和凭证 → 生成流水线脚本</li>
</ul>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a><span style = "color:red">拉取代码</span></h3><h6 id="Pipeline-script"><a href="#Pipeline-script" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">pipeline&#123;
    agent any
    stages&#123;
        stage(&#39;拉取代码&#39;)&#123;
            steps&#123;
                checkout scmGit(branches: [[name: &#39;*/master&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;]])
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output"><a href="#Console-Output" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (拉取代码)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
Cloning the remote Git repository
Cloning repository http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git init /var/lib/jenkins/workspace/web_demo_pipeline # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
First time build. Skipping changelog.
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<p>去Jenkins的服务器里寻找<code>/var/lib/jenkins/workspace/web_demo_pipeline</code></p>
<h3 id="编译打包"><a href="#编译打包" class="headerlink" title="编译打包"></a><span style = "color:red">编译打包</span></h3><p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：<code>sh：Shell Script</code><br>Shell Script：里面需要打所需要的命令 <code>mvn clean package</code></li>
</ul>
<h6 id="Pipeline-script-1"><a href="#Pipeline-script-1" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">pipeline&#123;
    agent any
    stages&#123;
        stage(&#39;build project&#39;)&#123;
            steps&#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
    &#125;
&#125;

--------------------------------------------
【总流水线代码】
pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output-1"><a href="#Console-Output-1" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (pull code)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
 &gt; git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/web_demo_pipeline/.git # timeout=10
Fetching changes from the remote Git repository
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
 &gt; git rev-list --no-walk 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (build project)
[Pipeline] sh
+ mvn clean package
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------&lt; com.itheima:web_demo &gt;------------------------
[INFO] Building web_demo 1.0-SNAPSHOT
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ web_demo ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ web_demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /var/lib/jenkins/workspace/web_demo_pipeline/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ web_demo ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ web_demo ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-war-plugin:3.3.2:war (default-war) @ web_demo ---
[INFO] Packaging webapp
[INFO] Assembling webapp [web_demo] in [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [/var/lib/jenkins/workspace/web_demo_pipeline/src/main/webapp]
[INFO] Building war: /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  10.242 s
[INFO] Finished at: 2025-06-24T20:32:45+08:00
[INFO] ------------------------------------------------------------------------
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<h3 id="部署-2"><a href="#部署-2" class="headerlink" title="部署"></a><span style = "color:red">部署</span></h3><p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：<code>deploy：Deploy war/ear to a container</code><br>WAR&#x2F;EAR files：<code>target/*.war</code><br>containers：<strong>Tomcat 8.x Remote</strong> 【容器可以增加多台】<br>credentials：添加tomcat凭证<br>Tomcat URL：<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/">http://192.168.200.131:8090/</a></li>
</ul>
<h6 id="Pipeline-script-2"><a href="#Pipeline-script-2" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">【总流水线代码】
pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output-2"><a href="#Console-Output-2" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (pull code)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
 &gt; git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/web_demo_pipeline/.git # timeout=10
Fetching changes from the remote Git repository
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
 &gt; git rev-list --no-walk 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (build project)
[Pipeline] sh
+ mvn clean package
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------&lt; com.itheima:web_demo &gt;------------------------
[INFO] Building web_demo 1.0-SNAPSHOT
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ web_demo ---
[INFO] Deleting /var/lib/jenkins/workspace/web_demo_pipeline/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ web_demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /var/lib/jenkins/workspace/web_demo_pipeline/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ web_demo ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ web_demo ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-war-plugin:3.3.2:war (default-war) @ web_demo ---
[INFO] Packaging webapp
[INFO] Assembling webapp [web_demo] in [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [/var/lib/jenkins/workspace/web_demo_pipeline/src/main/webapp]
[INFO] Building war: /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  7.472 s
[INFO] Finished at: 2025-06-24T20:39:46+08:00
[INFO] ------------------------------------------------------------------------
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (publish)
[Pipeline] deploy
[DeployPublisher][INFO] Attempting to deploy 1 war file(s)
[DeployPublisher][INFO] Deploying /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war to container Tomcat 8.x Remote with context null
  Redeploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
  Undeploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
  Deploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<h4 id="Pipeline-Script-from-SCM"><a href="#Pipeline-Script-from-SCM" class="headerlink" title="Pipeline Script from SCM "></a><span style = "color:red">Pipeline Script from SCM </span></h4><p>刚才我们都是直接在Jenkins的UI界面编写Pipeline代码，这样不方便脚本维护，建议把Pipeline脚本放 在项目中（一起进行版本控制）<br>1）在项目<strong>根目录</strong>建立<strong>Jenkinsfile</strong>文件，把内容复制到该文件中。把Jenkinsfile上传到Gitlab</p>
<pre><code class="java">Jenkinsfile【在根目录下】

pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p> 2）在项目中引用该<strong>文件</strong><br>在流水线上<br>定义<code>Pipeline script from SCM</code> → 选择git → 填写gitlab的url和凭证 → 脚本路径<code>Jenkinsfile</code>(这是我们上传的jenkinsfile里面包含着流水线代码的文件)</p>
<h4 id="Jenkins项目构建细节-1-常用的构建触发器"><a href="#Jenkins项目构建细节-1-常用的构建触发器" class="headerlink" title="Jenkins项目构建细节(1)-常用的构建触发器"></a>Jenkins项目构建细节(1)-常用的构建触发器</h4><p>Jenkins内置4种构建触发器： </p>
<ul>
<li>触发远程构建 </li>
<li>其他工程构建后触发（ Build after other projects are build） </li>
<li>定时构建（ Build periodically） </li>
<li>轮询 SCM（Poll SCM）</li>
</ul>
<h5 id="触发远程构建"><a href="#触发远程构建" class="headerlink" title="触发远程构建"></a>触发远程构建</h5><p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>触发远程构建</code> 身份验证令牌(这个token最好是加密的) 下面有个触发地址：</p>
<blockquote>
<p>Use the following URL to trigger build remotely: <code>JENKINS_URL</code>&#x2F;job&#x2F;web_demo_pipeline&#x2F;build?token&#x3D;TOKEN_NAME 或者 &#x2F;buildWithParameters?token&#x3D;TOKEN_NAME<br>Optionally append <code>&amp;cause=Cause+Text</code> to provide text that will be included in the recorded build cause.</p>
</blockquote>
<p>上面地址里面的：<code>job/web_demo_pipeline/build?token=TOKEN_NAME</code><br>→ <code>http://192.168.200.129:8888/job/web_demo_pipeline/build?token=6666</code><br>在浏览器输入上述地址 回车打开 你会发现已经远程触发了Jenkins的构建行为！！</p>
<h5 id="其他工程构建后触发"><a href="#其他工程构建后触发" class="headerlink" title="其他工程构建后触发"></a>其他工程构建后触发</h5><p>1）创建pre_job流水线工程<br>2）配置需要触发的工程</p>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Build after other projects are built</code><br>新建item → 创建一个<code>pre_job</code>的自由风格的工程 → 构建Execute shell 执行一个简单的脚本<br>回到<code>web_demo_pipeline</code>工程 在<code>Triggers</code>里面选择前置工程<code>pre_job</code><br>此时去构建<code>pre_job</code>你会发现 在构建完后 <code>web_demo_pipeline</code>也会进行自动构建</p>
<h5 id="定时构建"><a href="#定时构建" class="headerlink" title="定时构建"></a>定时构建</h5><p>定时字符串从左往右分别为： 分 时 日 月 周<br>一些定时表达式的例子：(H为0 就为整点)</p>
<pre><code class="java">每30分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32
每2个小时构建一次: H H/2 * * *
每天的8点，12点，22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *
每天中午12点定时构建一次 H 12 * * *
每天下午18点定时构建一次 H 18 * * *
在每个小时的前半个小时内的每10分钟 H(0-29)/10 * * * *
每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午
4:38) H H(9-16)/2 * * 1-5
</code></pre>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择 <code>Build periodically</code> 然后可以写时间cron表达式即可</p>
<h5 id="轮询SCM-版本控制-企业级不推荐使用"><a href="#轮询SCM-版本控制-企业级不推荐使用" class="headerlink" title="轮询SCM  [版本控制] [企业级不推荐使用]"></a><span style ="color:blue">轮询SCM  [版本控制] [企业级不推荐使用]</span></h5><p>轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。<br>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Poll SCM</code></p>
<blockquote>
<h4 id="jenkins的轮询SCM的构建到底是远程仓库变动触发-还是-本地仓库变动触发？"><a href="#jenkins的轮询SCM的构建到底是远程仓库变动触发-还是-本地仓库变动触发？" class="headerlink" title="jenkins的轮询SCM的构建到底是远程仓库变动触发 还是 本地仓库变动触发？"></a>jenkins的轮询SCM的构建到底是远程仓库变动触发 还是 本地仓库变动触发？</h4><p><strong>Jenkins 的“轮询 SCM”是通过轮询</strong>远程 Git 仓库（如 GitLab、GitHub）<strong>判断是否有变更</strong>，从而决定是否触发构建。</p>
</blockquote>
<p>注意：这次构建触发器， Jenkins会定时扫描整个项目的代码，增大系统的开销，不建议使用。</p>
<h4 id="Jenkins项目构建细节-2-Git-hook自动触发构建-gitlab就用gitlab插件，github则是github插件"><a href="#Jenkins项目构建细节-2-Git-hook自动触发构建-gitlab就用gitlab插件，github则是github插件" class="headerlink" title="Jenkins项目构建细节(2)-Git hook自动触发构建(*)gitlab就用gitlab插件，github则是github插件"></a>Jenkins项目构建细节(2)-Git hook自动触发构建(*)<del>gitlab就用gitlab插件，github则是github插件</del></h4><p>先在Jenkins市场安装<code>gitlab</code>插件</p>
<p>刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是 该方案的性能不佳。那有没有更好的方案呢？ 有的。就是<strong>利用Gitlab的webhook实现代码push到仓 库，立即触发项目自动构建</strong>。</p>
<blockquote>
<p><strong>轮询SCM原理</strong>：Jenkins                    →(发送定时请求)→                Gitlab代码变更<br><strong>webhook原理</strong>：Gitlab代码变更      →(发送构建请求)→                Jenkins</p>
</blockquote>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Build when a change is pushed to GitLab. GitLab webhook URL: http://192.168.200.129:8888/project/web_demo_pipeline</code></p>
<p>★ 要用root账号去GitLab开通一个webhook规则 → 点击上方的小齿轮 → 右侧<code>Settings</code>  → Network → 展开Outbound requests → 勾选<code>Allow requests to the local network from web hooks and services</code>和<code>Allow requests to the local network from system hooks</code>保存 → 在<code>web_demo</code>项目中 → Settings → Integrations → 可以粘贴URL(这里就是在Jenkins里面的<code>http://192.168.200.129:8888/project/web_demo_pipeline</code>) [把代码push到项目里来就会触发这个url自动构建] → Add webhook → 下方可以进行测试test → <code>push event</code> →↓</p>
<p>若出现 则证明gitlab是成功 只是Jenkins需要认证请求 去Jenkins开放接收请求的功能</p>
<pre><code class="xml">Hook executed successfully but returned HTTP 403 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=ISO-8859-1&quot;/&gt; &lt;title&gt;Error 403 anonymous is missing the Job/Build permission&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h2&gt;HTTP ERROR 403 anonymous is missing the Job/Build permission&lt;/h2&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;URI:&lt;/th&gt;&lt;td&gt;/project/web_demo_pipeline&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;STATUS:&lt;/th&gt;&lt;td&gt;403&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;MESSAGE:&lt;/th&gt;&lt;td&gt;anonymous is missing the Job/Build permission&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;SERVLET:&lt;/th&gt;&lt;td&gt;Stapler&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;hr/&gt;&lt;a href=&quot;https://jetty.org/&quot;&gt;Powered by Jetty:// 12.0.19&lt;/a&gt;&lt;hr/&gt; &lt;/body&gt; &lt;/html&gt;
</code></pre>
<p>Jenkins开放接收请求 → 打开主页并跟随路径<code>Dashboard → Manage Jenkins → System</code> 找到 GitLab Enable authentication for ‘&#x2F;project’ end-point【这个要反选 就是不能选钩 且里面的东西删除】 → 再去进行测试test → <code>push event</code> 即可成功<code>Hook executed successfully: HTTP 200</code></p>
<h4 id="Jenkins项目构建细节-3-Jenkins的参数化构建"><a href="#Jenkins项目构建细节-3-Jenkins的参数化构建" class="headerlink" title="Jenkins项目构建细节(3)-Jenkins的参数化构建"></a>Jenkins项目构建细节(3)-Jenkins的参数化构建</h4><p>有时在项目构建的过程中，我们需要**<u>根据用户的输入动态传入一些参数</u>**，从而影响整个构建结果，这时 我们可以使用参数化构建。<br>Jenkins支持非常丰富的参数类型</p>
<blockquote>
<p>大概意思就是 我在项目的jenkinsfile文件里面<br>steps {<br>    checkout scmGit(<br>        <em>branches</em>: [[<em>name</em>: ‘*&#x2F;master’]],<br>        <em>extensions</em>: [],<br>        <em>userRemoteConfigs</em>: [[<br>            <em>credentialsId</em>: ‘ca22e56f-0ecc-4fdc-965d-01e329a0b68a’,<br>            <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo.git&#39;">http://192.168.200.132:82/lanyun_group/web_demo.git&#39;</a><br>        ]]<br>    )<br>这个branches里面的 *&#x2F;master我要求是让用户动态输入值 而不是写死</p>
</blockquote>
<p>首先要在项目里面增加一些参数 <code>web_demo_pipeline</code> 项目中 可以先把触发器的值取消掉 → 进入上面的General的配置 选择<code>This project is parameterized</code> → 可以添加参数 → 加入<code>String Parameter</code>参数 →<br>输入 <u>名称：branch，默认值：master，描述：请输入一个分支的名称</u> → 此时在左侧就会出现一个 <code>Build with Parameters</code> →↓</p>
<blockquote>
<p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘pull code’) {<br>            steps {<br>                checkout scmGit(<br>                    branches: [[<span style = "color:red"><em>name</em>: ‘<em>&#x2F;${branch}}’</span>]],<br>                    <em>extensions</em>: [],<br>                    <em>userRemoteConfigs</em>: [[<br>                        <em>credentialsId</em>: ‘ca22e56f-0ecc-4fdc-965d-01e329a0b68a’,<br>                        <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo.git&#39;">http://192.168.200.132:82/lanyun_group/web_demo.git&#39;</a><br>                    ]]<br>                )<br>            }<br>        }<br>        stage(‘build project’) {<br>            steps {<br>                sh ‘mvn clean package’<br>            }<br>        }<br>        stage(‘publish’) {<br>            steps {<br>                deploy <em>adapters</em>: [tomcat8(<em>alternativeDeploymentContext</em>: ‘’, <em>credentialsId</em>: ‘e847a130-29c3-4d0b-bf35-db8d00de7950’, <em>path</em>: ‘’, <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/&#39;)]">http://192.168.200.131:8090/&#39;)]</a>, <em>contextPath</em>: <em>null</em>, <em>war</em>: ‘target&#x2F;</em>.war’<br>            }<br>        }<br>    }<br>}<br>【这时你在Jenkins构建时输入的参数就可以对应着Jenkinsfile文件的动态参数进行构建 (动态值红色已标注)】→ 需要把jenkinsfile的代码push到仓库里去</p>
</blockquote>
<h4 id="Jenkins项目构建细节-4-配置邮箱服务器发送构建结果"><a href="#Jenkins项目构建细节-4-配置邮箱服务器发送构建结果" class="headerlink" title="Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果"></a>Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果</h4><p>安装<code>Email Extension Template</code>插件</p>
<h5 id="Jenkins设置邮箱相关参数"><a href="#Jenkins设置邮箱相关参数" class="headerlink" title="Jenkins设置邮箱相关参数"></a>Jenkins设置邮箱相关参数</h5><p>Dashboard → Manage Jenkins → System → <code>Extended E-mail Notification</code> → QQ邮箱【官网 账号安全设置】打开SMTP服务 找到 <strong>POP3&#x2F;SMTP服务</strong>，点击「开启」→ 勾选“开启服务”旁边的复选框 → 生成<strong>SMTP&#x2F;IMAP 授权码已生成</strong> → <code>jitgujalhqtecadc</code> → 回到Jenkins → SMTP server填写：<code>smtp.qq.com</code>；端口是<code>465</code> → Default user e-mail suffix：<code>@qq.com</code>  下面的用户名是发件人 密码是授权码 使用SSL协议的话SMTP端口就是465 → Jenkins Location 系统管理员邮件地址是发件人地址 </p>
<h5 id="准备邮件内容"><a href="#准备邮件内容" class="headerlink" title="准备邮件内容"></a>准备邮件内容</h5><p>在项目根目录编写email.html，并把文件推送到Gitlab，内容如下：【根目录下】<br>BUILD_NUMBER、BUILD_STATUS等 来自于Jenkins的全局变量 </p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;$&#123;ENV, var=&quot;JOB_NAME&quot;&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt;
&lt;/head&gt;

&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;
      offset=&quot;0&quot;&gt;
&lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;
       style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;h2&gt;
            &lt;font color=&quot;#0000FF&quot;&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt;
        &lt;/h2&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;br /&gt;
            &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;ul&gt;
                &lt;li&gt;项目名称&amp;nbsp;：&amp;nbsp;$&#123;PROJECT_NAME&#125;&lt;/li&gt;
                &lt;li&gt;构建编号&amp;nbsp;：&amp;nbsp;第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt;
                &lt;li&gt;触发原因：&amp;nbsp;$&#123;CAUSE&#125;&lt;/li&gt;
                &lt;li&gt;构建日志：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;构建&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;&quot;&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;工作目录&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws&quot;&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;项目&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;Changes Since Last
            Successful Build:&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;ul&gt;
                &lt;li&gt;历史变更记录 : &lt;a href=&quot;$&#123;PROJECT_URL&#125;changes&quot;&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt; $&#123;CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=&quot;Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;&quot;,showPaths=true,changesFormat=&quot;&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;&quot;,pathFormat=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;%p&quot;&#125;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;Failed Test Results&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;pre
                style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;$FAILED_TESTS&lt;/pre&gt;
            &lt;br /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot;
                      style=&quot;font-family: Courier New&quot;&gt;$&#123;BUILD_LOG, maxLines=100&#125;&lt;/textarea&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>post的内容可以用流水线语法生成 → 完成之后点击片段生成器 生成一个 <code>emailext: Extended Email</code> 的代码片段</p>
<pre><code class="java">pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/$&#123;branch&#125;&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
    post&#123;
        always&#123;
             emailext(
                 subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
                 body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
                 to: &#39;2523419709@qq.com&#39;
             )
        &#125;
    &#125;
&#125;
</code></pre>
<p>PS：邮件相关全局参数参考列表：<br>系统设置-&gt;Extended E-mail Notification-&gt;Content Token Reference，点击旁边的?号</p>
<h4 id="Jenkins-SonarQube代码审查-1-安装SonarQube"><a href="#Jenkins-SonarQube代码审查-1-安装SonarQube" class="headerlink" title="Jenkins+SonarQube代码审查(1) - 安装SonarQube"></a>Jenkins+SonarQube代码审查(1) - 安装SonarQube</h4><h5 id="SonaQube简介"><a href="#SonaQube简介" class="headerlink" title="SonaQube简介"></a>SonaQube简介</h5><p>SonarQube 是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前 支持java,C#,C&#x2F;C++,Python,PL&#x2F;SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检 测。</p>
<p>官网： <a target="_blank" rel="noopener" href="https://www.sonarqube.org/">https://www.sonarqube.org/</a></p>
<h5 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h5><table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">服务器</th>
<th align="center">版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK</td>
<td align="center">192.168.200.129</td>
<td align="center">1.8</td>
</tr>
<tr>
<td align="center">MySQL</td>
<td align="center">192.168.200.129</td>
<td align="center">5.7</td>
</tr>
<tr>
<td align="center">SonarQube</td>
<td align="center">192.168.200.129</td>
<td align="center">6.7.4</td>
</tr>
</tbody></table>
<h5 id="安装SonarQube"><a href="#安装SonarQube" class="headerlink" title="安装SonarQube"></a>安装SonarQube</h5><p>1）安装MySQL（已完成）<br>2）安装SonarQube</p>
<blockquote>
<p>使用5.7数据库<br>先删除以前的</p>
<h3 id="建议操作："><a href="#建议操作：" class="headerlink" title="建议操作："></a>建议操作：</h3><ol>
<li><strong>先把多余或冲突的文件临时备份移动一下，避免yum混乱</strong></li>
</ol>
<pre><code>bash复制编辑sudo mv /etc/yum.repos.d/mysql-community.repo.rpmsave /root/
sudo mv /etc/yum.repos.d/mysql57.repo /root/
</code></pre>
<ol>
<li><strong>只保留 <code>mysql-community.repo</code> 这个 repo 文件，确保它内容正确（你可以用<code>cat</code>看下内容）</strong></li>
</ol>
<pre><code>cat /etc/yum.repos.d/mysql-community.repo
</code></pre>
<ol>
<li><strong>清理缓存，重新生成</strong></li>
</ol>
<pre><code>sudo yum clean all
sudo yum makecache
</code></pre>
<ol>
<li><strong>尝试安装mysql 5.7</strong></li>
</ol>
<pre><code>sudo yum install mysql-community-server
</code></pre>
<hr>
<h3 id="解决方案：用符合策略的密码先改，再降低策略"><a href="#解决方案：用符合策略的密码先改，再降低策略" class="headerlink" title="解决方案：用符合策略的密码先改，再降低策略"></a>解决方案：用符合策略的密码先改，再降低策略</h3><ol>
<li><strong>用一个符合复杂度的密码先改密码</strong>，例如：</li>
</ol>
<pre><code>sql


复制编辑
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Root@12345&#39;;
</code></pre>
<ol>
<li><strong>登录成功后降低密码策略：</strong></li>
</ol>
<pre><code>sql复制编辑SET GLOBAL validate_password_policy=LOW;
SET GLOBAL validate_password_length=1;
</code></pre>
<ol>
<li><strong>再修改为你想要的简单密码（比如<code>root</code>）：</strong></li>
</ol>
<pre><code>sql


复制编辑
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;
</code></pre>
<ol>
<li><strong>刷新权限</strong></li>
</ol>
<pre><code>FLUSH PRIVILEGES;
</code></pre>
</blockquote>
<p>在mysql创建sonar数据库</p>
<blockquote>
<h3 id="启动-MySQL-服务（如果没启动）"><a href="#启动-MySQL-服务（如果没启动）" class="headerlink" title="启动 MySQL 服务（如果没启动）"></a>启动 MySQL 服务（如果没启动）</h3><pre><code>systemctl start mysqld
</code></pre>
<p>启动后再次检查状态：</p>
<pre><code>systemctl status mysqld
</code></pre>
<p><code>mysql -uroot -p</code><br>账号密码是：root</p>
</blockquote>
<pre><code class="mysql">mysql&gt; create database sonar;

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sonar              |
| sys                |
+--------------------+
5 rows in set (0.07 sec)
</code></pre>
<h5 id="解压sonar，并设置权限"><a href="#解压sonar，并设置权限" class="headerlink" title="解压sonar，并设置权限"></a>解压sonar，并设置权限</h5><blockquote>
<p>yum install unzip<br>unzip sonarqube-6.7.4.zip                       解压<br>mkdir &#x2F;opt&#x2F;sonar                                       创建目录<br>mv sonarqube-6.7.4&#x2F;* &#x2F;opt&#x2F;sonar          移动文件<br>useradd sonar                                           <strong>创建sonar用户</strong>，必须sonar用于启动，否则报错 </p>
<p>chown -R sonar. &#x2F;opt&#x2F;sonar                    更改sonar目录及文件权限</p>
<p>[root@localhost ~]# cd &#x2F;opt&#x2F;sonar<br>[root@localhost sonar]# ll<br>总用量 12<br>drwxr-xr-x. 8 sonar sonar  136 5月  30 2018 bin<br>drwxr-xr-x. 2 sonar sonar   50 5月  30 2018 conf<br>-rw-r–r–. 1 sonar sonar 7651 5月  30 2018 COPYING<br>drwxr-xr-x. 2 sonar sonar   24 5月  30 2018 data<br>drwxr-xr-x. 7 sonar sonar  150 5月  30 2018 elasticsearch<br>drwxr-xr-x. 4 sonar sonar   40 5月  30 2018 extensions<br>drwxr-xr-x. 9 sonar sonar  140 5月  30 2018 lib<br>drwxr-xr-x. 2 sonar sonar    6 5月  30 2018 logs<br>drwxr-xr-x. 2 sonar sonar   24 5月  30 2018 temp<br>drwxr-xr-x. 9 sonar sonar 4096 5月  30 2018 web</p>
</blockquote>
<h5 id="修改sonar配置文件数据库连接信息"><a href="#修改sonar配置文件数据库连接信息" class="headerlink" title="修改sonar配置文件数据库连接信息"></a>修改sonar配置文件<del>数据库连接信息</del></h5><blockquote>
<p>[root@localhost opt]# cd sonar<br>[root@localhost sonar]# cd conf<br>[root@localhost conf]# vi sonar.properties</p>
<p>||          ||                   ||                  ||         </p>
<pre><code class="java">......
sonar.jdbc.username=root
sonar.jdbc.password=root
......
sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false 【这里打开注释】

注意：sonar默认监听9000端口，如果9000端口被占用，需要更改 
如果要改端口 在这里：
sonar.web.port=9999

</code></pre>
</blockquote>
<h6 id="启动sonar-129"><a href="#启动sonar-129" class="headerlink" title="启动sonar 129"></a>启动sonar 129</h6><blockquote>
<p>[root@localhost bin]# pwd<br>&#x2F;opt&#x2F;sonar&#x2F;bin<br>cd &#x2F;opt&#x2F;sonar&#x2F;bin</p>
</blockquote>
<p>修改配置文件：<code>vi /opt/sonar/conf/sonar.properties</code><br><span style ="color:red"><strong>重启sonar</strong></span>：<code>sudo -u sonar /opt/sonar/bin/linux-x86-64/sonar.sh restart</code> ★★  [Jenkins服务]</p>
<blockquote>
<h5 id="实时跟踪最新日志输出（推荐用于调试启动或运行时状态）"><a href="#实时跟踪最新日志输出（推荐用于调试启动或运行时状态）" class="headerlink" title="实时跟踪最新日志输出（推荐用于调试启动或运行时状态）"></a>实时跟踪最新日志输出（推荐用于调试启动或运行时状态）</h5><p>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;sonar.log<br>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;web.log<br>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;es.log</p>
<h5 id="查看日志末尾100条内容（快速查看最近日志）"><a href="#查看日志末尾100条内容（快速查看最近日志）" class="headerlink" title="查看日志末尾100条内容（快速查看最近日志）"></a>查看日志末尾100条内容（快速查看最近日志）</h5><p>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;sonar.log<br>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;web.log<br>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;es.log</p>
<h5 id="查看整个日志文件大小和权限"><a href="#查看整个日志文件大小和权限" class="headerlink" title="查看整个日志文件大小和权限"></a>查看整个日志文件大小和权限</h5><p>ls -lh &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;*.log</p>
</blockquote>
<p>访问<strong>SonarQube</strong></p>
<p>[192.168.200.129] (<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/">http://192.168.200.129:9999/</a>)</p>
<p><code>账号密码：admin admin</code><br>生成了一个token：<code>sonar: d30033c63973bd4183b6015995dbb513627c6f59</code></p>
<blockquote>
<p><span style = "color:red"><strong>启动命令总结：</strong></span><br>[192.168.200.132] GitLab：gitlab-ctl restart<br><a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo">lanyun_group &#x2F; web_demo · GitLab</a><br>[192.168.200.131] Tomcat：&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh<br><a target="_blank" rel="noopener" href="http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/">演示项目主页</a></p>
<p>[192.168.200.129] Jenkins：systemctl start jenkins<br><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/login?from=/job/web_demo_pipeline/">登录 - Jenkins</a><br>[192.168.200.129] SonarQube：sudo -u sonar &#x2F;opt&#x2F;sonar&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh restart<br><a target="_blank" rel="noopener" href="http://192.168.200.129:9999/about">192.168.200.129</a></p>
</blockquote>
<h3 id="Jenkins-SonarQube代码审查-2-实现代码审查"><a href="#Jenkins-SonarQube代码审查-2-实现代码审查" class="headerlink" title="Jenkins+SonarQube代码审查(2) - 实现代码审查"></a>Jenkins+SonarQube代码审查(2) - 实现代码审查</h3><p>审查流程：</p>
<blockquote>
<p>Jenkins →(调用)→ Sonar-Scanner →(提交审查结果)→ SonarQube →(保存审查结果)→ MySQL数据库</p>
</blockquote>
<h5 id="安装SonarQube-Scanner插件"><a href="#安装SonarQube-Scanner插件" class="headerlink" title="安装SonarQube Scanner插件"></a>安装SonarQube Scanner插件</h5><p>打开Jenkins的全局配置 → <strong>SonarQube Servers</strong> → Add SonarQube → Name：sonarqube；Server URL：<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/">http://192.168.200.129:9999/</a> → 新建一个证书[Manage Jenkins → Credentials → System → 全局添加 → 类型选择<code>Secret text</code> ；Secret是之前复制到的token字符串 ；描述：sonarqube-auth] → Server authentication token选择刚刚创建的sonarqube-auth</p>
<h5 id="SonarQube-关闭审查结果上传到SCM功能"><a href="#SonarQube-关闭审查结果上传到SCM功能" class="headerlink" title="SonarQube 关闭审查结果上传到SCM功能"></a>SonarQube 关闭审查结果上传到SCM功能</h5><p>[General Settings - Administration] (<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/admin/settings?category=scm">http://192.168.200.129:9999/admin/settings?category=scm</a>) 上方的Administration → 左侧的SCM → 第一个打开SCN Sensor</p>
<p>回到Jenkins的<code>web_demo_freestyle</code>项目点击构建 下方的Build Steps下面的<code>增加构建步骤</code> 选择<code>Execute SonarQube Scanner</code> (这里要在去Tools里安装配置 SonarQube Scanner 安装 → Name:sonar-scanner；Install automatically：<u>SonarQube Scanner 4.2.0.1873</u>) → 这里的jdk是根据Jenkins的jdk配置的 → (Path to project properties这个可以在项目下搞 也可以用Analysis properties 属性放在前端ui界面里面) 这里选择<code>Analysic properties</code>→↓</p>
<pre><code class="yaml"># must be unique in a given SonarQube instance
sonar.projectKey=web_demo_freestyle
# this is the name and version displayed in the SonarQube UI. Was mandatory 
prior to SonarQube 6.1.
sonar.projectName=web_demo_freestyle
sonar.projectVersion=1.0
 # Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on 
Windows.
 # This property is optional if sonar.modules is set.
 sonar.sources=.
 sonar.exclusions=**/test/**,**/target/**
 sonar.java.source=1.8
 sonar.java.target=1.8
 # Encoding of the source code. Default is default system encoding
 sonar.sourceEncoding=UTF-8
</code></pre>
<p>→ 应用保存 + 重新构建 </p>
<p>现在有个问题就是我Jenkins是2.504.2 然后jdk是17 我不想换jdk的情况下就要去 </p>
<pre><code class="yaml">Build Steps里面的执行脚本

echo &quot;开始进行编译构建&quot;
mvn clean package
echo &quot;编译构建结束&quot;

# 设置环境变量，给sonar-scanner的JVM传参数，解决Java17模块访问问题
export SONAR_SCANNER_OPTS=&quot;--add-opens=java.base/java.lang=ALL-UNNAMED \
--add-opens=java.base/java.lang.reflect=ALL-UNNAMED \
--add-opens=java.base/java.io=ALL-UNNAMED&quot;

# 执行Sonar扫描
/var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
  -Dsonar.projectKey=web_demo_freestyle \
  -Dsonar.host.url=http://192.168.200.129:9999 \
  -Dsonar.sources=. \
  -Dsonar.exclusions=**/test/**,**/target/** \
  -Dsonar.java.source=1.8 \
  -Dsonar.java.target=1.8

echo &quot;SonarQube扫描结束&quot;
</code></pre>
<blockquote>
<p>打开idea jenkinsfile文件</p>
<pre><code class="yaml">pipeline &#123;
 agent any
 stages &#123;
     stage(&#39;pull code&#39;) &#123;
         steps &#123;
             checkout scmGit(
                 branches: [[name: &quot;*/$&#123;branch&#125;&quot;]],
                 extensions: [],
                 userRemoteConfigs: [[
                     credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                     url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                 ]]
             )
         &#125;
     &#125;
     stage(&#39;build project&#39;) &#123;
         steps &#123;
             sh &#39;mvn clean package&#39;
         &#125;
     &#125;
     stage(&#39;sonarqube scan&#39;) &#123;
         environment &#123;
             // 传递给sonar-scanner JVM的启动参数，解决模块访问限制
             SONAR_SCANNER_OPTS = &#39;--add-opens=java.base/java.lang=ALL-UNNAMED &#39; +
                                  &#39;--add-opens=java.base/java.lang.reflect=ALL-UNNAMED &#39; +
                                  &#39;--add-opens=java.base/java.io=ALL-UNNAMED&#39;
         &#125;
         steps &#123;
             sh &#39;&#39;&#39;
             /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
               -Dsonar.projectKey=web_demo_freestyle \
               -Dsonar.host.url=http://192.168.200.129:9999 \
               -Dsonar.sources=. \
               -Dsonar.exclusions=**/test/**,**/target/** \
               -Dsonar.java.source=1.8 \
               -Dsonar.java.target=1.8
             &#39;&#39;&#39;
         &#125;
     &#125;
     stage(&#39;publish&#39;) &#123;
         steps &#123;
             deploy adapters: [tomcat8(
                 alternativeDeploymentContext: &#39;&#39;, 
                 credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, 
                 path: &#39;&#39;, 
                 url: &#39;http://192.168.200.131:8090/&#39;
             )], contextPath: null, war: &#39;target/*.war&#39;
         &#125;
     &#125;
 &#125;
 post &#123;
     always &#123;
         emailext(
             subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
             body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
             to: &#39;2523419709@qq.com&#39;
         )
     &#125;
 &#125;
&#125;
</code></pre>
<h3 id="✅-方法一：编辑-SonarScanner-的配置文件（最可靠）"><a href="#✅-方法一：编辑-SonarScanner-的配置文件（最可靠）" class="headerlink" title="✅ 方法一：编辑 SonarScanner 的配置文件（最可靠）"></a>✅ 方法一：编辑 SonarScanner 的配置文件（最可靠）</h3><p>编辑 Jenkins 中自动下载的 <code>sonar-scanner</code> 的 JVM 启动参数配置文件：</p>
<pre><code class="mysql">sudo vi /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/conf/sonar-scanner.properties
</code></pre>
<p>在文件最后 <strong>添加</strong></p>
<pre><code class="mysql"># 开启JDK17对反射的兼容
sonar.scanner.jvmArgs=--add-opens java.base/java.lang=ALL-UNNAMED
</code></pre>
<p>整体的文件是这样的：</p>
<pre><code class="yaml">#Configure here general information about the environment, such as SonarQube server connection details for example
#No information about specific project should appear here

#----- Default SonarQube server
sonar.host.url=http://localhost:9999

#----- Default source code encoding
#sonar.sourceEncoding=UTF-8
# 开启JDK17对反射的兼容
sonar.scanner.jvmArgs=--add-opens java.base/java.lang=ALL-UNNAMED
</code></pre>
<h4 id="★如果要使用sonarqube-一定要jdk是1-8★"><a href="#★如果要使用sonarqube-一定要jdk是1-8★" class="headerlink" title="★如果要使用sonarqube 一定要jdk是1.8★"></a>★如果要使用sonarqube 一定要jdk是1.8★</h4><p>首先需要去全局那里设置jdk（Manage jenkins → System）</p>
<p>键：<br><code>JAVA_HOME</code><br>值：<br><code>/usr/local/java/jdk-17.0.8+7</code></p>
<p>键：<br><code>JAVA_HOME</code><br>值：<br><code>/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64</code><br>在构建项目配置的时候<code>Build Steps</code> → <code>Execute SonarQube Scanner</code> → jdk一定要选择1.8的！！！</p>
<hr>
<hr>
<h4 id="流水线构建版本用的jdk17解决办法"><a href="#流水线构建版本用的jdk17解决办法" class="headerlink" title="流水线构建版本用的jdk17解决办法"></a><span style = "color:red"><strong>流水线构建版本用的jdk17解决办法</strong></span></h4><p>要默认的1.8才支持 所以直接从根源上解决这个问题</p>
<p>你当前的系统默认 Java 是 <strong>JDK 1.8</strong>，路径在：</p>
<pre><code>/usr/bin/java
</code></pre>
<p>你执行的：</p>
<pre><code>java -version
</code></pre>
<p>输出是：</p>
<pre><code>openjdk version &quot;1.8.0_262&quot;
</code></pre>
<p>说明现在 Jenkins 主机上默认使用的是 Java 8，这是符合 <strong>SonarQube 6.7.4 的推荐版本</strong>，很好！</p>
<hr>
<h2 id="✅-接下来你要做的"><a href="#✅-接下来你要做的" class="headerlink" title="✅ 接下来你要做的"></a>✅ 接下来你要做的</h2><p>为了确保 Jenkins 中的 <code>SonarScanner</code> 也用 Java 8 运行，你还需要修改如下：</p>
<hr>
<h3 id="✅-方法一：修改-sonar-scanner-启动脚本（推荐）"><a href="#✅-方法一：修改-sonar-scanner-启动脚本（推荐）" class="headerlink" title="✅ 方法一：修改 sonar-scanner 启动脚本（推荐）"></a>✅ 方法一：修改 <code>sonar-scanner</code> 启动脚本（推荐）</h3><pre><code class="java">vi /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner
</code></pre>
<p>在顶部添加下面两行 👇：</p>
<pre><code class="java">export JAVA_HOME=/usr
export PATH=$JAVA_HOME/bin:$PATH
</code></pre>
</blockquote>
<hr>
<h5 id="模拟SonaQube代码审查机制"><a href="#模拟SonaQube代码审查机制" class="headerlink" title="模拟SonaQube代码审查机制"></a>模拟SonaQube代码审查机制</h5><p><code>C:\Users\Pluminary\Desktop\web_demo\src\main\java\com\itheima\HelloServlet.java</code></p>
<pre><code class="java">package com.itheima;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 *
 */
public class HelloServlet extends HttpServlet &#123;


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        super.doPost(req,resp);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //模拟代码错误
        int i = 100/0;

        //模拟冗余代码
        int a = 100;
        a = 200;


        resp.getWriter().write(&quot;hello Servlet!&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！"><a href="#在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！" class="headerlink" title="在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！"></a>在项目添加SonaQube代码审查（流水线项目）<del>不在Jenkins里面写配置，在项目的文件里面写！</del></h4><pre><code class="java">sonar-project.properties
    
# must be unique in a given SonarQube instance
sonar.projectKey=web_demo_pipline
# this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.
sonar.projectName=web_demo_pipline
sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.
# This property is optional if sonar.modules is set.
sonar.sources=.
sonar.exclusions=**/test/**,**/target/**

sonar.java.source=1.8
sonar.java.target=1.8

# Encoding of the source code. Default is default system encoding
sonar.sourceEncoding=UTF-8
</code></pre>
<pre><code class="java">pipeline &#123;
    agent any

    tools &#123;
        // 使用 Jenkins 配置好的 JDK 1.8（别名需和你Jenkins中配置一致）
        jdk &#39;jdk-1.8.0&#39;
    &#125;

    environment &#123;
        // Sonar Scanner JVM 启动参数，开启必要的module访问权限
        SONAR_SCANNER_OPTS = &#39;--add-opens=java.base/java.lang=ALL-UNNAMED &#39; +
                             &#39;--add-opens=java.base/java.lang.reflect=ALL-UNNAMED &#39; +
                             &#39;--add-opens=java.base/java.io=ALL-UNNAMED&#39;
    &#125;

    stages &#123;
        stage(&#39;Pull Code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &quot;*/$&#123;branch&#125;&quot;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;

        stage(&#39;Build Project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;

        stage(&#39;SonarQube Scan&#39;) &#123;
            steps &#123;
                // 强制切换到 JDK8 环境，避免默认JDK17导致权限异常
                withEnv([
                    &#39;JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64&#39;,
                    &#39;PATH=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/bin:&#39; + env.PATH
                ]) &#123;
                    sh &#39;&#39;&#39;
                    /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
                      -Dsonar.projectKey=web_demo_freestyle \
                      -Dsonar.host.url=http://192.168.200.129:9999 \
                      -Dsonar.sources=. \
                      -Dsonar.exclusions=**/test/**,**/target/** \
                      -Dsonar.java.source=1.8 \
                      -Dsonar.java.target=1.8
                    &#39;&#39;&#39;
                &#125;
            &#125;
        &#125;

        stage(&#39;Publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(
                    alternativeDeploymentContext: &#39;&#39;,
                    credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;,
                    path: &#39;&#39;,
                    url: &#39;http://192.168.200.131:8090/&#39;
                )], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;

    post &#123;
        always &#123;
            emailext(
                subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
                body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
                to: &#39;2523419709@qq.com&#39;
            )
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h4 id="Jenkins-Docker-SpringCloud微服务持续集成-上"><a href="#Jenkins-Docker-SpringCloud微服务持续集成-上" class="headerlink" title="Jenkins+Docker+SpringCloud微服务持续集成(上)"></a>Jenkins+Docker+SpringCloud微服务持续集成(上)</h4><h5 id="Jenkins-Docker-SpringCloud持续集成流程说明"><a href="#Jenkins-Docker-SpringCloud持续集成流程说明" class="headerlink" title="Jenkins+Docker+SpringCloud持续集成流程说明"></a>Jenkins+Docker+SpringCloud持续集成流程说明</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/db193c56fc4ab5def5c327247037af53ce451fb5/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%AF%B4%E6%98%8E2.png"></p>
<p>大致流程说明：<br>1）开发人员每天把代码提交到Gitlab代码仓库<br>2）Jenkins从Gitlab中拉取项目源码，编译并打成jar包，然后构建成Docker镜像，将镜像上传到 Harbor私有仓库。<br>3）Jenkins发送SSH远程命令，让生产部署服务器到Harbor私有仓库拉取镜像到本地，然后创建容器。<br>4）最后，用户可以访问到容器</p>
<h6 id="服务列表-红色的软件为需要安装的软件，黑色代表已经安装"><a href="#服务列表-红色的软件为需要安装的软件，黑色代表已经安装" class="headerlink" title="服务列表(红色的软件为需要安装的软件，黑色代表已经安装)"></a>服务列表(红色的软件为需要安装的软件，黑色代表已经安装)</h6><table>
<thead>
<tr>
<th>服务器名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.200.132</td>
<td>Gitlab</td>
</tr>
<tr>
<td>持续集成服务器</td>
<td>192.168.200.129</td>
<td>Jenkins，Maven，Docker18.06.1-ce</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td></td>
<td>Docker18.06.1-ce，Harbor1.9.2</td>
</tr>
<tr>
<td>生产部署服务器</td>
<td></td>
<td>Docker18.06.1-ce</td>
</tr>
</tbody></table>
<h4 id="SpringCloud微服务源码概述"><a href="#SpringCloud微服务源码概述" class="headerlink" title="SpringCloud微服务源码概述"></a>SpringCloud微服务源码概述</h4><p>项目架构：前后端分离<br>后端技术栈：SpringBoot+SpringCloud+SpringDataJpa（Spring全家桶）<br>位置：<code>C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent</code></p>
<h6 id="微服务项目结构："><a href="#微服务项目结构：" class="headerlink" title="微服务项目结构："></a>微服务项目结构：</h6><ul>
<li>tensquare_parent ：父工程，存放基础配置 </li>
<li>tensquare_common ：通用工程，存放工具类 </li>
<li>tensquare_eureka_server：SpringCloud的Eureka注册中心 </li>
<li>tensquare_zuul ：SpringCloud的网关服务 </li>
<li>tensquare_admin_service ：基础权限认证中心，负责用户认证（使用JWT认证）</li>
<li>tensquare_gathering ： 一个简单的业务模块，活动微服务相关逻辑</li>
</ul>
<h6 id="数据库结构："><a href="#数据库结构：" class="headerlink" title="数据库结构："></a>数据库结构：</h6><ul>
<li>tensquare_user ：用户认证数据库，存放用户账户数据。对应tensquare_admin_service微服务 </li>
<li>tensquare_gathering ：活动微服务数据库。对应tensquare_gathering微服务</li>
</ul>
<h6 id="微服务配置分析："><a href="#微服务配置分析：" class="headerlink" title="微服务配置分析："></a>微服务配置分析：</h6><ul>
<li><p>tensquare_eureka</p>
</li>
<li><p>tensquare_zuul</p>
</li>
<li><p>tensquare_admin_service</p>
</li>
<li><p>tensquare_gathering</p>
</li>
<li><p>查看效果</p>
</li>
</ul>
<pre><code class="yaml">application.yaml

spring:
  application:
    name: EUREKA-HA

---

spring:
  profiles: eureka-server1
server:
  port: 10086
eureka:
  instance:
    hostname: localhost
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/

---

spring:
  profiles: eureka-server2
server:
  port: 10087
eureka:
  instance:
    hostname: localhost
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/
</code></pre>
<p>依次开启这些服务：<code>tensquare_eureka_server → tensquare_zuul → tensquare_admin_service → tensquare_gathering </code></p>
<blockquote>
<p>tensquare_eureka_server 要在配置的地方配置两个【复制出多一个】配置信息添加<code>Program arguments</code></p>
<p>EurekaServerApplication-Server1：-spring.profiles.active&#x3D;eureka-server1<br>EurekaServerApplication-Server2：–spring.profiles.active&#x3D;eureka-server2</p>
</blockquote>
<h5 id="调用postman"><a href="#调用postman" class="headerlink" title="调用postman"></a>调用postman</h5><h6 id="测试gathering接口的时候一定要在请求头带token"><a href="#测试gathering接口的时候一定要在请求头带token" class="headerlink" title="测试gathering接口的时候一定要在请求头带token"></a>测试gathering接口的时候一定要在请求头带token</h6><h6 id="测试获得token接口的时候一定是post请求-请求体是json形式"><a href="#测试获得token接口的时候一定是post请求-请求体是json形式" class="headerlink" title="测试获得token接口的时候一定是post请求 请求体是json形式"></a>测试获得token接口的时候一定是post请求 请求体是json形式</h6><pre><code class="yaml">GET：http://localhost:10020/gathering/gathering

Headers：这里的token是去post请求获得
</code></pre>
<pre><code class="yaml">POST：http://localhost:10020/admin/admin/login

json：&#123;
  &quot;loginname&quot;: &quot;admin&quot;,
  &quot;password&quot;: &quot;123456&quot;
&#125;
</code></pre>
<h4 id="本地部署-1-SpringCloud微服务部署"><a href="#本地部署-1-SpringCloud微服务部署" class="headerlink" title="本地部署(1)-SpringCloud微服务部署"></a>本地部署(1)-SpringCloud微服务部署</h4><h5 id="本地运行微服务"><a href="#本地运行微服务" class="headerlink" title="本地运行微服务"></a>本地运行微服务</h5><ul>
<li>逐一启动微服务</li>
<li>使用postman测试功能是否可用</li>
</ul>
<h5 id="本地部署微服务"><a href="#本地部署微服务" class="headerlink" title="本地部署微服务"></a>本地部署微服务</h5><ul>
<li>SpringBoot微服务项目打包</li>
</ul>
<blockquote>
<p>打开idea终端<br>PS C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent&gt;<br>托选想要打包的项目到终端<br>PS C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server&gt; <strong>mvn clean package</strong><br>此时就打好了jar包<br>C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server\target的<code>tensquare_eureka_server-1.0-SNAPSHOT.jar</code></p>
</blockquote>
<p>必须导入该插件</p>
<pre><code class="xml">在根pom.xml中
   &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

★ 这个就可以对springcloud进行打包 微服务的jar可以独立部署 扔到任何一个服务就可以单独运行 而不需要借助单独的tomcat ★
</code></pre>
<p>打包后在 target下产生jar包</p>
<ul>
<li><span style="color:red"><strong>本地运行微服务的jar包</strong></span></li>
</ul>
<p><code>java -jar xxx.jar</code></p>
<pre><code class="yaml">C:\Users\Pluminary\Desktop&gt;java -jar tensquare_eureka_server-1.0-SNAPSHOT.jar


2025-07-01 15:33:09.363  INFO 27172 --- [           main] o.s.core.annotation.AnnotationUtils      : Failed to introspect annotations on class org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration: java.lang.IllegalStateException: Could not obtain annotation attribute value for public abstract java.lang.Class[] org.springframework.boot.autoconfigure.condition.ConditionalOnClass.value()
2025-07-01 15:33:09.373  INFO 27172 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@8f4ea7c: startup date [Tue Jul 01 15:33:09 CST 2025]; root of context hierarchy
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils$1 (jar:file:/C:/Users/Pluminary/Desktop/tensquare_eureka_server-1.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-core-5.0.5.RELEASE.jar!/) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)
WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
2025-07-01 15:33:09.531  INFO 27172 --- [           main] f.a.AutowiredAnnotationBeanPostProcessor : JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring
2025-07-01 15:33:09.554  INFO 27172 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean &#39;configurationPropertiesRebinderAutoConfiguration&#39; of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$83532275] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)

  .   ____          _            __ _ _
 /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &#39;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.1.RELEASE)
</code></pre>
<h4 id="本地部署-2-前端静态web网站"><a href="#本地部署-2-前端静态web网站" class="headerlink" title="本地部署(2)-前端静态web网站"></a>本地部署(2)-前端静态web网站</h4><p>前端技术栈：NodeJS+VueJS+ElementUI<br>使用Visual Studio Code打开源码<br>位置：<code>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin</code></p>
<p>因为老版本无法继续用最新的nodejs<br>需要用nvm进行统一的nodejs管理 如果无法直接nvm下载的话<br>我们可以去官网下载安装包zip后解压进去 改名就行</p>
<blockquote>
<h4 id="✅-1-下载-Node-js-v10-24-1-64位-zip-版本"><a href="#✅-1-下载-Node-js-v10-24-1-64位-zip-版本" class="headerlink" title="✅ 1. 下载 Node.js v10.24.1 64位 zip 版本"></a>✅ 1. 下载 Node.js v10.24.1 64位 zip 版本</h4><p>你可以从官方链接下载：</p>
<p>📦 下载地址（Windows 64位）：</p>
<pre><code>bash


复制编辑
https://nodejs.org/dist/v10.24.1/node-v10.24.1-win-x64.zip
</code></pre>
<p>下载后，解压得到一个文件夹（比如叫 <code>node-v10.24.1-win-x64</code>）</p>
<hr>
<h4 id="✅-2-放入-NVM-的版本目录"><a href="#✅-2-放入-NVM-的版本目录" class="headerlink" title="✅ 2. 放入 NVM 的版本目录"></a>✅ 2. 放入 NVM 的版本目录</h4><p>将你解压得到的 <code>node-v10.24.1-win-x64</code> 文件夹重命名为：</p>
<pre><code>10.24.1
</code></pre>
<p>然后放入这个目录下：</p>
<pre><code>C:\Program Files\nvm\versions\10.24.1\
</code></pre>
<p>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin&gt;<strong>nvm list</strong></p>
<ul>
<li>20.12.0 (Currently using 64-bit executable)<br>10.24.1</li>
</ul>
<p>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin&gt;<strong>nvm use 10.24.1</strong><br>Now using node v10.24.1 (64-bit)</p>
<hr>
<hr>
<h4 id="🚀-步骤-1：重新下载对应-binding-node"><a href="#🚀-步骤-1：重新下载对应-binding-node" class="headerlink" title="🚀 步骤 1：重新下载对应 binding.node"></a>🚀 步骤 1：重新下载对应 <code>binding.node</code></h4><p>在项目目录下运行：</p>
<pre><code>bash


复制编辑
npm rebuild node-sass
</code></pre>
</blockquote>
<p> I  Your application is running here: <a target="_blank" rel="noopener" href="http://localhost:9528/">http://localhost:9528</a> 前端即可启动！<br><code>name: admin    password: 123456</code><br>[十次方社交平台-管理员后台] (<a target="_blank" rel="noopener" href="http://localhost:9528/#/gathering/index">http://localhost:9528/#/gathering/index</a>)</p>
<h3 id="环境准备-1-Docker快速入门"><a href="#环境准备-1-Docker快速入门" class="headerlink" title="环境准备(1)-Docker快速入门"></a>环境准备(1)-Docker快速入门</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流 行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销 极低。 Docker容器技术 vs 传统虚拟机技术</p>
<table>
<thead>
<tr>
<th></th>
<th>虚拟机</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td><strong>占用磁盘空间</strong></td>
<td>非常大，GB级</td>
<td>小，MB甚至KB级</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>慢。分钟级</td>
<td>快，秒级</td>
</tr>
<tr>
<td><strong>运行状态</strong></td>
<td>运行于Hypervisor上</td>
<td>直接运行在宿主机内核上</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>一台宿主机上十几个，最多几十个</td>
<td>上百个，甚至数百上千个</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>逊于宿主机</td>
<td>接近宿主机本地进程</td>
</tr>
<tr>
<td><strong>资源利用率</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>简单一句话总结：<strong>Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用</strong>。</p>
<h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>1）卸载旧版本</p>
<pre><code class="java">yum list installed | grep docker 列出当前所有docker的包
yum -y remove docker的包名称 卸载docker包
rm -rf /var/lib/docker 删除docker的所有镜像和容器
</code></pre>
<p>2）安装必要的软件包</p>
<pre><code class="yaml">sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2
</code></pre>
<p> 3）设置下载的镜像仓库</p>
<pre><code class="yaml">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p> 4）列出需要安装的版本列表</p>
<pre><code class="yaml">yum list docker-ce --showduplicates | sort -r
</code></pre>
<blockquote>
<p>docker-ce.x86_64  3:18.09.1-3.el7<br>docker-ce.x86_64  3:18.09.0-3.el7<br>docker-ce.x86_64  18.06.1.ce-3.el7<br>docker-ce.x86_64  18.06.0.ce-3.el7<br>…… </p>
</blockquote>
<p> 5 ）安装指定版本（这里使用18.0.1版本）</p>
<pre><code class="yaml">sudo yum install docker-ce-18.06.1.ce
</code></pre>
<p> 6）查看版本</p>
<pre><code class="yaml">docker -v
</code></pre>
<p> 7）启动Docker</p>
<pre><code class="yaml">sudo systemctl start docker   启动
sudo systemctl enable docker  设置开机启动
</code></pre>
<p>8）添加阿里云镜像下载地址</p>
<pre><code class="yaml">sudvi /etc/docker/daemon.json
</code></pre>
<blockquote>
<p>{<br>  “registry-mirrors”: [“<a href="https://zydiol88.mirror.aliyuncs.com&quot;]">https://zydiol88.mirror.aliyuncs.com&quot;]</a><br>}</p>
</blockquote>
<p>9 ）重启Docker</p>
<pre><code class="yaml">sudo systemctl restart docker
</code></pre>
<blockquote>
<p>第四步看这里：你现在的问题还是和之前一样：</p>
<blockquote>
<p>❌ <strong>无法访问 Docker 官方源（<code>https://download.docker.com/...</code>），报错 curl#35 - TCP connection reset by peer。</strong></p>
</blockquote>
<hr>
<h3 id="✅-解决方法：使用国内镜像（如清华、阿里）"><a href="#✅-解决方法：使用国内镜像（如清华、阿里）" class="headerlink" title="✅ 解决方法：使用国内镜像（如清华、阿里）"></a>✅ 解决方法：使用国内镜像（如清华、阿里）</h3><p>你需要 <strong>手动切换 Docker yum 源为国内镜像</strong>，否则无法继续安装。下面是最直接可行的解决方法。</p>
<hr>
<h2 id="🚀-一键换成清华源（CentOS-7-示例）"><a href="#🚀-一键换成清华源（CentOS-7-示例）" class="headerlink" title="🚀 一键换成清华源（CentOS 7 示例）"></a>🚀 一键换成清华源（CentOS 7 示例）</h2><p>请复制以下命令到你的服务器执行：</p>
<pre><code>bash复制编辑sudo tee /etc/yum.repos.d/docker-ce.repo &lt;&lt;-&#39;EOF&#39;
[docker-ce-stable]
name=Docker CE Stable - Tsinghua Mirror
baseurl=https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/7/x86_64/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/gpg
EOF
</code></pre>
<hr>
<h3 id="🔁-然后执行："><a href="#🔁-然后执行：" class="headerlink" title="🔁 然后执行："></a>🔁 然后执行：</h3><pre><code>sudo yum clean all
sudo yum makecache fast
</code></pre>
<hr>
<h3 id="✅-安装-Docker-指定版本（比如-18-06）"><a href="#✅-安装-Docker-指定版本（比如-18-06）" class="headerlink" title="✅ 安装 Docker 指定版本（比如 18.06）"></a>✅ 安装 Docker 指定版本（比如 18.06）</h3><pre><code>sudo yum install docker-ce-18.06.1.ce docker-ce-cli-18.06.1.ce containerd.io
</code></pre>
<p>或者查看所有可用版本：</p>
<pre><code>yum list docker-ce --showduplicates
</code></pre>
<hr>
<h3 id="🟢-启动并设置开机启动："><a href="#🟢-启动并设置开机启动：" class="headerlink" title="🟢 启动并设置开机启动："></a>🟢 启动并设置开机启动：</h3><pre><code>sudo systemctl start docker
sudo systemctl enable docker
</code></pre>
</blockquote>
<hr>
<hr>
<h3 id="Docker基本命令快速入门"><a href="#Docker基本命令快速入门" class="headerlink" title="Docker基本命令快速入门"></a>Docker基本命令快速入门</h3><h6 id="1）镜像命令"><a href="#1）镜像命令" class="headerlink" title="1）镜像命令"></a>1）镜像命令</h6><p>[docker配置镜像Docker pull时报错：<a target="_blank" rel="noopener" href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a> - 知乎] (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24228872523">https://zhuanlan.zhihu.com/p/24228872523</a>)</p>
<blockquote>
<p>这个错误表明Docker客户端尝试访问<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=253867805&content_type=Article&match_order=1&q=Docker+Hub&zhida_source=entity">Docker Hub</a>或其他<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=253867805&content_type=Article&match_order=1&q=Docker%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83&zhida_source=entity">Docker注册中心</a>时出现了问题。具体来说，是在尝试获取注册中心API的响应时遇到了错误。可能的原因包括网络问题、认证问题、注册中心URL不正确或者注册中心服务本身不可用。</p>
<p>2、解决方法</p>
<pre><code class="text">systemctl status docker
sudo mkdir -p /etc/docker
vim /etc/docker/daemon.json  
</code></pre>
<p>添加：</p>
<pre><code class="text">&#123;
  &quot;registry-mirrors&quot; : [&quot;https://docker.registry.cyou&quot;,
&quot;https://docker-cf.registry.cyou&quot;,
&quot;https://dockercf.jsdelivr.fyi&quot;,
&quot;https://docker.jsdelivr.fyi&quot;,
&quot;https://dockertest.jsdelivr.fyi&quot;,
&quot;https://mirror.aliyuncs.com&quot;,
&quot;https://dockerproxy.com&quot;,
&quot;https://mirror.baidubce.com&quot;,
&quot;https://docker.m.daocloud.io&quot;,
&quot;https://docker.nju.edu.cn&quot;,
&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,
&quot;https://docker.mirrors.ustc.edu.cn&quot;,
&quot;https://mirror.iscas.ac.cn&quot;,
&quot;https://docker.rainbond.cc&quot;,
&quot;https://do.nark.eu.org&quot;,
&quot;https://dc.j8.work&quot;,
&quot;https://dockerproxy.com&quot;,
&quot;https://gst6rzl9.mirror.aliyuncs.com&quot;,
&quot;https://registry.docker-cn.com&quot;,
&quot;http://hub-mirror.c.163.com&quot;,
&quot;http://mirrors.ustc.edu.cn/&quot;,
&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;,
&quot;http://mirrors.sohu.com/&quot; 
],
 &quot;insecure-registries&quot; : [
    &quot;registry.docker-cn.com&quot;,
    &quot;docker.mirrors.ustc.edu.cn&quot;
    ],
&quot;debug&quot;: true,
&quot;experimental&quot;: false
&#125;
</code></pre>
<p>重载和重启dockers服务</p>
<pre><code class="text">sudo systemctl daemon-reload
sudo systemctl restart docker
docker info
</code></pre>
<p>重新执行</p>
<pre><code class="text">docker run hello-world
</code></pre>
</blockquote>
<p>镜像：相当于应用的安装包，在Docker部署的任何应用都需要先构建成为镜像</p>
<pre><code class="yaml">docker search 镜像名称 搜索镜像
docker pull 镜像名称 拉取镜像
docker images 查看本地所有镜像
docker rmi -f 镜像名称 删除镜像
</code></pre>
<p><code>docker pull openjdk:8-jdk-alpine</code></p>
<pre><code class="yaml">[root@localhost ~]# docker pull openjdk:8-jdk-alpine
8-jdk-alpine: Pulling from library/openjdk
e7c96db7181b: Pull complete
f910a506b6cb: Pull complete
c2274a1a0e27: Pull complete
Digest: sha256:94792824df2df33402f201713f932b58cb9de94a0cd524164a0f2283343547b3
Status: Downloaded newer image for openjdk:8-jdk-alpine
[root@localhost ~]#
</code></pre>
<h4 id="2）容器命令"><a href="#2）容器命令" class="headerlink" title="2）容器命令"></a>2）容器命令</h4><p>容器：容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中。</p>
<pre><code class="yaml">docker run -i 镜像名称:标签 运行容器（默认是前台运行）
docker ps         查看运行的容器
docker ps -a      查询所有容器
</code></pre>
<h6 id="常用的参数："><a href="#常用的参数：" class="headerlink" title="常用的参数："></a>常用的参数：</h6><pre><code class="yaml">-i：运行容器
-d：后台守方式运行（守护式）
--name：给容器添加名称
-p：公开容器端口给当前宿主机
-v：挂载目录

docker exec -it 容器ID/容器名称 /bin/bash 进入容器内部
docker start/stop/restart 容器名称/ID 启动/停止/重启容器
docker rm -f 容器名称/ID 删除容器
</code></pre>
<blockquote>
<p>docker run -i nginx      运行容器<br>docker run -di nginx    后台运行容器</p>
</blockquote>
<h5 id="运行的时候创建端口-把端口暴露给宿主机-这样宿主机就可以进行ip地址-端口的访问虚拟机的容器了"><a href="#运行的时候创建端口-把端口暴露给宿主机-这样宿主机就可以进行ip地址-端口的访问虚拟机的容器了" class="headerlink" title="运行的时候创建端口 把端口暴露给宿主机 这样宿主机就可以进行ip地址+端口的访问虚拟机的容器了"></a>运行的时候创建端口 把端口暴露给宿主机 这样宿主机就可以进行ip地址+端口的访问虚拟机的容器了</h5><p><code>-p</code>是<span style = "color:red"><strong>公开端口</strong></span>   外部用90端口访问80端口<br><code>docker run -di -p 90:80 nginx</code></p>
<blockquote>
<p>[root@localhost ~]# docker run -di -p 90:80 nginx<br>04726503f6ee2d053b54b6361d128827d5fb26b867c8fbd5439a370a4ac137d9<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>04726503f6ee        nginx               “&#x2F;docker-entrypoint.…”   29 seconds ago      Up 27 seconds       0.0.0.0:90-&gt;80&#x2F;tcp   relaxed_goldberg</p>
</blockquote>
<p>此时用宿主机去访问：[Welcome to nginx!] (<a target="_blank" rel="noopener" href="http://192.168.200.129:90/">http://192.168.200.129:90/</a>)</p>
<blockquote>
<h1 id="Welcome-to-nginx"><a href="#Welcome-to-nginx" class="headerlink" title="Welcome to nginx!"></a>Welcome to nginx!</h1><p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p>
<p>For online documentation and support please refer to <a target="_blank" rel="noopener" href="http://nginx.org/">nginx.org</a>.<br>Commercial support is available at <a target="_blank" rel="noopener" href="http://nginx.com/">nginx.com</a>.</p>
<p><em>Thank you for using nginx.</em></p>
</blockquote>
<hr>
<h4 id="进入某个容器内部查看其内容："><a href="#进入某个容器内部查看其内容：" class="headerlink" title="进入某个容器内部查看其内容："></a>进入某个容器内部查看其内容：</h4><blockquote>
<p>[root@localhost ~]# <code>docker exec -it 04726503f6ee /bin/bash</code><br>root@04726503f6ee:&#x2F;# ls<br>bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>root@04726503f6ee:&#x2F;#</p>
</blockquote>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><blockquote>
<p>[root@localhost ~]# docker ps -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                NAMES<br>04726503f6ee        nginx               “&#x2F;docker-entrypoint.…”   4 minutes ago       Up 4 minutes                0.0.0.0:90-&gt;80&#x2F;tcp   relaxed_goldberg<br>9b9b1ec3e7a1        nginx               “&#x2F;docker-entrypoint.…”   10 minutes ago      Up 8 minutes                80&#x2F;tcp               gracious_knuth<br>4fb9d9e6858a        hello-world         “&#x2F;hello”                 29 minutes ago      Exited (0) 29 minutes ago                        elated_bhaskara<br>[root@localhost ~]# docker rm -f 4fb9d9e6858a<br>4fb9d9e6858a</p>
</blockquote>
<h3 id="虚拟机变化ip-导致无法ping通-解决办法"><a href="#虚拟机变化ip-导致无法ping通-解决办法" class="headerlink" title="虚拟机变化ip 导致无法ping通 解决办法"></a>虚拟机变化ip 导致无法ping通 解决办法</h3><p><code>cd /etc/sysconfig/network-scripts/</code></p>
<p><code>vi ifcfg-ens33</code></p>
<blockquote>
<h2 id="❗核心问题总结："><a href="#❗核心问题总结：" class="headerlink" title="❗核心问题总结："></a>❗核心问题总结：</h2><h3 id="你的宿主机（Windows）的真实联网网卡是："><a href="#你的宿主机（Windows）的真实联网网卡是：" class="headerlink" title="你的宿主机（Windows）的真实联网网卡是："></a>你的宿主机（Windows）的真实联网网卡是：</h3><ul>
<li><strong>无线网卡 WLAN</strong><ul>
<li>IP：<code>192.168.31.103</code></li>
<li>网关：<code>192.168.31.1</code></li>
</ul>
</li>
</ul>
<h3 id="而你的-VMware-虚拟机设置的是："><a href="#而你的-VMware-虚拟机设置的是：" class="headerlink" title="而你的 VMware 虚拟机设置的是："></a>而你的 VMware 虚拟机设置的是：</h3><ul>
<li><strong>静态 IP：192.168.200.132</strong></li>
<li>网关：<code>192.168.200.1</code></li>
<li>网络模式：你设为<strong>桥接模式</strong></li>
</ul>
<hr>
<h2 id="❗问题本质："><a href="#❗问题本质：" class="headerlink" title="❗问题本质："></a>❗问题本质：</h2><blockquote>
<p>你的虚拟机静态 IP 设置在 <strong>192.168.200.x 网段</strong>，但 <strong>宿主机是在 192.168.31.x 网段</strong>，说明你的<strong>桥接实际上根本没有生效</strong>，或者<strong>桥接到了错误的物理网卡</strong>。</p>
</blockquote>
<hr>
<h2 id="✅-最快修复方案（推荐，100-可行）："><a href="#✅-最快修复方案（推荐，100-可行）：" class="headerlink" title="✅ 最快修复方案（推荐，100% 可行）："></a>✅ 最快修复方案（推荐，100% 可行）：</h2><h3 id="🛠️-步骤一：修改-VMware-桥接设置"><a href="#🛠️-步骤一：修改-VMware-桥接设置" class="headerlink" title="🛠️ 步骤一：修改 VMware 桥接设置"></a>🛠️ 步骤一：修改 VMware 桥接设置</h3><ol>
<li>关闭虚拟机</li>
<li>打开 VMware 主界面 → 选择你的虚拟机 → 设置（Settings）→ 网络适配器</li>
<li>选择：<ul>
<li>✔️ 网络连接 → <strong>桥接模式（Bridged）</strong></li>
<li>点开旁边的 “<strong>桥接设置（Bridge Settings）</strong>”</li>
</ul>
</li>
<li>手动选择你的 <strong>Wi-Fi 无线网卡（例如 Intel Wireless-AC 或 Realtek Wireless）</strong><ul>
<li>不要选“自动”</li>
</ul>
</li>
<li><strong>取消勾选</strong>“复制物理网络连接状态”这一项</li>
<li>保存设置</li>
</ol>
<hr>
<h3 id="🛠️-步骤二：修改虚拟机内-IP-设置"><a href="#🛠️-步骤二：修改虚拟机内-IP-设置" class="headerlink" title="🛠️ 步骤二：修改虚拟机内 IP 设置"></a>🛠️ 步骤二：修改虚拟机内 IP 设置</h3><p>由于你真实网络是 <code>192.168.31.x</code>，所以虚拟机也应该设置为这个网段，例如：</p>
<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>：</p>
<pre><code>BOOTPROTO=static
NAME=ens33
DEVICE=ens33
ONBOOT=yes

IPADDR=192.168.31.150       # ← 随便取一个没被占用的
NETMASK=255.255.255.0
GATEWAY=192.168.31.1       # 这个是在宿主机网络下的环境网关 ipconfig
DNS1=8.8.8.8
</code></pre>
<p>然后执行：</p>
<pre><code>sudo systemctl restart network
</code></pre>
<p>或者：</p>
<pre><code>sudo ifdown ens33 &amp;&amp; sudo ifup ens33
</code></pre>
<hr>
<h3 id="✅-步骤三：在-Windows-上-ping-新的虚拟机-IP"><a href="#✅-步骤三：在-Windows-上-ping-新的虚拟机-IP" class="headerlink" title="✅ 步骤三：在 Windows 上 ping 新的虚拟机 IP"></a>✅ 步骤三：在 Windows 上 ping 新的虚拟机 IP</h3><pre><code>ping 192.168.31.150
</code></pre>
<hr>
<h2 id="🧠-如果你担心-IP-冲突怎么办？"><a href="#🧠-如果你担心-IP-冲突怎么办？" class="headerlink" title="🧠 如果你担心 IP 冲突怎么办？"></a>🧠 如果你担心 IP 冲突怎么办？</h2><p>在 Windows 上运行：</p>
<pre><code>ping 192.168.31.150
</code></pre>
<p>如果 ping 不通，就说明这个 IP 是空闲的，可以用。</p>
<hr>
<h2 id="✅-替代方案（保留-NAT-模式）"><a href="#✅-替代方案（保留-NAT-模式）" class="headerlink" title="✅ 替代方案（保留 NAT 模式）"></a>✅ 替代方案（保留 NAT 模式）</h2><p>如果你不想改桥接模式，可以继续用 <strong>VMware NAT 模式</strong>，那就让虚拟机保留原来的：</p>
<ul>
<li>IP：192.168.200.132</li>
<li>网关：192.168.200.1</li>
<li>然后通过端口转发（NAT 端口映射）来从主机访问虚拟机（需要手动配置）</li>
</ul>
<p>但 <strong>桥接 + 静态 IP 更简单、稳定、兼容性好</strong>。</p>
<hr>
<h2 id="✅-最终目标"><a href="#✅-最终目标" class="headerlink" title="✅ 最终目标"></a>✅ 最终目标</h2><p>你的宿主机和虚拟机 <strong>在同一个网段（如都在 <code>192.168.31.x</code>）</strong>，并且虚拟机网卡状态为 <code>UP</code>，那 ping 肯定通！</p>
<hr>
<h3 id="🔚-结论"><a href="#🔚-结论" class="headerlink" title="🔚 结论"></a>🔚 结论</h3><table>
<thead>
<tr>
<th>问题</th>
<th>解决方法</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟机 IP 设置错网段了</td>
<td>改为 <code>192.168.31.x</code>（和主机一样的网段）</td>
</tr>
<tr>
<td>桥接失败</td>
<td>手动指定桥接物理网卡为你的 <strong>无线网卡</strong>，不能选自动</td>
</tr>
<tr>
<td>不能 ping 通</td>
<td>网卡 DOWN → 启动；IP 不通 → 改网段；防火墙 → 暂停</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<blockquote>
<p>如果<code>ip a show ens33</code>没有ip地址怎么办 这样会导致moba连不上<br>应该是网卡状态为<code>down</code>说明网卡没启用<br>直接用ip命令把网卡打开<code>sudo ip link set ens33 up</code><br>然后找一下有没有 ip a show ens33<br>重启网络服务：<code>sudo systemctl restart network</code> 再次查看<br><span style = "color:red"><strong>如果还是没有 就手动设置IP</strong></span><br><code>sudo ip addr add 192.168.200.131/24 dev ens33 </code><br>再次重启网络服务：<code>sudo systemctl restart network</code><br>然后再次查看 <code>ip a show ens33</code></p>
</blockquote>
<h4 id="我想了解一下-虚拟机的-net直连-桥接-仅主机模式-自定义虚拟网络-这些有什么区别啊"><a href="#我想了解一下-虚拟机的-net直连-桥接-仅主机模式-自定义虚拟网络-这些有什么区别啊" class="headerlink" title="我想了解一下 虚拟机的 net直连 桥接 仅主机模式 自定义虚拟网络  这些有什么区别啊"></a>我想了解一下 虚拟机的 net直连 桥接 仅主机模式 自定义虚拟网络  这些有什么区别啊</h4><table>
<thead>
<tr>
<th>模式名称</th>
<th>虚拟机是否能访问外网</th>
<th>能否与主机通信</th>
<th>能否被局域网其它设备访问</th>
<th>场景用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NAT（网络地址转换）</strong></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>❌ 不能</td>
<td>默认模式，适合访问互联网但不被访问</td>
</tr>
<tr>
<td><strong>桥接模式（Bridged）</strong></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>适合开发、调试服务端程序</td>
</tr>
<tr>
<td><strong>仅主机模式（Host-Only）</strong></td>
<td>❌ 不可以</td>
<td>✅ 可以</td>
<td>❌ 不能</td>
<td>适合测试虚拟机与主机通信，隔离网络</td>
</tr>
<tr>
<td><strong>自定义虚拟网络</strong>（VMnetX）</td>
<td>看配置情况</td>
<td>看配置情况</td>
<td>看配置情况</td>
<td>高级用途，如多机组网、模拟拓扑</td>
</tr>
</tbody></table>
<h2 id="✅-判断网络模式"><a href="#✅-判断网络模式" class="headerlink" title="✅ 判断网络模式"></a>✅ 判断网络模式</h2><p>你需要检查虚拟机使用的<strong>网络连接方式</strong>，有几种常见模式：</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>是否能上网</th>
<th>是否能被主机访问</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAT</td>
<td>✅</td>
<td>❌</td>
<td>默认可以上网，不能被主机访问</td>
</tr>
<tr>
<td>桥接模式</td>
<td>✅</td>
<td>✅</td>
<td>与主机同网段，能上网、能互通</td>
</tr>
<tr>
<td>Host-only</td>
<td>❌</td>
<td>✅</td>
<td>不能上网，只能主机访问</td>
</tr>
<tr>
<td>内部网络（仅限虚拟机）</td>
<td>❌</td>
<td>❌</td>
<td>用于多虚拟机内部通信</td>
</tr>
</tbody></table>
<blockquote>
<h2 id="1️⃣-NAT-模式（默认）"><a href="#1️⃣-NAT-模式（默认）" class="headerlink" title="1️⃣ NAT 模式（默认）"></a>1️⃣ <strong>NAT 模式</strong>（默认）</h2><blockquote>
<p>虚拟机通过 VMware NAT 服务共享主机网络访问外网</p>
</blockquote>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 是 <code>192.168.200.x</code> 之类的 VMware 虚拟网段</li>
<li>宿主机充当“路由器”角色</li>
<li>适合需要上网，但不想暴露虚拟机到外部网络</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>无需特殊配置即可访问外网</li>
<li>安全，外部无法直接访问虚拟机</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>外部机器（包括宿主机）<strong>无法直接 ping 通虚拟机</strong></li>
<li>虚拟机 IP 不稳定</li>
</ul>
<h2 id="2️⃣-桥接模式（Bridged）"><a href="#2️⃣-桥接模式（Bridged）" class="headerlink" title="2️⃣ 桥接模式（Bridged）"></a>2️⃣ <strong>桥接模式（Bridged）</strong></h2><blockquote>
<p>虚拟机像真实电脑一样连接到局域网（通过宿主机的物理网卡桥接出去）</p>
</blockquote>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 和宿主机一样，都由路由器分配（比如 <code>192.168.31.x</code>）</li>
<li>可以直接与宿主机、局域网其他设备通信</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>和真实电脑一样，可以被 ping 通、远程访问、部署服务等</li>
<li>最贴近真实网络环境，适合服务器开发</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>依赖物理网络（尤其 Wi-Fi 桥接时可能失败）</li>
<li>公司&#x2F;学校网络可能屏蔽桥接</li>
</ul>
<h2 id="3️⃣-仅主机模式（Host-Only）"><a href="#3️⃣-仅主机模式（Host-Only）" class="headerlink" title="3️⃣ 仅主机模式（Host-Only）"></a>3️⃣ <strong>仅主机模式（Host-Only）</strong></h2><blockquote>
<p>虚拟机只能和宿主机通信，完全与外网隔离</p>
</blockquote>
<h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 通常是 <code>192.168.56.x</code> 或 <code>192.168.152.x</code></li>
<li>不能访问互联网</li>
</ul>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>安全，完全离线隔离</li>
<li>虚拟机和主机之间能稳定通信（做测试非常好）</li>
</ul>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>无法访问外网</li>
<li>无法被外部设备访问</li>
</ul>
<h2 id="4️⃣-自定义虚拟网络（VMnet0-19）"><a href="#4️⃣-自定义虚拟网络（VMnet0-19）" class="headerlink" title="4️⃣ 自定义虚拟网络（VMnet0~19）"></a>4️⃣ <strong>自定义虚拟网络（VMnet0~19）</strong></h2><blockquote>
<p>高级用户使用，可自由配置网络结构</p>
</blockquote>
<h3 id="典型用途："><a href="#典型用途：" class="headerlink" title="典型用途："></a>典型用途：</h3><ul>
<li>多台虚拟机组成专属局域网</li>
<li>配置 DHCP、NAT、Host-Only 混合网络</li>
<li>构建模拟数据中心、私有云、堡垒机环境等</li>
</ul>
<h2 id="🎯-总结建议（适合不同场景）："><a href="#🎯-总结建议（适合不同场景）：" class="headerlink" title="🎯 总结建议（适合不同场景）："></a>🎯 总结建议（适合不同场景）：</h2><table>
<thead>
<tr>
<th>场景</th>
<th>建议使用模式</th>
</tr>
</thead>
<tbody><tr>
<td>日常使用、能上网即可</td>
<td>NAT 模式（默认）</td>
</tr>
<tr>
<td>开发服务端、需要固定 IP + 被访问</td>
<td>桥接模式 ✅</td>
</tr>
<tr>
<td>只在主机和虚拟机之间通信</td>
<td>Host-Only 模式</td>
</tr>
<tr>
<td>多虚拟机模拟复杂网络</td>
<td>自定义（VMnet）</td>
</tr>
</tbody></table>
<h2 id="📌-一句话总结："><a href="#📌-一句话总结：" class="headerlink" title="📌 一句话总结："></a>📌 一句话总结：</h2><p><strong>NAT 是“内网访问外网”，桥接是“虚拟机等于真电脑”，Host-Only 是“我只和主机说话”，自定义是“你说了算”。</strong></p>
</blockquote>
<h2 id="环境准备-2-—Dockerfile镜像脚本快速入门"><a href="#环境准备-2-—Dockerfile镜像脚本快速入门" class="headerlink" title="环境准备(2)—Dockerfile镜像脚本快速入门"></a>环境准备(2)—Dockerfile镜像脚本快速入门</h2><p>Dockerfile其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组 合，只要理解它的逻辑和语法格式，就可以编写Dockerfile了。 简单点说，Dockerfile的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各 样，网络上的镜像很难满足实际的需求。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td></td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的作者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量(可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>编译镜像时运行的脚本(可以写多条)</td>
</tr>
<tr>
<td>CMD</td>
<td>设置容器的启动命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器的入口程序</td>
</tr>
<tr>
<td>ADD source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件。将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>和ADD相似，但是如果又压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>设置编译镜像时加入的参数</td>
</tr>
<tr>
<td>VOLUMN</td>
<td>设置容器的挂载卷</td>
</tr>
</tbody></table>
<p>新镜像是从基础镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一 层</p>
<h5 id="使用Dockerfile制作微服务镜像"><a href="#使用Dockerfile制作微服务镜像" class="headerlink" title="使用Dockerfile制作微服务镜像"></a>使用Dockerfile制作微服务镜像</h5><p>我们利用Dockerfile制作一个Eureka注册中心的镜像 </p>
<p>1）上传Eureka的微服务jar包到linux<del>这里的jar包要和Dockerfile文件在同一目录下</del><br>2）编写Dockerfile <code>vi Dockerfile</code></p>
<h6 id="作用-📦-构建一个用于运行-Java-应用（Spring-Boot-或其他-jar-应用）的-Docker-镜像。"><a href="#作用-📦-构建一个用于运行-Java-应用（Spring-Boot-或其他-jar-应用）的-Docker-镜像。" class="headerlink" title="作用:📦 构建一个用于运行 Java 应用（Spring Boot 或其他 jar 应用）的 Docker 镜像。"></a>作用:📦 <strong>构建一个用于运行 Java 应用（Spring Boot 或其他 jar 应用）的 Docker 镜像</strong>。</h6><p>这个 Dockerfile 是在用 Java 8 的轻量镜像里，运行你打包好的 jar 应用，并对外开放 10086 端口，非常适合部署 Spring Boot 项目。</p>
<pre><code class="yaml">FROM openjdk:8-jdk-alpine
ARG JAR_FILE
COPY $&#123;JAR_FILE&#125; app.jar
EXPOSE 10086
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<p>3 ）构建镜像 </p>
<p><code>docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1 .</code><br><u>-t是定义名字</u>  <u>.是在当前目录</u><br>4）查看镜像是否创建成功 </p>
<p><code>docker images </code></p>
<blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>eureka              v1                  36af14603456        15 seconds ago      150MB<br>nginx               latest              9592f5595f2b        7 days ago          192MB<br>hello-world         latest              74cc54e27dc4        5 months ago        10.1kB<br>openjdk             8-jdk-alpine        a3562aa0b991        6 years ago         105MB</p>
</blockquote>
<p>5）创建容器 </p>
<p><code>docker run -i --name=eureka -p 10086:10086 eureka:v1 </code><br><u>后台运行</u>：<code>docker run -d --name=eureka -p 10086:10086 eureka:v1</code></p>
<p>删除容器：<code>docker rm -f eureka</code><br>查看容器是否启动<code>docker ps</code><br>查看日志<code>docker logs -f eureka</code><br>后面可以直接启动这个容器 <code>docker start eureka</code></p>
<p>6）访问容器 <a target="_blank" rel="noopener" href="http://192.168.200.129:10086/">http://192.168.200.129:10086</a></p>
<blockquote>
<h3 id="修改后重新构建镜像："><a href="#修改后重新构建镜像：" class="headerlink" title="修改后重新构建镜像："></a>修改后重新构建镜像：</h3><pre><code>docker stop eureka
docker rm eureka

# 重新构建镜像（确保 Dockerfile 和配置文件都在当前目录）
docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1 .

# 启动容器并映射端口
docker run -d --name=eureka -p 10086:10086 eureka:v1
</code></pre>
<hr>
<p><strong>进入容器</strong>（你已经会了）：</p>
<pre><code>docker exec -it eureka /bin/sh
</code></pre>
<ol>
<li>**容器内查找 <code>application.yaml</code>**：</li>
</ol>
<pre><code>find / -name application.yaml 2&gt;/dev/null
</code></pre>
<ul>
<li><code>2&gt;/dev/null</code> 是把权限不够或找不到文件时的报错信息过滤掉，方便看结果。</li>
</ul>
<ol>
<li><strong>找到路径后，用 <code>cat</code> 查看内容</strong>：</li>
</ol>
<p>假设查到文件在 <code>/config/application.yaml</code>，那么：</p>
<pre><code>cat /config/application.yaml
</code></pre>
<hr>
<p>你要删除 <code>&lt;none&gt;</code> 的镜像，也就是“悬空镜像（dangling image）”，可以使用以下命令：</p>
<h3 id="🔍-查看所有悬空镜像"><a href="#🔍-查看所有悬空镜像" class="headerlink" title="🔍 查看所有悬空镜像"></a>🔍 查看所有悬空镜像</h3><pre><code>docker images -f &quot;dangling=true&quot;
</code></pre>
<h3 id="🗑-删除所有悬空镜像"><a href="#🗑-删除所有悬空镜像" class="headerlink" title="🗑 删除所有悬空镜像"></a>🗑 删除所有悬空镜像</h3><pre><code>docker rmi $(docker images -f &quot;dangling=true&quot; -q)
</code></pre>
<hr>
<p>root@localhost ~]# docker run -d –name&#x3D;eureka -p 10086:10086 eureka:v1 docker: Error response from daemon: Conflict. The container name “&#x2F;eureka” is already in use by container “9ea494448aeb1d99faecfe11e652f438938b87e1caaca890f9001199e1166dbc”. You have to remove (or rename) that container to be able to reuse that name. See ‘docker run –help’. 这个错误说明：<strong>虽然你已经 <code>docker stop eureka</code> 停止了容器，但它还没有被删除</strong>，所以容器名 <code>/eureka</code> 依然占用中，不能再用这个名字启动新的容器。</p>
<h3 id="✅-解决方案：删除旧容器"><a href="#✅-解决方案：删除旧容器" class="headerlink" title="✅ 解决方案：删除旧容器"></a>✅ 解决方案：删除旧容器</h3><p>你需要先 <strong>删除已停止的 <code>eureka</code> 容器</strong>，再重新启动：</p>
<pre><code>docker rm eureka
</code></pre>
<p>然后再重新运行新的容器：</p>
<pre><code>docker run -d --name=eureka -p 10086:10086 eureka:v1
</code></pre>
<hr>
<p>是桥接 能ping通 防火墙永久关闭了 本机打开了clash系统代理+全局</p>
<h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常关键的点来了！</p>
<p>你说：</p>
<p>✅ 虚拟机是桥接模式<br> ✅ 能 ping 通虚拟机 <code>192.168.200.129</code><br> ✅ 防火墙是永久关闭状态<br> ❌ <strong>本机打开了 Clash 并启用了系统代理 + 全局模式</strong></p>
<hr>
<h3 id="✅-你的-Eureka-服务配置和容器启动都是正确的，问题现在就出在：你本机开启了-Clash-的全局代理。"><a href="#✅-你的-Eureka-服务配置和容器启动都是正确的，问题现在就出在：你本机开启了-Clash-的全局代理。" class="headerlink" title="✅ 你的 Eureka 服务配置和容器启动都是正确的，问题现在就出在：你本机开启了 Clash 的全局代理。"></a>✅ 你的 Eureka 服务配置和容器启动都是正确的，问题现在就出在：<strong>你本机开启了 Clash 的全局代理。</strong></h3><h3 id="❗这会导致浏览器请求走代理，无法访问内网地址（例如-192-168-200-129-10086）。"><a href="#❗这会导致浏览器请求走代理，无法访问内网地址（例如-192-168-200-129-10086）。" class="headerlink" title="❗这会导致浏览器请求走代理，无法访问内网地址（例如 192.168.200.129:10086）。"></a>❗这会导致浏览器请求走代理，<strong>无法访问内网地址</strong>（例如 <code>192.168.200.129:10086</code>）。</h3><hr>
<h5 id="删除镜像：docker-rmi-eureka-v1"><a href="#删除镜像：docker-rmi-eureka-v1" class="headerlink" title="删除镜像：docker rmi eureka:v1"></a>删除镜像：<code>docker rmi eureka:v1</code></h5><p>删除所有悬挂镜像：&lt; none &gt;的 <code>docker images | grep &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs -r docker rmi -f</code></p>
<hr>
<hr>
<p><code>ss -tlnp | grep 10086</code>✅ 你看到的是：</p>
<pre><code>LISTEN     0      1024        :::10086                   :::*                   users:((&quot;docker-proxy&quot;,pid=31831,fd=4))
</code></pre>
<h3 id="📌-说明："><a href="#📌-说明：" class="headerlink" title="📌 说明："></a>📌 说明：</h3><p>这是 <strong>宿主机上的 docker-proxy</strong> 在监听 <code>10086</code> 端口，<strong>它只是端口映射的外壳进程</strong>。</p>
<p>但我们<strong>没有看到你容器内部的 Spring Boot 应用是否在监听端口</strong>，也就是说：</p>
<blockquote>
<p>✅ <strong>docker-proxy 映射是 OK 的</strong><br> ❗️<strong>容器里的 Spring Boot 可能绑定了 <code>127.0.0.1:10086</code>，不是 <code>0.0.0.0:10086</code>，导致 proxy 转发过去失败</strong></p>
</blockquote>
<hr>
<h2 id="✅-解决方案-——-修改配置，显式绑定-0-0-0-0"><a href="#✅-解决方案-——-修改配置，显式绑定-0-0-0-0" class="headerlink" title="✅ 解决方案 —— 修改配置，显式绑定 0.0.0.0"></a>✅ 解决方案 —— 修改配置，显式绑定 <code>0.0.0.0</code></h2><p>请 **修改你的 <code>application.yml</code>**，在 <code>server</code> 配置中添加这一行：</p>
<pre><code>yaml复制编辑server:
  port: 10086
  address: 0.0.0.0  # &lt;-- 显式监听所有网卡地址
</code></pre>
<hr>
<hr>
<p>[root@localhost ~]# netstat -tln<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 127.0.0.1:9100          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9229          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9168          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:8082          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:82              0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9236          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:3000          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:8060            0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9121          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9187          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9093          0.0.0.0:*               LISTEN<br>tcp6       0      0 :::3306                 :::*                    LISTEN<br>tcp6       0      0 ::1:9168                :::*                    LISTEN<br>tcp6       0      0 :::22                   :::*                    LISTEN<br>tcp6       0      0 :::10086                :::*                    LISTEN<br>tcp6       0      0 :::9094                 :::*                    LISTEN</p>
<p>你贴的 <code>netstat -tln</code> 结果说明：</p>
<ul>
<li>你的服务监听在 <strong><code>:::10086</code>（IPv6的所有地址）</strong>，没有监听任何IPv4地址（比如<code>0.0.0.0:10086</code>）</li>
<li>这意味着你的Spring Boot应用只监听了IPv6地址，IPv4访问就无法连接（所以你用 <code>http://192.168.200.129:10086</code> 访问会失败）</li>
</ul>
<h3 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h3><ol>
<li>修改你的 <code>Dockerfile</code> 中 <code>ENTRYPOINT</code>：</li>
</ol>
<pre><code class="java">FROM openjdk:8-jdk-alpine
ARG JAR_FILE
COPY $&#123;JAR_FILE&#125; app.jar
EXPOSE 10086
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<h2 id="2-构建新镜像（建议打新标签）"><a href="#2-构建新镜像（建议打新标签）" class="headerlink" title="2. 构建新镜像（建议打新标签）"></a>2. 构建新镜像（建议打新标签）</h2><pre><code>docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v2 .
</code></pre>
<hr>
<h2 id="3-停止并删除旧容器（如果还在运行）"><a href="#3-停止并删除旧容器（如果还在运行）" class="headerlink" title="3. 停止并删除旧容器（如果还在运行）"></a>3. 停止并删除旧容器（如果还在运行）</h2><pre><code>docker stop eureka
docker rm eureka
</code></pre>
<hr>
<h2 id="4-运行新镜像容器"><a href="#4-运行新镜像容器" class="headerlink" title="4. 运行新镜像容器"></a>4. 运行新镜像容器</h2><pre><code>docker run -d -p 10086:10086 --name eureka eureka:v2
</code></pre>
<h2 id="6-测试访问"><a href="#6-测试访问" class="headerlink" title="6. 测试访问"></a>6. 测试访问</h2><p>浏览器打开：</p>
<pre><code>http://192.168.200.129:10086
</code></pre>
<hr>
<hr>
<hr>
<p>现在可以访问成功了  为什么加上这句话就好了 ENTRYPOINT [“java”,”-Djava.net.preferIPv4Stack&#x3D;true”,”-jar”,”&#x2F;app.jar”] 为什么监听的时候还是ipv6 [root@localhost ~]# ss -tlnp | grep 10086 LISTEN     0      1024        :::10086                   :::*                   users:((“docker-proxy”,pid&#x3D;35209,fd&#x3D;4)) 但是成功在主机访问地址了</p>
<h6 id="为什么加上-Djava-net-preferIPv4Stack-true-就好了？"><a href="#为什么加上-Djava-net-preferIPv4Stack-true-就好了？" class="headerlink" title="为什么加上 -Djava.net.preferIPv4Stack=true 就好了？"></a>为什么加上 <code>-Djava.net.preferIPv4Stack=true</code> 就好了？</h6><ul>
<li>这个参数告诉 JVM <strong>优先使用 IPv4 网络栈</strong>，避免只监听 IPv6 导致外部 IPv4 地址访问不到的问题。</li>
<li>Spring Boot 的内嵌 Tomcat 在默认情况下，Linux 可能优先监听 IPv6 地址（<code>:::port</code>）。</li>
<li>加了这个参数后，Tomcat 会优先绑定 IPv4 地址，从而确保 Docker 的端口映射能正常被外部 IPv4 网络访问。</li>
</ul>
<hr>
<h3 id="为什么监听时还是显示-IPv6-10086-？"><a href="#为什么监听时还是显示-IPv6-10086-？" class="headerlink" title="为什么监听时还是显示 IPv6 (:::10086)？"></a>为什么监听时还是显示 IPv6 (<code>:::10086</code>)？</h3><ul>
<li>Linux 上 IPv6 的监听套接字 <code>:::</code> 默认是包含 IPv4 地址 <code>0.0.0.0</code> 的（叫做 IPv4-mapped IPv6 地址）。</li>
<li>也就是说，监听 <code>:::10086</code> 实际上同时监听了所有 IPv6 和 IPv4 地址。</li>
<li>这是一种操作系统层面的机制，不是 Java 层面的问题。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>-Djava.net.preferIPv4Stack=true</code></strong> 让 JVM 侧优先用 IPv4，避免了纯 IPv6 监听带来的访问问题。</li>
<li><strong><code>ss</code> 看到的 <code>:::10086</code> 其实也包括了 IPv4 地址</strong>，所以你才能用 IPv4 地址成功访问。</li>
<li>访问成功说明网络和端口映射都正常工作了。</li>
</ul>
<hr>
<hr>
<p>太好了，你现在已经非常接近成功了，我们来梳理一下现状和如何解决你“<strong>既能联网又能用 Mobaxterm 连上虚拟机</strong>”的问题。</p>
<hr>
<h2 id="✅-当前状态分析"><a href="#✅-当前状态分析" class="headerlink" title="✅ 当前状态分析"></a>✅ 当前状态分析</h2><p>你目前有两张网卡：</p>
<table>
<thead>
<tr>
<th>网卡名</th>
<th>IP 地址</th>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ens33</code></td>
<td><code>192.168.200.131</code></td>
<td>✅ UP，有 IP</td>
<td>是你原来的桥接或 Host-Only 网卡，用于主机连虚拟机</td>
</tr>
<tr>
<td><code>ens36</code></td>
<td>无 IP</td>
<td>❌ DOWN</td>
<td>是你新加的 NAT 网卡，但 <strong>没有启动 &#x2F; 没有获取 IP</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-为什么还无法联网？"><a href="#🧩-为什么还无法联网？" class="headerlink" title="🧩 为什么还无法联网？"></a>🧩 为什么还无法联网？</h2><p>你 curl 下载失败，是因为 NAT 网卡 <code>ens36</code> 没启动，虚拟机依然没联网。</p>
<hr>
<h2 id="✅-解决方案：启动-NAT-网卡并设置为默认出网口"><a href="#✅-解决方案：启动-NAT-网卡并设置为默认出网口" class="headerlink" title="✅ 解决方案：启动 NAT 网卡并设置为默认出网口"></a>✅ 解决方案：<strong>启动 NAT 网卡并设置为默认出网口</strong></h2><h3 id="第一步：激活-ens36（NAT-网卡）"><a href="#第一步：激活-ens36（NAT-网卡）" class="headerlink" title="第一步：激活 ens36（NAT 网卡）"></a>第一步：激活 ens36（NAT 网卡）</h3><p>执行：</p>
<pre><code>dhclient ens36
</code></pre>
<blockquote>
<p>⏳ 如果你没装 <code>dhclient</code>，可以试试：</p>
</blockquote>
<pre><code>nmcli device connect ens36
</code></pre>
<p>然后再次查看 IP：</p>
<pre><code>ip addr
</code></pre>
<p>你应该能看到 <code>ens36</code> 分配到类似 <code>192.168.226.x</code> 的地址（NAT 网段）</p>
</blockquote>
<h6 id="总结一下视频里的服务器ip所对应的服务"><a href="#总结一下视频里的服务器ip所对应的服务" class="headerlink" title="总结一下视频里的服务器ip所对应的服务"></a>总结一下视频里的服务器ip所对应的服务</h6><blockquote>
<p>192.168.66.100 GitLab<br>192.168.66.101 Jenkins<br>192.168.66.102 Harbor &amp;&amp; Tomcat<br>192.168.66.103 生产部署服务器</p>
</blockquote>
<h3 id="环境准备-3-Harbor镜像仓库安装及使用"><a href="#环境准备-3-Harbor镜像仓库安装及使用" class="headerlink" title="环境准备(3)-Harbor镜像仓库安装及使用"></a>环境准备(3)-Harbor镜像仓库安装及使用</h3><h5 id="Harbor简介"><a href="#Harbor简介" class="headerlink" title="Harbor简介"></a>Harbor简介</h5><p>Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。 除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：</p>
<ol>
<li>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以 用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定 传输的对象。 </li>
<li>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界 面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li>
<li>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。 </li>
<li>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li>
</ol>
<h5 id="Harbor安装"><a href="#Harbor安装" class="headerlink" title="Harbor安装"></a>Harbor安装</h5><p>Harbor需要安装在<code>192.168.200.131 Harbor &amp;&amp; Tomcat</code>上</p>
<ul>
<li><p>先安装Docker并启动Docker</p>
<blockquote>
<p>sudo systemctl start docker        启动Docker<br>sudo systemctl enable docker    开机自启动<br>sudo systemctl status docker     查看Docker服务状态</p>
</blockquote>
</li>
<li><p>安装docker-compose</p>
<pre><code class="java">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose 
sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
</li>
</ul>
<blockquote>
<p>你可以使用 <strong>离线安装 docker-compose</strong> 的方式，<strong>在主机上下载好二进制文件</strong>，再拷贝到虚拟机中使用，非常简单。</p>
<hr>
<h2 id="✅-方法一：主机下载-→-拷贝到虚拟机"><a href="#✅-方法一：主机下载-→-拷贝到虚拟机" class="headerlink" title="✅ 方法一：主机下载 → 拷贝到虚拟机"></a>✅ 方法一：<strong>主机下载 → 拷贝到虚拟机</strong></h2><h3 id="步骤-1️⃣：在主机（Windows）上用浏览器下载这个文件"><a href="#步骤-1️⃣：在主机（Windows）上用浏览器下载这个文件" class="headerlink" title="步骤 1️⃣：在主机（Windows）上用浏览器下载这个文件"></a>步骤 1️⃣：在主机（Windows）上用浏览器下载这个文件</h3><p>访问地址如下（你这个版本是 1.21.2）：</p>
<p>👉 <a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases/download/1.21.2/docker-compose-Linux-x86_64">https://github.com/docker/compose/releases/download/1.21.2/docker-compose-Linux-x86_64</a></p>
<p>下载后，重命名为：<code>docker-compose</code></p>
<hr>
<h3 id="步骤-2️⃣：用-MobaXterm-拷贝到虚拟机"><a href="#步骤-2️⃣：用-MobaXterm-拷贝到虚拟机" class="headerlink" title="步骤 2️⃣：用 MobaXterm 拷贝到虚拟机"></a>步骤 2️⃣：用 MobaXterm 拷贝到虚拟机</h3><p>你在 Mobaxterm 中连接好虚拟机后：</p>
<ol>
<li>左侧文件管理器中找到 <code>/usr/local/bin</code>（或 <code>/root</code>）</li>
<li>把你刚下载的 <code>docker-compose</code> 拖进去上传</li>
</ol>
<p>或者用 <code>scp</code> 命令上传：</p>
<pre><code>scp docker-compose root@192.168.200.131:/usr/local/bin/docker-compose
</code></pre>
<blockquote>
<p>把 <code>192.168.200.131</code> 换成你虚拟机 IP，输入密码即可</p>
</blockquote>
<hr>
<h3 id="步骤-3️⃣：在虚拟机中赋予执行权限"><a href="#步骤-3️⃣：在虚拟机中赋予执行权限" class="headerlink" title="步骤 3️⃣：在虚拟机中赋予执行权限"></a>步骤 3️⃣：在虚拟机中赋予执行权限</h3><pre><code>chmod +x /usr/local/bin/docker-compose
</code></pre>
<hr>
<h3 id="步骤-4️⃣：验证安装成功"><a href="#步骤-4️⃣：验证安装成功" class="headerlink" title="步骤 4️⃣：验证安装成功"></a>步骤 4️⃣：验证安装成功</h3><pre><code>docker-compose -v
</code></pre>
<p>输出类似：</p>
<pre><code>docker-compose version 1.21.2, build ...
</code></pre>
<p>✅ 完成！</p>
</blockquote>
<ul>
<li><p>下载Harbor的压缩包<code>harbor-offline-installer-v1.9.2.tgz</code></p>
</li>
<li><p>上传压缩包到linux并解压</p>
<blockquote>
<p>tar -xzf harbor-offline-installer-v1.9.2.tgz<br>mkdir &#x2F;opt&#x2F;harbor<br>mv harbor&#x2F;* &#x2F;opt&#x2F;harbor<br>cd &#x2F;opt&#x2F;harbor</p>
</blockquote>
</li>
<li><p>修改Harbor的配置</p>
<blockquote>
<p>vi harbor.yml</p>
</blockquote>
<p>修改hostname和port</p>
<blockquote>
<p>hostname：192.168.200.131<br>port：85</p>
</blockquote>
</li>
<li><p>安装Harbor</p>
<blockquote>
<p>.&#x2F;prepare<br>.&#x2F;install.sh </p>
</blockquote>
<h5 id="启动Harbor-★★-tomcat-131服务器"><a href="#启动Harbor-★★-tomcat-131服务器" class="headerlink" title="启动Harbor ★★ [tomcat 131服务器]"></a>启动Harbor ★★ [tomcat 131服务器]</h5><pre><code class="JAVA">cd /opt/harbor
./install.sh
</code></pre>
</li>
</ul>
<h5 id="这里有个经典的超级牛逼的大bug"><a href="#这里有个经典的超级牛逼的大bug" class="headerlink" title="这里有个经典的超级牛逼的大bug"></a><span style = "color:red">这里有个经典的超级牛逼的大bug</span></h5><h6 id="抛出问题："><a href="#抛出问题：" class="headerlink" title="抛出问题："></a>抛出问题：</h6><blockquote>
<p>这是我vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<br>DEFROUTE&#x3D;yes<br>NAME&#x3D;ens33<br>UUID&#x3D;a8ca17a4-0388-4b06-81b3-895e1a8180fe<br>DEVICE&#x3D;ens33<br>ONBOOT&#x3D;yes</p>
<p>IPADDR&#x3D;192.168.200.131<br>NETMASK&#x3D;255.255.255.0<br>GATEWAY&#x3D;192.168.31.1<br>DNS1&#x3D;8.8.8.8</p>
<p>这是我虚拟机的ip add</p>
<p>[root@localhost ~]# ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1&#x2F;128 scope host<br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    link&#x2F;ether 00:0c:29:7b:04:23 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.200.131&#x2F;24 brd 192.168.200.255 scope global noprefixroute ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe7b:423&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default<br>    link&#x2F;ether 02:42:94:7c:ad:4a brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever</p>
<p>该虚拟机选择了桥接模式 且 勾选了复制到物理网络连接状态<br>其虚拟网络编辑器里面<br>VMnet0 桥接模式 自动桥接   主机连接无 DHCP无  子网地址无<br>VMnet1 仅主机    外部连接无  主机连接已连接  DHCP已启用 子网地址192.168.22.0<br>VMnet8 NAT模式 NAT模式  主机连接已连接 DHCP无 子网地址192.168.200.0</p>
<p>这是我主机ipconfig<br>C:\Users\Pluminary&gt;ipconfig</p>
<p>Windows IP 配置</p>
<p>以太网适配器 以太网 4:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>无线局域网适配器 本地连接* 1:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>无线局域网适配器 本地连接* 2:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>以太网适配器 VMware Network Adapter VMnet1:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::1ea6:88fa:c0e1:f1ca%22<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.22.1<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . :</p>
<p>以太网适配器 VMware Network Adapter VMnet8:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::9e33:f9ac:4f64:9d71%3<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.200.2<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . : 192.168.200.1</p>
<p>无线局域网适配器 WLAN:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::7df7:efe4:1d3b:e2d2%12<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.31.103<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . : 192.168.31.1 </p>
<p>我现在的问题是 如果我改了GATEWAY&#x3D;192.168.31.1 为别的 那么我MobaXterm就连不上该虚拟机 现在的问题是 虚拟机没有网 我镜像都下载不了[root@localhost harbor]# .&#x2F;prepare<br>prepare base dir is set to &#x2F;opt&#x2F;harbor<br>Unable to find image ‘goharbor&#x2F;prepare:v1.9.2’ locally<br>^C<br>[root@localhost harbor]# ^C<br>[root@localhost harbor]#</p>
</blockquote>
<h6 id="GitHub解决方案："><a href="#GitHub解决方案：" class="headerlink" title="GitHub解决方案："></a>GitHub解决方案：</h6><blockquote>
<p>你目前的状态是：</p>
<hr>
<p>✅ <strong>虚拟机 IP</strong> 是 <code>192.168.200.131</code>（<strong>静态 IP，桥接模式下设置的</strong>）<br> ✅ <strong>宿主机 WLAN IP</strong> 是 <code>192.168.31.103</code><br> ❌ <strong>虚拟机无法联网</strong>（不能拉取镜像）<br> ✅ <strong>MobaXterm 可以连接虚拟机（192.168.200.131）</strong><br> ⚠️ <strong>虚拟机网关设置为 <code>192.168.31.1</code>，其实这是 WLAN 的网关，不属于 <code>192.168.200.x</code> 子网</strong></p>
<hr>
<h2 id="🔥-你现在的问题本质："><a href="#🔥-你现在的问题本质：" class="headerlink" title="🔥 你现在的问题本质："></a>🔥 <span style = "color:red">你现在的问题本质：</span></h2><ul>
<li>虽然 MobaXterm 能访问虚拟机 <code>192.168.200.131</code>，但虚拟机设置了一个<strong>不在本网段的网关：<code>192.168.31.1</code></strong></li>
<li>所以虚拟机根本无法出网（不能 ping 外网，也不能拉 harbor 镜像）</li>
</ul>
<hr>
<h2 id="✅-正确配置方式："><a href="#✅-正确配置方式：" class="headerlink" title="✅ 正确配置方式："></a>✅ 正确配置方式：</h2><p>让虚拟机在桥接模式下能 <strong>联网 + 被访问</strong></p>
<hr>
<h3 id="✅-第一步：设置正确网关（匹配虚拟机-IP-网段）"><a href="#✅-第一步：设置正确网关（匹配虚拟机-IP-网段）" class="headerlink" title="✅ 第一步：设置正确网关（匹配虚拟机 IP 网段）"></a>✅ 第一步：设置正确网关（匹配虚拟机 IP 网段）</h3><p>你虚拟机静态 IP 是 <code>192.168.200.131</code>，所以网关必须也在 <code>192.168.200.1~254</code> 范围。</p>
<p>观察宿主机 VMnet8（NAT）是 <code>192.168.200.2</code>，它的网关是：</p>
<pre><code>默认网关: 192.168.200.1
</code></pre>
<p>所以你应设置：</p>
<pre><code>IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1
DNS1=8.8.8.8
</code></pre>
<p>✅ 这个配置能让虚拟机出网（使用 VMware NAT 出口），也能让宿主机通过 <code>192.168.200.131</code> 访问虚拟机。</p>
<hr>
<h3 id="✅-第二步：如果你用的是-NAT-模式，则使用上面的-GATEWAY-是对的"><a href="#✅-第二步：如果你用的是-NAT-模式，则使用上面的-GATEWAY-是对的" class="headerlink" title="✅ 第二步：如果你用的是 NAT 模式，则使用上面的 GATEWAY 是对的"></a>✅ 第二步：如果你用的是 <strong>NAT 模式</strong>，则使用上面的 GATEWAY 是对的</h3><p>但你说你用了 <strong>桥接模式</strong>，那就要看桥接的是哪块网卡。</p>
<h4 id="桥接模式下，正确做法是："><a href="#桥接模式下，正确做法是：" class="headerlink" title="桥接模式下，正确做法是："></a>桥接模式下，正确做法是：</h4><ol>
<li>虚拟机 IP 要跟宿主机所连网络同一个网段</li>
<li>网关要设置为 <strong>宿主机 WLAN 的网关：<code>192.168.31.1</code></strong></li>
</ol>
<p>这样你才会在 MobaXterm 能访问、也能联网。</p>
<hr>
<h3 id="❗但你现在问题是："><a href="#❗但你现在问题是：" class="headerlink" title="❗但你现在问题是："></a>❗但你现在问题是：</h3><p>你桥接了，但 IP 却在 <code>192.168.200.x</code>，这说明虚拟机并没有成功桥接到宿主机 WLAN 网卡，而是连到了 VMware 的 NAT 网络（即使你设置桥接，也可能没生效）</p>
<hr>
<h2 id="✅-最建议方案"><a href="#✅-最建议方案" class="headerlink" title="✅ 最建议方案"></a>✅ 最建议方案</h2><h3 id="A-用-NAT-模式-正确网关（推荐稳定，适合大多数人）"><a href="#A-用-NAT-模式-正确网关（推荐稳定，适合大多数人）" class="headerlink" title="A. 用 NAT 模式 + 正确网关（推荐稳定，适合大多数人）"></a><strong>A. 用 NAT 模式 + 正确网关（推荐稳定，适合大多数人）</strong></h3><ol>
<li>把虚拟机改为 <strong>NAT 模式</strong></li>
<li><code>ifcfg-ens33</code> 设置如下：</li>
</ol>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1   # NAT 的默认网关
DNS1=8.8.8.8
</code></pre>
<ol>
<li>重启网络：</li>
</ol>
<pre><code>systemctl restart network
</code></pre>
<ol>
<li>测试网络：</li>
</ol>
<pre><code>ping -c 3 8.8.8.8
curl www.baidu.com
</code></pre>
<ol>
<li>然后使用 <code>MobaXterm</code> 访问你设置的 <code>192.168.200.131</code>，或设置端口转发（如 <code>127.0.0.1:2222</code> → <code>192.168.200.131:22</code>）</li>
</ol>
<hr>
<h3 id="B-或者继续桥接，但设置静态-IP-为-192-168-31-x-网段"><a href="#B-或者继续桥接，但设置静态-IP-为-192-168-31-x-网段" class="headerlink" title="B. 或者继续桥接，但设置静态 IP 为 192.168.31.x 网段"></a><strong>B. 或者继续桥接，但设置静态 IP 为 <code>192.168.31.x</code> 网段</strong></h3><p>如果你要桥接到宿主机 WLAN：</p>
<ol>
<li>修改 <code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>：</li>
</ol>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.31.130     # 自己定个没冲突的 IP
NETMASK=255.255.255.0
GATEWAY=192.168.31.1       # 你的无线网关
DNS1=8.8.8.8
</code></pre>
<ol>
<li>重启网络：</li>
</ol>
<pre><code>systemctl restart network
</code></pre>
<ol>
<li>检查 IP 和连通性：</li>
</ol>
<pre><code>ip addr
ping 8.8.8.8
</code></pre>
<hr>
<h2 id="✅-结论"><a href="#✅-结论" class="headerlink" title="✅ 结论"></a>✅ 结论</h2><p>你现在 MobaXterm 能连接，是因为用了静态 IP <code>192.168.200.131</code>，但由于网关不在同一网段，导致不能联网。</p>
<p>你只要根据你实际使用的网络模式（NAT 或桥接），<strong>把网关改成同网段的地址</strong>，问题就能解决。</p>
<hr>
<p>如果你告诉我你<strong>最终想使用 NAT 还是桥接</strong>（是否希望虚拟机能被其它设备访问），我可以直接帮你生成完整配置文件。</p>
<h6 id="继续延申问题："><a href="#继续延申问题：" class="headerlink" title="继续延申问题："></a>继续延申问题：</h6><p>我按照你说的改了 改成了nat模式 然后也改了配置  但是还是不行 [rooteloca1host ~]# ping -c 3 8.8.8.8PING 8.8.8.8(8.8.8.8) 56(84) bytes of data.From 192.168.200.131 icmp_seq&#x3D;1 Destination Host UnreachableFrom 192.168.200.131 icmp_seq&#x3D;2 Destination Host UnreachableFrom 192.168.200.131 icmp_seq&#x3D;3 Destination Host Unreachable8.8.8.8 ping statistics3 packets transmitted,0 received, +3 errors, 100% packet loss,time 1999mspipe3 现在连MobaXterm都连不上了 Network error: Connection timed out ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Session stopped    - Press <return> to exit tab    - Press R to restart session    - Press S to save terminal output to file</p>
<p>✅ 你现在的问题是：</p>
<blockquote>
<p><strong>你切换到 NAT 模式了，配置也改了，但：</strong></p>
<ul>
<li>❌ 仍然无法联网（<code>ping 8.8.8.8</code> 不通）</li>
<li>❌ MobaXterm 也连不上虚拟机（连接超时）</li>
<li>✅ 虚拟机 IP 是 <code>192.168.200.131</code>，网关你应该已改为 <code>192.168.200.1</code>（对吧？）</li>
</ul>
</blockquote>
<hr>
<p>我们来一步步快速排查：</p>
<hr>
<h2 id="✅-第一步：确认虚拟机网卡配置是否正确"><a href="#✅-第一步：确认虚拟机网卡配置是否正确" class="headerlink" title="✅ 第一步：确认虚拟机网卡配置是否正确"></a>✅ 第一步：确认虚拟机网卡配置是否正确</h2><p>在虚拟机里执行：</p>
<pre><code>cat /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<p>确认配置如下（<strong>静态 IP 模式 + NAT 网段的正确网关</strong>）：</p>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1
DNS1=8.8.8.8
</code></pre>
<p>如果不是这样，请立刻修改。</p>
<p>然后执行：</p>
<pre><code>systemctl restart network
</code></pre>
<hr>
<h2 id="✅-第二步：确认-NAT-模式是否正确工作"><a href="#✅-第二步：确认-NAT-模式是否正确工作" class="headerlink" title="✅ 第二步：确认 NAT 模式是否正确工作"></a>✅ 第二步：确认 NAT 模式是否正确工作</h2><p>打开 VMware 虚拟网络编辑器，确认：</p>
<ul>
<li>VMnet8 网络的 <strong>子网 IP</strong> 是 <code>192.168.200.0</code></li>
<li><strong>默认网关（Gateway）是 <code>192.168.200.1</code></strong></li>
<li>启用了 NAT 功能（有 <code>NAT 设置</code> 按钮，不是空的）</li>
<li>勾选了 “使用本地 DHCP 服务将 IP 地址分配给虚拟机”（建议开启）</li>
</ul>
<h2 id="✅-第三步：确认虚拟机路由是否存在"><a href="#✅-第三步：确认虚拟机路由是否存在" class="headerlink" title="✅ 第三步：确认虚拟机路由是否存在"></a>✅ 第三步：确认虚拟机路由是否存在</h2><p>在虚拟机中执行：</p>
<pre><code>ip route
</code></pre>
<p>你应该看到类似：</p>
<pre><code>default via 192.168.200.1 dev ens33
192.168.200.0/24 dev ens33 proto kernel scope link src 192.168.200.131
</code></pre>
<p>如果没有 <code>default via 192.168.200.1</code>，说明网关没生效，路由不通。</p>
<hr>
<h2 id="✅-第四步：确认宿主机启用了-NAT-网络服务"><a href="#✅-第四步：确认宿主机启用了-NAT-网络服务" class="headerlink" title="✅ 第四步：确认宿主机启用了 NAT 网络服务"></a>✅ 第四步：确认宿主机启用了 NAT 网络服务</h2><ol>
<li>打开 VMware 网络编辑器（以管理员身份运行）</li>
<li>点击 <code>VMnet8</code>，点右侧的 “NAT 设置”</li>
<li>看到：</li>
</ol>
<pre><code>网关 IP: 192.168.200.1
</code></pre>
<p>下面是端口转发之类设置，不用动。</p>
<ol>
<li>确保 VMware NAT Service 是运行状态：<ul>
<li>在宿主机按 Win+R → 输入 <code>services.msc</code></li>
<li>找到 <code>VMware NAT Service</code> 和 <code>VMware DHCP Service</code></li>
<li>状态必须是“正在运行”</li>
</ul>
</li>
</ol>
<hr>
<h2 id="✅-第五步：测试连接"><a href="#✅-第五步：测试连接" class="headerlink" title="✅ 第五步：测试连接"></a>✅ 第五步：测试连接</h2><ol>
<li>在虚拟机里执行：</li>
</ol>
<pre><code>ping 192.168.200.1
</code></pre>
<p>能 ping 通说明 NAT 网关 OK。</p>
<ol>
<li>在虚拟机里执行：</li>
</ol>
<pre><code>ping 8.8.8.8
</code></pre>
<p>仍然不通，说明出网失败，可能是：</p>
<ul>
<li>路由表错（<code>ip route</code> 查看）</li>
<li>NAT 服务没开（第 4 步）</li>
<li>没走正确网关（第 1 步）</li>
</ul>
<hr>
<hr>
<p>按照你说的做了 [root@localhost harbor]# docker ps | grep nginx 1773679bace8        goharbor&#x2F;nginx-photon:v1.9.2                             “nginx -g ‘daemon of…”   9 seconds ago       Up 7 seconds (health: starting)    0.0.0.0:85-&gt;8080&#x2F;tcp        nginx 7e41a5e0662b        goharbor&#x2F;harbor-portal:v1.9.2                            “nginx -g ‘daemon of…”   14 seconds ago      Up 10 seconds (health: starting)   8080&#x2F;tcp                    harbor-portal [root@localhost harbor]#</p>
<h6 id="ChatGPT-说：-1"><a href="#ChatGPT-说：-1" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常好，你现在的操作都没错，但从这条日志来看：</p>
<pre><code>
0.0.0.0:85-&gt;8080/tcp        nginx
</code></pre>
<p>说明 <strong><code>docker-compose.yml</code> 里仍然是 <code>85:8080</code> 映射</strong>，而不是我们期望的：</p>
<pre><code>
85:80
</code></pre>
<hr>
<h2 id="✅-解决方案：手动改一下-docker-compose-yml，然后重新启动-Harbor"><a href="#✅-解决方案：手动改一下-docker-compose-yml，然后重新启动-Harbor" class="headerlink" title="✅ 解决方案：手动改一下 docker-compose.yml，然后重新启动 Harbor"></a>✅ 解决方案：手动改一下 <code>docker-compose.yml</code>，然后重新启动 Harbor</h2><h3 id="✏️-步骤-1：手动修改端口映射"><a href="#✏️-步骤-1：手动修改端口映射" class="headerlink" title="✏️ 步骤 1：手动修改端口映射"></a>✏️ 步骤 1：手动修改端口映射</h3><p>打开 <code>docker-compose.yml</code>，找到 <code>proxy:</code> 下面这段：</p>
<pre><code>ports:
  - 85:8080
</code></pre>
<p>改成：</p>
<pre><code>ports:
  - 85:80
</code></pre>
<blockquote>
<p>🔁 如果你在 Vim 里编辑，改完后按：</p>
<pre><code>Esc → :wq
</code></pre>
</blockquote>
<hr>
<h3 id="🔄-步骤-2：重启-Harbor-服务"><a href="#🔄-步骤-2：重启-Harbor-服务" class="headerlink" title="🔄 步骤 2：重启 Harbor 服务"></a>🔄 步骤 2：重启 Harbor 服务</h3><pre><code>docker-compose down
docker-compose up -d
</code></pre>
<hr>
<h3 id="🔍-步骤-3：确认端口映射是否正确"><a href="#🔍-步骤-3：确认端口映射是否正确" class="headerlink" title="🔍 步骤 3：确认端口映射是否正确"></a>🔍 步骤 3：确认端口映射是否正确</h3><pre><code>docker ps | grep nginx
</code></pre>
<p>应该看到：</p>
<pre><code>0.0.0.0:85-&gt;80/tcp        nginx
</code></pre>
<hr>
<h3 id="✅-最后：浏览器访问-Harbor"><a href="#✅-最后：浏览器访问-Harbor" class="headerlink" title="✅ 最后：浏览器访问 Harbor"></a>✅ 最后：浏览器访问 Harbor</h3><p>打开浏览器访问：</p>
<pre><code>http://192.168.200.131:85/
</code></pre>
<p>你应该能看到 Harbor 登录页面。</p>
<hr>
<hr>
<h2 id="🔍-目前情况总结："><a href="#🔍-目前情况总结：" class="headerlink" title="🔍 目前情况总结："></a>🔍 目前情况总结：</h2><table>
<thead>
<tr>
<th>项</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td><code>nginx</code> 容器健康</td>
<td>✅ <code>healthy</code></td>
</tr>
<tr>
<td><code>curl localhost:85</code></td>
<td>❌ 失败（提示：Connection reset by peer）</td>
</tr>
<tr>
<td><code>ss -tnlp</code> 显示监听</td>
<td>✅ <code>docker-proxy</code> 在监听 <code>:::85</code></td>
</tr>
<tr>
<td><code>ping 192.168.200.131</code></td>
<td>✅ 通</td>
</tr>
<tr>
<td>浏览器访问 <code>http://192.168.200.131:85</code></td>
<td>❌ 超时</td>
</tr>
</tbody></table>
<h3 id="✅-正确的配置应为："><a href="#✅-正确的配置应为：" class="headerlink" title="✅ 正确的配置应为："></a>✅ 正确的配置应为：</h3><p>在 <code>docker-compose.yml</code> 里，把 <code>proxy</code> 服务的 <code>ports</code> 改为：</p>
<pre><code>ports:
  - 85:80
</code></pre>
<p>然后执行如下命令使配置生效：</p>
<pre><code># 停止并清理容器
docker-compose down

# 再启动
docker-compose up -d
</code></pre>
<p>再执行：</p>
<pre><code>curl -I http://localhost:85
</code></pre>
<p>你应该能看到：</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<p>然后用浏览器访问：</p>
<pre><code>http://192.168.200.131:85
</code></pre>
<p>✅ 成功进入 Harbor 页面！</p>
<hr>
<hr>
<p>我已经用了NAT模式 + 静态ip [root@localhost harbor]# curl -I <a target="_blank" rel="noopener" href="http://localhost:85/">http://localhost:85</a> curl: (56) Recv failure: Connection reset by peer [root@localhost harbor]# 嗯… 无法访问此页面 192.168.200.131 响应时间太长 请尝试： 在 Web 上搜索 192 168 200 131 检查连接 检查代理和防火墙 ERR_CONNECTION_TIMED_OUT</p>
<h6 id="ChatGPT-说：-2"><a href="#ChatGPT-说：-2" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>你现在的情况是：</p>
<ul>
<li>✅ 已经使用了 <strong>NAT 模式</strong>；</li>
<li>✅ <code>docker ps</code> 显示 Harbor 的 <code>nginx</code> 容器 <strong>端口映射是正确的</strong>：<code>0.0.0.0:85-&gt;80</code>；</li>
<li>❌ 但 <code>curl localhost:85</code> 报错：<code>Connection reset by peer</code>，说明容器里的 nginx 拒绝了连接；</li>
<li>❌ 主机访问 <code>http://192.168.200.131:85</code> 报超时，<strong>NAT 本身不支持直接访问虚拟机的 IP</strong>；</li>
<li>✅ 你已给虚拟机设置静态 IP 为 <code>192.168.200.131</code>；</li>
<li>❗ <strong>你没有配置端口转发！</strong></li>
</ul>
<hr>
<h2 id="🎯-结论：你现在这种做法是错误的"><a href="#🎯-结论：你现在这种做法是错误的" class="headerlink" title="🎯 结论：你现在这种做法是错误的"></a>🎯 结论：你现在这种做法是错误的</h2><blockquote>
<p><strong>NAT 模式下，主机不能通过虚拟机的 IP（192.168.200.131）访问 Harbor 的端口。</strong><br> <strong>应该通过端口转发实现！</strong></p>
</blockquote>
<hr>
<h2 id="✅-正确做法：配置端口转发（NAT-➜-主机映射）"><a href="#✅-正确做法：配置端口转发（NAT-➜-主机映射）" class="headerlink" title="✅ 正确做法：配置端口转发（NAT ➜ 主机映射）"></a>✅ 正确做法：配置端口转发（NAT ➜ 主机映射）</h2><h3 id="🛠-步骤如下："><a href="#🛠-步骤如下：" class="headerlink" title="🛠 步骤如下："></a>🛠 步骤如下：</h3><h4 id="①-打开-VMware-虚拟网络编辑器"><a href="#①-打开-VMware-虚拟网络编辑器" class="headerlink" title="① 打开 VMware 虚拟网络编辑器"></a>① 打开 VMware 虚拟网络编辑器</h4><ul>
<li>打开 VMware Workstation（非虚拟机内部）</li>
<li>菜单栏 ➜ <code>编辑</code> ➜ <code>虚拟网络编辑器</code></li>
<li>找到 <code>VMnet8</code>（即 NAT 模式）</li>
</ul>
<h4 id="②-点击右下角的“NAT-设置”"><a href="#②-点击右下角的“NAT-设置”" class="headerlink" title="② 点击右下角的“NAT 设置”"></a>② 点击右下角的“<strong>NAT 设置</strong>”</h4><ul>
<li>在弹出的 NAT 设置窗口中 ➜ 点击“<strong>端口转发（Port Forwarding）</strong>”</li>
</ul>
<h4 id="③-添加一条端口转发规则："><a href="#③-添加一条端口转发规则：" class="headerlink" title="③ 添加一条端口转发规则："></a>③ 添加一条端口转发规则：</h4><table>
<thead>
<tr>
<th>名称</th>
<th>协议</th>
<th>主机端口</th>
<th>虚拟机 IP</th>
<th>虚拟机端口</th>
</tr>
</thead>
<tbody><tr>
<td>harbor</td>
<td>TCP</td>
<td>1085</td>
<td>192.168.200.131</td>
<td>85</td>
</tr>
</tbody></table>
<blockquote>
<p>主机端口你可以写 1085，避免冲突；虚拟机端口是 Harbor 的端口 85。</p>
</blockquote>
<h2 id="📌-说明：为什么-NAT-模式不能直接访问虚拟机-IP？"><a href="#📌-说明：为什么-NAT-模式不能直接访问虚拟机-IP？" class="headerlink" title="📌 说明：为什么 NAT 模式不能直接访问虚拟机 IP？"></a>📌 说明：为什么 NAT 模式不能直接访问虚拟机 IP？</h2><blockquote>
<p>NAT 模式是虚拟机通过主机“共享网络”出去访问外部，但主机<strong>无法通过虚拟机的 NAT IP（如 192.168.200.131）访问回来</strong>，因为这个网段对主机来说是隔离的。<br> 除非做端口转发，否则无法通信。</p>
</blockquote>
<hr>
<hr>
<h3 id="🧭-接下来的最后一步："><a href="#🧭-接下来的最后一步：" class="headerlink" title="🧭 接下来的最后一步："></a>🧭 接下来的最后一步：</h3><p>你当前的网络结构是：</p>
<pre><code class="yaml">Windows 浏览器访问 localhost:10085
 ↓
VMware NAT 端口转发：10085 → 192.168.200.131:85
 ↓
Harbor Docker：85 → nginx容器的 82
 ↓
nginx 正常监听 82
</code></pre>
<p><code>cd /opt/harbor/</code></p>
<h5 id="搞了好久-估计是网络-配置的问题"><a href="#搞了好久-估计是网络-配置的问题" class="headerlink" title="搞了好久 估计是网络+配置的问题"></a><span style = "color:red">搞了好久 估计是网络+配置的问题</span></h5><p>这是<code>docker-compose.yml</code>的配置信息</p>
<pre><code class="yaml">version: &#39;2.3&#39;
services:
  log:
    image: goharbor/harbor-log:v1.9.2
    container_name: harbor-log
    restart: always
    dns_search: .
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    volumes:
      - /var/log/harbor/:/var/log/docker/:z
      - ./common/config/log/logrotate.conf:/etc/logrotate.d/logrotate.conf:z
      - ./common/config/log/rsyslog_docker.conf:/etc/rsyslog.d/rsyslog_docker.conf:z
    ports:
      - 127.0.0.1:1514:10514
    networks:
      - harbor
  registry:
    image: goharbor/registry-photon:v2.7.1-patch-2819-2553-v1.9.2
    container_name: registry
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
      - type: bind
        source: /data/secret/registry/root.crt
        target: /etc/registry/root.crt
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;registry&quot;
  registryctl:
    image: goharbor/harbor-registryctl:v1.9.2
    container_name: registryctl
    env_file:
      - ./common/config/registryctl/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
      - type: bind
        source: ./common/config/registryctl/config.yml
        target: /etc/registryctl/config.yml
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;registryctl&quot;
  postgresql:
    image: goharbor/harbor-db:v1.9.2
    container_name: harbor-db
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    volumes:
      - /data/database:/var/lib/postgresql/data:z
    networks:
      harbor:
    dns_search: .
    env_file:
      - ./common/config/db/env
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;postgresql&quot;
  core:
    image: goharbor/harbor-core:v1.9.2
    container_name: harbor-core
    env_file:
      - ./common/config/core/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - SETGID
      - SETUID
    volumes:
      - /data/ca_download/:/etc/core/ca/:z
      - /data/psc/:/etc/core/token/:z
      - /data/:/data/:z
      - ./common/config/core/certificates/:/etc/core/certificates/:z
      - type: bind
        source: ./common/config/core/app.conf
        target: /etc/core/app.conf
      - type: bind
        source: /data/secret/core/private_key.pem
        target: /etc/core/private_key.pem
      - type: bind
        source: /data/secret/keys/secretkey
        target: /etc/core/key
    networks:
      harbor:
    dns_search: .
    depends_on:
      - log
      - registry
      - redis
      - postgresql
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;core&quot;
  portal:
    image: goharbor/harbor-portal:v1.9.2
    container_name: harbor-portal
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
      - NET_BIND_SERVICE
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;portal&quot;

  jobservice:
    image: goharbor/harbor-jobservice:v1.9.2
    container_name: harbor-jobservice
    env_file:
      - ./common/config/jobservice/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/job_logs:/var/log/jobs:z
      - type: bind
        source: ./common/config/jobservice/config.yml
        target: /etc/jobservice/config.yml
    networks:
      - harbor
    dns_search: .
    depends_on:
      - core
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;jobservice&quot;
  redis:
    image: goharbor/redis-photon:v1.9.2
    container_name: redis
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/redis:/var/lib/redis
    networks:
      harbor:
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;redis&quot;
  proxy:
    image: goharbor/nginx-photon:v1.9.2
    container_name: nginx
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
      - NET_BIND_SERVICE
    volumes:
      - ./common/config/nginx:/etc/nginx:z
    networks:
      - harbor
    dns_search: .
    ports:
      - 85:8080
    depends_on:
      - registry
      - core
      - portal
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;proxy&quot;
networks:
  harbor:
    external: false
</code></pre>
<h6 id="这是harbor里的nginx的配置"><a href="#这是harbor里的nginx的配置" class="headerlink" title="这是harbor里的nginx的配置"></a>这是harbor里的nginx的配置</h6><pre><code class="yaml">[root@localhost nginx]# cat nginx.conf

worker_processes auto;
pid /tmp/nginx.pid;

events &#123;
  worker_connections 1024;
  use epoll;
  multi_accept on;
&#125;

http &#123;
  client_body_temp_path /tmp/client_body_temp;
  proxy_temp_path /tmp/proxy_temp;
  fastcgi_temp_path /tmp/fastcgi_temp;
  uwsgi_temp_path /tmp/uwsgi_temp;
  scgi_temp_path /tmp/scgi_temp;
  tcp_nodelay on;

  # this is necessary for us to be able to disable request buffering in all cases
  proxy_http_version 1.1;

  upstream core &#123;
    server core:8080;
  &#125;

  upstream portal &#123;
    server portal:8080;
  &#125;

  log_format timed_combined &#39;$remote_addr - &#39;
    &#39;&quot;$request&quot; $status $body_bytes_sent &#39;
    &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;
    &#39;$request_time $upstream_response_time $pipe&#39;;

  access_log /dev/stdout timed_combined;

  server &#123;
    listen 8080;
    server_tokens off;
    # disable any limits to avoid HTTP 413 for large image uploads
    client_max_body_size 0;

    # Add extra headers
    add_header X-Frame-Options DENY;
    add_header Content-Security-Policy &quot;frame-ancestors &#39;none&#39;&quot;;

    # costumized location config file can place to /etc/nginx/etc with prefix harbor.http. and suffix .conf
    include /etc/nginx/conf.d/harbor.http.*.conf;

    location / &#123;
      proxy_pass http://portal/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /c/ &#123;
      proxy_pass http://core/c/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /api/ &#123;
      proxy_pass http://core/api/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /chartrepo/ &#123;
      proxy_pass http://core/chartrepo/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /v1/ &#123;
      return 404;
    &#125;

    location /v2/ &#123;
      proxy_pass http://core/v2/;
      proxy_set_header Host $http_host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /service/ &#123;
      proxy_pass http://core/service/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /service/notifications &#123;
      return 404;
    &#125;
  &#125;
&#125;
</code></pre>
<p><span style = "color:red"><strong>这里附带重大BUG排查思路</strong></span></p>
<p>当然可以！我帮你把这整个过程的错误、涉及的宿主机、虚拟机、nginx（宿主机与容器里Harbor的nginx），以及排查思路，综合讲清楚，方便你理解整体流程。</p>
<hr>
<h1 id="1-相关环境和组件说明"><a href="#1-相关环境和组件说明" class="headerlink" title="1. 相关环境和组件说明"></a>1. 相关环境和组件说明</h1><ul>
<li><strong>宿主机</strong>：你的真实物理机或主机系统（Windows），负责运行虚拟机软件（比如VMware）。</li>
<li><strong>虚拟机</strong>：运行 Harbor 的 Linux 虚拟机（192.168.200.131），是 Harbor 的部署环境。</li>
<li><strong>Docker 容器内的 nginx</strong>：Harbor 里内置的 nginx 作为反向代理服务器，监听容器内部的端口（如 82 或 8080），将请求转发给 Harbor 应用组件。</li>
<li><strong>宿主机与虚拟机的网络</strong>：<ul>
<li>虚拟机配置桥接或NAT网络，宿主机通过 IP 和端口转发访问虚拟机。</li>
<li>端口转发需确保宿主机防火墙、虚拟机防火墙和 Docker 端口映射正确。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-你遇到的主要错误和症状总结"><a href="#2-你遇到的主要错误和症状总结" class="headerlink" title="2. 你遇到的主要错误和症状总结"></a>2. 你遇到的主要错误和症状总结</h1><table>
<thead>
<tr>
<th>错误&#x2F;症状</th>
<th>可能原因</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>Test-NetConnection</code> 提示 TCP 连接失败（比如端口1085失败，10085成功但浏览器连接拒绝）</td>
<td>端口未开放或服务未监听，防火墙或网络配置问题</td>
<td>端口映射或容器服务没启动好</td>
</tr>
<tr>
<td>Docker 启动 nginx 容器时报错：<code>unknown log opt &#39;syslog-address&#39; for json-file log driver</code></td>
<td><code>logging</code> 配置不兼容，<code>json-file</code> 驱动不支持 <code>syslog-address</code> 参数</td>
<td>需要调整日志驱动配置</td>
</tr>
<tr>
<td><code>curl http://localhost:85</code> 返回 302 或 200，但浏览器访问虚拟机IP时超时或重置连接</td>
<td>虚拟机防火墙、宿主机端口转发配置错误，或者nginx监听端口配置不一致</td>
<td>宿主机访问虚拟机端口不通</td>
</tr>
<tr>
<td>虚拟机上 <code>ss -tnlp</code> 看到 nginx 监听的是 82 端口，而 Docker 映射是 85:82</td>
<td>端口映射正确，但宿主机访问端口和内部监听端口不一致需要确认</td>
<td>访问时端口错位会导致访问失败</td>
</tr>
</tbody></table>
<hr>
<h1 id="3-排查思路和步骤详解"><a href="#3-排查思路和步骤详解" class="headerlink" title="3. 排查思路和步骤详解"></a>3. 排查思路和步骤详解</h1><h3 id="Step-1：确认容器服务启动及端口监听情况"><a href="#Step-1：确认容器服务启动及端口监听情况" class="headerlink" title="Step 1：确认容器服务启动及端口监听情况"></a>Step 1：确认容器服务启动及端口监听情况</h3><ul>
<li><code>docker-compose up -d</code> 启动 Harbor 相关服务，包括 nginx 代理容器。</li>
<li><code>docker ps</code> 看 nginx 容器是否在运行。</li>
<li><code>docker logs nginx</code> 查看 nginx 容器日志，看是否报错。</li>
<li><code>ss -tnlp</code>（或 <code>netstat -tnlp</code>）确认 nginx 容器内部监听端口，例如82或8080。</li>
</ul>
<hr>
<h3 id="Step-2：确认端口映射和宿主机网络"><a href="#Step-2：确认端口映射和宿主机网络" class="headerlink" title="Step 2：确认端口映射和宿主机网络"></a>Step 2：确认端口映射和宿主机网络</h3><ul>
<li>确认 docker-compose 端口映射，比如 <code>- 85:82</code> 说明宿主机85端口映射到容器82端口。</li>
<li>确认虚拟机的网络IP（192.168.200.131）可访问，虚拟机是否允许访问85端口。</li>
<li>通过宿主机（Windows）<code>Test-NetConnection 192.168.200.131 85</code> 测试连通性。</li>
<li>如果端口连接失败，检查：<ul>
<li>虚拟机防火墙状态（如 <code>firewall-cmd</code>），确认85端口开放。</li>
<li>虚拟机网络配置是否正确。</li>
<li>宿主机是否正确做了端口转发（NAT配置等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Step-3：确认宿主机与虚拟机间端口转发与防火墙设置"><a href="#Step-3：确认宿主机与虚拟机间端口转发与防火墙设置" class="headerlink" title="Step 3：确认宿主机与虚拟机间端口转发与防火墙设置"></a>Step 3：确认宿主机与虚拟机间端口转发与防火墙设置</h3><ul>
<li>你之前做的 VMware NAT 端口转发配置，确认宿主机的10085端口转发到虚拟机的85端口。</li>
<li>虚拟机防火墙是否禁用或开放该端口（你确认了 <code>firewalld</code> 未运行）。</li>
<li>SELinux 状态（你确认是 <code>Permissive</code>，不阻止）。</li>
</ul>
<hr>
<h3 id="Step-4：确认容器内部-nginx-与-Harbor-应用运行状态"><a href="#Step-4：确认容器内部-nginx-与-Harbor-应用运行状态" class="headerlink" title="Step 4：确认容器内部 nginx 与 Harbor 应用运行状态"></a>Step 4：确认容器内部 nginx 与 Harbor 应用运行状态</h3><ul>
<li>容器内 nginx 配置监听82端口，但外部映射成85端口，确认两者一致。</li>
<li>容器内 curl localhost:82 返回200，说明 nginx 服务正常。</li>
<li>nginx 返回的网页中包含 Harbor 前端静态资源，但前端一直转圈，可能是后端 API 没响应。</li>
<li>可能是 Harbor 核心服务(core)未正常工作或访问不到数据库&#x2F;redis，导致页面没加载完成。</li>
</ul>
<hr>
<h3 id="Step-5：重启虚拟机后问题消失"><a href="#Step-5：重启虚拟机后问题消失" class="headerlink" title="Step 5：重启虚拟机后问题消失"></a>Step 5：重启虚拟机后问题消失</h3><ul>
<li>重启虚拟机后，网络重新初始化，Docker网络也重建，端口转发生效，nginx和Harbor服务正常，浏览器访问成功。</li>
<li>说明之前网络环境（端口转发、Docker网络或nginx监听）存在缓存或未正常启动的问题。</li>
</ul>
<hr>
<h1 id="4-你看到的“宿主机与虚拟机”和“nginx内部-x2F-外部”的关系"><a href="#4-你看到的“宿主机与虚拟机”和“nginx内部-x2F-外部”的关系" class="headerlink" title="4. 你看到的“宿主机与虚拟机”和“nginx内部&#x2F;外部”的关系"></a>4. 你看到的“宿主机与虚拟机”和“nginx内部&#x2F;外部”的关系</h1><table>
<thead>
<tr>
<th>层级</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宿主机 (Windows)</strong></td>
<td>你直接操作的机器，运行 VMware，提供 NAT&#x2F;桥接网络，做端口转发</td>
<td>访问虚拟机IP和端口</td>
</tr>
<tr>
<td><strong>虚拟机 (Linux Harbor 环境)</strong></td>
<td>Harbor 部署环境，运行 Docker 和 Harbor 服务容器</td>
<td>虚拟机防火墙和网络设置必须正确</td>
</tr>
<tr>
<td><strong>Docker 容器内 nginx</strong></td>
<td>Harbor 的反向代理，监听容器内部端口（如82），转发给 Harbor 应用服务</td>
<td>Docker端口映射：宿主机85端口映射到容器82端口</td>
</tr>
<tr>
<td><strong>Harbor 应用组件</strong></td>
<td>Core、Portal、Registry 等，负责业务逻辑和数据</td>
<td>需要数据库和redis支持，服务正常才能正常访问</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-综合总结"><a href="#5-综合总结" class="headerlink" title="5. 综合总结"></a>5. 综合总结</h1><ul>
<li>你先遇到的端口连接失败，是虚拟机内服务监听、端口映射、虚拟机防火墙或宿主机端口转发配置的问题。</li>
<li>Docker 容器日志中的 <code>unknown log opt &#39;syslog-address&#39;</code> 是日志驱动配置错误，需要统一用 <code>json-file</code> 或兼容的驱动。</li>
<li>宿主机访问端口和容器监听端口要对应，nginx监听82端口，宿主机映射85端口，访问时要用宿主机的85端口。</li>
<li>访问 Harbor 首页看到 nginx 返回 200，说明 nginx 正常，前端页面开始加载，但若页面卡住，可能是后端服务未完全启动或网络访问不到其他 Harbor 服务。</li>
<li>重启虚拟机会刷新网络环境和容器服务，解决了之前隐藏的网络端口转发、Docker网络或者服务启动顺序的问题。</li>
<li>最后确认服务正常，可以访问页面。</li>
</ul>
<hr>
<p>如果总结起来，整个排查流程是：</p>
<ol>
<li><strong>确认服务启动和端口监听</strong>（<code>docker-compose up</code>、<code>ss -tnlp</code>、<code>docker logs</code>）。</li>
<li><strong>检查端口映射和虚拟机网络配置</strong>（NAT端口转发、虚拟机IP、防火墙）。</li>
<li><strong>宿主机访问测试</strong>（PowerShell的Test-NetConnection）。</li>
<li><strong>确认容器内服务状态</strong>（容器内curl）。</li>
<li><strong>调整配置并重启验证</strong>。</li>
<li><strong>最终确认页面访问正常</strong>。</li>
</ol>
<hr>
<h1 id="Harbor-访问故障排查文档"><a href="#Harbor-访问故障排查文档" class="headerlink" title="Harbor 访问故障排查文档"></a>Harbor 访问故障排查文档</h1><h2 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h2><p>你在虚拟机上用 Docker Compose 部署 Harbor，遇到宿主机访问 Harbor Web UI 端口无法连接的问题。本文档总结了排查和解决过程，覆盖容器服务状态、端口映射、虚拟机网络、防火墙配置等关键点。</p>
<hr>
<h2 id="二、排查准备"><a href="#二、排查准备" class="headerlink" title="二、排查准备"></a>二、排查准备</h2><ul>
<li><strong>宿主机环境</strong>：Windows（通过 VMware 运行虚拟机）</li>
<li><strong>虚拟机环境</strong>：Linux，Harbor 服务部署环境，IP 如 <code>192.168.200.131</code></li>
<li><strong>Docker Harbor 版本</strong>：v1.9.2</li>
<li><strong>访问端口映射</strong>：宿主机端口 85 映射到容器内 nginx 监听端口 82</li>
</ul>
<hr>
<h2 id="三、排查步骤"><a href="#三、排查步骤" class="headerlink" title="三、排查步骤"></a>三、排查步骤</h2><h3 id="Step-1-容器服务启动状态检查"><a href="#Step-1-容器服务启动状态检查" class="headerlink" title="Step 1. 容器服务启动状态检查"></a>Step 1. 容器服务启动状态检查</h3><ul>
<li><p>使用命令：</p>
<pre><code>bash复制编辑docker-compose up -d
docker ps
docker logs nginx --tail 50
</code></pre>
</li>
<li><p>确认 nginx 容器及其他 Harbor 服务容器是否运行正常，没有报错。</p>
</li>
<li><p>使用命令查看容器内部端口监听：</p>
<pre><code>bash


ss -tnlp | grep nginx
</code></pre>
</li>
</ul>
<p> 确认 nginx 是否监听正确的端口（一般是 82 或 8080）。</p>
<hr>
<h3 id="Step-2-Docker-端口映射与虚拟机端口监听确认"><a href="#Step-2-Docker-端口映射与虚拟机端口监听确认" class="headerlink" title="Step 2. Docker 端口映射与虚拟机端口监听确认"></a>Step 2. Docker 端口映射与虚拟机端口监听确认</h3><ul>
<li><p>检查 <code>docker-compose.yml</code> 端口映射配置，如：</p>
<p>&#96;&#96;&#96;</p>
</li>
</ul>
<p>ports:<br>    - 85:82</p>
<pre><code>
表示宿主机（虚拟机）85端口映射到容器82端口。

- 在虚拟机上确认端口监听：
</code></pre>
<pre><code>ss -tnlp | grep :85
```
</code></pre>
<p>  通常 docker-proxy 会监听对应端口。</p>
<hr>
<h3 id="Step-3-虚拟机网络配置和防火墙检查"><a href="#Step-3-虚拟机网络配置和防火墙检查" class="headerlink" title="Step 3. 虚拟机网络配置和防火墙检查"></a>Step 3. 虚拟机网络配置和防火墙检查</h3><ul>
<li>检查虚拟机的防火墙状态：</li>
</ul>
<pre><code>
firewall-cmd --state
</code></pre>
<pre><code>确保防火墙关闭或已开放对应端口。
</code></pre>
<ul>
<li><p>查看 SELinux 状态（有时会阻止网络服务）：</p>
<p>&#96;&#96;&#96;<br> getenforce</p>
</li>
</ul>
<pre><code>
建议设置为 `Permissive` 或 `Disabled`。

- 检查虚拟机的 IP 配置，确认使用的是正确的 IP。
 
 - 在宿主机（Windows）上使用 PowerShell 测试端口连通：
</code></pre>
<p>  powershell</p>
<p> 复制编辑<br>  Test-NetConnection -ComputerName 192.168.200.131 -Port 85</p>
<pre><code>
------

### Step 4. 宿主机与虚拟机端口转发设置（NAT模式）
 
 - 如果使用 VMware NAT，需要在 VMware NAT 设置中配置端口转发：
 - 主机端口（宿主机）设为 `10085`（或你需要的端口）
 - 转发到虚拟机 IP（如 `192.168.200.131`）的 85 端口
- 通过宿主机访问 `localhost:10085`，实际访问虚拟机的 Harbor 服务。

------

### Step 5. 使用 curl 命令测试服务

- 在虚拟机内部测试：
</code></pre>
<p> curl -I <a target="_blank" rel="noopener" href="http://localhost:82/">http://localhost:82</a></p>
<pre><code>
- 在虚拟机外部测试（宿主机）：
</code></pre>
<p>  curl -I <a target="_blank" rel="noopener" href="http://192.168.200.131:85/">http://192.168.200.131:85</a></p>
<pre><code>```
</code></pre>
<ul>
<li>观察返回结果，确认 HTTP 状态码是否正常（200&#x2F;302 等）。</li>
</ul>
<hr>
<h3 id="Step-6-遇到问题的典型症状及对应处理"><a href="#Step-6-遇到问题的典型症状及对应处理" class="headerlink" title="Step 6. 遇到问题的典型症状及对应处理"></a>Step 6. 遇到问题的典型症状及对应处理</h3><table>
<thead>
<tr>
<th>症状</th>
<th>可能原因</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>宿主机无法连接端口，连接超时</td>
<td>防火墙阻止、端口未开放</td>
<td>关闭防火墙或放行端口</td>
</tr>
<tr>
<td>curl 返回连接重置或拒绝</td>
<td>服务未启动或监听端口错误</td>
<td>检查 nginx 配置和容器启动</td>
</tr>
<tr>
<td>curl 返回200但页面加载不出</td>
<td>后端服务未就绪或网络不通</td>
<td>检查 Harbor core 服务状态</td>
</tr>
<tr>
<td>日志中报错日志驱动不支持</td>
<td>docker-compose 日志配置错误</td>
<td>统一使用 <code>json-file</code> 驱动</td>
</tr>
<tr>
<td>端口映射配置错误</td>
<td>端口映射写错</td>
<td>纠正 <code>docker-compose.yml</code> 中端口映射</td>
</tr>
</tbody></table>
<hr>
<h3 id="Step-7-重启生效验证"><a href="#Step-7-重启生效验证" class="headerlink" title="Step 7. 重启生效验证"></a>Step 7. 重启生效验证</h3><ul>
<li>重启虚拟机，有时可以修复网络绑定、端口冲突等隐患问题。</li>
<li>重启后再次测试端口连通性和页面访问。</li>
</ul>
<hr>
<h2 id="四、示例核心配置（端口映射部分）"><a href="#四、示例核心配置（端口映射部分）" class="headerlink" title="四、示例核心配置（端口映射部分）"></a>四、示例核心配置（端口映射部分）</h2><pre><code>services:
proxy:
   image: goharbor/nginx-photon:v1.9.2
  container_name: nginx
   ports:
    - 85:82  # 宿主机端口 85 映射到容器内 nginx 监听的 82 端口
       volumes:
           - ./common/config/nginx:/etc/nginx:z
          depends_on:
                 - core
                      - portal
                       - registry
</code></pre>
<hr>
<h2 id="五、常用命令汇总"><a href="#五、常用命令汇总" class="headerlink" title="五、常用命令汇总"></a>五、常用命令汇总</h2><table>
<thead>
<tr>
<th>作用</th>
<th>命令示例</th>
</tr>
</thead>
<tbody><tr>
<td>查看容器状态</td>
<td><code>docker ps</code></td>
</tr>
<tr>
<td>查看容器日志</td>
<td><code>docker logs nginx --tail 50</code></td>
</tr>
<tr>
<td>查看端口监听</td>
<td>&#96;ss -tnlp</td>
</tr>
<tr>
<td>测试端口连通（宿主机）</td>
<td><code>Test-NetConnection -ComputerName 192.168.200.131 -Port 85</code> (PowerShell)</td>
</tr>
<tr>
<td>虚拟机防火墙状态</td>
<td><code>firewall-cmd --state</code></td>
</tr>
<tr>
<td>SELinux 状态</td>
<td><code>getenforce</code></td>
</tr>
<tr>
<td>虚拟机内访问本地端口</td>
<td><code>curl -I http://localhost:82</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="访问故障排查简易步骤清单"><a href="#访问故障排查简易步骤清单" class="headerlink" title="访问故障排查简易步骤清单"></a>访问故障排查简易步骤清单</h1><ol>
<li><strong>确认 Docker 容器和服务状态</strong><ul>
<li><code>docker-compose up -d</code></li>
<li><code>docker ps</code></li>
<li><code>docker logs nginx</code></li>
</ul>
</li>
<li><strong>确认端口监听和映射</strong><ul>
<li>容器内部 <code>ss -tnlp | grep nginx</code></li>
</ul>
</li>
</ol>
<ul>
<li>虚拟机 <code>ss -tnlp | grep :85</code></li>
<li><code>docker-compose.yml</code> 中端口映射是否正确</li>
</ul>
<ol start="3">
<li><strong>检查虚拟机网络和防火墙</strong><ul>
<li><code>firewall-cmd --state</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>getenforce</code></li>
<li>关闭防火墙或放行端口</li>
</ul>
<ol start="4">
<li><strong>宿主机端口转发（NAT 模式）配置正确</strong><ul>
<li>确认 VMware NAT 端口转发设置无误</li>
</ul>
</li>
<li><strong>测试端口连通性</strong><ul>
<li>宿主机 PowerShell 测试端口连通</li>
<li>虚拟机内 curl 测试端口访问</li>
</ul>
</li>
<li><strong>浏览器访问测试</strong><ul>
<li>用正确端口访问 Harbor 页面</li>
<li>观察是否能正常加载</li>
</ul>
</li>
<li><strong>重启虚拟机和服务</strong><ul>
<li>解决网络缓存、绑定等异常</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="在Harbor创建用户和项目"><a href="#在Harbor创建用户和项目" class="headerlink" title="在Harbor创建用户和项目"></a>在Harbor创建用户和项目</h5><ul>
<li>创建项目</li>
</ul>
<p>Harbor的项目分为公开和私有的：<br>公开项目：所有用户都可以访问，通常存放公共的镜像，默认有一个library公开项目。 私有项目：只有授权用户才可以访问，通常存放项目本身的镜像。<br>我们可以为微服务项目创建一个新的项目</p>
<ul>
<li><p>创建用户 创建的用户为：eric   Eric123456</p>
</li>
<li><p>给私有项目分配用户</p>
<p>进入tensquare项目→成员→新建用户→eric为维护人员</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>权限说明</th>
</tr>
</thead>
<tbody><tr>
<td>访客</td>
<td>对于指定项目拥有只读权限</td>
</tr>
<tr>
<td>开发人员</td>
<td>对于指定项目拥有读写权限</td>
</tr>
<tr>
<td>维护人员</td>
<td>对于指定项目拥有读写权限，创建Webhooks</td>
</tr>
<tr>
<td>项目管理员</td>
<td>除了读写权限，同时拥有用户管理&#x2F;镜像扫描等管理权限</td>
</tr>
</tbody></table>
<ul>
<li>以新用户登录Harbor</li>
</ul>
<h5 id="把镜像上传到Harbor"><a href="#把镜像上传到Harbor" class="headerlink" title="把镜像上传到Harbor"></a>把镜像上传到Harbor</h5><ul>
<li><p>给镜像打上标签</p>
<blockquote>
<p>docker tag eureka:v1 192.168.200.131:85&#x2F;tensquare&#x2F;eureka:v1</p>
</blockquote>
</li>
<li><p>推送镜像</p>
<blockquote>
<p>docker push 192.168.200.131:85&#x2F;tensquare&#x2F;eureka:v1</p>
<hr>
<p>The push refers to repository [192.168.66.102:85&#x2F;tensquare&#x2F;eureka] Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS  client</p>
</blockquote>
<p>这时会出现以上报错，是因为 Docker没有把Harbor加入信任列表中</p>
</li>
<li><p>把Harbor地址加入到Docker信任列表<br><code>cd /etc/docker</code></p>
<p><code>vi daemon.json</code></p>
<blockquote>
<p>{<br>“registry-mirrors”: [“<a href="https://zydiol88.mirror.aliyuncs.com&quot;]">https://zydiol88.mirror.aliyuncs.com&quot;]</a>,<br>“insecure-registries”: [“192.168.200.131:85”]<br>}</p>
</blockquote>
</li>
</ul>
<p>​       需要重启Docker<br>​      <code>systemctl restart docker</code></p>
<ul>
<li><p>再次执行推送命令，会显示权限不足</p>
<p><code>docker push 192.168.200.131:85/tensquare/eureka:v1</code></p>
<blockquote>
<p>denied: requested access to the resource is denied</p>
</blockquote>
<p>需要先登录 Harbor，再推送镜像</p>
</li>
<li><p>登录Harbor</p>
<p><code> docker login -u eric -p Eric123456 192.168.200.131:85</code> </p>
</li>
<li><p>再次push</p>
<p><code>docker push 192.168.200.131:85/tensquare/eureka:v1</code></p>
</li>
</ul>
<h5 id="从Harbor下载镜像"><a href="#从Harbor下载镜像" class="headerlink" title="从Harbor下载镜像"></a>从Harbor下载镜像</h5><p>需求：在192.168.200.130服务器完成从Harbor下载镜像</p>
<ul>
<li><p>安装并启动Docker</p>
</li>
<li><p>修改Docker配置</p>
<p><code>vi /etc/docker/daemon.json</code></p>
<pre><code class="yaml">&#123;
 &quot;registry-mirrors&quot;: [&quot;https://zydiol88.mirror.aliyuncs.com&quot;],
 &quot;insecure-registries&quot;: [&quot;192.168.66.102:85&quot;]
&#125;
</code></pre>
<p>重启docker：<code>systemctl restart docker</code></p>
</li>
<li><p>先登录，再从Harbor下载镜像</p>
<p><code> docker login -u eric -p Eric123456 192.168.200.131:85</code><br><code>docker pull 192.168.200.131:85/tensquare/eureka:v1</code></p>
</li>
</ul>
<h4 id="微服务持续集成-1-项目代码上传到Gitlab"><a href="#微服务持续集成-1-项目代码上传到Gitlab" class="headerlink" title="微服务持续集成(1)-项目代码上传到Gitlab"></a>微服务持续集成(1)-项目代码上传到Gitlab</h4><p>在IDEA操作即可，参考之前的步骤。包括后台微服务(tensquare_back)和前端web网站(tensquare_front)代码<br>[<u>lanyun_group · GitLab</u>] (<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group">http://192.168.200.132:82/lanyun_group</a>)</p>
<h4 id="微服务持续集成-2-从Gitlab拉取项目源码后台微服务的持续集成"><a href="#微服务持续集成-2-从Gitlab拉取项目源码后台微服务的持续集成" class="headerlink" title="微服务持续集成(2)-从Gitlab拉取项目源码后台微服务的持续集成"></a>微服务持续集成(2)-从Gitlab拉取项目源码<del>后台微服务的持续集成</del></h4><p>先去Jenkins里面创建一个<code>tensquare_back</code>的流水线 → 流水线定义选择<code>Pipeline script form SCM</code><del>脚本文件放在项目根目录下</del> → SCM选择<code>Git</code>拉取脚本文件 → 在根目录下创建一个Jenkinsfile → 用流水线语法写’拉取代码’的语法 → ↓</p>
<pre><code class="yaml">stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &#39;*/master&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_back.git&#39;]])
   &#125;
</code></pre>
<p>→ 修改语法代码里的 name: ‘*&#x2F;master’ 为可变参数 → 去流水线的配置里 勾选<code>This project is parameterized</code> → 添加参数选择<code>String Parameter</code>  → 名称:branch   默认值:master  描述:请输入一个分支名称 →  修改里面的参数为动态的 →↓</p>
<pre><code class="yaml">   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_back.git&#39;]])
   &#125;
</code></pre>
<p>→ 将后面的<code>credentialsId</code>和<code>url</code>可以定义为脚本参数全局引用 → ↓</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
&#125;
</code></pre>
<p>构建即可成功！！ 可以去Moba的<code>/var/lib/jenkins/workspace/</code>查看是否有<code>tensquare_back</code></p>
<h4 id="微服务持续集成-3-提交到SonarQube代码审查"><a href="#微服务持续集成-3-提交到SonarQube代码审查" class="headerlink" title="微服务持续集成(3)-提交到SonarQube代码审查"></a>微服务持续集成(3)-提交到SonarQube代码审查</h4><ul>
<li><h5 id="创建项目，并设置参数"><a href="#创建项目，并设置参数" class="headerlink" title="创建项目，并设置参数"></a>创建项目，并设置参数</h5></li>
</ul>
<p>创建tensquare_back项目，添加两个参数 → 在流水线上设置里选择<code>choice Parameter</code> → 名称:project_name；选项:tensquare_eureka_server、tensquare_zuul、tensquare_admin_service、tensquare_gathering；描述:请选择一个构建的项目</p>
<ul>
<li><h5 id="每个项目的根目录下添加sonar-project-properties"><a href="#每个项目的根目录下添加sonar-project-properties" class="headerlink" title="每个项目的根目录下添加sonar-project.properties"></a>每个项目的根目录下添加<code>sonar-project.properties</code></h5></li>
</ul>
<pre><code class="yaml">eureka_server   gathering   admin_service   zuul
只需要改里面的projectName和projectKey即可

# must be unique in a given SonarQube instance
sonar.projectKey=tensquare_eureka_server
# this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.
sonar.projectName=tensquare_eureka_server
sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.
# This property is optional if sonar.modules is set.
sonar.sources=.
sonar.exclusions=**/test/**,**/target/**
sonar.java.binaries=.

sonar.java.source=1.8
sonar.java.target=1.8
#sonar.java.libraries=**/target/classes/**

# Encoding of the source code. Default is default system encoding
sonar.sourceEncoding=UTF-8
</code></pre>
<ul>
<li><h5 id="修改jenkinsfile构建脚本"><a href="#修改jenkinsfile构建脚本" class="headerlink" title="修改jenkinsfile构建脚本"></a>修改jenkinsfile构建脚本</h5></li>
</ul>
<p>要在Jenkins的全局Tools管理里面 有SonarQube Scanner安装<br>Jenkins全局的system里面有定义sonarqube的url</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
&#125;
</code></pre>
<h3 id="微服务持续集成-4-使用Dockerfile编译、生成镜像"><a href="#微服务持续集成-4-使用Dockerfile编译、生成镜像" class="headerlink" title="微服务持续集成(4)-使用Dockerfile编译、生成镜像"></a>微服务持续集成(4)-使用Dockerfile编译、生成镜像</h3><h6 id="利用dockerfile-maven-plugin插件构建Docker镜像"><a href="#利用dockerfile-maven-plugin插件构建Docker镜像" class="headerlink" title="利用dockerfile-maven-plugin插件构建Docker镜像"></a>利用dockerfile-maven-plugin插件构建Docker镜像</h6><ul>
<li>在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件</li>
</ul>
<pre><code class="yaml">&lt;plugin&gt;
                &lt;groupId&gt;com.spotify&lt;/groupId&gt;
                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.6&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;repository&gt;$&#123;project.artifactId&#125;&lt;/repository&gt;
                    &lt;buildArgs&gt;
                        &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;
                    &lt;/buildArgs&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
</code></pre>
<ul>
<li>修改Jenkinsfile让他根据参数打包微服务工程</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package&quot;
    &#125;
&#125;
</code></pre>
<ul>
<li>父工程的pom.xml要改一个过时的代码</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.tensquare&lt;/groupId&gt;
    &lt;artifactId&gt;tensquare_parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;tensquare_common&lt;/module&gt;
        &lt;module&gt;tensquare_eureka_server&lt;/module&gt;
        &lt;module&gt;tensquare_zuul&lt;/module&gt;
        &lt;module&gt;tensquare_admin_service&lt;/module&gt;
        &lt;module&gt;tensquare_gathering&lt;/module&gt;
    &lt;/modules&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;!-- ✅ 推荐使用正式版本 Finchley.SR4 --&gt;
        &lt;spring-cloud.version&gt;Finchley.SR4&lt;/spring-cloud.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;!-- 可选：保留 spring-milestones --&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>通过MoBa把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\tensquare_parent</code>的<code>tensquare_parent</code>项目保存到<code>/root/repo/com/tensquare/</code>里</li>
<li>随后通过步骤二，构建所有的工程 → <strong>打包所有微服务的工程</strong> → 在Jenkins虚拟机的<code>/var/lib/jenkins/workspace/tensquare_back/</code>这里面的各个项目的<code>target</code>里面打包了刚刚微服务的所有构建东西</li>
</ul>
<h4 id="微服务持续集成-4-使用Dockerfile编译、生成镜像-1"><a href="#微服务持续集成-4-使用Dockerfile编译、生成镜像-1" class="headerlink" title="微服务持续集成(4)-使用Dockerfile编译、生成镜像"></a>微服务持续集成(4)-使用Dockerfile编译、生成镜像</h4><p>利用dockerfile-maven-plugin插件构建Docker镜像</p>
<ul>
<li>在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件</li>
</ul>
<pre><code class="xml"> &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;com.spotify&lt;/groupId&gt;
                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.6&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;repository&gt;$&#123;project.artifactId&#125;&lt;/repository&gt;
                    &lt;buildArgs&gt;
                        &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;
                    &lt;/buildArgs&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<ul>
<li>在dockerfile父目录文件中增加一个<code>...dockerfile:build</code>去触发每个微服务项目的dockerfile执行【用流水线进行镜像构建】</li>
</ul>
<pre><code class="xml">    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
    &#125;
</code></pre>
<p>全部构建完成后就大功告成！！！</p>
<pre><code class="yaml">[root@localhost docker]# docker images
REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE
tensquare_gathering                   latest              a62362e8dc2f        8 minutes ago       155MB
tensquare_admin_service               latest              ee2a85292e98        9 minutes ago       156MB
tensquare_eureka_server               latest              2a78c4a12fc4        11 minutes ago      148MB
tensquare_zuul                        latest              33bf136ee3cb        12 minutes ago      146MB
eureka                                v2                  2c9a3610123d        24 hours ago        150MB
192.168.200.131:85/tensquare/eureka   v1                  e85b5d3d9090        25 hours ago        150MB
eureka                                v1                  e85b5d3d9090        25 hours ago        150MB
nginx                                 latest              9592f5595f2b        8 days ago          192MB
hello-world                           latest              74cc54e27dc4        5 months ago        10.1kB
openjdk                               8-jdk-alpine        a3562aa0b991        6 years ago         105MB
</code></pre>
<hr>
<h4 id="微服务持续集成-5-上传到Harbor镜像仓库"><a href="#微服务持续集成-5-上传到Harbor镜像仓库" class="headerlink" title="微服务持续集成(5)-上传到Harbor镜像仓库"></a>微服务持续集成(5)-上传到Harbor镜像仓库</h4><ul>
<li>修改<code>Jenkinsfile.groovy</code>构建脚本</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;
    &#125;
&#125;
</code></pre>
<p>此时再去构建一个项目在Jenkins虚拟机服务的镜像里就会出现按照规则打好tag的镜像</p>
<blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY                                             TAG                 IMAGE ID            CREATED              SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              e19b4ba07d54        About a minute ago   148MB</p>
</blockquote>
<ul>
<li><h5 id="把镜像推送到Harbor-要登录-输入账号密码-不要写在脚本文件-把harbor账号密码用jenkins全局凭证"><a href="#把镜像推送到Harbor-要登录-输入账号密码-不要写在脚本文件-把harbor账号密码用jenkins全局凭证" class="headerlink" title="把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)"></a>把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)</h5></li>
</ul>
<p>去Jenkins申请一个全局的凭证，ID：<code>f83725d3-d5fc-4faf-8ac1-1a56487dfc7b</code><br>怎么在jenkinsfile里面使用呢？要用流水线语法的片段生成器 <code>withCredentials：Bind credentials to variables</code>[<u>借助凭证进行脚本处理</u>] (如果没有显示绑定 就刷新一下界面)；选择<code>绑定</code>→<u><code>用户名变量：username</code> <code>密码变量：password</code></u> 这个是引用的刚刚创立的<code>eric_harbor-auth</code>凭证</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<p>此时harbor的tensquare中镜像仓库就有了<code>tensquare/tensquare_eureka_server</code></p>
<h4 id="微服务持续集成-6-拉取镜像和发布应用"><a href="#微服务持续集成-6-拉取镜像和发布应用" class="headerlink" title="微服务持续集成(6)-拉取镜像和发布应用"></a>微服务持续集成(6)-拉取镜像和发布应用</h4><h6 id="安装-Publish-Over-SSH-插件目的是想把129Jenkins和130product进行连通"><a href="#安装-Publish-Over-SSH-插件目的是想把129Jenkins和130product进行连通" class="headerlink" title="安装  Publish Over SSH 插件目的是想把129Jenkins和130product进行连通"></a>安装  <code>Publish Over SSH 插件</code><del>目的是想把129Jenkins和130product进行连通</del></h6><p>安装此插件可以实现远程发送Shell命令</p>
<p>随后去全局system寻找<code>Publish over SSH</code></p>
<p>在product虚拟机：<code>id_rsa是私钥</code>，<code>id_rsa.pub是公钥</code></p>
<pre><code class="yaml">[root@localhost ~]# cd /root/.ssh
[root@localhost .ssh]# ll
总用量 12
-rw-------. 1 root root 1679 6月  18 20:05 id_rsa
-rw-r--r--. 1 root root  408 6月  18 20:05 id_rsa.pub
-rw-r--r--. 1 root root  177 6月  18 21:00 known_hosts
[root@localhost .ssh]#
</code></pre>
<p>输入<code>[root@localhost .ssh]# ssh-keygen -y -f /root/.ssh/id_rsa</code>会显示私钥<br>如果直接输出 <code>ssh-rsa AAAA...</code> 这样的公钥内容 → 说明<strong>没有加密</strong>，Jenkins 中可以把 <code>Passphrase</code> 留空<br>下面添加一台远程服务器<code>SSH Servers</code></p>
<blockquote>
<p>Name：master_server<br>Hostname：192.168.200.130<br>Username：root<br>Remote Directory：&#x2F;</p>
</blockquote>
<h6 id="配置远程部署服务器"><a href="#配置远程部署服务器" class="headerlink" title="配置远程部署服务器"></a>配置远程部署服务器</h6><ul>
<li>拷贝公钥到远程服务器</li>
</ul>
<blockquote>
<p>是的，你遇到的错误：</p>
<pre><code>Failed to connect session for config [master_server]. Message [Auth fail for methods &#39;publickey,gssapi-keyex,gssapi-with-mic,password&#39;]
</code></pre>
<p><strong>说明 Jenkins 使用你提供的私钥连接远程服务器失败</strong>。这个问题一般由以下几种原因导致：</p>
<hr>
<h2 id="✅【推荐方案】重新生成兼容格式的私钥（PEM）"><a href="#✅【推荐方案】重新生成兼容格式的私钥（PEM）" class="headerlink" title="✅【推荐方案】重新生成兼容格式的私钥（PEM）"></a>✅【推荐方案】重新生成兼容格式的私钥（PEM）</h2><p>你看到的建议：</p>
<blockquote>
<pre><code>ssh-keygen -m PEM -t rsa -b 4096
</code></pre>
</blockquote>
<p>是完全正确的，因为：</p>
<ul>
<li>Jenkins 使用的 <strong>Java SSH 实现</strong>（JSch 或 Trilead）<strong>不支持 OpenSSH 的新私钥格式（RFC4716）</strong>；</li>
<li><code>-m PEM</code> 表示使用旧版兼容格式（Jenkins 能识别）；</li>
<li><code>-t rsa -b 4096</code> 表示生成 RSA 4096 位密钥。</li>
</ul>
<hr>
<h3 id="✅-重新生成-SSH-密钥步骤如下"><a href="#✅-重新生成-SSH-密钥步骤如下" class="headerlink" title="✅ 重新生成 SSH 密钥步骤如下"></a>✅ 重新生成 SSH 密钥步骤如下</h3><ol>
<li>在 Jenkins 所在机器上执行（推荐使用 <code>jenkins</code> 用户身份，不要用 root）：</li>
</ol>
<pre><code>ssh-keygen -m PEM -t rsa -b 4096 -C &quot;jenkins@tensquare&quot; -f ~/.ssh/id_rsa_jenkins
</code></pre>
<p>过程中会问你是否设置密码（passphrase），你可以 <strong>直接回车留空</strong>。</p>
<p>生成后会有两个文件：</p>
<pre><code>~/.ssh/id_rsa_jenkins       ← 私钥（复制给 Jenkins）
~/.ssh/id_rsa_jenkins.pub   ← 公钥（配置到目标服务器）
</code></pre>
<hr>
<ol>
<li><strong>把公钥内容添加到远程主机的 authorized_keys 中</strong></li>
</ol>
<pre><code>cat ~/.ssh/id_rsa_jenkins.pub | ssh root@192.168.200.130 &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;
</code></pre>
<p>或者你手动将 <code>id_rsa_jenkins.pub</code> 内容添加到 <code>/root/.ssh/authorized_keys</code> 中。</p>
<hr>
<ol>
<li><strong>Jenkins 中配置 SSH 连接</strong></li>
</ol>
<p>在 Jenkins → <code>Manage Jenkins</code> → <code>Configure System</code> → <code>Publish over SSH</code>：</p>
<ul>
<li><strong>Path to Key</strong>：填入 <code>/root/.ssh/id_rsa_jenkins</code>（或你放的实际路径）</li>
<li><strong>Key</strong>：可留空（有 Path 即可）</li>
<li><strong>Passphrase</strong>：如果你上面生成时留空，这里也留空</li>
<li><strong>Name</strong>：master_server</li>
<li><strong>Hostname</strong>：192.168.200.130</li>
<li><strong>Username</strong>：root（或其他你授权了公钥的用户）</li>
<li><strong>Remote Directory</strong>：比如 <code>/home/jenkins-deploy</code> 或 <code>/root/</code>或<code>/</code></li>
</ul>
<p>✔ 点击 <code>Test Configuration</code> 测试成功为止</p>
</blockquote>
<ul>
<li><p>查看流水线语法</p>
<p>因为新下载那个插件后需要重启Jenkins。然后<br>步骤<code>sshPublisher:Send build artifacts overSSH</code> 直接生成流水线脚本后融入Jenkinsfile文件中</p>
<blockquote>
<p>SSH Server<br>Name：master_server</p>
</blockquote>
</li>
</ul>
<p>里面的<code>$port</code>需要搞成可变参数 去Jenkins里面添加一个参数</p>
<blockquote>
<p>名称：port<br>默认值：10086<br>描述：请输入一个对应服务的端口</p>
</blockquote>
<p>在生产虚拟机先<code>[root@localhost ~]# mkdir /opt/jenkins_shell</code>然后把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\部署脚本</code>的<code>deploy.sh</code>传入 之后添加执行权限<code>[root@localhost jenkins_shell]# chmod +x deploy.sh</code></p>
<h5 id="成功！！！"><a href="#成功！！！" class="headerlink" title="成功！！！"></a>成功！！！</h5><blockquote>
<p>[root@localhost jenkins_shell]# docker images<br>REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka   v1                  e85b5d3d9090        44 hours ago        150MB<br>[root@localhost jenkins_shell]# docker ps<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</p>
<hr>
<p>[root@localhost jenkins_shell]# docker images</p>
<p>REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              60d020191110        35 seconds ago      148MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka                    v1                  e85b5d3d9090        44 hours ago        150MB<br>[root@localhost jenkins_shell]# docker ps<br>CONTAINER ID        IMAGE                                                         COMMAND                CREATED             STATUS              PORTS                      NAMES<br>b934523c60da        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server:latest   “java -jar &#x2F;app.jar”   33 seconds ago      Up 30 seconds       0.0.0.0:10086-&gt;10086&#x2F;tcp   focused_boyd</p>
</blockquote>
<p>成功访问：[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>)</p>
<p>如果要下载其他镜像 需要把每个服务的<code>application.yml</code>更改连接地址</p>
<blockquote>
<p>更改所有服务的application.yml地址<br>sonarqube的是129里面有mysql<br>eureka的是130用的生产虚拟服务器</p>
</blockquote>
<blockquote>
<p>那我微服务里的application.yml server:   port: 9001 spring:   application:      name: tensquare-admin-service #指定服务名  datasource:      driverClassName: com.mysql.jdbc.Driver    url: jdbc:mysql:&#x2F;&#x2F;192.168.200.129&#x2F;tensquare_user?characterEncoding&#x3D;UTF8    username: root    password: root  jpa:     database: mysql    show-sql: true 这样写可以吗</p>
<p><code>那个192.168.200.129:3306/</code>回答：</p>
<ul>
<li><strong>如果你的微服务运行环境和 MySQL 在同一局域网内，且 192.168.200.129 是 MySQL 服务所在虚拟机的有效IP，且网络是通的，端口 3306 没被防火墙拦截，NAT或者桥接配置无误，使用这个 IP 和端口是完全没问题的。</strong></li>
<li>也就是说，如果你从微服务所在的机器能 ping 通 <code>192.168.200.129</code> 并且 <code>telnet 192.168.200.129 3306</code> 可以连通，就可以这么写。</li>
</ul>
<hr>
<h3 id="你需要确认的："><a href="#你需要确认的：" class="headerlink" title="你需要确认的："></a>你需要确认的：</h3><ol>
<li><strong>你的微服务运行在哪台机器？</strong><ul>
<li>如果微服务也在虚拟机里（同一台虚拟机或同一内网），用虚拟机的IP写就对。</li>
<li>如果微服务在宿主机，且虚拟机用的是 NAT 模式，你必须确认端口映射存在，否则宿主机连这个 IP 3306 不通（原因是 NAT 隔离）。这时用虚拟机私有 IP 直接连接是不行的。</li>
</ul>
</li>
<li><strong>网络连通性</strong><ul>
<li>微服务所在机器能 <code>ping</code> 通该 IP。</li>
<li>能 <code>telnet IP 3306</code> 连通。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>只要网络通，端口放通，<code>jdbc:mysql://192.168.200.129:3306/数据库名</code> 写法就是标准且正确的。</strong></li>
<li>如果网络不通，就要调整网络配置（比如桥接、端口映射），或者改用 <code>localhost</code>、<code>127.0.0.1</code> 访问本机MySQL。</li>
</ul>
</blockquote>
<h6 id="分别构建其余的几个微服务项目-记住port端口是要跟application-yml里面一致的"><a href="#分别构建其余的几个微服务项目-记住port端口是要跟application-yml里面一致的" class="headerlink" title="分别构建其余的几个微服务项目 记住port端口是要跟application.yml里面一致的"></a>分别构建其余的几个微服务项目 记住port端口是要跟application.yml里面一致的</h6><blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_gathering       latest              c700a6359fce        33 seconds ago      155MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service   latest              92453ab6e765        2 minutes ago       156MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_zuul            latest              122afd78d6ef        3 minutes ago       146MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              60d020191110        4 hours ago         148MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka                    v1                  e85b5d3d9090        2 days ago          150MB</p>
<hr>
<p>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE                                                         COMMAND                  CREATED              STATUS              PORTS                      NAMES<br>aa2178c7dd0d        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_gathering:latest       “java -Djava.net.pre…”   About a minute ago   Up 59 seconds       0.0.0.0:9002-&gt;9002&#x2F;tcp     nostalgic_lichterman<br>14e040066165        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service:latest   “java -Djava.net.pre…”   2 minutes ago        Up 2 minutes        0.0.0.0:9001-&gt;9001&#x2F;tcp     dreamy_montalcini<br>8143d8ccbeee        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_zuul:latest            “java -Djava.net.pre…”   3 minutes ago        Up 3 minutes        0.0.0.0:10020-&gt;10020&#x2F;tcp   gracious_kalam<br>b934523c60da        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server:latest   “java -jar &#x2F;app.jar”     4 hours ago          Up 4 hours          0.0.0.0:10086-&gt;10086&#x2F;tcp   focused_boyd</p>
<p>你这个情况是镜像有了，但是没有运行的容器，所以要启动镜像，创建并运行容器。</p>
<h3 id="启动镜像★★的基本命令是：-Jenkins-129服务器"><a href="#启动镜像★★的基本命令是：-Jenkins-129服务器" class="headerlink" title="启动镜像★★的基本命令是：[Jenkins 129服务器]"></a>启动镜像★★的基本命令是：[Jenkins 129服务器]</h3><pre><code>docker run -d -p &lt;宿主机端口&gt;:&lt;容器端口&gt; --name &lt;容器名字&gt; &lt;镜像名&gt;
</code></pre>
<p>直接启动无需重新创建容器：<br>先查看所有容器(包括已停止的)：<code>docker ps -a</code></p>
<blockquote>
<p>docker start tensquare_admin_service<br>docker start tensquare_gathering<br>docker start tensquare_zuul<br>docker start tensquare_eureka_server</p>
</blockquote>
<p>若需要删除再重新启动</p>
<p>举个例子：</p>
<blockquote>
<p>先删除之前的容器：<br>docker rm tensquare_admin_service<br>docker rm tensquare_gathering<br>docker rm tensquare_zuul<br>docker rm tensquare_eureka_server</p>
</blockquote>
<pre><code>docker run -d -p 9001:9101 --name tensquare_admin_service 192.168.200.131:85/tensquare/tensquare_admin_service:latest
docker run -d -p 9002:9002 --name tensquare_gathering 192.168.200.131:85/tensquare/tensquare_gathering:latest
docker run -d -p 10020:10020 --name tensquare_zuul 192.168.200.131:85/tensquare/tensquare_zuul:latest
docker run -d -p 10086:10086 --name tensquare_eureka_server 192.168.200.131:85/tensquare/tensquare_eureka_server:latest
</code></pre>
<blockquote>
<p>[root@localhost ~]# docker rm -f tensquare_admin_service<br>tensquare_admin_service<br>[root@localhost ~]# docker run -d -p 9101:9001 –name tensquare_admin_service 192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service:latest<br>634a31582dc81acf34b101d468d84b1c3f92b75477b6ad469abe00dc09821d4b<br>[root@localhost ~]#</p>
</blockquote>
<blockquote>
<p>端口映射要根据你的程序监听端口设定，否则外部访问不到容器服务。</p>
</blockquote>
<h3 id="此时也要在生产130服务器上去重新启动那些容器"><a href="#此时也要在生产130服务器上去重新启动那些容器" class="headerlink" title="此时也要在生产130服务器上去重新启动那些容器"></a>此时也要在生产130服务器上去重新启动那些容器</h3><blockquote>
<h3 id="✅-1-重启-130-上的容器"><a href="#✅-1-重启-130-上的容器" class="headerlink" title="✅ 1. 重启 130 上的容器"></a>✅ <strong>1. 重启 130 上的容器</strong></h3><p>可以用 <code>docker start 容器ID或容器名</code> 重启：</p>
<pre><code>bash复制编辑docker start e55957d0a79e  # gathering
docker start 3c8592621ab7  # admin_service
docker start 43a7ca513e37  # zuul
docker start 831aeb331519  # eureka
</code></pre>
<p>或者统一启动：</p>
<pre><code>bash


复制编辑
docker start $(docker ps -a -q)
</code></pre>
</blockquote>
<hr>
<hr>
<hr>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>停止容器：</p>
<pre><code>docker stop 容器ID或容器名
</code></pre>
<p>删除容器：</p>
<pre><code>docker rm 容器ID或容器名
</code></pre>
<h3 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3. 删除镜像"></a>3. 删除镜像</h3><p>删除有标签的镜像：</p>
<pre><code>docker rmi 192.168.200.131:85/tensquare/tensquare_gathering
docker rmi tensquare_gathering
</code></pre>
<p>删除无标签的悬空镜像：</p>
<pre><code>docker rmi 08b0a9196df2
</code></pre>
<h3 id="4-如果有多个无标签镜像，删除所有悬空镜像"><a href="#4-如果有多个无标签镜像，删除所有悬空镜像" class="headerlink" title="4. 如果有多个无标签镜像，删除所有悬空镜像"></a>4. 如果有多个无标签镜像，删除所有悬空镜像</h3><pre><code>docker image prune
</code></pre>
</blockquote>
<p>[生产]：[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>)</p>
<blockquote>
<h5 id="Instances-currently-registered-with-Eureka"><a href="#Instances-currently-registered-with-Eureka" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h5><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>TENSQUARE-ADMIN-SERVICE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.4:9001/actuator/info">14e040066165:tensquare-admin-service:9001</a></td>
</tr>
<tr>
<td align="left"><strong>TENSQUARE-GATHERING</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.5:9002/actuator/info">aa2178c7dd0d:tensquare-gathering:9002</a></td>
</tr>
<tr>
<td align="left"><strong>TENSQUARE-ZUUL</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.3:10020/actuator/info">8143d8ccbeee:tensquare-zuul:10020</a></td>
</tr>
</tbody></table>
</blockquote>
<h6 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h6><pre><code class="java">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
        // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
        // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
        sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
    &#125;
&#125;
</code></pre>
<h6 id="deploy-sh"><a href="#deploy-sh" class="headerlink" title="deploy.sh"></a>deploy.sh</h6><pre><code class="java">#! /bin/sh
#接收外部参数
harbor_url=$1
harbor_project_name=$2
project_name=$3
tag=$4
port=$5

imageName=$harbor_url/$harbor_project_name/$project_name:$tag

echo &quot;$imageName&quot;

#查询容器是否存在，存在则删除
containerId=`docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125;  | awk &#39;&#123;print $1&#125;&#39;`
if [ &quot;$containerId&quot; !=  &quot;&quot; ] ; then
    #停掉容器
    docker stop $containerId

    #删除容器
    docker rm $containerId
    
    echo &quot;成功删除容器&quot;
fi

#查询镜像是否存在，存在则删除
imageId=`docker images | grep -w $project_name  | awk &#39;&#123;print $3&#125;&#39;`

if [ &quot;$imageId&quot; !=  &quot;&quot; ] ; then
      
    #删除镜像
    docker rmi -f $imageId
    
    echo &quot;成功删除镜像&quot;
fi

# 登录Harbor
docker login -u eric -p Eric123456 $harbor_url

# 下载镜像
docker pull $imageName

# 启动容器
docker run -di -p $port:$port $imageName

echo &quot;容器启动成功&quot;
</code></pre>
<h5 id="连接数据库的时候有问题"><a href="#连接数据库的时候有问题" class="headerlink" title="连接数据库的时候有问题"></a>连接数据库的时候有问题</h5><blockquote>
<p>[root@localhost ~]# &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld –initialize –user&#x3D;mysql –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql 2025-07-04T10:46:28.109697Z 0 [Warning] [MY-011070] [Server] ‘Disabling symbolic links using –skip-symbolic-links (or equivalent) is the default. Consider not using this option as it’ is deprecated and will be removed in a future release. 2025-07-04T10:46:28.110588Z 0 [System] [MY-013169] [Server] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld (mysqld 8.0.30) initializing of server in progress as process 31821 2025-07-04T10:46:28.115123Z 0 [ERROR] [MY-010457] [Server] –initialize specified but the data directory has files in it. Aborting. 2025-07-04T10:46:28.115149Z 0 [ERROR] [MY-013236] [Server] The designated data directory &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; is unusable. You can remove all files that the server added to it. 2025-07-04T10:46:28.115231Z 0 [ERROR] [MY-010119] [Server] Aborting 2025-07-04T10:46:28.115717Z 0 [System] [MY-010910] [Server] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld: Shutdown complete (mysqld 8.0.30)  MySQL Community Server - GPL. [root@localhost ~]#</p>
<h6 id="ChatGPT-说：-3"><a href="#ChatGPT-说：-3" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>报错很明确：</p>
<pre><code>--initialize specified but the data directory has files in it. Aborting.
</code></pre>
<p>意思是：你指定的 <code>/var/lib/mysql</code> 目录 <strong>里面已经有文件了</strong>，所以初始化被拒绝了。</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-备份或清空-var-lib-mysql-目录"><a href="#1-备份或清空-var-lib-mysql-目录" class="headerlink" title="1. 备份或清空 /var/lib/mysql 目录"></a>1. 备份或清空 <code>/var/lib/mysql</code> 目录</h3><p>如果你确认目录里面的数据可以删除（或者你已经备份了重要数据），执行：</p>
<pre><code>rm -rf /var/lib/mysql/*
</code></pre>
<p>确保目录下文件都删干净。</p>
<hr>
<h3 id="2-再次执行初始化"><a href="#2-再次执行初始化" class="headerlink" title="2. 再次执行初始化"></a>2. 再次执行初始化</h3><pre><code>/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/var/lib/mysql
</code></pre>
<p>这次应该会成功。</p>
<hr>
<h3 id="3-启动-MySQL-服务"><a href="#3-启动-MySQL-服务" class="headerlink" title="3. 启动 MySQL 服务"></a>3. 启动 MySQL 服务</h3><pre><code>systemctl start mysql
</code></pre>
<hr>
<h3 id="4-查看状态和日志，确保启动成功"><a href="#4-查看状态和日志，确保启动成功" class="headerlink" title="4. 查看状态和日志，确保启动成功"></a>4. 查看状态和日志，确保启动成功</h3><pre><code>systemctl status mysql
tail -n 50 /var/log/mariadb/mariadb.log
</code></pre>
<hr>
<p>如果你担心误删数据，可以先备份目录：</p>
<pre><code>mv /var/lib/mysql /var/lib/mysql_backup_$(date +%F_%T)
mkdir /var/lib/mysql
chown mysql:mysql /var/lib/mysql
</code></pre>
<p>然后再初始化。</p>
<p>这样启动<code>mysql -uroot -p --socket=/var/lib/mysql/mysql.sock</code></p>
<hr>
<hr>
<hr>
<p><strong>宿主机（Windows）通过 NAT 模式连接虚拟机的正确姿势不是直接用虚拟机IP，而是用映射到宿主机的端口。</strong></p>
<hr>
<h4 id="你当前用的："><a href="#你当前用的：" class="headerlink" title="你当前用的："></a>你当前用的：</h4><pre><code>mysql -uroot -proot -h192.168.200.129 -P3306
</code></pre>
<p>这是虚拟机的私有IP，NAT模式下外部访问是被隔离的，直接连这个IP不通。</p>
<hr>
<h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><ol>
<li>在 VMware 的 NAT 设置里添加端口转发规则，把宿主机的某个端口（比如3306）转发到虚拟机的3306端口。</li>
<li>宿主机连接时，用 <code>127.0.0.1</code>（或者 <code>localhost</code>）加端口访问。</li>
</ol>
<p>例如：</p>
<pre><code>mysql -uroot -proot -h127.0.0.1 -P3306
</code></pre>
<hr>
<h3 id="如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。"><a href="#如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。" class="headerlink" title="如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。"></a>如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。</h3><hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>你的 MySQL 配置没问题了</li>
<li>NAT模式下宿主机访问虚拟机MySQL必须用端口转发+127.0.0.1</li>
<li>或切换桥接，直接用虚拟机IP访问</li>
</ul>
<hr>
<h2 id="✅-查看容器日志命令："><a href="#✅-查看容器日志命令：" class="headerlink" title="✅ 查看容器日志命令："></a>✅ 查看容器日志命令：</h2></blockquote>
<blockquote>
<pre><code>docker logs -f dreamy_montalcini
</code></pre>
<ul>
<li><code>-f</code> 表示 <strong>实时追踪日志</strong>，相当于 <code>tail -f</code> 的效果</li>
<li>如果你只想看最近的日志行数，比如 100 行：</li>
</ul>
<pre><code>docker logs --tail 100 dreamy_montalcini
</code></pre>
<hr>
<h3 id="✅-还可以用容器-ID："><a href="#✅-还可以用容器-ID：" class="headerlink" title="✅ 还可以用容器 ID："></a>✅ 还可以用容器 ID：</h3><pre><code>docker logs -f 14e040066165
</code></pre>
</blockquote>
<h4 id="如果mysql忘记密码了怎么办"><a href="#如果mysql忘记密码了怎么办" class="headerlink" title="如果mysql忘记密码了怎么办"></a>如果mysql忘记密码了怎么办</h4><blockquote>
<h3 id="✅-第一步：找出-mysqld-safe-路径"><a href="#✅-第一步：找出-mysqld-safe-路径" class="headerlink" title="✅ 第一步：找出 mysqld_safe 路径"></a>✅ 第一步：找出 <code>mysqld_safe</code> 路径</h3><p>所以系统找不到 <code>mysqld_safe</code> 命令。请执行下面命令找出它在哪：</p>
<pre><code>sudo find / -name mysqld_safe
</code></pre>
<p>它一般可能在 <code>/usr/bin/mysqld_safe</code> 或 <code>/usr/local/mysql/bin/mysqld_safe</code></p>
<p>找到后，比如它在 <code>/usr/local/mysql/bin/mysqld_safe</code>，那你这样启动 MySQL 跳过权限：</p>
<pre><code>sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables --skip-networking &amp;
</code></pre>
<p>然后 <strong>等待几秒钟（5-10s）</strong> 再执行：</p>
<pre><code>mysql -uroot
</code></pre>
</blockquote>
<blockquote>
<p>[root@localhost ~]# sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid &amp;<br>[1] 56721<br>[root@localhost ~]# 2025-07-04T13:53:36.378946Z mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>2025-07-04T13:53:36.468224Z mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>[root@localhost ~]# sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid &amp;<br>[2] 56935<br>[root@localhost ~]# 2025-07-04T13:53:48.624877Z mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>2025-07-04T13:53:48.718002Z mysqld_safe A mysqld process already exists</p>
<p>[2]+  退出 1                sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>[root@localhost ~]# ps aux | grep mysqld<br>root      56721  0.0  0.0 241292   632 pts&#x2F;1    S    21:53   0:00 sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>root      56723  0.1  0.0 113412   452 pts&#x2F;1    S    21:53   0:00 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>mysql     56861 22.2 18.1 1774388 339036 pts&#x2F;1  Sl   21:53   0:03 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld –basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql –plugin-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;plugin –user&#x3D;mysql –log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid –socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock<br>root      57071  0.0  0.0 112828   988 pts&#x2F;1    S+   21:53   0:00 grep –color&#x3D;auto mysqld<br>[root@localhost ~]#</p>
</blockquote>
<h4 id="数据库修改策略权限以及让远程宿主机连接"><a href="#数据库修改策略权限以及让远程宿主机连接" class="headerlink" title="数据库修改策略权限以及让远程宿主机连接"></a>数据库修改策略权限以及让远程宿主机连接</h4><blockquote>
<p>mysql -uroot -p</p>
<p>SET GLOBAL validate_password_policy &#x3D; LOW;<br>SET GLOBAL validate_password_length &#x3D; 4;</p>
<p>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)</p>
<p>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; select user, host from mysql.user where user&#x3D;’root’;<br>+——+————+<br>| user | host       |<br>+——+————+<br>| root | %          |<br>| root | 172.17.0.5 |<br>| root | localhost  |<br>+——+————+<br>3 rows in set (0.00 sec)</p>
</blockquote>
<blockquote>
<p>你给的 Spring Boot 配置文件（application.yml）大致结构是对的，不过结合你之前报错信息（MySQL 连接时出现 <span style = "color:red"><code>CommunicationsException</code>，SSL握手失败）和你的配置，有几点需要确认和调整：</span></p>
<hr>
<h3 id="1-MySQL-连接-URL-推荐加上参数，关闭-SSL"><a href="#1-MySQL-连接-URL-推荐加上参数，关闭-SSL" class="headerlink" title="1. MySQL 连接 URL 推荐加上参数，关闭 SSL"></a>1. MySQL 连接 URL 推荐加上参数，关闭 SSL</h3><p>默认情况下 MySQL Connector 可能会尝试用 SSL 连接，而你的报错就是 SSL 握手失败：</p>
<pre><code>Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
</code></pre>
<p>解决办法是在 URL 中明确关闭 SSL，改成：</p>
<pre><code>spring:
  datasource:
    url: jdbc:mysql://192.168.200.129:3306/tensquare_user?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
</code></pre>
<ul>
<li><code>useSSL=false</code> 关闭 SSL 连接</li>
<li><code>serverTimezone=Asia/Shanghai</code> 解决时区警告（可选）</li>
<li><code>characterEncoding=UTF-8</code> 保持编码一致（注意大小写）</li>
</ul>
</blockquote>
<h4 id="微服务持续集成-7-部署前端静态web网站"><a href="#微服务持续集成-7-部署前端静态web网站" class="headerlink" title="微服务持续集成(7)-部署前端静态web网站"></a>微服务持续集成(7)-部署前端静态web网站</h4><p>129机器进行npm命令打包 → 远程传输文件 →(SSH远程调用)→ 130生产服务器Nginx</p>
<blockquote>
<h4 id="为什么用-Nginx-而不是直接用-Docker？"><a href="#为什么用-Nginx-而不是直接用-Docker？" class="headerlink" title="为什么用 Nginx 而不是直接用 Docker？"></a>为什么用 Nginx 而不是直接用 Docker？</h4><h5 id="①-Nginx-是专业的高性能静态文件服务器"><a href="#①-Nginx-是专业的高性能静态文件服务器" class="headerlink" title="① Nginx 是专业的高性能静态文件服务器"></a>① <strong>Nginx 是专业的高性能静态文件服务器</strong></h5><ul>
<li>速度快、资源占用低，响应迅速</li>
<li>支持缓存、压缩、访问控制、日志、反向代理等丰富功能</li>
<li>易于配置访问路径、rewrite规则等</li>
</ul>
<h5 id="②-Docker-是“容器化”技术，适合运行应用程序"><a href="#②-Docker-是“容器化”技术，适合运行应用程序" class="headerlink" title="② Docker 是“容器化”技术，适合运行应用程序"></a>② <strong>Docker 是“容器化”技术，适合运行应用程序</strong></h5><ul>
<li>Docker 让你把应用和运行环境打包，适合部署动态应用（比如后端服务）</li>
<li>纯静态文件没运行时依赖，没必要额外用容器包裹</li>
<li>如果直接用 Docker 部署静态网站，往往是把 Nginx 或 Apache 装在容器里，再由容器提供静态服务 — 这就和单纯用 Nginx 差不多，只是多了容器层</li>
</ul>
</blockquote>
<h5 id="安装Nginx服务器"><a href="#安装Nginx服务器" class="headerlink" title="安装Nginx服务器"></a>安装Nginx服务器</h5><blockquote>
<p>yum install epel-release<br>yum -y install nginx 安装</p>
</blockquote>
<p>修改nginx的端口，默认80，改为9090：</p>
<blockquote>
<p>vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
</blockquote>
<pre><code class="yaml"> server &#123;
        listen    9099 default_server;   
        listen    [::]:9099 default_server;     
        server_name  _;
        root       /usr/share/nginx/html;  
</code></pre>
<p>还需要关闭 selinux，将SELINUX&#x3D;disabled</p>
<blockquote>
<p>setenforce 0                            先临时关闭<br><strong>vi &#x2F;etc&#x2F;selinux&#x2F;config</strong>             编辑文件，永久关闭 SELINUX&#x3D;disabled</p>
</blockquote>
<p>启动Nginx ★★</p>
<blockquote>
<p>systemctl enable nginx 设置开机启动<br>systemctl start nginx 启动<br>systemctl stop nginx 停止<br>systemctl restart nginx 重启<br>systemctl status nginx.service 查看运行状态</p>
</blockquote>
<p>[Welcome to CentOS] (<a target="_blank" rel="noopener" href="http://192.168.200.130:9099/">http://192.168.200.130:9099/</a>)</p>
<h4 id="在Jenkins的服务器里-安装NodeJS插件"><a href="#在Jenkins的服务器里-安装NodeJS插件" class="headerlink" title="在Jenkins的服务器里 安装NodeJS插件"></a>在Jenkins的服务器里 安装NodeJS插件</h4><p>前端在本机的位置：<code>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin</code></p>
<p>Jenkins配置Nginx服务器<br><code>Dashboard → Manage Jenkins → Tools → NodeJS新增</code></p>
<blockquote>
<p>别名：nodejs12<br>版本：NodeJS 12.3.1</p>
</blockquote>
<h6 id="创建前端流水线项目-tensquare-front"><a href="#创建前端流水线项目-tensquare-front" class="headerlink" title="创建前端流水线项目 tensquare_front"></a>创建前端流水线项目 <code>tensquare_front</code></h6><p>添加一个参数<code>This project is parameterized</code> → 名称branch 默认值master<br>在Jenkins里找一个凭证<code>点击右侧zhangsan → 更新 → 就会显示有ID </code> 复制后变成git_auth</p>
<h6 id="流水线Pipeline-script"><a href="#流水线Pipeline-script" class="headerlink" title="流水线Pipeline script"></a>流水线<code>Pipeline script</code></h6><pre><code class="yaml">//gitlab凭证
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
node&#123;
    stage(&#39;拉取代码&#39;)&#123;
        checkout scmGit(branches: [[name: &#39;*/$&#123;branch&#125;&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_front.git&#39;]])
    &#125;
     stage(&#39;打包，部署网站&#39;) &#123;
        //使用NodeJS的npm进行打包
        nodejs(&#39;nodejs12&#39;)&#123;
         sh &#39;&#39;&#39;
             npm install
             npm run build   
        &#39;&#39;&#39;         
        &#125;
     &#125;
     //=====以下为远程调用进行项目部署========
     sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &#39;&#39;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;/usr/share/nginx/html&#39;, remoteDirectorySDF: false, removePrefix: &#39;dist&#39;, sourceFiles: &#39;dist/**&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
&#125;
</code></pre>
<p>去gitlab里面修改<code>tensquare_front</code>里面的config→<code>prod.env.js</code></p>
<pre><code class="java">&#39;use strict&#39;
module.exports = &#123;
  NODE_ENV: &#39;&quot;production&quot;&#39;,
  // BASE_API: &#39;&quot;http://192.168.207.131:7300/mock/5c0b42c85b4c7508d4dc568c/1024&quot;&#39;
  BASE_API: &#39;&quot;http://192.168.200.130:10020&quot;&#39; // 管理员网关[生产]
&#125;
</code></pre>
<p>去构建一下！</p>
<p>然后去生产服务器寻找</p>
<blockquote>
<p>[root@localhost html]# <code>cd /usr/share/nginx/html</code><br>[root@localhost html]# ll<br>总用量 80<br>-rw-r–r–. 1 root root  3650 11月 11 2022 404.html<br>-rw-r–r–. 1 root root  3693 11月 11 2022 50x.html<br>lrwxrwxrwx. 1 root root    20 7月   5 19:30 en-US -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;en-US<br>-rw-r–r–. 1 root root 67646 7月   5 20:12 favicon.ico<br>drwxr-xr-x. 2 root root    27 7月   5 19:30 icons<br>lrwxrwxrwx. 1 root root    18 7月   5 19:30 img -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;img<br>lrwxrwxrwx. 1 root root    25 7月   5 19:30 index.html -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;index.html<br>-rw-r–r–. 1 root root   368 11月 11 2022 nginx-logo.png<br>lrwxrwxrwx. 1 root root    14 7月   5 19:30 poweredby.png -&gt; nginx-logo.png<br>drwxr-xr-x. 6 root root    51 7月   5 20:12 static<br>[root@localhost html]#</p>
</blockquote>
<p>回头再去访问：<a target="_blank" rel="noopener" href="http://192.168.200.130:9099/">http://192.168.200.130:9099/</a> 已经成功</p>
<blockquote>
<p>admin  123456</p>
</blockquote>
<p>登录进去查看是否能连通之前在镜像部署的微服务后端！！！[一次成功 完美！！]</p>
<h4 id="Jenkins-Docker-SpringCloud微服务持续集成-下-之前是单机版"><a href="#Jenkins-Docker-SpringCloud微服务持续集成-下-之前是单机版" class="headerlink" title="Jenkins+Docker+SpringCloud微服务持续集成(下)之前是单机版"></a>Jenkins+Docker+SpringCloud微服务持续集成(下)<del>之前是单机版</del></h4><h6 id="上面部署方案存在的问题："><a href="#上面部署方案存在的问题：" class="headerlink" title="上面部署方案存在的问题："></a>上面部署方案存在的问题：</h6><p>1）一次只能选择一个微服务部署<br>2）只有一台生产者部署服务器<br>3）每个微服务只有一个实例，容错率低</p>
<h5 id="初级版已完成接下来是中级版本！！"><a href="#初级版已完成接下来是中级版本！！" class="headerlink" title="初级版已完成接下来是中级版本！！"></a>初级版已完成接下来是中级版本！！</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/b15e17b4e1423812026358347a2f45e5a23e8bc3/%E6%96%B0%E9%B2%9C%E9%9B%86%E6%88%90%E5%9B%BE2.png"></p>
<p>在idea项目中增加一台新的机器作为eureka注册的地方</p>
<pre><code class="yml">tensquare_gathering/src/main/resources/application.yml
server: 
  port: 9002
spring: 
  application:  
    name: tensquare-gathering #指定服务名
  datasource:  
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.200.129:3306/tensquare_gathering?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
  jpa: 
    database: mysql
    show-sql: true
#Eureka客户端配置
eureka:
  client:
    service-url:
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳
    lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期
    prefer-ip-address: true
</code></pre>
<pre><code class="yaml">tensquare_admin_service/src/main/resources/application.yml
server: 
  port: 9001
spring: 
  application:  
    name: tensquare-admin-service #指定服务名
  datasource:  
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.200.129:3306/tensquare_user?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
  jpa: 
    database: mysql
    show-sql: true

#Eureka配置
eureka:
  client:
    service-url:
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳
    lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期
    prefer-ip-address: true


 # jwt参数
jwt:
  config:
    key: itcast
    ttl: 1800000
</code></pre>
<pre><code class="yaml">tensquare_zuul/src/main/resources/application.yml
server:
  port: 10020 # 端口
  
# 基本服务信息
spring:
  application:
    name: tensquare-zuul # 服务ID
    
# Eureka配置
eureka:
  client:
    service-url:  
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    prefer-ip-address: true
  
# 修改ribbon的超时时间
ribbon:
  ConnectTimeout: 1500 # 连接超时时间，默认500ms
  ReadTimeout: 3000  # 请求超时时间，默认1000ms
  
  
# 修改hystrix的熔断超时时间
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMillisecond: 2000 # 熔断超时时长，默认1000ms
            

# 网关路由配置
zuul:
  routes:
    admin:
      path: /admin/**
      serviceId: tensquare-admin-service
    gathering:
          path: /gathering/**
          serviceId: tensquare-gathering

 # jwt参数
jwt:
  config:
    key: itcast
    ttl: 1800000
</code></pre>
<pre><code class="yaml">C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server\src\main\resources\application.yml
# 集群版
spring:
  application:
    name: EUREKA-HA

---
server:
  port: 10086
spring:
  # 指定profile=eureka-server1
  profiles: eureka-server1
eureka:
  instance:
    # 指定当profile=eureka-server1时，主机名是eureka-server1
    hostname: 192.168.66.130
  client:
    service-url:
      # 将自己注册到eureka-server1、eureka-server2这个Eureka上面去
      defaultZone: http://192.168.66.130:10086/eureka/,http://192.168.66.133:10086/eureka/

---
server:
  port: 10086
spring:
  profiles: eureka-server2
eureka:
  instance:
    hostname: 192.168.66.132
  client:
    service-url:
      defaultZone: http://192.168.66.130:10086/eureka/,http://192.168.66.133:10086/eureka/
</code></pre>
<p>然后更改提交push到gitlab</p>
<h4 id="设计Jenkins集群项目的构建参数"><a href="#设计Jenkins集群项目的构建参数" class="headerlink" title="设计Jenkins集群项目的构建参数"></a>设计Jenkins集群项目的构建参数</h4><ul>
<li><p>安装Extended Choice Parameter插件<del>支持多选框</del></p>
</li>
<li><p>新建一个<code>tensquare_back_cluster</code>的item<br>流水线选择piplin…SCM；git的url填gitlab里的后端地址</p>
</li>
<li><p>第一步安装好插件后 就可以在<code>This project...</code> 中看到<code>Choice Parameter</code><br>先添加一个<code>String Parameter</code>：名称branch 默认值master 描述请输入分支名称</p>
</li>
<li><p>再添加参数选择多选<code>Extended Choice Parameter</code>：名称project_name 描述:请选择需要部署的微服务；勾选<code>Basic Parameter Types</code> → Check Boxes → Number of Visble Items：4 → Delimiter<code>,</code>(用逗号去隔开) → 点击下面的<code>Choose Source for Value</code> → Value为<code>tensquare_eureka_server@10086,tensquare_zuul@10020,tensquare_admin_service@9001,tensquare_gathering@9002</code> → 点击<code>Choose Source for Default Value</code>(选择默认值)：<code>tensquare_eureka_server@10086</code> → 点击<code>ChooseSourceforValueDescription</code>(描述备注) Description：<code>注册中心,服务网关,认证中心,活动微服务</code> 👉 应用保存 → 构建就可以看到</p>
<p>★★ 请注意 配置多选的时候 Jenkins那里一定不要多加空格什么的！</p>
</li>
<li><p>更新Jenkinsfile代码</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i = 0; i &lt; selectedProjectNames.length; i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
        // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
        // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
        sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="多个项目打包及构建上传镜像"><a href="#多个项目打包及构建上传镜像" class="headerlink" title="多个项目打包及构建上传镜像"></a>多个项目打包及构建上传镜像</h4><ul>
<li>更新Jenkinsfile文件</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i=0;i&lt;selectedProjectNames.length;i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程，上传镜像&#39;) &#123;
        for (int i = 0; i &lt; selectedProjectNames.length; i++) &#123;
            //tensquare_eureka_server@10086
            def projectInfo = selectedProjectNames[i];
            //当前遍历的项目名称
            def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
            //当前遍历的项目端口
            def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

            sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

            //定义镜像名称
            def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

            // 对镜像打上标签
            sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
            withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
                // 登录到Harbor
                sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

                //镜像上传
                sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

                sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
            &#125;
            // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
            // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
            sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="把Eureka注册中心集群部署到多台服务器"><a href="#把Eureka注册中心集群部署到多台服务器" class="headerlink" title="把Eureka注册中心集群部署到多台服务器"></a>把Eureka注册中心集群部署到多台服务器</h4><p><code>Dashboard → Manage Jenkins → 下面的SSH Server → 增加一台133的机器</code><br>测试之前需要把Jenkins服务的公钥拷贝到133上面</p>
<blockquote>
<p>在Jenkins的129机器<br>[root@localhost ~]# ssh-copy-id 192.168.200.133    [Product_slave]</p>
</blockquote>
<blockquote>
<p>SSH Server→【应用+Save】<br>Name：slave_server<br>Hostname：192.168.200.133<br>Username：root<br>Remote Directory：&#x2F;</p>
</blockquote>
<p>继续在Jenkins的<code>tensquare_back_cluster</code>中的<code>Configure</code>的<code>Extended Choice Parameter</code>的下面<code>添加参数</code> → 继续添加<code>Extended Choice Parameter</code> → 在里面继续添加<code>Name：publish_server;Description：请选择需要部署的服务器</code> → 勾选<code>Basic Parameter Types</code>, <code>Parameter Type：Check Boxes</code> → <code>Number of Visible Items：2</code>, <code>Delimiter：,</code> 下面的<code>Choose Source for Value</code> → <code>Value：master_server,slave_server</code> → 下面的<code>Default Value：master_server</code> → 下面的<code>Description：主节点,从节点</code> → 应用+Save</p>
<ul>
<li>更新了<code>Jenkinsfile</code>文件</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)
    // 获取当前选择的服务器名称
    def selectedServers = &quot;$&#123;publish_server&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i=0;i&lt;selectedProjectNames.length;i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程，上传镜像&#39;) &#123;
        for (int i = 0; i &lt; selectedProjectNames.length; i++) &#123;
            //tensquare_eureka_server@10086
            def projectInfo = selectedProjectNames[i];
            //当前遍历的项目名称
            def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
            //当前遍历的项目端口
            def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

            sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

            //定义镜像名称
            def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

            // 对镜像打上标签
            sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
            withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
                // 登录到Harbor
                sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

                //镜像上传
                sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

                sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
            &#125;
            //遍历所有服务器，分别部署
            for (int j = 0; j &lt; selectedServers.length; j++) &#123;
                //获取当前遍历的服务器名称
                def currentServerName = selectedServers[j]

                //加上的参数格式：--spring.profiles.active=eureka-server1/eureka-server2
                def activeProfile = &quot;--spring.profiles.active=&quot;

                //根据不同的服务名称来读取不同的Eureka配置信息
                if (currentServerName == &quot;master_server&quot;) &#123;
                    activeProfile = activeProfile + &quot;eureka-server1&quot;
                &#125; else if (currentServerName == &quot;slave_server&quot;) &#123;
                    activeProfile = activeProfile + &quot;eureka-server2&quot;
                &#125;

                // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
                // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
                sshPublisher(publishers: [sshPublisherDesc(configName: &quot;$&#123;currentServerName&#125;&quot;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deployCluster.sh $harbor_url $harbor_project $currentProjectName $tag $currentProjectPort $activeProfile&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>将之前的<code>deploy.sh</code>换成了<code>deployCluster.sh</code></li>
</ul>
<pre><code class="yaml">#! /bin/sh
#接收外部参数
harbor_url=$1
harbor_project_name=$2
project_name=$3
tag=$4
port=$5
profile=$6

imageName=$harbor_url/$harbor_project_name/$project_name:$tag

echo &quot;$imageName&quot;

#查询容器是否存在，存在则删除
containerId=`docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125;  | awk &#39;&#123;print $1&#125;&#39;`

if [ &quot;$containerId&quot; !=  &quot;&quot; ] ; then
    #停掉容器
    docker stop $containerId

    #删除容器
    docker rm $containerId
    
    echo &quot;成功删除容器&quot;
fi

#查询镜像是否存在，存在则删除
imageId=`docker images | grep -w $project_name  | awk &#39;&#123;print $3&#125;&#39;`

if [ &quot;$imageId&quot; !=  &quot;&quot; ] ; then
      
    #删除镜像
    docker rmi -f $imageId
    
    echo &quot;成功删除镜像&quot;
fi

# 登录Harbor
docker login -u eric -p Eric123456 $harbor_url

# 下载镜像
docker pull $imageName

# 启动容器
docker run -di -p $port:$port $imageName $profile

echo &quot;容器启动成功&quot;
</code></pre>
<ul>
<li><p>master_server,slave_server将130生产的机器<code>master机器</code>里 放入<code>deployCluster.sh</code> 是在这个目录<code>/opt/jenkins_shell/</code>里面<br>然后加上权限</p>
<blockquote>
<p>[root@localhost ~]# <code>cd /opt/jenkins_shell/</code><br>[root@localhost jenkins_shell]# <code>chmod +x deployCluster.sh</code></p>
</blockquote>
</li>
<li><p>然后在133机器上<code>slave机器</code> 按照上一步的操作拖进去 然后加入权限</p>
<blockquote>
<p>[root@localhost ~]# <code>cd /opt/jenkins_shell/</code><br>[root@localhost jenkins_shell]# <code>chmod +x deployCluster.sh</code></p>
</blockquote>
</li>
</ul>
<p>[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>) + [Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.133:10086/">http://192.168.200.133:10086/</a>)</p>
<ul>
<li><p>然后再去把剩下的都构建了</p>
<blockquote>
<h4 id="project-name"><a href="#project-name" class="headerlink" title="project_name"></a>project_name</h4><p>请选择需要部署的微服务</p>
<table>
<thead>
<tr>
<th>注册中心</th>
</tr>
</thead>
<tbody><tr>
<td>服务网关</td>
</tr>
<tr>
<td>认证中心</td>
</tr>
<tr>
<td>活动微服务</td>
</tr>
</tbody></table>
<h4 id="publish-server"><a href="#publish-server" class="headerlink" title="publish_server"></a>publish_server</h4><p>请选择需要部署的服务器</p>
<table>
<thead>
<tr>
<th>主节点</th>
</tr>
</thead>
<tbody><tr>
<td>从节点</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="Nginx-Zuul集群实现高可用网关"><a href="#Nginx-Zuul集群实现高可用网关" class="headerlink" title="Nginx + Zuul集群实现高可用网关"></a>Nginx + Zuul集群实现高可用网关</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/d0f70a9927ff44bf814b318e0c7211a8e0bdbce6/Nginx%20+%20Zuul%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BD%91%E5%85%B3.png"></p>
<h5 id="更改133的nginx配置"><a href="#更改133的nginx配置" class="headerlink" title="更改133的nginx配置"></a>更改133的nginx配置</h5><p><code>vi /etc/nginx/nginx.conf</code></p>
<pre><code class="yaml">user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events &#123;
    worker_connections 1024;
&#125;

http &#123;
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 4096;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    include /etc/nginx/conf.d/*.conf;

    ### 新增负载均衡配置
    upstream zuulServer &#123;
        server 192.168.200.130:10020 weight=1;
        server 192.168.200.133:10020 weight=1;
    &#125;

    server &#123;
        listen       85 default_server;
        listen       [::]:85 default_server;
        server_name  _;·
        root         /usr/share/nginx/html;

        include /etc/nginx/default.d/*.conf;

        location / &#123;
            proxy_pass http://zuulServer/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        &#125;

        error_page 404 /404.html;
        location = /404.html &#123;
        &#125;

        error_page 500 502 503 504 /50x.html;
        location = /50x.html &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<p>重启Nginx：<code>systemctl restart nginx</code><br>修改前端Nginx的访问地址tensquare_front → config → <code>prod.env.js</code></p>
<pre><code class="yaml">&#39;use strict&#39;
module.exports = &#123;
  NODE_ENV: &#39;&quot;production&quot;&#39;,
  // BASE_API: &#39;&quot;http://192.168.207.131:7300/mock/5c0b42c85b4c7508d4dc568c/1024&quot;&#39;
  BASE_API: &#39;&quot;http://192.168.200.133:85&quot;&#39; // 管理员网关
&#125;
</code></pre>
<h3 id="基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-上"><a href="#基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-上" class="headerlink" title="基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(上)"></a>基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(上)</h3><h5 id="Jenkins的Master-Slave分布式构建"><a href="#Jenkins的Master-Slave分布式构建" class="headerlink" title="Jenkins的Master-Slave分布式构建"></a>Jenkins的Master-Slave分布式构建</h5><h6 id="什么是Master-Slave分布式构建"><a href="#什么是Master-Slave分布式构建" class="headerlink" title="什么是Master-Slave分布式构建"></a>什么是Master-Slave分布式构建</h6><p>Jenkins的Master-Slave分布式构建，就是通过将构建过程分配到从属Slave节点上，从而减轻Master节 点的压力，而且可以同时构建多个，有点类似负载均衡的概念。</p>
<h6 id="如何实现Master-Slave分布式构建"><a href="#如何实现Master-Slave分布式构建" class="headerlink" title="如何实现Master-Slave分布式构建"></a>如何实现Master-Slave分布式构建</h6><ul>
<li><p>开启代理程序的TCP端口<code>Dashboard → Manage Jenkins → Security → 代理：随机选取</code></p>
</li>
<li><p>新建节点 <code>Dashboard → Manage Jenkins → Nodes → New node → 节点名称: slave1  勾选Permanent Agent → create </code> → 我的Jenkins主节点在101机器，从节点就放在102机器吧 → 去102机器<code>cd /root； mkdir jenkins</code>  → 远程工作目录：<code>/root/jenkins</code> → 用法；启动方式；可用性都是默认第一个 → 点进去刚刚创建的slave →↓</p>
<pre><code class="yaml">Run from agent command line: (Unix) 
# 下载agent.jar
curl -sO http://192.168.200.133:8888/jnlpJars/agent.jar

java -jar agent.jar -url http://192.168.200.129:8888/ -secret 85f68f679a60139d7867571d577299c3c7d10f913acfca589bb0b9018b86e14d -name slave1 -webSocket -workDir &quot;/root/jenkins&quot;
</code></pre>
<p>想要这个 需要下载个agent.jar包传到102的&#x2F;root机器中</p>
</li>
</ul>
<blockquote>
<h2 id="✅-最简单解决方案（推荐）"><a href="#✅-最简单解决方案（推荐）" class="headerlink" title="✅ 最简单解决方案（推荐）"></a>✅ 最简单解决方案（推荐）</h2><h3 id="✅-方案一：从-Jenkins-主机上下载，再用-SCP-复制到-agent-机器"><a href="#✅-方案一：从-Jenkins-主机上下载，再用-SCP-复制到-agent-机器" class="headerlink" title="✅ 方案一：从 Jenkins 主机上下载，再用 SCP 复制到 agent 机器"></a>✅ <strong>方案一：从 Jenkins 主机上下载，再用 SCP 复制到 agent 机器</strong></h3><p>在 Jenkins 主机（192.168.200.129）上执行：</p>
<pre><code>curl -sO http://localhost:8888/jnlpJars/agent.jar
</code></pre>
<p>然后从主机 <strong>scp 到 192.168.200.133</strong>：</p>
<pre><code>scp agent.jar root@192.168.200.133:/root/
</code></pre>
<p>登录密码或配置了免密都行。</p>
</blockquote>
<h3 id="Kubernetes实现Master-Slave分布式构建方案"><a href="#Kubernetes实现Master-Slave分布式构建方案" class="headerlink" title="Kubernetes实现Master-Slave分布式构建方案"></a><span style = "color:red">Kubernetes实现Master-Slave分布式构建方案</span></h3><h5 id="传统Jenkins的Master-Slave方案的缺陷"><a href="#传统Jenkins的Master-Slave方案的缺陷" class="headerlink" title="传统Jenkins的Master-Slave方案的缺陷"></a>传统Jenkins的Master-Slave方案的缺陷</h5><ul>
<li>Master 每个 节点发生单点故障时，整个流程都不可用了 </li>
<li>Slave节点的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置致管理起来非常不方便，维护起来也是比较费劲 </li>
<li>资源分配不均衡，有的 Slave节点要运行的job出现排队等待，而有的Slave节点处于空闲状态 </li>
<li>资源浪费，每台 掉资源 Slave节点可能是实体机或者VM，当Slave节点处于空闲状态时，也不会完全释放</li>
</ul>
<p>以上种种问题，我们可以引入Kubernates来解决！</p>
<p>K8S是对主从分布式架构的优化！！！</p>
<h5 id="Kubernates简介"><a href="#Kubernates简介" class="headerlink" title="Kubernates简介"></a>Kubernates简介</h5><p>Kubernetes（简称，K8S）是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化的 应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的 便捷性。 其主要功能如下：</p>
<ul>
<li>使用 Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 </li>
<li>以集群的方式运行、管理跨机器的容器。以集群的方式运行、管理跨机器的容器。</li>
<li>解决 Docker跨机器容器之间的通讯问题。解决Docker跨机器容器之间的通讯问题。 </li>
<li>Kubernetes 的自我修复机制使得容器集群总是运行在用户期望的状态。</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/e7ba868ee01a6860f90f158257d10a2f1d6d1a83/Kubernates+Docker+Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E5%9B%BE.png" style="zoom: 80%;" />

<h4 id="Kubernates-Docker-Jenkins持续集成方案好处"><a href="#Kubernates-Docker-Jenkins持续集成方案好处" class="headerlink" title="Kubernates+Docker+Jenkins持续集成方案好处"></a>Kubernates+Docker+Jenkins持续集成方案好处</h4><ul>
<li><span style = "color:red">服务高可用</span>：当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。 </li>
<li><span style = "color:red">动态伸缩，合理使用资源</span>：每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。 </li>
<li><span style = "color:red">扩展性好</span> ：当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。</li>
</ul>
<h4 id="Kubeadm安装Kubernetes"><a href="#Kubeadm安装Kubernetes" class="headerlink" title="Kubeadm安装Kubernetes"></a>Kubeadm安装Kubernetes</h4><h5 id="Kubernetes的架构"><a href="#Kubernetes的架构" class="headerlink" title="Kubernetes的架构"></a>Kubernetes的架构</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/062acb4452ba025e956c0bea31d53ad08618cbc1/kubernetes.png"></p>
<ul>
<li><strong>API Serve</strong>r ：用于暴露Kubernetes API，任何资源的请求的调用操作都是通过kube-apiserver提供的接 口进行的。 </li>
<li><strong>Etcd</strong>：是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计 划。 </li>
<li><strong>Controller-Manager</strong>：作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点 （Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额 （ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化 修复流程，确保集群始终处于预期的工作状态。 </li>
<li><strong>Scheduler</strong>：监视新创建没有分配到Node的Pod，为Pod选择一个Node。 </li>
<li><strong>Kubelet</strong>：负责维护容器的生命周期，同时负责Volume和网络的管理 </li>
<li><strong>Kube proxy</strong>：是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通 信与负载均衡机制的重要组件。</li>
</ul>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.200.132</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td>192.168.200.131</td>
<td>Harbor1.9.2</td>
</tr>
<tr>
<td>k8s-master</td>
<td>192.168.200.129</td>
<td>kube-apiserver、kube-controller-manager、kube scheduler、docker、etcd、calico，NFS</td>
</tr>
<tr>
<td>k8s-node1</td>
<td>192.168.200.130</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
<tr>
<td>k8s-node2</td>
<td>192.168.200.133</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
</tbody></table>
<h4 id="三台机器都需要完成-结束我会提示"><a href="#三台机器都需要完成-结束我会提示" class="headerlink" title="三台机器都需要完成(结束我会提示)"></a><span style ="color:green">三台机器都需要完成<del>(结束我会提示)</del></span></h4><p>修改三台机器的hostname及hosts文件</p>
<blockquote>
<p>【输入hostname即可查看是否改成功】<br>hostnamectl set-hostname k8s-master   【129】<br>hostnamectl set-hostname k8s-node1    【130】<br>hostnamectl set-hostname k8s-node2    【133】</p>
</blockquote>
<blockquote>
<p>【将id映射的hostname进行关联】<br>[输入 <code>cat /etc/hosts</code> 查看是否成功]<br>cat &gt;&gt;&#x2F;etc&#x2F;hosts&lt;&lt;EOF<br>192.168.200.129 k8s-master<br>192.168.200.130 k8s-node1<br>192.168.200.133 k8s-node2<br>EOF</p>
</blockquote>
<p>效果图</p>
<blockquote>
<p>[root@localhost ~]# cat &#x2F;etc&#x2F;hosts<br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.200.129 k8s-master<br>192.168.200.130 k8s-node1<br>192.168.200.133 k8s-node2</p>
</blockquote>
<p>关闭防火墙和关闭SELinux</p>
<blockquote>
<p>systemctl stop firewalld<br>systemctl disable firewalld </p>
<p><code>setenforce 0</code> 临时关闭<br><code>vi /etc/sysconfig/selinux </code>永久关闭<br>改为<code>SELINUX=disabled</code></p>
</blockquote>
<p><strong>关闭 SELinux</strong> 可以避免一些服务（如 Jenkins、SonarQube、Docker）因为权限问题无法访问网络或文件，但<strong>不是永久推荐</strong>的安全实践。</p>
<h6 id="设置系统参数"><a href="#设置系统参数" class="headerlink" title="设置系统参数"></a>设置系统参数</h6><p>设置允许路由转发，不对bridge的数据进行处理<br>创建文件</p>
<blockquote>
<p>vi &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
<p>内容如下：</p>
<p>net.bridge.bridge-nf-call-ip6tables &#x3D; 1<br>net.bridge.bridge-nf-call-iptables &#x3D; 1<br>net.ipv4.ip_forward &#x3D; 1<br>vm.swappiness &#x3D; 0</p>
</blockquote>
<p>执行文件</p>
<blockquote>
<p>sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
</blockquote>
<h5 id="kube-proxy开启ipvs的前置条件"><a href="#kube-proxy开启ipvs的前置条件" class="headerlink" title="kube-proxy开启ipvs的前置条件"></a>kube-proxy开启ipvs的前置条件</h5><pre><code class="yaml">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
EOF

chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash   ☆☆
/etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4
</code></pre>
<h5 id="所有节点关闭swap"><a href="#所有节点关闭swap" class="headerlink" title="所有节点关闭swap"></a>所有节点关闭swap</h5><blockquote>
<p>swapoff -a 临时关闭<br>vi &#x2F;etc&#x2F;fstab 永久关闭 </p>
<p>注释掉以下字段<br>&#x2F;dev&#x2F;mapper&#x2F;cl-swap swap swap defaults 0 0</p>
</blockquote>
<h5 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h5><ul>
<li>kubeadm：用来初始化集群的指令。 </li>
<li>kubelet：在集群中的每个节点上用来启动 pod 和 container 等。 </li>
<li>kubectl:  清空yum缓存 用来与集群通信的命令行工具。</li>
</ul>
<h5 id="清空yum缓存"><a href="#清空yum缓存" class="headerlink" title="清空yum缓存"></a>清空yum缓存</h5><blockquote>
<p>yum clean all</p>
</blockquote>
<h5 id="设置yum安装源"><a href="#设置yum安装源" class="headerlink" title="设置yum安装源"></a>设置yum安装源</h5><pre><code class="yaml">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg 
https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>
<p>安装：<code>yum install -y kubelet kubeadm kubectl</code></p>
<h5 id="kubelt-设置开机启动（注意：先不启动，现在启动的话会报错）"><a href="#kubelt-设置开机启动（注意：先不启动，现在启动的话会报错）" class="headerlink" title="kubelt 设置开机启动（注意：先不启动，现在启动的话会报错）"></a>kubelt 设置开机启动（注意：先不启动，现在启动的话会报错）</h5><p><code>systemctl start kubelet</code> 启动 ★★</p>
<p><code>systemctl enable kubelet</code> 开机启动</p>
<h5 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h5><p><code>kubelet --version</code>  → Kubernetes v1.28.2</p>
<p><span style="color:green">结束！</span></p>
<h4 id="Master节点需要完成-129主节点"><a href="#Master节点需要完成-129主节点" class="headerlink" title="Master节点需要完成 [129主节点]"></a>Master节点需要完成 [129主节点]</h4><ul>
<li>运行初始化命令</li>
</ul>
<pre><code class="yaml">kubeadm init --kubernetes-version=1.28.2 \
--apiserver-advertise-address=192.168.200.129 \
--image-repository registry.aliyuncs.com/google_containers \
--service-cidr=10.1.0.0/16 \
--pod-network-cidr=10.244.0.0/16
</code></pre>
<blockquote>
<h4 id="如何重新初始化？"><a href="#如何重新初始化？" class="headerlink" title="如何重新初始化？"></a>如何重新初始化？</h4><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-清理旧集群残留"><a href="#1-清理旧集群残留" class="headerlink" title="1. 清理旧集群残留"></a>1. <strong>清理旧集群残留</strong></h3><p>先执行 <code>kubeadm reset</code> 清理当前节点的 Kubernetes 配置和状态：</p>
<pre><code>kubeadm reset -f
kubeadm reset
</code></pre>
<p>这个命令会清理 kubelet 配置文件、证书、容器网络和所有 Kubernetes 相关状态。</p>
<hr>
<h3 id="2-清理网络相关残留"><a href="#2-清理网络相关残留" class="headerlink" title="2. 清理网络相关残留"></a>2. <strong>清理网络相关残留</strong></h3><p>清理 CNI 网络配置和容器残留：</p>
<pre><code>rm -rf /etc/cni/net.d
rm -rf /var/lib/cni/
rm -rf /var/lib/kubelet/*
</code></pre>
<hr>
<h3 id="3-确认-containerd-服务启动"><a href="#3-确认-containerd-服务启动" class="headerlink" title="3. 确认 containerd 服务启动"></a>3. <strong>确认 containerd 服务启动</strong></h3><p>确保 containerd 运行：</p>
<pre><code>systemctl restart containerd
systemctl status containerd
</code></pre>
<hr>
<h3 id="4-重新初始化-Kubernetes"><a href="#4-重新初始化-Kubernetes" class="headerlink" title="4. 重新初始化 Kubernetes"></a>4. <strong>重新初始化 Kubernetes</strong></h3><p>执行你之前的初始化命令：</p>
<pre><code>kubeadm init --kubernetes-version=1.28.2 \
  --apiserver-advertise-address=192.168.200.129 \
  --image-repository registry.aliyuncs.com/google_containers \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.244.0.0/16
</code></pre>
<hr>
<h3 id="5-配置-kubeconfig"><a href="#5-配置-kubeconfig" class="headerlink" title="5. 配置 kubeconfig"></a>5. <strong>配置 kubeconfig</strong></h3><p>初始化完成后，按照提示将配置文件复制到用户目录：</p>
<pre><code>mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<hr>
<h3 id="6-部署网络插件"><a href="#6-部署网络插件" class="headerlink" title="6. 部署网络插件"></a>6. <strong>部署网络插件</strong></h3><p>根据你使用的网络插件（比如 Flannel、Calico），按照官方文档部署。以 Flannel 为例：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<hr>
<h3 id="7-验证"><a href="#7-验证" class="headerlink" title="7. 验证"></a>7. <strong>验证</strong></h3><p>查看节点和 Pod 状态：</p>
<pre><code>kubectl get nodes
kubectl get pods -n kube-system
</code></pre>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token q54yl3.xgho0e6o5080hnnf \
        --discovery-token-ca-cert-hash sha256:b8f6a58b65ad6bcfec65e5ed6ab5efac95f3a4ee82b2c388a87b20c3e813079b
</code></pre>
<hr>
<hr>
<hr>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>你之前的配置文件和状态未清理，导致不能重新初始化。先用 <code>kubeadm reset</code> 清理，再重新初始化。这样会自动生成 <code>kubelet</code> 配置文件和 <code>kubelet.conf</code>，解决你遇到的启动失败问题。</p>
</blockquote>
<blockquote>
<p>问题：     [ERROR CRI]: container runtime is not running: output: E0706 21:24:43.293740   26106 remote_runtime.go:616] “Status from runtime service failed” err&#x3D;”rpc error: code &#x3D; Unavailable desc &#x3D; connection error: desc &#x3D; &quot;transport: Error while dialing dial unix &#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock: connect: no such file or directory&quot;“ time&#x3D;”2025-07-06T21:24:43+08:00” level&#x3D;fatal msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unavailable desc &#x3D; connection error: desc &#x3D; &quot;transport: Error while dialing dial unix &#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock: connect: no such file or directory&quot;“ , error: exit status 1 [preflight] If you know what you are doing, you can make a check non-fatal with <code>--ignore-preflight-errors=...</code> To see the stack trace of this error execute with –v&#x3D;5 or higher [root@k8s-master ~]#</p>
<h3 id="✅-立即解决步骤（推荐直接复制粘贴执行）"><a href="#✅-立即解决步骤（推荐直接复制粘贴执行）" class="headerlink" title="✅ 立即解决步骤（推荐直接复制粘贴执行）"></a>✅ 立即解决步骤（推荐直接复制粘贴执行）</h3><h4 id="1️⃣-安装-containerd"><a href="#1️⃣-安装-containerd" class="headerlink" title="1️⃣ 安装 containerd"></a>1️⃣ 安装 containerd</h4><pre><code>yum install -y containerd
</code></pre>
<p>你这里显示的是一个<strong>非标准的 containerd 配置模板</strong>（很可能来自旧版本或 docker 提供的 containerd），<strong>缺失了完整配置结构和 <code>SystemdCgroup</code> 字段</strong>，所以这不是我们需要的配置。</p>
<hr>
<h3 id="✅-正确做法是：用标准-containerd-命令生成完整配置"><a href="#✅-正确做法是：用标准-containerd-命令生成完整配置" class="headerlink" title="✅ 正确做法是：用标准 containerd 命令生成完整配置"></a>✅ 正确做法是：用标准 containerd 命令生成完整配置</h3><p>请执行以下命令替换掉旧配置：</p>
<hr>
<h3 id="🔁-步骤-1：重新生成-containerd-的标准配置文件"><a href="#🔁-步骤-1：重新生成-containerd-的标准配置文件" class="headerlink" title="🔁 步骤 1：重新生成 containerd 的标准配置文件"></a>🔁 步骤 1：重新生成 containerd 的标准配置文件</h3><pre><code>rm -f /etc/containerd/config.toml  # 删除旧文件
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🔧-步骤-2：编辑配置文件，修改-SystemdCgroup-true"><a href="#🔧-步骤-2：编辑配置文件，修改-SystemdCgroup-true" class="headerlink" title="🔧 步骤 2：编辑配置文件，修改 SystemdCgroup = true"></a>🔧 步骤 2：编辑配置文件，修改 <code>SystemdCgroup = true</code></h3><pre><code>vi /etc/containerd/config.toml
</code></pre>
<p>在文件中搜索这一行（用 <code>/SystemdCgroup</code>）：</p>
<pre><code>SystemdCgroup = false
</code></pre>
<p>将它修改为：</p>
<pre><code>SystemdCgroup = true
</code></pre>
<hr>
<h3 id="🔁-步骤-3：重启-containerd"><a href="#🔁-步骤-3：重启-containerd" class="headerlink" title="🔁 步骤 3：重启 containerd"></a>🔁 步骤 3：重启 containerd</h3><pre><code>systemctl daemon-reexec
systemctl restart containerd
systemctl enable containerd
</code></pre>
<hr>
<h3 id="✅-步骤-4：验证是否运行中"><a href="#✅-步骤-4：验证是否运行中" class="headerlink" title="✅ 步骤 4：验证是否运行中"></a>✅ 步骤 4：验证是否运行中</h3><pre><code>systemctl status containerd
</code></pre>
<p>确保输出中看到：<code>Active: active (running)</code></p>
<hr>
<h5 id="然后你就可以继续-kubeadm-init-了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行"><a href="#然后你就可以继续-kubeadm-init-了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行" class="headerlink" title="然后你就可以继续 kubeadm init 了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行"></a>然后你就可以继续 <code>kubeadm init</code> 了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行</h5><h4 id="一、清理旧的集群数据"><a href="#一、清理旧的集群数据" class="headerlink" title="一、清理旧的集群数据"></a>一、清理旧的集群数据</h4><p>你可以执行下面命令，清理之前的 kubeadm 初始化信息：</p>
<pre><code>kubeadm reset
</code></pre>
<hr>
<hr>
<hr>
<hr>
<h3 id="你这边的核心问题是："><a href="#你这边的核心问题是：" class="headerlink" title="你这边的核心问题是："></a><span style = "color:red">你这边的核心问题是：</span></h3><blockquote>
<p>❌ containerd 没有启动，导致 kubeadm 报错<br> <code>&quot;connect: no such file or directory&quot; → /var/run/containerd/containerd.sock</code></p>
</blockquote>
<p>这说明 <strong>containerd 根本没跑起来</strong>，Kubernetes 无法连接它。</p>
<hr>
<h3 id="✅-解决思路：修复-containerd-的配置-启动-containerd"><a href="#✅-解决思路：修复-containerd-的配置-启动-containerd" class="headerlink" title="✅ 解决思路：修复 containerd 的配置 + 启动 containerd"></a>✅ 解决思路：修复 containerd 的配置 + 启动 containerd</h3><p>我们手把手来操作👇</p>
<hr>
<h2 id="🧹-第一步：清空-containerd-的配置文件并重新生成"><a href="#🧹-第一步：清空-containerd-的配置文件并重新生成" class="headerlink" title="🧹 第一步：清空 containerd 的配置文件并重新生成"></a>🧹 第一步：清空 containerd 的配置文件并重新生成</h2><pre><code>rm -f /etc/containerd/config.toml
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<p>✅ 这一步会恢复官方默认配置。</p>
<h3 id="✏️-第二步：使用-vi（所有-Linux-通用）"><a href="#✏️-第二步：使用-vi（所有-Linux-通用）" class="headerlink" title="✏️ 第二步：使用 vi（所有 Linux 通用）"></a>✏️ 第二步：使用 <code>vi</code>（所有 Linux 通用）</h3><pre><code>vi /etc/containerd/config.toml
</code></pre>
<p>查找这一段：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;]
  sandbox_image = &quot;registry.k8s.io/pause:3.6&quot;
</code></pre>
<p>把它改成：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;]
  sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;
</code></pre>
<p>✅ 保存并退出🔄 第三步：重启 containerd</p>
<pre><code>systemctl daemon-reexec
systemctl restart containerd
</code></pre>
<h2 id="✅-第四步：确认-containerd-已成功启动"><a href="#✅-第四步：确认-containerd-已成功启动" class="headerlink" title="✅ 第四步：确认 containerd 已成功启动"></a>✅ 第四步：确认 containerd 已成功启动</h2><pre><code>systemctl status containerd
</code></pre>
<p>看输出里有 <code>Active: active (running)</code>，说明启动成功。🧪 第五步：验证 socket 文件是否存在</p>
<pre><code>ls -l /var/run/containerd/containerd.sock
</code></pre>
<p>应该能看到类似：</p>
<pre><code>srw-rw---- 1 root root 0 Jul 6 22:06 /var/run/containerd/containerd.sock
</code></pre>
<p>如果没看到，说明 containerd 没真正运行成功。</p>
<h2 id="🧱-第六步：重新执行-kubeadm-init"><a href="#🧱-第六步：重新执行-kubeadm-init" class="headerlink" title="🧱 第六步：重新执行 kubeadm init"></a>🧱 第六步：重新执行 <code>kubeadm init</code></h2><pre><code>kubeadm init --kubernetes-version=1.28.2 \
  --apiserver-advertise-address=192.168.200.129 \
  --image-repository registry.aliyuncs.com/google_containers \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.244.0.0/16
</code></pre>
<p>若是token忘记了 可以执行直接生成一个新的<br><code>kubeadm token create --print-join-command</code></p>
<pre><code class="yam">[root@k8s-master calico]# kubeadm token create --print-join-command
kubeadm join 192.168.200.129:6443 --token jn3083.g1lz52mo680wiic9 --discovery-token-ca-cert-hash sha256:d03d798679d90f348b1cf7a1c12d5d1bfcbe2bd18e4a1aec97055b60c0f042ca
</code></pre>
<p>此时去从节点生成可能会有报错你这个错误说明当前节点（<code>k8s-node1</code>）<br><strong>之前已经执行过 <code>kubeadm join</code> 或者其他 kubeadm 相关操作，留下了配置文件或端口被占用</strong>，不能直接再次执行 <code>kubeadm join</code>。</p>
<hr>
<h3 id="❗报错详情分析："><a href="#❗报错详情分析：" class="headerlink" title="❗报错详情分析："></a>❗报错详情分析：</h3><pre><code>[ERROR FileAvailable--etc-kubernetes-kubelet.conf]: /etc/kubernetes/kubelet.conf already exists
[ERROR Port-10250]: Port 10250 is in use
[ERROR FileAvailable--etc-kubernetes-pki-ca.crt]: /etc/kubernetes/pki/ca.crt already exists
</code></pre>
<p>这些错误说明：</p>
<ul>
<li><code>/etc/kubernetes/kubelet.conf</code> 文件存在 —— 说明 kubelet 被配置过。</li>
<li><code>10250</code> 端口已被占用 —— kubelet 服务正在运行。</li>
<li><code>/etc/kubernetes/pki/ca.crt</code> 文件存在 —— 集群证书存在，可能是之前加入过失败或残留文件。</li>
</ul>
<hr>
<h3 id="✅-解决方法（清理残留再重新-join）："><a href="#✅-解决方法（清理残留再重新-join）：" class="headerlink" title="✅ 解决方法（清理残留再重新 join）："></a>✅ 解决方法（<strong>清理残留再重新 join</strong>）：</h3><p>你可以先在 node 节点执行 <strong>重置操作</strong>：</p>
<pre><code>kubeadm reset -f
</code></pre>
<p>然后再清理一下配置和 iptables 规则（可选但推荐）：</p>
<pre><code>rm -rf /etc/kubernetes/pki
rm -rf /etc/kubernetes/kubelet.conf
rm -rf /var/lib/kubelet/*
iptables -F
systemctl restart kubelet
</code></pre>
<p>然后重新执行你之前的 <code>kubeadm join</code> 命令：</p>
<pre><code>kubeadm join 192.168.200.129:6443 --token eoxdev.8tkpz5csc7x1mqgc \
        --discovery-token-ca-cert-hash sha256:6acf9c7e6c11bb973bd57404f9ec28b93ab5b48f8a50f0213bc389bbfb4bf68f
</code></pre>
<hr>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr>
<p>一切顺利的话，k8s 就能初始化成功了！</p>
<blockquote>
<p>Your Kubernetes control-plane has initialized successfully!</p>
<p>To start using your cluster, you need to run the following as a regular user:</p>
<p>  mkdir -p $HOME&#x2F;.kube<br>  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config<br>  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</p>
<p>Alternatively, if you are the root user, you can run:</p>
<p>  export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</p>
<p>You should now deploy a pod network to the cluster.<br>Run “kubectl apply -f [podnetwork].yaml” with one of the options listed at:<br>  <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<p>Then you can join any number of worker nodes by running the following on each as root:</p>
<p>kubeadm join 192.168.200.129:6443 –token zjoxjc.f58nh7lixocvjpgj <br>        –discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3<br>[root@k8s-master ~]#</p>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
        --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
</blockquote>
</blockquote>
<ul>
<li>按照它的提示逐步修改k8s配置文件     配置 <code>kubectl</code> 工具</li>
</ul>
<pre><code class="yaml">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<ul>
<li>安装Calico</li>
</ul>
<pre><code class="java">mkdir k8s
cd k8s
wget https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
// 上面的别用了 用这个新的
wget https://jiangstudy.online:8081/sources/calico.yaml
sed -i &#39;s/192.168.0.0/10.244.0.0/g&#39; calico.yaml  【改地址 分给prod的虚拟地址】

kubectl apply -f calico.yaml
</code></pre>
<p>或者ai说的</p>
<pre><code class="yaml"># 1. 创建工作目录
mkdir -p ~/k8s &amp;&amp; cd ~/k8s

# 2. 下载 Calico 清单文件（推荐使用最新版本，而非 v3.10）
wget https://docs.projectcalico.org/manifests/calico.yaml -O calico.yaml

# 3. 修改 POD CIDR（根据您的集群规划）
# 注意：必须与 kubeadm init 时指定的 --pod-network-cidr 一致
sed -i &#39;s|192.168.0.0/16|10.244.0.0/16|g&#39; calico.yaml

# 4. 部署 Calico
kubectl apply -f calico.yaml

# 5. 验证安装
kubectl get pods -n kube-system -w
</code></pre>
<ul>
<li>等待几分钟，查看所有Pod的状态，确保所有Pod都是Running状态</li>
</ul>
<p><code>kubectl get pod --all-namespaces -o wide</code></p>
<blockquote>
<p>你这个 <code>calico.yaml</code> 是 <strong>很老的版本 v3.10</strong>，其中用的是 <code>apiextensions.k8s.io/v1beta1</code>，<strong>早在 Kubernetes v1.22 中就被移除了</strong>，你现在用的是 <strong>Kubernetes 1.28</strong>，自然就出错了。</p>
<hr>
<h3 id="✅-正确做法：使用-Calico-官方支持-Kubernetes-v1-28-的最新-YAML"><a href="#✅-正确做法：使用-Calico-官方支持-Kubernetes-v1-28-的最新-YAML" class="headerlink" title="✅ 正确做法：使用 Calico 官方支持 Kubernetes v1.28 的最新 YAML"></a>✅ 正确做法：使用 Calico 官方支持 Kubernetes v1.28 的最新 YAML</h3><hr>
<p><code>https://docs.projectcalico.org/manifests/calico.yaml</code>浏览器访问然后去<code>/root/k8s</code>里面进行全部替换成新版本</p>
<h3 id="一键下载安装推荐版本："><a href="#一键下载安装推荐版本：" class="headerlink" title="一键下载安装推荐版本："></a>一键下载安装推荐版本：</h3><pre><code>curl https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml -O
</code></pre>
<blockquote>
<p>Calico v3.26 支持 Kubernetes v1.28，放心使用</p>
</blockquote>
<p>然后再修改 <code>Pod CIDR</code>：</p>
<pre><code>sed -i &#39;s/192.168.0.0/10.244.0.0/g&#39; calico.yaml
</code></pre>
<ol>
<li><strong>建议修改镜像源为阿里云（国内可拉取）</strong>：<br> 例如将以下几行（在 calico.yaml 中）：</li>
</ol>
<pre><code>image: calico/cni:v3.26.1
</code></pre>
<p>替换为：</p>
<pre><code>image: registry.cn-hangzhou.aliyuncs.com/chenby/calico_cni:v3.26.1
</code></pre>
<p>最后重新部署：</p>
<pre><code>kubectl apply -f calico.yaml
</code></pre>
<hr>
<h3 id="✅-检查-Calico-状态"><a href="#✅-检查-Calico-状态" class="headerlink" title="✅ 检查 Calico 状态"></a>✅ 检查 Calico 状态</h3><p>部署完大约 10~30 秒后执行：</p>
<pre><code>kubectl get pods -n kube-system
</code></pre>
<p>正常会看到 <code>calico-node</code> 和 <code>calico-kube-controllers</code> 都处于 <code>Running</code> 状态。</p>
<hr>
<hr>
<hr>
<h3 id="傻卵ai和scdn-查半天都没用-还不如B站up的方法-一遍通"><a href="#傻卵ai和scdn-查半天都没用-还不如B站up的方法-一遍通" class="headerlink" title="傻卵ai和scdn 查半天都没用 还不如B站up的方法[一遍通]"></a><span style="color:red"><strong>傻卵ai和scdn 查半天都没用 还不如B站up的方法<del>[一遍通]</del></strong></span></h3><p><a target="_blank" rel="noopener" href="https://jiangstudy.online/archives/kubernetes-calicozu-jian-de-an-zhuang">【kubernetes】Calico组件的安装-云途运维</a></p>
<p>以下步骤只在master01执行：相关的yaml已上传文件资源服务器，需要下载下来使用：</p>
<pre><code class="yaml">mkdir /root/calico &amp;&amp; cd /root/calico/
wget https://jiangstudy.online:8081/sources/calico.yaml
</code></pre>
<p>修改POD网段    说明：pod网段即为主机规划时的网段。</p>
<pre><code class="yaml">POD_SUBNET=`cat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep cluster-cidr= | awk -F= &#39;&#123;print $NF&#125;&#39;`

sed -i &quot;s#POD_CIDR#$&#123;POD_SUBNET&#125;#g&quot; calico.yaml
</code></pre>
<p>部署calico<br><code>kubectl apply -f calico.yaml</code></p>
<p>查看状态<br><code> kubectl get node</code><br><code>kubectl get pods -n kube-system -w</code></p>
</blockquote>
<h3 id="Slave节点需要完成"><a href="#Slave节点需要完成" class="headerlink" title="Slave节点需要完成"></a>Slave节点需要完成</h3><ul>
<li><p>让所有节点让集群环境</p>
<p>使用之前Master节点产生的命令加入集群</p>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token eoxdev.8tkpz5csc7x1mqgc \
        --discovery-token-ca-cert-hash sha256:6acf9c7e6c11bb973bd57404f9ec28b93ab5b48f8a50f0213bc389bbfb4bf68f
</code></pre>
</li>
<li><p>启动<code>kubelet</code></p>
<p><code>systemctl start kubelet</code> 启动<br><code>systemctl status kubelet</code> 查看状态</p>
</li>
<li><p>回到Master节点查看，如果Status全部为Ready，代表集群环境搭建成功！！！</p>
<p><code>kubectl get nodes</code></p>
</li>
</ul>
<blockquote>
<p>你的这个报错：</p>
<pre><code>validate service connection: CRI v1 runtime API is not implemented for endpoint &quot;unix:///var/run/containerd/containerd.sock&quot;
</code></pre>
<p>说明 <strong>containerd 的 CRI 接口没启用</strong>，这是因为你的 <code>/etc/containerd/config.toml</code> 配置不完整或者缺少必要字段。</p>
<hr>
<h2 id="✅-立即修复步骤如下："><a href="#✅-立即修复步骤如下：" class="headerlink" title="✅ 立即修复步骤如下："></a>✅ 立即修复步骤如下：</h2><h3 id="🔧-第一步：重新生成-config-toml-配置文件"><a href="#🔧-第一步：重新生成-config-toml-配置文件" class="headerlink" title="🔧 第一步：重新生成 config.toml 配置文件"></a>🔧 第一步：<strong>重新生成 config.toml 配置文件</strong></h3><pre><code>rm -f /etc/containerd/config.toml
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🛠️-第二步：修改配置启用-CRI-systemd-驱动"><a href="#🛠️-第二步：修改配置启用-CRI-systemd-驱动" class="headerlink" title="🛠️ 第二步：修改配置启用 CRI + systemd 驱动"></a>🛠️ 第二步：<strong>修改配置启用 CRI + systemd 驱动</strong></h3><pre><code>vim /etc/containerd/config.toml
</code></pre>
<p>找到这段：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
  SystemdCgroup = false
</code></pre>
<p>把 <code>false</code> 改成 <code>true</code>：</p>
<pre><code>SystemdCgroup = true
</code></pre>
<p>或者直接用命令修改：</p>
<pre><code>sed -i &#39;s/SystemdCgroup = false/SystemdCgroup = true/&#39; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🚀-第三步：重启-containerd"><a href="#🚀-第三步：重启-containerd" class="headerlink" title="🚀 第三步：重启 containerd"></a>🚀 第三步：<strong>重启 containerd</strong></h3><pre><code>systemctl daemon-reexec
systemctl restart containerd
systemctl status containerd
</code></pre>
<p>确认运行正常后：</p>
<pre><code>ls /var/run/containerd/containerd.sock
</code></pre>
<p>如果有输出说明 socket 正常，containerd 工作 OK。</p>
<hr>
<h3 id="🔁-第四步：再次执行-kubeadm-join"><a href="#🔁-第四步：再次执行-kubeadm-join" class="headerlink" title="🔁 第四步：再次执行 kubeadm join"></a>🔁 第四步：再次执行 kubeadm join</h3><pre><code>kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
  --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
<h4 id="如果重复导入节点报error"><a href="#如果重复导入节点报error" class="headerlink" title="如果重复导入节点报error"></a>如果重复导入节点报error</h4><p>你这个问题是由于 <strong><code>kubeadm join</code> 重复执行导致节点上已有残留的配置文件和端口占用</strong>，所以报错。</p>
<hr>
<hr>
<h2 id="✅-正确处理方式：重置-node-节点后重新-join"><a href="#✅-正确处理方式：重置-node-节点后重新-join" class="headerlink" title="✅ 正确处理方式：重置 node 节点后重新 join"></a>✅ 正确处理方式：<strong>重置 node 节点后重新 join</strong></h2><p>执行以下命令即可：</p>
<h3 id="1-重置-node-节点配置"><a href="#1-重置-node-节点配置" class="headerlink" title="1. 重置 node 节点配置"></a>1. <strong>重置 node 节点配置</strong></h3><pre><code>kubeadm reset -f
</code></pre>
<h3 id="2-清理-CNI-网络配置"><a href="#2-清理-CNI-网络配置" class="headerlink" title="2. 清理 CNI 网络配置"></a>2. <strong>清理 CNI 网络配置</strong></h3><pre><code>rm -rf /etc/cni/net.d
</code></pre>
<h3 id="3-重启相关服务"><a href="#3-重启相关服务" class="headerlink" title="3. 重启相关服务"></a>3. <strong>重启相关服务</strong></h3><pre><code>systemctl restart kubelet
systemctl restart containerd
</code></pre>
<h3 id="4-重新-join"><a href="#4-重新-join" class="headerlink" title="4. 重新 join"></a>4. <strong>重新 join</strong></h3><p>然后再执行你原来的 join 生成的命令即可：</p>
<pre><code>kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
  --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></blockquote>
<blockquote>
<p>[root@k8s-master k8s]# docker pull docker.io&#x2F;calico&#x2F;node:v3.26.1<br>v3.26.1: Pulling from calico&#x2F;node<br>c998069b4a7c: Downloading [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;   ]   81.5MB&#x2F;86.58MB<br>6cf92fa5251d: Download complete</p>
<p>[root@k8s-master k8s]# docker save docker.io&#x2F;calico&#x2F;node:v3.26.1 -o calico-node-v3.26.1.tar<br>[root@k8s-master k8s]# ctr images import –all-platforms calico-node-v3.26.1.tar<br>unpacking docker.io&#x2F;calico&#x2F;node:v3.26.1 (sha256:568fb25384d6460176b5528381a2d6fef36d110cfaddda5ae286afbf8fe15d5b)…done<br>[root@k8s-master k8s]# ctr images ls | grep calico&#x2F;node<br>docker.io&#x2F;calico&#x2F;node:v3.26.1 application&#x2F;vnd.docker.distribution.manifest.v2+json sha256:568fb25384d6460176b5528381a2d6fef36d110cfaddda5ae286afbf8fe15d5b 247.7 MiB linux&#x2F;arm64 -<br>[root@k8s-master k8s]# kubectl -n kube-system delete pod -l k8s-app&#x3D;calico-node</p>
<p>（你刚才就是 <code>calico_cni</code> 拉失败）</p>
<p>你可以用如下命令一口气替换：</p>
<pre><code>sed -i &#39;s@docker.io/calico/cni@registry.cn-hangzhou.aliyuncs.com/chenby/calico_cni@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/pod2daemon-flexvol@registry.cn-hangzhou.aliyuncs.com/chenby/calico_pod2daemon-flexvol@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/node@registry.cn-hangzhou.aliyuncs.com/chenby/calico_node@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/kube-controllers@registry.cn-hangzhou.aliyuncs.com/chenby/calico_kube-controllers@g&#39; calico.yaml
</code></pre>
<hr>
<h3 id="🔧-步骤四：重新部署"><a href="#🔧-步骤四：重新部署" class="headerlink" title="🔧 步骤四：重新部署"></a>🔧 步骤四：重新部署</h3><pre><code>kubectl apply -f calico.yaml
</code></pre>
</blockquote>
<blockquote>
<p>sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://docker.m.daocloud.io&quot;,&quot;https//p5lmkba8.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;]">https://docker.m.daocloud.io&quot;,&quot;https://p5lmkba8.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;]</a><br>}<br>EOF<br>————————————————</p>
<hr>
<hr>
<hr>
<h3 id="大坑：子节点的calico一直处于初始化无法启动解决方案"><a href="#大坑：子节点的calico一直处于初始化无法启动解决方案" class="headerlink" title="大坑：子节点的calico一直处于初始化无法启动解决方案"></a><span style="color:red"><strong>大坑：子节点的calico一直处于初始化无法启动解决方案</strong></span></h3><p>虽然都在，但关键是containerd配置是否默认用的是 <code>registry.k8s.io/pause:3.6</code> ，导致kubelet拉这个镜像时出错。</p>
<hr>
<p>请你检查并修改 <strong>containerd配置</strong>，明确指定 <code>sandbox_image</code> 用阿里云镜像：</p>
<pre><code>cat /etc/containerd/config.toml | grep sandbox_image
</code></pre>
<p>如果没设置，执行：</p>
<pre><code>containerd config default &gt; /etc/containerd/config.toml.backup
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<p>然后编辑 <code>/etc/containerd/config.toml</code>，找到 <code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</code> 部分，加入或修改为：</p>
<pre><code>sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.6&quot;
</code></pre>
<p>保存后，重启containerd：</p>
<pre><code>systemctl restart containerd
</code></pre>
<p>然后重启 kubelet：</p>
<pre><code>systemctl restart kubelet
</code></pre>
<hr>
<p>确认 <code>containerRuntimeEndpoint</code> 在 kubelet 配置文件或启动参数中有正确指向：</p>
<pre><code>containerRuntimeEndpoint: unix:///run/containerd/containerd.sock
</code></pre>
<hr>
<p>最后删除calico-node和kube-proxy pod，触发重新调度：</p>
<pre><code>kubectl -n kube-system delete pod -l k8s-app=calico-node
kubectl -n kube-system delete pod -l k8s-app=kube-proxy
</code></pre>
<p>然后观察节点状态和Pod状态。</p>
<p><code>kubectl get nodes</code> 查看节点状态<br><code>kubectl get pods -n kube-system -o wide</code> 查看pod状态</p>
<hr>
<p>总结：<br> <strong>确保 containerd 配置里的 sandbox_image 指向阿里云镜像，避免kubelet拉不到官方registry.k8s.io的镜像导致网络插件初始化失败，从而使节点一直NotReady。</strong></p>
<hr>
<hr>
<hr>
<h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><blockquote>
<p>calico-node-xb2js                          0&#x2F;1     CrashLoopBackOff   9 (4m12s ago)   25m   192.168.200.130   k8s-node1 </p>
</blockquote>
<h3 id="❗你的-k8s-node1-上-端口-9099-被-Nginx-占用了，而这个端口正是-Calico-默认用于健康检查的端口。"><a href="#❗你的-k8s-node1-上-端口-9099-被-Nginx-占用了，而这个端口正是-Calico-默认用于健康检查的端口。" class="headerlink" title="❗你的 k8s-node1 上 端口 9099 被 Nginx 占用了，而这个端口正是 Calico 默认用于健康检查的端口。"></a>❗你的 <code>k8s-node1</code> 上 <strong>端口 <code>9099</code> 被 Nginx 占用了</strong>，而这个端口正是 <code>Calico</code> 默认用于健康检查的端口。</h3><p>导致结果就是：</p>
<blockquote>
<p><code>calico-node</code> 启动失败并反复报错 <code>listen tcp 127.0.0.1:9099: bind: address already in use</code>，Pod 状态进入 <code>CrashLoopBackOff</code>。</p>
</blockquote>
<hr>
<h2 id="✅-解决方案"><a href="#✅-解决方案" class="headerlink" title="✅ 解决方案"></a>✅ 解决方案</h2><p>你可以选 <strong>其中一个方法</strong>：</p>
<hr>
<h3 id="✅-方案一：改-Nginx-的端口（推荐）"><a href="#✅-方案一：改-Nginx-的端口（推荐）" class="headerlink" title="✅ 方案一：改 Nginx 的端口（推荐）"></a>✅ <strong>方案一：改 Nginx 的端口（推荐）</strong></h3><ol>
<li><p>找到你的 <code>nginx</code> 配置文件（通常在 <code>vi /etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/conf.d/xxx.conf</code>）</p>
</li>
<li><p>修改 <code>listen 9877;</code> 为其他端口，比如 <code>listen 8081;</code></p>
</li>
<li><p>重启 nginx：</p>
<pre><code>systemctl restart nginx
</code></pre>
</li>
<li><p>删除重启 <code>calico-node</code> Pod：</p>
<pre><code>kubectl delete pod -n kube-system -l k8s-app=calico-node --field-selector spec.nodeName=k8s-node1
</code></pre>
</li>
<li><p>等待 Pod 变成 <code>Running</code> 状态。</p>
</li>
</ol>
</blockquote>
<h3 id="基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-下"><a href="#基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-下" class="headerlink" title="基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(下)"></a>基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(下)</h3><h4 id="安装和配置NFS文件共享服务器"><a href="#安装和配置NFS文件共享服务器" class="headerlink" title="安装和配置NFS文件共享服务器"></a>安装和配置NFS文件共享服务器</h4><h6 id="安装和配置-NFS"><a href="#安装和配置-NFS" class="headerlink" title="安装和配置 NFS"></a>安装和配置 NFS</h6><p>NFS（Network File System），它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。我们可以利用NFS共享Jenkins运行的配置文件、Maven的仓库依赖文件等</p>
<p>我们把NFS服务器安装在192.168.200.129机器上</p>
<ul>
<li><p>安装NFS服务（在所有K8S的节点都需要安装）</p>
<p><code>yum install -y nfs-utils</code> 【仅此这个都要运行】 </p>
</li>
<li><p>创建共享目录</p>
<pre><code class="yaml">mkdir -p /opt/nfs/jenkins
编写NFS的共享配置：
vi /etc/exports      
内容如下:  代表对所有IP都开放此目录，rw是读写
【no_root_suqash root用户生成的数据不做身份转换，也就原来是root，归root用户管理。权限太大实际需要评估】
/opt/nfs/jenkins    *(rw,no_root_squash)           
</code></pre>
</li>
<li><p>启动服务</p>
<pre><code class="yaml">systemctl enable nfs   开机启动
systemctl start nfs    启动
</code></pre>
</li>
<li><p>查看NFS共享目录</p>
<pre><code class="yaml">showmount -e 192.168.200.129
在这之前也要安装nfs服务：yum install -y nfs-utils
</code></pre>
<blockquote>
<p>[root@k8s-node1 ~]# showmount -e 192.168.200.129<br>Export list for 192.168.200.129:<br>&#x2F;opt&#x2F;nfs&#x2F;jenkins *</p>
</blockquote>
</li>
</ul>
<h3 id="在Kubernetes安装Jenkins-Master"><a href="#在Kubernetes安装Jenkins-Master" class="headerlink" title="在Kubernetes安装Jenkins-Master"></a>在Kubernetes安装Jenkins-Master</h3><h5 id="创建NFS-client-provisioner"><a href="#创建NFS-client-provisioner" class="headerlink" title="创建NFS client provisioner"></a>创建NFS client provisioner</h5><p>nfs-client-provisioner 是一个Kubernetes的简易NFS的外部provisioner，本身不提供NFS，需要现有 的NFS服务器提供存储。</p>
<ul>
<li><p>上传nfs-client-provisioner构建文件</p>
<p>把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\k8s-jenkins</code>的<code>jenkins-master</code>和<code>nfs-client</code>上传到129Jenkins虚拟机上面</p>
<blockquote>
<p>[root@k8s-master ~]# cd jenkins-master&#x2F;<br>[root@k8s-master jenkins-master]# ll<br>总用量 16<br>-rw-r–r– 1 root root 1874 7月   7 15:59 rbac.yaml<br>-rw-r–r– 1 root root   87 7月   7 15:59 ServiceaAcount.yaml<br>-rw-r–r– 1 root root  284 7月   7 15:59 Service.yaml      【对外暴露信息】<br>-rw-r–r– 1 root root 2116 7月   7 15:59 StatefulSet.yaml 【有状态应用】</p>
<p>[root@k8s-master ~]# cd nfs-client&#x2F;<br>[root@k8s-master nfs-client]# ll<br>总用量 12<br>-rw-r–r– 1 root root  225 7月   7 16:03 class.yaml<br>-rw-r–r– 1 root root  985 7月   7 16:03 deployment.yaml<br>-rw-r–r– 1 root root 1526 7月   7 16:03 rbac.yaml<br>[root@k8s-master nfs-client]# <code>vi deployment.yaml</code><br>修改里面的地址为主节点Jenkins的</p>
</blockquote>
</li>
<li><p>构建nfs-client-provisioner的pod资源</p>
<pre><code class="yaml">cd nfs-client
kubectl create -f .
</code></pre>
</li>
<li><p>查看pod是否创建成功<br><code>kubectl get pods</code></p>
<blockquote>
<p>[root@k8s-master nfs-client]# kubectl get pods<br>NAME                                      READY   STATUS              RESTARTS   AGE<br>nfs-client-provisioner-68cd5845b6-dqqm2   0&#x2F;1     ContainerCreating   0          15s</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><span style="color:red"><strong>这里也有个拉镜像的问题 deployment.yaml的lizhenliang&#x2F;nfs-client-provisioner:latest</strong></span></p>
<p>接下来操作步骤：</p>
<h3 id="1-修改你的-deployment-yaml-中的镜像字段，改成刚拉取的镜像："><a href="#1-修改你的-deployment-yaml-中的镜像字段，改成刚拉取的镜像：" class="headerlink" title="1. 修改你的 deployment.yaml 中的镜像字段，改成刚拉取的镜像："></a>1. 修改你的 <code>deployment.yaml</code> 中的镜像字段，改成刚拉取的镜像：</h3><pre><code>containers:
  - name: nfs-client-provisioner
    image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
    # 其他配置保持不变
</code></pre>
<p>确保 <code>env</code> 和 <code>volumes</code> 中 NFS 服务器地址及路径正确，和你之前确认的一致。</p>
<hr>
<h3 id="2-应用更新后的-Deployment-配置："><a href="#2-应用更新后的-Deployment-配置：" class="headerlink" title="2. 应用更新后的 Deployment 配置："></a>2. 应用更新后的 Deployment 配置：</h3><pre><code>kubectl apply -f deployment.yaml
</code></pre>
<hr>
<h3 id="3-查看-Pod-状态："><a href="#3-查看-Pod-状态：" class="headerlink" title="3. 查看 Pod 状态："></a>3. 查看 Pod 状态：</h3><pre><code>kubectl get pods -w
</code></pre>
<p>等待 Pod 状态变成 <code>Running</code> 和 <code>READY 1/1</code>。</p>
<blockquote>
<p>[root@k8s-master nfs-client]# kubectl get pods -w<br>NAME                                      READY   STATUS    RESTARTS   AGE<br>nfs-client-provisioner-7d79bcf5d4-tddhl   1&#x2F;1     Running   0          3m33s</p>
</blockquote>
<pre><code class="yaml">可用的deployment.yaml 位置在129机器的/root/nfs-client

apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: nfs-client-provisioner
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              value: 192.168.200.129 
            - name: NFS_PATH
              value: /opt/nfs/jenkins/
      volumes:
        - name: nfs-client-root
          nfs:
            server: 192.168.200.129
            path: /opt/nfs/jenkins/
</code></pre>
</blockquote>
<ul>
<li><p>返回<code>jenkins-master</code>目录</p>
<blockquote>
<p>[root@k8s-master ~]# cd jenkins-master&#x2F;<br>[root@k8s-master jenkins-master]#<br>[root@k8s-master jenkins-master]# <code>kubectl create namespace kube-ops</code><br>namespace&#x2F;kube-ops created<br>[root@k8s-master jenkins-master]# <code>kubectl create -f .</code><br>✅ 如果你只是想重新部署，可以改用 <code>kubectl apply -f .</code> （<strong>推荐</strong>，用于更新已有资源）</p>
<p>❌ 如果你要重新初始化，先删除旧资源：</p>
<pre><code>kubectl delete -f . &amp;&amp; kubectl create -f .
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<p><span style="color:red">这里报错因为有一些过时了的 需要更改 注意是在<code>/root/jenkins-master</code>中的rbac.yaml</span><br>你这个问题根源就是 apiVersion 使用了 <code>rbac.authorization.k8s.io/v1beta1</code>，新版 Kubernetes 不再支持这个版本了，必须改成 <code>rbac.authorization.k8s.io/v1</code>。</p>
<p>另外，你 <code>ClusterRole</code> 不应该带 <code>namespace</code> 字段，因为 ClusterRole 是集群级别的资源，不属于某个命名空间。</p>
<hr>
<p>我帮你改成符合最新标准的版本，注意几点：</p>
<ul>
<li>所有 <code>rbac.authorization.k8s.io/v1beta1</code> 改为 <code>rbac.authorization.k8s.io/v1</code></li>
<li>删除 <code>ClusterRole</code> 中的 <code>namespace</code></li>
<li>Role 和 RoleBinding 保留 <code>namespace: kube-ops</code></li>
<li>RoleBinding 和 ClusterRoleBinding 中的 <code>subjects</code> namespace 保持和 ServiceAccount 一致</li>
</ul>
<pre><code class="yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkins
  namespace: kube-ops
rules:
  - apiGroups: [&quot;extensions&quot;, &quot;apps&quot;]
    resources: [&quot;deployments&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;services&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/exec&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/log&quot;]
    verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;secrets&quot;]
    verbs: [&quot;get&quot;]

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkins
  namespace: kube-ops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: jenkins
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: kube-ops

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkinsClusterRole
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/exec&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/log&quot;]
    verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;secrets&quot;]
    verbs: [&quot;get&quot;]

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkinsClusterRoleBinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkinsClusterRole
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: kube-ops
</code></pre>
<p>保存后，用：</p>
<pre><code>kubectl apply -f rbac.yaml
</code></pre>
<p>应该就不会再报找不到资源类型的错误了。</p>
<blockquote>
<p>成功！！<br>service&#x2F;jenkins created<br>serviceaccount&#x2F;jenkins created<br>statefulset.apps&#x2F;jenkins created<br>role.rbac.authorization.k8s.io&#x2F;jenkins created<br>rolebinding.rbac.authorization.k8s.io&#x2F;jenkins created<br>clusterrole.rbac.authorization.k8s.io&#x2F;jenkinsClusterRole created<br>clusterrolebinding.rbac.authorization.k8s.io&#x2F;jenkinsClusterRoleBinding created</p>
</blockquote>
<hr>
<hr>
<p>输入<code>kubectl get pod --namespace kube-ops</code></p>
</blockquote>
<ul>
<li><blockquote>
<p>[root@k8s-master jenkins-master]# <code>kubectl get pod --namespace kube-ops</code><br>NAME        READY   STATUS    RESTARTS   AGE</p>
<p>[root@k8s-master jenkins-master]# <code>kubectl get service --namespace kube-ops</code><br>更详细的查看：<code>kubectl get service --namespace kube-ops -o wide</code><br>NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                          AGE<br>jenkins   NodePort   10.1.85.222   <none>        8080:30742&#x2F;TCP,50000:31261&#x2F;TCP   8m1s</p>
</blockquote>
</li>
</ul>
<blockquote>
<h3 id="如果不能running看这里！"><a href="#如果不能running看这里！" class="headerlink" title="如果不能running看这里！"></a><span style = "color:red">如果不能running看这里！</span></h3><p>你应该把 Deployment 里的镜像改成 <code>quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11</code>，这样 Pod 就能正常拉镜像启动了。</p>
<hr>
<h3 id="正确示例片段改成："><a href="#正确示例片段改成：" class="headerlink" title="正确示例片段改成："></a>正确示例片段改成：</h3><pre><code>containers:
  - name: nfs-client-provisioner
    image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
    volumeMounts:
      - name: nfs-client-root
        mountPath: /persistentvolumes
    env:
      - name: PROVISIONER_NAME
        value: fuseim.pri/ifs
      - name: NFS_SERVER
        value: 192.168.200.129
      - name: NFS_PATH
        value: /opt/nfs/jenkins/
volumes:
  - name: nfs-client-root
    nfs:
      server: 192.168.200.129
      path: /opt/nfs/jenkins/
</code></pre>
<hr>
<p>改完后执行：</p>
<pre><code>、kubectl apply -f deployment.yaml
kubectl delete pod -n default -l app=nfs-client-provisioner
kubectl get pods -n default -w
</code></pre>
<p>确认 Pod 快速启动且状态为 Running。</p>
<hr>
<p>这样 PVC 才能被正确绑定，<code>jenkins</code> 的 PVC Pending 状态才会解决。</p>
<hr>
<hr>
<hr>
<p>你这边已经非常接近解决了，目前的 <strong>唯一问题是 Provisioner 报了 <code>selfLink was empty, can&#39;t make reference</code> 的错误</strong>，这在 Kubernetes v1.20+ 中是<strong>常见兼容性问题</strong>，因为 <code>selfLink</code> 字段已经被弃用并默认禁用了。</p>
<hr>
<h2 id="✅-当前现状确认："><a href="#✅-当前现状确认：" class="headerlink" title="✅ 当前现状确认："></a>✅ 当前现状确认：</h2><table>
<thead>
<tr>
<th>项目</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>NFS 服务</td>
<td>正常可挂载 ✅</td>
</tr>
<tr>
<td>Jenkins PVC</td>
<td>一直 Pending ❌</td>
</tr>
<tr>
<td>Provisioner Pod 状态</td>
<td>Running ✅</td>
</tr>
<tr>
<td>Provisioner 日志报错</td>
<td><code>selfLink</code> ❌</td>
</tr>
<tr>
<td>StorageClass&#x2F;Provisioner 名</td>
<td>一致 ✅</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚨-问题根因"><a href="#🚨-问题根因" class="headerlink" title="🚨 问题根因"></a>🚨 问题根因</h2><p><code>nfs-client-provisioner</code> 的<strong>老版本</strong>依赖了 <code>selfLink</code> 字段，但你用的是 <strong>Kubernetes v1.28</strong>，从 v1.20 起 <code>selfLink</code> 默认禁用，导致：</p>
<pre><code>unexpected error getting claim reference: selfLink was empty, can&#39;t make reference
</code></pre>
<h3 id="✅-解决方案：用国内镜像源代替"><a href="#✅-解决方案：用国内镜像源代替" class="headerlink" title="✅ 解决方案：用国内镜像源代替"></a>✅ 解决方案：用国内镜像源代替</h3><p>我推荐你使用 阿里云加速镜像 或 [DockerHub 镜像代理]。下面我给你一份修改好的 <code>deployment.yaml</code>，使用了国内可访问的镜像仓库地址。</p>
<hr>
<h3 id="✅-修改后的-deployment-yaml（适配国内镜像源）"><a href="#✅-修改后的-deployment-yaml（适配国内镜像源）" class="headerlink" title="✅ 修改后的 deployment.yaml（适配国内镜像源）"></a>✅ 修改后的 <code>deployment.yaml</code>（适配国内镜像源）</h3><pre><code>yaml复制编辑apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: nfs-client-provisioner
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: registry.cn-hangzhou.aliyuncs.com/zhangshijie/nfs-subdir-external-provisioner:v4.0.2
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              value: 192.168.200.129
            - name: NFS_PATH
              value: /opt/nfs/jenkins/
      volumes:
        - name: nfs-client-root
          nfs:
            server: 192.168.200.129
            path: /opt/nfs/jenkins/
</code></pre>
<hr>
<h3 id="📌-操作步骤"><a href="#📌-操作步骤" class="headerlink" title="📌 操作步骤"></a>📌 操作步骤</h3><ol>
<li>把上面内容保存为 <code>deployment.yaml</code></li>
<li>应用并重建：</li>
</ol>
<pre><code>kubectl apply -f deployment.yaml
kubectl delete pod -n default -l app=nfs-client-provisioner
</code></pre>
<ol>
<li>然后检查 PVC 状态是否变成 <code>Bound</code>：</li>
</ol>
<pre><code>kubectl get pvc -n kube-ops
</code></pre>
<h3 id="这里是第二种方法-已尝试可行-！"><a href="#这里是第二种方法-已尝试可行-！" class="headerlink" title="这里是第二种方法[已尝试可行]！"></a><span style = "color:red">这里是第二种方法[已尝试可行]！</span></h3><p><code>/root/jenkins-master/</code></p>
<p>你贴出来的 <code>StatefulSet.yaml</code> 文件已经包含了镜像配置的位置！</p>
<hr>
<h3 id="🎯-问题就在这一段："><a href="#🎯-问题就在这一段：" class="headerlink" title="🎯 问题就在这一段："></a>🎯 问题就在这一段：</h3><pre><code>yaml复制编辑containers:
  - name: jenkins
    image: jenkins/jenkins:lts-alpine  👈 就是这行！！！
</code></pre>
<p>这个 <code>image:</code> 指定的镜像目前拉不下来（你刚才试图用的是阿里云镜像，结果不存在），所以你现在只需要 <strong>改成可用的镜像地址</strong>。</p>
<hr>
<h3 id="✅-推荐改法如下："><a href="#✅-推荐改法如下：" class="headerlink" title="✅ 推荐改法如下："></a>✅ 推荐改法如下：</h3><pre><code>yaml复制编辑containers:
  - name: jenkins
    image: jenkins/jenkins:lts-jdk17   # ✅ 推荐：可拉取的官方 Jenkins 镜像
    imagePullPolicy: IfNotPresent
</code></pre>
<blockquote>
<p>💡这是 Jenkins 官方最新稳定版本（带 JDK 17）的镜像，在 Docker Hub 可用，国内访问可能慢一点，但比你原来的阿里云镜像靠谱。</p>
</blockquote>
<hr>
<h3 id="🛠-修改步骤："><a href="#🛠-修改步骤：" class="headerlink" title="🛠 修改步骤："></a>🛠 修改步骤：</h3><ol>
<li><p>打开 <code>StatefulSet.yaml</code>：</p>
<pre><code>vim StatefulSet.yaml
</code></pre>
</li>
<li><p>找到：</p>
<pre><code>image: jenkins/jenkins:lts-alpine
</code></pre>
</li>
<li><p>改成：</p>
<pre><code>image: jenkins/jenkins:lts-jdk17
</code></pre>
</li>
<li><p>保存退出（按 <code>Esc</code> 然后输入 <code>:wq</code>）</p>
</li>
</ol>
<hr>
<h3 id="🔁-然后重新部署："><a href="#🔁-然后重新部署：" class="headerlink" title="🔁 然后重新部署："></a>🔁 然后重新部署：</h3><pre><code>kubectl apply -f StatefulSet.yaml
kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<blockquote>
<p>第二条命令是为了立刻让 Pod 使用新镜像重建。</p>
</blockquote>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          4s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          8s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          9s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          10s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          19s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          24s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          31s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          32s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS             RESTARTS   AGE jenkins-0   0&#x2F;1     ImagePullBackOff   0          47s [root@k8s-master jenkins-master]#</p>
</blockquote>
<p>很好，你的 Jenkins Pod 现在变成了：</p>
<pre><code>STATUS: ImagePullBackOff
</code></pre>
<hr>
<h2 id="✅-这说明你已经修改成功了，但节点还是拉不到镜像。"><a href="#✅-这说明你已经修改成功了，但节点还是拉不到镜像。" class="headerlink" title="✅ 这说明你已经修改成功了，但节点还是拉不到镜像。"></a>✅ <strong>这说明你已经修改成功了，但节点还是拉不到镜像。</strong></h2><p>我们确认下你用了哪个镜像，执行：</p>
<pre><code>kubectl get pod jenkins-0 -n kube-ops -o=jsonpath=&#39;&#123;.spec.containers[0].image&#125;&#39;
</code></pre>
<p>你应该看到输出类似于：</p>
<pre><code>jenkins/jenkins:lts-jdk17
</code></pre>
<p>然后我们来排查下一步。</p>
<hr>
<h2 id="🧭-下一步：去节点上测试能否手动拉取镜像"><a href="#🧭-下一步：去节点上测试能否手动拉取镜像" class="headerlink" title="🧭 下一步：去节点上测试能否手动拉取镜像"></a>🧭 下一步：去节点上测试能否手动拉取镜像</h2><p><strong>进入 <code>k8s-node1</code> 节点（Pod 分配在哪个节点，看 <code>kubectl describe pod</code> 可以看到）</strong>：</p>
<pre><code>ssh root@k8s-node1
</code></pre>
<p>在节点上运行：</p>
<pre><code>docker pull jenkins/jenkins:lts-jdk17
</code></pre>
<p>或者如果你用的是 <code>containerd</code> 作为容器运行时：</p>
<pre><code>ctr images pull docker.io/jenkins/jenkins:lts-jdk17
</code></pre>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# clear [root@k8s-master jenkins-master]# ll 总用量 16 -rw-r–r– 1 root root 1863 7月   7 16:39 rbac.yaml -rw-r–r– 1 root root   87 7月   7 15:59 ServiceaAcount.yaml -rw-r–r– 1 root root  284 7月   7 15:59 Service.yaml -rw-r–r– 1 root root 2117 7月   7 18:37 StatefulSet.yaml [root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          4s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          8s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          9s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          10s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          19s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          24s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          31s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          32s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS             RESTARTS   AGE jenkins-0   0&#x2F;1     ImagePullBackOff   0          47s [root@k8s-master jenkins-master]# ^C [root@k8s-master jenkins-master]# kubectl get pod jenkins-0 -n kube-ops -o&#x3D;jsonpath&#x3D;’{.spec.containers[0].image}’ jenkins&#x2F;jenkins:lts-jdk17[root@k8s-master jenkins-master]# ssh root@k8s-node1 The authenticity of host ‘k8s-node1 (192.168.200.130)’ can’t be established. ECDSA key fingerprint is SHA256:LMkCxwuWrKBih+Iy+lnayVkAyKdVG7JpVVR3TctpMuk. ECDSA key fingerprint is MD5:c1:76:72:fb:65:64:f8:d5:71:5b:38:a8:9b:07:a6:e6. Are you sure you want to continue connecting (yes&#x2F;no)? docker pull jenkins&#x2F;jenkins:lts-jdk17 Please type ‘yes’ or ‘no’: yes Warning: Permanently added ‘k8s-node1’ (ECDSA) to the list of known hosts. root@k8s-node1’s password: Permission denied, please try again. root@k8s-node1’s password: Last failed login: Mon Jul  7 18:39:33 CST 2025 from k8s-master on ssh:notty There was 1 failed login attempt since the last successful login. Last login: Mon Jul  7 17:36:26 2025 from 192.168.200.2 [root@k8s-node1 ~]# docker pull jenkins&#x2F;jenkins:lts-jdk17 lts-jdk17: Pulling from jenkins&#x2F;jenkins 0c01110621e0: Pull complete 2315362e4443: Pull complete 4185f63a4bf1: Pull complete 51c9d25ed578: Pull complete 10709260192c: Pull complete 474c0ab7c65d: Pull complete 62d5bb186774: Pull complete f1c4b8ee4b6f: Pull complete 065b78ceb30c: Pull complete b99138e4f420: Pull complete e05a8359c72d: Pull complete 981fa0afce25: Pull complete Digest: sha256:dd570585c3adadefcfbeba915e27bf7feca1815a0ea8a659d46b51f54fc7ea06 Status: Downloaded newer image for jenkins&#x2F;jenkins:lts-jdk17 [root@k8s-node1 ~]#</p>
</blockquote>
<p>太好了！你已经在 <code>k8s-node1</code> 节点上 <strong>成功拉下来了 Jenkins 的镜像</strong>：</p>
<pre><code>bash


复制编辑
✅ jenkins/jenkins:lts-jdk17 拉取成功！
</code></pre>
<hr>
<h3 id="❓但为什么-Pod-还是拉不到？"><a href="#❓但为什么-Pod-还是拉不到？" class="headerlink" title="❓但为什么 Pod 还是拉不到？"></a>❓但为什么 Pod 还是拉不到？</h3><p>Kubernetes 默认不会自动使用你用 <code>docker pull</code> 拉下来的镜像，除非你的 K8s 用的容器运行时 <strong>就是 Docker</strong>。</p>
<p>现在我们确认一下你的容器运行时是不是 Docker，执行下面的命令：</p>
<pre><code>bash


复制编辑
ps -ef | grep kubelet | grep -v grep
</code></pre>
<p>看结果里面有没有：</p>
<ul>
<li><code>--container-runtime=docker</code> ✅（说明用的是 Docker）</li>
<li>或者有 <code>containerd</code> 或 <code>cri-o</code> ❌（说明用的是 containerd，不会用 docker 拉的镜像）</li>
</ul>
<hr>
<h3 id="✅-如果你看到用的是-containerd（大概率是）"><a href="#✅-如果你看到用的是-containerd（大概率是）" class="headerlink" title="✅ 如果你看到用的是 containerd（大概率是）"></a>✅ 如果你看到用的是 <code>containerd</code>（大概率是）</h3><p>那你就需要把 Docker 拉下来的镜像导入给 <code>containerd</code> 用！</p>
<hr>
<h2 id="🔄-导入镜像到-containerd-的方法如下："><a href="#🔄-导入镜像到-containerd-的方法如下：" class="headerlink" title="🔄 导入镜像到 containerd 的方法如下："></a>🔄 导入镜像到 <code>containerd</code> 的方法如下：</h2><ol>
<li><strong>在 <code>k8s-node1</code> 节点上保存镜像为 tar 包：</strong></li>
</ol>
<pre><code>docker save jenkins/jenkins:lts-jdk17 -o jenkins.tar
</code></pre>
<ol>
<li><strong>用 <code>ctr</code> 命令导入给 containerd 使用：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images import jenkins.tar
</code></pre>
<ol>
<li><strong>验证 containerd 已经识别：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images ls | grep jenkins
</code></pre>
<p>你应该看到 <code>docker.io/jenkins/jenkins:lts-jdk17</code> 这一行。</p>
<hr>
<h2 id="🔁-然后重启-Pod："><a href="#🔁-然后重启-Pod：" class="headerlink" title="🔁 然后重启 Pod："></a>🔁 然后重启 Pod：</h2><pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<p>过一会再执行：</p>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>你现在在 <strong>master 节点（192.168.200.129）</strong>，但 Jenkins Pod 被调度到 <strong>node1 节点（192.168.200.130）</strong>，所以镜像必须在 node1 上可用。而你刚才是手动在 node1 上 <code>docker pull</code> 了 Jenkins 镜像，这一步做得 ✅<strong>没问题</strong>。</p>
<hr>
<h2 id="✅-问题核心确认"><a href="#✅-问题核心确认" class="headerlink" title="✅ 问题核心确认"></a>✅ 问题核心确认</h2><blockquote>
<p>你当前用的是 Kubernetes，但默认的容器运行时 <strong>不是 Docker，而是 containerd</strong>，所以：</p>
<p>❗ <strong>你用 <code>docker pull</code> 拉下的镜像 containerd 用不到</strong></p>
</blockquote>
<hr>
<h2 id="✅-解决方案：把-docker-镜像导入到-containerd-里"><a href="#✅-解决方案：把-docker-镜像导入到-containerd-里" class="headerlink" title="✅ 解决方案：把 docker 镜像导入到 containerd 里"></a>✅ 解决方案：把 docker 镜像导入到 containerd 里</h2><h3 id="在-node1-上（192-168-200-130）执行以下命令："><a href="#在-node1-上（192-168-200-130）执行以下命令：" class="headerlink" title="在 node1 上（192.168.200.130）执行以下命令："></a>在 node1 上（192.168.200.130）执行以下命令：</h3><ol>
<li><strong>把镜像导出为 tar 包</strong></li>
</ol>
<pre><code>docker save jenkins/jenkins:lts-jdk17 -o jenkins.tar
</code></pre>
<ol>
<li><strong>导入到 containerd：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images import jenkins.tar
</code></pre>
<ol>
<li><strong>检查 containerd 是否导入成功：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images ls | grep jenkins
</code></pre>
<p>你应该看到输出类似：</p>
<pre><code>docker.io/jenkins/jenkins:lts-jdk17 ...
</code></pre>
<hr>
<h2 id="🔄-然后，在-master-节点（192-168-200-129）上执行："><a href="#🔄-然后，在-master-节点（192-168-200-129）上执行：" class="headerlink" title="🔄 然后，在 master 节点（192.168.200.129）上执行："></a>🔄 然后，在 master 节点（192.168.200.129）上执行：</h2><pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<p>等 10~20 秒后看 Pod 是否启动成功：</p>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>看到状态变为：</p>
<pre><code>jenkins-0   1/1     Running
</code></pre>
<p>就说明一切 OK ✅！</p>
<p>你现在遇到的问题是：</p>
<blockquote>
<p>⚠️ <strong>在 <code>node1（130）</code> 节点上运行 <code>kubectl</code> 命令时，K8s API server 无法正常访问，提示 <code>the server could not find the requested resource</code>。</strong></p>
</blockquote>
<p>这是因为：<br> 👉 <code>kubectl</code> 命令只能在 <strong>已配置好 K8s 集群访问权限的节点上使用</strong>，通常是 <strong>master 节点（192.168.200.129）</strong>。</p>
<hr>
<h2 id="✅-正确操作流程如下："><a href="#✅-正确操作流程如下：" class="headerlink" title="✅ 正确操作流程如下："></a>✅ 正确操作流程如下：</h2><h3 id="🔁-你刚才在-node1-上导入-containerd-镜像已经成功了，现在："><a href="#🔁-你刚才在-node1-上导入-containerd-镜像已经成功了，现在：" class="headerlink" title="🔁 你刚才在 node1 上导入 containerd 镜像已经成功了，现在："></a>🔁 <strong>你刚才在 node1 上导入 containerd 镜像已经成功了</strong>，现在：</h3><ol>
<li><strong>返回到 master 节点（192.168.200.129）</strong></li>
<li><strong>执行删除 pod 的命令（由 master 控制）</strong>：</li>
</ol>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<ol>
<li><strong>查看 pod 状态：</strong></li>
</ol>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>你应该看到 <code>jenkins-0</code> 在 <code>node1</code> 上重新启动，并变成 <code>Running</code> 状态。</p>
<p>你现在正登录在 <strong>node1 节点（192.168.200.130）</strong>，而你的 <code>kubectl</code> 应该在 <strong>master 节点（192.168.200.129）</strong> 上执行。</p>
<hr>
<h3 id="✅-回到-master-节点的方法："><a href="#✅-回到-master-节点的方法：" class="headerlink" title="✅ 回到 master 节点的方法："></a>✅ 回到 master 节点的方法：</h3><p>只要你是通过 SSH 登录进来的，<strong>直接输入 <code>exit</code> 或按 <code>Ctrl+D</code></strong> 即可退出当前 SSH 会话，返回 master 节点：</p>
<pre><code>[root@k8s-node1 ~]# exit
</code></pre>
<p>或</p>
<pre><code>[root@k8s-node1 ~]# logout
</code></pre>
<p>然后你就会看到：</p>
<pre><code>[root@k8s-master ~]#
</code></pre>
<p>这时候你就在 master 节点上了！</p>
<hr>
<h3 id="🧠-提醒：kubectl-只能在-master-上执行"><a href="#🧠-提醒：kubectl-只能在-master-上执行" class="headerlink" title="🧠 提醒：kubectl 只能在 master 上执行"></a>🧠 提醒：kubectl 只能在 master 上执行</h3><p>比如这些命令：</p>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
kubectl get pods -n kube-ops
kubectl logs jenkins-0 -n kube-ops
</code></pre>
<p>都需要在 <strong>master 节点（192.168.200.129）</strong> 上执行，其他 node 节点默认是没有权限或 kubeconfig 配置的。</p>
<hr>
<p>现在你可以：</p>
<p>✅ 先退出 <code>node1</code>：</p>
<pre><code>exit
</code></pre>
<p>✅ 然后在 master 上执行：</p>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
kubectl get pod -n kube-ops -w
</code></pre>
<h4 id="成功！！！！"><a href="#成功！！！！" class="headerlink" title="成功！！！！"></a>成功！！！！</h4><blockquote>
<p>[root@k8s-master jenkins-master]# kubectl get pod -n kube-ops<br>NAME        READY   STATUS    RESTARTS   AGE<br>jenkins-0   1&#x2F;1     Running   0          7m39s<br>[root@k8s-master jenkins-master]#</p>
</blockquote>
</blockquote>
<ul>
<li><p>承接上文！！<br><code> kubectl get service --namespace kube-ops</code> 得到端口号</p>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl get service –namespace kube-ops<br>NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                          AGE<br>jenkins   NodePort   10.1.85.222   <none>        8080:30742&#x2F;TCP,50000:31261&#x2F;TCP   3h3m</p>
</blockquote>
<p>访问即可：<a target="_blank" rel="noopener" href="http://192.168.200.130:30742/">http://192.168.200.130:30742/</a><br>如何查密码？</p>
<blockquote>
<h5 id="解锁-Jenkins"><a href="#解锁-Jenkins" class="headerlink" title="解锁 Jenkins"></a>解锁 Jenkins</h5><p>为了确保管理员安全地安装 Jenkins，密码已写入到日志中（<a target="_blank" rel="noopener" href="https://www.jenkins.io/redirect/find-jenkins-logs">不知道在哪里？</a>）该文件在服务器上：</p>
<pre><code>/var/jenkins_home/secrets/initialAdminPassword
</code></pre>
<p>请从本地复制密码并粘贴到下面。</p>
<p>管理员密码：</p>
</blockquote>
<p><code>cd /opt/nfs/jenkins</code><br><code>ll</code><br><code>cd kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e </code><br><code> cd secrets</code><br><code>cat initialAdminPassword</code></p>
<blockquote>
<p>[root@k8s-master jenkins-master]# cd &#x2F;opt&#x2F;nfs<br>[root@k8s-master nfs]# ll<br>总用量 0<br>drwxr-xr-x 3 root root 86 7月   7 17:13 jenkins<br>[root@k8s-master nfs]# cd jenkins&#x2F;<br>[root@k8s-master jenkins]# ll<br>总用量 4<br>drwxrwxrwx 11 root root 4096 7月   7 19:10 kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e</p>
<p>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# ll<br>总用量 28<br>-rw-r–r–  1 sonar 1000 1663 7月   7 18:58 config.xml<br>-rw-r–r–  1 sonar 1000  216 7月   7 18:57 copy_reference_file.log<br>-rw-r–r–  1 sonar 1000  156 7月   7 18:58 hudson.model.UpdateCenter.xml<br>-rw-r–r–  1 sonar 1000  171 7月   7 18:55 jenkins.telemetry.Correlator.xml<br>drwxr-xr-x  2 sonar 1000    6 7月   7 18:55 jobs<br>-rw-r–r–  1 sonar 1000 1037 7月   7 18:58 nodeMonitors.xml<br>drwxr-xr-x  2 sonar 1000    6 7月   7 18:55 plugins<br>-rw-r–r–  1 sonar 1000  258 7月   7 18:57 queue.xml.bak<br>-rw-r–r–  1 sonar 1000   64 7月   7 18:55 secret.key<br>-rw-r–r–  1 sonar 1000    0 7月   7 18:55 secret.key.not-so-secret<br>drwx——  2 sonar 1000   91 7月   7 18:55 secrets<br>drwxr-xr-x  2 sonar 1000   67 7月   7 18:58 updates<br>drwxr-xr-x  2 sonar 1000   24 7月   7 18:55 userContent<br>drwxr-xr-x  3 sonar 1000   56 7月   7 18:55 users<br>drwxr-xr-x 10 sonar 1000  247 7月   7 18:55 war</p>
<p>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# ^C<br>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# cd secrets<br>[root@k8s-master secrets]# ll<br>总用量 12<br>-rw-r—– 1 sonar 1000  33 7月   7 18:55 initialAdminPassword<br>-rw-r–r– 1 sonar 1000  32 7月   7 18:55 jenkins.model.Jenkins.crumbSalt<br>-rw-r–r– 1 sonar 1000 256 7月   7 18:55 master.key<br>[root@k8s-master secrets]# <code>cat initialAdminPassword</code><br>7a2c40f15a564286aac63f61b9f20b95   【复制它去上面管理员密码解锁！！】</p>
</blockquote>
</li>
<li><p>创建管理员用户前选自选安装 → 无 → 账号：root   密码：panchunyao123<br>Jenkins URL：<a target="_blank" rel="noopener" href="http://192.168.200.130:30742/">http://192.168.200.130:30742/</a><br>这里面的插件和配置延续之前129机器上的</p>
<blockquote>
<p><code>cd /opt/nfs/jenkins/kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e/updates</code></p>
<p>输入[替换国内地址]：<code>sed -i &#39;s/http:\/\/updates.jenkins ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/ www.google.com/https:\/\/ www.baidu.com/g&#39; default.json</code></p>
<p>最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a><br>上面这个不行就按照老的来吧<br><a target="_blank" rel="noopener" href="https://updates.jenkins.io/update-center.json">https://updates.jenkins.io/update-center.json</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/restart">http://192.168.200.129:8888/restart</a> 重启Jenkins</p>
</blockquote>
</li>
<li><p>先安装基本的插件</p>
<ul>
<li>Localization:Chinese </li>
<li>Git </li>
<li>Pipeline </li>
<li>Extended Choice Parameter</li>
</ul>
</li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="Jenkins与Kubernetes整合"><a href="#Jenkins与Kubernetes整合" class="headerlink" title="Jenkins与Kubernetes整合"></a>Jenkins与Kubernetes整合</h3><h5 id="安装Kubernetes插件"><a href="#安装Kubernetes插件" class="headerlink" title="安装Kubernetes插件"></a>安装Kubernetes插件</h5><p>安装后 依次点击<code>Dashboard -&gt; 系统管理 -&gt; 云 -&gt; 新建云 -&gt; Kubernetes</code></p>
<blockquote>
<p>new cloud → cloud name：kubernetes     Type：kubernetes → create →<br>Kubernetes 地址：<a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a><br>命名空间：kube-ops<br>→ 连接测试 → Connected to Kubernetes v1.28.2<br>→ Jenkins URL地址： <a target="_blank" rel="noopener" href="http://jenkins.kube-ops.svc.cluster.local:8080/">http://jenkins.kube-ops.svc.cluster.local:8080</a><br>→ 应用 + 保存</p>
</blockquote>
<ul>
<li>kubernetes 地址采用了kube的服务器发现： <a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a> </li>
<li>namespace 填kube-ops，然后点击Test Connection，如果出现 Connection test successful 的提 示信息证明 Jenkins 已经可以和 Kubernetes 系统正常通信 </li>
<li>Jenkins URL  地址： <a target="_blank" rel="noopener" href="http://jenkins.kube-ops.svc.cluster.local:8080/">http://jenkins.kube-ops.svc.cluster.local:8080</a></li>
</ul>
<h4 id="构建Jenkins-Slave自定义镜像"><a href="#构建Jenkins-Slave自定义镜像" class="headerlink" title="构建Jenkins-Slave自定义镜像"></a>构建Jenkins-Slave自定义镜像</h4><ul>
<li>Jenkins-Master在构建Job的时候，Kubernetes会创建Jenkins-Slave的Pod来完成Job的构建。我们选择 运行Jenkins-Slave的镜像为官方推荐镜像：jenkins&#x2F;jnlp-slave:latest，但是这个镜像里面并没有Maven 环境，为了方便使用，我们需要自定义一个新的镜像：<br>先把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\k8s-jenkins</code>的<code>jenkins-slave</code>塞进129的<code>/root/</code>下</li>
</ul>
<blockquote>
<p>[root@k8s-master jenkins-slave]# ll<br>总用量 8948<br>-rw-r–r– 1 root root 9142315 7月   7 20:47 apache-maven-3.6.2-bin.tar.gz<br>-rw-r–r– 1 root root     556 7月   7 20:47 Dockerfile<br>-rw-r–r– 1 root root   10475 7月   7 20:47 settings.xml</p>
</blockquote>
<pre><code class="yaml"># Dockerfile

FROM jenkins/jnlp-slave:latest
MAINTAINER itcast

# 切换到 root 账户进行操作
USER root

# 安装 maven
COPY apache-maven-3.6.2-bin.tar.gz .

RUN tar -zxf apache-maven-3.6.2-bin.tar.gz &amp;&amp; \
    mv apache-maven-3.6.2 /usr/local &amp;&amp; \
    rm -f apache-maven-3.6.2-bin.tar.gz &amp;&amp; \
    ln -s /usr/local/apache-maven-3.6.2/bin/mvn /usr/bin/mvn &amp;&amp; \
    ln -s /usr/local/apache-maven-3.6.2 /usr/local/apache-maven &amp;&amp; \
    mkdir -p /usr/local/apache-maven/repo

COPY settings.xml /usr/local/apache-maven/conf/settings.xml

USER jenkins
</code></pre>
<ul>
<li><p>构建出一个新镜像：jenkins-slave-maven:latest<br><code>docker build -t jenkins-slave-maven:latest</code></p>
</li>
<li><p>然把镜像上传到Harbor的公共库library中</p>
<p>先打标签！<br><code> docker tag jenkins-slave-maven:latest 192.168.200.131:85/library/jenkins-slave-maven:latest</code><br>然后登录！<br><code> docker login -u admin -p Harbor12345 192.168.200.131:85</code></p>
</li>
</ul>
<blockquote>
<p>WARNING! Using –password via the CLI is insecure. Use –password-stdin. Error response from daemon: Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS client [root@k8s-master jenkins-slave]# docker login -u admin -p Harbor12345 192.168.200.131:85 WARNING! Using –password via the CLI is insecure. Use –password-stdin. Error response from daemon: Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS client [root@k8s-master jenkins-slave]#</p>
<p>你这个错误的根本原因是：<strong>Harbor 使用的是 HTTP 协议，而 Docker 默认使用 HTTPS</strong>，所以报错：</p>
<blockquote>
<pre><code>http: server gave HTTP response to HTTPS client
</code></pre>
</blockquote>
<hr>
<h2 id="✅-解决方案（分两步）："><a href="#✅-解决方案（分两步）：" class="headerlink" title="✅ 解决方案（分两步）："></a>✅ 解决方案（分两步）：</h2><hr>
<h3 id="🔧-第一步：允许-Docker-使用-HTTP-连接-Harbor（非安全模式）"><a href="#🔧-第一步：允许-Docker-使用-HTTP-连接-Harbor（非安全模式）" class="headerlink" title="🔧 第一步：允许 Docker 使用 HTTP 连接 Harbor（非安全模式）"></a>🔧 第一步：允许 Docker 使用 HTTP 连接 Harbor（非安全模式）</h3><h4 id="1️⃣-修改-Docker-配置文件-etc-docker-daemon-json"><a href="#1️⃣-修改-Docker-配置文件-etc-docker-daemon-json" class="headerlink" title="1️⃣ 修改 Docker 配置文件 /etc/docker/daemon.json"></a>1️⃣ 修改 Docker 配置文件 <code>/etc/docker/daemon.json</code></h4><pre><code>vi /etc/docker/daemon.json
</code></pre>
<p>添加（或修改）以下内容：</p>
<pre><code>&#123;
  &quot;insecure-registries&quot;: [&quot;192.168.200.131:85&quot;]
&#125;
</code></pre>
<p>如果已有其他配置，比如 <code>registry-mirrors</code>，合并在一个 JSON 对象内：</p>
<pre><code>&#123;
  &quot;registry-mirrors&quot;: [
    &quot;https://docker.m.daocloud.io&quot;,
    &quot;https://wy1u1ijg.mirror.aliyuncs.com&quot;,
    &quot;https://p5lmkba8.mirror.aliyuncs.com&quot;,
    &quot;https://registry.docker-cn.com&quot;
  ],
  &quot;insecure-registries&quot;: [
    &quot;192.168.200.131:85&quot;
  ]
&#125;
</code></pre>
<hr>
<h4 id="2️⃣-重启-Docker-服务"><a href="#2️⃣-重启-Docker-服务" class="headerlink" title="2️⃣ 重启 Docker 服务"></a>2️⃣ 重启 Docker 服务</h4><pre><code>systemctl daemon-reexec
systemctl restart docker
</code></pre>
<hr>
<h3 id="🧪-第二步：重新登录-Harbor"><a href="#🧪-第二步：重新登录-Harbor" class="headerlink" title="🧪 第二步：重新登录 Harbor"></a>🧪 第二步：重新登录 Harbor</h3><pre><code>docker login 192.168.200.131:85 -u admin -p Harbor12345
</code></pre>
<p>这时你不会再看到 HTTPS 报错了。</p>
</blockquote>
<ul>
<li><p>push镜像上harbor [Harbor] (<a target="_blank" rel="noopener" href="http://192.168.200.131:85/harbor/projects/1/repositories">http://192.168.200.131:85/harbor/projects/1/repositories</a>)<br><code> docker push 192.168.200.131:85/library/jenkins-slave-maven:latest</code></p>
<blockquote>
<p>[root@k8s-master jenkins-slave]# docker push 192.168.200.131:85&#x2F;library&#x2F;jenkins-slave-maven:latest<br>The push refers to repository [192.168.200.131:85&#x2F;library&#x2F;jenkins-slave-maven]<br>22c917fbd463: Pushed<br>9522f341fa42: Pushed<br>1656341ae8c3: Pushed<br>1a2dbe51b5d3: Pushed<br>ed059ff604cf: Pushed<br>4cb0baa801b1: Pushed<br>3f01ba93adcb: Pushed<br>3dee86c3d230: Pushed<br>5ccb7c9ecca8: Pushed<br>8a510d97a0f7: Pushed<br>3f948fda930d: Pushed<br>cf7a8ba4ff71: Pushed<br>4e006334a6fd: Pushed<br>latest: digest: sha256:38043da78f22253730d941f110156b5130ecdb416fc13b52157d402bbf32f0b4 size: 3046</p>
</blockquote>
</li>
</ul>
<h3 id="测试Jenkins-Slave是否可以创建"><a href="#测试Jenkins-Slave是否可以创建" class="headerlink" title="测试Jenkins-Slave是否可以创建"></a>测试Jenkins-Slave是否可以创建</h3><p>去子节点的Jenkins创建一个item：<code>test_jenkins_slave</code> 是流水线项目<br>一定要在流水线上告诉Jenkins是放在从节点上的！</p>
<h5 id="Pipeline-scipt"><a href="#Pipeline-scipt" class="headerlink" title="Pipeline scipt"></a>Pipeline scipt</h5><pre><code class="yaml">// git 的 URL 和 凭证ID
def git_address = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
def git_auth = &quot;630eed58-d62f-4c1b-bf96-1cf9c92a7f36&quot;

// 正确使用 podTemplate 包裹 node
podTemplate(label: &#39;jenkins-slave&#39;, cloud: &#39;kubernetes&#39;, containers: [
    containerTemplate(
        name: &#39;jnlp&#39;,
        image: &quot;192.168.200.131:85/library/jenkins-slave-maven:latest&quot;,
        ttyEnabled: true,
        command: &#39;/bin/sh&#39;
    )
]) &#123;
    node(&quot;jenkins-slave&quot;) &#123;
        stage(&#39;拉取代码&#39;) &#123;
            checkout scmGit(
                branches: [[name: &quot;master&quot;]],
                extensions: [],
                userRemoteConfigs: [[
                    credentialsId: &quot;$&#123;git_auth&#125;&quot;,
                    url: &quot;$&#123;git_address&#125;&quot;
                ]]
            )
        &#125;
    &#125;
&#125;
</code></pre>
<p>然后点击构建 就会在从节点进行创建 此时去看<code>Dashboard → 系统管理 → 节点和云管理</code>的时候就会多一个刚刚自主创建的节点 <strong>快速创建 并快速回收</strong>！！</p>
<h4 id="Jenkins-Kubernetes-Docker完成微服务持续集成"><a href="#Jenkins-Kubernetes-Docker完成微服务持续集成" class="headerlink" title="Jenkins+Kubernetes+Docker完成微服务持续集成"></a>Jenkins+Kubernetes+Docker完成微服务持续集成</h4><h5 id="拉取代码，构建镜像"><a href="#拉取代码，构建镜像" class="headerlink" title="拉取代码，构建镜像"></a>拉取代码，构建镜像</h5><ul>
<li><p>创建NFS共享目录</p>
<p>让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录</p>
<pre><code class="yaml">vi /etc/exports
添加内容：
/opt/nfs/jenkins   *(rw,no_root_squash) 
/opt/nfs/maven     *(rw,no_root_squash) 
systemctl restart nfs   重启NFS
</code></pre>
<blockquote>
<p>[root@k8s-node1 ~]# showmount -e 192.168.200.129<br>Export list for 192.168.200.129:<br>&#x2F;opt&#x2F;nfs&#x2F;maven   *              【maven仓库实现共享】<br>&#x2F;opt&#x2F;nfs&#x2F;jenkins *<br>[root@k8s-node1 ~]#</p>
</blockquote>
</li>
<li><p>创建项目，编写构建Pipeline</p>
<pre><code class="yaml">// git 的 URL 和 凭证ID
def git_address = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
def git_auth = &quot;630eed58-d62f-4c1b-bf96-1cf9c92a7f36&quot;
//构建版本的名称
def tag = &quot;latest&quot;
 //Harbor私服地址
def harbor_url = &quot;192.168.200.131:85&quot;
 //Harbor的项目名称
def harbor_project_name = &quot;tensquare&quot;
 //Harbor的凭证
def harbor_auth = &quot;f82340a4-5173-40e3-bc76-602db3a5acf5&quot;

podTemplate(
    label: &#39;jenkins-slave&#39;,
    cloud: &#39;kubernetes&#39;,
    containers: [
        containerTemplate(
            name: &#39;jnlp&#39;,
            image: &quot;192.168.200.131:85/library/jenkins-slave-maven:latest&quot;
        ),
        containerTemplate(
            name: &#39;docker&#39;,
            image: &quot;docker:stable&quot;,
            ttyEnabled: true,
            command: &#39;cat&#39;
        )
    ],
    volumes: [
        hostPathVolume(
            mountPath: &#39;/var/run/docker.sock&#39;,
            hostPath: &#39;/var/run/docker.sock&#39;
        ),
        nfsVolume(
            mountPath: &#39;/usr/local/apache-maven/repo&#39;,
            serverAddress: &#39;192.168.200.129&#39;,
            serverPath: &#39;/opt/nfs/maven&#39;
        )
    ]
) &#123;
    node(&quot;jenkins-slave&quot;) &#123;
        stage(&#39;拉取代码&#39;) &#123;
            checkout scmGit(
                branches: [[name: &quot;master&quot;]],
                extensions: [],
                userRemoteConfigs: [[
                    credentialsId: &quot;$&#123;git_auth&#125;&quot;,
                    url: &quot;$&#123;git_address&#125;&quot;
                ]]
            )
        &#125;

        stage(&#39;编译，安装公共子工程&#39;) &#123;
            sh &quot;mvn -f tensquare_common clean install&quot;
        &#125;

        stage(&#39;构建镜像，部署项目&#39;) &#123;
            // 把选择的项目信息转为数组
            def selectedProjects = &quot;$&#123;project_name&#125;&quot;.split(&#39;,&#39;)

            for (int i = 0; i &lt; selectedProjects.size(); i++) &#123;
                // 取出每个项目的名称和端口
                def currentProject = selectedProjects[i]
                def currentProjectName = currentProject.split(&#39;@&#39;)[0]
                def currentProjectPort = currentProject.split(&#39;@&#39;)[1]
                def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

                // 编译，构建本地镜像
                sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

                container(&#39;docker&#39;) &#123;
                    // 给镜像打标签
                    sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;

                    // 登录 Harbor，并上传镜像
                    withCredentials([usernamePassword(
                        credentialsId: &quot;$&#123;harbor_auth&#125;&quot;,
                        passwordVariable: &#39;password&#39;,
                        usernameVariable: &#39;username&#39;
                    )]) &#123;
                        sh &quot;docker login -u $&#123;username&#125; -p $&#123;password&#125; $&#123;harbor_url&#125;&quot;
                        sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
                    &#125;

                    // 删除本地镜像
                    sh &quot;docker rmi -f $&#123;imageName&#125;&quot;
                    sh &quot;docker rmi -f $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>勾选<code>参数化构建过程</code> → <code>Extended Choice Parameter</code>和之前的一样 可回看<code>tensquare_eureka_server@10086,tensquare_zuul@10020,tensquare_admin_service@9001,tensquare_gathering@9002</code></p>
</li>
</ul>
<h5 id="安装Kubernetes-Continuous-Deploy插件-Kubernetes-CLI插件-Kubernetes-Credentials-Provider"><a href="#安装Kubernetes-Continuous-Deploy插件-Kubernetes-CLI插件-Kubernetes-Credentials-Provider" class="headerlink" title="安装Kubernetes Continuous Deploy插件 || Kubernetes CLI插件 || Kubernetes Credentials Provider"></a>安装Kubernetes Continuous Deploy插件 || Kubernetes CLI插件 || Kubernetes Credentials Provider</h5><ul>
<li><p>修改后的流水线脚本</p>
<pre><code class="yaml">// 这里是在全局凭证添加后点进去可以查看ID
dsf k8s_auth = &quot;xxxxxxxxx&quot;
// 定义k8s-harbor的凭证
def secret_name = &quot;registry-auth-secret&quot;
...
...
def deploy_image_name = &quot;$&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
 //部署到K8S
 sh &quot;&quot;&quot;
 sed -i &#39;s#\$IMAGE_NAME#$&#123;deploy_image_name&#125;#&#39; 
$&#123;currentProjectName&#125;/deploy.yml
 sed -i &#39;s#\$SECRET_NAME#$&#123;secret_name&#125;#&#39; 
$&#123;currentProjectName&#125;/deploy.yml
 &quot;&quot;&quot;
 kubernetesDeploy configs: &quot;$&#123;currentProjectName&#125;/deploy.yml&quot;, 
kubeconfigId: &quot;$&#123;k8s_auth&#125;&quot;
</code></pre>
</li>
<li><p>去Jenkins的凭证里加k8s凭证</p>
<blockquote>
<h2 id="❗Credentials-from-Kubernetes-Secrets-will-not-be-available"><a href="#❗Credentials-from-Kubernetes-Secrets-will-not-be-available" class="headerlink" title="❗Credentials from Kubernetes Secrets will not be available"></a>❗<code>Credentials from Kubernetes Secrets will not be available</code></h2><h3 id="🧠-说明："><a href="#🧠-说明：" class="headerlink" title="🧠 说明："></a>🧠 说明：</h3><ul>
<li>这个警告说明 Jenkins 无法通过 Kubernetes 插件从 <code>Secret</code> 里加载凭证。</li>
<li>通常是以下原因之一：<ul>
<li><strong>Pod 没有挂载正确的 ServiceAccount &#x2F; RBAC 不够</strong></li>
<li>缺少 <code>Kubernetes Credentials Provider Plugin</code></li>
<li>没有开启 K8s secret credential provider 功能</li>
</ul>
</li>
</ul>
<h3 id="✅-解决方案："><a href="#✅-解决方案：" class="headerlink" title="✅ 解决方案："></a>✅ 解决方案：</h3><ol>
<li><p>确保你安装了插件：</p>
<ul>
<li><code>Kubernetes</code></li>
<li><code>Kubernetes Credentials Provider</code></li>
</ul>
</li>
<li><p>配置 Jenkins Deployment 的 ServiceAccount 具备权限，绑定如下 ClusterRole：</p>
</li>
<li><p>你可以给 Jenkins 的 ServiceAccount 绑定一个 <code>ClusterRole</code> 来读取 secrets：<br><code>/root/jenkins-master/</code>的<code>ServiceaAcount.yaml</code></p>
<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: kube-ops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-read-secrets
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: ServiceAccount
  name: jenkins
  namespace: kube-ops
</code></pre>
<blockquote>
<p>👆这会给 <code>jenkins</code> 账户授予读取所有 namespace 的 <code>secret</code> 权限。</p>
</blockquote>
<p>将上面内容保存为 <code>jenkins-rbac.yaml</code>，然后执行：</p>
<pre><code class="yaml">kubectl apply -f jenkins-rbac.yaml
</code></pre>
</li>
</ol>
</blockquote>
</li>
<li><p>添加凭证 → 类型<code>Kubernetes configuration(kubeconfig)</code>；范围全局；描述k8s-auth；Kubeconfig选择<code>Enter directly</code>这里面的密钥要去 129Jenkins机器上拿<br><code>cd /root/.kube</code> → <code>cat config</code> 显示的内容全部原封不动的复制到那里面</p>
</li>
<li><p>在每个项目下建立deploy.xml</p>
<h6 id="Eureka的deply-yml"><a href="#Eureka的deply-yml" class="headerlink" title="Eureka的deply.yml"></a>Eureka的deply.yml</h6><pre><code class="yaml">---
apiVersion: v1
kind: Service
metadata:
  name: eureka
  labels:
    app: eureka
spec:
  type: NodePort
  ports:
    - port: 10086
      name: eureka
      targetPort: 10086
  selector:
    app: eureka
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: eureka
spec:
  serviceName: &quot;eureka&quot;
  replicas: 2
  selector:
    matchLabels:
      app: eureka
  template:
    metadata:
      labels:
        app: eureka
    spec:
      imagePullSecrets:
        - name: $SECRET_NAME
      containers:
        - name: eureka
          image: $IMAGE_NAME
          ports:
            - containerPort: 10086
          env:
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: EUREKA_SERVER
              value: &quot;http://eureka-0.eureka:10086/eureka/,http://eureka-1.eureka:10086/eureka/&quot;
            - name: EUREKA_INSTANCE_HOSTNAME
              value: $&#123;MY_POD_NAME&#125;.eureka
  podManagementPolicy: &quot;Parallel&quot;
</code></pre>
<p>其他项目的deploy.yml主要把名字和端口修改：</p>
<h6 id="zuul的deploy-yml"><a href="#zuul的deploy-yml" class="headerlink" title="zuul的deploy.yml"></a>zuul的deploy.yml</h6><pre><code class="yaml">---
apiVersion: v1
kind: Service
metadata:
  name: zuul
  labels:
    app: zuul
spec:
  type: NodePort
  ports:
    - port: 10020
      name: zuul
      targetPort: 10020
  selector:
    app: zuul
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: zuul
spec:
  serviceName: &quot;zuul&quot;
  replicas: 2
  selector:
    matchLabels:
      app: zuul
  template:
    metadata:
      labels:
        app: zuul
    spec:
      imagePullSecrets:
        - name: $SECRET_NAME
      containers:
        - name: zuul
          image: $IMAGE_NAME
          ports:
            - containerPort: 10020
  podManagementPolicy: &quot;Parallel&quot;
</code></pre>
</li>
<li><p>还要在流水线定义k8s-harbor的凭证<br>生成Docker凭证  Docker凭证，用于Kubernetes到Docker私服拉取镜像</p>
<blockquote>
<p>docker login -u itcast -p Itcast123 192.168.66.102:85     登录Harbor </p>
<p>kubectl create secret docker-registry registry-auth-secret  –docker server&#x3D;192.168.200.131:85 –docker-username&#x3D;itcast –docker-password&#x3D;Itcast123 – docker-email&#x3D;<a href="mailto:&#105;&#x74;&#x63;&#x61;&#115;&#116;&#64;&#105;&#116;&#x63;&#97;&#x73;&#x74;&#x2e;&#x63;&#110;">&#105;&#x74;&#x63;&#x61;&#115;&#116;&#64;&#105;&#116;&#x63;&#97;&#x73;&#x74;&#x2e;&#x63;&#110;</a>    生成 </p>
<p>kubectl get secret    查看密钥</p>
</blockquote>
</li>
<li><p>项目构建后，查看服务创建情况</p>
<blockquote>
<p>kubectl get pods -owide<br>kubectl get service</p>
</blockquote>
</li>
</ul>
<h4 id="启动命令总结"><a href="#启动命令总结" class="headerlink" title="启动命令总结"></a>启动命令总结</h4><pre><code class="java">[192.168.200.132]GitLab：gitlab-ctl restart 
[192.168.200.131]Tomcat：/opt/tomcat/bin/startup.sh

[192.168.200.129]Jenkins：/systemctl start jenkins
[192.168.200.129]SonarQube：sudo -u sonarqube /opt/sonar/bin/linux-x86-64/sonar.sh restart
</code></pre>
<h4 id="2025-7-8-0-02-完结撒花★-°-☆-￣▽￣-x2F-°★-。"><a href="#2025-7-8-0-02-完结撒花★-°-☆-￣▽￣-x2F-°★-。" class="headerlink" title="2025.7.8  0:02   完结撒花★,°:.☆(￣▽￣)&#x2F;$:.°★ 。"></a><span style = "color:red">2025.7.8  0:02   完结撒花<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。</span></h4>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2025/06/15/后端/Jenkins/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/03/30/AI/OpenCV/">
        <h2>
            OpenCV
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/3/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="图形相关处理"><a href="#图形相关处理" class="headerlink" title="图形相关处理"></a>图形相关处理</h4><p>OpenCV是应用广泛的开源图像处理库，我们以其为基础，介绍相关的图像处理方法:包括基本的图像处理方法:几何变换，形态学变换，围伦平滑，直方围操作，板匹配，霍夫变换等；特征提取和描述方法：理解角点特征，Harris和Shi-TomaS算法，SIFT&#x2F;SURF算法，Fast算法，ORB算法等；还有OpenCV在视频操作中的应用，最后的案例是使用OpenCV进行人险检测。</p>
<p>在第一次世界大战后，1921年美国科学家发明了BartlaneSystem，并从伦敦传到纽约传输了第一幅数字图像，其亮度用离散数值表示，:将图片编码成5个灰度级，如下图所示，通过海底电缆进行传输。在发送端图片被编码并使用打孔带记录，通过系统传输后在接收方使用特殊的打印机恢复成图像。</p>
<p>1950年左右，计算机被发明，数字图像处理学科正式诞生</p>
<h6 id="位数"><a href="#位数" class="headerlink" title="位数"></a>位数</h6><p>计算机采用0&#x2F;1编码的系统，数字图像也是利用0&#x2F;1来记录信息，我们平常接触的图像都是8位数图像，包含0~255灰度，其中0，代表最黑，1，表示最白。</p>
<h6 id="二值图像"><a href="#二值图像" class="headerlink" title="二值图像:"></a>二值图像:</h6><p>一幅二值图像的二维矩阵仅由0、1两个值构成，“0”代表黑色，“1”代白色。由于每一像素(矩阵中每一元素)取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别(OCR)和掩膜图像的存储，</p>
<h6 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图:"></a>灰度图:</h6><p>每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色;但是，灰度图像在黑色与白色之间还有许多级的颜色深度。灰度图像经常是在单个电磁波频谱如可见光内测量每个像素的亮度得到的，用于显示的灰度图像通常用每个采样像素8位的非线性尺度来保存，这样可以有256级灰度(如果用16位，则有65536级)。</p>
<h6 id="彩色图"><a href="#彩色图" class="headerlink" title="彩色图:"></a>彩色图:</h6><p>每个像素通常是由红(R)、绿(G)、蓝(B)三个分量来表示的，分量介干(0，255)。RGB图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红(R)、绿(G)、蓝(B)三原色的组合来表示每个像素的颜色。但与索引图像不同的是，RGB图像每一个像素的颜色值(由RGB三原色表示)直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个MxN的二维矩阵分别表示各个像素的R、G、B三个颜色分量。RGB图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像。</p>
<h6 id="1-图像是什么"><a href="#1-图像是什么" class="headerlink" title="1. 图像是什么"></a>1. 图像是什么</h6><p>图：物体反射或透射光的分布<br>像：人的视觉系统所接受的图在人脑中所形版的印象或认识</p>
<h6 id="2-模拟图像和数字图像"><a href="#2-模拟图像和数字图像" class="headerlink" title="2. 模拟图像和数字图像"></a>2. 模拟图像和数字图像</h6><p>模拟图像：连续存储的数据<br>数字图像：分级存储的数据</p>
<h6 id="3-数字图像"><a href="#3-数字图像" class="headerlink" title="3. 数字图像"></a>3. 数字图像</h6><p>位数:图像的表示，常见的就是8位分类：二值图像，灰度图像和彩色图像</p>
<h5 id="OpenCV的优势"><a href="#OpenCV的优势" class="headerlink" title="OpenCV的优势:"></a>OpenCV的优势:</h5><h6 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1. 编程语言"></a>1. 编程语言</h6><p>OpenCV基于C++实现，同时提供python,Ruby,Matlab等语言的接口。OpenCV-Python是OpenCV的Python API，结合了OpenCV C++ API和Python语言的最佳特性。</p>
<h6 id="2-跨平台"><a href="#2-跨平台" class="headerlink" title="2. 跨平台"></a>2. 跨平台</h6><p>可以在不同的系统平台上使用，包括Windows，Linux，OSX，Android和i0S。基于CUDA和OpenCl的高速GPU操作接口也在积极开发中</p>
<h6 id="3-活跃的开发团队"><a href="#3-活跃的开发团队" class="headerlink" title="3. 活跃的开发团队"></a>3. 活跃的开发团队</h6><h6 id="4-丰富的AP"><a href="#4-丰富的AP" class="headerlink" title="4. 丰富的AP!"></a>4. 丰富的AP!</h6><p>同时添加了对深度学习的支持。完善的传统计算机视觉算法，涵盖主流的机器学习算法，</p>
<h5 id="OpenCV-Python"><a href="#OpenCV-Python" class="headerlink" title="OpenCV-Python"></a>OpenCV-Python</h5><p>OpenCV-Python是一个Python绑定库，旨在解决计算机视觉问题。<br>Python是一种由Guido van Rossum开发的通用编程语言，它很快就变得非常流行，主要是因为它的简单性和代码可读性。它使程序员能够用更少的代码行表达思想，而不会降低可读性</p>
<p>与C&#x2F;C++等语言相比，Python速度较慢。也就是说，Python可以使用C&#x2F;C++轻松扩展，这使我们可以在C&#x2F;C++中编写计算密集型代码，并创建可用作Python模块的Python包装器。这给我们带来了两个好处:首先，代码与原始C&#x2F;C++代码一样快(因为它是在后台工作的实际C++代码)，其次，在Python中编写代码比使用C&#x2F;C++更容易。OpenCV-Python是原始OpenCVC++实现的Python包装器。</p>
<p>OpenCV-Python使用Numpy，这是一个高度优化的数据库操作库，具有MATLAB风格的语法。所有OpenCV数组结构都转换为Numpy数组。这也使得与使用Numpy的其他库(如SciPy和Matplotib)集成更容易。</p>
<h5 id="OpenCV部署方法"><a href="#OpenCV部署方法" class="headerlink" title="OpenCV部署方法"></a>OpenCV部署方法</h5><p>安装OpenCV之前需要先安装<code>numpy</code>, <code>matplotlibJ</code><br>创建Python虚拟环境cv,在cv中安装即可<br>先安装OpenCV-Python,由于一些经典的算法被申请了版权，新版本有很大的限制，所以选用3.4.3以下的版</p>
<h5 id="OpenCV模块简介"><a href="#OpenCV模块简介" class="headerlink" title="OpenCV模块简介"></a>OpenCV模块简介</h5><p>其中core、highgui、imgproc是最基础的模块，该课程主要是围绕这几个模块展开的，分别介绍如下:</p>
<ul>
<li><p><strong>core</strong>模块实现了最核心的数据结构及其基本运算，如绘图函数、数组操作相关函数等。</p>
</li>
<li><p><strong>highgui</strong>模块实现了视频与图像的读取、显示、存储等接口。</p>
</li>
<li><p><strong>imgproc</strong>模块实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、阈值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。</p>
<p>对于图像处理其他更高层次的方向及应用，penCV也有相关的模块实现</p>
</li>
<li><p><strong>features2d</strong>模块用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征</p>
</li>
<li><p><strong>objdetect</strong>模块实现了一些目标检测的功能，经典的基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification(级联分类)和Latent SVM等。</p>
</li>
<li><p><strong>stitching</strong>模块实现了图像拼接功能。</p>
</li>
<li><p><strong>FLANN</strong>模块(Fast Library for Approximate Nearest Neighbors)，包含快速近似最近邻搜索FLANN和聚类Clustering算法。</p>
</li>
<li><p><strong>mI</strong>模块机器学习模块(SVM，决策树，Boosting等等)</p>
</li>
<li><p><strong>photo</strong>模块包含图像修复和图像去噪两部分。</p>
</li>
<li><p><strong>video</strong>模块针对视频处理，如背景分离，前景检测、对象跟踪等。</p>
</li>
<li><p><strong>calib3d</strong>模块即Calibration(校准)3D，这个模块主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。</p>
</li>
<li><p><strong>G-API</strong>模块包含超高效的图像处理pipeline引整</p>
</li>
</ul>
<h5 id="OpenCV基本操作"><a href="#OpenCV基本操作" class="headerlink" title="OpenCV基本操作"></a>OpenCV基本操作</h5><p>本章主要介绍图像的基础操作，包括:</p>
<ul>
<li>图像的IO操作，读取和保存方法</li>
<li>在图像上绘制几何图形</li>
<li>怎么获取图像的属性</li>
<li>怎么访问图像的像素，进行通道分离，合并等</li>
<li>怎么实现颜色空间的变换</li>
<li>图像的算术运算</li>
</ul>
<h5 id="图像的基础操作"><a href="#图像的基础操作" class="headerlink" title="图像的基础操作"></a>图像的基础操作</h5><ul>
<li>掌握图像的读取和保存方法</li>
<li>能够使用OpenCV在图像上绘制几何图形</li>
<li>能够访问图像的像素</li>
<li>能够获取图像的属性，并进行通道的分离和合并</li>
<li>能够实现颜色空间的变换</li>
</ul>
<h1 id="图像的IO操作"><a href="#图像的IO操作" class="headerlink" title="图像的IO操作"></a>图像的IO操作</h1><p>这里我们会给大家介绍如何读取图像，如何显示图像和如何保存图像。</p>
<h2 id="1-1-读取图像"><a href="#1-1-读取图像" class="headerlink" title="1.1 读取图像"></a>1.1 读取图像</h2><ol>
<li>API</li>
</ol>
<pre><code class="python">cv.imread()
</code></pre>
<p>参数：</p>
<ul>
<li><p>要读取的图像</p>
</li>
<li><p>读取方式的标志</p>
<ul>
<li><p><code>cv.IMREAD*COLOR</code>：以<strong>彩色模式</strong>加载图像，任何图像的透明度都将被忽略。这是默认参数。</p>
</li>
<li><p><code>cv.IMREAD*GRAYSCALE</code>：以<strong>灰度模式</strong>加载图像</p>
</li>
<li><p><code>cv.IMREAD_UNCHANGED</code>：包括<strong>alpha通道</strong>的加载图像模式。</p>
<p><strong>可以使用1、0或者-1来替代上面三个标志</strong></p>
</li>
</ul>
</li>
<li><p>参考代码</p>
<pre><code class="python">import numpy as np
import cv2 as cv
# 以灰度图的形式读取图像
img = cv.imread(&#39;messi5.jpg&#39;,0)
</code></pre>
</li>
</ul>
<p><strong>注意：如果加载的路径有错误，不会报错，会返回一个None值</strong></p>
<h2 id="1-2显示图像"><a href="#1-2显示图像" class="headerlink" title="1.2显示图像"></a>1.2显示图像</h2><p>1 . API</p>
<pre><code class="python">cv.imshow()
</code></pre>
<p>参数：</p>
<ul>
<li>显示图像的窗口名称，以字符串类型表示</li>
<li>要加载的图像</li>
</ul>
<p><strong>注意：在调用显示图像的API后，要调用cv.waitKey()给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来</strong>。</p>
<p>另外我们也可使用matplotlib对图像进行展示。</p>
<ol>
<li><p>参考代码</p>
<pre><code class="python"># opencv中显示
cv.imshow(&#39;image&#39;,img)
cv.waitKey(0) # 永远的等待下去
# matplotlib中展示
plt.imshow(img[:,:,::-1])
</code></pre>
</li>
</ol>
<h2 id="1-3-保存图像"><a href="#1-3-保存图像" class="headerlink" title="1.3 保存图像"></a>1.3 保存图像</h2><ol>
<li><p>API</p>
<pre><code class="python">cv.imwrite()
</code></pre>
<p>参数：</p>
<ul>
<li>文件名，要保存在哪里</li>
<li>要保存的图像</li>
</ul>
</li>
<li><p>参考代码</p>
<pre><code class="python">cv.imwrite(&#39;messigray.png&#39;,img)
</code></pre>
</li>
</ol>
<h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><p>我们通过加载灰度图像，显示图像，如果按’s’并退出则保存图像，或者按ESC键直接退出而不保存。</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 读取图像
img = cv.imread(&#39;messi5.jpg&#39;,0)
# 2 显示图像
# 2.1 利用opencv展示图像
cv.imshow(&#39;image&#39;,img)
# 2.2 在matplotplotlib中展示图像【RGB通道】  后面要反转图像去显示
plt.imshow(img[:,:,::-1])
plt.title(&#39;匹配结果&#39;), plt.xticks([]), plt.yticks([])
plt.show()
k = cv.waitKey(0)
# 3 保存图像
cv.imwrite(&#39;messigray.png&#39;,img)
</code></pre>
<h1 id="2-绘制几何图形"><a href="#2-绘制几何图形" class="headerlink" title="2 绘制几何图形"></a>2 绘制几何图形</h1><h2 id="2-1-绘制直线"><a href="#2-1-绘制直线" class="headerlink" title="2.1 绘制直线"></a>2.1 绘制直线</h2><pre><code>cv.line(img,start,end,color,thickness)
</code></pre>
<p>参数：</p>
<ul>
<li>img:要绘制直线的图像</li>
<li>Start,end: 直线的起点和终点</li>
<li>color: 线条的颜色</li>
<li>Thickness: 线条宽度</li>
</ul>
<h2 id="2-2-绘制圆形"><a href="#2-2-绘制圆形" class="headerlink" title="2.2 绘制圆形"></a>2.2 绘制圆形</h2><pre><code class="python">cv.circle(img,centerpoint, r, color, thickness)
</code></pre>
<p>参数：</p>
<ul>
<li>img:要绘制圆形的图像</li>
<li>Centerpoint, r: 圆心和半径</li>
<li>color: 线条的颜色</li>
<li>Thickness: 线条宽度，为-1时生成闭合图案并填充颜色</li>
</ul>
<h2 id="2-3-绘制矩形"><a href="#2-3-绘制矩形" class="headerlink" title="2.3 绘制矩形"></a>2.3 绘制矩形</h2><pre><code class="python">cv.rectangle(img,leftupper,rightdown,color,thickness)
</code></pre>
<p>参数：</p>
<ul>
<li>img:要绘制矩形的图像</li>
<li>Leftupper, rightdown: 矩形的左上角和右下角坐标</li>
<li>color: 线条的颜色</li>
<li>Thickness: 线条宽度</li>
</ul>
<h2 id="2-4-向图像中添加文字"><a href="#2-4-向图像中添加文字" class="headerlink" title="2.4 向图像中添加文字"></a>2.4 向图像中添加文字</h2><pre><code class="python">cv.putText(img,text,station, font, fontsize,color,thickness,cv.LINE_AA)
</code></pre>
<p>参数：</p>
<ul>
<li>img: 图像</li>
<li>text：要写入的文本数据</li>
<li>station：文本的放置位置</li>
<li>font：字体</li>
<li>Fontsize :字体大小</li>
</ul>
<h2 id="2-5-效果展示"><a href="#2-5-效果展示" class="headerlink" title="2.5 效果展示"></a>2.5 效果展示</h2><p>我们生成一个全黑的图像，然后在里面绘制图像并添加文字</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 创建一个空白的图像
img = np.zeros((512,512,3), np.uint8)
# 2 绘制图形
cv.line(img,(0,0),(511,511),(255,0,0),5)
cv.rectangle(img,(384,0),(510,128),(0,255,0),3)
cv.circle(img,(447,63), 63, (0,0,255), -1)
font = cv.FONT_HERSHEY_SIMPLEX
cv.putText(img,&#39;OpenCV&#39;,(10,500), font, 4,(255,255,255),2,cv.LINE_AA)
# 3 图像展示
plt.imshow(img[:,:,::-1])
plt.title(&#39;匹配结果&#39;), plt.xticks([]), plt.yticks([])
plt.show()
</code></pre>
<h1 id="3-获取并修改图像中的像素点"><a href="#3-获取并修改图像中的像素点" class="headerlink" title="3 获取并修改图像中的像素点"></a>3 获取并修改图像中的像素点</h1><p>我们可以通过行和列的坐标值获取该像素点的像素值。对于BGR图像，它返回一个蓝，绿，红值的数组。对于灰度图像，仅返回相应的强度值。使用相同的方法对像素值进行修改。</p>
<pre><code class="python">import numpy as np
import cv2 as cv
img = cv.imread(&#39;messi5.jpg&#39;)
# 获取某个像素点的值
px = img[100,100]
# 仅获取蓝色通道的强度值
blue = img[100,100,0]
# 修改某个位置的像素值
img[100,100] = [255,255,255]
</code></pre>
<h1 id="4-获取图像的属性"><a href="#4-获取图像的属性" class="headerlink" title="4 获取图像的属性"></a>4 获取图像的属性</h1><p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p>
<h1 id="5-图像通道的拆分与合并"><a href="#5-图像通道的拆分与合并" class="headerlink" title="5 图像通道的拆分与合并"></a>5 图像通道的拆分与合并</h1><p>有时需要在B，G，R通道图像上单独工作。在这种情况下，需要将BGR图像分割为单个通道。或者在其他情况下，可能需要将这些单独的通道合并到BGR图像。你可以通过以下方式完成。</p>
<pre><code class="python"># 通道拆分
b,g,r = cv.split(img)
# 通道合并
img = cv.merge((b,g,r))
</code></pre>
<h1 id="6-色彩空间的改变"><a href="#6-色彩空间的改变" class="headerlink" title="6 色彩空间的改变"></a>6 色彩空间的改变</h1><p>OpenCV中有150多种颜色空间转换方法。最广泛使用的转换方法有两种，BGR↔Gray和BGR↔HSV。</p>
<p>API：</p>
<pre><code class="python">cv.cvtColor(input_image，flag)
</code></pre>
<p>参数：</p>
<ul>
<li>input_image: 进行颜色空间转换的图像</li>
<li>flag: 转换类型<ul>
<li><code>cv.COLOR_BGR2GRAY</code> : BGR↔Gray</li>
<li><code>cv.COLOR_BGR2HSV</code>: BGR→HSV</li>
</ul>
</li>
</ul>
<hr>
<p><strong>总结：</strong></p>
<ol>
<li><p>图像IO操作的API：</p>
<p><code>cv.imread()</code>: 读取图像</p>
<p><code>cv.imshow()</code>：显示图像</p>
<p><code>cv.imwrite()</code>: 保存图像</p>
</li>
<li><p>在图像上绘制几何图像</p>
<p><code>cv.line()</code>: 绘制直线</p>
<p><code>cv.circle()</code>: 绘制圆形</p>
<p><code>cv.rectangle()</code>: 绘制矩形</p>
<p><code>cv.putText()</code>: 在图像上添加文字</p>
</li>
<li><p>直接使用行列索引获取图像中的像素并进行修改</p>
</li>
<li><p>图像的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>API</th>
</tr>
</thead>
<tbody><tr>
<td>形状</td>
<td>img.shape</td>
</tr>
<tr>
<td>图像大小</td>
<td>img.size</td>
</tr>
<tr>
<td>数据类型</td>
<td>img.dtype</td>
</tr>
</tbody></table>
</li>
<li><p>拆分通道：cv.split()</p>
<p>通道合并：cv.merge()</p>
</li>
<li><p>色彩空间的改变</p>
<p>cv.cvtColor(input_image，flag)</p>
</li>
</ol>
<p>★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★</p>
<h5 id="Jupyter-Notebook增加临时环境"><a href="#Jupyter-Notebook增加临时环境" class="headerlink" title="Jupyter Notebook增加临时环境"></a>Jupyter Notebook增加临时环境</h5><p>在Jupyter的terminal中</p>
<pre><code class="python">★ ★ PS C:\Users\Pluminary\Documents&gt; pip config set global.index-url https://pypi.tuna.tsi
nghua.edu.cn/simple
Writing to C:\Users\Pluminary\AppData\Roaming\pip\pip.ini
★ ★ PS C:\Users\Pluminary\Documents&gt; pip install opencv-python --cache-dir ./pipcache
&gt;&gt;
Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple, https://pypi.ngc.nvidia.
com
Collecting opencv-python
  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/a4/7d/f1c30a92854540bf789e9cd
5dde7ef49bbe63f855b85a2e6b3db8135c591/opencv_python-4.11.0.86-cp37-abi3-win_amd64.whl
(39.5 MB)
     --------------------------------------- 39.5/39.5 MB 1.3 MB/s eta 0:00:00
★ ★ PS C:\Users\Pluminary\Documents&gt; pip install matplotlib
</code></pre>
<p>★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★</p>
<h3 id="算数操作【要用到上面的Jupyter-Notebook】"><a href="#算数操作【要用到上面的Jupyter-Notebook】" class="headerlink" title="算数操作【要用到上面的Jupyter Notebook】"></a>算数操作【要用到上面的Jupyter Notebook】</h3><p><strong>学习目标</strong></p>
<ul>
<li>了解图像的加法、混合操作</li>
</ul>
<h1 id="1-图像的加法注意：这里都要求两幅图像是相同大小的"><a href="#1-图像的加法注意：这里都要求两幅图像是相同大小的" class="headerlink" title="1.图像的加法注意：这里都要求两幅图像是相同大小的"></a>1.图像的加法<del>注意：这里都要求两幅图像是相同大小的</del></h1><p>你可以使用OpenCV的cv.add()函数把两幅图像相加，或者可以简单地通过numpy操作添加两个图像，如res &#x3D; img1 + img2。两个图像应该具有相同的大小和类型，或者第二个图像可以是标量值。</p>
<p><strong>注意：OpenCV加法和Numpy加法之间存在差异。<u>OpenCV的加法是饱和操作</u>，而<u>Numpy添加是模运算</u>。</strong></p>
<p>参考以下代码：</p>
<pre><code class="python">【OpenCV】
&gt;&gt;&gt; x = np.uint8([250])
&gt;&gt;&gt; y = np.uint8([10])
&gt;&gt;&gt; print( cv.add(x,y) ) # 250+10 = 260 =&gt; 255
[[255]]

【Numpy】
&gt;&gt;&gt; print( x+y )          # 250+10 = 260 % 256 = 4
[4]
</code></pre>
<p>这种差别在你对两幅图像进行加法时会更加明显。OpenCV 的结果会更好一点。所以我们尽量使用 OpenCV 中的函数。</p>
<p>代码：</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# 1 读取图像
img1 = cv.imread(&quot;view.jpg&quot;)
img2 = cv.imread(&quot;rain.jpg&quot;)

# 2 加法操作
img3 = cv.add(img1,img2) # cv中的加法
img4 = img1+img2 # 直接相加

# 3 图像显示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img3[:,:,::-1])
axes[0].set_title(&quot;cv中的加法&quot;)
axes[1].imshow(img4[:,:,::-1])
axes[1].set_title(&quot;直接相加&quot;)
plt.show()
</code></pre>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# 显示下雨的图片 (&quot;./image/view.jpg&quot;)
rain = cv.imread(&quot;./rain.jpg&quot;)
plt.imshow(rain[:,:,::-1])

# 显示风景图片
view = cv.imread(&quot;./view.jpg&quot;)
plt.imshow(view[:,:,::-1])

# 用cv去做加法 显示雨中风景图
img1 = cv.add(rain,view)
plt.imshow(img1[:,:,::-1])

# 用普通做加法 显示雨中风景图
img2 = rain+view
plt.imshow(img2[:,:,::-1])
</code></pre>
<p>总结：OpenCV的加法效果要大于Numpy的加法效果</p>
<h1 id="2-图像的混合注意：这里都要求两幅图像是相同大小的"><a href="#2-图像的混合注意：这里都要求两幅图像是相同大小的" class="headerlink" title="2.图像的混合注意：这里都要求两幅图像是相同大小的"></a>2.图像的混合<del>注意：这里都要求两幅图像是相同大小的</del></h1><p>这其实也是加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：</p>
<blockquote>
<p>g(x) &#x3D; (1−α)f0(x) + αf1(x)</p>
</blockquote>
<p>通过修改 α 的值（0 → 1），可以实现非常炫酷的混合。</p>
<p>现在我们把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数cv2.addWeighted()可以按下面的公式对图片进行混合操作。</p>
<blockquote>
<p>dst &#x3D; α⋅img1 + β⋅img2 + γ</p>
</blockquote>
<p>这里γ取为零。</p>
<p>参考以下代码：</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# 1 读取图像
img1 = cv.imread(&quot;view.jpg&quot;)
img2 = cv.imread(&quot;rain.jpg&quot;)

# 2 图像混合
img3 = cv.addWeighted(img1,0.7,img2,0.3,0)

# 3 图像显示
plt.figure(figsize=(8,8))
plt.imshow(img3[:,:,::-1])
plt.show()
</code></pre>
<pre><code class="python">## 结合上方的代码
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt

# 显示下雨的图片
rain = cv.imread(&quot;./rain.jpg&quot;)
plt.imshow(rain[:,:,::-1])

# 显示风景图片
view = cv.imread(&quot;./view.jpg&quot;)
plt.imshow(view[:,:,::-1])

# 用cv去做加法 显示雨中风景图
img1 = cv.add(rain,view)
plt.imshow(img1[:,:,::-1])

# 用普通做加法 显示雨中风景图
img2 = rain+view
plt.imshow(img2[:,:,::-1])

# 做指定参数的混合加法
img3 = cv.addWeighted(view,0.5,rain,0.5,0)
plt.imshow(img3[:,:,::-1])
</code></pre>
<p><strong>总结</strong></p>
<ol>
<li><p>图像加法：将两幅图像加载一起</p>
<p>cv.add()</p>
</li>
<li><p>图像的混合：将两幅图像按照不同的比例进行混合</p>
<p>cv.addweight()</p>
</li>
</ol>
<p>注意：这里都要求两幅图像是相同大小的。</p>
<h2 id="1-图像缩放-绝对尺寸-相对尺寸"><a href="#1-图像缩放-绝对尺寸-相对尺寸" class="headerlink" title="1 图像缩放[绝对尺寸+相对尺寸]"></a>1 图像缩放<del>[绝对尺寸+相对尺寸]</del></h2><p>缩放是对图像的大小进行调整，即使图像放大或缩小。</p>
<ol>
<li><p>lAPI</p>
<pre><code class="python">cv2.resize(src,dsize,fx=0,fy=0,interpolation=cv2.INTER_LINEAR)
</code></pre>
<p>参数：</p>
<ul>
<li><p>src : 输入图像</p>
</li>
<li><p>dsize: 绝对尺寸，直接指定调整后图像的大小</p>
</li>
<li><p>fx,fy: 相对尺寸，将dsize设置为None，然后将fx和fy设置为比例因子即可</p>
</li>
<li><p>interpolation：插值方法，</p>
<table>
<thead>
<tr>
<th>插值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>cv2.INTER_LINEAR</td>
<td>双线性插值法</td>
</tr>
<tr>
<td>cv2.INTER_NEAREST</td>
<td>最近邻插值</td>
</tr>
<tr>
<td>cv2.INTER_AREA</td>
<td>像素</td>
</tr>
<tr>
<td>cv2.INTER_CUBIC</td>
<td>双三次插值</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>示例</p>
</li>
<li><pre><code class="python">import cv2 as cv
# 1. 读取图片
img1 = cv.imread(&quot;./image/dog.jpeg&quot;)
# 2.图像缩放
# 2.1 绝对尺寸
rows,cols = img1.shape[:2]
res = cv.resize(img1,(2*cols,2*rows),interpolation=cv.INTER_CUBIC)

# 2.2 相对尺寸
res1 = cv.resize(img1,None,fx=0.5,fy=0.5)

# 3 图像显示
# 3.1 使用opencv显示图像(不推荐)
cv.imshow(&quot;orignal&quot;,img1)
cv.imshow(&quot;enlarge&quot;,res)
cv.imshow(&quot;shrink）&quot;,res1)
cv.waitKey(0)

# 3.2 使用matplotlib显示图像
fig,axes=plt.subplots(nrows=1,ncols=3,figsize=(10,8),dpi=100)
axes[0].imshow(res[:,:,::-1])
axes[0].set_title(&quot;绝对尺度（放大）&quot;)
axes[1].imshow(img1[:,:,::-1])
axes[1].set_title(&quot;原图&quot;)
axes[2].imshow(res1[:,:,::-1])
axes[2].set_title(&quot;相对尺度（缩小）&quot;)
plt.show()
</code></pre>
</li>
</ol>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
kids = cv.imread(&quot;./kids.jpg&quot;)
plt.imshow(kids[:,:,::-1])

# 绝对尺寸
rows,cols = kids.shape[:2]
rows =&gt;&gt; 374
cols =&gt;&gt; 500
res = cv.resize(kids,[2*rows,2*cols])
plt.imshow(res[:,:,::-1])
res.shape =&gt;&gt; (1000,748,3)

# 相对尺寸
res1 = cv.resize(kids,None,fx=0.5,fy=0.5)
plt.imshow(res1[:,:,::-1])
res1.shape =&gt;&gt; (187,250,3)
</code></pre>
<h2 id="2-图像平移"><a href="#2-图像平移" class="headerlink" title="2 图像平移"></a>2 图像平移</h2><p>图像平移将图像按照指定方向和距离，移动到相应的位置。</p>
<ol>
<li>API</li>
</ol>
<pre><code class="python">cv.warpAffine(img,M,dsize)
</code></pre>
<p>参数：</p>
<ul>
<li><p>img: 输入图像</p>
</li>
<li><p>M： 2∗∗3移动矩阵</p>
<p>对于(x,y)处的像素点，要把它移动到(x+tx,y+ty<em>x</em>+<em>t**x</em>,<em>y</em>+<em>t**y</em>)处时，M矩阵应如下设置：</p>
<p>M &#x3D; [1 0 t<del>x</del>]<br>    [0 1 t<del>y</del>]<br>注意：将M<em>M</em>设置为np.float32类型的Numpy数组。</p>
</li>
<li><p>dsize: 输出图像的大小</p>
<p><strong>注意：输出图像的大小，它应该是(宽度，高度)的形式。请记住,width&#x3D;列数，height&#x3D;行数。</strong></p>
</li>
<li><p>示例</p>
</li>
</ul>
<p>需求是将图像的像素点移动(50,100)的距离：</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1. 读取图像
img1 = cv.imread(&quot;./image/image2.jpg&quot;)

# 2. 图像平移
rows,cols = img1.shape[:2]
M = M = np.float32([[1,0,100],[0,1,50]])# 平移矩阵
dst = cv.warpAffine(img1,M,(cols,rows))

# 3. 图像显示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img1[:,:,::-1])
axes[0].set_title(&quot;原图&quot;)
axes[1].imshow(dst[:,:,::-1])
axes[1].set_title(&quot;平移后结果&quot;)
plt.show()
</code></pre>
<h2 id="3-图像旋转-每一个像素点坐标进行修改"><a href="#3-图像旋转-每一个像素点坐标进行修改" class="headerlink" title="3 图像旋转[每一个像素点坐标进行修改]"></a>3 图像旋转<del>[每一个像素点坐标进行修改]</del></h2><h6 id="图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。图像旋转后图像的水平对称轴、垂直对称轴及中心坐标原点都可能会发生变换，因此需要对图像旋转中的坐标进行相应转换。"><a href="#图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。图像旋转后图像的水平对称轴、垂直对称轴及中心坐标原点都可能会发生变换，因此需要对图像旋转中的坐标进行相应转换。" class="headerlink" title="图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。图像旋转后图像的水平对称轴、垂直对称轴及中心坐标原点都可能会发生变换，因此需要对图像旋转中的坐标进行相应转换。"></a>图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。图像旋转后图像的水平对称轴、垂直对称轴及中心坐标原点都可能会发生变换，因此需要对图像旋转中的坐标进行相应转换。</h6><p>同时我们要修正原点的位置，因为原图像中的坐标原点在图像的左上角，经过旋转后图像的大小会有所变化，原点也需要修正。</p>
<p>假设在旋转的时候是以旋转中心为坐标原点的，旋转结束后还需要将坐标原点移到图像左上角，也就是还要进行一次变换。</p>
<h6 id="在OpenCV中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。"><a href="#在OpenCV中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。" class="headerlink" title="在OpenCV中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。"></a>在OpenCV中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。</h6><ol>
<li><p>API</p>
<pre><code>cv2.getRotationMatrix2D(center, angle, scale)
</code></pre>
<p>参数：</p>
<ul>
<li><strong>center</strong>：旋转中心</li>
<li><strong>angle</strong>：旋转角度</li>
<li><strong>scale</strong>：缩放比例</li>
</ul>
<p>返回：</p>
<ul>
<li><p><strong>M</strong>：旋转矩阵</p>
<p>调用cv.warpAffine完成图像的旋转</p>
</li>
</ul>
</li>
<li><p>示例</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 读取图像
img = cv.imread(&quot;./image/image2.jpg&quot;)

# 2 图像旋转
rows,cols = img.shape[:2]
# 2.1 生成旋转矩阵
M = cv.getRotationMatrix2D((cols/2,rows/2),90,1)
# 2.2 进行旋转变换
dst = cv.warpAffine(img,M,(cols,rows))

# 3 图像展示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img1[:,:,::-1])
axes[0].set_title(&quot;原图&quot;)
axes[1].imshow(dst[:,:,::-1])
axes[1].set_title(&quot;旋转后结果&quot;)
plt.show()
</code></pre>
</li>
</ol>
<pre><code class="python">## 完整的Jupyter
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
kids = cv.imread(&quot;./kids.jpg&quot;)
plt.imshow(kids[:,:,::-1])

# 绝对尺寸
rows,cols = kids.shape[:2]
rows =&gt;&gt; 374
cols =&gt;&gt; 500
res = cv.resize(kids,[2*rows,2*cols])
plt.imshow(res[:,:,::-1])
res.shape

# 相对尺寸
res1 = cv.resize(kids,None,fx=0.5,fy=0.5)
plt.imshow(res1[:,:,::-1])
res1.shape

# 图像平移
rows,cols = kids.shape[:2]
M = np.float32([[1,0,100],[0,1,50]])
res2 = cv.warpAffine(kids,M,(cols,rows))
plt.imshow(res2[:,:,::-1])

# 图像旋转
M = cv.getRotationMatrix2D((cols/2,rows/2),45,1)
res3 = cv.warpAffine(kids,M,(cols,rows))
plt.imshow(res3[:,:,::-1])
</code></pre>
<h2 id="4-仿射变换-类似ps的扭曲"><a href="#4-仿射变换-类似ps的扭曲" class="headerlink" title="4 仿射变换[类似ps的扭曲]"></a>4 仿射变换[类似ps的扭曲]</h2><p>图像的仿射变换涉及到图像的形状位置角度的变化，是深度学习预处理中常到的功能,仿射变换主要是对图像的缩放，旋转，翻转和平移等操作的组合。</p>
<p>那什么是图像的仿射变换，如下图所示，图1中的点1, 2 和 3 与图二中三个点一一映射, 仍然形成三角形, 但形状已经大大改变，通过这样两组三点（感兴趣点）求出仿射变换， 接下来我们就能把仿射变换应用到图像中所有的点中，就完成了图像的仿射变换。</p>
<p>在OpenCV中，仿射变换的矩阵是一个2×3的矩阵：<br>M&#x3D;[A   B]&#x3D;[a00  a01  b0]<br>                &#x3D;[a10  a11  b1]<br>其中左边的2×2子矩阵$A$是线性变换矩阵，右边的2×1子矩阵$B$是平移项：<br>A&#x3D;[a<del>00</del>  a<del>01</del>]  ,  B&#x3D;[b<del>0</del>]<br>     [a<del>10</del>  a<del>11</del>]          [b<del>1</del>]<br>对于图像上的任一位置(x,y)，仿射变换执行的是如下的操作：<br>T<del>affine</del> &#x3D; A[x] + B &#x3D; M[x]<br>                 [y]              [y]<br>                                    [1]<br>需要注意的是，对于图像而言，宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。所以原点的位置不是左下角而是右上角，y的方向也不是向上，而是向下。</p>
<p>在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后cv2.getAﬃneTransform 会创建一个 2x3 的矩阵，最后这个矩阵会被传给函数 cv2.warpAﬃne。</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 图像读取
img = cv.imread(&quot;./image/image2.jpg&quot;)

# 2 仿射变换
rows,cols = img.shape[:2]
# 2.1 创建变换矩阵
pts1 = np.float32([[50,50],[200,50],[50,200]])
pts2 = np.float32([[100,100],[200,50],[100,250]])
M = cv.getAffineTransform(pts1,pts2)
# 2.2 完成仿射变换
dst = cv.warpAffine(img,M,(cols,rows))

# 3 图像显示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img[:,:,::-1])
axes[0].set_title(&quot;原图&quot;)
axes[1].imshow(dst[:,:,::-1])
axes[1].set_title(&quot;仿射后结果&quot;)
plt.show()
</code></pre>
<pre><code class="python">## 代码承接上方
# 仿射变换
pts1 = np.float32([[56,65],[368,52],[389,390]])
pts2 = np.float32([[100,145],[300,100],[310,300]])

M = cv.getAffineTransform(pts1,pts2)
    M array([[ 6.40600025e-01, -1.02147944e-02,  6.47903603e+01],
               [-1.19267183e-01,  5.99126068e-01,  1.12735768e+02]])
res4 = cv.warpAffine(kids,M,(cols,rows))
plt.imshow(res4[:,:,::-1])
</code></pre>
<h2 id="5-透射变换"><a href="#5-透射变换" class="headerlink" title="5 透射变换"></a>5 透射变换</h2><p>透射变换是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>
<p>在opencv中，我们要找到四个点，其中任意三个不共线，然后获取变换矩阵T，再进行透射变换。通过函数cv.getPerspectiveTransform找到变换矩阵，将cv.warpPerspective应用于此3x3变换矩阵。</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 读取图像
img = cv.imread(&quot;./image/image2.jpg&quot;)
# 2 透射变换
rows,cols = img.shape[:2]
# 2.1 创建变换矩阵
pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pts2 = np.float32([[100,145],[300,100],[80,290],[310,300]])

T = cv.getPerspectiveTransform(pts1,pts2)
# 2.2 进行变换
dst = cv.warpPerspective(img,T,(cols,rows))

# 3 图像显示
fig,axes=plt.subplots(nrows=1,ncols=2,figsize=(10,8),dpi=100)
axes[0].imshow(img[:,:,::-1])
axes[0].set_title(&quot;原图&quot;)
axes[1].imshow(dst[:,:,::-1])
axes[1].set_title(&quot;透射后结果&quot;)
plt.show()
</code></pre>
<pre><code class="python">## 代码承接上方
# 投射变换
pst1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pst2 = np.float32([[100,145],[300,100],[80,290],[310,300]])
T = cv.getPerspectiveTransform(pst1,pst2)
T
res5 = cv.warpPerspective(kids,T,(cols,rows))
plt.imshow(res5[:,:,::-1])
</code></pre>
<h2 id="6-图像金字塔"><a href="#6-图像金字塔" class="headerlink" title="6 图像金字塔"></a>6 图像金字塔</h2><p>图像金字塔是图像多尺度表达的一种，最主要用于图像的分割，是一种以多分辨率来解释图像的有效但概念简单的结构。</p>
<p>图像金字塔用于机器视觉和图像压缩，一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。</p>
<p>金字塔的<strong>底部</strong>是<u>待处理图像的高分辨率表示</u>，而<strong>顶部</strong>是<u>低分辨率的近似，层级越高，图像越小，分辨率越低</u>。</p>
<ol>
<li><p>API</p>
<pre><code class="python">cv.pyrUp(img)       #对图像进行上采样
cv.pyrDown(img)        #对图像进行下采样
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 图像读取
img = cv.imread(&quot;./image/image2.jpg&quot;)
# 2 进行图像采样
up_img = cv.pyrUp(img)  # 上采样操作
img_1 = cv.pyrDown(img)  # 下采样操作
# 3 图像显示
cv.imshow(&#39;enlarge&#39;, up_img)
cv.imshow(&#39;original&#39;, img)
cv.imshow(&#39;shrink&#39;, img_1)
cv.waitKey(0)
cv.destroyAllWindows()
</code></pre>
</li>
</ol>
<pre><code class="python">## 代码承接上方
# 图像金字塔
 # 图像上采样
plt.imshow(kids[:,:,::-1])
imgup = cv.pyrUp(kids)
plt.imshow(imgup[:,:,::-1])
imgup2 = cv.pyrUp(imgup)
plt.imshow(imgup2[:,:,::-1])
 # 图像下采样
imgdown = cv.pyrDown(kids)
plt.imshow(imgdown[:,:,::-1])
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li><p>图像缩放：对图像进行放大或缩小</p>
<p>cv.resize()</p>
</li>
<li><p>图像平移：</p>
<p>指定平移矩阵后，调用cv.warpAffine()平移图像</p>
</li>
<li><p>图像旋转：</p>
<p>调用cv.getRotationMatrix2D获取旋转矩阵，然后调用cv.warpAffine()进行旋转</p>
</li>
<li><p>仿射变换：</p>
<p>调用cv.getAffineTransform将创建变换矩阵，最后该矩阵将传递给cv.warpAffine()进行变换</p>
</li>
<li><p>透射变换：</p>
<p>通过函数cv.getPerspectiveTransform()找到变换矩阵，将cv.warpPerspective()进行投射变换</p>
</li>
<li><p>金字塔</p>
<p>图像金字塔是图像多尺度表达的一种，使用的API：</p>
<p>cv.pyrUp(): 向上采样</p>
<p>cv.pyrDown(): 向下采样</p>
</li>
</ol>
<h1 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h1><p><strong>学习目标</strong></p>
<ul>
<li>理解图像的邻域，连通性</li>
<li>了解不同的形态学操作：腐蚀，膨胀，开闭运算，礼帽和黑帽等，及其不同操作之间的关系</li>
</ul>
<hr>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7899a786380300b8aa93bbd471ba874c0b649fd9/%E5%BD%A2%E6%80%81%E5%AD%A6-%E8%BF%9E%E9%80%9A%E6%80%A7.jpg"></p>
<p>形态学转换是基于图像形状的一些简单操作。它通常在二进制图像上执行。腐蚀和膨胀是两个基本的形态学运算符。然后它的变体形式如开运算，闭运算，礼帽黑帽等。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c7f87aace71d4989fc73f89741e4f29a24c619a4/%E5%BD%A2%E6%80%81%E5%AD%A6-%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80.jpg"></p>
<h6 id="膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。"><a href="#膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。" class="headerlink" title="膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。"></a>膨胀的作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。</h6><p><strong>API</strong>：</p>
<pre><code class="python">   cv.dilate(img,kernel,iterations)
</code></pre>
<p>参数：</p>
<ul>
<li>img: 要处理的图像</li>
<li>kernel: 核结构</li>
<li>iterations: 腐蚀的次数，默认是1</li>
</ul>
<ol>
<li><strong>示例</strong></li>
</ol>
<p>我们使用一个5*5的卷积核实现腐蚀和膨胀的运算：</p>
<pre><code class="python">import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
# 1 读取图像
img = cv.imread(&quot;./image/image3.png&quot;)
# 2 创建核结构
kernel = np.ones((5, 5), np.uint8)

# 3 图像腐蚀和膨胀
erosion = cv.erode(img, kernel) # 腐蚀
dilate = cv.dilate(img,kernel) # 膨胀

# 4 图像展示
fig,axes=plt.subplots(nrows=1,ncols=3,figsize=(10,8),dpi=100)
axes[0].imshow(img)
axes[0].set_title(&quot;原图&quot;)
axes[1].imshow(erosion)
axes[1].set_title(&quot;腐蚀后结果&quot;)
axes[2].imshow(dilate)
axes[2].set_title(&quot;膨胀后结果&quot;)
plt.show()
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#1bccbc>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/03/30/AI/OpenCV/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/03/30/后端/python知识点/">
        <h2>
            python知识点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/3/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h5 id="项目01-python源码实例知识点"><a href="#项目01-python源码实例知识点" class="headerlink" title="项目01 python源码实例知识点"></a>项目01 python源码实例知识点</h5><p>在控制台打出Icon表情：win+R → Wingdings → 字符码 0xcc  中间加个 f0 → 0xf0cc<br>大写字母转换为小写字母：str.upper()<br>小写字母转换为大写字母：str.lower()<br>station.reverse()   #对高铁站列表反向输出<br>world &#x3D; [“西北”, “中国”, “亚洲”, “世界”]<br>print(world[random.choice([0, 1, 2, 3])]<br>random.shuffle() 顺序打乱<br>random.sample(sqn,n) 从序列中选n个随机且不重复的元素<br>sdate&#x3D;datetime.datetime.today().strftime(‘%m-%d  %H:%M’)<br>sys.stdout.flush 刷新画面布<br>flag &#x3D; random.choice([“+”, “-“])   # 随机产生”+”或 “-“号<br>ces &#x3D; random.randint(1,100)  # 随机生成一个数字<br>fl &#x3D; f.readlines()<br>del fl[:8]    #del删除切片（前8行数据）<br>fl &#x3D; fl[1::3] #提取下标为1，步长为3的切片<br>str1 &#x3D; ‘ ‘.join(fl)  #join()函数分割文本数据<br>str1 &#x3D; str1.replace(‘[QQ红包]请使用新版手机QQ查收红包。’,’’)<br>#滤除无用文本</p>
<h6 id="文件操作对比"><a href="#文件操作对比" class="headerlink" title="文件操作对比"></a>文件操作对比</h6><pre><code class="python">#打开文件
def button1():
  global file1
  file1=tk.filedialog.askopenfilename()
  txt_path1.set(file1)


#对比文件
def Diff():
  with open(file1) as f1,open(file2) as f2:
    text1 = f1.readlines()
    text2 = f2.readlines()
  d = difflib.HtmlDiff()
  with open(&#39;result1.html&#39;,&#39;w&#39;) as f:
    f.write(d.make_file(text1,text2))
</code></pre>
<p>a1&#x3D;list(set(list1))  #字符串列表去重</p>
<pre><code class="python">print(&quot;&quot;.join([s for s in str1.splitlines(True) if s.strip()]))

这行代码的作用是打印字符串 str1 中非空行的内容，并且保留原有的换行符。下面是逐部分的解析：

str1.splitlines(True)
splitlines() 是字符串的方法，用于将字符串按行分割成列表。
参数 True 表示在分割时保留行尾的换行符。
这部分代码将 str1 按行分割成一个列表，每个元素是一行字符串，包括换行符。

[s for s in ... if s.strip()]
这是一个列表推导式，用于生成一个新的列表。
s for s in ... 表示对每个分割后的行字符串 s 进行迭代。

if s.strip() 是一个条件表达式，用于过滤掉空行或只包含空白字符的行。strip() 方法移除字符串两端的空白字符（包括空格、制表符、换行符等），如果 s.strip() 返回一个空字符串，表示 s 是一个空行或只包含空白字符。

&quot;&quot;.join(...)
join() 是字符串的方法，用于将列表中的元素连接成一个字符串。这里使用空字符串 &quot;&quot; 作为连接符，表示不添加额外的字符。
这部分代码将列表推导式生成的列表中的所有非空行连接成一个单一的字符串，保留每行末尾的换行符。
print(...)
print() 函数用于输出结果到控制台。
这部分代码将最终连接好的字符串打印出来。
综合起来，这行代码的执行流程是：
----------------------------------------------------------------
将 str1 按行分割成列表，保留每行的换行符。
过滤掉列表中的空行或只包含空白字符的行。
将过滤后的非空行连接成一个字符串。
打印最终的结果。
</code></pre>
<p>#用线程控制自动切换单词<br>t &#x3D; threading.Thread(target&#x3D;autoChange)<br>t.start()</p>
<pre><code class="python">print(&quot;电影:&quot;,film)
print(&#39;判断演员是否本部电影的演员。回车确认“是”，输入任意键确认“不是”&#39;)
for i in range(6):                     # 6次竞猜
    new = random.choice(actall)        # 随机选择演员
    actall.remove(new)                 # 从演员库删除选择的演员，防止下次再次出现
    print(new)  # 显示竞猜演员
    # 从用户输入中获取一个字符串 并移除该字符串两端的空白字符
    num = input(&quot;&quot;).strip()  # 用户进行判断，选择回车还是其他键
    if not num:  # 选择回车，确认是该部电影主演
        if new not in acter:  # 如果该演员不在本部电影主演库里面
            count -= 3  # 积分减3分
            print(&quot;答错了，减三分！&quot;)
        else:  # 答对了
            count += 3  # 积分加3分
            print(&quot;答对了，加三分！&quot;)
        print(&quot;当前分数：&quot;, count)
    else:  # 选择其他键，确认不是该部电影主演
        if new not in acter:  # 如果该演员不在本部电影主演库里面
            count += 3  # 积分加3分
            print(&quot;答对了，加三分！&quot;)
        else:  # 答错了
            count -= 3  # 积分减3分
            print(&quot;答错了，减三分！&quot;)
        print(&quot;当前分数：&quot;, count)  # 输出当前积分
</code></pre>
<p>turtle（海龟）库是<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=102483654&content_type=Article&match_order=1&q=turtle%E7%BB%98%E5%9B%BE%E4%BD%93%E7%B3%BB&zhida_source=entity">turtle绘图体系</a>python的实现；<br>turtle绘图体系：1969年诞生，主要用于程序设计入门；<br>turtle库是python的标准库之一；属于入门级的图形绘制函数库；<br>turtle库绘制原理：有一只海龟在窗体正中心，在画布上游走，走过的轨迹形成了绘制的图形，海龟由程序控制，可以自由改变颜色、方向宽度等；</p>
<p>screen.onkeypress(None,”space”)  #按空格键启动转盘</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2025/03/30/后端/python知识点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/03/19/AI/RAGFlow执行流程解析canvas/">
        <h2>
            RAGFlow执行流程解析canvas
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/3/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="Canvas-py"><a href="#Canvas-py" class="headerlink" title="Canvas.py"></a>Canvas.py</h4><pre><code class="python">import logging
import json
from copy import deepcopy
from functools import partial

import pandas as pd

from agent.component import component_class
from agent.component.base import ComponentBase


class Canvas:
    &quot;&quot;&quot;
    dsl = &#123;
        &quot;components&quot;: &#123;
            &quot;begin&quot;: &#123;
                &quot;obj&quot;:&#123;
                    &quot;component_name&quot;: &quot;Begin&quot;,
                    &quot;params&quot;: &#123;&#125;,
                &#125;,
                &quot;downstream&quot;: [&quot;answer_0&quot;],
                &quot;upstream&quot;: [],
            &#125;,
            &quot;answer_0&quot;: &#123;
                &quot;obj&quot;: &#123;
                    &quot;component_name&quot;: &quot;Answer&quot;,
                    &quot;params&quot;: &#123;&#125;
                &#125;,
                &quot;downstream&quot;: [&quot;retrieval_0&quot;],
                &quot;upstream&quot;: [&quot;begin&quot;, &quot;generate_0&quot;],
            &#125;,
            &quot;retrieval_0&quot;: &#123;
                &quot;obj&quot;: &#123;
                    &quot;component_name&quot;: &quot;Retrieval&quot;,
                    &quot;params&quot;: &#123;&#125;
                &#125;,
                &quot;downstream&quot;: [&quot;generate_0&quot;],
                &quot;upstream&quot;: [&quot;answer_0&quot;],
            &#125;,
            &quot;generate_0&quot;: &#123;
                &quot;obj&quot;: &#123;
                    &quot;component_name&quot;: &quot;Generate&quot;,
                    &quot;params&quot;: &#123;&#125;
                &#125;,
                &quot;downstream&quot;: [&quot;answer_0&quot;],
                &quot;upstream&quot;: [&quot;retrieval_0&quot;],
            &#125;
        &#125;,
        &quot;history&quot;: [],
        &quot;messages&quot;: [],
        &quot;reference&quot;: [],
        &quot;path&quot;: [[&quot;begin&quot;]],
        &quot;answer&quot;: []
    &#125;
    &quot;&quot;&quot;
    # dsl是组件流的JSON格式字符串 定义了组件的连接关系
    # tenant_id多租户管理
    # component存储所有组件实例
    def __init__(self, dsl: str, tenant_id=None):
        self.path = []
        self.history = []
        self.messages = []
        self.answer = []
        self.components = &#123;&#125;
        # 如果提供了dsl则解析JSON 否则使用默认的DSL结构（包含 Begin 组件）
        self.dsl = json.loads(dsl) if dsl else &#123;
            &quot;components&quot;: &#123;
                &quot;begin&quot;: &#123;
                    &quot;obj&quot;: &#123;
                        &quot;component_name&quot;: &quot;Begin&quot;,
                        &quot;params&quot;: &#123;
                            &quot;prologue&quot;: &quot;Hi there!&quot;
                        &#125;
                    &#125;,
                    &quot;downstream&quot;: [],
                    &quot;upstream&quot;: [],
                    &quot;parent_id&quot;: &quot;&quot;
                &#125;
            &#125;,
            &quot;history&quot;: [],
            &quot;messages&quot;: [],
            &quot;reference&quot;: [],
            &quot;path&quot;: [],
            &quot;answer&quot;: []
        &#125;
        self._tenant_id = tenant_id
        self._embed_id = &quot;&quot;
        self.load()

    # 加载dsl
    def load(self):
      # 解析dsl[&quot;components&quot;]存储组件实例 并检查必要组件是否存在
        # 组件字典存入self.components
        self.components = self.dsl[&quot;components&quot;]
        # cpn_nms记录组件名称集合
        cpn_nms = set([])

        # 遍历组件 提取名称
        for k, cpn in self.components.items():
            cpn_nms.add(cpn[&quot;obj&quot;][&quot;component_name&quot;])
        # 确保Begin和Answer组件存在 否则抛出错误
        assert &quot;Begin&quot; in cpn_nms, &quot;There have to be an &#39;Begin&#39; component.&quot;
        assert &quot;Answer&quot; in cpn_nms, &quot;There have to be an &#39;Answer&#39; component.&quot;

        # for循环便利self.components这个字典
        # 其中键k是组件标识符 cpn是一个包含组件详细信息的字典
        for k, cpn in self.components.items():
            # 将组件名称添加到cpn_nms集合中
            cpn_nms.add(cpn[&quot;obj&quot;][&quot;component_name&quot;])
            # 通过component_class动态创建 拼接param
            param = component_class(cpn[&quot;obj&quot;][&quot;component_name&quot;] + &quot;Param&quot;)()
            # 更新param实例的属性 将cpn[&quot;obj&quot;][&quot;params&quot;]字典中的键值对应用到param实例上
            param.update(cpn[&quot;obj&quot;][&quot;params&quot;])
            param.check()
          # 使用component_class动态创建了一个新的组件实例 并将其赋值给cpn[&quot;obj&quot;]
            # 新实例的创建使用了当前类实例self、组件标识符k和参数实例param
            cpn[&quot;obj&quot;] = component_class(cpn[&quot;obj&quot;][&quot;component_name&quot;])(self, k, param)
            # 检查当前组件的名称是否为&quot;Categorize&quot;
            if cpn[&quot;obj&quot;].component_name == &quot;Categorize&quot;:
                # 组件是&quot;Categorize&quot; 则遍历param.category_description字典 这个字典包含了分类描述
                for _, desc in param.category_description.items():
                    # 这两行代码检查desc[&quot;to&quot;]（可能是下游组件的标识符）是否已经在cpn[&quot;downstream&quot;]列表中
                    if desc[&quot;to&quot;] not in cpn[&quot;downstream&quot;]:
                        # 如果不在，就将其添加到列表中
                        cpn[&quot;downstream&quot;].append(desc[&quot;to&quot;])
        # 将self.dsl[&quot;path&quot;]的值赋给self.path属性
        self.path = self.dsl[&quot;path&quot;]
        self.history = self.dsl[&quot;history&quot;]
        self.messages = self.dsl[&quot;messages&quot;]
        self.answer = self.dsl[&quot;answer&quot;]
        self.reference = self.dsl[&quot;reference&quot;]
        self._embed_id = self.dsl.get(&quot;embed_id&quot;, &quot;&quot;)

    # 定义了类的字符串表示形式 通常用于打印对象时显示的信息
    # 这几行代码将类的属性值赋给self.dsl字典中的相应键
    def __str__(self):
        self.dsl[&quot;path&quot;] = self.path
        self.dsl[&quot;history&quot;] = self.history
        self.dsl[&quot;messages&quot;] = self.messages
        self.dsl[&quot;answer&quot;] = self.answer
        self.dsl[&quot;reference&quot;] = self.reference
        self.dsl[&quot;embed_id&quot;] = self._embed_id
        # 创建一个新的字典dsl 其中包含一个键components 其值为一个空字典
        dsl = &#123;
            &quot;components&quot;: &#123;&#125;
        &#125;
        # 遍历self.dsl字典的键 如果键不是components 则将其值深拷贝到新的dsl字典中
        for k in self.dsl.keys():
            if k in [&quot;components&quot;]:
                continue
            dsl[k] = deepcopy(self.dsl[k])

        # 遍历self.components字典 将每个组件的信息深拷贝到dsl字典的components键下
        # 对于obj键 将其值转换为字符串后再解析为JSON
        for k, cpn in self.components.items():
            if k not in dsl[&quot;components&quot;]:
                dsl[&quot;components&quot;][k] = &#123;&#125;
            for c in cpn.keys():
                if c == &quot;obj&quot;:
                    dsl[&quot;components&quot;][k][c] = json.loads(str(cpn[&quot;obj&quot;]))
                    continue
                dsl[&quot;components&quot;][k][c] = deepcopy(cpn[c])
        # 返回dsl字典的JSON字符串表示形式 ensure_ascii=False确保非ASCII字符可以正确显示
        return json.dumps(dsl, ensure_ascii=False)

    # 将类的属性重置为空列表
    def reset(self):
        self.path = []
        self.history = []
        self.messages = []
        self.answer = []
        self.reference = []
        # 遍历self.components字典 并调用每个组件的reset方法
        for k, cpn in self.components.items():
            self.components[k][&quot;obj&quot;].reset()
        # 将_embed_id属性重置为空字符串
        self._embed_id = &quot;&quot;

    # 这个方法用于根据组件ID获取组件名称
    def get_component_name(self, cid):
        # 遍历self.dsl字典中的graph键下的nodes列表
        # 如果找到匹配的ID 则返回相应的组件名称
        for n in self.dsl[&quot;graph&quot;][&quot;nodes&quot;]:
            if cid == n[&quot;id&quot;]:
                return n[&quot;data&quot;][&quot;name&quot;]
        # 如果没有找到匹配的ID 则返回空字符串
        return &quot;&quot;

    def run(self, **kwargs):
        # 如果self.answer列表不为空
        if self.answer:
            # 用于存储接下来要执行的组件ID
            cpn_id = self.answer[0]
            # 存完就从列表中移除
            self.answer.pop(0)
            try:
                # 尝试执行 self.components 字典中对应 cpn_id 的组件对象的 run 方法
                # 并传入 self.history 和 **kwargs 作为参数
                ans = self.components[cpn_id][&quot;obj&quot;].run(self.history, **kwargs)
                # 如果执行过程中发生异常
            except Exception as e:
                # 捕获该异常并使用 ComponentBase.be_output 方法处理异常信息
                ans = ComponentBase.be_output(str(e))
            # 将执行过的组件ID添加到 self.path 列表的最后一个元素中
            # self.path 似乎用于记录执行路径
            self.path[-1].append(cpn_id)
            # 如果 kwargs 中包含关键字 “stream”
            # 则假设 ans 是一个生成器 遍历它并逐个 yield 出来
            # 如果不是 则直接 yield ans
            if kwargs.get(&quot;stream&quot;):
                for an in ans():
                    yield an
            else:
                yield ans
            return
        # 如果 self.path 为空 则执行名为 “begin” 的组件的 run 方法 并将 “begin” 添加到 self.path 中
        if not self.path:
            self.components[&quot;begin&quot;][&quot;obj&quot;].run(self.history, **kwargs)
            self.path.append([&quot;begin&quot;])
        # 向 self.path 添加一个空列表 为接下来的组件执行做准备
        self.path.append([])

        ran = -1
        waiting = []
        without_dependent_checking = []

        # 当有下游组件downstream时
        # 它接受一个组件列表 cpns 作为参数
        def prepare2run(cpns):
            # 这些变量在函数外部定义 但在函数内部可以被修改
            nonlocal ran, ans
            # 遍历 cpns 列表中的每个组件ID c
            # 如果 c 已经是 self.path 中最后一个列表的最后一个元素 则跳过当前循环
            for c in cpns:
                if self.path[-1] and c == self.path[-1][-1]:
                    continue
                # 从 self.components 字典中获取组件ID c 对应的组件对象
                cpn = self.components[c][&quot;obj&quot;]
                # 如果组件的名称是 “Answer” 则将组件ID c 添加到 self.answer 列表中
                if cpn.component_name == &quot;Answer&quot;:
                    self.answer.append(c)
                else:
                    # 如果组件不是 “Answer” 则记录调试信息 检查组件是否有未执行的依赖组件
                    # 如果有 将组件ID添加到 waiting 列表 并跳过当前循环
                    logging.debug(f&quot;Canvas.prepare2run: &#123;c&#125;&quot;)
                    if c not in without_dependent_checking:
                        cpids = cpn.get_dependent_components()
                        if any([cc not in self.path[-1] for cc in cpids]):
                            if c not in waiting:
                                waiting.append(c)
                            continue
                    yield &quot;*&#39;&#123;&#125;&#39;* is running...🕞&quot;.format(self.get_component_name(c))
                    # 如果组件是 “Iteration” 则获取其开始组件 并检查是否已经结束 如果没有结束 则更新 cpn 和 c 为开始组件
                    if cpn.component_name.lower() == &quot;iteration&quot;:
                        st_cpn = cpn.get_start()
                        assert st_cpn, &quot;Start component not found for Iteration.&quot;
                        if not st_cpn[&quot;obj&quot;].end():
                            cpn = st_cpn[&quot;obj&quot;]
                            c = cpn._id
                    # 尝试运行组件
                    try:
                        ans = cpn.run(self.history, **kwargs)
                    # 并捕获任何异常 如果发生异常 记录错误并更新 ran 然后重新抛出异常
                    except Exception as e:
                        logging.exception(f&quot;Canvas.run got exception: &#123;e&#125;&quot;)
                        self.path[-1].append(c)
                        ran += 1
                        raise e
                    # 将组件ID c 添加到 self.path 的最后一个列表中
                    self.path[-1].append(c)
            # 增加 ran 计数器的值
            ran += 1
        &quot;&quot;&quot;
        接下来的代码块处理下游组件的运行 循环检测 以及组件输出的合并
        这部分代码涉及到更复杂的逻辑，如处理循环、条件分支、组件输出等
        &quot;&quot;&quot;
        # 获取上一个组件的下游组件列表
        downstream = self.components[self.path[-2][-1]][&quot;downstream&quot;]
        # 如果没有下游组件 但存在父组件ID 则合并父组件和当前组件的输出
        if not downstream and self.components[self.path[-2][-1]].get(&quot;parent_id&quot;):
            cid = self.path[-2][-1]
            pid = self.components[cid][&quot;parent_id&quot;]
            o, _ = self.components[cid][&quot;obj&quot;].output(allow_partial=False)
            oo, _ = self.components[pid][&quot;obj&quot;].output(allow_partial=False)
            self.components[pid][&quot;obj&quot;].set_output(pd.concat([oo, o], ignore_index=True).dropna())
            downstream = [pid]
        # 递归调用 prepare2run 函数处理下游组件 并生成运行状态信息
        for m in prepare2run(downstream):
            yield &#123;&quot;content&quot;: m, &quot;running_status&quot;: True&#125;

        # 在 ran 的值有效时 处理循环和组件运行
        # ran 的值在 0 和 self.path[-1] 的长度之间时继续执行
        while 0 &lt;= ran &lt; len(self.path[-1]):
            logging.debug(f&quot;Canvas.run: &#123;ran&#125; &#123;self.path&#125;&quot;)
            # 从 self.path 中获取当前要处理的组件ID cpn_id
            # 并通过 get_component 方法获取组件对象
            cpn_id = self.path[-1][ran]
            cpn = self.get_component(cpn_id)
            # 如果当前组件没有下游组件、没有父组件ID 并且没有等待处理的组件 则退出循环
            if not any([cpn[&quot;downstream&quot;], cpn.get(&quot;parent_id&quot;), waiting]):
                break

            # 调用 _find_loop 方法检查是否存在循环 如果存在则抛出 OverflowError 异常
            loop = self._find_loop()
            if loop:
                raise OverflowError(f&quot;Too much loops: &#123;loop&#125;&quot;)
            # 如果组件的名称是 “switch”、“categorize” 或 “relevant” 则处理这些特定类型的组件
            if cpn[&quot;obj&quot;].component_name.lower() in [&quot;switch&quot;, &quot;categorize&quot;, &quot;relevant&quot;]:
                switch_out = cpn[&quot;obj&quot;].output()[1].iloc[0, 0]
                assert switch_out in self.components, \
                    &quot;&#123;&#125;&#39;s output: &#123;&#125; not valid.&quot;.format(cpn_id, switch_out)
                # 递归调用 prepare2run 函数处理特定组件的输出 并生成运行状态信息 然后继续下一次循环
                for m in prepare2run([switch_out]):
                    yield &#123;&quot;content&quot;: m, &quot;running_status&quot;: True&#125;
                continue

            # 处理父组件输出合并
            downstream = cpn[&quot;downstream&quot;]
            # 如果没有下游组件但有父组件ID 则合并父组件和当前组件的输出
            if not downstream and cpn.get(&quot;parent_id&quot;):
                pid = cpn[&quot;parent_id&quot;]
                _, o = cpn[&quot;obj&quot;].output(allow_partial=False)
                _, oo = self.components[pid][&quot;obj&quot;].output(allow_partial=False)
                self.components[pid][&quot;obj&quot;].set_output(pd.concat([oo.dropna(axis=1), o.dropna(axis=1)], ignore_index=True))
                downstream = [pid]
            # 递归调用 prepare2run 函数处理下游组件 并生成运行状态信息
            for m in prepare2run(downstream):
                yield &#123;&quot;content&quot;: m, &quot;running_status&quot;: True&#125;

            # 如果 ran 的值等于或超过 self.path[-1] 的长度
            # 并且有等待处理的组件 则处理这些组件 并更新 ran 的值
            if ran &gt;= len(self.path[-1]) and waiting:
                without_dependent_checking = waiting
                waiting = []
                for m in prepare2run(without_dependent_checking):
                    yield &#123;&quot;content&quot;: m, &quot;running_status&quot;: True&#125;
                without_dependent_checking = []
                ran -= 1
        # 如果 self.answer 列表非空 处理答案组件
        if self.answer:
            cpn_id = self.answer[0]
            self.answer.pop(0)
            ans = self.components[cpn_id][&quot;obj&quot;].run(self.history, **kwargs)
            self.path[-1].append(cpn_id)
            # 如果 self.answer 列表为空 抛出异常 提示需要在流程末尾添加交互组件
            if kwargs.get(&quot;stream&quot;):
                assert isinstance(ans, partial)
                for an in ans():
                    yield an
            else:
                yield ans

        else:
            raise Exception(&quot;The dialog flow has no way to interact with you. Please add an &#39;Interact&#39; component to the end of the flow.&quot;)

    def get_component(self, cpn_id):
        return self.components[cpn_id]

    def get_tenant_id(self):
        return self._tenant_id
    # 定义一个名为 get_history 的方法 它接受一个参数 window_size 这个参数用于确定需要返回多少条历史记录
    def get_history(self, window_size):
        # 初始化一个空列表convs  用于存储格式化后的对话记录
        convs = []
        # 使用一个 for 循环遍历 self.history 的最后 window_size 条记录
        # self.history 应该是一个列表 其中每个元素都是一个包含角色和对象（对话内容）的元组
        &quot;&quot;&quot;
            role 是对话中的角色，例如 “user” 或 “assistant”。
            obj 是与该角色相关的对话内容，它可能是一个列表或单个对象
        &quot;&quot;&quot;
        for role, obj in self.history[window_size * -1:]:
            if isinstance(obj, list) and obj and all([isinstance(o, dict) for o in obj]):
                convs.append(&#123;&quot;role&quot;: role, &quot;content&quot;: &#39;\n&#39;.join([str(s.get(&quot;content&quot;, &quot;&quot;)) for s in obj])&#125;)
            else:
                convs.append(&#123;&quot;role&quot;: role, &quot;content&quot;: str(obj)&#125;)
        return convs

    def add_user_input(self, question):
        self.history.append((&quot;user&quot;, question))

    def set_embedding_model(self, embed_id):
        self._embed_id = embed_id

    def get_embedding_model(self):
        return self._embed_id
 # 定义一个名为 _find_loop 的方法 它接受一个可选参数 max_loops默认值为6 这个参数用于限制循环检测的次数
    def _find_loop(self, max_loops=6):
        # 获取 self.path 列表的最后一个元素（即当前路径）并将其反转 以便从后往前检查
        path = self.path[-1][::-1]
        # 如果路径的长度小于2 则没有足够的元素形成循环 因此直接返回 False
        if len(path) &lt; 2:
            return False
        # 遍历路径，如果找到以 “answer” 或 “iterationitem” 开头的元素
        # 则从路径中移除该元素及其后面的所有元素
        # 因为这些元素可能表示循环的结束
        for i in range(len(path)):
            if path[i].lower().find(&quot;answer&quot;) == 0 or path[i].lower().find(&quot;iterationitem&quot;) == 0:
                path = path[:i]
                break
        # 再次检查路径长度 如果移除特定元素后长度小于2 则返回 False
        if len(path) &lt; 2:
            return False
        # 使用一个循环来检查路径的不同子序列 loc 是子序列的长度
        # 从 2 开始 直到路径长度的一半
        for loc in range(2, len(path) // 2):
            # 创建一个子序列pat 它是路径的前loc个元素 用逗号连接
            pat = &quot;,&quot;.join(path[0:loc])
            # 创建一个字符串 path_str 它是整个路径 用逗号连接
            path_str = &quot;,&quot;.join(path)
            # 如果子序列pat的长度大于或等于整个路径字符串 ath_str的长度 则不可能形成循环 因此返回 False
            if len(pat) &gt;= len(path_str):
                return False
            &quot;&quot;&quot;
            使用一个 while 循环来检查 path_str 是否以 pat 开头 
            如果是 则减少 loop 计数 并从 path_str 中移除 pat 和随后的逗号
            如果 loop 计数降到 0 以下 说明找到了循环
            &quot;&quot;&quot;
            loop = max_loops
            while path_str.find(pat) == 0 and loop &gt;= 0:
                loop -= 1
                if len(pat)+1 &gt;= len(path_str):
                    return False
                path_str = path_str[len(pat)+1:]
                # 如果找到了循环 则创建一个循环模式的字符串 使用 &quot; =&gt; &quot; 作为分隔符
                # 并将路径中的每个元素的前半部分（在冒号之前的部分）连接起来
                # 最后 返回一个表示循环的模式字符串
            if loop &lt; 0:
                pat = &quot; =&gt; &quot;.join([p.split(&quot;:&quot;)[0] for p in path[0:loc]])
                return pat + &quot; =&gt; &quot; + pat

        return False

    def get_prologue(self):
        return self.components[&quot;begin&quot;][&quot;obj&quot;]._param.prologue

    def set_global_param(self, **kwargs):
        for k, v in kwargs.items():
            for q in self.components[&quot;begin&quot;][&quot;obj&quot;]._param.query:
                if k != q[&quot;key&quot;]:
                    continue
                q[&quot;value&quot;] = v

    def get_preset_param(self):
        return self.components[&quot;begin&quot;][&quot;obj&quot;]._param.query

    def get_component_input_elements(self, cpnnm):
        return self.components[cpnnm][&quot;obj&quot;].get_input_elements()
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#879cff>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/03/19/AI/RAGFlow执行流程解析canvas/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/03/19/AI/RAGFlow代理组件技术/">
        <h2>
            RAGFlow代理组件技术
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/3/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="如果要自己创建一个组件并且使用"><a href="#如果要自己创建一个组件并且使用" class="headerlink" title="如果要自己创建一个组件并且使用"></a><span style = "color:red">如果要自己创建一个组件并且使用</span></h4><h6 id="要创建一个新的组件类-自定义新的组件参数"><a href="#要创建一个新的组件类-自定义新的组件参数" class="headerlink" title="要创建一个新的组件类 + 自定义新的组件参数"></a>要创建一个新的组件类 + 自定义新的组件参数</h6><p>① <code>agent/component/xxxx.py</code> 在里面<strong>继承</strong> <code>ComponentParamBase</code> +  <code>ComponentBase</code> 类 这样就可以重用其中的大部分方法和逻辑<br>② 新组件类需要实现 <code>_run</code> 方法，这个方法会定义组件的具体业务逻辑</p>
<pre><code class="python">BaiduFanyiParam →→ ComponentBase → base.py
★★★ base.py【里面的output是输出为元组(DataFrame) 
再通过序列化转换为(字典)(def as_dict(self))JSON】 ★★★

    扩展性：不同的子类可以根据具体需求实现自己的 _run 方法
           不同的业务逻辑可能需要不同的数据处理方式和计算方法
    灵活配置：kwargs 参数提供了方法调用时灵活传递参数的能力，可以根据需要在不同情况下调整行为。
    调试和监控：通过 logging.debug 和 set_output 记录输入和输出，可以在调试和生产环境中跟踪程序的行为，并及时发现问题。
    
    def run(self, history, **kwargs):
        logging.debug(&quot;&#123;&#125;, history: &#123;&#125;, kwargs: &#123;&#125;&quot;.format(self, json.dumps(history, ensure_ascii=False),
                                                              json.dumps(kwargs, ensure_ascii=False)))
        self._param.debug_inputs = []
        try:
            res = self._run(history, **kwargs)
            self.set_output(res)
        except Exception as e:
            self.set_output(pd.DataFrame([&#123;&quot;content&quot;: str(e)&#125;]))
            raise e

        return res

    def _run(self, history, **kwargs):
        raise NotImplementedError()
</code></pre>
<pre><code class="python">【自定义组件】BaiduFanyi →→ ComponentBase → abc.py 【Python的抽象基类(类似于Java的接口)】
确保某些类在继承抽象基类时遵循特定的协议 这在设计大型系统或者框架时非常有用
★ 接口定义：定义了组件必须实现的方法 =&gt; `_run` =&gt; 组件执行其任务的地方
★ 组件命名：通过 component_name 类属性，它提供了组件的名称，这有助于在系统中识别和管理组件
★ 运行逻辑：`_run` 方法是组件的核心，它包含了组件的执行逻辑，例如如何使用参数、如何处理输入、如何调用外部API等
★ 输入/输出处理：output → base.py 用于处理组件的输出，确保所有组件的输出格式一致
------------------------------------------------------------------------------
【自定义组件参数】BaiduFanyiParam →→ ComponentParamBase → base.py 【初始化+校验】
定义了百度翻译组件所需的参数，例如 appid、secret_key、trans_type 等，它还实现了一个 check 方法，用于验证参数的有效性。
★ 参数封装：它封装了组件运行所需的所有参数，使得参数管理更加集中方便
★ 参数验证：通过 check 方法，可以确保在组件运行前所有必要的参数都被正确设置，并且是有效的
★ 可扩展性：其他组件的参数类可以继承 ComponentParamBase 并根据需要添加或修改参数
</code></pre>
<pre><code class="python">import random
# 抽象基类模块 用于定义组件的基类
from abc import ABC
# 用于发送 HTTP 请求，与 百度翻译 API 交互
import requests
# 基础组件类，于构建此组件的父类，定义组件的基本结构和参数。
from agent.component.base import ComponentBase, ComponentParamBase
# 用于生成百度翻译 API 请求签名（加密哈希）
from hashlib import md5

# 百度翻译组件的参数定义类 继承ComponentParamBase
class BaiduFanyiParam(ComponentParamBase):
    &quot;&quot;&quot;
    Define the BaiduFanyi component parameters.
    &quot;&quot;&quot;

    def __init__(self):
        super().__init__()
   # appid 和 secret_key 是百度翻译 API 的 身份验证 信息（需要在百度翻译开放平台获取）
        self.appid = &quot;xxx&quot;
        self.secret_key = &quot;xxx&quot;
   # translate：普通翻译   fieldtranslate：专业领域翻译
        self.trans_type = &#39;translate&#39;
        self.parameters = []
   # source_lang 翻译的源语言   target_lang 翻译的目标语言
        self.source_lang = &#39;auto&#39;
        self.target_lang = &#39;auto&#39;
   # domain 如果使用专业领域翻译，需指定领域（如 finance 表示 金融 领域）
        self.domain = &#39;finance&#39;
# 检查参数合法性
    def check(self):
    # check_empty()：确保 appid 和 secret_key 不能为空。
        self.check_empty(self.appid, &quot;BaiduFanyi APPID&quot;)
        self.check_empty(self.secret_key, &quot;BaiduFanyi Secret Key&quot;)
# check_valid_value()：确保 trans_type、source_lang、target_lang、domain 的值在合法选项之内
        self.check_valid_value(self.trans_type, &quot;Translate type&quot;, [&#39;translate&#39;, &#39;fieldtranslate&#39;])
# 以下是列举各种语言
        self.check_valid_value(self.source_lang, &quot;Source language&quot;,
                               [&#39;auto&#39;, &#39;zh&#39;, &#39;en&#39;, &#39;yue&#39;, &#39;wyw&#39;, &#39;jp&#39;, &#39;kor&#39;, &#39;fra&#39;, &#39;spa&#39;, &#39;th&#39;, &#39;ara&#39;, &#39;ru&#39;, &#39;pt&#39;,
                                &#39;de&#39;, &#39;it&#39;, &#39;el&#39;, &#39;nl&#39;, &#39;pl&#39;, &#39;bul&#39;, &#39;est&#39;, &#39;dan&#39;, &#39;fin&#39;, &#39;cs&#39;, &#39;rom&#39;, &#39;slo&#39;, &#39;swe&#39;,
                                &#39;hu&#39;, &#39;cht&#39;, &#39;vie&#39;])
        self.check_valid_value(self.target_lang, &quot;Target language&quot;,
                               [&#39;auto&#39;, &#39;zh&#39;, &#39;en&#39;, &#39;yue&#39;, &#39;wyw&#39;, &#39;jp&#39;, &#39;kor&#39;, &#39;fra&#39;, &#39;spa&#39;, &#39;th&#39;, &#39;ara&#39;, &#39;ru&#39;, &#39;pt&#39;,
                                &#39;de&#39;, &#39;it&#39;, &#39;el&#39;, &#39;nl&#39;, &#39;pl&#39;, &#39;bul&#39;, &#39;est&#39;, &#39;dan&#39;, &#39;fin&#39;, &#39;cs&#39;, &#39;rom&#39;, &#39;slo&#39;, &#39;swe&#39;,
                                &#39;hu&#39;, &#39;cht&#39;, &#39;vie&#39;])
# 以下是列举不同专业领域
        self.check_valid_value(self.domain, &quot;Translate field&quot;,
                               [&#39;it&#39;, &#39;finance&#39;, &#39;machinery&#39;, &#39;senimed&#39;, &#39;novel&#39;, &#39;academic&#39;, &#39;aerospace&#39;, &#39;wiki&#39;,
                                &#39;news&#39;, &#39;law&#39;, &#39;contract&#39;])

# 继承ComponentBase和ABC


# -------------------------------------------------------------------------------- #


class BaiduFanyi(ComponentBase, ABC):
 # 定义组件名称在系统内唯一标识该组件
    component_name = &quot;BaiduFanyi&quot;
    # _run()是组件的 核心执行函数，用于处理翻译请求。
# **kwargs：可以让函数更加灵活，因为它可以接受任意数量的命名参数
# 在函数内部，kwargs 是一个字典，包含了所有传递给函数的额外命名参数。
    def _run(self, history, **kwargs):
&#39;&#39;&#39;
self.get_input() 获取输入内容。
如果 content 存在，则用 - 连接多个内容（拼接成单个字符串）。
如果 ans 为空，直接返回 &quot;&quot;
&#39;&#39;&#39;
        ans = self.get_input()
        ans = &quot; - &quot;.join(ans[&quot;content&quot;]) if &quot;content&quot; in ans else &quot;&quot;
        if not ans:
            return BaiduFanyi.be_output(&quot;&quot;)

        try:
&#39;&#39;&#39;
source_lang 和 target_lang：来源和目标语言。
appid：百度翻译 API 的 应用 ID。
salt：随机数（百度 API 需要此参数）。
secret_key：百度 API 的 密钥
&#39;&#39;&#39;
            source_lang = self._param.source_lang
            target_lang = self._param.target_lang
            appid = self._param.appid
            salt = random.randint(32768, 65536)
            secret_key = self._param.secret_key
-------------------------- ☆ 普通翻译API请求 ☆ --------------------------
            if self._param.trans_type == &#39;translate&#39;:
            # md5签名，防止请求被篡改
                sign = md5((appid + ans + salt + secret_key).encode(&#39;utf-8&#39;)).hexdigest()
     # 发送 HTTP POST 请求 访问 百度翻译 API
                url = &#39;http://api.fanyi.baidu.com/api/trans/vip/translate?&#39; + &#39;q=&#39; + ans + &#39;&amp;from=&#39; + source_lang + &#39;&amp;to=&#39; + target_lang + &#39;&amp;appid=&#39; + appid + &#39;&amp;salt=&#39; + salt + &#39;&amp;sign=&#39; + sign
                headers = &#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;
            # 解析返回结果
                response = requests.post(url=url, headers=headers).json()

                if response.get(&#39;error_code&#39;):
                    BaiduFanyi.be_output(&quot;**Error**:&quot; + response[&#39;error_msg&#39;])

                return BaiduFanyi.be_output(response[&#39;trans_result&#39;][0][&#39;dst&#39;])
-------------------------- ★ 专业翻译API请求 ★ --------------------------
            elif self._param.trans_type == &#39;fieldtranslate&#39;:
                domain = self._param.domain
                sign = md5((appid + ans + salt + domain + secret_key).encode(&#39;utf-8&#39;)).hexdigest()
                url = &#39;http://api.fanyi.baidu.com/api/trans/vip/fieldtranslate?&#39; + &#39;q=&#39; + ans + &#39;&amp;from=&#39; + source_lang + &#39;&amp;to=&#39; + target_lang + &#39;&amp;appid=&#39; + appid + &#39;&amp;salt=&#39; + salt + &#39;&amp;domain=&#39; + domain + &#39;&amp;sign=&#39; + sign
                headers = &#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;
                response = requests.post(url=url, headers=headers).json()

                if response.get(&#39;error_code&#39;):
                    BaiduFanyi.be_output(&quot;**Error**:&quot; + response[&#39;error_msg&#39;])

                return BaiduFanyi.be_output(response[&#39;trans_result&#39;][0][&#39;dst&#39;])
        # 捕获 所有异常，防止程序崩溃
        except Exception as e:
            BaiduFanyi.be_output(&quot;**Error**:&quot; + str(e))
</code></pre>
<h6 id="针对于自定义组件参数-ComponentParamBase-为什么里面是用的Json格式？"><a href="#针对于自定义组件参数-ComponentParamBase-为什么里面是用的Json格式？" class="headerlink" title="针对于自定义组件参数[ComponentParamBase] 为什么里面是用的Json格式？"></a>针对于自定义组件参数[ComponentParamBase] 为什么里面是用的Json格式？</h6><ul>
<li><p><strong>方便序列化</strong>：<code>json.dumps()</code>将对象转换为JSON字符串，可以轻松地保存或传输对象数据。</p>
<pre><code class="python">base.py
    def __str__(self):
        &quot;&quot;&quot;
        &#123;
            &quot;component_name&quot;: &quot;Begin&quot;,
            &quot;params&quot;: &#123;&#125;
        &#125;
        &quot;&quot;&quot;
        # .format()将变量插入到字符串模板中的占位符位置  &#123;&#123;&#125;&#125;转义&#123;&#125;
        return &quot;&quot;&quot;&#123;&#123;
              "component_name": "&#123;&#125;",
              "params": &#123;&#125;,
              "output": &#123;&#125;,
              "inputs": &#123;&#125;
          &#125;&#125;&quot;&quot;&quot;.format(self.component_name,
                     self._param,
# json.dumps(...): 将获取的 &quot;output&quot; 和 &quot;inputs&quot; 值序列化为 JSON 格式的字符串
# json.loads(str(self._param)): 将 self._param 转换为字符串，然后将其解析为 JSON 对象
# self._param 转换为字符串，然后将其解析为 JSON 对象
# 从 JSON 对象中获取 &quot;output&quot; 键对应的值，如果不存在则返回空字典 &#123;&#125;
                     json.dumps(json.loads(str(self._param)).get(&quot;output&quot;, &#123;&#125;), ensure_ascii=False),
                     json.dumps(json.loads(str(self._param)).get(&quot;inputs&quot;, []), ensure_ascii=False)
        )
</code></pre>
</li>
<li><p><strong>方便调试和展示</strong>：在 <code>__str__</code> 方法中返回 JSON 字符串，可以方便地查看对象的内容。尤其是在调试过程中，直接打印出对象的 JSON 格式可以帮助开发人员快速查看对象的状态及其内部数据结构</p>
<pre><code class="python"># 将对象转换为 JSON 字符串
    def __str__(self):
        return json.dumps(self.as_dict(), ensure_ascii=False)
# 递归地将对象的属性转换成字典 适用于将对象序列化为 JSON 或进行其他操作
    def as_dict(self):
        def _recursive_convert_obj_to_dict(obj):
            ret_dict = &#123;&#125;
            for attr_name in list(obj.__dict__):
                if attr_name in [_FEEDED_DEPRECATED_PARAMS, _DEPRECATED_PARAMS, _USER_FEEDED_PARAMS, _IS_RAW_CONF]:
                    continue
                # get attr
                attr = getattr(obj, attr_name)
                if isinstance(attr, pd.DataFrame):
                    ret_dict[attr_name] = attr.to_dict()
                    continue
                if attr and type(attr).__name__ not in dir(builtins):
                    ret_dict[attr_name] = _recursive_convert_obj_to_dict(attr)
                else:
                    ret_dict[attr_name] = attr
            return ret_dict
        return _recursive_convert_obj_to_dict(self)
</code></pre>
</li>
<li><p><strong>与大模型交互</strong>：当涉及到与大语言模型（如 GPT）或其他机器学习模型的交互时，JSON 格式的数据通常是标准的输入和输出格式。将对象转为 JSON 字符串，能够更容易地将数据传递给模型进行处理或分析，模型通常会接受 JSON 格式的数据进行训练或推理。</p>
</li>
</ul>
<h5 id="如何去运用？"><a href="#如何去运用？" class="headerlink" title="如何去运用？"></a>如何去运用？</h5><ul>
<li><strong>数据交换</strong>：可以将这个 JSON 字符串用作 API 请求或响应的数据格式。例如，你可以将这个对象作为 HTTP 请求的 body 发送，或者从网络中获取 JSON 格式的数据，然后解析回对象。</li>
<li><strong>持久化存储</strong>：如果你需要将对象数据持久化到数据库或文件系统，JSON 是一个很好的存储格式。例如，将对象数据存储在文件中或数据库表的 JSON 类型字段中，便于未来读取和操作。</li>
<li><strong>配置和参数更新</strong>：<code>update</code> 方法中接收到的 <code>conf</code> 参数实际上是一个字典对象，它通过递归的方式更新对象的属性。如果你将对象序列化为 JSON 格式后，可以将 JSON 作为配置文件传递给应用，应用根据该配置动态调整其行为。这使得系统更加灵活和可配置。</li>
<li><strong>验证与校验</strong>：<code>validate</code> 方法利用存储在 JSON 文件中的规则对对象进行参数验证，这是一种常见的方式来确保输入的数据符合特定的格式或限制。可以通过动态加载配置文件来验证对象的数据，保证数据的合法性。</li>
</ul>
<h5 id="数据输出-元组-及转换-JSON"><a href="#数据输出-元组-及转换-JSON" class="headerlink" title="数据输出(元组)及转换(JSON)"></a>数据输出(元组)及转换(JSON)</h5><pre><code class="python">----------------------------------- 输出为元组 -----------------------------------    
    def output(self, allow_partial=True) -&gt; Tuple[str, Union[pd.DataFrame, partial]]:
        o = getattr(self._param, self._param.output_var_name)
        if not isinstance(o, partial):
            if not isinstance(o, pd.DataFrame):
                if isinstance(o, list):
                    return self._param.output_var_name, pd.DataFrame(o)
                if o is None:
                    return self._param.output_var_name, pd.DataFrame()
                return self._param.output_var_name, pd.DataFrame([&#123;&quot;content&quot;: str(o)&#125;])
            return self._param.output_var_name, o

        if allow_partial or not isinstance(o, partial):
            if not isinstance(o, partial) and not isinstance(o, pd.DataFrame):
                return pd.DataFrame(o if isinstance(o, list) else [o])
            return self._param.output_var_name, o

        outs = None
        for oo in o():
            if not isinstance(oo, pd.DataFrame):
                # 最终返回的是一个元组
                outs = pd.DataFrame(oo if isinstance(oo, list) else [oo])
            else:
                outs = oo
        return self._param.output_var_name, outs

----------------------------------- 序列化为JSON -----------------------------------
 # 将对象转换为 JSON 字符串
    def __str__(self):
        return json.dumps(self.as_dict(), ensure_ascii=False)

    # 递归地将对象的属性转换成字典 适用于将对象序列化为 JSON 或进行其他操作
    def as_dict(self):
        def _recursive_convert_obj_to_dict(obj):
            ret_dict = &#123;&#125;
            for attr_name in list(obj.__dict__):
                if attr_name in [_FEEDED_DEPRECATED_PARAMS, _DEPRECATED_PARAMS,
                                 _USER_FEEDED_PARAMS, _IS_RAW_CONF]:
                    continue
                # get attr
                attr = getattr(obj, attr_name)
                if isinstance(attr, pd.DataFrame):
                    ret_dict[attr_name] = attr.to_dict()
                    continue
                if attr and type(attr).__name__ not in dir(builtins):
                    ret_dict[attr_name] = _recursive_convert_obj_to_dict(attr)
                else:
                    ret_dict[attr_name] = attr

            return ret_dict

        return _recursive_convert_obj_to_dict(self)
    
--------------------------------------------------------------------------------------
def get_stream_input(self)：
def get_input_elements(self):
    
def get_input(self)：
# 上游组件的输出：它会检查当前组件的上游组件，并尝试从这些组件获取输出数据作为当前的输入
# 如果 _param.query 存在，它会遍历查询参数，并根据参数的类型（如组件 ID）来决定如何获取相应的输入数据
# input后再通过DataFrame转换为元组 再去转换为字典
# 来回来转换是为了满足特定的接口要求或者为了确保数据在不同层之间传输时的兼容性



&#39;&#39;&#39;
                           使用Pandas库来处理数据
★ get_input函数: 这个函数首先检查是否有调试输入，如果有，则返回一个包含调试输入内容的DataFrame。然后，它处理查询输入，根据查询中的不同条件（如component_id、value等），调用其他函数获取相应的输入内容，并将这些内容添加到self._param.inputs列表中。最后，它通过pd.concat函数将所有上游组件[结合history]的输出合并成一个DataFrame，并返回。

★ get_input_elements函数: 这个函数根据self._param.query中的查询，构建一个输入元素列表，其中每个元素包含名称、键和值。

★get_stream_input函数: 这个函数处理流式输入，根据组件路径，调用其他函数获取相应的输入内容，并返回。

主要是处理输入参数，并根据不同的条件获取相应的输入内容。它并没有直接接受不同种类类型的入参，而是根据传入的查询参数来获取输入内容。
&#39;&#39;&#39;
</code></pre>
<hr>
<p>① <span style = "color:red">agent&#x2F;component&#x2F;baidufanyi.py</span> 【后端代码】<br>② <span style = "color:red">agent&#x2F;component&#x2F;_ _ init _ _.py</span>  【初始化】<br>③ web&#x2F;src&#x2F;pages&#x2F;flow&#x2F;flow-drawer&#x2F;index.tsx【表单抽屉组件 UI展示】<br>④ web&#x2F;src&#x2F;pages&#x2F;flow&#x2F;form&#x2F;baidu-fanyi-form&#x2F;index.tsx 【提供用户界面让用户能配置并提交参数】<br>⑤ web&#x2F;src&#x2F;pages&#x2F;flow&#x2F;constant.tsx 【定义一个应用程序中使用的各种图标、常量、枚举、接口、状态和函数】<br>⑥ web&#x2F;src&#x2F;locales&#x2F;zh.ts 【把所有要显示的搞到zh.ts中(前端组件描述)】<br>⑦ web&#x2F;src&#x2F;pages&#x2F;agent&#x2F;constant.tsx【引入组件所需的各种图标、以及操作项的样式、初始值、语言等】<br>⑧ web&#x2F;src&#x2F;pages&#x2F;agent&#x2F;form-sheet&#x2F;use-form-config-map.tsx 【表单配置映射、配置不同操作对应表单组件】<br>⑨ web&#x2F;src&#x2F;pages&#x2F;agent&#x2F;form&#x2F;baidu-fanyi-form&#x2F;index.tsx 【构建配置表单 】<br>⑩ web&#x2F;src&#x2F;pages&#x2F;agent&#x2F;hooks.tsx 【管理图形界面流程图 各种钩子 → 建数据处理流程】</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="创建动态代理组件-实战"><a href="#创建动态代理组件-实战" class="headerlink" title="创建动态代理组件 [实战]"></a><span style = "color:red">创建动态代理组件 [实战]</span></h1><h2 id="📌-实现步骤"><a href="#📌-实现步骤" class="headerlink" title="📌 实现步骤"></a><strong>📌 实现步骤</strong></h2><ol>
<li><strong>后端（Python FastAPI）</strong><ul>
<li>创建一个 API 服务器，提供组件注册、查询、运行接口。</li>
<li>组件信息存储在内存（可扩展到数据库）。</li>
<li>组件代码动态执行，支持 <code>exec()</code> 加载。</li>
</ul>
</li>
<li><strong>前端（HTML + JavaScript）</strong><ul>
<li>提供一个表单，允许用户输入<strong>组件名称</strong>、<strong>参数</strong>、<strong>Python 代码</strong>。</li>
<li>提交表单后，通过 <code>fetch()</code> 发送 <code>POST</code> 请求给后端。</li>
<li>组件创建成功后，前端可以调用 <code>run</code> 接口测试组件。</li>
</ul>
</li>
<li><strong>Postman 测试</strong><ul>
<li>先创建组件 <code>POST /api/components/create</code></li>
<li>再运行组件 <code>POST /api/components/run</code></li>
</ul>
</li>
</ol>
<hr>
<h1 id="1️⃣-后端代码（FastAPI）"><a href="#1️⃣-后端代码（FastAPI）" class="headerlink" title="1️⃣ 后端代码（FastAPI）"></a><strong>1️⃣ 后端代码（FastAPI）</strong></h1><p>创建 <code>server.py</code>，这个文件用于启动 FastAPI 服务器，并提供 API 端点。</p>
<blockquote>
<p><strong>安装依赖（如果未安装 FastAPI 和 Uvicorn）：</strong></p>
<pre><code class="python">pip install fastapi uvicorn pandas
</code></pre>
</blockquote>
<p>📌 <strong>代码（server.py）：</strong></p>
<pre><code class="python">from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import pandas as pd

app = FastAPI()

# 组件存储（模拟数据库）
components = &#123;&#125;

class ComponentData(BaseModel):
    name: str
    params: dict
    code: str

@app.post(&quot;/api/components/create&quot;)
def create_component(component: ComponentData):
    &quot;&quot;&quot;
    创建新的动态组件，存储在内存中，并使用 exec() 加载组件代码
    &quot;&quot;&quot;
    if component.name in components:
        raise HTTPException(status_code=400, detail=&quot;组件已存在&quot;)
    
    # 安全地执行代码，存储类定义
    local_vars = &#123;&#125;
    exec(component.code, globals(), local_vars)
    
    if component.name not in local_vars:
        raise HTTPException(status_code=400, detail=&quot;代码中必须定义同名类&quot;)
    
    components[component.name] = &#123;
        &quot;params&quot;: component.params,
        &quot;class&quot;: local_vars[component.name]
    &#125;
    return &#123;&quot;message&quot;: f&quot;组件 &#123;component.name&#125; 创建成功&quot;&#125;

@app.get(&quot;/api/components&quot;)
def list_components():
    &quot;&quot;&quot;
    获取所有注册的组件
    &quot;&quot;&quot;
    return &#123;&quot;components&quot;: list(components.keys())&#125;

class RunRequest(BaseModel):
    component_name: str
    history: list
    params: dict

@app.post(&quot;/api/components/run&quot;)
def run_component(request: RunRequest):
    &quot;&quot;&quot;
    运行指定的组件，并返回其输出
    &quot;&quot;&quot;
    if request.component_name not in components:
        raise HTTPException(status_code=404, detail=&quot;组件不存在&quot;)

    component_class = components[request.component_name][&quot;class&quot;]
    component_instance = component_class()
    
    # 调用 _run 方法，模拟运行
    try:
        result = component_instance._run(request.history, **request.params)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f&quot;组件执行错误: &#123;str(e)&#125;&quot;)
    
    return &#123;&quot;result&quot;: result.to_dict(orient=&quot;records&quot;)&#125;

# 运行服务器（可选：手动执行 uvicorn server:app --reload）
if __name__ == &quot;__main__&quot;:
    import uvicorn
    uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=8000)
</code></pre>
<hr>
<h1 id="2️⃣-前端代码"><a href="#2️⃣-前端代码" class="headerlink" title="2️⃣ 前端代码"></a><strong>2️⃣ 前端代码</strong></h1><h3 id="📌-HTML-页面"><a href="#📌-HTML-页面" class="headerlink" title="📌 HTML 页面"></a><strong>📌 HTML 页面</strong></h3><p>📌 <strong>代码（index.html）：</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;动态组件管理&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;创建动态组件&lt;/h2&gt;
    &lt;form id=&quot;componentForm&quot;&gt;
        &lt;label&gt;组件名称：&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;componentName&quot; required&gt;&lt;br&gt;&lt;br&gt;

        &lt;label&gt;参数 (JSON 格式)：&lt;/label&gt;
        &lt;textarea id=&quot;componentParams&quot; required&gt;&#123;&quot;param1&quot;: &quot;value1&quot;&#125;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;

        &lt;label&gt;Python 代码：&lt;/label&gt;
        &lt;textarea id=&quot;componentCode&quot; required&gt;
class TestComponent:
    def _run(self, history, **kwargs):
        return pd.DataFrame([&#123;&#39;content&#39;: &#39;Hello, this is a test!&#39;&#125;])
        &lt;/textarea&gt;&lt;br&gt;&lt;br&gt;

        &lt;button type=&quot;button&quot; onclick=&quot;submitNewComponent()&quot;&gt;提交组件&lt;/button&gt;
    &lt;/form&gt;

    &lt;h2&gt;运行组件&lt;/h2&gt;
    &lt;label&gt;组件名称：&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;runComponentName&quot; required&gt;&lt;br&gt;&lt;br&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;runComponent()&quot;&gt;运行组件&lt;/button&gt;

    &lt;h3&gt;运行结果：&lt;/h3&gt;
    &lt;pre id=&quot;result&quot;&gt;&lt;/pre&gt;

    &lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h3 id="📌-JavaScript-代码"><a href="#📌-JavaScript-代码" class="headerlink" title="📌 JavaScript 代码"></a><strong>📌 JavaScript 代码</strong></h3><p>📌 <strong>代码（test.js）：</strong></p>
<pre><code class="js">const apiBaseUrl = &quot;http://localhost:8000/api&quot;;  // 替换为你的服务器地址

function submitNewComponent() &#123;
    const name = document.getElementById(&quot;componentName&quot;).value;
    const params = document.getElementById(&quot;componentParams&quot;).value;
    const code = document.getElementById(&quot;componentCode&quot;).value;

    fetch(`$&#123;apiBaseUrl&#125;/components/create`, &#123;
        method: &quot;POST&quot;,
        headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,
        body: JSON.stringify(&#123;
            name: name,
            params: JSON.parse(params),
            code: code
        &#125;)
    &#125;)
    .then(response =&gt; response.json())
    .then(data =&gt; alert(data.message || JSON.stringify(data)))
    .catch(error =&gt; console.error(&quot;Error:&quot;, error));
&#125;

function runComponent() &#123;
    const componentName = document.getElementById(&quot;runComponentName&quot;).value;

    fetch(`$&#123;apiBaseUrl&#125;/components/run`, &#123;
        method: &quot;POST&quot;,
        headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,
        body: JSON.stringify(&#123;
            component_name: componentName,
            history: [],
            params: &#123;&#125;
        &#125;)
    &#125;)
    .then(response =&gt; response.json())
    .then(data =&gt; &#123;
        document.getElementById(&quot;result&quot;).innerText = JSON.stringify(data, null, 2);
    &#125;)
    .catch(error =&gt; console.error(&quot;Error:&quot;, error));
&#125;
</code></pre>
<hr>
<h1 id="3️⃣-使用-Postman-测试"><a href="#3️⃣-使用-Postman-测试" class="headerlink" title="3️⃣ 使用 Postman 测试"></a><strong>3️⃣ 使用 Postman 测试</strong></h1><p>启动服务器后，可以使用 Postman 测试 API。</p>
<h3 id="（1）创建动态组件"><a href="#（1）创建动态组件" class="headerlink" title="（1）创建动态组件"></a><strong>（1）创建动态组件</strong></h3><ul>
<li><p><strong>方法</strong>：<code>POST</code></p>
</li>
<li><p><strong>URL</strong>：<code>http://localhost:8000/api/components/create</code></p>
</li>
<li><p>Body（JSON）</p>
<pre><code class="python">&#123;
  &quot;name&quot;: &quot;TestComponent&quot;,
  &quot;params&quot;: &#123;
    &quot;param1&quot;: &quot;value1&quot;
  &#125;,
  &quot;code&quot;: &quot;class TestComponent:\n    def _run(self, history, **kwargs):\n        return pd.DataFrame([&#123;&#39;content&#39;: &#39;Hello, world!&#39;&#125;])&quot;
&#125;
</code></pre>
</li>
<li><p>期望结果</p>
<pre><code class="python">&#123;
  &quot;message&quot;: &quot;组件 TestComponent 创建成功&quot;
&#125;
</code></pre>
</li>
</ul>
<h3 id="（2）运行组件"><a href="#（2）运行组件" class="headerlink" title="（2）运行组件"></a><strong>（2）运行组件</strong></h3><ul>
<li><p><strong>方法</strong>：<code>POST</code></p>
</li>
<li><p><strong>URL</strong>：<code>http://localhost:8000/api/components/run</code></p>
</li>
<li><p>Body（JSON）</p>
<p>：</p>
<pre><code class="python">&#123;
  &quot;component_name&quot;: &quot;TestComponent&quot;,
  &quot;history&quot;: [],
  &quot;params&quot;: &#123;&#125;
&#125;
</code></pre>
</li>
<li><p>期望结果</p>
<p>：</p>
<pre><code class="python">&#123;
  &quot;result&quot;: [&#123;&quot;content&quot;: &quot;Hello, world!&quot;&#125;]
&#125;
</code></pre>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>后端</strong>：FastAPI 实现了组件创建、查询、运行的 API。</li>
<li><strong>前端</strong>：HTML + JS 提供交互界面，用户可输入参数和代码。</li>
<li><strong>测试</strong>：可用 Postman 调试，确保组件能被动态创建和运行。</li>
</ul>
<p>🚀 <strong>现在，你可以在 Postman 或前端界面中测试你的动态组件功能了！</strong></p>
<hr>
<p><span style = "color:red"><strong>纯后端情况如何添加自定义组件呢</strong></span></p>
<p>这里以我琢磨的<strong>JSONPath</strong>自定义组件为例</p>
<p>首先要清楚RAGFlow的执行流程 要了解画布的流程 推荐先看一遍RAGFlow执行流程的文档 然后了解一下canvas.py和canvas_app.py的源码 掌握整体流程。</p>
<p>这里最重要的一个思想要明白 现在你只有后端 你没有前端 你在RAGFlow图形化界面拖拽进去的形式已经无法针对于纯后端添加自定义组件了 那怎么办？我们来梳理一下思路 我们想要什么？我们想要图形化界面拖拽过后的整体数据 也就是数据库里的dsl，我们要拿到它 然后用我们自己开发的自定义组件去解析这个大大的JSON。那么这里就涉及到没有前端 你如何去后端去添加自己做的自定义组件！当然常规方法 去图形化界面拖拽已经无法完成这种操作 你只能把希望寄托在数据库 </p>
<p>我们来打开数据库 此时你需要一个组件的数据表 component</p>
<p>– rag_flow.component definition</p>
<p>CREATE TABLE <code>component</code> (</p>
<p>  <code>id</code> varchar(32) NOT NULL,</p>
<p>  <code>create_time</code> bigint DEFAULT NULL,</p>
<p>  <code>create_date</code> datetime DEFAULT NULL,</p>
<p>  <code>update_time</code> bigint DEFAULT NULL,</p>
<p>  <code>update_date</code> datetime DEFAULT NULL,</p>
<p>  <code>tenant_id</code> varchar(32) NOT NULL,</p>
<p>  <code>module</code> varchar(255) NOT NULL,</p>
<p>  <code>created_by</code> varchar(32) NOT NULL,</p>
<p>  <code>is_deleted</code> tinyint DEFAULT ‘0’,</p>
<p>  PRIMARY KEY (<code>id</code>)</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci;</p>
<p>这是创建表的信息 目前我们只需要关注module里面的 我们要把我们自己开发的组件按照那些形式添加进去 我的组件叫:”jsonpath” 那么我的module里面就应该是agent.component.jsonpath 当然你要按照它的风格把组件放在这个包里面。</p>
<p>其次还要注意在这个包里面的__init__.py </p>
<p>把你的组件加进去 “jsonpath”:”JSONPath”</p>
<p>此时并非万事大吉 因为我们目前只有纯后端 没有前端那些 所以回到开头所说 你要自己把你的组件以json的格式手动加入到数据库的dsl中 因为很长所以你需要<a target="_blank" rel="noopener" href="https://www.json.cn/">JSON在线解析格式化验证 - JSON.cn</a>去让它展示的更直观</p>
<p>这是我组件需要的json 你要手动的去添加到dsl 步骤就是先复制数据库的dsl 然后放在解析器里面 <strong>手动的去添加自己的组件</strong></p>
<p>“JSONPath:PathProcessor”: {“obj”: {“component_name”: “JSONPath”,”params”: {“output_var_name”: “output”,”jsonpath_expr”: “$.components[*].obj.component_name”,”debug_mode”: true,”query”: [],”inputs”: [],”debug_inputs”: [],”output”: {“content”: {“0”: “”}}}},”downstream”: [“Generate:TwelveClocksSpeak”],”upstream”: []}</p>
<p>这只是我的组件json 你需要在完整的dsl把它插入进去 按照它们形成的格式 这里说明一下 dsl就是你在图形化界面创建agent的时候里面各各组件的相关信息 当然你还要注意自己写的组件类型 是用来干什么的 你才能去做到对应相应的处理 比如说我这个是解析json的 那我就不能去拿上下文组件的输入或输出 正常的流程是连线后你要拿到上游的输出结果 作为你组件的输入结果。我这个则是拿到全局画布canvas_data数据再去进行解析</p>
<p>所以要明白需求才能去更好的融入代码中 经过这几天的学习真的感觉 只有自己一点点的摸索过后才能真正的印象深刻 才能慢慢变得强大！</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#ff7d73>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/03/19/AI/RAGFlow代理组件技术/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>