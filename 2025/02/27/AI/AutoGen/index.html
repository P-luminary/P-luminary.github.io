
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || AutoGen</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>AutoGen </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/27
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/AI" style=color:#ffa2c4>
                    AI
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <p><span style = "color:red"><strong>待完成</strong>：架构 设计思想 整个代码怎么组织起来的 怎么去满足各种需求 </span><br><u>B站牛人UP主【DataSense】</u><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7462775772009938970">AutoGen 技术博客系列 (一)：基础介绍与入门教程这篇博客提供了对 AutoGen 的基础介绍和入门教程，包括核心 - 掘金</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16u4y1j7so/?vd_source=a4d980c3208d51858f08b3025a6ab2d9">AutoGen 智能应用开发（一）｜AutoGen 基础_哔哩哔哩_bilibili</a></p>
<p>[microsoft&#x2F;autogen: A programming framework for agentic AI 🤖 PyPi: autogen-agentchat Discord: <a target="_blank" rel="noopener" href="https://aka.ms/autogen-discord">https://aka.ms/autogen-discord</a> Office Hour: <a target="_blank" rel="noopener" href="https://aka.ms/autogen-officehour]">https://aka.ms/autogen-officehour]</a> (<a target="_blank" rel="noopener" href="https://github.com/microsoft/autogen">https://github.com/microsoft/autogen</a>)</p>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>AutoGen</strong> 和 <strong>AutoGen Studio</strong> 都是由微软开发的用于创建和管理人工智能（AI）智能体的工具，但它们在功能和目标方面存在一些差异。</p>
<p>AutoGen 是一款基于 AI 和大数据技术的产品设计工具，旨在通过自动提取产品需求、智能优化设计方案并生成最终的产品模型或解决方案。其核心目标是将人工干预降至最低，从而提升用户体验和系统开发效率。AutoGen 是一个开源的 Python 框架，用于定义、配置和组合 AI 代理以构建多智能体应用。它提供了一种用于描述代理行为和它们之间交互的声明性语言。AutoGen 非常灵活，可用于构建各种多智能体应用，但它需要一定的编程技能才能使用。</p>
<p>AutoGen Studio 是一个基于 AutoGen 框架的图形用户界面（GUI）工具。它使开发人员能够更轻松地创建和管理多智能体应用，而无需编写代码。AutoGen Studio 提供了拖放式界面和各种预构建模块，可以简化多智能体应用的开发过程。但是，AutoGen Studio 的灵活性不如 AutoGen，并且它可能不适用于需要高度定制的应用。</p>
<p>以下表格总结了 AutoGen 和 AutoGen Studio 的一些关键区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">AutoGen</th>
<th align="left">AutoGen Studio</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型</td>
<td align="left">框架</td>
<td align="left">GUI 工具</td>
</tr>
<tr>
<td align="left">抽象级别</td>
<td align="left">更底层</td>
<td align="left">更高层</td>
</tr>
<tr>
<td align="left">灵活度</td>
<td align="left">更灵活</td>
<td align="left">不太灵活</td>
</tr>
<tr>
<td align="left">易用性</td>
<td align="left">更难使用</td>
<td align="left">更易使用</td>
</tr>
<tr>
<td align="left">编程要求</td>
<td align="left">需要编程技能</td>
<td align="left">无需编程技能</td>
</tr>
<tr>
<td align="left">常见用例</td>
<td align="left">高度定制的多智能体应用</td>
<td align="left">通用多智能体应用</td>
</tr>
</tbody></table>
<p><strong>总而言之，AutoGen</strong> 适合需要高度定制和灵活性的多智能体应用开发人员，而 <strong>AutoGen Studio</strong> 适合需要快速构建通用多智能体应用的开发人员。</p>
<p>AI + 行业 &#x3D; Agent</p>
<p>只需要把接口复制粘贴来到AutoGen Studio的技能表<br>**<u>万能API</u>**：[<strong>天聚数行TianAPI - 应用开发者API数据调用平台</strong>] (<a target="_blank" rel="noopener" href="https://www.tianapi.com/">https://www.tianapi.com/</a>)</p>
<p>我们要去给智能体配置上你需要的能力！</p>
<p>我结合智能体我可以做到每个行业 但每个行业都有自己角色的一个定义<br>我要给智能体定义角色</p>
<hr>
<blockquote>
<ol>
<li><strong>技术基础和领域：</strong><ul>
<li>“AutoGen” 可能依赖于特定的技术，如机器学习算法、自然语言处理模型等，<br>主要用于自动化代码生成、文档自动提取或数据分析任务。</li>
<li>“AiAgent” 则是人工智能领域的核心概念，涵盖从需求理解到解决方案生成的<br>全生命周期管理。它能够将不同领域的需求整合起来，提供综合性的解决方案。</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li>在“AutoGen”的应用中，可能包括自动化代码生成、文档自动化处理、数据分析<br>工具的构建等。</li>
<li>在“AiAgent”的应用中，可能涉及需求分析和理解，数据预处理与清洗，以及生<br>成生成模型（如“AutoGen”）中的产品设计生成。</li>
</ul>
</li>
<li><strong>功能特点：</strong><ul>
<li>“AutoGen” 可能专注于自动化、快速迭代和标准化能力，适合需要大量重复劳<br>动的任务。</li>
<li>“AiAgent” 通常结合人工智能的高级算法和分布式系统，能够处理复杂、多领<br>域的问题，并提供灵活的解决方案。</li>
</ul>
</li>
<li><strong>研究方向与应用深度：</strong><ul>
<li>在“AutoGen”的研究中，可能侧重于特定任务的具体实现和技术优化。</li>
<li>在“AiAgent”的研究中，可能涉及跨领域的知识融合、分布式计算环境等高级技<br>术，推动了AI领域的发展。</li>
</ul>
</li>
</ol>
</blockquote>
<p>全自动化的 <strong>AI Agents</strong></p>
<p>LangChain可以实现做AI Agent<br>XAgent || <strong>AutoGen</strong> 是更一步进化的</p>
<p>如果有与图片输出相关的，帮忙加一个GenImg(“图片生成提示 <strong>Prompt</strong>“)<br>利用Prompt设定可以分配任务到不同的Agent上</p>
<p><strong>AutoGen</strong> 是一个框架，支持使用多个代理来开发 LLM 应用程序这些代理可以相互对话来解决任务。AutoGen 代理是可定制的、可对话的，并且无缝地允许人参与其中。他们可以结合 LLM、人工输入和不同工具的各种模式运行。</p>
<p><strong>AutoGen</strong>是微软的开源框架</p>
<p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/microsoft/autogen">microsoft&#x2F;autogen: A programming framework for agentic AI 🤖 PyPi: autogen-agentchat Discord: https://aka.ms/autogen-discord Office Hour: https://aka.ms/autogen-officehour</a></p>
<p>文档博客：<a target="_blank" rel="noopener" href="https://microsoft.github.io/autogen/stable/">AutoGen — AutoGen</a></p>
<h5 id="AutoGen-主要特点"><a href="#AutoGen-主要特点" class="headerlink" title="AutoGen 主要特点"></a>AutoGen 主要特点</h5><p>AutoGen 可以轻松构建基于多代理对话的下一代 LLM 应用程序。它简化了复杂的LLM 工作流程的编排、自动化和优化。它最大限度地提高了 LLM 模型的性能并克服了它们的弱点。<br>它支持复杂工作流程的多种对话模式。借助可定制和可对话的代理，开发人员可以使用 AutoGen 构建各种涉及对话自主性、代理数量和代理对话拓扑的对话模式。<br>它提供了一系列具有不同复杂性的工作系统。 这些系统涵盖各种领域和复杂性的广泛应用。 这演示了 AutoGen 如何轻松支持不同的对话模式。<br>AutoGen 提供增强的 LLM 推理。 它提供 API统一和缓存等实用程序，以及错误处理、多配置推理、上下文编程等高级使用模式。</p>
<p>AutoGen 抽象并实现了可对话代理，旨在通过代理间对话来解决任务。<br><strong>可对话</strong>：AutoGen 中的代理是可对话的，这意味着任何代理都可以从其他代理发送和接收消息以发起或继续对话<br><strong>可定制</strong>：AutoGen 中的代理可以定制以集成 LLM、人、工具或它们的组合。</p>
<hr>
<h6 id="★-PyCharm怎么打开-ipynb后缀文件-我需要详细步骤-我pycharm里面没有这个？"><a href="#★-PyCharm怎么打开-ipynb后缀文件-我需要详细步骤-我pycharm里面没有这个？" class="headerlink" title="★ PyCharm怎么打开.ipynb后缀文件 我需要详细步骤 我pycharm里面没有这个？"></a>★ PyCharm怎么打开.ipynb后缀文件 我需要详细步骤 我pycharm里面没有这个？</h6><p>如果 PyCharm 版本较老或者插件不可用，可以用外部 Jupyter Notebook 运行：</p>
<ol>
<li><p>安装 Jupyter</p>
<p>打开 PyCharm 自带的 Terminal（终端）输入：</p>
<pre><code class="python">pip install jupyter
</code></pre>
</li>
<li><p>在 Terminal 里启动 <strong>Jupyter</strong></p>
<pre><code class="python">jupyter notebook
</code></pre>
</li>
<li><p><strong>在浏览器中打开 .ipynb</strong> Jupyter Notebook 会在浏览器中打开，你可以在其中编辑 <code>.ipynb</code> 文件。</p>
</li>
</ol>
<h5 id="AutoGen基础环境配置"><a href="#AutoGen基础环境配置" class="headerlink" title="AutoGen基础环境配置"></a>AutoGen基础环境配置</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/epitomizelu/article/details/140287498?ops_request_misc=%7B%22request_id%22:%2202bd36b0219fe5e5f9a59b0a71085885%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=02bd36b0219fe5e5f9a59b0a71085885&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-140287498-null-null.142%5Ev101%5Epc_search_result_base7&utm_term=%E6%80%8E%E4%B9%88%E4%B8%8B%E8%BD%BDautogen&spm=1018.2226.3001.4187">AutoGen基础环境安装_autogen安装-CSDN博客</a></p>
<p>windows开始菜单搜索栏，搜索prompt，搜索结果中可以看应用<code>Aanconda Powershell Prompt</code>。</p>
<p>接下来，我们将使用这个工具创建一个特定版本的Python环境。<br>在打开的命令行工具中输入如下命令，然后回车。</p>
<p><code>conda create -n lcy python=3.10</code></p>
<blockquote>
<p>-n 后面是的lcy是环境的名称，相当于一个标识，后续要用这个环境时通过这个名称进行查找<br>python&#x3D;3.10，是指定python的版本</p>
</blockquote>
<p>接下来，输入如下命令，切换到创建好的环境。</p>
<p>★ <code>conda activate lcy</code></p>
<p>接下来我们需要安装Autogen Studio。<br>那怎么安装呢？超级简单，在刚刚我们准备好的python环境中执行一个命令就好。</p>
<p><code>pip install autogen studio</code></p>
<p>但如果直接这样执行的话，因为它会访问国外的网站完成下载，所以速度非常慢，慢到不能忍受。所以我们需要让它去国内的镜像下载。通过参数-i指定国内镜像地址，我们使用阿里云的镜像。</p>
<p>上述命令就变成如下这样了。</p>
<p><code>pip install autogenstudio -i https://mirrors.aliyun.com/pypi/simple</code></p>
<p>下载之后，使用如下命令启动autogen studio服务。</p>
<pre><code class="bash">★ (lcy) C:\Users\Pluminary&gt; autogenstudio ui --port 6001
</code></pre>
<p>之后直接访问<code>AutoGen Studio [Beta]</code> → [127.0.0.1:6001] (<a target="_blank" rel="noopener" href="http://127.0.0.1:6001/">http://127.0.0.1:6001/</a>)</p>
<blockquote>
<p>在AutoGen Studio中，Team Builder是一个功能模块，允许用户配置和管理不同的Agents来构建多智能体系统。下面是对您提到的几种Agents的详细分析：</p>
<h6 id="AssistantAgent"><a href="#AssistantAgent" class="headerlink" title="AssistantAgent"></a>AssistantAgent</h6><ul>
<li><strong>用途</strong>：AssistantAgent 是一种用于处理和生成对话的智能体。它可以用来创建聊天机器人、虚拟助手或任何需要与用户进行交互的应用程序。</li>
<li>功能<ul>
<li><strong>对话生成</strong>：能够基于用户的输入生成自然语言响应。</li>
<li><strong>任务执行</strong>：可以执行特定的任务，如信息查询、简单计算或执行预设的命令。</li>
<li><strong>上下文管理</strong>：保持对话的上下文，使得对话更加连贯和自然。</li>
</ul>
</li>
</ul>
<h6 id="Web-Surfer-Agent"><a href="#Web-Surfer-Agent" class="headerlink" title="Web Surfer Agent"></a>Web Surfer Agent</h6><ul>
<li><strong>用途</strong>：Web Surfer Agent 专门用于从互联网上检索信息。它是一个网络爬虫，能够访问网页并提取有用的信息。</li>
<li>功能<ul>
<li><strong>网页访问</strong>：能够访问指定的网页，获取内容。</li>
<li><strong>信息提取</strong>：从网页中提取结构化或非结构化数据。</li>
<li><strong>数据整合</strong>：将提取的数据整合到对话或应用程序中。</li>
</ul>
</li>
</ul>
<h6 id="Verification-Assistant"><a href="#Verification-Assistant" class="headerlink" title="Verification Assistant"></a>Verification Assistant</h6><ul>
<li><strong>用途</strong>：Verification Assistant 用于验证信息的准确性或执行某些检查任务。</li>
<li>功能<ul>
<li><strong>数据验证</strong>：检查数据的准确性，例如验证用户输入的信息是否符合特定的格式或标准。</li>
<li><strong>逻辑验证</strong>：执行逻辑检查，比如验证某个流程是否按照预定的规则执行。</li>
<li><strong>合规性检查</strong>：确保操作符合特定的行业或法律标准。</li>
</ul>
</li>
</ul>
<h6 id="UserProxyAgent"><a href="#UserProxyAgent" class="headerlink" title="UserProxyAgent"></a>UserProxyAgent</h6><ul>
<li><strong>用途</strong>：UserProxyAgent 代表用户执行操作，通常用于模拟用户行为或自动化用户任务。</li>
<li>功能<ul>
<li><strong>行为模拟</strong>：模拟用户的行为，例如在测试环境中模拟用户操作。</li>
<li><strong>任务自动化</strong>：自动化重复性的用户任务，提高效率。</li>
<li><strong>隐私保护</strong>：在需要保护用户隐私的场景中，代替用户执行操作，减少个人信息泄露的风险。</li>
</ul>
</li>
</ul>
<p>在Team Builder中，这些Agents可以被配置和组合，以构建复杂的工作流程。例如，一个工作流程可能首先使用Web Surfer Agent从网络上获取信息，然后由AssistantAgent处理这些信息并生成响应，最后由Verification Assistant验证响应的准确性。通过这种方式，AutoGen Studio 提供了一个灵活且强大的平台，用于创建高效且可扩展的多智能体系统。</p>
</blockquote>
<hr>
<hr>
<p><strong>ConversableAgent</strong> 是一个综合性的智能对话系统，它能够提供个性化和高效的交流体验</p>
<p><strong>AssistantAgent（助手代理）</strong>：</p>
<p>想象一下你有一个智能助手，比如Siri或Alexa，AssistantAgent就像是这个助手的大脑。它的任务是理解和处理用户的请求，然后做出相应的回应。在AutoGen系统中，AssistantAgent负责接收用户的信息，分析这些信息，并根据预设的规则或逻辑来执行任务。比如，如果你告诉助手“我明天有个会议”，AssistantAgent就会帮你设置提醒或者添加到日程中。</p>
<p><strong>UserProxyAgent（用户代理代理）</strong>：</p>
<p>想象你在玩一个角色扮演游戏，UserProxyAgent就像是你的角色，它代表你在游戏世界中行动。在AutoGen系统中，UserProxyAgent代表用户与系统或其他用户进行交互。它可以是用户的替身，执行用户的命令，或者代表用户参与某些活动。比如，如果你在一个在线论坛上，UserProxyAgent可以帮你发帖或者回复别人的评论。</p>
<p><strong>GroupChatManager（群聊管理器）</strong>：</p>
<p>想象你在参加一个多人在线会议或群聊，GroupChatManager就像是会议的主持人或者群聊的管理员。它的职责是协调群聊中的所有参与者，确保信息流畅且有序地传递。在AutoGen系统中，GroupChatManager负责管理群聊的各个方面，比如邀请成员加入、监控聊天内容、维持聊天秩序等。如果有人在群聊中发了不合适的内容，GroupChatManager可能会介入处理。</p>
<hr>
<p><span style = "color:red">在PyCharm中新建一个基于<strong>conda</strong>的工程文件</span><br><u><strong>在命令行里输入</strong></u>:<code> pip install pyautogen</code></p>
<p>本地启动 DeepSeek → <code>C:\Users\Pluminary&gt;ollama run deepseek-r1:1.5b</code></p>
<h5 id="配置Open-WebUI"><a href="#配置Open-WebUI" class="headerlink" title="配置Open WebUI"></a>配置Open WebUI</h5><p><span style = "color:red"><strong>可以测试模型的问答</strong></span></p>
<h6 id="先安装conda"><a href="#先安装conda" class="headerlink" title="先安装conda"></a>先安装conda</h6><pre><code class="python">conda create -n open-webui python=3.11.0
activate open-webui

# 开源的访问大模型管理页面
pip install open-webui
</code></pre>
<h6 id="配置WebUI：启动"><a href="#配置WebUI：启动" class="headerlink" title="配置WebUI：启动"></a>配置WebUI：启动</h6><pre><code class="python">open-webui serve
------------------
http://localhost:8080
</code></pre>
<pre><code class="python">sentence_bert_config.json: 100%|████████████████████████████████████████████████████████████| 53.0/53.0 [00:00&lt;?, ?B/s]
tokenizer_config.json: 100%|██████████████████████████████████████████████████████████████████| 350/350 [00:00&lt;?, ?B/s]
vocab.txt: 100%|████████████████████████████████████████████████████████████████████| 232k/232k [00:00&lt;00:00, 1.17MB/s]
tokenizer.json: 100%|███████████████████████████████████████████████████████████████| 466k/466k [00:00&lt;00:00, 26.0MB/s]
special_tokens_map.json: 100%|████████████████████████████████████████████████████████████████| 112/112 [00:00&lt;?, ?B/s]
INFO:     Started server process [18264]
INFO:     Waiting for application startup.
2025-02-28 08:29:21.807 | INFO     | open_webui.utils.logger:start_logger:140 - GLOBAL_LOG_LEVEL: INFO - &#123;&#125;

# 等看到端口号再去访问 18264
</code></pre>
<hr>
<h4 id="利用Python部署本地DeepSeek并进行连通"><a href="#利用Python部署本地DeepSeek并进行连通" class="headerlink" title="利用Python部署本地DeepSeek并进行连通"></a>利用Python部署本地DeepSeek并进行连通</h4><pre><code class="python"># 用于发送 HTTP 请求。在此代码中，我们使用它与本地部署的 DeepSeek 服务进行通信
import requests
# 用于处理 JSON 数据，尤其是在发送和接收 HTTP 请求时
import json


# 定义与 DeepSeek 服务交互的类
class DeepSeekChat:
    # 这个类负责与 DeepSeek 服务进行交互 它接受两个参数：
    &#39;&#39;&#39;
     model：模型名称，在这个案例中是 &quot;deepseek-r1:1.5b&quot;。
     base_url：DeepSeek 服务的 API 基础 URL，即本地部署的 DeepSeek 服务地址。
     
我们通常使用self作为第一个参数的名称。这是为了代码的可读性和一致性。这个约定使得其他阅读你代码的Python程序员能够立即识别出self代表的是类的实例。
    &#39;&#39;&#39;
    def __init__(self, model, base_url):
        self.model = model
        self.base_url = base_url

    # send_message 方法：该方法接收一个消息列表 messages
    # 并构建一个 POST 请求的有效负载（payload），包括模型名称和消息内容。messages 是一个包含多条消息的列表。
    def send_message(self, messages):
        # 构建请求数据
        payload = &#123;
            &quot;model&quot;: self.model,
            &quot;messages&quot;: messages
        &#125;
        # 设置请求头，指定请求体的内容类型为 application/json
        headers = &#123;
            &quot;Content-Type&quot;: &quot;application/json&quot;
        &#125;

        # 发送请求到本地 DeepSeek 服务
 &#39;&#39;&#39;
使用 requests.post() 发送 HTTP POST 请求到 DeepSeek 服务的 API 地址 self.base_url
json.dumps(payload) 将请求体的负载 payload 转换为 JSON 格式的字符串。
 &#39;&#39;&#39;
        response = requests.post(self.base_url, headers=headers, data=json.dumps(payload))

        if response.status_code == 200:
            return response.json()  # 返回 DeepSeek 返回的响应
        else:
            return &#123;&quot;error&quot;: f&quot;Request failed with status code &#123;response.status_code&#125;&quot;&#125;


# 定义初始化消息 定义启动对话函数
&#39;&#39;&#39;
此函数启动并管理与用户的对话。它定义了一个初始化的 messages 列表，其中包含一个系统消息，系统消息的角色是 &quot;system&quot;，内容是 &quot;You are a helpful assistant.&quot;，这将告诉模型其应扮演的角色
&#39;&#39;&#39;
def start_conversation():
    messages = [
        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;  # 系统消息定义角色
    ]

    # 初始化 DeepSeekChat 实例
    deepseek_chat = DeepSeekChat(
        model=&quot;deepseek-r1:1.5b&quot;,  # 使用的本地模型
        base_url=&quot;http://localhost:11434/v1/chat/completions&quot;  # 本地服务 URL
    )
# 创建一个 DeepSeekChat 类的实例 deepseek_chat，并传入本地模型和服务的 URL
    while True:
        try:
            # 获取用户输入问题
            user_input = input(&quot;You: &quot;)

            # 如果用户输入 &quot;exit&quot; 退出循环
            # 进入一个 while True 循环，不断等待用户输入
            #用户的每次输入都会被捕获并存储在 user_input 变量中。

            if user_input.lower() == &quot;exit&quot;:
                print(&quot;Exiting the conversation.&quot;)
                break

            # 添加用户消息
             essages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;)

            # 发送用户消息并获取模型回答 将用户的输入添加到 messages 列表中，消息的角色设置为 &quot;user&quot;。
            response = deepseek_chat.send_message(messages)

            # 检查响应是否包含错误
            if &quot;error&quot; in response:
                print(response[&quot;error&quot;])
            else:
                # 打印 DeepSeek 模型的回答
                answer = response.get(&quot;choices&quot;, [&#123;&#125;])[0].get(&quot;message&quot;, &#123;&#125;).get(&quot;content&quot;, &quot;No response&quot;)
                print(&quot;DeepSeek: &quot; + answer)

        except KeyboardInterrupt:
            print(&quot;\nExiting the conversation due to user interrupt.&quot;)
            break
&#39;&#39;&#39;
if __name__ == &quot;__main__&quot;: 语句保证只有当脚本作为主程序执行时才会调用 start_conversation 函数。如果该脚本被作为模块导入到其他脚本中，则不会执行该函数。
&#39;&#39;&#39;

if __name__ == &quot;__main__&quot;:
    start_conversation()
</code></pre>
<h6 id="假设你已经理解了-DeepSeek-的基础代码，下面的例子演示了如何使用-AutoGen-集成-DeepSeek："><a href="#假设你已经理解了-DeepSeek-的基础代码，下面的例子演示了如何使用-AutoGen-集成-DeepSeek：" class="headerlink" title="假设你已经理解了 DeepSeek 的基础代码，下面的例子演示了如何使用 AutoGen 集成 DeepSeek："></a><strong>假设你已经理解了 DeepSeek 的基础代码，下面的例子演示了如何使用 AutoGen 集成 DeepSeek：</strong></h6><pre><code class="python">import requests
from autogen import Agent, GroupChat, GroupChatManager
from autogen.models.openai import OpenAIChatCompletionClient
import json

# 定义与 DeepSeek 服务交互的类
class DeepSeekChat:
    def __init__(self, model, base_url):
        self.model = model
        self.base_url = base_url

    def send_message(self, messages):
        payload = &#123;
            &quot;model&quot;: self.model,
            &quot;messages&quot;: messages
        &#125;
        headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;
        response = requests.post(self.base_url, headers=headers, data=json.dumps(payload))
        
        if response.status_code == 200:
            return response.json()
        else:
            return &#123;&quot;error&quot;: f&quot;Request failed with status code &#123;response.status_code&#125;&quot;&#125;

# 创建自定义代理（DeepSeek 代理）
class DeepSeekAgent(Agent):
    def __init__(self, model, base_url):
        super().__init__(name=&quot;DeepSeekAgent&quot;)
        self.chat = DeepSeekChat(model, base_url)

    def on_message(self, message):
        response = self.chat.send_message([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message&#125;])
        return response.get(&quot;choices&quot;, [&#123;&#125;])[0].get(&quot;message&quot;, &#123;&#125;).get(&quot;content&quot;, &quot;No response&quot;)

# 创建用户代理
class UserAgent(Agent):
    def __init__(self):
        super().__init__(name=&quot;UserAgent&quot;)

    def on_message(self, message):
        return message

# 设置 DeepSeek 代理
deepseek_agent = DeepSeekAgent(model=&quot;deepseek-r1:1.5b&quot;, base_url=&quot;http://localhost:11434/v1/chat/completions&quot;)
user_agent = UserAgent()

# 创建群聊
group_chat = GroupChat(agents=[deepseek_agent, user_agent])
group_chat_manager = GroupChatManager(group_chat)

# 启动对话
def start_conversation():
    while True:
        try:
            user_input = input(&quot;You: &quot;)
            if user_input.lower() == &quot;exit&quot;:
                print(&quot;Exiting the conversation.&quot;)
                break
            
            response = group_chat_manager.handle_message(user_input)
            print(f&quot;DeepSeek: &#123;response&#125;&quot;)
        
        except KeyboardInterrupt:
            print(&quot;\nExiting the conversation due to user interrupt.&quot;)
            break

if __name__ == &quot;__main__&quot;:
    start_conversation()
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>