
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 洪哥面试题</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>洪哥面试题 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/9
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/面试" style=color:#ffa2c4>
                    面试
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】【N+1】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】【2N+1】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.<strong>继承</strong> Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.<strong>实现</strong> Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。 [无返回值]<br>3.<strong>实现</strong> Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。[有返回值]<br>4.使用<strong>线程池</strong>创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<pre><code class="java">// 1. 继承Thread类并重写run方法
class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 继承Thread类&quot;);
    &#125;
&#125;

// 2. 实现Runnable接口并重写run方法
class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 实现Runnable接口&quot;);
    &#125;
&#125;

// 3. 实现Callable接口并重写call方法
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable&lt;String&gt; &#123;
    @Override
    public String call() throws Exception &#123;
        System.out.println(&quot;线程运行中 - 实现Callable接口&quot;);
        return &quot;Callable线程返回结果&quot;;
    &#125;
&#125;

// 4. 使用线程池创建线程
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadCreationExamples &#123;
    public static void main(String[] args) &#123;
        // 继承Thread类创建线程
        Thread thread1 = new MyThread();
        thread1.start();

        // 实现Runnable接口创建线程
        Thread thread2 = new Thread(new MyRunnable());
        thread2.start();

        // 实现Callable接口创建线程
        MyCallable callable = new MyCallable();
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
        Thread thread3 = new Thread(futureTask);
        thread3.start();
        try &#123;
            // 获取线程执行结果的返回值
            String result = futureTask.get();
            System.out.println(result);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        // 使用线程池创建线程
        ExecutorService executor = Executors.newFixedThreadPool(2);
        executor.execute(new MyRunnable()); // 提交Runnable任务
        executor.submit(new MyCallable()); // 提交Callable任务
        executor.shutdown(); // 关闭线程池
    &#125;
&#125;
</code></pre>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><blockquote>
<h6 id="七大核心参数解释"><a href="#七大核心参数解释" class="headerlink" title="七大核心参数解释"></a><strong>七大核心参数解释</strong></h6><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td><strong>核心线程数</strong>，线程池常驻的线程数量，即使空闲也不会被销毁（除非 <code>allowCoreThreadTimeOut = true</code>）</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td><strong>最大线程数</strong>，线程池能容纳的最大线程数量（包括核心线程）</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td><strong>非核心(临时)线程的存活时间</strong>，超过这个时间，空闲的线程会被回收</td>
</tr>
<tr>
<td><code>unit</code></td>
<td><strong>时间单位</strong>，<code>keepAliveTime</code> 的时间单位，如：秒（<code>TimeUnit.SECONDS</code>）</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td><strong>任务(阻塞)队列</strong>，用于缓存提交但尚未执行的任务（如：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>）</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td><strong>线程工厂</strong>，用于自定义线程创建（可以设置线程名称、是否为守护线程等）</td>
</tr>
<tr>
<td><code>handler</code></td>
<td><strong>拒绝策略</strong>，当任务队列已满且线程数量达到最大线程数时的处理方式；(抛不抛异常…)</td>
</tr>
</tbody></table>
</blockquote>
<p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li><strong>异步任务处理</strong>：<u>将任务提交到线程池异步执行</u>，而不阻塞主线程</li>
</ul>
<blockquote>
<p>假设我们有一个电商平台，其中一个核心业务是处理用户订单。在订单处理过程中，我们需要执行以下任务：</p>
<ol>
<li><h6 id="验证订单信息（例如：检查库存、验证用户信息等）。"><a href="#验证订单信息（例如：检查库存、验证用户信息等）。" class="headerlink" title="验证订单信息（例如：检查库存、验证用户信息等）。"></a>验证订单信息（例如：检查库存、验证用户信息等）。</h6></li>
<li><h6 id="计算订单金额（包括商品价格、折扣、运费等）。"><a href="#计算订单金额（包括商品价格、折扣、运费等）。" class="headerlink" title="计算订单金额（包括商品价格、折扣、运费等）。"></a>计算订单金额（包括商品价格、折扣、运费等）。</h6></li>
<li><h6 id="生成订单并保存到数据库。"><a href="#生成订单并保存到数据库。" class="headerlink" title="生成订单并保存到数据库。"></a>生成订单并保存到数据库。</h6></li>
<li><h6 id="发送订单确认邮件给用户。"><a href="#发送订单确认邮件给用户。" class="headerlink" title="发送订单确认邮件给用户。"></a>发送订单确认邮件给用户。</h6></li>
</ol>
<p>由于这些任务相对独立，并且处理时间可能较长，我们希望在不影响用户操作的前提下异步执行它们。以下是使用线程池处理这些异步任务的模拟代码：</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class Order &#123;
    // 订单信息
    private String orderId;
    private String userId;
    private double amount;

    // 构造函数、getter和setter省略
&#125;

class OrderService &#123;
    private ExecutorService executorService = Executors.newFixedThreadPool(10); // 假设线程池大小为10

    // 处理订单
    public void processOrder(Order order) &#123;
        // 1. 验证订单信息
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;验证订单信息: &quot; + order.getOrderId());
            // 假设验证成功
        &#125;);

        // 2. 计算订单金额
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;计算订单金额: &quot; + order.getOrderId());
            // 假设计算成功，设置订单金额
            order.setAmount(100.0); // 示例金额
        &#125;);

        // 3. 生成订单并保存到数据库
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;生成订单并保存到数据库: &quot; + order.getOrderId());
            // 假设保存成功
        &#125;);

        // 4. 发送订单确认邮件
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;发送订单确认邮件: &quot; + order.getOrderId());
            // 假设邮件发送成功
        &#125;);
    &#125;

    // 关闭线程池
    public void shutdown() &#123;
        try &#123;
            executorService.shutdown();
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executorService.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executorService.shutdownNow();
        &#125;
    &#125;
&#125;

public class ThreadPoolApplication &#123;
    public static void main(String[] args) &#123;
        OrderService orderService = new OrderService();
        Order order = new Order();
        order.setOrderId(&quot;ORDER12345&quot;);
        order.setUserId(&quot;USER12345&quot;);

        // 处理订单
        orderService.processOrder(order);

        // 假设主线程还有其他任务，这里模拟等待其他任务完成
        try &#123;
            Thread.sleep(5000); // 等待5秒
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        // 关闭线程池
        orderService.shutdown();
    &#125;
&#125;
</code></pre>
<p>在这个模拟场景中，我们创建了一个 <code>OrderService</code> 类，它包含一个线程池用于异步处理订单的各个步骤。当用户创建订单时，<code>processOrder</code> 方法会将订单处理的各个任务提交到线程池中异步执行。这样，主线程不会被阻塞，可以继续处理其他用户请求或执行其他任务。在所有任务都提交到线程池后，主线程可能会执行其他逻辑，最后调用 <code>shutdown</code> 方法来优雅地关闭线程池。</p>
<hr>
<h5 id="线程池执行流程图解"><a href="#线程池执行流程图解" class="headerlink" title="线程池执行流程图解"></a>线程池执行流程图解</h5><p>当你调用：</p>
<pre><code class="java">executorService.submit(() -&gt; &#123;
    // 任务逻辑
&#125;);
</code></pre>
<p>实际上背后会触发 <code>ThreadPoolExecutor</code> 的如下处理逻辑：<strong>线程池内部执行流程</strong></p>
<ol>
<li><strong>核心线程数未满</strong>：<ul>
<li>立即创建新线程来处理该任务。</li>
</ul>
</li>
<li><strong>核心线程数已满</strong>，进入下一步：<ul>
<li>将任务放入任务队列（如 <code>LinkedBlockingQueue</code>）。</li>
</ul>
</li>
<li><strong>任务队列已满</strong>，进入下一步：<ul>
<li>判断当前线程数是否小于最大线程数：<ul>
<li>如果小于，创建非核心线程来执行任务；</li>
<li>如果等于最大线程数，触发 <strong>拒绝策略</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>执行完毕</strong>的线程会回到池中等待下一个任务（如果有），<strong>非核心线程在空闲超时后会被销毁</strong>。</li>
</ol>
<h4 id="结合你的业务场景做解析"><a href="#结合你的业务场景做解析" class="headerlink" title="结合你的业务场景做解析"></a>结合你的业务场景做解析</h4><p>你这个订单场景中，共有 <strong>四个异步任务</strong>：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>任务名称</th>
<th>是否必须顺序</th>
<th>是否耗时</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td>验证订单</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>②</td>
<td>计算金额</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>③</td>
<td>写入数据库</td>
<td>否（有依赖）</td>
<td>是</td>
</tr>
<tr>
<td>④</td>
<td>发送确认邮件</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>“不一定必须顺序”，是基于<strong>“线程池异步任务” 的并发角度</strong>而言的 —— 如果某些任务之间没有直接依赖关系<strong>，那就可以并发异步执行，提高效率。</strong></p>
<p>但是你指出了一个关键点：这个场景中每个步骤其实<strong>是有依赖关系</strong>的，这种顺序性是业务逻辑所要求的，<strong>不是线程池可以随意打乱的</strong>！</p>
</blockquote>
<p>✅ 这正是线程池最适用的场景：<strong>任务独立 &#x2F; 可并行处理 &#x2F; 需要节省响应时间</strong></p>
<h3 id="🧠-所以在这个场景中，线程池的正确使用方式应该是："><a href="#🧠-所以在这个场景中，线程池的正确使用方式应该是：" class="headerlink" title="🧠 所以在这个场景中，线程池的正确使用方式应该是："></a>🧠 所以在这个场景中，线程池的<strong>正确使用方式</strong>应该是：</h3><p>我们不能把所有任务都直接丢进线程池 <strong>并发执行</strong>，而应该是：</p>
<pre><code class="yaml">主线程：
    1. 验证订单（同步执行）
    2. 计算金额（同步执行或异步计算后 get() 等待结果）
    3. 写入数据库（依赖前面两个成功）
    4. 发送确认邮件（可异步执行）
</code></pre>
<p>✅ 其中 <strong>步骤 ④ 发送邮件</strong> 是唯一适合异步执行的 —— 它不影响主流程，可以交给线程池异步去发。</p>
<p><strong>订单处理是有严格先后顺序依赖的</strong>：</p>
<ul>
<li><strong>验证 → 金额 → 入库 → 邮件</strong> 是一条主流程链；</li>
<li>线程池 <strong>不是用来打乱这个顺序的</strong>，而是用来 <strong>并发执行不影响主流程的附属任务</strong>（如邮件通知、日志、异步推送等）；</li>
</ul>
<hr>
<h4 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a><strong>使用线程池的好处：</strong></h4><ul>
<li>🚀 <strong>提升响应速度</strong>：主线程快速返回（如 UI&#x2F;接口响应），耗时任务交给线程池异步完成。</li>
<li>✅ <strong>防止线程资源滥用</strong>：相比每个任务都<code>new Thread()</code>，线程池能<strong>重用线程</strong>，避免频繁创建&#x2F;销毁造成资源浪费。</li>
<li>🔒 <strong>线程复用 + 并发控制</strong>：通过设置 <code>corePoolSize</code> 和 <code>queueCapacity</code> 控制系统负载。</li>
</ul>
<pre><code class="java">ExecutorService executorService = new ThreadPoolExecutor(
    5,                // 核心线程数
    10,               // 最大线程数
    60,               // 非核心线程的空闲存活时间
    TimeUnit.SECONDS,
    new LinkedBlockingQueue&lt;&gt;(100), // 队列长度
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy() // 拒绝策略
);
</code></pre>
<h4 id="🎯-参数如何选择："><a href="#🎯-参数如何选择：" class="headerlink" title="🎯 参数如何选择："></a>🎯 参数如何选择：</h4><table>
<thead>
<tr>
<th>参数</th>
<th>选型建议</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>可设为CPU核心数或稍高，如 <code>Runtime.getRuntime().availableProcessors()</code></td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>视任务复杂度、响应时间等决定，通常为核心数的 2~3 倍 <strong>2N+1</strong></td>
</tr>
<tr>
<td>queueCapacity</td>
<td>适合使用有限队列（如100），避免OOM</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>一般设置 30~60 秒</td>
</tr>
<tr>
<td>拒绝策略</td>
<td>建议使用 <code>CallerRunsPolicy</code> 或自定义策略</td>
</tr>
</tbody></table>
<h5 id="什么时候不该用线程池？"><a href="#什么时候不该用线程池？" class="headerlink" title="什么时候不该用线程池？"></a>什么时候不该用线程池？</h5><p>虽然线程池非常好，但在这些情况下应该慎用：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>建议方式</th>
</tr>
</thead>
<tbody><tr>
<td>任务轻量、低频</td>
<td>可直接 new Thread</td>
</tr>
<tr>
<td>任务耗时严重、不确定性高</td>
<td>可用异步消息队列或限流机制替代</td>
</tr>
<tr>
<td>并发极高，超出系统承载能力</td>
<td>应加熔断、降级、防抖等保护机制</td>
</tr>
</tbody></table>
<h5 id="总结线程池应用场景"><a href="#总结线程池应用场景" class="headerlink" title="总结线程池应用场景"></a>总结线程池应用场景</h5><table>
<thead>
<tr>
<th>应用场景</th>
<th>是否推荐</th>
<th>理由说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 异步任务</td>
<td>推荐</td>
<td>提升响应速度，释放主线程</td>
</tr>
<tr>
<td>✅ 数据汇总</td>
<td>推荐</td>
<td>多接口并行调用、加速结果收敛</td>
</tr>
<tr>
<td>✅ 定时批处理任务</td>
<td>推荐</td>
<td>比如定时拉取、导入数据、分段分页并发处理等</td>
</tr>
<tr>
<td>❌ 高频IO长耗时任务</td>
<td>慎用</td>
<td>应考虑消息队列+异步消费，避免线程被长时间占用</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<blockquote>
<p><strong>安装 Docker</strong>：确保你的部署服务器上安装了 Docker。<br><strong>安装 Jenkins</strong>：可以通过 Docker 安装 Jenkins，或者直接在服务器上安装。</p>
<h4 id="步骤-1：安装-Jenkins-和-Docker"><a href="#步骤-1：安装-Jenkins-和-Docker" class="headerlink" title="步骤 1：安装 Jenkins 和 Docker"></a>步骤 1：安装 Jenkins 和 Docker</h4><p>确保 Jenkins 和 Docker 在服务器上都已经安装并运行。</p>
<h4 id="步骤-2：配置-Jenkins"><a href="#步骤-2：配置-Jenkins" class="headerlink" title="步骤 2：配置 Jenkins"></a>步骤 2：配置 Jenkins</h4><ol>
<li><p><strong>启动 Jenkins</strong>：</p>
<p>使用 Docker 启动 Jenkins：</p>
<pre><code>docker run -d --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts
</code></pre>
</li>
<li><p><strong>访问 Jenkins</strong>：在浏览器中访问 <code>http://&lt;服务器地址&gt;:8080</code>，并按照指示完成 Jenkins 的初始设置。</p>
</li>
<li><p><strong>安装必要的插件</strong>：安装 Docker、Git 等相关插件。</p>
</li>
</ol>
<h4 id="步骤-3：创建-Jenkins-任务"><a href="#步骤-3：创建-Jenkins-任务" class="headerlink" title="步骤 3：创建 Jenkins 任务"></a>步骤 3：创建 Jenkins 任务</h4><ol>
<li><p><strong>新建任务</strong>：在 Jenkins 主页上，点击“新建任务”。</p>
</li>
<li><p><strong>配置源码管理</strong>：配置 Git 仓库地址。</p>
</li>
<li><p><strong>配置构建触发器</strong>：选择合适的触发器。</p>
</li>
<li><p><strong>配置构建环境</strong>：勾选“Build inside a Docker container”。</p>
</li>
<li><p><strong>添加构建步骤</strong>：</p>
<ul>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker build -t myapp .
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加构建后操作</strong>：</p>
<ul>
<li><p><strong>Push built image</strong>：如果需要将镜像推送到 Docker 仓库，填写仓库信息。</p>
</li>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker stop myapp || true
docker rm myapp || true
docker run -d --name myapp -p 8080:8080 myapp
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="步骤-4：执行构建"><a href="#步骤-4：执行构建" class="headerlink" title="步骤 4：执行构建"></a>步骤 4：执行构建</h4><p>保存配置后，可以手动触发构建或者等待触发器自动执行构建。</p>
<h4 id="步骤-5：验证部署"><a href="#步骤-5：验证部署" class="headerlink" title="步骤 5：验证部署"></a>步骤 5：验证部署</h4><p>构建完成后，访问服务器的指定端口（例如 <code>http://&lt;服务器地址&gt;:8080</code>），验证应用是否成功部署。</p>
</blockquote>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="线程池场景题"><a href="#线程池场景题" class="headerlink" title="线程池场景题"></a>线程池场景题</h4><h6 id="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"><a href="#核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？" class="headerlink" title="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"></a>核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？</h6><p>在您描述的线程池配置下，当有6个并发任务到来时，这些任务的处理情况如下：</p>
<ul>
<li>核心线程数是5，意味着线程池会首先创建5个线程来处理任务。</li>
<li>当第6个任务到来时，由于核心线程都在忙，线程池会将这个任务放入队列中，因为队列的大小也是10。</li>
</ul>
<p>所以，在这种情况下，线程池中会有6个任务：<strong>5个任务正在被5个核心线程处理，另外1个任务在队列中等待</strong>。线程池并没有达到最大线程数10个，因为当前的任务数量和队列容量还未超过核心线程数和队列的总和。</p>
<blockquote>
<p>在您提供的线程池配置下（核心线程数5个，最大线程数10个，队列容量10个），当6个并发任务到来时，线程池不会立即创建10个线程，原因如下：</p>
<ol>
<li><strong>核心线程数优先</strong>：线程池首先会使用核心线程来处理任务。核心线程数是5，所以前5个任务会分别由5个核心线程来处理。</li>
<li><strong>队列缓冲</strong>：当核心线程都在忙碌时，额外的任务会被放入队列中等待，而不是立即创建新的线程。您的队列容量是10，足以容纳当前的第6个任务。</li>
<li><strong>按需创建线程</strong>：线程池会根据任务的处理速度和队列的饱和度来决定是否需要创建超出核心线程数的线程。在您的例子中，尽管有6个并发任务，但队列还未满，因此没有必要创建额外的线程。</li>
<li><strong>最大线程数限制</strong>：最大线程数是线程池可以创建的线程数量的上限，但这并不意味着线程池会一开始就创建到这个上限。只有当队列满了，且还有新的任务到来时，线程池才会创建额外的线程（最多达到最大线程数）来处理这些任务。</li>
</ol>
<p>因此，在您的场景中，当6个并发任务到来时，线程池的操作是：</p>
<ul>
<li>5个核心线程各自处理一个任务。</li>
<li>第6个任务被放入队列中等待。</li>
</ul>
<p>此时，线程池中只有5个线程在运行，队列中有1个任务，总共6个任务。线程池不会创建额外的线程，因为当前的任务数量还未超过核心线程数和队列的总容量。只有当队列满了（即有10个任务在队列中），且还有新的任务到来时，线程池才会考虑创建额外的线程，直到达到最大线程数10个。</p>
</blockquote>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在<strong>URL</strong>之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，<u>敏感数据不应通过过GET请求发送</u></li>
<li>URL长度限制通常在<strong>2000个字符</strong>左右，这意味着GET请求能够传输的数据有限</li>
<li><strong>可以被缓存</strong>，也会被浏览器保存在历史记录中</li>
<li>常用于<strong>信息查询、数据检索</strong>等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在<strong>请求体</strong>中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上<strong>没有大小限制</strong>，适用于传输大量数据.</li>
<li><strong>不会被缓存</strong>，且不会保存在浏觉器历史记录中</li>
<li>常用于<strong>数据提交、表单提交</strong>等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<blockquote>
<p>“GET 和 POST 都是 HTTP 协议中最常用的请求方式，最本质的区别在于数据传输的位置与幂等性，不仅影响安全性和缓存行为，也关系到实际应用场景选择。”</p>
<h3 id="✅-GET-与-POST-请求的对比总结表"><a href="#✅-GET-与-POST-请求的对比总结表" class="headerlink" title="✅ GET 与 POST 请求的对比总结表"></a>✅ GET 与 POST 请求的对比总结表</h3><table>
<thead>
<tr>
<th>项目</th>
<th>GET 请求</th>
<th>POST 请求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>查询资源（获取数据）</td>
<td>提交资源（发送数据）</td>
</tr>
<tr>
<td><strong>数据位置</strong></td>
<td>URL 参数：拼接在 <code>?</code> 后面，如 <code>/user?id=1</code></td>
<td>请求体：放在 HTTP 请求体中</td>
</tr>
<tr>
<td><strong>是否显示参数</strong></td>
<td>✅ 显示（暴露在 URL 中，用户可见）</td>
<td>❌ 不显示（隐藏在 Body 中）</td>
</tr>
<tr>
<td><strong>是否安全</strong></td>
<td>❌ 不安全（敏感信息容易泄露，如明文密码）</td>
<td>✅ 相对安全（但也要注意防止抓包等问题）</td>
</tr>
<tr>
<td><strong>参数长度限制</strong></td>
<td>有限制（由浏览器和服务器限制，一般不超过 2KB）</td>
<td>理论上无限制（受服务器配置影响）</td>
</tr>
<tr>
<td><strong>是否可缓存</strong></td>
<td>✅ 可以被缓存</td>
<td>❌ 默认不可缓存</td>
</tr>
<tr>
<td><strong>是否保留历史记录</strong></td>
<td>✅ 会被浏览器记录</td>
<td>❌ 不会记录</td>
</tr>
<tr>
<td><strong>是否能被收藏为书签</strong></td>
<td>✅ 可以（URL完整）</td>
<td>❌ 不建议（没有完整 URL 参数）</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>查询、检索、列表展示</td>
<td>提交表单、上传文件、登录、注册</td>
</tr>
<tr>
<td><strong>请求幂等性</strong></td>
<td>✅ 幂等（多次请求结果一样）</td>
<td>❌ 不一定幂等（多次提交可能创建多条数据）</td>
</tr>
<tr>
<td><strong>常用请求头</strong></td>
<td><code>Accept</code>、<code>User-Agent</code>、<code>Host</code>、<code>Authorization</code> 等</td>
<td>额外使用：<code>Content-Type</code>（如：<code>application/json</code>、<code>multipart/form-data</code>）</td>
</tr>
<tr>
<td><strong>是否可附带请求体</strong></td>
<td>✅ 理论支持，但不推荐使用，很多服务端框架默认忽略（如 Spring MVC）</td>
<td>✅ 正常使用请求体（Body）传参</td>
</tr>
<tr>
<td><strong>是否支持路径参数</strong></td>
<td>✅ 支持，如 <code>/user/1</code></td>
<td>✅ 同样支持路径参数和 query 参数（但参数多用 Body 传）</td>
</tr>
<tr>
<td><strong>是否可以拼接 ? 参数</strong></td>
<td>✅ 常用，如 <code>/api?key=123</code></td>
<td>✅ 也可以 <code>/api?token=abc</code>，但数据主体依然建议放在请求体中</td>
</tr>
<tr>
<td><strong>对缓存友好程度</strong></td>
<td>✅ 友好，可被浏览器缓存，也可用于 CDN 缓存</td>
<td>❌ 默认不可缓存（除非通过响应头指定）</td>
</tr>
<tr>
<td><strong>在 RESTful 中常用场景</strong></td>
<td>获取资源，如 GET <code>/api/users</code></td>
<td>创建资源，如 POST <code>/api/users</code>，或提交登录等敏感操作</td>
</tr>
</tbody></table>
<h3 id="冷门但常考-amp-实战必备考点"><a href="#冷门但常考-amp-实战必备考点" class="headerlink" title="冷门但常考 &amp; 实战必备考点"></a>冷门但常考 &amp; 实战必备考点</h3><table>
<thead>
<tr>
<th>冷门知识点 &#x2F; 实战经验</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET 请求也可以有请求体</td>
<td>✅ <strong>HTTP 协议允许</strong>，但很多框架（如 Spring）不解析，默认忽略</td>
</tr>
<tr>
<td>POST 请求也可以拼接 URL 参数</td>
<td>✅ URL 参数与请求体可同时存在，如：<code>POST /api?type=1</code> + body 传参</td>
</tr>
<tr>
<td>浏览器最大 URL 长度限制</td>
<td>❗ 通常为 2KB～8KB，<strong>IE 最小</strong>，<strong>Chrome 支持更长</strong></td>
</tr>
<tr>
<td>POST 也可以被缓存</td>
<td>❌ 默认不会缓存，但可通过 <code>Cache-Control</code> 或自定义缓存策略强制缓存</td>
</tr>
<tr>
<td>GET 请求一般不能上传文件（除非用 Base64 等特殊形式）</td>
<td>文件上传推荐用 <code>POST + multipart/form-data</code></td>
</tr>
<tr>
<td>登录操作必须用 POST</td>
<td>因为 GET 暴露用户名&#x2F;密码容易被记录，<strong>敏感数据必须走 POST + HTTPS 加密传输</strong></td>
</tr>
<tr>
<td>GET 请求参数对顺序敏感</td>
<td>某些框架（如部分网关、签名认证）会对 URL 参数顺序敏感，应注意参数顺序一致</td>
</tr>
<tr>
<td>Content-Type 区别</td>
<td>- GET 请求常省略或默认 - POST 常设定为： ① application&#x2F;json ② application&#x2F;x-www-form-urlencoded ③ multipart&#x2F;form-data</td>
</tr>
<tr>
<td>GET 请求会被预检（preflight）吗？</td>
<td>❌ 不会，只有跨域的非简单请求（如 PUT、带自定义头的 POST）才会有 OPTIONS 预检</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 <strong>multipart&#x2F;form-data</strong>”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<blockquote>
<h3 id="🔧-完整的上传流程"><a href="#🔧-完整的上传流程" class="headerlink" title="🔧 完整的上传流程"></a>🔧 完整的上传流程</h3><table>
<thead>
<tr>
<th>环节</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前端</td>
<td>使用 <code>form</code> 表单或 Ajax 上传，<code>Content-Type</code> 设置为 <code>multipart/form-data</code>，支持<strong>同时传文本+文件</strong></td>
</tr>
<tr>
<td>控制器</td>
<td>Spring Boot 使用 <code>MultipartFile</code> 类型接收上传文件，可使用 <code>.getInputStream()</code> 获取内容流</td>
</tr>
<tr>
<td>上传工具类</td>
<td>将文件流封装上传到第三方云存储，如阿里云 OSS、七牛云、腾讯云等</td>
</tr>
<tr>
<td>云存储</td>
<td>云厂商拥有<strong>备份、容灾、集群、分发</strong>等能力，确保数据安全和访问速度</td>
</tr>
<tr>
<td>返回前端</td>
<td>返回上传后的图片 URL 或文件 ID 等信息</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<blockquote>
<ol>
<li><strong>读取到 JVM 内存</strong>：<ul>
<li>当前端发送图片文件到后端时，后端服务器需要接收这个文件的数据。</li>
<li>在 Java 应用程序中，接收到的文件数据首先会被加载到 JVM（Java 虚拟机）的内存中。这是因为在 Java 应用程序中处理任何数据之前，数据必须先被加载到内存中。</li>
</ul>
</li>
<li><strong>二进制流给到阿里云</strong>：<ul>
<li>一旦文件数据被加载到 JVM 内存中，后端服务通常会将这些数据以二进制流的形式上传到云存储服务，比如阿里云的对象存储服务（OSS）。</li>
<li>这个过程涉及到数据的读取和写入操作，即从 JVM 内存读取数据，然后写入到云存储服务。</li>
</ul>
</li>
<li><strong>并发可能导致内存溢出</strong>：<ul>
<li>如果有多个用户同时上传大图片，后端服务器可能会同时处理多个上传请求。</li>
<li>每个上传请求都会占用一部分 JVM 内存。如果上传的图片非常大，且并发请求的数量很多，那么所有请求加起来的内存使用量可能会迅速增加。</li>
<li>如果内存使用量超过了 JVM 分配给应用程序的内存大小（即 OutOfMemory，简称 OOM），就会发生内存溢出错误。这种错误会导致应用程序崩溃或者变得不稳定。</li>
</ul>
</li>
<li><strong>限制上传大小的重要性</strong>：<ul>
<li>为了防止内存溢出错误，后端通常会限制上传文件的大小。</li>
<li>通过限制单个文件的最大大小（<code>max-file-size</code>）和整个请求的最大大小（<code>max-request-size</code>），可以有效地控制内存的使用，避免因大量并发上传大文件而耗尽服务器内存。</li>
</ul>
</li>
</ol>
<blockquote>
<h3 id="前端图片大小如何限制？"><a href="#前端图片大小如何限制？" class="headerlink" title="前端图片大小如何限制？"></a>前端图片大小如何限制？</h3><h4 id="✅-原因：避免后端-OOM（内存溢出）"><a href="#✅-原因：避免后端-OOM（内存溢出）" class="headerlink" title="✅ 原因：避免后端 OOM（内存溢出）"></a>✅ 原因：避免后端 OOM（内存溢出）</h4><table>
<thead>
<tr>
<th>步骤</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>上传前</td>
<td>浏览器本地可限制图片大小或压缩（前端 UI 限制）</td>
</tr>
<tr>
<td>上传中</td>
<td>设置 <code>multipart/form-data</code> 协议</td>
</tr>
<tr>
<td>后端接收</td>
<td>文件先被加载到 JVM 内存，再传给云服务，<strong>大图 + 并发上传 &#x3D; 高内存占用</strong></td>
</tr>
<tr>
<td>限制大小</td>
<td>避免 OOM，保障服务稳定性</td>
</tr>
</tbody></table>
<h4 id="✅-Spring-Boot-限制配置"><a href="#✅-Spring-Boot-限制配置" class="headerlink" title="✅ Spring Boot 限制配置"></a>✅ Spring Boot 限制配置</h4><pre><code class="java">spring:
  servlet:
    multipart:
      max-file-size: 10MB         # 单个文件最大10MB
      max-request-size: 20MB      # 整体请求最大20MB（多个文件+字段）
</code></pre>
<h3 id="控制器代码示例（Java）"><a href="#控制器代码示例（Java）" class="headerlink" title="控制器代码示例（Java）"></a>控制器代码示例（Java）</h3><pre><code class="java">@PostMapping(&quot;/upload&quot;)
public String uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;
    if (file.isEmpty()) &#123;
        return &quot;上传失败，文件为空&quot;;
    &#125;

    try (InputStream inputStream = file.getInputStream()) &#123;
        // 上传到阿里云OSS的逻辑
        String url = ossUtil.upload(inputStream, file.getOriginalFilename());
        return &quot;上传成功，访问地址：&quot; + url;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
        return &quot;上传失败：&quot; + e.getMessage();
    &#125;
&#125;
</code></pre>
<h3 id="冷门但常考的扩展点"><a href="#冷门但常考的扩展点" class="headerlink" title="冷门但常考的扩展点"></a>冷门但常考的扩展点</h3><table>
<thead>
<tr>
<th>知识点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>MultipartFile</code> 是什么？</td>
<td>是 Spring 封装的文件上传类型，内部包含文件名、文件大小、文件流等</td>
</tr>
<tr>
<td>同一请求能传图片+文本？</td>
<td>✅ 支持，表单中可同时上传 <code>file</code> + 文本字段，如商品名、描述</td>
</tr>
<tr>
<td>阿里云的上传路径建议？</td>
<td>可使用时间戳+UUID组合路径，如：<code>images/2025/07/abc.jpg</code>，防止重复文件覆盖</td>
</tr>
<tr>
<td>为什么选择 OSS？</td>
<td>专业、安全、弹性扩展、支持 CDN 分发、支持跨区域访问</td>
</tr>
<tr>
<td>OSS 上传是否走 JVM？</td>
<td>是的，文件先读入 JVM，再通过 SDK 上传，但也可以优化为<strong>直传（前端直传 OSS）</strong>减少后端压力</td>
</tr>
<tr>
<td>会不会并发导致 OOM？</td>
<td>是的，尤其是大文件 + 并发上传，若不限制上传大小，极易导致内存溢出</td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br><del>发展前景？表明上家公司不好</del><br><del>太想进步？表名上家公司提供的技术不好 自己技术不好</del><br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<blockquote>
<p>“<code>@RestController</code> 是 Spring 为了简化 RESTful 接口开发而推出的复合注解，等价于 <code>@Controller + @ResponseBody</code>。它让我们开发 API 接口时无需再为每个方法添加 <code>@ResponseBody</code>，所有返回值会自动转换为 JSON 或 XML 格式写入响应体，非常适合前后端分离项目。”</p>
</blockquote>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code class="yaml"># application.yml
server:
port: 8080

custom:
property: myCustomValue
number: 42
enabled: true
</code></pre>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class CustomComponent &#123;

 // 注入server.port属性
 @Value(&quot;$&#123;server.port&#125;&quot;)
 private String serverPort;

 // 注入custom.property属性
 @Value(&quot;$&#123;custom.property&#125;&quot;)
 private String customProperty;

 // 注入custom.number属性，并转换为int类型
 @Value(&quot;$&#123;custom.number&#125;&quot;)
 private int customNumber;

 // 注入custom.enabled属性，并转换为boolean类型
 @Value(&quot;$&#123;custom.enabled&#125;&quot;)
 private boolean customEnabled;

 // 使用SpEL表达式来计算值
 @Value(&quot;#&#123;$&#123;custom.number&#125; * 2&#125;&quot;)
 private int doubleCustomNumber;

 // 使用SpEL表达式来获取环境变量
 @Value(&quot;#&#123;systemProperties[&#39;os.name&#39;]&#125;&quot;)
 private String osName;

 // ... 使用注入的值进行操作

 // Getter和Setter方法
 // ...
&#125;
</code></pre>
</blockquote>
<ul>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。然后确保主应用程序类或某个配置类上有<code>@EnableConfigurationProperties(AppProperties.class)</code> 注解<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<blockquote>
<h3 id="IOC-与-DI-总结对比表"><a href="#IOC-与-DI-总结对比表" class="headerlink" title="IOC 与 DI 总结对比表"></a>IOC 与 DI 总结对比表</h3><table>
<thead>
<tr>
<th>概念</th>
<th>IOC（控制反转）</th>
<th>DI（依赖注入）</th>
</tr>
</thead>
<tbody><tr>
<td>含义</td>
<td>控制权从代码“主动”创建对象，反转给 Spring 容器</td>
<td>Spring 容器将依赖对象“注入”到目标对象中</td>
</tr>
<tr>
<td>目标</td>
<td><strong>解耦合</strong>，管理对象生命周期和依赖关系</td>
<td>实现 IOC 的核心手段，降低模块耦合度</td>
</tr>
<tr>
<td>体现</td>
<td>Bean 由容器统一创建和维护</td>
<td>对象的依赖由容器自动提供</td>
</tr>
<tr>
<td>好处</td>
<td>降低耦合、统一管理对象</td>
<td>提高可维护性、扩展性、便于测试</td>
</tr>
<tr>
<td>关系</td>
<td>是一种设计思想</td>
<td>是实现方式（IOC 的具体实现手段）</td>
</tr>
</tbody></table>
<h3 id="IOC-amp-DI-经典解释"><a href="#IOC-amp-DI-经典解释" class="headerlink" title="IOC &amp; DI 经典解释"></a>IOC &amp; DI 经典解释</h3><ul>
<li><strong>IOC（控制反转）</strong> 是一种思想，把原来由开发者手动 new 对象的工作交给 Spring 容器来做，实现<strong>对象创建和依赖管理的统一控制</strong>。</li>
<li><strong>DI（依赖注入）</strong> 是实现 IOC 的一种方式，即通过注解、构造函数等方式，由容器<strong>注入依赖对象</strong>。</li>
</ul>
<p>📌 举个栗子：</p>
<p>类似租房平台，房东提供房子（Bean），中介平台（Spring 容器）统一管理，租客（业务类）不直接找房东，而是由平台分配依赖。</p>
</blockquote>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据<strong>属性名称</strong>去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据<strong>属性类型</strong>去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
<h6 id="它俩最大的区别是什么？"><a href="#它俩最大的区别是什么？" class="headerlink" title="它俩最大的区别是什么？"></a>它俩最大的区别是什么？</h6><blockquote>
<p> <code>@Autowired</code> 更倾向于按<strong>类型注入</strong>，如果类型不唯一，则需要指定注入的名称。<br> <code>@Resource</code> 更倾向于按<strong>名称注入</strong>，如果没有指定名称，则尝试按类型注入。<br> 两者的不同在于默认的注入策略和如何处理不唯一的 Bean 定义。</p>
<p> <code>@Autowired</code> 和 <code>@Resource</code> 最大的区别在于它们的默认注入策略和所依赖的注入机制：</p>
<ol>
<li><strong>默认注入策略</strong>：</li>
</ol>
<ul>
<li><code>@Autowired</code>：默认是按照类型（Type）进行注入的。如果容器中存在多个相同类型的 Bean，则需要通过 <code>@Qualifier</code> 注解指定具体的 Bean 名称，或者通过设置 <code>@Autowired</code> 的 <code>required</code> 属性为 <code>false</code> 来允许没有找到匹配的 Bean 时不抛出异常。</li>
<li><code>@Resource</code>：默认是按照名称（Name）进行注入的。如果未指定名称，则尝试按类型进行注入。如果容器中存在多个相同类型的 Bean，且没有指定名称，可能会抛出异常。</li>
</ul>
<ol start="2">
<li><strong>依赖的注入机制</strong>：</li>
</ol>
<ul>
<li><code>@Autowired</code>：是 Spring 框架提供的注解，因此它只能用于 Spring 管理的上下文中。</li>
<li><code>@Resource</code>：是 Java 的扩展包（javax.annotation）提供的注解，它是 JSR-250 规范的一部分，因此可以在任何实现了 JSR-250 规范的容器中使用，不仅限于 Spring。</li>
</ul>
<p> 简而言之，最大的区别在于 <code>@Autowired</code> 更侧重于<strong>类型匹配</strong>，而 <code>@Resource</code> 更侧重于<strong>名称匹配</strong>，并且 <code>@Resource</code> 是 Java 标准的一部分，具有更广泛的适用性。</p>
<h3 id="Autowired-vs-Resource-区别总结表"><a href="#Autowired-vs-Resource-区别总结表" class="headerlink" title="@Autowired vs @Resource 区别总结表"></a>@Autowired vs @Resource 区别总结表</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>@Autowired</code></th>
<th><code>@Resource</code></th>
</tr>
</thead>
<tbody><tr>
<td>提供方</td>
<td>Spring</td>
<td>JDK（JSR-250）</td>
</tr>
<tr>
<td>默认注入方式</td>
<td>按类型（byType）</td>
<td>按名称（byName）</td>
</tr>
<tr>
<td>是否支持按类型注入</td>
<td>✅ 支持</td>
<td>✅ 支持（次选）</td>
</tr>
<tr>
<td>是否支持按名称注入</td>
<td>✅ 需搭配 <code>@Qualifier</code></td>
<td>✅ 默认</td>
</tr>
<tr>
<td>是否推荐</td>
<td>✅ 推荐</td>
<td>⚠️ 部分场景适用</td>
</tr>
<tr>
<td>可用位置</td>
<td>构造方法、字段、方法</td>
<td>字段、方法</td>
</tr>
<tr>
<td>是否支持多个构造方法</td>
<td>❌ 不能多个都加 @Autowired</td>
<td>❌ 同理</td>
</tr>
</tbody></table>
<h3 id="✅-开发建议"><a href="#✅-开发建议" class="headerlink" title="✅ 开发建议"></a>✅ 开发建议</h3><table>
<thead>
<tr>
<th>场景</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>只有一个依赖对象</td>
<td>优先使用构造器注入，语义清晰</td>
</tr>
<tr>
<td>需要注入多个依赖</td>
<td>使用字段注入或构造器注入</td>
</tr>
<tr>
<td>对依赖可选性较强</td>
<td>可考虑 setter 或普通方法注入</td>
</tr>
<tr>
<td>想确保更强约束性</td>
<td>使用构造器注入（+final属性）</td>
</tr>
</tbody></table>
<p> “IOC 是一种反转控制权的思想，由 Spring 容器来统一管理对象的创建和依赖；而 DI 是实现 IOC 的手段，通过构造器、属性等方式将依赖对象注入到类中。它们的最终目的是为了解耦，提高代码的可维护性和扩展性。开发中常用 <code>@Autowired</code> 和 <code>@Resource</code> 实现属性注入，构造器注入则更具可读性和测试友好性。”</p>
</blockquote>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和<code>@Autowired</code>类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> <strong>不可多个方法都加@Autowired</strong>  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;
    private DependencyB dependencyB;

    // 构造函数注入
    @Autowired
    public MyService(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // 另一个构造函数
    @Autowired
    public MyService(DependencyB dependencyB) &#123;
        this.dependencyB = dependencyB;
    &#125;

    // ... 其他方法 ...
&#125;
/////////////////////////////////////////////////////
在上面的例子中，由于有两个构造函数都使用了 @Autowired 注解，Spring 将无法确定使用哪一个构造函数，因此会抛出异常。要解决这个问题，你应该只在一个构造函数上使用 @Autowired 注解。
</code></pre>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // Set 方法注入
    @Autowired
    public void setDependencyA(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
在 Spring Boot 中，虽然不常用 XML 配置，但是你仍然可以通过注解来实现 Set 方法注入。
</code></pre>
</li>
<li><p><strong>普通方法注入</strong></p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // 普通方法注入
    @Autowired
    public void init(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
普通方法注入指的是在类中的任意非构造函数方法上使用 @Autowired 注解
</code></pre>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后【数组+链表+红黑树】在解决哈希冲突时有了较大的变化，当<strong>链表长度</strong>大于阈值（默认为<strong>8</strong>）时且<strong>数组长度</strong>大于<strong>64</strong>时，将链表转化为红黑树，以减少搜索时间。扩容时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对<strong>数组长度取模</strong> eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcode值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是<strong>hash冲突</strong>  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单向链表[linkedlist才是双向链表]。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<blockquote>
<p>拉链法（Chaining）是 Java 的 <code>HashMap</code> 在 JDK 1.8 之前以及之后都使用的一种解决哈希冲突的方法。在 JDK 1.8 之前，<code>HashMap</code> 的实现主要是基于拉链法，即使用链表来解决哈希冲突。当不同的键通过哈希函数计算出相同的哈希码，并且映射到同一个桶（bucket）时，这些键值对将以链表的形式存储在同一个桶中。</p>
<p>在 JDK 1.8 中，<code>HashMap</code> 的实现进行了改进，当链表的长度超过一定阈值（默认是 8）时，链表会被转换成红黑树。这是为了优化哈希表的性能，特别是当哈希冲突严重时，链表的查询效率会降低到 O(n)，而红黑树可以将查询效率提升到 O(log n)。</p>
<h3 id="红黑树如何避免哈希冲突"><a href="#红黑树如何避免哈希冲突" class="headerlink" title="红黑树如何避免哈希冲突"></a>红黑树如何避免哈希冲突</h3><p>红黑树本身并不直接解决哈希冲突，而是优化了哈希冲突发生后的数据结构。以下是红黑树在 <code>HashMap</code> 中是如何工作的：</p>
<ol>
<li><strong>哈希冲突</strong>：当不同的键产生相同的哈希码或经过取模运算后落在同一个桶时，就会发生哈希冲突。</li>
<li><strong>链表</strong>：在 JDK 1.8 中，如果桶中的元素少于一定数量（默认为 8），就会使用链表来存储这些元素。</li>
<li><strong>红黑树转换</strong>：当链表的长度超过阈值（默认为 8）时，并且数组的长度超过 64，链表会被转换成红黑树。这样可以减少查找时间，因为红黑树是一种自平衡的二叉搜索树。</li>
<li><strong>自平衡</strong>：红黑树通过旋转和重新着色操作来保持树的平衡，从而避免了二叉搜索树退化成链表的情况。</li>
</ol>
<h3 id="红黑树的旋转和自平衡"><a href="#红黑树的旋转和自平衡" class="headerlink" title="红黑树的旋转和自平衡"></a>红黑树的旋转和自平衡</h3><p>红黑树通过以下规则保持平衡：</p>
<ul>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li>
<li><strong>根节点</strong>：根节点是黑色的。</li>
<li><strong>红色规则</strong>：如果一个节点是红色的，则它的子节点必须是黑色的（不能有两个连续的红色节点）。</li>
<li><strong>黑色高度</strong>：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>当插入或删除节点时，可能会破坏这些规则，此时红黑树会通过以下操作来重新平衡：</p>
<ul>
<li><strong>左旋转</strong>：当右子节点是红色，而左子节点是黑色或不存在时，进行左旋转。</li>
<li><strong>右旋转</strong>：当左子节点是红色，并且它的左子节点也是红色时，进行右旋转。</li>
<li><strong>重新着色</strong>：在某些情况下，通过改变节点颜色来维持红黑树的性质。</li>
</ul>
<p>通过这些操作，红黑树确保了即使在最坏的情况下，树的高度也不会超过 2log(n+1)，从而保证了 O(log n) 的时间复杂度。</p>
<p>总结来说，红黑树并不直接解决哈希冲突，而是<strong>优化了哈希冲突后的数据结构</strong>，使得即使在发生大量哈希冲突的情况下，<code>HashMap</code> 的性能也不会显著下降。</p>
</blockquote>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p><strong>底层是包装了一个hashmap</strong>，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList 读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。<strong>计算hashcode会比equals更快</strong>，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，<strong>所以先判断hashcode 再判断equals</strong>   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个   ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<blockquote>
<h3 id="hashCode-与-equals-总结对比表"><a href="#hashCode-与-equals-总结对比表" class="headerlink" title="hashCode() 与 equals() 总结对比表"></a><code>hashCode()</code> 与 <code>equals()</code> 总结对比表</h3><table>
<thead>
<tr>
<th>比较项</th>
<th><code>hashCode()</code></th>
<th><code>equals()</code></th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>返回对象的哈希值</td>
<td>判断两个对象是否“逻辑相等”</td>
</tr>
<tr>
<td>定义位置</td>
<td><code>Object</code> 类中定义，可被重写</td>
<td>同上</td>
</tr>
<tr>
<td>默认行为</td>
<td>返回对象内存地址的整数表示</td>
<td>比较是否为同一对象（地址）</td>
</tr>
<tr>
<td>需要重写的场景</td>
<td>自定义对象作为集合的 key（如 <code>HashMap</code>、<code>HashSet</code>）</td>
<td>自定义对象需要逻辑比较</td>
</tr>
<tr>
<td>是否与对象属性有关</td>
<td>默认无关，重写后应有关</td>
<td>重写时应只关心关键属性</td>
</tr>
<tr>
<td>性能</td>
<td>高效（整型值）</td>
<td>慢（逐个属性比较）</td>
</tr>
</tbody></table>
<h3 id="二者关系说明（核心规则）"><a href="#二者关系说明（核心规则）" class="headerlink" title="二者关系说明（核心规则）"></a>二者关系说明（核心规则）</h3><table>
<thead>
<tr>
<th>判断</th>
<th>是否成立</th>
</tr>
</thead>
<tbody><tr>
<td><code>equals()</code> 返回 <code>true</code> → <code>hashCode()</code> 必须相等</td>
<td>✅ 必须成立</td>
</tr>
<tr>
<td><code>hashCode()</code> 相等 → <code>equals()</code> 不一定相等</td>
<td>⚠️ 可能不成立（<strong>哈希冲突</strong>）</td>
</tr>
</tbody></table>
<p>👉 这就是为什么 <strong>HashMap 在比较 key 时，先比 <code>hashCode()</code>，再比 <code>equals()</code><strong>，为了</strong>提升性能</strong>，也确保<strong>正确性</strong>。</p>
<pre><code class="java">String s1 = &quot;重地&quot;;
String s2 = &quot;通话&quot;;

System.out.println(s1.hashCode()); // 输出1179395
System.out.println(s2.hashCode()); // 输出1179395
System.out.println(s1.equals(s2)); // false
</code></pre>
<p>⚠️ 两个字符串的 <code>hashCode()</code> 相同，但 <code>equals()</code> 不相同，说明它们逻辑上不相等（只是<strong>哈希冲突</strong>）。</p>
<h3 id="✅-为什么要重写-hashCode-和-equals-？"><a href="#✅-为什么要重写-hashCode-和-equals-？" class="headerlink" title="✅ 为什么要重写 hashCode() 和 equals()？"></a>✅ 为什么要重写 <code>hashCode()</code> 和 <code>equals()</code>？</h3><p>如果你将自定义对象用作集合中的 key（如放入 <code>HashMap</code> 或 <code>HashSet</code>），那么：</p>
<ul>
<li>不重写：默认使用地址判断，相同内容的新对象视为不同</li>
<li>正确重写：按属性判断内容一致性，可识别“逻辑相同”的对象</li>
</ul>
<pre><code class="java">public class User &#123;
    private String name;
    private int age;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User other = (User) o;
        return this.age == other.age &amp;&amp; Objects.equals(this.name, other.name);
    &#125;

    @Override
    public int hashCode() &#123;
        return Objects.hash(name, age);
    &#125;
&#125;
</code></pre>
<p><code>equals()</code> 用于判断两个对象是否逻辑相等，<code>hashCode()</code> 用于加快集合查找效率。在实际开发中，若你要将对象作为 <code>HashMap</code> 或 <code>HashSet</code> 的 key，必须同时重写这两个方法，保证逻辑一致性，避免出现“相等的对象进不了集合”的问题。</p>
</blockquote>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用<strong>ConcurrentHashMap<del>线程安全</del><strong>、Collections.synchronizedMap()、</strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>HashTable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了<strong>ConcurrentHashMap读不加锁 写加锁</strong>。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<blockquote>
<p><strong>Synchronized</strong></p>
<pre><code class="java">public class SynchronizedExample &#123;
    public synchronized void synchronizedMethod() &#123;
        // 这里是同步代码块
        System.out.println(&quot;进入同步方法&quot;);
        // 执行一些操作
        System.out.println(&quot;退出同步方法&quot;);
    &#125;
&#125;
-----------------------------------------------------
public class SynchronizedBlockExample &#123;
    private final Object lock = new Object();

    public void synchronizedBlock() &#123;
        synchronized (lock) &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入同步代码块&quot;);
            // 执行一些操作
            System.out.println(&quot;退出同步代码块&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>ReentrantLock</strong></p>
<pre><code class="java">import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample &#123;
    private final ReentrantLock lock = new ReentrantLock();

    public void lockedMethod() &#123;
        lock.lock(); // 加锁
        try &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入锁定的方法&quot;);
            // 执行一些操作
            System.out.println(&quot;退出锁定的方法&quot;);
        &#125; finally &#123;
            lock.unlock(); // 解锁
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是<strong>log(n)</strong><br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p><strong>WebSocket</strong>【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p><u>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component</u><br><u>定义切点 <code>@Pointcut</code> 声明切点表达式</u></p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<blockquote>
<h3 id="💬-有没有在项目中使用-AOP？用来做什么？"><a href="#💬-有没有在项目中使用-AOP？用来做什么？" class="headerlink" title="💬 有没有在项目中使用 AOP？用来做什么？"></a>💬 <strong>有没有在项目中使用 AOP？用来做什么？</strong></h3><blockquote>
<p>有使用，主要应用场景有两个：</p>
<ul>
<li>一是 <strong>操作日志记录</strong>：在 Web 项目中，我们通过 AOP 拦截 Controller 层方法，在方法执行后记录操作人、操作类型、接口路径等信息，用于审计和排查问题。</li>
<li>二是 <strong>数据脱敏处理</strong>：在某些返回值中包含手机号、身份证等敏感字段，通过 AOP 拦截 Service 返回结果，在返回给前端前进行统一脱敏（如：150***8786）。</li>
</ul>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class LogAspect &#123;

    // 定义切点，拦截所有 controller 包下的方法
    @Pointcut(&quot;execution(* com.example.controller..*(..))&quot;)
    public void controllerPointcut() &#123;&#125;

    // 环绕通知
    @Around(&quot;controllerPointcut()&quot;)
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        long start = System.currentTimeMillis();
        try &#123;
            return joinPoint.proceed();
        &#125; finally &#123;
            long end = System.currentTimeMillis();
            System.out.println(&quot;接口耗时：&quot; + (end - start) + &quot;ms&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="🧠-AOP-通知类型简述（答题建议）"><a href="#🧠-AOP-通知类型简述（答题建议）" class="headerlink" title="🧠 AOP 通知类型简述（答题建议）"></a><strong>🧠 AOP 通知类型简述（答题建议）</strong></h3><table>
<thead>
<tr>
<th>通知类型</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td><code>@Before</code></td>
<td>在方法执行前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td><code>@After</code></td>
<td>方法执行后（无论成功或异常）</td>
</tr>
<tr>
<td>返回通知</td>
<td><code>@AfterReturning</code></td>
<td>方法<strong>成功返回后</strong>执行，可获取返回值</td>
</tr>
<tr>
<td>异常通知</td>
<td><code>@AfterThrowing</code></td>
<td>方法抛出异常后执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td><code>@Around</code></td>
<td>方法执行前后都可执行，适合统一处理（如 try…finally）</td>
</tr>
</tbody></table>
<h3 id="你在项目中遇到的-AOP-注意事项"><a href="#你在项目中遇到的-AOP-注意事项" class="headerlink" title="你在项目中遇到的 AOP 注意事项"></a><strong>你在项目中遇到的 AOP 注意事项</strong></h3><ul>
<li>如果你在 AOP 中使用 <code>ThreadLocal</code>（如存储登录用户信息），<strong>一定要在方法执行完后调用 <code>remove()</code> 释放资源</strong>，否则可能造成<strong>内存泄漏</strong>。</li>
<li>推荐使用 <code>@Around</code> + <code>try-finally</code> 模式，<strong>无论是否抛异常，finally 都能执行</strong>，比如清理上下文。</li>
<li><code>@AfterReturning</code>：<strong>仅在方法成功返回时执行</strong>，<strong>不会处理异常情况</strong>，这一点面试常考。</li>
<li>AOP 是基于 <strong>动态代理机制（JDK 或 CGLIB）</strong>，本质是对方法的增强。和拦截器、过滤器最大的不同是：<strong>AOP 不是仅限于 HTTP 请求，可以增强任意 Bean 的任意方法。</strong></li>
</ul>
</blockquote>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<blockquote>
<p>我来帮你<strong>通俗一点梳理这段 AOP 的使用逻辑和运行机制</strong>，你可以类比成“程序在运行到某个点的时候，会自动执行你预设的增强代码”。</p>
<h2 id="✅-举个例子你就明白了："><a href="#✅-举个例子你就明白了：" class="headerlink" title="✅ 举个例子你就明白了："></a>✅ 举个例子你就明白了：</h2><p>你写了个 Controller：</p>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello() &#123;
        System.out.println(&quot;正在执行业务逻辑&quot;);
        return &quot;Hello World&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="⚙️-当你访问-hello，Spring-执行流程如下："><a href="#⚙️-当你访问-hello，Spring-执行流程如下：" class="headerlink" title="⚙️ 当你访问 /hello，Spring 执行流程如下："></a>⚙️ 当你访问 <code>/hello</code>，Spring 执行流程如下：</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣</td>
<td>执行你的 AOP 中 <code>@Around</code> 方法（aroundAdvice）</td>
</tr>
<tr>
<td>2️⃣</td>
<td><code>joinPoint.proceed()</code> 触发目标方法（即 <code>hello()</code>）执行</td>
</tr>
<tr>
<td>3️⃣</td>
<td>方法返回或抛异常，finally 一定会执行</td>
</tr>
<tr>
<td>4️⃣</td>
<td>AOP 把最终返回值交回 Spring 继续响应前端</td>
</tr>
</tbody></table>
<h2 id="✅-补充理解：execution-表达式"><a href="#✅-补充理解：execution-表达式" class="headerlink" title="✅ 补充理解：execution 表达式"></a>✅ 补充理解：execution 表达式</h2><p>你这个表达式：</p>
<pre><code class="java">execution(* com.example.yourpackage.controller..*(..))
</code></pre>
<ul>
<li><code>*</code>：匹配所有返回值类型</li>
<li><code>com.example.yourpackage.controller..*</code>：匹配该包及子包的所有类</li>
<li><code>*</code>：匹配所有方法</li>
<li><code>(..)</code>：匹配任意参数类型和个数</li>
</ul>
<p>🧠 所以可以理解成：**”凡是 controller 包下的任何方法，AOP 都要插手”**</p>
<p>你就是告诉 Spring AOP：“当你运行到这些方法时，先来找我执行一些额外操作”，这就是<strong>切面增强的精髓</strong>。</p>
</blockquote>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.<strong>BigDecimal</strong></p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)</p>
<ol>
<li>beforeCreate创建前</li>
<li>created创建后</li>
<li>beforeMount载入前</li>
<li>mounted挂载完成</li>
<li>beforeUpdate数据更新前</li>
<li>updated数据更新后</li>
<li>beforeUnmount组件销毁前</li>
<li>unmounted组件销毁后</li>
</ol>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<blockquote>
<ol>
<li><strong>启动类</strong>：Spring Boot 应用通常有一个带有 <code>@SpringBootApplication</code> 注解的启动类。这个注解是一个组合注解，它包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</li>
<li><strong>@EnableAutoConfiguration</strong>：这个注解是自动装配的关键。它告诉 Spring Boot 根据类路径下的类、Bean 的定义以及各种属性设置，自动配置 Spring 应用。这个注解会导入 <code>AutoConfigurationImportSelector</code> 类，该类会读取所有 <code>spring.factories</code> 文件中的 <code>EnableAutoConfiguration</code> 条目，并将它们作为配置类导入。</li>
<li><strong>条件化配置</strong>：Spring Boot 使用 <code>@Conditional</code> 注解及其一系列的派生注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等）来确保只有在满足特定条件时，配置类或 Bean 才会被创建。</li>
<li><strong>配置类</strong>：自动装配是通过一系列的配置类来实现的，这些配置类包含了 <code>@Bean</code> 方法，用于创建和配置 Spring 容器中的 Bean。</li>
</ol>
</blockquote>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

@Autowired
private MyService self; // 注入自身代理实例

public void methodA() &#123;
// ... 业务逻辑 ...

self.methodB(); // 通过代理实例调用，事务注解将生效
&#125;

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() &#123;
// ... 业务逻辑 ...
&#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
<h2 id="Spring-事务传播行为对比表"><a href="#Spring-事务传播行为对比表" class="headerlink" title="Spring 事务传播行为对比表"></a>Spring 事务传播行为对比表</h2><table>
<thead>
<tr>
<th><strong>传播行为</strong></th>
<th><strong>是否加入当前事务</strong></th>
<th><strong>当前无事务是否新建事务</strong></th>
<th><strong>当前有事务是否挂起原事务</strong></th>
<th><strong>常见用途 &#x2F; 场景举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>REQUIRED</strong>（默认）</td>
<td>✅加入</td>
<td>✅新建</td>
<td>❌不挂起</td>
<td>大多数业务逻辑，默认即可（如用户下单）</td>
</tr>
<tr>
<td><strong>SUPPORTS</strong></td>
<td>✅加入</td>
<td>❌不新建，直接运行</td>
<td>❌不挂起</td>
<td>非核心操作，事务可有可无（如查询、打日志、非敏感接口）</td>
</tr>
<tr>
<td><strong>MANDATORY</strong></td>
<td>✅加入</td>
<td>❌不新建 → 报错</td>
<td>❌不挂起</td>
<td>强依赖事务环境，如在已有事务内强制做某个操作（如审计组件）</td>
</tr>
<tr>
<td><strong>REQUIRES_NEW</strong></td>
<td>❌不加入</td>
<td>✅新建</td>
<td>✅挂起原事务</td>
<td><strong>日志记录、补偿事务等</strong>。如主逻辑回滚了，日志也必须写入数据库</td>
</tr>
<tr>
<td><strong>NOT_SUPPORTED</strong></td>
<td>❌不加入</td>
<td>✅以非事务运行</td>
<td>✅挂起原事务</td>
<td>第三方接口调用、不能用事务的场景（如读库压力大，必须立即返回）</td>
</tr>
<tr>
<td><strong>NEVER</strong></td>
<td>❌不加入</td>
<td>✅以非事务运行</td>
<td>❌不挂起 → 如果有事务 → 报错</td>
<td>严禁事务场景，例如你调用了一个只能在无事务环境下工作的接口</td>
</tr>
<tr>
<td><strong>NESTED</strong></td>
<td>✅作为嵌套事务</td>
<td>✅新建（嵌套）</td>
<td>❌不挂起</td>
<td>子事务失败可以单独回滚但主事务不影响（例如更新多个模块，一个失败不影响其他）</td>
</tr>
</tbody></table>
<h2 id="🧠-快速记忆技巧"><a href="#🧠-快速记忆技巧" class="headerlink" title="🧠 快速记忆技巧"></a>🧠 快速记忆技巧</h2><table>
<thead>
<tr>
<th>记忆关键词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>REQUIRED</strong> 就像“我有就用，没有我自己建” → 默认值</td>
<td></td>
</tr>
<tr>
<td><strong>REQUIRES_NEW</strong> “谁都有我不管，我自己开新号”</td>
<td></td>
</tr>
<tr>
<td><strong>SUPPORTS</strong> “随缘，有就上，没有就裸跑”</td>
<td></td>
</tr>
<tr>
<td><strong>MANDATORY</strong> “必须有事务，没有就不干”</td>
<td></td>
</tr>
<tr>
<td><strong>NOT_SUPPORTED</strong> “你们开会我不参与，我要单干”</td>
<td></td>
</tr>
<tr>
<td><strong>NEVER</strong> “你们别开会，我一开会就炸”</td>
<td></td>
</tr>
<tr>
<td><strong>NESTED</strong> “我是你肚子里的小事务，单独受罚，妈你别哭”</td>
<td></td>
</tr>
</tbody></table>
<h2 id="💬-示例记忆法（像讲段子一样）："><a href="#💬-示例记忆法（像讲段子一样）：" class="headerlink" title="💬 示例记忆法（像讲段子一样）："></a>💬 示例记忆法（像讲段子一样）：</h2><blockquote>
<p>老板（事务A）叫你干活（方法B）：</p>
<ul>
<li><strong>REQUIRED</strong>：老板已经在开会，我就进来一起开；没会议我就自己组织一个</li>
<li><strong>REQUIRES_NEW</strong>：我不管老板在不在，我自己重新开一个会（挂起老板的）</li>
<li><strong>SUPPORTS</strong>：老板开会我就进，不开我就随便干干</li>
<li><strong>MANDATORY</strong>：老板必须先开会，否则我不干活（抛异常）</li>
<li><strong>NOT_SUPPORTED</strong>：老板要是开会，我就去抽根烟；不开我才来干活（挂起事务）</li>
<li><strong>NEVER</strong>：谁开会我跟谁急，我只干没有事务的活</li>
<li><strong>NESTED</strong>：老板开了会，我在会里又开了一个子会，出了事自己担责不连累老板</li>
</ul>
</blockquote>
<h2 id="✅-重点注意（常考陷阱）"><a href="#✅-重点注意（常考陷阱）" class="headerlink" title="✅ 重点注意（常考陷阱）"></a>✅ 重点注意（常考陷阱）</h2><table>
<thead>
<tr>
<th>场景</th>
<th>考点</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类中 a() 直接调用 b()（b有事务）</td>
<td><strong>事务注解失效</strong>！因为 Spring 是基于代理的，自己调自己不走代理！解决：<strong>注入自己 <code>@Autowired private Self self;</code> 然后 <code>self.b()</code></strong></td>
</tr>
<tr>
<td>为什么要用 REQUIRES_NEW？</td>
<td>防止主事务回滚时影响某些<strong>必须成功的操作</strong>（如操作日志、发送消息）</td>
</tr>
<tr>
<td>NESTED 与 REQUIRES_NEW 区别？</td>
<td>NESTED 依赖原事务，提交回滚可以局部控制；REQUIRES_NEW 完全独立，互不干扰</td>
</tr>
<tr>
<td>使用 NOT_SUPPORTED&#x2F;NEVER 的典型场景？</td>
<td>调用第三方接口不允许事务干扰，如防止长事务锁表等问题</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<blockquote>
<h4 id="声明式事务管理（-Transactional）"><a href="#声明式事务管理（-Transactional）" class="headerlink" title="声明式事务管理（@Transactional）"></a>声明式事务管理<del>（@Transactional）</del></h4><pre><code class="java">// 你需要在 Spring 配置中启用事务注解支持：
@Configuration
@EnableTransactionManagement
public class SpringConfig &#123;

 @Bean
 public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) &#123;
     return new JpaTransactionManager(entityManagerFactory);
 &#125;

 // ... 其他配置
&#125;


// 然后，你可以在服务层的方法上使用 @Transactional 注解来声明事务边界：
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AccountService &#123;

 @Autowired
 private AccountRepository accountRepository;

 @Transactional
 public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
     // 执行转账操作，比如：
     Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow(...);
     Account toAccount = accountRepository.findById(toAccountId).orElseThrow(...);

     fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
     toAccount.setBalance(toAccount.getBalance().add(amount));

     accountRepository.save(fromAccount);
     accountRepository.save(toAccount);

     // 如果这里发生异常，Spring 将回滚事务
 &#125;
&#125;
</code></pre>
<h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

@Service
public class AccountService &#123;

 @Autowired
 private TransactionTemplate transactionTemplate;

 public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
     transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
         @Override
         protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
             try &#123;
                 // 执行转账操作，与声明式事务管理中的操作相同
                 // ...
             &#125; catch (Exception e) &#123;
                 status.setRollbackOnly(); // 如果发生异常，标记事务回滚
             &#125;
         &#125;
     &#125;);
 &#125;
&#125;
</code></pre>
<h2 id="✅-一句话理解"><a href="#✅-一句话理解" class="headerlink" title="✅ 一句话理解"></a>✅ 一句话理解</h2><p><strong>Spring事务</strong> &#x3D; 帮你保证一组数据库操作要么全部成功，要么全部失败（ACID）。</p>
<hr>
<h2 id="🌟-Spring事务使用方式"><a href="#🌟-Spring事务使用方式" class="headerlink" title="🌟 Spring事务使用方式"></a>🌟 Spring事务使用方式</h2><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>使用场景举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>声明式事务</strong>（@Transactional）</td>
<td>推荐方式，简洁，基于AOP代理增强方法</td>
<td>99%业务场景，转账、下单、库存扣减</td>
</tr>
<tr>
<td><strong>编程式事务</strong>（TransactionTemplate）</td>
<td>自己控制事务开始、提交、回滚流程</td>
<td>特殊场景需要精细控制事务，如代码逻辑复杂、异常处理嵌套</td>
</tr>
</tbody></table>
<h2 id="🎯-实战答题模板"><a href="#🎯-实战答题模板" class="headerlink" title="🎯 实战答题模板"></a>🎯 实战答题模板</h2><p>“在项目中我主要用的是<strong>声明式事务</strong>，通过<code>@Transactional</code>注解来管理事务，通常放在<strong>service层</strong>方法上。比如用户下单时，我需要在一个事务中完成订单生成、库存扣减、用户积分变更，如果中间任何一环失败，整个事务都会自动回滚，确保数据一致性。”</p>
<p>“我还了解过<strong>编程式事务</strong>，像使用<code>TransactionTemplate</code>手动管理事务边界，适合一些流程比较复杂或需要细粒度事务控制的业务场景。”</p>
<h3 id="Transactional-注解常用属性："><a href="#Transactional-注解常用属性：" class="headerlink" title="@Transactional 注解常用属性："></a><code>@Transactional</code> 注解常用属性：</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>propagation</code></td>
<td>事务的传播行为（REQUIRED&#x2F;REQUIRES_NEW等）</td>
<td><code>@Transactional(propagation=...)</code></td>
</tr>
<tr>
<td><code>rollbackFor</code></td>
<td>哪些异常会触发回滚（默认只回滚运行时异常）</td>
<td><code>@Transactional(rollbackFor=Exception.class)</code></td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td>是否只读事务，优化性能</td>
<td><code>@Transactional(readOnly=true)</code></td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>超时时间，单位：秒</td>
<td><code>@Transactional(timeout=5)</code></td>
</tr>
</tbody></table>
<h2 id="💥-易错点提示（面试常问）"><a href="#💥-易错点提示（面试常问）" class="headerlink" title="💥 易错点提示（面试常问）"></a>💥 易错点提示（面试常问）</h2><table>
<thead>
<tr>
<th>问题点</th>
<th>正确做法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>注解加在controller层</strong></td>
<td>❌ → <code>@Transactional</code>应加在<strong>service层</strong></td>
</tr>
<tr>
<td><strong>方法内自己调用自己</strong></td>
<td>❌ 事务失效！应通过注入自己调用</td>
</tr>
<tr>
<td><strong>只抛了Exception没加rollbackFor</strong></td>
<td>默认只回滚RuntimeException</td>
</tr>
<tr>
<td><strong>数据库引擎不是InnoDB</strong></td>
<td>MySQL需用InnoDB才支持事务</td>
</tr>
</tbody></table>
<h2 id="🔧-小结：项目中事务用法模版"><a href="#🔧-小结：项目中事务用法模版" class="headerlink" title="🔧 小结：项目中事务用法模版"></a>🔧 小结：项目中事务用法模版</h2><pre><code class="java">@Service
public class OrderService &#123;

    @Autowired
    private OrderMapper orderMapper;

    @Autowired
    private StockMapper stockMapper;

    @Transactional(rollbackFor = Exception.class) // 推荐加上 rollbackFor
    public void createOrder(Order order) &#123;
        // 1. 创建订单
        orderMapper.insert(order);

        // 2. 扣减库存
        stockMapper.deduct(order.getProductId(), order.getQuantity());

        // 3. 模拟异常测试事务回滚
        // int i = 1 / 0;

        // 4. 插入日志等其他操作...
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<blockquote>
<p>非阻塞IO（Non-blocking I&#x2F;O）是一种IO模型，它允许程序在执行IO操作时不会被阻塞，即程序可以在发起IO请求后继续执行其他任务，而不需要等待IO操作完成。以下是关于非阻塞IO的一些关键点：</p>
<h3 id="非阻塞IO的特点："><a href="#非阻塞IO的特点：" class="headerlink" title="非阻塞IO的特点："></a>非阻塞IO的特点：</h3><ol>
<li><strong>异步操作</strong>：非阻塞IO操作通常是异步的，意味着程序发起IO请求后，不需要等待IO操作完成，而是可以立即返回去做其他事情。</li>
<li><strong>事件驱动</strong>：非阻塞IO往往与事件驱动模型结合使用，程序可以通过监听器来响应IO事件（如数据可读、连接可写等）。</li>
<li><strong>减少等待时间</strong>：由于程序在等待IO操作完成时不会阻塞，它可以继续处理其他任务，从而提高了程序的响应性和吞吐量。</li>
</ol>
<h3 id="非阻塞IO的实现方式："><a href="#非阻塞IO的实现方式：" class="headerlink" title="非阻塞IO的实现方式："></a>非阻塞IO的实现方式：</h3><ul>
<li><strong>NIO（New I&#x2F;O）</strong>：在Java中，NIO提供了一种非阻塞的IO方式，使用<code>Selector</code>来管理多个通道（Channel）上的IO事件。</li>
<li><strong>AIO（Asynchronous I&#x2F;O）</strong>：AIO是另一种非阻塞IO模型，它允许程序完全异步地执行IO操作，通常是通过完成端口（Completion Ports）来实现。</li>
<li><strong>BIO（Blocking I&#x2F;O）</strong>：与非阻塞IO相对的是阻塞IO，其中每个IO操作都会阻塞调用线程，直到操作完成。</li>
</ul>
<h3 id="非阻塞IO的优势："><a href="#非阻塞IO的优势：" class="headerlink" title="非阻塞IO的优势："></a>非阻塞IO的优势：</h3><ul>
<li><strong>资源利用率</strong>：非阻塞IO可以更有效地利用系统资源，因为单个线程可以处理多个IO操作。</li>
<li><strong>高并发处理</strong>：在处理大量并发连接时，非阻塞IO可以显著提高系统的并发处理能力。</li>
</ul>
<h3 id="非阻塞IO在Redis中的应用："><a href="#非阻塞IO在Redis中的应用：" class="headerlink" title="非阻塞IO在Redis中的应用："></a>非阻塞IO在Redis中的应用：</h3><ul>
<li><strong>单线程模型</strong>：Redis是一个基于内存的键值存储数据库，它使用单线程模型来处理所有客户端请求。由于操作是基于内存的，速度非常快，而单线程避免了上下文切换的开销。</li>
<li><strong>非阻塞IO和多路复用</strong>：尽管Redis是单线程的，但它使用非阻塞IO和多路复用技术（如epoll或kqueue）来同时处理多个IO流。这意味着Redis可以在等待IO操作（如网络响应）时不阻塞，从而可以继续处理其他请求。</li>
<li><strong>高性能</strong>：Redis的非阻塞IO和多路复用机制使得它即使在面对大量并发请求时也能保持高性能。</li>
</ul>
</blockquote>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><h6 id="写入依赖"><a href="#写入依赖" class="headerlink" title="写入依赖"></a>写入依赖</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- Use the latest version available --&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p><strong>String</strong>：存储对象信息(转JSON)<br>将用户信息序列化为JSON字符串后存储。</p>
<pre><code class="json">SET user:1000 &#39;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;email&quot;:&quot;alice@example.com&quot;&#125;&#39;

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisStringExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.set(&quot;user:1000&quot;, &quot;&#123;\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;age\&quot;:30,\&quot;email\&quot;:\&quot;alice@example.com\&quot;&#125;&quot;);
        String userInfo = jedis.get(&quot;user:1000&quot;);
        System.out.println(userInfo);
        
        jedis.incr(&quot;visits&quot;);
        long visits = jedis.get(&quot;visits&quot;);
        System.out.println(&quot;Visits: &quot; + visits);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构<br>可以将数据库查询结果缓存为一个列表</p>
<pre><code class="mysql"># 查询记录的缓存
LPUSH recent:queries &quot;SELECT * FROM users WHERE age &gt; 30&quot;

# 消息队列
使用List作为消息队列，生产者将消息LPUSH到列表，消费者从列表中RPOP消息
LPUSH message:queue &quot;message1&quot;
RPOP message:queue

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisListExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.lpush(&quot;recent:queries&quot;, &quot;SELECT * FROM users WHERE age &gt; 30&quot;);
        String query = jedis.rpop(&quot;recent:queries&quot;);
        System.out.println(&quot;Recent Query: &quot; + query);
        
        jedis.close();
    &#125;
&#125;
w
</code></pre>
</li>
<li><p><strong>Hash</strong>：获取局部属性，小key不能设置过期时间<del>Hash是一个键值对集合，适合存储对象</del><br>Hash是一个键值对集合，适合存储对象</p>
<pre><code class="mysql">HSET user:1000 name &quot;Alice&quot; age 30 email &quot;alice@example.com&quot;
HGET user:1000 name

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisHashExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;name&quot;, &quot;Alice&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;age&quot;, &quot;30&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;email&quot;, &quot;alice@example.com&quot;);
        
        String name = jedis.hget(&quot;user:1000&quot;, &quot;name&quot;);
        System.out.println(&quot;Name: &quot; + name);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)<br>社交场景：使用Set来存储用户的关注列表，确保关注关系的唯一性。</p>
<pre><code class="mysql">SADD user:1000:following 2000 3000 4000

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisSetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.sadd(&quot;user:1000:following&quot;, &quot;2000&quot;, &quot;3000&quot;, &quot;4000&quot;);
        Set&lt;String&gt; following = jedis.smembers(&quot;user:1000:following&quot;);
        System.out.println(&quot;Following: &quot; + following);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>聚合计算：计算两个用户的共同关注。</p>
<pre><code class="java">SINTER user:1000:following user:2000:following
</code></pre>
</li>
<li><p><strong>Zset</strong>：排序场景，排行榜，姓名排序</p>
<p>排行榜：根据用户得分来存储排行榜</p>
<pre><code class="mysql">ZADD leaderboard 1000 Alice 950 Bob 900 Charlie
ZRANGE leaderboard 0 -1 WITHSCORES

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;
import java.util.Set;

public class RedisZsetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 1000, &quot;Alice&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 950, &quot;Bob&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 900, &quot;Charlie&quot;);
        
        Set&lt;String&gt; leaderboard = jedis.zrange(&quot;leaderboard&quot;, 0, -1);
        System.out.println(&quot;Leaderboard: &quot; + leaderboard);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>姓名排序：存储学生姓名和成绩，并按成绩排序。</p>
<pre><code class="mysql">ZADD students 92 John 85 Mary 88 Alice
ZRANGE students 0 -1 WITHSCORES
</code></pre>
</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li><p>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除<br><strong>惰性删除策略是在访问键时检查键是否过期</strong>，如果过期则删除。</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class LazyExpiration &#123;
    private Jedis jedis;

    public LazyExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public String getKey(String key) &#123;
        // 检查键是否存在
        if (!jedis.exists(key)) &#123;
            return null;
        &#125;

        // 检查键是否过期
        if (isExpired(key)) &#123;
            // 如果键已过期，则删除它
            jedis.del(key);
            return null;
        &#125;

        // 如果键未过期，返回键的值
        return jedis.get(key);
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public static void main(String[] args) &#123;
        LazyExpiration lazyExpiration = new LazyExpiration();
        String value = lazyExpiration.getKey(&quot;myKey&quot;);
        if (value != null) &#123;
            System.out.println(&quot;Key value: &quot; + value);
        &#125; else &#123;
            System.out.println(&quot;Key does not exist or has expired.&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>定时删除：设置键的过期时间，当键过期时，立即删除</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class ActiveExpiration &#123;
    private Jedis jedis;

    public ActiveExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void activeExpireCycle() &#123;
        // 随机检查一定数量的键
        for (int i = 0; i &lt; 10; i++) &#123;
            String key = jedis.randomKey();
            if (key != null &amp;&amp; isExpired(key)) &#123;
                // 如果键已过期，则删除它
                jedis.del(key);
            &#125;
        &#125;
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public void runPeriodicTask() &#123;
        // 定时任务，按照一定的频率运行
        while (true) &#123;
            activeExpireCycle();
            try &#123;
                Thread.sleep(1000); // 每秒执行一次
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        ActiveExpiration activeExpiration = new ActiveExpiration();
        // 启动定时任务
        activeExpiration.runPeriodicTask();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class RedisMaxMemoryPolicyExample &#123;
    private Jedis jedis;

    public RedisMaxMemoryPolicyExample() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void setMaxMemoryPolicy(String policy) &#123;
        // 设置Redis的内存淘汰策略
        jedis.configSet(&quot;maxmemory-policy&quot;, policy);
    &#125;

    public String getMaxMemoryPolicy() &#123;
        // 获取当前Redis的内存淘汰策略
        return jedis.configGet(&quot;maxmemory-policy&quot;).get(1);
    &#125;

    public static void main(String[] args) &#123;
        RedisMaxMemoryPolicyExample example = new RedisMaxMemoryPolicyExample();

        // 设置不同的内存淘汰策略
        example.setMaxMemoryPolicy(&quot;noeviction&quot;);       // 默认策略，拒绝写请求
        example.setMaxMemoryPolicy(&quot;allkeys-lru&quot;);      // 所有键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-lfu&quot;);      // 所有键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lru&quot;);     // 仅有过期时间的键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lfu&quot;);     // 仅有过期时间的键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-random&quot;);   // 所有键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-random&quot;);  // 仅有过期时间的键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-ttl&quot;);     // 优先淘汰TTL较短的键

        // 获取当前内存淘汰策略
        String currentPolicy = example.getMaxMemoryPolicy();
        System.out.println(&quot;Current Max Memory Policy: &quot; + currentPolicy);
    &#125;
&#125;
</code></pre>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br>[商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class DailyActiveUserCounter &#123;
    private Jedis jedis;

    public DailyActiveUserCounter() &#123;
        this.jedis = new Jedis(&quot;localhost&quot;); // 连接到Redis服务器
    &#125;

    // 映射用户ID到位图的键
    private String getUserBitmapKey(long userId, int day) &#123;
        return &quot;user:bitmap:&quot; + userId + &quot;:&quot; + day;
    &#125;

    // 用户签到
    public void userSignIn(long userId, int day) &#123;
        String key = getUserBitmapKey(userId, day);
        jedis.setbit(key, userId % 86400, true); // 假设一天有86400秒，使用秒数作为偏移量
    &#125;

    // 检查用户连续七天的签到情况
    public boolean checkContinuousSignIn(long userId, int day) &#123;
        for (int i = 0; i &lt; 7; i++) &#123;
            String key = getUserBitmapKey(userId, day - i);
            if (jedis.getbit(key, userId % 86400) == false) &#123;
                return false; // 如果在连续的七天内有一天没有签到，则返回false
            &#125;
        &#125;
        return true; // 连续七天都有签到
    &#125;

    public static void main(String[] args) &#123;
        DailyActiveUserCounter counter = new DailyActiveUserCounter();

        // 假设用户ID为12345，今天签到
        long userId = 12345;
        int today = 1; // 假设今天是第1天
        counter.userSignIn(userId, today);

        // 检查用户是否连续七天签到
        boolean isContinuous = counter.checkContinuousSignIn(userId, today);
        System.out.println(&quot;User &quot; + userId + &quot; has signed in for 7 consecutive days: &quot; + isContinuous);
    &#125;
&#125;
</code></pre>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p><strong>try catch 在里面继续再去查mysql数据库</strong></p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中yaml文件</p>
<ul>
<li><h6 id="JDK动态代理是-基于接口实现来实现增强"><a href="#JDK动态代理是-基于接口实现来实现增强" class="headerlink" title="JDK动态代理是 基于接口实现来实现增强"></a>JDK动态代理是 <u>基于接口实现来实现增强</u></h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是-基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是-基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是 基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是 <u>基于继承目标类并覆写其方法来实现</u></h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的<strong>代理</strong>类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，<strong>有一些简单的需求是没有的</strong>[沟通成本太高了]<br><strong>稍微复杂的需求会有需求文档</strong>，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<pre><code class="java">// 单例Bean
import org.springframework.stereotype.Component;

@Component
public class SingletonBean &#123;
    // Bean的代码
&#125;

----------------------------------------------------
    
// 多例Bean

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(&quot;prototype&quot;)
public class PrototypeBean &#123;
    // Bean的代码
&#125;
</code></pre>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<blockquote>
<h2 id="SQL的“写法顺序”-vs-“执行顺序”"><a href="#SQL的“写法顺序”-vs-“执行顺序”" class="headerlink" title="SQL的“写法顺序” vs “执行顺序”"></a>SQL的“写法顺序” vs “执行顺序”</h2><table>
<thead>
<tr>
<th>书写顺序（你写的时候）</th>
<th>实际执行顺序（数据库引擎执行时）</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT … FROM …</td>
<td><strong>FROM</strong>（确定数据源）</td>
</tr>
<tr>
<td>[JOIN … ON …]</td>
<td><strong>JOIN&#x2F;ON</strong>（表连接）</td>
</tr>
<tr>
<td>WHERE …</td>
<td><strong>WHERE</strong>（行过滤）</td>
</tr>
<tr>
<td>GROUP BY …</td>
<td><strong>GROUP BY</strong>（分组）</td>
</tr>
<tr>
<td>HAVING …</td>
<td><strong>HAVING</strong>（组过滤）</td>
</tr>
<tr>
<td>SELECT …</td>
<td><strong>SELECT</strong>（列筛选&#x2F;表达式）</td>
</tr>
<tr>
<td>ORDER BY …</td>
<td><strong>ORDER BY</strong>（排序）</td>
</tr>
<tr>
<td>LIMIT …</td>
<td><strong>LIMIT</strong>（分页&#x2F;截断）</td>
</tr>
</tbody></table>
<h2 id="为什么执行顺序是这样设计的？（核心）"><a href="#为什么执行顺序是这样设计的？（核心）" class="headerlink" title="为什么执行顺序是这样设计的？（核心）"></a>为什么<strong>执行顺序是这样设计的</strong>？（核心）</h2><h3 id="🌟1-先FROM："><a href="#🌟1-先FROM：" class="headerlink" title="🌟1. 先FROM："></a>🌟1. <strong>先FROM</strong>：</h3><p>确定<strong>要操作的表或视图</strong>，这是基础，后面所有步骤都基于这个“数据源”。</p>
<h3 id="🌟2-JOIN-x2F-ON："><a href="#🌟2-JOIN-x2F-ON：" class="headerlink" title="🌟2. JOIN&#x2F;ON："></a>🌟2. <strong>JOIN&#x2F;ON</strong>：</h3><p>在多个表之间构建连接关系，决定你从这些表中<strong>怎样拼接出一张“临时大表”</strong>。</p>
<h3 id="🌟3-WHERE："><a href="#🌟3-WHERE：" class="headerlink" title="🌟3. WHERE："></a>🌟3. <strong>WHERE</strong>：</h3><p>在JOIN后对临时表做<strong>行级过滤</strong>，只保留符合条件的记录。<br> 👉 这样可以尽早“减小数据量”，<strong>提升后续处理效率（比如分组）</strong>。</p>
<h3 id="🌟4-GROUP-BY："><a href="#🌟4-GROUP-BY：" class="headerlink" title="🌟4. GROUP BY："></a>🌟4. <strong>GROUP BY</strong>：</h3><p>基于保留的数据按某个字段做<strong>分组聚合</strong>，如统计、求和等。</p>
<h3 id="🌟5-HAVING："><a href="#🌟5-HAVING：" class="headerlink" title="🌟5. HAVING："></a>🌟5. <strong>HAVING</strong>：</h3><p>对<strong>聚合后的组</strong>进行筛选（如：只保留总金额 &gt; 1000 的组）。</p>
<h3 id="🌟6-SELECT："><a href="#🌟6-SELECT：" class="headerlink" title="🌟6. SELECT："></a>🌟6. <strong>SELECT</strong>：</h3><p>选择返回哪些字段，同时也可能包含聚合函数（如 <code>COUNT(*)</code>, <code>SUM()</code>），此时组已经存在了。</p>
<h3 id="🌟7-ORDER-BY："><a href="#🌟7-ORDER-BY：" class="headerlink" title="🌟7. ORDER BY："></a>🌟7. <strong>ORDER BY</strong>：</h3><p>对最终结果<strong>排序</strong>，这个阶段才有机会看到完整结果。</p>
<h3 id="🌟8-LIMIT："><a href="#🌟8-LIMIT：" class="headerlink" title="🌟8. LIMIT："></a>🌟8. <strong>LIMIT</strong>：</h3><p>只取前几行，<strong>分页优化</strong>的最后一环，减少结果输出体积</p>
<pre><code class="mysql">SELECT u.username, SUM(o.amount) AS total_amount
FROM user u
JOIN `order` o ON u.id = o.user_id
WHERE o.status = &#39;paid&#39;
GROUP BY u.id
HAVING total_amount &gt; 0
ORDER BY total_amount DESC
LIMIT 5;
</code></pre>
<h2 id="这样的顺序有什么优势？"><a href="#这样的顺序有什么优势？" class="headerlink" title="这样的顺序有什么优势？"></a>这样的顺序有什么优势？</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>目的&#x2F;优势</th>
</tr>
</thead>
<tbody><tr>
<td>FROM+JOIN</td>
<td>先构建大数据源结构，作为后续处理基础</td>
</tr>
<tr>
<td>WHERE</td>
<td>尽早过滤不必要的数据 → <strong>提高性能（减少后续数据量）</strong></td>
</tr>
<tr>
<td>GROUP BY</td>
<td>只对保留下来的数据做聚合，<strong>提高分组效率</strong></td>
</tr>
<tr>
<td>HAVING</td>
<td>聚合后再过滤，避免误筛不完整组</td>
</tr>
<tr>
<td>SELECT</td>
<td>最后选择字段，<strong>保证表达式都合法且数据齐全</strong></td>
</tr>
<tr>
<td>ORDER BY</td>
<td>排序通常开销大，<strong>放最后执行</strong>最合理</td>
</tr>
<tr>
<td>LIMIT</td>
<td>控制输出量，<strong>提高响应速度和用户体验</strong></td>
</tr>
</tbody></table>
<h2 id="面试如何回答（建议模板）"><a href="#面试如何回答（建议模板）" class="headerlink" title="面试如何回答（建议模板）"></a>面试如何回答（建议模板）</h2><p>“SQL的执行顺序设计是为了最大限度提升查询效率。先执行FROM和JOIN是因为必须先构建数据源；然后用WHERE尽早过滤行，避免无意义的数据进入分组、排序等更耗性能的阶段；GROUP BY在WHERE过滤后进行，HAVING则是对聚合结果再做筛选；SELECT最后才执行，是因为只有在前面都处理完后，才能确定哪些字段可用；ORDER BY 和 LIMIT是最终结果的加工。这种顺序是数据库执行优化的核心逻辑。”</p>
</blockquote>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
<p>我们在生产环境中遇到接口卡住不响应的情况，会先使用 <code>jps</code> 找到目标 Java 进程的 PID，然后用 <code>jstack &lt;PID&gt;</code> 导出线程堆栈日志。我们重点查看是否存在 <code>Found one Java-level deadlock</code> 的提示，并分析具体是哪几个线程锁住了彼此的资源。如果确认是死锁，我们会进一步分析代码逻辑进行解耦或调整加锁顺序。</p>
<blockquote>
<p>Found one Java-level deadlock:</p>
<p>“Thread-1”:<br>  waiting to lock monitor 0x00000000053c3d28 (object 0x000000076b300030, a java.lang.Object),<br>  which is held by “Thread-0”<br>“Thread-0”:<br>  waiting to lock monitor 0x00000000053c3d48 (object 0x000000076b300028, a java.lang.Object),<br>  which is held by “Thread-1”</p>
<p>Java stack information for the threads listed above:</p>
<p>Thread-1:<br>  at DeadlockDemo.lambda$main$1(DeadlockDemo.java:20)</p>
<ul>
<li>waiting to lock &lt;0x000000076b300030&gt; (a java.lang.Object)</li>
<li>locked &lt;0x000000076b300028&gt; (a java.lang.Object)</li>
</ul>
<p>Thread-0:<br>  at DeadlockDemo.lambda$main$0(DeadlockDemo.java:11)</p>
<ul>
<li>waiting to lock &lt;0x000000076b300028&gt; (a java.lang.Object)</li>
<li>locked &lt;0x000000076b300030&gt; (a java.lang.Object)</li>
</ul>
</blockquote>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当<strong>参数是用户输入</strong>时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会<strong>自动转义参数</strong>。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
<blockquote>
<h3 id="MyBatis-中-和-的区别"><a href="#MyBatis-中-和-的区别" class="headerlink" title="MyBatis 中 #{}和${} 的区别"></a>MyBatis 中 <code>#&#123;&#125;</code>和<code>$&#123;&#125;</code> 的区别</h3><table>
<thead>
<tr>
<th>项目</th>
<th><code>#&#123;&#125;</code>（占位符）</th>
<th><code>$&#123;&#125;</code>（字符串拼接）</th>
</tr>
</thead>
<tbody><tr>
<td>替换方式</td>
<td>使用 <strong>? 占位符</strong></td>
<td><strong>字符串直接拼接进SQL</strong></td>
</tr>
<tr>
<td>是否转义</td>
<td>✅ 自动转义，安全</td>
<td>❌ 不转义，有SQL注入风险</td>
</tr>
<tr>
<td>使用底层</td>
<td>JDBC 的 PreparedStatement</td>
<td>字符串拼接，执行前已成完整SQL</td>
</tr>
<tr>
<td>场景</td>
<td>传入值如：用户名、ID、价格等参数</td>
<td>动态表名、列名、排序字段、函数等</td>
</tr>
<tr>
<td>安全性</td>
<td>安全，推荐使用</td>
<td>不安全，谨慎使用</td>
</tr>
<tr>
<td>类型处理</td>
<td>✅ 自动处理类型转换</td>
<td>❌ 不做类型处理，需手动拼接格式</td>
</tr>
<tr>
<td>性能（缓存）</td>
<td>支持 SQL 缓存</td>
<td>由于 SQL 变化大，缓存命中低</td>
</tr>
</tbody></table>
<h4 id="正确使用"><a href="#正确使用" class="headerlink" title="正确使用 #{}"></a>正确使用 <code>#&#123;&#125;</code></h4><pre><code class="xml">&lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt;
  SELECT * FROM users WHERE id = #&#123;userId&#125;
&lt;/select&gt;
</code></pre>
<ul>
<li>自动转为：<code>SELECT * FROM users WHERE id = ?</code></li>
<li>安全，可防止 SQL 注入。</li>
</ul>
<h4 id="必须使用-的场景（动态表名或列）"><a href="#必须使用-的场景（动态表名或列）" class="headerlink" title="必须使用 ${} 的场景（动态表名或列）"></a>必须使用 <code>$&#123;&#125;</code> 的场景（动态表名或列）</h4><pre><code class="xml">&lt;select id=&quot;selectByColumn&quot; resultType=&quot;User&quot;&gt;
  SELECT * FROM users WHERE $&#123;columnName&#125; = #&#123;value&#125;
&lt;/select&gt;
</code></pre>
<ul>
<li>用于：动态字段（如 <code>name</code>、<code>email</code>）查询。</li>
<li>注意：<code>$&#123;columnName&#125;</code> 可能来自用户输入，<strong>必须白名单校验</strong>，否则容易被 SQL 注入。</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
<li>如果左表是主表，或者左表中的数据是查询的主要关注点，而右表中的数据是辅助信息时，通常使用左外连接。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
<li>如果右表是主表，或者右表中的数据是查询的主要关注点，而左表中的数据是辅助信息时，通常使用右外连接</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
<li>全外连接不常用，因为它通常会返回大量的包含NULL的数据，这可能会导致查询结果难以解释。只有在确实需要两表中的所有数据时才使用。</li>
</ul>
<hr>
<blockquote>
<ul>
<li><strong>性能考虑</strong>：外连接可能会比内连接（Inner Join）更消耗资源，特别是当表很大时。如果可能，尽量使用内连接。</li>
<li><strong>数据完整性</strong>：如果业务逻辑要求查询结果必须包含某个表的所有记录，那么应该使用相应的外连接。</li>
</ul>
<h2 id="内连接-vs-外连接：核心区别总结"><a href="#内连接-vs-外连接：核心区别总结" class="headerlink" title="内连接 vs 外连接：核心区别总结"></a>内连接 vs 外连接：核心区别总结</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>是否保留非匹配行</th>
<th>NULL 出现在哪一边</th>
</tr>
</thead>
<tbody><tr>
<td><strong>内连接</strong></td>
<td>只返回两个表中满足连接条件的<strong>交集部分</strong></td>
<td>❌</td>
<td>❌ 不会有 NULL</td>
</tr>
<tr>
<td><strong>左外连接</strong></td>
<td>保留<strong>左表所有记录</strong>，右表没有匹配的填 NULL</td>
<td>✅（保留左表）</td>
<td>右表字段为 NULL</td>
</tr>
<tr>
<td><strong>右外连接</strong></td>
<td>保留<strong>右表所有记录</strong>，左表没有匹配的填 NULL</td>
<td>✅（保留右表）</td>
<td>左表字段为 NULL</td>
</tr>
<tr>
<td><strong>全外连接</strong></td>
<td>左右两表都保留，不匹配的部分填 NULL（<strong>并集</strong>）</td>
<td>✅（都保留）</td>
<td>两边都可能为 NULL</td>
</tr>
</tbody></table>
<h2 id="✅-图示记忆法"><a href="#✅-图示记忆法" class="headerlink" title="✅ 图示记忆法"></a>✅ 图示记忆法</h2><ul>
<li><code>A</code> 表在左边，<code>B</code> 表在右边：</li>
</ul>
<pre><code class="css">    INNER JOIN：     A ∩ B
    LEFT JOIN：      A ⟕ B
    RIGHT JOIN：     A ⟖ B
    FULL JOIN：      A ∪ B
</code></pre>
<h2 id="✅-实际应用建议"><a href="#✅-实际应用建议" class="headerlink" title="✅ 实际应用建议"></a>✅ 实际应用建议</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐连接方式</th>
</tr>
</thead>
<tbody><tr>
<td>获取匹配数据</td>
<td>INNER JOIN</td>
</tr>
<tr>
<td><strong>主表必须展示，辅表可无</strong></td>
<td><strong>LEFT JOIN</strong></td>
</tr>
<tr>
<td>辅表必须展示，主表可无</td>
<td>RIGHT JOIN</td>
</tr>
<tr>
<td>数据对账&#x2F;差异比对&#x2F;全量汇总</td>
<td>FULL OUTER JOIN</td>
</tr>
</tbody></table>
<p>内连接只返回满足条件的交集数据，外连接用于保留某一边或两边的所有记录。常用的是左外连接，适合主表为主、辅表为辅的场景。外连接比内连接更全，但性能略低，因此建议根据业务场景合理选择。</p>
</blockquote>
<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚**<u>这个技术是解决什么领域的问题</u>**，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h3 id="ThreadLocal相关面试题"><a href="#ThreadLocal相关面试题" class="headerlink" title="ThreadLocal相关面试题"></a>ThreadLocal相关面试题</h3><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h5 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h5><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p><strong>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</strong></p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);// 写入线程本地变量
            getData(&quot;t1&quot;);// 读取线程本地变量
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);// 写入线程本地变量
            getData(&quot;t2&quot;);// 读取线程本地变量
        &#125;, &quot;t2&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<blockquote>
<h2 id="字符串工具类"><a href="#字符串工具类" class="headerlink" title="字符串工具类"></a><strong>字符串工具类</strong></h2><table>
<thead>
<tr>
<th>工具类库</th>
<th>类名</th>
<th>说明与特点</th>
</tr>
</thead>
<tbody><tr>
<td>Apache Commons</td>
<td><code>StringUtils</code> (<code>org.apache.commons.lang3.StringUtils</code>)</td>
<td>提供了大量字符串处理方法，如<code>isBlank()</code>、<code>join()</code>、<code>split()</code>、<code>contains()</code>等。非常稳定、功能强大。</td>
</tr>
<tr>
<td>Hutool</td>
<td><code>StrUtil</code> (<code>cn.hutool.core.util.StrUtil</code>)</td>
<td>轻量级工具包，功能类似，但更加面向国人开发，API 命名更简洁清晰，如 <code>isBlank()</code>、<code>format()</code>、<code>hide()</code>等。</td>
</tr>
<tr>
<td>Java 自带</td>
<td><code>String</code> 类和 <code>StringBuilder</code>, <code>StringBuffer</code></td>
<td>提供基础字符串操作，如 <code>substring()</code>、<code>indexOf()</code>、<code>replace()</code> 等。</td>
</tr>
</tbody></table>
<p><strong>推荐：</strong>开发中可以结合使用 <code>Apache StringUtils</code> 或 <code>Hutool StrUtil</code>，比自己写字符串判断高效且可读性好。</p>
<h2 id="✅-1-用户注册校验-—-Apache-Commons-StringUtils"><a href="#✅-1-用户注册校验-—-Apache-Commons-StringUtils" class="headerlink" title="✅ 1. 用户注册校验 — Apache Commons StringUtils"></a>✅ <strong>1. 用户注册校验 — Apache Commons <code>StringUtils</code></strong></h2><p><strong>业务背景：</strong> 用户注册时，需要校验用户名和邮箱不能为 null 或空字符串。</p>
<pre><code class="java">import org.apache.commons.lang3.StringUtils;

public class UserService &#123;
    public boolean isValidUser(String username, String email) &#123;
        return StringUtils.isNotBlank(username) &amp;&amp; StringUtils.isNotBlank(email);
    &#125;
&#125;
</code></pre>
<h3 id="📌-优势说明："><a href="#📌-优势说明：" class="headerlink" title="📌 优势说明："></a>📌 优势说明：</h3><ul>
<li><code>StringUtils.isNotBlank()</code> 能判断 null、空字符串、全是空格的字符串。</li>
<li>替代了传统的 <code>&quot;&quot;.equals(x) || x == null || x.trim().length() == 0</code>，简洁高效。</li>
</ul>
<hr>
<h2 id="✅-2-昵称脱敏展示-—-Hutool-StrUtil"><a href="#✅-2-昵称脱敏展示-—-Hutool-StrUtil" class="headerlink" title="✅ 2. 昵称脱敏展示 — Hutool StrUtil"></a>✅ <strong>2. 昵称脱敏展示 — Hutool <code>StrUtil</code></strong></h2><p><strong>业务背景：</strong> 用户中心页面要展示脱敏后的昵称，如 <code>张三丰</code> → <code>张*丰</code>。</p>
<pre><code class="java">import cn.hutool.core.util.StrUtil;

public class UserUtil &#123;
    public static String desensitizeName(String name) &#123;
        return StrUtil.hide(name, 1, name.length() - 1); // 从第2位到倒数第1位隐藏
    &#125;
&#125;
</code></pre>
<p><strong>输出示例：</strong></p>
<pre><code class="java">System.out.println(desensitizeName(&quot;张三丰&quot;)); // 张*丰
</code></pre>
<h3 id="📌-优势说明：-1"><a href="#📌-优势说明：-1" class="headerlink" title="📌 优势说明："></a>📌 优势说明：</h3><ul>
<li><code>StrUtil.hide()</code> 非常适合做数据脱敏处理（身份证、手机号等）。</li>
<li>API 直观易用，无需自己写 substring 拼接逻辑。</li>
</ul>
<hr>
<h2 id="✅-3-SQL拼接或日志打印-—-Java-原生-StringBuilder"><a href="#✅-3-SQL拼接或日志打印-—-Java-原生-StringBuilder" class="headerlink" title="✅ 3. SQL拼接或日志打印 — Java 原生 StringBuilder"></a>✅ <strong>3. SQL拼接或日志打印 — Java 原生 <code>StringBuilder</code></strong></h2><p><strong>业务背景：</strong> 拼接一段复杂 SQL 或多字段日志输出。</p>
<pre><code class="java">public class LogBuilder &#123;
    public static String buildLog(String userId, String action, long timestamp) &#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;用户ID: &quot;).append(userId)
          .append(&quot;, 操作: &quot;).append(action)
          .append(&quot;, 时间: &quot;).append(timestamp);
        return sb.toString();
    &#125;
&#125;
</code></pre>
<p><strong>输出：</strong></p>
<pre><code class="java">用户ID: 123456, 操作: 登录, 时间: 1721559065000
</code></pre>
<h3 id="📌-优势说明：-2"><a href="#📌-优势说明：-2" class="headerlink" title="📌 优势说明："></a>📌 优势说明：</h3><ul>
<li><code>StringBuilder</code> 适合循环中或大量字符串拼接，性能比 <code>+</code> 更优。</li>
<li>通常用于日志、SQL、通知信息构建等场景。</li>
</ul>
</blockquote>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p><strong>成员变量</strong>是在jvm的<strong>堆</strong><br><strong>局部变量</strong>是在jvm的<strong>栈</strong><br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<pre><code class="java">public class VariableDemo &#123;

    // 成员变量
    int age = 18;              // 非静态成员变量 -&gt; 堆中
    static String school = &quot;北大&quot;; // 静态成员变量 -&gt; 方法区中

    public void printInfo() &#123;
        // 局部变量
        String name = &quot;小明&quot;;  // 局部变量 -&gt; 栈中
        int age = 20;          // 局部变量，和成员变量重名（就近原则）

        System.out.println(&quot;局部变量 name：&quot; + name); // 小明
        System.out.println(&quot;局部变量 age：&quot; + age);   // 20
        System.out.println(&quot;成员变量 age：&quot; + this.age); // 18（用this访问成员变量）
        System.out.println(&quot;静态变量 school：&quot; + school); // 北大
    &#125;

    public static void main(String[] args) &#123;
        VariableDemo v = new VariableDemo();
        v.printInfo();
    &#125;
&#125;
------------------------------------------------------------------------
JVM 内存结构：

方法区（存放类信息、静态变量等）
└── VariableDemo.class
     └── static school = &quot;北大&quot;

堆内存（存放对象和非静态成员变量）
└── v 对象
     └── age = 18

栈内存（每个线程的栈帧）
└── main() 栈帧
     └── v 引用

└── printInfo() 栈帧
     ├── name = &quot;小明&quot;
     ├── age = 20 （局部变量）
</code></pre>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行<strong>代码审查</strong>，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行<strong>单元测试</strong>，确保代码的功能正确无误。</li>
<li>进行<strong>代码优化</strong>，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，<strong>它将现实世界的事物抽象成程序中的对象</strong>。Java面向对象的主要特征包括：</p>
<ul>
<li><strong>封装</strong>：将对象的<strong>属性</strong>和<strong>行为</strong>封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li><strong>继承</strong>：允许<strong>子类继承父类的属性和行为</strong>，实现代码的复用。</li>
<li><strong>多态</strong>：<strong>同一个接口可以有多个不同的实现</strong>，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较<strong>基本数据类型</strong>时，比较的是<strong>值</strong>；比较<strong>引用数据类型</strong>时，比较的是对象的<strong>内存地址</strong>。</li>
<li>equals：是Object类的一个方法，<strong>默认比较</strong>的是<strong>对象的内存地址</strong>。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<blockquote>
<h4 id="✅-有没有做过权限控制？"><a href="#✅-有没有做过权限控制？" class="headerlink" title="✅ 有没有做过权限控制？"></a>✅ <strong>有没有做过权限控制？</strong></h4><p>有，在项目中我用的是 <strong>Spring Security + JWT</strong> 的权限控制方案，整体基于 <strong>RBAC 模型</strong>（基于角色的访问控制）。</p>
<h4 id="✅-权限模型设计（RBAC）"><a href="#✅-权限模型设计（RBAC）" class="headerlink" title="✅ 权限模型设计（RBAC）"></a>✅ <strong>权限模型设计（RBAC）</strong></h4><p><strong>核心思路：通过“角色”来间接管理用户权限</strong></p>
<table>
<thead>
<tr>
<th>实体</th>
<th>关系说明</th>
</tr>
</thead>
<tbody><tr>
<td>用户（User）</td>
<td>关联多个角色（Role）</td>
</tr>
<tr>
<td>角色（Role）</td>
<td>关联多个权限&#x2F;菜单（Permission）</td>
</tr>
<tr>
<td>权限（Permission）</td>
<td>描述资源：菜单、接口等</td>
</tr>
</tbody></table>
<p>中间表设计：</p>
<ul>
<li>用户角色表（user_role）→ 多对多</li>
<li>角色权限表（role_permission）→ 多对多</li>
</ul>
<h2 id="✅-SpringSecurity-是如何实现的？"><a href="#✅-SpringSecurity-是如何实现的？" class="headerlink" title="✅ SpringSecurity 是如何实现的？"></a>✅ <span style = "color:red"><strong>SpringSecurity 是如何实现的？</strong></span></h2><p>项目是 <strong>前后端分离</strong>，使用的是 <strong>JWT 无状态认证</strong>。</p>
<h3 id="1️⃣-用户登录认证（AuthenticationManager）"><a href="#1️⃣-用户登录认证（AuthenticationManager）" class="headerlink" title="1️⃣ 用户登录认证（AuthenticationManager）"></a>1️⃣ 用户登录认证（<code>AuthenticationManager</code>）</h3><ul>
<li>用户登录提交账号密码 → 调用 SpringSecurity 的认证逻辑</li>
<li>认证通过后，生成 <strong>JWT Token</strong> 返回给前端<del>前端在随后的请求中携带这个JWT令牌</del></li>
<li>同时把 <strong>用户信息 + 权限信息</strong> 缓存在 Redis 中</li>
</ul>
<h3 id="2️⃣-用户请求鉴权（拦截-校验）"><a href="#2️⃣-用户请求鉴权（拦截-校验）" class="headerlink" title="2️⃣ 用户请求鉴权（拦截 + 校验）"></a>2️⃣ 用户请求鉴权（拦截 + 校验）</h3><p>用户每次访问接口都带上 JWT：<del>使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性</del></p>
<h4 id="核心流程："><a href="#核心流程：" class="headerlink" title="核心流程："></a>核心流程：</h4><pre><code class="java">请求到来 → JWT过滤器提取Token → 解析用户信息 → 加载权限 → 比对是否有权限 → 放行 or 拦截
</code></pre>
<h4 id="具体细节："><a href="#具体细节：" class="headerlink" title="具体细节："></a>具体细节：</h4><ul>
<li>使用 <strong>自定义过滤器</strong> 替换 <code>UsernamePasswordAuthenticationFilter</code></li>
<li>Token 中取出用户名 → 去 Redis 中拿权限信息（避免每次都查库）</li>
<li>使用 <strong><code>AccessDecisionManager</code></strong> 和 <strong><code>SecurityMetadataSource</code></strong> 判断当前接口所需权限是否被用户拥有</li>
<li>校验成功：放行；校验失败：返回 403 自定义响应（如“无权限访问”）</li>
</ul>
<h2 id="✅-为什么使用-Redis-缓存权限？"><a href="#✅-为什么使用-Redis-缓存权限？" class="headerlink" title="✅ 为什么使用 Redis 缓存权限？"></a>✅ <strong>为什么使用 Redis 缓存权限？</strong></h2><ul>
<li>避免每次请求都去查数据库，提升性能</li>
<li>实现单点登录、Token失效管理等操作更方便</li>
<li>权限信息改动 → Redis 也同步更新</li>
</ul>
<hr>
<h2 id="✅-如何定义哪些接口需要权限？"><a href="#✅-如何定义哪些接口需要权限？" class="headerlink" title="✅ 如何定义哪些接口需要权限？"></a>✅ <strong>如何定义哪些接口需要权限？</strong></h2><ul>
<li>使用 <code>@PreAuthorize(&quot;hasAuthority(&#39;xxx&#39;)&quot;)</code></li>
<li>或者用自定义权限注解 + AOP 实现</li>
</ul>
<hr>
<h2 id="✅-总结一句话回答"><a href="#✅-总结一句话回答" class="headerlink" title="✅ 总结一句话回答"></a>✅ 总结一句话回答</h2><p>我使用的是基于 <strong>JWT + SpringSecurity</strong> 的权限控制，采用的是 <strong>RBAC 模型</strong>，通过用户角色权限的绑定来控制资源访问。权限信息登录时就缓存到 Redis，提高了性能，接口鉴权用的是自定义的 <code>AccessDecisionManager</code> 来校验 Token 与权限是否匹配，确保接口安全。</p>
</blockquote>
<blockquote>
<h3 id="✅-场景描述：权限精确到按钮级别"><a href="#✅-场景描述：权限精确到按钮级别" class="headerlink" title="✅ 场景描述：权限精确到按钮级别"></a>✅ 场景描述：<span style = "color:red">权限精确到按钮级别</span></h3><p>不仅控制用户能否访问“某个菜单”，还要控制：</p>
<ul>
<li>某些用户能看到“编辑”按钮</li>
<li>某些用户不能看到“删除”按钮</li>
<li>某些按钮点击后后台要鉴权（如“导出”、“审核”等）</li>
</ul>
<h2 id="🧩-一、数据库设计（基于-RBAC-模型）"><a href="#🧩-一、数据库设计（基于-RBAC-模型）" class="headerlink" title="🧩 一、数据库设计（基于 RBAC 模型）"></a>🧩 一、数据库设计（基于 RBAC 模型）</h2><h3 id="1️⃣-表结构设计（核心五张表）"><a href="#1️⃣-表结构设计（核心五张表）" class="headerlink" title="1️⃣ 表结构设计（核心五张表）"></a>1️⃣ 表结构设计（核心五张表）</h3><table>
<thead>
<tr>
<th>表名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>user</code></td>
<td>用户表</td>
</tr>
<tr>
<td><code>role</code></td>
<td>角色表</td>
</tr>
<tr>
<td><code>permission</code></td>
<td>权限资源表（菜单、接口、按钮）</td>
</tr>
<tr>
<td><code>user_role</code></td>
<td>用户与角色的多对多关联</td>
</tr>
<tr>
<td><code>role_permission</code></td>
<td>角色与权限的多对多关联</td>
</tr>
</tbody></table>
<h3 id="2️⃣-permission-权限表示例（关键）"><a href="#2️⃣-permission-权限表示例（关键）" class="headerlink" title="2️⃣ permission 权限表示例（关键）"></a>2️⃣ <code>permission</code> 权限表示例（关键）</h3><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>主键</td>
</tr>
<tr>
<td>name</td>
<td>权限名称，例如“删除按钮”</td>
</tr>
<tr>
<td>type</td>
<td>类型：<code>menu</code>、<code>button</code>、<code>api</code></td>
</tr>
<tr>
<td>perm_code</td>
<td>权限标识，例如：<code>user:delete</code>、<code>user:edit</code></td>
</tr>
<tr>
<td>parent_id</td>
<td>上级权限（菜单树结构）</td>
</tr>
<tr>
<td>url &#x2F; path</td>
<td>前端路由或接口路径</td>
</tr>
<tr>
<td>method</td>
<td>请求方式：<code>GET/POST/DELETE</code>（接口专用）</td>
</tr>
</tbody></table>
<p>🚨 <strong>重点</strong>：按钮权限是存放在 <code>permission</code> 表里的，只是 <code>type = button</code>，和菜单&#x2F;接口共用一个表。</p>
<h2 id="🔁-二、后端逻辑处理流程"><a href="#🔁-二、后端逻辑处理流程" class="headerlink" title="🔁 二、后端逻辑处理流程"></a>🔁 二、后端逻辑处理流程</h2><h3 id="1️⃣-用户登录时加载权限"><a href="#1️⃣-用户登录时加载权限" class="headerlink" title="1️⃣ 用户登录时加载权限"></a>1️⃣ 用户登录时加载权限</h3><pre><code class="java">@Override
public UserDetails loadUserByUsername(String username) &#123;
    // 1. 查询用户
    User user = userMapper.selectByUsername(username);

    // 2. 查询权限（按钮 + 接口 + 菜单）
    List&lt;String&gt; permissionCodes = permissionMapper.getUserPerms(user.getId());

    // 3. 存入 UserDetails
    return new LoginUser(user, permissionCodes);
&#125;
</code></pre>
<p>✔️ 这些 <code>permissionCodes</code> 会通过 JWT 或 Redis 存起来，后续用来鉴权和前端展示。</p>
<h3 id="2️⃣-鉴权控制（精确到按钮）"><a href="#2️⃣-鉴权控制（精确到按钮）" class="headerlink" title="2️⃣ 鉴权控制（精确到按钮）"></a>2️⃣ 鉴权控制（精确到按钮）</h3><p>你需要：</p>
<ul>
<li><strong>后端校验接口权限</strong>（如调用删除接口必须拥有 <code>user:delete</code> 权限）</li>
<li><strong>前端展示按钮</strong>要判断是否有权限</li>
</ul>
<h4 id="🧷-方法一：接口权限控制（后端）"><a href="#🧷-方法一：接口权限控制（后端）" class="headerlink" title="🧷 方法一：接口权限控制（后端）"></a>🧷 方法一：接口权限控制（后端）</h4><pre><code class="java">@PreAuthorize(&quot;hasAuthority(&#39;user:delete&#39;)&quot;) // ★★★★
@DeleteMapping(&quot;/user/delete/&#123;id&#125;&quot;)
public void deleteUser(@PathVariable Long id) &#123;
    // 业务逻辑
&#125;
</code></pre>
<blockquote>
<p>✔️ 只有拥有 <code>user:delete</code> 权限的用户才能调用这个接口。</p>
</blockquote>
<hr>
<h4 id="🧷-方法二：按钮权限控制（前端）"><a href="#🧷-方法二：按钮权限控制（前端）" class="headerlink" title="🧷 方法二：按钮权限控制（前端）"></a>🧷 方法二：按钮权限控制（前端）</h4><pre><code class="vue">&lt;!-- Vue 示例 --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;el-button v-if=&quot;hasPermission(&#39;user:edit&#39;)&quot;&gt;编辑&lt;/el-button&gt;
    &lt;el-button v-if=&quot;hasPermission(&#39;user:delete&#39;)&quot;&gt;删除&lt;/el-button&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">// 权限判断函数
export function hasPermission(code) &#123;
  const perms = JSON.parse(localStorage.getItem(&quot;userPerms&quot;)) || [];
  return perms.includes(code);
&#125;
</code></pre>
<h5 id="🛠-三、JWT-Redis-权限缓存方案（提高性能）"><a href="#🛠-三、JWT-Redis-权限缓存方案（提高性能）" class="headerlink" title="🛠 三、JWT + Redis 权限缓存方案（提高性能）"></a>🛠 三、JWT + Redis 权限缓存方案（提高性能）</h5><h5 id="登录成功后："><a href="#登录成功后：" class="headerlink" title="登录成功后："></a>登录成功后：</h5><pre><code class="java">// 登录成功后：
String token = jwtUtil.generateToken(userId);

// Redis缓存用户权限
redis.set(&quot;login:&quot; + userId, JSON.stringify(LoginUser对象)) // 包括 permissionCodes

// 返回token给前端
</code></pre>
<h5 id="鉴权过滤器："><a href="#鉴权过滤器：" class="headerlink" title="鉴权过滤器："></a>鉴权过滤器：</h5><pre><code class="java">// Token过滤器从请求头获取token → 从Redis读取用户权限 → 设置SecurityContext
</code></pre>
<hr>
<h5 id="📐-四、权限结构如何传给前端？"><a href="#📐-四、权限结构如何传给前端？" class="headerlink" title="📐 四、权限结构如何传给前端？"></a>📐 四、权限结构如何传给前端？</h5><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code class="json">[
  &#123;
    &quot;menuName&quot;: &quot;用户管理&quot;,
    &quot;path&quot;: &quot;/user&quot;,
    &quot;children&quot;: [
      &#123;
        &quot;menuName&quot;: &quot;用户列表&quot;,
        &quot;path&quot;: &quot;/user/list&quot;,
        &quot;permissions&quot;: [&quot;user:add&quot;, &quot;user:delete&quot;, &quot;user:edit&quot;]
      &#125;
    ]
  &#125;
]
</code></pre>
<p>前端根据这些 <code>permissions</code> 控制按钮显示。</p>
<hr>
<h2 id="✅-总结一句话回答："><a href="#✅-总结一句话回答：" class="headerlink" title="✅ 总结一句话回答："></a>✅ 总结一句话回答：</h2><p>在项目中我们实现了<strong>精确到按钮级别的权限控制</strong>。使用 RBAC 模型统一管理“菜单、接口、按钮权限”，后端统一校验权限（用 Spring Security 的 <code>@PreAuthorize</code>），前端根据用户权限码动态控制按钮的显示，用户权限在登录时就加载并缓存到 Redis + JWT 中，实现了性能与安全的平衡。</p>
<h2 id="✅-真实项目中常见补充点（面试必问）"><a href="#✅-真实项目中常见补充点（面试必问）" class="headerlink" title="✅ 真实项目中常见补充点（面试必问）"></a>✅ 真实项目中常见补充点（面试必问）</h2><table>
<thead>
<tr>
<th>问题</th>
<th>解答</th>
</tr>
</thead>
<tbody><tr>
<td>前端怎么知道自己有哪些权限？</td>
<td>登录后从后端返回权限码数组，如 <code>[&quot;user:add&quot;, &quot;user:delete&quot;]</code>，存在 Vuex &#x2F; Pinia 或 localStorage 中</td>
</tr>
<tr>
<td>权限更新了怎么办？</td>
<td>更新用户角色后，同时刷新 Redis 缓存或设置 token 过期时间较短</td>
</tr>
<tr>
<td>一个按钮需要多个权限怎么办？</td>
<td><code>v-if=&quot;hasPermission(&#39;user:add&#39;) &amp;&amp; hasPermission(&#39;user:export&#39;)&quot;</code></td>
</tr>
</tbody></table>
<h4 id="我想要你详细讲一下-数据库的那张权限表-帮我模拟一些字段和数据-实现达到按钮级别"><a href="#我想要你详细讲一下-数据库的那张权限表-帮我模拟一些字段和数据-实现达到按钮级别" class="headerlink" title="我想要你详细讲一下 数据库的那张权限表 帮我模拟一些字段和数据 实现达到按钮级别"></a><span style = "color:blue">我想要你详细讲一下 数据库的那张权限表 帮我模拟一些字段和数据 实现达到按钮级别</span></h4><p>我们就来详细 <strong>模拟一张完整的权限表（<code>permission</code>）</strong>，并：</p>
<ol>
<li>定义它的字段含义</li>
<li>填入一些真实的示例数据（<strong>精确到按钮级别</strong>）</li>
<li>分析如何建立菜单树、按钮权限和接口权限之间的关系</li>
<li>说明这些数据在前后端中如何使用</li>
</ol>
<h2 id="🧩-一、权限表（permission）字段设计"><a href="#🧩-一、权限表（permission）字段设计" class="headerlink" title="🧩 一、权限表（permission）字段设计"></a>🧩 一、权限表（<code>permission</code>）字段设计</h2><table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>示例值</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>BIGINT</td>
<td><code>1001</code></td>
<td>权限唯一标识（长整型，通常是雪花ID）</td>
</tr>
<tr>
<td><code>name</code></td>
<td>VARCHAR</td>
<td><code>&quot;用户管理&quot;</code></td>
<td>权限名称（菜单&#x2F;按钮&#x2F;接口名称）</td>
</tr>
<tr>
<td><code>type</code></td>
<td>VARCHAR</td>
<td><code>&quot;menu&quot;</code> &#x2F; <code>&quot;button&quot;</code> &#x2F; <code>&quot;api&quot;</code></td>
<td>权限类型，支持菜单、按钮、接口</td>
</tr>
<tr>
<td><code>parent_id</code></td>
<td>BIGINT</td>
<td><code>0</code> &#x2F; <code>1001</code> &#x2F; <code>1002</code></td>
<td>上级ID（0 表示顶级）</td>
</tr>
<tr>
<td><code>perm_code</code></td>
<td>VARCHAR</td>
<td><code>&quot;user:list&quot;</code> &#x2F; <code>&quot;user:delete&quot;</code></td>
<td>权限标识，用于校验</td>
</tr>
<tr>
<td><code>url</code> &#x2F; <code>path</code></td>
<td>VARCHAR</td>
<td><code>&quot;/user/list&quot;</code> &#x2F; <code>&quot;/api/user/delete&quot;</code></td>
<td>前端路由或后台接口地址</td>
</tr>
<tr>
<td><code>method</code></td>
<td>VARCHAR</td>
<td><code>&quot;GET&quot;</code> &#x2F; <code>&quot;POST&quot;</code> &#x2F; <code>&quot;DELETE&quot;</code></td>
<td>请求方式（用于接口）</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>INT</td>
<td><code>1</code> &#x2F; <code>2</code> &#x2F; <code>3</code></td>
<td>排序字段</td>
</tr>
<tr>
<td><code>status</code></td>
<td>TINYINT</td>
<td><code>1</code></td>
<td>启用状态：1启用、0禁用</td>
</tr>
<tr>
<td><code>visible</code></td>
<td>TINYINT</td>
<td><code>1</code></td>
<td>是否前端可见（按钮用）</td>
</tr>
</tbody></table>
<h2 id="📌-二、模拟真实权限表数据（示例）"><a href="#📌-二、模拟真实权限表数据（示例）" class="headerlink" title="📌 二、模拟真实权限表数据（示例）"></a>📌 二、模拟真实权限表数据（示例）</h2><p>假设我们有一个系统模块叫“用户管理”，有一个菜单和三个按钮：</p>
<ul>
<li>用户管理（菜单）</li>
<li>查询用户（按钮）</li>
<li>编辑用户（按钮）</li>
<li>删除用户（按钮）</li>
</ul>
<p>我们再加上一个接口权限作为后台控制。【这里<strong>id</strong>和<strong>parent_id</strong>很重要】</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>type</th>
<th>parent_id</th>
<th>perm_code</th>
<th>path</th>
<th>method</th>
<th>visible</th>
<th>sort</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>用户管理</td>
<td><code>menu</code></td>
<td>0</td>
<td><code>user:root</code></td>
<td><code>/user</code></td>
<td>null</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1001</td>
<td>用户列表</td>
<td><code>menu</code></td>
<td>1000</td>
<td><code>user:list</code></td>
<td><code>/user/list</code></td>
<td>null</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1002</td>
<td>查询按钮</td>
<td><code>button</code></td>
<td>1001</td>
<td><code>user:query</code></td>
<td>null</td>
<td>null</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1003</td>
<td>编辑按钮</td>
<td><code>button</code></td>
<td>1001</td>
<td><code>user:edit</code></td>
<td>null</td>
<td>null</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1004</td>
<td>删除按钮</td>
<td><code>button</code></td>
<td>1001</td>
<td><code>user:delete</code></td>
<td>null</td>
<td>null</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>1005</td>
<td>删除用户API</td>
<td><code>api</code></td>
<td>1001</td>
<td><code>user:delete</code></td>
<td><code>/api/user/delete</code></td>
<td>DELETE</td>
<td>0</td>
<td>4</td>
</tr>
</tbody></table>
<h2 id="🧠-三、说明和作用分析"><a href="#🧠-三、说明和作用分析" class="headerlink" title="🧠 三、说明和作用分析"></a>🧠 三、说明和作用分析</h2><h3 id="1️⃣-type-menu"><a href="#1️⃣-type-menu" class="headerlink" title="1️⃣ type = menu"></a>1️⃣ <code>type = menu</code></h3><ul>
<li>表示是<strong>页面菜单节点</strong></li>
<li>前端构建菜单树的依据</li>
<li>有<code>path</code>字段，用于前端路由匹配</li>
</ul>
<h3 id="2️⃣-type-button"><a href="#2️⃣-type-button" class="headerlink" title="2️⃣ type = button"></a>2️⃣ <code>type = button</code></h3><ul>
<li>表示按钮级别权限</li>
<li><strong>前端判断按钮显隐</strong>时使用：</li>
</ul>
<pre><code class="js">hasPermission(&#39;user:delete&#39;) ? 显示删除按钮 : 不显示
</code></pre>
<h3 id="3️⃣-type-api"><a href="#3️⃣-type-api" class="headerlink" title="3️⃣ type = api"></a>3️⃣ <code>type = api</code></h3><ul>
<li>表示后台接口权限</li>
<li>由 Spring Security + <code>@PreAuthorize(&quot;hasAuthority(&#39;user:delete&#39;)&quot;)</code> 控制接口是否放行</li>
</ul>
<h3 id="4️⃣-perm-code"><a href="#4️⃣-perm-code" class="headerlink" title="4️⃣ perm_code"></a>4️⃣ <code>perm_code</code></h3><ul>
<li>每一个权限都有一个唯一 <code>perm_code</code>，即权限码</li>
<li>按钮和API**可以共用一个 <code>perm_code</code>**，代表前后端权限打通</li>
</ul>
<h2 id="🧾-附：完整表结构建表SQL"><a href="#🧾-附：完整表结构建表SQL" class="headerlink" title="🧾 附：完整表结构建表SQL"></a>🧾 附：完整表结构建表SQL</h2><pre><code class="sql">CREATE TABLE `permission` (
  `id` BIGINT PRIMARY KEY,
  `name` VARCHAR(100) NOT NULL,
  `type` VARCHAR(20) NOT NULL COMMENT &#39;menu, button, api&#39;,
  `parent_id` BIGINT DEFAULT 0,
  `perm_code` VARCHAR(100),
  `path` VARCHAR(200),
  `method` VARCHAR(10),
  `visible` TINYINT DEFAULT 1,
  `sort` INT DEFAULT 1,
  `status` TINYINT DEFAULT 1
);
</code></pre>
</blockquote>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。【无返回值】</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法【有返回值】</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：<strong>读多写少</strong> 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：<strong>写多读少</strong> 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<blockquote>
<h2 id="🔒-各种锁对比表格"><a href="#🔒-各种锁对比表格" class="headerlink" title="🔒 各种锁对比表格"></a>🔒 各种锁对比表格</h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>乐观锁（version）</td>
<td>冲突少、性能优先</td>
<td>无阻塞、效率高</td>
<td>有冲突时需重试，自旋成本高</td>
</tr>
<tr>
<td>悲观锁（for update）</td>
<td>冲突多、安全性要求高</td>
<td>强一致性</td>
<td>并发性能差，可能导致死锁</td>
</tr>
<tr>
<td>分布式锁（Redis&#x2F;Redisson）</td>
<td>多服务&#x2F;微服务场景</td>
<td>支持跨节点资源锁定</td>
<td>实现复杂，依赖中间件</td>
</tr>
<tr>
<td>本地锁（synchronized&#x2F;Lock）</td>
<td>单服务场景</td>
<td>实现简单</td>
<td>无法跨JVM，分布式无效</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
<h3 id="🧩-场景-1：筛选出余额大于1000的用户列表（filter）"><a href="#🧩-场景-1：筛选出余额大于1000的用户列表（filter）" class="headerlink" title="🧩 场景 1：筛选出余额大于1000的用户列表（filter）"></a>🧩 场景 1：筛选出余额大于1000的用户列表（<code>filter</code>）</h3><pre><code class="java">List&lt;User&gt; richUsers = userList.stream()
    .filter(user -&gt; user.getBalance().compareTo(BigDecimal.valueOf(1000)) &gt; 0)
    .collect(Collectors.toList());
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>filter</code> 用来“过滤”，留下满足条件的用户。</p>
<hr>
<h3 id="🧩-场景-2：获取所有用户名组成的新列表（map）"><a href="#🧩-场景-2：获取所有用户名组成的新列表（map）" class="headerlink" title="🧩 场景 2：获取所有用户名组成的新列表（map）"></a>🧩 场景 2：获取所有用户名组成的新列表（<code>map</code>）</h3><pre><code class="java">List&lt;String&gt; usernameList = userList.stream()
    .map(User::getUsername)
    .collect(Collectors.toList());
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>map</code> 是映射，通常是将对象转换成某个字段或新结构。</p>
<hr>
<h3 id="🧩-场景-3：对订单按金额排序（sorted）"><a href="#🧩-场景-3：对订单按金额排序（sorted）" class="headerlink" title="🧩 场景 3：对订单按金额排序（sorted）"></a>🧩 场景 3：对订单按金额排序（<code>sorted</code>）</h3><pre><code class="java">List&lt;Order&gt; sortedOrders = orderList.stream()
    .sorted(Comparator.comparing(Order::getAmount))
    .collect(Collectors.toList());
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>sorted</code> 用于排序，自定义排序字段。</p>
<hr>
<h3 id="🧩-场景-4：统计多少个订单金额大于1000（filter-count）"><a href="#🧩-场景-4：统计多少个订单金额大于1000（filter-count）" class="headerlink" title="🧩 场景 4：统计多少个订单金额大于1000（filter + count）"></a>🧩 场景 4：统计多少个订单金额大于1000（<code>filter + count</code>）</h3><pre><code class="java">long highValueOrderCount = orderList.stream()
    .filter(order -&gt; order.getAmount().compareTo(BigDecimal.valueOf(1000)) &gt; 0)
    .count();
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>count()</code> 是终止操作，直接返回数量。</p>
<hr>
<h3 id="🧩-场景-5：判断是否有用户未激活（anyMatch）"><a href="#🧩-场景-5：判断是否有用户未激活（anyMatch）" class="headerlink" title="🧩 场景 5：判断是否有用户未激活（anyMatch）"></a>🧩 场景 5：判断是否有用户未激活（<code>anyMatch</code>）</h3><pre><code class="java">boolean hasInactive = userList.stream()
    .anyMatch(user -&gt; !user.isActive());
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>anyMatch</code> 检查<strong>是否存在</strong>一个满足条件的元素。</p>
<hr>
<h3 id="🧩-场景-6：求所有订单的总金额（map-reduce）"><a href="#🧩-场景-6：求所有订单的总金额（map-reduce）" class="headerlink" title="🧩 场景 6：求所有订单的总金额（map + reduce）"></a>🧩 场景 6：求所有订单的总金额（<code>map + reduce</code>）</h3><pre><code class="java">BigDecimal totalAmount = orderList.stream()
    .map(Order::getAmount)
    .reduce(BigDecimal.ZERO, BigDecimal::add);
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>reduce</code> 是归约，把多个值合成一个值。</p>
<hr>
<h3 id="🧩-场景-7：跳过前5条，取后5条（skip-limit）"><a href="#🧩-场景-7：跳过前5条，取后5条（skip-limit）" class="headerlink" title="🧩 场景 7：跳过前5条，取后5条（skip + limit）"></a>🧩 场景 7：跳过前5条，取后5条（<code>skip + limit</code>）</h3><pre><code class="java">List&lt;Order&gt; lastFive = orderList.stream()
    .skip(orderList.size() - 5)
    .limit(5)
    .collect(Collectors.toList());
</code></pre>
<p>✅ <strong>重点理解：</strong> 用于分页、滚动加载的典型场景。</p>
<hr>
<h3 id="🧩-场景-8：分组统计——按用户ID分组他们的订单（collect-Collectors-groupingBy-）"><a href="#🧩-场景-8：分组统计——按用户ID分组他们的订单（collect-Collectors-groupingBy-）" class="headerlink" title="🧩 场景 8：分组统计——按用户ID分组他们的订单（collect(Collectors.groupingBy)）"></a>🧩 场景 8：分组统计——按用户ID分组他们的订单（<code>collect(Collectors.groupingBy)</code>）</h3><pre><code class="java">Map&lt;Long, List&lt;Order&gt;&gt; ordersByUser = orderList.stream()
    .collect(Collectors.groupingBy(Order::getUserId));
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>groupingBy</code> 是分组聚合操作。</p>
<hr>
<h3 id="🧩-场景-9：提取用户ID组成-Set-去重（map-collect-Collectors-toSet-）"><a href="#🧩-场景-9：提取用户ID组成-Set-去重（map-collect-Collectors-toSet-）" class="headerlink" title="🧩 场景 9：提取用户ID组成 Set 去重（map + collect(Collectors.toSet())）"></a>🧩 场景 9：提取用户ID组成 Set 去重（<code>map + collect(Collectors.toSet())</code>）</h3><pre><code class="java">Set&lt;Long&gt; userIds = userList.stream()
    .map(User::getId)
    .collect(Collectors.toSet());
</code></pre>
<p>✅ <strong>重点理解：</strong> 利用 <code>Set</code> 实现自动去重。</p>
<hr>
<h3 id="🧩-场景-10：查找第一个未发货订单（filter-findFirst）"><a href="#🧩-场景-10：查找第一个未发货订单（filter-findFirst）" class="headerlink" title="🧩 场景 10：查找第一个未发货订单（filter + findFirst）"></a>🧩 场景 10：查找第一个未发货订单（<code>filter + findFirst</code>）</h3><pre><code class="java">Optional&lt;Order&gt; firstUnshipped = orderList.stream()
    .filter(order -&gt; !order.isShipped())
    .findFirst();
</code></pre>
<p>✅ <strong>重点理解：</strong> <code>findFirst()</code> 返回的是 <code>Optional&lt;T&gt;</code>，避免空指针。</p>
<hr>
<h3 id="✅-总结表：常用-Stream-操作一图读懂"><a href="#✅-总结表：常用-Stream-操作一图读懂" class="headerlink" title="✅ 总结表：常用 Stream 操作一图读懂"></a>✅ 总结表：常用 Stream 操作一图读懂</h3><table>
<thead>
<tr>
<th>操作方法</th>
<th>功能说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>filter()</code></td>
<td>过滤数据</td>
<td><code>filter(u -&gt; u.age &gt; 18)</code></td>
</tr>
<tr>
<td><code>map()</code></td>
<td>映射转换</td>
<td><code>map(User::getId)</code></td>
</tr>
<tr>
<td><code>sorted()</code></td>
<td>排序</td>
<td><code>sorted(Comparator.comparing())</code></td>
</tr>
<tr>
<td><code>limit()</code></td>
<td>限制返回个数</td>
<td><code>limit(10)</code></td>
</tr>
<tr>
<td><code>skip()</code></td>
<td>跳过前面几个</td>
<td><code>skip(5)</code></td>
</tr>
<tr>
<td><code>collect()</code></td>
<td>收集结果</td>
<td><code>collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><code>count()</code></td>
<td>计数</td>
<td><code>.count()</code></td>
</tr>
<tr>
<td><code>anyMatch()</code></td>
<td>是否有任意一个满足</td>
<td><code>anyMatch(u -&gt; !u.active)</code></td>
</tr>
<tr>
<td><code>allMatch()</code></td>
<td>所有都满足</td>
<td><code>allMatch(u -&gt; u.age &gt; 0)</code></td>
</tr>
<tr>
<td><code>reduce()</code></td>
<td>累积求和等</td>
<td><code>reduce(0, Integer::sum)</code></td>
</tr>
<tr>
<td><code>findFirst()</code></td>
<td>返回第一个</td>
<td><code>findFirst()</code></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="总结一下lambdaquerywrapper-和-querywrapper的区别-还有他们各自的真实场景"><a href="#总结一下lambdaquerywrapper-和-querywrapper的区别-还有他们各自的真实场景" class="headerlink" title="总结一下lambdaquerywrapper 和 querywrapper的区别 还有他们各自的真实场景"></a><span style = "color:red">总结一下lambdaquerywrapper 和 querywrapper的区别 还有他们各自的真实场景</span></h4><blockquote>
<h3 id="✅-一句话区分："><a href="#✅-一句话区分：" class="headerlink" title="✅ 一句话区分："></a>✅ 一句话区分：</h3><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>使用方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>QueryWrapper</code></td>
<td>通过 <strong>字段名字符串</strong> 构造条件</td>
<td><code>.eq(&quot;username&quot;, &quot;Tom&quot;)</code></td>
</tr>
<tr>
<td><code>LambdaQueryWrapper</code></td>
<td>通过 <strong>方法引用（安全）</strong> 构造条件</td>
<td><code>.eq(User::getUsername, &quot;Tom&quot;)</code></td>
</tr>
</tbody></table>
<h2 id="✳️-1-QueryWrapper：字段名写字符串的方式"><a href="#✳️-1-QueryWrapper：字段名写字符串的方式" class="headerlink" title="✳️ 1. QueryWrapper：字段名写字符串的方式"></a>✳️ 1. <code>QueryWrapper</code>：字段名写字符串的方式</h2><h3 id="✅-特点："><a href="#✅-特点：" class="headerlink" title="✅ 特点："></a>✅ 特点：</h3><ul>
<li>字段名用字符串传入，如 <code>&quot;username&quot;</code>。</li>
<li>使用简单、灵活、直观。</li>
<li><strong>但容易拼写错误，且不支持字段重构（字段名变了不会报错）</strong>。</li>
</ul>
<h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><pre><code class="java">QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
wrapper.eq(&quot;username&quot;, &quot;Tom&quot;)
       .ge(&quot;age&quot;, 18)
       .like(&quot;email&quot;, &quot;@gmail.com&quot;);

List&lt;User&gt; list = userMapper.selectList(wrapper);
</code></pre>
<h3 id="✅-适用场景："><a href="#✅-适用场景：" class="headerlink" title="✅ 适用场景："></a>✅ 适用场景：</h3><ul>
<li>快速写 Demo、测试。</li>
<li>字段是动态传入的（如：前端传字段名）——需要用字符串拼字段名。</li>
<li>表字段不会频繁变动。</li>
</ul>
<hr>
<h2 id="✳️-2-LambdaQueryWrapper：方法引用式，更安全！"><a href="#✳️-2-LambdaQueryWrapper：方法引用式，更安全！" class="headerlink" title="✳️ 2. LambdaQueryWrapper：方法引用式，更安全！"></a>✳️ 2. <code>LambdaQueryWrapper</code>：方法引用式，更安全！</h2><h3 id="✅-特点：-1"><a href="#✅-特点：-1" class="headerlink" title="✅ 特点："></a>✅ 特点：</h3><ul>
<li>使用 <strong>方法引用</strong>（如 <code>User::getUsername</code>），可以避免拼写错误。</li>
<li>编译时检查字段名，重命名字段 IDE 可自动修改引用。</li>
<li>更加 <strong>类型安全、可维护</strong>。</li>
</ul>
<h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.eq(User::getUsername, &quot;Tom&quot;)
       .ge(User::getAge, 18)
       .like(User::getEmail, &quot;@gmail.com&quot;);

List&lt;User&gt; list = userMapper.selectList(wrapper);
</code></pre>
<h3 id="✅-适用场景：-1"><a href="#✅-适用场景：-1" class="headerlink" title="✅ 适用场景："></a>✅ 适用场景：</h3><ul>
<li>实际项目开发中推荐优先使用。</li>
<li>字段会变，怕忘改地方。</li>
<li>追求代码规范、可读性和安全性。</li>
</ul>
<h2 id="🔍-场景对比总结："><a href="#🔍-场景对比总结：" class="headerlink" title="🔍 场景对比总结："></a>🔍 场景对比总结：</h2><table>
<thead>
<tr>
<th>需求&#x2F;场景</th>
<th>推荐使用</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>字段名是前端传过来的字符串</td>
<td><code>QueryWrapper</code></td>
<td>字段名只能动态拼接</td>
</tr>
<tr>
<td>普通查询（写死字段名）</td>
<td><code>LambdaQueryWrapper</code></td>
<td>编译器校验字段名，防止拼写错误</td>
</tr>
<tr>
<td>想快速测试或写 Demo</td>
<td><code>QueryWrapper</code></td>
<td>简洁方便</td>
</tr>
<tr>
<td>表结构变动频繁、重构频繁</td>
<td><code>LambdaQueryWrapper</code></td>
<td>字段引用会被 IDE 识别</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="LambdaQueryWrapper真实场景"><a href="#LambdaQueryWrapper真实场景" class="headerlink" title="LambdaQueryWrapper真实场景"></a><span style = "color:red"><code>LambdaQueryWrapper</code>真实场景</span></h4><blockquote>
<h2 id="✅-场景一：精确查询：查某个用户是否存在"><a href="#✅-场景一：精确查询：查某个用户是否存在" class="headerlink" title="✅ 场景一：精确查询：查某个用户是否存在"></a>✅ 场景一：<strong>精确查询：查某个用户是否存在</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.eq(User::getUsername, &quot;admin&quot;);

User user = userMapper.selectOne(wrapper);
</code></pre>
<blockquote>
<p>说明：判断用户名为 admin 的用户是否存在。<code>eq</code> 表示等于。</p>
</blockquote>
<hr>
<h2 id="✅-场景二：范围查询：查年龄在-18-30-岁之间的用户"><a href="#✅-场景二：范围查询：查年龄在-18-30-岁之间的用户" class="headerlink" title="✅ 场景二：范围查询：查年龄在 18~30 岁之间的用户"></a>✅ 场景二：<strong>范围查询：查年龄在 18~30 岁之间的用户</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.between(User::getAge, 18, 30);

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<blockquote>
<p>说明：<code>between</code> 等价于 <code>age &gt;= 18 AND age &lt;= 30</code></p>
</blockquote>
<hr>
<h2 id="✅-场景三：模糊查询：查邮箱包含“-gmail”的用户"><a href="#✅-场景三：模糊查询：查邮箱包含“-gmail”的用户" class="headerlink" title="✅ 场景三：模糊查询：查邮箱包含“@gmail”的用户"></a>✅ 场景三：<strong>模糊查询：查邮箱包含“@gmail”的用户</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.like(User::getEmail, &quot;@gmail&quot;);

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<blockquote>
<pre><code>like` 相当于 SQL 中的 `LIKE &#39;%xxx%&#39;
</code></pre>
</blockquote>
<hr>
<h2 id="✅-场景四：多条件查询：查-username-为-tom，且状态为启用"><a href="#✅-场景四：多条件查询：查-username-为-tom，且状态为启用" class="headerlink" title="✅ 场景四：多条件查询：查 username 为 tom，且状态为启用"></a>✅ 场景四：<strong>多条件查询：查 username 为 tom，且状态为启用</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.eq(User::getUsername, &quot;tom&quot;)
       .eq(User::getStatus, 1); // 1 代表启用

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<hr>
<h2 id="✅-场景五：动态查询：某些参数可为空，不传就不作为查询条件"><a href="#✅-场景五：动态查询：某些参数可为空，不传就不作为查询条件" class="headerlink" title="✅ 场景五：动态查询：某些参数可为空，不传就不作为查询条件"></a>✅ 场景五：<strong>动态查询：某些参数可为空，不传就不作为查询条件</strong></h2><pre><code class="java">String username = &quot;tom&quot;;
Integer age = null;

LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.eq(StringUtils.isNotBlank(username), User::getUsername, username)
       .eq(age != null, User::getAge, age);

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<blockquote>
<p>⭐ 动态条件拼接是 MyBatis-Plus 的一大特色：<strong>条件为 true 才拼入 SQL</strong></p>
</blockquote>
<hr>
<h2 id="✅-场景六：排序查询：按注册时间倒序"><a href="#✅-场景六：排序查询：按注册时间倒序" class="headerlink" title="✅ 场景六：排序查询：按注册时间倒序"></a>✅ 场景六：<strong>排序查询：按注册时间倒序</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.orderByDesc(User::getCreateTime);

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<hr>
<h2 id="✅-场景七：分页查询-条件筛选"><a href="#✅-场景七：分页查询-条件筛选" class="headerlink" title="✅ 场景七：分页查询 + 条件筛选"></a>✅ 场景七：<strong>分页查询 + 条件筛选</strong></h2><pre><code class="java">Page&lt;User&gt; page = new Page&lt;&gt;(1, 10); // 第1页，每页10条

LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.like(User::getUsername, &quot;张&quot;)
       .ge(User::getAge, 18);

IPage&lt;User&gt; userPage = userMapper.selectPage(page, wrapper);
</code></pre>
<blockquote>
<p><code>selectPage</code> 返回分页对象 <code>IPage</code>，包含总条数、总页数、当前页数据。</p>
</blockquote>
<hr>
<h2 id="✅-场景八：统计某状态下的用户数量"><a href="#✅-场景八：统计某状态下的用户数量" class="headerlink" title="✅ 场景八：统计某状态下的用户数量"></a>✅ 场景八：<strong>统计某状态下的用户数量</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.eq(User::getStatus, 1);

Long count = userMapper.selectCount(wrapper);
</code></pre>
<hr>
<h2 id="✅-场景九：只查指定列：查所有用户名和邮箱"><a href="#✅-场景九：只查指定列：查所有用户名和邮箱" class="headerlink" title="✅ 场景九：只查指定列：查所有用户名和邮箱"></a>✅ 场景九：<strong>只查指定列：查所有用户名和邮箱</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.select(User::getUsername, User::getEmail);

List&lt;User&gt; users = userMapper.selectList(wrapper);
</code></pre>
<hr>
<h2 id="✅-场景十：删除某个年龄段的用户（慎用！）"><a href="#✅-场景十：删除某个年龄段的用户（慎用！）" class="headerlink" title="✅ 场景十：删除某个年龄段的用户（慎用！）"></a>✅ 场景十：<strong>删除某个年龄段的用户（慎用！）</strong></h2><pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();
wrapper.lt(User::getAge, 10); // 年龄小于10岁

userMapper.delete(wrapper);
</code></pre>
<h2 id="🧠-总结你可以记住几个关键词："><a href="#🧠-总结你可以记住几个关键词：" class="headerlink" title="🧠 总结你可以记住几个关键词："></a>🧠 总结你可以记住几个关键词：</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>eq</code> &#x2F; <code>ne</code></td>
<td>等于 &#x2F; 不等于</td>
</tr>
<tr>
<td><code>like</code> &#x2F; <code>notLike</code></td>
<td>模糊匹配</td>
</tr>
<tr>
<td><code>gt</code> &#x2F; <code>ge</code></td>
<td>大于 &#x2F; 大于等于</td>
</tr>
<tr>
<td><code>lt</code> &#x2F; <code>le</code></td>
<td>小于 &#x2F; 小于等于</td>
</tr>
<tr>
<td><code>between</code></td>
<td>范围查询</td>
</tr>
<tr>
<td><code>in</code> &#x2F; <code>notIn</code></td>
<td>集合查询</td>
</tr>
<tr>
<td><code>isNull</code> &#x2F; <code>isNotNull</code></td>
<td>判空</td>
</tr>
<tr>
<td><code>orderByAsc</code> &#x2F; <code>orderByDesc</code></td>
<td>排序</td>
</tr>
<tr>
<td><code>select</code></td>
<td>指定返回字段</td>
</tr>
<tr>
<td><code>last</code></td>
<td>拼接SQL片段，比如分页的 <code>limit</code></td>
</tr>
</tbody></table>
<h2 id="挑战高级复杂场景"><a href="#挑战高级复杂场景" class="headerlink" title="挑战高级复杂场景"></a><span style = "color:blue">挑战高级复杂场景</span></h2><h2 id="🧩-场景设定：后台用户综合筛选"><a href="#🧩-场景设定：后台用户综合筛选" class="headerlink" title="🧩 场景设定：后台用户综合筛选"></a>🧩 场景设定：后台用户综合筛选</h2><p>你是某后台系统开发人员，领导提出了一个用户综合查询需求：</p>
<blockquote>
<p>“我要你查出所有<strong>状态正常</strong>的用户（status&#x3D;1），要求他们的：</p>
<ul>
<li>昵称中包含”超”</li>
<li>年龄在 20 到 30 岁之间</li>
<li>注册时间要大于某个时间点（比如 2023-01-01）</li>
<li>邮箱不能为 null</li>
<li>并且用户类型不能是 admin</li>
<li>用户ID必须在某一批导入的 id 集合中</li>
<li>最后按照注册时间降序、年龄升序排序</li>
<li>返回分页数据，每页10条，只查 <code>id</code>, <code>nickname</code>, <code>email</code>, <code>createTime</code> 字段。”</li>
</ul>
</blockquote>
<pre><code class="java">LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();

wrapper
    .eq(User::getStatus, 1)                         // 状态正常
    .like(User::getNickname, &quot;超&quot;)                  // 昵称模糊匹配
    .between(User::getAge, 20, 30)                  // 年龄在20~30之间
    .gt(User::getCreateTime, LocalDate.of(2023, 1, 1)) // 注册时间大于2023-01-01
    .isNotNull(User::getEmail)                     // 邮箱不为null
    .ne(User::getUserType, &quot;admin&quot;)                // 类型不能是admin
    .in(User::getId, idList)                       // id必须在给定集合中
    .orderByDesc(User::getCreateTime)              // 注册时间降序
    .orderByAsc(User::getAge)                      // 年龄升序
    .select(User::getId, User::getNickname, User::getEmail, User::getCreateTime); // 只查这几个字段
</code></pre>
<h3 id="✅-配合分页使用："><a href="#✅-配合分页使用：" class="headerlink" title="✅ 配合分页使用："></a>✅ 配合分页使用：</h3><pre><code class="java">Page&lt;User&gt; page = new Page&lt;&gt;(1, 10); // 第1页，每页10条
IPage&lt;User&gt; result = userMapper.selectPage(page, wrapper);
</code></pre>
<h2 id="🧩-变种考点：动态条件拼接"><a href="#🧩-变种考点：动态条件拼接" class="headerlink" title="🧩 变种考点：动态条件拼接"></a>🧩 变种考点：动态条件拼接</h2><p>比如昵称可能为空，idList可能为空，我们加上动态判断：</p>
<pre><code class="java">wrapper
    .eq(User::getStatus, 1)
    .like(StringUtils.isNotBlank(nickname), User::getNickname, nickname)
    .between(minAge != null &amp;&amp; maxAge != null, User::getAge, minAge, maxAge)
    .in(CollectionUtil.isNotEmpty(idList), User::getId, idList);
</code></pre>
<p><strong>LambdaQueryWrapper 是最适合在真实业务中构建动态、复杂、类型安全 SQL 的利器</strong>，配合 Stream、分页、动态参数、条件拼接，几乎能满足所有后台 CRUD 需求。</p>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br><strong><u>工厂模式</u><strong>：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，</strong>所有依赖于它的对象</strong>都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    </p>
<p>1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过<strong>递归调用</strong>来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<blockquote>
<h3 id="🧠-一句话理解每个模式（先记关键词）"><a href="#🧠-一句话理解每个模式（先记关键词）" class="headerlink" title="🧠 一句话理解每个模式（先记关键词）"></a>🧠 一句话理解每个模式（先记关键词）</h3><table>
<thead>
<tr>
<th>模式名</th>
<th>核心关键词</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单例模式</strong></td>
<td>只创建一次，全局唯一</td>
<td>Spring 中的 Bean、配置类</td>
</tr>
<tr>
<td><strong>工厂模式</strong></td>
<td>创建对象不关心具体类</td>
<td>日志、支付、解析器、登录类型等</td>
</tr>
<tr>
<td><strong>策略模式</strong></td>
<td>多种行为自由切换，面向接口</td>
<td>登录方式、支付方式、算法切换</td>
</tr>
<tr>
<td><strong>模板方法模式</strong></td>
<td>公共流程固定，步骤个别实现</td>
<td>钩子函数、抽象类调用子类流程</td>
</tr>
<tr>
<td><strong>责任链模式</strong></td>
<td>多个处理器按顺序处理请求</td>
<td>参数校验链、日志链、权限校验链</td>
</tr>
<tr>
<td><strong>观察者模式</strong></td>
<td>一变多变，通知机制</td>
<td>事件总线、消息订阅、MQ监听</td>
</tr>
<tr>
<td><strong>代理模式</strong></td>
<td>中间人控制访问&#x2F;增强</td>
<td>RPC远程调用、权限控制、缓存等</td>
</tr>
</tbody></table>
<h3 id="📦-实战分类-项目应用"><a href="#📦-实战分类-项目应用" class="headerlink" title="📦 实战分类 + 项目应用"></a>📦 实战分类 + 项目应用</h3><h4 id="1️⃣-行为型模式"><a href="#1️⃣-行为型模式" class="headerlink" title="1️⃣ 行为型模式"></a>1️⃣ <strong>行为型模式</strong></h4><h5 id="✅-策略模式（Strategy）【最常考🔥】"><a href="#✅-策略模式（Strategy）【最常考🔥】" class="headerlink" title="✅ 策略模式（Strategy）【最常考🔥】"></a>✅ 策略模式（Strategy）【最常考🔥】</h5><ul>
<li><strong>特点</strong>：行为可切换</li>
<li><strong>场景</strong>：多个登录方式（手机号 &#x2F; 密码 &#x2F; 第三方登录）</li>
<li><strong>怎么用</strong>：<ul>
<li>定义统一接口 <code>LoginStrategy</code></li>
<li>编写不同策略类 <code>PhoneLoginStrategy</code>、<code>PwdLoginStrategy</code></li>
<li>用工厂或Map封装，接收一个登录类型参数调用 <code>.doLogin()</code></li>
</ul>
</li>
</ul>
<h5 id="✅-责任链模式（Chain-of-Responsibility）"><a href="#✅-责任链模式（Chain-of-Responsibility）" class="headerlink" title="✅ 责任链模式（Chain of Responsibility）"></a>✅ 责任链模式（Chain of Responsibility）</h5><ul>
<li><strong>特点</strong>：多个处理器一个接一个处理</li>
<li><strong>场景</strong>：表单参数校验、下单流程、审批流程</li>
<li><strong>递归 or 迭代实现</strong>：<ul>
<li>迭代：List + for循环</li>
<li>递归：一个 Handler 内部 <code>next.handle(request)</code></li>
</ul>
</li>
</ul>
<h5 id="✅-模板方法模式（Template-Method）"><a href="#✅-模板方法模式（Template-Method）" class="headerlink" title="✅ 模板方法模式（Template Method）"></a>✅ 模板方法模式（Template Method）</h5><ul>
<li><strong>特点</strong>：父类定义算法框架，子类实现步骤</li>
<li><strong>场景</strong>：支付流程、通知发送（短信&#x2F;微信）</li>
<li><strong>怎么用</strong>：<ul>
<li>抽象类定义 <code>checkParams</code>、<code>buildRequest</code>、<code>send</code></li>
<li>子类实现这些步骤</li>
</ul>
</li>
</ul>
<h5 id="✅-观察者模式（Observer）"><a href="#✅-观察者模式（Observer）" class="headerlink" title="✅ 观察者模式（Observer）"></a>✅ 观察者模式（Observer）</h5><ul>
<li><strong>特点</strong>：一个变化通知多个订阅者</li>
<li><strong>场景</strong>：MQ消费后触发多个事件、发布文章后通知关注者</li>
<li><strong>怎么用</strong>：<ul>
<li>Spring 的 <code>@EventListener</code></li>
<li>Guava EventBus &#x2F; Disruptor</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2️⃣-创建型模式"><a href="#2️⃣-创建型模式" class="headerlink" title="2️⃣ 创建型模式"></a>2️⃣ <strong>创建型模式</strong></h4><h5 id="✅-工厂模式（Factory）"><a href="#✅-工厂模式（Factory）" class="headerlink" title="✅ 工厂模式（Factory）"></a>✅ 工厂模式（Factory）</h5><ul>
<li><strong>特点</strong>：创建对象解耦</li>
<li><strong>场景</strong>：创建不同类型的策略类、构建不同报文体</li>
<li><strong>怎么用</strong>：<ul>
<li>定义工厂类，根据参数 new 不同类或从 map 中 get</li>
</ul>
</li>
</ul>
<h5 id="✅-单例模式（Singleton）"><a href="#✅-单例模式（Singleton）" class="headerlink" title="✅ 单例模式（Singleton）"></a>✅ 单例模式（Singleton）</h5><ul>
<li><strong>特点</strong>：只创建一个对象，节省资源</li>
<li><strong>场景</strong>：配置类、工具类、缓存类、Spring 默认就是单例</li>
</ul>
<hr>
<h4 id="3️⃣-结构型模式"><a href="#3️⃣-结构型模式" class="headerlink" title="3️⃣ 结构型模式"></a>3️⃣ <strong>结构型模式</strong></h4><h5 id="✅-代理模式（Proxy）"><a href="#✅-代理模式（Proxy）" class="headerlink" title="✅ 代理模式（Proxy）"></a>✅ 代理模式（Proxy）</h5><ul>
<li><strong>特点</strong>：给目标对象加一层控制</li>
<li><strong>场景</strong>：权限控制、RPC远程调用、限流、缓存</li>
<li><strong>怎么用</strong>：<ul>
<li>JDK动态代理、CGLIB</li>
<li>Spring AOP就是代理模式（加日志、权限等）</li>
</ul>
</li>
</ul>
<h5 id="行为有策略，流程靠责任；骨架定模板，通知用观察；对象建工厂，中间靠代理，唯一单实例。"><a href="#行为有策略，流程靠责任；骨架定模板，通知用观察；对象建工厂，中间靠代理，唯一单实例。" class="headerlink" title="行为有策略，流程靠责任；骨架定模板，通知用观察；对象建工厂，中间靠代理，唯一单实例。"></a><span style = "color:blue">行为有策略，流程靠责任；骨架定模板，通知用观察；对象建工厂，中间靠代理，唯一单实例。</span></h5></blockquote>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。容易浪费资源</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁"><a href="#4-双重校验锁" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code>public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code>public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><ul>
<li><p><u>第一个</u>是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br><code>**不可解决脏读**：读未提交允许一个事务读取另一个事务尚未提交的数据变更。如果一个事务读取了另一个事务的未提交数据，然后那个事务回滚，则第一个事务读取的数据就是无效的（脏数据）</code></p>
</li>
<li><p><u>第二个</u>是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br><code>**解决脏独**：读已提交确保一个事务只能读取已经提交的数据变更。如果一个事务正在修改某些数据，那么在它提交之前，其他事务不能读取这些数据。这样就可以避免脏读。</code><br><code>**不可解决不可重复读**：一个事务在读取某些数据后，另一个事务修改了这些数据并提交，导致第一个事务再次读取时得到不同的结果</code><br><code>**不可解决幻读**：一个事务在读取某个范围的数据后，另一个事务插入了一些新数据并提交，导致第一个事务在执行范围查询时看到了新插入的数据</code></p>
</li>
<li><p><u>第三个</u>是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。</p>
</li>
<li><p><u>第四个</u>是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁<br><code>串行化是最严格的事务隔离级别。它通过强制事务串行执行来避免上述所有问题。在一个事务执行时，它会锁定涉及的所有数据行或表，直到事务完成。这确保了事务完全隔离，但是会显著降低系统的并发性能</code></p>
</li>
</ul>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p><code>INSERT</code>不带查询筛选条件  <strong>上行锁</strong><del>底层是索引，b+树底层叶子</del></p>
<blockquote>
<ul>
<li><strong>行锁</strong>：通常情况下，插入操作会锁定插入行所在的索引项，以防止其他事务同时修改同一行。这是因为数据库通常使用B+树来维护索引，<strong>插入操作需要在B+树中找到正确的位置来插入新的索引项</strong>。如果插入操作涉及到唯一索引，数据库还会检查是否有重复的键值，这也会触发行锁。</li>
<li><strong>注意</strong>：即使插入操作没有查询筛选条件，它仍然可能涉及到行锁，因为数据库需要保证新插入的数据不会与现有数据冲突。</li>
</ul>
</blockquote>
<p><code>UPDATE</code>看where后面的条件 <strong>带索引</strong>加行锁<del>构建b+树</del> <strong>不带索引</strong>的加表锁<br>表锁的速度比行锁速度快</p>
<blockquote>
<h6 id="带索引的条件："><a href="#带索引的条件：" class="headerlink" title="带索引的条件："></a>带索引的条件：</h6><ul>
<li><strong>行锁</strong>：如果更新操作的条件是索引列，数据库能够快速定位到需要更新的行，因此只会锁定那些特定的行。行锁可以最大程度地减少锁定的数据量，从而提高并发性能。</li>
<li><strong>原理</strong>：数据库使用B+树索引来快速查找满足条件的行，然后对这些行加锁。</li>
</ul>
<h6 id="不带索引的条件："><a href="#不带索引的条件：" class="headerlink" title="不带索引的条件："></a>不带索引的条件：</h6><ul>
<li><strong>表锁</strong>：如果更新操作的条件不是索引列，数据库可能需要扫描整个表来找到需要更新的行。在这种情况下，为了简化锁定逻辑并防止在扫描过程中数据被修改，数据库可能会选择锁定整个表。</li>
<li><strong>原理</strong>：由于没有索引可以利用，数据库必须检查每一行来确定是否满足更新条件，因此使用表锁可以避免复杂的锁定管理。</li>
</ul>
</blockquote>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<blockquote>
<h3 id="🧩-二、锁的判断依据"><a href="#🧩-二、锁的判断依据" class="headerlink" title="🧩 二、锁的判断依据"></a>🧩 二、锁的判断依据</h3><table>
<thead>
<tr>
<th>操作类型</th>
<th>是否使用索引？</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT</code></td>
<td>和是否冲突有关</td>
<td>行锁或表锁</td>
<td>INSERT默认加<strong>意向排他锁 + 行锁</strong>，唯一索引冲突时加锁更复杂</td>
</tr>
<tr>
<td><strong><code>UPDATE</code></strong></td>
<td><strong><code>WHERE</code>使用了索引</strong></td>
<td><strong>行锁（推荐）</strong></td>
<td>命中索引范围 → 行锁；可并发更新不同数据行</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td><code>WHERE</code>没用索引</td>
<td>表锁（不推荐）</td>
<td>扫描全表找目标 → 表锁；阻塞性大</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>和 UPDATE 类似</td>
<td>同上</td>
<td>删除符合条件的行，和更新逻辑一样</td>
</tr>
<tr>
<td><code>SELECT</code></td>
<td>普通查询</td>
<td>无锁（MVCC）</td>
<td>读不加锁，靠快照版本</td>
</tr>
<tr>
<td><code>SELECT ... for update</code></td>
<td>使用索引？</td>
<td>行锁或表锁</td>
<td>强制加锁，依赖索引判断行锁&#x2F;表锁</td>
</tr>
</tbody></table>
<h3 id="ABA-问题（乐观锁延申）"><a href="#ABA-问题（乐观锁延申）" class="headerlink" title="ABA 问题（乐观锁延申）"></a>ABA 问题（乐观锁延申）</h3><p>你前面说得对，在<strong>并发高场景</strong>中，即使数据值一样也不能认为没变，这就是<strong>ABA问题</strong>：</p>
<ul>
<li>A线程读了版本为1的数据，准备更新</li>
<li>B线程将数据从A改为B，又改回A，版本号变了</li>
<li>A线程再更新时发现版本不一致，避免了误操作！</li>
</ul>
<p>解决方式就是：</p>
<ul>
<li>使用 <code>version</code> 字段 + 乐观锁更新 <code>WHERE version = ?</code></li>
<li>如果更新失败，重试或提示失败（可加重试次数）</li>
</ul>
<p>在MySQL中是否加行锁还是表锁，取决于是否命中了索引。</p>
<ul>
<li>对于 <code>UPDATE</code> &#x2F; <code>DELETE</code> 等 DML 语句，如果 <code>WHERE</code> 条件命中索引，InnoDB 会加<strong>行锁</strong>；</li>
<li>如果未命中索引，则会加<strong>表锁</strong>，以保证操作的原子性和一致性。<br> 插入 <code>INSERT</code> 一般是对 B+ 树页加意向锁和插入位置加锁，如果涉及唯一索引校验也会加锁。<br> 对于并发控制，MySQL采用MVCC机制来实现非阻塞读写，在读时不加锁而是使用快照版本。<br> 如果业务涉及乐观锁防止并发更新错误，还可以通过版本号控制来避免ABA问题。</li>
</ul>
</blockquote>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的<strong>基本数据类型</strong>和<strong>引用类型地址</strong>，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：创建一个新的对象，并复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>维度</th>
<th>浅拷贝</th>
<th>深拷贝</th>
</tr>
</thead>
<tbody><tr>
<td>基本数据类型</td>
<td>复制值</td>
<td>复制值</td>
</tr>
<tr>
<td>引用类型</td>
<td>复制<strong>引用地址</strong>，指向同一对象</td>
<td>复制<strong>引用所指向的对象</strong>，<strong>开辟新内存空间</strong></td>
</tr>
<tr>
<td>是否影响原对象</td>
<td>会影响（共享引用）</td>
<td>不会影响（各自独立）</td>
</tr>
<tr>
<td>性能</td>
<td>快，开销小</td>
<td>慢，递归复制所有对象</td>
</tr>
<tr>
<td>使用场景</td>
<td>数据不变或只读场景</td>
<td>数据完全隔离、需要独立副本场景</td>
</tr>
</tbody></table>
<p>在Java中，浅拷贝仅复制对象的基本类型值和引用类型地址，因此多个对象可能共享同一引用，一方修改会影响另一方；而深拷贝则会递归复制所有引用对象，完全隔离副本。</p>
<p>通常浅拷贝使用 <code>super.clone()</code> 即可，而深拷贝需要实现 <code>Cloneable</code> 接口 + 手动对每一个引用类型递归克隆，或使用序列化方案更为简洁。深拷贝体现了原型设计模式的思想，适合于需要保留对象快照、撤销功能、缓存隔离等场景。</p>
</blockquote>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于<strong>启动一个新线程</strong>，并执行<strong>该线程</strong>的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并<strong>不会启动</strong>一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<blockquote>
<h6 id="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"><a href="#我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统" class="headerlink" title="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"></a>我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统</h6><h5 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h5><p>该系统需要处理大量的订单，包括订单验证、库存检查、支付处理和订单状态更新。为了提高处理效率，我们决定使用多线程来并行处理订单。</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.Random;

public class OrderProcessingSystem &#123;

    public static void main(String[] args) &#123;
        // 创建一个固定大小的线程池
        int numberOfProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numberOfProcessors);

        // 模拟订单队列
        Random random = new Random();
        for (int orderId = 1; orderId &lt;= 100; orderId++) &#123;
            int finalOrderId = orderId;
            executor.submit(() -&gt; &#123;
                processOrder(finalOrderId, random.nextInt(1000));
            &#125;);
        &#125;

        // 关闭线程池
        executor.shutdown();
        try &#123;
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executor.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        &#125;
    &#125;

    private static void processOrder(int orderId, int orderAmount) &#123;
        System.out.println(&quot;Processing order ID: &quot; + orderId + &quot; - Thread: &quot; + Thread.currentThread().getName());
        
        // 模拟订单验证
        validateOrder(orderId);
        
        // 模拟库存检查
        checkInventory(orderId);
        
        // 模拟支付处理
        processPayment(orderId, orderAmount);
        
        // 更新订单状态
        updateOrderStatus(orderId, &quot;Completed&quot;);
    &#125;

    private static void validateOrder(int orderId) &#123;
        // 模拟订单验证逻辑
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Order ID &quot; + orderId + &quot; validated.&quot;);
    &#125;

    private static void checkInventory(int orderId) &#123;
        // 模拟库存检查逻辑
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Inventory checked for Order ID &quot; + orderId + &quot;.&quot;);
    &#125;

    private static void processPayment(int orderId, int orderAmount) &#123;
        // 模拟支付处理逻辑
        try &#123;
            Thread.sleep(300);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Payment processed for Order ID &quot; + orderId + &quot; - Amount: &quot; + orderAmount);
    &#125;

    private static void updateOrderStatus(int orderId, String status) &#123;
        // 模拟订单状态更新逻辑
        System.out.println(&quot;Order ID &quot; + orderId + &quot; status updated to &quot; + status + &quot;.&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个示例中，我们创建了一个固定大小的线程池，其大小等于可用处理器的数量。然后，我们模拟了一个包含100个订单的队列，并为每个订单提交了一个任务到线程池中。每个任务代表订单处理的整个流程，包括验证、库存检查、支付处理和状态更新。<strong>每个步骤都通过休眠来模拟耗时操作</strong>。最后，我们关闭线程池并等待所有任务完成。</p>
</blockquote>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程<strong>暂停执行</strong>并<strong>释放当前对象上的锁</strong>，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是随机唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是<strong>基于内存</strong>的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持<strong>数据持久化</strong>，可以将内存中的数据<strong>保存到磁盘</strong>中，防止数据丢失。<br><strong>分布式</strong>：Redis支持<strong>主从复制</strong>、<strong>哨兵</strong>和<strong>集群模式</strong>，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><h6 id="可以存储一下类型的数据"><a href="#可以存储一下类型的数据" class="headerlink" title="可以存储一下类型的数据"></a>可以存储一下类型的数据</h6><blockquote>
<ol>
<li><strong>会话缓存（Session Store）</strong>：用户会话信息，如用户登录状态、用户偏好设置等。</li>
<li><strong>页面缓存</strong>：动态生成的网页内容，以减少数据库的读取次数。</li>
<li><strong>对象缓存</strong>：例如，用户信息、商品详情等，减少数据库访问。</li>
<li><strong>消息队列</strong>：用作消息队列，处理异步任务。</li>
<li><strong>排行榜或计数器</strong>：如用户点赞数、视频播放次数等。</li>
<li><strong>地理空间数据</strong>：用于实现基于地理位置的查询。</li>
<li><strong>分布式锁</strong>：在分布式系统中协调不同服务或节点的操作</li>
</ol>
</blockquote>
<h6 id="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："><a href="#关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：" class="headerlink" title="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："></a>关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：</h6><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<blockquote>
<h3 id="JWT（JSON-Web-Tokens）"><a href="#JWT（JSON-Web-Tokens）" class="headerlink" title="JWT（JSON Web Tokens）"></a>JWT（JSON Web Tokens）</h3><p>JWT是一种在各方之间传递安全可靠信息的简洁的、URL安全的表达方式。其特点包括：</p>
<ul>
<li><strong>无状态</strong>：服务器不存储任何会话信息，每个请求都携带包含所有必要信息的JWT。</li>
<li><strong>自包含</strong>：JWT中包含了用户的所有声明，减少了服务器的数据库查询。</li>
<li><strong>跨域认证</strong>：特别适用于单点登录（SSO）。</li>
</ul>
<h3 id="JWT的局限性"><a href="#JWT的局限性" class="headerlink" title="JWT的局限性"></a>JWT的局限性</h3><ul>
<li><strong>无法失效</strong>：一旦签发了JWT，在它过期之前，它在任何地方都是有效的，无法提前失效。</li>
<li><strong>续签问题</strong>：JWT过期后需要重新签发，处理起来相对复杂。</li>
<li><strong>携带信息量大</strong>：每个请求都携带JWT，如果JWT中包含的信息较多，会增加请求的大小。</li>
</ul>
<h3 id="使用Redis替代JWT"><a href="#使用Redis替代JWT" class="headerlink" title="使用Redis替代JWT"></a>使用Redis替代JWT</h3><p>使用Redis作为会话存储，可以解决JWT的一些问题：</p>
<ol>
<li><strong>中心化控制</strong>：通过Redis，服务器可以集中管理会话信息，可以随时使会话失效。</li>
<li><strong>灵活的过期策略</strong>：可以设置更细粒度的过期时间，并在需要时刷新会话。</li>
<li><strong>状态管理</strong>：对于需要频繁更改用户状态的应用，使用Redis可以更方便地管理。</li>
<li><strong>安全性</strong>：虽然Redis存储会话信息，但可以结合HTTPS和合适的加密策略来保证传输过程的安全</li>
</ol>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ol>
<li><strong>用户登录</strong>：用户登录成功后，生成一个唯一的会话标识（如UUID），并将其作为key存储在Redis中，value可以是用户ID或者其他必要信息，并设置适当的过期时间。</li>
<li><strong>请求验证</strong>：用户每次请求时，需要在请求头中携带会话标识，服务器端通过这个标识在Redis中查找会话信息，进行验证。</li>
<li><strong>会话过期或失效</strong>：当用户登出或会话过期时，从Redis中删除对应的会话信息。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>数据持久性</strong>：Redis的数据是存储在内存中的，需要考虑持久化策略以防止数据丢失。</li>
<li><strong>高可用性</strong>：在集群环境下，需要配置Redis的高可用方案，如哨兵（Sentinel）或集群模式。</li>
<li><strong>安全性</strong>：确保Redis的安全性，防止未授权访问。</li>
</ul>
</blockquote>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<pre><code class="java">   // 用户登录，创建会话
    public String loginUser(String userId) &#123;
        String sessionId = UUID.randomUUID().toString();
        String sessionData = createSessionData(userId);
        jedis.setex(sessionId, 1800, sessionData); // 设置会话过期时间为30分钟
        return sessionId;
    &#125;
</code></pre>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，<strong>服务消费者</strong>，<strong>注册中心</strong>，<strong>服务提供者</strong>在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，<strong>在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务</strong>，默认为轮询，还有加权轮询，随机。<strong>同时服务消费者还会定时去注册中心拉取服务提供者的信息</strong></p>
<h6 id="如果我们的服务挂掉了怎么办"><a href="#如果我们的服务挂掉了怎么办" class="headerlink" title="如果我们的服务挂掉了怎么办?"></a>如果我们的服务挂掉了怎么办?</h6><p>服务提供者会每隔一段时间去向注册中心报告自己的状态[发送心跳ping 30s&#x2F;次 共90s]，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
</ol>
<p><code>Feign是一个声明式的Web服务客户端（Web服务客户端就是Http客户端），让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可。</code></p>
<p><span style = "color:red"><code>OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过【动态代理】的方式产生实现类，实现类中做负载均衡并调用其他服务。</code></span></p>
<pre><code class="java">@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;
&#125;

@Component
@FeignClient(url = &quot;http://localhost/8001&quot;)
public interface PaymentFeignService&#123;
&#125;
</code></pre>
<blockquote>
<pre><code class="java">二、OpenFeign使用
2.1.OpenFeign 常规远程调用
所谓常规远程调用，指的是对接第三方接口，和第三方并不是微服务模块关系，所以肯定不可能通过注册中心来调用服务。

第一步：导入OpenFeign的依赖

第二步：启动类需要添加 【@EnableFeignClients】
    
第三步：提供者的接口
@RestController
@RequestMapping(&quot;/test&quot;)
public class FeignTestController &#123;

    @GetMapping(&quot;/selectPaymentList&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize) &#123;
        System.out.println(pageIndex);
        System.out.println(pageSize);
        Payment payment = new Payment();
        payment.setSerial(&quot;222222222&quot;);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + payment);
    &#125;

    @GetMapping(value = &quot;/selectPaymentListByQuery&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentListByQuery(Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @PostMapping(value = &quot;/create&quot;, consumes = &quot;application/json&quot;)
    public CommonResult&lt;Payment&gt; create(@RequestBody Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @GetMapping(&quot;/getPaymentById/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id) &#123;
        System.out.println(id);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;
    
第四步：消费者调用提供者接口
@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;

    @GetMapping(value = &quot;/payment/selectPaymentList&quot;)
    CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize);

    @GetMapping(value = &quot;/payment/selectPaymentListByQuery&quot;)
    CommonResult&lt;Payment&gt; selectPaymentListByQuery(@SpringQueryMap Payment payment);

    @PostMapping(value = &quot;/payment/create&quot;, consumes = &quot;application/json&quot;)
    CommonResult&lt;Payment&gt; create(@RequestBody Payment payment);

    @GetMapping(&quot;/payment/getPaymentById/&#123;id&#125;&quot;)
    CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id);
&#125;
</code></pre>
</blockquote>
<ol>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<blockquote>
<h6 id="思考一个问题：哪些方式创建单例模式？-1"><a href="#思考一个问题：哪些方式创建单例模式？-1" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全-1"><a href="#1-懒汉式，线程不安全-1" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全-1"><a href="#2-懒汉式，线程安全-1" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式-1"><a href="#3-饿汉式-1" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁-1"><a href="#4-双重校验锁-1" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code class="java">public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类-1"><a href="#5-静态内部类-1" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举-1"><a href="#6-枚举-1" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
</blockquote>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><p><strong>公平锁</strong>：多个线程按照它们请求<strong>锁的顺序</strong>来获取锁，<strong>先来先得</strong>。这种方式不会产生饥饿现象，但可能会<strong>降低吞吐量</strong>，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></p>
<blockquote>
<h6 id="为什么会降低吞吐量？"><a href="#为什么会降低吞吐量？" class="headerlink" title="为什么会降低吞吐量？"></a>为什么会降低吞吐量？</h6><ol>
<li><strong>维护等待队列</strong>：公平锁为了保证按照请求锁的顺序来获取锁，必须维护一个有序的等待队列。这意味着每次有线程请求锁或者释放锁时，都需要进行额外的操作来管理这个队列，这会增加开销。</li>
<li><strong>上下文切换开销</strong>：当锁被释放时，公平锁需要唤醒等待队列中的第一个线程。这个过程涉及到线程的上下文切换，上下文切换是有成本的，因为它涉及到保存和恢复线程的状态。</li>
<li><strong>减少并发机会</strong>：由于公平锁要求先来先得，即使锁被释放后请求锁的线程即使处于可运行状态，也必须等待前面的线程先执行。这可能会减少并发执行的机会，从而降低吞吐量。</li>
<li><strong>增加延迟</strong>：公平锁可能会增加线程获取锁的平均等待时间，因为每个线程都必须等待前一个线程完成。这种延迟可能会导致系统整体性能下降。</li>
</ol>
</blockquote>
</li>
<li><p><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></p>
</li>
</ul>
<h6 id="ReentrantLock-看传参-公平-x2F-非公平都支持"><a href="#ReentrantLock-看传参-公平-x2F-非公平都支持" class="headerlink" title="ReentrantLock 看传参 公平&#x2F;非公平都支持"></a>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持</h6><pre><code class="java">ReentrantLock 是Java提供的显式锁，它允许你通过构造函数参数来选择是使用公平锁还是非公平锁：

公平锁（Fair Lock）：通过传递true给ReentrantLock的构造函数来创建。这确保了锁的获取是按照线程请求锁的顺序进行的，防止饥饿现象。
ReentrantLock fairLock = new ReentrantLock(true);

非公平锁（Non-Fair Lock）：通过传递false或者不传递参数（默认值）给ReentrantLock的构造函数来创建。这种方式允许线程“插队”，可能会提高吞吐量，但也可能导致某些线程长时间无法获取锁。
ReentrantLock nonFairLock = new ReentrantLock(false); // 或者
ReentrantLock nonFairLock = new ReentrantLock(); // 默认是非公平锁
</code></pre>
<h6 id="Synchronized-公平锁"><a href="#Synchronized-公平锁" class="headerlink" title="Synchronized 公平锁"></a>Synchronized 公平锁</h6><pre><code class="java">从Java 6开始，synchronized的实现得到了改进，它试图实现一种偏向锁和轻量级锁的策略，以提高性能。
以下是关于synchronized的一些关键点：

偏向性：synchronized在锁竞争不激烈的情况下，会尝试偏向第一个获取锁的线程，这有助于减少不必要的同步开销。
轻量级锁：当没有竞争时，synchronized会使用轻量级锁，这比使用操作系统提供的重量级锁要快得多。
重量级锁：当存在竞争时，synchronized会升级为重量级锁，这涉及到操作系统的线程调度。

synchronized不会严格地保证公平性，因为它允许锁的“重入”和偏向性，这意味着它更倾向于非公平锁的行为。然而，在锁竞争激烈的情况下，synchronized会尽量保持一定的公平性，因为它会按照线程在监视器队列中的顺序来获取锁。

总的来说，synchronized不是严格意义上的公平锁，但它的实现细节和调度策略可能会在一定程度上表现出公平锁的特性。与ReentrantLock相比，synchronized的锁获取机制更为复杂，并且它是由JVM内部实现的，因此具体的调度细节对开发者来说是透明的。
</code></pre>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250206094925513.png" alt="image-20250206094925513"></p>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java **<u>动态代理技术</u>**，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p><code>volatile</code> 是Java语言中的一个关键字，用于修饰变量，以确保该变量的读写操作对所有线程立即可见，并且防止指令重排序优化。</p>
<p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证<strong>可见性</strong>和<strong>有序性</strong>。</p>
<blockquote>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>在一个多线程程序中，为了提高性能，每个线程可能会将共享变量缓存到自己的CPU缓存中。如果一个线程修改了这个变量的值，而这个新值没有及时写回主内存，那么其他线程可能会读取到旧值。使用<code>volatile</code>关键字可以确保：</p>
<ul>
<li>每次读写变量都是直接操作主内存。</li>
<li>当一个线程修改了一个<code>volatile</code>变量时，新值会立即被写入主内存。</li>
<li>其他线程读取<code>volatile</code>变量时，会从主内存中读取最新值。</li>
</ul>
<p>这样，<code>volatile</code>就保证了不同线程之间共享变量的可见性。</p>
<h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><p>在没有<code>volatile</code>修饰的变量上，Java编译器和处理器可能会进行指令重排序，以提高程序运行的效率。指令重排序可能会导致程序的执行顺序与代码的编写顺序不一致。使用<code>volatile</code>可以防止以下两种类型的重排序：</p>
<ul>
<li><strong>写操作的重排序</strong>：<code>volatile</code>变量的写操作不允许与它之前的操作重排序。</li>
<li><strong>读操作的重排序</strong>：<code>volatile</code>变量的读操作不允许与它之后的操作重排序。</li>
</ul>
<p>这样，<code>volatile</code>就提供了一定的有序性保证。</p>
</blockquote>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的</p>
<blockquote>
<p>在Java的并发编程中，<code>AbstractQueuedSynchronizer</code>（简称AQS）是一个非常重要的类，它提供了一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和其他同步器（例如信号量、事件等）。AQS 本身是一个抽象类，<strong>它内部定义了<u>获取资源（锁）</u>和<u>释放资源（锁）</u>的基本方法</strong>，以及<strong>管理同步状态</strong>和<strong>队列</strong>的机制。</p>
<p>当说“ReentrantLock是基于AQS实现的”，意味着<code>ReentrantLock</code>这个具体锁的实现类，是<strong>继承并利用了AQS提供的模板方法</strong>来构建其功能的。具体来说：</p>
<ul>
<li><strong>继承</strong>：<code>ReentrantLock</code>内部有一个内部类叫做<code>Sync</code>，这个<code>Sync</code>类直接继承自<code>AbstractQueuedSynchronizer</code>。</li>
<li><strong>实现</strong>：<code>Sync</code>类（及其子类）会根据需要重写AQS的一些方法，如<code>tryAcquire</code>和<code>tryRelease</code>，这些方法用于定义获取锁和释放锁的具体行为。</li>
<li><strong>利用模板方法</strong>：AQS提供了一系列的模板方法（如<code>acquire</code>、<code>release</code>等），这些方法内部会调用前面提到的可重写方法（如<code>tryAcquire</code>、<code>tryRelease</code>），从而允许<code>ReentrantLock</code>按照特定的逻辑来管理锁的状态。</li>
</ul>
<p>因此，<u>“基于AQS实现”的表述强调了<code>ReentrantLock</code>并不是从头开始构建锁的所有细节，而是站在AQS这个强大的基础框架之上</u>，通过实现特定的策略来完成锁的具体功能。这样做的好处是减少了代码量，提高了代码的可维护性和可重用性，并且由于AQS经过了严格的测试，基于它实现的锁也更加可靠。</p>
</blockquote>
<p>定义了一个并发情况下一些抽象的资源 资源能否<strong>共享&#x2F;独享</strong> 定义了<strong>公平&#x2F;非公平</strong><br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于<strong>重量级锁</strong>，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p><u>一段很长的时间内都只被一个线程使用锁</u> <strong>偏向锁</strong><br><u>有线程交替或线程加锁的时间是错开的</u> <strong>轻量级锁</strong><br><u>有很多线程来抢</u> <strong>重量级锁</strong></p>
<blockquote>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>偏向锁是一种优化锁的机制，它的设计初衷是：如果一个锁在大多数时间里只被一个线程访问，那么就没有必要进行线程间的同步操作，因为不存在锁竞争。在这种情况下，JVM会为这个锁赋予一个“偏向”，即偏向于第一个获取它的线程。在后续的锁操作中，如果该线程再次请求这个锁，就不需要进行同步操作，从而提高性能。偏向锁适用于只有一个线程访问同步块的场景。</p>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>轻量级锁是另一种锁的优化，它适用于锁竞争不是很激烈，且锁持有的时间短的场景。当线程交替访问同步块时，使用轻量级锁可以减少传统的重量级锁带来的性能开销。轻量级锁是通过在对象头中的一些标记位来实现的，当锁处于轻量级锁状态时，线程通过CAS操作来尝试获取锁，如果成功，则直接进入同步块执行，从而避免了使用操作系统级别的重量级锁机制。</p>
<h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>重量级锁是JVM中最传统的锁实现，也是性能开销最大的锁。当有很多线程同时竞争同一个锁时，JVM会使用重量级锁来确保线程安全。重量级锁依赖于操作系统的互斥量（mutex），会导致线程状态在用户态和核心态之间转换，这种转换是非常耗时的。因此，当锁竞争非常激烈时，使用重量级锁可以保证公平性和线程安全，但会带来较大的性能开销。</p>
<blockquote>
<p>在处理多线程同时竞争同一个锁的情况时，并不一定总是需要使用重量级锁。以下是一些优化和策略，可以帮助您更好地处理并发场景：</p>
<ol>
<li><strong>最小化同步范围</strong>：<ul>
<li>仅对必要的代码块进行同步，减少锁的竞争。</li>
<li>使用细粒度锁，比如对不同的数据结构使用不同的锁，而不是对整个对象加锁。</li>
</ul>
</li>
<li><strong>使用并发工具类</strong>：<ul>
<li>Java提供了许多并发工具类，如<code>java.util.concurrent</code>包中的<code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ConcurrentHashMap</code>等，它们提供了比synchronized更丰富的功能。</li>
</ul>
</li>
<li><strong>锁分离</strong>：<ul>
<li>对于读多写少的场景，可以使用读写锁（<code>ReadWriteLock</code>），它允许多个读线程同时访问，而写线程则互斥。</li>
</ul>
</li>
<li><strong>锁优化</strong>：<ul>
<li>在锁竞争不是很激烈的情况下，可以使用轻量级锁或偏向锁，这些锁的开销比重量级锁小。</li>
</ul>
</li>
<li><strong>无锁编程</strong>：<ul>
<li>使用原子类（如<code>AtomicInteger</code>、<code>AtomicReference</code>）和线程安全的数据结构，这些类通过CAS操作实现了无锁的线程安全。</li>
</ul>
</li>
<li><strong>线程池</strong>：<ul>
<li>使用线程池来管理线程，避免频繁创建和销毁线程带来的开销。</li>
</ul>
</li>
<li><strong>避免死锁</strong>：<ul>
<li>设计代码时注意锁的顺序，避免循环等待条件，减少死锁的发生。</li>
</ul>
</li>
<li><strong>性能测试</strong>：<ul>
<li>对并发代码进行性能测试，了解不同锁策略对性能的影响，并根据测试结果选择合适的锁。</li>
</ul>
</li>
</ol>
</blockquote>
</blockquote>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是<strong>用对象头找个地方存一把锁</strong>，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(<strong>自旋锁</strong>64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以<strong>自动</strong>加锁和解锁，而 <code>ReentrantLock</code> 需要<strong>手动</strong>加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方-作用域-，分别锁的是什么"><a href="#synchronized可以作用在哪些地方-作用域-，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方(作用域)，分别锁的是什么"></a>synchronized可以作用在哪些地方(作用域)，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<blockquote>
<h2 id="面试答题模板：项目中如何解决分布式事务问题"><a href="#面试答题模板：项目中如何解决分布式事务问题" class="headerlink" title="面试答题模板：项目中如何解决分布式事务问题"></a>面试答题模板：项目中如何解决分布式事务问题</h2><h3 id="1-在哪些地方遇到分布式事务？"><a href="#1-在哪些地方遇到分布式事务？" class="headerlink" title="1. 在哪些地方遇到分布式事务？"></a>1. <strong>在哪些地方遇到分布式事务？</strong></h3><blockquote>
<p>在项目中，当一个操作需要<strong>同时修改多个服务或数据库中的数据</strong>时，就涉及到分布式事务。</p>
<p>举个例子，比如：</p>
<ul>
<li>用户下单时，同时需要更新<strong>订单服务</strong>、<strong>库存服务</strong>、<strong>账户服务</strong></li>
<li>秒杀系统中，用户提交订单 → 扣减库存 → 支付 → 发货，这些服务彼此独立，不能直接使用本地事务</li>
<li>使用了微服务架构（Spring Cloud 或 Dubbo），服务之间通过 RPC 或 MQ 通信</li>
</ul>
</blockquote>
<hr>
<h3 id="2-为什么不能用本地事务？"><a href="#2-为什么不能用本地事务？" class="headerlink" title="2. 为什么不能用本地事务？"></a>2. <strong>为什么不能用本地事务？</strong></h3><blockquote>
<p>因为每个服务有独立的数据源和事务管理器，Spring 或数据库事务不能跨 JVM、不能跨库。使用 <code>@Transactional</code> 只对一个服务内部有效。</p>
</blockquote>
<hr>
<h3 id="3-怎么解决的？你项目中用的什么方式？"><a href="#3-怎么解决的？你项目中用的什么方式？" class="headerlink" title="3. 怎么解决的？你项目中用的什么方式？"></a>3. <strong>怎么解决的？你项目中用的什么方式？</strong></h3><blockquote>
<p>我们使用了 <strong>Seata</strong> 分布式事务框架，配合 <strong>MySQL + Nacos 注册中心 + Spring Cloud Alibaba</strong>。</p>
</blockquote>
<h4 id="✅-主要使用的是-AT-模式："><a href="#✅-主要使用的是-AT-模式：" class="headerlink" title="✅ 主要使用的是 AT 模式："></a>✅ 主要使用的是 <strong>AT 模式</strong>：</h4><ul>
<li><strong>一阶段（try）</strong>：执行业务逻辑（如插入订单、扣库存），Seata 会自动代理数据源，记录<strong>前镜像</strong>和<strong>后镜像</strong>，并生成全局锁，挂起全局事务。</li>
<li><strong>二阶段 commit</strong>：如果所有子事务都执行成功，Seata 释放资源，数据自动提交。</li>
<li><strong>二阶段 rollback</strong>：如果其中一个失败，Seata 会根据前镜像自动回滚其他操作。</li>
</ul>
</blockquote>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><blockquote>
<h3 id="使用-MQ-的主要场景"><a href="#使用-MQ-的主要场景" class="headerlink" title="使用 MQ 的主要场景"></a>使用 MQ 的主要场景</h3><p>我们项目中使用了 MQ 来实现一些<strong>异步解耦、流量削峰、延迟处理</strong>的需求，典型场景包括：</p>
<ul>
<li><strong>下单成功后异步发放优惠券和积分</strong></li>
<li><strong>订单支付成功后通知物流发货</strong></li>
<li><strong>延迟关闭未支付订单（延迟队列）</strong></li>
</ul>
<h3 id="具体业务流程（订单-积分-优惠券）"><a href="#具体业务流程（订单-积分-优惠券）" class="headerlink" title="具体业务流程（订单 + 积分 + 优惠券）"></a>具体业务流程（订单 + 积分 + 优惠券）</h3><h4 id="📦-用户下单-→-支付成功-→-MQ-异步通知："><a href="#📦-用户下单-→-支付成功-→-MQ-异步通知：" class="headerlink" title="📦 用户下单 → 支付成功 → MQ 异步通知："></a>📦 用户下单 → 支付成功 → MQ 异步通知：</h4><ol>
<li><p>用户提交订单，订单服务创建订单。</p>
</li>
<li><p>用户完成支付，<strong>订单服务更新订单状态为“已支付”</strong>。</p>
</li>
<li><p>然后将订单信息封装成消息，发送到多个 Topic：</p>
<pre><code class="json">&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;status&quot;: &quot;PAID&quot;
&#125;
</code></pre>
<ul>
<li>发给 <code>coupon_topic</code>：异步发放优惠券</li>
<li>发给 <code>point_topic</code>：异步发放积分</li>
<li>发给 <code>logistics_topic</code>：异步准备发货</li>
</ul>
</li>
</ol>
<h3 id="为什么使用-MQ？"><a href="#为什么使用-MQ？" class="headerlink" title="为什么使用 MQ？"></a>为什么使用 MQ？</h3><table>
<thead>
<tr>
<th>目的</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>解耦服务</strong></td>
<td>各个服务（积分&#x2F;优惠券&#x2F;物流）独立开发部署，订单服务只需发送消息，不关心接收者</td>
</tr>
<tr>
<td><strong>异步处理</strong></td>
<td>订单服务快速响应用户请求，提升用户体验</td>
</tr>
<tr>
<td><strong>流量削峰</strong></td>
<td>高并发秒杀场景中，通过 MQ 缓冲请求，避免库存服务被直接打爆</td>
</tr>
<tr>
<td><strong>延迟处理</strong></td>
<td>通过延迟消息机制实现“30分钟未支付自动关闭订单”等功能</td>
</tr>
</tbody></table>
<h3 id="示例：异步发放积分与优惠券"><a href="#示例：异步发放积分与优惠券" class="headerlink" title="示例：异步发放积分与优惠券"></a>示例：异步发放积分与优惠券</h3><h4 id="🛠-技术栈"><a href="#🛠-技术栈" class="headerlink" title="🛠 技术栈"></a>🛠 技术栈</h4><ul>
<li>消息中间件：RocketMQ &#x2F; RabbitMQ &#x2F; Kafka（我使用的是 RocketMQ）</li>
<li>消息格式：JSON</li>
<li>发送方式：异步发送 <code>sendAsync</code> 或可靠发送 <code>sendSync</code></li>
</ul>
<h4 id="👇-示例代码："><a href="#👇-示例代码：" class="headerlink" title="👇 示例代码："></a>👇 示例代码：</h4><p><strong>订单服务 - 发送消息</strong></p>
<pre><code class="java">OrderMessage message = new OrderMessage(orderId, userId, &quot;PAID&quot;);
rocketMQTemplate.syncSend(&quot;point_topic&quot;, message);
rocketMQTemplate.syncSend(&quot;coupon_topic&quot;, message);
</code></pre>
<p><strong>积分服务 - 监听消息</strong></p>
<pre><code class="java">@RocketMQMessageListener(topic = &quot;point_topic&quot;, consumerGroup = &quot;point_group&quot;)
public class PointConsumer implements RocketMQListener&lt;OrderMessage&gt; &#123;
    public void onMessage(OrderMessage msg) &#123;
        pointService.addPoint(msg.getUserId(), 100);
    &#125;
&#125;
</code></pre>
<h3 id="延迟队列：关闭未支付订单"><a href="#延迟队列：关闭未支付订单" class="headerlink" title="延迟队列：关闭未支付订单"></a>延迟队列：关闭未支付订单</h3><ul>
<li>下单成功但未支付时，发送一条延迟消息到 <code>order_timeout_topic</code>，延迟30分钟。</li>
<li>消费时判断订单状态是否已支付，未支付则关闭订单并恢复库存。</li>
</ul>
<pre><code class="java">Message message = MessageBuilder.withPayload(orderId)
    .setHeader(MessageConst.PROPERTY_DELAY_TIME_LEVEL, 16) // 延迟30分钟
    .build();
rocketMQTemplate.syncSend(&quot;order_timeout_topic&quot;, message);
</code></pre>
<hr>
<hr>
<h5 id="问：mq发送的消息-那怎么样才是对接到了真正的业务代码-比如我30分钟没付款-那就给我关闭未支付订单-我这里是mq不只是发送消息的吗-又怎么能触碰到真实的调用关闭未支付订单的那个业务逻辑代码呢？"><a href="#问：mq发送的消息-那怎么样才是对接到了真正的业务代码-比如我30分钟没付款-那就给我关闭未支付订单-我这里是mq不只是发送消息的吗-又怎么能触碰到真实的调用关闭未支付订单的那个业务逻辑代码呢？" class="headerlink" title="问：mq发送的消息 那怎么样才是对接到了真正的业务代码 比如我30分钟没付款 那就给我关闭未支付订单 我这里是mq不只是发送消息的吗 又怎么能触碰到真实的调用关闭未支付订单的那个业务逻辑代码呢？"></a><span style = "color:blue">问：mq发送的消息 那怎么样才是对接到了真正的业务代码 比如我30分钟没付款 那就给我关闭未支付订单 我这里是mq不只是发送消息的吗 又怎么能触碰到真实的调用关闭未支付订单的那个业务逻辑代码呢？</span></h5><h2 id="✅-所以完整流程如下："><a href="#✅-所以完整流程如下：" class="headerlink" title="✅ 所以完整流程如下："></a>✅ 所以完整流程如下：</h2><h3 id="场景：30分钟内未支付-→-自动关闭订单（延迟队列）"><a href="#场景：30分钟内未支付-→-自动关闭订单（延迟队列）" class="headerlink" title="场景：30分钟内未支付 → 自动关闭订单（延迟队列）"></a>场景：30分钟内未支付 → 自动关闭订单（延迟队列）</h3><hr>
<h3 id="✅-1-下单成功-→-发一条延迟消息-到-MQ"><a href="#✅-1-下单成功-→-发一条延迟消息-到-MQ" class="headerlink" title="✅ 1. 下单成功 → 发一条延迟消息 到 MQ"></a>✅ 1. 下单成功 → 发一条<strong>延迟消息</strong> 到 MQ</h3><p>这一步由<strong>订单服务</strong>完成，它只是<strong>把订单ID封装成消息，发到某个延迟Topic</strong>，比如 <code>order_timeout_topic</code>。</p>
<pre><code class="java">Message&lt;String&gt; message = MessageBuilder.withPayload(orderId)
    .setHeader(MessageConst.PROPERTY_DELAY_TIME_LEVEL, 16) // 延迟30分钟
    .build();

rocketMQTemplate.syncSend(&quot;order_timeout_topic&quot;, message);
</code></pre>
<h3 id="✅-2-等待30分钟，消息达到时间被投递-→-触发消费者"><a href="#✅-2-等待30分钟，消息达到时间被投递-→-触发消费者" class="headerlink" title="✅ 2. 等待30分钟，消息达到时间被投递 → 触发消费者"></a>✅ 2. 等待30分钟，消息达到时间被投递 → <strong>触发消费者</strong></h3><p>这一步由<strong>你自己写的消费者类</strong>完成。</p>
<pre><code class="java">@RocketMQMessageListener(
    topic = &quot;order_timeout_topic&quot;, 
    consumerGroup = &quot;order_timeout_group&quot;
)
@Component
public class OrderTimeoutConsumer implements RocketMQListener&lt;String&gt; &#123;

    @Autowired
    private OrderService orderService;

    @Override
    public void onMessage(String orderId) &#123;
        // ✅ 真正的业务逻辑调用就在这里
        orderService.closeUnpaidOrder(orderId);
    &#125;
&#125;
</code></pre>
<h3 id="✅-3-消费者接收到消息，调用你的真实业务代码："><a href="#✅-3-消费者接收到消息，调用你的真实业务代码：" class="headerlink" title="✅ 3. 消费者接收到消息，调用你的真实业务代码："></a>✅ 3. 消费者接收到消息，<strong>调用你的真实业务代码</strong>：</h3><pre><code class="java">public void closeUnpaidOrder(String orderId) &#123;
    Order order = orderMapper.selectById(orderId);
    
    // ✅ 校验状态：只有未支付才关闭
    if (&quot;UNPAID&quot;.equals(order.getStatus())) &#123;
        // 更新订单状态为“已关闭”
        order.setStatus(&quot;CLOSED&quot;);
        orderMapper.updateById(order);

        // 回滚库存（如果之前预扣了库存）
        stockService.rollbackStock(order.getItems());

        log.info(&quot;订单 &#123;&#125; 已超时未支付，自动关闭&quot;, orderId);
    &#125;
&#125;
</code></pre>
<h2 id="✅-总结一句话："><a href="#✅-总结一句话：" class="headerlink" title="✅ 总结一句话："></a>✅ 总结一句话：</h2><blockquote>
<p><strong>MQ 只是“消息的搬运工”</strong>，但你要写消费者类（<code>RocketMQListener</code> &#x2F; <code>@RabbitListener</code> &#x2F; <code>KafkaListener</code>），<strong>在 <code>onMessage()</code> 方法中调用你的业务代码</strong>，才算真正“对接了业务逻辑”。</p>
</blockquote>
<hr>
<h3 id="📌-这样你就能实现："><a href="#📌-这样你就能实现：" class="headerlink" title="📌 这样你就能实现："></a>📌 这样你就能实现：</h3><ul>
<li>下单时发送一条“30分钟后的提醒消息”</li>
<li>30分钟后，消息被自动投递</li>
<li>消费者接收消息</li>
<li>消费者去执行你写好的“关闭订单”逻辑</li>
</ul>
<h3 id="✅-你写的业务代码只是“收到通知之后”执行"><a href="#✅-你写的业务代码只是“收到通知之后”执行" class="headerlink" title="✅ 你写的业务代码只是“收到通知之后”执行"></a>✅ <strong>你写的业务代码只是“收到通知之后”执行</strong></h3><h3 id="❗是-MQ-延迟队列在背后帮你等待-30-分钟"><a href="#❗是-MQ-延迟队列在背后帮你等待-30-分钟" class="headerlink" title="❗是 MQ 延迟队列在背后帮你等待 30 分钟"></a>❗<strong>是 MQ 延迟队列在背后帮你等待 30 分钟</strong></h3><h2 id="🔁-两种“定时任务”的方式对比"><a href="#🔁-两种“定时任务”的方式对比" class="headerlink" title="🔁 两种“定时任务”的方式对比"></a>🔁 两种“定时任务”的方式对比</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>谁来等待30分钟？</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定时任务 Cron</strong></td>
<td>你写一个 <code>@Scheduled</code> 每隔1分钟轮询数据库</td>
<td>数据多了会导致 <strong>扫描性能差</strong>，且 <strong>不精确</strong></td>
<td>简单、直观</td>
</tr>
<tr>
<td><strong>MQ 延迟队列</strong></td>
<td><strong>MQ自动等待30分钟后投递消息</strong></td>
<td>要配合消息系统、消费者写法略复杂</td>
<td>精准、性能高、无感知、无需数据库轮询</td>
</tr>
</tbody></table>
<h2 id="🧩-真实执行流程再解释一遍"><a href="#🧩-真实执行流程再解释一遍" class="headerlink" title="🧩 真实执行流程再解释一遍"></a>🧩 真实执行流程再解释一遍</h2><h3 id="🔵-用户下单成功"><a href="#🔵-用户下单成功" class="headerlink" title="🔵 用户下单成功"></a>🔵 用户下单成功</h3><p>业务代码执行完后做两件事：</p>
<ol>
<li>把订单状态写入数据库：<code>UNPAID</code></li>
<li>向 MQ 发一条“延迟30分钟”的消息，内容是订单ID</li>
</ol>
<hr>
<h3 id="🟡-MQ-延迟队列（如-RocketMQ）"><a href="#🟡-MQ-延迟队列（如-RocketMQ）" class="headerlink" title="🟡 MQ 延迟队列（如 RocketMQ）"></a>🟡 MQ 延迟队列（如 RocketMQ）</h3><p>你设置了：</p>
<pre><code>.setHeader(MessageConst.PROPERTY_DELAY_TIME_LEVEL, 16); // 表示延迟30分钟
</code></pre>
<p>MQ 会帮你缓存这条消息，<strong>不会立即投递！</strong></p>
<hr>
<h3 id="🔴-等到-30-分钟后，MQ-才把这条消息交给你写的消费者类（比如-OrderTimeoutConsumer）"><a href="#🔴-等到-30-分钟后，MQ-才把这条消息交给你写的消费者类（比如-OrderTimeoutConsumer）" class="headerlink" title="🔴 等到 30 分钟后，MQ 才把这条消息交给你写的消费者类（比如 OrderTimeoutConsumer）"></a>🔴 等到 30 分钟后，MQ 才把这条消息交给你写的消费者类（比如 <code>OrderTimeoutConsumer</code>）</h3><p>你的消费者代码才会被执行：</p>
<pre><code class="java">public void onMessage(String orderId) &#123;
    orderService.closeUnpaidOrder(orderId);
&#125;
</code></pre>
<p>此时才会调用你写的业务逻辑代码，<strong>检查订单是否已支付，如果没支付，就自动关闭</strong></p>
<h2 id="✅-为什么不用-Scheduled-？"><a href="#✅-为什么不用-Scheduled-？" class="headerlink" title="✅ 为什么不用 @Scheduled ？"></a>✅ 为什么不用 <code>@Scheduled</code> ？</h2><p>你当然<strong>可以用定时任务</strong>，比如：</p>
<pre><code class="java">@Scheduled(cron = &quot;0 */1 * * * ?&quot;)
public void scanUnpaidOrders() &#123;
    // 每1分钟检查一次数据库里状态为 UNPAID 且超过30分钟的订单
&#125;
</code></pre>
<h3 id="❗但是问题是："><a href="#❗但是问题是：" class="headerlink" title="❗但是问题是："></a>❗但是问题是：</h3><ul>
<li>每次都要 <strong>扫整个表</strong> 或者一部分数据，性能差</li>
<li>不能做到<strong>秒级准确执行</strong>（可能要等1分钟才触发）</li>
<li>高并发系统（像电商、秒杀）<strong>根本扛不住频繁轮询</strong></li>
</ul>
<h2 id="✅-为什么用-MQ-延迟消息是最佳选择？"><a href="#✅-为什么用-MQ-延迟消息是最佳选择？" class="headerlink" title="✅ 为什么用 MQ 延迟消息是最佳选择？"></a>✅ 为什么用 MQ 延迟消息是最佳选择？</h2><ul>
<li><strong>MQ自己维护延时，精确到秒级</strong></li>
<li><strong>不依赖数据库定时轮询</strong></li>
<li><strong>一条消息就是一笔订单，到时间再投递，性能高</strong></li>
<li><strong>和核心业务逻辑完全解耦</strong></li>
</ul>
</blockquote>
<p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>
<h4 id="说一下jvm的内存区域，以及每个区域是干什么的"><a href="#说一下jvm的内存区域，以及每个区域是干什么的" class="headerlink" title="说一下jvm的内存区域，以及每个区域是干什么的"></a>说一下jvm的内存区域，以及每个区域是干什么的</h4><p>虚拟机栈、本地方法栈、程序计数器、元空间、堆</p>
<blockquote>
<h6 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h6><p><strong>虚拟机栈</strong>：每个线程运行时所需要的内存(<u><strong>先进后出</strong></u>)<del>方法调用过程</del>。每个栈由多个栈帧组成，对应着每次方法调用所占用的内存。每个线程只能有一个活动<strong>栈帧</strong>，对应着当前执行的那个方法</p>
<p><strong>本地方法栈</strong>：与虚拟机栈类似，区别→虚拟机栈执行java方法，本地方法栈执行native方法【被封装的方法  没有具体实现的 都封装在java虚拟机中】专门存储java写的局部方法的局部变量</p>
<p><strong>程序计数器</strong>：是当前线程所执行的字节码指令的行号指示器 同一个核是错峰出行 会上下文切换，要用程序计数器记录下当前执行到哪里的代码</p>
<p><strong>元空间</strong>：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。最大区别是<strong>元空间在本地内存</strong>中而不是虚拟机中。1.8以前叫永久代   1.8后叫方法区或元空间 一般存储类元信息。还会存有运行时常量池。在里面还会存有静态变量</p>
<p><strong>堆内存</strong>：是JVM所有线程共享的部分，唯一用途是来保存对象实例、数组；由年轻代和老年代组成。new一个都会开启一个空间</p>
</blockquote>
<p><strong>类加载器</strong>：类加载器（Class Loader）负责将类的字节码文件（.class文件）加载到JVM中，并转化为对应的<code>java.lang.Class</code>对象，以供Java程序使用。</p>
<p><strong>执行引擎</strong>：执行引擎（Execution Engine）是负责执行字节码的核心组件。执行引擎的作用是读取字节码指令，对它们进行解析并执行，从而实现Java程序的功能</p>
<p><strong>本地库接口</strong>：是Java虚拟机的一部分，它允许Java程序调用其他语言编写的本地应用程序和库（通常是C或C++）。这是因为Java本身设计为平台无关的语言，但它有时需要与特定平台的底层系统或硬件进行交互，而这通常是通过本地代码实现的。</p>
<p><strong>直接内存（Direct Memory）</strong>：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<h4 id="说一下常见的垃圾回收算法-他们的特点是什么？"><a href="#说一下常见的垃圾回收算法-他们的特点是什么？" class="headerlink" title="说一下常见的垃圾回收算法 他们的特点是什么？"></a>说一下常见的垃圾回收算法 他们的特点是什么？</h4><p><strong>标记清除算法</strong>：将垃圾回收分为2个阶段，标记和清除。内存碎片高，效率高，清除快<br><strong>标记整理算法</strong>：一般用于老年代，将存活的对象都向另一端移动，然后清理边界以外的垃圾。[对象要移动,效率低]，效率慢一些 需要把内存碎片移动，内存碎片没有 但是效率低一点<br><strong>复制算法</strong>：将原有的内存空间一分为二，每次只用其中一块，正在使用的对象复制到另一个内存中，然后将该内存空间清空，交换两个内存的角色，完成垃圾回收。</p>
<p><u>被标记的是没有被回收的</u></p>
<h4 id="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"><a href="#说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现" class="headerlink" title="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"></a>说一下常见的垃圾回收器以及他们的特点<del>垃圾收集器是垃圾收集算法的具体实现</del></h4><p><strong>串行</strong>垃圾收集器[新生代区]：指使用<strong>单线程</strong>进行垃圾回收(用户请求不能访问<del>STW</del>)，堆内存较小适合个人电脑。底层用的<strong>复制算法</strong><br><strong>并行</strong>垃圾收集器：JDK8默认使用此垃圾回收器，在垃圾回收时，<strong>多个线程</strong>在工作(用户请求不能访问<del>STW</del>)，并且java应用中所有线程都要暂停，等待垃圾回收的完成。底层用的<strong>复制算法</strong><br><strong>CMS</strong>(并发[Concurrent Mark Sweep])垃圾收集器：是一款并发的、使用标记—清除算法的垃圾回收器(针对老年代)   <u>初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置</u>  小于8G内存用CMS  一般用并发垃圾收集器配合收集年轻小内存<br><strong>G1</strong>垃圾收集器[复制算法]：Eden(2M)、最大回收停顿时间、大内存适合用G1、大于8G内存用G1</p>
<h4 id="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"><a href="#说一下cms的各个阶段过程以及特点CMS一般都清理老年代" class="headerlink" title="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"></a>说一下cms的各个阶段过程以及特点<del>CMS一般都清理老年代</del></h4><p>过程：初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置<br>是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<br>其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
<p><strong>初始标记</strong>：找GCRoot根去的第一层对象[STW] 速度是非常快的。为什么STW？如果找的时候同时也要标记 那么若这时候有的未被标记那就有大BUG。<br><strong>并发标记</strong>：从第一层找到后的之后那些对象不能被回收(CMS回收器会遍历老年代，标记出所有活动的对象)，在这个阶段，应用程序线程与垃圾回收线程并发运行[能接收用户请求]，会产生新的对象。<br><strong>并发预清理</strong>：这个阶段也是并发执行的，目的是处理在并发标记阶段应用程序线程产生的新垃圾，CMS回收器会清理那些在并发标记阶段被修改的对象，并执行一些预清理工作，以减少下一个STW阶段的暂停时间。<br><strong>最终标记</strong>：这个阶段是STW的，它是为了处理在并发标记和并发预清理阶段未被处理的对象。CMS回收器会完成所有剩余的标记工作，确保所有存活的对象都被正确标记<br><strong>并发清除</strong>：在这个阶段，应用程序线程与垃圾回收线程再次并发运行。CMS回收器会清除未被标记的对象，释放内存空间。清除过程中不会移动存活对象，因此可能会产生内存碎片。<br><strong>并发重置</strong>：这个阶段是并发执行的，目的是重置CMS数据结构，为下一次垃圾回收做准备。</p>
<h4 id="说一下g1的各个阶段过程以及特点，"><a href="#说一下g1的各个阶段过程以及特点，" class="headerlink" title="说一下g1的各个阶段过程以及特点，"></a>说一下g1的各个阶段过程以及特点，</h4><p>划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中<code>humongous</code>专为大对象准备<br>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集。如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></p>
<h4 id="你们项目是用哪一个垃圾收集器，为什么用这个"><a href="#你们项目是用哪一个垃圾收集器，为什么用这个" class="headerlink" title="你们项目是用哪一个垃圾收集器，为什么用这个?"></a>你们项目是用哪一个垃圾收集器，为什么用这个?</h4><p>每个服务两个节点 8G4核 用CMS 太大就用G1</p>
<h4 id="什么样的对象会被成为垃圾对象？"><a href="#什么样的对象会被成为垃圾对象？" class="headerlink" title="什么样的对象会被成为垃圾对象？"></a>什么样的对象会被成为垃圾对象？</h4><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong><br>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<ol>
<li><strong>标记阶段</strong>：从GCRoots开始，标记所有可达的对象。</li>
<li><strong>回收阶段</strong>：遍历堆中的所有对象，回收那些未被标记的对象所占用的空间。</li>
</ol>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
<p>通过可达性分析算法，那些从任何GCRoots都无法到达的对象被认为是不可达的，因此可以被垃圾回收器回收。这种方法能够处理循环引用的情况，这是引用计数法所无法解决的</p>
</li>
</ul>
<p>静态的成员变量[元空间 基本不会被回收] 局部变量 成员属性 </p>
<h4 id="说一下双亲委派机制以及优点"><a href="#说一下双亲委派机制以及优点" class="headerlink" title="说一下双亲委派机制以及优点"></a>说一下双亲委派机制以及优点</h4><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类<br>优点：</p>
<ul>
<li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p>用相同的加载器在同一个路径下只能用同一个路径的类 用不同的加载器就可以加载</p>
<h6 id="如何打破双亲委派模型？"><a href="#如何打破双亲委派模型？" class="headerlink" title="如何打破双亲委派模型？"></a>如何打破双亲委派模型？</h6><p><strong>自定义类加载器</strong>：</p>
<ul>
<li><p>通过<strong>自定义类加载器</strong>，并重写<code>loadClass</code>方法，可以实现在加载类时不遵循双亲委派模型。在自定义类加载器中，你可以直接尝试加载类，而不是先委派给父类加载器。</p>
<pre><code class="java">public class CustomClassLoader extends ClassLoader &#123;
    @Override
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;
        // 直接加载，不委派给父类加载器
        return findClass(name);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jvm常用的参数有哪些？代表什么意思"><a href="#jvm常用的参数有哪些？代表什么意思" class="headerlink" title="jvm常用的参数有哪些？代表什么意思"></a>jvm常用的参数有哪些？代表什么意思</h4><p>jps 进程状态信息<br>jstack 查看进程内线程的堆栈信息(产生死锁也可以查看)<br>jmap 查看堆栈信息(生成堆栈内存快照，内存使用信息)<br>jhat 堆转存快照分析工具<br>jstat JVM统计监测工具</p>
<ol>
<li><code>-Xms</code> 和 <code>-Xmx</code>：<ul>
<li><code>-Xms</code>：设置JVM堆内存的初始大小（最小值）。</li>
<li><code>-Xmx</code>：设置JVM堆内存的最大大小。</li>
</ul>
</li>
<li><code>-Xss</code>：<ul>
<li>设置每个线程的堆栈大小。</li>
</ul>
</li>
<li><code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code>：<ul>
<li><code>-XX:NewSize</code>：设置新生代内存的初始大小。</li>
<li><code>-XX:MaxNewSize</code>：设置新生代内存的最大大小。</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio</code>：<ul>
<li>设置新生代中Eden区与Survivor区的容量比例。</li>
</ul>
</li>
<li><code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>（Java 8及之前版本）：<ul>
<li><code>-XX:PermSize</code>：设置永久代（方法区）的初始大小。</li>
<li><code>-XX:MaxPermSize</code>：设置永久代的最大大小。</li>
</ul>
</li>
<li>设置元空间大小<ol>
<li><code>-XX:MetaspaceSize</code>：<ul>
<li>设置元空间的初始大小。当元空间耗尽时，JVM会尝试扩展元空间的大小，直到达到最大值（如果设置了的话）。</li>
</ul>
</li>
<li><code>-XX:MaxMetaspaceSize</code>：<ul>
<li>设置元空间的最大大小。如果没有设置这个参数，元空间的大小只受本地内存限制。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="四大引用分别是什么，代表什么意思？"><a href="#四大引用分别是什么，代表什么意思？" class="headerlink" title="四大引用分别是什么，代表什么意思？"></a>四大引用分别是什么，代表什么意思？</h4><p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收。<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，<strong>内存依然不够</strong>时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，<strong>只要进行了垃圾回收</strong>，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
<p>● 强引用指的就是代码中普遍存在的赋值方式，比如A 但是不a &#x3D; new A()这种。强引用关联的对象，永远不会被GC回收。<br>● 软引用可以用SoftReference来描述，指的是那些有用是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。<br>● 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，只要进行了垃圾回收，就会把引用对象回收。<br>● 虚引用他必须和ReferenceQueue一起使用，必须配合引用队列使用，被引用对象回收时，<br>会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存。</p>
<h4 id="什么是内存溢出？什么是内存泄露？"><a href="#什么是内存溢出？什么是内存泄露？" class="headerlink" title="什么是内存溢出？什么是内存泄露？"></a>什么是内存溢出？什么是内存泄露？</h4><p><strong>内存溢出</strong>：内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，导致所需要的内存超出了系统所能提供的最大内存。【会先进行一次GC实在不够就OOM 堆\栈(递归过多,局部变量过多)\方法区都有可能发生内存溢出】<br><strong>内存泄露</strong><del>ThreadLocal会导致(未及时释放)</del>：内存泄露是指程序中已分配的内存由于某种原因未能释放，即使在不再需要这些内存的情况下，它们仍然保持分配状态，导致可用内存逐渐减少</p>
<h4 id="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"><a href="#你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？" class="headerlink" title="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"></a>你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？</h4><p>有的，内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<p>异常的祖先是：<code>Throwable</code></p>
<h4 id="怎么解决cpu飙高"><a href="#怎么解决cpu飙高" class="headerlink" title="怎么解决cpu飙高"></a>怎么解决cpu飙高</h4><p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h4 id="项目中遇到的难点"><a href="#项目中遇到的难点" class="headerlink" title="项目中遇到的难点"></a>项目中遇到的难点</h4><p>1.从业务角度 曾经做过保险项目 金融保险领域 行外人需要花很多时间了解需求还有同事的帮助才懂得需求知道如何去写</p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>