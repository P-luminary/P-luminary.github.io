
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || SpringAI-Alibaba</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>SpringAI-Alibaba </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/7/8
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/AI" style=color:#ff7d73>
                    AI
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h3 id="Spring-AI-Ailibaba简介"><a href="#Spring-AI-Ailibaba简介" class="headerlink" title="Spring AI Ailibaba简介"></a>Spring AI Ailibaba简介</h3><p>SpringAlAlibaba是基于SpringAI构建的框架，专注于与阿里云生态的深度集成。适合国内开发者，尤其是需要快速接入阿里云AI能力的场景。</p>
<p>LangChain4j是 LangChain项目的Java移植版本，专注于构建多模态、多参与者的AI应用，适合需要构建复杂AI工作流和多模态应用的开发者</p>
<blockquote>
<p>文档：<a target="_blank" rel="noopener" href="https://www.processon.com/view/link/6810800f83d6ee240f5796b0">Spring AI Alibaba实战| ProcessOn免费在线作图,在线流程图,在线思维导图</a></p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://java2ai.com/?spm=5176.29160081.0.0.2856aa5cpGp7Py">Spring AI Alibaba 官网_快速构建 JAVA AI 应用</a></p>
<p>项目：<a target="_blank" rel="noopener" href="https://gitee.com/dongchenglin/ai-demo">ai-demo: 本项目围绕 Spring AI Alibaba 技术栈打造实战课程《Spring AI Alibaba 从入门到进阶实战》，由 Fox 精心开发。课程从基础入门到深度实战，覆盖 Spring AI Alibaba 核心原理、大模型（含本地与云端，如 Ollama、通义千问 ）集成、多模态功能（文生图、语音交互 ）、RAG 架构、Function Calling、MCP 协议等关键技术，更通过电商智</a></p>
</blockquote>
<p>[<u>Spring AI Alibaba 官网_快速构建 JAVA AI 应用</u>] (<a target="_blank" rel="noopener" href="http://java2ai.com/">http://java2ai.com/</a>)</p>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul>
<li>模型(Model)</li>
<li>提示（Prompt）</li>
<li>嵌入（Embedding）</li>
<li>Token</li>
<li>结构化输出(Structured Output)</li>
<li>微调（Fine Tuning）</li>
<li>检索增强生成（RAG）</li>
<li>函数调用（Function Calling)</li>
<li>评估人工智能的回答(Evaluation)</li>
</ul>
<h5 id="同步接口实现"><a href="#同步接口实现" class="headerlink" title="同步接口实现"></a>同步接口实现</h5><pre><code class="java">  @GetMapping(&quot;/chat&quot;)
    public String chat(@RequestParam String input) &#123;
        return chatClient.prompt().user(input).call().content();
    &#125;
</code></pre>
<h5 id="流式响应实现"><a href="#流式响应实现" class="headerlink" title="流式响应实现"></a>流式响应实现</h5><pre><code class="java">   @GetMapping(value = &quot;/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; stream(String input) &#123;
        return this.chatClient.prompt()
                .user(input)
                .stream()
                .content();
    &#125;
</code></pre>
<h4 id="ChatClient"><a href="#ChatClient" class="headerlink" title="ChatClient"></a>ChatClient</h4><p><strong>作用</strong>：通过 ChatClient，开发者可以更专注于业务逻辑而非底层协调，显著提升基于 LLM 的应用开发效率。<br><strong>适用场景</strong>：快速开发：适合需要快速构建端到端 AI 交互的应用（如聊天机器人、问答系统）。复杂流程封装：当需要协调多个组件（如 LLM + 记忆 + 工具）时，减少样板代码。</p>
<h5 id="返回实体类-entity"><a href="#返回实体类-entity" class="headerlink" title="返回实体类  .entity"></a>返回实体类  <code>.entity</code></h5><pre><code class="java">    @GetMapping(&quot;/movies&quot;)
    public ActorFilms movies(@RequestParam(value = &quot;input&quot;) String input) throws Exception &#123;
        return this.chatClient.prompt()
                .user(input)
                .call()
                .entity(ActorFilms.class);
    &#125;

curl --location --request GET &#39;http://localhost:1000/movies&#39; \
--header &#39;User-Agent: Apifox/1.0.0 (https://apifox.com)&#39; \
--header &#39;Content-Type: application/json&#39;
</code></pre>
<h5 id="指定消息角色-defaultSystem"><a href="#指定消息角色-defaultSystem" class="headerlink" title="指定消息角色  .defaultSystem"></a>指定消息角色  <code>.defaultSystem</code></h5><pre><code class="java">    public ChatController(ChatClient.Builder builder) &#123;
        this.chatClient = builder
                .defaultSystem(&quot;你是一个演员，请列出你所参演的电影&quot;)
                .build();
    &#125;
    @GetMapping(&quot;/chat&quot;)
    public String chat(@RequestParam(value = &quot;input&quot;) String input) &#123;

        return this.chatClient.prompt()
                .user(input)
                .call()
                .content();
    &#125;


curl --location --request GET &#39;http://localhost:1000/chat&#39; \
--header &#39;User-Agent: Apifox/1.0.0 (https://apifox.com)&#39; \
--header &#39;Content-Type: application/json&#39;
</code></pre>
<pre><code class="java">package com.fox.alibabaaidemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
public  class AIController &#123;
      private final ChatClient chatClient;
    public AIController(ChatClient.Builder builder) &#123;
        this.chatClient =  builder
                .defaultSystem(&quot;你是一个友好的聊天机器人，回答问题时要使用&#123;voice&#125;的语气&quot;)
                .build();
    &#125;
      @GetMapping(&quot;/ai&quot;)
      Map&lt;String, String&gt; completion(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;说一个笑话&quot;) String message, String voice) &#123;
        return Map.of(
            &quot;completion&quot;,
            this.chatClient.prompt()
                .system(sp -&gt; sp.param(&quot;voice&quot;, voice))
                .user(message)
                .call()
                .content());
      &#125;
    &#125;

GET：http://localhost:1000/ai
voice  沈腾
</code></pre>
<h3 id="其他默认设置"><a href="#其他默认设置" class="headerlink" title="其他默认设置"></a>其他默认设置</h3><p>除了 <code>defaultSystem</code> 之外，您还可以在 <code>ChatClient.Builder</code> 级别上指定其他默认提示。</p>
<ul>
<li><code>defaultOptions(ChatOptions chatOptions)</code>：传入 <code>ChatOptions</code> 类中定义的可移植选项或特定于模型实现的如 <code>DashScopeChatOptions</code> 选项。有关特定于模型的<code>ChatOptions</code>实现的更多信息，请参阅 JavaDocs。</li>
<li><code>defaultFunction(String name, String description, java.util.function.Function&lt;I, O&gt; function)</code>：<code>name</code> 用于在用户文本中引用该函数，<code>description</code>解释该函数的用途并帮助 AI 模型选择正确的函数以获得准确的响应，参数 <code>function</code> 是模型将在必要时执行的 Java 函数实例。</li>
<li><code>defaultFunctions(String... functionNames)</code>：应用程序上下文中定义的 java.util.Function 的 bean 名称。</li>
<li><code>defaultUser(String text)</code>、<code>defaultUser(Resource text)</code>、<code>defaultUser(Consumer&lt;UserSpec&gt; userSpecConsumer)</code> 这些方法允许您定义用户消息输入，<code>Consumer&lt;UserSpec&gt;</code>允许您使用 lambda 指定用户消息输入和任何默认参数。</li>
<li><code>defaultAdvisors(RequestResponseAdvisor... advisor)</code>：Advisors 允许修改用于创建 <code>Prompt</code> 的数据，<code>QuestionAnswerAdvisor</code> 实现通过在 Prompt 中附加与用户文本相关的上下文信息来实现 <code>Retrieval Augmented Generation</code> 模式。</li>
<li><code>defaultAdvisors(Consumer&lt;AdvisorSpec&gt; advisorSpecConsumer)</code>：此方法允许您定义一个 <code>Consumer</code> 并使用 <code>AdvisorSpec</code> 配置多个 Advisor，Advisor 可以修改用于创建 <code>Prompt</code> 的最终数据，<code>Consumer&lt;AdvisorSpec&gt;</code> 允许您指定 lambda 来添加 Advisor 例如 <code>QuestionAnswerAdvisor</code>。</li>
</ul>
<p>您可以在运行时使用 <code>ChatClient</code> 提供的不带 <code>default</code> 前缀的相应方法覆盖这些默认值。</p>
<ul>
<li><p><code>options(ChatOptions chatOptions)</code></p>
</li>
<li><p><code>function(String name, String description, java.util.function.Function&lt;I, O&gt; function)</code></p>
</li>
<li><p><code>functions(String... functionNames)</code></p>
</li>
<li><p><code>user(String text)</code>、<code>user(Resource text)</code>、<code>user(Consumer&lt;UserSpec&gt; userSpecConsumer)</code></p>
</li>
<li><p><code>advisors(RequestResponseAdvisor... advisor)</code></p>
</li>
<li><p><code>advisors(Consumer&lt;AdvisorSpec&gt; advisorSpecConsumer)</code></p>
</li>
</ul>
<h2 id="【基于内存存储】多轮对话记忆管理对话记忆"><a href="#【基于内存存储】多轮对话记忆管理对话记忆" class="headerlink" title="【基于内存存储】多轮对话记忆管理对话记忆"></a>【基于内存存储】多轮对话记忆管理<del>对话记忆</del></h2><h5 id="对话模型-Chat-Model"><a href="#对话模型-Chat-Model" class="headerlink" title="对话模型(Chat Model)"></a>对话模型(Chat Model)</h5><p>对话模型（Chat Model）接收一系列消息（Message）作为输入，与模型 LLM 服务进行交互，并接收返回的聊天消息（Chat Message）作为输出。相比于普通的程序输入，模型的输入与输出消息（Message）不止支持纯字符文本，还支持包括语音、图片、视频等作为输入输出。同时，在 Spring AI Alibaba 中，消息中还支持包含不同的角色，帮助底层模型区分来自模型、用户和系统指令等的不同消息。</p>
<p>Spring AI Alibaba 复用了 Spring AI 抽象的 Model API，并与通义系列大模型服务进行适配（如通义千问、通义万相等），目前支持纯文本聊天、文生图、文生语音、语音转文本等。以下是框架定义的几个核心 API：</p>
<ul>
<li>ChatModel，文本聊天交互模型，支持纯文本格式作为输入，并将模型的输出以格式化文本形式返回。</li>
<li>ImageModel，接收用户文本输入，并将模型生成的图片作为输出返回。</li>
<li>AudioModel，接收用户文本输入，并将模型合成的语音作为输出返回。</li>
</ul>
<p>Spring AI Alibaba 支持以上 Model 抽象与通义系列模型的适配，并通过 <code>spring-ai-alibaba-starter</code> AutoConfiguration 自动初始化了默认实例，因此我们可以在应用程序中直接注入 ChatModel、ImageModel 等 bean，当然在需要的时候也可以自定义 Model 实例。</p>
<h5 id="对话记忆介绍"><a href="#对话记忆介绍" class="headerlink" title="对话记忆介绍"></a>对话记忆介绍</h5><p>”大模型的对话记忆”这一概念，根植于人工智能与自然语言处理领域，特别是针对具有深度学习能力的大型语言模型而言，它指的是模型在与用户进行交互式对话过程中，能够追踪、理解并利用先前对话上下文的能力。 此机制使得大模型不仅能够响应即时的输入请求，还能基于之前的交流内容能够在对话中记住先前的对话内容，并根据这些信息进行后续的响应。这种记忆机制使得模型能够在对话中持续跟踪和理解用户的意图和上下文，从而实现更自然和连贯的对话。</p>
<p>我们在调用大模型的过程中，如果自己维护多轮的对话记忆，通常情况下调用代码如下</p>
<pre><code class="java">import java.util.ArrayList;

List&lt;Message&gt; messages = new ArrayList&lt;&gt;();

//第一轮对话
messages.add(new SystemMessage(&quot;你是一个旅游规划师&quot;));
messages.add(new UserMessage(&quot;我想去新疆&quot;));
ChatResponse response = chatModel.call(new Prompt(messages));
String content = response.getResult().getOutput().getContent();

messages.add(new AssistantMessage(content));

        //第二轮对话
messages.add(new UserMessage(&quot;能帮我推荐一些旅游景点吗?&quot;));
response = chatModel.call(new Prompt(messages));
content = response.getResult().getOutput().getContent();

messages.add(new AssistantMessage(content));

        //第三轮对话
messages.add(new UserMessage(&quot;那里这两天的天气如何?&quot;));
response = chatModel.call(new Prompt(messages));
content = response.getResult().getOutput().getContent();

System.out.printf(&quot;content: %s\n&quot;, content);
</code></pre>
<h2 id="基于memory的对话记忆advisors是增强器"><a href="#基于memory的对话记忆advisors是增强器" class="headerlink" title="基于memory的对话记忆advisors是增强器"></a>基于memory的对话记忆<del>advisors是增强器</del></h2><p>如何让大模型有对话记忆呢？<br><code>Advisor(MessageChatMemoryAdvisor)、Memory(InMemoryChatMemory,RedisChatMemory)</code><br>使用ChatMemoryAdvisor与RedisChatMemory存储历史对话 </p>
<pre><code class="yaml">ChatClient.builder(chatModel)
  .defaultAdvisors(new MessageChatMemoryAdvisor(redisChatMemory))
  .build();
</code></pre>
<p>spring-ai-alibaba支持基于chat memory的对话记忆，也就是不需要调用显示的记录每一轮的对话历史。下边是一个基于内存存储的对话记忆实现:</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;/chat-memory&quot;)
public class ChatMemoryController &#123;

    private final ChatClient chatClient;

    public ChatMemoryController(ChatModel chatModel) &#123;
// 构建对话模型 基于内存的方式InMemory...
        this.chatClient = ChatClient
                .builder(chatModel)
                .defaultSystem(&quot;你是一个旅游规划师，请根据用户的需求提供旅游规划建议。&quot;)
                .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
//                .defaultAdvisors(new MessageChatMemoryAdvisor(new RedisChatMemory(
//                        &quot;127.0.0.1&quot;,
//                        6379,
//                        null
//                )))
                .build();
    &#125;

    /**
     * 获取内存中的聊天内容
     * 根据提供的prompt和chatId，从内存中获取相关的聊天内容，并设置响应的字符编码为UTF-8。
     *
     * @param prompt 用于获取聊天内容的提示信息
     * @param chatId 聊天的唯一标识符，用于区分不同的聊天会话
     * @param response HTTP响应对象，用于设置响应的字符编码
     * @return 返回包含聊天内容的Flux&lt;String&gt;对象
     */
    @GetMapping(&quot;/in-memory&quot;)
    public Flux&lt;String&gt; memory(
            @RequestParam(&quot;prompt&quot;) String prompt,
            @RequestParam(&quot;chatId&quot;) String chatId,
            HttpServletResponse response
    ) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return chatClient.prompt(prompt).advisors(
                a -&gt; a
                        .param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)
                        .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 100)
        ).stream().content();
    &#125;

GET：http://localhost:1000/chat-memory/in-memory
prompt  我想去新疆玩
chatId  Pluminary
</code></pre>
<blockquote>
<h1 id="One【我想去新疆玩】"><a href="#One【我想去新疆玩】" class="headerlink" title="One【我想去新疆玩】"></a>One【我想去新疆玩】</h1><p>太棒了！新疆是中国最美丽、最多元化的旅游目的地之一，拥有壮丽的自然风光、丰富的民族文化和悠久的历史遗迹。根据你的兴趣和时间安排，我可以为你量身定制一份详细的旅行计划。</p>
<p>以下是一份 <strong>7天经典新疆旅游路线推荐</strong>，适合第一次来新疆的游客：</p>
<hr>
<h3 id="🌄-7天经典新疆旅游线路（北疆线）"><a href="#🌄-7天经典新疆旅游线路（北疆线）" class="headerlink" title="🌄 7天经典新疆旅游线路（北疆线）"></a>🌄 7天经典新疆旅游线路（北疆线）</h3><h4 id="✅-路线概览："><a href="#✅-路线概览：" class="headerlink" title="✅ 路线概览："></a>✅ 路线概览：</h4><p>乌鲁木齐 → 天池 → 乌鲁木齐 → 奎屯 → 赛里木湖 → 果子沟 → 伊宁 → 那拉提草原 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</p>
<hr>
<h3 id="📅-行程详情："><a href="#📅-行程详情：" class="headerlink" title="📅 行程详情："></a>📅 行程详情：</h3><h4 id="第1天：抵达乌鲁木齐"><a href="#第1天：抵达乌鲁木齐" class="headerlink" title="第1天：抵达乌鲁木齐"></a>第1天：抵达乌鲁木齐</h4><ul>
<li>抵达乌鲁木齐地窝堡国际机场或火车站。</li>
<li>游览【国际大巴扎】，购买当地特产与手工艺品。</li>
<li>晚上可品尝新疆特色美食：大盘鸡、烤包子、羊肉串等。</li>
</ul>
<h4 id="第2天：乌鲁木齐-→-天山天池-→-返回乌鲁木齐"><a href="#第2天：乌鲁木齐-→-天山天池-→-返回乌鲁木齐" class="headerlink" title="第2天：乌鲁木齐 → 天山天池 → 返回乌鲁木齐"></a>第2天：乌鲁木齐 → 天山天池 → 返回乌鲁木齐</h4><ul>
<li>上午驱车前往【天山天池】，欣赏雪山、湖泊、松林交相辉映的美景。</li>
<li>下午返回市区，参观【新疆博物馆】了解西域历史文化。</li>
<li>可尝试维吾尔族风味晚餐。</li>
</ul>
<h4 id="第3天：乌鲁木齐-→-奎屯-→-赛里木湖"><a href="#第3天：乌鲁木齐-→-奎屯-→-赛里木湖" class="headerlink" title="第3天：乌鲁木齐 → 奎屯 → 赛里木湖"></a>第3天：乌鲁木齐 → 奎屯 → 赛里木湖</h4><ul>
<li>乘车约6小时到达【赛里木湖】，被誉为“大西洋最后一滴眼泪”。</li>
<li>环湖游览，拍摄湖光山色，入住湖边民宿或附近酒店。</li>
</ul>
<h4 id="第4天：赛里木湖-→-伊宁"><a href="#第4天：赛里木湖-→-伊宁" class="headerlink" title="第4天：赛里木湖 → 伊宁"></a>第4天：赛里木湖 → 伊宁</h4><ul>
<li>沿果子沟峡谷前行，穿越【果子沟大桥】，风景绝佳。</li>
<li>到达伊宁市后，游览【喀赞其民俗区】，感受浓郁的维吾尔族风情。</li>
<li>住伊宁。</li>
</ul>
<h4 id="第5天：伊宁-→-那拉提草原"><a href="#第5天：伊宁-→-那拉提草原" class="headerlink" title="第5天：伊宁 → 那拉提草原"></a>第5天：伊宁 → 那拉提草原</h4><ul>
<li>乘车约3小时到达【那拉提草原】，是新疆最美的高山草甸之一。</li>
<li>骑马、徒步、摄影，体验草原牧民生活。</li>
<li>住那拉提镇。</li>
</ul>
<h4 id="第6天：那拉提-→-巴音布鲁克-→-独库公路-→-乌鲁木齐"><a href="#第6天：那拉提-→-巴音布鲁克-→-独库公路-→-乌鲁木齐" class="headerlink" title="第6天：那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐"></a>第6天：那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</h4><ul>
<li>驱车前往【巴音布鲁克草原】，探访著名的“九曲十八弯”开都河。</li>
<li>沿【独库公路】北段返回乌鲁木齐，途中穿越天山山脉，风景震撼。</li>
<li>全天行车时间较长（约8-10小时），建议提前准备干粮和水。</li>
</ul>
<h4 id="第7天：乌鲁木齐-→-返程"><a href="#第7天：乌鲁木齐-→-返程" class="headerlink" title="第7天：乌鲁木齐 → 返程"></a>第7天：乌鲁木齐 → 返程</h4><ul>
<li>根据航班&#x2F;火车时间安排返程。</li>
<li>可在市区再次购物或补拍未尽兴的景点。</li>
</ul>
<hr>
<h3 id="💡-小贴士："><a href="#💡-小贴士：" class="headerlink" title="💡 小贴士："></a>💡 小贴士：</h3><ul>
<li><strong>最佳旅游季节</strong>：每年6月-10月是新疆的最佳旅游季节，气候宜人，风景最美。</li>
<li><strong>交通方式</strong>：<ul>
<li>自驾游是探索新疆最好的方式，路况较好。</li>
<li>若不自驾，也可以选择包车或参加当地品质团。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>新疆昼夜温差大，注意带好保暖衣物。</li>
<li>注意防晒，紫外线较强。</li>
<li>尊重少数民族风俗习惯，避免敏感话题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="🍽️-必吃美食推荐："><a href="#🍽️-必吃美食推荐：" class="headerlink" title="🍽️ 必吃美食推荐："></a>🍽️ 必吃美食推荐：</h3><ul>
<li>烤包子</li>
<li>手抓饭</li>
<li>羊肉串</li>
<li>盘吉尔塔格麻饼</li>
<li>牛骨头汤</li>
<li>新疆酸奶+馕</li>
</ul>
<hr>
<p>如果你有更长的时间，还可以考虑延伸到南疆（喀什、塔克拉玛干沙漠、帕米尔高原）或者北疆深度游（可可托海、喀纳斯、禾木）。</p>
<p>你可以告诉我：</p>
<ul>
<li>出行时间</li>
<li>同行人数</li>
<li>是否自驾</li>
<li>是否希望加入人文历史或摄影元素</li>
</ul>
<p>我可以为你定制更详细的行程、住宿推荐和预算方案哦！</p>
<h1 id="Tow-prompt：有哪些好玩的地方？"><a href="#Tow-prompt：有哪些好玩的地方？" class="headerlink" title="Tow [prompt：有哪些好玩的地方？]"></a>Tow [prompt：有哪些好玩的地方？]</h1><p>当然可以！作为一个旅游规划师，我会根据不同的旅行兴趣、时间和预算，为你推荐新疆最值得一去的<strong>好玩地方</strong>。新疆地大景美，玩法多样，既有自然风光，也有浓郁的民族风情和历史人文。</p>
<hr>
<h2 id="🌄-新疆十大必玩景点推荐（按类型分类）"><a href="#🌄-新疆十大必玩景点推荐（按类型分类）" class="headerlink" title="🌄 新疆十大必玩景点推荐（按类型分类）"></a>🌄 新疆十大必玩景点推荐（按类型分类）</h2><h3 id="一、自然风光类"><a href="#一、自然风光类" class="headerlink" title="一、自然风光类"></a>一、自然风光类</h3><h4 id="1-喀纳斯湖景区"><a href="#1-喀纳斯湖景区" class="headerlink" title="1. 喀纳斯湖景区"></a>1. <strong>喀纳斯湖景区</strong></h4><ul>
<li><strong>关键词</strong>：神秘湖怪、变色湖、图瓦人村落</li>
<li><strong>推荐理由</strong>：被誉为“人间仙境”，四季皆美，秋季尤胜。</li>
<li><strong>适合人群</strong>：摄影爱好者、自然探险者</li>
</ul>
<h4 id="2-赛里木湖"><a href="#2-赛里木湖" class="headerlink" title="2. 赛里木湖"></a>2. <strong>赛里木湖</strong></h4><ul>
<li><strong>关键词</strong>：大西洋最后一滴眼泪、花海、湖光山色</li>
<li><strong>推荐理由</strong>：夏季油菜花盛开，湖水清澈见底，是北疆最美湖泊之一。</li>
</ul>
<h4 id="3-那拉提草原"><a href="#3-那拉提草原" class="headerlink" title="3. 那拉提草原"></a>3. <strong>那拉提草原</strong></h4><ul>
<li><strong>关键词</strong>：空中草原、骑马、牧民风情</li>
<li><strong>推荐理由</strong>：夏季草原如画，适合徒步、骑马、拍照。</li>
</ul>
<h4 id="4-巴音布鲁克草原-amp-九曲十八弯"><a href="#4-巴音布鲁克草原-amp-九曲十八弯" class="headerlink" title="4. 巴音布鲁克草原 &amp; 九曲十八弯"></a>4. <strong>巴音布鲁克草原 &amp; 九曲十八弯</strong></h4><ul>
<li><strong>关键词</strong>：天鹅故乡、开都河九曲、日落绝美</li>
<li><strong>推荐理由</strong>：中国第二大草原，电影《飞驰人生》取景地。</li>
</ul>
<h4 id="5-独库公路"><a href="#5-独库公路" class="headerlink" title="5. 独库公路"></a>5. <strong>独库公路</strong></h4><ul>
<li><strong>关键词</strong>：天山之路、一日四季、自驾天堂</li>
<li><strong>推荐理由</strong>：被誉为“中国最美景观大道”，连接南北疆。</li>
</ul>
<hr>
<h3 id="二、历史文化类"><a href="#二、历史文化类" class="headerlink" title="二、历史文化类"></a>二、历史文化类</h3><h4 id="6-交河故城-amp-高昌故城"><a href="#6-交河故城-amp-高昌故城" class="headerlink" title="6. 交河故城 &amp; 高昌故城"></a>6. <strong>交河故城 &amp; 高昌故城</strong></h4><ul>
<li><strong>关键词</strong>：丝绸之路遗迹、千年古城</li>
<li><strong>推荐理由</strong>：感受古代西域文明的辉煌与沧桑。</li>
</ul>
<h4 id="7-克孜尔千佛洞"><a href="#7-克孜尔千佛洞" class="headerlink" title="7. 克孜尔千佛洞"></a>7. <strong>克孜尔千佛洞</strong></h4><ul>
<li><strong>关键词</strong>：佛教艺术瑰宝、壁画、石窟群</li>
<li><strong>推荐理由</strong>：比敦煌莫高窟更早开凿，艺术价值极高。</li>
</ul>
<h4 id="8-香妃墓（阿帕克霍加墓）"><a href="#8-香妃墓（阿帕克霍加墓）" class="headerlink" title="8. 香妃墓（阿帕克霍加墓）"></a>8. <strong>香妃墓（阿帕克霍加墓）</strong></h4><ul>
<li><strong>关键词</strong>：爱情传说、伊斯兰建筑</li>
<li><strong>推荐理由</strong>：喀什最具代表性的古迹之一。</li>
</ul>
<hr>
<h3 id="三、民俗风情类"><a href="#三、民俗风情类" class="headerlink" title="三、民俗风情类"></a>三、民俗风情类</h3><h4 id="9-喀什老城（艾提尕尔清真寺）"><a href="#9-喀什老城（艾提尕尔清真寺）" class="headerlink" title="9. 喀什老城（艾提尕尔清真寺）"></a>9. <strong>喀什老城（艾提尕尔清真寺）</strong></h4><ul>
<li><strong>关键词</strong>：维吾尔族风情、夜市、手工艺</li>
<li><strong>推荐理由</strong>：南疆文化中心，充满异域风情。</li>
</ul>
<h4 id="10-塔克拉玛干沙漠-x2F-塔中沙漠公路"><a href="#10-塔克拉玛干沙漠-x2F-塔中沙漠公路" class="headerlink" title="10. 塔克拉玛干沙漠 &#x2F; 塔中沙漠公路"></a>10. <strong>塔克拉玛干沙漠 &#x2F; 塔中沙漠公路</strong></h4><ul>
<li><strong>关键词</strong>：死亡之海、星空露营、越野挑战</li>
<li><strong>推荐理由</strong>：体验极限风光，感受荒漠中的壮美。</li>
</ul>
<hr>
<h2 id="🏞️-按线路推荐热门玩法"><a href="#🏞️-按线路推荐热门玩法" class="headerlink" title="🏞️ 按线路推荐热门玩法"></a>🏞️ 按线路推荐热门玩法</h2><table>
<thead>
<tr>
<th>线路类型</th>
<th>推荐景点</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>北疆经典线</td>
<td>天池、赛里木湖、那拉提、巴音布鲁克、独库公路</td>
<td>风景优美、适合首次来新疆</td>
</tr>
<tr>
<td>南疆深度线</td>
<td>喀什、塔克拉玛干沙漠、帕米尔高原、塔县、白沙湖</td>
<td>民俗浓郁、神秘原始</td>
</tr>
<tr>
<td>北疆深度线</td>
<td>喀纳斯、禾木、可可托海</td>
<td>秋季绝美、摄影圣地</td>
</tr>
<tr>
<td>自驾线路</td>
<td>独库公路、沙漠公路、喀纳斯环线</td>
<td>风景多变、自由灵活</td>
</tr>
</tbody></table>
<hr>
<h2 id="📅-根据时间长短推荐玩法"><a href="#📅-根据时间长短推荐玩法" class="headerlink" title="📅 根据时间长短推荐玩法"></a>📅 根据时间长短推荐玩法</h2><table>
<thead>
<tr>
<th>时间安排</th>
<th>推荐行程</th>
</tr>
</thead>
<tbody><tr>
<td>5-7天</td>
<td>北疆经典线：乌鲁木齐 → 赛里木湖 → 那拉提 → 巴音布鲁克 → 独库公路 → 乌鲁木齐</td>
</tr>
<tr>
<td>8-10天</td>
<td>北疆+南疆组合：乌鲁木齐 → 喀纳斯 → 那拉提 → 伊宁 → 喀什 → 帕米尔高原</td>
</tr>
<tr>
<td>10天以上</td>
<td>全疆深度游：涵盖北疆、南疆、东疆，体验多元文化与极致风光</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎯-小贴士：如何选择适合你的路线？"><a href="#🎯-小贴士：如何选择适合你的路线？" class="headerlink" title="🎯 小贴士：如何选择适合你的路线？"></a>🎯 小贴士：如何选择适合你的路线？</h2><ol>
<li><strong>喜欢自然风光？</strong> → 喀纳斯、赛里木湖、那拉提</li>
<li><strong>喜欢人文历史？</strong> → 交河故城、克孜尔千佛洞、喀什老城</li>
<li><strong>喜欢冒险刺激？</strong> → 塔克拉玛干沙漠、独库公路自驾</li>
<li><strong>喜欢摄影？</strong> → 喀纳斯秋景、巴音布鲁克日落、帕米尔高原星空</li>
<li><strong>亲子出游？</strong> → 乌鲁木齐博物馆、天山天池、那拉提草原</li>
</ol>
<hr>
<p>如果你能告诉我以下信息，我可以帮你定制专属行程：</p>
<ul>
<li>出行时间（几月份）</li>
<li>出行人数（是否带老人&#x2F;小孩）</li>
<li>是否自驾或包车</li>
<li>偏好自然&#x2F;人文&#x2F;美食&#x2F;摄影等哪一类</li>
<li>预算范围（经济型&#x2F;舒适型&#x2F;豪华型）</li>
</ul>
<p>期待你的回复，我将为你打造一份<strong>专属新疆旅行计划</strong>！✨</p>
</blockquote>
<p>当然，开发者也可以自行实现ChatMemory基于类似于文件、Redis等方式进行上下文内容的存储和记录。</p>
<h2 id="【基于Redis存储】多轮对话记忆管理对话记忆"><a href="#【基于Redis存储】多轮对话记忆管理对话记忆" class="headerlink" title="【基于Redis存储】多轮对话记忆管理对话记忆"></a>【基于Redis存储】多轮对话记忆管理<del>对话记忆</del></h2><p>这里Redis的官方依赖有问题 需要自己修改再去使用 不算得上是重构 要去重写建立新的<br>可以将下面的打成包 使用的时候只需要引入依赖即可</p>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\my-redis-memory\src\main\java\com\fox\myredismemory\RedisChatMemory.java
package com.fox.myredismemory;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.messages.UserMessage;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

import org.springframework.ai.chat.memory.ChatMemory;
import org.springframework.ai.chat.messages.Message;

/**
 *
 * 基于Redis的聊天记忆实现。
 * 该类实现了ChatMemory接口，提供了将聊天消息存储到Redis中的功能。
 *
 * @author Fox
 */
public class RedisChatMemory implements ChatMemory, AutoCloseable &#123;

    private static final Logger logger = LoggerFactory.getLogger(RedisChatMemory.class);

    private static final String DEFAULT_KEY_PREFIX = &quot;chat:&quot;;

    private static final String DEFAULT_HOST = &quot;127.0.0.1&quot;;

    private static final int DEFAULT_PORT = 6379;

    private static final String DEFAULT_PASSWORD = null;

    private final JedisPool jedisPool;


    private final ObjectMapper objectMapper;

    public RedisChatMemory() &#123;

        this(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_PASSWORD);
    &#125;

    public RedisChatMemory(String host, int port, String password) &#123;

        JedisPoolConfig poolConfig = new JedisPoolConfig();

        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, password);
        this.objectMapper = new ObjectMapper();
        logger.info(&quot;Connected to Redis at &#123;&#125;:&#123;&#125;&quot;, host, port);
    &#125;

    @Override
    public void add(String conversationId, List&lt;Message&gt; messages) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        AtomicLong timestamp = new AtomicLong(System.currentTimeMillis());

        try (Jedis jedis = jedisPool.getResource()) &#123;
            // 使用pipeline批量操作提升性能
            var pipeline = jedis.pipelined();
            messages.forEach(message -&gt;
                    pipeline.hset(key, String.valueOf(timestamp.getAndIncrement()), message.toString())
            );
            pipeline.sync();
        &#125;

        logger.info(&quot;Added messages to conversationId: &#123;&#125;&quot;, conversationId);
    &#125;

    @Override
    public List&lt;Message&gt; get(String conversationId, int lastN) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        try (Jedis jedis = jedisPool.getResource()) &#123;
            Map&lt;String, String&gt; allMessages = jedis.hgetAll(key);
            if (allMessages.isEmpty()) &#123;
                return List.of();
            &#125;

            return allMessages.entrySet().stream()
                    .sorted((e1, e2) -&gt;
                            Long.compare(Long.parseLong(e2.getKey()), Long.parseLong(e1.getKey()))
                    )
                    .limit(lastN)
                    .map(entry -&gt; new UserMessage(entry.getValue()))
                    .collect(Collectors.toList());
        &#125;


    &#125;

    @Override
    public void clear(String conversationId) &#123;

        String key = DEFAULT_KEY_PREFIX + conversationId;

        try (Jedis jedis = jedisPool.getResource()) &#123;
            jedis.del(key);
        &#125;
        logger.info(&quot;Cleared messages for conversationId: &#123;&#125;&quot;, conversationId);
    &#125;

    @Override
    public void close() &#123;
        try (Jedis jedis = jedisPool.getResource()) &#123;
            if (jedis != null) &#123;

                jedis.close();

                logger.info(&quot;Redis connection closed.&quot;);
            &#125;
            if (jedisPool != null) &#123;

                jedisPool.close();

                logger.info(&quot;Jedis pool closed.&quot;);
            &#125;
        &#125;

    &#125;

    public void clearOverLimit(String conversationId, int maxLimit, int deleteSize) &#123;
        try &#123;
            String key = DEFAULT_KEY_PREFIX + conversationId;
            try (Jedis jedis = jedisPool.getResource()) &#123;
                List&lt;String&gt; all = jedis.lrange(key, 0, -1);

                if (all.size() &gt;= maxLimit) &#123;
                    all = all.stream().skip(Math.max(0, deleteSize)).toList();
                &#125;
                this.clear(conversationId);
                for (String message : all) &#123;
                    jedis.rpush(key, message);
                &#125;
            &#125;
        &#125;
        catch (Exception e) &#123;
            logger.error(&quot;Error clearing messages from Redis chat memory&quot;, e);
            throw new RuntimeException(e);
        &#125;
    &#125;

&#125;
</code></pre>
<pre><code class="java">@RestController
@RequestMapping(&quot;/chat-memory&quot;)
public class ChatMemoryController &#123;

    private final ChatClient chatClient;

    public ChatMemoryController(ChatModel chatModel) &#123;
// 构建对话模型 基于内存的方式InMemory...
        this.chatClient = ChatClient
                .builder(chatModel)
                .defaultSystem(&quot;你是一个旅游规划师，请根据用户的需求提供旅游规划建议。&quot;)
//                .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))
                .defaultAdvisors(new MessageChatMemoryAdvisor(new RedisChatMemory(
                        &quot;127.0.0.1&quot;,
                        6379,
                        null
                )))
                .build();
    &#125;

    
    /**
     * 从Redis中获取聊天内容
     * 根据提供的prompt和chatId，从Redis中检索聊天内容，并以Flux&lt;String&gt;的形式返回
     *
     * @param prompt 聊天内容的提示或查询关键字
     * @param chatId 聊天的唯一标识符，用于从Redis中检索特定的聊天内容
     * @param response HttpServletResponse对象，用于设置响应的字符编码为UTF-8
     * @return Flux&lt;String&gt; 包含聊天内容的反应式流
     */
    @GetMapping(&quot;/redis&quot;)
    public Flux&lt;String&gt; redis(
            @RequestParam(&quot;prompt&quot;) String prompt,
            @RequestParam(&quot;chatId&quot;) String chatId,
            HttpServletResponse response
    ) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);

        return chatClient.prompt(prompt)
                .advisors(
                a -&gt; a
                        .param(CHAT_MEMORY_CONVERSATION_ID_KEY, chatId)
                        .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 10)
                )
                .stream().content();
    &#125;

GET：http://localhost:1000/chat-memory/redis
prompt  有什么好吃的？
chatId  Pluminary
</code></pre>
<p>打开<code>Another Redis Desktop Manager</code>即可看见<code>Key</code>和<code>Value</code><br>这里也是基于上下文 第一个问题是我想去三亚 第二个问题有什么好吃的<del>这里是基于第一个问题和回答去输出结果</del></p>
<pre><code class="java">Key：1752192461656
Value：UserMessage&#123;content=&#39;我想去三亚&#39;, properties=&#123;messageType=USER&#125;, messageType=USER&#125;
</code></pre>
<h3 id="ChatModel对话模型"><a href="#ChatModel对话模型" class="headerlink" title="ChatModel对话模型"></a>ChatModel对话模型</h3><p><code>ChatResponse</code>里面是对话的json响应类</p>
<pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.chat.DashScopeChatOptions;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.io.IOException;

@RestController
public class ChatModelController &#123;
    private final ChatModel chatModel;

    public ChatModelController(@Qualifier(&quot;dashscopeChatModel&quot;) ChatModel chatModel) &#123;
        this.chatModel = chatModel;
    &#125;

    @RequestMapping(&quot;/chat2&quot;)
    public String chat2(String input) &#123;

        DashScopeChatOptions options = DashScopeChatOptions.builder()
                .withTemperature(0.9)
                .withMaxToken(1500)
           //     .withTopP(0.01)
                .build();

        Prompt prompt = new Prompt(input, options);
        ChatResponse response = chatModel.call(prompt);
        //ChatResponse response = chatModel.call(new Prompt(input));
        return response.getResult().getOutput().getText();
    &#125;


    @RequestMapping(&quot;/streamChat&quot;)
    public Flux&lt;String&gt; streamChat(String input, HttpServletResponse response) throws IOException &#123;
        response.setContentType(&quot;text/event-stream&quot;);
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return chatModel.stream(input);
    &#125;
&#125;

GET：http://localhost:1000/chat2
input  我想去深圳，帮我做个规划
</code></pre>
<h3 id="ImageModel实现文生图"><a href="#ImageModel实现文生图" class="headerlink" title="ImageModel实现文生图"></a>ImageModel实现文生图</h3><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.image.DashScopeImageOptions;
import org.springframework.ai.image.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ImageModelController &#123;
    private final ImageModel imageModel;

    ImageModelController(@Qualifier(&quot;dashScopeImageModel&quot;) ImageModel imageModel) &#123;
        this.imageModel = imageModel;
    &#125;

    @RequestMapping(&quot;/image&quot;)
    public String image(String input) &#123;
        ImageOptions options = ImageOptionsBuilder.builder()
                .model(&quot;wanx2.1-t2i-turbo&quot;)
                .height(1024)
                .width(1024)
                .build();

        ImagePrompt imagePrompt = new ImagePrompt(input, options);
        ImageResponse response = imageModel.call(imagePrompt);
        String imageUrl = response.getResult().getOutput().getUrl();

        return &quot;redirect:&quot; + imageUrl;
    &#125;
&#125;

GET：http://localhost:1000/image
input  森林中的绝美精灵，手里拿着弓

</code></pre>
<h3 id="AudioModel文生语音-amp-语音转文本"><a href="#AudioModel文生语音-amp-语音转文本" class="headerlink" title="AudioModel文生语音&amp;语音转文本"></a>AudioModel文生语音&amp;语音转文本</h3><h6 id="文本生成语音"><a href="#文本生成语音" class="headerlink" title="文本生成语音"></a>文本生成语音</h6><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionModel;
import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionOptions;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisModel;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisPrompt;
import com.alibaba.cloud.ai.dashscope.audio.synthesis.SpeechSynthesisResponse;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.ByteBuffer;

/**
 * @author: Fox
 * @Desc:
 **/
@RestController
@RequestMapping(&quot;/audio&quot;)
public class AudioModelController &#123;

    private final SpeechSynthesisModel speechSynthesisModel;

    @Autowired
    public AudioModelController(SpeechSynthesisModel speechSynthesisModel) &#123;
        this.speechSynthesisModel = speechSynthesisModel;
    &#125;

    @GetMapping(&quot;/synthesize&quot;)
    public ResponseEntity&lt;byte[]&gt; synthesizeSpeech(@RequestParam String text) throws IOException &#123;
        // 构建语音合成请求
        SpeechSynthesisPrompt prompt = new SpeechSynthesisPrompt(text);

        // 调用模型生成语音
        SpeechSynthesisResponse response = speechSynthesisModel.call(prompt);
        ByteBuffer audioData = response.getResult().getOutput().getAudio();

        // 将 ByteBuffer 转换为字节数组
        byte[] audioBytes = new byte[audioData.remaining()];
        audioData.get(audioBytes);

        // 返回音频流（MP3格式）
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(&quot;Content-Disposition&quot;, &quot;attachment; filename=output.mp3&quot;)
                .body(audioBytes);
    &#125;
&#125;

GET：http://localhost:1000/audio/synthesize
text  我真的太喜欢点赞啦
</code></pre>
<h5 id="语音生成文本"><a href="#语音生成文本" class="headerlink" title="语音生成文本"></a>语音生成文本</h5><pre><code class="java">package com.fox.alibabaaidemo.controller;

import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionModel;
import com.alibaba.cloud.ai.dashscope.audio.DashScopeAudioTranscriptionOptions;
import org.springframework.ai.audio.transcription.AudioTranscriptionPrompt;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.net.MalformedURLException;

/**
 * @author: Fox
 * @Desc:
 **/
@RestController
public class AudioModelController2 &#123;

    private static final String AUDIO_RESOURCES_URL = &quot;https://dashscope.oss-cn-beijing.aliyuncs.com/samples/audio/paraformer/hello_world_female2.wav&quot;;

    private final DashScopeAudioTranscriptionModel dashScopeAudioTranscriptionModel; //modelname:sensevoice-v1,paraformer-realtime-v2,paraformer-v2

    AudioModelController2(DashScopeAudioTranscriptionModel dashScopeAudioTranscriptionModel)&#123;
        this.dashScopeAudioTranscriptionModel = dashScopeAudioTranscriptionModel;
    &#125;

    @GetMapping(&quot;/audio&quot;)
    public String audio() throws MalformedURLException &#123;
        Resource resource =new UrlResource(AUDIO_RESOURCES_URL);

        AudioTranscriptionPrompt prompt = new AudioTranscriptionPrompt(resource,
                DashScopeAudioTranscriptionOptions.builder()
                        .withModel(&quot;sensevoice-v1&quot;)
                        .build());

        return dashScopeAudioTranscriptionModel.call(prompt).getResult().getOutput();
    &#125;
&#125;

GET：http://localhost:1000/audio
</code></pre>
<h1 id="提示词-Prompt-create"><a href="#提示词-Prompt-create" class="headerlink" title="提示词 (Prompt).create"></a>提示词 (Prompt)<del>.create</del></h1><p>Prompt 是引导 AI 模型生成特定输出的输入格式，Prompt 的设计和措辞会显著影响模型的响应。</p>
<p>Prompt 最开始只是简单的字符串，随着时间的推移，prompt 逐渐开始包含特定的占位符，例如 AI 模型可以识别的 “USER:”、“SYSTEM:” 等。阿里云通义模型可通过将多个消息字符串分类为不同的角色，然后再由 AI 模型处理，为 prompt 引入了更多结构。每条消息都分配有特定的角色，这些角色对消息进行分类，明确 AI 模型提示的每个部分的上下文和目的。这种结构化方法增强了与 AI 沟通的细微差别和有效性，因为 prompt 的每个部分在交互中都扮演着独特且明确的角色。</p>
<p>Prompt 中的主要角色（Role）包括：</p>
<ul>
<li>系统角色（System Role）：指导 AI 的行为和响应方式，设置 AI 如何解释和回复输入的参数或规则。这类似于在发起对话之前向 AI 提供说明。</li>
<li>用户角色（User Role）：代表用户的输入 - 他们向 AI 提出的问题、命令或陈述。这个角色至关重要，因为它构成了 AI 响应的基础。</li>
<li>助手角色（Assistant Role）：AI 对用户输入的响应。这不仅仅是一个答案或反应，它对于保持对话的流畅性至关重要。通过跟踪 AI 之前的响应（其“助手角色”消息），系统可确保连贯且上下文相关的交互。助手消息也可能包含功能工具调用请求信息。它就像 AI 中的一个特殊功能，在需要执行特定功能（例如计算、获取数据或不仅仅是说话）时使用。</li>
<li>工具&#x2F;功能角色（Tool&#x2F;Function Role）：工具&#x2F;功能角色专注于响应工具调用助手消息返回附加信息。</li>
</ul>
<h5 id="API-概览"><a href="#API-概览" class="headerlink" title="API 概览"></a>API 概览</h5><h5 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h5><p>通常使用 ChatModel 的 call() 方法，该方法接受 Prompt 实例并返回 ChatResponse。</p>
<p>Prompt 类充当有组织的一系列 Message 对象和请求 ChatOptions 的容器。每条消息在提示中都体现了独特的角色，其内容和意图各不相同。这些角色可以包含各种元素，从用户查询到 AI 生成的响应再到相关背景信息。这种安排可以实现与 AI 模型的复杂而详细的交互，因为提示是由多条消息构成的，每条消息都被分配了在对话中扮演的特定角色。</p>
<p>该类实现的接口支持提示创建的不同方面：</p>
<p><strong>PromptTemplateStringActions</strong> 专注于创建和呈现提示字符串，代表提示生成的最基本形式。</p>
<p><strong>PromptTemplateMessageActions</strong> 专门用于通过生成和操作 Message 对象来创建提示。</p>
<p><strong>PromptTemplateActions</strong> 旨在返回 Prompt 对象，该对象可以传递给 ChatModel 以生成响应。</p>
<p>虽然这些接口可能在许多项目中没有得到广泛使用，但它们展示了创建提示的不同方法。</p>
<h6 id="实现ConfigurablePromptTemplateFactory"><a href="#实现ConfigurablePromptTemplateFactory" class="headerlink" title="实现ConfigurablePromptTemplateFactory"></a>实现ConfigurablePromptTemplateFactory</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\java\com\fox\promptdemo\config\PromptTemplateConfig.java

package com.fox.promptdemo.config;

import com.alibaba.cloud.ai.prompt.ConfigurablePromptTemplateFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PromptTemplateConfig &#123;

    @Bean
    public ConfigurablePromptTemplateFactory configurablePromptTemplateFactory() &#123;
        // 这里假设ConfigurablePromptTemplateFactory有一个无参构造函数
        return new ConfigurablePromptTemplateFactory();
        // 如果需要配置参数，可以在这里进行配置
        // return new ConfigurablePromptTemplateFactory(param1, param2);
    &#125;
&#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\java\com\fox\promptdemo\controller\PromptTemplateController.java
@GetMapping(&quot;/prompt-template&quot;)
    public AssistantMessage generate(
            @RequestParam(value = &quot;author&quot;, defaultValue = &quot;鲁迅&quot;) String author
    ) &#123;

        ConfigurablePromptTemplate template = configurablePromptTemplateFactory.getTemplate(&quot;test-template&quot;);

        if (template == null) &#123;
            template = configurablePromptTemplateFactory.create(&quot;test-template&quot;,
                    &quot;请列出 &#123;author&#125; 最著名的三本书。&quot;);
        &#125;

        Prompt prompt;
        if (StringUtils.hasText(author)) &#123;
            prompt = template.create(Map.of(&quot;author&quot;, author));
        &#125; else &#123;
            prompt = template.create();
        &#125;

        return chatClient.prompt(prompt)
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;

GET：http://localhost:10007/example/ai/prompt-template
author  鲁迅
</code></pre>
<h6 id="实现PromptTemplate"><a href="#实现PromptTemplate" class="headerlink" title="实现PromptTemplate"></a>实现PromptTemplate</h6><pre><code class="java">@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class PromptTemplateController &#123;

    private final ChatClient chatClient;

    private final ConfigurablePromptTemplateFactory configurablePromptTemplateFactory;
        
    // 这里的资源是以st文件类型放在了resources的prompts里面
    @Value(&quot;classpath:/prompts/joke-prompt.st&quot;)
    private Resource jokeResource;

    @GetMapping(&quot;/prompt&quot;)
    public AssistantMessage completion(
            @RequestParam(value = &quot;adjective&quot;, defaultValue = &quot;有趣&quot;) String adjective,
            @RequestParam(value = &quot;topic&quot;, defaultValue = &quot;奶牛&quot;) String topic
    ) &#123;

        PromptTemplate promptTemplate = new PromptTemplate(jokeResource);
        Prompt prompt = promptTemplate.create(Map.of(&quot;adjective&quot;, adjective, &quot;topic&quot;, topic));

        return chatClient.prompt(prompt)
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\joke-prompt.st
给我讲一个关于 &#123;topic&#125; 的 &#123;adjective&#125; 笑话

GET：http://localhost:10007/example/ai/prompt
adjective  有趣的
topic  猫
</code></pre>
<h6 id="实现SystemPromptTemplate"><a href="#实现SystemPromptTemplate" class="headerlink" title="实现SystemPromptTemplate"></a>实现SystemPromptTemplate</h6><pre><code class="java">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.promptdemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.prompt.SystemPromptTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class RoleController &#123;

    private final ChatClient chatClient;

    @Value(&quot;classpath:/prompts/system-message.st&quot;)
    private Resource systemResource;

    @Autowired
    public RoleController(ChatClient.Builder builder) &#123;
        this.chatClient = builder.build();
    &#125;
// defaultValue是没有传入时候的默认值
    @GetMapping(&quot;/roles&quot;)
    public AssistantMessage generate(
            @RequestParam(value = &quot;message&quot;,
            defaultValue = &quot;请介绍一下海盗黄金时代的三位著名海盗，以及他们为什么这样做。为每个海盗至少写一句话。&quot;) String message,
            @RequestParam(value = &quot;name&quot;, defaultValue = &quot;Fox&quot;) String name,
            @RequestParam(value = &quot;voice&quot;, defaultValue = &quot;海盗&quot;) String voice
    ) &#123;

        UserMessage userMessage = new UserMessage(message);

        SystemPromptTemplate systemPromptTemplate = new SystemPromptTemplate(systemResource);
        // .createMessage创建一个系统消息
        Message systemMessage = systemPromptTemplate.createMessage(Map.of(&quot;name&quot;, name, &quot;voice&quot;, voice));

        return chatClient.prompt(new Prompt(List.of(userMessage, systemMessage)))
                .call()
                .chatResponse()
                .getResult()
                .getOutput();
    &#125;
&#125;

GET：http://localhost:10007/example/ai/roles
name  Pluminary
voice  海盗
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\system-message.st
你是一个有用的 AI 助手。
你是帮助人们查找信息的 AI 助手。
你的名字是 &#123;name&#125;
你应该使用你的姓名和 &#123;voice&#125; 的样式回复用户的请求。
</code></pre>
<h3 id="静态RAG实现：提示词动态注入"><a href="#静态RAG实现：提示词动态注入" class="headerlink" title="静态RAG实现：提示词动态注入"></a>静态RAG实现：提示词动态注入</h3><p>当前实现的方式：</p>
<ul>
<li>属于 “文档预加载+条件触发” 模式</li>
<li>通过 stuffit 参数实现 人工控制的上下文开关</li>
<li>上下文直接来自预定义的静态资源文件</li>
<li>本质上是一种轻量级的 静态RAG（Static RAG）</li>
</ul>
<p>经典RAG：</p>
<ul>
<li>采用 “检索-排序-注入” 自动化流程</li>
<li>依赖向量相似度计算动态选择上下文</li>
<li>支持增量学习和实时知识更新</li>
<li>典型流程：问题编码→向量检索→相关性过滤→上下文注入</li>
</ul>
<p>适用场景建议<br>当前方式更适合：</p>
<ul>
<li>文档规模小（如产品说明书、FAQ等）</li>
<li>需要严格控制的回答范围</li>
<li>快速原型开发阶段</li>
<li>对实时性要求不高的场景</li>
</ul>
<p>需要升级到RAG当：</p>
<ul>
<li>文档超过100MB或频繁更新</li>
<li>需要基于问题语义自动匹配上下文</li>
<li>要求支持多文档源混合检索</li>
<li>需要结合用户画像的个性化回答</li>
</ul>
<pre><code class="java">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.promptdemo.controller;

import com.fox.promptdemo.entity.Completion;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.prompt.PromptTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/example/ai&quot;)
public class StuffController &#123;

    private final ChatClient chatClient;

    @Value(&quot;classpath:/docs/bailian.md&quot;)
    private Resource docsToStuffResource;

    @Value(&quot;classpath:/prompts/qa-prompt.st&quot;)
    private Resource qaPromptResource;

    @Autowired
    public StuffController(ChatClient.Builder builder) &#123;
        this.chatClient = builder.build();
    &#125;

    @GetMapping(value = &quot;/stuff&quot;)
    public Completion completion(@RequestParam(value = &quot;message&quot;, defaultValue = &quot;给我推荐一款百炼系列的手机？&quot;)
                                     String message, @RequestParam(value = &quot;stuffit&quot;, defaultValue = &quot;false&quot;)
                                     boolean stuffit) &#123;

        PromptTemplate promptTemplate = new PromptTemplate(qaPromptResource);

        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;question&quot;, message);
        if (stuffit) &#123;
            map.put(&quot;context&quot;, docsToStuffResource);
        &#125; else &#123;
            map.put(&quot;context&quot;, &quot;&quot;);
        &#125;

        return new Completion(chatClient.prompt(promptTemplate.create(map)).call().content());
    &#125;

&#125;


GET：http://localhost:10007/example/ai/stuff
message  给我推荐一款百炼系列的手机？
stuffit  true
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\prompts\qa-prompt.st
使用以下上下文来回答最后的问题。
如果你不知道答案，就说你不知道，不要试图编造答案。

&#123;context&#125;

问题: &#123;question&#125;
有用的答案：
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\prompt-demo\src\main\resources\docs\bailian.md
# **百炼手机产品介绍**

欢迎来到未来科技的前沿，探索我们精心打造的智能手机系列，每一款都是为了满足您对科技生活的无限遐想而生。

**百炼X1** —— 畅享极致视界：搭载6.7英寸1440 x 3200像素超清屏幕，搭配120Hz刷新率，流畅视觉体验跃然眼前。256GB海量存储空间与12GB RAM强强联合，无论是大型游戏还是多任务处理，都能轻松应对。5000mAh电池长续航，加上超感光四摄系统，记录生活每一刻精彩。参考售价：4599 - 4999

**通义Vivid 7** —— 智能摄影新体验：拥有6.5英寸1080 x 2400像素全面屏，AI智能摄影功能让每一张照片都能展现专业级色彩与细节。8GB RAM与128GB存储空间确保流畅操作，4500mAh电池满足日常所需。侧面指纹解锁，便捷又安全。参考售价：2999 - 3299

**星尘S9 Pro** —— 创新视觉盛宴：突破性6.9英寸1440 x 3088像素屏下摄像头设计，带来无界视觉享受。512GB存储与16GB RAM的顶级配置，配合6000mAh电池与100W快充技术，让性能与续航并驾齐驱，引领科技潮流。参考售价：5999 - 6499。

**百炼Ace Ultra** —— 游戏玩家之选：配备6.67英寸1080 x 2400像素屏幕，内置10GB RAM与256GB存储，确保游戏运行丝滑无阻。5500mAh电池搭配液冷散热系统，长时间游戏也能保持冷静。高动态双扬声器，沉浸式音效升级游戏体验。参考售价：3999 - 4299。

**百炼Zephyr Z9** —— 轻薄便携的艺术：轻巧的6.4英寸1080 x 2340像素设计，搭配128GB存储与6GB RAM，日常使用游刃有余。4000mAh电池确保一天无忧，30倍数字变焦镜头捕捉远处细节，轻薄而不失强大。参考售价：2499 - 2799。

**百炼Flex Fold+** —— 折叠屏新纪元：集创新与奢华于一身，主屏7.6英寸1800 x 2400像素与外屏4.7英寸1080 x 2400像素，多角度自由悬停设计，满足不同场景需求。512GB存储、12GB RAM，加之4700mAh电池与UTG超薄柔性玻璃，开启折叠屏时代新篇章。此外，这款手机还支持双卡双待、卫星通话，帮助您在世界各地都能畅联通话。参考零售价：9999 - 10999。

每一款手机都是匠心独运，只为成就您手中的科技艺术品。选择属于您的智能伙伴，开启未来科技生活的新篇章。
</code></pre>
<h3 id="实现结构化输出转JSON或Java对象-entity-【文本转特定格式】"><a href="#实现结构化输出转JSON或Java对象-entity-【文本转特定格式】" class="headerlink" title="实现结构化输出转JSON或Java对象(.entity)【文本转特定格式】"></a>实现结构化输出<del>转JSON或Java对象(.entity)</del>【文本转特定格式】</h3><h4 id="ChatClient-1"><a href="#ChatClient-1" class="headerlink" title="ChatClient"></a>ChatClient</h4><p>调用<code>entity()</code>方法 </p>
<pre><code class="java">// 实体对象
ActorsFilms actorsFilms = ChatClient.create(chatModel).prompt()
        .user(u -&gt; u.text(&quot;Generate the filmography of 5 movies for &#123;actor&#125;.&quot;)
                    .param(&quot;actor&quot;, &quot;Tom Hanks&quot;))
        .call()
        .entity(ActorsFilms.class);
</code></pre>
<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><pre><code class="java">List&lt;ActorsFilms&gt; actorsFilms = ChatClient.create(chatModel).prompt()
        .user(&quot;Generate the filmography of 5 movies for Tom Hanks and Bill Murray.&quot;)
        .call()
        .entity(new ParameterizedTypeReference&lt;List&lt;ActorsFilms&gt;&gt;() &#123;&#125;);


//使用 ListOutputConverter 将模型响应转换为 List：
List&lt;String&gt; flavors = ChatClient.create(chatModel).prompt()
                .user(u -&gt; u.text(&quot;List five &#123;subject&#125;&quot;)
                            .param(&quot;subject&quot;, &quot;ice cream flavors&quot;))
                .call()
                .entity(new ListOutputConverter(new DefaultConversionService()));
</code></pre>
<h6 id="Map-lt-String-Object-gt"><a href="#Map-lt-String-Object-gt" class="headerlink" title="Map&lt; String, Object&gt;"></a>Map&lt; String, Object&gt;</h6><pre><code class="java">Map&lt;String, Object&gt; result = ChatClient.create(chatModel).prompt()
        .user(u -&gt; u.text(&quot;Provide me a List of &#123;subject&#125;&quot;)
                    .param(&quot;subject&quot;, &quot;an array of numbers from 1 to 9 under their key name &#39;numbers&#39;&quot;))
        .call()
        .entity(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);
</code></pre>
<hr>
<pre><code class="java">com/fox/structureddemo/stream/StreamToBeanEntity.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

public class StreamToBeanEntity &#123;

    private String title;
    private String author;
    private String date;
    private String content;

    public StreamToBeanEntity() &#123;
    &#125;

    public String getTitle() &#123;
        return title;
    &#125;

    public void setTitle(String title) &#123;
        this.title = title;
    &#125;

    public String getAuthor() &#123;
        return author;
    &#125;

    public void setAuthor(String author) &#123;
        this.author = author;
    &#125;

    public String getDate() &#123;
        return date;
    &#125;

    public void setDate(String date) &#123;
        this.date = date;
    &#125;

    public String getContent() &#123;
        return content;
    &#125;

    public void setContent(String content) &#123;
        this.content = content;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;StreamToBeanEntity&#123;&quot; +
                &quot;title=&#39;&quot; + title + &#39;\&#39;&#39; +
                &quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
                &quot;, date=&#39;&quot; + date + &#39;\&#39;&#39; +
                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/structureddemo/stream/StreamToBeanController.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.converter.BeanOutputConverter;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.util.Objects;


@RestController
@RequestMapping(&quot;/example/stream&quot;)
public class StreamToBeanController &#123;

    private final ChatClient chatClient;

    private static final Logger log = LoggerFactory.getLogger(StreamToBeanController.class);

    public StreamToBeanController(ChatClient.Builder builder) &#123;
        // 使用builder对象构建ChatClient实例
        this.chatClient = builder.build();
    &#125;


    /**
     * @return &#123;@link com.fox.structureddemo.stream.StreamToBeanEntity&#125;
     */
    @GetMapping(&quot;/play&quot;)
    public StreamToBeanEntity simpleChat(HttpServletResponse response) &#123;

        response.setCharacterEncoding(&quot;UTF-8&quot;);

        var converter = new BeanOutputConverter&lt;&gt;(
                new ParameterizedTypeReference&lt;StreamToBeanEntity&gt;() &#123; &#125;
        );

        Flux&lt;String&gt; flux = this.chatClient.prompt()
                .user(u -&gt; u.text(&quot;&quot;&quot;
                        requirement: 请用大概 120 字，作者为 Fox ，为计算机的发展历史写一首现代诗;
                        format: 以纯文本输出 json，请不要包含任何多余的文字——包括 markdown 格式;
                        outputExample: &#123;
                             &quot;title&quot;: &#123;title&#125;,
                             &quot;author&quot;: &#123;author&#125;,
                             &quot;date&quot;: &#123;date&#125;,
                             &quot;content&quot;: &#123;content&#125;
                        &#125;;
                        &quot;&quot;&quot;))
                .stream()
                .content();

        String result = String.join(&quot;\n&quot;, Objects.requireNonNull(flux.collectList().block()))
                .replaceAll(&quot;\\n&quot;, &quot;&quot;)
                .replaceAll(&quot;\\s+&quot;, &quot; &quot;)
                .replaceAll(&quot;\&quot;\\s*:&quot;, &quot;\&quot;:&quot;)
                .replaceAll(&quot;:\\s*\&quot;&quot;, &quot;:\&quot;&quot;);

        log.info(&quot;LLMs 响应的 json 数据为：&#123;&#125;&quot;, result);

        return converter.convert(result);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/structureddemo/stream/StreamToJsonController.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.fox.structureddemo.stream;

import com.alibaba.cloud.ai.dashscope.api.DashScopeResponseFormat;
import com.alibaba.cloud.ai.dashscope.chat.DashScopeChatOptions;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping(&quot;/example/stream/json&quot;)
public class StreamToJsonController &#123;

    private static final String DEFAULT_PROMPT = &quot;你好，请以JSON格式介绍你自己！&quot;;

    private final ChatClient dashScopeChatClient;

    public StreamToJsonController(ChatModel chatModel) &#123;

        DashScopeResponseFormat responseFormat = new DashScopeResponseFormat();
        responseFormat.setType(DashScopeResponseFormat.Type.JSON_OBJECT);

        this.dashScopeChatClient = ChatClient.builder(chatModel)
                .defaultOptions(
                        DashScopeChatOptions.builder()
                                .withTopP(0.7)
                                .withResponseFormat(responseFormat)
                                .build()
                )
                .build();
    &#125;

    /**
     * @return &#123;@link String&#125;
     */
    @GetMapping(&quot;/play&quot;)
    public String simpleChat(HttpServletResponse response) &#123;
        response.setCharacterEncoding(&quot;UTF-8&quot;);
        return dashScopeChatClient.prompt(DEFAULT_PROMPT)
                .call()
                .content();
    &#125;

&#125;
</code></pre>
<h3 id="通义千问大模型调优"><a href="#通义千问大模型调优" class="headerlink" title="通义千问大模型调优"></a>通义千问大模型调优</h3><ul>
<li><p><strong>temperature</strong>：温度值越高，模型生成的内容就越丰富多样</p>
<h6 id="温度只是来调整候选Token集合的概率分布"><a href="#温度只是来调整候选Token集合的概率分布" class="headerlink" title="温度只是来调整候选Token集合的概率分布"></a>温度只是来调整候选Token集合的概率分布</h6><p>低值（0.2）：适用于标准化回答（如退货政策查询）<br>高值（0.8）：适用于创意场景（如促销文案生成）低温度、中温度和高温度是依据通义千问plus模型的取值范围[0, 2)来划分。</p>
<ul>
<li>低温度（temperature&#x3D;0.1）：大模型选择“RAG”的概率远高于其它候选Token，这会导致其输出相对单一。</li>
<li>中温度（temperature&#x3D;0.7）：候选Token之间概率分布相对平缓，除“RAG”之外的候选Token出现的概率都在增加。</li>
<li>高温度（temperature&#x3D;1.2）：原低概率的候选Token出现概率进一步提升，打乱原有的排序，进一步提高了大模型输出的随机性。在上图中，“画画”出现的概率反而最高。</li>
</ul>
</li>
<li><p><strong>top_p</strong>：top_p值越高，大模型的输出结果随机性越高</p>
<h6 id="top-p控制候选Token集合的采样范围。"><a href="#top-p控制候选Token集合的采样范围。" class="headerlink" title="top_p控制候选Token集合的采样范围。"></a>top_p控制候选Token集合的采样范围。</h6><p>设置top_p&#x3D;0.9平衡多样性与准确性，防止低概率token干扰</p>
</li>
</ul>
<p>为了确保生成内容的可控性，建议不要同时调整top_p和temperature。同时调整可能导致输出结果不可预测和复杂。你可以优先调整其中一种参数，观察其对结果的影响，再逐步微调。</p>
<ul>
<li><strong>top_k</strong>：top_k越大，生成内容越多样化；top_k越小，内容则更固</li>
</ul>
<p>在通义千问系列模型中，参数top<em>k也有类似top</em>p的能力，可查阅通义千问API文档。它是一种采样机制，从概率排名前k的Token中随机选择一个进行输出。一般来说，top<em>k越大，生成内容越多样化；top</em>k越小，内容则更固定。当top_k设置为1时，模型仅选择概率最高的Token，输出会更加稳定，但也会导致缺乏变化和创意。</p>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/model-studio/use-qwen-by-calling-api?spm=a2c4g.11186623.help-menu-2400256.d_3_3_0.68332bdb2Afk2s&scm=20140722.H_2712576._.OR_help-V_1">通义千问API参考_大模型服务平台百炼(Model Studio)-阿里云帮助中心</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b76b2ef0bfbe66e8f88d7e832b3e955d3a3800d6/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B02.png"></p>
<h4 id="多个AI大模型无缝切换【👆图在上面👆】"><a href="#多个AI大模型无缝切换【👆图在上面👆】" class="headerlink" title="多个AI大模型无缝切换【👆图在上面👆】"></a>多个AI大模型无缝切换【👆图在上面👆】</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QDICVSc8em4YYnEdRy07Ag">如何实现多个AI大模型的无缝切换，比如DeepSeek-R1 调用失败可以请求降级调用 QwQ-32B。 AI网关方案实战</a></p>
<p>期，通义千问发布了一款全新的推理模型 QwQ-32B。在各类基准测试中，这个拥有 320 亿参数的模型展现出了与 DeepSeek-R1（6710 亿参数）相当的性能。这意味着：</p>
<ul>
<li>对于个人用户而言，QwQ-32B 能够直接在本地运行，且对设备的要求更低，适合在更小的移动设备上使用。</li>
<li>对于企业用户来说，调用推理大模型 API 的成本可以进一步降低，最高可减少 90% 的费用。</li>
</ul>
<p>在实际应用中，无缝切换多个大模型的需求日益凸显。例如，企业可能需要同时对接多个大模型，以满足不同业务场景的需求；当单个模型出现稳定性问题时，能够迅速回退到另一个模型，确保业务的连续性和稳定性；在 Multi Agent 场景下，一个复杂任务可能需要调用多个模型来协同完成。Higress AI 网关提供了一个强大的解决方案，支持多模型服务，并具备消费者鉴权、模型自动切换等高级功能。</p>
<p>本文将为您提供一份详细的教程，指导您如何使用 Higress AI 网关在 DeepSeek-R1 和 QwQ-32B 大模型之间实现无缝切换。</p>
<p>关于Higress网关的使用，可以参考我上一篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU1ODk1NTQ0Mg==&mid=2247485661&idx=1&sn=2435d46a1ee26308c84b3ef2c2068a12&scene=21#wechat_redirect">阿里巴巴开源的云原生网关Higress实战</a></p>
<p>若想要Higress桌面版 先下载<code>Docker Desktop</code>再下载 <code>Cygwin</code>验证<br>Cygwin 安装是否成功</p>
<pre><code class="shell">cygcheck -c cygwin
</code></pre>
<blockquote>
<p>Pluminary@Pluminary ~<br>$ cygcheck -c cygwin<br>Cygwin Package Information<br>Package              Version    Status<br>cygwin               3.6.1-1        OK</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/474242350">cygwin下载及安装详细教程，windows使用linux的shell命令编译源码（win10) - 知乎</a><br><a target="_blank" rel="noopener" href="https://higress.cn/zh-cn/blog/DeployOnWindows/">Windows 下 Higress 部署实践 | Higress</a></p>
<p>先<strong>单机部署nacos</strong> 进入<code>D:\nacos-docker-master\cmd</code><br>单机部署指令：<code>docker-compose -f example/standalone-derby.yaml up</code><br>这里可以修改端口映射：<code>D:\nacos-docker-master\example\standalone-derby.yaml</code> 如下👇<br>正确的监控检查命令：<code>curl http://192.168.31.103:8848/nacos/v3/console/health/readiness</code></p>
<pre><code class="yaml">version: &quot;2&quot;
services:
  nacos:
    image: nacos/nacos-server:$&#123;NACOS_VERSION&#125;
    container_name: nacos-standalone
    environment:
      - PREFER_HOST_MODE=hostname
      - MODE=standalone
      - NACOS_AUTH_IDENTITY_KEY=serverIdentity
      - NACOS_AUTH_IDENTITY_VALUE=security
      - NACOS_AUTH_TOKEN=VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=
    volumes:
      - ./standalone-logs/:/home/nacos/logs
    ports:
      - &quot;8848:8848&quot;
      - &quot;18080:8080&quot;       
  prometheus:
    container_name: prometheus
    image: prom/prometheus:latest
    volumes:
      - ./prometheus/prometheus-standalone.yaml:/etc/prometheus/prometheus.yml
    ports:
      - &quot;9090:9090&quot;
    depends_on:
      - nacos
    restart: on-failure
  grafana:
    container_name: grafana
    image: grafana/grafana:latest
    ports:
      - 3000:3000
    restart: on-failure
</code></pre>
<p>随后在桌面打开<code>cmd</code>输入<code>ipconfig</code>寻找ip地址 记录下来<br>在桌面右键 → 选择 <strong>Git Bash Here</strong>，进入 Bash 环境<br>在 Git Bash 里执行命令：【ip地址是通过ipconfig获取】**<u>这里要记得关闭梯子和代理 因为从阿里云拉镜像</u>**</p>
<pre><code class="yaml">curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.31.103:8848
</code></pre>
<p>★★</p>
<pre><code class="java">// 安装higress 进入bash
$ curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.43.85:8848 --nacos-username=nacos --nacos-password=nacos --nacos-ns=higress-system --nacos-ns=higress-system

       // 这里是启动的nacos
cd D:\nacos-docker-master\example
// 重启docker(Nacos)
docker-compose -f standalone-derby.yaml down
docker-compose -f standalone-derby.yaml up -d

// 一键重启
docker restart nacos-standalone

    
       // 这里是启动higress    
// 在桌面启一个bash  启动higress
$ /c/Users/Pluminary/Desktop/higress/bin/startup.sh
// 如果改了配置 在bash里  【一定要先启动docker 才可以干别的】
cd /c/Users/Pluminary/Desktop/higress
./bin/shutdown.sh
./bin/startup.sh
    
</code></pre>
<blockquote>
<h4 id="然后就一直无敌报错："><a href="#然后就一直无敌报错：" class="headerlink" title="然后就一直无敌报错："></a>然后就一直无敌报错：</h4><p><a target="_blank" rel="noopener" href="http://192.168.31.103:8848/nacos/v1/console/health/readiness">http://192.168.31.103:8848/nacos/v1/console/health/readiness</a> returns 000<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…<br>Waiting for Nacos to get ready…</p>
<p>修改端口不占用冲突的8080即可</p>
<p><code>cd D:\nacos-docker-master\example</code></p>
<p><strong>重启docker(Nacos)</strong><br><code>docker-compose -f standalone-derby.yaml down</code><br><code>docker-compose -f standalone-derby.yaml up -d</code></p>
<h4 id="一键重启"><a href="#一键重启" class="headerlink" title="一键重启"></a>一键重启</h4><p><code>docker restart nacos-standalone</code></p>
<hr>
<hr>
<hr>
<h4 id="下一个报错："><a href="#下一个报错：" class="headerlink" title="下一个报错："></a>下一个报错：</h4><p>Nacos is ready.<br>Initializing Nacos server…</p>
<p>Nacos 3.x isn’t fully supported yet.</p>
<p>If you do want to use Nacos 3.x, please add the following property into its application.properties file:<br>  nacos.core.api.compatibility.console.enabled&#x3D;true</p>
<p>Higress configuration failed with 255.<br>Failed to install Higress<br>        For support, go to <a target="_blank" rel="noopener" href="https://github.com/alibaba/higress">https://github.com/alibaba/higress</a>.</p>
<h6 id="这说明什么？"><a href="#这说明什么？" class="headerlink" title="这说明什么？"></a>这说明什么？</h6><ul>
<li>Higress 当前版本对 Nacos 3.x 支持不完善，需要兼容模式开启</li>
<li>你的 Nacos 3.x 服务默认没开启兼容控制台API，导致健康检查接口返回异常或空</li>
</ul>
<h4 id="1-修改-Nacos-配置，启用兼容模式"><a href="#1-修改-Nacos-配置，启用兼容模式" class="headerlink" title="1. 修改 Nacos 配置，启用兼容模式"></a>1. 修改 Nacos 配置，启用兼容模式</h4><p>找到你的 Nacos 容器中 <code>application.properties</code> 文件，添加下面这一行：</p>
<pre><code>nacos.core.api.compatibility.console.enabled=true
</code></pre>
<h4 id="2-重启-Nacos-容器"><a href="#2-重启-Nacos-容器" class="headerlink" title="2. 重启 Nacos 容器"></a>2. 重启 Nacos 容器</h4><pre><code>cd D:\nacos-docker-master\example
docker restart nacos-standalone
</code></pre>
<h4 id="3-访问健康接口测试"><a href="#3-访问健康接口测试" class="headerlink" title="3. 访问健康接口测试"></a>3. 访问健康接口测试</h4><pre><code class="java">curl http://192.168.43.85:8848/nacos/v1/console/health/readiness
</code></pre>
<p><span style="color:red"><strong>搞什么乱七八糟的配置 直接降级nacos 因为nacos3.xxx有很多不兼容的地方</strong><br></span><code>D:\nacos-docker-master\example</code>的<code>NACOS_VERSION=v2.3.1</code></p>
<pre><code class="yaml">Pluminary@Pluminary MINGW64 ~/Desktop
$ curl -fsSL https://higress.io/standalone/get-higress.sh | bash -s -- -c nacos://192.168.43.85:8848 --nacos-username=nacos --nacos-password=nacos --nacos-ns=higress-system 

Downloading https://github.com/higress-group/higress-
standalone/archive/refs/tags/v2.1.5.tar.gz...
==== Build Configurations ====
time=&quot;2025-07-12T00:40:46+08:00&quot; level=warning msg=&quot;C:\\Users\\Pluminary\\Desktop\\higress\\compose\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion&quot;
Nacos is ready.
Initializing Nacos server...
Use Nacos API v1
  Namespace higress-system already exists in Nacos.
  Fixed data encryption key is used. Skip config overwriting check.
Initializing API server configurations...
  Data encryption key already exists.
Initializing controller configurations...

 ___  ___  ___  ________  ________  _______   ________   ________
|\  \|\  \|\  \|\   ____\|\   __  \|\  ___ \ |\   ____\ |\   ____\
\ \  \\\  \ \  \ \  \___|\ \  \|\  \ \   __/|\ \  \___|_\ \  \___|_
 \ \   __  \ \  \ \  \  __\ \   _  _\ \  \_|/_\ \_____  \\ \_____  \
  \ \  \ \  \ \  \ \  \|\  \ \  \\  \\ \  \_|\ \|____|\  \\|____|\  \
   \ \__\ \__\ \__\ \_______\ \__\\ _\\ \_______\____\_\  \ ____\_\  \
    \|__|\|__|\|__|\|_______|\|__|\|__|\|_______|\_________\\_________\
                                                \|_________\|_________|

Higress is configured successfully.

Important Notes:
  Sensitive configurations are encrypted when saving to Nacos.
  When configuring another server with the same Nacos configuration service, please make sure to add the following argument so all servers use the same encryption key:
   

Usage:
  Start: /c/Users/Pluminary/Desktop/higress/bin/startup.sh
  Stop: /c/Users/Pluminary/Desktop/higress/bin/shutdown.sh
  View Component Statuses: /c/Users/Pluminary/Desktop/higress/bin/status.sh
  View Logs: /c/Users/Pluminary/Desktop/higress/bin/logs.sh
  Re-configure: /c/Users/Pluminary/Desktop/higress/bin/configure.sh -r

Happy Higressing!
</code></pre>
<p>访问Nacos：<a target="_blank" rel="noopener" href="http://192.168.31.103:8848/nacos/#/listeningToQuery?dataId=&group=&appName=&namespace=&namespaceShowName=public">Nacos</a> 或 地址改成localhost</p>
</blockquote>
<blockquote>
<h2 id="✅-配置项-1：secrets-nacos-auth-default"><a href="#✅-配置项-1：secrets-nacos-auth-default" class="headerlink" title="✅ 配置项 1：secrets.nacos-auth-default"></a>✅ 配置项 1：<code>secrets.nacos-auth-default</code></h2><h3 id="位置："><a href="#位置：" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code>（对应 <code>higress-system</code>）</li>
<li><strong>Data ID：</strong> <code>secrets.nacos-auth-default</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容："><a href="#配置内容：" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>username: nacos
password: nacos
</code></pre>
<hr>
<h2 id="✅-配置项-2：configmaps-higress-config"><a href="#✅-配置项-2：configmaps-higress-config" class="headerlink" title="✅ 配置项 2：configmaps.higress-config"></a>✅ 配置项 2：<code>configmaps.higress-config</code></h2><h3 id="位置：-1"><a href="#位置：-1" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code></li>
<li><strong>Data ID：</strong> <code>configmaps.higress-config</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容：-1"><a href="#配置内容：-1" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: higress-config
  namespace: higress-system
data:
  ingressClass: higress
</code></pre>
<hr>
<h2 id="✅-配置项-3：mcpbridges-default"><a href="#✅-配置项-3：mcpbridges-default" class="headerlink" title="✅ 配置项 3：mcpbridges.default"></a>✅ 配置项 3：<code>mcpbridges.default</code></h2><h3 id="位置：-2"><a href="#位置：-2" class="headerlink" title="位置："></a><strong>位置：</strong></h3><ul>
<li><strong>命名空间：</strong> <code>fc629691-b48f-4fa2-baa7-770dbaf8b63e</code></li>
<li><strong>Data ID：</strong> <code>mcpbridges.default</code></li>
<li><strong>Group：</strong> <code>DEFAULT_GROUP</code></li>
<li><strong>配置格式：</strong> <code>YAML</code></li>
</ul>
<h3 id="配置内容：-2"><a href="#配置内容：-2" class="headerlink" title="配置内容："></a><strong>配置内容：</strong></h3><pre><code>apiVersion: networking.higress.io/v1
kind: McpBridge
metadata:
  name: default
  namespace: higress-system
spec:
  registries:
    - domain: httpbin.org
      name: httpbin
      port: 80
      type: dns
</code></pre>
<pre><code class="yaml">./bin/configure.sh -a -c nacos://192.168.31.103:8848 \
  --nacos-username=nacos \
  --nacos-password=nacos \
  --nacos-ns=higress-system
</code></pre>
<h3 id="✅-解决方案：使用-r-参数强制重新配置"><a href="#✅-解决方案：使用-r-参数强制重新配置" class="headerlink" title="✅ 解决方案：使用 -r 参数强制重新配置"></a>✅ 解决方案：使用 <code>-r</code> 参数强制重新配置</h3><p>你需要<strong>强制重新执行配置流程并显式指定 nacos 命名空间</strong>，命令如下：</p>
<pre><code>bash复制编辑./bin/configure.sh -a -r \
  -c nacos://192.168.31.103:8848 \
  --nacos-username=nacos \
  --nacos-password=nacos \
  --nacos-ns=higress-system \
  -k 7bbac1c2ab91ff074cb8d219c307d203
</code></pre>
<p>📌 说明：</p>
<ul>
<li><code>-r</code>：重新运行配置流程（一定要加）</li>
<li><code>--nacos-ns=higress-system</code>：这才是决定配置写入哪个命名空间的参数</li>
<li><code>.env</code> 中的 <code>NACOS_NS</code> 虽然也有用，但以你命令参数为主</li>
</ul>
</blockquote>
<h3 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h3><p>RAG：接收到问题后，去知识库查资料，得到检索知识后进行回答<br>微调：提前学习知识，丰富自己的能力，接收到问题后进行回答</p>
<pre><code class="java">RAG → 问题 → (LLM+知识) → 回复
    
                   问题
                    ↓
微调 → LLM → 知识 → LLM(new)
               ↘    ↓
                   回复
</code></pre>
<h5 id="RAG工作原理："><a href="#RAG工作原理：" class="headerlink" title="RAG工作原理："></a>RAG工作原理：</h5><ul>
<li><p><strong>建立索引阶段</strong></p>
<p>文件上传 → 文档加载 → 内容分割 → 文本向量化 → 索引存储</p>
</li>
<li><p><strong>检索与生成阶段</strong></p>
<p><strong>检索</strong>：检索阶段会召回与问题最相关的文本段。通过embedding模型对问题进行文本向量化，并与向量数据库的段落进行语义相似度的比较，找出最相关的段落。<br><strong>生成</strong>：在检索到相关的文本段后，RAG应用会将问题与文本段通过提示词模板生成最终的提示词，由大模型生成回复，这个阶段更多是利用大模型的总结能力，而不是大模型本身具有的知识。</p>
</li>
<li><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>用户提问 →  → → → → →     提示词  → 大语言模型 → 输出答案<br>   ↘      →    内容检索   →       ↑</p>
</li>
</ul>
<pre><code class="java">com/fox/ragdemo/config/RagConfig.java
package com.fox.ragdemo.config;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.document.Document;
import org.springframework.ai.embedding.EmbeddingModel;
import org.springframework.ai.vectorstore.SimpleVectorStore;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class RagConfig &#123;

    @Bean
    ChatClient chatClient(ChatClient.Builder builder) &#123;
        return builder.defaultSystem(&quot;你将作为一名机器人产品的专家，对于用户的使用需求作出解答&quot;)
                .build();
    &#125;

    @Bean
    VectorStore vectorStore(EmbeddingModel embeddingModel) &#123;
        SimpleVectorStore simpleVectorStore = SimpleVectorStore.builder(embeddingModel)
                .build();

        // 生成一个机器人产品说明书的文档
        List&lt;Document&gt; documents = List.of(
                new Document(&quot;产品说明书:产品名称：智能机器人\n&quot; +
                        &quot;产品描述：智能机器人是一个智能设备，能够自动完成各种任务。\n&quot; +
                        &quot;功能：\n&quot; +
                        &quot;1. 自动导航：机器人能够自动导航到指定位置。\n&quot; +
                        &quot;2. 自动抓取：机器人能够自动抓取物品。\n&quot; +
                        &quot;3. 自动放置：机器人能够自动放置物品。\n&quot;));

        simpleVectorStore.add(documents);
        return simpleVectorStore;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/fox/ragdemo/controller/RagController.java
package com.fox.ragdemo.controller;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.client.advisor.QuestionAnswerAdvisor;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/ai&quot;)
public class RagController &#123;

    @Autowired
    private ChatClient chatClient;

    @Autowired
    private VectorStore vectorStore;


    @GetMapping(value = &quot;/chat&quot;, produces = &quot;text/plain; charset=UTF-8&quot;)
    public String generation(String userInput) &#123;
        // 发起聊天请求并处理响应
        return chatClient.prompt()
                .user(userInput)
                // 调用知识库
                .advisors(new QuestionAnswerAdvisor(vectorStore))
                .call()
                .content();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.fox.ragdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RagDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(RagDemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="RAG-阿里云百炼"><a href="#RAG-阿里云百炼" class="headerlink" title="RAG+阿里云百炼"></a>RAG+阿里云百炼</h3><h5 id="本地集成百炼智能体应用"><a href="#本地集成百炼智能体应用" class="headerlink" title="本地集成百炼智能体应用"></a>本地集成百炼智能体应用</h5><ul>
<li><strong>传统SpringBoot应用</strong>(Spring AI Alibaba) → <strong>百炼平台</strong>(智能体应用)</li>
<li>SpringBoot + Spring AI Alibaba接入RAG应用实战<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MO59zPv5OFtB01htIcIwwg">SpringBoot+Spring AI Alibaba接入RAG应用实战，让你的微服务应用具备智能化能力，小白也能快速上手</a></li>
</ul>
<h5 id="本地RAG应用集成百炼知识库"><a href="#本地RAG应用集成百炼知识库" class="headerlink" title="本地RAG应用集成百炼知识库"></a>本地RAG应用集成百炼知识库</h5><pre><code class="yaml">知识库：
【学校简介】
阳光中学创建于1998年，是一所全日制寄宿制完全中学，坐落于江苏省苏州市。学校占地120亩，现有教职工120人，学生1500余人。多年来，阳光中学秉持“厚德载物，知行合一”的校训，致力于培养具有国际视野与中国灵魂的复合型人才。
________________________________________
【课程设置】
阳光中学设有初中和高中两个学段，开设课程包括语文、数学、英语、物理、化学、生物、历史、地理、政治、信息技术、音乐、美术和体育等。高一开始分文理科方向，同时提供选修课程如Python编程、人工智能基础、商务英语等，满足学生多元发展需求。
________________________________________
【师资力量】
学校现有特级教师3人，高级教师32人，硕士学历以上教师占比达70%。其中语文学科带头人王老师曾获全国语文优质课一等奖，数学组组长李老师拥有15年以上高三教学经验，多次带出省级高考状元。
________________________________________
【校园生活】
阳光中学注重学生全面发展，组织丰富的课外活动与社团，如机器人社、合唱团、辩论社、摄影社、篮球队等。每年5月举办校园艺术节，每年10月举行运动会，深受师生喜爱。校园内有图书馆、自助餐厅、医务室、心理咨询室等完善设施。
________________________________________
【校规制度】
1.    学生必须穿着校服上课，不得迟到、早退或旷课；
2.    晚自习时间为每周一至周五18:30—20:30；
3.    禁止携带手机等电子产品进课堂；
4.    严禁在校园内打架、吸烟、喝酒，一经发现严肃处理；
5.    每月评选“文明班级”“学习标兵”等荣誉称号。
________________________________________
【招生信息】
阳光中学每年春季开始招生，面向全国招收初一、高一新生。招生名额有限，需通过笔试和面试。学费标准为初中部每学期6000元，高中部每学期8000元，另设有奖学金与助学金政策，家庭困难学生可申请减免。
________________________________________
【常见问题解答】
Q：阳光中学是否提供住宿？
A：学校提供标准化学生宿舍，6人一间，配备空调、热水器与独立卫生间，设有生活老师管理。
Q：学校是否提供营养餐？
A：学生餐厅提供三餐，包括荤素搭配的营养套餐，每周公布菜单，确保健康卫生。
Q：如何申请插班？
A：插班生需在每学期开学前一个月提交申请，学校将根据学位情况及考试成绩决定是否录取。
Q：学校对艺术体育特长生有优惠吗？
A：是的。学校每年招收部分艺术、体育特长生，可享受降分录取及奖学金政策。
________________________________________
【校园热点资讯】
2025年6月，阳光中学高考再创佳绩，重本上线率达89%，其中7人被清华北大录取；
2025年3月，阳光中学学生在全国青少年人工智能竞赛中获得一等奖；
2024年10月，学校新建科学楼正式启用，建筑面积达4800平方米，配备多个功能实验室。
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\bailian-agent\src\main\java\com\fox\bailianagent\controller\BailianAgentRagController.java
package com.fox.bailianagent.controller;

import com.alibaba.cloud.ai.dashscope.agent.DashScopeAgent;
import com.alibaba.cloud.ai.dashscope.agent.DashScopeAgentOptions;
import com.alibaba.cloud.ai.dashscope.api.DashScopeAgentApi;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BailianAgentRagController &#123;
  private DashScopeAgent agent;

  @Value(&quot;$&#123;spring.ai.dashscope.agent.app-id&#125;&quot;)
  private String appId;

  public BailianAgentRagController(DashScopeAgentApi dashscopeAgentApi) &#123;
    this.agent = new DashScopeAgent(dashscopeAgentApi);
  &#125;

  @GetMapping(&quot;/bailian/agent/call&quot;)
  public String call(@RequestParam(value = &quot;message&quot;) String message) &#123;
    ChatResponse response = agent.call(
            new Prompt(message, DashScopeAgentOptions.builder()
                    // 与智能体的绑定
                    .withAppId(appId)
                    .build()));
    AssistantMessage app_output = response.getResult().getOutput();
    return app_output.getText();
  &#125;
&#125;

GET：http://localhost:8088/bailian/agent/call
message  学校简介是什么？
</code></pre>
<pre><code class="java">package com.fox.bailianagent;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BailianAgentApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(BailianAgentApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">server:
  port: 8088

spring:
  application:
    name: bailian-agent
  ai:
    dashscope:
      agent:
# https://bailian.console.aliyun.com/?tab=app#/app-center
        app-id: xxxxxxx
      api-key: xxxxxxx
</code></pre>
<h3 id="SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库"><a href="#SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库" class="headerlink" title="SpringAIAlibaba本地集成百炼知识库实战通过代码将文件上传到百炼知识库"></a>SpringAIAlibaba本地集成百炼知识库实战<del>通过代码将文件上传到百炼知识库</del></h3><pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.controller;

import com.fox.bailianragdemo.service.RagService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping(&quot;/ai&quot;)
public class CloudRagController &#123;

    private final RagService cloudRagService;

    public CloudRagController(RagService cloudRagService) &#123;
        this.cloudRagService = cloudRagService;
    &#125;

    @GetMapping(&quot;/bailian/knowledge/importDocument&quot;)
    public void importDocument() &#123;
        cloudRagService.importDocuments();
    &#125;

    @GetMapping(&quot;/bailian/knowledge/generate&quot;)
    public Flux&lt;String&gt; generate(@RequestParam(value = &quot;message&quot;,
            defaultValue = &quot;你好，请问你的知识库文档主要是关于什么内容的?&quot;) String message) &#123;
        return cloudRagService.retrieve(message).map(x -&gt; x.getResult().getOutput().getText());
    &#125;

&#125;
</code></pre>
<pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.service;

import com.alibaba.cloud.ai.advisor.DocumentRetrievalAdvisor;
import com.alibaba.cloud.ai.dashscope.api.DashScopeApi;
import com.alibaba.cloud.ai.dashscope.rag.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.document.Document;
import org.springframework.ai.document.DocumentReader;
import org.springframework.ai.rag.retrieval.search.DocumentRetriever;
import org.springframework.ai.vectorstore.VectorStore;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;


@Service()
public class CloudRagService implements RagService &#123;

    private static final Logger logger = LoggerFactory.getLogger(CloudRagService.class);

    private static final String indexName = &quot;阳光中学&quot;;

    @Value(&quot;classpath:/data/spring_ai_alibaba_quickstart.pdf&quot;)
    private Resource springAiResource;

    private static final String retrievalSystemTemplate = &quot;&quot;&quot;
            上下文信息如下:
            ---------------------
            &#123;question_answer_context&#125;
            ---------------------
            根据上下文和提供的历史信息，而不是先验知识,回答用户问题。
            如果答案不在上下文中，请告知用户无法回答该问题。
            &quot;&quot;&quot;;

    private final ChatClient chatClient;

    private final DashScopeApi dashscopeApi;

    public CloudRagService(ChatClient.Builder builder, DashScopeApi dashscopeApi) &#123;
        DocumentRetriever retriever = new DashScopeDocumentRetriever(dashscopeApi,
                DashScopeDocumentRetrieverOptions.builder().withIndexName(indexName).build());

        this.dashscopeApi = dashscopeApi;
        this.chatClient = builder
                .defaultAdvisors(new DocumentRetrievalAdvisor(retriever, retrievalSystemTemplate))
                .build();
    &#125;

    @Override
    public void importDocuments() &#123;
        String path = saveToTempFile(springAiResource);

        // 1. import and split documents
        DocumentReader reader = new DashScopeDocumentCloudReader(path, dashscopeApi, null);
        List&lt;Document&gt; documentList = reader.get();
        logger.info(&quot;&#123;&#125; documents loaded and split&quot;, documentList.size());

        // 1. add documents to DashScope cloud storage 向量数据库
        VectorStore vectorStore = new DashScopeCloudStore(dashscopeApi, new DashScopeStoreOptions(indexName));
        vectorStore.add(documentList);
        logger.info(&quot;&#123;&#125; documents added to dashscope cloud vector store&quot;, documentList.size());
    &#125;

    private String saveToTempFile(Resource springAiResource) &#123;
        try &#123;
            File tempFile = File.createTempFile(&quot;spring_ai_alibaba_quickstart&quot;, &quot;.pdf&quot;);
            tempFile.deleteOnExit();

            try (InputStream inputStream = springAiResource.getInputStream();
                    FileOutputStream outputStream = new FileOutputStream(tempFile)) &#123;
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) &#123;
                    outputStream.write(buffer, 0, bytesRead);
                &#125;
            &#125;

            return tempFile.getAbsolutePath();
        &#125;
        catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public Flux&lt;ChatResponse&gt; retrieve(String message) &#123;
        return chatClient.prompt().user(message).stream().chatResponse();
    &#125;

&#125;
</code></pre>
<pre><code class="java">/*
* Copyright 2024 the original author or authors.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package com.fox.bailianragdemo.service;

import org.springframework.ai.chat.model.ChatResponse;
import reactor.core.publisher.Flux;


public interface RagService &#123;

    void importDocuments();

    Flux&lt;ChatResponse&gt; retrieve(String message);
&#125;
</code></pre>
<pre><code class="yaml">server:
  port: 8088

spring:
  application:
    name: bailian-rag-demo
  ai:
    dashscope:
      api-key: xxxxx
</code></pre>
<h3 id="工具Fuction-Calling"><a href="#工具Fuction-Calling" class="headerlink" title="工具Fuction Calling"></a>工具Fuction Calling</h3><p>允许语言大模型调用外部函数(Function)或API来执行特定任务或获取实时数据。<br>例如：<br>调用天气API查询实时天气。<br>调用数据库接口执行查询。 其核心是扩展模型的交互能力，使其能执行操作或获取结构化数据，而非仅依赖内部知识</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><p>实时数据查询：如股票行情、天气、航班信息。<br>任务自动化：预订会议、下单、数据计算等。<br>系统集成：与CRM、ERP等业务系统交互（如创建客户记录）</p>
<h6 id="和RAG的区别"><a href="#和RAG的区别" class="headerlink" title="和RAG的区别"></a>和RAG的区别</h6><p>RAG和Function Calling分别从知识增强和功能扩展两个维度提升LLM能力。选择取决于具体需求：</p>
<ul>
<li>需结合外部知识？ → RAG</li>
<li>需执行操作或获取实时数据？ → Function Calling</li>
<li>复杂场景：两者结合（如Agent框架中集成RAG和工具调用）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">RAG</th>
<th align="center">Function Calling</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据依赖</td>
<td align="center">依赖外部知识库的覆盖和质量</td>
<td align="center">依赖API或函数的可用性和稳定性</td>
</tr>
<tr>
<td align="center">实时性</td>
<td align="center">受限于知识库更新频率</td>
<td align="center">可获取实时数据(如API返回结果)</td>
</tr>
<tr>
<td align="center">输出形式</td>
<td align="center">自然语言文本</td>
<td align="center">结构化数据(Json)或操作结果</td>
</tr>
<tr>
<td align="center">适用问题类型</td>
<td align="center">需外部知识支持的复杂问题</td>
<td align="center">需执行操作或获取动态数据的场景</td>
</tr>
<tr>
<td align="center">实现复杂度</td>
<td align="center">需构建高效检索系统(向量数据库)</td>
<td align="center">需定义函数接口和参数规范</td>
</tr>
</tbody></table>
<h3 id="Function-Calling获取天气信息"><a href="#Function-Calling获取天气信息" class="headerlink" title="Function Calling获取天气信息"></a>Function Calling获取天气信息</h3><h6 id="以Function为接口调用apply方法"><a href="#以Function为接口调用apply方法" class="headerlink" title="以Function为接口调用apply方法"></a>以Function为接口调用apply方法</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\function\WeatherFunction.java

package com.fox.toolcallingdemo.tool.weather.function;

import java.util.function.Function;

public class WeatherFunction implements Function&lt;WeatherFunction.WeatherRequest, String&gt; &#123;
    @Override
    public String apply(WeatherRequest request) &#123;
        // 此处省略了实际的天气查询逻辑，直接返回一个示例字符串
        // 实际应用中需要根据请求参数调用天气API获取天气信息
        return &quot;The weather in &quot; + request.getCity() + &quot; is sunny.&quot;;
    &#125;
    public static class WeatherRequest &#123;
        private String city;
        public String getCity() &#123; return city; &#125;
        public void setCity(String city) &#123; this.city = city; &#125;
    &#125;
&#125;
</code></pre>
<h6 id="把函数以Bean形式交给Spring去管理"><a href="#把函数以Bean形式交给Spring去管理" class="headerlink" title="把函数以Bean形式交给Spring去管理"></a>把函数以Bean形式交给Spring去管理</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\function\FunctionConfig.java
    
package com.fox.toolcallingdemo.tool.weather.function;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Description;

import java.util.function.Function;

@Configuration
public class FunctionConfig &#123;
    @Bean
    // 标识
    @Description(&quot;获取指定城市的天气信息&quot;)
    public Function&lt;WeatherFunction.WeatherRequest, String&gt; weatherFunction() &#123;
        return new WeatherFunction();
    &#125;
&#125;
</code></pre>
<h6 id="告诉大模型请求可以调函数"><a href="#告诉大模型请求可以调函数" class="headerlink" title="告诉大模型请求可以调函数"></a>告诉大模型请求可以调函数</h6><pre><code class="java">package com.fox.toolcallingdemo.controller;


import com.fox.toolcallingdemo.tool.weather.method.WeatherTool;
import com.fox.toolcallingdemo.tool.weather.method.WeatherToolImpl;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/weather&quot;)
public class WeatherController &#123;

    private final ChatClient dashScopeChatClient;

    /**
    * 默认全局调函数
    */
    public WeatherController(ChatClient.Builder chatClientBuilder) &#123;
        this.dashScopeChatClient = chatClientBuilder
                .defaultFunctions(&quot;weatherFunction&quot;)
                //.defaultTools(new WeatherToolImpl())
                .build();
    &#125;
-------------------------------------------------------------------------------------
    /**
     * 无工具版
     */
    @GetMapping(&quot;/chat&quot;)
    public String simpleChat(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;
        return dashScopeChatClient.prompt(query).call().content();
    &#125;
-------------------------------------------------------------------------------------
    /**
     * 调用工具版 - function
     */
    @GetMapping(&quot;/chat-tool-function&quot;)
    public String chatTranslateFunction(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;

    // 就可以去找刚刚函数构建的bean
        return dashScopeChatClient.prompt(query).functions(&quot;weatherFunction&quot;).call().content();
    &#125;

-------------------------------------------------------------------------------------

    /**
     * 调用工具版 - method
     */
    @GetMapping(&quot;/chat-tool-method&quot;)
    public String chatTranslateMethod(@RequestParam(value = &quot;query&quot;, defaultValue = &quot;北京今天的天气&quot;) String query) &#123;

        return dashScopeChatClient.prompt(query).tools(new WeatherToolImpl()).call().content();
    &#125;
&#125;

GET：http://localhost:8088/weather/chat-tool-method
query  深圳今天的天气怎么样？
</code></pre>
<h6 id="承接上面最后一个Method版"><a href="#承接上面最后一个Method版" class="headerlink" title="承接上面最后一个Method版"></a>承接上面最后一个Method版</h6><pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\method\WeatherTool.java
package com.fox.toolcallingdemo.tool.weather.method;

public interface WeatherTool &#123;
    String getWeather(String city);
&#125;
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\HouDuan\ai-demo\toolcalling-demo\src\main\java\com\fox\toolcallingdemo\tool\weather\method\WeatherToolImpl.java
package com.fox.toolcallingdemo.tool.weather.method;


import org.springframework.ai.tool.annotation.Tool;

public class WeatherToolImpl implements WeatherTool &#123;
    @Override
    @Tool(description = &quot;获取指定城市的天气信息。&quot;)
    public String getWeather(String city) &#123;
        return &quot;The weather in &quot; + city + &quot; is sunny.&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="MCP协议"><a href="#MCP协议" class="headerlink" title="MCP协议"></a>MCP协议</h3><p>模型上下文协议（即 Model Context Protocol，MCP）是一个开放协议，它规范了应用程序如何向大型语言模型（LLM）提供上下文。MCP 提供了一种统一的方式将 AI 模型连接到不同的数据源和工具，它定义了统一的集成方式。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7ee928d5d4f2a3c021548c45f038914f81673875/SpringAI_MCP-2.png" alt="MCP图+与function_calling区别"></p>
<h3 id="百炼智能体应用接入高德地图MCP服务"><a href="#百炼智能体应用接入高德地图MCP服务" class="headerlink" title="百炼智能体应用接入高德地图MCP服务"></a>百炼智能体应用接入高德地图MCP服务</h3><p><a target="_blank" rel="noopener" href="https://bailian.console.aliyun.com/?tab=app#/app-center/assistant/6f624944e0334768aa4d3a014f5a9913">大模型服务平台百炼控制台</a><br>在智能体应用的<strong>技能</strong>添加<strong>MCP服务</strong> <code>Amap Maps</code>需要提前开通即可</p>
<h3 id="MCP开发实战"><a href="#MCP开发实战" class="headerlink" title="MCP开发实战"></a>MCP开发实战</h3><h5 id="模型上下文协议（Model-Context-Protocol）"><a href="#模型上下文协议（Model-Context-Protocol）" class="headerlink" title="模型上下文协议（Model Context Protocol）"></a>模型上下文协议（Model Context Protocol）</h5><h5 id="MCP-简介"><a href="#MCP-简介" class="headerlink" title="MCP 简介"></a>MCP 简介</h5><p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/">模型上下文协议（即 Model Context Protocol，MCP）</a>是一个开放协议，它规范了应用程序如何向大型语言模型（LLM）提供上下文。MCP 提供了一种统一的方式将 AI 模型连接到不同的数据源和工具，它定义了统一的集成方式。在开发智能体（Agent）的过程中，我们经常需要将将智能体与数据和工具集成，MCP 以标准的方式规范了智能体与数据及工具的集成方式，可以帮助您在 LLM 之上构建智能体（Agent）和复杂的工作流。目前已经有大量的服务接入并提供了 MCP server 实现，当前这个生态正在以非常快的速度不断的丰富中，具体可参见：<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers">MCP Servers</a>。</p>
<h5 id="Spring-AI-MCP"><a href="#Spring-AI-MCP" class="headerlink" title="Spring AI MCP"></a>Spring AI MCP</h5><p>Spring AI MCP 为模型上下文协议提供 Java 和 Spring 框架集成。它使 Spring AI 应用程序能够通过标准化的接口与不同的数据源和工具进行交互，支持同步和异步通信模式。</p>
<p>Spring AI MCP 采用模块化架构，包括以下组件：</p>
<ul>
<li>Spring AI 应用程序：使用 Spring AI 框架构建想要通过 MCP 访问数据的生成式 AI 应用程序</li>
<li>Spring MCP 客户端：MCP 协议的 Spring AI 实现，与服务器保持 1:1 连接</li>
<li>MCP 服务器：轻量级程序，每个程序都通过标准化的模型上下文协议公开特定的功能</li>
<li>本地数据源：MCP 服务器可以安全访问的计算机文件、数据库和服务</li>
<li>远程服务：MCP 服务器可以通过互联网（例如，通过 API）连接到的外部系统</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>要启用此功能，请将以下依赖项添加到您项目的 Maven<code>pom.xml</code>文件中：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-mcp&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>或者添加到您的 Gradle<code>build.gradle</code>文件中：</p>
<pre><code class="xml">dependencies &#123;
    implementation &#39;org.springframework.experimental:spring-ai-mcp:1.0.0&#39;
&#125;
</code></pre>
<p>Spring AI MCP 目前并没有在 Maven Central Repository 中提供。需要将 <code>Spring milestone</code>仓库添加到<code>pom.xml</code>中，才可以访问 Spring AI MCP 工件：</p>
<pre><code class="xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-milestones&lt;/id&gt;
    &lt;name&gt;Spring Milestones&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;
    &lt;snapshots&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/snapshots&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p>要使用 MCP，首先需要创建<code>McpClient</code>，它提供了与 MCP server 的同步和异步通信能力。现在我们创建一个 McpClient 来注册 MCP Brave 服务和 ChatClient，从而让 LLM 调用它们：</p>
<pre><code class="java">var stdioParams = ServerParameters.builder(&quot;npx&quot;)
        .args(&quot;-y&quot;, &quot;@modelcontextprotocol/server-brave-search&quot;)
        .addEnvVar(&quot;BRAVE_API_KEY&quot;, System.getenv(&quot;BRAVE_API_KEY&quot;))
        .build();

var mcpClient = McpClient.using(new StdioClientTransport(stdioParams)).sync();

var init = mcpClient.initialize();

var chatClient = chatClientBuilder
        .defaultFunctions(mcpClient.listTools(null)
                .tools()
                .stream()
                .map(tool -&gt; new McpFunctionCallback(mcpClient, tool))
                .toArray(McpFunctionCallback[]::new))
        .build();

String response = chatClient
        .prompt(&quot;Does Spring AI supports the Model Context Protocol? Please provide some references.&quot;)
        .call().content();
</code></pre>
<p>在上述代码中，首先通过<code>npx</code>命令启动一个独立的进程，运行<code>@modelcontextprotocol/server-brave-search</code>服务，并指定 Brave API 密钥。然后创建一个基于 stdio 的传输层，与 MCP server 进行通信。最后初始化与 MCP 服务器的连接。</p>
<p>要使用 McpClient，需要将<code>McpClient</code>注入到 Spring AI 的<code>ChatClient</code>中，从而让 LLM 调用 MCP server。在 Spring AI 中，可以通过 Function Callbacks 的方式将 MCP 工具转换为 Spring AI 的 Function，从而让 LLM 调用。</p>
<p>最后，通过<code>ChatClient</code>与 LLM 进行交互，并使用<code>McpClient</code>与 MCP server 进行通信，获取最终的返回结果。</p>
<p><strong>官方的alibaba服务教学</strong>：<code>C:\Users\Pluminary\Desktop\HouDuan\spring-ai-alibaba-examples</code></p>
<h5 id="Stdio传输层"><a href="#Stdio传输层" class="headerlink" title="Stdio传输层"></a>Stdio传输层</h5><p>Stdio(标准输入输出) 传输层是MCP最基本的传输实现方式。它通过进程间通信(IPC)实现</p>
<h5 id="SSE传输层"><a href="#SSE传输层" class="headerlink" title="SSE传输层"></a>SSE传输层</h5><p>SSE(Server-Sent Events) 传输层是基于HTTP的单向通信机制，专门用于服务器向客户端推送数据</p>
<h3 id="MCP是什么？和Function-calling有什么区别？美团面试题"><a href="#MCP是什么？和Function-calling有什么区别？美团面试题" class="headerlink" title="MCP是什么？和Function calling有什么区别？美团面试题"></a>MCP是什么？和Function calling有什么区别？<del>美团面试题</del></h3><p>MCP可以通过Client指定SSE 再去找一个远程地址直接就可以调用<del>MCP就像拓展坞，MCPServer可以部署到云端给外部使用</del><br>Function Calling则需要自己手动去写一个去调用外部</p>
<blockquote>
<p>这道面试题问的是：</p>
<blockquote>
<p><strong>MCP 是什么？它和 Function Calling 有什么区别？</strong></p>
</blockquote>
<p>来自美团，很可能是在考察你对 <strong>大模型应用框架</strong>（尤其是 RAG、工具调用、Agent 框架等）底层机制的理解，特别是近几年阿里推出的 Spring AI Alibaba MCP 模型调用框架。</p>
<hr>
<h2 id="✅-一、什么是-MCP？"><a href="#✅-一、什么是-MCP？" class="headerlink" title="✅ 一、什么是 MCP？"></a>✅ 一、什么是 MCP？</h2><p><strong>MCP（Model Call Protocol）</strong> 是阿里巴巴在 <a target="_blank" rel="noopener" href="https://github.com/springaialibaba/spring-ai-alibaba">Spring AI Alibaba</a> 框架中提出的一个模型调用协议，全称是：</p>
<blockquote>
<p><strong>Model Call Protocol（模型调用协议）</strong></p>
</blockquote>
<p>它的作用是：<br> 🔧 <strong>统一模型接入规范</strong>，为不同的大模型（阿里通义、百度文心、ChatGLM、文生图、图生图等）提供一套<strong>通用、标准、结构化的调用协议和扩展机制</strong>。</p>
<h3 id="✅-MCP-解决的问题："><a href="#✅-MCP-解决的问题：" class="headerlink" title="✅ MCP 解决的问题："></a>✅ MCP 解决的问题：</h3><ul>
<li>🌀 不同大模型调用方式、参数格式五花八门 → MCP 提供统一接口抽象</li>
<li>🛠 支持插件工具调用（Tool Calling）</li>
<li>🔁 支持多轮对话记忆</li>
<li>🤖 支持 Agent 架构（例如 RAG、Function调用等）</li>
<li>📦 可以灵活切换底层大模型，实现模型无感知迁移（例如将通义大模型无缝替换为文心一言）</li>
</ul>
<hr>
<h3 id="✅-MCP-的核心组件："><a href="#✅-MCP-的核心组件：" class="headerlink" title="✅ MCP 的核心组件："></a>✅ MCP 的核心组件：</h3><ol>
<li><code>MCPModel</code>：统一的模型接口（封装了 prompt 处理、调用逻辑等）</li>
<li><code>MCPFunctionCallingModel</code>：支持 Function Calling 的模型</li>
<li><code>MCPMessage</code>、<code>MCPResponse</code>：统一的输入&#x2F;输出数据结构</li>
<li><code>ToolDefinition</code>, <code>FunctionCall</code>, <code>ToolResult</code>：对工具调用结构化建模</li>
</ol>
<hr>
<h2 id="✅-二、什么是-Function-Calling？"><a href="#✅-二、什么是-Function-Calling？" class="headerlink" title="✅ 二、什么是 Function Calling？"></a>✅ 二、什么是 Function Calling？</h2><p>Function Calling 是由 OpenAI 提出的技术，后被各大模型厂商采纳（如通义千问、百度文心也支持），它让大模型在对话中能够调用外部函数。</p>
<h3 id="🔧-它的核心概念："><a href="#🔧-它的核心概念：" class="headerlink" title="🔧 它的核心概念："></a>🔧 它的核心概念：</h3><ul>
<li>大模型通过识别语义内容，决定是否调用一个函数（例如查天气、查数据库、生成图片等）</li>
<li>由用户预定义函数列表（Function Schema），模型根据意图选择调用</li>
<li>返回结构化 JSON 给开发者，由程序调用实际函数 → 执行后返回结果给模型</li>
</ul>
<hr>
<h3 id="✅-Function-Calling-实现的能力："><a href="#✅-Function-Calling-实现的能力：" class="headerlink" title="✅ Function Calling 实现的能力："></a>✅ Function Calling 实现的能力：</h3><table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>工具接入能力</td>
<td>让模型“用工具”去扩展知识或能力，如查资料、查库存、操作系统等</td>
</tr>
<tr>
<td>多轮调用链</td>
<td>支持调用链组合，如 A→B→C 的流程式工具使用</td>
</tr>
<tr>
<td>Agent能力基础</td>
<td>是 Agent 能够链式思维和计划任务执行的基础</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-三、MCP-和-Function-Calling-的关系与区别"><a href="#✅-三、MCP-和-Function-Calling-的关系与区别" class="headerlink" title="✅ 三、MCP 和 Function Calling 的关系与区别"></a>✅ 三、MCP 和 Function Calling 的关系与区别</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>MCP</th>
<th>Function Calling</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>一种大模型调用<strong>协议标准</strong></td>
<td>一种大模型的<strong>工具调用机制</strong></td>
</tr>
<tr>
<td>是否支持 Function</td>
<td>✅ 支持，MCP 中内置了 Function Calling 抽象</td>
<td>✅ 只关注“函数调用”，不管模型接入细节</td>
</tr>
<tr>
<td>作用范围</td>
<td>📦 模型统一封装、RAG、Chat、工具调用、记忆、代理等（整个调用框架）</td>
<td>🧠 模型如何调用函数、如何组织工具返回</td>
</tr>
<tr>
<td>抽象程度</td>
<td>高度抽象框架层，统一输入输出模型、适配各类模型</td>
<td>相对底层，是大模型的<strong>功能点</strong></td>
</tr>
<tr>
<td>使用者</td>
<td>开发框架作者（如 Spring AI Alibaba）</td>
<td>模型厂商、应用开发者</td>
</tr>
<tr>
<td>代表项目</td>
<td>Spring AI Alibaba MCP、LangChain4j MCP、百度文心 RAGFlow 等</td>
<td>OpenAI GPT、通义千问、ChatGLM、Claude 等支持 Function Calling 的模型</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-四、通俗比喻理解"><a href="#✅-四、通俗比喻理解" class="headerlink" title="✅ 四、通俗比喻理解"></a>✅ 四、通俗比喻理解</h2><blockquote>
<p>MCP 是一个大楼的 <strong>“总控中心”</strong>，可以调配各种大模型、工具、记忆、插件等资源</p>
<p>Function Calling 是这个大楼里的一套 <strong>“智能工具调度系统”</strong>，专门处理“这个请求要不要调用某个工具来完成”。</p>
</blockquote>
<hr>
<h2 id="✅-五、实际应用举例（代码层）"><a href="#✅-五、实际应用举例（代码层）" class="headerlink" title="✅ 五、实际应用举例（代码层）"></a>✅ 五、实际应用举例（代码层）</h2><p>在 Spring AI Alibaba 中，你可以这样使用 MCP + FunctionCalling：</p>
<pre><code>@Autowired
private FunctionCallingChatClient chatClient;

@PostMapping(&quot;/chat&quot;)
public String chat(@RequestBody String prompt) &#123;
    Message response = chatClient.call(
        Message.of(prompt),
        FunctionCallingOptions.builder()
            .function(ToolDefinitions.fromClass(MyFunction.class))
            .build()
    );
    return response.getContent();
&#125;
</code></pre>
<p>上面这段代码：</p>
<ul>
<li>使用 MCP 提供的 <code>FunctionCallingChatClient</code> 调用大模型</li>
<li>绑定了一个 Function（MyFunction），模型根据上下文会自动决定是否调用它</li>
</ul>
<hr>
<h2 id="✅-总结答法（面试简明说法）："><a href="#✅-总结答法（面试简明说法）：" class="headerlink" title="✅ 总结答法（面试简明说法）："></a>✅ 总结答法（面试简明说法）：</h2><blockquote>
<p>MCP 是阿里推出的模型调用协议，统一了模型接入、工具调用、Agent 调度等能力，是一种面向“统一模型开发框架”的抽象；Function Calling 是大模型的一种能力，允许它根据语义调用结构化函数。MCP 包含了 Function Calling 能力，但它作用更广，面向的是整套大模型调用生命周期，Function Calling 则聚焦在“如何让模型使用外部函数”这件事上。</p>
</blockquote>
</blockquote>
<h2 id="电商智能客服项目"><a href="#电商智能客服项目" class="headerlink" title="电商智能客服项目"></a><span style ="color:red">电商智能客服项目</span></h2><h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><p><code>JDK17、SpringBoot3.4.0、Spring AI 1.0.0-M6、Spring AI Alibaba 1.0.0-M6.1</code></p>
<h5 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/105e0b2c60fafdf49943dd1fc8283011dacbc1fb/%E7%94%B5%E5%95%86%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF.png"></p>
<p><strong>项目位于</strong>：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai</code><br><strong>前端</strong>位于：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai\frontend</code></p>
<blockquote>
<p>可以右键通过终端打开文件夹<br>①：yarn install    安装依赖<br>②：yarn dev        启动项目</p>
</blockquote>
<p><strong>后端</strong>位于：<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order</code>【order.sql也在这里】；<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-ai</code>分别启动两个模块的<code>Application</code></p>
<h4 id="使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装"><a href="#使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装" class="headerlink" title="使用MCP调用订单服务查询订单详情MCPServer是对订单层的包装"></a>使用MCP调用订单服务查询订单详情<del>MCPServer是对订单层的包装</del></h4><p>项目位于<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order-mcp-client</code>；<code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order-mcp-server</code><br><code>C:\Users\Pluminary\Desktop\HouDuan\ai-demo\tlmall-order</code></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>