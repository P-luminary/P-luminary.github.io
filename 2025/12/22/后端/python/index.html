
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || python</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>python </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/12/22
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#879cff>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul>
<li>整数 int</li>
<li>浮点数 float</li>
<li>复数 complex</li>
<li>布尔 bool</li>
</ul>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul>
<li>str</li>
</ul>
<h5 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h5><ul>
<li>列表 list</li>
<li>元组 tuple</li>
<li>集合 set</li>
<li>字典 dict</li>
</ul>
<h5 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h5><ul>
<li>None</li>
</ul>
<h5 id="上述类型中"><a href="#上述类型中" class="headerlink" title="上述类型中"></a>上述类型中</h5><ul>
<li>不可变的有：数值、字符串、元组</li>
<li>可变的类型有：列表、集合、字典</li>
</ul>
<h5 id="如果数字比较大，可使用下划线将其中的数字分组，使其更清晰易读。"><a href="#如果数字比较大，可使用下划线将其中的数字分组，使其更清晰易读。" class="headerlink" title="如果数字比较大，可使用下划线将其中的数字分组，使其更清晰易读。"></a>如果数字比较大，可使用下划线将其中的数字分组，使其更清晰易读。</h5><pre><code class="python">num1 = 1_000_000_000_000_000
print(num1)  # 1000000000000000
</code></pre>
<h5 id="type-与-isinstance-类型判断"><a href="#type-与-isinstance-类型判断" class="headerlink" title="type 与 isinstance 类型判断"></a>type 与 isinstance 类型判断</h5><p>可以使用 type() 来查看变量类型，使用 isinstance() 来判断变量类型。<br>type() 和 isinstance() 的区别在于 type() 不会认为子类是一种父类类型，isinstance() 会认为子类是一种父类类型。</p>
<pre><code class="python">num1 = True
num2 = 10
print(type(num1))  # &lt;class &#39;bool&#39;&gt;
print(type(num2))  # &lt;class &#39;int&#39;&gt;
print(type(num1) == type(num2))  # False
print(isinstance(num1, bool))  # True
print(isinstance(num1, int))  # True，Python3中，bool是int的子类
print(isinstance(num2, int))  # True
</code></pre>
<p><strong>小整数池</strong></p>
<p>Python将 [-5, 256] 的整数维护在小整数对象池中。这些整数提前创建好且不会被垃圾回收，避免了为整数频繁申请和销毁内存空间。不管在程序的什么位置，使用的位于这个范围内的整数都是同一个对象。</p>
<p><strong>大整数池</strong><br>一开始大整数池为空，每创建一个大整数就会向池中存储一个。</p>
<p>不同的 Python 实现：小整数池的范围和实现细节可能因 Python 的不同实现（如 CPython、Jython、IronPython 等）而有所不同。上述提到的[-5, 256]范围是 CPython 的默认实现。</p>
<p>有时连续赋值的相同大整数也可能指向同一对象，这是因为Python环境的优化机制,但是这个优化不是绝对的，也取决于解释器以及交互式以及脚本环境。</p>
<p><strong>float浮点型</strong></p>
<p>Python将所有带小数点的数称为浮点数。要注意在使用浮点数进行计算时可能会存在微小误差，可以通过导入<strong>decimal</strong>解决</p>
<pre><code class="python">num1 = 0.1
num2 = 0.2
print(num1 + num2)  # 0.30000000000000004
from decimal import Decimal
num3 = Decimal(&#39;1.0&#39;)
num4 = Decimal(&#39;0.9&#39;)
print(num3-num4)

也可以使用科学计数法表示浮点数。
num1 = 1.3e7
print(num1)  # 13000000.0
</code></pre>
<p>在Python中，能够解释为假的值不只有False，还有：</p>
<ul>
<li>None、0、0.0、False、所有的空容器（空列表、空元组、空字典、空集合、空字符串）</li>
</ul>
<p>为了解决浮点数丢失精度情况，可以借助py其他模块提供的功能</p>
<p><code>from decimal import Decimal</code></p>
<h6 id="bool是int的子类型，可以和整数进行运算"><a href="#bool是int的子类型，可以和整数进行运算" class="headerlink" title="bool是int的子类型，可以和整数进行运算"></a>bool是int的子类型，可以和整数进行运算</h6><p><code>num1 = True    print(num1 + 10)</code></p>
<table>
<thead>
<tr>
<th><em><strong>*转义字符*</strong></em></th>
<th><em><strong>*说明*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>在行尾作为续行符</td>
</tr>
<tr>
<td>\ \</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\ ‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\ “</td>
<td>双引号</td>
</tr>
<tr>
<td><em><strong>*\b*</strong></em></td>
<td>退格</td>
</tr>
<tr>
<td><em><strong>*\n*</strong></em></td>
<td>换行</td>
</tr>
<tr>
<td><em><strong>*\t*</strong></em></td>
<td>横向制表符</td>
</tr>
<tr>
<td><em><strong>*\r*</strong></em></td>
<td>回车，回到行首</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><em><strong>*函数*</strong></em></th>
<th><em><strong>*说明*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>*int(x [,base])*</strong></em></td>
<td>将x转换为一个整数，x若为字符串可用base指定进制</td>
</tr>
<tr>
<td><em><strong>*float(x)*</strong></em></td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td><em><strong>*complex(real[,imag])*</strong></em></td>
<td>创建一个实部为real，虚部为imag的复数</td>
</tr>
<tr>
<td><em><strong>*str(x)*</strong></em></td>
<td>将对象x转换为一个字符串</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象x转换为一个字符串，可以转义字符串中的特殊字符</td>
</tr>
<tr>
<td><em><strong>*eval(x)*</strong></em></td>
<td>执行x字符串表达式，并返回表达式的值</td>
</tr>
<tr>
<td><em><strong>*bin(x)*</strong></em></td>
<td>将一个整数转换为一个二进制字符串</td>
</tr>
<tr>
<td><em><strong>*oct(x)*</strong></em></td>
<td>将一个整数转换为一个八进制字符串</td>
</tr>
<tr>
<td><em><strong>*hex(x)*</strong></em></td>
<td>将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td><em><strong>*ord(x)*</strong></em></td>
<td>将一个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td><em><strong>*chr(x)*</strong></em></td>
<td>将一个整数转换为一个Unicode字符</td>
</tr>
<tr>
<td><em><strong>*tuple(s)*</strong></em></td>
<td>将序列s转换为一个元组</td>
</tr>
<tr>
<td><em><strong>*list(s)*</strong></em></td>
<td>将序列s转换为一个列表</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换s为可变集合</td>
</tr>
</tbody></table>
<pre><code class="python">num_int = 123
num_str = &quot;456&quot;
print(&quot;num_int 数据类型为:&quot;,type(num_int))
print(&quot;类型转换前，num_str 数据类型为:&quot;,type(num_str))
num_str = int(num_str)    # 强制转换为整型
print(&quot;类型转换后，num_str 数据类型为:&quot;,type(num_str))
num_sum = num_int + num_str
print(&quot;num_int 与 num_str 相加结果为:&quot;,num_sum)
print(&quot;sum 数据类型为:&quot;,type(num_sum))
输出：
num_int 数据类型为: &lt;class &#39;int&#39;&gt;
类型转换前，num_str 数据类型为: &lt;class &#39;str&#39;&gt;
类型转换后，num_str 数据类型为: &lt;class &#39;int&#39;&gt;
num_int 与 num_str 相加结果为: 579
sum 数据类型为: &lt;class &#39;int&#39;&gt;
</code></pre>
<h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><pre><code class="python"># Python开始等待你的输入。这时，你可以输入任意字符，然后按回车后完成输入。
input_str = input(&quot;请输入：&quot;)
# 输入完成后，不会有任何提示，刚才输入的内容存放到input_str变量里了
print(&quot;input_str数据类型为:&quot;,type(input_str))
# 输出input_str查看变量内容
print(input_str)
</code></pre>
<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><pre><code class="python">使用 print() 可将内容打印。
print(&quot;Hello Python&quot;)

多个内容之间可以使用逗号隔开。
print(&quot;Hello&quot;, &quot; Python&quot;)

可以使用 end= 来控制 print() 以什么结尾。
print(&quot;使用\\n结尾&quot;, end=&quot;\n&quot;)  # 用\n结尾，等同于print(&quot;使用\\n结尾&quot;)
print(&#39;使用&quot;&quot;结尾&#39;, end=&quot;&quot;)  # 用空字符串结尾
print(&quot;Hello&quot;)
</code></pre>
<pre><code class="python">格式化输出
（1）字符串中使用 % 占位
int1 = 10
float1 = 3.14159

str1 = &quot;int1 = %d, float1 = %f&quot; % (int1, float1)
print(str1)  # int1 = 10, float1 = 3.141590
</code></pre>
<h4 id="字符串-format"><a href="#字符串-format" class="headerlink" title="字符串.format()"></a>字符串.format()</h4><pre><code class="python">方式1：不设置指定位置，按默认顺序
int1 = 10
float1 = 3.14159
bool1 = True
str2 = &quot;int1 = &#123;&#125;, float1 = &#123;&#125;, bool1 = &#123;&#125;&quot;.format(int1, float1, bool1)
print(str2)  # int1 = 10, float1 = 3.14159, bool1 = True

方式2：设置指定位置，不能和方式1混合使用
int1 = 10
float1 = 3.14159
bool1 = True
str2 = &quot;int1 = &#123;0&#125;, float1 = &#123;1&#125;, bool1 = &#123;2&#125;&quot;.format(int1, float1, bool1)
print(str2)  # int1 = 10, float1 = 3.14159, bool1 = True

方式3：设置参数
int1 = 10
float1 = 3.14159
bool1 = True
str2 = &quot;int1 = &#123;i1&#125;, float1 = &#123;f1&#125;, bool1 = &#123;b1&#125;&quot;.format(i1=int1, f1=float1, b1=bool1)
print(str2)  # int1 = 10, float1 = 3.14159, bool1 = True
</code></pre>
<h5 id="f-字符串"><a href="#f-字符串" class="headerlink" title="f-字符串"></a>f-字符串</h5><h6 id="字符串前加上一个-f-，字符串中的-内写入变量名。"><a href="#字符串前加上一个-f-，字符串中的-内写入变量名。" class="headerlink" title="字符串前加上一个 f ，字符串中的{}内写入变量名。"></a>字符串前加上一个 f ，字符串中的{}内写入变量名。</h6><pre><code class="python">int1 = 10
float1 = 3.14159
str3 = f&quot;int1 = &#123;int1&#125;, float1 = &#123;float1&#125;&quot;
print(str3)  # int1 = 10, float1 = 3.14159
</code></pre>
<h6 id="内变量名后可以加上-x3D-，打印时会在变量值前加上-变量名-x3D"><a href="#内变量名后可以加上-x3D-，打印时会在变量值前加上-变量名-x3D" class="headerlink" title="{}内变量名后可以加上 &#x3D; ，打印时会在变量值前加上 变量名&#x3D;"></a>{}内变量名后可以加上 &#x3D; ，打印时会在变量值前加上 变量名&#x3D;</h6><pre><code class="python">int1 = 10
float1 = 3.14159
str3 = f&quot;&#123;int1 = &#125;, &#123;float1 = &#125;&quot;
print(str3)  # int1 = 10, float1 = 3.14159
</code></pre>
<pre><code class="python">num1 = 10
num2 = 20
num3 = 30

print(f&quot;num1 = &#123;num1&#125;, num2 = &#123;num2&#125;, num3 = &#123;num3&#125;&quot;)
print(f&quot;&#123;num1=&#125;, &#123;num2=&#125;, &#123;num3=&#125;&quot;)
</code></pre>
<h6 id="外再套一层-，即-，会转义"><a href="#外再套一层-，即-，会转义" class="headerlink" title="{}外再套一层{}，即{ { } }，会转义"></a>{}外再套一层{}，即{ { } }，会转义</h6><pre><code class="python">int1 = 10
float1 = 3.14159
str3 = f&quot;&#123;&#123;int1 = &#125;&#125;, &#123;&#123;float1 = &#125;&#125;&quot;
print(str3)  # &#123;int1 = &#125;, &#123;float1 = &#125;
</code></pre>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a><strong>成员运算符</strong></h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>在指定的序列中找到值返回 True，否则返回 False</td>
<td>a in [‘a’, ‘b’, ‘c’]</td>
</tr>
<tr>
<td>not in</td>
<td>在指定的序列中没有找到值返回 True，否则返回 False</td>
<td>a not in [‘a’, ‘b’, ‘c’]</td>
</tr>
</tbody></table>
<pre><code class="python"># -------------成员运算符---------------
num6 = 1
num7 = 20
test_list = [1,2,3,4,5]
print(test_list)
print(num6 in test_list) # True 判断1是不是列表中的的成员
print(num7 not in test_list) # True
</code></pre>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a><strong>身份运算符</strong></h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>判断两个标识符是不是引用自相同对象</td>
<td>a is b，类似id(a) &#x3D;&#x3D; id(b)。如果引用的是同一个对象则返回True，否则返回False</td>
</tr>
<tr>
<td>not is</td>
<td>判断两个标识符是不是引用自不同对象</td>
<td>a is not b，类似id(a) !&#x3D; id(b)。如果引用的不是同一个对象则返回True，否则返回False</td>
</tr>
</tbody></table>
<pre><code class="python"># -------------身份运算符---------------
m = 20
n = 20
q = 30
print(m is n)  # True 判断m和n在内存中是否指向同一个地址 都在小整数池里
print(n is q)  # False
print(n is not q)  # True
# id() 用于获取对象在内存中的地址
print(id(m) == id(n)) # True

print(&quot;-&quot; * 30)
# -------------is和==的区别---------------
a = [1,2,3]
b = a 

print(b is a)  # True
print(b == a)  # True

b = a[:]  # 快速复刻一个新的列表并给b
print(b)
print(b is a)  # False
print(b == a)  # True
</code></pre>
<h3 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h3><p><strong>语法：</strong></p>
<pre><code class="python">if 表达式:
    语句
</code></pre>
<h3 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h3><p><strong>语法：</strong></p>
<pre><code class="python">if 表达式:
    语句1
else:
    语句2
</code></pre>
<h3 id="双分支-1"><a href="#双分支-1" class="headerlink" title="双分支"></a>双分支</h3><p><strong>语法：</strong></p>
<pre><code class="python">if 表达式1:
    语句1
elif 表达式2:
    语句2
elif 表达式3:
    语句3
else:  # else如不需要可以省略
    语句4
</code></pre>
<h3 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h3><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code class="python">if 表达式1:
    if 表达式2:
        语句1
    else:
        语句2
else:
    if 表达式3:
        语句3
    else:
        语句4
</code></pre>
<h3 id="match-case语句"><a href="#match-case语句" class="headerlink" title="match case语句"></a>match case语句</h3><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><pre><code class="python">match x:
    case a:
        语句1
    case b:
        语句2
    case _:
        语句3
</code></pre>
<pre><code class="python">match month := 3:
    case 1 | 3 | 5 | 7 | 8 | 10 | 12:
        print(f&quot;&#123;month&#125;月有31天&quot;)
    case 4 | 6 | 9 | 11:
        print(f&quot;&#123;month&#125;月有30天&quot;)
    case 2:
        print(f&quot;&#123;month&#125;月可能有28天&quot;)
    case _:
        print(f&quot;&#123;month&#125;月有?天&quot;)
</code></pre>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><pre><code class="python">num1 = 2
num2 = 3
max_num = num1 if num1 &gt; num2 else num2
print(max_num)
</code></pre>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><pre><code class="python">while 表达式:
    语句-循环体
</code></pre>
<pre><code class="python">import time

num = 1
while num &lt; 100:
    print(&quot;\r&quot; + &quot;=&quot; * num, end=&quot;&quot;)
    num += 1
    time.sleep(0.05)
</code></pre>
<h6 id="while-else"><a href="#while-else" class="headerlink" title="while else"></a>while else</h6><p><strong>while</strong> 后可以加上 <strong>else</strong>，当 <strong>while</strong> 表达式结果为 <strong>False</strong> 时会执行 <strong>else</strong> 中的语句。</p>
<pre><code class="python">rabbit = 2
week = 1
while week &lt; 10:
    rabbit = rabbit + rabbit * 2
    week += 1
else:
print(f&quot;第&#123;week&#125;周有&#123;rabbit&#125;只兔子&quot;)
</code></pre>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p><strong>for</strong> 循环可以用来遍历可迭代对象，如列表或字符串</p>
<pre><code class="python">for 临时变量 in 可迭代对象:
    语句
</code></pre>
<p><strong>for</strong> 循环后也可以加上 <strong>else</strong>，循环结束后会执行 <strong>else</strong> 中语句</p>
<pre><code class="python">for 临时变量 in 可迭代对象:
    语句1
else:
    语句2
</code></pre>
<pre><code class="python">（1）遍历列表
for i in [2, 3, 5, 7, 11, 13, 17, 19]:
    print(i)
    
（2）遍历字符串
for i in &quot;hello world&quot;:
    print(i)
    
（3）遍历range数列
for i in range(10):
    print(i)
</code></pre>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p><strong>range([start,] stop[, step])</strong> 函数可以生成数列，它返回一个可迭代对象。<br>指定生成到stop（不包含stop）的数列，默认从0开始</p>
<pre><code class="python">for i in range(10):
    print(i)
</code></pre>
<p>指定生成数列的范围，从start到stop（不包含stop），可设定步长，默认步长为1，步长可正可负。</p>
<pre><code class="python">or i in range(-10, 10):
    print(i)

for i in range(10, -10, -3):
    print(i)
</code></pre>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>跳过当前循环块中的剩余语句，继续进行下一轮循环。一般写在<strong>if</strong>判断中。</p>
<p>案例，打印0-9，跳过偶数</p>
<pre><code class="python">for i in range(10):
    if i % 2 == 0:
        continue
    print(i)
</code></pre>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>跳出当前<strong>for</strong>或<strong>while</strong>的循环体，一般写在<strong>if</strong>判断中。<br>如果<strong>for</strong> 或<strong>while</strong>循环通过<strong>break</strong>终止，循环对应的<strong>else</strong> 将不执行。</p>
<p>案例：求0-9每个数自己幂自己的加和，如果大于10000000则循环终止。</p>
<pre><code class="python">sum = 0
for i in range(10):
    sum = sum + i**i
    if sum &gt; 10000000:
        break
    print(i, sum)
else:
    print(&quot;循环完成,sum = &quot;, sum)
</code></pre>
<h3 id="pass【循环体或函数写的时候思考的占位】"><a href="#pass【循环体或函数写的时候思考的占位】" class="headerlink" title="pass【循环体或函数写的时候思考的占位】"></a>pass【循环体或函数写的时候思考的<u>占位</u>】</h3><p>pass是空语句，是为了保持程序结构 的完整性。<br>pass不做任何事情，一般用做占位语句。</p>
<p>例如：在一个循环中，如果循环体为空，语法会提示报错，<br>这个时候我们就可以使用pass占位</p>
<pre><code class="python">for i in range(10):
    pass
</code></pre>
<pre><code class="python">while True:
    pass
</code></pre>
<hr>
<pre><code class="python">循环相关的关键字：：：：：
   continue
         跳出当前正在进行的循环，继续下次循环
   break
        跳出整个循环
   pass
           循环体的占位
</code></pre>
<hr>
<h3 id="容器数据类型"><a href="#容器数据类型" class="headerlink" title="容器数据类型"></a>容器数据类型</h3><pre><code class="python">list  列表
tuple 元组
set   集合
dict  字典
不可变类型：数组、字符串、元组
可变类型：列表、集合、字典
</code></pre>
<p>按<strong>ctrl+p</strong>可以看某个函数所需要填的元素</p>
<h5 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h5><p>序列（Sequence）是一种基本且核心的数据结构，它允许我们以有序的方式存储和操作数据。序列可以包含不同类型的元素，并且支持通过索引来访问和修改这些元素。常见的序列类型包括：<span style = "color:red"><strong>列表（List）、元组（Tuple）、字符串（String）</strong></span></p>
<p><strong>序列的操作</strong></p>
<p>Ø 索引：sequence[0]<br>Ø 切片：sequence[1:3]<br>Ø 相加：sequence1 + sequence2<br>Ø 乘法：sequence * 3<br>Ø 检查成员：x in sequence<br>Ø 计算长度：len(sequence)<br>Ø 计算最大值、最小值：max(sequence)、min(sequence)</p>
<h4 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a><span style = "color:red">列表List</span></h4><p>Ø 列表是一个可变的、有序的元素集合<br>Ø 列表使用 [] 定义，数据之间使用 <strong>,</strong> 分隔。<br>Ø 列表中每个元素都有对应的位置值，称为索引或下标，索引从起始从0开始向后逐个递增，并且从末尾从-1开始逐个向前递减。<br>Ø 列表中元素可以是不同的类型。</p>
<h5 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h5><p><code>list1 = [100, 200, 300, 400, 500]</code></p>
<h5 id="访问列表"><a href="#访问列表" class="headerlink" title="访问列表"></a>访问列表</h5><h6 id="通过索引获取列表中元素"><a href="#通过索引获取列表中元素" class="headerlink" title="通过索引获取列表中元素"></a>通过索引获取列表中元素</h6><pre><code class="python">list1 = [100, 200, 300, 400, 500]
print(list1[1])  # 200
print(list1[-2])  # 400
</code></pre>
<h6 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h6><pre><code class="python">list1 = [100, 200, 300, 400, 500]
print(list1)  # 取全部元素
print(list1[:])  # 复制整个列表
print(list1[2:4])  # 取索引从2开始到4(不包含)的元素
print(list1[2:])  # 取索引从2开始到末尾的元素
print(list1[:2])  # 取索引从0开始到2(不包含)的元素
print(list1[2:-1])  # 取索引从2开始到-1(不包含)的元素
print(list1[::-1])  # 倒序取元素
</code></pre>
<h6 id="向列表中添加元素【append】"><a href="#向列表中添加元素【append】" class="headerlink" title="向列表中添加元素【append】"></a>向列表中添加元素【append】</h6><pre><code class="python">list1 = [100, 200, 300, 400, 500]
list1.append(600) # 在列表末尾追加元素
list1.insert(2,700) # 在列表指定的位置追加元素
print(list1)
</code></pre>
<h6 id="列表相加"><a href="#列表相加" class="headerlink" title="列表相加"></a><strong>列表相加</strong></h6><pre><code class="python">list1 = [100, 200, 300]
list2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
print(list1 + list2)  # [100, 200, 300, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<h6 id="列表乘法"><a href="#列表乘法" class="headerlink" title="列表乘法"></a>列表乘法</h6><pre><code class="python">list1 = [100, 200, 300]
print(list1 * 2)  # [100, 200, 300, 100, 200, 300]
</code></pre>
<h4 id="修改列表中元素"><a href="#修改列表中元素" class="headerlink" title="修改列表中元素"></a>修改列表中元素</h4><h5 id="通过下标修改"><a href="#通过下标修改" class="headerlink" title="通过下标修改"></a>通过下标修改</h5><pre><code class="python">list1 = [100, 200, 300, 400, 500]
list1[0] = -1
print(list1)
</code></pre>
<h5 id="通过切片修改"><a href="#通过切片修改" class="headerlink" title="通过切片修改"></a>通过切片修改</h5><pre><code class="python">list1 = [100, 200, 300, 400, 500]
list1[2:4] = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
print(list1)
</code></pre>
<h5 id="检查成员是否为列表中元素"><a href="#检查成员是否为列表中元素" class="headerlink" title="检查成员是否为列表中元素"></a>检查成员是否为列表中元素</h5><pre><code class="python">list1 = [100, 200, 300]
print(100 in list1)  # True
</code></pre>
<h5 id="获取列表长度"><a href="#获取列表长度" class="headerlink" title="获取列表长度"></a>获取列表长度</h5><pre><code class="python">list1 = [100, 200, 300]
print(len(list1))  # 3
</code></pre>
<pre><code class="python">5.2.9 求列表中元素的最大值、最小值、加和
list1 = [100, 200, 300, 400, 500]
print(max(list1))  # 500
print(min(list1))  # 100
print(sum(list1))  # 1500

5.2.10 遍历列表
1）直接遍历列表元素
list1 = [100, 200, 300, 400, 500]
for i in list1:
    print(i)
    
2）通过下标遍历列表
list1 = [100, 200, 300, 400, 500]
for i in range(len(list1)):
    print(i, list1[i])
    
3）使用enumerate()同时获取列表的下标和元素
list1 = [100, 200, 300, 400, 500]
for i, val in enumerate(list1):
    print(i, val)
——-——————————————————————————
0 100
1 200
2 300
3 400
4 500
    
5.2.11 删除列表指定位置元素或者切片
list1 = [100, 200, 300, 400, 500]
del list1[2]
print(list1)

5.2.12 嵌套列表
列表中元素可以为列表。
list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
for inner_list in list1:
    print(inner_list)

list2 = [100,200,300,400,500]
list2.insert(3,300)
# 删除第一次出现的x
list2.remove(300)
print(list2)
</code></pre>
<h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><p>列表推导式是 Python 中一种简洁创建列表的方式，它将一个<strong>可迭代对象</strong>（如列表、元组、集合、字符串等）的元素<strong>通过某种运算</strong>或<strong>条件筛选</strong>后生成一个新的列表。</p>
<pre><code class="python">（1）基础的列表推导式
squares = [x**2 for x in range(5)]
print(squares)  # [0, 1, 4, 9, 16]

（2）带条件的列表推导式
squares = [x**2 for x in range(10) if x % 2 == 0]
print(squares)  # [0, 4, 16, 36, 64]

（3）使用现有列表的列表推导式
list1 = [1, 2, 3, 4, 5]
squares = [x**2 for x in list1]
print(squares)  # [1, 4, 9, 16, 25]

（4）包含多个循环的列表推导式
list1 = [1, 2, 3, 4, 5]
list2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
tuple_list = [(i, j) for i in list1 for j in list2]
print(tuple_list)

# i,j 为元素 组合成了(i,j)元组
# i在list1中 j在list2中
</code></pre>
<h4 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a>zip()函数</h4><p>zip() 函数可将多个可迭代对象中对应元素打包为一个个元组。</p>
<pre><code class="python">list1 = [1, 2, 3, 4, 5]
list2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
zipped = zip(list1, list2)
print(list(zipped))
# [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;), (4, &#39;d&#39;), (5, &#39;e&#39;)]
</code></pre>
<h4 id="列表常用方法"><a href="#列表常用方法" class="headerlink" title="列表常用方法"></a>列表常用方法</h4><pre><code class="python"># 在指定位置插入x
list.insert(index,x)
# 在列表末尾追加x
list.append(x)
# 在列表1的末尾追加列表2的数据    
list1.extend(list2)    
# 删除指定位置的数据或切片
del list[index]    
# 删除第一次出现的x
list.remove(x)    
# 删除指定位置的数据，默认为末尾数据
list.pop([index])
# 清空列表中元素    
list.clear()    
# 修改指定位置的数据
list[index] = x    
# 修改列表切片的数据
list1[start:end] = list2    
# 返回排序后的新列表，可选降序
sorted(list[,reverse=True])    
# 对列表就地排序，可选降序
list.sort([reverse=True])
# 反转列表中的元素    
list.reverse()    
# 返回x在列表中首次出现的位置，可指定起始和结束范围
list.index(x[,start,[,end]])    
# 返回x的数量
list.count(x)    
# 返回列表元素个数
len(list)    
# 返回列表中最大值
max(list)    
# 返回列表中最小值
min(list)    
# 返回列表中所有元素和
sum(list)    
# 拷贝列表
list.copy()    
# 将序列转换为列表
list(x)    
</code></pre>
<h4 id="列表元素遍历"><a href="#列表元素遍历" class="headerlink" title="列表元素遍历"></a>列表元素遍历</h4><pre><code class="python">list1 = [100, 200, 300, 400, 500]
for i in range(0,len(list1)):
    print(i, list1[i])

0 100
1 200
2 300
3 400
4 500
</code></pre>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a><span style = "color:red">列表 list</span></h4><ul>
<li>list是可变的，可以对list中的元素进行修改 </li>
<li>list是有序的，每个元素都有对应的下标(索引)，可以通过索引获取元素以及对list进行切片操作 </li>
<li>list中可以存放不同类型的元素 </li>
<li>使用[]定义list</li>
</ul>
<h4 id="字符串-String-是不可变的"><a href="#字符串-String-是不可变的" class="headerlink" title="字符串 String(是不可变的)"></a><span style = "color:red">字符串 String(是不可变的)</span></h4><ul>
<li>str是不可变的，不能直接对原字符串进行修改， 如果修改会创建新的对象 </li>
<li>str是有序的，字符串中的每个字符都有对应的下标(素引) ，可以通过索引获取字符以及队str进行切片操作</li>
<li>str的定义方式：</li>
</ul>
<pre><code class="python">单引号
双引号 
# 三引号可以保留字符串的样式
三引号
str1 = &quot;&quot;&quot;abc
def&quot;&quot;&quot;

# 获取字符以及字符串切片
print(str1[3])
print(str1[1:5])
print(str1[:5])
print(str1[:]) #原输出
print(str1[::-1]) #逆向获取
</code></pre>
<pre><code class="python">5.3.1创建字符串
str1 = &quot;hello world&quot;

5.3.2访问字符串
str1 = &quot;hello world&quot;
print(str1[0])
print(str1[-1])
print(str1[4:-3])

5.3.3字符串相加
str1 = &quot;hello world&quot;
str2 = &quot;dlrow olleh&quot;
print(str1 + str2)  # hello worlddlrow olleh

5.3.4字符串乘法
str1 = &quot;hello world&quot;
print(str1 * 2)  # hello worldhello world

5.3.5检查成员是否为字符串中元素
str1 = &quot;hello world&quot;
print(&quot;lo&quot; in str1)  # True

5.3.6原始字符串
所有的字符串按照字面意思处理，没有转义字符。需在字符串前加上r / R。
print(&quot;hello\nworld&quot;)
print(r&quot;hello\nworld&quot;)
print(R&quot;hello\t\tworld&quot;)
</code></pre>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>str.replace(old,new[,max])</td>
<td>把将字符串中的old替换成new,如果指定max，则替换不超过max次</td>
</tr>
<tr>
<td>str.split([x][,n])</td>
<td>按x分隔字符串，默认按任何空白字符串分隔并在结果中丢弃空字符串。可指定最大分隔次数</td>
</tr>
<tr>
<td>str.rsplit([x] [,n])</td>
<td>与split()类似，从右边开始分隔</td>
</tr>
<tr>
<td>join(seq)</td>
<td>以x作为分隔符，将序列中所有的字符串合并为一个新的字符串</td>
</tr>
<tr>
<td>str.strip([x])</td>
<td>截掉字符串两边的空格或指定字符</td>
</tr>
<tr>
<td>str.lstrip([x])</td>
<td>截掉字符串左边的空格或指定字符</td>
</tr>
<tr>
<td>str.rstrip([x])</td>
<td>截掉字符串右边的空格或指定字符</td>
</tr>
</tbody></table>
<pre><code class="python">list1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]
str1 = &quot;-&quot;.join(list1)
print(str1)
# a-b-c-d-e-f

list1 = &quot;abcdefg&quot;
str1 = list1.find(&quot;g&quot;)
print(str1)
# 6

str1 = list1.find(&quot;d&quot;,3,5)
print(str1)
# 3
</code></pre>
<h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a><span style = "color:red">元组 tuple</span></h4><ul>
<li>tuple是不可变的，不能直接队元组中的元素进行修改</li>
<li>tuple是有序的，每个元素都有对应的下标(索引)，可以通过索引获取元组中以及队元组进行切片</li>
<li>tuple中可以存放不同类型的数据</li>
<li>使用()定义tuple</li>
</ul>
<pre><code class="python"># 创建元组对象
tup = (100,200,300,400,500)
# 如果元组中只有一个元组，那么在元素的后面也需要加&#39;，&#39;
tup1 = (100,)
# 使用元组推导式 创建元组
list1 = [i*2 for i in range(10)]

print(tup)
print(tup1, type(tup1))
# (100, 200, 300, 400, 500)
# (100,) &lt;class &#39;tuple&#39;&gt;


# 访问元组
tuple1 = (100,200,300,400,500)
print(tuple1[-2])
# 400


#元组相加
tuple1 = (100, 200, 300)
tuple2 = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
print(tuple1 + tuple2)  
# (100, 200, 300, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)


#元组相乘
tuple1 = (100, 200, 300)
print(tuple1 * 2)  
# (100, 200, 300, 100, 200, 300)


#检查成员是否为元组中元素
tuple1 = (100, 200, 300, 400, 500)
print(300 in tuple1)  
# True


#获取元组长度
tuple1 = (100, 200, 300, 400, 500)
print(len(tuple1))  
# 5


#求元组中元素的最大值、最小值、加和
tuple1 = (100, 200, 300, 400, 500)
print(max(tuple1))  # 500
print(min(tuple1))  # 100
print(sum(tuple1))  # 1500


#遍历元组
tuple1 = (100, 200, 300, 400, 500) 

for i in tuple1:
    print(i)

for i in range(len(tuple1)):
    print(i, tuple1[i])

for i, val in enumerate(tuple1):
    print(i, val)
    
</code></pre>
<h4 id="元组的不可变"><a href="#元组的不可变" class="headerlink" title="元组的不可变"></a>元组的不可变</h4><p>元组的不可变指的是元组所指向的<strong>内存中的内容不可变</strong>，但可以重新赋值</p>
<pre><code class="python">tuple1 = (100, 200, 300)
print(id(tuple1), tuple1)
tuple1 = tuple1 + (1, 2, 3)
print(id(tuple1), tuple1)
</code></pre>
<p>如果元组中元素是可变数据类型，其嵌套项可以被修改</p>
<pre><code class="python">tuple1 = (100, 200, 300, [1, 2, 3])
tuple1[3].append(4)
print(tuple1)  # (100, 200, 300, [1, 2, 3, 4])
</code></pre>
<h4 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a><span style = "color:red">集合Set</span></h4><ul>
<li>集合是无序的，且不包含重复元素。</li>
<li>集合使用 <strong>{}</strong> 定义，数据之间使用 <strong>,</strong> 分隔，也可以使用set()定义。</li>
<li>集合没有索引，所以不能通过切片方式访问集合元素。</li>
<li>集合中元素可以是不同的类型。</li>
<li>集合可以进行数学上的集合操作，如并集、交集和差集。</li>
<li>集合适用于需要快速成员检查、消除重复项和集合运算的场景。</li>
</ul>
<h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>可以通过{}或set()创建集合，但创建空集合需要使用set()而非{}，因为{}会创建空字典。</p>
<pre><code class="python">set1 = &#123;1, 2, 3&#125;
set2 = set([1, 2, 3])  # 使用set()函数从列表创建集合
set3 = set()
print(set1, set2, set3)
</code></pre>
<p>也可以通过集合推导式创建集合。</p>
<pre><code class="python">set1 = &#123;x for x in range(10) if x % 2 == 0&#125;
print(set1)  # &#123;0, 2, 4, 6, 8&#125;
</code></pre>
<h4 id="向集合中添加元素"><a href="#向集合中添加元素" class="headerlink" title="向集合中添加元素"></a>向集合中添加元素</h4><pre><code class="python">set1 = &#123;1, 2, 3&#125;
set1.add(4)
set1.add(5)
print(set1)
</code></pre>
<h4 id="从集合中删除元素"><a href="#从集合中删除元素" class="headerlink" title="从集合中删除元素"></a><strong>从集合中删除元素</strong></h4><pre><code class="python">set1 = &#123;1, 2, 3&#125;
set1.remove(2)
print(set1)
</code></pre>
<h4 id="检查成员是否为集合中元素"><a href="#检查成员是否为集合中元素" class="headerlink" title="检查成员是否为集合中元素"></a><strong>检查成员是否为集合中元素</strong></h4><pre><code class="python">set1 = &#123;1, 2, 3, 4, 5&#125;
print(2 in set1)  # True
</code></pre>
<h4 id="获取集合长度"><a href="#获取集合长度" class="headerlink" title="获取集合长度"></a><strong>获取集合长度</strong></h4><pre><code class="python">set1 = &#123;1, 2, 3, 4, 5&#125;
print(len(set1))  # 5
</code></pre>
<h4 id="求集合中元素的最大值、最小值、加和"><a href="#求集合中元素的最大值、最小值、加和" class="headerlink" title="求集合中元素的最大值、最小值、加和"></a><strong>求集合中元素的最大值、最小值、加和</strong></h4><pre><code class="python">set1 = &#123;1, 2, 3, 4, 5&#125;
print(max(set1))  # 5
print(min(set1))  # 1
print(sum(set1))  # 15
</code></pre>
<h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a><strong>遍历集合</strong></h4><pre><code class="python">set1 = &#123;1, 2, 3, 4, 5&#125;
for item in set1:
  print(item)

# 变量去掉 不需要
for _ in rang(len(set1))
  print(set1.pop())
</code></pre>
<pre><code class="python">#添加元素
set.add(x)
#添加元素，x可以为列表、元组、字符串、字典等可迭代对象
set.update(x)    
#添加元素后返回一个新的集合，x可以为列表、元组、字符串、字典等可迭代对象
set.union(x)    
#从集合中移除x，x不存在则报错 
set.remove(x)    
#从集合中移除x，x不存在也不报错
set.discard(x)     
#【随机取出】集合中的一个元素，如果集合为空则报错
set.pop()
#清空集合
set.clear()    
#求set1和x1的差集，返回一个新的集合
set.difference(x1,...)
#求set1和x1的差集
set.difference_update(x1,...)    
#求set1和x1的交集，返回一个新的集合
set.intersection(x1,...)    
#求set1和x1的交集
set.intersection_update(x1,...)    
#两集合求交集
set1 &amp; set2    
#两集合求并集
set1 | set2    
#两集合求差集
set1 - set2    
#判断两集合是否没有交集
set1.isdisjoint(set2)
#判断set1是否为set2的子集
set1.issubset(set2)    
#判断set2是否为set1的子集
set1.issuperset(set2)    
#求两集合中不重复的元素，返回一个新的集合
set1.symmetric_difference(set2)    
#求两集合中不重复的元素
set1.symmetric_difference_update(set2)    
#拷贝集合
set.copy()    
#返回集合元素个数
len(set)
#求集合中元素的最大值
max(set)    
#求集合中元素的最小值
min(set)    
#求集合中元素的加和
sum(set)    
</code></pre>
<p><span style = "color:red"><strong>字典Dictionary</strong></span> [k:v键值对形式]</p>
<ul>
<li>一个无序的键值对集合，键是唯一的，而值可以重复。</li>
<li>字典使用 <strong>{}</strong> 定义，键（key）和值（value）使用 <strong>:</strong> 连接，每个键值对之间使用 <strong>,</strong> 分隔。如{key1 <strong>:</strong> value1**,** key2 <strong>:</strong> value2}</li>
<li>字典没有索引。</li>
<li>字典可以通过键来获取对应的值。</li>
<li>值可以取任何数据类型，但键必须是不可变的，如字符串、数字、元组。</li>
</ul>
<h6 id="空集合可以通过dict1-x3D-或set-x3D-去创建"><a href="#空集合可以通过dict1-x3D-或set-x3D-去创建" class="headerlink" title="空集合可以通过dict1&#x3D;{}或set&#x3D;()去创建"></a>空集合可以通过dict1&#x3D;{}或set&#x3D;()去创建</h6><h5 id="可以通过-或dict-创建字典"><a href="#可以通过-或dict-创建字典" class="headerlink" title="可以通过{}或dict()创建字典"></a>可以通过{}或dict()创建字典</h5><pre><code class="python">dict1 = &#123;&#125;
dict2 = dict()
dict3 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;male&quot;&#125;
dict4 = dict(name=&quot;Bob&quot;, age=20, gender=&quot;female&quot;)
dict5 = dict([(&quot;name&quot;, &quot;Tom&quot;), (&quot;age&quot;, 22), (&quot;gender&quot;, &quot;male&quot;)])
print(dict1)
print(dict2)
print(dict3)
print(dict4)
print(dict5)
</code></pre>
<h5 id="也可以通过字典推导式创建字典"><a href="#也可以通过字典推导式创建字典" class="headerlink" title="也可以通过字典推导式创建字典"></a>也可以通过字典推导式创建字典</h5><pre><code class="python">squares = &#123;x: x**2 for x in range(4)&#125;
print(squares)  # &#123;0: 0, 1: 1, 2: 4, 3: 9&#125;
</code></pre>
<h5 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h5><p>可通过 [] 访问字典中的元素。key不存在时会报错</p>
<pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;male&quot;&#125;
print(dict1[&quot;name&quot;])  # Alice
print(dict1[&quot;age&quot;])  # 18
print(dict1[&quot;gender&quot;])  # male
print(dict1[&quot;address&quot;])  # 报错
</code></pre>
<p>也可以通过get()获取字典中的元素。key不存在时会返回None，也可以指定默认值。</p>
<pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;male&quot;&#125;
print(dict1.get(&quot;name&quot;))  # Alice
print(dict1.get(&quot;age&quot;))  # 18
print(dict1.get(&quot;gender&quot;))  # male
print(dict1.get(&quot;address&quot;))  # None
# 这里earth是默认值 如果找不到address的value就默认是earth
print(dict1.get(&quot;address&quot;, &quot;earth&quot;))  # earth
</code></pre>
<h5 id="向字典中添加元素"><a href="#向字典中添加元素" class="headerlink" title="向字典中添加元素"></a>向字典中添加元素</h5><p>为字典指定的key赋值value，若key原本不存在则会被添加</p>
<pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;male&quot;&#125;
dict1[&quot;address&quot;] = &quot;earth&quot;
print(dict1)

#&#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 18, &#39;gender&#39;: &#39;male&#39;, &#39;address&#39;: &#39;earth&#39;&#125;
</code></pre>
<h5 id="修改字典中元素"><a href="#修改字典中元素" class="headerlink" title="修改字典中元素"></a>修改字典中元素</h5><p>通过key修改对应的value</p>
<pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;male&quot;&#125;
dict1[&quot;name&quot;] = &quot;Bob&quot;
print(dict1)

#&#123;&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 18, &#39;gender&#39;: &#39;male&#39;, &#39;address&#39;: &#39;earth&#39;&#125;
</code></pre>
<h5 id="检查成员是否为字典中的key"><a href="#检查成员是否为字典中的key" class="headerlink" title="检查成员是否为字典中的key"></a><strong>检查成员是否为字典中的key</strong></h5><pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 81, &quot;gender&quot;: &quot;male&quot;&#125;
print(&quot;name&quot; in dict1)  # 检查key是否存在
print(&quot;Alice&quot; in dict1)  # 无法直接检查value是否存在
</code></pre>
<p><strong>获取字典长度</strong></p>
<pre><code class="python">dict1 = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 81, &quot;gender&quot;: &quot;male&quot;&#125;
print(len(dict1))  # 3
</code></pre>
<h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><pre><code class="python">dict1=&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18&#125;
#遍历所有k
allKeys = dict1.keys()
for i in allKeys:
    print(i)
print(&quot;*********&quot;)

#遍历所有v
allValues = dict1.values()
for k in allValues:
    print(k)
print(&quot;*********&quot;)

#遍历所有k-v
for i in allKeys:
    print(i + &quot;---&quot; + str(dict1[i]))
或
    print(f&quot;&#123;i&#125;---&#123;dict1[i]&#125;&quot;)
print(&quot;*********&quot;)

------------------------------------
*********
tom
18
*********
name---tom
age---18
*********
</code></pre>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>item一般对容器来讲 是代表当前<strong>容器的元素项</strong><br>对于字典来讲 是每个元素是<strong>配对键值对形式</strong></p>
<pre><code class="python">items = dict1.items()
print(items)
print(type(items))
for item in items:
    print(item)
----------------------
dict_items([(&#39;name&#39;, &#39;tom&#39;), (&#39;age&#39;, 18)])
&lt;class &#39;dict_items&#39;&gt;
(&#39;name&#39;, &#39;tom&#39;)
(&#39;age&#39;, 18)
</code></pre>
<h5 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h5><pre><code class="python">my_dict = &#123;&#39;Name&#39;: &#39;Tom&#39;, &#39;Age&#39;: 17&#125;
del my_dict[&#39;Name&#39;] # 删除键 &#39;Name&#39;
# my_dict.clear()     # 清空字典
# del my_dict         # 删除字典

print (my_dict)
</code></pre>
<h6 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h6><pre><code class="python">#根据key删除键值对
del dict[key]
#获取key所对应的value，同时删除该键值对，可设置默认值
dict.pop(key[,default])
#取出字典中的最后插入的键值对，字典为空则报错
dict.popitem()
#清空字典
dict.clear()
#将dict2中的键值对更新到dict1中
dict1.update(dict2)
#获取字典中key对应value，可设置默认值
dict.get(key[,default])
#获取字典中key对应value，可设置默认值。若key不存在于字典中，将会添加key并将value设为默认值
dict.setdefault(key[,default])
#获取字典所有的key，返回一个视图对象。字典改变，视图也会跟着变化
dict.keys()
#获取字典所有的value，返回一个视图对象
dict.values()
#获取字典所有的(key,value)，返回一个视图对象
dict.items()
#拷贝字典
dict.copy()
#以序列seq中元素做字典的key创建一个新字典，可设置value的默认值
dict.fromkeys(seq[,default])
</code></pre>
<p><span style = "color:blue"> <strong>列表、元组、字典和集合的区别</strong></span></p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>是否可变</th>
<th>是否重复</th>
<th>是否有序</th>
<th>定义符号</th>
</tr>
</thead>
<tbody><tr>
<td>列表【List】</td>
<td>可变</td>
<td>允许</td>
<td>有序</td>
<td>[]或list()</td>
</tr>
<tr>
<td>元组【Tuple】</td>
<td>不可变</td>
<td>允许</td>
<td>有序</td>
<td>()或tuple()</td>
</tr>
<tr>
<td>字典【Dictionary】</td>
<td>可变</td>
<td>键不允许，值允许</td>
<td>键无序（Python 3.7+版本中保持插入顺序）</td>
<td>{}或dict()</td>
</tr>
<tr>
<td>集合【Set】</td>
<td>可变</td>
<td>允许</td>
<td>无序</td>
<td>{}或set()</td>
</tr>
</tbody></table>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>直观理解，带名字的代码块</li>
<li>将完成某一块功能的代码抽取出来，取一个名字，就是函数。如果以后再要完成这个功能的时候，就不需要再编写整体代码了，直接通过名字去调用函数即可。</li>
</ul>
<pre><code class="python">案例：打印两次2x3的*
&#39;&#39;&#39;
    该案例演示了函数的抽取以及调用
    打印如下图形
        ***
        ***
        -------
        ***
        ***
&#39;&#39;&#39;
# 定义一个函数,该函数完成打印输出2*3 &quot;*&quot;的功能
def printStar() :
    &#39;&#39;&#39;
        这是对函数功能的说明
    &#39;&#39;&#39;
    row = 2
    while row &gt; 0 :
        print(&quot;*&quot; * 3)
        row -= 1

# 调用函数
printStar()
print(&quot;-&quot; * 20)
printStar()
</code></pre>
<p>（1）注意：</p>
<ul>
<li>函数必须先定义再调用</li>
<li>函数在定义的时候只是告诉解释器我定义了一个这样的函数，可以完成某些功能，但是这个时候函数还没有执行，需要调用函数后，才会执行。</li>
</ul>
<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p><strong>语法：</strong></p>
<pre><code class="python">def 函数名(参数列表)
     函数体
    [return]

说明：
       &quot;def&quot; 是定义函数的关键字
#   函数名：程序员自己定义的，需要遵循标识符的命名规范
    函数名后，跟着一对小括号，里面放的是参数列表
        参数，函数执行的时候需要依赖的值
        参数可以有多个，多个参数之间用逗号分隔
        如果没有参数，小括号不能省略
    用：结束函数的声明
    函数具体完成的功能在函数体中实现，需要进行缩进
    通过return关键字将函数执行的结果返回给调用者【可以不加，默认返回值是None】 
--------------------------------------------------------------------
def print_star():
    num = 2
    while num &gt; 0:
        print(&quot;*&quot; * 3)
        num -= 1
print_star()
print(&quot;-&quot; * 30)
print_star()
</code></pre>
<h5 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h5><p>在函数的提供者定义函数时候，声明的参数称之为形式参数<br><code>def print_star(rows,clos):</code><br>在函数的调用者调用函数的时候，传递的参数称之为实际参数<br><code>print_star(100,3)</code></p>
<p>注意：在函数声明的时候，并没有给形式参数分配内容空间，只是做了一个占位<br>在调用的时候，会将实参的地址引用赋值给形参</p>
<pre><code class="python"># 原始方法
def print_star_1():
    num = 2
    while num &gt; 0:
        print(&quot;*&quot; * 3)
        num -= 1

def print_star_2():
    num = 1
    while num &gt; 0:
        print(&quot;*&quot; * 6)
        num -= 1
        
print_star_1()
print(&quot;~&quot; * 30)
print_star_2()

------------------------------

# 抽取函数（加参数）
def print_star(rows,clos):
    while rows &gt; 0:
        print(&quot;*&quot; * clos)
        rows -= 1

print_star(2,3)
------------------------------
***
***
</code></pre>
<h4 id="赋值操作情况说明"><a href="#赋值操作情况说明" class="headerlink" title="赋值操作情况说明"></a>赋值操作情况说明</h4><h5 id="对于参数传递的是可变数据类型"><a href="#对于参数传递的是可变数据类型" class="headerlink" title="对于参数传递的是可变数据类型"></a>对于参数传递的是可变数据类型</h5><p><code>var1 *= 2</code> 使用了原地址<br><code>var1 = var1 * 2</code> 开辟了新的空间</p>
<h4 id="参数传递的形式【-a是要传元组-val1-val2-、-a是要传字典-key-val-】"><a href="#参数传递的形式【-a是要传元组-val1-val2-、-a是要传字典-key-val-】" class="headerlink" title="参数传递的形式【*a是要传元组(val1,val2)、**a是要传字典{key,val}】"></a>参数传递的形式【<code>*a是要传元组(val1,val2)、**a是要传字典&#123;key,val&#125;</code>】</h4><ul>
<li><p>必须参数【参数个数和顺序要一致 通过位置进行赋值】</p>
</li>
<li><p>关键字参数【传递实参的时候要带名称且一致，位置可以不一致】</p>
</li>
<li><p>默认值参数【在定义参数的时候，可以给参数指定默认值；形参数量可以和实参数量不一致，不传参则默认值】</p>
</li>
<li><p>不定长参数</p>
<ul>
<li><p>【<code>def 函数名([普通参数], *不定长参数名, [普通参数2])</code>】调用时，普通参数1是按照位置进行匹配的；普通参数2按照关键字进行匹配；处理不定长参数时，使用<strong>元组</strong>进行处理</p>
<pre><code class="python">def func(num,*args,plu):
    print(num)
    print(args)
    print(plu)
func(3, 2,1,1,1,1, plu = 666)
-------------------------
3
(2, 1, 1, 1, 1)
666
</code></pre>
</li>
<li><p>【<code>def 函数名([普通参数], **不定长参数名)</code>】调用时，普通参数1是按照位置进行匹配的；不定长参数后面不允许出现其他的参数；处理不定长参数时，使用<strong>字典</strong>{key:value}进行处理</p>
<pre><code class="python">def func(num,**args):
    print(num)
    print(args)
func(300, a = 1,b =2 ,c = 3,d = 4)
-------------------------
300
&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;
</code></pre>
<pre><code class="python">def func(**args):
    print(arg)
func(**&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18&#125;)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>不定长参数可以在形参前面加”*”【定义的是元组】</p>
<pre><code class="python">def func(num,*args):
    print(num)
    print(args)
func(3, 2,1,1,1,1)
</code></pre>
<p>（1）<strong>注意：</strong></p>
<p>Ø 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
<p>Ø 如果形参中出现了不定长参数，那么在调用函数的时候，先通过位置进行必须参数的匹配，然后不定长参数后面的参数必须通过关键字参数匹配</p>
<p>Ø 如果不定长的参数后面还有参数,必须通过关键字参数传参</p>
<pre><code class="python">def func(num,*args):
    print(num)
    print(args)
func(3, 2,1,1,1,1, num1 = 300)
</code></pre>
<p>Ø 还有一种就是参数带两个星号 **的可变长参数，基本语法如下：</p>
<pre><code class="python">def 函数名([普通参数,] **var_args_dict ):
   函数体
</code></pre>
<p>加了两个星号 ** 的参数会以字典的形式导入，后面就不能再有其他参数了</p>
<pre><code class="python">&#39;&#39;&#39;
    该案例演示了函数调用时的不定长参数
&#39;&#39;&#39;
def printInfo(num,**vardict):
    print(num)
    print(vardict)
    # return

printInfo(10,key1 = 20,key2 = 30)
printInfo(10,a = 20,b = 30)
</code></pre>
<h4 id="解包传参"><a href="#解包传参" class="headerlink" title="解包传参"></a>解包传参</h4><p>若函数的形参是定长参数，可以通过 * 和 ** 对列表、元组、字典等解包传参。</p>
<pre><code class="python">def func(a, b, c):
    return a + b + c
tuple11 = (1, 2, 3)
print(func(*tuple11))

# 字典中key的名称和参数名必须一致
dict1 = &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;
print(func(**dict1))

---------------------------------
6
6

#若是直接 print(a,b,c) =&gt; 1,2,3
</code></pre>
<h4 id="强制使用位置传参或关键字参数"><a href="#强制使用位置传参或关键字参数" class="headerlink" title="强制使用位置传参或关键字参数"></a>强制使用位置传参或关键字参数</h4><p>&#x2F; 前的参数必须使用位置传参，* 后的参数必须用关键字传参。</p>
<pre><code class="python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)

f(1, 2, 3, d=4, e=5, f=6) 
</code></pre>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code class="python">&quot;&quot;&quot;
    通过函数修改列表中元素的练习题
    需求：要函数对列表进行处理，又不希望函数修改原列表
    例如：
        有一个列表，list[1,2,3,[100,200,300]]
        定义一个函数，向列表中的子列表后追加一个新的元素400 =&gt; list[1,2,3,[100,200,300,400]]
&quot;&quot;&quot;
def change_list(m_list):
    print(f&quot;函数内修改列表前列表地址：&#123;id(m_list)&#125;,列表中的元素:&#123;m_list&#125;&quot;)
    m_list[3].append(400)
    print(f&quot;函数内修改列表前列表地址：&#123;id(m_list)&#125;,列表中的元素:&#123;m_list&#125;&quot;)

list1 = [1,2,3,[100,200,300]]
print(f&quot;函数外列表地址：&#123;id(list1)&#125;,列表中的元素:&#123;list1&#125;&quot;)
list2 = list1.copy()
print(id(list2))
print(id(list1))
change_list(list1)
print(f&quot;函数外调用函数后列表地址：&#123;id(list1)&#125;,列表中的元素:&#123;list1&#125;&quot;)

#浅拷贝
# list2 = list1.copy()
#深拷贝
# list2 = copy.deepcopy(list1)
-----------------------------------------------
函数外列表地址：2259355396224,列表中的元素:[1, 2, 3, [100, 200, 300]]
2259354860416
2259355396224
函数内修改列表前列表地址：2259355396224,列表中的元素:[1, 2, 3, [100, 200, 300]]
函数内修改列表前列表地址：2259355396224,列表中的元素:[1, 2, 3, [100, 200, 300, 400]]
函数外调用函数后列表地址：2259355396224,列表中的元素:[1, 2, 3, [100, 200, 300, 400]]
</code></pre>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>在程序开发中，有时候希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。返回值就是函数完成工作后，给调用者的一个结果</p>
<p>Ø 在函数中使用 return 关键字可以返回结果 ，并结束正在执行的函数</p>
<p>Ø 如果return后面跟[表达式]，在结束函数的同时向调用方返回一个表达式。</p>
<p>Ø 如果仅仅是return关键字，后面没有加内容，函数执行返回调用方None。</p>
<p>Ø 调用函数一方，可以使用变量来接收函数的返回结果</p>
<p>（1）不带表达式的 <strong>return</strong> 语句，返回 <strong>None</strong>。</p>
<pre><code class="python">def f(a, b, c):
    pass
    return

print(f(1, 2, 3))  # None
</code></pre>
<p>（2）函数中如果没有 <strong>return</strong> 语句，在函数运行结束后也会返回 <strong>None</strong>。</p>
<pre><code class="python">def f(a, b, c):
    pass

print(f(1, 2, 3))  # None
</code></pre>
<p>（3）用变量接收返回结果</p>
<pre><code class="python">def add(num1,num2) :
    &#39;&#39;&#39;求两个数的和&#39;&#39;&#39;
    sum1 = num1 + num2
    return sum1

res = add(10,20)
print(&quot;两个数的和为:&quot; ,res)
</code></pre>
<p>（4）<strong>return</strong> 语句可以返回多个值，多个值会放在一个元组中。</p>
<pre><code class="python">def f(a, b, c):
    return a, b, c, [a, b, c]
print(f(1, 2, 3))  # (1, 2, 3, [1, 2, 3])
</code></pre>
<h4 id="什么是闭包【可以延长局部变量的生命周期-】"><a href="#什么是闭包【可以延长局部变量的生命周期-】" class="headerlink" title="什么是闭包【可以延长局部变量的生命周期 】"></a><strong>什么是闭包</strong>【可以延长局部变量的生命周期 】</h4><p>当调用的函数执行完毕后，函数内的变量就会被销毁。但有时希望在调用函数后函数内的数据能够保存下来重复使用，这时候可以用到闭包。闭包可以避免使用全局值，并提供某种形式的数据隐藏。</p>
<p>构建闭包的条件：</p>
<p>Ø 外部函数内定义一个内部函数。</p>
<p>Ø 内部函数用到外部函数中的变量。</p>
<p>Ø 外部函数将内部函数作为返回值。</p>
<pre><code class="python"># 构建闭包
def linear(a, b):
    def inner(x):
        return a * x + b

    return inner

y1 = linear(1, 1)
print(y1)  # &lt;function linear.&lt;locals&gt;.inner at 0x00000291279D19E0&gt;
print(y1(5))  # 6
</code></pre>
<p>将调用 linear() 后返回的函数对象赋值给 y1，虽然 linear() 函数已经执行完毕，但是我们调用 y1() 时，y1() 仍然记得 linear() 中 a 和 b 的值。</p>
<h4 id="查看闭包中的值"><a href="#查看闭包中的值" class="headerlink" title="查看闭包中的值"></a><strong>查看闭包中的值</strong></h4><p>所有函数对象都有一个 <strong><strong>closure</strong></strong> 属性，如果它是一个闭包函数，则该属性返回单元格对象的元组。</p>
<pre><code class="python">def linear(a, b):
    def inner(x):
        return a * x + b

    return inner

y1 = linear(1, 2)
objects = y1.__closure__
print(objects)
print(objects[0].cell_contents)  # 1
print(objects[1].cell_contents)  # 2
</code></pre>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>全局变量-作用于整个模块<br>局部变量-作用于当前函数<br>在局部作用域内，如果给变量进行赋值操作，会将遍历当做局部变量进行处理</p>
<pre><code class="python">&#39;&#39;&#39;
    该案例演示了全局变量和局部变量
&#39;&#39;&#39;
sum = 0 # 这是一个全局变量

def add(num1,num2) :
    sum = num1 + num2 # 这是一个局部变量
    print(&quot;函数内局部变量的值:&quot;,sum,id(sum))
    return sum

add(10,20)
# print(num1) # num1访问不到
print(&quot;函数外全局变量:&quot;,sum,id(sum))
</code></pre>
<p><code>_global和nonlocal关键字</code></p>
<h5 id="global"><a href="#global" class="headerlink" title="_global"></a>_global</h5><p>在函数内使用 <strong>global</strong> 声明全局变量<br>函数内使用 <strong>global</strong> 声明全局变量后，可以修改全局变量。</p>
<pre><code class="python">var1 = 10
def func():
    # 声明：当前在局部作用域中使用全局的变量 var1
    global var1
    var1 = 20
    print(f&quot;局部作用域中的var1=&#123;var1, id(var1)&#125;&quot;)
func()
print(f&quot;全局作用域中的var1=&#123;var1, id(var1)&#125;&quot;)

----------------------------------------
局部作用域中的var1=(20, 2091892605776)
全局作用域中的var1=(20, 2091892605776)



list1 = [1,2,3]
def func():
    # 声明：当前在局部作用域中使用全局的变量 var1
    list1[0] = 100
    print(f&quot;局部作用域中的var1=&#123;list1, id(list1)&#125;&quot;)
func()
print(f&quot;全局作用域中的var1=&#123;list1, id(list1)&#125;&quot;)
-----------------------------------------
局部作用域中的var1=([100, 2, 3], 1992346097088)
全局作用域中的var1=([100, 2, 3], 1992346097088)
</code></pre>
<h5 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h5><p><strong>nonlocal</strong> 也用作内部作用域修改外部作用域的变量的场景，不过此时外部作用域不是全局作用域而是嵌套作用域。</p>
<pre><code class="python">def outer():
    var1 = 10
    def inner():
        nonlocal var1
        var1 = 20
        print(f&quot;局部作用域中的var1=&#123;var1, id(var1)&#125;&quot;)
    inner()
    print(f&quot;嵌套作用域中的var1=&#123;var1, id(var1)&#125;&quot;)
outer()
------------------------------------------
局部作用域中的var1=(20, 1769305604944)
嵌套作用域中的var1=(20, 1769305604944)
</code></pre>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归是一种逻辑思想，将一个大工作分为逐渐减小的小工作，比如说一个和尚要搬50块石头，他想，只要先搬走49块，那剩下的一块就能搬完了，然后考虑那49块，只要先搬走48块，那剩下的一块就能搬完了……，递归是一种思想，只不过在程序中，就是依靠函数嵌套这个特性来实现了</p>
<p><strong>本质：</strong>递归调用就是在函数体中又调用了函数本身</p>
<h4 id="匿名函数的定义"><a href="#匿名函数的定义" class="headerlink" title="匿名函数的定义"></a>匿名函数的定义</h4><p><strong>匿名函数</strong></p>
<p><strong>语法</strong></p>
<p>Python使用 <span style = "color:red"><strong>lambda</strong></span> 来定义匿名函数，所谓匿名，指其不用 <strong>def</strong> 的标准形式定义函数。</p>
<p><code>lambda 参数列表: 表达式</code></p>
<p>Ø lambda 只是一个表达式，函数体比def简单很多。<br>Ø lambda的主体是一个表达式，而不是一个代码块，所以仅仅能在lambda表达式中封装有限的逻辑进去。<br>Ø lambda函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
<h5 id="普通函数传参"><a href="#普通函数传参" class="headerlink" title="普通函数传参"></a>普通函数传参</h5><pre><code class="python">def operator(a, b):
    return a + b
def function(a, b, operator):
    return operator(a, b)
print(function(1, 2, operator))
</code></pre>
<h5 id="匿名函数传参"><a href="#匿名函数传参" class="headerlink" title="匿名函数传参"></a>匿名函数传参</h5><pre><code class="python">def function(a, b, operator):
    return operator(a, b)
print(function(1, 2, lambda x, y: x + y))
</code></pre>
<h4 id="匿名函数作为内置函数的参数"><a href="#匿名函数作为内置函数的参数" class="headerlink" title="匿名函数作为内置函数的参数"></a>匿名函数作为内置函数的参数</h4><p>可以将匿名函数与常用的内置参数搭配使用。</p>
<ul>
<li><strong>sorted()</strong></li>
</ul>
<pre><code class="python">#有三名学生的姓名和年龄，按年龄排序。
student_list = [&#123;&quot;name&quot;: &quot;zhang3&quot;, &quot;age&quot;: 36&#125;, &#123;&quot;name&quot;: &quot;li4&quot;, &quot;age&quot;: 14&#125;, &#123;&quot;name&quot;: &quot;wang5&quot;, &quot;age&quot;: 27&#125;]
print(sorted(student_list, key=lambda x: x[&quot;age&quot;]))
-----------------------------------------------------
student_list.sort(key= lambda stu: stu[&quot;age&quot;])
print(student_list)
-----------------------------------------------------
def getKey(std):
    return std[&quot;age&quot;]
student_list.sort(key=getKey)
print(student_list)
</code></pre>
<ul>
<li><strong>map</strong>()</li>
</ul>
<pre><code class="python">map() #函数对序列中元素逐一处理。
map_result = map(lambda x: x * x, [0, 1, 3, 7, 9])
print(list(map_result))  # [0, 1, 9, 49, 81]
----------------------------------------------------
list1 = [1,2,3,4,5,6,7,8,9,10]
print(list(map(lambda item: item * item, list1)))
</code></pre>
<ul>
<li><strong>filter</strong>()</li>
</ul>
<pre><code class="python">filter() #函数对序列中元素过滤。
filter_result = filter(lambda x: x &gt;= 0, [-0, -1, -3, 7, 9])
print(list(filter_result))  # [0, 7, 9]
</code></pre>
<ul>
<li><strong>reduce()</strong></li>
</ul>
<pre><code class="python">reduce() #函数对序列中元素进行累积。
from functools import reduce

reduce_result = reduce(lambda x, y: x * y, [1, 2, 3, 4, 5])
print(reduce_result)  # 120
</code></pre>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p><strong>文件的基本概念</strong></p>
<p>在计算机中，文件是存储在磁盘上的数据集合。文件可以包含各种类型的数据，如文本、图像、音频、视频或程序代码。</p>
<p>文件系统通过文件名和文件路径来定位和管理文件。文件名通常包含文件的名称和扩展名，扩展名用于表示文件的类型（例如 <strong>.txt</strong> 表示文本文件，**.jpg** 表示图像文件）。文件路径可以是绝对路径（从文件系统的根目录开始）或相对路径（相对于当前工作目录）。</p>
<p>在编写程序的时候，数据是以二进制的形式存储在内存的，将数据写到磁盘文件的过程称之为持久化。</p>
<h4 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a><strong>文件的分类</strong></h4><p><strong>1）纯文本文件</strong></p>
<p>有统一的编码，可以被看做存储在磁盘上的长字符串。</p>
<p>纯文本文件编码格式常见的有ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16等。</p>
<p><strong>2）二进制文件</strong></p>
<p>没有统一的字符编码，直接由0与1组成。</p>
<p>如图片文件（jpg、png），视频文件（avi）等。</p>
<h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><p><strong>1）打开文件</strong></p>
<p>使用 <strong>open()</strong> 打开或创建文件，该方法执行完毕之后返回的是一个file对象。</p>
<h6 id="常用形式"><a href="#常用形式" class="headerlink" title="常用形式"></a>常用形式</h6><pre><code class="python">open(文件名, 模式)
f = open(&quot;test.txt&quot;, &quot;w&quot;)
</code></pre>
<pre><code class="python">模式       说明
r        读写方式：只读，文件若不存在会报错。默认此模式
w        读写方式：写入，写入前清空原有数据。文件不存在会创建文件
a        读写方式：追加写入，在原有数据后追加，文件不存在会创建文件
x        读写方式：创建新文件并写入，文件若已存在会报错
b        编码方式：以二进制打开。一般用于非文本文件如图片等
t        编码方式：以文本模式打开，默认此模式
+        能读能写
</code></pre>
<p><strong>2）完整形式</strong></p>
<pre><code class="python">open(
    file,  # 文件路径   ★★★★★★★★★
    mode=&quot;r&quot;,  # 文件打开模式
    buffering=-1,  # 缓冲
    encoding=None,  # 文本编码方式，一般用utf8  ★★★★★★★★★
    errors=None,  # 报错级别
    newline=None,  # 区分换行符
    closefd=True,  # 传入的file参数类型
    opener=None,  # 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符
)
</code></pre>
<p><strong>3）关闭文件</strong></p>
<pre><code class="python">f.close()
</code></pre>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><pre><code class="python">&quot;&quot;&quot;
    该案例演示了读写文件操作
&quot;&quot;&quot;

&quot;&quot;&quot;

# 向文件中写入数据
# 打开文件（建立程序和文件之间的通道）
f = open(&quot;test.txt&quot;,&quot;w&quot;)

# 向文件中写入数据
f.write(&quot;hello world\n&quot;)
f.write(&quot;nihao python\n&quot;)

# 关闭和文件之间的建立的通道
f.close()
&quot;&quot;&quot;
# 从文件中读取数据
# 打开文件（建立程序和文件之间的通道）
f = open(&quot;test.txt&quot;,&quot;r&quot;)
# 从文件中读取数据   read() 默认读取所有数据
# print(f.read())
# 从文件中读取指定的字节大小数据
# print(f.read(5))
# print(f.read(8))

# 读取一行数据
# print(f.readline())
# print(f.readline())

# 读取所有行
print(f.readlines())

# 关闭和文件之间的建立的通道
f.close()
</code></pre>
<p>1）<strong>read</strong></p>
<p><strong>read([size])</strong> 可以从文件中读取数据，size 表示要从文件中读取的数据的长度（单位是字节），如果没有传入 size 则读取文件中所有的数据。</p>
<pre><code class="python"># 打开文件
f = open(&quot;test.txt&quot;, &quot;rt&quot;)
# 读取文件所有数据 
print(f.read())
# 关闭文件
f.close()
print(&quot;-&quot;*20)
f = open(&quot;test.txt&quot;, &quot;rt&quot;)
# 读取文件5个字节数据
print(f.read(5))
print(f.read(8))
f.close()
</code></pre>
<p>2）<strong>readline</strong></p>
<p><strong>readline([size])</strong> 可以从文件中读取整行数据，也可以通过 size 设置读取数据的长度。</p>
<pre><code class="python">f = open(&quot;test.txt&quot;, &quot;rt&quot;)
print(f.readline())
print(f.readline(1))
print(f.readline(1))
f.close()
</code></pre>
<p>3）<strong>readlines</strong></p>
<p><strong>readlines([size])</strong> 读取所有行并返回列表，若给定 size&gt;0，返回总和大约为 size 字节的行， 实际读取值可能比 size 大。</p>
<pre><code class="python">f = open(&quot;test.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)
print(f.readlines())
f.close()
</code></pre>
<h5 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h5><pre><code class="python">函数    说明
# 移动偏移量并返回新的绝对位置
file.seek(offset[,from])    。
offset：移动的字节数，如果是负数表示从倒数第几位开始。
from：从哪个位置开始移动；0为开头，1为当前位置，2为末尾。from不为0时需使用&#39;b&#39;二进制模式打开文件。
# 返回当前偏移量
file.tell()
# 从开头开始截断文件为size个字符，无size表示从当前位置截断。windows系统下的换行大小2个字符
file.truncate([size])    
# 将序列中字符串写入文件，需要自己加入换行符
file.writelines(seq)    
# 如果可以读取文件则返回True
file.readable()    
# 如果可以写入文件则返回True
file.writeable()    
# 如果文件支持随机访问则返回True
file.seekable()    
# 重命名文件
os.rename(old,new)
# 删除文件
os.remove(file)
# 创建目录，不支持递归创建
os.mkdir(dir)
# 递归创建目录
os.makedirs(dir)    
# 获取当前路径
os.getcwd()    
# 进入指定目录
os.chdir(dir)
# 获取目录下文件和目录列表
os.listdir(dir)    
# 删除空目录
os.rmdir(dir)    
# 递归删除空目录
os.removedirs(dir)    
# 将相对路径转换为绝对路径
os.path.abspath(path)    
# 获取路径中的文件名部分
os.path.basename(path)    
# 获取路径中的目录部分
os.path.dirname(path)    
# 拼接多个路径，自动处理路径分隔符
os.path.join(*paths)    
# 将路径分割为目录和文件名的元组
os.path.split(path)    
# 将路径分割为文件名和扩展名的元组
os.path.splitext(path)    
# 判断路径是否存在
os.path.exists(path)    
# 判断路径是否为文件
os.path.isfile(path)    
# 判断路径是否为目录
os.path.isdir(path)    
# 获取文件的大小，以字节为单位
os.path.getsize(path)    
# 获取文件的最后访问时间
os.path.getatime(path)    
# 获取文件的最后修改时间
os.path.getmtime(path)    
</code></pre>
<h4 id="图片拷贝"><a href="#图片拷贝" class="headerlink" title="图片拷贝"></a>图片拷贝</h4><pre><code class="python">def file_copy(source_file_path, dest_file_path):
    # 打开源文件
    source_file = open(source_file_path, &#39;rb&#39;)
    # 从源文件中读取数据
    content = source_file.read()
    # 打开目标文件
    dest_file = open(dest_file_path, &#39;wb&#39;)
    # 将内容写到目标文件
    dest_file.write(content)
    # 关闭源文件
    source_file.close()
    # 关闭目标文件
    dest_file.close()
file_copy(&quot;c:\\Users\\Pluminary\\Desktop\\HouDuan\\22.png&quot;,&quot;c:\\Users\\Pluminary\\Desktop\\HouDuan\\echos\\11.png&quot;)
</code></pre>
<h5 id="图片拷贝优化-不要一次性读取完，要指定读取字节"><a href="#图片拷贝优化-不要一次性读取完，要指定读取字节" class="headerlink" title="图片拷贝优化[不要一次性读取完，要指定读取字节]"></a>图片拷贝优化[不要一次性读取完，要指定读取字节]</h5><pre><code class="python">def file_copy(source_file_path, dest_file_path):
    # 打开源文件
    source_file = open(source_file_path, &#39;rb&#39;)
    # 打开目标文件
    dest_file = open(dest_file_path, &#39;wb&#39;)

    # 从源文件中读取数据
    content = source_file.read(1024)

    # 将内容写到目标文件
    while content:
        dest_file.write(content)
        content = source_file.read(1024)
    # 关闭源文件
    source_file.close()
    # 关闭目标文件
    dest_file.close()
file_copy(&quot;c:\\Users\\Pluminary\\Desktop\\HouDuan\\22.png&quot;,&quot;c:\\Users\\Pluminary\\Desktop\\HouDuan\\echos\\1.png&quot;)
</code></pre>
<h4 id="面向对象之类和对象"><a href="#面向对象之类和对象" class="headerlink" title="面向对象之类和对象"></a><span style="color:red">面向对象之类和对象</span></h4><p>面向过程编程（Procedural Programming）和面向对象编程（OOP）是两种不同的编程范式，它们在软件开发中都有广泛的应用。</p>
<p>Python是一种混合型的语言，既支持面向过程的编程，也支持面向对象的编程。</p>
<p>面向过程的编程是一种以过程为中心的编程方式，主要关注解决问题的步骤，并将这些步骤写成函数或方法。</p>
<p>面向对象的编程是一种以对象为中心的编程方式，主要关注在解决问题的过程中涉及哪些对象以及这些对象如何交互</p>
<pre><code class="python">&quot;&quot;&quot;
    该案例对比面向过程变成、面向函数式编程、面向对象编程

    准备做3道菜，通过程序描述出每道菜的做菜流程
    东北大拉皮
    东北大乱炖
    锅包肉

    *的意思是：可能要拌多种食物
&quot;&quot;&quot;

# 面向对象的编程
class 菜:
    def __init__(self,name):
        self.name = name

    def 洗(self,clm):
        print(f&quot;&#123;self.name&#125;洗&#123;clm&#125;&quot;)

    def 切(self,clm):
        print(f&quot;&#123;self.name&#125;切&#123;clm&#125;&quot;)

    def 拌(self,*clm):
        print(f&quot;&#123;self.name&#125;拌&#123;clm&#125;&quot;)

    def 炖(self,*clm):
        print(f&quot;&#123;self.name&#125;炖&#123;clm&#125;&quot;)

    def 炸(self,clm):
        print(f&quot;&#123;self.name&#125;炸&#123;clm&#125;&quot;)

    def 上菜(self):
        print(f&quot;&#123;self.name&#125;上菜&quot;)
        
# dlp是面向对象的对象
dlp = 菜(&quot;东北大拉皮&quot;)
dlp.洗(&quot;黄瓜&quot;)
dlp.洗(&quot;拉皮&quot;)
dlp.切(&quot;黄瓜&quot;)
dlp.拌(&quot;黄瓜&quot;,&quot;拉皮&quot;,&quot;调料&quot;)
dlp.上菜()


&quot;&quot;&quot;
面向函数的编程方式
def 东北大拉皮(func):
    洗(&quot;黄瓜&quot;)
    洗(&quot;拉皮&quot;)
    切(&quot;黄瓜&quot;)
    拌(&quot;黄瓜&quot;, &quot;拉皮&quot;, &quot;调料&quot;)
    上菜(&quot;东北大拉皮&quot;)

def 东北大乱炖():
    洗(&quot;白菜&quot;)
    洗(&quot;豆角&quot;)
    洗(&quot;土豆&quot;)
    切(&quot;肉&quot;)
    炖(&quot;白菜&quot;, &quot;土豆&quot;, &quot;豆角&quot;, &quot;肉&quot;, &quot;玉米&quot;, &quot;粉条&quot;, &quot;调料&quot;)
    上菜(&quot;东北大乱炖&quot;)

def 小酥肉():
    洗(&quot;肉&quot;)
    切(&quot;肉&quot;)
    拌(&quot;肉&quot;, &quot;淀粉&quot;)
    炸(&quot;肉&quot;)
    上菜(&quot;小酥肉&quot;)
    print(&quot;~&quot; * 30)
东北大拉皮()
东北大乱炖()
小酥肉()
&quot;&quot;&quot;


&quot;&quot;&quot;
    面向过程的编程方式
        适合一些简单的流程和步骤，如果业务比较复杂，不太合适
# 东北大拉皮
洗(&quot;黄瓜&quot;)
洗(&quot;拉皮&quot;)
切(&quot;黄瓜&quot;)
拌(&quot;黄瓜&quot;,&quot;拉皮&quot;,&quot;调料&quot;)
上菜(&quot;东北大拉皮&quot;)
print(&quot;~&quot;*30)
# 东北大乱炖
洗(&quot;白菜&quot;)
洗(&quot;豆角&quot;)
洗(&quot;土豆&quot;)
切(&quot;肉&quot;)
炖(&quot;白菜&quot;,&quot;土豆&quot;,&quot;豆角&quot;,&quot;肉&quot;,&quot;玉米&quot;,&quot;粉条&quot;,&quot;调料&quot;)
上菜(&quot;东北大乱炖&quot;)
print(&quot;~&quot;*30)
# 小酥肉
洗(&quot;肉&quot;)
切(&quot;肉&quot;)
拌(&quot;肉&quot;,&quot;淀粉&quot;)
炸(&quot;肉&quot;)
上菜(&quot;小酥肉&quot;)
print(&quot;~&quot;*30)
&quot;&quot;&quot;
</code></pre>
<h4 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h4><p>类是大量对象共性的抽象</p>
<ul>
<li>有什么——属性</li>
<li>能做什么——方法</li>
</ul>
<p>在程序中，类是创建对象的模板<br>类是客观事物在人脑中的主观反应</p>
<p>对象在自然界中，只要是客观存在事物都是（万物皆对象）<br>类是抽象的，对象是具体的</p>
<p>类的组成</p>
<ul>
<li>class类名：</li>
<li>属性<ul>
<li>类属性</li>
<li>实例属性</li>
</ul>
</li>
<li>方法<ul>
<li>类方法</li>
<li>实例方法</li>
<li>静态方法</li>
<li>特殊方法(魔法方法)</li>
</ul>
</li>
</ul>
<h4 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h4><p><strong>1）语法</strong></p>
<pre><code class="python">class 类名:
  &quot;&quot;&quot;类说明文档&quot;&quot;&quot;
  类体
</code></pre>
<p>类名一般使用大驼峰命名法。<br>类体中可以包含类属性（也叫类变量）、方法、实例属性（也叫实例变量）等。</p>
<pre><code class="python">&quot;&quot;&quot;
    该案例演示了简单的类的定义以及对象的创建
&quot;&quot;&quot;

# 定义一个学生类
class Student:
    &#39;&#39;&#39;这是一个学生类&#39;&#39;&#39;
    # 类属性   所有类的实例共享的
    school = &quot;atguigu&quot;

    # 在创建学生对象（实例）的时候，会自动调用的方法
    def __init__(self, name, age):
        # 定义实例属性   每个实例属性是独立的，相互不影响
        self.name = name
        self.age = age

    # 实例方法  方法第一个参数是self，表示当前实例对象
    # 对象.方法() 调用当前方法的时候，会将当前对象自身作为参数传递给方法
    def play_game(self):
        print(f&quot;&#123;self.age&#125;岁的&#123;self.name&#125;正在专注的玩着游戏&quot;)

    def study(self):
        print(f&quot;&#123;self.age&#125;岁的&#123;self.name&#125;正在有一搭没一搭的学着&quot;)

    def video(self):
        print(f&quot;&#123;self.age&#125;岁的&#123;self.name&#125;正在录着视频&quot;)

# 通过类这个模板创建当前类的实例(对象)
mzl = Student(&quot;mzl&quot;,23)
print(mzl.name)
print(mzl.age)
print(mzl.school)
mzl.video()

dgd = Student(&quot;dgd&quot;, 23)
print(dgd.name)
print(dgd.age)
print(mzl.school)
dgd.study()
</code></pre>
<h4 id="类的定义以及类的操作"><a href="#类的定义以及类的操作" class="headerlink" title="类的定义以及类的操作"></a>类的定义以及类的操作</h4><h6 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h6><p><code>类名.成员名</code><br><strong>案例：</strong></p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;

    home = &quot;earth&quot;

    def __init__(self):
        self.age = 0

    def eat(self):
        print(&quot;eating...&quot;)

    def drink(self):
        print(&quot;drinking...&quot;)
---------------------------------------------------------------
home = Person.home  # 获取一个字符串 这里是通过类
eat_function = Person.eat  # 获取一个函数对象
doc = Person.__doc__  # 获取类的说明文档

print(home)  # earth
print(eat_function)  # &lt;function Person.eat at 0x00000232C8230F40&gt;
print(doc)  # 人的类
-----------------------------或者-------------------------------
p = Person()  # 创建一个对象
print(p.home)  # earth    这里是通过对象
print(p.age)  # 0
p.eat()  # eating...
p.drink()  # drinking...
</code></pre>
<h3 id="init"><a href="#init" class="headerlink" title="_ _ init() _ _"></a><span style = "color:red"><strong>_ _ init() _ _</strong></span></h3><p><code>__init__() 方法的调用时机在实例（通过 [__new__()](#object.__new__)）被创建之后，返回调用者之前。一般用于初始化一些数据。当类定义了 __init__() 方法后，在类实例化的时候会自动调用 __init__() 方法。也可以向 __init__() 方法中传参。</code></p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;

    home = &quot;earth&quot;

    def __init__(self, name):
        self.name = name

p = Person(&quot;张三&quot;)  # 创建一个对象
print(p.name)  # 张三
</code></pre>
<h3 id="self-作为实例传参"><a href="#self-作为实例传参" class="headerlink" title="self 作为实例传参"></a><span style = "color:red"><strong>self 作为实例传参</strong></span></h3><p><strong>self</strong>代表类的实例自身。调用实例方法时，实例对象会作为第一个参数被传入。因此，我们调用p.eat()时就相当于调用了Person.eat(p)。<br>在<code>__init__</code>方法以及其他的实例方法中，第一个参数都是self<br>self是一个约定俗成的名字，一般不需要我们去关心，可以通过self去调用当前类中其他实例属性或方法；<code>__init__</code>不能又返回值只能是None</p>
<pre><code class="python">class Student:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def eat(self):
        print(&quot;eating&quot;)
    def study(self):
        print(&quot;studying&quot;)
    def study_eat(self):
        self.eat()
        self.study()
zsf = Student(&quot;zsf&quot;,18)
zsf.study_eat()
-------------------------------
eating
studying
</code></pre>
<h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><p><u>类属性也叫类变量，在类中方法外面进行定义</u><br>类中所有的实例共享这个类属性</p>
<p>1）通过 <code>类名.属性名</code> 或 <code>实例名.属性名</code> 访问</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    home = &quot;earth&quot;  # 定义类属性
print(Person.home)  # 通过类名访问类属性

p1 = Person()  # 创建一个实例对象
print(p1.home)  # 通过实例名访问类属性，(如果实例没有覆盖这个类属性的值)
</code></pre>
<p>2）通过 <code>类名.属性名</code> 添加与修改类属性</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
Person.home = &quot;earth&quot;  # 添加类属性
print(Person.home)  # earth

Person.home = &quot;mars&quot;  # 修改类属性
print(Person.home)  # mars
</code></pre>
<p>若使用 实例名.属性名 则会创建或修改实例属性，因此不建议类属性和实例属性同名</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    home = &quot;earth&quot;
p1 = Person()
p2 = Person()
print(Person.home)  # earth
print(p1.home)  # earth
print(p2.home)  # earth

print(&quot;通过 类名.属性名 修改 类属性&quot;)
Person.home = &quot;mars&quot;
print(Person.home)  # mars
print(p1.home)  # mars
print(p2.home)  # mars

print(&quot;通过 实例名.属性名 会创建 实例属性&quot;)
p1.home = &quot;venus&quot;
print(Person.home)  # mars
print(p1.home)  # venus
print(p2.home)  # mars
</code></pre>
<p>3）所有该类的实例共享同一个类属性</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    home = &quot;earth&quot;  # 定义类属性，所有实例共享

p1 = Person()  # 创建一个实例对象
p2 = Person()  # 创建另一个实例对象

print(p1.home)  # earth
print(p2.home)  # earth
Person.home = &quot;mars&quot;  # 修改类属性
print(p1.home)  # mars
print(p2.home)  # mars
</code></pre>
<h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>也叫实例变量。在类方法中定义的属性。通过 <code>self.属性名</code>定义。</p>
<p>1）通过<code>实例名.属性名</code> 访问</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;

    def __init__(self, name, age):
        self.name = name  # 定义实例属性
        self.age = age  # 定义实例属性

p1 = Person(&quot;张三&quot;, 18)  # 创建一个实例对象
print(p1.name, p1.age)  # 张三 18

p2 = Person(&quot;李四&quot;, 81)  # 创建一个实例对象
print(p2.name, p2.age)  # 李四 81

print(Person.name)  # 报错
</code></pre>
<p>2）通过 <code>实例名.属性名</code> 添加与修改实例属性<br>只是对当前的实例添加 对其他的没有影响</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    pass
p1 = Person()  # 创建一个实例对象
p1.name = &quot;张三&quot;  # 添加实例属性
p1.age = 18  # 添加实例属性
print(p1.name, p1.age)  # 张三 18

p1.age = 25  # 修改实例属性
print(p1.name, p1.age)  # 张三 25
</code></pre>
<p>3）每个实例独有一份实例属性</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    def __init__(self, name):
        self.name = name  # 定义实例属性
        self.age = 0  # 定义实例属性

p1 = Person(&quot;张三&quot;)  # 创建一个实例对象
print(p1.name, p1.age)  # 张三 0
p1.age = 18  # 修改p1的age属性
print(p1.name, p1.age)  # 张三 18

p2 = Person(&quot;李四&quot;)  # 创建另一个实例对象
print(p2.name, p2.age)  # 李四 0
</code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Python的类中有三种方法：实例方法、静态方法、类方法</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>Ø 实例方法在类中定义，第一个参数为self，代表实例本身。<br>Ø 实例方法只能被实例对象调用。<br>Ø 可以访问实例属性、类属性、类方法。</p>
<pre><code class="python">class Person:
    &quot;&quot;&quot;人的类&quot;&quot;&quot;
    home = &quot;earth&quot;

    def __init__(self, name):
        self.name = name

    def instance_method(self):
        print(self.name, self.home, Person.home)

p = Person(&quot;张三&quot;)
p.instance_method()  # 张三 earth earth，此时p中没有home实例属性，会去查找home类属性
Person.home = &quot;venus&quot;  # 修改类属性
p.home = &quot;mars&quot;  # 定义实例属性
p.instance_method()  # 张三 mars venus
</code></pre>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>Ø 类方法在类中通过 @classmethod 定义，第一个参数为cls，代表类本身。<br>Ø 类方法可以被类和实例对象调用。<br>Ø 可以访问类属性。</p>
<p>在不创建实例的情况下调用，通过类名直接调用，非常方便，适合一些和类整体相关的操作。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>Ø 静态方法在类中通过 @staticmethod 定义<br>Ø 不访问实例属性或类属性，只依赖于传入的参数<br>Ø 可以通过类名或实例调用，但它不会访问类或实例的内部信息，更像是一个工具函数，只是为了方便组织代码，把它放在了类里面。</p>
<pre><code class="python">&quot;&quot;&quot;
    该案例演示了方法
&quot;&quot;&quot;
import types


def drink(self):
    print(&quot;drinking&quot;)

class Student:
    &quot;&quot;&quot;这是一个学生类&quot;&quot;&quot;
    school = &quot;atguigu&quot;
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 实例方法
    def eat(self):
        print(self.school)
        print(self.name)
        print(self.age)

    # 类方法
    @classmethod
    def get_info(cls):
        print(cls.school)
        print(cls.__doc__)

zwj = Student(&quot;zwj&quot;,30)
# zwj.eat()
# zwj.get_info()
# Student.get_info()

# zwj.drink = drink
# zwj.drink()

# Student.drink = drink
# zwj.drink()
# Student.drink(zwj)

zcs = Student(&quot;zcs&quot;,50)

zcs.drink = types.MethodType(drink, zcs)
zcs.drink()

Student.get_info()


&quot;&quot;&quot;
class MathUtil:
    @staticmethod  # 不加是用不了的
    def add(a, b):
        return a + b
print(MathUtil.add(10, 20))
&quot;&quot;&quot;
-----------------------------------
drinking
atguigu
这是一个学生类
</code></pre>
<h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><p>方法名中有两个前缀下划线和两个后缀下划线的方法为特殊方法，也叫魔法方法。上文提到的 <code>__init__()</code>就是一个特殊方法。这些方法会在进行特定的操作时自动被调用。</p>
<pre><code class="python">几个常见的特殊方法：

1）__new__()
对象实例化时第一个调用的方法。

2）__init__()
类的初始化方法。

3）__del__()
    对象的销毁器，定义了当对象被垃圾回收时的行为。使用 del xxx 时不会主动调用 __del__() ，除非此时引用计数==0。
    
4）__str__()
定义了对类的实例调用 str() 时的行为。

5）__repr__()
定义对类的实例调用 repr() 时的行为。 str() 和 repr() 最主要的差别在于目标用户。 repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而 str() 则产生人类可读的输出。

6）__getattribute__()
属性访问拦截器，定义了属性被访问前的操作。
</code></pre>
<h3 id="动态添加属性与方法"><a href="#动态添加属性与方法" class="headerlink" title="动态添加属性与方法"></a>动态添加属性与方法</h3><h4 id="动态给对象添加属性"><a href="#动态给对象添加属性" class="headerlink" title="动态给对象添加属性"></a>动态给对象添加属性</h4><pre><code class="python">class Person:
    def __init__(self, name=None):
        self.name = name

p = Person(&quot;张三&quot;)
print(p.name)  # 张三

p.age = 18
print(p.age)  # 18
</code></pre>
<h4 id="动态给类添加属性"><a href="#动态给类添加属性" class="headerlink" title="动态给类添加属性"></a><strong>动态给类添加属性</strong></h4><pre><code class="python">class Person:
    def __init__(self, name=None):
        self.name = name

p = Person(&quot;张三&quot;)
print(p.name)  # 张三

Person.age = 0
print(p.age)  # 0
</code></pre>
<h4 id="动态给对象添加方法"><a href="#动态给对象添加方法" class="headerlink" title="动态给对象添加方法"></a>动态给对象添加方法</h4><h5 id="1）添加普通方法"><a href="#1）添加普通方法" class="headerlink" title="1）添加普通方法"></a>1）添加普通方法</h5><pre><code class="python">class Person:
    def __init__(self, name=None):
        self.name = name

def eat():
    print(&quot;吃饭&quot;)

p = Person(&quot;张三&quot;)
p.eat = eat
p.eat()  # 吃饭
</code></pre>
<h5 id="2）添加实例方法"><a href="#2）添加实例方法" class="headerlink" title="2）添加实例方法"></a>2）添加实例方法</h5><p>给对象添加的实例方法只绑定在当前对象上，不对其他对象生效，而且需要传入 self 参数。需要使用 types.MethodType(方法名，实例对象) 来添加实例方法。</p>
<pre><code class="python">import types

class Person:
    def __init__(self, name=None):
        self.name = name

def eat(self):
    print(f&quot;&#123;self.name&#125;在吃饭&quot;)

p = Person(&quot;张三&quot;)
p.eat = types.MethodType(eat, p)
p.eat()  # 张三在吃饭
</code></pre>
<h4 id="动态给类添加方法"><a href="#动态给类添加方法" class="headerlink" title="动态给类添加方法"></a>动态给类添加方法</h4><p>给类添加的方法对它的所有对象都生效，添加类方法需要传入 cls 参数，添加静态方法则不需要。</p>
<pre><code class="python">class Person:
    home = &quot;earth&quot;

    def __init__(self, name=None):
        self.name = name

# 定义类方法
@classmethod
def come_from(cls):
    print(f&quot;来自&#123;cls.home&#125;&quot;)

# 定义静态方法
@staticmethod
def static_function():
    print(&quot;static function&quot;)

Person.come_from = come_from
Person.come_from()  # 来自earth

Person.static_function = static_function
Person.static_function()  # static function
</code></pre>
<h4 id="动态删除属性与方法"><a href="#动态删除属性与方法" class="headerlink" title="动态删除属性与方法"></a>动态删除属性与方法</h4><p>Ø <strong>del</strong> 对象**.**属性名<br>Ø <strong>delattr</strong>(对象，属性名)</p>
<h4 id="slots-限制实例属性与实例方法"><a href="#slots-限制实例属性与实例方法" class="headerlink" title="__slots__限制实例属性与实例方法"></a><code>__slots__</code>限制实例属性与实例方法</h4><p>Python允许在定义类的时候，定义一个特殊的 <code>__slots__</code>变量，来限制该类的实例能添加的属性。使用<code>__slots__</code>可以限制添加实例属性和实例方法，但类属性、类方法和静态方法还可以添加。<code>__slots__</code>仅对当前类生效，对其子类无效。</p>
<pre><code class="python">import types

class Person:
    __slots__ = (&quot;name&quot;, &quot;age&quot;, &quot;eat&quot;)

    def __init__(self, name=None):
        self.name = name

def eat(self):
    print(f&quot;&#123;self.name&#125;在吃饭&quot;)

def drink(self):
    print(f&quot;&#123;self.name&#125;在喝水&quot;)

p = Person(&quot;张三&quot;)

# 添加实例属性
p.age = 10
print(p.age)  # 10

# 添加实例方法
p.eat = types.MethodType(eat, p)
p.eat()  # 张三在吃饭

# 添加实例属性
p.weight = 100  # AttributeError: &#39;Person&#39; object has no attribute &#39;weight&#39;

# 添加实例方法
p.drink = type.MethodType(drink, p)  # AttributeError: type object &#39;type&#39; has no attribute &#39;MethodType&#39;
</code></pre>
<h3 id="面向对象之三大特性"><a href="#面向对象之三大特性" class="headerlink" title="面向对象之三大特性"></a>面向对象之三大特性</h3>
    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>