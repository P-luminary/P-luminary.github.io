
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Jenkins</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Jenkins </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/6/15
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#1bccbc>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h3 id="持续集成及JenKins介绍"><a href="#持续集成及JenKins介绍" class="headerlink" title="持续集成及JenKins介绍"></a>持续集成及JenKins介绍</h3><p><strong>配套原版资料</strong>：<a href="file:///E:/Java实例项目1-20套/资料-Jenkins教程/Jenkins资料/笔记/Jenkins持续集成从入门到精通.pdf">Jenkins持续集成从入门到精通.pdf</a></p>
<p>软件开发生命周期【<strong>需求分析、设计、实现、测试、进化</strong>】</p>
<h3 id="软件开发瀑布模型"><a href="#软件开发瀑布模型" class="headerlink" title="软件开发瀑布模型"></a>软件开发瀑布模型</h3><p>瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>简单易用和理解</td>
<td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地 增加了工作量。</td>
</tr>
<tr>
<td>当前一阶段完成后，您只需要 去关注后续阶段</td>
<td>由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险</td>
</tr>
<tr>
<td>为项目提供了按阶段划分的检 查节点</td>
<td>瀑布模型的突出缺点是不适应用户需求的变化</td>
</tr>
</tbody></table>
<h3 id="软件开发敏捷开发模型"><a href="#软件开发敏捷开发模型" class="headerlink" title="软件开发敏捷开发模型"></a>软件开发敏捷开发模型</h3><p>敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。 </p>
<p>&#x3D;&#x3D;<strong>何为迭代开发</strong>？&#x3D;&#x3D; 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大 开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开 发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而 是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨 道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 </p>
<p>&#x3D;&#x3D;<strong>何为增量开发</strong>？&#x3D;&#x3D; 软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一 号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地 基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…..</p>
<p>敏捷开发如何迭代？<br>虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。</p>
<p>敏捷开发有什么好处？  </p>
<p>&#x3D;&#x3D;<strong>早期交付</strong>&#x3D;&#x3D; 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照 传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完 成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后 才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后 面每个月都会有现金流，资金压力就大大减轻了。 </p>
<p>&#x3D;&#x3D;<strong>降低风险</strong>&#x3D;&#x3D; 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比 较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。 <strong>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量</strong>。它的核心措施是，代码集成到主干 之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归 功于持续集成</p>
<h5 id="持续集成的流程"><a href="#持续集成的流程" class="headerlink" title="持续集成的流程"></a>持续集成的流程</h5><h6 id="提交"><a href="#提交" class="headerlink" title="提交"></a><span style = "color:red"><strong>提交</strong></span></h6><p>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。 </p>
<h6 id="测试（第一轮）"><a href="#测试（第一轮）" class="headerlink" title="测试（第一轮） "></a><span style = "color:red"><strong>测试（第一轮）</strong> </span></h6><p>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 </p>
<h6 id="构建"><a href="#构建" class="headerlink" title="构建 "></a><span style = "color:red"><strong>构建</strong> </span></h6><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实 际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 </p>
<h6 id="测试（第二轮）"><a href="#测试（第二轮）" class="headerlink" title="测试（第二轮） "></a><span style = "color:red"><strong>测试（第二轮）</strong> </span></h6><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。 </p>
<h6 id="部署"><a href="#部署" class="headerlink" title="部署 "></a><span style = "color:red"><strong>部署</strong> </span></h6><p>过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 </p>
<h6 id="回滚"><a href="#回滚" class="headerlink" title="回滚 "></a><span style = "color:red"><strong>回滚</strong> </span></h6><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录</p>
<h3 id="持续集成的组成要素"><a href="#持续集成的组成要素" class="headerlink" title="持续集成的组成要素"></a>持续集成的组成要素</h3><ul>
<li>一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的，无需人工干预。 </li>
<li>一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。 </li>
<li>一个持续集成服务器，Jenkins 就是一个配置简单和使用方便的持续集成服务器</li>
</ul>
<h3 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h3><p>1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少；<br>2、对系统健康持续检查，减少发布风险带来的问题；<br>3、减少重复性工作；<br>4、<strong>持续部署</strong>，提供可部署单元包；<br>5、持续交付可供使用的版本；<br>6、增强团队信心</p>
<h3 id="JenKins介绍"><a href="#JenKins介绍" class="headerlink" title="JenKins介绍"></a><span style = "color:red">JenKins介绍</span></h3><p>Jenkins  是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。官网：  <a target="_blank" rel="noopener" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a><br>CI：持续集成（Continuous Integration）<br>CD：持续部署（Continuous ????）</p>
<h4 id="Jenkins的特征："><a href="#Jenkins的特征：" class="headerlink" title="Jenkins的特征："></a>Jenkins的特征：</h4><ul>
<li>开源的 Java语言开发持续集成工具，支持持续集成，持续部署。 </li>
<li>易于安装部署配置：可通过 方便web界面配置管理。 </li>
<li>消息通知及测试报告：集成 yum安装,或下载war包以及通过docker容器等快速实现安装部署，可 RSS&#x2F;E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit&#x2F;TestNG测试报告。 Jenkins能够让多台计算机一起构建&#x2F;测试。 </li>
<li>分布式构建：支持 </li>
<li>文件识别： Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 </li>
<li>丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如 docker等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5a664e75de77e3633f64215df2e5990365c3606a/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E.png" alt="持续集成流程说明"></p>
<h4 id="服务器列表-统一使用CentOS7"><a href="#服务器列表-统一使用CentOS7" class="headerlink" title="服务器列表[统一使用CentOS7]"></a>服务器列表[统一使用CentOS7]</h4><table>
<thead>
<tr>
<th>名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码托管服务器</strong></td>
<td>192.168.200.128</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td><strong>持续集成服务器</strong></td>
<td>192.168.200.129</td>
<td>Jenkins-2.190.3，JDK1.8，Maven3.6.2，Git， SonarQube</td>
</tr>
<tr>
<td><strong>应用测试服务器</strong></td>
<td>192.168.66.102</td>
<td>JDK1.8，Tomcat8.5</td>
</tr>
</tbody></table>
<h3 id="Gitlab-团队个人版github-代码托管服务器安装"><a href="#Gitlab-团队个人版github-代码托管服务器安装" class="headerlink" title="Gitlab[团队个人版github]代码托管服务器安装"></a>Gitlab[团队个人版github]代码托管服务器安装</h3><p>[lanyun_group &#x2F; web_demo · GitLab] (<a target="_blank" rel="noopener" href="http://192.168.200.128:82/lanyun_group/web_demo">http://192.168.200.128:82/lanyun_group/web_demo</a>)</p>
<p>官网：  <a target="_blank" rel="noopener" href="https://about.gitlab.com/">https://about.gitlab.com/</a><br>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的 web服务。</p>
<p>GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似， 可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，GitLab是可以部署到自己的服务器 上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放 在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub</p>
<ul>
<li><p>安装相关依赖 </p>
<blockquote>
<p>yum -y install policycoreutils openssh-server openssh-clients postfix</p>
</blockquote>
</li>
<li><p>启动ssh服务&amp;设置为开机启动</p>
<blockquote>
<p>systemctl enable sshd &amp;&amp; sudo systemctl start sshd </p>
</blockquote>
</li>
<li><p>设置postfix开机自启，并启动，postfix支持gitlab发信功能</p>
<blockquote>
<p>systemctl enable postfix &amp;&amp; systemctl start postfix </p>
</blockquote>
</li>
<li><p>开放ssh以及http服务，然后重新加载防火墙列表 </p>
<blockquote>
<p>firewall-cmd –add-service&#x3D;ssh –permanent<br>firewall-cmd –add-service&#x3D;http –permanent<br>firewall-cmd –reload </p>
</blockquote>
<p>如果关闭防火墙就不需要做以上配置 </p>
</li>
<li><p>下载gitlab包，并且安装 </p>
<blockquote>
<p><strong>在线下载安装包</strong>：<br>wget  <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x</a> 86_64.rpm <strong>安装</strong>：<br>rpm -i gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm </p>
</blockquote>
</li>
<li><p>修改gitlab配置 </p>
<blockquote>
<p>vi &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb </p>
</blockquote>
<p>修改gitlab访问地址和端口，默认为80，我们改为82<br>external_url ‘ <a href="http://192.168.200.132:82&#39;">http://192.168.200.132:82&#39;</a><br>nginx[‘listen_port’] &#x3D; 82 </p>
</li>
<li><p>重载配置及<span style = "color:red"><strong>启动gitlab</strong></span> </p>
<blockquote>
<p>gitlab-ctl reconfigure<br>gitlab-ctl restart  ★★</p>
</blockquote>
</li>
<li><p>把端口添加到防火墙</p>
</li>
</ul>
<blockquote>
<p>firewall-cmd –zone&#x3D;public –add-port&#x3D;82&#x2F;tcp –permanent<br>firewall-cmd –reload </p>
<p>启动成功后，看到以下修改管理员root密码的页面，修改密码后，然后登录即可</p>
</blockquote>
<p>账号：root<br>密码：panchunyao123</p>
<h6 id="Gitlab用户在组里面有5种不同权限："><a href="#Gitlab用户在组里面有5种不同权限：" class="headerlink" title="Gitlab用户在组里面有5种不同权限："></a>Gitlab用户在组里面有5种不同权限：</h6><p>Guest：可以创建issue、发表评论，不能读写版本库<br>Reporter：可以克隆代码，不能提交，QA、PM 可以赋予这个权限<br>Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限<br>Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个 权限 Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组 长可以赋予这个权限</p>
<p>如果张三被管理员添加了Owner权限，那么张三就可以在idea里面通过gitlab里面的仓库地址 上传项目到这个web_demo了。</p>
<h4 id="持续集成环境—Jenkins安装【我用了最新的Jenkins-2-440-1】"><a href="#持续集成环境—Jenkins安装【我用了最新的Jenkins-2-440-1】" class="headerlink" title="持续集成环境—Jenkins安装【我用了最新的Jenkins 2.440.1】"></a>持续集成环境—Jenkins安装【我用了最新的Jenkins 2.440.1】</h4><p>[Setup Wizard [Jenkins]] (<a target="_blank" rel="noopener" href="http://192.168.200.129:8888/">http://192.168.200.129:8888/</a>)</p>
<ul>
<li><p>安装JDK Jenkins需要依赖JDK，所以先安装JDK1.8 </p>
<blockquote>
<p>yum install java-1.8.0-openjdk* -y</p>
</blockquote>
</li>
</ul>
<p>​       安装目录为：&#x2F;usr&#x2F;lib&#x2F;jvm </p>
<ul>
<li>获取jenkins安装包</li>
</ul>
<p>下载页面： <a target="_blank" rel="noopener" href="https://jenkins.io/zh/download/">https://jenkins.io/zh/download/</a><br>安装文件：jenkins-2.190.3-1.1.noarch.rpm </p>
<ul>
<li><p>把安装包上传到192.168.66.101服务器，进行安装 </p>
<blockquote>
<p>rpm -ivh jenkins-2.190.3-1.1.noarch.rpm </p>
</blockquote>
</li>
<li><p>进入文件目录</p>
<blockquote>
<p>cd &#x2F;etc&#x2F;sysconfig</p>
</blockquote>
</li>
<li><p>修改Jenkins配置 </p>
<blockquote>
<p>vi jenkins</p>
</blockquote>
</li>
</ul>
<p>修改内容如下： </p>
<blockquote>
<p>JENKINS_USER&#x3D;”root”<br>JENKINS_PORT&#x3D;”8888” </p>
</blockquote>
<ul>
<li><p><span style = "color:red">启动<strong>Jenkins</strong></span></p>
<blockquote>
<p>systemctl start jenkins ★★</p>
<p>[root@localhost sysconfig]# systemctl start jenkins</p>
</blockquote>
</li>
<li><p>打开浏览器访问<br>[192.168.200.129:8888] (<a target="_blank" rel="noopener" href="http://192.168.200.129:8888/">http://192.168.200.129:8888/</a>)<br>注意：本服务器把防火墙关闭了，如果开启防火墙，需要在防火墙添加端口 </p>
</li>
<li><p>获取并输入admin账户密码 </p>
<blockquote>
<p>[root@localhost sysconfig]# cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword</p>
<p>[root@localhost sysconfig]# cat &#x2F;root&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword<br>3d83c355f83d4942847d4390fc5dcc39</p>
</blockquote>
</li>
<li><p>跳过插件安装 [点击第二个选择 然后上面全无]<br>因为Jenkins插件需要连接默认官网下载，速度非常慢，而且经过会失败，所以我们暂时先跳过插件安装</p>
</li>
</ul>
<h6 id="综上操作"><a href="#综上操作" class="headerlink" title="综上操作"></a>综上操作</h6><blockquote>
<p>[root@localhost ~]# java -version<br>java version “21.0.1” 2023-10-17 LTS<br>Java(TM) SE Runtime Environment (build 21.0.1+12-LTS-29)<br>Java HotSpot(TM) 64-Bit Server VM (build 21.0.1+12-LTS-29, mixed mode, sharing)<br>[root@localhost ~]# cd &#x2F;usr&#x2F;lib&#x2F;jvm<br>[root@localhost jvm]# ll<br>总用量 0<br>lrwxrwxrwx. 1 root root  26 6月  15 16:27 java -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk<br>lrwxrwxrwx. 1 root root  32 6月  15 16:27 java-1.8.0 -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_1.8.0<br>lrwxrwxrwx. 1 root root  40 6月  15 16:27 java-1.8.0-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_1.8.0_openjdk<br>drwxr-xr-x. 9 root root 109 6月  15 16:27 java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64<br>lrwxrwxrwx. 1 root root  34 6月  15 16:27 java-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;java_sdk_openjdk<br>lrwxrwxrwx. 1 root root  21 6月  15 16:27 jre -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre<br>lrwxrwxrwx. 1 root root  27 6月  15 16:27 jre-1.8.0 -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_1.8.0<br>lrwxrwxrwx. 1 root root  35 6月  15 16:27 jre-1.8.0-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_1.8.0_openjdk<br>lrwxrwxrwx. 1 root root  49 6月  15 16:27 jre-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64 -&gt; java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64&#x2F;jre<br>lrwxrwxrwx. 1 root root  29 6月  15 16:27 jre-openjdk -&gt; &#x2F;etc&#x2F;alternatives&#x2F;jre_openjdk<br>[root@localhost jvm]# cd java-1.8.0-openjdk<br>[root@localhost java-1.8.0-openjdk]#</p>
</blockquote>
<blockquote>
<h2 id="下一步：你只需要执行-升级Jenkins的升级流程"><a href="#下一步：你只需要执行-升级Jenkins的升级流程" class="headerlink" title="下一步：你只需要执行 升级Jenkins的升级流程"></a>下一步：你只需要执行 升级Jenkins的升级流程</h2><h3 id="以下是你的专属升级操作指令合集（CentOS-7-专用）："><a href="#以下是你的专属升级操作指令合集（CentOS-7-专用）：" class="headerlink" title="以下是你的专属升级操作指令合集（CentOS 7 专用）："></a>以下是你的专属升级操作指令合集（CentOS 7 专用）：</h3><hr>
<h3 id="🔧-1-备份-Jenkins-数据（可选但强烈推荐）"><a href="#🔧-1-备份-Jenkins-数据（可选但强烈推荐）" class="headerlink" title="🔧 1. 备份 Jenkins 数据（可选但强烈推荐）"></a>🔧 1. 备份 Jenkins 数据（可选但强烈推荐）</h3><pre><code class="js">sudo systemctl stop jenkins
sudo cp -r /var/lib/jenkins /var/lib/jenkins_backup_$(date +%F)
sudo cp /etc/sysconfig/jenkins /etc/sysconfig/jenkins.bak
</code></pre>
<hr>
<h3 id="🔧-2-添加-Jenkins-官方-LTS-Yum-源"><a href="#🔧-2-添加-Jenkins-官方-LTS-Yum-源" class="headerlink" title="🔧 2. 添加 Jenkins 官方 LTS Yum 源"></a>🔧 2. 添加 Jenkins 官方 LTS Yum 源</h3><pre><code class="js">sudo curl --silent --location https://pkg.jenkins.io/redhat-stable/jenkins.repo | sudo tee /etc/yum.repos.d/jenkins.repo &gt; /dev/null
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
</code></pre>
<hr>
<h3 id="🔧-3-升级-Jenkins"><a href="#🔧-3-升级-Jenkins" class="headerlink" title="🔧 3. 升级 Jenkins"></a>🔧 3. 升级 Jenkins</h3><pre><code class="js">sudo yum clean all
sudo yum makecache
sudo yum upgrade jenkins -y
</code></pre>
<p>如果提示没有可升级的版本，执行以下命令强制重新安装最新版 Jenkins：</p>
<pre><code class="js">sudo yum remove jenkins -y
sudo yum install jenkins -y
</code></pre>
<p>⚠️ <strong>不会丢失数据</strong>，因为 Jenkins 配置、任务、插件都在 <code>/var/lib/jenkins</code> 中，你已经备份过。</p>
<hr>
<h3 id="🔧-4-启动-Jenkins-并查看状态"><a href="#🔧-4-启动-Jenkins-并查看状态" class="headerlink" title="🔧 4. 启动 Jenkins 并查看状态"></a>🔧 4. 启动 Jenkins 并查看状态</h3><pre><code class="js">sudo systemctl daemon-reexec
sudo systemctl start jenkins
sudo systemctl status jenkins
</code></pre>
<hr>
<h3 id="🔧-5-访问-Jenkins-页面"><a href="#🔧-5-访问-Jenkins-页面" class="headerlink" title="🔧 5. 访问 Jenkins 页面"></a>🔧 5. 访问 Jenkins 页面</h3><p>访问地址：</p>
<pre><code class="js">http://&lt;你的服务器IP&gt;:8888
</code></pre>
<hr>
<h3 id="🔧-6-查看-Jenkins-新版本号"><a href="#🔧-6-查看-Jenkins-新版本号" class="headerlink" title="🔧 6. 查看 Jenkins 新版本号"></a>🔧 6. 查看 Jenkins 新版本号</h3><pre><code class="js">jenkins --version
</code></pre>
<p>或者登录网页右下角查看，应该是类似：</p>
<pre><code class="js">Jenkins ver. 2.440.1
</code></pre>
</blockquote>
<blockquote>
<h2 id="查看-Jenkins-服务状态"><a href="#查看-Jenkins-服务状态" class="headerlink" title="查看 Jenkins 服务状态"></a>查看 Jenkins 服务状态</h2><p>请运行以下命令获取具体错误：</p>
<pre><code class="js">sudo systemctl status jenkins -l
</code></pre>
</blockquote>
<blockquote>
<h3 id="步骤-3：重启-Jenkins-服务"><a href="#步骤-3：重启-Jenkins-服务" class="headerlink" title="步骤 3：重启 Jenkins 服务"></a>步骤 3：重启 Jenkins 服务</h3><pre><code class="js">sudo systemctl daemon-reexec
sudo systemctl restart jenkins
sudo systemctl status jenkins -l
</code></pre>
</blockquote>
<blockquote>
<h3 id="🔗-插件下载地址与命令"><a href="#🔗-插件下载地址与命令" class="headerlink" title="🔗 插件下载地址与命令"></a>🔗 插件下载地址与命令</h3><p>以下命令会下载所有缺失依赖：</p>
<pre><code>bash复制编辑# 进入 Jenkins 插件目录
cd /var/lib/jenkins/plugins

# 下载缺失的依赖插件
wget https://updates.jenkins.io/download/plugins/commons-lang3-api/3.13.0-62.v7d18e55f51e2/commons-lang3-api.hpi
wget https://updates.jenkins.io/download/plugins/ionicons-api/56.v1b_1c8c49374e/ionicons-api.hpi
wget https://updates.jenkins.io/download/plugins/caffeine-api/3.1.8-133.v17b_1ff2e0599/caffeine-api.hpi
</code></pre>
</blockquote>
<h4 id="持续集成环境—Jenkins插件管理【Manage-Jenkins】"><a href="#持续集成环境—Jenkins插件管理【Manage-Jenkins】" class="headerlink" title="持续集成环境—Jenkins插件管理【Manage Jenkins】"></a>持续集成环境—Jenkins插件管理【Manage Jenkins】</h4><p>Jenkins本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用 Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。 </p>
<h5 id="修改Jenkins插件下载地址"><a href="#修改Jenkins插件下载地址" class="headerlink" title="修改Jenkins插件下载地址"></a>修改Jenkins插件下载地址</h5><p>Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址：<br>Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available<br>新版本：<u>Jenkins → Manage Jenkins → Plugins → Avaliable plugins</u></p>
<h5 id="去Jenkins默认的开发目录"><a href="#去Jenkins默认的开发目录" class="headerlink" title="去Jenkins默认的开发目录"></a>去Jenkins默认的开发目录</h5><p>这样做是为了把 Jenkins官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址</p>
<blockquote>
<p>[root@localhost sysconfig]# cd &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;<br>[root@localhost jenkins]# cd updates&#x2F;<br>[root@localhost updates]# ll<br>总用量 3064<br>-rw-r–r–. 1 root root 3125621 6月  15 16:38 default.json<br>-rw-r–r–. 1 root root    7976 6月  15 16:38 hudson.tasks.Maven.MavenInstaller</p>
</blockquote>
<blockquote>
<p>sed -i ‘s&#x2F;http://updates.jenkins ci.org/download&#x2F;https://mirrors.tuna.tsinghua.edu.cn/jenkins&#x2F;g’ default.json &amp;&amp; sed -i ‘s&#x2F;http:// <a target="_blank" rel="noopener" href="http://www.google.com/https:////">www.google.com/https:\/\/</a> <a target="_blank" rel="noopener" href="http://www.baidu.com/g&#39;">www.baidu.com/g&#39;</a> default.json</p>
</blockquote>
<p>最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/restart">http://192.168.200.129:8888/restart</a> 重启Jenkins</p>
<h4 id="下载中文汉化插件"><a href="#下载中文汉化插件" class="headerlink" title="下载中文汉化插件"></a>下载中文汉化插件</h4><p><a target="_blank" rel="noopener" href="http://192.168.66.101:8888/restart">http://192.168.66.101:8888/restart</a> ，重启Jenkins。 Jenkins-&gt;Manage Jenkins-&gt;Manage Plugins，点击Available，搜索”Chinese”</p>
<h4 id="开启权限全局安全配置"><a href="#开启权限全局安全配置" class="headerlink" title="开启权限全局安全配置"></a>开启权限全局安全配置</h4><p>在Security中的授权策略切换为 “Role-Based Strategy”，保存</p>
<p>【从插件市场上下载下来的 可以直接通过MobaXterm 放在&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;plugins&#x2F; 然后重启Jenkins】</p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><p>在系统管理页面进入 Manage and Assign Roles；点击”Manage Roles”</p>
<p>里面的<strong>Global roles</strong>（全局角色）：管理员等高级用户可以创建基于全局的角色 Project roles（项目角色）： 针对某个或者某些项目的角色 Slave roles（奴隶角色）：节点相关的权限</p>
<p>我们添加以下三个角色：【<u>一个基础角色 两个项目角色</u>】</p>
<ul>
<li><strong>baseRole</strong> ：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑 定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色，会报错误：用户名 is missing the Overall&#x2F;Read permission </li>
<li><strong>role1</strong> ：该角色为<strong>项目角色</strong>(下面的Item roles)。使用正则表达式绑定” <strong>itcast.</strong>* “，意思是只能操作itcast开头的项目。</li>
<li><strong>role2</strong> ：该角色也为<strong>项目角色</strong>。绑定”itheima.*”，意思是只能操作itheima开头的项目。</li>
</ul>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>在系统管理页面进入 <strong>Manage Users</strong><br><strong>用户一</strong>：用户名：eric     密码：123456<br><strong>用户二</strong>：用户名：JacK    密码：123456</p>
<h4 id="给用户分配角色"><a href="#给用户分配角色" class="headerlink" title="给用户分配角色"></a>给用户分配角色</h4><p>系统管理页面进入Manage and Assign Roles，点击Assign Roles<br>绑定规则如下： </p>
<ul>
<li>eric 用户分别绑定baseRole和role1角色 </li>
<li>jack 用户分别绑定baseRole和role2角色</li>
</ul>
<h4 id="创建项目测试权限"><a href="#创建项目测试权限" class="headerlink" title="创建项目测试权限"></a>创建项目测试权限</h4><p>以itcast管理员账户创建两个项目，分别为itcast01和itheima01</p>
<p>结果为： </p>
<ul>
<li>eric 用户登录，只能看到itcast01项目 </li>
<li>jack 用户登录，只能看到itheima01项目</li>
</ul>
<h2 id="持续集成环境—Jenkins凭证管理"><a href="#持续集成环境—Jenkins凭证管理" class="headerlink" title="持续集成环境—Jenkins凭证管理"></a>持续集成环境—Jenkins凭证管理</h2><p>凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，<u><strong>以便 Jenkins可以和这些第三方的应用进行交互</strong></u>。 </p>
<h5 id="安装Credentials-Binding插件"><a href="#安装Credentials-Binding插件" class="headerlink" title="安装Credentials Binding插件"></a>安装Credentials Binding插件</h5><p>要在Jenkins使用凭证管理功能，需要安装<strong>Credentials Binding</strong>插件<br>安装插件后，左边多了”<strong>凭证</strong>“菜单，在这里管理所有凭证 [新版是在<strong>Security</strong>栏有<strong>凭证管理</strong>]<br>进入凭据后点击<strong>Stores scoped to Jenkins</strong>下     <strong>域</strong>的**<u>全局</u>**</p>
<h6 id="可以添加的凭证有-5种："><a href="#可以添加的凭证有-5种：" class="headerlink" title="可以添加的凭证有 5种："></a>可以添加的凭证有 5种：</h6><ul>
<li>Username with password ：用户名和密码 </li>
<li>SSH Username with private key： 使用SSH用户和密钥 </li>
<li>Secret file：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的Secret file就会被删除。 </li>
<li>Secret text ：需要保存的一个加密的文本串，如钉钉机器人或Github的api token【k8s也会用】</li>
<li>Certificate ：通过上传证书文件的方式</li>
</ul>
<p>常用的凭证类型有：<strong>Username with password（用户密码）</strong>和<strong>SSH Username with private key（SSH 密钥）</strong><br>接下来以使用Git工具到Gitlab拉取项目源码为例，演示Jenkins的如何管理Gitlab的凭证<br>★ <u><strong>在Jenkins里面安装git插件</strong></u><br>★ <u>要先在<strong>Jenkins的服务</strong>里面安装git插件</u></p>
<p><strong>CentOS7上安装Git工具</strong>：</p>
<pre><code class="js">yum install git -y            安装
git --version                 安装后查看版本
</code></pre>
<h4 id="用户密码类型"><a href="#用户密码类型" class="headerlink" title="用户密码类型"></a>用户密码类型</h4><p>**<u>全局添加凭证</u>**：Dashboard → Manage Jenkins → Credentials → System → Global credentials (unrestricted) → New credentials</p>
<p>-<br>  Jenkins-&gt;凭证-&gt;系统-&gt;全局凭证-&gt;添加凭证</p>
<h5 id="测试凭证是否可用"><a href="#测试凭证是否可用" class="headerlink" title="测试凭证是否可用"></a>测试凭证是否可用</h5><p>创建一个FreeStyle项目：新建Item-&gt;FreeStyle Project-&gt;确定<br>找到 “源码管理”-&gt;”Git”，在Repository URL复制Gitlab中的项目URL</p>
<p><strong>新搞个item然后点击进去 左侧的配置→General→源码管理→选择Git →↓</strong> </p>
<pre><code class="java">Repository URL：http://192.168.200.128:82/lanyun_group/web_demo.git
Credentials：【选择刚刚给张三创建的凭证】
</code></pre>
<p>保存配置后，点击构建 ”Build Now“ 开始构建项目<br>可以在左下方的Builds里找到刚刚构建的项目 可以查看控制台输出</p>
<pre><code class="java">Started by user root
Running as SYSTEM
Building in workspace /var/lib/jenkins/workspace/test02
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
Cloning the remote Git repository
Cloning repository http://192.168.200.128:82/lanyun_group/web_demo.git
 &gt; git init /var/lib/jenkins/workspace/test02 # timeout=10
Fetching upstream changes from http://192.168.200.128:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.128:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git config remote.origin.url http://192.168.200.128:82/lanyun_group/web_demo.git # timeout=10
 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 2f41cd33af519a5c55df8d78ba59032d9069f0b8 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 2f41cd33af519a5c55df8d78ba59032d9069f0b8 # timeout=10
Commit message: &quot;初始化项目提交&quot;
First time build. Skipping changelog.
Finished: SUCCESS
</code></pre>
<p>查看**&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;**目录，发现已经从Gitlab成功拉取了代码到Jenkins中</p>
<h4 id="SSH密钥类型"><a href="#SSH密钥类型" class="headerlink" title="SSH密钥类型"></a>SSH密钥类型</h4><h6 id="SSH免密登录示意图："><a href="#SSH免密登录示意图：" class="headerlink" title="SSH免密登录示意图："></a>SSH免密登录示意图：</h6><p>[<u>GitLab服务器(存放公钥：id_rsa.pub)</u>] ←←←<strong>ssh免密登录</strong>←←← [<u>Jenkins服务器(存放私钥：id_rsa)</u>]</p>
<ul>
<li><h5 id="使用root用户生成公钥和私钥"><a href="#使用root用户生成公钥和私钥" class="headerlink" title="使用root用户生成公钥和私钥"></a>使用root用户生成公钥和私钥</h5></li>
</ul>
<blockquote>
<p>ssh-keygen -t rsa</p>
</blockquote>
<pre><code class="java">在 192.168.200.129_Jenkins 服务器里

[root@localhost ~]# ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Created directory &#39;/root/.ssh&#39;.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:88fFvAS2e6i9c4+KXfmENWeu6NJNmOb1+CCsYLarYLc root@localhost.localdomain
The key&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|            o    |
|           . =   |
|        S   .o=.+|
|         o o+=oBo|
|    o . + .+B+Boo|
|   . o + o.B+=+*.|
|      E.o.+oB=oo+|
+----[SHA256]-----+

[root@localhost ~]# cd /root/.ssh
[root@localhost .ssh]# ll
总用量 8
-rw-------. 1 root root 1679 6月  18 20:05 id_rsa       【私钥】
-rw-r--r--. 1 root root  408 6月  18 20:05 id_rsa.pub   【公钥】
</code></pre>
<ul>
<li><h5 id="要在gitlab服务里存放一个公钥"><a href="#要在gitlab服务里存放一个公钥" class="headerlink" title="要在gitlab服务里存放一个公钥"></a>要在gitlab服务里存放一个公钥</h5></li>
</ul>
<p>以root账户登录-&gt;点击头像-&gt;Settings-&gt;SSH Keys→在Jenkins服务里面用<br> <code>[root@localhost .ssh]# cat id_rsa.pub</code><br>打开公钥的文件得到信息。复制刚才id_rsa.pub文件的内容到这里，点击”Add Key”</p>
<ul>
<li><h5 id="在Jenkins中添加凭证，配置私钥"><a href="#在Jenkins中添加凭证，配置私钥" class="headerlink" title="在Jenkins中添加凭证，配置私钥"></a>在Jenkins中添加凭证，配置私钥</h5></li>
</ul>
<p>在Jenkins添加一个全局新的凭证，类型为”<strong>SSH Username with private key</strong>“，在jenkins服务器里输入指令查看<strong>私钥</strong><br><code>[root@localhost .ssh]# cat id_rsa</code><br>把刚才生成<strong>私钥</strong>文件内容复制过来塞进去<br>此时去gitlab项目中把ssh的复制过来<code>git@192.168.200.128:lanyun_group/web_demo.git</code><br>同样尝试构建项目，如果代码可以正常拉取，代表凭证配置成功！</p>
<p><span style = "color:red"><strong>如果报错</strong></span>：</p>
<pre><code class="java">Command &quot;git ls-remote -h git@192.168.200.128:lanyun_group/web_demo.git HEAD&quot; returned status code 128
stderr: No ECDSA host key is known for 192.168.200.128 and you have requested strict checking.
Host key verification failed.
fatal: Could not read from remote repository.
</code></pre>
<p><span style = "color:red"><strong>报错原因</strong></span>：</p>
<pre><code class="java">SSH 主机指纹未验证（Host key verification failed）

Git 使用的是 SSH 协议访问远程仓库（git@192.168.200.128），但本地机器之前没有连接过该主机，或者 .ssh/known_hosts 文件中没有该 IP 的公钥信息。

而且启用了“严格检查”（Strict Host Key Checking），所以 Git 拒绝连接该服务器。



★★ 方法：手动信任主机（推荐）★★
ssh git@192.168.200.128
系统会提示你是否信任该主机，比如：

The authenticity of host &#39;192.168.200.128 (192.168.200.128)&#39; can&#39;t be established.
ECDSA key fingerprint is SHA256:xxx...
Are you sure you want to continue connecting (yes/no/[fingerprint])?
✅ 输入 yes 之后，主机公钥会加入 ~/.ssh/known_hosts 文件，后续连接将不再失败。
</code></pre>
<h6 id="到这里已经完成了这份图的部分内容，要开始融入Maven"><a href="#到这里已经完成了这份图的部分内容，要开始融入Maven" class="headerlink" title="到这里已经完成了这份图的部分内容，要开始融入Maven"></a><strong><u>到这里已经完成了这份图的部分内容，要开始融入Maven</u></strong></h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/5a664e75de77e3633f64215df2e5990365c3606a/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E.png" alt="持续集成流程说明"></p>
<h2 id="持续集成环境—Maven安装和配置"><a href="#持续集成环境—Maven安装和配置" class="headerlink" title="持续集成环境—Maven安装和配置"></a>持续集成环境—Maven安装和配置</h2><p>在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目</p>
<p>把<code>apache-maven-3.6.2-bin.tar.gz</code>传到 &#x2F;root 根目录中【Jenkins服务器】</p>
<pre><code class="java">tar -xzf apache-maven-3.6.2-bin.tar.gz       解压
mkdir -p /opt/maven                          创建目录
mv apache-maven-3.6.2/* /opt/maven           移动文件
</code></pre>
<blockquote>
<p>[root@localhost ~]# mkdir -p &#x2F;opt&#x2F;maven<br>[root@localhost ~]# mv apache-maven-3.6.2&#x2F;* &#x2F;opt&#x2F;maven<br>[root@localhost ~]# cd &#x2F;opt&#x2F;maven&#x2F;<br>[root@localhost maven]# ll<br>总用量 28<br>drwxr-xr-x. 2 root root     97 6月  18 21:37 bin<br>drwxr-xr-x. 2 root root     42 6月  18 21:37 boot<br>drwxrwxr-x. 3 1000 mysql    63 8月  27 2019 conf<br>drwxrwxr-x. 4 1000 mysql  4096 6月  18 21:37 lib<br>-rw-rw-r–. 1 1000 mysql 12846 8月  27 2019 LICENSE<br>-rw-rw-r–. 1 1000 mysql   182 8月  27 2019 NOTICE<br>-rw-rw-r–. 1 1000 mysql  2533 8月  27 2019 README.txt<br>[root@localhost maven]#</p>
</blockquote>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><blockquote>
<p>vi &#x2F;etc&#x2F;profile</p>
</blockquote>
<pre><code class="java">export JAVA_HOME=/usr/local/java/jdk-17.0.8+7
export MAVEN_HOME=/opt/maven
export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin
</code></pre>
<blockquote>
<p>source &#x2F;etc&#x2F;profile                 配置生效<br>mvn -v                                      查找Maven版本</p>
</blockquote>
<h4 id="全局工具配置关联JDK和Maven"><a href="#全局工具配置关联JDK和Maven" class="headerlink" title="全局工具配置关联JDK和Maven"></a>全局工具配置关联JDK和Maven</h4><p>Jenkins-&gt;Manage Jenkins-&gt;Tools→ JDK安装 → 新增JDK → </p>
<blockquote>
<p>【JDK】<br><strong>别名</strong>：jdk-17.0.8+7<br><strong>JAVA_HOME</strong>：&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-17.0.8+7</p>
</blockquote>
<p>下面的Maven安装→ 新增Maven →</p>
<blockquote>
<p>【Maven】<br><strong>Name</strong>：maven3.6.2<br><strong>MAVEN_HOME</strong>：&#x2F;opt&#x2F;maven</p>
</blockquote>
<p>点击应用 → 保存</p>
<h4 id="添加Jenkins全局变量"><a href="#添加Jenkins全局变量" class="headerlink" title="添加Jenkins全局变量"></a>添加Jenkins全局变量</h4><p>Jenkins → Manage Jenkins → System → 下面找到<strong>全局属性</strong> → <strong>Environment variables</strong> </p>
<pre><code class="java">以下是用键值对的形式显示：
JAVA_HOME   /usr/local/java/jdk-17.0.8+7
M2_HOME     /opt/maven
PATH+EXTRA  $M2_HOME/bin
</code></pre>
<h4 id="修改Maven的settings-xml"><a href="#修改Maven的settings-xml" class="headerlink" title="修改Maven的settings.xml"></a>修改Maven的settings.xml</h4><pre><code class="java">mkdir /root/repo                  创建本地仓库目录
vi /opt/maven/conf/settings.xml
</code></pre>
<p>本地仓库改为：&#x2F;root&#x2F;repo</p>
<pre><code class="java">  &lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: $&#123;user.home&#125;/.m2/repository
  --&gt;
  &lt;localRepository&gt;/root/repo&lt;/localRepository&gt;
</code></pre>
<p>添加阿里云私服地址：</p>
<pre><code class="java">    &lt;mirror&gt;
      &lt;id&gt;alimaven&lt;/id&gt;
      &lt;name&gt;aliyun maven&lt;/name&gt;
      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;/mirror&gt;
</code></pre>
<h4 id="测试Maven是否配置成功"><a href="#测试Maven是否配置成功" class="headerlink" title="测试Maven是否配置成功"></a>测试Maven是否配置成功</h4><p>使用之前的gitlab密码测试项目，修改配置;<br>在某个项目中→Triggers中→Build Steps选择 <strong>Execute shell</strong>(执行shell脚本命令)<br>输入</p>
<blockquote>
<p>mvn clean package</p>
</blockquote>
<p>然后再去构建！！</p>
<blockquote>
<h3 id="🔧-步骤一：删除损坏的插件文件"><a href="#🔧-步骤一：删除损坏的插件文件" class="headerlink" title="🔧 步骤一：删除损坏的插件文件"></a>🔧 步骤一：删除损坏的插件文件</h3><p>执行以下命令彻底删除这个错误的插件缓存：</p>
<pre><code class="java">rm -rf /root/repo/org/apache/maven/plugins/maven-clean-plugin
</code></pre>
<hr>
<h3 id="🔧-步骤二：将-Maven-镜像源改为稳定的中央仓库"><a href="#🔧-步骤二：将-Maven-镜像源改为稳定的中央仓库" class="headerlink" title="🔧 步骤二：将 Maven 镜像源改为稳定的中央仓库"></a>🔧 步骤二：将 Maven 镜像源改为稳定的中央仓库</h3><p>编辑 <code>/root/.m2/settings.xml</code> 或 <code>/etc/maven/settings.xml</code>（按你的系统配置）为以下内容：</p>
<pre><code class="xml">&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0
                              http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
  
  &lt;localRepository&gt;/root/repo&lt;/localRepository&gt;

  &lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;central&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;Maven Central&lt;/name&gt;
      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;
    &lt;/mirror&gt;
  &lt;/mirrors&gt;

&lt;/settings&gt;
</code></pre>
</blockquote>
<h4 id="持续集成环境—Tomcat安装和配置"><a href="#持续集成环境—Tomcat安装和配置" class="headerlink" title="持续集成环境—Tomcat安装和配置"></a>持续集成环境—Tomcat安装和配置</h4><p>安装Tomcat8.5  把Tomcat压缩包上传到192.168.200.131服务器 </p>
<blockquote>
<p>yum install java-1.8.0-openjdk* -y                           安装JDK（已完成）<br>tar -xzf apache-tomcat-8.5.47.tar.gz                       解压<br>mkdir -p &#x2F;opt&#x2F;tomcat                                                 创建目录<br>mv &#x2F;root&#x2F;apache-tomcat-8.5.47&#x2F;* &#x2F;opt&#x2F;tomcat     移动文件<br><span style ="color:red"><strong>启动tomcat</strong></span><br>&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh ★★        </p>
<p><span style ="color:blue">[Apache Tomcat&#x2F;8.5.47]</span> (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/">http://192.168.200.131:8090/</a>) 【已改端口8090】</p>
<p><strong>关闭已有 Tomcat</strong>（建议先关闭，避免冲突）：</p>
<pre><code>/opt/tomcat/bin/shutdown.sh
</code></pre>
<p><strong>再启动</strong>：</p>
<pre><code>/opt/tomcat/bin/startup.sh
</code></pre>
</blockquote>
<p>不过现在访问这个地址是没有权限的[403 Access Denied] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/">http://192.168.200.131:8090/manager/</a>) 现在要增加权限</p>
<h4 id="配置-Tomcat用户角色权限"><a href="#配置-Tomcat用户角色权限" class="headerlink" title="配置 Tomcat用户角色权限"></a>配置 Tomcat用户角色权限</h4><p>默认情况下Tomcat是没有配置用户角色权限的</p>
<blockquote>
<h1 id="403-Access-Denied"><a href="#403-Access-Denied" class="headerlink" title="403 Access Denied"></a>403 Access Denied</h1><p>You are not authorized to view this page.</p>
<p>By default the Manager is only accessible from a browser running on the same machine as Tomcat. If you wish to modify this restriction, you’ll need to edit the Manager’s <code>context.xml</code> file.</p>
<p>If you have already configured the Manager application to allow access and you have used your browsers back button, used a saved book-mark or similar then you may have triggered the cross-site request forgery (CSRF) protection that has been enabled for the HTML interface of the Manager application. You will need to reset this protection by returning to the <a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/html">main Manager page</a>. Once you return to this page, you will be able to continue using the Manager application’s HTML interface normally. If you continue to see this access denied message, check that you have the necessary permissions to access this application.</p>
<p>If you have not changed any configuration files, please examine the file <code>conf/tomcat-users.xml</code> in your installation. That file must contain the credentials to let you use this webapp.</p>
<p>For example, to add the <code>manager-gui</code> role to a user named <code>tomcat</code> with a password of <code>s3cret</code>, add the following to the config file listed above.</p>
<pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;
&lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;manager-gui&quot;/&gt;
</code></pre>
<p>Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single <code>manager</code> role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access.</p>
<ul>
<li><code>manager-gui</code> - allows access to the HTML GUI and the status pages</li>
<li><code>manager-script</code> - allows access to the text interface and the status pages</li>
<li><code>manager-jmx</code> - allows access to the JMX proxy and the status pages</li>
<li><code>manager-status</code> - allows access to the status pages only</li>
</ul>
<p>The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection:</p>
<ul>
<li>Users with the <code>manager-gui</code> role should not be granted either the <code>manager-script</code> or <code>manager-jmx</code> roles.</li>
<li>If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session.</li>
</ul>
<p>For more information - please see the <a target="_blank" rel="noopener" href="http://192.168.200.131:8090/docs/manager-howto.html">Manager App How-To</a>.</p>
</blockquote>
<p>但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置， 添加用户及权限</p>
<blockquote>
<p>vi &#x2F;opt&#x2F;tomcat&#x2F;conf&#x2F;tomcat-users.xml</p>
</blockquote>
<p>内容如下：</p>
<pre><code class="xml">&lt;tomcat-users&gt;
 &lt;role rolename=&quot;tomcat&quot;/&gt;
 &lt;role rolename=&quot;role1&quot;/&gt;
 &lt;role rolename=&quot;manager-script&quot;/&gt;
 &lt;role rolename=&quot;manager-gui&quot;/&gt;
 &lt;role rolename=&quot;manager-status&quot;/&gt; 
&lt;role rolename=&quot;admin-gui&quot;/&gt;
 &lt;role rolename=&quot;admin-script&quot;/&gt; 
&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager
script,tomcat,admin-gui,admin-script&quot;/&gt;
 &lt;/tomcat-users&gt;
</code></pre>
<p>用户和密码都是： tomcat<br>注意：为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置</p>
<blockquote>
<p>vi &#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;manager&#x2F;META-INF&#x2F;context.xml</p>
</blockquote>
<pre><code class="yaml">&lt;!--
 &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;
 allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;
--&gt;
</code></pre>
<p>注释掉这行就行！！</p>
<blockquote>
<p><strong>关闭已有 Tomcat</strong>（建议先关闭，避免冲突）：</p>
<pre><code>/opt/tomcat/bin/shutdown.sh
</code></pre>
<p><strong>再启动</strong>：</p>
<pre><code>/opt/tomcat/bin/startup.sh
</code></pre>
</blockquote>
<p>[&#x2F;manager] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/manager/html">http://192.168.200.131:8090/manager/html</a>)   <strong>此时就可以访问了！！！</strong></p>
<h2 id="3、Jenkins构建Maven项目"><a href="#3、Jenkins构建Maven项目" class="headerlink" title="3、Jenkins构建Maven项目"></a>3、Jenkins构建Maven项目</h2><h4 id="Jenkins项目构建类型-1-Jenkins构建的项目类型介绍"><a href="#Jenkins项目构建类型-1-Jenkins构建的项目类型介绍" class="headerlink" title="Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍"></a>Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍</h4><p>Jenkins中自动构建项目的类型有很多，常用的有以下三种： </p>
<ul>
<li>自由风格软件项目（ FreeStyle Project） </li>
<li>Maven 项目（Maven Project） </li>
<li><span style ="color:red"><strong>流水线项目（ Pipeline Project）</strong></span></li>
</ul>
<p>每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在 实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）</p>
<h4 id="Jenkins项目构建类型-2-自由风格项目构建"><a href="#Jenkins项目构建类型-2-自由风格项目构建" class="headerlink" title="Jenkins项目构建类型(2)-自由风格项目构建"></a>Jenkins项目构建类型(2)-自由风格项目构建</h4><p>下面演示创建一个自由风格项目来完成项目的集成过程：</p>
<blockquote>
<p>拉取代码→编译→打包→部署</p>
</blockquote>
<p>……</p>
<h4 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h4><p>把项目部署到远程的Tomcat里面 </p>
<h6 id="1）安装-Deploy-to-container插件"><a href="#1）安装-Deploy-to-container插件" class="headerlink" title="1）安装 Deploy to container插件"></a>1）安装 Deploy to container插件</h6><p>Jenkins本身无法实现远程部署到Tomcat的功能，需要在Jenkins里面安装<strong>Deploy to container</strong>插件实现</p>
<p><a href="file:///C:/Users/Pluminary/Desktop/Jenkins持续集成从入门到精通.pdf">Jenkins持续集成从入门到精通.pdf</a> 【39页】</p>
<p>①：<strong>Build Steps</strong> → Execute shell →↓</p>
<pre><code class="java">echo &quot;开始进行编译构建&quot;
mvn clean package
echo &quot;编译构建结束&quot;
</code></pre>
<p>②：在Jenkins的项目配置里 下面<br>构建后操作：【Deploy war&#x2F;ear to a container】→ 选择 <strong><u>Tomcat 8.x Remote</u></strong><br><strong>WAR&#x2F;EAR files</strong>：<u>target&#x2F;*.war</u><br><strong>Containers</strong>：<br>新增一个凭证 用户名tomcat 密码tomcat</p>
<p>部署成功后，访问项目：[<u>演示项目主页</u>] (<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/">http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/</a>)</p>
<pre><code class="xml">如果看到此页面，代表项目部署成功啦！--这是master分支 添加用户
修改用户
删除用户 查询用户
</code></pre>
<p>演示改动代码后的持续集成<br>1）IDEA中源码修改并提交到gitlab<br>2）在Jenkins中项目重新构建<br>3）访问Tomcat</p>
<h5 id="演示改动代码后的持续集成"><a href="#演示改动代码后的持续集成" class="headerlink" title="演示改动代码后的持续集成"></a>演示改动代码后的持续集成</h5><p>1）IDEA中源码修改并提交到gitlab<br>2）<strong>在Jenkins中项目重新构建</strong><br>3）访问Tomcat</p>
<h4 id="Jenkins项目构建类型-3-Maven项目构建"><a href="#Jenkins项目构建类型-3-Maven项目构建" class="headerlink" title="Jenkins项目构建类型(3)-Maven项目构建"></a>Jenkins项目构建类型(3)-Maven项目构建</h4><p>1）安装 <strong>Maven Integration</strong> 插件<br>2）创建 <strong>Maven</strong> 项目<br>3）配置项目<br>拉取代码和远程部署的过程和自由风格项目一样，只是”构建”部分不同</p>
<p>新建<strong>Item</strong> → <strong>构建一个maven项目</strong><br>其中Build的<strong>Root POM</strong>是要找到pom.xml的路径才行【默认执行maven命令】<br>所以只需要在<strong>Goals and options</strong>里面敲上<code>clean package</code></p>
<h4 id="Jenkins项目构建类型-4-Pipeline流水线项目构建"><a href="#Jenkins项目构建类型-4-Pipeline流水线项目构建" class="headerlink" title="Jenkins项目构建类型(4)-Pipeline流水线项目构建(*)"></a>Jenkins项目构建类型(4)-Pipeline流水线项目构建(*)</h4><h5 id="Pipeline简介"><a href="#Pipeline简介" class="headerlink" title="Pipeline简介"></a>Pipeline简介</h5><h6 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h6><p>Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点 的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。</p>
<h6 id="2）使用Pipeline有以下好处（来自翻译自官方文档）："><a href="#2）使用Pipeline有以下好处（来自翻译自官方文档）：" class="headerlink" title="2）使用Pipeline有以下好处（来自翻译自官方文档）："></a>2）使用Pipeline有以下好处（来自翻译自官方文档）：</h6><p>代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。 持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。 可停止：Pipeline可接 收交互式输入，以确定是否继续执行Pipeline。 多功能：Pipeline支持现实世界中复杂的持续交付要 求。它支持fork&#x2F;join、循环执行，并行执行任务的功能。 可扩展：Pipeline插件支持其DSL的自定义扩 展 ，以及与其他插件集成的多个选项。</p>
<h6 id="3）如何创建-Jenkins-Pipeline呢？"><a href="#3）如何创建-Jenkins-Pipeline呢？" class="headerlink" title="3）如何创建 Jenkins Pipeline呢？"></a>3）如何创建 Jenkins Pipeline呢？</h6><ul>
<li>Pipeline 脚本是由 Groovy 语言实现的，但是我们没必要单独去学习 Groovy </li>
<li>Pipeline 支持两种语法：<span style="color:red"><strong>Declarative</strong>(声明式)</span> 和 <span style="color:red"><strong>Scripted Pipeline</strong>(脚本式)</span>语法 </li>
<li>Pipeline  也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一 个 Jenkinsfile 脚本文件放入项目源码库中（<u>一般我们都推荐在 Jenkins 中直接从源代码控制(SCM) 中直接载入 Jenkinsfile Pipeline 这种方法</u>）</li>
</ul>
<h5 id="安装Pipeline插件如果一次安装失败，重启一次再安装-没视图就安装pipeline-Stage-View"><a href="#安装Pipeline插件如果一次安装失败，重启一次再安装-没视图就安装pipeline-Stage-View" class="headerlink" title="安装Pipeline插件如果一次安装失败，重启一次再安装[没视图就安装pipeline Stage View]"></a>安装Pipeline插件<del>如果一次安装失败，重启一次再安装</del>[没视图就安装pipeline Stage View]</h5><p>Manage Jenkins-&gt;Manage Plugins-&gt;可选插件</p>
<h3 id="Pipeline语法快速入门"><a href="#Pipeline语法快速入门" class="headerlink" title="Pipeline语法快速入门"></a>Pipeline语法快速入门</h3><h5 id="1）Declarative声明式-Pipeline"><a href="#1）Declarative声明式-Pipeline" class="headerlink" title="1）Declarative声明式-Pipeline"></a>1）Declarative声明式-Pipeline</h5><p><strong><u>创建项目</u></strong> [<strong>agent是代理、stage是阶段、steps是步骤</strong>]</p>
<ul>
<li><strong>Node</strong> ：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行 环境，后续讲到Jenkins的Master-Slave架构的时候用到。 </li>
<li><strong>Stage</strong> ：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。 </li>
<li><strong>Step</strong> ：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。</li>
</ul>
<pre><code class="java">pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                echo &#39;pull code&#39;
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                echo &#39;build project&#39;
            &#125;
        &#125;
        stage(&#39;publish project&#39;) &#123;
            steps &#123;
                echo &#39;publish project&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2）Scripted-Pipeline脚本式-Pipeline"><a href="#2）Scripted-Pipeline脚本式-Pipeline" class="headerlink" title="2）Scripted Pipeline脚本式-Pipeline"></a>2）Scripted Pipeline脚本式-Pipeline</h5><p><strong><u>创建项目</u></strong><br>流水线那里选择 “<strong>Scripted Pipeline</strong>“</p>
<pre><code class="java">node &#123;
    def mvnHome
    stage(&#39;pull code&#39;)&#123;
        echo &#39;pull code&#39;
    &#125;
    stage(&#39;build project&#39;)&#123;
        echo &#39;build project&#39;
    &#125;
    stage(&#39;publish project&#39;)&#123;
        echo &#39;publish project&#39;
    &#125;
&#125;
</code></pre>
<p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：checkout：Check out from version control [从版本控制里拉取代码]<br>选择git拉取代码 填写URL和凭证 → 生成流水线脚本</li>
</ul>
<h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a><span style = "color:red">拉取代码</span></h3><h6 id="Pipeline-script"><a href="#Pipeline-script" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">pipeline&#123;
    agent any
    stages&#123;
        stage(&#39;拉取代码&#39;)&#123;
            steps&#123;
                checkout scmGit(branches: [[name: &#39;*/master&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;]])
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output"><a href="#Console-Output" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (拉取代码)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
Cloning the remote Git repository
Cloning repository http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git init /var/lib/jenkins/workspace/web_demo_pipeline # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10
Avoid second fetch
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
First time build. Skipping changelog.
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<p>去Jenkins的服务器里寻找<code>/var/lib/jenkins/workspace/web_demo_pipeline</code></p>
<h3 id="编译打包"><a href="#编译打包" class="headerlink" title="编译打包"></a><span style = "color:red">编译打包</span></h3><p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：<code>sh：Shell Script</code><br>Shell Script：里面需要打所需要的命令 <code>mvn clean package</code></li>
</ul>
<h6 id="Pipeline-script-1"><a href="#Pipeline-script-1" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">pipeline&#123;
    agent any
    stages&#123;
        stage(&#39;build project&#39;)&#123;
            steps&#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
    &#125;
&#125;

--------------------------------------------
【总流水线代码】
pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output-1"><a href="#Console-Output-1" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (pull code)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
 &gt; git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/web_demo_pipeline/.git # timeout=10
Fetching changes from the remote Git repository
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
 &gt; git rev-list --no-walk 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (build project)
[Pipeline] sh
+ mvn clean package
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------&lt; com.itheima:web_demo &gt;------------------------
[INFO] Building web_demo 1.0-SNAPSHOT
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ web_demo ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ web_demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /var/lib/jenkins/workspace/web_demo_pipeline/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ web_demo ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ web_demo ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-war-plugin:3.3.2:war (default-war) @ web_demo ---
[INFO] Packaging webapp
[INFO] Assembling webapp [web_demo] in [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [/var/lib/jenkins/workspace/web_demo_pipeline/src/main/webapp]
[INFO] Building war: /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  10.242 s
[INFO] Finished at: 2025-06-24T20:32:45+08:00
[INFO] ------------------------------------------------------------------------
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<h3 id="部署-2"><a href="#部署-2" class="headerlink" title="部署"></a><span style = "color:red">部署</span></h3><p><span style = "color:blue"><u>流水线脚本</u></span>：点击可以使用官方的脚本生成器</p>
<ul>
<li><strong>片段生成器</strong>：<br>示例步骤：<code>deploy：Deploy war/ear to a container</code><br>WAR&#x2F;EAR files：<code>target/*.war</code><br>containers：<strong>Tomcat 8.x Remote</strong> 【容器可以增加多台】<br>credentials：添加tomcat凭证<br>Tomcat URL：<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/">http://192.168.200.131:8090/</a></li>
</ul>
<h6 id="Pipeline-script-2"><a href="#Pipeline-script-2" class="headerlink" title="Pipeline script"></a>Pipeline script</h6><pre><code class="java">【总流水线代码】
pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Console-Output-2"><a href="#Console-Output-2" class="headerlink" title="Console Output"></a>Console Output</h5><pre><code class="java">Started by user root
[Pipeline] Start of Pipeline
[Pipeline] node
Running on Jenkins in /var/lib/jenkins/workspace/web_demo_pipeline
[Pipeline] &#123;
[Pipeline] stage
[Pipeline] &#123; (pull code)
[Pipeline] checkout
The recommended git tool is: NONE
using credential ca22e56f-0ecc-4fdc-965d-01e329a0b68a
 &gt; git rev-parse --resolve-git-dir /var/lib/jenkins/workspace/web_demo_pipeline/.git # timeout=10
Fetching changes from the remote Git repository
 &gt; git config remote.origin.url http://192.168.200.132:82/lanyun_group/web_demo.git # timeout=10
Fetching upstream changes from http://192.168.200.132:82/lanyun_group/web_demo.git
 &gt; git --version # timeout=10
 &gt; git --version # &#39;git version 1.8.3.1&#39;
using GIT_ASKPASS to set credentials gitlab-auth-password
 &gt; git fetch --tags --progress http://192.168.200.132:82/lanyun_group/web_demo.git +refs/heads/*:refs/remotes/origin/* # timeout=10
 &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10
Checking out Revision 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 (refs/remotes/origin/master)
 &gt; git config core.sparsecheckout # timeout=10
 &gt; git checkout -f 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
Commit message: &quot;修改index.jsp加入细节(!)&quot;
 &gt; git rev-list --no-walk 7ae1ec4086586fb471b0e9dee0a0d00d0b6d6f54 # timeout=10
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (build project)
[Pipeline] sh
+ mvn clean package
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------&lt; com.itheima:web_demo &gt;------------------------
[INFO] Building web_demo 1.0-SNAPSHOT
[INFO] --------------------------------[ war ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ web_demo ---
[INFO] Deleting /var/lib/jenkins/workspace/web_demo_pipeline/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ web_demo ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to /var/lib/jenkins/workspace/web_demo_pipeline/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ web_demo ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /var/lib/jenkins/workspace/web_demo_pipeline/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ web_demo ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ web_demo ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-war-plugin:3.3.2:war (default-war) @ web_demo ---
[INFO] Packaging webapp
[INFO] Assembling webapp [web_demo] in [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [/var/lib/jenkins/workspace/web_demo_pipeline/src/main/webapp]
[INFO] Building war: /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  7.472 s
[INFO] Finished at: 2025-06-24T20:39:46+08:00
[INFO] ------------------------------------------------------------------------
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] stage
[Pipeline] &#123; (publish)
[Pipeline] deploy
[DeployPublisher][INFO] Attempting to deploy 1 war file(s)
[DeployPublisher][INFO] Deploying /var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war to container Tomcat 8.x Remote with context null
  Redeploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
  Undeploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
  Deploying [/var/lib/jenkins/workspace/web_demo_pipeline/target/web_demo-1.0-SNAPSHOT.war]
[Pipeline] &#125;
[Pipeline] // stage
[Pipeline] &#125;
[Pipeline] // node
[Pipeline] End of Pipeline
Finished: SUCCESS
</code></pre>
<h4 id="Pipeline-Script-from-SCM"><a href="#Pipeline-Script-from-SCM" class="headerlink" title="Pipeline Script from SCM "></a><span style = "color:red">Pipeline Script from SCM </span></h4><p>刚才我们都是直接在Jenkins的UI界面编写Pipeline代码，这样不方便脚本维护，建议把Pipeline脚本放 在项目中（一起进行版本控制）<br>1）在项目<strong>根目录</strong>建立<strong>Jenkinsfile</strong>文件，把内容复制到该文件中。把Jenkinsfile上传到Gitlab</p>
<pre><code class="java">Jenkinsfile【在根目录下】

pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/master&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p> 2）在项目中引用该<strong>文件</strong><br>在流水线上<br>定义<code>Pipeline script from SCM</code> → 选择git → 填写gitlab的url和凭证 → 脚本路径<code>Jenkinsfile</code>(这是我们上传的jenkinsfile里面包含着流水线代码的文件)</p>
<h4 id="Jenkins项目构建细节-1-常用的构建触发器"><a href="#Jenkins项目构建细节-1-常用的构建触发器" class="headerlink" title="Jenkins项目构建细节(1)-常用的构建触发器"></a>Jenkins项目构建细节(1)-常用的构建触发器</h4><p>Jenkins内置4种构建触发器： </p>
<ul>
<li>触发远程构建 </li>
<li>其他工程构建后触发（ Build after other projects are build） </li>
<li>定时构建（ Build periodically） </li>
<li>轮询 SCM（Poll SCM）</li>
</ul>
<h5 id="触发远程构建"><a href="#触发远程构建" class="headerlink" title="触发远程构建"></a>触发远程构建</h5><p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>触发远程构建</code> 身份验证令牌(这个token最好是加密的) 下面有个触发地址：</p>
<blockquote>
<p>Use the following URL to trigger build remotely: <code>JENKINS_URL</code>&#x2F;job&#x2F;web_demo_pipeline&#x2F;build?token&#x3D;TOKEN_NAME 或者 &#x2F;buildWithParameters?token&#x3D;TOKEN_NAME<br>Optionally append <code>&amp;cause=Cause+Text</code> to provide text that will be included in the recorded build cause.</p>
</blockquote>
<p>上面地址里面的：<code>job/web_demo_pipeline/build?token=TOKEN_NAME</code><br>→ <code>http://192.168.200.129:8888/job/web_demo_pipeline/build?token=6666</code><br>在浏览器输入上述地址 回车打开 你会发现已经远程触发了Jenkins的构建行为！！</p>
<h5 id="其他工程构建后触发"><a href="#其他工程构建后触发" class="headerlink" title="其他工程构建后触发"></a>其他工程构建后触发</h5><p>1）创建pre_job流水线工程<br>2）配置需要触发的工程</p>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Build after other projects are built</code><br>新建item → 创建一个<code>pre_job</code>的自由风格的工程 → 构建Execute shell 执行一个简单的脚本<br>回到<code>web_demo_pipeline</code>工程 在<code>Triggers</code>里面选择前置工程<code>pre_job</code><br>此时去构建<code>pre_job</code>你会发现 在构建完后 <code>web_demo_pipeline</code>也会进行自动构建</p>
<h5 id="定时构建"><a href="#定时构建" class="headerlink" title="定时构建"></a>定时构建</h5><p>定时字符串从左往右分别为： 分 时 日 月 周<br>一些定时表达式的例子：(H为0 就为整点)</p>
<pre><code class="java">每30分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32
每2个小时构建一次: H H/2 * * *
每天的8点，12点，22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *
每天中午12点定时构建一次 H 12 * * *
每天下午18点定时构建一次 H 18 * * *
在每个小时的前半个小时内的每10分钟 H(0-29)/10 * * * *
每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午
4:38) H H(9-16)/2 * * 1-5
</code></pre>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择 <code>Build periodically</code> 然后可以写时间cron表达式即可</p>
<h5 id="轮询SCM-版本控制-企业级不推荐使用"><a href="#轮询SCM-版本控制-企业级不推荐使用" class="headerlink" title="轮询SCM  [版本控制] [企业级不推荐使用]"></a><span style ="color:blue">轮询SCM  [版本控制] [企业级不推荐使用]</span></h5><p>轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。<br>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Poll SCM</code></p>
<blockquote>
<h4 id="jenkins的轮询SCM的构建到底是远程仓库变动触发-还是-本地仓库变动触发？"><a href="#jenkins的轮询SCM的构建到底是远程仓库变动触发-还是-本地仓库变动触发？" class="headerlink" title="jenkins的轮询SCM的构建到底是远程仓库变动触发 还是 本地仓库变动触发？"></a>jenkins的轮询SCM的构建到底是远程仓库变动触发 还是 本地仓库变动触发？</h4><p><strong>Jenkins 的“轮询 SCM”是通过轮询</strong>远程 Git 仓库（如 GitLab、GitHub）<strong>判断是否有变更</strong>，从而决定是否触发构建。</p>
</blockquote>
<p>注意：这次构建触发器， Jenkins会定时扫描整个项目的代码，增大系统的开销，不建议使用。</p>
<h4 id="Jenkins项目构建细节-2-Git-hook自动触发构建-gitlab就用gitlab插件，github则是github插件"><a href="#Jenkins项目构建细节-2-Git-hook自动触发构建-gitlab就用gitlab插件，github则是github插件" class="headerlink" title="Jenkins项目构建细节(2)-Git hook自动触发构建(*)gitlab就用gitlab插件，github则是github插件"></a>Jenkins项目构建细节(2)-Git hook自动触发构建(*)<del>gitlab就用gitlab插件，github则是github插件</del></h4><p>先在Jenkins市场安装<code>gitlab</code>插件</p>
<p>刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是 该方案的性能不佳。那有没有更好的方案呢？ 有的。就是<strong>利用Gitlab的webhook实现代码push到仓 库，立即触发项目自动构建</strong>。</p>
<blockquote>
<p><strong>轮询SCM原理</strong>：Jenkins                    →(发送定时请求)→                Gitlab代码变更<br><strong>webhook原理</strong>：Gitlab代码变更      →(发送构建请求)→                Jenkins</p>
</blockquote>
<p>打开<code>web_demo_pipeline</code>的配置 里面的<code>Triggers</code> 选择<code>Build when a change is pushed to GitLab. GitLab webhook URL: http://192.168.200.129:8888/project/web_demo_pipeline</code></p>
<p>★ 要用root账号去GitLab开通一个webhook规则 → 点击上方的小齿轮 → 右侧<code>Settings</code>  → Network → 展开Outbound requests → 勾选<code>Allow requests to the local network from web hooks and services</code>和<code>Allow requests to the local network from system hooks</code>保存 → 在<code>web_demo</code>项目中 → Settings → Integrations → 可以粘贴URL(这里就是在Jenkins里面的<code>http://192.168.200.129:8888/project/web_demo_pipeline</code>) [把代码push到项目里来就会触发这个url自动构建] → Add webhook → 下方可以进行测试test → <code>push event</code> →↓</p>
<p>若出现 则证明gitlab是成功 只是Jenkins需要认证请求 去Jenkins开放接收请求的功能</p>
<pre><code class="xml">Hook executed successfully but returned HTTP 403 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=ISO-8859-1&quot;/&gt; &lt;title&gt;Error 403 anonymous is missing the Job/Build permission&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h2&gt;HTTP ERROR 403 anonymous is missing the Job/Build permission&lt;/h2&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;URI:&lt;/th&gt;&lt;td&gt;/project/web_demo_pipeline&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;STATUS:&lt;/th&gt;&lt;td&gt;403&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;MESSAGE:&lt;/th&gt;&lt;td&gt;anonymous is missing the Job/Build permission&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;SERVLET:&lt;/th&gt;&lt;td&gt;Stapler&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;hr/&gt;&lt;a href=&quot;https://jetty.org/&quot;&gt;Powered by Jetty:// 12.0.19&lt;/a&gt;&lt;hr/&gt; &lt;/body&gt; &lt;/html&gt;
</code></pre>
<p>Jenkins开放接收请求 → 打开主页并跟随路径<code>Dashboard → Manage Jenkins → System</code> 找到 GitLab Enable authentication for ‘&#x2F;project’ end-point【这个要反选 就是不能选钩 且里面的东西删除】 → 再去进行测试test → <code>push event</code> 即可成功<code>Hook executed successfully: HTTP 200</code></p>
<h4 id="Jenkins项目构建细节-3-Jenkins的参数化构建"><a href="#Jenkins项目构建细节-3-Jenkins的参数化构建" class="headerlink" title="Jenkins项目构建细节(3)-Jenkins的参数化构建"></a>Jenkins项目构建细节(3)-Jenkins的参数化构建</h4><p>有时在项目构建的过程中，我们需要**<u>根据用户的输入动态传入一些参数</u>**，从而影响整个构建结果，这时 我们可以使用参数化构建。<br>Jenkins支持非常丰富的参数类型</p>
<blockquote>
<p>大概意思就是 我在项目的jenkinsfile文件里面<br>steps {<br>    checkout scmGit(<br>        <em>branches</em>: [[<em>name</em>: ‘*&#x2F;master’]],<br>        <em>extensions</em>: [],<br>        <em>userRemoteConfigs</em>: [[<br>            <em>credentialsId</em>: ‘ca22e56f-0ecc-4fdc-965d-01e329a0b68a’,<br>            <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo.git&#39;">http://192.168.200.132:82/lanyun_group/web_demo.git&#39;</a><br>        ]]<br>    )<br>这个branches里面的 *&#x2F;master我要求是让用户动态输入值 而不是写死</p>
</blockquote>
<p>首先要在项目里面增加一些参数 <code>web_demo_pipeline</code> 项目中 可以先把触发器的值取消掉 → 进入上面的General的配置 选择<code>This project is parameterized</code> → 可以添加参数 → 加入<code>String Parameter</code>参数 →<br>输入 <u>名称：branch，默认值：master，描述：请输入一个分支的名称</u> → 此时在左侧就会出现一个 <code>Build with Parameters</code> →↓</p>
<blockquote>
<p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘pull code’) {<br>            steps {<br>                checkout scmGit(<br>                    branches: [[<span style = "color:red"><em>name</em>: ‘<em>&#x2F;${branch}}’</span>]],<br>                    <em>extensions</em>: [],<br>                    <em>userRemoteConfigs</em>: [[<br>                        <em>credentialsId</em>: ‘ca22e56f-0ecc-4fdc-965d-01e329a0b68a’,<br>                        <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo.git&#39;">http://192.168.200.132:82/lanyun_group/web_demo.git&#39;</a><br>                    ]]<br>                )<br>            }<br>        }<br>        stage(‘build project’) {<br>            steps {<br>                sh ‘mvn clean package’<br>            }<br>        }<br>        stage(‘publish’) {<br>            steps {<br>                deploy <em>adapters</em>: [tomcat8(<em>alternativeDeploymentContext</em>: ‘’, <em>credentialsId</em>: ‘e847a130-29c3-4d0b-bf35-db8d00de7950’, <em>path</em>: ‘’, <em>url</em>: ‘<a target="_blank" rel="noopener" href="http://192.168.200.131:8090/&#39;)]">http://192.168.200.131:8090/&#39;)]</a>, <em>contextPath</em>: <em>null</em>, <em>war</em>: ‘target&#x2F;</em>.war’<br>            }<br>        }<br>    }<br>}<br>【这时你在Jenkins构建时输入的参数就可以对应着Jenkinsfile文件的动态参数进行构建 (动态值红色已标注)】→ 需要把jenkinsfile的代码push到仓库里去</p>
</blockquote>
<h4 id="Jenkins项目构建细节-4-配置邮箱服务器发送构建结果"><a href="#Jenkins项目构建细节-4-配置邮箱服务器发送构建结果" class="headerlink" title="Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果"></a>Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果</h4><p>安装<code>Email Extension Template</code>插件</p>
<h5 id="Jenkins设置邮箱相关参数"><a href="#Jenkins设置邮箱相关参数" class="headerlink" title="Jenkins设置邮箱相关参数"></a>Jenkins设置邮箱相关参数</h5><p>Dashboard → Manage Jenkins → System → <code>Extended E-mail Notification</code> → QQ邮箱【官网 账号安全设置】打开SMTP服务 找到 <strong>POP3&#x2F;SMTP服务</strong>，点击「开启」→ 勾选“开启服务”旁边的复选框 → 生成<strong>SMTP&#x2F;IMAP 授权码已生成</strong> → <code>jitgujalhqtecadc</code> → 回到Jenkins → SMTP server填写：<code>smtp.qq.com</code>；端口是<code>465</code> → Default user e-mail suffix：<code>@qq.com</code>  下面的用户名是发件人 密码是授权码 使用SSL协议的话SMTP端口就是465 → Jenkins Location 系统管理员邮件地址是发件人地址 </p>
<h5 id="准备邮件内容"><a href="#准备邮件内容" class="headerlink" title="准备邮件内容"></a>准备邮件内容</h5><p>在项目根目录编写email.html，并把文件推送到Gitlab，内容如下：【根目录下】<br>BUILD_NUMBER、BUILD_STATUS等 来自于Jenkins的全局变量 </p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;$&#123;ENV, var=&quot;JOB_NAME&quot;&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt;
&lt;/head&gt;

&lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;
      offset=&quot;0&quot;&gt;
&lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;
       style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;h2&gt;
            &lt;font color=&quot;#0000FF&quot;&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt;
        &lt;/h2&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;br /&gt;
            &lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建信息&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;ul&gt;
                &lt;li&gt;项目名称&amp;nbsp;：&amp;nbsp;$&#123;PROJECT_NAME&#125;&lt;/li&gt;
                &lt;li&gt;构建编号&amp;nbsp;：&amp;nbsp;第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt;
                &lt;li&gt;触发原因：&amp;nbsp;$&#123;CAUSE&#125;&lt;/li&gt;
                &lt;li&gt;构建日志：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;构建&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;BUILD_URL&#125;&quot;&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;工作目录&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws&quot;&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;项目&amp;nbsp;&amp;nbsp;Url&amp;nbsp;：&amp;nbsp;&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;Changes Since Last
            Successful Build:&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;ul&gt;
                &lt;li&gt;历史变更记录 : &lt;a href=&quot;$&#123;PROJECT_URL&#125;changes&quot;&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt; $&#123;CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=&quot;Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;&quot;,showPaths=true,changesFormat=&quot;&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;&quot;,pathFormat=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;%p&quot;&#125;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;Failed Test Results&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;pre
                style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&gt;$FAILED_TESTS&lt;/pre&gt;
            &lt;br /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;b&gt;&lt;font color=&quot;#0B610B&quot;&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt;
            &lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot;
                      style=&quot;font-family: Courier New&quot;&gt;$&#123;BUILD_LOG, maxLines=100&#125;&lt;/textarea&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>post的内容可以用流水线语法生成 → 完成之后点击片段生成器 生成一个 <code>emailext: Extended Email</code> 的代码片段</p>
<pre><code class="java">pipeline &#123;
    agent any
    stages &#123;
        stage(&#39;pull code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &#39;*/$&#123;branch&#125;&#39;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;
        stage(&#39;build project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;
        stage(&#39;publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(alternativeDeploymentContext: &#39;&#39;, credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, path: &#39;&#39;, url: &#39;http://192.168.200.131:8090/&#39;)], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;
    post&#123;
        always&#123;
             emailext(
                 subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
                 body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
                 to: &#39;2523419709@qq.com&#39;
             )
        &#125;
    &#125;
&#125;
</code></pre>
<p>PS：邮件相关全局参数参考列表：<br>系统设置-&gt;Extended E-mail Notification-&gt;Content Token Reference，点击旁边的?号</p>
<h4 id="Jenkins-SonarQube代码审查-1-安装SonarQube"><a href="#Jenkins-SonarQube代码审查-1-安装SonarQube" class="headerlink" title="Jenkins+SonarQube代码审查(1) - 安装SonarQube"></a>Jenkins+SonarQube代码审查(1) - 安装SonarQube</h4><h5 id="SonaQube简介"><a href="#SonaQube简介" class="headerlink" title="SonaQube简介"></a>SonaQube简介</h5><p>SonarQube 是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前 支持java,C#,C&#x2F;C++,Python,PL&#x2F;SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检 测。</p>
<p>官网： <a target="_blank" rel="noopener" href="https://www.sonarqube.org/">https://www.sonarqube.org/</a></p>
<h5 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h5><table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">服务器</th>
<th align="center">版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK</td>
<td align="center">192.168.200.129</td>
<td align="center">1.8</td>
</tr>
<tr>
<td align="center">MySQL</td>
<td align="center">192.168.200.129</td>
<td align="center">5.7</td>
</tr>
<tr>
<td align="center">SonarQube</td>
<td align="center">192.168.200.129</td>
<td align="center">6.7.4</td>
</tr>
</tbody></table>
<h5 id="安装SonarQube"><a href="#安装SonarQube" class="headerlink" title="安装SonarQube"></a>安装SonarQube</h5><p>1）安装MySQL（已完成）<br>2）安装SonarQube</p>
<blockquote>
<p>使用5.7数据库<br>先删除以前的</p>
<h3 id="建议操作："><a href="#建议操作：" class="headerlink" title="建议操作："></a>建议操作：</h3><ol>
<li><strong>先把多余或冲突的文件临时备份移动一下，避免yum混乱</strong></li>
</ol>
<pre><code>bash复制编辑sudo mv /etc/yum.repos.d/mysql-community.repo.rpmsave /root/
sudo mv /etc/yum.repos.d/mysql57.repo /root/
</code></pre>
<ol>
<li><strong>只保留 <code>mysql-community.repo</code> 这个 repo 文件，确保它内容正确（你可以用<code>cat</code>看下内容）</strong></li>
</ol>
<pre><code>cat /etc/yum.repos.d/mysql-community.repo
</code></pre>
<ol>
<li><strong>清理缓存，重新生成</strong></li>
</ol>
<pre><code>sudo yum clean all
sudo yum makecache
</code></pre>
<ol>
<li><strong>尝试安装mysql 5.7</strong></li>
</ol>
<pre><code>sudo yum install mysql-community-server
</code></pre>
<hr>
<h3 id="解决方案：用符合策略的密码先改，再降低策略"><a href="#解决方案：用符合策略的密码先改，再降低策略" class="headerlink" title="解决方案：用符合策略的密码先改，再降低策略"></a>解决方案：用符合策略的密码先改，再降低策略</h3><ol>
<li><strong>用一个符合复杂度的密码先改密码</strong>，例如：</li>
</ol>
<pre><code>sql


复制编辑
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Root@12345&#39;;
</code></pre>
<ol>
<li><strong>登录成功后降低密码策略：</strong></li>
</ol>
<pre><code>sql复制编辑SET GLOBAL validate_password_policy=LOW;
SET GLOBAL validate_password_length=1;
</code></pre>
<ol>
<li><strong>再修改为你想要的简单密码（比如<code>root</code>）：</strong></li>
</ol>
<pre><code>sql


复制编辑
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39;;
</code></pre>
<ol>
<li><strong>刷新权限</strong></li>
</ol>
<pre><code>FLUSH PRIVILEGES;
</code></pre>
</blockquote>
<p>在mysql创建sonar数据库</p>
<blockquote>
<h3 id="启动-MySQL-服务（如果没启动）"><a href="#启动-MySQL-服务（如果没启动）" class="headerlink" title="启动 MySQL 服务（如果没启动）"></a>启动 MySQL 服务（如果没启动）</h3><pre><code>systemctl start mysqld
</code></pre>
<p>启动后再次检查状态：</p>
<pre><code>systemctl status mysqld
</code></pre>
<p><code>mysql -uroot -p</code><br>账号密码是：root</p>
</blockquote>
<pre><code class="mysql">mysql&gt; create database sonar;

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sonar              |
| sys                |
+--------------------+
5 rows in set (0.07 sec)
</code></pre>
<h5 id="解压sonar，并设置权限"><a href="#解压sonar，并设置权限" class="headerlink" title="解压sonar，并设置权限"></a>解压sonar，并设置权限</h5><blockquote>
<p>yum install unzip<br>unzip sonarqube-6.7.4.zip                       解压<br>mkdir &#x2F;opt&#x2F;sonar                                       创建目录<br>mv sonarqube-6.7.4&#x2F;* &#x2F;opt&#x2F;sonar          移动文件<br>useradd sonar                                           <strong>创建sonar用户</strong>，必须sonar用于启动，否则报错 </p>
<p>chown -R sonar. &#x2F;opt&#x2F;sonar                    更改sonar目录及文件权限</p>
<p>[root@localhost ~]# cd &#x2F;opt&#x2F;sonar<br>[root@localhost sonar]# ll<br>总用量 12<br>drwxr-xr-x. 8 sonar sonar  136 5月  30 2018 bin<br>drwxr-xr-x. 2 sonar sonar   50 5月  30 2018 conf<br>-rw-r–r–. 1 sonar sonar 7651 5月  30 2018 COPYING<br>drwxr-xr-x. 2 sonar sonar   24 5月  30 2018 data<br>drwxr-xr-x. 7 sonar sonar  150 5月  30 2018 elasticsearch<br>drwxr-xr-x. 4 sonar sonar   40 5月  30 2018 extensions<br>drwxr-xr-x. 9 sonar sonar  140 5月  30 2018 lib<br>drwxr-xr-x. 2 sonar sonar    6 5月  30 2018 logs<br>drwxr-xr-x. 2 sonar sonar   24 5月  30 2018 temp<br>drwxr-xr-x. 9 sonar sonar 4096 5月  30 2018 web</p>
</blockquote>
<h5 id="修改sonar配置文件数据库连接信息"><a href="#修改sonar配置文件数据库连接信息" class="headerlink" title="修改sonar配置文件数据库连接信息"></a>修改sonar配置文件<del>数据库连接信息</del></h5><blockquote>
<p>[root@localhost opt]# cd sonar<br>[root@localhost sonar]# cd conf<br>[root@localhost conf]# vi sonar.properties</p>
<p>||          ||                   ||                  ||         </p>
<pre><code class="java">......
sonar.jdbc.username=root
sonar.jdbc.password=root
......
sonar.jdbc.url=jdbc:mysql://127.0.0.1:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false 【这里打开注释】

注意：sonar默认监听9000端口，如果9000端口被占用，需要更改 
如果要改端口 在这里：
sonar.web.port=9999

</code></pre>
</blockquote>
<h6 id="启动sonar-129"><a href="#启动sonar-129" class="headerlink" title="启动sonar 129"></a>启动sonar 129</h6><blockquote>
<p>[root@localhost bin]# pwd<br>&#x2F;opt&#x2F;sonar&#x2F;bin<br>cd &#x2F;opt&#x2F;sonar&#x2F;bin</p>
</blockquote>
<p>修改配置文件：<code>vi /opt/sonar/conf/sonar.properties</code><br><span style ="color:red"><strong>重启sonar</strong></span>：<code>sudo -u sonar /opt/sonar/bin/linux-x86-64/sonar.sh restart</code> ★★  [Jenkins服务]</p>
<blockquote>
<h5 id="实时跟踪最新日志输出（推荐用于调试启动或运行时状态）"><a href="#实时跟踪最新日志输出（推荐用于调试启动或运行时状态）" class="headerlink" title="实时跟踪最新日志输出（推荐用于调试启动或运行时状态）"></a>实时跟踪最新日志输出（推荐用于调试启动或运行时状态）</h5><p>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;sonar.log<br>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;web.log<br>tail -f &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;es.log</p>
<h5 id="查看日志末尾100条内容（快速查看最近日志）"><a href="#查看日志末尾100条内容（快速查看最近日志）" class="headerlink" title="查看日志末尾100条内容（快速查看最近日志）"></a>查看日志末尾100条内容（快速查看最近日志）</h5><p>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;sonar.log<br>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;web.log<br>tail -n 100 &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;es.log</p>
<h5 id="查看整个日志文件大小和权限"><a href="#查看整个日志文件大小和权限" class="headerlink" title="查看整个日志文件大小和权限"></a>查看整个日志文件大小和权限</h5><p>ls -lh &#x2F;opt&#x2F;sonar&#x2F;logs&#x2F;*.log</p>
</blockquote>
<p>访问<strong>SonarQube</strong></p>
<p>[192.168.200.129] (<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/">http://192.168.200.129:9999/</a>)</p>
<p><code>账号密码：admin admin</code><br>生成了一个token：<code>sonar: d30033c63973bd4183b6015995dbb513627c6f59</code></p>
<blockquote>
<p><span style = "color:red"><strong>启动命令总结：</strong></span><br>[192.168.200.132] GitLab：gitlab-ctl restart<br><a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group/web_demo">lanyun_group &#x2F; web_demo · GitLab</a><br>[192.168.200.131] Tomcat：&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.sh<br><a target="_blank" rel="noopener" href="http://192.168.200.131:8090/web_demo-1.0-SNAPSHOT/">演示项目主页</a></p>
<p>[192.168.200.129] Jenkins：systemctl start jenkins<br><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/login?from=/job/web_demo_pipeline/">登录 - Jenkins</a><br>[192.168.200.129] SonarQube：sudo -u sonar &#x2F;opt&#x2F;sonar&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh restart<br><a target="_blank" rel="noopener" href="http://192.168.200.129:9999/about">192.168.200.129</a></p>
</blockquote>
<h3 id="Jenkins-SonarQube代码审查-2-实现代码审查"><a href="#Jenkins-SonarQube代码审查-2-实现代码审查" class="headerlink" title="Jenkins+SonarQube代码审查(2) - 实现代码审查"></a>Jenkins+SonarQube代码审查(2) - 实现代码审查</h3><p>审查流程：</p>
<blockquote>
<p>Jenkins →(调用)→ Sonar-Scanner →(提交审查结果)→ SonarQube →(保存审查结果)→ MySQL数据库</p>
</blockquote>
<h5 id="安装SonarQube-Scanner插件"><a href="#安装SonarQube-Scanner插件" class="headerlink" title="安装SonarQube Scanner插件"></a>安装SonarQube Scanner插件</h5><p>打开Jenkins的全局配置 → <strong>SonarQube Servers</strong> → Add SonarQube → Name：sonarqube；Server URL：<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/">http://192.168.200.129:9999/</a> → 新建一个证书[Manage Jenkins → Credentials → System → 全局添加 → 类型选择<code>Secret text</code> ；Secret是之前复制到的token字符串 ；描述：sonarqube-auth] → Server authentication token选择刚刚创建的sonarqube-auth</p>
<h5 id="SonarQube-关闭审查结果上传到SCM功能"><a href="#SonarQube-关闭审查结果上传到SCM功能" class="headerlink" title="SonarQube 关闭审查结果上传到SCM功能"></a>SonarQube 关闭审查结果上传到SCM功能</h5><p>[General Settings - Administration] (<a target="_blank" rel="noopener" href="http://192.168.200.129:9999/admin/settings?category=scm">http://192.168.200.129:9999/admin/settings?category=scm</a>) 上方的Administration → 左侧的SCM → 第一个打开SCN Sensor</p>
<p>回到Jenkins的<code>web_demo_freestyle</code>项目点击构建 下方的Build Steps下面的<code>增加构建步骤</code> 选择<code>Execute SonarQube Scanner</code> (这里要在去Tools里安装配置 SonarQube Scanner 安装 → Name:sonar-scanner；Install automatically：<u>SonarQube Scanner 4.2.0.1873</u>) → 这里的jdk是根据Jenkins的jdk配置的 → (Path to project properties这个可以在项目下搞 也可以用Analysis properties 属性放在前端ui界面里面) 这里选择<code>Analysic properties</code>→↓</p>
<pre><code class="yaml"># must be unique in a given SonarQube instance
sonar.projectKey=web_demo_freestyle
# this is the name and version displayed in the SonarQube UI. Was mandatory 
prior to SonarQube 6.1.
sonar.projectName=web_demo_freestyle
sonar.projectVersion=1.0
 # Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on 
Windows.
 # This property is optional if sonar.modules is set.
 sonar.sources=.
 sonar.exclusions=**/test/**,**/target/**
 sonar.java.source=1.8
 sonar.java.target=1.8
 # Encoding of the source code. Default is default system encoding
 sonar.sourceEncoding=UTF-8
</code></pre>
<p>→ 应用保存 + 重新构建 </p>
<p>现在有个问题就是我Jenkins是2.504.2 然后jdk是17 我不想换jdk的情况下就要去 </p>
<pre><code class="yaml">Build Steps里面的执行脚本

echo &quot;开始进行编译构建&quot;
mvn clean package
echo &quot;编译构建结束&quot;

# 设置环境变量，给sonar-scanner的JVM传参数，解决Java17模块访问问题
export SONAR_SCANNER_OPTS=&quot;--add-opens=java.base/java.lang=ALL-UNNAMED \
--add-opens=java.base/java.lang.reflect=ALL-UNNAMED \
--add-opens=java.base/java.io=ALL-UNNAMED&quot;

# 执行Sonar扫描
/var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
  -Dsonar.projectKey=web_demo_freestyle \
  -Dsonar.host.url=http://192.168.200.129:9999 \
  -Dsonar.sources=. \
  -Dsonar.exclusions=**/test/**,**/target/** \
  -Dsonar.java.source=1.8 \
  -Dsonar.java.target=1.8

echo &quot;SonarQube扫描结束&quot;
</code></pre>
<blockquote>
<p>打开idea jenkinsfile文件</p>
<pre><code class="yaml">pipeline &#123;
 agent any
 stages &#123;
     stage(&#39;pull code&#39;) &#123;
         steps &#123;
             checkout scmGit(
                 branches: [[name: &quot;*/$&#123;branch&#125;&quot;]],
                 extensions: [],
                 userRemoteConfigs: [[
                     credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                     url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                 ]]
             )
         &#125;
     &#125;
     stage(&#39;build project&#39;) &#123;
         steps &#123;
             sh &#39;mvn clean package&#39;
         &#125;
     &#125;
     stage(&#39;sonarqube scan&#39;) &#123;
         environment &#123;
             // 传递给sonar-scanner JVM的启动参数，解决模块访问限制
             SONAR_SCANNER_OPTS = &#39;--add-opens=java.base/java.lang=ALL-UNNAMED &#39; +
                                  &#39;--add-opens=java.base/java.lang.reflect=ALL-UNNAMED &#39; +
                                  &#39;--add-opens=java.base/java.io=ALL-UNNAMED&#39;
         &#125;
         steps &#123;
             sh &#39;&#39;&#39;
             /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
               -Dsonar.projectKey=web_demo_freestyle \
               -Dsonar.host.url=http://192.168.200.129:9999 \
               -Dsonar.sources=. \
               -Dsonar.exclusions=**/test/**,**/target/** \
               -Dsonar.java.source=1.8 \
               -Dsonar.java.target=1.8
             &#39;&#39;&#39;
         &#125;
     &#125;
     stage(&#39;publish&#39;) &#123;
         steps &#123;
             deploy adapters: [tomcat8(
                 alternativeDeploymentContext: &#39;&#39;, 
                 credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;, 
                 path: &#39;&#39;, 
                 url: &#39;http://192.168.200.131:8090/&#39;
             )], contextPath: null, war: &#39;target/*.war&#39;
         &#125;
     &#125;
 &#125;
 post &#123;
     always &#123;
         emailext(
             subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
             body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
             to: &#39;2523419709@qq.com&#39;
         )
     &#125;
 &#125;
&#125;
</code></pre>
<h3 id="✅-方法一：编辑-SonarScanner-的配置文件（最可靠）"><a href="#✅-方法一：编辑-SonarScanner-的配置文件（最可靠）" class="headerlink" title="✅ 方法一：编辑 SonarScanner 的配置文件（最可靠）"></a>✅ 方法一：编辑 SonarScanner 的配置文件（最可靠）</h3><p>编辑 Jenkins 中自动下载的 <code>sonar-scanner</code> 的 JVM 启动参数配置文件：</p>
<pre><code class="mysql">sudo vi /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/conf/sonar-scanner.properties
</code></pre>
<p>在文件最后 <strong>添加</strong></p>
<pre><code class="mysql"># 开启JDK17对反射的兼容
sonar.scanner.jvmArgs=--add-opens java.base/java.lang=ALL-UNNAMED
</code></pre>
<p>整体的文件是这样的：</p>
<pre><code class="yaml">#Configure here general information about the environment, such as SonarQube server connection details for example
#No information about specific project should appear here

#----- Default SonarQube server
sonar.host.url=http://localhost:9999

#----- Default source code encoding
#sonar.sourceEncoding=UTF-8
# 开启JDK17对反射的兼容
sonar.scanner.jvmArgs=--add-opens java.base/java.lang=ALL-UNNAMED
</code></pre>
<h4 id="★如果要使用sonarqube-一定要jdk是1-8★"><a href="#★如果要使用sonarqube-一定要jdk是1-8★" class="headerlink" title="★如果要使用sonarqube 一定要jdk是1.8★"></a>★如果要使用sonarqube 一定要jdk是1.8★</h4><p>首先需要去全局那里设置jdk（Manage jenkins → System）</p>
<p>键：<br><code>JAVA_HOME</code><br>值：<br><code>/usr/local/java/jdk-17.0.8+7</code></p>
<p>键：<br><code>JAVA_HOME</code><br>值：<br><code>/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64</code><br>在构建项目配置的时候<code>Build Steps</code> → <code>Execute SonarQube Scanner</code> → jdk一定要选择1.8的！！！</p>
<hr>
<hr>
<h4 id="流水线构建版本用的jdk17解决办法"><a href="#流水线构建版本用的jdk17解决办法" class="headerlink" title="流水线构建版本用的jdk17解决办法"></a><span style = "color:red"><strong>流水线构建版本用的jdk17解决办法</strong></span></h4><p>要默认的1.8才支持 所以直接从根源上解决这个问题</p>
<p>你当前的系统默认 Java 是 <strong>JDK 1.8</strong>，路径在：</p>
<pre><code>/usr/bin/java
</code></pre>
<p>你执行的：</p>
<pre><code>java -version
</code></pre>
<p>输出是：</p>
<pre><code>openjdk version &quot;1.8.0_262&quot;
</code></pre>
<p>说明现在 Jenkins 主机上默认使用的是 Java 8，这是符合 <strong>SonarQube 6.7.4 的推荐版本</strong>，很好！</p>
<hr>
<h2 id="✅-接下来你要做的"><a href="#✅-接下来你要做的" class="headerlink" title="✅ 接下来你要做的"></a>✅ 接下来你要做的</h2><p>为了确保 Jenkins 中的 <code>SonarScanner</code> 也用 Java 8 运行，你还需要修改如下：</p>
<hr>
<h3 id="✅-方法一：修改-sonar-scanner-启动脚本（推荐）"><a href="#✅-方法一：修改-sonar-scanner-启动脚本（推荐）" class="headerlink" title="✅ 方法一：修改 sonar-scanner 启动脚本（推荐）"></a>✅ 方法一：修改 <code>sonar-scanner</code> 启动脚本（推荐）</h3><pre><code class="java">vi /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner
</code></pre>
<p>在顶部添加下面两行 👇：</p>
<pre><code class="java">export JAVA_HOME=/usr
export PATH=$JAVA_HOME/bin:$PATH
</code></pre>
</blockquote>
<hr>
<h5 id="模拟SonaQube代码审查机制"><a href="#模拟SonaQube代码审查机制" class="headerlink" title="模拟SonaQube代码审查机制"></a>模拟SonaQube代码审查机制</h5><p><code>C:\Users\Pluminary\Desktop\web_demo\src\main\java\com\itheima\HelloServlet.java</code></p>
<pre><code class="java">package com.itheima;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 *
 */
public class HelloServlet extends HttpServlet &#123;


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        super.doPost(req,resp);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //模拟代码错误
        int i = 100/0;

        //模拟冗余代码
        int a = 100;
        a = 200;


        resp.getWriter().write(&quot;hello Servlet!&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！"><a href="#在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！" class="headerlink" title="在项目添加SonaQube代码审查（流水线项目）不在Jenkins里面写配置，在项目的文件里面写！"></a>在项目添加SonaQube代码审查（流水线项目）<del>不在Jenkins里面写配置，在项目的文件里面写！</del></h4><pre><code class="java">sonar-project.properties
    
# must be unique in a given SonarQube instance
sonar.projectKey=web_demo_pipline
# this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.
sonar.projectName=web_demo_pipline
sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.
# This property is optional if sonar.modules is set.
sonar.sources=.
sonar.exclusions=**/test/**,**/target/**

sonar.java.source=1.8
sonar.java.target=1.8

# Encoding of the source code. Default is default system encoding
sonar.sourceEncoding=UTF-8
</code></pre>
<pre><code class="java">pipeline &#123;
    agent any

    tools &#123;
        // 使用 Jenkins 配置好的 JDK 1.8（别名需和你Jenkins中配置一致）
        jdk &#39;jdk-1.8.0&#39;
    &#125;

    environment &#123;
        // Sonar Scanner JVM 启动参数，开启必要的module访问权限
        SONAR_SCANNER_OPTS = &#39;--add-opens=java.base/java.lang=ALL-UNNAMED &#39; +
                             &#39;--add-opens=java.base/java.lang.reflect=ALL-UNNAMED &#39; +
                             &#39;--add-opens=java.base/java.io=ALL-UNNAMED&#39;
    &#125;

    stages &#123;
        stage(&#39;Pull Code&#39;) &#123;
            steps &#123;
                checkout scmGit(
                    branches: [[name: &quot;*/$&#123;branch&#125;&quot;]],
                    extensions: [],
                    userRemoteConfigs: [[
                        credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;,
                        url: &#39;http://192.168.200.132:82/lanyun_group/web_demo.git&#39;
                    ]]
                )
            &#125;
        &#125;

        stage(&#39;Build Project&#39;) &#123;
            steps &#123;
                sh &#39;mvn clean package&#39;
            &#125;
        &#125;

        stage(&#39;SonarQube Scan&#39;) &#123;
            steps &#123;
                // 强制切换到 JDK8 环境，避免默认JDK17导致权限异常
                withEnv([
                    &#39;JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64&#39;,
                    &#39;PATH=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64/bin:&#39; + env.PATH
                ]) &#123;
                    sh &#39;&#39;&#39;
                    /var/lib/jenkins/tools/hudson.plugins.sonar.SonarRunnerInstallation/sonar-scanner/bin/sonar-scanner \
                      -Dsonar.projectKey=web_demo_freestyle \
                      -Dsonar.host.url=http://192.168.200.129:9999 \
                      -Dsonar.sources=. \
                      -Dsonar.exclusions=**/test/**,**/target/** \
                      -Dsonar.java.source=1.8 \
                      -Dsonar.java.target=1.8
                    &#39;&#39;&#39;
                &#125;
            &#125;
        &#125;

        stage(&#39;Publish&#39;) &#123;
            steps &#123;
                deploy adapters: [tomcat8(
                    alternativeDeploymentContext: &#39;&#39;,
                    credentialsId: &#39;e847a130-29c3-4d0b-bf35-db8d00de7950&#39;,
                    path: &#39;&#39;,
                    url: &#39;http://192.168.200.131:8090/&#39;
                )], contextPath: null, war: &#39;target/*.war&#39;
            &#125;
        &#125;
    &#125;

    post &#123;
        always &#123;
            emailext(
                subject: &#39;构建通知：$&#123;PROJECT_NAME&#125; - Build # $&#123;BUILD_NUMBER&#125; - $&#123;BUILD_STATUS&#125;!&#39;,
                body: &#39;$&#123;FILE,path=&quot;email.html&quot;&#125;&#39;,
                to: &#39;2523419709@qq.com&#39;
            )
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h4 id="Jenkins-Docker-SpringCloud微服务持续集成-上"><a href="#Jenkins-Docker-SpringCloud微服务持续集成-上" class="headerlink" title="Jenkins+Docker+SpringCloud微服务持续集成(上)"></a>Jenkins+Docker+SpringCloud微服务持续集成(上)</h4><h5 id="Jenkins-Docker-SpringCloud持续集成流程说明"><a href="#Jenkins-Docker-SpringCloud持续集成流程说明" class="headerlink" title="Jenkins+Docker+SpringCloud持续集成流程说明"></a>Jenkins+Docker+SpringCloud持续集成流程说明</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/db193c56fc4ab5def5c327247037af53ce451fb5/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E8%AF%B4%E6%98%8E2.png"></p>
<p>大致流程说明：<br>1）开发人员每天把代码提交到Gitlab代码仓库<br>2）Jenkins从Gitlab中拉取项目源码，编译并打成jar包，然后构建成Docker镜像，将镜像上传到 Harbor私有仓库。<br>3）Jenkins发送SSH远程命令，让生产部署服务器到Harbor私有仓库拉取镜像到本地，然后创建容器。<br>4）最后，用户可以访问到容器</p>
<h6 id="服务列表-红色的软件为需要安装的软件，黑色代表已经安装"><a href="#服务列表-红色的软件为需要安装的软件，黑色代表已经安装" class="headerlink" title="服务列表(红色的软件为需要安装的软件，黑色代表已经安装)"></a>服务列表(红色的软件为需要安装的软件，黑色代表已经安装)</h6><table>
<thead>
<tr>
<th>服务器名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.200.132</td>
<td>Gitlab</td>
</tr>
<tr>
<td>持续集成服务器</td>
<td>192.168.200.129</td>
<td>Jenkins，Maven，Docker18.06.1-ce</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td></td>
<td>Docker18.06.1-ce，Harbor1.9.2</td>
</tr>
<tr>
<td>生产部署服务器</td>
<td></td>
<td>Docker18.06.1-ce</td>
</tr>
</tbody></table>
<h4 id="SpringCloud微服务源码概述"><a href="#SpringCloud微服务源码概述" class="headerlink" title="SpringCloud微服务源码概述"></a>SpringCloud微服务源码概述</h4><p>项目架构：前后端分离<br>后端技术栈：SpringBoot+SpringCloud+SpringDataJpa（Spring全家桶）<br>位置：<code>C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent</code></p>
<h6 id="微服务项目结构："><a href="#微服务项目结构：" class="headerlink" title="微服务项目结构："></a>微服务项目结构：</h6><ul>
<li>tensquare_parent ：父工程，存放基础配置 </li>
<li>tensquare_common ：通用工程，存放工具类 </li>
<li>tensquare_eureka_server：SpringCloud的Eureka注册中心 </li>
<li>tensquare_zuul ：SpringCloud的网关服务 </li>
<li>tensquare_admin_service ：基础权限认证中心，负责用户认证（使用JWT认证）</li>
<li>tensquare_gathering ： 一个简单的业务模块，活动微服务相关逻辑</li>
</ul>
<h6 id="数据库结构："><a href="#数据库结构：" class="headerlink" title="数据库结构："></a>数据库结构：</h6><ul>
<li>tensquare_user ：用户认证数据库，存放用户账户数据。对应tensquare_admin_service微服务 </li>
<li>tensquare_gathering ：活动微服务数据库。对应tensquare_gathering微服务</li>
</ul>
<h6 id="微服务配置分析："><a href="#微服务配置分析：" class="headerlink" title="微服务配置分析："></a>微服务配置分析：</h6><ul>
<li><p>tensquare_eureka</p>
</li>
<li><p>tensquare_zuul</p>
</li>
<li><p>tensquare_admin_service</p>
</li>
<li><p>tensquare_gathering</p>
</li>
<li><p>查看效果</p>
</li>
</ul>
<pre><code class="yaml">application.yaml

spring:
  application:
    name: EUREKA-HA

---

spring:
  profiles: eureka-server1
server:
  port: 10086
eureka:
  instance:
    hostname: localhost
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/

---

spring:
  profiles: eureka-server2
server:
  port: 10087
eureka:
  instance:
    hostname: localhost
  client:
    service-url:
      defaultZone: http://localhost:10086/eureka/,http://localhost:10087/eureka/
</code></pre>
<p>依次开启这些服务：<code>tensquare_eureka_server → tensquare_zuul → tensquare_admin_service → tensquare_gathering </code></p>
<blockquote>
<p>tensquare_eureka_server 要在配置的地方配置两个【复制出多一个】配置信息添加<code>Program arguments</code></p>
<p>EurekaServerApplication-Server1：-spring.profiles.active&#x3D;eureka-server1<br>EurekaServerApplication-Server2：–spring.profiles.active&#x3D;eureka-server2</p>
</blockquote>
<h5 id="调用postman"><a href="#调用postman" class="headerlink" title="调用postman"></a>调用postman</h5><h6 id="测试gathering接口的时候一定要在请求头带token"><a href="#测试gathering接口的时候一定要在请求头带token" class="headerlink" title="测试gathering接口的时候一定要在请求头带token"></a>测试gathering接口的时候一定要在请求头带token</h6><h6 id="测试获得token接口的时候一定是post请求-请求体是json形式"><a href="#测试获得token接口的时候一定是post请求-请求体是json形式" class="headerlink" title="测试获得token接口的时候一定是post请求 请求体是json形式"></a>测试获得token接口的时候一定是post请求 请求体是json形式</h6><pre><code class="yaml">GET：http://localhost:10020/gathering/gathering

Headers：这里的token是去post请求获得
</code></pre>
<pre><code class="yaml">POST：http://localhost:10020/admin/admin/login

json：&#123;
  &quot;loginname&quot;: &quot;admin&quot;,
  &quot;password&quot;: &quot;123456&quot;
&#125;
</code></pre>
<h4 id="本地部署-1-SpringCloud微服务部署"><a href="#本地部署-1-SpringCloud微服务部署" class="headerlink" title="本地部署(1)-SpringCloud微服务部署"></a>本地部署(1)-SpringCloud微服务部署</h4><h5 id="本地运行微服务"><a href="#本地运行微服务" class="headerlink" title="本地运行微服务"></a>本地运行微服务</h5><ul>
<li>逐一启动微服务</li>
<li>使用postman测试功能是否可用</li>
</ul>
<h5 id="本地部署微服务"><a href="#本地部署微服务" class="headerlink" title="本地部署微服务"></a>本地部署微服务</h5><ul>
<li>SpringBoot微服务项目打包</li>
</ul>
<blockquote>
<p>打开idea终端<br>PS C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent&gt;<br>托选想要打包的项目到终端<br>PS C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server&gt; <strong>mvn clean package</strong><br>此时就打好了jar包<br>C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server\target的<code>tensquare_eureka_server-1.0-SNAPSHOT.jar</code></p>
</blockquote>
<p>必须导入该插件</p>
<pre><code class="xml">在根pom.xml中
   &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

★ 这个就可以对springcloud进行打包 微服务的jar可以独立部署 扔到任何一个服务就可以单独运行 而不需要借助单独的tomcat ★
</code></pre>
<p>打包后在 target下产生jar包</p>
<ul>
<li><span style="color:red"><strong>本地运行微服务的jar包</strong></span></li>
</ul>
<p><code>java -jar xxx.jar</code></p>
<pre><code class="yaml">C:\Users\Pluminary\Desktop&gt;java -jar tensquare_eureka_server-1.0-SNAPSHOT.jar


2025-07-01 15:33:09.363  INFO 27172 --- [           main] o.s.core.annotation.AnnotationUtils      : Failed to introspect annotations on class org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration: java.lang.IllegalStateException: Could not obtain annotation attribute value for public abstract java.lang.Class[] org.springframework.boot.autoconfigure.condition.ConditionalOnClass.value()
2025-07-01 15:33:09.373  INFO 27172 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@8f4ea7c: startup date [Tue Jul 01 15:33:09 CST 2025]; root of context hierarchy
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.springframework.cglib.core.ReflectUtils$1 (jar:file:/C:/Users/Pluminary/Desktop/tensquare_eureka_server-1.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-core-5.0.5.RELEASE.jar!/) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)
WARNING: Please consider reporting this to the maintainers of org.springframework.cglib.core.ReflectUtils$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
2025-07-01 15:33:09.531  INFO 27172 --- [           main] f.a.AutowiredAnnotationBeanPostProcessor : JSR-330 &#39;javax.inject.Inject&#39; annotation found and supported for autowiring
2025-07-01 15:33:09.554  INFO 27172 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean &#39;configurationPropertiesRebinderAutoConfiguration&#39; of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$83532275] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)

  .   ____          _            __ _ _
 /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &#39;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.1.RELEASE)
</code></pre>
<h4 id="本地部署-2-前端静态web网站"><a href="#本地部署-2-前端静态web网站" class="headerlink" title="本地部署(2)-前端静态web网站"></a>本地部署(2)-前端静态web网站</h4><p>前端技术栈：NodeJS+VueJS+ElementUI<br>使用Visual Studio Code打开源码<br>位置：<code>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin</code></p>
<p>因为老版本无法继续用最新的nodejs<br>需要用nvm进行统一的nodejs管理 如果无法直接nvm下载的话<br>我们可以去官网下载安装包zip后解压进去 改名就行</p>
<blockquote>
<h4 id="✅-1-下载-Node-js-v10-24-1-64位-zip-版本"><a href="#✅-1-下载-Node-js-v10-24-1-64位-zip-版本" class="headerlink" title="✅ 1. 下载 Node.js v10.24.1 64位 zip 版本"></a>✅ 1. 下载 Node.js v10.24.1 64位 zip 版本</h4><p>你可以从官方链接下载：</p>
<p>📦 下载地址（Windows 64位）：</p>
<pre><code>bash


复制编辑
https://nodejs.org/dist/v10.24.1/node-v10.24.1-win-x64.zip
</code></pre>
<p>下载后，解压得到一个文件夹（比如叫 <code>node-v10.24.1-win-x64</code>）</p>
<hr>
<h4 id="✅-2-放入-NVM-的版本目录"><a href="#✅-2-放入-NVM-的版本目录" class="headerlink" title="✅ 2. 放入 NVM 的版本目录"></a>✅ 2. 放入 NVM 的版本目录</h4><p>将你解压得到的 <code>node-v10.24.1-win-x64</code> 文件夹重命名为：</p>
<pre><code>10.24.1
</code></pre>
<p>然后放入这个目录下：</p>
<pre><code>C:\Program Files\nvm\versions\10.24.1\
</code></pre>
<p>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin&gt;<strong>nvm list</strong></p>
<ul>
<li>20.12.0 (Currently using 64-bit executable)<br>10.24.1</li>
</ul>
<p>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin&gt;<strong>nvm use 10.24.1</strong><br>Now using node v10.24.1 (64-bit)</p>
<hr>
<hr>
<h4 id="🚀-步骤-1：重新下载对应-binding-node"><a href="#🚀-步骤-1：重新下载对应-binding-node" class="headerlink" title="🚀 步骤 1：重新下载对应 binding.node"></a>🚀 步骤 1：重新下载对应 <code>binding.node</code></h4><p>在项目目录下运行：</p>
<pre><code>bash


复制编辑
npm rebuild node-sass
</code></pre>
</blockquote>
<p> I  Your application is running here: <a target="_blank" rel="noopener" href="http://localhost:9528/">http://localhost:9528</a> 前端即可启动！<br><code>name: admin    password: 123456</code><br>[十次方社交平台-管理员后台] (<a target="_blank" rel="noopener" href="http://localhost:9528/#/gathering/index">http://localhost:9528/#/gathering/index</a>)</p>
<h3 id="环境准备-1-Docker快速入门"><a href="#环境准备-1-Docker快速入门" class="headerlink" title="环境准备(1)-Docker快速入门"></a>环境准备(1)-Docker快速入门</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流 行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销 极低。 Docker容器技术 vs 传统虚拟机技术</p>
<table>
<thead>
<tr>
<th></th>
<th>虚拟机</th>
<th>容器</th>
</tr>
</thead>
<tbody><tr>
<td><strong>占用磁盘空间</strong></td>
<td>非常大，GB级</td>
<td>小，MB甚至KB级</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>慢。分钟级</td>
<td>快，秒级</td>
</tr>
<tr>
<td><strong>运行状态</strong></td>
<td>运行于Hypervisor上</td>
<td>直接运行在宿主机内核上</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>一台宿主机上十几个，最多几十个</td>
<td>上百个，甚至数百上千个</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>逊于宿主机</td>
<td>接近宿主机本地进程</td>
</tr>
<tr>
<td><strong>资源利用率</strong></td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>简单一句话总结：<strong>Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用</strong>。</p>
<h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>1）卸载旧版本</p>
<pre><code class="java">yum list installed | grep docker 列出当前所有docker的包
yum -y remove docker的包名称 卸载docker包
rm -rf /var/lib/docker 删除docker的所有镜像和容器
</code></pre>
<p>2）安装必要的软件包</p>
<pre><code class="yaml">sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2
</code></pre>
<p> 3）设置下载的镜像仓库</p>
<pre><code class="yaml">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p> 4）列出需要安装的版本列表</p>
<pre><code class="yaml">yum list docker-ce --showduplicates | sort -r
</code></pre>
<blockquote>
<p>docker-ce.x86_64  3:18.09.1-3.el7<br>docker-ce.x86_64  3:18.09.0-3.el7<br>docker-ce.x86_64  18.06.1.ce-3.el7<br>docker-ce.x86_64  18.06.0.ce-3.el7<br>…… </p>
</blockquote>
<p> 5 ）安装指定版本（这里使用18.0.1版本）</p>
<pre><code class="yaml">sudo yum install docker-ce-18.06.1.ce
</code></pre>
<p> 6）查看版本</p>
<pre><code class="yaml">docker -v
</code></pre>
<p> 7）启动Docker</p>
<pre><code class="yaml">sudo systemctl start docker   启动
sudo systemctl enable docker  设置开机启动
</code></pre>
<p>8）添加阿里云镜像下载地址</p>
<pre><code class="yaml">sudvi /etc/docker/daemon.json
</code></pre>
<blockquote>
<p>{<br>  “registry-mirrors”: [“<a href="https://zydiol88.mirror.aliyuncs.com&quot;]">https://zydiol88.mirror.aliyuncs.com&quot;]</a><br>}</p>
</blockquote>
<p>9 ）重启Docker</p>
<pre><code class="yaml">sudo systemctl restart docker
</code></pre>
<blockquote>
<p>第四步看这里：你现在的问题还是和之前一样：</p>
<blockquote>
<p>❌ <strong>无法访问 Docker 官方源（<code>https://download.docker.com/...</code>），报错 curl#35 - TCP connection reset by peer。</strong></p>
</blockquote>
<hr>
<h3 id="✅-解决方法：使用国内镜像（如清华、阿里）"><a href="#✅-解决方法：使用国内镜像（如清华、阿里）" class="headerlink" title="✅ 解决方法：使用国内镜像（如清华、阿里）"></a>✅ 解决方法：使用国内镜像（如清华、阿里）</h3><p>你需要 <strong>手动切换 Docker yum 源为国内镜像</strong>，否则无法继续安装。下面是最直接可行的解决方法。</p>
<hr>
<h2 id="🚀-一键换成清华源（CentOS-7-示例）"><a href="#🚀-一键换成清华源（CentOS-7-示例）" class="headerlink" title="🚀 一键换成清华源（CentOS 7 示例）"></a>🚀 一键换成清华源（CentOS 7 示例）</h2><p>请复制以下命令到你的服务器执行：</p>
<pre><code>bash复制编辑sudo tee /etc/yum.repos.d/docker-ce.repo &lt;&lt;-&#39;EOF&#39;
[docker-ce-stable]
name=Docker CE Stable - Tsinghua Mirror
baseurl=https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/7/x86_64/stable
enabled=1
gpgcheck=1
gpgkey=https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/gpg
EOF
</code></pre>
<hr>
<h3 id="🔁-然后执行："><a href="#🔁-然后执行：" class="headerlink" title="🔁 然后执行："></a>🔁 然后执行：</h3><pre><code>sudo yum clean all
sudo yum makecache fast
</code></pre>
<hr>
<h3 id="✅-安装-Docker-指定版本（比如-18-06）"><a href="#✅-安装-Docker-指定版本（比如-18-06）" class="headerlink" title="✅ 安装 Docker 指定版本（比如 18.06）"></a>✅ 安装 Docker 指定版本（比如 18.06）</h3><pre><code>sudo yum install docker-ce-18.06.1.ce docker-ce-cli-18.06.1.ce containerd.io
</code></pre>
<p>或者查看所有可用版本：</p>
<pre><code>yum list docker-ce --showduplicates
</code></pre>
<hr>
<h3 id="🟢-启动并设置开机启动："><a href="#🟢-启动并设置开机启动：" class="headerlink" title="🟢 启动并设置开机启动："></a>🟢 启动并设置开机启动：</h3><pre><code>sudo systemctl start docker
sudo systemctl enable docker
</code></pre>
</blockquote>
<hr>
<hr>
<h3 id="Docker基本命令快速入门"><a href="#Docker基本命令快速入门" class="headerlink" title="Docker基本命令快速入门"></a>Docker基本命令快速入门</h3><h6 id="1）镜像命令"><a href="#1）镜像命令" class="headerlink" title="1）镜像命令"></a>1）镜像命令</h6><p>[docker配置镜像Docker pull时报错：<a target="_blank" rel="noopener" href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a> - 知乎] (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24228872523">https://zhuanlan.zhihu.com/p/24228872523</a>)</p>
<blockquote>
<p>这个错误表明Docker客户端尝试访问<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=253867805&content_type=Article&match_order=1&q=Docker+Hub&zhida_source=entity">Docker Hub</a>或其他<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=253867805&content_type=Article&match_order=1&q=Docker%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83&zhida_source=entity">Docker注册中心</a>时出现了问题。具体来说，是在尝试获取注册中心API的响应时遇到了错误。可能的原因包括网络问题、认证问题、注册中心URL不正确或者注册中心服务本身不可用。</p>
<p>2、解决方法</p>
<pre><code class="text">systemctl status docker
sudo mkdir -p /etc/docker
vim /etc/docker/daemon.json  
</code></pre>
<p>添加：</p>
<pre><code class="text">&#123;
  &quot;registry-mirrors&quot; : [&quot;https://docker.registry.cyou&quot;,
&quot;https://docker-cf.registry.cyou&quot;,
&quot;https://dockercf.jsdelivr.fyi&quot;,
&quot;https://docker.jsdelivr.fyi&quot;,
&quot;https://dockertest.jsdelivr.fyi&quot;,
&quot;https://mirror.aliyuncs.com&quot;,
&quot;https://dockerproxy.com&quot;,
&quot;https://mirror.baidubce.com&quot;,
&quot;https://docker.m.daocloud.io&quot;,
&quot;https://docker.nju.edu.cn&quot;,
&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,
&quot;https://docker.mirrors.ustc.edu.cn&quot;,
&quot;https://mirror.iscas.ac.cn&quot;,
&quot;https://docker.rainbond.cc&quot;,
&quot;https://do.nark.eu.org&quot;,
&quot;https://dc.j8.work&quot;,
&quot;https://dockerproxy.com&quot;,
&quot;https://gst6rzl9.mirror.aliyuncs.com&quot;,
&quot;https://registry.docker-cn.com&quot;,
&quot;http://hub-mirror.c.163.com&quot;,
&quot;http://mirrors.ustc.edu.cn/&quot;,
&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;,
&quot;http://mirrors.sohu.com/&quot; 
],
 &quot;insecure-registries&quot; : [
    &quot;registry.docker-cn.com&quot;,
    &quot;docker.mirrors.ustc.edu.cn&quot;
    ],
&quot;debug&quot;: true,
&quot;experimental&quot;: false
&#125;
</code></pre>
<p>重载和重启dockers服务</p>
<pre><code class="text">sudo systemctl daemon-reload
sudo systemctl restart docker
docker info
</code></pre>
<p>重新执行</p>
<pre><code class="text">docker run hello-world
</code></pre>
</blockquote>
<p>镜像：相当于应用的安装包，在Docker部署的任何应用都需要先构建成为镜像</p>
<pre><code class="yaml">docker search 镜像名称 搜索镜像
docker pull 镜像名称 拉取镜像
docker images 查看本地所有镜像
docker rmi -f 镜像名称 删除镜像
</code></pre>
<p><code>docker pull openjdk:8-jdk-alpine</code></p>
<pre><code class="yaml">[root@localhost ~]# docker pull openjdk:8-jdk-alpine
8-jdk-alpine: Pulling from library/openjdk
e7c96db7181b: Pull complete
f910a506b6cb: Pull complete
c2274a1a0e27: Pull complete
Digest: sha256:94792824df2df33402f201713f932b58cb9de94a0cd524164a0f2283343547b3
Status: Downloaded newer image for openjdk:8-jdk-alpine
[root@localhost ~]#
</code></pre>
<h4 id="2）容器命令"><a href="#2）容器命令" class="headerlink" title="2）容器命令"></a>2）容器命令</h4><p>容器：容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中。</p>
<pre><code class="yaml">docker run -i 镜像名称:标签 运行容器（默认是前台运行）
docker ps         查看运行的容器
docker ps -a      查询所有容器
</code></pre>
<h6 id="常用的参数："><a href="#常用的参数：" class="headerlink" title="常用的参数："></a>常用的参数：</h6><pre><code class="yaml">-i：运行容器
-d：后台守方式运行（守护式）
--name：给容器添加名称
-p：公开容器端口给当前宿主机
-v：挂载目录

docker exec -it 容器ID/容器名称 /bin/bash 进入容器内部
docker start/stop/restart 容器名称/ID 启动/停止/重启容器
docker rm -f 容器名称/ID 删除容器
</code></pre>
<blockquote>
<p>docker run -i nginx      运行容器<br>docker run -di nginx    后台运行容器</p>
</blockquote>
<h5 id="运行的时候创建端口-把端口暴露给宿主机-这样宿主机就可以进行ip地址-端口的访问虚拟机的容器了"><a href="#运行的时候创建端口-把端口暴露给宿主机-这样宿主机就可以进行ip地址-端口的访问虚拟机的容器了" class="headerlink" title="运行的时候创建端口 把端口暴露给宿主机 这样宿主机就可以进行ip地址+端口的访问虚拟机的容器了"></a>运行的时候创建端口 把端口暴露给宿主机 这样宿主机就可以进行ip地址+端口的访问虚拟机的容器了</h5><p><code>-p</code>是<span style = "color:red"><strong>公开端口</strong></span>   外部用90端口访问80端口<br><code>docker run -di -p 90:80 nginx</code></p>
<blockquote>
<p>[root@localhost ~]# docker run -di -p 90:80 nginx<br>04726503f6ee2d053b54b6361d128827d5fb26b867c8fbd5439a370a4ac137d9<br>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES<br>04726503f6ee        nginx               “&#x2F;docker-entrypoint.…”   29 seconds ago      Up 27 seconds       0.0.0.0:90-&gt;80&#x2F;tcp   relaxed_goldberg</p>
</blockquote>
<p>此时用宿主机去访问：[Welcome to nginx!] (<a target="_blank" rel="noopener" href="http://192.168.200.129:90/">http://192.168.200.129:90/</a>)</p>
<blockquote>
<h1 id="Welcome-to-nginx"><a href="#Welcome-to-nginx" class="headerlink" title="Welcome to nginx!"></a>Welcome to nginx!</h1><p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p>
<p>For online documentation and support please refer to <a target="_blank" rel="noopener" href="http://nginx.org/">nginx.org</a>.<br>Commercial support is available at <a target="_blank" rel="noopener" href="http://nginx.com/">nginx.com</a>.</p>
<p><em>Thank you for using nginx.</em></p>
</blockquote>
<hr>
<h4 id="进入某个容器内部查看其内容："><a href="#进入某个容器内部查看其内容：" class="headerlink" title="进入某个容器内部查看其内容："></a>进入某个容器内部查看其内容：</h4><blockquote>
<p>[root@localhost ~]# <code>docker exec -it 04726503f6ee /bin/bash</code><br>root@04726503f6ee:&#x2F;# ls<br>bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>root@04726503f6ee:&#x2F;#</p>
</blockquote>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><blockquote>
<p>[root@localhost ~]# docker ps -a<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                NAMES<br>04726503f6ee        nginx               “&#x2F;docker-entrypoint.…”   4 minutes ago       Up 4 minutes                0.0.0.0:90-&gt;80&#x2F;tcp   relaxed_goldberg<br>9b9b1ec3e7a1        nginx               “&#x2F;docker-entrypoint.…”   10 minutes ago      Up 8 minutes                80&#x2F;tcp               gracious_knuth<br>4fb9d9e6858a        hello-world         “&#x2F;hello”                 29 minutes ago      Exited (0) 29 minutes ago                        elated_bhaskara<br>[root@localhost ~]# docker rm -f 4fb9d9e6858a<br>4fb9d9e6858a</p>
</blockquote>
<h3 id="虚拟机变化ip-导致无法ping通-解决办法"><a href="#虚拟机变化ip-导致无法ping通-解决办法" class="headerlink" title="虚拟机变化ip 导致无法ping通 解决办法"></a>虚拟机变化ip 导致无法ping通 解决办法</h3><p><code>cd /etc/sysconfig/network-scripts/</code></p>
<p><code>vi ifcfg-ens33</code></p>
<blockquote>
<h2 id="❗核心问题总结："><a href="#❗核心问题总结：" class="headerlink" title="❗核心问题总结："></a>❗核心问题总结：</h2><h3 id="你的宿主机（Windows）的真实联网网卡是："><a href="#你的宿主机（Windows）的真实联网网卡是：" class="headerlink" title="你的宿主机（Windows）的真实联网网卡是："></a>你的宿主机（Windows）的真实联网网卡是：</h3><ul>
<li><strong>无线网卡 WLAN</strong><ul>
<li>IP：<code>192.168.31.103</code></li>
<li>网关：<code>192.168.31.1</code></li>
</ul>
</li>
</ul>
<h3 id="而你的-VMware-虚拟机设置的是："><a href="#而你的-VMware-虚拟机设置的是：" class="headerlink" title="而你的 VMware 虚拟机设置的是："></a>而你的 VMware 虚拟机设置的是：</h3><ul>
<li><strong>静态 IP：192.168.200.132</strong></li>
<li>网关：<code>192.168.200.1</code></li>
<li>网络模式：你设为<strong>桥接模式</strong></li>
</ul>
<hr>
<h2 id="❗问题本质："><a href="#❗问题本质：" class="headerlink" title="❗问题本质："></a>❗问题本质：</h2><blockquote>
<p>你的虚拟机静态 IP 设置在 <strong>192.168.200.x 网段</strong>，但 <strong>宿主机是在 192.168.31.x 网段</strong>，说明你的<strong>桥接实际上根本没有生效</strong>，或者<strong>桥接到了错误的物理网卡</strong>。</p>
</blockquote>
<hr>
<h2 id="✅-最快修复方案（推荐，100-可行）："><a href="#✅-最快修复方案（推荐，100-可行）：" class="headerlink" title="✅ 最快修复方案（推荐，100% 可行）："></a>✅ 最快修复方案（推荐，100% 可行）：</h2><h3 id="🛠️-步骤一：修改-VMware-桥接设置"><a href="#🛠️-步骤一：修改-VMware-桥接设置" class="headerlink" title="🛠️ 步骤一：修改 VMware 桥接设置"></a>🛠️ 步骤一：修改 VMware 桥接设置</h3><ol>
<li>关闭虚拟机</li>
<li>打开 VMware 主界面 → 选择你的虚拟机 → 设置（Settings）→ 网络适配器</li>
<li>选择：<ul>
<li>✔️ 网络连接 → <strong>桥接模式（Bridged）</strong></li>
<li>点开旁边的 “<strong>桥接设置（Bridge Settings）</strong>”</li>
</ul>
</li>
<li>手动选择你的 <strong>Wi-Fi 无线网卡（例如 Intel Wireless-AC 或 Realtek Wireless）</strong><ul>
<li>不要选“自动”</li>
</ul>
</li>
<li><strong>取消勾选</strong>“复制物理网络连接状态”这一项</li>
<li>保存设置</li>
</ol>
<hr>
<h3 id="🛠️-步骤二：修改虚拟机内-IP-设置"><a href="#🛠️-步骤二：修改虚拟机内-IP-设置" class="headerlink" title="🛠️ 步骤二：修改虚拟机内 IP 设置"></a>🛠️ 步骤二：修改虚拟机内 IP 设置</h3><p>由于你真实网络是 <code>192.168.31.x</code>，所以虚拟机也应该设置为这个网段，例如：</p>
<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>：</p>
<pre><code>BOOTPROTO=static
NAME=ens33
DEVICE=ens33
ONBOOT=yes

IPADDR=192.168.31.150       # ← 随便取一个没被占用的
NETMASK=255.255.255.0
GATEWAY=192.168.31.1       # 这个是在宿主机网络下的环境网关 ipconfig
DNS1=8.8.8.8
</code></pre>
<p>然后执行：</p>
<pre><code>sudo systemctl restart network
</code></pre>
<p>或者：</p>
<pre><code>sudo ifdown ens33 &amp;&amp; sudo ifup ens33
</code></pre>
<hr>
<h3 id="✅-步骤三：在-Windows-上-ping-新的虚拟机-IP"><a href="#✅-步骤三：在-Windows-上-ping-新的虚拟机-IP" class="headerlink" title="✅ 步骤三：在 Windows 上 ping 新的虚拟机 IP"></a>✅ 步骤三：在 Windows 上 ping 新的虚拟机 IP</h3><pre><code>ping 192.168.31.150
</code></pre>
<hr>
<h2 id="🧠-如果你担心-IP-冲突怎么办？"><a href="#🧠-如果你担心-IP-冲突怎么办？" class="headerlink" title="🧠 如果你担心 IP 冲突怎么办？"></a>🧠 如果你担心 IP 冲突怎么办？</h2><p>在 Windows 上运行：</p>
<pre><code>ping 192.168.31.150
</code></pre>
<p>如果 ping 不通，就说明这个 IP 是空闲的，可以用。</p>
<hr>
<h2 id="✅-替代方案（保留-NAT-模式）"><a href="#✅-替代方案（保留-NAT-模式）" class="headerlink" title="✅ 替代方案（保留 NAT 模式）"></a>✅ 替代方案（保留 NAT 模式）</h2><p>如果你不想改桥接模式，可以继续用 <strong>VMware NAT 模式</strong>，那就让虚拟机保留原来的：</p>
<ul>
<li>IP：192.168.200.132</li>
<li>网关：192.168.200.1</li>
<li>然后通过端口转发（NAT 端口映射）来从主机访问虚拟机（需要手动配置）</li>
</ul>
<p>但 <strong>桥接 + 静态 IP 更简单、稳定、兼容性好</strong>。</p>
<hr>
<h2 id="✅-最终目标"><a href="#✅-最终目标" class="headerlink" title="✅ 最终目标"></a>✅ 最终目标</h2><p>你的宿主机和虚拟机 <strong>在同一个网段（如都在 <code>192.168.31.x</code>）</strong>，并且虚拟机网卡状态为 <code>UP</code>，那 ping 肯定通！</p>
<hr>
<h3 id="🔚-结论"><a href="#🔚-结论" class="headerlink" title="🔚 结论"></a>🔚 结论</h3><table>
<thead>
<tr>
<th>问题</th>
<th>解决方法</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟机 IP 设置错网段了</td>
<td>改为 <code>192.168.31.x</code>（和主机一样的网段）</td>
</tr>
<tr>
<td>桥接失败</td>
<td>手动指定桥接物理网卡为你的 <strong>无线网卡</strong>，不能选自动</td>
</tr>
<tr>
<td>不能 ping 通</td>
<td>网卡 DOWN → 启动；IP 不通 → 改网段；防火墙 → 暂停</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<blockquote>
<p>如果<code>ip a show ens33</code>没有ip地址怎么办 这样会导致moba连不上<br>应该是网卡状态为<code>down</code>说明网卡没启用<br>直接用ip命令把网卡打开<code>sudo ip link set ens33 up</code><br>然后找一下有没有 ip a show ens33<br>重启网络服务：<code>sudo systemctl restart network</code> 再次查看<br><span style = "color:red"><strong>如果还是没有 就手动设置IP</strong></span><br><code>sudo ip addr add 192.168.200.131/24 dev ens33 </code><br>再次重启网络服务：<code>sudo systemctl restart network</code><br>然后再次查看 <code>ip a show ens33</code></p>
</blockquote>
<h4 id="我想了解一下-虚拟机的-net直连-桥接-仅主机模式-自定义虚拟网络-这些有什么区别啊"><a href="#我想了解一下-虚拟机的-net直连-桥接-仅主机模式-自定义虚拟网络-这些有什么区别啊" class="headerlink" title="我想了解一下 虚拟机的 net直连 桥接 仅主机模式 自定义虚拟网络  这些有什么区别啊"></a>我想了解一下 虚拟机的 net直连 桥接 仅主机模式 自定义虚拟网络  这些有什么区别啊</h4><table>
<thead>
<tr>
<th>模式名称</th>
<th>虚拟机是否能访问外网</th>
<th>能否与主机通信</th>
<th>能否被局域网其它设备访问</th>
<th>场景用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NAT（网络地址转换）</strong></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>❌ 不能</td>
<td>默认模式，适合访问互联网但不被访问</td>
</tr>
<tr>
<td><strong>桥接模式（Bridged）</strong></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>适合开发、调试服务端程序</td>
</tr>
<tr>
<td><strong>仅主机模式（Host-Only）</strong></td>
<td>❌ 不可以</td>
<td>✅ 可以</td>
<td>❌ 不能</td>
<td>适合测试虚拟机与主机通信，隔离网络</td>
</tr>
<tr>
<td><strong>自定义虚拟网络</strong>（VMnetX）</td>
<td>看配置情况</td>
<td>看配置情况</td>
<td>看配置情况</td>
<td>高级用途，如多机组网、模拟拓扑</td>
</tr>
</tbody></table>
<h2 id="✅-判断网络模式"><a href="#✅-判断网络模式" class="headerlink" title="✅ 判断网络模式"></a>✅ 判断网络模式</h2><p>你需要检查虚拟机使用的<strong>网络连接方式</strong>，有几种常见模式：</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>是否能上网</th>
<th>是否能被主机访问</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAT</td>
<td>✅</td>
<td>❌</td>
<td>默认可以上网，不能被主机访问</td>
</tr>
<tr>
<td>桥接模式</td>
<td>✅</td>
<td>✅</td>
<td>与主机同网段，能上网、能互通</td>
</tr>
<tr>
<td>Host-only</td>
<td>❌</td>
<td>✅</td>
<td>不能上网，只能主机访问</td>
</tr>
<tr>
<td>内部网络（仅限虚拟机）</td>
<td>❌</td>
<td>❌</td>
<td>用于多虚拟机内部通信</td>
</tr>
</tbody></table>
<blockquote>
<h2 id="1️⃣-NAT-模式（默认）"><a href="#1️⃣-NAT-模式（默认）" class="headerlink" title="1️⃣ NAT 模式（默认）"></a>1️⃣ <strong>NAT 模式</strong>（默认）</h2><blockquote>
<p>虚拟机通过 VMware NAT 服务共享主机网络访问外网</p>
</blockquote>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 是 <code>192.168.200.x</code> 之类的 VMware 虚拟网段</li>
<li>宿主机充当“路由器”角色</li>
<li>适合需要上网，但不想暴露虚拟机到外部网络</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>无需特殊配置即可访问外网</li>
<li>安全，外部无法直接访问虚拟机</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>外部机器（包括宿主机）<strong>无法直接 ping 通虚拟机</strong></li>
<li>虚拟机 IP 不稳定</li>
</ul>
<h2 id="2️⃣-桥接模式（Bridged）"><a href="#2️⃣-桥接模式（Bridged）" class="headerlink" title="2️⃣ 桥接模式（Bridged）"></a>2️⃣ <strong>桥接模式（Bridged）</strong></h2><blockquote>
<p>虚拟机像真实电脑一样连接到局域网（通过宿主机的物理网卡桥接出去）</p>
</blockquote>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 和宿主机一样，都由路由器分配（比如 <code>192.168.31.x</code>）</li>
<li>可以直接与宿主机、局域网其他设备通信</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>和真实电脑一样，可以被 ping 通、远程访问、部署服务等</li>
<li>最贴近真实网络环境，适合服务器开发</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>依赖物理网络（尤其 Wi-Fi 桥接时可能失败）</li>
<li>公司&#x2F;学校网络可能屏蔽桥接</li>
</ul>
<h2 id="3️⃣-仅主机模式（Host-Only）"><a href="#3️⃣-仅主机模式（Host-Only）" class="headerlink" title="3️⃣ 仅主机模式（Host-Only）"></a>3️⃣ <strong>仅主机模式（Host-Only）</strong></h2><blockquote>
<p>虚拟机只能和宿主机通信，完全与外网隔离</p>
</blockquote>
<h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>虚拟机 IP 通常是 <code>192.168.56.x</code> 或 <code>192.168.152.x</code></li>
<li>不能访问互联网</li>
</ul>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>安全，完全离线隔离</li>
<li>虚拟机和主机之间能稳定通信（做测试非常好）</li>
</ul>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>无法访问外网</li>
<li>无法被外部设备访问</li>
</ul>
<h2 id="4️⃣-自定义虚拟网络（VMnet0-19）"><a href="#4️⃣-自定义虚拟网络（VMnet0-19）" class="headerlink" title="4️⃣ 自定义虚拟网络（VMnet0~19）"></a>4️⃣ <strong>自定义虚拟网络（VMnet0~19）</strong></h2><blockquote>
<p>高级用户使用，可自由配置网络结构</p>
</blockquote>
<h3 id="典型用途："><a href="#典型用途：" class="headerlink" title="典型用途："></a>典型用途：</h3><ul>
<li>多台虚拟机组成专属局域网</li>
<li>配置 DHCP、NAT、Host-Only 混合网络</li>
<li>构建模拟数据中心、私有云、堡垒机环境等</li>
</ul>
<h2 id="🎯-总结建议（适合不同场景）："><a href="#🎯-总结建议（适合不同场景）：" class="headerlink" title="🎯 总结建议（适合不同场景）："></a>🎯 总结建议（适合不同场景）：</h2><table>
<thead>
<tr>
<th>场景</th>
<th>建议使用模式</th>
</tr>
</thead>
<tbody><tr>
<td>日常使用、能上网即可</td>
<td>NAT 模式（默认）</td>
</tr>
<tr>
<td>开发服务端、需要固定 IP + 被访问</td>
<td>桥接模式 ✅</td>
</tr>
<tr>
<td>只在主机和虚拟机之间通信</td>
<td>Host-Only 模式</td>
</tr>
<tr>
<td>多虚拟机模拟复杂网络</td>
<td>自定义（VMnet）</td>
</tr>
</tbody></table>
<h2 id="📌-一句话总结："><a href="#📌-一句话总结：" class="headerlink" title="📌 一句话总结："></a>📌 一句话总结：</h2><p><strong>NAT 是“内网访问外网”，桥接是“虚拟机等于真电脑”，Host-Only 是“我只和主机说话”，自定义是“你说了算”。</strong></p>
</blockquote>
<h2 id="环境准备-2-—Dockerfile镜像脚本快速入门"><a href="#环境准备-2-—Dockerfile镜像脚本快速入门" class="headerlink" title="环境准备(2)—Dockerfile镜像脚本快速入门"></a>环境准备(2)—Dockerfile镜像脚本快速入门</h2><p>Dockerfile其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组 合，只要理解它的逻辑和语法格式，就可以编写Dockerfile了。 简单点说，Dockerfile的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各 样，网络上的镜像很难满足实际的需求。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>FROM image_name:tag</td>
<td></td>
</tr>
<tr>
<td>MAINTAINER user_name</td>
<td>声明镜像的作者</td>
</tr>
<tr>
<td>ENV key value</td>
<td>设置环境变量(可以写多条)</td>
</tr>
<tr>
<td>RUN command</td>
<td>编译镜像时运行的脚本(可以写多条)</td>
</tr>
<tr>
<td>CMD</td>
<td>设置容器的启动命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器的入口程序</td>
</tr>
<tr>
<td>ADD source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>将宿主机的文件复制到容器内，如果是一个压缩文件。将会在复制后自动解压</td>
</tr>
<tr>
<td>COPY source_dir&#x2F;file dest_dir&#x2F;file</td>
<td>和ADD相似，但是如果又压缩文件并不能解压</td>
</tr>
<tr>
<td>WORKDIR path_dir</td>
<td>设置工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>设置编译镜像时加入的参数</td>
</tr>
<tr>
<td>VOLUMN</td>
<td>设置容器的挂载卷</td>
</tr>
</tbody></table>
<p>新镜像是从基础镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一 层</p>
<h5 id="使用Dockerfile制作微服务镜像"><a href="#使用Dockerfile制作微服务镜像" class="headerlink" title="使用Dockerfile制作微服务镜像"></a>使用Dockerfile制作微服务镜像</h5><p>我们利用Dockerfile制作一个Eureka注册中心的镜像 </p>
<p>1）上传Eureka的微服务jar包到linux<del>这里的jar包要和Dockerfile文件在同一目录下</del><br>2）编写Dockerfile <code>vi Dockerfile</code></p>
<h6 id="作用-📦-构建一个用于运行-Java-应用（Spring-Boot-或其他-jar-应用）的-Docker-镜像。"><a href="#作用-📦-构建一个用于运行-Java-应用（Spring-Boot-或其他-jar-应用）的-Docker-镜像。" class="headerlink" title="作用:📦 构建一个用于运行 Java 应用（Spring Boot 或其他 jar 应用）的 Docker 镜像。"></a>作用:📦 <strong>构建一个用于运行 Java 应用（Spring Boot 或其他 jar 应用）的 Docker 镜像</strong>。</h6><p>这个 Dockerfile 是在用 Java 8 的轻量镜像里，运行你打包好的 jar 应用，并对外开放 10086 端口，非常适合部署 Spring Boot 项目。</p>
<pre><code class="yaml">FROM openjdk:8-jdk-alpine
ARG JAR_FILE
COPY $&#123;JAR_FILE&#125; app.jar
EXPOSE 10086
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<p>3 ）构建镜像 </p>
<p><code>docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1 .</code><br><u>-t是定义名字</u>  <u>.是在当前目录</u><br>4）查看镜像是否创建成功 </p>
<p><code>docker images </code></p>
<blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>eureka              v1                  36af14603456        15 seconds ago      150MB<br>nginx               latest              9592f5595f2b        7 days ago          192MB<br>hello-world         latest              74cc54e27dc4        5 months ago        10.1kB<br>openjdk             8-jdk-alpine        a3562aa0b991        6 years ago         105MB</p>
</blockquote>
<p>5）创建容器 </p>
<p><code>docker run -i --name=eureka -p 10086:10086 eureka:v1 </code><br><u>后台运行</u>：<code>docker run -d --name=eureka -p 10086:10086 eureka:v1</code></p>
<p>删除容器：<code>docker rm -f eureka</code><br>查看容器是否启动<code>docker ps</code><br>查看日志<code>docker logs -f eureka</code><br>后面可以直接启动这个容器 <code>docker start eureka</code></p>
<p>6）访问容器 <a target="_blank" rel="noopener" href="http://192.168.200.129:10086/">http://192.168.200.129:10086</a></p>
<blockquote>
<h3 id="修改后重新构建镜像："><a href="#修改后重新构建镜像：" class="headerlink" title="修改后重新构建镜像："></a>修改后重新构建镜像：</h3><pre><code>docker stop eureka
docker rm eureka

# 重新构建镜像（确保 Dockerfile 和配置文件都在当前目录）
docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1 .

# 启动容器并映射端口
docker run -d --name=eureka -p 10086:10086 eureka:v1
</code></pre>
<hr>
<p><strong>进入容器</strong>（你已经会了）：</p>
<pre><code>docker exec -it eureka /bin/sh
</code></pre>
<ol>
<li>**容器内查找 <code>application.yaml</code>**：</li>
</ol>
<pre><code>find / -name application.yaml 2&gt;/dev/null
</code></pre>
<ul>
<li><code>2&gt;/dev/null</code> 是把权限不够或找不到文件时的报错信息过滤掉，方便看结果。</li>
</ul>
<ol>
<li><strong>找到路径后，用 <code>cat</code> 查看内容</strong>：</li>
</ol>
<p>假设查到文件在 <code>/config/application.yaml</code>，那么：</p>
<pre><code>cat /config/application.yaml
</code></pre>
<hr>
<p>你要删除 <code>&lt;none&gt;</code> 的镜像，也就是“悬空镜像（dangling image）”，可以使用以下命令：</p>
<h3 id="🔍-查看所有悬空镜像"><a href="#🔍-查看所有悬空镜像" class="headerlink" title="🔍 查看所有悬空镜像"></a>🔍 查看所有悬空镜像</h3><pre><code>docker images -f &quot;dangling=true&quot;
</code></pre>
<h3 id="🗑-删除所有悬空镜像"><a href="#🗑-删除所有悬空镜像" class="headerlink" title="🗑 删除所有悬空镜像"></a>🗑 删除所有悬空镜像</h3><pre><code>docker rmi $(docker images -f &quot;dangling=true&quot; -q)
</code></pre>
<hr>
<p>root@localhost ~]# docker run -d –name&#x3D;eureka -p 10086:10086 eureka:v1 docker: Error response from daemon: Conflict. The container name “&#x2F;eureka” is already in use by container “9ea494448aeb1d99faecfe11e652f438938b87e1caaca890f9001199e1166dbc”. You have to remove (or rename) that container to be able to reuse that name. See ‘docker run –help’. 这个错误说明：<strong>虽然你已经 <code>docker stop eureka</code> 停止了容器，但它还没有被删除</strong>，所以容器名 <code>/eureka</code> 依然占用中，不能再用这个名字启动新的容器。</p>
<h3 id="✅-解决方案：删除旧容器"><a href="#✅-解决方案：删除旧容器" class="headerlink" title="✅ 解决方案：删除旧容器"></a>✅ 解决方案：删除旧容器</h3><p>你需要先 <strong>删除已停止的 <code>eureka</code> 容器</strong>，再重新启动：</p>
<pre><code>docker rm eureka
</code></pre>
<p>然后再重新运行新的容器：</p>
<pre><code>docker run -d --name=eureka -p 10086:10086 eureka:v1
</code></pre>
<hr>
<p>是桥接 能ping通 防火墙永久关闭了 本机打开了clash系统代理+全局</p>
<h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常关键的点来了！</p>
<p>你说：</p>
<p>✅ 虚拟机是桥接模式<br> ✅ 能 ping 通虚拟机 <code>192.168.200.129</code><br> ✅ 防火墙是永久关闭状态<br> ❌ <strong>本机打开了 Clash 并启用了系统代理 + 全局模式</strong></p>
<hr>
<h3 id="✅-你的-Eureka-服务配置和容器启动都是正确的，问题现在就出在：你本机开启了-Clash-的全局代理。"><a href="#✅-你的-Eureka-服务配置和容器启动都是正确的，问题现在就出在：你本机开启了-Clash-的全局代理。" class="headerlink" title="✅ 你的 Eureka 服务配置和容器启动都是正确的，问题现在就出在：你本机开启了 Clash 的全局代理。"></a>✅ 你的 Eureka 服务配置和容器启动都是正确的，问题现在就出在：<strong>你本机开启了 Clash 的全局代理。</strong></h3><h3 id="❗这会导致浏览器请求走代理，无法访问内网地址（例如-192-168-200-129-10086）。"><a href="#❗这会导致浏览器请求走代理，无法访问内网地址（例如-192-168-200-129-10086）。" class="headerlink" title="❗这会导致浏览器请求走代理，无法访问内网地址（例如 192.168.200.129:10086）。"></a>❗这会导致浏览器请求走代理，<strong>无法访问内网地址</strong>（例如 <code>192.168.200.129:10086</code>）。</h3><hr>
<h5 id="删除镜像：docker-rmi-eureka-v1"><a href="#删除镜像：docker-rmi-eureka-v1" class="headerlink" title="删除镜像：docker rmi eureka:v1"></a>删除镜像：<code>docker rmi eureka:v1</code></h5><p>删除所有悬挂镜像：&lt; none &gt;的 <code>docker images | grep &quot;&lt;none&gt;&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs -r docker rmi -f</code></p>
<hr>
<hr>
<p><code>ss -tlnp | grep 10086</code>✅ 你看到的是：</p>
<pre><code>LISTEN     0      1024        :::10086                   :::*                   users:((&quot;docker-proxy&quot;,pid=31831,fd=4))
</code></pre>
<h3 id="📌-说明："><a href="#📌-说明：" class="headerlink" title="📌 说明："></a>📌 说明：</h3><p>这是 <strong>宿主机上的 docker-proxy</strong> 在监听 <code>10086</code> 端口，<strong>它只是端口映射的外壳进程</strong>。</p>
<p>但我们<strong>没有看到你容器内部的 Spring Boot 应用是否在监听端口</strong>，也就是说：</p>
<blockquote>
<p>✅ <strong>docker-proxy 映射是 OK 的</strong><br> ❗️<strong>容器里的 Spring Boot 可能绑定了 <code>127.0.0.1:10086</code>，不是 <code>0.0.0.0:10086</code>，导致 proxy 转发过去失败</strong></p>
</blockquote>
<hr>
<h2 id="✅-解决方案-——-修改配置，显式绑定-0-0-0-0"><a href="#✅-解决方案-——-修改配置，显式绑定-0-0-0-0" class="headerlink" title="✅ 解决方案 —— 修改配置，显式绑定 0.0.0.0"></a>✅ 解决方案 —— 修改配置，显式绑定 <code>0.0.0.0</code></h2><p>请 **修改你的 <code>application.yml</code>**，在 <code>server</code> 配置中添加这一行：</p>
<pre><code>yaml复制编辑server:
  port: 10086
  address: 0.0.0.0  # &lt;-- 显式监听所有网卡地址
</code></pre>
<hr>
<hr>
<p>[root@localhost ~]# netstat -tln<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 127.0.0.1:9100          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9229          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9168          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:8082          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:82              0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9236          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:3000          0.0.0.0:*               LISTEN<br>tcp        0      0 0.0.0.0:8060            0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9121          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9187          0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:9093          0.0.0.0:*               LISTEN<br>tcp6       0      0 :::3306                 :::*                    LISTEN<br>tcp6       0      0 ::1:9168                :::*                    LISTEN<br>tcp6       0      0 :::22                   :::*                    LISTEN<br>tcp6       0      0 :::10086                :::*                    LISTEN<br>tcp6       0      0 :::9094                 :::*                    LISTEN</p>
<p>你贴的 <code>netstat -tln</code> 结果说明：</p>
<ul>
<li>你的服务监听在 <strong><code>:::10086</code>（IPv6的所有地址）</strong>，没有监听任何IPv4地址（比如<code>0.0.0.0:10086</code>）</li>
<li>这意味着你的Spring Boot应用只监听了IPv6地址，IPv4访问就无法连接（所以你用 <code>http://192.168.200.129:10086</code> 访问会失败）</li>
</ul>
<h3 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h3><ol>
<li>修改你的 <code>Dockerfile</code> 中 <code>ENTRYPOINT</code>：</li>
</ol>
<pre><code class="java">FROM openjdk:8-jdk-alpine
ARG JAR_FILE
COPY $&#123;JAR_FILE&#125; app.jar
EXPOSE 10086
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.net.preferIPv4Stack=true&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>
<h2 id="2-构建新镜像（建议打新标签）"><a href="#2-构建新镜像（建议打新标签）" class="headerlink" title="2. 构建新镜像（建议打新标签）"></a>2. 构建新镜像（建议打新标签）</h2><pre><code>docker build --build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v2 .
</code></pre>
<hr>
<h2 id="3-停止并删除旧容器（如果还在运行）"><a href="#3-停止并删除旧容器（如果还在运行）" class="headerlink" title="3. 停止并删除旧容器（如果还在运行）"></a>3. 停止并删除旧容器（如果还在运行）</h2><pre><code>docker stop eureka
docker rm eureka
</code></pre>
<hr>
<h2 id="4-运行新镜像容器"><a href="#4-运行新镜像容器" class="headerlink" title="4. 运行新镜像容器"></a>4. 运行新镜像容器</h2><pre><code>docker run -d -p 10086:10086 --name eureka eureka:v2
</code></pre>
<h2 id="6-测试访问"><a href="#6-测试访问" class="headerlink" title="6. 测试访问"></a>6. 测试访问</h2><p>浏览器打开：</p>
<pre><code>http://192.168.200.129:10086
</code></pre>
<hr>
<hr>
<hr>
<p>现在可以访问成功了  为什么加上这句话就好了 ENTRYPOINT [“java”,”-Djava.net.preferIPv4Stack&#x3D;true”,”-jar”,”&#x2F;app.jar”] 为什么监听的时候还是ipv6 [root@localhost ~]# ss -tlnp | grep 10086 LISTEN     0      1024        :::10086                   :::*                   users:((“docker-proxy”,pid&#x3D;35209,fd&#x3D;4)) 但是成功在主机访问地址了</p>
<h6 id="为什么加上-Djava-net-preferIPv4Stack-true-就好了？"><a href="#为什么加上-Djava-net-preferIPv4Stack-true-就好了？" class="headerlink" title="为什么加上 -Djava.net.preferIPv4Stack=true 就好了？"></a>为什么加上 <code>-Djava.net.preferIPv4Stack=true</code> 就好了？</h6><ul>
<li>这个参数告诉 JVM <strong>优先使用 IPv4 网络栈</strong>，避免只监听 IPv6 导致外部 IPv4 地址访问不到的问题。</li>
<li>Spring Boot 的内嵌 Tomcat 在默认情况下，Linux 可能优先监听 IPv6 地址（<code>:::port</code>）。</li>
<li>加了这个参数后，Tomcat 会优先绑定 IPv4 地址，从而确保 Docker 的端口映射能正常被外部 IPv4 网络访问。</li>
</ul>
<hr>
<h3 id="为什么监听时还是显示-IPv6-10086-？"><a href="#为什么监听时还是显示-IPv6-10086-？" class="headerlink" title="为什么监听时还是显示 IPv6 (:::10086)？"></a>为什么监听时还是显示 IPv6 (<code>:::10086</code>)？</h3><ul>
<li>Linux 上 IPv6 的监听套接字 <code>:::</code> 默认是包含 IPv4 地址 <code>0.0.0.0</code> 的（叫做 IPv4-mapped IPv6 地址）。</li>
<li>也就是说，监听 <code>:::10086</code> 实际上同时监听了所有 IPv6 和 IPv4 地址。</li>
<li>这是一种操作系统层面的机制，不是 Java 层面的问题。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>-Djava.net.preferIPv4Stack=true</code></strong> 让 JVM 侧优先用 IPv4，避免了纯 IPv6 监听带来的访问问题。</li>
<li><strong><code>ss</code> 看到的 <code>:::10086</code> 其实也包括了 IPv4 地址</strong>，所以你才能用 IPv4 地址成功访问。</li>
<li>访问成功说明网络和端口映射都正常工作了。</li>
</ul>
<hr>
<hr>
<p>太好了，你现在已经非常接近成功了，我们来梳理一下现状和如何解决你“<strong>既能联网又能用 Mobaxterm 连上虚拟机</strong>”的问题。</p>
<hr>
<h2 id="✅-当前状态分析"><a href="#✅-当前状态分析" class="headerlink" title="✅ 当前状态分析"></a>✅ 当前状态分析</h2><p>你目前有两张网卡：</p>
<table>
<thead>
<tr>
<th>网卡名</th>
<th>IP 地址</th>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ens33</code></td>
<td><code>192.168.200.131</code></td>
<td>✅ UP，有 IP</td>
<td>是你原来的桥接或 Host-Only 网卡，用于主机连虚拟机</td>
</tr>
<tr>
<td><code>ens36</code></td>
<td>无 IP</td>
<td>❌ DOWN</td>
<td>是你新加的 NAT 网卡，但 <strong>没有启动 &#x2F; 没有获取 IP</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-为什么还无法联网？"><a href="#🧩-为什么还无法联网？" class="headerlink" title="🧩 为什么还无法联网？"></a>🧩 为什么还无法联网？</h2><p>你 curl 下载失败，是因为 NAT 网卡 <code>ens36</code> 没启动，虚拟机依然没联网。</p>
<hr>
<h2 id="✅-解决方案：启动-NAT-网卡并设置为默认出网口"><a href="#✅-解决方案：启动-NAT-网卡并设置为默认出网口" class="headerlink" title="✅ 解决方案：启动 NAT 网卡并设置为默认出网口"></a>✅ 解决方案：<strong>启动 NAT 网卡并设置为默认出网口</strong></h2><h3 id="第一步：激活-ens36（NAT-网卡）"><a href="#第一步：激活-ens36（NAT-网卡）" class="headerlink" title="第一步：激活 ens36（NAT 网卡）"></a>第一步：激活 ens36（NAT 网卡）</h3><p>执行：</p>
<pre><code>dhclient ens36
</code></pre>
<blockquote>
<p>⏳ 如果你没装 <code>dhclient</code>，可以试试：</p>
</blockquote>
<pre><code>nmcli device connect ens36
</code></pre>
<p>然后再次查看 IP：</p>
<pre><code>ip addr
</code></pre>
<p>你应该能看到 <code>ens36</code> 分配到类似 <code>192.168.226.x</code> 的地址（NAT 网段）</p>
</blockquote>
<h6 id="总结一下视频里的服务器ip所对应的服务"><a href="#总结一下视频里的服务器ip所对应的服务" class="headerlink" title="总结一下视频里的服务器ip所对应的服务"></a>总结一下视频里的服务器ip所对应的服务</h6><blockquote>
<p>192.168.66.100 GitLab<br>192.168.66.101 Jenkins<br>192.168.66.102 Harbor &amp;&amp; Tomcat<br>192.168.66.103 生产部署服务器</p>
</blockquote>
<h3 id="环境准备-3-Harbor镜像仓库安装及使用"><a href="#环境准备-3-Harbor镜像仓库安装及使用" class="headerlink" title="环境准备(3)-Harbor镜像仓库安装及使用"></a>环境准备(3)-Harbor镜像仓库安装及使用</h3><h5 id="Harbor简介"><a href="#Harbor简介" class="headerlink" title="Harbor简介"></a>Harbor简介</h5><p>Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。 除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：</p>
<ol>
<li>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以 用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定 传输的对象。 </li>
<li>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界 面可以支持登陆、搜索功能，包括区分公有、私有镜像。</li>
<li>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。 </li>
<li>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</li>
</ol>
<h5 id="Harbor安装"><a href="#Harbor安装" class="headerlink" title="Harbor安装"></a>Harbor安装</h5><p>Harbor需要安装在<code>192.168.200.131 Harbor &amp;&amp; Tomcat</code>上</p>
<ul>
<li><p>先安装Docker并启动Docker</p>
<blockquote>
<p>sudo systemctl start docker        启动Docker<br>sudo systemctl enable docker    开机自启动<br>sudo systemctl status docker     查看Docker服务状态</p>
</blockquote>
</li>
<li><p>安装docker-compose</p>
<pre><code class="java">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose 
sudo chmod +x /usr/local/bin/docker-compose
</code></pre>
</li>
</ul>
<blockquote>
<p>你可以使用 <strong>离线安装 docker-compose</strong> 的方式，<strong>在主机上下载好二进制文件</strong>，再拷贝到虚拟机中使用，非常简单。</p>
<hr>
<h2 id="✅-方法一：主机下载-→-拷贝到虚拟机"><a href="#✅-方法一：主机下载-→-拷贝到虚拟机" class="headerlink" title="✅ 方法一：主机下载 → 拷贝到虚拟机"></a>✅ 方法一：<strong>主机下载 → 拷贝到虚拟机</strong></h2><h3 id="步骤-1️⃣：在主机（Windows）上用浏览器下载这个文件"><a href="#步骤-1️⃣：在主机（Windows）上用浏览器下载这个文件" class="headerlink" title="步骤 1️⃣：在主机（Windows）上用浏览器下载这个文件"></a>步骤 1️⃣：在主机（Windows）上用浏览器下载这个文件</h3><p>访问地址如下（你这个版本是 1.21.2）：</p>
<p>👉 <a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases/download/1.21.2/docker-compose-Linux-x86_64">https://github.com/docker/compose/releases/download/1.21.2/docker-compose-Linux-x86_64</a></p>
<p>下载后，重命名为：<code>docker-compose</code></p>
<hr>
<h3 id="步骤-2️⃣：用-MobaXterm-拷贝到虚拟机"><a href="#步骤-2️⃣：用-MobaXterm-拷贝到虚拟机" class="headerlink" title="步骤 2️⃣：用 MobaXterm 拷贝到虚拟机"></a>步骤 2️⃣：用 MobaXterm 拷贝到虚拟机</h3><p>你在 Mobaxterm 中连接好虚拟机后：</p>
<ol>
<li>左侧文件管理器中找到 <code>/usr/local/bin</code>（或 <code>/root</code>）</li>
<li>把你刚下载的 <code>docker-compose</code> 拖进去上传</li>
</ol>
<p>或者用 <code>scp</code> 命令上传：</p>
<pre><code>scp docker-compose root@192.168.200.131:/usr/local/bin/docker-compose
</code></pre>
<blockquote>
<p>把 <code>192.168.200.131</code> 换成你虚拟机 IP，输入密码即可</p>
</blockquote>
<hr>
<h3 id="步骤-3️⃣：在虚拟机中赋予执行权限"><a href="#步骤-3️⃣：在虚拟机中赋予执行权限" class="headerlink" title="步骤 3️⃣：在虚拟机中赋予执行权限"></a>步骤 3️⃣：在虚拟机中赋予执行权限</h3><pre><code>chmod +x /usr/local/bin/docker-compose
</code></pre>
<hr>
<h3 id="步骤-4️⃣：验证安装成功"><a href="#步骤-4️⃣：验证安装成功" class="headerlink" title="步骤 4️⃣：验证安装成功"></a>步骤 4️⃣：验证安装成功</h3><pre><code>docker-compose -v
</code></pre>
<p>输出类似：</p>
<pre><code>docker-compose version 1.21.2, build ...
</code></pre>
<p>✅ 完成！</p>
</blockquote>
<ul>
<li><p>下载Harbor的压缩包<code>harbor-offline-installer-v1.9.2.tgz</code></p>
</li>
<li><p>上传压缩包到linux并解压</p>
<blockquote>
<p>tar -xzf harbor-offline-installer-v1.9.2.tgz<br>mkdir &#x2F;opt&#x2F;harbor<br>mv harbor&#x2F;* &#x2F;opt&#x2F;harbor<br>cd &#x2F;opt&#x2F;harbor</p>
</blockquote>
</li>
<li><p>修改Harbor的配置</p>
<blockquote>
<p>vi harbor.yml</p>
</blockquote>
<p>修改hostname和port</p>
<blockquote>
<p>hostname：192.168.200.131<br>port：85</p>
</blockquote>
</li>
<li><p>安装Harbor</p>
<blockquote>
<p>.&#x2F;prepare<br>.&#x2F;install.sh </p>
</blockquote>
<h5 id="启动Harbor-★★-tomcat-131服务器"><a href="#启动Harbor-★★-tomcat-131服务器" class="headerlink" title="启动Harbor ★★ [tomcat 131服务器]"></a>启动Harbor ★★ [tomcat 131服务器]</h5><pre><code class="JAVA">cd /opt/harbor
./install.sh
</code></pre>
</li>
</ul>
<h5 id="这里有个经典的超级牛逼的大bug"><a href="#这里有个经典的超级牛逼的大bug" class="headerlink" title="这里有个经典的超级牛逼的大bug"></a><span style = "color:red">这里有个经典的超级牛逼的大bug</span></h5><h6 id="抛出问题："><a href="#抛出问题：" class="headerlink" title="抛出问题："></a>抛出问题：</h6><blockquote>
<p>这是我vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<br>DEFROUTE&#x3D;yes<br>NAME&#x3D;ens33<br>UUID&#x3D;a8ca17a4-0388-4b06-81b3-895e1a8180fe<br>DEVICE&#x3D;ens33<br>ONBOOT&#x3D;yes</p>
<p>IPADDR&#x3D;192.168.200.131<br>NETMASK&#x3D;255.255.255.0<br>GATEWAY&#x3D;192.168.31.1<br>DNS1&#x3D;8.8.8.8</p>
<p>这是我虚拟机的ip add</p>
<p>[root@localhost ~]# ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1&#x2F;128 scope host<br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000<br>    link&#x2F;ether 00:0c:29:7b:04:23 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.200.131&#x2F;24 brd 192.168.200.255 scope global noprefixroute ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe7b:423&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default<br>    link&#x2F;ether 02:42:94:7c:ad:4a brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.1&#x2F;16 brd 172.17.255.255 scope global docker0<br>       valid_lft forever preferred_lft forever</p>
<p>该虚拟机选择了桥接模式 且 勾选了复制到物理网络连接状态<br>其虚拟网络编辑器里面<br>VMnet0 桥接模式 自动桥接   主机连接无 DHCP无  子网地址无<br>VMnet1 仅主机    外部连接无  主机连接已连接  DHCP已启用 子网地址192.168.22.0<br>VMnet8 NAT模式 NAT模式  主机连接已连接 DHCP无 子网地址192.168.200.0</p>
<p>这是我主机ipconfig<br>C:\Users\Pluminary&gt;ipconfig</p>
<p>Windows IP 配置</p>
<p>以太网适配器 以太网 4:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>无线局域网适配器 本地连接* 1:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>无线局域网适配器 本地连接* 2:</p>
<p>   媒体状态  . . . . . . . . . . . . : 媒体已断开连接<br>   连接特定的 DNS 后缀 . . . . . . . :</p>
<p>以太网适配器 VMware Network Adapter VMnet1:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::1ea6:88fa:c0e1:f1ca%22<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.22.1<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . :</p>
<p>以太网适配器 VMware Network Adapter VMnet8:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::9e33:f9ac:4f64:9d71%3<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.200.2<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . : 192.168.200.1</p>
<p>无线局域网适配器 WLAN:</p>
<p>   连接特定的 DNS 后缀 . . . . . . . :<br>   本地链接 IPv6 地址. . . . . . . . : fe80::7df7:efe4:1d3b:e2d2%12<br>   IPv4 地址 . . . . . . . . . . . . : 192.168.31.103<br>   子网掩码  . . . . . . . . . . . . : 255.255.255.0<br>   默认网关. . . . . . . . . . . . . : 192.168.31.1 </p>
<p>我现在的问题是 如果我改了GATEWAY&#x3D;192.168.31.1 为别的 那么我MobaXterm就连不上该虚拟机 现在的问题是 虚拟机没有网 我镜像都下载不了[root@localhost harbor]# .&#x2F;prepare<br>prepare base dir is set to &#x2F;opt&#x2F;harbor<br>Unable to find image ‘goharbor&#x2F;prepare:v1.9.2’ locally<br>^C<br>[root@localhost harbor]# ^C<br>[root@localhost harbor]#</p>
</blockquote>
<h6 id="GitHub解决方案："><a href="#GitHub解决方案：" class="headerlink" title="GitHub解决方案："></a>GitHub解决方案：</h6><blockquote>
<p>你目前的状态是：</p>
<hr>
<p>✅ <strong>虚拟机 IP</strong> 是 <code>192.168.200.131</code>（<strong>静态 IP，桥接模式下设置的</strong>）<br> ✅ <strong>宿主机 WLAN IP</strong> 是 <code>192.168.31.103</code><br> ❌ <strong>虚拟机无法联网</strong>（不能拉取镜像）<br> ✅ <strong>MobaXterm 可以连接虚拟机（192.168.200.131）</strong><br> ⚠️ <strong>虚拟机网关设置为 <code>192.168.31.1</code>，其实这是 WLAN 的网关，不属于 <code>192.168.200.x</code> 子网</strong></p>
<hr>
<h2 id="🔥-你现在的问题本质："><a href="#🔥-你现在的问题本质：" class="headerlink" title="🔥 你现在的问题本质："></a>🔥 <span style = "color:red">你现在的问题本质：</span></h2><ul>
<li>虽然 MobaXterm 能访问虚拟机 <code>192.168.200.131</code>，但虚拟机设置了一个<strong>不在本网段的网关：<code>192.168.31.1</code></strong></li>
<li>所以虚拟机根本无法出网（不能 ping 外网，也不能拉 harbor 镜像）</li>
</ul>
<hr>
<h2 id="✅-正确配置方式："><a href="#✅-正确配置方式：" class="headerlink" title="✅ 正确配置方式："></a>✅ 正确配置方式：</h2><p>让虚拟机在桥接模式下能 <strong>联网 + 被访问</strong></p>
<hr>
<h3 id="✅-第一步：设置正确网关（匹配虚拟机-IP-网段）"><a href="#✅-第一步：设置正确网关（匹配虚拟机-IP-网段）" class="headerlink" title="✅ 第一步：设置正确网关（匹配虚拟机 IP 网段）"></a>✅ 第一步：设置正确网关（匹配虚拟机 IP 网段）</h3><p>你虚拟机静态 IP 是 <code>192.168.200.131</code>，所以网关必须也在 <code>192.168.200.1~254</code> 范围。</p>
<p>观察宿主机 VMnet8（NAT）是 <code>192.168.200.2</code>，它的网关是：</p>
<pre><code>默认网关: 192.168.200.1
</code></pre>
<p>所以你应设置：</p>
<pre><code>IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1
DNS1=8.8.8.8
</code></pre>
<p>✅ 这个配置能让虚拟机出网（使用 VMware NAT 出口），也能让宿主机通过 <code>192.168.200.131</code> 访问虚拟机。</p>
<hr>
<h3 id="✅-第二步：如果你用的是-NAT-模式，则使用上面的-GATEWAY-是对的"><a href="#✅-第二步：如果你用的是-NAT-模式，则使用上面的-GATEWAY-是对的" class="headerlink" title="✅ 第二步：如果你用的是 NAT 模式，则使用上面的 GATEWAY 是对的"></a>✅ 第二步：如果你用的是 <strong>NAT 模式</strong>，则使用上面的 GATEWAY 是对的</h3><p>但你说你用了 <strong>桥接模式</strong>，那就要看桥接的是哪块网卡。</p>
<h4 id="桥接模式下，正确做法是："><a href="#桥接模式下，正确做法是：" class="headerlink" title="桥接模式下，正确做法是："></a>桥接模式下，正确做法是：</h4><ol>
<li>虚拟机 IP 要跟宿主机所连网络同一个网段</li>
<li>网关要设置为 <strong>宿主机 WLAN 的网关：<code>192.168.31.1</code></strong></li>
</ol>
<p>这样你才会在 MobaXterm 能访问、也能联网。</p>
<hr>
<h3 id="❗但你现在问题是："><a href="#❗但你现在问题是：" class="headerlink" title="❗但你现在问题是："></a>❗但你现在问题是：</h3><p>你桥接了，但 IP 却在 <code>192.168.200.x</code>，这说明虚拟机并没有成功桥接到宿主机 WLAN 网卡，而是连到了 VMware 的 NAT 网络（即使你设置桥接，也可能没生效）</p>
<hr>
<h2 id="✅-最建议方案"><a href="#✅-最建议方案" class="headerlink" title="✅ 最建议方案"></a>✅ 最建议方案</h2><h3 id="A-用-NAT-模式-正确网关（推荐稳定，适合大多数人）"><a href="#A-用-NAT-模式-正确网关（推荐稳定，适合大多数人）" class="headerlink" title="A. 用 NAT 模式 + 正确网关（推荐稳定，适合大多数人）"></a><strong>A. 用 NAT 模式 + 正确网关（推荐稳定，适合大多数人）</strong></h3><ol>
<li>把虚拟机改为 <strong>NAT 模式</strong></li>
<li><code>ifcfg-ens33</code> 设置如下：</li>
</ol>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1   # NAT 的默认网关
DNS1=8.8.8.8
</code></pre>
<ol>
<li>重启网络：</li>
</ol>
<pre><code>systemctl restart network
</code></pre>
<ol>
<li>测试网络：</li>
</ol>
<pre><code>ping -c 3 8.8.8.8
curl www.baidu.com
</code></pre>
<ol>
<li>然后使用 <code>MobaXterm</code> 访问你设置的 <code>192.168.200.131</code>，或设置端口转发（如 <code>127.0.0.1:2222</code> → <code>192.168.200.131:22</code>）</li>
</ol>
<hr>
<h3 id="B-或者继续桥接，但设置静态-IP-为-192-168-31-x-网段"><a href="#B-或者继续桥接，但设置静态-IP-为-192-168-31-x-网段" class="headerlink" title="B. 或者继续桥接，但设置静态 IP 为 192.168.31.x 网段"></a><strong>B. 或者继续桥接，但设置静态 IP 为 <code>192.168.31.x</code> 网段</strong></h3><p>如果你要桥接到宿主机 WLAN：</p>
<ol>
<li>修改 <code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>：</li>
</ol>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.31.130     # 自己定个没冲突的 IP
NETMASK=255.255.255.0
GATEWAY=192.168.31.1       # 你的无线网关
DNS1=8.8.8.8
</code></pre>
<ol>
<li>重启网络：</li>
</ol>
<pre><code>systemctl restart network
</code></pre>
<ol>
<li>检查 IP 和连通性：</li>
</ol>
<pre><code>ip addr
ping 8.8.8.8
</code></pre>
<hr>
<h2 id="✅-结论"><a href="#✅-结论" class="headerlink" title="✅ 结论"></a>✅ 结论</h2><p>你现在 MobaXterm 能连接，是因为用了静态 IP <code>192.168.200.131</code>，但由于网关不在同一网段，导致不能联网。</p>
<p>你只要根据你实际使用的网络模式（NAT 或桥接），<strong>把网关改成同网段的地址</strong>，问题就能解决。</p>
<hr>
<p>如果你告诉我你<strong>最终想使用 NAT 还是桥接</strong>（是否希望虚拟机能被其它设备访问），我可以直接帮你生成完整配置文件。</p>
<h6 id="继续延申问题："><a href="#继续延申问题：" class="headerlink" title="继续延申问题："></a>继续延申问题：</h6><p>我按照你说的改了 改成了nat模式 然后也改了配置  但是还是不行 [rooteloca1host ~]# ping -c 3 8.8.8.8PING 8.8.8.8(8.8.8.8) 56(84) bytes of data.From 192.168.200.131 icmp_seq&#x3D;1 Destination Host UnreachableFrom 192.168.200.131 icmp_seq&#x3D;2 Destination Host UnreachableFrom 192.168.200.131 icmp_seq&#x3D;3 Destination Host Unreachable8.8.8.8 ping statistics3 packets transmitted,0 received, +3 errors, 100% packet loss,time 1999mspipe3 现在连MobaXterm都连不上了 Network error: Connection timed out ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Session stopped    - Press <return> to exit tab    - Press R to restart session    - Press S to save terminal output to file</p>
<p>✅ 你现在的问题是：</p>
<blockquote>
<p><strong>你切换到 NAT 模式了，配置也改了，但：</strong></p>
<ul>
<li>❌ 仍然无法联网（<code>ping 8.8.8.8</code> 不通）</li>
<li>❌ MobaXterm 也连不上虚拟机（连接超时）</li>
<li>✅ 虚拟机 IP 是 <code>192.168.200.131</code>，网关你应该已改为 <code>192.168.200.1</code>（对吧？）</li>
</ul>
</blockquote>
<hr>
<p>我们来一步步快速排查：</p>
<hr>
<h2 id="✅-第一步：确认虚拟机网卡配置是否正确"><a href="#✅-第一步：确认虚拟机网卡配置是否正确" class="headerlink" title="✅ 第一步：确认虚拟机网卡配置是否正确"></a>✅ 第一步：确认虚拟机网卡配置是否正确</h2><p>在虚拟机里执行：</p>
<pre><code>cat /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<p>确认配置如下（<strong>静态 IP 模式 + NAT 网段的正确网关</strong>）：</p>
<pre><code>DEVICE=ens33
BOOTPROTO=static
ONBOOT=yes
IPADDR=192.168.200.131
NETMASK=255.255.255.0
GATEWAY=192.168.200.1
DNS1=8.8.8.8
</code></pre>
<p>如果不是这样，请立刻修改。</p>
<p>然后执行：</p>
<pre><code>systemctl restart network
</code></pre>
<hr>
<h2 id="✅-第二步：确认-NAT-模式是否正确工作"><a href="#✅-第二步：确认-NAT-模式是否正确工作" class="headerlink" title="✅ 第二步：确认 NAT 模式是否正确工作"></a>✅ 第二步：确认 NAT 模式是否正确工作</h2><p>打开 VMware 虚拟网络编辑器，确认：</p>
<ul>
<li>VMnet8 网络的 <strong>子网 IP</strong> 是 <code>192.168.200.0</code></li>
<li><strong>默认网关（Gateway）是 <code>192.168.200.1</code></strong></li>
<li>启用了 NAT 功能（有 <code>NAT 设置</code> 按钮，不是空的）</li>
<li>勾选了 “使用本地 DHCP 服务将 IP 地址分配给虚拟机”（建议开启）</li>
</ul>
<h2 id="✅-第三步：确认虚拟机路由是否存在"><a href="#✅-第三步：确认虚拟机路由是否存在" class="headerlink" title="✅ 第三步：确认虚拟机路由是否存在"></a>✅ 第三步：确认虚拟机路由是否存在</h2><p>在虚拟机中执行：</p>
<pre><code>ip route
</code></pre>
<p>你应该看到类似：</p>
<pre><code>default via 192.168.200.1 dev ens33
192.168.200.0/24 dev ens33 proto kernel scope link src 192.168.200.131
</code></pre>
<p>如果没有 <code>default via 192.168.200.1</code>，说明网关没生效，路由不通。</p>
<hr>
<h2 id="✅-第四步：确认宿主机启用了-NAT-网络服务"><a href="#✅-第四步：确认宿主机启用了-NAT-网络服务" class="headerlink" title="✅ 第四步：确认宿主机启用了 NAT 网络服务"></a>✅ 第四步：确认宿主机启用了 NAT 网络服务</h2><ol>
<li>打开 VMware 网络编辑器（以管理员身份运行）</li>
<li>点击 <code>VMnet8</code>，点右侧的 “NAT 设置”</li>
<li>看到：</li>
</ol>
<pre><code>网关 IP: 192.168.200.1
</code></pre>
<p>下面是端口转发之类设置，不用动。</p>
<ol>
<li>确保 VMware NAT Service 是运行状态：<ul>
<li>在宿主机按 Win+R → 输入 <code>services.msc</code></li>
<li>找到 <code>VMware NAT Service</code> 和 <code>VMware DHCP Service</code></li>
<li>状态必须是“正在运行”</li>
</ul>
</li>
</ol>
<hr>
<h2 id="✅-第五步：测试连接"><a href="#✅-第五步：测试连接" class="headerlink" title="✅ 第五步：测试连接"></a>✅ 第五步：测试连接</h2><ol>
<li>在虚拟机里执行：</li>
</ol>
<pre><code>ping 192.168.200.1
</code></pre>
<p>能 ping 通说明 NAT 网关 OK。</p>
<ol>
<li>在虚拟机里执行：</li>
</ol>
<pre><code>ping 8.8.8.8
</code></pre>
<p>仍然不通，说明出网失败，可能是：</p>
<ul>
<li>路由表错（<code>ip route</code> 查看）</li>
<li>NAT 服务没开（第 4 步）</li>
<li>没走正确网关（第 1 步）</li>
</ul>
<hr>
<hr>
<p>按照你说的做了 [root@localhost harbor]# docker ps | grep nginx 1773679bace8        goharbor&#x2F;nginx-photon:v1.9.2                             “nginx -g ‘daemon of…”   9 seconds ago       Up 7 seconds (health: starting)    0.0.0.0:85-&gt;8080&#x2F;tcp        nginx 7e41a5e0662b        goharbor&#x2F;harbor-portal:v1.9.2                            “nginx -g ‘daemon of…”   14 seconds ago      Up 10 seconds (health: starting)   8080&#x2F;tcp                    harbor-portal [root@localhost harbor]#</p>
<h6 id="ChatGPT-说：-1"><a href="#ChatGPT-说：-1" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常好，你现在的操作都没错，但从这条日志来看：</p>
<pre><code>
0.0.0.0:85-&gt;8080/tcp        nginx
</code></pre>
<p>说明 <strong><code>docker-compose.yml</code> 里仍然是 <code>85:8080</code> 映射</strong>，而不是我们期望的：</p>
<pre><code>
85:80
</code></pre>
<hr>
<h2 id="✅-解决方案：手动改一下-docker-compose-yml，然后重新启动-Harbor"><a href="#✅-解决方案：手动改一下-docker-compose-yml，然后重新启动-Harbor" class="headerlink" title="✅ 解决方案：手动改一下 docker-compose.yml，然后重新启动 Harbor"></a>✅ 解决方案：手动改一下 <code>docker-compose.yml</code>，然后重新启动 Harbor</h2><h3 id="✏️-步骤-1：手动修改端口映射"><a href="#✏️-步骤-1：手动修改端口映射" class="headerlink" title="✏️ 步骤 1：手动修改端口映射"></a>✏️ 步骤 1：手动修改端口映射</h3><p>打开 <code>docker-compose.yml</code>，找到 <code>proxy:</code> 下面这段：</p>
<pre><code>ports:
  - 85:8080
</code></pre>
<p>改成：</p>
<pre><code>ports:
  - 85:80
</code></pre>
<blockquote>
<p>🔁 如果你在 Vim 里编辑，改完后按：</p>
<pre><code>Esc → :wq
</code></pre>
</blockquote>
<hr>
<h3 id="🔄-步骤-2：重启-Harbor-服务"><a href="#🔄-步骤-2：重启-Harbor-服务" class="headerlink" title="🔄 步骤 2：重启 Harbor 服务"></a>🔄 步骤 2：重启 Harbor 服务</h3><pre><code>docker-compose down
docker-compose up -d
</code></pre>
<hr>
<h3 id="🔍-步骤-3：确认端口映射是否正确"><a href="#🔍-步骤-3：确认端口映射是否正确" class="headerlink" title="🔍 步骤 3：确认端口映射是否正确"></a>🔍 步骤 3：确认端口映射是否正确</h3><pre><code>docker ps | grep nginx
</code></pre>
<p>应该看到：</p>
<pre><code>0.0.0.0:85-&gt;80/tcp        nginx
</code></pre>
<hr>
<h3 id="✅-最后：浏览器访问-Harbor"><a href="#✅-最后：浏览器访问-Harbor" class="headerlink" title="✅ 最后：浏览器访问 Harbor"></a>✅ 最后：浏览器访问 Harbor</h3><p>打开浏览器访问：</p>
<pre><code>http://192.168.200.131:85/
</code></pre>
<p>你应该能看到 Harbor 登录页面。</p>
<hr>
<hr>
<h2 id="🔍-目前情况总结："><a href="#🔍-目前情况总结：" class="headerlink" title="🔍 目前情况总结："></a>🔍 目前情况总结：</h2><table>
<thead>
<tr>
<th>项</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td><code>nginx</code> 容器健康</td>
<td>✅ <code>healthy</code></td>
</tr>
<tr>
<td><code>curl localhost:85</code></td>
<td>❌ 失败（提示：Connection reset by peer）</td>
</tr>
<tr>
<td><code>ss -tnlp</code> 显示监听</td>
<td>✅ <code>docker-proxy</code> 在监听 <code>:::85</code></td>
</tr>
<tr>
<td><code>ping 192.168.200.131</code></td>
<td>✅ 通</td>
</tr>
<tr>
<td>浏览器访问 <code>http://192.168.200.131:85</code></td>
<td>❌ 超时</td>
</tr>
</tbody></table>
<h3 id="✅-正确的配置应为："><a href="#✅-正确的配置应为：" class="headerlink" title="✅ 正确的配置应为："></a>✅ 正确的配置应为：</h3><p>在 <code>docker-compose.yml</code> 里，把 <code>proxy</code> 服务的 <code>ports</code> 改为：</p>
<pre><code>ports:
  - 85:80
</code></pre>
<p>然后执行如下命令使配置生效：</p>
<pre><code># 停止并清理容器
docker-compose down

# 再启动
docker-compose up -d
</code></pre>
<p>再执行：</p>
<pre><code>curl -I http://localhost:85
</code></pre>
<p>你应该能看到：</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<p>然后用浏览器访问：</p>
<pre><code>http://192.168.200.131:85
</code></pre>
<p>✅ 成功进入 Harbor 页面！</p>
<hr>
<hr>
<p>我已经用了NAT模式 + 静态ip [root@localhost harbor]# curl -I <a target="_blank" rel="noopener" href="http://localhost:85/">http://localhost:85</a> curl: (56) Recv failure: Connection reset by peer [root@localhost harbor]# 嗯… 无法访问此页面 192.168.200.131 响应时间太长 请尝试： 在 Web 上搜索 192 168 200 131 检查连接 检查代理和防火墙 ERR_CONNECTION_TIMED_OUT</p>
<h6 id="ChatGPT-说：-2"><a href="#ChatGPT-说：-2" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>你现在的情况是：</p>
<ul>
<li>✅ 已经使用了 <strong>NAT 模式</strong>；</li>
<li>✅ <code>docker ps</code> 显示 Harbor 的 <code>nginx</code> 容器 <strong>端口映射是正确的</strong>：<code>0.0.0.0:85-&gt;80</code>；</li>
<li>❌ 但 <code>curl localhost:85</code> 报错：<code>Connection reset by peer</code>，说明容器里的 nginx 拒绝了连接；</li>
<li>❌ 主机访问 <code>http://192.168.200.131:85</code> 报超时，<strong>NAT 本身不支持直接访问虚拟机的 IP</strong>；</li>
<li>✅ 你已给虚拟机设置静态 IP 为 <code>192.168.200.131</code>；</li>
<li>❗ <strong>你没有配置端口转发！</strong></li>
</ul>
<hr>
<h2 id="🎯-结论：你现在这种做法是错误的"><a href="#🎯-结论：你现在这种做法是错误的" class="headerlink" title="🎯 结论：你现在这种做法是错误的"></a>🎯 结论：你现在这种做法是错误的</h2><blockquote>
<p><strong>NAT 模式下，主机不能通过虚拟机的 IP（192.168.200.131）访问 Harbor 的端口。</strong><br> <strong>应该通过端口转发实现！</strong></p>
</blockquote>
<hr>
<h2 id="✅-正确做法：配置端口转发（NAT-➜-主机映射）"><a href="#✅-正确做法：配置端口转发（NAT-➜-主机映射）" class="headerlink" title="✅ 正确做法：配置端口转发（NAT ➜ 主机映射）"></a>✅ 正确做法：配置端口转发（NAT ➜ 主机映射）</h2><h3 id="🛠-步骤如下："><a href="#🛠-步骤如下：" class="headerlink" title="🛠 步骤如下："></a>🛠 步骤如下：</h3><h4 id="①-打开-VMware-虚拟网络编辑器"><a href="#①-打开-VMware-虚拟网络编辑器" class="headerlink" title="① 打开 VMware 虚拟网络编辑器"></a>① 打开 VMware 虚拟网络编辑器</h4><ul>
<li>打开 VMware Workstation（非虚拟机内部）</li>
<li>菜单栏 ➜ <code>编辑</code> ➜ <code>虚拟网络编辑器</code></li>
<li>找到 <code>VMnet8</code>（即 NAT 模式）</li>
</ul>
<h4 id="②-点击右下角的“NAT-设置”"><a href="#②-点击右下角的“NAT-设置”" class="headerlink" title="② 点击右下角的“NAT 设置”"></a>② 点击右下角的“<strong>NAT 设置</strong>”</h4><ul>
<li>在弹出的 NAT 设置窗口中 ➜ 点击“<strong>端口转发（Port Forwarding）</strong>”</li>
</ul>
<h4 id="③-添加一条端口转发规则："><a href="#③-添加一条端口转发规则：" class="headerlink" title="③ 添加一条端口转发规则："></a>③ 添加一条端口转发规则：</h4><table>
<thead>
<tr>
<th>名称</th>
<th>协议</th>
<th>主机端口</th>
<th>虚拟机 IP</th>
<th>虚拟机端口</th>
</tr>
</thead>
<tbody><tr>
<td>harbor</td>
<td>TCP</td>
<td>1085</td>
<td>192.168.200.131</td>
<td>85</td>
</tr>
</tbody></table>
<blockquote>
<p>主机端口你可以写 1085，避免冲突；虚拟机端口是 Harbor 的端口 85。</p>
</blockquote>
<h2 id="📌-说明：为什么-NAT-模式不能直接访问虚拟机-IP？"><a href="#📌-说明：为什么-NAT-模式不能直接访问虚拟机-IP？" class="headerlink" title="📌 说明：为什么 NAT 模式不能直接访问虚拟机 IP？"></a>📌 说明：为什么 NAT 模式不能直接访问虚拟机 IP？</h2><blockquote>
<p>NAT 模式是虚拟机通过主机“共享网络”出去访问外部，但主机<strong>无法通过虚拟机的 NAT IP（如 192.168.200.131）访问回来</strong>，因为这个网段对主机来说是隔离的。<br> 除非做端口转发，否则无法通信。</p>
</blockquote>
<hr>
<hr>
<h3 id="🧭-接下来的最后一步："><a href="#🧭-接下来的最后一步：" class="headerlink" title="🧭 接下来的最后一步："></a>🧭 接下来的最后一步：</h3><p>你当前的网络结构是：</p>
<pre><code class="yaml">Windows 浏览器访问 localhost:10085
 ↓
VMware NAT 端口转发：10085 → 192.168.200.131:85
 ↓
Harbor Docker：85 → nginx容器的 82
 ↓
nginx 正常监听 82
</code></pre>
<p><code>cd /opt/harbor/</code></p>
<h5 id="搞了好久-估计是网络-配置的问题"><a href="#搞了好久-估计是网络-配置的问题" class="headerlink" title="搞了好久 估计是网络+配置的问题"></a><span style = "color:red">搞了好久 估计是网络+配置的问题</span></h5><p>这是<code>docker-compose.yml</code>的配置信息</p>
<pre><code class="yaml">version: &#39;2.3&#39;
services:
  log:
    image: goharbor/harbor-log:v1.9.2
    container_name: harbor-log
    restart: always
    dns_search: .
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    volumes:
      - /var/log/harbor/:/var/log/docker/:z
      - ./common/config/log/logrotate.conf:/etc/logrotate.d/logrotate.conf:z
      - ./common/config/log/rsyslog_docker.conf:/etc/rsyslog.d/rsyslog_docker.conf:z
    ports:
      - 127.0.0.1:1514:10514
    networks:
      - harbor
  registry:
    image: goharbor/registry-photon:v2.7.1-patch-2819-2553-v1.9.2
    container_name: registry
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
      - type: bind
        source: /data/secret/registry/root.crt
        target: /etc/registry/root.crt
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;registry&quot;
  registryctl:
    image: goharbor/harbor-registryctl:v1.9.2
    container_name: registryctl
    env_file:
      - ./common/config/registryctl/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
      - type: bind
        source: ./common/config/registryctl/config.yml
        target: /etc/registryctl/config.yml
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;registryctl&quot;
  postgresql:
    image: goharbor/harbor-db:v1.9.2
    container_name: harbor-db
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
    volumes:
      - /data/database:/var/lib/postgresql/data:z
    networks:
      harbor:
    dns_search: .
    env_file:
      - ./common/config/db/env
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;postgresql&quot;
  core:
    image: goharbor/harbor-core:v1.9.2
    container_name: harbor-core
    env_file:
      - ./common/config/core/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - SETGID
      - SETUID
    volumes:
      - /data/ca_download/:/etc/core/ca/:z
      - /data/psc/:/etc/core/token/:z
      - /data/:/data/:z
      - ./common/config/core/certificates/:/etc/core/certificates/:z
      - type: bind
        source: ./common/config/core/app.conf
        target: /etc/core/app.conf
      - type: bind
        source: /data/secret/core/private_key.pem
        target: /etc/core/private_key.pem
      - type: bind
        source: /data/secret/keys/secretkey
        target: /etc/core/key
    networks:
      harbor:
    dns_search: .
    depends_on:
      - log
      - registry
      - redis
      - postgresql
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;core&quot;
  portal:
    image: goharbor/harbor-portal:v1.9.2
    container_name: harbor-portal
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
      - NET_BIND_SERVICE
    networks:
      - harbor
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;portal&quot;

  jobservice:
    image: goharbor/harbor-jobservice:v1.9.2
    container_name: harbor-jobservice
    env_file:
      - ./common/config/jobservice/env
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/job_logs:/var/log/jobs:z
      - type: bind
        source: ./common/config/jobservice/config.yml
        target: /etc/jobservice/config.yml
    networks:
      - harbor
    dns_search: .
    depends_on:
      - core
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;jobservice&quot;
  redis:
    image: goharbor/redis-photon:v1.9.2
    container_name: redis
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    volumes:
      - /data/redis:/var/lib/redis
    networks:
      harbor:
    dns_search: .
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;redis&quot;
  proxy:
    image: goharbor/nginx-photon:v1.9.2
    container_name: nginx
    restart: always
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
      - NET_BIND_SERVICE
    volumes:
      - ./common/config/nginx:/etc/nginx:z
    networks:
      - harbor
    dns_search: .
    ports:
      - 85:8080
    depends_on:
      - registry
      - core
      - portal
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;proxy&quot;
networks:
  harbor:
    external: false
</code></pre>
<h6 id="这是harbor里的nginx的配置"><a href="#这是harbor里的nginx的配置" class="headerlink" title="这是harbor里的nginx的配置"></a>这是harbor里的nginx的配置</h6><pre><code class="yaml">[root@localhost nginx]# cat nginx.conf

worker_processes auto;
pid /tmp/nginx.pid;

events &#123;
  worker_connections 1024;
  use epoll;
  multi_accept on;
&#125;

http &#123;
  client_body_temp_path /tmp/client_body_temp;
  proxy_temp_path /tmp/proxy_temp;
  fastcgi_temp_path /tmp/fastcgi_temp;
  uwsgi_temp_path /tmp/uwsgi_temp;
  scgi_temp_path /tmp/scgi_temp;
  tcp_nodelay on;

  # this is necessary for us to be able to disable request buffering in all cases
  proxy_http_version 1.1;

  upstream core &#123;
    server core:8080;
  &#125;

  upstream portal &#123;
    server portal:8080;
  &#125;

  log_format timed_combined &#39;$remote_addr - &#39;
    &#39;&quot;$request&quot; $status $body_bytes_sent &#39;
    &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;
    &#39;$request_time $upstream_response_time $pipe&#39;;

  access_log /dev/stdout timed_combined;

  server &#123;
    listen 8080;
    server_tokens off;
    # disable any limits to avoid HTTP 413 for large image uploads
    client_max_body_size 0;

    # Add extra headers
    add_header X-Frame-Options DENY;
    add_header Content-Security-Policy &quot;frame-ancestors &#39;none&#39;&quot;;

    # costumized location config file can place to /etc/nginx/etc with prefix harbor.http. and suffix .conf
    include /etc/nginx/conf.d/harbor.http.*.conf;

    location / &#123;
      proxy_pass http://portal/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /c/ &#123;
      proxy_pass http://core/c/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /api/ &#123;
      proxy_pass http://core/api/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /chartrepo/ &#123;
      proxy_pass http://core/chartrepo/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /v1/ &#123;
      return 404;
    &#125;

    location /v2/ &#123;
      proxy_pass http://core/v2/;
      proxy_set_header Host $http_host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /service/ &#123;
      proxy_pass http://core/service/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      # When setting up Harbor behind other proxy, such as an Nginx instance, remove the below line if the proxy already has similar settings.
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_request_buffering off;
    &#125;

    location /service/notifications &#123;
      return 404;
    &#125;
  &#125;
&#125;
</code></pre>
<p><span style = "color:red"><strong>这里附带重大BUG排查思路</strong></span></p>
<p>当然可以！我帮你把这整个过程的错误、涉及的宿主机、虚拟机、nginx（宿主机与容器里Harbor的nginx），以及排查思路，综合讲清楚，方便你理解整体流程。</p>
<hr>
<h1 id="1-相关环境和组件说明"><a href="#1-相关环境和组件说明" class="headerlink" title="1. 相关环境和组件说明"></a>1. 相关环境和组件说明</h1><ul>
<li><strong>宿主机</strong>：你的真实物理机或主机系统（Windows），负责运行虚拟机软件（比如VMware）。</li>
<li><strong>虚拟机</strong>：运行 Harbor 的 Linux 虚拟机（192.168.200.131），是 Harbor 的部署环境。</li>
<li><strong>Docker 容器内的 nginx</strong>：Harbor 里内置的 nginx 作为反向代理服务器，监听容器内部的端口（如 82 或 8080），将请求转发给 Harbor 应用组件。</li>
<li><strong>宿主机与虚拟机的网络</strong>：<ul>
<li>虚拟机配置桥接或NAT网络，宿主机通过 IP 和端口转发访问虚拟机。</li>
<li>端口转发需确保宿主机防火墙、虚拟机防火墙和 Docker 端口映射正确。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-你遇到的主要错误和症状总结"><a href="#2-你遇到的主要错误和症状总结" class="headerlink" title="2. 你遇到的主要错误和症状总结"></a>2. 你遇到的主要错误和症状总结</h1><table>
<thead>
<tr>
<th>错误&#x2F;症状</th>
<th>可能原因</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>Test-NetConnection</code> 提示 TCP 连接失败（比如端口1085失败，10085成功但浏览器连接拒绝）</td>
<td>端口未开放或服务未监听，防火墙或网络配置问题</td>
<td>端口映射或容器服务没启动好</td>
</tr>
<tr>
<td>Docker 启动 nginx 容器时报错：<code>unknown log opt &#39;syslog-address&#39; for json-file log driver</code></td>
<td><code>logging</code> 配置不兼容，<code>json-file</code> 驱动不支持 <code>syslog-address</code> 参数</td>
<td>需要调整日志驱动配置</td>
</tr>
<tr>
<td><code>curl http://localhost:85</code> 返回 302 或 200，但浏览器访问虚拟机IP时超时或重置连接</td>
<td>虚拟机防火墙、宿主机端口转发配置错误，或者nginx监听端口配置不一致</td>
<td>宿主机访问虚拟机端口不通</td>
</tr>
<tr>
<td>虚拟机上 <code>ss -tnlp</code> 看到 nginx 监听的是 82 端口，而 Docker 映射是 85:82</td>
<td>端口映射正确，但宿主机访问端口和内部监听端口不一致需要确认</td>
<td>访问时端口错位会导致访问失败</td>
</tr>
</tbody></table>
<hr>
<h1 id="3-排查思路和步骤详解"><a href="#3-排查思路和步骤详解" class="headerlink" title="3. 排查思路和步骤详解"></a>3. 排查思路和步骤详解</h1><h3 id="Step-1：确认容器服务启动及端口监听情况"><a href="#Step-1：确认容器服务启动及端口监听情况" class="headerlink" title="Step 1：确认容器服务启动及端口监听情况"></a>Step 1：确认容器服务启动及端口监听情况</h3><ul>
<li><code>docker-compose up -d</code> 启动 Harbor 相关服务，包括 nginx 代理容器。</li>
<li><code>docker ps</code> 看 nginx 容器是否在运行。</li>
<li><code>docker logs nginx</code> 查看 nginx 容器日志，看是否报错。</li>
<li><code>ss -tnlp</code>（或 <code>netstat -tnlp</code>）确认 nginx 容器内部监听端口，例如82或8080。</li>
</ul>
<hr>
<h3 id="Step-2：确认端口映射和宿主机网络"><a href="#Step-2：确认端口映射和宿主机网络" class="headerlink" title="Step 2：确认端口映射和宿主机网络"></a>Step 2：确认端口映射和宿主机网络</h3><ul>
<li>确认 docker-compose 端口映射，比如 <code>- 85:82</code> 说明宿主机85端口映射到容器82端口。</li>
<li>确认虚拟机的网络IP（192.168.200.131）可访问，虚拟机是否允许访问85端口。</li>
<li>通过宿主机（Windows）<code>Test-NetConnection 192.168.200.131 85</code> 测试连通性。</li>
<li>如果端口连接失败，检查：<ul>
<li>虚拟机防火墙状态（如 <code>firewall-cmd</code>），确认85端口开放。</li>
<li>虚拟机网络配置是否正确。</li>
<li>宿主机是否正确做了端口转发（NAT配置等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Step-3：确认宿主机与虚拟机间端口转发与防火墙设置"><a href="#Step-3：确认宿主机与虚拟机间端口转发与防火墙设置" class="headerlink" title="Step 3：确认宿主机与虚拟机间端口转发与防火墙设置"></a>Step 3：确认宿主机与虚拟机间端口转发与防火墙设置</h3><ul>
<li>你之前做的 VMware NAT 端口转发配置，确认宿主机的10085端口转发到虚拟机的85端口。</li>
<li>虚拟机防火墙是否禁用或开放该端口（你确认了 <code>firewalld</code> 未运行）。</li>
<li>SELinux 状态（你确认是 <code>Permissive</code>，不阻止）。</li>
</ul>
<hr>
<h3 id="Step-4：确认容器内部-nginx-与-Harbor-应用运行状态"><a href="#Step-4：确认容器内部-nginx-与-Harbor-应用运行状态" class="headerlink" title="Step 4：确认容器内部 nginx 与 Harbor 应用运行状态"></a>Step 4：确认容器内部 nginx 与 Harbor 应用运行状态</h3><ul>
<li>容器内 nginx 配置监听82端口，但外部映射成85端口，确认两者一致。</li>
<li>容器内 curl localhost:82 返回200，说明 nginx 服务正常。</li>
<li>nginx 返回的网页中包含 Harbor 前端静态资源，但前端一直转圈，可能是后端 API 没响应。</li>
<li>可能是 Harbor 核心服务(core)未正常工作或访问不到数据库&#x2F;redis，导致页面没加载完成。</li>
</ul>
<hr>
<h3 id="Step-5：重启虚拟机后问题消失"><a href="#Step-5：重启虚拟机后问题消失" class="headerlink" title="Step 5：重启虚拟机后问题消失"></a>Step 5：重启虚拟机后问题消失</h3><ul>
<li>重启虚拟机后，网络重新初始化，Docker网络也重建，端口转发生效，nginx和Harbor服务正常，浏览器访问成功。</li>
<li>说明之前网络环境（端口转发、Docker网络或nginx监听）存在缓存或未正常启动的问题。</li>
</ul>
<hr>
<h1 id="4-你看到的“宿主机与虚拟机”和“nginx内部-x2F-外部”的关系"><a href="#4-你看到的“宿主机与虚拟机”和“nginx内部-x2F-外部”的关系" class="headerlink" title="4. 你看到的“宿主机与虚拟机”和“nginx内部&#x2F;外部”的关系"></a>4. 你看到的“宿主机与虚拟机”和“nginx内部&#x2F;外部”的关系</h1><table>
<thead>
<tr>
<th>层级</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宿主机 (Windows)</strong></td>
<td>你直接操作的机器，运行 VMware，提供 NAT&#x2F;桥接网络，做端口转发</td>
<td>访问虚拟机IP和端口</td>
</tr>
<tr>
<td><strong>虚拟机 (Linux Harbor 环境)</strong></td>
<td>Harbor 部署环境，运行 Docker 和 Harbor 服务容器</td>
<td>虚拟机防火墙和网络设置必须正确</td>
</tr>
<tr>
<td><strong>Docker 容器内 nginx</strong></td>
<td>Harbor 的反向代理，监听容器内部端口（如82），转发给 Harbor 应用服务</td>
<td>Docker端口映射：宿主机85端口映射到容器82端口</td>
</tr>
<tr>
<td><strong>Harbor 应用组件</strong></td>
<td>Core、Portal、Registry 等，负责业务逻辑和数据</td>
<td>需要数据库和redis支持，服务正常才能正常访问</td>
</tr>
</tbody></table>
<hr>
<h1 id="5-综合总结"><a href="#5-综合总结" class="headerlink" title="5. 综合总结"></a>5. 综合总结</h1><ul>
<li>你先遇到的端口连接失败，是虚拟机内服务监听、端口映射、虚拟机防火墙或宿主机端口转发配置的问题。</li>
<li>Docker 容器日志中的 <code>unknown log opt &#39;syslog-address&#39;</code> 是日志驱动配置错误，需要统一用 <code>json-file</code> 或兼容的驱动。</li>
<li>宿主机访问端口和容器监听端口要对应，nginx监听82端口，宿主机映射85端口，访问时要用宿主机的85端口。</li>
<li>访问 Harbor 首页看到 nginx 返回 200，说明 nginx 正常，前端页面开始加载，但若页面卡住，可能是后端服务未完全启动或网络访问不到其他 Harbor 服务。</li>
<li>重启虚拟机会刷新网络环境和容器服务，解决了之前隐藏的网络端口转发、Docker网络或者服务启动顺序的问题。</li>
<li>最后确认服务正常，可以访问页面。</li>
</ul>
<hr>
<p>如果总结起来，整个排查流程是：</p>
<ol>
<li><strong>确认服务启动和端口监听</strong>（<code>docker-compose up</code>、<code>ss -tnlp</code>、<code>docker logs</code>）。</li>
<li><strong>检查端口映射和虚拟机网络配置</strong>（NAT端口转发、虚拟机IP、防火墙）。</li>
<li><strong>宿主机访问测试</strong>（PowerShell的Test-NetConnection）。</li>
<li><strong>确认容器内服务状态</strong>（容器内curl）。</li>
<li><strong>调整配置并重启验证</strong>。</li>
<li><strong>最终确认页面访问正常</strong>。</li>
</ol>
<hr>
<h1 id="Harbor-访问故障排查文档"><a href="#Harbor-访问故障排查文档" class="headerlink" title="Harbor 访问故障排查文档"></a>Harbor 访问故障排查文档</h1><h2 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h2><p>你在虚拟机上用 Docker Compose 部署 Harbor，遇到宿主机访问 Harbor Web UI 端口无法连接的问题。本文档总结了排查和解决过程，覆盖容器服务状态、端口映射、虚拟机网络、防火墙配置等关键点。</p>
<hr>
<h2 id="二、排查准备"><a href="#二、排查准备" class="headerlink" title="二、排查准备"></a>二、排查准备</h2><ul>
<li><strong>宿主机环境</strong>：Windows（通过 VMware 运行虚拟机）</li>
<li><strong>虚拟机环境</strong>：Linux，Harbor 服务部署环境，IP 如 <code>192.168.200.131</code></li>
<li><strong>Docker Harbor 版本</strong>：v1.9.2</li>
<li><strong>访问端口映射</strong>：宿主机端口 85 映射到容器内 nginx 监听端口 82</li>
</ul>
<hr>
<h2 id="三、排查步骤"><a href="#三、排查步骤" class="headerlink" title="三、排查步骤"></a>三、排查步骤</h2><h3 id="Step-1-容器服务启动状态检查"><a href="#Step-1-容器服务启动状态检查" class="headerlink" title="Step 1. 容器服务启动状态检查"></a>Step 1. 容器服务启动状态检查</h3><ul>
<li><p>使用命令：</p>
<pre><code>bash复制编辑docker-compose up -d
docker ps
docker logs nginx --tail 50
</code></pre>
</li>
<li><p>确认 nginx 容器及其他 Harbor 服务容器是否运行正常，没有报错。</p>
</li>
<li><p>使用命令查看容器内部端口监听：</p>
<pre><code>bash


ss -tnlp | grep nginx
</code></pre>
</li>
</ul>
<p> 确认 nginx 是否监听正确的端口（一般是 82 或 8080）。</p>
<hr>
<h3 id="Step-2-Docker-端口映射与虚拟机端口监听确认"><a href="#Step-2-Docker-端口映射与虚拟机端口监听确认" class="headerlink" title="Step 2. Docker 端口映射与虚拟机端口监听确认"></a>Step 2. Docker 端口映射与虚拟机端口监听确认</h3><ul>
<li><p>检查 <code>docker-compose.yml</code> 端口映射配置，如：</p>
<p>&#96;&#96;&#96;</p>
</li>
</ul>
<p>ports:<br>    - 85:82</p>
<pre><code>
表示宿主机（虚拟机）85端口映射到容器82端口。

- 在虚拟机上确认端口监听：
</code></pre>
<pre><code>ss -tnlp | grep :85
```
</code></pre>
<p>  通常 docker-proxy 会监听对应端口。</p>
<hr>
<h3 id="Step-3-虚拟机网络配置和防火墙检查"><a href="#Step-3-虚拟机网络配置和防火墙检查" class="headerlink" title="Step 3. 虚拟机网络配置和防火墙检查"></a>Step 3. 虚拟机网络配置和防火墙检查</h3><ul>
<li>检查虚拟机的防火墙状态：</li>
</ul>
<pre><code>
firewall-cmd --state
</code></pre>
<pre><code>确保防火墙关闭或已开放对应端口。
</code></pre>
<ul>
<li><p>查看 SELinux 状态（有时会阻止网络服务）：</p>
<p>&#96;&#96;&#96;<br> getenforce</p>
</li>
</ul>
<pre><code>
建议设置为 `Permissive` 或 `Disabled`。

- 检查虚拟机的 IP 配置，确认使用的是正确的 IP。
 
 - 在宿主机（Windows）上使用 PowerShell 测试端口连通：
</code></pre>
<p>  powershell</p>
<p> 复制编辑<br>  Test-NetConnection -ComputerName 192.168.200.131 -Port 85</p>
<pre><code>
------

### Step 4. 宿主机与虚拟机端口转发设置（NAT模式）
 
 - 如果使用 VMware NAT，需要在 VMware NAT 设置中配置端口转发：
 - 主机端口（宿主机）设为 `10085`（或你需要的端口）
 - 转发到虚拟机 IP（如 `192.168.200.131`）的 85 端口
- 通过宿主机访问 `localhost:10085`，实际访问虚拟机的 Harbor 服务。

------

### Step 5. 使用 curl 命令测试服务

- 在虚拟机内部测试：
</code></pre>
<p> curl -I <a target="_blank" rel="noopener" href="http://localhost:82/">http://localhost:82</a></p>
<pre><code>
- 在虚拟机外部测试（宿主机）：
</code></pre>
<p>  curl -I <a target="_blank" rel="noopener" href="http://192.168.200.131:85/">http://192.168.200.131:85</a></p>
<pre><code>```
</code></pre>
<ul>
<li>观察返回结果，确认 HTTP 状态码是否正常（200&#x2F;302 等）。</li>
</ul>
<hr>
<h3 id="Step-6-遇到问题的典型症状及对应处理"><a href="#Step-6-遇到问题的典型症状及对应处理" class="headerlink" title="Step 6. 遇到问题的典型症状及对应处理"></a>Step 6. 遇到问题的典型症状及对应处理</h3><table>
<thead>
<tr>
<th>症状</th>
<th>可能原因</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>宿主机无法连接端口，连接超时</td>
<td>防火墙阻止、端口未开放</td>
<td>关闭防火墙或放行端口</td>
</tr>
<tr>
<td>curl 返回连接重置或拒绝</td>
<td>服务未启动或监听端口错误</td>
<td>检查 nginx 配置和容器启动</td>
</tr>
<tr>
<td>curl 返回200但页面加载不出</td>
<td>后端服务未就绪或网络不通</td>
<td>检查 Harbor core 服务状态</td>
</tr>
<tr>
<td>日志中报错日志驱动不支持</td>
<td>docker-compose 日志配置错误</td>
<td>统一使用 <code>json-file</code> 驱动</td>
</tr>
<tr>
<td>端口映射配置错误</td>
<td>端口映射写错</td>
<td>纠正 <code>docker-compose.yml</code> 中端口映射</td>
</tr>
</tbody></table>
<hr>
<h3 id="Step-7-重启生效验证"><a href="#Step-7-重启生效验证" class="headerlink" title="Step 7. 重启生效验证"></a>Step 7. 重启生效验证</h3><ul>
<li>重启虚拟机，有时可以修复网络绑定、端口冲突等隐患问题。</li>
<li>重启后再次测试端口连通性和页面访问。</li>
</ul>
<hr>
<h2 id="四、示例核心配置（端口映射部分）"><a href="#四、示例核心配置（端口映射部分）" class="headerlink" title="四、示例核心配置（端口映射部分）"></a>四、示例核心配置（端口映射部分）</h2><pre><code>services:
proxy:
   image: goharbor/nginx-photon:v1.9.2
  container_name: nginx
   ports:
    - 85:82  # 宿主机端口 85 映射到容器内 nginx 监听的 82 端口
       volumes:
           - ./common/config/nginx:/etc/nginx:z
          depends_on:
                 - core
                      - portal
                       - registry
</code></pre>
<hr>
<h2 id="五、常用命令汇总"><a href="#五、常用命令汇总" class="headerlink" title="五、常用命令汇总"></a>五、常用命令汇总</h2><table>
<thead>
<tr>
<th>作用</th>
<th>命令示例</th>
</tr>
</thead>
<tbody><tr>
<td>查看容器状态</td>
<td><code>docker ps</code></td>
</tr>
<tr>
<td>查看容器日志</td>
<td><code>docker logs nginx --tail 50</code></td>
</tr>
<tr>
<td>查看端口监听</td>
<td>&#96;ss -tnlp</td>
</tr>
<tr>
<td>测试端口连通（宿主机）</td>
<td><code>Test-NetConnection -ComputerName 192.168.200.131 -Port 85</code> (PowerShell)</td>
</tr>
<tr>
<td>虚拟机防火墙状态</td>
<td><code>firewall-cmd --state</code></td>
</tr>
<tr>
<td>SELinux 状态</td>
<td><code>getenforce</code></td>
</tr>
<tr>
<td>虚拟机内访问本地端口</td>
<td><code>curl -I http://localhost:82</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="访问故障排查简易步骤清单"><a href="#访问故障排查简易步骤清单" class="headerlink" title="访问故障排查简易步骤清单"></a>访问故障排查简易步骤清单</h1><ol>
<li><strong>确认 Docker 容器和服务状态</strong><ul>
<li><code>docker-compose up -d</code></li>
<li><code>docker ps</code></li>
<li><code>docker logs nginx</code></li>
</ul>
</li>
<li><strong>确认端口监听和映射</strong><ul>
<li>容器内部 <code>ss -tnlp | grep nginx</code></li>
</ul>
</li>
</ol>
<ul>
<li>虚拟机 <code>ss -tnlp | grep :85</code></li>
<li><code>docker-compose.yml</code> 中端口映射是否正确</li>
</ul>
<ol start="3">
<li><strong>检查虚拟机网络和防火墙</strong><ul>
<li><code>firewall-cmd --state</code></li>
</ul>
</li>
</ol>
<ul>
<li><code>getenforce</code></li>
<li>关闭防火墙或放行端口</li>
</ul>
<ol start="4">
<li><strong>宿主机端口转发（NAT 模式）配置正确</strong><ul>
<li>确认 VMware NAT 端口转发设置无误</li>
</ul>
</li>
<li><strong>测试端口连通性</strong><ul>
<li>宿主机 PowerShell 测试端口连通</li>
<li>虚拟机内 curl 测试端口访问</li>
</ul>
</li>
<li><strong>浏览器访问测试</strong><ul>
<li>用正确端口访问 Harbor 页面</li>
<li>观察是否能正常加载</li>
</ul>
</li>
<li><strong>重启虚拟机和服务</strong><ul>
<li>解决网络缓存、绑定等异常</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="在Harbor创建用户和项目"><a href="#在Harbor创建用户和项目" class="headerlink" title="在Harbor创建用户和项目"></a>在Harbor创建用户和项目</h5><ul>
<li>创建项目</li>
</ul>
<p>Harbor的项目分为公开和私有的：<br>公开项目：所有用户都可以访问，通常存放公共的镜像，默认有一个library公开项目。 私有项目：只有授权用户才可以访问，通常存放项目本身的镜像。<br>我们可以为微服务项目创建一个新的项目</p>
<ul>
<li><p>创建用户 创建的用户为：eric   Eric123456</p>
</li>
<li><p>给私有项目分配用户</p>
<p>进入tensquare项目→成员→新建用户→eric为维护人员</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>权限说明</th>
</tr>
</thead>
<tbody><tr>
<td>访客</td>
<td>对于指定项目拥有只读权限</td>
</tr>
<tr>
<td>开发人员</td>
<td>对于指定项目拥有读写权限</td>
</tr>
<tr>
<td>维护人员</td>
<td>对于指定项目拥有读写权限，创建Webhooks</td>
</tr>
<tr>
<td>项目管理员</td>
<td>除了读写权限，同时拥有用户管理&#x2F;镜像扫描等管理权限</td>
</tr>
</tbody></table>
<ul>
<li>以新用户登录Harbor</li>
</ul>
<h5 id="把镜像上传到Harbor"><a href="#把镜像上传到Harbor" class="headerlink" title="把镜像上传到Harbor"></a>把镜像上传到Harbor</h5><ul>
<li><p>给镜像打上标签</p>
<blockquote>
<p>docker tag eureka:v1 192.168.200.131:85&#x2F;tensquare&#x2F;eureka:v1</p>
</blockquote>
</li>
<li><p>推送镜像</p>
<blockquote>
<p>docker push 192.168.200.131:85&#x2F;tensquare&#x2F;eureka:v1</p>
<hr>
<p>The push refers to repository [192.168.66.102:85&#x2F;tensquare&#x2F;eureka] Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS  client</p>
</blockquote>
<p>这时会出现以上报错，是因为 Docker没有把Harbor加入信任列表中</p>
</li>
<li><p>把Harbor地址加入到Docker信任列表<br><code>cd /etc/docker</code></p>
<p><code>vi daemon.json</code></p>
<blockquote>
<p>{<br>“registry-mirrors”: [“<a href="https://zydiol88.mirror.aliyuncs.com&quot;]">https://zydiol88.mirror.aliyuncs.com&quot;]</a>,<br>“insecure-registries”: [“192.168.200.131:85”]<br>}</p>
</blockquote>
</li>
</ul>
<p>​       需要重启Docker<br>​      <code>systemctl restart docker</code></p>
<ul>
<li><p>再次执行推送命令，会显示权限不足</p>
<p><code>docker push 192.168.200.131:85/tensquare/eureka:v1</code></p>
<blockquote>
<p>denied: requested access to the resource is denied</p>
</blockquote>
<p>需要先登录 Harbor，再推送镜像</p>
</li>
<li><p>登录Harbor</p>
<p><code> docker login -u eric -p Eric123456 192.168.200.131:85</code> </p>
</li>
<li><p>再次push</p>
<p><code>docker push 192.168.200.131:85/tensquare/eureka:v1</code></p>
</li>
</ul>
<h5 id="从Harbor下载镜像"><a href="#从Harbor下载镜像" class="headerlink" title="从Harbor下载镜像"></a>从Harbor下载镜像</h5><p>需求：在192.168.200.130服务器完成从Harbor下载镜像</p>
<ul>
<li><p>安装并启动Docker</p>
</li>
<li><p>修改Docker配置</p>
<p><code>vi /etc/docker/daemon.json</code></p>
<pre><code class="yaml">&#123;
 &quot;registry-mirrors&quot;: [&quot;https://zydiol88.mirror.aliyuncs.com&quot;],
 &quot;insecure-registries&quot;: [&quot;192.168.66.102:85&quot;]
&#125;
</code></pre>
<p>重启docker：<code>systemctl restart docker</code></p>
</li>
<li><p>先登录，再从Harbor下载镜像</p>
<p><code> docker login -u eric -p Eric123456 192.168.200.131:85</code><br><code>docker pull 192.168.200.131:85/tensquare/eureka:v1</code></p>
</li>
</ul>
<h4 id="微服务持续集成-1-项目代码上传到Gitlab"><a href="#微服务持续集成-1-项目代码上传到Gitlab" class="headerlink" title="微服务持续集成(1)-项目代码上传到Gitlab"></a>微服务持续集成(1)-项目代码上传到Gitlab</h4><p>在IDEA操作即可，参考之前的步骤。包括后台微服务(tensquare_back)和前端web网站(tensquare_front)代码<br>[<u>lanyun_group · GitLab</u>] (<a target="_blank" rel="noopener" href="http://192.168.200.132:82/lanyun_group">http://192.168.200.132:82/lanyun_group</a>)</p>
<h4 id="微服务持续集成-2-从Gitlab拉取项目源码后台微服务的持续集成"><a href="#微服务持续集成-2-从Gitlab拉取项目源码后台微服务的持续集成" class="headerlink" title="微服务持续集成(2)-从Gitlab拉取项目源码后台微服务的持续集成"></a>微服务持续集成(2)-从Gitlab拉取项目源码<del>后台微服务的持续集成</del></h4><p>先去Jenkins里面创建一个<code>tensquare_back</code>的流水线 → 流水线定义选择<code>Pipeline script form SCM</code><del>脚本文件放在项目根目录下</del> → SCM选择<code>Git</code>拉取脚本文件 → 在根目录下创建一个Jenkinsfile → 用流水线语法写’拉取代码’的语法 → ↓</p>
<pre><code class="yaml">stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &#39;*/master&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_back.git&#39;]])
   &#125;
</code></pre>
<p>→ 修改语法代码里的 name: ‘*&#x2F;master’ 为可变参数 → 去流水线的配置里 勾选<code>This project is parameterized</code> → 添加参数选择<code>String Parameter</code>  → 名称:branch   默认值:master  描述:请输入一个分支名称 →  修改里面的参数为动态的 →↓</p>
<pre><code class="yaml">   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &#39;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&#39;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_back.git&#39;]])
   &#125;
</code></pre>
<p>→ 将后面的<code>credentialsId</code>和<code>url</code>可以定义为脚本参数全局引用 → ↓</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
&#125;
</code></pre>
<p>构建即可成功！！ 可以去Moba的<code>/var/lib/jenkins/workspace/</code>查看是否有<code>tensquare_back</code></p>
<h4 id="微服务持续集成-3-提交到SonarQube代码审查"><a href="#微服务持续集成-3-提交到SonarQube代码审查" class="headerlink" title="微服务持续集成(3)-提交到SonarQube代码审查"></a>微服务持续集成(3)-提交到SonarQube代码审查</h4><ul>
<li><h5 id="创建项目，并设置参数"><a href="#创建项目，并设置参数" class="headerlink" title="创建项目，并设置参数"></a>创建项目，并设置参数</h5></li>
</ul>
<p>创建tensquare_back项目，添加两个参数 → 在流水线上设置里选择<code>choice Parameter</code> → 名称:project_name；选项:tensquare_eureka_server、tensquare_zuul、tensquare_admin_service、tensquare_gathering；描述:请选择一个构建的项目</p>
<ul>
<li><h5 id="每个项目的根目录下添加sonar-project-properties"><a href="#每个项目的根目录下添加sonar-project-properties" class="headerlink" title="每个项目的根目录下添加sonar-project.properties"></a>每个项目的根目录下添加<code>sonar-project.properties</code></h5></li>
</ul>
<pre><code class="yaml">eureka_server   gathering   admin_service   zuul
只需要改里面的projectName和projectKey即可

# must be unique in a given SonarQube instance
sonar.projectKey=tensquare_eureka_server
# this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.
sonar.projectName=tensquare_eureka_server
sonar.projectVersion=1.0

# Path is relative to the sonar-project.properties file. Replace &quot;\&quot; by &quot;/&quot; on Windows.
# This property is optional if sonar.modules is set.
sonar.sources=.
sonar.exclusions=**/test/**,**/target/**
sonar.java.binaries=.

sonar.java.source=1.8
sonar.java.target=1.8
#sonar.java.libraries=**/target/classes/**

# Encoding of the source code. Default is default system encoding
sonar.sourceEncoding=UTF-8
</code></pre>
<ul>
<li><h5 id="修改jenkinsfile构建脚本"><a href="#修改jenkinsfile构建脚本" class="headerlink" title="修改jenkinsfile构建脚本"></a>修改jenkinsfile构建脚本</h5></li>
</ul>
<p>要在Jenkins的全局Tools管理里面 有SonarQube Scanner安装<br>Jenkins全局的system里面有定义sonarqube的url</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
&#125;
</code></pre>
<h3 id="微服务持续集成-4-使用Dockerfile编译、生成镜像"><a href="#微服务持续集成-4-使用Dockerfile编译、生成镜像" class="headerlink" title="微服务持续集成(4)-使用Dockerfile编译、生成镜像"></a>微服务持续集成(4)-使用Dockerfile编译、生成镜像</h3><h6 id="利用dockerfile-maven-plugin插件构建Docker镜像"><a href="#利用dockerfile-maven-plugin插件构建Docker镜像" class="headerlink" title="利用dockerfile-maven-plugin插件构建Docker镜像"></a>利用dockerfile-maven-plugin插件构建Docker镜像</h6><ul>
<li>在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件</li>
</ul>
<pre><code class="yaml">&lt;plugin&gt;
                &lt;groupId&gt;com.spotify&lt;/groupId&gt;
                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.6&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;repository&gt;$&#123;project.artifactId&#125;&lt;/repository&gt;
                    &lt;buildArgs&gt;
                        &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;
                    &lt;/buildArgs&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
</code></pre>
<ul>
<li>修改Jenkinsfile让他根据参数打包微服务工程</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package&quot;
    &#125;
&#125;
</code></pre>
<ul>
<li>父工程的pom.xml要改一个过时的代码</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.tensquare&lt;/groupId&gt;
    &lt;artifactId&gt;tensquare_parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;tensquare_common&lt;/module&gt;
        &lt;module&gt;tensquare_eureka_server&lt;/module&gt;
        &lt;module&gt;tensquare_zuul&lt;/module&gt;
        &lt;module&gt;tensquare_admin_service&lt;/module&gt;
        &lt;module&gt;tensquare_gathering&lt;/module&gt;
    &lt;/modules&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;!-- ✅ 推荐使用正式版本 Finchley.SR4 --&gt;
        &lt;spring-cloud.version&gt;Finchley.SR4&lt;/spring-cloud.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;!-- 可选：保留 spring-milestones --&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>通过MoBa把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\tensquare_parent</code>的<code>tensquare_parent</code>项目保存到<code>/root/repo/com/tensquare/</code>里</li>
<li>随后通过步骤二，构建所有的工程 → <strong>打包所有微服务的工程</strong> → 在Jenkins虚拟机的<code>/var/lib/jenkins/workspace/tensquare_back/</code>这里面的各个项目的<code>target</code>里面打包了刚刚微服务的所有构建东西</li>
</ul>
<h4 id="微服务持续集成-4-使用Dockerfile编译、生成镜像-1"><a href="#微服务持续集成-4-使用Dockerfile编译、生成镜像-1" class="headerlink" title="微服务持续集成(4)-使用Dockerfile编译、生成镜像"></a>微服务持续集成(4)-使用Dockerfile编译、生成镜像</h4><p>利用dockerfile-maven-plugin插件构建Docker镜像</p>
<ul>
<li>在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件</li>
</ul>
<pre><code class="xml"> &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;com.spotify&lt;/groupId&gt;
                &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.6&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;repository&gt;$&#123;project.artifactId&#125;&lt;/repository&gt;
                    &lt;buildArgs&gt;
                        &lt;JAR_FILE&gt;target/$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt;
                    &lt;/buildArgs&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<ul>
<li>在dockerfile父目录文件中增加一个<code>...dockerfile:build</code>去触发每个微服务项目的dockerfile执行【用流水线进行镜像构建】</li>
</ul>
<pre><code class="xml">    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
    &#125;
</code></pre>
<p>全部构建完成后就大功告成！！！</p>
<pre><code class="yaml">[root@localhost docker]# docker images
REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE
tensquare_gathering                   latest              a62362e8dc2f        8 minutes ago       155MB
tensquare_admin_service               latest              ee2a85292e98        9 minutes ago       156MB
tensquare_eureka_server               latest              2a78c4a12fc4        11 minutes ago      148MB
tensquare_zuul                        latest              33bf136ee3cb        12 minutes ago      146MB
eureka                                v2                  2c9a3610123d        24 hours ago        150MB
192.168.200.131:85/tensquare/eureka   v1                  e85b5d3d9090        25 hours ago        150MB
eureka                                v1                  e85b5d3d9090        25 hours ago        150MB
nginx                                 latest              9592f5595f2b        8 days ago          192MB
hello-world                           latest              74cc54e27dc4        5 months ago        10.1kB
openjdk                               8-jdk-alpine        a3562aa0b991        6 years ago         105MB
</code></pre>
<hr>
<h4 id="微服务持续集成-5-上传到Harbor镜像仓库"><a href="#微服务持续集成-5-上传到Harbor镜像仓库" class="headerlink" title="微服务持续集成(5)-上传到Harbor镜像仓库"></a>微服务持续集成(5)-上传到Harbor镜像仓库</h4><ul>
<li>修改<code>Jenkinsfile.groovy</code>构建脚本</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;
    &#125;
&#125;
</code></pre>
<p>此时再去构建一个项目在Jenkins虚拟机服务的镜像里就会出现按照规则打好tag的镜像</p>
<blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY                                             TAG                 IMAGE ID            CREATED              SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              e19b4ba07d54        About a minute ago   148MB</p>
</blockquote>
<ul>
<li><h5 id="把镜像推送到Harbor-要登录-输入账号密码-不要写在脚本文件-把harbor账号密码用jenkins全局凭证"><a href="#把镜像推送到Harbor-要登录-输入账号密码-不要写在脚本文件-把harbor账号密码用jenkins全局凭证" class="headerlink" title="把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)"></a>把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)</h5></li>
</ul>
<p>去Jenkins申请一个全局的凭证，ID：<code>f83725d3-d5fc-4faf-8ac1-1a56487dfc7b</code><br>怎么在jenkinsfile里面使用呢？要用流水线语法的片段生成器 <code>withCredentials：Bind credentials to variables</code>[<u>借助凭证进行脚本处理</u>] (如果没有显示绑定 就刷新一下界面)；选择<code>绑定</code>→<u><code>用户名变量：username</code> <code>密码变量：password</code></u> 这个是引用的刚刚创立的<code>eric_harbor-auth</code>凭证</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<p>此时harbor的tensquare中镜像仓库就有了<code>tensquare/tensquare_eureka_server</code></p>
<h4 id="微服务持续集成-6-拉取镜像和发布应用"><a href="#微服务持续集成-6-拉取镜像和发布应用" class="headerlink" title="微服务持续集成(6)-拉取镜像和发布应用"></a>微服务持续集成(6)-拉取镜像和发布应用</h4><h6 id="安装-Publish-Over-SSH-插件目的是想把129Jenkins和130product进行连通"><a href="#安装-Publish-Over-SSH-插件目的是想把129Jenkins和130product进行连通" class="headerlink" title="安装  Publish Over SSH 插件目的是想把129Jenkins和130product进行连通"></a>安装  <code>Publish Over SSH 插件</code><del>目的是想把129Jenkins和130product进行连通</del></h6><p>安装此插件可以实现远程发送Shell命令</p>
<p>随后去全局system寻找<code>Publish over SSH</code></p>
<p>在product虚拟机：<code>id_rsa是私钥</code>，<code>id_rsa.pub是公钥</code></p>
<pre><code class="yaml">[root@localhost ~]# cd /root/.ssh
[root@localhost .ssh]# ll
总用量 12
-rw-------. 1 root root 1679 6月  18 20:05 id_rsa
-rw-r--r--. 1 root root  408 6月  18 20:05 id_rsa.pub
-rw-r--r--. 1 root root  177 6月  18 21:00 known_hosts
[root@localhost .ssh]#
</code></pre>
<p>输入<code>[root@localhost .ssh]# ssh-keygen -y -f /root/.ssh/id_rsa</code>会显示私钥<br>如果直接输出 <code>ssh-rsa AAAA...</code> 这样的公钥内容 → 说明<strong>没有加密</strong>，Jenkins 中可以把 <code>Passphrase</code> 留空<br>下面添加一台远程服务器<code>SSH Servers</code></p>
<blockquote>
<p>Name：master_server<br>Hostname：192.168.200.130<br>Username：root<br>Remote Directory：&#x2F;</p>
</blockquote>
<h6 id="配置远程部署服务器"><a href="#配置远程部署服务器" class="headerlink" title="配置远程部署服务器"></a>配置远程部署服务器</h6><ul>
<li>拷贝公钥到远程服务器</li>
</ul>
<blockquote>
<p>是的，你遇到的错误：</p>
<pre><code>Failed to connect session for config [master_server]. Message [Auth fail for methods &#39;publickey,gssapi-keyex,gssapi-with-mic,password&#39;]
</code></pre>
<p><strong>说明 Jenkins 使用你提供的私钥连接远程服务器失败</strong>。这个问题一般由以下几种原因导致：</p>
<hr>
<h2 id="✅【推荐方案】重新生成兼容格式的私钥（PEM）"><a href="#✅【推荐方案】重新生成兼容格式的私钥（PEM）" class="headerlink" title="✅【推荐方案】重新生成兼容格式的私钥（PEM）"></a>✅【推荐方案】重新生成兼容格式的私钥（PEM）</h2><p>你看到的建议：</p>
<blockquote>
<pre><code>ssh-keygen -m PEM -t rsa -b 4096
</code></pre>
</blockquote>
<p>是完全正确的，因为：</p>
<ul>
<li>Jenkins 使用的 <strong>Java SSH 实现</strong>（JSch 或 Trilead）<strong>不支持 OpenSSH 的新私钥格式（RFC4716）</strong>；</li>
<li><code>-m PEM</code> 表示使用旧版兼容格式（Jenkins 能识别）；</li>
<li><code>-t rsa -b 4096</code> 表示生成 RSA 4096 位密钥。</li>
</ul>
<hr>
<h3 id="✅-重新生成-SSH-密钥步骤如下"><a href="#✅-重新生成-SSH-密钥步骤如下" class="headerlink" title="✅ 重新生成 SSH 密钥步骤如下"></a>✅ 重新生成 SSH 密钥步骤如下</h3><ol>
<li>在 Jenkins 所在机器上执行（推荐使用 <code>jenkins</code> 用户身份，不要用 root）：</li>
</ol>
<pre><code>ssh-keygen -m PEM -t rsa -b 4096 -C &quot;jenkins@tensquare&quot; -f ~/.ssh/id_rsa_jenkins
</code></pre>
<p>过程中会问你是否设置密码（passphrase），你可以 <strong>直接回车留空</strong>。</p>
<p>生成后会有两个文件：</p>
<pre><code>~/.ssh/id_rsa_jenkins       ← 私钥（复制给 Jenkins）
~/.ssh/id_rsa_jenkins.pub   ← 公钥（配置到目标服务器）
</code></pre>
<hr>
<ol>
<li><strong>把公钥内容添加到远程主机的 authorized_keys 中</strong></li>
</ol>
<pre><code>cat ~/.ssh/id_rsa_jenkins.pub | ssh root@192.168.200.130 &quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;
</code></pre>
<p>或者你手动将 <code>id_rsa_jenkins.pub</code> 内容添加到 <code>/root/.ssh/authorized_keys</code> 中。</p>
<hr>
<ol>
<li><strong>Jenkins 中配置 SSH 连接</strong></li>
</ol>
<p>在 Jenkins → <code>Manage Jenkins</code> → <code>Configure System</code> → <code>Publish over SSH</code>：</p>
<ul>
<li><strong>Path to Key</strong>：填入 <code>/root/.ssh/id_rsa_jenkins</code>（或你放的实际路径）</li>
<li><strong>Key</strong>：可留空（有 Path 即可）</li>
<li><strong>Passphrase</strong>：如果你上面生成时留空，这里也留空</li>
<li><strong>Name</strong>：master_server</li>
<li><strong>Hostname</strong>：192.168.200.130</li>
<li><strong>Username</strong>：root（或其他你授权了公钥的用户）</li>
<li><strong>Remote Directory</strong>：比如 <code>/home/jenkins-deploy</code> 或 <code>/root/</code>或<code>/</code></li>
</ul>
<p>✔ 点击 <code>Test Configuration</code> 测试成功为止</p>
</blockquote>
<ul>
<li><p>查看流水线语法</p>
<p>因为新下载那个插件后需要重启Jenkins。然后<br>步骤<code>sshPublisher:Send build artifacts overSSH</code> 直接生成流水线脚本后融入Jenkinsfile文件中</p>
<blockquote>
<p>SSH Server<br>Name：master_server</p>
</blockquote>
</li>
</ul>
<p>里面的<code>$port</code>需要搞成可变参数 去Jenkins里面添加一个参数</p>
<blockquote>
<p>名称：port<br>默认值：10086<br>描述：请输入一个对应服务的端口</p>
</blockquote>
<p>在生产虚拟机先<code>[root@localhost ~]# mkdir /opt/jenkins_shell</code>然后把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\部署脚本</code>的<code>deploy.sh</code>传入 之后添加执行权限<code>[root@localhost jenkins_shell]# chmod +x deploy.sh</code></p>
<h5 id="成功！！！"><a href="#成功！！！" class="headerlink" title="成功！！！"></a>成功！！！</h5><blockquote>
<p>[root@localhost jenkins_shell]# docker images<br>REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka   v1                  e85b5d3d9090        44 hours ago        150MB<br>[root@localhost jenkins_shell]# docker ps<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</p>
<hr>
<p>[root@localhost jenkins_shell]# docker images</p>
<p>REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              60d020191110        35 seconds ago      148MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka                    v1                  e85b5d3d9090        44 hours ago        150MB<br>[root@localhost jenkins_shell]# docker ps<br>CONTAINER ID        IMAGE                                                         COMMAND                CREATED             STATUS              PORTS                      NAMES<br>b934523c60da        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server:latest   “java -jar &#x2F;app.jar”   33 seconds ago      Up 30 seconds       0.0.0.0:10086-&gt;10086&#x2F;tcp   focused_boyd</p>
</blockquote>
<p>成功访问：[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>)</p>
<p>如果要下载其他镜像 需要把每个服务的<code>application.yml</code>更改连接地址</p>
<blockquote>
<p>更改所有服务的application.yml地址<br>sonarqube的是129里面有mysql<br>eureka的是130用的生产虚拟服务器</p>
</blockquote>
<blockquote>
<p>那我微服务里的application.yml server:   port: 9001 spring:   application:      name: tensquare-admin-service #指定服务名  datasource:      driverClassName: com.mysql.jdbc.Driver    url: jdbc:mysql:&#x2F;&#x2F;192.168.200.129&#x2F;tensquare_user?characterEncoding&#x3D;UTF8    username: root    password: root  jpa:     database: mysql    show-sql: true 这样写可以吗</p>
<p><code>那个192.168.200.129:3306/</code>回答：</p>
<ul>
<li><strong>如果你的微服务运行环境和 MySQL 在同一局域网内，且 192.168.200.129 是 MySQL 服务所在虚拟机的有效IP，且网络是通的，端口 3306 没被防火墙拦截，NAT或者桥接配置无误，使用这个 IP 和端口是完全没问题的。</strong></li>
<li>也就是说，如果你从微服务所在的机器能 ping 通 <code>192.168.200.129</code> 并且 <code>telnet 192.168.200.129 3306</code> 可以连通，就可以这么写。</li>
</ul>
<hr>
<h3 id="你需要确认的："><a href="#你需要确认的：" class="headerlink" title="你需要确认的："></a>你需要确认的：</h3><ol>
<li><strong>你的微服务运行在哪台机器？</strong><ul>
<li>如果微服务也在虚拟机里（同一台虚拟机或同一内网），用虚拟机的IP写就对。</li>
<li>如果微服务在宿主机，且虚拟机用的是 NAT 模式，你必须确认端口映射存在，否则宿主机连这个 IP 3306 不通（原因是 NAT 隔离）。这时用虚拟机私有 IP 直接连接是不行的。</li>
</ul>
</li>
<li><strong>网络连通性</strong><ul>
<li>微服务所在机器能 <code>ping</code> 通该 IP。</li>
<li>能 <code>telnet IP 3306</code> 连通。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>只要网络通，端口放通，<code>jdbc:mysql://192.168.200.129:3306/数据库名</code> 写法就是标准且正确的。</strong></li>
<li>如果网络不通，就要调整网络配置（比如桥接、端口映射），或者改用 <code>localhost</code>、<code>127.0.0.1</code> 访问本机MySQL。</li>
</ul>
</blockquote>
<h6 id="分别构建其余的几个微服务项目-记住port端口是要跟application-yml里面一致的"><a href="#分别构建其余的几个微服务项目-记住port端口是要跟application-yml里面一致的" class="headerlink" title="分别构建其余的几个微服务项目 记住port端口是要跟application.yml里面一致的"></a>分别构建其余的几个微服务项目 记住port端口是要跟application.yml里面一致的</h6><blockquote>
<p>[root@localhost ~]# docker images<br>REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_gathering       latest              c700a6359fce        33 seconds ago      155MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service   latest              92453ab6e765        2 minutes ago       156MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_zuul            latest              122afd78d6ef        3 minutes ago       146MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server   latest              60d020191110        4 hours ago         148MB<br>192.168.200.131:85&#x2F;tensquare&#x2F;eureka                    v1                  e85b5d3d9090        2 days ago          150MB</p>
<hr>
<p>[root@localhost ~]# docker ps<br>CONTAINER ID        IMAGE                                                         COMMAND                  CREATED              STATUS              PORTS                      NAMES<br>aa2178c7dd0d        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_gathering:latest       “java -Djava.net.pre…”   About a minute ago   Up 59 seconds       0.0.0.0:9002-&gt;9002&#x2F;tcp     nostalgic_lichterman<br>14e040066165        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service:latest   “java -Djava.net.pre…”   2 minutes ago        Up 2 minutes        0.0.0.0:9001-&gt;9001&#x2F;tcp     dreamy_montalcini<br>8143d8ccbeee        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_zuul:latest            “java -Djava.net.pre…”   3 minutes ago        Up 3 minutes        0.0.0.0:10020-&gt;10020&#x2F;tcp   gracious_kalam<br>b934523c60da        192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_eureka_server:latest   “java -jar &#x2F;app.jar”     4 hours ago          Up 4 hours          0.0.0.0:10086-&gt;10086&#x2F;tcp   focused_boyd</p>
<p>你这个情况是镜像有了，但是没有运行的容器，所以要启动镜像，创建并运行容器。</p>
<h3 id="启动镜像★★的基本命令是：-Jenkins-129服务器"><a href="#启动镜像★★的基本命令是：-Jenkins-129服务器" class="headerlink" title="启动镜像★★的基本命令是：[Jenkins 129服务器]"></a>启动镜像★★的基本命令是：[Jenkins 129服务器]</h3><pre><code>docker run -d -p &lt;宿主机端口&gt;:&lt;容器端口&gt; --name &lt;容器名字&gt; &lt;镜像名&gt;
</code></pre>
<p>直接启动无需重新创建容器：<br>先查看所有容器(包括已停止的)：<code>docker ps -a</code></p>
<blockquote>
<p>docker start tensquare_admin_service<br>docker start tensquare_gathering<br>docker start tensquare_zuul<br>docker start tensquare_eureka_server</p>
</blockquote>
<p>若需要删除再重新启动</p>
<p>举个例子：</p>
<blockquote>
<p>先删除之前的容器：<br>docker rm tensquare_admin_service<br>docker rm tensquare_gathering<br>docker rm tensquare_zuul<br>docker rm tensquare_eureka_server</p>
</blockquote>
<pre><code>docker run -d -p 9001:9101 --name tensquare_admin_service 192.168.200.131:85/tensquare/tensquare_admin_service:latest
docker run -d -p 9002:9002 --name tensquare_gathering 192.168.200.131:85/tensquare/tensquare_gathering:latest
docker run -d -p 10020:10020 --name tensquare_zuul 192.168.200.131:85/tensquare/tensquare_zuul:latest
docker run -d -p 10086:10086 --name tensquare_eureka_server 192.168.200.131:85/tensquare/tensquare_eureka_server:latest
</code></pre>
<blockquote>
<p>[root@localhost ~]# docker rm -f tensquare_admin_service<br>tensquare_admin_service<br>[root@localhost ~]# docker run -d -p 9101:9001 –name tensquare_admin_service 192.168.200.131:85&#x2F;tensquare&#x2F;tensquare_admin_service:latest<br>634a31582dc81acf34b101d468d84b1c3f92b75477b6ad469abe00dc09821d4b<br>[root@localhost ~]#</p>
</blockquote>
<blockquote>
<p>端口映射要根据你的程序监听端口设定，否则外部访问不到容器服务。</p>
</blockquote>
<h3 id="此时也要在生产130服务器上去重新启动那些容器"><a href="#此时也要在生产130服务器上去重新启动那些容器" class="headerlink" title="此时也要在生产130服务器上去重新启动那些容器"></a>此时也要在生产130服务器上去重新启动那些容器</h3><blockquote>
<h3 id="✅-1-重启-130-上的容器"><a href="#✅-1-重启-130-上的容器" class="headerlink" title="✅ 1. 重启 130 上的容器"></a>✅ <strong>1. 重启 130 上的容器</strong></h3><p>可以用 <code>docker start 容器ID或容器名</code> 重启：</p>
<pre><code>bash复制编辑docker start e55957d0a79e  # gathering
docker start 3c8592621ab7  # admin_service
docker start 43a7ca513e37  # zuul
docker start 831aeb331519  # eureka
</code></pre>
<p>或者统一启动：</p>
<pre><code>bash


复制编辑
docker start $(docker ps -a -q)
</code></pre>
</blockquote>
<hr>
<hr>
<hr>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>停止容器：</p>
<pre><code>docker stop 容器ID或容器名
</code></pre>
<p>删除容器：</p>
<pre><code>docker rm 容器ID或容器名
</code></pre>
<h3 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3. 删除镜像"></a>3. 删除镜像</h3><p>删除有标签的镜像：</p>
<pre><code>docker rmi 192.168.200.131:85/tensquare/tensquare_gathering
docker rmi tensquare_gathering
</code></pre>
<p>删除无标签的悬空镜像：</p>
<pre><code>docker rmi 08b0a9196df2
</code></pre>
<h3 id="4-如果有多个无标签镜像，删除所有悬空镜像"><a href="#4-如果有多个无标签镜像，删除所有悬空镜像" class="headerlink" title="4. 如果有多个无标签镜像，删除所有悬空镜像"></a>4. 如果有多个无标签镜像，删除所有悬空镜像</h3><pre><code>docker image prune
</code></pre>
</blockquote>
<p>[生产]：[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>)</p>
<blockquote>
<h5 id="Instances-currently-registered-with-Eureka"><a href="#Instances-currently-registered-with-Eureka" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h5><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>TENSQUARE-ADMIN-SERVICE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.4:9001/actuator/info">14e040066165:tensquare-admin-service:9001</a></td>
</tr>
<tr>
<td align="left"><strong>TENSQUARE-GATHERING</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.5:9002/actuator/info">aa2178c7dd0d:tensquare-gathering:9002</a></td>
</tr>
<tr>
<td align="left"><strong>TENSQUARE-ZUUL</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://172.17.0.3:10020/actuator/info">8143d8ccbeee:tensquare-zuul:10020</a></td>
</tr>
</tbody></table>
</blockquote>
<h6 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h6><pre><code class="java">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
      def scannerHome = tool &#39;sonar-scanner&#39;
      //引用当前JenkinsSonarQube环境 Jenkins的System里
      withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
      // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
                sh &quot;&quot;&quot;
                    cd $&#123;project_name&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
        // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
        // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
        sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
    &#125;
&#125;
</code></pre>
<h6 id="deploy-sh"><a href="#deploy-sh" class="headerlink" title="deploy.sh"></a>deploy.sh</h6><pre><code class="java">#! /bin/sh
#接收外部参数
harbor_url=$1
harbor_project_name=$2
project_name=$3
tag=$4
port=$5

imageName=$harbor_url/$harbor_project_name/$project_name:$tag

echo &quot;$imageName&quot;

#查询容器是否存在，存在则删除
containerId=`docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125;  | awk &#39;&#123;print $1&#125;&#39;`
if [ &quot;$containerId&quot; !=  &quot;&quot; ] ; then
    #停掉容器
    docker stop $containerId

    #删除容器
    docker rm $containerId
    
    echo &quot;成功删除容器&quot;
fi

#查询镜像是否存在，存在则删除
imageId=`docker images | grep -w $project_name  | awk &#39;&#123;print $3&#125;&#39;`

if [ &quot;$imageId&quot; !=  &quot;&quot; ] ; then
      
    #删除镜像
    docker rmi -f $imageId
    
    echo &quot;成功删除镜像&quot;
fi

# 登录Harbor
docker login -u eric -p Eric123456 $harbor_url

# 下载镜像
docker pull $imageName

# 启动容器
docker run -di -p $port:$port $imageName

echo &quot;容器启动成功&quot;
</code></pre>
<h5 id="连接数据库的时候有问题"><a href="#连接数据库的时候有问题" class="headerlink" title="连接数据库的时候有问题"></a>连接数据库的时候有问题</h5><blockquote>
<p>[root@localhost ~]# &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld –initialize –user&#x3D;mysql –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql 2025-07-04T10:46:28.109697Z 0 [Warning] [MY-011070] [Server] ‘Disabling symbolic links using –skip-symbolic-links (or equivalent) is the default. Consider not using this option as it’ is deprecated and will be removed in a future release. 2025-07-04T10:46:28.110588Z 0 [System] [MY-013169] [Server] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld (mysqld 8.0.30) initializing of server in progress as process 31821 2025-07-04T10:46:28.115123Z 0 [ERROR] [MY-010457] [Server] –initialize specified but the data directory has files in it. Aborting. 2025-07-04T10:46:28.115149Z 0 [ERROR] [MY-013236] [Server] The designated data directory &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; is unusable. You can remove all files that the server added to it. 2025-07-04T10:46:28.115231Z 0 [ERROR] [MY-010119] [Server] Aborting 2025-07-04T10:46:28.115717Z 0 [System] [MY-010910] [Server] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld: Shutdown complete (mysqld 8.0.30)  MySQL Community Server - GPL. [root@localhost ~]#</p>
<h6 id="ChatGPT-说：-3"><a href="#ChatGPT-说：-3" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>报错很明确：</p>
<pre><code>--initialize specified but the data directory has files in it. Aborting.
</code></pre>
<p>意思是：你指定的 <code>/var/lib/mysql</code> 目录 <strong>里面已经有文件了</strong>，所以初始化被拒绝了。</p>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-备份或清空-var-lib-mysql-目录"><a href="#1-备份或清空-var-lib-mysql-目录" class="headerlink" title="1. 备份或清空 /var/lib/mysql 目录"></a>1. 备份或清空 <code>/var/lib/mysql</code> 目录</h3><p>如果你确认目录里面的数据可以删除（或者你已经备份了重要数据），执行：</p>
<pre><code>rm -rf /var/lib/mysql/*
</code></pre>
<p>确保目录下文件都删干净。</p>
<hr>
<h3 id="2-再次执行初始化"><a href="#2-再次执行初始化" class="headerlink" title="2. 再次执行初始化"></a>2. 再次执行初始化</h3><pre><code>/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/var/lib/mysql
</code></pre>
<p>这次应该会成功。</p>
<hr>
<h3 id="3-启动-MySQL-服务"><a href="#3-启动-MySQL-服务" class="headerlink" title="3. 启动 MySQL 服务"></a>3. 启动 MySQL 服务</h3><pre><code>systemctl start mysql
</code></pre>
<hr>
<h3 id="4-查看状态和日志，确保启动成功"><a href="#4-查看状态和日志，确保启动成功" class="headerlink" title="4. 查看状态和日志，确保启动成功"></a>4. 查看状态和日志，确保启动成功</h3><pre><code>systemctl status mysql
tail -n 50 /var/log/mariadb/mariadb.log
</code></pre>
<hr>
<p>如果你担心误删数据，可以先备份目录：</p>
<pre><code>mv /var/lib/mysql /var/lib/mysql_backup_$(date +%F_%T)
mkdir /var/lib/mysql
chown mysql:mysql /var/lib/mysql
</code></pre>
<p>然后再初始化。</p>
<p>这样启动<code>mysql -uroot -p --socket=/var/lib/mysql/mysql.sock</code></p>
<hr>
<hr>
<hr>
<p><strong>宿主机（Windows）通过 NAT 模式连接虚拟机的正确姿势不是直接用虚拟机IP，而是用映射到宿主机的端口。</strong></p>
<hr>
<h4 id="你当前用的："><a href="#你当前用的：" class="headerlink" title="你当前用的："></a>你当前用的：</h4><pre><code>mysql -uroot -proot -h192.168.200.129 -P3306
</code></pre>
<p>这是虚拟机的私有IP，NAT模式下外部访问是被隔离的，直接连这个IP不通。</p>
<hr>
<h3 id="正确做法："><a href="#正确做法：" class="headerlink" title="正确做法："></a>正确做法：</h3><ol>
<li>在 VMware 的 NAT 设置里添加端口转发规则，把宿主机的某个端口（比如3306）转发到虚拟机的3306端口。</li>
<li>宿主机连接时，用 <code>127.0.0.1</code>（或者 <code>localhost</code>）加端口访问。</li>
</ol>
<p>例如：</p>
<pre><code>mysql -uroot -proot -h127.0.0.1 -P3306
</code></pre>
<hr>
<h3 id="如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。"><a href="#如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。" class="headerlink" title="如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。"></a>如果你想用虚拟机的私有IP直接连接，建议改成桥接网卡。</h3><hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>你的 MySQL 配置没问题了</li>
<li>NAT模式下宿主机访问虚拟机MySQL必须用端口转发+127.0.0.1</li>
<li>或切换桥接，直接用虚拟机IP访问</li>
</ul>
<hr>
<h2 id="✅-查看容器日志命令："><a href="#✅-查看容器日志命令：" class="headerlink" title="✅ 查看容器日志命令："></a>✅ 查看容器日志命令：</h2></blockquote>
<blockquote>
<pre><code>docker logs -f dreamy_montalcini
</code></pre>
<ul>
<li><code>-f</code> 表示 <strong>实时追踪日志</strong>，相当于 <code>tail -f</code> 的效果</li>
<li>如果你只想看最近的日志行数，比如 100 行：</li>
</ul>
<pre><code>docker logs --tail 100 dreamy_montalcini
</code></pre>
<hr>
<h3 id="✅-还可以用容器-ID："><a href="#✅-还可以用容器-ID：" class="headerlink" title="✅ 还可以用容器 ID："></a>✅ 还可以用容器 ID：</h3><pre><code>docker logs -f 14e040066165
</code></pre>
</blockquote>
<h4 id="如果mysql忘记密码了怎么办"><a href="#如果mysql忘记密码了怎么办" class="headerlink" title="如果mysql忘记密码了怎么办"></a>如果mysql忘记密码了怎么办</h4><blockquote>
<h3 id="✅-第一步：找出-mysqld-safe-路径"><a href="#✅-第一步：找出-mysqld-safe-路径" class="headerlink" title="✅ 第一步：找出 mysqld_safe 路径"></a>✅ 第一步：找出 <code>mysqld_safe</code> 路径</h3><p>所以系统找不到 <code>mysqld_safe</code> 命令。请执行下面命令找出它在哪：</p>
<pre><code>sudo find / -name mysqld_safe
</code></pre>
<p>它一般可能在 <code>/usr/bin/mysqld_safe</code> 或 <code>/usr/local/mysql/bin/mysqld_safe</code></p>
<p>找到后，比如它在 <code>/usr/local/mysql/bin/mysqld_safe</code>，那你这样启动 MySQL 跳过权限：</p>
<pre><code>sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables --skip-networking &amp;
</code></pre>
<p>然后 <strong>等待几秒钟（5-10s）</strong> 再执行：</p>
<pre><code>mysql -uroot
</code></pre>
</blockquote>
<blockquote>
<p>[root@localhost ~]# sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid &amp;<br>[1] 56721<br>[root@localhost ~]# 2025-07-04T13:53:36.378946Z mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>2025-07-04T13:53:36.468224Z mysqld_safe Starting mysqld daemon with databases from &#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>[root@localhost ~]# sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid &amp;<br>[2] 56935<br>[root@localhost ~]# 2025-07-04T13:53:48.624877Z mysqld_safe Logging to ‘&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log’.<br>2025-07-04T13:53:48.718002Z mysqld_safe A mysqld process already exists</p>
<p>[2]+  退出 1                sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>[root@localhost ~]# ps aux | grep mysqld<br>root      56721  0.0  0.0 241292   632 pts&#x2F;1    S    21:53   0:00 sudo &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>root      56723  0.1  0.0 113412   452 pts&#x2F;1    S    21:53   0:00 &#x2F;bin&#x2F;sh &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld_safe –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid<br>mysql     56861 22.2 18.1 1774388 339036 pts&#x2F;1  Sl   21:53   0:03 &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld –basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql –datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql –plugin-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib&#x2F;plugin –user&#x3D;mysql –log-error&#x3D;&#x2F;var&#x2F;log&#x2F;mariadb&#x2F;mariadb.log –pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid –socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock<br>root      57071  0.0  0.0 112828   988 pts&#x2F;1    S+   21:53   0:00 grep –color&#x3D;auto mysqld<br>[root@localhost ~]#</p>
</blockquote>
<h4 id="数据库修改策略权限以及让远程宿主机连接"><a href="#数据库修改策略权限以及让远程宿主机连接" class="headerlink" title="数据库修改策略权限以及让远程宿主机连接"></a>数据库修改策略权限以及让远程宿主机连接</h4><blockquote>
<p>mysql -uroot -p</p>
<p>SET GLOBAL validate_password_policy &#x3D; LOW;<br>SET GLOBAL validate_password_length &#x3D; 4;</p>
<p>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)</p>
<p>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.01 sec)</p>
<p>mysql&gt; select user, host from mysql.user where user&#x3D;’root’;<br>+——+————+<br>| user | host       |<br>+——+————+<br>| root | %          |<br>| root | 172.17.0.5 |<br>| root | localhost  |<br>+——+————+<br>3 rows in set (0.00 sec)</p>
</blockquote>
<blockquote>
<p>你给的 Spring Boot 配置文件（application.yml）大致结构是对的，不过结合你之前报错信息（MySQL 连接时出现 <span style = "color:red"><code>CommunicationsException</code>，SSL握手失败）和你的配置，有几点需要确认和调整：</span></p>
<hr>
<h3 id="1-MySQL-连接-URL-推荐加上参数，关闭-SSL"><a href="#1-MySQL-连接-URL-推荐加上参数，关闭-SSL" class="headerlink" title="1. MySQL 连接 URL 推荐加上参数，关闭 SSL"></a>1. MySQL 连接 URL 推荐加上参数，关闭 SSL</h3><p>默认情况下 MySQL Connector 可能会尝试用 SSL 连接，而你的报错就是 SSL 握手失败：</p>
<pre><code>Caused by: javax.net.ssl.SSLException: Received fatal alert: internal_error
</code></pre>
<p>解决办法是在 URL 中明确关闭 SSL，改成：</p>
<pre><code>spring:
  datasource:
    url: jdbc:mysql://192.168.200.129:3306/tensquare_user?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
</code></pre>
<ul>
<li><code>useSSL=false</code> 关闭 SSL 连接</li>
<li><code>serverTimezone=Asia/Shanghai</code> 解决时区警告（可选）</li>
<li><code>characterEncoding=UTF-8</code> 保持编码一致（注意大小写）</li>
</ul>
</blockquote>
<h4 id="微服务持续集成-7-部署前端静态web网站"><a href="#微服务持续集成-7-部署前端静态web网站" class="headerlink" title="微服务持续集成(7)-部署前端静态web网站"></a>微服务持续集成(7)-部署前端静态web网站</h4><p>129机器进行npm命令打包 → 远程传输文件 →(SSH远程调用)→ 130生产服务器Nginx</p>
<blockquote>
<h4 id="为什么用-Nginx-而不是直接用-Docker？"><a href="#为什么用-Nginx-而不是直接用-Docker？" class="headerlink" title="为什么用 Nginx 而不是直接用 Docker？"></a>为什么用 Nginx 而不是直接用 Docker？</h4><h5 id="①-Nginx-是专业的高性能静态文件服务器"><a href="#①-Nginx-是专业的高性能静态文件服务器" class="headerlink" title="① Nginx 是专业的高性能静态文件服务器"></a>① <strong>Nginx 是专业的高性能静态文件服务器</strong></h5><ul>
<li>速度快、资源占用低，响应迅速</li>
<li>支持缓存、压缩、访问控制、日志、反向代理等丰富功能</li>
<li>易于配置访问路径、rewrite规则等</li>
</ul>
<h5 id="②-Docker-是“容器化”技术，适合运行应用程序"><a href="#②-Docker-是“容器化”技术，适合运行应用程序" class="headerlink" title="② Docker 是“容器化”技术，适合运行应用程序"></a>② <strong>Docker 是“容器化”技术，适合运行应用程序</strong></h5><ul>
<li>Docker 让你把应用和运行环境打包，适合部署动态应用（比如后端服务）</li>
<li>纯静态文件没运行时依赖，没必要额外用容器包裹</li>
<li>如果直接用 Docker 部署静态网站，往往是把 Nginx 或 Apache 装在容器里，再由容器提供静态服务 — 这就和单纯用 Nginx 差不多，只是多了容器层</li>
</ul>
</blockquote>
<h5 id="安装Nginx服务器"><a href="#安装Nginx服务器" class="headerlink" title="安装Nginx服务器"></a>安装Nginx服务器</h5><blockquote>
<p>yum install epel-release<br>yum -y install nginx 安装</p>
</blockquote>
<p>修改nginx的端口，默认80，改为9090：</p>
<blockquote>
<p>vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p>
</blockquote>
<pre><code class="yaml"> server &#123;
        listen    9099 default_server;   
        listen    [::]:9099 default_server;     
        server_name  _;
        root       /usr/share/nginx/html;  
</code></pre>
<p>还需要关闭 selinux，将SELINUX&#x3D;disabled</p>
<blockquote>
<p>setenforce 0                            先临时关闭<br><strong>vi &#x2F;etc&#x2F;selinux&#x2F;config</strong>             编辑文件，永久关闭 SELINUX&#x3D;disabled</p>
</blockquote>
<p>启动Nginx ★★</p>
<blockquote>
<p>systemctl enable nginx 设置开机启动<br>systemctl start nginx 启动<br>systemctl stop nginx 停止<br>systemctl restart nginx 重启<br>systemctl status nginx.service 查看运行状态</p>
</blockquote>
<p>[Welcome to CentOS] (<a target="_blank" rel="noopener" href="http://192.168.200.130:9099/">http://192.168.200.130:9099/</a>)</p>
<h4 id="在Jenkins的服务器里-安装NodeJS插件"><a href="#在Jenkins的服务器里-安装NodeJS插件" class="headerlink" title="在Jenkins的服务器里 安装NodeJS插件"></a>在Jenkins的服务器里 安装NodeJS插件</h4><p>前端在本机的位置：<code>C:\Users\Pluminary\Desktop\QianDuan\tensquareAdmin</code></p>
<p>Jenkins配置Nginx服务器<br><code>Dashboard → Manage Jenkins → Tools → NodeJS新增</code></p>
<blockquote>
<p>别名：nodejs12<br>版本：NodeJS 12.3.1</p>
</blockquote>
<h6 id="创建前端流水线项目-tensquare-front"><a href="#创建前端流水线项目-tensquare-front" class="headerlink" title="创建前端流水线项目 tensquare_front"></a>创建前端流水线项目 <code>tensquare_front</code></h6><p>添加一个参数<code>This project is parameterized</code> → 名称branch 默认值master<br>在Jenkins里找一个凭证<code>点击右侧zhangsan → 更新 → 就会显示有ID </code> 复制后变成git_auth</p>
<h6 id="流水线Pipeline-script"><a href="#流水线Pipeline-script" class="headerlink" title="流水线Pipeline script"></a>流水线<code>Pipeline script</code></h6><pre><code class="yaml">//gitlab凭证
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
node&#123;
    stage(&#39;拉取代码&#39;)&#123;
        checkout scmGit(branches: [[name: &#39;*/$&#123;branch&#125;&#39;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &#39;http://192.168.200.132:82/lanyun_group/tensquare_front.git&#39;]])
    &#125;
     stage(&#39;打包，部署网站&#39;) &#123;
        //使用NodeJS的npm进行打包
        nodejs(&#39;nodejs12&#39;)&#123;
         sh &#39;&#39;&#39;
             npm install
             npm run build   
        &#39;&#39;&#39;         
        &#125;
     &#125;
     //=====以下为远程调用进行项目部署========
     sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &#39;&#39;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;/usr/share/nginx/html&#39;, remoteDirectorySDF: false, removePrefix: &#39;dist&#39;, sourceFiles: &#39;dist/**&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
&#125;
</code></pre>
<p>去gitlab里面修改<code>tensquare_front</code>里面的config→<code>prod.env.js</code></p>
<pre><code class="java">&#39;use strict&#39;
module.exports = &#123;
  NODE_ENV: &#39;&quot;production&quot;&#39;,
  // BASE_API: &#39;&quot;http://192.168.207.131:7300/mock/5c0b42c85b4c7508d4dc568c/1024&quot;&#39;
  BASE_API: &#39;&quot;http://192.168.200.130:10020&quot;&#39; // 管理员网关[生产]
&#125;
</code></pre>
<p>去构建一下！</p>
<p>然后去生产服务器寻找</p>
<blockquote>
<p>[root@localhost html]# <code>cd /usr/share/nginx/html</code><br>[root@localhost html]# ll<br>总用量 80<br>-rw-r–r–. 1 root root  3650 11月 11 2022 404.html<br>-rw-r–r–. 1 root root  3693 11月 11 2022 50x.html<br>lrwxrwxrwx. 1 root root    20 7月   5 19:30 en-US -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;en-US<br>-rw-r–r–. 1 root root 67646 7月   5 20:12 favicon.ico<br>drwxr-xr-x. 2 root root    27 7月   5 19:30 icons<br>lrwxrwxrwx. 1 root root    18 7月   5 19:30 img -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;img<br>lrwxrwxrwx. 1 root root    25 7月   5 19:30 index.html -&gt; ..&#x2F;..&#x2F;doc&#x2F;HTML&#x2F;index.html<br>-rw-r–r–. 1 root root   368 11月 11 2022 nginx-logo.png<br>lrwxrwxrwx. 1 root root    14 7月   5 19:30 poweredby.png -&gt; nginx-logo.png<br>drwxr-xr-x. 6 root root    51 7月   5 20:12 static<br>[root@localhost html]#</p>
</blockquote>
<p>回头再去访问：<a target="_blank" rel="noopener" href="http://192.168.200.130:9099/">http://192.168.200.130:9099/</a> 已经成功</p>
<blockquote>
<p>admin  123456</p>
</blockquote>
<p>登录进去查看是否能连通之前在镜像部署的微服务后端！！！[一次成功 完美！！]</p>
<h4 id="Jenkins-Docker-SpringCloud微服务持续集成-下-之前是单机版"><a href="#Jenkins-Docker-SpringCloud微服务持续集成-下-之前是单机版" class="headerlink" title="Jenkins+Docker+SpringCloud微服务持续集成(下)之前是单机版"></a>Jenkins+Docker+SpringCloud微服务持续集成(下)<del>之前是单机版</del></h4><h6 id="上面部署方案存在的问题："><a href="#上面部署方案存在的问题：" class="headerlink" title="上面部署方案存在的问题："></a>上面部署方案存在的问题：</h6><p>1）一次只能选择一个微服务部署<br>2）只有一台生产者部署服务器<br>3）每个微服务只有一个实例，容错率低</p>
<h5 id="初级版已完成接下来是中级版本！！"><a href="#初级版已完成接下来是中级版本！！" class="headerlink" title="初级版已完成接下来是中级版本！！"></a>初级版已完成接下来是中级版本！！</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/b15e17b4e1423812026358347a2f45e5a23e8bc3/%E6%96%B0%E9%B2%9C%E9%9B%86%E6%88%90%E5%9B%BE2.png"></p>
<p>在idea项目中增加一台新的机器作为eureka注册的地方</p>
<pre><code class="yml">tensquare_gathering/src/main/resources/application.yml
server: 
  port: 9002
spring: 
  application:  
    name: tensquare-gathering #指定服务名
  datasource:  
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.200.129:3306/tensquare_gathering?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
  jpa: 
    database: mysql
    show-sql: true
#Eureka客户端配置
eureka:
  client:
    service-url:
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳
    lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期
    prefer-ip-address: true
</code></pre>
<pre><code class="yaml">tensquare_admin_service/src/main/resources/application.yml
server: 
  port: 9001
spring: 
  application:  
    name: tensquare-admin-service #指定服务名
  datasource:  
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://192.168.200.129:3306/tensquare_user?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
  jpa: 
    database: mysql
    show-sql: true

#Eureka配置
eureka:
  client:
    service-url:
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳
    lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期
    prefer-ip-address: true


 # jwt参数
jwt:
  config:
    key: itcast
    ttl: 1800000
</code></pre>
<pre><code class="yaml">tensquare_zuul/src/main/resources/application.yml
server:
  port: 10020 # 端口
  
# 基本服务信息
spring:
  application:
    name: tensquare-zuul # 服务ID
    
# Eureka配置
eureka:
  client:
    service-url:  
      defaultZone: http://192.168.200.130:10086/eureka,http://192.168.200.133:10086/eureka
  instance:
    prefer-ip-address: true
  
# 修改ribbon的超时时间
ribbon:
  ConnectTimeout: 1500 # 连接超时时间，默认500ms
  ReadTimeout: 3000  # 请求超时时间，默认1000ms
  
  
# 修改hystrix的熔断超时时间
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMillisecond: 2000 # 熔断超时时长，默认1000ms
            

# 网关路由配置
zuul:
  routes:
    admin:
      path: /admin/**
      serviceId: tensquare-admin-service
    gathering:
          path: /gathering/**
          serviceId: tensquare-gathering

 # jwt参数
jwt:
  config:
    key: itcast
    ttl: 1800000
</code></pre>
<pre><code class="yaml">C:\Users\Pluminary\Desktop\HouDuan\tensquare_parent\tensquare_eureka_server\src\main\resources\application.yml
# 集群版
spring:
  application:
    name: EUREKA-HA

---
server:
  port: 10086
spring:
  # 指定profile=eureka-server1
  profiles: eureka-server1
eureka:
  instance:
    # 指定当profile=eureka-server1时，主机名是eureka-server1
    hostname: 192.168.66.130
  client:
    service-url:
      # 将自己注册到eureka-server1、eureka-server2这个Eureka上面去
      defaultZone: http://192.168.66.130:10086/eureka/,http://192.168.66.133:10086/eureka/

---
server:
  port: 10086
spring:
  profiles: eureka-server2
eureka:
  instance:
    hostname: 192.168.66.132
  client:
    service-url:
      defaultZone: http://192.168.66.130:10086/eureka/,http://192.168.66.133:10086/eureka/
</code></pre>
<p>然后更改提交push到gitlab</p>
<h4 id="设计Jenkins集群项目的构建参数"><a href="#设计Jenkins集群项目的构建参数" class="headerlink" title="设计Jenkins集群项目的构建参数"></a>设计Jenkins集群项目的构建参数</h4><ul>
<li><p>安装Extended Choice Parameter插件<del>支持多选框</del></p>
</li>
<li><p>新建一个<code>tensquare_back_cluster</code>的item<br>流水线选择piplin…SCM；git的url填gitlab里的后端地址</p>
</li>
<li><p>第一步安装好插件后 就可以在<code>This project...</code> 中看到<code>Choice Parameter</code><br>先添加一个<code>String Parameter</code>：名称branch 默认值master 描述请输入分支名称</p>
</li>
<li><p>再添加参数选择多选<code>Extended Choice Parameter</code>：名称project_name 描述:请选择需要部署的微服务；勾选<code>Basic Parameter Types</code> → Check Boxes → Number of Visble Items：4 → Delimiter<code>,</code>(用逗号去隔开) → 点击下面的<code>Choose Source for Value</code> → Value为<code>tensquare_eureka_server@10086,tensquare_zuul@10020,tensquare_admin_service@9001,tensquare_gathering@9002</code> → 点击<code>Choose Source for Default Value</code>(选择默认值)：<code>tensquare_eureka_server@10086</code> → 点击<code>ChooseSourceforValueDescription</code>(描述备注) Description：<code>注册中心,服务网关,认证中心,活动微服务</code> 👉 应用保存 → 构建就可以看到</p>
<p>★★ 请注意 配置多选的时候 Jenkins那里一定不要多加空格什么的！</p>
</li>
<li><p>更新Jenkinsfile代码</p>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i = 0; i &lt; selectedProjectNames.length; i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程&#39;)&#123;
        sh &quot;mvn -f $&#123;project_name&#125; clean package dockerfile:build&quot;
        // 定义镜像名称
        def imageName = &quot;$&#123;project_name&#125;:$&#123;tag&#125;&quot;

        // 对镜像打上标签
        sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

        // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
        withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
            // 登录到Harbor
            sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

            //镜像上传
            sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
        &#125;
        // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
        // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
        sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="多个项目打包及构建上传镜像"><a href="#多个项目打包及构建上传镜像" class="headerlink" title="多个项目打包及构建上传镜像"></a>多个项目打包及构建上传镜像</h4><ul>
<li>更新Jenkinsfile文件</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i=0;i&lt;selectedProjectNames.length;i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程，上传镜像&#39;) &#123;
        for (int i = 0; i &lt; selectedProjectNames.length; i++) &#123;
            //tensquare_eureka_server@10086
            def projectInfo = selectedProjectNames[i];
            //当前遍历的项目名称
            def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
            //当前遍历的项目端口
            def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

            sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

            //定义镜像名称
            def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

            // 对镜像打上标签
            sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
            withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
                // 登录到Harbor
                sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

                //镜像上传
                sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

                sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
            &#125;
            // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
            // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
            sshPublisher(publishers: [sshPublisherDesc(configName: &#39;master_server&#39;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deploy.sh $harbor_url $harbor_project $project_name $tag $port&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="把Eureka注册中心集群部署到多台服务器"><a href="#把Eureka注册中心集群部署到多台服务器" class="headerlink" title="把Eureka注册中心集群部署到多台服务器"></a>把Eureka注册中心集群部署到多台服务器</h4><p><code>Dashboard → Manage Jenkins → 下面的SSH Server → 增加一台133的机器</code><br>测试之前需要把Jenkins服务的公钥拷贝到133上面</p>
<blockquote>
<p>在Jenkins的129机器<br>[root@localhost ~]# ssh-copy-id 192.168.200.133    [Product_slave]</p>
</blockquote>
<blockquote>
<p>SSH Server→【应用+Save】<br>Name：slave_server<br>Hostname：192.168.200.133<br>Username：root<br>Remote Directory：&#x2F;</p>
</blockquote>
<p>继续在Jenkins的<code>tensquare_back_cluster</code>中的<code>Configure</code>的<code>Extended Choice Parameter</code>的下面<code>添加参数</code> → 继续添加<code>Extended Choice Parameter</code> → 在里面继续添加<code>Name：publish_server;Description：请选择需要部署的服务器</code> → 勾选<code>Basic Parameter Types</code>, <code>Parameter Type：Check Boxes</code> → <code>Number of Visible Items：2</code>, <code>Delimiter：,</code> 下面的<code>Choose Source for Value</code> → <code>Value：master_server,slave_server</code> → 下面的<code>Default Value：master_server</code> → 下面的<code>Description：主节点,从节点</code> → 应用+Save</p>
<ul>
<li>更新了<code>Jenkinsfile</code>文件</li>
</ul>
<pre><code class="yaml">//git凭证ID
def git_auth = &quot;ca22e56f-0ecc-4fdc-965d-01e329a0b68a&quot;
//git的url地址
def git_url = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
//镜像的版本号
def tag = &quot;latest&quot;
//Harbor的url地址
def harbor_url = &quot;192.168.200.131:85&quot;
//镜像库项目名称
def harbor_project = &quot;tensquare&quot;
//harbor的登录凭证ID
def harbor_auth = &quot;f83725d3-d5fc-4faf-8ac1-1a56487dfc7b&quot;


node &#123;
    // 获取当前选择的项目名称 要用逗号去切割
    def selectedProjectNames = &quot;$&#123;project_name&#125;&quot;.split(&quot;,&quot;)
    // 获取当前选择的服务器名称
    def selectedServers = &quot;$&#123;publish_server&#125;&quot;.split(&quot;,&quot;)

   stage(&#39;拉取代码&#39;) &#123;
      checkout scmGit(branches: [[name: &quot;*/$&#123;branch&#125;&quot;]], extensions: [], userRemoteConfigs: [[credentialsId: &quot;$&#123;git_auth&#125;&quot;, url: &quot;$&#123;git_url&#125;&quot;]])
   &#125;
   stage(&#39;代码审查&#39;) &#123;
      for(int i=0;i&lt;selectedProjectNames.length;i++)&#123;
          // tensquare_eureka_server@10086
           def projectInfo = selectedProjectNames[i];
          // 当前遍历的项目名称
           def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
          // 当前遍历的项目端口
           def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

          //定义当前的Jenkins的sonarqubeScanner工具 Jenkins的全局Tools里
          def scannerHome = tool &#39;sonar-scanner&#39;
          //引用当前JenkinsSonarQube环境 Jenkins的System里
          withSonarQubeEnv(&#39;sonarqube&#39;)&#123;
              // 需要进入某个项目 在Jenkins选择什么项目就cd什么项目
              sh &quot;&quot;&quot;
                    cd $&#123;currentProjectName&#125;
                    $&#123;scannerHome&#125;/bin/sonar-scanner
                &quot;&quot;&quot;
          &#125;
      &#125;
    &#125;
    stage(&#39;编译，安装公共子工程&#39;)&#123;
        sh &quot;mvn -f tensquare_common clean install&quot;
    &#125;
    stage(&#39;编译，打包微服务工程，上传镜像&#39;) &#123;
        for (int i = 0; i &lt; selectedProjectNames.length; i++) &#123;
            //tensquare_eureka_server@10086
            def projectInfo = selectedProjectNames[i];
            //当前遍历的项目名称
            def currentProjectName = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[0]
            //当前遍历的项目端口
            def currentProjectPort = &quot;$&#123;projectInfo&#125;&quot;.split(&quot;@&quot;)[1]

            sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

            //定义镜像名称
            def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

            // 对镜像打上标签
            sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

            // 把镜像推送到Harbor(要登录 输入账号密码 不要写在脚本文件 把harbor账号密码用jenkins全局凭证)
            withCredentials([usernamePassword(credentialsId: &quot;$&#123;harbor_auth&#125;&quot;, passwordVariable: &#39;password&#39;, usernameVariable: &#39;username&#39;)]) &#123;
                // 登录到Harbor
                sh &quot;docker login -u $&#123;username&#125; -p  $&#123;password&#125; $&#123;harbor_url&#125;&quot;

                //镜像上传
                sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project&#125;/$&#123;imageName&#125;&quot;

                sh &quot;echo &#39;🔥🔥镜像上传成功✅✅&#39;&quot;
            &#125;
            //遍历所有服务器，分别部署
            for (int j = 0; j &lt; selectedServers.length; j++) &#123;
                //获取当前遍历的服务器名称
                def currentServerName = selectedServers[j]

                //加上的参数格式：--spring.profiles.active=eureka-server1/eureka-server2
                def activeProfile = &quot;--spring.profiles.active=&quot;

                //根据不同的服务名称来读取不同的Eureka配置信息
                if (currentServerName == &quot;master_server&quot;) &#123;
                    activeProfile = activeProfile + &quot;eureka-server1&quot;
                &#125; else if (currentServerName == &quot;slave_server&quot;) &#123;
                    activeProfile = activeProfile + &quot;eureka-server2&quot;
                &#125;

                // 部署应用 发送命令调用生产服务器的shell脚本文件 完成所有的微服务项目部署行为
                // deploy.sh 是触发远程脚本文件(镜像拉取和容器创建的行为)
                sshPublisher(publishers: [sshPublisherDesc(configName: &quot;$&#123;currentServerName&#125;&quot;, transfers: [sshTransfer(cleanRemote: false, excludes: &#39;&#39;, execCommand: &quot;/opt/jenkins_shell/deployCluster.sh $harbor_url $harbor_project $currentProjectName $tag $currentProjectPort $activeProfile&quot;, execTimeout: 120000, flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: &#39;[, ]+&#39;, remoteDirectory: &#39;&#39;, remoteDirectorySDF: false, removePrefix: &#39;&#39;, sourceFiles: &#39;&#39;)], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)])
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>将之前的<code>deploy.sh</code>换成了<code>deployCluster.sh</code></li>
</ul>
<pre><code class="yaml">#! /bin/sh
#接收外部参数
harbor_url=$1
harbor_project_name=$2
project_name=$3
tag=$4
port=$5
profile=$6

imageName=$harbor_url/$harbor_project_name/$project_name:$tag

echo &quot;$imageName&quot;

#查询容器是否存在，存在则删除
containerId=`docker ps -a | grep -w $&#123;project_name&#125;:$&#123;tag&#125;  | awk &#39;&#123;print $1&#125;&#39;`

if [ &quot;$containerId&quot; !=  &quot;&quot; ] ; then
    #停掉容器
    docker stop $containerId

    #删除容器
    docker rm $containerId
    
    echo &quot;成功删除容器&quot;
fi

#查询镜像是否存在，存在则删除
imageId=`docker images | grep -w $project_name  | awk &#39;&#123;print $3&#125;&#39;`

if [ &quot;$imageId&quot; !=  &quot;&quot; ] ; then
      
    #删除镜像
    docker rmi -f $imageId
    
    echo &quot;成功删除镜像&quot;
fi

# 登录Harbor
docker login -u eric -p Eric123456 $harbor_url

# 下载镜像
docker pull $imageName

# 启动容器
docker run -di -p $port:$port $imageName $profile

echo &quot;容器启动成功&quot;
</code></pre>
<ul>
<li><p>master_server,slave_server将130生产的机器<code>master机器</code>里 放入<code>deployCluster.sh</code> 是在这个目录<code>/opt/jenkins_shell/</code>里面<br>然后加上权限</p>
<blockquote>
<p>[root@localhost ~]# <code>cd /opt/jenkins_shell/</code><br>[root@localhost jenkins_shell]# <code>chmod +x deployCluster.sh</code></p>
</blockquote>
</li>
<li><p>然后在133机器上<code>slave机器</code> 按照上一步的操作拖进去 然后加入权限</p>
<blockquote>
<p>[root@localhost ~]# <code>cd /opt/jenkins_shell/</code><br>[root@localhost jenkins_shell]# <code>chmod +x deployCluster.sh</code></p>
</blockquote>
</li>
</ul>
<p>[Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.130:10086/">http://192.168.200.130:10086/</a>) + [Eureka] (<a target="_blank" rel="noopener" href="http://192.168.200.133:10086/">http://192.168.200.133:10086/</a>)</p>
<ul>
<li><p>然后再去把剩下的都构建了</p>
<blockquote>
<h4 id="project-name"><a href="#project-name" class="headerlink" title="project_name"></a>project_name</h4><p>请选择需要部署的微服务</p>
<table>
<thead>
<tr>
<th>注册中心</th>
</tr>
</thead>
<tbody><tr>
<td>服务网关</td>
</tr>
<tr>
<td>认证中心</td>
</tr>
<tr>
<td>活动微服务</td>
</tr>
</tbody></table>
<h4 id="publish-server"><a href="#publish-server" class="headerlink" title="publish_server"></a>publish_server</h4><p>请选择需要部署的服务器</p>
<table>
<thead>
<tr>
<th>主节点</th>
</tr>
</thead>
<tbody><tr>
<td>从节点</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h4 id="Nginx-Zuul集群实现高可用网关"><a href="#Nginx-Zuul集群实现高可用网关" class="headerlink" title="Nginx + Zuul集群实现高可用网关"></a>Nginx + Zuul集群实现高可用网关</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/d0f70a9927ff44bf814b318e0c7211a8e0bdbce6/Nginx%20+%20Zuul%E9%9B%86%E7%BE%A4%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BD%91%E5%85%B3.png"></p>
<h5 id="更改133的nginx配置"><a href="#更改133的nginx配置" class="headerlink" title="更改133的nginx配置"></a>更改133的nginx配置</h5><p><code>vi /etc/nginx/nginx.conf</code></p>
<pre><code class="yaml">user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events &#123;
    worker_connections 1024;
&#125;

http &#123;
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 4096;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    include /etc/nginx/conf.d/*.conf;

    ### 新增负载均衡配置
    upstream zuulServer &#123;
        server 192.168.200.130:10020 weight=1;
        server 192.168.200.133:10020 weight=1;
    &#125;

    server &#123;
        listen       85 default_server;
        listen       [::]:85 default_server;
        server_name  _;·
        root         /usr/share/nginx/html;

        include /etc/nginx/default.d/*.conf;

        location / &#123;
            proxy_pass http://zuulServer/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        &#125;

        error_page 404 /404.html;
        location = /404.html &#123;
        &#125;

        error_page 500 502 503 504 /50x.html;
        location = /50x.html &#123;
        &#125;
    &#125;
&#125;
</code></pre>
<p>重启Nginx：<code>systemctl restart nginx</code><br>修改前端Nginx的访问地址tensquare_front → config → <code>prod.env.js</code></p>
<pre><code class="yaml">&#39;use strict&#39;
module.exports = &#123;
  NODE_ENV: &#39;&quot;production&quot;&#39;,
  // BASE_API: &#39;&quot;http://192.168.207.131:7300/mock/5c0b42c85b4c7508d4dc568c/1024&quot;&#39;
  BASE_API: &#39;&quot;http://192.168.200.133:85&quot;&#39; // 管理员网关
&#125;
</code></pre>
<h3 id="基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-上"><a href="#基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-上" class="headerlink" title="基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(上)"></a>基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(上)</h3><h5 id="Jenkins的Master-Slave分布式构建"><a href="#Jenkins的Master-Slave分布式构建" class="headerlink" title="Jenkins的Master-Slave分布式构建"></a>Jenkins的Master-Slave分布式构建</h5><h6 id="什么是Master-Slave分布式构建"><a href="#什么是Master-Slave分布式构建" class="headerlink" title="什么是Master-Slave分布式构建"></a>什么是Master-Slave分布式构建</h6><p>Jenkins的Master-Slave分布式构建，就是通过将构建过程分配到从属Slave节点上，从而减轻Master节 点的压力，而且可以同时构建多个，有点类似负载均衡的概念。</p>
<h6 id="如何实现Master-Slave分布式构建"><a href="#如何实现Master-Slave分布式构建" class="headerlink" title="如何实现Master-Slave分布式构建"></a>如何实现Master-Slave分布式构建</h6><ul>
<li><p>开启代理程序的TCP端口<code>Dashboard → Manage Jenkins → Security → 代理：随机选取</code></p>
</li>
<li><p>新建节点 <code>Dashboard → Manage Jenkins → Nodes → New node → 节点名称: slave1  勾选Permanent Agent → create </code> → 我的Jenkins主节点在101机器，从节点就放在102机器吧 → 去102机器<code>cd /root； mkdir jenkins</code>  → 远程工作目录：<code>/root/jenkins</code> → 用法；启动方式；可用性都是默认第一个 → 点进去刚刚创建的slave →↓</p>
<pre><code class="yaml">Run from agent command line: (Unix) 
# 下载agent.jar
curl -sO http://192.168.200.133:8888/jnlpJars/agent.jar

java -jar agent.jar -url http://192.168.200.129:8888/ -secret 85f68f679a60139d7867571d577299c3c7d10f913acfca589bb0b9018b86e14d -name slave1 -webSocket -workDir &quot;/root/jenkins&quot;
</code></pre>
<p>想要这个 需要下载个agent.jar包传到102的&#x2F;root机器中</p>
</li>
</ul>
<blockquote>
<h2 id="✅-最简单解决方案（推荐）"><a href="#✅-最简单解决方案（推荐）" class="headerlink" title="✅ 最简单解决方案（推荐）"></a>✅ 最简单解决方案（推荐）</h2><h3 id="✅-方案一：从-Jenkins-主机上下载，再用-SCP-复制到-agent-机器"><a href="#✅-方案一：从-Jenkins-主机上下载，再用-SCP-复制到-agent-机器" class="headerlink" title="✅ 方案一：从 Jenkins 主机上下载，再用 SCP 复制到 agent 机器"></a>✅ <strong>方案一：从 Jenkins 主机上下载，再用 SCP 复制到 agent 机器</strong></h3><p>在 Jenkins 主机（192.168.200.129）上执行：</p>
<pre><code>curl -sO http://localhost:8888/jnlpJars/agent.jar
</code></pre>
<p>然后从主机 <strong>scp 到 192.168.200.133</strong>：</p>
<pre><code>scp agent.jar root@192.168.200.133:/root/
</code></pre>
<p>登录密码或配置了免密都行。</p>
</blockquote>
<h3 id="Kubernetes实现Master-Slave分布式构建方案"><a href="#Kubernetes实现Master-Slave分布式构建方案" class="headerlink" title="Kubernetes实现Master-Slave分布式构建方案"></a><span style = "color:red">Kubernetes实现Master-Slave分布式构建方案</span></h3><h5 id="传统Jenkins的Master-Slave方案的缺陷"><a href="#传统Jenkins的Master-Slave方案的缺陷" class="headerlink" title="传统Jenkins的Master-Slave方案的缺陷"></a>传统Jenkins的Master-Slave方案的缺陷</h5><ul>
<li>Master 每个 节点发生单点故障时，整个流程都不可用了 </li>
<li>Slave节点的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置致管理起来非常不方便，维护起来也是比较费劲 </li>
<li>资源分配不均衡，有的 Slave节点要运行的job出现排队等待，而有的Slave节点处于空闲状态 </li>
<li>资源浪费，每台 掉资源 Slave节点可能是实体机或者VM，当Slave节点处于空闲状态时，也不会完全释放</li>
</ul>
<p>以上种种问题，我们可以引入Kubernates来解决！</p>
<p>K8S是对主从分布式架构的优化！！！</p>
<h5 id="Kubernates简介"><a href="#Kubernates简介" class="headerlink" title="Kubernates简介"></a>Kubernates简介</h5><p>Kubernetes（简称，K8S）是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化的 应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的 便捷性。 其主要功能如下：</p>
<ul>
<li>使用 Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 </li>
<li>以集群的方式运行、管理跨机器的容器。以集群的方式运行、管理跨机器的容器。</li>
<li>解决 Docker跨机器容器之间的通讯问题。解决Docker跨机器容器之间的通讯问题。 </li>
<li>Kubernetes 的自我修复机制使得容器集群总是运行在用户期望的状态。</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/e7ba868ee01a6860f90f158257d10a2f1d6d1a83/Kubernates+Docker+Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%9E%B6%E6%9E%84%E5%9B%BE.png" style="zoom: 80%;" />

<h4 id="Kubernates-Docker-Jenkins持续集成方案好处"><a href="#Kubernates-Docker-Jenkins持续集成方案好处" class="headerlink" title="Kubernates+Docker+Jenkins持续集成方案好处"></a>Kubernates+Docker+Jenkins持续集成方案好处</h4><ul>
<li><span style = "color:red">服务高可用</span>：当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。 </li>
<li><span style = "color:red">动态伸缩，合理使用资源</span>：每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。 </li>
<li><span style = "color:red">扩展性好</span> ：当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。</li>
</ul>
<h4 id="Kubeadm安装Kubernetes"><a href="#Kubeadm安装Kubernetes" class="headerlink" title="Kubeadm安装Kubernetes"></a>Kubeadm安装Kubernetes</h4><h5 id="Kubernetes的架构"><a href="#Kubernetes的架构" class="headerlink" title="Kubernetes的架构"></a>Kubernetes的架构</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/062acb4452ba025e956c0bea31d53ad08618cbc1/kubernetes.png"></p>
<ul>
<li><strong>API Serve</strong>r ：用于暴露Kubernetes API，任何资源的请求的调用操作都是通过kube-apiserver提供的接 口进行的。 </li>
<li><strong>Etcd</strong>：是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计 划。 </li>
<li><strong>Controller-Manager</strong>：作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点 （Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额 （ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化 修复流程，确保集群始终处于预期的工作状态。 </li>
<li><strong>Scheduler</strong>：监视新创建没有分配到Node的Pod，为Pod选择一个Node。 </li>
<li><strong>Kubelet</strong>：负责维护容器的生命周期，同时负责Volume和网络的管理 </li>
<li><strong>Kube proxy</strong>：是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通 信与负载均衡机制的重要组件。</li>
</ul>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP地址</th>
<th>安装的软件</th>
</tr>
</thead>
<tbody><tr>
<td>代码托管服务器</td>
<td>192.168.200.132</td>
<td>Gitlab-12.4.2</td>
</tr>
<tr>
<td>Docker仓库服务器</td>
<td>192.168.200.131</td>
<td>Harbor1.9.2</td>
</tr>
<tr>
<td>k8s-master</td>
<td>192.168.200.129</td>
<td>kube-apiserver、kube-controller-manager、kube scheduler、docker、etcd、calico，NFS</td>
</tr>
<tr>
<td>k8s-node1</td>
<td>192.168.200.130</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
<tr>
<td>k8s-node2</td>
<td>192.168.200.133</td>
<td>kubelet、kubeproxy、Docker18.06.1-ce</td>
</tr>
</tbody></table>
<h4 id="三台机器都需要完成-结束我会提示"><a href="#三台机器都需要完成-结束我会提示" class="headerlink" title="三台机器都需要完成(结束我会提示)"></a><span style ="color:green">三台机器都需要完成<del>(结束我会提示)</del></span></h4><p>修改三台机器的hostname及hosts文件</p>
<blockquote>
<p>【输入hostname即可查看是否改成功】<br>hostnamectl set-hostname k8s-master   【129】<br>hostnamectl set-hostname k8s-node1    【130】<br>hostnamectl set-hostname k8s-node2    【133】</p>
</blockquote>
<blockquote>
<p>【将id映射的hostname进行关联】<br>[输入 <code>cat /etc/hosts</code> 查看是否成功]<br>cat &gt;&gt;&#x2F;etc&#x2F;hosts&lt;&lt;EOF<br>192.168.200.129 k8s-master<br>192.168.200.130 k8s-node1<br>192.168.200.133 k8s-node2<br>EOF</p>
</blockquote>
<p>效果图</p>
<blockquote>
<p>[root@localhost ~]# cat &#x2F;etc&#x2F;hosts<br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.200.129 k8s-master<br>192.168.200.130 k8s-node1<br>192.168.200.133 k8s-node2</p>
</blockquote>
<p>关闭防火墙和关闭SELinux</p>
<blockquote>
<p>systemctl stop firewalld<br>systemctl disable firewalld </p>
<p><code>setenforce 0</code> 临时关闭<br><code>vi /etc/sysconfig/selinux </code>永久关闭<br>改为<code>SELINUX=disabled</code></p>
</blockquote>
<p><strong>关闭 SELinux</strong> 可以避免一些服务（如 Jenkins、SonarQube、Docker）因为权限问题无法访问网络或文件，但<strong>不是永久推荐</strong>的安全实践。</p>
<h6 id="设置系统参数"><a href="#设置系统参数" class="headerlink" title="设置系统参数"></a>设置系统参数</h6><p>设置允许路由转发，不对bridge的数据进行处理<br>创建文件</p>
<blockquote>
<p>vi &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
<p>内容如下：</p>
<p>net.bridge.bridge-nf-call-ip6tables &#x3D; 1<br>net.bridge.bridge-nf-call-iptables &#x3D; 1<br>net.ipv4.ip_forward &#x3D; 1<br>vm.swappiness &#x3D; 0</p>
</blockquote>
<p>执行文件</p>
<blockquote>
<p>sysctl -p &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p>
</blockquote>
<h5 id="kube-proxy开启ipvs的前置条件"><a href="#kube-proxy开启ipvs的前置条件" class="headerlink" title="kube-proxy开启ipvs的前置条件"></a>kube-proxy开启ipvs的前置条件</h5><pre><code class="yaml">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF
#!/bin/bash
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
EOF

chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash   ☆☆
/etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4
</code></pre>
<h5 id="所有节点关闭swap"><a href="#所有节点关闭swap" class="headerlink" title="所有节点关闭swap"></a>所有节点关闭swap</h5><blockquote>
<p>swapoff -a 临时关闭<br>vi &#x2F;etc&#x2F;fstab 永久关闭 </p>
<p>注释掉以下字段<br>&#x2F;dev&#x2F;mapper&#x2F;cl-swap swap swap defaults 0 0</p>
</blockquote>
<h5 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h5><ul>
<li>kubeadm：用来初始化集群的指令。 </li>
<li>kubelet：在集群中的每个节点上用来启动 pod 和 container 等。 </li>
<li>kubectl:  清空yum缓存 用来与集群通信的命令行工具。</li>
</ul>
<h5 id="清空yum缓存"><a href="#清空yum缓存" class="headerlink" title="清空yum缓存"></a>清空yum缓存</h5><blockquote>
<p>yum clean all</p>
</blockquote>
<h5 id="设置yum安装源"><a href="#设置yum安装源" class="headerlink" title="设置yum安装源"></a>设置yum安装源</h5><pre><code class="yaml">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg 
https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
</code></pre>
<p>安装：<code>yum install -y kubelet kubeadm kubectl</code></p>
<h5 id="kubelt-设置开机启动（注意：先不启动，现在启动的话会报错）"><a href="#kubelt-设置开机启动（注意：先不启动，现在启动的话会报错）" class="headerlink" title="kubelt 设置开机启动（注意：先不启动，现在启动的话会报错）"></a>kubelt 设置开机启动（注意：先不启动，现在启动的话会报错）</h5><p><code>systemctl start kubelet</code> 启动 ★★</p>
<p><code>systemctl enable kubelet</code> 开机启动</p>
<h5 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h5><p><code>kubelet --version</code>  → Kubernetes v1.28.2</p>
<p><span style="color:green">结束！</span></p>
<h4 id="Master节点需要完成-129主节点"><a href="#Master节点需要完成-129主节点" class="headerlink" title="Master节点需要完成 [129主节点]"></a>Master节点需要完成 [129主节点]</h4><ul>
<li>运行初始化命令</li>
</ul>
<pre><code class="yaml">kubeadm init --kubernetes-version=1.28.2 \
--apiserver-advertise-address=192.168.200.129 \
--image-repository registry.aliyuncs.com/google_containers \
--service-cidr=10.1.0.0/16 \
--pod-network-cidr=10.244.0.0/16
</code></pre>
<blockquote>
<h4 id="如何重新初始化？"><a href="#如何重新初始化？" class="headerlink" title="如何重新初始化？"></a>如何重新初始化？</h4><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="1-清理旧集群残留"><a href="#1-清理旧集群残留" class="headerlink" title="1. 清理旧集群残留"></a>1. <strong>清理旧集群残留</strong></h3><p>先执行 <code>kubeadm reset</code> 清理当前节点的 Kubernetes 配置和状态：</p>
<pre><code>kubeadm reset -f
kubeadm reset
</code></pre>
<p>这个命令会清理 kubelet 配置文件、证书、容器网络和所有 Kubernetes 相关状态。</p>
<hr>
<h3 id="2-清理网络相关残留"><a href="#2-清理网络相关残留" class="headerlink" title="2. 清理网络相关残留"></a>2. <strong>清理网络相关残留</strong></h3><p>清理 CNI 网络配置和容器残留：</p>
<pre><code>rm -rf /etc/cni/net.d
rm -rf /var/lib/cni/
rm -rf /var/lib/kubelet/*
</code></pre>
<hr>
<h3 id="3-确认-containerd-服务启动"><a href="#3-确认-containerd-服务启动" class="headerlink" title="3. 确认 containerd 服务启动"></a>3. <strong>确认 containerd 服务启动</strong></h3><p>确保 containerd 运行：</p>
<pre><code>systemctl restart containerd
systemctl status containerd
</code></pre>
<hr>
<h3 id="4-重新初始化-Kubernetes"><a href="#4-重新初始化-Kubernetes" class="headerlink" title="4. 重新初始化 Kubernetes"></a>4. <strong>重新初始化 Kubernetes</strong></h3><p>执行你之前的初始化命令：</p>
<pre><code>kubeadm init --kubernetes-version=1.28.2 \
  --apiserver-advertise-address=192.168.200.129 \
  --image-repository registry.aliyuncs.com/google_containers \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.244.0.0/16
</code></pre>
<hr>
<h3 id="5-配置-kubeconfig"><a href="#5-配置-kubeconfig" class="headerlink" title="5. 配置 kubeconfig"></a>5. <strong>配置 kubeconfig</strong></h3><p>初始化完成后，按照提示将配置文件复制到用户目录：</p>
<pre><code>mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<hr>
<h3 id="6-部署网络插件"><a href="#6-部署网络插件" class="headerlink" title="6. 部署网络插件"></a>6. <strong>部署网络插件</strong></h3><p>根据你使用的网络插件（比如 Flannel、Calico），按照官方文档部署。以 Flannel 为例：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml
</code></pre>
<hr>
<h3 id="7-验证"><a href="#7-验证" class="headerlink" title="7. 验证"></a>7. <strong>验证</strong></h3><p>查看节点和 Pod 状态：</p>
<pre><code>kubectl get nodes
kubectl get pods -n kube-system
</code></pre>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token q54yl3.xgho0e6o5080hnnf \
        --discovery-token-ca-cert-hash sha256:b8f6a58b65ad6bcfec65e5ed6ab5efac95f3a4ee82b2c388a87b20c3e813079b
</code></pre>
<hr>
<hr>
<hr>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>你之前的配置文件和状态未清理，导致不能重新初始化。先用 <code>kubeadm reset</code> 清理，再重新初始化。这样会自动生成 <code>kubelet</code> 配置文件和 <code>kubelet.conf</code>，解决你遇到的启动失败问题。</p>
</blockquote>
<blockquote>
<p>问题：     [ERROR CRI]: container runtime is not running: output: E0706 21:24:43.293740   26106 remote_runtime.go:616] “Status from runtime service failed” err&#x3D;”rpc error: code &#x3D; Unavailable desc &#x3D; connection error: desc &#x3D; &quot;transport: Error while dialing dial unix &#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock: connect: no such file or directory&quot;“ time&#x3D;”2025-07-06T21:24:43+08:00” level&#x3D;fatal msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unavailable desc &#x3D; connection error: desc &#x3D; &quot;transport: Error while dialing dial unix &#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock: connect: no such file or directory&quot;“ , error: exit status 1 [preflight] If you know what you are doing, you can make a check non-fatal with <code>--ignore-preflight-errors=...</code> To see the stack trace of this error execute with –v&#x3D;5 or higher [root@k8s-master ~]#</p>
<h3 id="✅-立即解决步骤（推荐直接复制粘贴执行）"><a href="#✅-立即解决步骤（推荐直接复制粘贴执行）" class="headerlink" title="✅ 立即解决步骤（推荐直接复制粘贴执行）"></a>✅ 立即解决步骤（推荐直接复制粘贴执行）</h3><h4 id="1️⃣-安装-containerd"><a href="#1️⃣-安装-containerd" class="headerlink" title="1️⃣ 安装 containerd"></a>1️⃣ 安装 containerd</h4><pre><code>yum install -y containerd
</code></pre>
<p>你这里显示的是一个<strong>非标准的 containerd 配置模板</strong>（很可能来自旧版本或 docker 提供的 containerd），<strong>缺失了完整配置结构和 <code>SystemdCgroup</code> 字段</strong>，所以这不是我们需要的配置。</p>
<hr>
<h3 id="✅-正确做法是：用标准-containerd-命令生成完整配置"><a href="#✅-正确做法是：用标准-containerd-命令生成完整配置" class="headerlink" title="✅ 正确做法是：用标准 containerd 命令生成完整配置"></a>✅ 正确做法是：用标准 containerd 命令生成完整配置</h3><p>请执行以下命令替换掉旧配置：</p>
<hr>
<h3 id="🔁-步骤-1：重新生成-containerd-的标准配置文件"><a href="#🔁-步骤-1：重新生成-containerd-的标准配置文件" class="headerlink" title="🔁 步骤 1：重新生成 containerd 的标准配置文件"></a>🔁 步骤 1：重新生成 containerd 的标准配置文件</h3><pre><code>rm -f /etc/containerd/config.toml  # 删除旧文件
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🔧-步骤-2：编辑配置文件，修改-SystemdCgroup-true"><a href="#🔧-步骤-2：编辑配置文件，修改-SystemdCgroup-true" class="headerlink" title="🔧 步骤 2：编辑配置文件，修改 SystemdCgroup = true"></a>🔧 步骤 2：编辑配置文件，修改 <code>SystemdCgroup = true</code></h3><pre><code>vi /etc/containerd/config.toml
</code></pre>
<p>在文件中搜索这一行（用 <code>/SystemdCgroup</code>）：</p>
<pre><code>SystemdCgroup = false
</code></pre>
<p>将它修改为：</p>
<pre><code>SystemdCgroup = true
</code></pre>
<hr>
<h3 id="🔁-步骤-3：重启-containerd"><a href="#🔁-步骤-3：重启-containerd" class="headerlink" title="🔁 步骤 3：重启 containerd"></a>🔁 步骤 3：重启 containerd</h3><pre><code>systemctl daemon-reexec
systemctl restart containerd
systemctl enable containerd
</code></pre>
<hr>
<h3 id="✅-步骤-4：验证是否运行中"><a href="#✅-步骤-4：验证是否运行中" class="headerlink" title="✅ 步骤 4：验证是否运行中"></a>✅ 步骤 4：验证是否运行中</h3><pre><code>systemctl status containerd
</code></pre>
<p>确保输出中看到：<code>Active: active (running)</code></p>
<hr>
<h5 id="然后你就可以继续-kubeadm-init-了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行"><a href="#然后你就可以继续-kubeadm-init-了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行" class="headerlink" title="然后你就可以继续 kubeadm init 了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行"></a>然后你就可以继续 <code>kubeadm init</code> 了。如果你愿意，我可以一步步带你确认配置生效。现在请先执行</h5><h4 id="一、清理旧的集群数据"><a href="#一、清理旧的集群数据" class="headerlink" title="一、清理旧的集群数据"></a>一、清理旧的集群数据</h4><p>你可以执行下面命令，清理之前的 kubeadm 初始化信息：</p>
<pre><code>kubeadm reset
</code></pre>
<hr>
<hr>
<hr>
<hr>
<h3 id="你这边的核心问题是："><a href="#你这边的核心问题是：" class="headerlink" title="你这边的核心问题是："></a><span style = "color:red">你这边的核心问题是：</span></h3><blockquote>
<p>❌ containerd 没有启动，导致 kubeadm 报错<br> <code>&quot;connect: no such file or directory&quot; → /var/run/containerd/containerd.sock</code></p>
</blockquote>
<p>这说明 <strong>containerd 根本没跑起来</strong>，Kubernetes 无法连接它。</p>
<hr>
<h3 id="✅-解决思路：修复-containerd-的配置-启动-containerd"><a href="#✅-解决思路：修复-containerd-的配置-启动-containerd" class="headerlink" title="✅ 解决思路：修复 containerd 的配置 + 启动 containerd"></a>✅ 解决思路：修复 containerd 的配置 + 启动 containerd</h3><p>我们手把手来操作👇</p>
<hr>
<h2 id="🧹-第一步：清空-containerd-的配置文件并重新生成"><a href="#🧹-第一步：清空-containerd-的配置文件并重新生成" class="headerlink" title="🧹 第一步：清空 containerd 的配置文件并重新生成"></a>🧹 第一步：清空 containerd 的配置文件并重新生成</h2><pre><code>rm -f /etc/containerd/config.toml
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<p>✅ 这一步会恢复官方默认配置。</p>
<h3 id="✏️-第二步：使用-vi（所有-Linux-通用）"><a href="#✏️-第二步：使用-vi（所有-Linux-通用）" class="headerlink" title="✏️ 第二步：使用 vi（所有 Linux 通用）"></a>✏️ 第二步：使用 <code>vi</code>（所有 Linux 通用）</h3><pre><code>vi /etc/containerd/config.toml
</code></pre>
<p>查找这一段：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;]
  sandbox_image = &quot;registry.k8s.io/pause:3.6&quot;
</code></pre>
<p>把它改成：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;]
  sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;
</code></pre>
<p>✅ 保存并退出🔄 第三步：重启 containerd</p>
<pre><code>systemctl daemon-reexec
systemctl restart containerd
</code></pre>
<h2 id="✅-第四步：确认-containerd-已成功启动"><a href="#✅-第四步：确认-containerd-已成功启动" class="headerlink" title="✅ 第四步：确认 containerd 已成功启动"></a>✅ 第四步：确认 containerd 已成功启动</h2><pre><code>systemctl status containerd
</code></pre>
<p>看输出里有 <code>Active: active (running)</code>，说明启动成功。🧪 第五步：验证 socket 文件是否存在</p>
<pre><code>ls -l /var/run/containerd/containerd.sock
</code></pre>
<p>应该能看到类似：</p>
<pre><code>srw-rw---- 1 root root 0 Jul 6 22:06 /var/run/containerd/containerd.sock
</code></pre>
<p>如果没看到，说明 containerd 没真正运行成功。</p>
<h2 id="🧱-第六步：重新执行-kubeadm-init"><a href="#🧱-第六步：重新执行-kubeadm-init" class="headerlink" title="🧱 第六步：重新执行 kubeadm init"></a>🧱 第六步：重新执行 <code>kubeadm init</code></h2><pre><code>kubeadm init --kubernetes-version=1.28.2 \
  --apiserver-advertise-address=192.168.200.129 \
  --image-repository registry.aliyuncs.com/google_containers \
  --service-cidr=10.1.0.0/16 \
  --pod-network-cidr=10.244.0.0/16
</code></pre>
<p>若是token忘记了 可以执行直接生成一个新的<br><code>kubeadm token create --print-join-command</code></p>
<pre><code class="yam">[root@k8s-master calico]# kubeadm token create --print-join-command
kubeadm join 192.168.200.129:6443 --token jn3083.g1lz52mo680wiic9 --discovery-token-ca-cert-hash sha256:d03d798679d90f348b1cf7a1c12d5d1bfcbe2bd18e4a1aec97055b60c0f042ca
</code></pre>
<p>此时去从节点生成可能会有报错你这个错误说明当前节点（<code>k8s-node1</code>）<br><strong>之前已经执行过 <code>kubeadm join</code> 或者其他 kubeadm 相关操作，留下了配置文件或端口被占用</strong>，不能直接再次执行 <code>kubeadm join</code>。</p>
<hr>
<h3 id="❗报错详情分析："><a href="#❗报错详情分析：" class="headerlink" title="❗报错详情分析："></a>❗报错详情分析：</h3><pre><code>[ERROR FileAvailable--etc-kubernetes-kubelet.conf]: /etc/kubernetes/kubelet.conf already exists
[ERROR Port-10250]: Port 10250 is in use
[ERROR FileAvailable--etc-kubernetes-pki-ca.crt]: /etc/kubernetes/pki/ca.crt already exists
</code></pre>
<p>这些错误说明：</p>
<ul>
<li><code>/etc/kubernetes/kubelet.conf</code> 文件存在 —— 说明 kubelet 被配置过。</li>
<li><code>10250</code> 端口已被占用 —— kubelet 服务正在运行。</li>
<li><code>/etc/kubernetes/pki/ca.crt</code> 文件存在 —— 集群证书存在，可能是之前加入过失败或残留文件。</li>
</ul>
<hr>
<h3 id="✅-解决方法（清理残留再重新-join）："><a href="#✅-解决方法（清理残留再重新-join）：" class="headerlink" title="✅ 解决方法（清理残留再重新 join）："></a>✅ 解决方法（<strong>清理残留再重新 join</strong>）：</h3><p>你可以先在 node 节点执行 <strong>重置操作</strong>：</p>
<pre><code>kubeadm reset -f
</code></pre>
<p>然后再清理一下配置和 iptables 规则（可选但推荐）：</p>
<pre><code>rm -rf /etc/kubernetes/pki
rm -rf /etc/kubernetes/kubelet.conf
rm -rf /var/lib/kubelet/*
iptables -F
systemctl restart kubelet
</code></pre>
<p>然后重新执行你之前的 <code>kubeadm join</code> 命令：</p>
<pre><code>kubeadm join 192.168.200.129:6443 --token eoxdev.8tkpz5csc7x1mqgc \
        --discovery-token-ca-cert-hash sha256:6acf9c7e6c11bb973bd57404f9ec28b93ab5b48f8a50f0213bc389bbfb4bf68f
</code></pre>
<hr>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr>
<p>一切顺利的话，k8s 就能初始化成功了！</p>
<blockquote>
<p>Your Kubernetes control-plane has initialized successfully!</p>
<p>To start using your cluster, you need to run the following as a regular user:</p>
<p>  mkdir -p $HOME&#x2F;.kube<br>  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config<br>  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</p>
<p>Alternatively, if you are the root user, you can run:</p>
<p>  export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</p>
<p>You should now deploy a pod network to the cluster.<br>Run “kubectl apply -f [podnetwork].yaml” with one of the options listed at:<br>  <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">https://kubernetes.io/docs/concepts/cluster-administration/addons/</a></p>
<p>Then you can join any number of worker nodes by running the following on each as root:</p>
<p>kubeadm join 192.168.200.129:6443 –token zjoxjc.f58nh7lixocvjpgj <br>        –discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3<br>[root@k8s-master ~]#</p>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
        --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
</blockquote>
</blockquote>
<ul>
<li>按照它的提示逐步修改k8s配置文件     配置 <code>kubectl</code> 工具</li>
</ul>
<pre><code class="yaml">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<ul>
<li>安装Calico</li>
</ul>
<pre><code class="java">mkdir k8s
cd k8s
wget https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
// 上面的别用了 用这个新的
wget https://jiangstudy.online:8081/sources/calico.yaml
sed -i &#39;s/192.168.0.0/10.244.0.0/g&#39; calico.yaml  【改地址 分给prod的虚拟地址】

kubectl apply -f calico.yaml
</code></pre>
<p>或者ai说的</p>
<pre><code class="yaml"># 1. 创建工作目录
mkdir -p ~/k8s &amp;&amp; cd ~/k8s

# 2. 下载 Calico 清单文件（推荐使用最新版本，而非 v3.10）
wget https://docs.projectcalico.org/manifests/calico.yaml -O calico.yaml

# 3. 修改 POD CIDR（根据您的集群规划）
# 注意：必须与 kubeadm init 时指定的 --pod-network-cidr 一致
sed -i &#39;s|192.168.0.0/16|10.244.0.0/16|g&#39; calico.yaml

# 4. 部署 Calico
kubectl apply -f calico.yaml

# 5. 验证安装
kubectl get pods -n kube-system -w
</code></pre>
<ul>
<li>等待几分钟，查看所有Pod的状态，确保所有Pod都是Running状态</li>
</ul>
<p><code>kubectl get pod --all-namespaces -o wide</code></p>
<blockquote>
<p>你这个 <code>calico.yaml</code> 是 <strong>很老的版本 v3.10</strong>，其中用的是 <code>apiextensions.k8s.io/v1beta1</code>，<strong>早在 Kubernetes v1.22 中就被移除了</strong>，你现在用的是 <strong>Kubernetes 1.28</strong>，自然就出错了。</p>
<hr>
<h3 id="✅-正确做法：使用-Calico-官方支持-Kubernetes-v1-28-的最新-YAML"><a href="#✅-正确做法：使用-Calico-官方支持-Kubernetes-v1-28-的最新-YAML" class="headerlink" title="✅ 正确做法：使用 Calico 官方支持 Kubernetes v1.28 的最新 YAML"></a>✅ 正确做法：使用 Calico 官方支持 Kubernetes v1.28 的最新 YAML</h3><hr>
<p><code>https://docs.projectcalico.org/manifests/calico.yaml</code>浏览器访问然后去<code>/root/k8s</code>里面进行全部替换成新版本</p>
<h3 id="一键下载安装推荐版本："><a href="#一键下载安装推荐版本：" class="headerlink" title="一键下载安装推荐版本："></a>一键下载安装推荐版本：</h3><pre><code>curl https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml -O
</code></pre>
<blockquote>
<p>Calico v3.26 支持 Kubernetes v1.28，放心使用</p>
</blockquote>
<p>然后再修改 <code>Pod CIDR</code>：</p>
<pre><code>sed -i &#39;s/192.168.0.0/10.244.0.0/g&#39; calico.yaml
</code></pre>
<ol>
<li><strong>建议修改镜像源为阿里云（国内可拉取）</strong>：<br> 例如将以下几行（在 calico.yaml 中）：</li>
</ol>
<pre><code>image: calico/cni:v3.26.1
</code></pre>
<p>替换为：</p>
<pre><code>image: registry.cn-hangzhou.aliyuncs.com/chenby/calico_cni:v3.26.1
</code></pre>
<p>最后重新部署：</p>
<pre><code>kubectl apply -f calico.yaml
</code></pre>
<hr>
<h3 id="✅-检查-Calico-状态"><a href="#✅-检查-Calico-状态" class="headerlink" title="✅ 检查 Calico 状态"></a>✅ 检查 Calico 状态</h3><p>部署完大约 10~30 秒后执行：</p>
<pre><code>kubectl get pods -n kube-system
</code></pre>
<p>正常会看到 <code>calico-node</code> 和 <code>calico-kube-controllers</code> 都处于 <code>Running</code> 状态。</p>
<hr>
<hr>
<hr>
<h3 id="傻卵ai和scdn-查半天都没用-还不如B站up的方法-一遍通"><a href="#傻卵ai和scdn-查半天都没用-还不如B站up的方法-一遍通" class="headerlink" title="傻卵ai和scdn 查半天都没用 还不如B站up的方法[一遍通]"></a><span style="color:red"><strong>傻卵ai和scdn 查半天都没用 还不如B站up的方法<del>[一遍通]</del></strong></span></h3><p><a target="_blank" rel="noopener" href="https://jiangstudy.online/archives/kubernetes-calicozu-jian-de-an-zhuang">【kubernetes】Calico组件的安装-云途运维</a></p>
<p>以下步骤只在master01执行：相关的yaml已上传文件资源服务器，需要下载下来使用：</p>
<pre><code class="yaml">mkdir /root/calico &amp;&amp; cd /root/calico/
wget https://jiangstudy.online:8081/sources/calico.yaml
</code></pre>
<p>修改POD网段    说明：pod网段即为主机规划时的网段。</p>
<pre><code class="yaml">POD_SUBNET=`cat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep cluster-cidr= | awk -F= &#39;&#123;print $NF&#125;&#39;`

sed -i &quot;s#POD_CIDR#$&#123;POD_SUBNET&#125;#g&quot; calico.yaml
</code></pre>
<p>部署calico<br><code>kubectl apply -f calico.yaml</code></p>
<p>查看状态<br><code> kubectl get node</code><br><code>kubectl get pods -n kube-system -w</code></p>
</blockquote>
<h3 id="Slave节点需要完成"><a href="#Slave节点需要完成" class="headerlink" title="Slave节点需要完成"></a>Slave节点需要完成</h3><ul>
<li><p>让所有节点让集群环境</p>
<p>使用之前Master节点产生的命令加入集群</p>
<pre><code class="yaml">kubeadm join 192.168.200.129:6443 --token eoxdev.8tkpz5csc7x1mqgc \
        --discovery-token-ca-cert-hash sha256:6acf9c7e6c11bb973bd57404f9ec28b93ab5b48f8a50f0213bc389bbfb4bf68f
</code></pre>
</li>
<li><p>启动<code>kubelet</code></p>
<p><code>systemctl start kubelet</code> 启动<br><code>systemctl status kubelet</code> 查看状态</p>
</li>
<li><p>回到Master节点查看，如果Status全部为Ready，代表集群环境搭建成功！！！</p>
<p><code>kubectl get nodes</code></p>
</li>
</ul>
<blockquote>
<p>你的这个报错：</p>
<pre><code>validate service connection: CRI v1 runtime API is not implemented for endpoint &quot;unix:///var/run/containerd/containerd.sock&quot;
</code></pre>
<p>说明 <strong>containerd 的 CRI 接口没启用</strong>，这是因为你的 <code>/etc/containerd/config.toml</code> 配置不完整或者缺少必要字段。</p>
<hr>
<h2 id="✅-立即修复步骤如下："><a href="#✅-立即修复步骤如下：" class="headerlink" title="✅ 立即修复步骤如下："></a>✅ 立即修复步骤如下：</h2><h3 id="🔧-第一步：重新生成-config-toml-配置文件"><a href="#🔧-第一步：重新生成-config-toml-配置文件" class="headerlink" title="🔧 第一步：重新生成 config.toml 配置文件"></a>🔧 第一步：<strong>重新生成 config.toml 配置文件</strong></h3><pre><code>rm -f /etc/containerd/config.toml
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🛠️-第二步：修改配置启用-CRI-systemd-驱动"><a href="#🛠️-第二步：修改配置启用-CRI-systemd-驱动" class="headerlink" title="🛠️ 第二步：修改配置启用 CRI + systemd 驱动"></a>🛠️ 第二步：<strong>修改配置启用 CRI + systemd 驱动</strong></h3><pre><code>vim /etc/containerd/config.toml
</code></pre>
<p>找到这段：</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
  SystemdCgroup = false
</code></pre>
<p>把 <code>false</code> 改成 <code>true</code>：</p>
<pre><code>SystemdCgroup = true
</code></pre>
<p>或者直接用命令修改：</p>
<pre><code>sed -i &#39;s/SystemdCgroup = false/SystemdCgroup = true/&#39; /etc/containerd/config.toml
</code></pre>
<hr>
<h3 id="🚀-第三步：重启-containerd"><a href="#🚀-第三步：重启-containerd" class="headerlink" title="🚀 第三步：重启 containerd"></a>🚀 第三步：<strong>重启 containerd</strong></h3><pre><code>systemctl daemon-reexec
systemctl restart containerd
systemctl status containerd
</code></pre>
<p>确认运行正常后：</p>
<pre><code>ls /var/run/containerd/containerd.sock
</code></pre>
<p>如果有输出说明 socket 正常，containerd 工作 OK。</p>
<hr>
<h3 id="🔁-第四步：再次执行-kubeadm-join"><a href="#🔁-第四步：再次执行-kubeadm-join" class="headerlink" title="🔁 第四步：再次执行 kubeadm join"></a>🔁 第四步：再次执行 kubeadm join</h3><pre><code>kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
  --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
<h4 id="如果重复导入节点报error"><a href="#如果重复导入节点报error" class="headerlink" title="如果重复导入节点报error"></a>如果重复导入节点报error</h4><p>你这个问题是由于 <strong><code>kubeadm join</code> 重复执行导致节点上已有残留的配置文件和端口占用</strong>，所以报错。</p>
<hr>
<hr>
<h2 id="✅-正确处理方式：重置-node-节点后重新-join"><a href="#✅-正确处理方式：重置-node-节点后重新-join" class="headerlink" title="✅ 正确处理方式：重置 node 节点后重新 join"></a>✅ 正确处理方式：<strong>重置 node 节点后重新 join</strong></h2><p>执行以下命令即可：</p>
<h3 id="1-重置-node-节点配置"><a href="#1-重置-node-节点配置" class="headerlink" title="1. 重置 node 节点配置"></a>1. <strong>重置 node 节点配置</strong></h3><pre><code>kubeadm reset -f
</code></pre>
<h3 id="2-清理-CNI-网络配置"><a href="#2-清理-CNI-网络配置" class="headerlink" title="2. 清理 CNI 网络配置"></a>2. <strong>清理 CNI 网络配置</strong></h3><pre><code>rm -rf /etc/cni/net.d
</code></pre>
<h3 id="3-重启相关服务"><a href="#3-重启相关服务" class="headerlink" title="3. 重启相关服务"></a>3. <strong>重启相关服务</strong></h3><pre><code>systemctl restart kubelet
systemctl restart containerd
</code></pre>
<h3 id="4-重新-join"><a href="#4-重新-join" class="headerlink" title="4. 重新 join"></a>4. <strong>重新 join</strong></h3><p>然后再执行你原来的 join 生成的命令即可：</p>
<pre><code>kubeadm join 192.168.200.129:6443 --token zjoxjc.f58nh7lixocvjpgj \
  --discovery-token-ca-cert-hash sha256:3cbdd81868c4470767b5c82af37fb63c2240c98e5f00eb0458df99350cabb7b3
</code></pre>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></blockquote>
<blockquote>
<p>[root@k8s-master k8s]# docker pull docker.io&#x2F;calico&#x2F;node:v3.26.1<br>v3.26.1: Pulling from calico&#x2F;node<br>c998069b4a7c: Downloading [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;   ]   81.5MB&#x2F;86.58MB<br>6cf92fa5251d: Download complete</p>
<p>[root@k8s-master k8s]# docker save docker.io&#x2F;calico&#x2F;node:v3.26.1 -o calico-node-v3.26.1.tar<br>[root@k8s-master k8s]# ctr images import –all-platforms calico-node-v3.26.1.tar<br>unpacking docker.io&#x2F;calico&#x2F;node:v3.26.1 (sha256:568fb25384d6460176b5528381a2d6fef36d110cfaddda5ae286afbf8fe15d5b)…done<br>[root@k8s-master k8s]# ctr images ls | grep calico&#x2F;node<br>docker.io&#x2F;calico&#x2F;node:v3.26.1 application&#x2F;vnd.docker.distribution.manifest.v2+json sha256:568fb25384d6460176b5528381a2d6fef36d110cfaddda5ae286afbf8fe15d5b 247.7 MiB linux&#x2F;arm64 -<br>[root@k8s-master k8s]# kubectl -n kube-system delete pod -l k8s-app&#x3D;calico-node</p>
<p>（你刚才就是 <code>calico_cni</code> 拉失败）</p>
<p>你可以用如下命令一口气替换：</p>
<pre><code>sed -i &#39;s@docker.io/calico/cni@registry.cn-hangzhou.aliyuncs.com/chenby/calico_cni@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/pod2daemon-flexvol@registry.cn-hangzhou.aliyuncs.com/chenby/calico_pod2daemon-flexvol@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/node@registry.cn-hangzhou.aliyuncs.com/chenby/calico_node@g&#39; calico.yaml
sed -i &#39;s@docker.io/calico/kube-controllers@registry.cn-hangzhou.aliyuncs.com/chenby/calico_kube-controllers@g&#39; calico.yaml
</code></pre>
<hr>
<h3 id="🔧-步骤四：重新部署"><a href="#🔧-步骤四：重新部署" class="headerlink" title="🔧 步骤四：重新部署"></a>🔧 步骤四：重新部署</h3><pre><code>kubectl apply -f calico.yaml
</code></pre>
</blockquote>
<blockquote>
<p>sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a target="_blank" rel="noopener" href="https://docker.m.daocloud.io&quot;,&quot;https//p5lmkba8.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;]">https://docker.m.daocloud.io&quot;,&quot;https://p5lmkba8.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;]</a><br>}<br>EOF<br>————————————————</p>
<hr>
<hr>
<hr>
<h3 id="大坑：子节点的calico一直处于初始化无法启动解决方案"><a href="#大坑：子节点的calico一直处于初始化无法启动解决方案" class="headerlink" title="大坑：子节点的calico一直处于初始化无法启动解决方案"></a><span style="color:red"><strong>大坑：子节点的calico一直处于初始化无法启动解决方案</strong></span></h3><p>虽然都在，但关键是containerd配置是否默认用的是 <code>registry.k8s.io/pause:3.6</code> ，导致kubelet拉这个镜像时出错。</p>
<hr>
<p>请你检查并修改 <strong>containerd配置</strong>，明确指定 <code>sandbox_image</code> 用阿里云镜像：</p>
<pre><code>cat /etc/containerd/config.toml | grep sandbox_image
</code></pre>
<p>如果没设置，执行：</p>
<pre><code>containerd config default &gt; /etc/containerd/config.toml.backup
containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<p>然后编辑 <code>/etc/containerd/config.toml</code>，找到 <code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</code> 部分，加入或修改为：</p>
<pre><code>sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.6&quot;
</code></pre>
<p>保存后，重启containerd：</p>
<pre><code>systemctl restart containerd
</code></pre>
<p>然后重启 kubelet：</p>
<pre><code>systemctl restart kubelet
</code></pre>
<hr>
<p>确认 <code>containerRuntimeEndpoint</code> 在 kubelet 配置文件或启动参数中有正确指向：</p>
<pre><code>containerRuntimeEndpoint: unix:///run/containerd/containerd.sock
</code></pre>
<hr>
<p>最后删除calico-node和kube-proxy pod，触发重新调度：</p>
<pre><code>kubectl -n kube-system delete pod -l k8s-app=calico-node
kubectl -n kube-system delete pod -l k8s-app=kube-proxy
</code></pre>
<p>然后观察节点状态和Pod状态。</p>
<p><code>kubectl get nodes</code> 查看节点状态<br><code>kubectl get pods -n kube-system -o wide</code> 查看pod状态</p>
<hr>
<p>总结：<br> <strong>确保 containerd 配置里的 sandbox_image 指向阿里云镜像，避免kubelet拉不到官方registry.k8s.io的镜像导致网络插件初始化失败，从而使节点一直NotReady。</strong></p>
<hr>
<hr>
<hr>
<h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><blockquote>
<p>calico-node-xb2js                          0&#x2F;1     CrashLoopBackOff   9 (4m12s ago)   25m   192.168.200.130   k8s-node1 </p>
</blockquote>
<h3 id="❗你的-k8s-node1-上-端口-9099-被-Nginx-占用了，而这个端口正是-Calico-默认用于健康检查的端口。"><a href="#❗你的-k8s-node1-上-端口-9099-被-Nginx-占用了，而这个端口正是-Calico-默认用于健康检查的端口。" class="headerlink" title="❗你的 k8s-node1 上 端口 9099 被 Nginx 占用了，而这个端口正是 Calico 默认用于健康检查的端口。"></a>❗你的 <code>k8s-node1</code> 上 <strong>端口 <code>9099</code> 被 Nginx 占用了</strong>，而这个端口正是 <code>Calico</code> 默认用于健康检查的端口。</h3><p>导致结果就是：</p>
<blockquote>
<p><code>calico-node</code> 启动失败并反复报错 <code>listen tcp 127.0.0.1:9099: bind: address already in use</code>，Pod 状态进入 <code>CrashLoopBackOff</code>。</p>
</blockquote>
<hr>
<h2 id="✅-解决方案"><a href="#✅-解决方案" class="headerlink" title="✅ 解决方案"></a>✅ 解决方案</h2><p>你可以选 <strong>其中一个方法</strong>：</p>
<hr>
<h3 id="✅-方案一：改-Nginx-的端口（推荐）"><a href="#✅-方案一：改-Nginx-的端口（推荐）" class="headerlink" title="✅ 方案一：改 Nginx 的端口（推荐）"></a>✅ <strong>方案一：改 Nginx 的端口（推荐）</strong></h3><ol>
<li><p>找到你的 <code>nginx</code> 配置文件（通常在 <code>vi /etc/nginx/nginx.conf</code> 或 <code>/etc/nginx/conf.d/xxx.conf</code>）</p>
</li>
<li><p>修改 <code>listen 9877;</code> 为其他端口，比如 <code>listen 8081;</code></p>
</li>
<li><p>重启 nginx：</p>
<pre><code>systemctl restart nginx
</code></pre>
</li>
<li><p>删除重启 <code>calico-node</code> Pod：</p>
<pre><code>kubectl delete pod -n kube-system -l k8s-app=calico-node --field-selector spec.nodeName=k8s-node1
</code></pre>
</li>
<li><p>等待 Pod 变成 <code>Running</code> 状态。</p>
</li>
</ol>
</blockquote>
<h3 id="基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-下"><a href="#基于Kubernetes-x2F-K8S构建Jenkins持续集成平台-下" class="headerlink" title="基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(下)"></a>基于Kubernetes&#x2F;K8S构建Jenkins持续集成平台(下)</h3><h4 id="安装和配置NFS文件共享服务器"><a href="#安装和配置NFS文件共享服务器" class="headerlink" title="安装和配置NFS文件共享服务器"></a>安装和配置NFS文件共享服务器</h4><h6 id="安装和配置-NFS"><a href="#安装和配置-NFS" class="headerlink" title="安装和配置 NFS"></a>安装和配置 NFS</h6><p>NFS（Network File System），它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。我们可以利用NFS共享Jenkins运行的配置文件、Maven的仓库依赖文件等</p>
<p>我们把NFS服务器安装在192.168.200.129机器上</p>
<ul>
<li><p>安装NFS服务（在所有K8S的节点都需要安装）</p>
<p><code>yum install -y nfs-utils</code> 【仅此这个都要运行】 </p>
</li>
<li><p>创建共享目录</p>
<pre><code class="yaml">mkdir -p /opt/nfs/jenkins
编写NFS的共享配置：
vi /etc/exports      
内容如下:  代表对所有IP都开放此目录，rw是读写
【no_root_suqash root用户生成的数据不做身份转换，也就原来是root，归root用户管理。权限太大实际需要评估】
/opt/nfs/jenkins    *(rw,no_root_squash)           
</code></pre>
</li>
<li><p>启动服务</p>
<pre><code class="yaml">systemctl enable nfs   开机启动
systemctl start nfs    启动
</code></pre>
</li>
<li><p>查看NFS共享目录</p>
<pre><code class="yaml">showmount -e 192.168.200.129
在这之前也要安装nfs服务：yum install -y nfs-utils
</code></pre>
<blockquote>
<p>[root@k8s-node1 ~]# showmount -e 192.168.200.129<br>Export list for 192.168.200.129:<br>&#x2F;opt&#x2F;nfs&#x2F;jenkins *</p>
</blockquote>
</li>
</ul>
<h3 id="在Kubernetes安装Jenkins-Master"><a href="#在Kubernetes安装Jenkins-Master" class="headerlink" title="在Kubernetes安装Jenkins-Master"></a>在Kubernetes安装Jenkins-Master</h3><h5 id="创建NFS-client-provisioner"><a href="#创建NFS-client-provisioner" class="headerlink" title="创建NFS client provisioner"></a>创建NFS client provisioner</h5><p>nfs-client-provisioner 是一个Kubernetes的简易NFS的外部provisioner，本身不提供NFS，需要现有 的NFS服务器提供存储。</p>
<ul>
<li><p>上传nfs-client-provisioner构建文件</p>
<p>把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\k8s-jenkins</code>的<code>jenkins-master</code>和<code>nfs-client</code>上传到129Jenkins虚拟机上面</p>
<blockquote>
<p>[root@k8s-master ~]# cd jenkins-master&#x2F;<br>[root@k8s-master jenkins-master]# ll<br>总用量 16<br>-rw-r–r– 1 root root 1874 7月   7 15:59 rbac.yaml<br>-rw-r–r– 1 root root   87 7月   7 15:59 ServiceaAcount.yaml<br>-rw-r–r– 1 root root  284 7月   7 15:59 Service.yaml      【对外暴露信息】<br>-rw-r–r– 1 root root 2116 7月   7 15:59 StatefulSet.yaml 【有状态应用】</p>
<p>[root@k8s-master ~]# cd nfs-client&#x2F;<br>[root@k8s-master nfs-client]# ll<br>总用量 12<br>-rw-r–r– 1 root root  225 7月   7 16:03 class.yaml<br>-rw-r–r– 1 root root  985 7月   7 16:03 deployment.yaml<br>-rw-r–r– 1 root root 1526 7月   7 16:03 rbac.yaml<br>[root@k8s-master nfs-client]# <code>vi deployment.yaml</code><br>修改里面的地址为主节点Jenkins的</p>
</blockquote>
</li>
<li><p>构建nfs-client-provisioner的pod资源</p>
<pre><code class="yaml">cd nfs-client
kubectl create -f .
</code></pre>
</li>
<li><p>查看pod是否创建成功<br><code>kubectl get pods</code></p>
<blockquote>
<p>[root@k8s-master nfs-client]# kubectl get pods<br>NAME                                      READY   STATUS              RESTARTS   AGE<br>nfs-client-provisioner-68cd5845b6-dqqm2   0&#x2F;1     ContainerCreating   0          15s</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><span style="color:red"><strong>这里也有个拉镜像的问题 deployment.yaml的lizhenliang&#x2F;nfs-client-provisioner:latest</strong></span></p>
<p>接下来操作步骤：</p>
<h3 id="1-修改你的-deployment-yaml-中的镜像字段，改成刚拉取的镜像："><a href="#1-修改你的-deployment-yaml-中的镜像字段，改成刚拉取的镜像：" class="headerlink" title="1. 修改你的 deployment.yaml 中的镜像字段，改成刚拉取的镜像："></a>1. 修改你的 <code>deployment.yaml</code> 中的镜像字段，改成刚拉取的镜像：</h3><pre><code>containers:
  - name: nfs-client-provisioner
    image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
    # 其他配置保持不变
</code></pre>
<p>确保 <code>env</code> 和 <code>volumes</code> 中 NFS 服务器地址及路径正确，和你之前确认的一致。</p>
<hr>
<h3 id="2-应用更新后的-Deployment-配置："><a href="#2-应用更新后的-Deployment-配置：" class="headerlink" title="2. 应用更新后的 Deployment 配置："></a>2. 应用更新后的 Deployment 配置：</h3><pre><code>kubectl apply -f deployment.yaml
</code></pre>
<hr>
<h3 id="3-查看-Pod-状态："><a href="#3-查看-Pod-状态：" class="headerlink" title="3. 查看 Pod 状态："></a>3. 查看 Pod 状态：</h3><pre><code>kubectl get pods -w
</code></pre>
<p>等待 Pod 状态变成 <code>Running</code> 和 <code>READY 1/1</code>。</p>
<blockquote>
<p>[root@k8s-master nfs-client]# kubectl get pods -w<br>NAME                                      READY   STATUS    RESTARTS   AGE<br>nfs-client-provisioner-7d79bcf5d4-tddhl   1&#x2F;1     Running   0          3m33s</p>
</blockquote>
<pre><code class="yaml">可用的deployment.yaml 位置在129机器的/root/nfs-client

apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: nfs-client-provisioner
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              value: 192.168.200.129 
            - name: NFS_PATH
              value: /opt/nfs/jenkins/
      volumes:
        - name: nfs-client-root
          nfs:
            server: 192.168.200.129
            path: /opt/nfs/jenkins/
</code></pre>
</blockquote>
<ul>
<li><p>返回<code>jenkins-master</code>目录</p>
<blockquote>
<p>[root@k8s-master ~]# cd jenkins-master&#x2F;<br>[root@k8s-master jenkins-master]#<br>[root@k8s-master jenkins-master]# <code>kubectl create namespace kube-ops</code><br>namespace&#x2F;kube-ops created<br>[root@k8s-master jenkins-master]# <code>kubectl create -f .</code><br>✅ 如果你只是想重新部署，可以改用 <code>kubectl apply -f .</code> （<strong>推荐</strong>，用于更新已有资源）</p>
<p>❌ 如果你要重新初始化，先删除旧资源：</p>
<pre><code>kubectl delete -f . &amp;&amp; kubectl create -f .
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<p><span style="color:red">这里报错因为有一些过时了的 需要更改 注意是在<code>/root/jenkins-master</code>中的rbac.yaml</span><br>你这个问题根源就是 apiVersion 使用了 <code>rbac.authorization.k8s.io/v1beta1</code>，新版 Kubernetes 不再支持这个版本了，必须改成 <code>rbac.authorization.k8s.io/v1</code>。</p>
<p>另外，你 <code>ClusterRole</code> 不应该带 <code>namespace</code> 字段，因为 ClusterRole 是集群级别的资源，不属于某个命名空间。</p>
<hr>
<p>我帮你改成符合最新标准的版本，注意几点：</p>
<ul>
<li>所有 <code>rbac.authorization.k8s.io/v1beta1</code> 改为 <code>rbac.authorization.k8s.io/v1</code></li>
<li>删除 <code>ClusterRole</code> 中的 <code>namespace</code></li>
<li>Role 和 RoleBinding 保留 <code>namespace: kube-ops</code></li>
<li>RoleBinding 和 ClusterRoleBinding 中的 <code>subjects</code> namespace 保持和 ServiceAccount 一致</li>
</ul>
<pre><code class="yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkins
  namespace: kube-ops
rules:
  - apiGroups: [&quot;extensions&quot;, &quot;apps&quot;]
    resources: [&quot;deployments&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;services&quot;]
    verbs: [&quot;create&quot;, &quot;delete&quot;, &quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;patch&quot;, &quot;update&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/exec&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/log&quot;]
    verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;secrets&quot;]
    verbs: [&quot;get&quot;]

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkins
  namespace: kube-ops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: jenkins
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: kube-ops

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkinsClusterRole
rules:
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/exec&quot;]
    verbs: [&quot;create&quot;,&quot;delete&quot;,&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;pods/log&quot;]
    verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;]
  - apiGroups: [&quot;&quot;]
    resources: [&quot;secrets&quot;]
    verbs: [&quot;get&quot;]

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: jenkinsClusterRoleBinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkinsClusterRole
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: kube-ops
</code></pre>
<p>保存后，用：</p>
<pre><code>kubectl apply -f rbac.yaml
</code></pre>
<p>应该就不会再报找不到资源类型的错误了。</p>
<blockquote>
<p>成功！！<br>service&#x2F;jenkins created<br>serviceaccount&#x2F;jenkins created<br>statefulset.apps&#x2F;jenkins created<br>role.rbac.authorization.k8s.io&#x2F;jenkins created<br>rolebinding.rbac.authorization.k8s.io&#x2F;jenkins created<br>clusterrole.rbac.authorization.k8s.io&#x2F;jenkinsClusterRole created<br>clusterrolebinding.rbac.authorization.k8s.io&#x2F;jenkinsClusterRoleBinding created</p>
</blockquote>
<hr>
<hr>
<p>输入<code>kubectl get pod --namespace kube-ops</code></p>
</blockquote>
<ul>
<li><blockquote>
<p>[root@k8s-master jenkins-master]# <code>kubectl get pod --namespace kube-ops</code><br>NAME        READY   STATUS    RESTARTS   AGE</p>
<p>[root@k8s-master jenkins-master]# <code>kubectl get service --namespace kube-ops</code><br>更详细的查看：<code>kubectl get service --namespace kube-ops -o wide</code><br>NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                          AGE<br>jenkins   NodePort   10.1.85.222   <none>        8080:30742&#x2F;TCP,50000:31261&#x2F;TCP   8m1s</p>
</blockquote>
</li>
</ul>
<blockquote>
<h3 id="如果不能running看这里！"><a href="#如果不能running看这里！" class="headerlink" title="如果不能running看这里！"></a><span style = "color:red">如果不能running看这里！</span></h3><p>你应该把 Deployment 里的镜像改成 <code>quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11</code>，这样 Pod 就能正常拉镜像启动了。</p>
<hr>
<h3 id="正确示例片段改成："><a href="#正确示例片段改成：" class="headerlink" title="正确示例片段改成："></a>正确示例片段改成：</h3><pre><code>containers:
  - name: nfs-client-provisioner
    image: quay.io/external_storage/nfs-client-provisioner:v3.1.0-k8s1.11
    volumeMounts:
      - name: nfs-client-root
        mountPath: /persistentvolumes
    env:
      - name: PROVISIONER_NAME
        value: fuseim.pri/ifs
      - name: NFS_SERVER
        value: 192.168.200.129
      - name: NFS_PATH
        value: /opt/nfs/jenkins/
volumes:
  - name: nfs-client-root
    nfs:
      server: 192.168.200.129
      path: /opt/nfs/jenkins/
</code></pre>
<hr>
<p>改完后执行：</p>
<pre><code>、kubectl apply -f deployment.yaml
kubectl delete pod -n default -l app=nfs-client-provisioner
kubectl get pods -n default -w
</code></pre>
<p>确认 Pod 快速启动且状态为 Running。</p>
<hr>
<p>这样 PVC 才能被正确绑定，<code>jenkins</code> 的 PVC Pending 状态才会解决。</p>
<hr>
<hr>
<hr>
<p>你这边已经非常接近解决了，目前的 <strong>唯一问题是 Provisioner 报了 <code>selfLink was empty, can&#39;t make reference</code> 的错误</strong>，这在 Kubernetes v1.20+ 中是<strong>常见兼容性问题</strong>，因为 <code>selfLink</code> 字段已经被弃用并默认禁用了。</p>
<hr>
<h2 id="✅-当前现状确认："><a href="#✅-当前现状确认：" class="headerlink" title="✅ 当前现状确认："></a>✅ 当前现状确认：</h2><table>
<thead>
<tr>
<th>项目</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>NFS 服务</td>
<td>正常可挂载 ✅</td>
</tr>
<tr>
<td>Jenkins PVC</td>
<td>一直 Pending ❌</td>
</tr>
<tr>
<td>Provisioner Pod 状态</td>
<td>Running ✅</td>
</tr>
<tr>
<td>Provisioner 日志报错</td>
<td><code>selfLink</code> ❌</td>
</tr>
<tr>
<td>StorageClass&#x2F;Provisioner 名</td>
<td>一致 ✅</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚨-问题根因"><a href="#🚨-问题根因" class="headerlink" title="🚨 问题根因"></a>🚨 问题根因</h2><p><code>nfs-client-provisioner</code> 的<strong>老版本</strong>依赖了 <code>selfLink</code> 字段，但你用的是 <strong>Kubernetes v1.28</strong>，从 v1.20 起 <code>selfLink</code> 默认禁用，导致：</p>
<pre><code>unexpected error getting claim reference: selfLink was empty, can&#39;t make reference
</code></pre>
<h3 id="✅-解决方案：用国内镜像源代替"><a href="#✅-解决方案：用国内镜像源代替" class="headerlink" title="✅ 解决方案：用国内镜像源代替"></a>✅ 解决方案：用国内镜像源代替</h3><p>我推荐你使用 阿里云加速镜像 或 [DockerHub 镜像代理]。下面我给你一份修改好的 <code>deployment.yaml</code>，使用了国内可访问的镜像仓库地址。</p>
<hr>
<h3 id="✅-修改后的-deployment-yaml（适配国内镜像源）"><a href="#✅-修改后的-deployment-yaml（适配国内镜像源）" class="headerlink" title="✅ 修改后的 deployment.yaml（适配国内镜像源）"></a>✅ 修改后的 <code>deployment.yaml</code>（适配国内镜像源）</h3><pre><code>yaml复制编辑apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: nfs-client-provisioner
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: registry.cn-hangzhou.aliyuncs.com/zhangshijie/nfs-subdir-external-provisioner:v4.0.2
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: fuseim.pri/ifs
            - name: NFS_SERVER
              value: 192.168.200.129
            - name: NFS_PATH
              value: /opt/nfs/jenkins/
      volumes:
        - name: nfs-client-root
          nfs:
            server: 192.168.200.129
            path: /opt/nfs/jenkins/
</code></pre>
<hr>
<h3 id="📌-操作步骤"><a href="#📌-操作步骤" class="headerlink" title="📌 操作步骤"></a>📌 操作步骤</h3><ol>
<li>把上面内容保存为 <code>deployment.yaml</code></li>
<li>应用并重建：</li>
</ol>
<pre><code>kubectl apply -f deployment.yaml
kubectl delete pod -n default -l app=nfs-client-provisioner
</code></pre>
<ol>
<li>然后检查 PVC 状态是否变成 <code>Bound</code>：</li>
</ol>
<pre><code>kubectl get pvc -n kube-ops
</code></pre>
<h3 id="这里是第二种方法-已尝试可行-！"><a href="#这里是第二种方法-已尝试可行-！" class="headerlink" title="这里是第二种方法[已尝试可行]！"></a><span style = "color:red">这里是第二种方法[已尝试可行]！</span></h3><p><code>/root/jenkins-master/</code></p>
<p>你贴出来的 <code>StatefulSet.yaml</code> 文件已经包含了镜像配置的位置！</p>
<hr>
<h3 id="🎯-问题就在这一段："><a href="#🎯-问题就在这一段：" class="headerlink" title="🎯 问题就在这一段："></a>🎯 问题就在这一段：</h3><pre><code>yaml复制编辑containers:
  - name: jenkins
    image: jenkins/jenkins:lts-alpine  👈 就是这行！！！
</code></pre>
<p>这个 <code>image:</code> 指定的镜像目前拉不下来（你刚才试图用的是阿里云镜像，结果不存在），所以你现在只需要 <strong>改成可用的镜像地址</strong>。</p>
<hr>
<h3 id="✅-推荐改法如下："><a href="#✅-推荐改法如下：" class="headerlink" title="✅ 推荐改法如下："></a>✅ 推荐改法如下：</h3><pre><code>yaml复制编辑containers:
  - name: jenkins
    image: jenkins/jenkins:lts-jdk17   # ✅ 推荐：可拉取的官方 Jenkins 镜像
    imagePullPolicy: IfNotPresent
</code></pre>
<blockquote>
<p>💡这是 Jenkins 官方最新稳定版本（带 JDK 17）的镜像，在 Docker Hub 可用，国内访问可能慢一点，但比你原来的阿里云镜像靠谱。</p>
</blockquote>
<hr>
<h3 id="🛠-修改步骤："><a href="#🛠-修改步骤：" class="headerlink" title="🛠 修改步骤："></a>🛠 修改步骤：</h3><ol>
<li><p>打开 <code>StatefulSet.yaml</code>：</p>
<pre><code>vim StatefulSet.yaml
</code></pre>
</li>
<li><p>找到：</p>
<pre><code>image: jenkins/jenkins:lts-alpine
</code></pre>
</li>
<li><p>改成：</p>
<pre><code>image: jenkins/jenkins:lts-jdk17
</code></pre>
</li>
<li><p>保存退出（按 <code>Esc</code> 然后输入 <code>:wq</code>）</p>
</li>
</ol>
<hr>
<h3 id="🔁-然后重新部署："><a href="#🔁-然后重新部署：" class="headerlink" title="🔁 然后重新部署："></a>🔁 然后重新部署：</h3><pre><code>kubectl apply -f StatefulSet.yaml
kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<blockquote>
<p>第二条命令是为了立刻让 Pod 使用新镜像重建。</p>
</blockquote>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          4s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          8s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          9s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          10s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          19s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          24s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          31s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          32s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS             RESTARTS   AGE jenkins-0   0&#x2F;1     ImagePullBackOff   0          47s [root@k8s-master jenkins-master]#</p>
</blockquote>
<p>很好，你的 Jenkins Pod 现在变成了：</p>
<pre><code>STATUS: ImagePullBackOff
</code></pre>
<hr>
<h2 id="✅-这说明你已经修改成功了，但节点还是拉不到镜像。"><a href="#✅-这说明你已经修改成功了，但节点还是拉不到镜像。" class="headerlink" title="✅ 这说明你已经修改成功了，但节点还是拉不到镜像。"></a>✅ <strong>这说明你已经修改成功了，但节点还是拉不到镜像。</strong></h2><p>我们确认下你用了哪个镜像，执行：</p>
<pre><code>kubectl get pod jenkins-0 -n kube-ops -o=jsonpath=&#39;&#123;.spec.containers[0].image&#125;&#39;
</code></pre>
<p>你应该看到输出类似于：</p>
<pre><code>jenkins/jenkins:lts-jdk17
</code></pre>
<p>然后我们来排查下一步。</p>
<hr>
<h2 id="🧭-下一步：去节点上测试能否手动拉取镜像"><a href="#🧭-下一步：去节点上测试能否手动拉取镜像" class="headerlink" title="🧭 下一步：去节点上测试能否手动拉取镜像"></a>🧭 下一步：去节点上测试能否手动拉取镜像</h2><p><strong>进入 <code>k8s-node1</code> 节点（Pod 分配在哪个节点，看 <code>kubectl describe pod</code> 可以看到）</strong>：</p>
<pre><code>ssh root@k8s-node1
</code></pre>
<p>在节点上运行：</p>
<pre><code>docker pull jenkins/jenkins:lts-jdk17
</code></pre>
<p>或者如果你用的是 <code>containerd</code> 作为容器运行时：</p>
<pre><code>ctr images pull docker.io/jenkins/jenkins:lts-jdk17
</code></pre>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# clear [root@k8s-master jenkins-master]# ll 总用量 16 -rw-r–r– 1 root root 1863 7月   7 16:39 rbac.yaml -rw-r–r– 1 root root   87 7月   7 15:59 ServiceaAcount.yaml -rw-r–r– 1 root root  284 7月   7 15:59 Service.yaml -rw-r–r– 1 root root 2117 7月   7 18:37 StatefulSet.yaml [root@k8s-master jenkins-master]# kubectl apply -f StatefulSet.yaml statefulset.apps&#x2F;jenkins configured [root@k8s-master jenkins-master]# kubectl delete pod jenkins-0 -n kube-ops pod “jenkins-0” deleted [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          4s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          8s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          9s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          10s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          11s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS              RESTARTS   AGE jenkins-0   0&#x2F;1     ContainerCreating   0          19s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          24s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          27s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          31s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS         RESTARTS   AGE jenkins-0   0&#x2F;1     ErrImagePull   0          32s [root@k8s-master jenkins-master]# kubectl get pod -n kube-ops NAME        READY   STATUS             RESTARTS   AGE jenkins-0   0&#x2F;1     ImagePullBackOff   0          47s [root@k8s-master jenkins-master]# ^C [root@k8s-master jenkins-master]# kubectl get pod jenkins-0 -n kube-ops -o&#x3D;jsonpath&#x3D;’{.spec.containers[0].image}’ jenkins&#x2F;jenkins:lts-jdk17[root@k8s-master jenkins-master]# ssh root@k8s-node1 The authenticity of host ‘k8s-node1 (192.168.200.130)’ can’t be established. ECDSA key fingerprint is SHA256:LMkCxwuWrKBih+Iy+lnayVkAyKdVG7JpVVR3TctpMuk. ECDSA key fingerprint is MD5:c1:76:72:fb:65:64:f8:d5:71:5b:38:a8:9b:07:a6:e6. Are you sure you want to continue connecting (yes&#x2F;no)? docker pull jenkins&#x2F;jenkins:lts-jdk17 Please type ‘yes’ or ‘no’: yes Warning: Permanently added ‘k8s-node1’ (ECDSA) to the list of known hosts. root@k8s-node1’s password: Permission denied, please try again. root@k8s-node1’s password: Last failed login: Mon Jul  7 18:39:33 CST 2025 from k8s-master on ssh:notty There was 1 failed login attempt since the last successful login. Last login: Mon Jul  7 17:36:26 2025 from 192.168.200.2 [root@k8s-node1 ~]# docker pull jenkins&#x2F;jenkins:lts-jdk17 lts-jdk17: Pulling from jenkins&#x2F;jenkins 0c01110621e0: Pull complete 2315362e4443: Pull complete 4185f63a4bf1: Pull complete 51c9d25ed578: Pull complete 10709260192c: Pull complete 474c0ab7c65d: Pull complete 62d5bb186774: Pull complete f1c4b8ee4b6f: Pull complete 065b78ceb30c: Pull complete b99138e4f420: Pull complete e05a8359c72d: Pull complete 981fa0afce25: Pull complete Digest: sha256:dd570585c3adadefcfbeba915e27bf7feca1815a0ea8a659d46b51f54fc7ea06 Status: Downloaded newer image for jenkins&#x2F;jenkins:lts-jdk17 [root@k8s-node1 ~]#</p>
</blockquote>
<p>太好了！你已经在 <code>k8s-node1</code> 节点上 <strong>成功拉下来了 Jenkins 的镜像</strong>：</p>
<pre><code>bash


复制编辑
✅ jenkins/jenkins:lts-jdk17 拉取成功！
</code></pre>
<hr>
<h3 id="❓但为什么-Pod-还是拉不到？"><a href="#❓但为什么-Pod-还是拉不到？" class="headerlink" title="❓但为什么 Pod 还是拉不到？"></a>❓但为什么 Pod 还是拉不到？</h3><p>Kubernetes 默认不会自动使用你用 <code>docker pull</code> 拉下来的镜像，除非你的 K8s 用的容器运行时 <strong>就是 Docker</strong>。</p>
<p>现在我们确认一下你的容器运行时是不是 Docker，执行下面的命令：</p>
<pre><code>bash


复制编辑
ps -ef | grep kubelet | grep -v grep
</code></pre>
<p>看结果里面有没有：</p>
<ul>
<li><code>--container-runtime=docker</code> ✅（说明用的是 Docker）</li>
<li>或者有 <code>containerd</code> 或 <code>cri-o</code> ❌（说明用的是 containerd，不会用 docker 拉的镜像）</li>
</ul>
<hr>
<h3 id="✅-如果你看到用的是-containerd（大概率是）"><a href="#✅-如果你看到用的是-containerd（大概率是）" class="headerlink" title="✅ 如果你看到用的是 containerd（大概率是）"></a>✅ 如果你看到用的是 <code>containerd</code>（大概率是）</h3><p>那你就需要把 Docker 拉下来的镜像导入给 <code>containerd</code> 用！</p>
<hr>
<h2 id="🔄-导入镜像到-containerd-的方法如下："><a href="#🔄-导入镜像到-containerd-的方法如下：" class="headerlink" title="🔄 导入镜像到 containerd 的方法如下："></a>🔄 导入镜像到 <code>containerd</code> 的方法如下：</h2><ol>
<li><strong>在 <code>k8s-node1</code> 节点上保存镜像为 tar 包：</strong></li>
</ol>
<pre><code>docker save jenkins/jenkins:lts-jdk17 -o jenkins.tar
</code></pre>
<ol>
<li><strong>用 <code>ctr</code> 命令导入给 containerd 使用：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images import jenkins.tar
</code></pre>
<ol>
<li><strong>验证 containerd 已经识别：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images ls | grep jenkins
</code></pre>
<p>你应该看到 <code>docker.io/jenkins/jenkins:lts-jdk17</code> 这一行。</p>
<hr>
<h2 id="🔁-然后重启-Pod："><a href="#🔁-然后重启-Pod：" class="headerlink" title="🔁 然后重启 Pod："></a>🔁 然后重启 Pod：</h2><pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<p>过一会再执行：</p>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>你现在在 <strong>master 节点（192.168.200.129）</strong>，但 Jenkins Pod 被调度到 <strong>node1 节点（192.168.200.130）</strong>，所以镜像必须在 node1 上可用。而你刚才是手动在 node1 上 <code>docker pull</code> 了 Jenkins 镜像，这一步做得 ✅<strong>没问题</strong>。</p>
<hr>
<h2 id="✅-问题核心确认"><a href="#✅-问题核心确认" class="headerlink" title="✅ 问题核心确认"></a>✅ 问题核心确认</h2><blockquote>
<p>你当前用的是 Kubernetes，但默认的容器运行时 <strong>不是 Docker，而是 containerd</strong>，所以：</p>
<p>❗ <strong>你用 <code>docker pull</code> 拉下的镜像 containerd 用不到</strong></p>
</blockquote>
<hr>
<h2 id="✅-解决方案：把-docker-镜像导入到-containerd-里"><a href="#✅-解决方案：把-docker-镜像导入到-containerd-里" class="headerlink" title="✅ 解决方案：把 docker 镜像导入到 containerd 里"></a>✅ 解决方案：把 docker 镜像导入到 containerd 里</h2><h3 id="在-node1-上（192-168-200-130）执行以下命令："><a href="#在-node1-上（192-168-200-130）执行以下命令：" class="headerlink" title="在 node1 上（192.168.200.130）执行以下命令："></a>在 node1 上（192.168.200.130）执行以下命令：</h3><ol>
<li><strong>把镜像导出为 tar 包</strong></li>
</ol>
<pre><code>docker save jenkins/jenkins:lts-jdk17 -o jenkins.tar
</code></pre>
<ol>
<li><strong>导入到 containerd：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images import jenkins.tar
</code></pre>
<ol>
<li><strong>检查 containerd 是否导入成功：</strong></li>
</ol>
<pre><code>ctr -n k8s.io images ls | grep jenkins
</code></pre>
<p>你应该看到输出类似：</p>
<pre><code>docker.io/jenkins/jenkins:lts-jdk17 ...
</code></pre>
<hr>
<h2 id="🔄-然后，在-master-节点（192-168-200-129）上执行："><a href="#🔄-然后，在-master-节点（192-168-200-129）上执行：" class="headerlink" title="🔄 然后，在 master 节点（192.168.200.129）上执行："></a>🔄 然后，在 master 节点（192.168.200.129）上执行：</h2><pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<p>等 10~20 秒后看 Pod 是否启动成功：</p>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>看到状态变为：</p>
<pre><code>jenkins-0   1/1     Running
</code></pre>
<p>就说明一切 OK ✅！</p>
<p>你现在遇到的问题是：</p>
<blockquote>
<p>⚠️ <strong>在 <code>node1（130）</code> 节点上运行 <code>kubectl</code> 命令时，K8s API server 无法正常访问，提示 <code>the server could not find the requested resource</code>。</strong></p>
</blockquote>
<p>这是因为：<br> 👉 <code>kubectl</code> 命令只能在 <strong>已配置好 K8s 集群访问权限的节点上使用</strong>，通常是 <strong>master 节点（192.168.200.129）</strong>。</p>
<hr>
<h2 id="✅-正确操作流程如下："><a href="#✅-正确操作流程如下：" class="headerlink" title="✅ 正确操作流程如下："></a>✅ 正确操作流程如下：</h2><h3 id="🔁-你刚才在-node1-上导入-containerd-镜像已经成功了，现在："><a href="#🔁-你刚才在-node1-上导入-containerd-镜像已经成功了，现在：" class="headerlink" title="🔁 你刚才在 node1 上导入 containerd 镜像已经成功了，现在："></a>🔁 <strong>你刚才在 node1 上导入 containerd 镜像已经成功了</strong>，现在：</h3><ol>
<li><strong>返回到 master 节点（192.168.200.129）</strong></li>
<li><strong>执行删除 pod 的命令（由 master 控制）</strong>：</li>
</ol>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
</code></pre>
<ol>
<li><strong>查看 pod 状态：</strong></li>
</ol>
<pre><code>kubectl get pod -n kube-ops
</code></pre>
<p>你应该看到 <code>jenkins-0</code> 在 <code>node1</code> 上重新启动，并变成 <code>Running</code> 状态。</p>
<p>你现在正登录在 <strong>node1 节点（192.168.200.130）</strong>，而你的 <code>kubectl</code> 应该在 <strong>master 节点（192.168.200.129）</strong> 上执行。</p>
<hr>
<h3 id="✅-回到-master-节点的方法："><a href="#✅-回到-master-节点的方法：" class="headerlink" title="✅ 回到 master 节点的方法："></a>✅ 回到 master 节点的方法：</h3><p>只要你是通过 SSH 登录进来的，<strong>直接输入 <code>exit</code> 或按 <code>Ctrl+D</code></strong> 即可退出当前 SSH 会话，返回 master 节点：</p>
<pre><code>[root@k8s-node1 ~]# exit
</code></pre>
<p>或</p>
<pre><code>[root@k8s-node1 ~]# logout
</code></pre>
<p>然后你就会看到：</p>
<pre><code>[root@k8s-master ~]#
</code></pre>
<p>这时候你就在 master 节点上了！</p>
<hr>
<h3 id="🧠-提醒：kubectl-只能在-master-上执行"><a href="#🧠-提醒：kubectl-只能在-master-上执行" class="headerlink" title="🧠 提醒：kubectl 只能在 master 上执行"></a>🧠 提醒：kubectl 只能在 master 上执行</h3><p>比如这些命令：</p>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
kubectl get pods -n kube-ops
kubectl logs jenkins-0 -n kube-ops
</code></pre>
<p>都需要在 <strong>master 节点（192.168.200.129）</strong> 上执行，其他 node 节点默认是没有权限或 kubeconfig 配置的。</p>
<hr>
<p>现在你可以：</p>
<p>✅ 先退出 <code>node1</code>：</p>
<pre><code>exit
</code></pre>
<p>✅ 然后在 master 上执行：</p>
<pre><code>kubectl delete pod jenkins-0 -n kube-ops
kubectl get pod -n kube-ops -w
</code></pre>
<h4 id="成功！！！！"><a href="#成功！！！！" class="headerlink" title="成功！！！！"></a>成功！！！！</h4><blockquote>
<p>[root@k8s-master jenkins-master]# kubectl get pod -n kube-ops<br>NAME        READY   STATUS    RESTARTS   AGE<br>jenkins-0   1&#x2F;1     Running   0          7m39s<br>[root@k8s-master jenkins-master]#</p>
</blockquote>
</blockquote>
<ul>
<li><p>承接上文！！<br><code> kubectl get service --namespace kube-ops</code> 得到端口号</p>
<blockquote>
<p>[root@k8s-master jenkins-master]# kubectl get service –namespace kube-ops<br>NAME      TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)                          AGE<br>jenkins   NodePort   10.1.85.222   <none>        8080:30742&#x2F;TCP,50000:31261&#x2F;TCP   3h3m</p>
</blockquote>
<p>访问即可：<a target="_blank" rel="noopener" href="http://192.168.200.130:30742/">http://192.168.200.130:30742/</a><br>如何查密码？</p>
<blockquote>
<h5 id="解锁-Jenkins"><a href="#解锁-Jenkins" class="headerlink" title="解锁 Jenkins"></a>解锁 Jenkins</h5><p>为了确保管理员安全地安装 Jenkins，密码已写入到日志中（<a target="_blank" rel="noopener" href="https://www.jenkins.io/redirect/find-jenkins-logs">不知道在哪里？</a>）该文件在服务器上：</p>
<pre><code>/var/jenkins_home/secrets/initialAdminPassword
</code></pre>
<p>请从本地复制密码并粘贴到下面。</p>
<p>管理员密码：</p>
</blockquote>
<p><code>cd /opt/nfs/jenkins</code><br><code>ll</code><br><code>cd kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e </code><br><code> cd secrets</code><br><code>cat initialAdminPassword</code></p>
<blockquote>
<p>[root@k8s-master jenkins-master]# cd &#x2F;opt&#x2F;nfs<br>[root@k8s-master nfs]# ll<br>总用量 0<br>drwxr-xr-x 3 root root 86 7月   7 17:13 jenkins<br>[root@k8s-master nfs]# cd jenkins&#x2F;<br>[root@k8s-master jenkins]# ll<br>总用量 4<br>drwxrwxrwx 11 root root 4096 7月   7 19:10 kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e</p>
<p>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# ll<br>总用量 28<br>-rw-r–r–  1 sonar 1000 1663 7月   7 18:58 config.xml<br>-rw-r–r–  1 sonar 1000  216 7月   7 18:57 copy_reference_file.log<br>-rw-r–r–  1 sonar 1000  156 7月   7 18:58 hudson.model.UpdateCenter.xml<br>-rw-r–r–  1 sonar 1000  171 7月   7 18:55 jenkins.telemetry.Correlator.xml<br>drwxr-xr-x  2 sonar 1000    6 7月   7 18:55 jobs<br>-rw-r–r–  1 sonar 1000 1037 7月   7 18:58 nodeMonitors.xml<br>drwxr-xr-x  2 sonar 1000    6 7月   7 18:55 plugins<br>-rw-r–r–  1 sonar 1000  258 7月   7 18:57 queue.xml.bak<br>-rw-r–r–  1 sonar 1000   64 7月   7 18:55 secret.key<br>-rw-r–r–  1 sonar 1000    0 7月   7 18:55 secret.key.not-so-secret<br>drwx——  2 sonar 1000   91 7月   7 18:55 secrets<br>drwxr-xr-x  2 sonar 1000   67 7月   7 18:58 updates<br>drwxr-xr-x  2 sonar 1000   24 7月   7 18:55 userContent<br>drwxr-xr-x  3 sonar 1000   56 7月   7 18:55 users<br>drwxr-xr-x 10 sonar 1000  247 7月   7 18:55 war</p>
<p>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# ^C<br>[root@k8s-master kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e]# cd secrets<br>[root@k8s-master secrets]# ll<br>总用量 12<br>-rw-r—– 1 sonar 1000  33 7月   7 18:55 initialAdminPassword<br>-rw-r–r– 1 sonar 1000  32 7月   7 18:55 jenkins.model.Jenkins.crumbSalt<br>-rw-r–r– 1 sonar 1000 256 7月   7 18:55 master.key<br>[root@k8s-master secrets]# <code>cat initialAdminPassword</code><br>7a2c40f15a564286aac63f61b9f20b95   【复制它去上面管理员密码解锁！！】</p>
</blockquote>
</li>
<li><p>创建管理员用户前选自选安装 → 无 → 账号：root   密码：panchunyao123<br>Jenkins URL：<a target="_blank" rel="noopener" href="http://192.168.200.130:30742/">http://192.168.200.130:30742/</a><br>这里面的插件和配置延续之前129机器上的</p>
<blockquote>
<p><code>cd /opt/nfs/jenkins/kube-ops-jenkins-home-jenkins-0-pvc-18f7c50d-f5e6-443d-ab24-2ebd09b88a2e/updates</code></p>
<p>输入[替换国内地址]：<code>sed -i &#39;s/http:\/\/updates.jenkins ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/ www.google.com/https:\/\/ www.baidu.com/g&#39; default.json</code></p>
<p>最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a><br>上面这个不行就按照老的来吧<br><a target="_blank" rel="noopener" href="https://updates.jenkins.io/update-center.json">https://updates.jenkins.io/update-center.json</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.200.129:8888/restart">http://192.168.200.129:8888/restart</a> 重启Jenkins</p>
</blockquote>
</li>
<li><p>先安装基本的插件</p>
<ul>
<li>Localization:Chinese </li>
<li>Git </li>
<li>Pipeline </li>
<li>Extended Choice Parameter</li>
</ul>
</li>
</ul>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="Jenkins与Kubernetes整合"><a href="#Jenkins与Kubernetes整合" class="headerlink" title="Jenkins与Kubernetes整合"></a>Jenkins与Kubernetes整合</h3><h5 id="安装Kubernetes插件"><a href="#安装Kubernetes插件" class="headerlink" title="安装Kubernetes插件"></a>安装Kubernetes插件</h5><p>安装后 依次点击<code>Dashboard -&gt; 系统管理 -&gt; 云 -&gt; 新建云 -&gt; Kubernetes</code></p>
<blockquote>
<p>new cloud → cloud name：kubernetes     Type：kubernetes → create →<br>Kubernetes 地址：<a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a><br>命名空间：kube-ops<br>→ 连接测试 → Connected to Kubernetes v1.28.2<br>→ Jenkins URL地址： <a target="_blank" rel="noopener" href="http://jenkins.kube-ops.svc.cluster.local:8080/">http://jenkins.kube-ops.svc.cluster.local:8080</a><br>→ 应用 + 保存</p>
</blockquote>
<ul>
<li>kubernetes 地址采用了kube的服务器发现： <a target="_blank" rel="noopener" href="https://kubernetes.default.svc.cluster.local/">https://kubernetes.default.svc.cluster.local</a> </li>
<li>namespace 填kube-ops，然后点击Test Connection，如果出现 Connection test successful 的提 示信息证明 Jenkins 已经可以和 Kubernetes 系统正常通信 </li>
<li>Jenkins URL  地址： <a target="_blank" rel="noopener" href="http://jenkins.kube-ops.svc.cluster.local:8080/">http://jenkins.kube-ops.svc.cluster.local:8080</a></li>
</ul>
<h4 id="构建Jenkins-Slave自定义镜像"><a href="#构建Jenkins-Slave自定义镜像" class="headerlink" title="构建Jenkins-Slave自定义镜像"></a>构建Jenkins-Slave自定义镜像</h4><ul>
<li>Jenkins-Master在构建Job的时候，Kubernetes会创建Jenkins-Slave的Pod来完成Job的构建。我们选择 运行Jenkins-Slave的镜像为官方推荐镜像：jenkins&#x2F;jnlp-slave:latest，但是这个镜像里面并没有Maven 环境，为了方便使用，我们需要自定义一个新的镜像：<br>先把<code>E:\Java实例项目1-20套\资料-Jenkins教程\Jenkins资料\资料\资料\03.资料\k8s-jenkins</code>的<code>jenkins-slave</code>塞进129的<code>/root/</code>下</li>
</ul>
<blockquote>
<p>[root@k8s-master jenkins-slave]# ll<br>总用量 8948<br>-rw-r–r– 1 root root 9142315 7月   7 20:47 apache-maven-3.6.2-bin.tar.gz<br>-rw-r–r– 1 root root     556 7月   7 20:47 Dockerfile<br>-rw-r–r– 1 root root   10475 7月   7 20:47 settings.xml</p>
</blockquote>
<pre><code class="yaml"># Dockerfile

FROM jenkins/jnlp-slave:latest
MAINTAINER itcast

# 切换到 root 账户进行操作
USER root

# 安装 maven
COPY apache-maven-3.6.2-bin.tar.gz .

RUN tar -zxf apache-maven-3.6.2-bin.tar.gz &amp;&amp; \
    mv apache-maven-3.6.2 /usr/local &amp;&amp; \
    rm -f apache-maven-3.6.2-bin.tar.gz &amp;&amp; \
    ln -s /usr/local/apache-maven-3.6.2/bin/mvn /usr/bin/mvn &amp;&amp; \
    ln -s /usr/local/apache-maven-3.6.2 /usr/local/apache-maven &amp;&amp; \
    mkdir -p /usr/local/apache-maven/repo

COPY settings.xml /usr/local/apache-maven/conf/settings.xml

USER jenkins
</code></pre>
<ul>
<li><p>构建出一个新镜像：jenkins-slave-maven:latest<br><code>docker build -t jenkins-slave-maven:latest</code></p>
</li>
<li><p>然把镜像上传到Harbor的公共库library中</p>
<p>先打标签！<br><code> docker tag jenkins-slave-maven:latest 192.168.200.131:85/library/jenkins-slave-maven:latest</code><br>然后登录！<br><code> docker login -u admin -p Harbor12345 192.168.200.131:85</code></p>
</li>
</ul>
<blockquote>
<p>WARNING! Using –password via the CLI is insecure. Use –password-stdin. Error response from daemon: Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS client [root@k8s-master jenkins-slave]# docker login -u admin -p Harbor12345 192.168.200.131:85 WARNING! Using –password via the CLI is insecure. Use –password-stdin. Error response from daemon: Get <a target="_blank" rel="noopener" href="https://192.168.200.131:85/v2/">https://192.168.200.131:85/v2/</a>: http: server gave HTTP response to HTTPS client [root@k8s-master jenkins-slave]#</p>
<p>你这个错误的根本原因是：<strong>Harbor 使用的是 HTTP 协议，而 Docker 默认使用 HTTPS</strong>，所以报错：</p>
<blockquote>
<pre><code>http: server gave HTTP response to HTTPS client
</code></pre>
</blockquote>
<hr>
<h2 id="✅-解决方案（分两步）："><a href="#✅-解决方案（分两步）：" class="headerlink" title="✅ 解决方案（分两步）："></a>✅ 解决方案（分两步）：</h2><hr>
<h3 id="🔧-第一步：允许-Docker-使用-HTTP-连接-Harbor（非安全模式）"><a href="#🔧-第一步：允许-Docker-使用-HTTP-连接-Harbor（非安全模式）" class="headerlink" title="🔧 第一步：允许 Docker 使用 HTTP 连接 Harbor（非安全模式）"></a>🔧 第一步：允许 Docker 使用 HTTP 连接 Harbor（非安全模式）</h3><h4 id="1️⃣-修改-Docker-配置文件-etc-docker-daemon-json"><a href="#1️⃣-修改-Docker-配置文件-etc-docker-daemon-json" class="headerlink" title="1️⃣ 修改 Docker 配置文件 /etc/docker/daemon.json"></a>1️⃣ 修改 Docker 配置文件 <code>/etc/docker/daemon.json</code></h4><pre><code>vi /etc/docker/daemon.json
</code></pre>
<p>添加（或修改）以下内容：</p>
<pre><code>&#123;
  &quot;insecure-registries&quot;: [&quot;192.168.200.131:85&quot;]
&#125;
</code></pre>
<p>如果已有其他配置，比如 <code>registry-mirrors</code>，合并在一个 JSON 对象内：</p>
<pre><code>&#123;
  &quot;registry-mirrors&quot;: [
    &quot;https://docker.m.daocloud.io&quot;,
    &quot;https://wy1u1ijg.mirror.aliyuncs.com&quot;,
    &quot;https://p5lmkba8.mirror.aliyuncs.com&quot;,
    &quot;https://registry.docker-cn.com&quot;
  ],
  &quot;insecure-registries&quot;: [
    &quot;192.168.200.131:85&quot;
  ]
&#125;
</code></pre>
<hr>
<h4 id="2️⃣-重启-Docker-服务"><a href="#2️⃣-重启-Docker-服务" class="headerlink" title="2️⃣ 重启 Docker 服务"></a>2️⃣ 重启 Docker 服务</h4><pre><code>systemctl daemon-reexec
systemctl restart docker
</code></pre>
<hr>
<h3 id="🧪-第二步：重新登录-Harbor"><a href="#🧪-第二步：重新登录-Harbor" class="headerlink" title="🧪 第二步：重新登录 Harbor"></a>🧪 第二步：重新登录 Harbor</h3><pre><code>docker login 192.168.200.131:85 -u admin -p Harbor12345
</code></pre>
<p>这时你不会再看到 HTTPS 报错了。</p>
</blockquote>
<ul>
<li><p>push镜像上harbor [Harbor] (<a target="_blank" rel="noopener" href="http://192.168.200.131:85/harbor/projects/1/repositories">http://192.168.200.131:85/harbor/projects/1/repositories</a>)<br><code> docker push 192.168.200.131:85/library/jenkins-slave-maven:latest</code></p>
<blockquote>
<p>[root@k8s-master jenkins-slave]# docker push 192.168.200.131:85&#x2F;library&#x2F;jenkins-slave-maven:latest<br>The push refers to repository [192.168.200.131:85&#x2F;library&#x2F;jenkins-slave-maven]<br>22c917fbd463: Pushed<br>9522f341fa42: Pushed<br>1656341ae8c3: Pushed<br>1a2dbe51b5d3: Pushed<br>ed059ff604cf: Pushed<br>4cb0baa801b1: Pushed<br>3f01ba93adcb: Pushed<br>3dee86c3d230: Pushed<br>5ccb7c9ecca8: Pushed<br>8a510d97a0f7: Pushed<br>3f948fda930d: Pushed<br>cf7a8ba4ff71: Pushed<br>4e006334a6fd: Pushed<br>latest: digest: sha256:38043da78f22253730d941f110156b5130ecdb416fc13b52157d402bbf32f0b4 size: 3046</p>
</blockquote>
</li>
</ul>
<h3 id="测试Jenkins-Slave是否可以创建"><a href="#测试Jenkins-Slave是否可以创建" class="headerlink" title="测试Jenkins-Slave是否可以创建"></a>测试Jenkins-Slave是否可以创建</h3><p>去子节点的Jenkins创建一个item：<code>test_jenkins_slave</code> 是流水线项目<br>一定要在流水线上告诉Jenkins是放在从节点上的！</p>
<h5 id="Pipeline-scipt"><a href="#Pipeline-scipt" class="headerlink" title="Pipeline scipt"></a>Pipeline scipt</h5><pre><code class="yaml">// git 的 URL 和 凭证ID
def git_address = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
def git_auth = &quot;630eed58-d62f-4c1b-bf96-1cf9c92a7f36&quot;

// 正确使用 podTemplate 包裹 node
podTemplate(label: &#39;jenkins-slave&#39;, cloud: &#39;kubernetes&#39;, containers: [
    containerTemplate(
        name: &#39;jnlp&#39;,
        image: &quot;192.168.200.131:85/library/jenkins-slave-maven:latest&quot;,
        ttyEnabled: true,
        command: &#39;/bin/sh&#39;
    )
]) &#123;
    node(&quot;jenkins-slave&quot;) &#123;
        stage(&#39;拉取代码&#39;) &#123;
            checkout scmGit(
                branches: [[name: &quot;master&quot;]],
                extensions: [],
                userRemoteConfigs: [[
                    credentialsId: &quot;$&#123;git_auth&#125;&quot;,
                    url: &quot;$&#123;git_address&#125;&quot;
                ]]
            )
        &#125;
    &#125;
&#125;
</code></pre>
<p>然后点击构建 就会在从节点进行创建 此时去看<code>Dashboard → 系统管理 → 节点和云管理</code>的时候就会多一个刚刚自主创建的节点 <strong>快速创建 并快速回收</strong>！！</p>
<h4 id="Jenkins-Kubernetes-Docker完成微服务持续集成"><a href="#Jenkins-Kubernetes-Docker完成微服务持续集成" class="headerlink" title="Jenkins+Kubernetes+Docker完成微服务持续集成"></a>Jenkins+Kubernetes+Docker完成微服务持续集成</h4><h5 id="拉取代码，构建镜像"><a href="#拉取代码，构建镜像" class="headerlink" title="拉取代码，构建镜像"></a>拉取代码，构建镜像</h5><ul>
<li><p>创建NFS共享目录</p>
<p>让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录</p>
<pre><code class="yaml">vi /etc/exports
添加内容：
/opt/nfs/jenkins   *(rw,no_root_squash) 
/opt/nfs/maven     *(rw,no_root_squash) 
systemctl restart nfs   重启NFS
</code></pre>
<blockquote>
<p>[root@k8s-node1 ~]# showmount -e 192.168.200.129<br>Export list for 192.168.200.129:<br>&#x2F;opt&#x2F;nfs&#x2F;maven   *              【maven仓库实现共享】<br>&#x2F;opt&#x2F;nfs&#x2F;jenkins *<br>[root@k8s-node1 ~]#</p>
</blockquote>
</li>
<li><p>创建项目，编写构建Pipeline</p>
<pre><code class="yaml">// git 的 URL 和 凭证ID
def git_address = &quot;http://192.168.200.132:82/lanyun_group/tensquare_back.git&quot;
def git_auth = &quot;630eed58-d62f-4c1b-bf96-1cf9c92a7f36&quot;
//构建版本的名称
def tag = &quot;latest&quot;
 //Harbor私服地址
def harbor_url = &quot;192.168.200.131:85&quot;
 //Harbor的项目名称
def harbor_project_name = &quot;tensquare&quot;
 //Harbor的凭证
def harbor_auth = &quot;f82340a4-5173-40e3-bc76-602db3a5acf5&quot;

podTemplate(
    label: &#39;jenkins-slave&#39;,
    cloud: &#39;kubernetes&#39;,
    containers: [
        containerTemplate(
            name: &#39;jnlp&#39;,
            image: &quot;192.168.200.131:85/library/jenkins-slave-maven:latest&quot;
        ),
        containerTemplate(
            name: &#39;docker&#39;,
            image: &quot;docker:stable&quot;,
            ttyEnabled: true,
            command: &#39;cat&#39;
        )
    ],
    volumes: [
        hostPathVolume(
            mountPath: &#39;/var/run/docker.sock&#39;,
            hostPath: &#39;/var/run/docker.sock&#39;
        ),
        nfsVolume(
            mountPath: &#39;/usr/local/apache-maven/repo&#39;,
            serverAddress: &#39;192.168.200.129&#39;,
            serverPath: &#39;/opt/nfs/maven&#39;
        )
    ]
) &#123;
    node(&quot;jenkins-slave&quot;) &#123;
        stage(&#39;拉取代码&#39;) &#123;
            checkout scmGit(
                branches: [[name: &quot;master&quot;]],
                extensions: [],
                userRemoteConfigs: [[
                    credentialsId: &quot;$&#123;git_auth&#125;&quot;,
                    url: &quot;$&#123;git_address&#125;&quot;
                ]]
            )
        &#125;

        stage(&#39;编译，安装公共子工程&#39;) &#123;
            sh &quot;mvn -f tensquare_common clean install&quot;
        &#125;

        stage(&#39;构建镜像，部署项目&#39;) &#123;
            // 把选择的项目信息转为数组
            def selectedProjects = &quot;$&#123;project_name&#125;&quot;.split(&#39;,&#39;)

            for (int i = 0; i &lt; selectedProjects.size(); i++) &#123;
                // 取出每个项目的名称和端口
                def currentProject = selectedProjects[i]
                def currentProjectName = currentProject.split(&#39;@&#39;)[0]
                def currentProjectPort = currentProject.split(&#39;@&#39;)[1]
                def imageName = &quot;$&#123;currentProjectName&#125;:$&#123;tag&#125;&quot;

                // 编译，构建本地镜像
                sh &quot;mvn -f $&#123;currentProjectName&#125; clean package dockerfile:build&quot;

                container(&#39;docker&#39;) &#123;
                    // 给镜像打标签
                    sh &quot;docker tag $&#123;imageName&#125; $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;

                    // 登录 Harbor，并上传镜像
                    withCredentials([usernamePassword(
                        credentialsId: &quot;$&#123;harbor_auth&#125;&quot;,
                        passwordVariable: &#39;password&#39;,
                        usernameVariable: &#39;username&#39;
                    )]) &#123;
                        sh &quot;docker login -u $&#123;username&#125; -p $&#123;password&#125; $&#123;harbor_url&#125;&quot;
                        sh &quot;docker push $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
                    &#125;

                    // 删除本地镜像
                    sh &quot;docker rmi -f $&#123;imageName&#125;&quot;
                    sh &quot;docker rmi -f $&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>勾选<code>参数化构建过程</code> → <code>Extended Choice Parameter</code>和之前的一样 可回看<code>tensquare_eureka_server@10086,tensquare_zuul@10020,tensquare_admin_service@9001,tensquare_gathering@9002</code></p>
</li>
</ul>
<h5 id="安装Kubernetes-Continuous-Deploy插件-Kubernetes-CLI插件-Kubernetes-Credentials-Provider"><a href="#安装Kubernetes-Continuous-Deploy插件-Kubernetes-CLI插件-Kubernetes-Credentials-Provider" class="headerlink" title="安装Kubernetes Continuous Deploy插件 || Kubernetes CLI插件 || Kubernetes Credentials Provider"></a>安装Kubernetes Continuous Deploy插件 || Kubernetes CLI插件 || Kubernetes Credentials Provider</h5><ul>
<li><p>修改后的流水线脚本</p>
<pre><code class="yaml">// 这里是在全局凭证添加后点进去可以查看ID
dsf k8s_auth = &quot;xxxxxxxxx&quot;
// 定义k8s-harbor的凭证
def secret_name = &quot;registry-auth-secret&quot;
...
...
def deploy_image_name = &quot;$&#123;harbor_url&#125;/$&#123;harbor_project_name&#125;/$&#123;imageName&#125;&quot;
 //部署到K8S
 sh &quot;&quot;&quot;
 sed -i &#39;s#\$IMAGE_NAME#$&#123;deploy_image_name&#125;#&#39; 
$&#123;currentProjectName&#125;/deploy.yml
 sed -i &#39;s#\$SECRET_NAME#$&#123;secret_name&#125;#&#39; 
$&#123;currentProjectName&#125;/deploy.yml
 &quot;&quot;&quot;
 kubernetesDeploy configs: &quot;$&#123;currentProjectName&#125;/deploy.yml&quot;, 
kubeconfigId: &quot;$&#123;k8s_auth&#125;&quot;
</code></pre>
</li>
<li><p>去Jenkins的凭证里加k8s凭证</p>
<blockquote>
<h2 id="❗Credentials-from-Kubernetes-Secrets-will-not-be-available"><a href="#❗Credentials-from-Kubernetes-Secrets-will-not-be-available" class="headerlink" title="❗Credentials from Kubernetes Secrets will not be available"></a>❗<code>Credentials from Kubernetes Secrets will not be available</code></h2><h3 id="🧠-说明："><a href="#🧠-说明：" class="headerlink" title="🧠 说明："></a>🧠 说明：</h3><ul>
<li>这个警告说明 Jenkins 无法通过 Kubernetes 插件从 <code>Secret</code> 里加载凭证。</li>
<li>通常是以下原因之一：<ul>
<li><strong>Pod 没有挂载正确的 ServiceAccount &#x2F; RBAC 不够</strong></li>
<li>缺少 <code>Kubernetes Credentials Provider Plugin</code></li>
<li>没有开启 K8s secret credential provider 功能</li>
</ul>
</li>
</ul>
<h3 id="✅-解决方案："><a href="#✅-解决方案：" class="headerlink" title="✅ 解决方案："></a>✅ 解决方案：</h3><ol>
<li><p>确保你安装了插件：</p>
<ul>
<li><code>Kubernetes</code></li>
<li><code>Kubernetes Credentials Provider</code></li>
</ul>
</li>
<li><p>配置 Jenkins Deployment 的 ServiceAccount 具备权限，绑定如下 ClusterRole：</p>
</li>
<li><p>你可以给 Jenkins 的 ServiceAccount 绑定一个 <code>ClusterRole</code> 来读取 secrets：<br><code>/root/jenkins-master/</code>的<code>ServiceaAcount.yaml</code></p>
<pre><code>apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: kube-ops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-read-secrets
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: ServiceAccount
  name: jenkins
  namespace: kube-ops
</code></pre>
<blockquote>
<p>👆这会给 <code>jenkins</code> 账户授予读取所有 namespace 的 <code>secret</code> 权限。</p>
</blockquote>
<p>将上面内容保存为 <code>jenkins-rbac.yaml</code>，然后执行：</p>
<pre><code class="yaml">kubectl apply -f jenkins-rbac.yaml
</code></pre>
</li>
</ol>
</blockquote>
</li>
<li><p>添加凭证 → 类型<code>Kubernetes configuration(kubeconfig)</code>；范围全局；描述k8s-auth；Kubeconfig选择<code>Enter directly</code>这里面的密钥要去 129Jenkins机器上拿<br><code>cd /root/.kube</code> → <code>cat config</code> 显示的内容全部原封不动的复制到那里面</p>
</li>
<li><p>在每个项目下建立deploy.xml</p>
<h6 id="Eureka的deply-yml"><a href="#Eureka的deply-yml" class="headerlink" title="Eureka的deply.yml"></a>Eureka的deply.yml</h6><pre><code class="yaml">---
apiVersion: v1
kind: Service
metadata:
  name: eureka
  labels:
    app: eureka
spec:
  type: NodePort
  ports:
    - port: 10086
      name: eureka
      targetPort: 10086
  selector:
    app: eureka
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: eureka
spec:
  serviceName: &quot;eureka&quot;
  replicas: 2
  selector:
    matchLabels:
      app: eureka
  template:
    metadata:
      labels:
        app: eureka
    spec:
      imagePullSecrets:
        - name: $SECRET_NAME
      containers:
        - name: eureka
          image: $IMAGE_NAME
          ports:
            - containerPort: 10086
          env:
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: EUREKA_SERVER
              value: &quot;http://eureka-0.eureka:10086/eureka/,http://eureka-1.eureka:10086/eureka/&quot;
            - name: EUREKA_INSTANCE_HOSTNAME
              value: $&#123;MY_POD_NAME&#125;.eureka
  podManagementPolicy: &quot;Parallel&quot;
</code></pre>
<p>其他项目的deploy.yml主要把名字和端口修改：</p>
<h6 id="zuul的deploy-yml"><a href="#zuul的deploy-yml" class="headerlink" title="zuul的deploy.yml"></a>zuul的deploy.yml</h6><pre><code class="yaml">---
apiVersion: v1
kind: Service
metadata:
  name: zuul
  labels:
    app: zuul
spec:
  type: NodePort
  ports:
    - port: 10020
      name: zuul
      targetPort: 10020
  selector:
    app: zuul
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: zuul
spec:
  serviceName: &quot;zuul&quot;
  replicas: 2
  selector:
    matchLabels:
      app: zuul
  template:
    metadata:
      labels:
        app: zuul
    spec:
      imagePullSecrets:
        - name: $SECRET_NAME
      containers:
        - name: zuul
          image: $IMAGE_NAME
          ports:
            - containerPort: 10020
  podManagementPolicy: &quot;Parallel&quot;
</code></pre>
</li>
<li><p>还要在流水线定义k8s-harbor的凭证<br>生成Docker凭证  Docker凭证，用于Kubernetes到Docker私服拉取镜像</p>
<blockquote>
<p>docker login -u itcast -p Itcast123 192.168.66.102:85     登录Harbor </p>
<p>kubectl create secret docker-registry registry-auth-secret  –docker server&#x3D;192.168.200.131:85 –docker-username&#x3D;itcast –docker-password&#x3D;Itcast123 – docker-email&#x3D;<a href="mailto:&#105;&#x74;&#x63;&#x61;&#115;&#116;&#64;&#105;&#116;&#x63;&#97;&#x73;&#x74;&#x2e;&#x63;&#110;">&#105;&#x74;&#x63;&#x61;&#115;&#116;&#64;&#105;&#116;&#x63;&#97;&#x73;&#x74;&#x2e;&#x63;&#110;</a>    生成 </p>
<p>kubectl get secret    查看密钥</p>
</blockquote>
</li>
<li><p>项目构建后，查看服务创建情况</p>
<blockquote>
<p>kubectl get pods -owide<br>kubectl get service</p>
</blockquote>
</li>
</ul>
<h4 id="启动命令总结"><a href="#启动命令总结" class="headerlink" title="启动命令总结"></a>启动命令总结</h4><pre><code class="java">[192.168.200.132]GitLab：gitlab-ctl restart 
[192.168.200.131]Tomcat：/opt/tomcat/bin/startup.sh

[192.168.200.129]Jenkins：/systemctl start jenkins
[192.168.200.129]SonarQube：sudo -u sonarqube /opt/sonar/bin/linux-x86-64/sonar.sh restart
</code></pre>
<h4 id="2025-7-8-0-02-完结撒花★-°-☆-￣▽￣-x2F-°★-。"><a href="#2025-7-8-0-02-完结撒花★-°-☆-￣▽￣-x2F-°★-。" class="headerlink" title="2025.7.8  0:02   完结撒花★,°:.☆(￣▽￣)&#x2F;$:.°★ 。"></a><span style = "color:red">2025.7.8  0:02   完结撒花<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。</span></h4>
    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>