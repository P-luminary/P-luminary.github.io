
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 数据库</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>数据库 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/8
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#879cff>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="数据库基础内容"><a href="#数据库基础内容" class="headerlink" title="数据库基础内容"></a>数据库基础内容</h1><h3 id="数据库系统-DBMS"><a href="#数据库系统-DBMS" class="headerlink" title="数据库系统(DBMS)"></a>数据库系统(DBMS)</h3><ul>
<li>关系型数据库系统(RDBMS)是指使用了关系模型的数据库</li>
<li>关系模型中，数据是分类存放的，数据之间可以有联系</li>
<li>淘宝网背后是3000多个数据库并发的<strong>集群</strong></li>
<li>DB2电信金融领域   Oracle数据库集群  <strong><span style = "color:red">MySQL开源灵活</span></strong>  SQL Server教育领域免费</li>
<li><strong>NoSQL数据库</strong>[Redis]指的是数据分类存放，但是数据之间没有关联关系的数据库系统<br>主流NoSQL数据库 &#x3D;&gt; <strong>Redis(内存 双十一秒杀)</strong>   MemCache   <strong>MongoDB(新闻)</strong>   Neo4J<br>NoSQL数据库只是关系型数据库的补充</li>
</ul>
<h3 id="MySQL衍生版"><a href="#MySQL衍生版" class="headerlink" title="MySQL衍生版"></a>MySQL衍生版</h3><p><strong>Oracle</strong>  Percona(Linux系统)  MariaDB</p>
<h3 id="重设root密码-D-x2F-temp-txt"><a href="#重设root密码-D-x2F-temp-txt" class="headerlink" title="重设root密码 (D:&#x2F;temp.txt)"></a>重设root密码 (D:&#x2F;temp.txt)</h3><ul>
<li><p>创建一个Txt文件，定义修改密码的SQL语句</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 
</code></pre>
</li>
<li><p>Windows PowerSheell(管理员) 窗口打开<br>停止服务</p>
<pre><code class="sql">net stop mysql180

mysqld --defaults-file=&quot;D:\MySQL\MySQL Server 8.0\my.ini&quot; --init-file==&quot;D:/temp.txt&quot; --console
ctrl+C取消
</code></pre>
<p>启动服务</p>
<pre><code class="sql">net start mysql180
</code></pre>
</li>
</ul>
<h3 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h3><ul>
<li><p>在<strong>my.ini</strong>文件中，我们可以设置各种MySQL的配置，例如字符集、端口号、目录地址等等</p>
<p>my.init{客户端配置信息：[client]…    [mysql]…      <strong>数据库配置信息</strong>：[mysqld]…}</p>
</li>
</ul>
<pre><code class="sql">[client]

# pipe=

# socket=MYSQL 端口号

port=3306

# 错误时主板没有轰鸣声
[mysql]
no-beep

# server_type=3
[mysqld]
#端口号
port=3306


# basedir=&quot;D:/MySQL/MySQL Server 8.0/&quot;
# Path to the database root
datadir=D:/MySQL/MySQL Server 8.0\Data

# with an account. 密码认证插件
authentication_policy=mysql_native_password

#默认存储引擎
default-storage-engine=INNODB

# database servers. 开启严格模式
sql-mode=&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&quot;

# General and Slow logging. 用文件记录日志
log-output=FILE
# 关闭日志输出
general-log=0
# 日志文件名称
general_log_file=&quot;PLUMINARY.log&quot;
# 开启慢查询日志
slow-query-log=1
#慢查询日志文件名称
slow_query_log_file=&quot;PLUMINARY-slow.log&quot;
#大于多少秒的执行SQL被记录在慢查询日志
long_query_time=10

# Error Logging.错误日志名称
log-error=&quot;PLUMINARY.err&quot;

# from every other ID in use by any other source or replica. 集群会用到数据库ID
server-id=1

# 把表名转换成小写
lower_case_table_names=1

# 导入导出数据的目录地址
secure-file-priv=&quot;D:/MySQL/MySQL Server 8.0/Uploads&quot;

#最大连接数
max_connections=151
</code></pre>
<h3 id="定义逻辑库、数据表"><a href="#定义逻辑库、数据表" class="headerlink" title="定义逻辑库、数据表"></a>定义逻辑库、数据表</h3><ul>
<li>SQL是用于访问和处理数据的标准的计算机语言</li>
</ul>
<h5 id="SQL语句的注释"><a href="#SQL语句的注释" class="headerlink" title="SQL语句的注释"></a>SQL语句的注释</h5><pre><code class="sql"># 这是一段注释文字
/* 这是另一段注释文字 */
</code></pre>
<h3 id="创建逻辑库"><a href="#创建逻辑库" class="headerlink" title="创建逻辑库"></a>创建逻辑库</h3><pre><code class="sql">CREATE DATABASE 逻辑库名称; #创建
SHOW DATABASES; #展现逻辑库
DROP DATABASE 逻辑库名称; #删除
</code></pre>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre><code class="sql">CREATE TABLE 数据表(
  列名1 数据类型[约束] [COMMENT 注释],
  列名2 数据类型[约束] [COMMENT 注释],
  ......
)[COMMENT = 注释];


CREATA TABLE student(
  id INT UNSIGNED PRIMARY KEY, #主键约束 不可重复
  name VARCHAR(20) NOT NULL, #varchar 字符串 最大不超过20个字符 NOT NULL必填,不允许没有数据
  sex CHAR(1) NOT NULL, #char 字符
  birthday DATE NOT NULL, 
  tel CHAR(11) NOT NULL,
  remark VARCHAR(200)  #备注不超过200字符串
);

INSERT INTO student VALUES(1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);

SHOW tables; #展现数据表名称
DESC student; #数据表结构具体情况
SHOW CREATE TABLE student; #查询当时的sql语句
DROP TABLE student; #删除数据表
</code></pre>
<h3 id="数据定义语言：数据类型"><a href="#数据定义语言：数据类型" class="headerlink" title="数据定义语言：数据类型"></a>数据定义语言：数据类型</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">1字节</td>
<td align="center">小整数</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">2字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center">MEDIUMIINT</td>
<td align="center">3字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center"><strong>INT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>较大整数</strong></td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">8字节</td>
<td align="center">大整数</td>
</tr>
<tr>
<td align="center"><strong>FLOAT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>单精度浮点数</strong></td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8字节</td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td align="center">DECIMAL[精确钱]</td>
<td align="center">——–</td>
<td align="center">DECIMAL(10,2)</td>
</tr>
</tbody></table>
<ul>
<li>十进制的浮点数无法在计算机中用二进制精确表达 比如0.2</li>
</ul>
<pre><code class="sql">   num FLOAT(20,10) #位数20 小数点后精确10位  在num中输入0.2的时候 变成了0.200000000030
=&gt; num DECIMAL(20,10)
</code></pre>
<h3 id="数据类型：字符串"><a href="#数据类型：字符串" class="headerlink" title="数据类型：字符串"></a>数据类型：字符串</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CHAR</strong></td>
<td align="center">1-255字符</td>
<td align="center">固定长度字符串</td>
</tr>
<tr>
<td align="center"><strong>VARCHAR</strong></td>
<td align="center">1-65535字符</td>
<td align="center">不固定长度字符串</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">1-65535字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">MEDIUMETEXT</td>
<td align="center">1-1千6百万字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">1-42亿字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
</tbody></table>
<h4 id="数据类型：日期类型-年月日中间横线分割-要加引号"><a href="#数据类型：日期类型-年月日中间横线分割-要加引号" class="headerlink" title="数据类型：日期类型(年月日中间横线分割 要加引号)"></a>数据类型：日期类型(年月日中间横线分割 要加引号)</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">3字节</td>
<td align="center">日期</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3字节</td>
<td align="center">时间</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">1字节</td>
<td align="center">年份</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8字节</td>
<td align="center">日期时间[电影开始时间]</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4字节</td>
<td align="center">时间戳</td>
</tr>
</tbody></table>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><pre><code class="sql">ALTER TABLE 表名称
ADD 列1 数据类型 [约束] [COMMENT 注释],
ADD 列2 数据类型 [约束] [COMMENT 注释],
......;

ADD address VARCHAR(200) NOT NULL;
</code></pre>
<h5 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h5><pre><code class="sql">ALTER TABLE 表名称
CHANGE 列1 新列名1 数据类型 [约束] [COMMENT 注释],
CHANGE 列2 新列名2 数据类型 [约束] [COMMENT 注释],
......;

修改字段
ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL;
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名
</code></pre>
<h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><pre><code class="sql">ALTER TABLE 表名称
DROP 列1，
DROP 列2，
......;
</code></pre>
<h3 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h3><h4 id="第一范式：原子性"><a href="#第一范式：原子性" class="headerlink" title="第一范式：原子性"></a>第一范式：原子性</h4><ul>
<li>第一范式是数据库的基本要求，不满足组这一点就不是关系数据库</li>
<li>数据库的每一列都是<strong>不可分割</strong>的基本数据项，同一列中不能有多个值，也不能存在重复的属性</li>
</ul>
<h6 id="不符合第一范式"><a href="#不符合第一范式" class="headerlink" title="不符合第一范式"></a>不符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三年级1班</td>
</tr>
</tbody></table>
<h6 id="符合第一范式"><a href="#符合第一范式" class="headerlink" title="符合第一范式"></a>符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">年纪</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三</td>
<td align="center">1班</td>
</tr>
</tbody></table>
<h4 id="第二范式：唯一性"><a href="#第二范式：唯一性" class="headerlink" title="第二范式：唯一性"></a>第二范式：唯一性</h4><ul>
<li>数据表中的<strong>每条记录必须是唯一的</strong>。为了实现区分，通常要为表加上一列用来存储唯一标识，这个唯一属性列被称为主键列</li>
</ul>
<h6 id="无法区分重复的数据"><a href="#无法区分重复的数据" class="headerlink" title="无法区分重复的数据"></a>无法区分重复的数据</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h6 id="数据具有唯一性"><a href="#数据具有唯一性" class="headerlink" title="数据具有唯一性"></a>数据具有唯一性</h6><table>
<thead>
<tr>
<th align="center">流水号</th>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">201807152687</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">201807152694</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h4 id="第三范式：关联性"><a href="#第三范式：关联性" class="headerlink" title="第三范式：关联性"></a>第三范式：关联性</h4><ul>
<li>每列都与主键有直接关系，<strong>不存在传递依赖</strong></li>
</ul>
<h6 id="违反第三范式"><a href="#违反第三范式" class="headerlink" title="违反第三范式"></a>违反第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<p>拿爸爸作为主键 儿子和女儿字段都是依赖于爸爸字段 但是后面的字段<strong>违反了第三范式</strong> <u>女儿的玩具和女儿的衣服是依赖于女儿这个字段的并不依赖于爸爸这个字段</u><br>数据表关系都非常松散 在检索的时候非常慢 因为爸爸主键字段查询非常快 但是查女儿的玩具和女儿的衣服找不到一样的主键</p>
<h6 id="遵守第三范式"><a href="#遵守第三范式" class="headerlink" title="遵守第三范式"></a>遵守第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<ul>
<li>依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<p>部门字段也是依赖于编号的 两张表没有违反第三范式</p>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><ul>
<li>MySQL中的字段约束共有四种：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">约束名称</th>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键约束</td>
<td align="center">PRIMARY KEY</td>
<td align="center">字段值唯一，且不能为NULL</td>
</tr>
<tr>
<td align="center">非空约束</td>
<td align="center">NOT NULL</td>
<td align="center">字段值不能为NULL</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">UNIQUE</td>
<td align="center">字段值唯一，且可以为NULL</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">FOREIGN KEY</td>
<td align="center">保持关联数据的逻辑性</td>
</tr>
</tbody></table>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul>
<li>主键约束要求字段的值在全表必须唯一，而且不能为NULL值</li>
<li>建议主键一定要使用数字类型，因为数字的检索速度会非常快</li>
<li>如果主键是数字类型，还可也设置自动增长</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
    ......
);
</code></pre>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><ul>
<li>非空约束要求字段的值不能为NULL值</li>
<li>NULL值以为没有值，而不是 “” 空字符串</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    married BOOLEAN NOT NULL DEFAULT FALSE #若不写则是默认值false
);
</code></pre>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ul>
<li>唯一约束要求字段值如果不为NULL，那么在全表必须唯一</li>
</ul>
<pre><code class="sql">CREATE TABLE t_tracher(
    ......
    tel CHAR(11) NOT NULL UNIQUE
);
</code></pre>
<pre><code class="sql">t_  tb_  一般是真实的表  
v_ vw_   一般是视图虚拟表的意思
</code></pre>
<h6 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h6><pre><code class="sql">CREATE TABLE t_teacher(
    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    tel CHAR(11) NOT NULL UNIQUE, #唯一约束 UNIQUE 字段值唯一，且可以为NULL
    married BOOLEAN NOT NULL DEFAULT FALSE
);
-------------------------------------------------------------------------
CREATE TABLE student(
    id INT UNSIGNED PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    sex CHAR(1) NOT NULL,
    birthday DATE NOT NULL,
    tel CHAR(11) NOT NULL,
    remark VARCHAR(200)
);
INSERT INTO student VALUES (1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);
DESC student; 
SHOW CREATE TABLE student;

ALTER TABLE student
ADD address VARCHAR(200) NOT NULL, #添加字段信息
ADD home_tel CHAR(11) NOT NULL;

ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL; #改字段类型信息

ALTER TABLE student
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名

ALTER TABLE student
DROP address; #删除字段
</code></pre>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul>
<li>外键约束用来保证关联数据的逻辑关系</li>
<li>外键约束的定义是写在子表上的</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<pre><code class="sql">CREATE TABLE t_dept(
    deptno INT UNSIGNED PRIMARY KEY,
    dname VARCHAR(20) NOT NULL UNIQUE,
    tel CHAR(4) UNIQUE #写了电话必须唯一
);
</code></pre>
<pre><code class="sql">CREATE TABLE t_emp(
    empno INT UNSIGNED PRIMARY KEY,
    ename VARCHAR(20) NOT NULL,
    sex EUNM(&quot;男&quot;,&quot;女&quot;) NOT NULL, #枚举 选择其中一个
    deptno INT UNSIGNED,
    hiredate DATE NOT NULL,
    FOREIGN KEY (deptno) REFERENCES t_dept(deptno) #和父表进行外键约束关联
);
</code></pre>
<p>不允许删除第一个编号 需要先删除第二个表的记录 再删除第一个表记录 逻辑关系有保证</p>
<h3 id="外键约束的闭环问题-【因此开发中放弃外键约束】"><a href="#外键约束的闭环问题-【因此开发中放弃外键约束】" class="headerlink" title="外键约束的闭环问题 【因此开发中放弃外键约束】"></a>外键约束的闭环问题 【因此开发中放弃外键约束】</h3><ul>
<li>如果形成外键闭环，我们将无法删除任何一张表的记录</li>
</ul>
<h3 id="数据排序的好处"><a href="#数据排序的好处" class="headerlink" title="数据排序的好处"></a>数据排序的好处</h3><ul>
<li>一旦数据排序后，查找的速度就会翻倍，现实世界跟程序世界都是如此</li>
</ul>
<h3 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h3><pre><code class="sql">CREATE TABLE 表名称(
    ......,
    INDEX [索引名称] (字段),
    ......
);

#数据库对这个索引字段排序生成二叉树 每个字段都是有索引名称的
CREATE TABLE t_message(
    id INT UNSIGNED PRIMARY KEY,
    content VARCHAR(200) NOT NULL,
    type ENUM(&quot;公告&quot;,&quot;通报&quot;,&quot;个人通知&quot;) NOT NULL,
    create_time TIMESTAMP NOT NULL,
    INDEX idx_type (type)
); #利用二叉树的二分查找去查找索引字段就会非常快
</code></pre>
<h3 id="如何添加与删除索引"><a href="#如何添加与删除索引" class="headerlink" title="如何添加与删除索引"></a>如何添加与删除索引</h3><pre><code class="sql">CREATE INDEX 索引名称 ON 表名(字段); #添加索引
ALTER TABLE 表名称 ADD INDEX [索引名](字段); #添加索引
SHOW INDEX FORM 表名; #展示索引表  PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
DROP INDEX 索引名称 ON 表名; #删除索引
</code></pre>
<h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><ul>
<li>数据量很大，而且经常被查询的数据表可以设置索引 (日志表很少查询 无需设置 因为数据库要维护二叉树)</li>
<li>索引只添加在<strong>经常被用作检索</strong>条件的字段上面</li>
<li>不要在<strong>大字段</strong>上创建索引</li>
</ul>
<p>(<u>以上均为DDL语句</u>)</p>
<h6 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h6><h3 id="数据操作语句：普通查询"><a href="#数据操作语句：普通查询" class="headerlink" title="数据操作语句：普通查询"></a>数据操作语句：普通查询</h3><h5 id="记录查询"><a href="#记录查询" class="headerlink" title="记录查询"></a>记录查询</h5><ul>
<li>最基本的查询语句是由<strong>SELECT</strong> 和 <strong>FROM</strong>关键字组成</li>
</ul>
<pre><code class="sql">USE demo;
SELECT * FROM t_emp; #FROM是从员工表查数据 *是在结果集里显示员工表所有字段
SELECT empno,ename,sal FROM t_emp; #不查询所有 单独查询想要的
</code></pre>
<ul>
<li>SELECT语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交给数据库高效查找数据</li>
<li>通常情况下 ，SELECT子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列明重命名的机制 [<strong>起别名</strong>：只是对查询的结果集字段改名称]</li>
</ul>
<pre><code class="sql">SELECT
  empno,
  sal*12 AS &quot;income&quot;
FROM t_emp;
</code></pre>
<ul>
<li>上述sql 查询语句的子句执行顺序</li>
</ul>
<p>① <strong>词法分析与优化</strong>：读取SQL语句<br>② <strong>FROM</strong>：选择数据来源<br>③ <strong>SELECT</strong>：选择输出内容</p>
<h3 id="数据操作语言：数据分页"><a href="#数据操作语言：数据分页" class="headerlink" title="数据操作语言：数据分页"></a>数据操作语言：数据分页</h3><ul>
<li>朋友圈只会加载少量部分信息，不用一次性加载全部朋友圈，那样只会浪费CPU时间、内存和网络带宽</li>
<li>如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... LIMIT 起始位置,偏移量; 
SELECT empno,ename FROM t_emp LIMIT 0,20; #从0往后取20条数据
</code></pre>
<h6 id="数据分页简写"><a href="#数据分页简写" class="headerlink" title="数据分页简写"></a>数据分页简写</h6><ul>
<li>如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0</li>
</ul>
<pre><code class="sql">SELECT empno,ename FROM t_emp LIMIT 10;
SELECT empno,ename FROM t_emp LIMIT 0,10;
FROM → SELECT → LIMIT
</code></pre>
<h3 id="结果集排序"><a href="#结果集排序" class="headerlink" title="结果集排序"></a>结果集排序</h3><ul>
<li>如果没有设置，查询语句不会对结果集进行排序。也就是说，如果想让结果集按照某种顺序排序，就必须使用ORDER BY子句 【<strong>默认升序</strong>】</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... ORDER BY 列名 [ASC|DESC];
SELECT ename,sal FROM t_emp ORDER BY sal;
</code></pre>
<h3 id="排序关键字"><a href="#排序关键字" class="headerlink" title="排序关键字"></a>排序关键字</h3><ul>
<li>ASC代表升序(默认)，DESC代表降序</li>
<li>如果排序列是数字类型，数据库就按照数字大小排序，如果是日期类型就按照日期大小排序，如果是字符串就暗战字符集序号排序。</li>
</ul>
<pre><code class="sql">SELECT ename,sal FROM t_emp ORDER BY hiredate DESC;
</code></pre>
<h6 id="排序字段内容相同的情况"><a href="#排序字段内容相同的情况" class="headerlink" title="排序字段内容相同的情况"></a>排序字段内容相同的情况</h6><ul>
<li>如果两条数据排序字段内容相同 <strong>sal 都是3000</strong><br>默认情况下是按照主键升序</li>
</ul>
<h6 id="多个排序字段"><a href="#多个排序字段" class="headerlink" title="多个排序字段"></a>多个排序字段</h6><ul>
<li>使用ORDER BY规定首要排序顺序条件和次要排序条件。数据库会先按照要排序条件排序，如果遇到首要排序内容相同的记录，那么就会启动次要排序条件接着排序</li>
</ul>
<pre><code class="sql">SELECT ename,sal,hiredate 
FROM t_emp 
ORDER BY hiredate DESC,sal ASC;
#先按照首要排序hiredate降序 再启动次要排序sal降序

SELECT ename,sal,hiredate
FROM t_emp
ORDER BY sal DESC 
LIMIT 0,5  #工资排在前五位进行降序
</code></pre>
<h6 id="排序-分页"><a href="#排序-分页" class="headerlink" title="排序+分页"></a>排序+分页</h6><ul>
<li>ODER BY 子句书写的时候放在LIMIT子句的前面<br><strong>FROM → SELECT → ORDER BY → LIMIT</strong></li>
</ul>
<h3 id="结果集中的重复数据"><a href="#结果集中的重复数据" class="headerlink" title="结果集中的重复数据"></a>结果集中的重复数据</h3><ul>
<li><p>假如我们要查询员工表有多种职业，写出来的sql语句</p>
<pre><code class="sql">SELECT job FROM t_emp; #结果集内可能会出现重复记录
</code></pre>
</li>
<li><p>如果去除重复的数据，可以使用 <strong>DISTINCT</strong> 关键字来实现</p>
<pre><code class="sql">SELECT DISTINCT 字段 FROM ...;
SELECT DISTINCT job FROM t_emp;
</code></pre>
</li>
</ul>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li><p>使用<strong>DISTINCT</strong>的<strong>SELECT</strong>子句中只能查询一列数据，如果查询多列，去除重复记录就会失效</p>
<pre><code class="sql">SELECT DISTINCT job,ename FROM t_emp; #有job相同但是ename不相同 不能查询
</code></pre>
</li>
<li><p><strong>DISTINCT</strong>关键字只能再SELECT子句中使用一次 [必须放在第一个字段前面]</p>
</li>
</ul>
<h3 id="数据操作语言：条件查询-一"><a href="#数据操作语言：条件查询-一" class="headerlink" title="数据操作语言：条件查询(一)"></a>数据操作语言：条件查询(一)</h3><ul>
<li><p>满足某一种或几种条件的记录。这类条件要用<strong>WHERE</strong>子句来实现数据的筛选</p>
<pre><code class="sql">SELECT ... FROM ... WHERE 条件 [AND|OR] 条件 ...;

SELECT empno,ename,sal FROM t_emp
WHERE deptno=10 AND sal&gt;=2000;

SELECT empno,ename,sal
FROM t_emp
WHERE(deptno=10 OR deptno=20) AND sal&gt;=2000;
</code></pre>
</li>
</ul>
<h6 id="四类运算符"><a href="#四类运算符" class="headerlink" title="四类运算符"></a>四类运算符</h6><ul>
<li><p>WHERE语句中的条件运算会用到以下四种运算符</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">数学运算符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">比较运算符</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">逻辑运算符</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">按位运算符</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="算数运算符-加-减-乘-x2F-除-模"><a href="#算数运算符-加-减-乘-x2F-除-模" class="headerlink" title="算数运算符 [+加  -减  *乘  &#x2F;除  %模]"></a>算数运算符 [+加  -减  *乘  &#x2F;除  %模]</h6><p>NULL值与任何数字加减乘除都是NULL值 如果想要运算 必须加入 <strong>IFNULL</strong>(null,0); 意思是遇到NULL值就用0来计算 10+IFNULL(null,0) &#x3D; 10<br><strong>DATEDIFF</strong>(入职日期-现在的日期)&#x2F;365</p>
<pre><code class="sql">从t_emp表中找出 号位是10 和 总工资≥15000 的并且 计算工龄超过20年的人
SELECT empno,ename,sal,hiredate
FROM t_emp
WHERE deptno=10 AND (sal+IFNULL(NULL,0))*12&gt;=15000
AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
<h6 id="比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40"><a href="#比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40" class="headerlink" title="比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]"></a>比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]</h6><pre><code class="sql">查询10 20 30部门里面在1980年以前入职的员工而且不能是SALESMAN职位
SELECT
  empno,ename,sal,deptno,hiredate
FROM t_emp;
WHERE deptno IN(10,20,30) AND job!=&quot;SALESMAN&quot;
AND hiredate&lt;&quot;1985-01-01&quot;;
</code></pre>
<h6 id="续比较运算符"><a href="#续比较运算符" class="headerlink" title="+续比较运算符"></a>+续比较运算符</h6><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">表达式</th>
<th align="center">意义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">IS NULL</td>
<td align="center">为空</td>
<td align="center">comm IS NULL</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">IS NOT NULL</td>
<td align="center">不为空</td>
<td align="center">comm IS NOT NULL</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">BETWEEN AND</td>
<td align="center">范围</td>
<td align="center">sal BETWEEN 2000 AND 3000</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">LIKE</td>
<td align="center">模糊查询</td>
<td align="center">ename LIKE “A%”</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><span style = "color : red"><strong>REGEXP</strong></span></td>
<td align="center"><span style = "color : red"><strong>正则表达式</strong></span></td>
<td align="center"><strong>ename REGEXP “[a-zA-Z]{4}”</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>__代表前方一个未知    %代表前方N个未知</p>
</blockquote>
<pre><code class="sql">SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename LIKE &quot;_LAKE&quot;;

SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename REGEXP &quot;^[\\u4e00-\\u9fa5]&#123;2,4&#125;$&quot;; #正则表达汉字范围寻找两到四个中文字符
</code></pre>
<h6 id="按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移"><a href="#按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移" class="headerlink" title="按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]"></a>按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]</h6><p>&lt;&lt; 左移  10&lt;&lt;1 把10转换成二进制位 在最右面补上一个0 整体向左移动了一个单位<br>》》左移  10&lt;&lt;1 把10转换成二进制位 在最右面抹去一个0 整体向右移动了一个单位</p>
<h3 id="二进制按位运算"><a href="#二进制按位运算" class="headerlink" title="二进制按位运算"></a>二进制按位运算</h3><ul>
<li>二进制运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算<br>SELECT 3 &amp; 7;    0011 &amp; 0111 &#x3D; 0011 &#x3D; 3</li>
</ul>
<h3 id="数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或"><a href="#数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或" class="headerlink" title="数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]"></a>数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]</h3><pre><code class="sql">查询10和20之外部门的信息
SELECT
  ename,deptno,sal
FROM t_emp
WHERE NOT deptno IN(10,20) XOR sal&gt;=2000;
</code></pre>
<h3 id="WHERE子句的注意事项"><a href="#WHERE子句的注意事项" class="headerlink" title="WHERE子句的注意事项"></a>WHERE子句的注意事项</h3><ul>
<li>WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把<strong>索引条件，或者筛选掉记录最多的条件</strong>写在最左侧<pre><code class="sql">SELECT empno,ename FROM t_emp
WHERE ename = &quot;FORD&quot; AND sal &gt;= 2000;

SELECT empno,ename FROM t_emp
WHERE deptno = 10 AND sal &gt;= 2000;
</code></pre>
</li>
</ul>
<h3 id="各种子句的执行排序"><a href="#各种子句的执行排序" class="headerlink" title="各种子句的执行排序"></a>各种子句的执行排序</h3><h5 id="FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → SELECT → ORDER BY → LIMIT"></a>FROM → WHERE → SELECT → ORDER BY → LIMIT</h5><p>先表 再查出符合条件的记录 才能从中挑选出符合的字段 先排序后限制</p>
<hr>
<h1 id="数据库高级内容"><a href="#数据库高级内容" class="headerlink" title="数据库高级内容"></a>数据库高级内容</h1><h3 id="数据操作语言：聚合函数"><a href="#数据操作语言：聚合函数" class="headerlink" title="数据操作语言：聚合函数"></a>数据操作语言：聚合函数</h3><ul>
<li><p>聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对<strong>数据求和</strong>、求<strong>最大值</strong>和<strong>最小值</strong>、求<strong>平均值</strong>等等</p>
</li>
<li><p>求公司员工的平均月收入是多少？</p>
<pre><code class="sql">底薪+佣金(不是null)
SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="SUM函数"><a href="#SUM函数" class="headerlink" title="SUM函数"></a>SUM函数</h5><ul>
<li><p>SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0，日期类型统计结果是毫秒数相加</p>
<pre><code class="sql">SELECT SUM(ename) FROM t_emp

SELECT SUM(sal) FROM t_emp
WHERE deptno IN (10,20);
</code></pre>
</li>
</ul>
<h5 id="MAX函数"><a href="#MAX函数" class="headerlink" title="MAX函数"></a>MAX函数</h5><ul>
<li><p>MAX函数用于获得非空值的最大值</p>
<pre><code class="sql">SELECT MAX(comm) FORM t_emp;

①查询10和20部门中,月收入最高的员工？
SELECT 
MAX(sal+IFNULL(comm,0)) FROM t_temp
FROM t_emp
WHERE deptno IN (10,20);

②查询员工名字最长的是几个字符？
SELECT MAX(LENGTH(ename)) FROM t_emp;

SELECT
SUM(sal),MAX(sal+IFNULL(comm,0)) 
FROM t_emp
WHERE deptno IN(10,20); 
</code></pre>
</li>
</ul>
<h5 id="MIN函数"><a href="#MIN函数" class="headerlink" title="MIN函数"></a>MIN函数</h5><ul>
<li><p>MIN函数用于获得非空值的最小值</p>
<pre><code class="sql">SELECT MIN(empno) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a>AVG函数</h5><ul>
<li><p>AVG函数用于获得非空值的平均值，非数字数据统计结果为0</p>
<pre><code class="sql">SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h5><ul>
<li><p>COUNT(*) [<u>找所有</u>]用于获得包含空值的记录数，COUNT(列名)用于获得包含非空值的记录数</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp; #统计所有   15 
SELECT COUNT(comm) FROM t_emp; #统计数量是非空   5
</code></pre>
</li>
<li><p>查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数</p>
<pre><code class="sql">SELECT COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20) 
AND sal&gt;=2000
AND DATEDIFF(NOW(),hiredate)/365&gt;=15;
</code></pre>
</li>
<li><p>查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？</p>
<pre><code class="sql">×××××××××错误示范×××××××××
SELECT COUNT(*) FROM t_emp
WHERE hiredate&gt;=&quot;1985-01-01&quot;
AND sal&gt;AVG(sal); #AVG无法运行 聚合函数不能出现在WHERE里面
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：分组查询"><a href="#数据操作语言：分组查询" class="headerlink" title="数据操作语言：分组查询"></a>数据操作语言：分组查询</h3><h6 id="为什么要分组？"><a href="#为什么要分组？" class="headerlink" title="为什么要分组？"></a>为什么要分组？</h6><ul>
<li>默认情况下汇总函数是对全表范围内的数据做统计</li>
<li>GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理</li>
</ul>
<pre><code class="sql">SELECT deptno,ROUND(AVG(sal))
FROM t_emp
GROUP BY deptno; #分组来计算AVG
</code></pre>
<h3 id="逐级分组"><a href="#逐级分组" class="headerlink" title="逐级分组"></a>逐级分组</h3><ul>
<li>数据库支持多列分组条件，执行的时候逐级分组</li>
<li>查询每个部门里，每种职位的人员数量和平均底薪</li>
</ul>
<pre><code class="sql">#按照部门和工作分组 ↓这种职位人数 ↓这种职位底薪平均值
SELECT deptno,job,COUNT(*),AVG(sal)
FROM t_emp 
GROUP BY deptno,job
ORDER BY deptno; #按照deptno去排序
</code></pre>
<h3 id="对SELECT子句的要求"><a href="#对SELECT子句的要求" class="headerlink" title="对SELECT子句的要求"></a>对SELECT子句的要求</h3><ul>
<li>查询语句中如果含有<strong>GROUP BY</strong>子句，那么SELECT子句中的内容就必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在<strong>SELECT</strong>子句中</li>
</ul>
<pre><code class="sql">#正确示范
SELECT deptno,COUNT(*),AVG(sal)
FROM t_emp GROUP BY deptno;

#错误示范
SELECT deptno,COUNT(*),AVG(sal),sal
FROM t_emp GROUP BY deptno;
</code></pre>
<h3 id="对分组结果集再次做汇总计算"><a href="#对分组结果集再次做汇总计算" class="headerlink" title="对分组结果集再次做汇总计算"></a>对分组结果集再次做汇总计算</h3><pre><code class="sql">SELECT 
deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)
FROM t_emp 
GROUP BY deptno WITH ROLLUP; #WITH ROLLUP对汇总函数再次进行汇总运算
</code></pre>
<h3 id="GROUP-CONCAT函数"><a href="#GROUP-CONCAT函数" class="headerlink" title="GROUP_CONCAT函数"></a>GROUP_CONCAT函数</h3><ul>
<li><p><strong>GROUP_CONCAT</strong>函数可以把分组查询中的<strong>某个字段拼接成一个字符串</strong></p>
</li>
<li><p>查询每个部门内底薪超过2000元的人数和员工姓名</p>
<pre><code class="sql">SELECT deptno,GROUP_CONCAT(ename),COUNT(*)
FROM t_emp 
WHERE sal&gt;=2000
GROUP BY deptno;
</code></pre>
<table>
<thead>
<tr>
<th align="center">deptno</th>
<th align="center">COUNT(*)</th>
<th align="center">GROUP_CONCAT(ename)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">CLARK,KING</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">3</td>
<td align="center">JONES,SCOTT,FORD</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">1</td>
<td align="center">BLAKE</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="各种子句的执行顺序"><a href="#各种子句的执行顺序" class="headerlink" title="各种子句的执行顺序"></a>各种子句的执行顺序</h3><h5 id="FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT"></a>FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT</h5><p><strong>WHERE</strong>符合的留下来交给<strong>GROUP BY</strong>去分组之后调用<strong>SELECT</strong>中的聚合函数计算 <strong>ORDER BY</strong>子句对结果排序交给<strong>LIMIT</strong>子句来挑选返回哪些数据</p>
<h3 id="分组查询遇到的困难？"><a href="#分组查询遇到的困难？" class="headerlink" title="分组查询遇到的困难？"></a>分组查询遇到的困难？</h3><ul>
<li><p>查询部门平均底薪超过2000元的部门编号</p>
<pre><code class="sql">#错误演示[因为WHERE语句出现了聚合函数]
SELECT deptno FROM t_emp
WHERE AVG(sal)&gt;=2000
GROUP BY deptno;
</code></pre>
</li>
<li><p><strong>HAVING</strong>语句是紧紧跟着<strong>GROUP BY</strong>语句的 <u>HAVING子句可以写聚合函数作为判断条件</u></p>
<pre><code class="sql">SELECT deptno
FROM t_emp
GROUP BY deptno HAVING AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的用途"><a href="#HAVING子句的用途" class="headerlink" title="HAVING子句的用途"></a>HAVING子句的用途</h3><ul>
<li><p>查询每个部门中，<u>1982年以后入职的员工$<em>{普通条件可以写在WHERE里}$</u><u>超过2个人</u>$</em>{COUNT(*)&gt;&#x3D;2}$的部门编号<br>不能拿<strong>聚合函数</strong>和<strong>某一个字段</strong>做判断</p>
<pre><code class="sql">SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2;
ORDER BY deptno ASC;

SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2 AND AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的特殊用法-作用类似于WHERE"><a href="#HAVING子句的特殊用法-作用类似于WHERE" class="headerlink" title="HAVING子句的特殊用法 [作用类似于WHERE]"></a>HAVING子句的特殊用法 [作用类似于WHERE]</h3><ul>
<li><p>按照数字1分组，MySQL会根据SELECT子句中的列进行分组，HAVING子句也可以正常使用<br>能用WHERE就不要先用HAVING 它的作用是給聚合函数做判断</p>
<pre><code class="sql">#不推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
GROUP BY 1 HAVING deptno IN (10,20);

#推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20)
GROUP BY 1;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-一"><a href="#数据操作语言：表链接查询-一" class="headerlink" title="数据操作语言：表链接查询(一)"></a>数据操作语言：表链接查询(一)</h3><h5 id="从多张表中提取数据"><a href="#从多张表中提取数据" class="headerlink" title="从多张表中提取数据"></a>从多张表中提取数据</h5><ul>
<li><p>从多张表中提取数据，必须指定关联的条件。如果不定义关联条件就会出现无条件链接，两张表的数据会交叉连接，产生<strong>笛卡尔积</strong></p>
</li>
<li><p>规定了链接条件的表链接语句，就不会出现笛卡尔积 [On条件]</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e JOIN t_dept d #給表起别名
ON e.deptno=d.deptno; #员工部门编号等于部门的部门编号
</code></pre>
</li>
</ul>
<h3 id="表链接的分类"><a href="#表链接的分类" class="headerlink" title="表链接的分类"></a>表链接的分类</h3><ul>
<li>表链接分为两种：<strong>内链接</strong>和<strong>外连接</strong></li>
<li><strong>内链接</strong>是结果集中只保留符合连接条件的记录</li>
<li><strong>外连接</strong>是不管符不符合链接条件，记录都要保留在结果集中</li>
</ul>
<h6 id="内链接"><a href="#内链接" class="headerlink" title="内链接"></a>内链接</h6><pre><code class="sql">SELECT ... FROM 表1
[INNER] JOIN 表2 ON 条件
[INNER] JOIN 表3 ON 条件
...
</code></pre>
<h6 id="内连接的多种语法形式"><a href="#内连接的多种语法形式" class="headerlink" title="内连接的多种语法形式"></a>内连接的多种语法形式</h6><pre><code class="sql">SELECT ... FROM 表1 JOIN 表2 ON 连接条件;
SELECT ... FROM 表1 JOIN 表2 WHERE 连接条件
SELECT ... FROM 表1,表2 WHERE 连接条件;
</code></pre>
<h3 id="内连接练习1"><a href="#内连接练习1" class="headerlink" title="内连接练习1"></a>内连接练习1</h3><ul>
<li><strong>查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级</strong>？且保证工资符合范围</li>
</ul>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname,e.sal,e.job,s.grade
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal;
</code></pre>
<ul>
<li>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</li>
</ul>
<h3 id="内连接练习2"><a href="#内连接练习2" class="headerlink" title="内连接练习2"></a>内连接练习2</h3><ul>
<li><p>查询与<strong>SCOTT</strong>相同部门的员工都有谁？</p>
</li>
<li><p>相同的数据表也可以做表连接</p>
<pre><code class="sql">SELECT deptno
FROM t_emp
WHERE ename=&quot;SCOTT&quot;; 

#子查询的结果变成了条件  SCOTT本人不算
SELECT deptno
FROM t_emp
WHERE deptno=(SELECT dptno FROM t_emp WHERE ename=&quot;SCOTT&quot;);
AND ename!=&quot;SCOTT&quot;;

#改造快速一些  ON后是筛选条件 和 WHERE作用差不多
SELECT e2.ename
FROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno
WHERE e1.ename=&quot;SCOTT&quot; AND e2.ename!=&quot;SCOTT&quot;; 
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-二"><a href="#数据操作语言：表链接查询-二" class="headerlink" title="数据操作语言：表链接查询(二)"></a>数据操作语言：表链接查询(二)</h3><h5 id="内连接查询练习1"><a href="#内连接查询练习1" class="headerlink" title="内连接查询练习1"></a>内连接查询练习1</h5><ul>
<li>查询底薪超过公司平均底薪的员工信息？<br><span style="color : red"><strong>把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】</strong></span></li>
</ul>
<pre><code class="sql">#错误展示
SELECT e2.empno,e2.ename,e2.sal  #因为ON可以换成WHERE 然而WHERE后面有聚合函数 所以会报错
FORM t_emp e1 JOIN t_emp e2 ON e2.sal&gt;=AVG(e1.sal);

#把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】
SELECT AVG(sal)
FROM t_emp;

SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN(SELECT AVG(sal) avg FROM t_emp) t #avg别名
ON e.sal&gt;=t.avg;
</code></pre>
<ul>
<li>查询RESEARCH部门的人数、最高底薪、最低底薪、平均底薪、平均工龄？</li>
</ul>
<pre><code class="sql">SELECT COUNT(*),MAX(e.sal),MIN(e.sal),AVG(e.sal),AVG(DATEDIFF(NOW(),e.hiredate)/365)
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;RESEARCH&quot;;

SELECT FLOOR(28.9); #变成28 向上取整
SELECT CEIL(1.1);   #变成1  向上取整
</code></pre>
<h5 id="内连接查询练习2"><a href="#内连接查询练习2" class="headerlink" title="内连接查询练习2"></a>内连接查询练习2</h5><ul>
<li><p>查询每种职业的最高工资、最低工资、平均工资、最高工资等级和最低工资等级？</p>
<pre><code class="sql">SELECT 
e.job,MAX(e.sal+IFNULL(e,comm,0)),
MIN(e.sal+IFNULL(e,comm,0)),AVG(e.sal+IFNULL(e,comm,0)),
MAX(s.grade),MIN(s.grade)
FROM t_emp e JOIN t_salgrade s
ON (e.sal+IFNULL(e,comm,0)) BETWEEN s.losal AND s.hisal
GROUP BY e.job;
</code></pre>
</li>
<li><p>查询每个底薪超过部门平均底薪的员工信息 [<strong>用表连接 而不是子查询</strong>]</p>
<pre><code class="sql">SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY dptno) t #别名t
ON e.deptno=t.deptno AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-三"><a href="#数据操作语言：表链接查询-三" class="headerlink" title="数据操作语言：表链接查询(三)"></a>数据操作语言：表链接查询(三)</h3><h5 id="为什么要使用外连接"><a href="#为什么要使用外连接" class="headerlink" title="为什么要使用外连接"></a>为什么要使用外连接</h5><ul>
<li>如果说陈浩是一名临时人员，没有固定的部门编制(NULL)，那么我们想查询每名员工和他的部门名称，用内连接就会遗漏掉陈浩，所以要引用外连接的语法才能解决这个问题</li>
</ul>
<h5 id="外连接简介"><a href="#外连接简介" class="headerlink" title="外连接简介"></a>外连接简介</h5><ul>
<li><p>外连接与内连接的区别在于，除了符合条件的记录之外，结果集中还会保留不符合条件的记录</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e  #因为陈浩部门编制是NULL 不能直接JOIN 只能LEFT JOIN
LEFT JOIN t_dept d ON e.deptno=d.deptno; 
</code></pre>
<table>
<thead>
<tr>
<th>7902</th>
<th>FORD</th>
<th>RESEARCH</th>
</tr>
</thead>
<tbody><tr>
<td>7934</td>
<td>MILLER</td>
<td>ACCOUNTING</td>
</tr>
<tr>
<td>8000</td>
<td>陈浩</td>
<td>(<strong>NULL</strong>)</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h3><ul>
<li><p>左外连接就是保留左表所有的记录，与右表做连接。如果右表有符合条件的记录就与左表连接。如果右表没有符合条件的记录，就用NULL与左表连接。右外连接也是如此。</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FORM t_dept d RIGHT JOIN t_emp e #要保留所有的t_emp e
ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="外连接练习1"><a href="#外连接练习1" class="headerlink" title="外连接练习1"></a>外连接练习1</h3><ul>
<li><p>查询每个部门的名称和部门的人数？ [40有部门没员工 要保存空值]<br><u>左外连接把部门表写在左侧    右外连接把部门表写在右侧</u></p>
<pre><code class="sql">SELECT d.dname,COUNT(*)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录 右表有空
ON d.deptno=e.deptno
GROUP BY d.deptno; #因为保留了左表所有记录 所以分组按照部门号分
#最终有一条t_dept与t_emp中的NULL做连接 所以 COUNT算上此记录
#若要将右表的NULL值忽略掉 要在COUNT(d.deptno)这样写

SELECT d.dname,COUNT(d.deptno)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录
ON d.deptno=e.deptno
GROUP BY d.deptno;
</code></pre>
<table>
<thead>
<tr>
<th>dname</th>
<th>COUNT(d.deptno)</th>
</tr>
</thead>
<tbody><tr>
<td>ACCOUNTING</td>
<td>3</td>
</tr>
<tr>
<td>RESEARCH</td>
<td>5</td>
</tr>
<tr>
<td>SALES</td>
<td>6</td>
</tr>
<tr>
<td><strong>OPERATIONS</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody></table>
</li>
<li><p>查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替</p>
</li>
<li><p><strong>UNION关键字</strong>可以将多个查询语句的结果集进行合并</p>
<pre><code class="sql">(查询语句) UNION (查询语句) UNION (查询语句)...
（SELECT d.name,COUNT(e.deptno)
FROM t_dept d LEFT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
）UNION
(SELECT d.dname,COUNT(*)
FROM t_dept d RIGHT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
);
</code></pre>
</li>
</ul>
<h3 id="数据库操作语言：表连接查询-四"><a href="#数据库操作语言：表连接查询-四" class="headerlink" title="数据库操作语言：表连接查询(四)"></a>数据库操作语言：表连接查询(四)</h3><ul>
<li><p>查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司编号、上司姓名、上司部门？<br>[不知道：员工信息 员工的上司信息    两个不知道信息是不能使用子查询的  <u>员工表 部门表 公司等级表</u>]</p>
<pre><code class="sql">#陈浩要保存下来 用外连接
SELECT
e.empno,e.ename,d.dname,
e.sal+IFNULL(e.comm,0),s.grade,
FLOOR(DATEDIFF(NOW(),e.hiredate)/365),
t.empno AS mgrno,t.ename AS mname,t.dname AS mdname #定义上司的数据
FROM t_emp e 
LEFT JOIN t_dept d ON e.deptno=d.deptno #结果集所有记录保存下来跟工资等级表做连接
LEFT JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal
LEFT JOIN
(SELECT e1.empno,e1.ename,d1.dname
FROM t_emp e1 JOIN t_dept d1
ON e1.deptno=d1.deptno
)t ON e.mgr=t.empno;
</code></pre>
</li>
</ul>
<h3 id="外连接的注意事项"><a href="#外连接的注意事项" class="headerlink" title="外连接的注意事项"></a>外连接的注意事项</h3><ul>
<li><strong>内连接</strong>值保留符合条件的记录，所以查询条件写在ON子句和WHERE子句中的效果是相同的。但是<strong>外连接</strong>里，条件写在WHERE子句里，不符合条件的记录是会被过滤掉的，而不是保留下来的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2af31e5baf5f6fc6e517ef9c13f689a8ab3db3a0/data/%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5WHEWE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
<h3 id="数据操作语言：子查询-一"><a href="#数据操作语言：子查询-一" class="headerlink" title="数据操作语言：子查询(一)"></a>数据操作语言：子查询(一)</h3><p>WHERE中的子查询是需要反复查询的 不推荐使用，但是把它所得的结果集作为一张表跟其他表做连接是推荐的</p>
<ul>
<li><p>子查询是一种查询中嵌套查询的语句</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="子查询的分类"><a href="#子查询的分类" class="headerlink" title="子查询的分类"></a>子查询的分类</h6><ul>
<li>子查询可以写在三个地方：<strong>WHERE子句、FROM子句、SELECT子句</strong>，但是只有FROM子句子查询是最可取的</li>
</ul>
<h6 id="WHERE子查询"><a href="#WHERE子查询" class="headerlink" title="WHERE子查询"></a>WHERE子查询</h6><ul>
<li><p>这种子查询最简单，最容易理解，但是确实<strong>效率很低</strong>的子查询</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp #↓↓↓↓ 比较每条记录都要重写执行子查询 ↓↓↓↓
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="FROM子查询"><a href="#FROM子查询" class="headerlink" title="FROM子查询"></a>FROM子查询</h6><ul>
<li><p>这种子查询只会执行一次，所以<strong>查询效率很高</strong></p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT
e.empno,e.ename,e.sal,t.avg
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg
FORM t_emp 
GROUP BY deptno) t #按照部门编号去分组 起别名
ON e.deptno=t.deptno 
AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h6 id="SELECT子查询"><a href="#SELECT子查询" class="headerlink" title="SELECT子查询"></a>SELECT子查询</h6><ul>
<li><p>这种子查询每输出一条记录的时候都要执行一次，<strong>查询效率很低</strong></p>
<pre><code class="sql">SELECT
e.empno,
e.ename,
(SELECT dname FROM t_dept WHERE deptno=e.deptno)
FROM t_emp e;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：子查询-二"><a href="#数据操作语言：子查询-二" class="headerlink" title="数据操作语言：子查询(二)"></a>数据操作语言：子查询(二)</h3><h5 id="单行子查询和多行子查询-结果集可以作为新表连接"><a href="#单行子查询和多行子查询-结果集可以作为新表连接" class="headerlink" title="单行子查询和多行子查询 [结果集可以作为新表连接]"></a>单行子查询和多行子查询 [结果集可以作为新表连接]</h5><ul>
<li><p>单行子查询的结果集只有一条记录，多行子查询结果集有多行记录</p>
</li>
<li><p>多行子查询只能出现在WHERE子句和FROM子句中</p>
</li>
<li><p>如何用子查询查找FORD和MARTIN两个人的同事</p>
<pre><code class="sql">SELECT ename #排除那俩人之外
FROM t_emp 
WHERE
deptno IN    # deptno = 不行因为后面返回了两条记录
(SELECT deptno FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;)); #返回两条记录
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;);
</code></pre>
</li>
</ul>
<h3 id="WHERE子句中的多行子查询"><a href="#WHERE子句中的多行子查询" class="headerlink" title="WHERE子句中的多行子查询"></a>WHERE子句中的多行子查询</h3><ul>
<li><p>WHERE子句中，可以使用<strong>IN、ALL、ANY、EXISTS</strong>关键字来处理多行表达式结果集的条件判断</p>
</li>
<li><p>调查”FORD”和”MARTIN”底薪都高的员工信息</p>
<pre><code class="sql">SELECT ename 
FROM t_emp 
WHERE sal &gt; ALL #ALL是sal里的数比结果集里的所有值都大  ANY则是比任何一个人大
(SELECT sal FROM t_emp #结果集里返回了多条记录
WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); #不包含这俩人
</code></pre>
</li>
</ul>
<h3 id="EXISTS关键字"><a href="#EXISTS关键字" class="headerlink" title="EXISTS关键字"></a>EXISTS关键字</h3><ul>
<li><p><strong>EXISTS关键字</strong>是把原来在子查询之外的条件判断，写到了子查询的里面<br>EXISTS用上之后WHERE就不写任何语句了</p>
<pre><code class="sql">SELECT ... FROM 表名 WHERE [NOT] EXISTS(子查询);
</code></pre>
</li>
<li><p>查询工资等级是3级或者4级的员工信息</p>
<pre><code class="sql">#排斥此方法 效率低下
SELECT
FROM t_emp
WHERE EXISTS(
SELECT * FROM t_salgrade
WHERE sal BETWEEN losal AND hisal 
AND grade IN(3,4)
);
</code></pre>
</li>
</ul>
<h1 id="MySQL对数据的基本操作"><a href="#MySQL对数据的基本操作" class="headerlink" title="MySQL对数据的基本操作"></a>MySQL对数据的基本操作</h1><h3 id="数据操作语言：INSERT语句"><a href="#数据操作语言：INSERT语句" class="headerlink" title="数据操作语言：INSERT语句"></a>数据操作语言：INSERT语句</h3><ul>
<li><p><strong>INSERT</strong>语句可以向数据表写入记录，可以是一条记录，也可以是多条记录</p>
<pre><code class="sql">INSERT INTO 表名(字段1,字段2,......) #添加字段可以快速写入 
VALUES(值1,值2,......);

INSERT INTO 表名(字段1,字段2,......) 
VALUES(值1,值2,......),(值1,值2,......); #多条记录

INSERT INTO t_dept(deptno,dname,loc)
VALUES(520,&quot;研发部&quot;,&quot;河北&quot;),(250,&quot;销售部&quot;,&quot;江西&quot;);

#向技术部添加一条员工记录 
#[技术部编号不知道 子查询技术部的编号 结果 写到VALUES子句里面通过INSERT插入员工表里面]
INSERT INTO t_emp
(empno,ename,job,mgr,hiredate,sal,comm,deptno)
VALUES(8001,&quot;潘春尧&quot;,&quot;SALESMAN&quot;,8000,&quot;2023-10-15&quot;,2000,NULL,
(SELECT deptno FROM t_dept WHERE dname=&quot;技术部&quot;)); #子查询单个结果返回
</code></pre>
</li>
</ul>
<h3 id="INSERT语法方言"><a href="#INSERT语法方言" class="headerlink" title="INSERT语法方言"></a>INSERT语法方言</h3><ul>
<li><p>MySQL的INSERT语句有一种方言语法</p>
<pre><code class="sql">INSERT INTO 表名 SET 字段1=值1,字段2=值2,......; #只适合Mysql数据库

(INSERT) INTO t_emp
SET empno=8002,ename=&quot;JACK&quot;,job=&quot;SLAESMAN&quot;,mgr=8000,
hiredate=&quot;1985-01-01&quot;,sal=2500,comm=NULL,deptno=50;

DELETE FROM t_emp WHERE empno=8002;
</code></pre>
</li>
</ul>
<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><ul>
<li><p><strong>IGNORE</strong>关键字会让<strong>INSERT</strong>只插入数据库不存在的记录</p>
<pre><code class="sql">INSERT [IGNORE] INTO 表名...;
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;技术部&quot;,&quot;北京&quot;); #40编号是主键被占用了 和已经现存的记录有冲突

#运用方言写
INSERT IGNORE INTO t_dept
SET deptno=40,dname=&quot;技术部&quot;,loc=&quot;北京&quot;;

#多重数据忽略不正确的数据
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;);

#VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;)
#&gt; Affected rows: 1
#&gt; 时间: 0.002s
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：UPDATE语句-一"><a href="#数据操作语言：UPDATE语句-一" class="headerlink" title="数据操作语言：UPDATE语句(一)"></a>数据操作语言：UPDATE语句(一)</h3><ul>
<li><p>UPDATE语句用于修改表的记录<br><strong>UPDATE</strong>中的<strong>NIGNORE</strong>直接忽略冲突的语句</p>
<pre><code class="sql">UPDATE [IGNORE] 表名
SET 字段1=值1，字段2=值2,......
[WHERE 条件1...] #有条件的修改记录
[ORDER BY...] #对数据先排序 后修改员工编号＋1 
[LIMIT...]; #取分页数据

#把每个员工的编号和上司的编号+1，用ORDER BY子句完成
UPDATE t_emp 
SET empno=empno+1,mgr=mgr+1
ORDER BY empno DESC;

#把用收入前三名的员工底薪减100元，用LIMIT子句完成
UPDATE t_emp
SET sal=sal-100 
ORDER BY sal+IFNULL(comm,0) DESC #降序 
LIMIT 3; #取前三条记录
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-一"><a href="#UPDATE语句的表连接-一" class="headerlink" title="UPDATE语句的表连接(一)"></a>UPDATE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句</p>
<pre><code class="sql">UPDATE 表1 JOIN 表2 ON 条件
SET 字段1=值1,字段2=值2,......;
</code></pre>
</li>
<li><p>表连接的UPDATE语句可以修改多张表的记录[<strong>进化</strong>]</p>
<pre><code class="sql">UPDATE 表1,表2
SET 字段1=值1,字段2=值2,......
WHERE 连接条件;

#把ALLEN调往RESEARCH部门，职务调整为ANALYST
[员工表+部门表]
UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
#//在t_emp表中找到ALLEN + 在t_dept表中找到RESEARCH 
#//然后把d.deptno赋值給e.deptno

UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno,e.job=&quot;ANALYST&quot;,d.loc=&quot;北京&quot;
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
</code></pre>
</li>
<li><p>把底薪低于公司平均底薪的员工，底薪增加150元<br>[运用<strong>表连接</strong>的方法比<strong>WHERE语句</strong>的效率高]</p>
<pre><code class="sql">UPDATE t_emp e JOIN
(SELECT AVG(sal) AS avg FROM t_emp) t
ON e.sal&lt;t.avg
SET e.sal=e.sal+150;
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-二"><a href="#UPDATE语句的表连接-二" class="headerlink" title="UPDATE语句的表连接(二)"></a>UPDATE语句的表连接(二)</h3><ul>
<li><p>UPDATE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">UPDATE 表1[LEFT|RIGHT] JOIN 表2 ON 条件 
SET 字段1=值1,字段2=值2,...;
</code></pre>
</li>
<li><p>把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门<br>[把所有员工保留下来 但是陈浩没有部门 用内连接的话会把陈浩忽略掉 要用<strong>左外连接</strong>把左表所有数据保留下来再去跟部门表作连接]</p>
<pre><code class="sql">#把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno #连接条件 不符合的也保留
SET e.deptno=202
WHERE e.deptno IS NULL OR (d.dname=&quot;SALES&quot; AND e.sal&lt;2000);
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：-DELETE语句-一"><a href="#数据操作语言：-DELETE语句-一" class="headerlink" title="数据操作语言： DELETE语句(一)"></a>数据操作语言： DELETE语句(一)</h3><ul>
<li>DELETE语句用于删除记录<pre><code class="sql">DELETE [IGNORE] FROM 表名
[WHERE 条件1,条件2,...] #按照条件删除记录
[ORDER BY...] #排序后删除
[LIMIT...]; #分页 工资降序排序 排在前五名的删掉
#顺序依次向下 最后一个是DELETE
</code></pre>
</li>
</ul>
<h6 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h6><ul>
<li><p>删除10部门中，工龄超过20年的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
</li>
<li><p>删除20部门中工资最高的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=20
ORDER BY sal+IFNULL(comm,0) DESC
LIMIT 1;
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-一"><a href="#DELETE语句的表连接-一" class="headerlink" title="DELETE语句的表连接(一)"></a>DELETE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所有我们可以利用表连接的方法来改造<strong>DELETE</strong>语句</p>
<pre><code class="sql">DELETE 表1,...FROM 表1 JOIN 表2 ON 条件 #删除哪张表记录的操作
[WHERE 条件1,条件2,...]
[ORDER BY...]
[LIMIT...];

#删除SALES部门和该部门的全部员工记录
#无需外连接 因为没有部门需要不删除的
DELETE e,d
FROM t_emp e JOIN t_dept d NO e.deptno=d.deptno #部门名称
WHERE d.dname=&quot;SALES&quot;;
</code></pre>
</li>
<li><p>删除<strong>SALES部门</strong>和该部门的全部员工记录[<strong>表连接</strong>]</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS sal FROM t_emp GOURP BY deptno)
ON e.deptno=t.deptno AND e.sal&lt;t.sal
</code></pre>
</li>
<li><p>删除员工KING和他的直接下属的员工记录，用表连接实现</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT empno FROM t_emp WHERE ename=&quot;KING&quot;) t
ON e.mgr=t.empno OR e.empno=t.empno; #KING的下属 OR KING这个人
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-二"><a href="#DELETE语句的表连接-二" class="headerlink" title="DELETE语句的表连接(二)"></a>DELETE语句的表连接(二)</h3><ul>
<li><p>DELETE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">DELETE 表1,... FROM 表1 [LEFT|RIGHT] JOIN 表2 ON 条件...;
</code></pre>
</li>
<li><p>删除SALES部门的员工，以及没有部门的员工 [左外 因为陈浩没部门要保留 外连接(不可用内连接)]</p>
<pre><code class="sql">DELETE e
FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;SALES&quot; OR e.deptno IS NULL
</code></pre>
</li>
</ul>
<h3 id="快速删除数据表全部记录"><a href="#快速删除数据表全部记录" class="headerlink" title="快速删除数据表全部记录"></a>快速删除数据表全部记录</h3><ul>
<li><p>DELETE语句实在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里面，然后删除记录</p>
</li>
<li><p>TRUNCATE语句再事务机制之外删除记录，速度大于DELETE语句</p>
<pre><code class="sql">TRUNCATE TABLE 表名;
</code></pre>
</li>
</ul>
<h3 id="MySql的内置函数"><a href="#MySql的内置函数" class="headerlink" title="MySql的内置函数"></a>MySql的内置函数</h3><p>数据库函<strong>数分类：数字、字符、日期、条件</strong>函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ABS</td>
<td align="center">绝对值</td>
<td align="center">ABS(-100)</td>
</tr>
<tr>
<td align="center">ROUND</td>
<td align="center">四舍五入</td>
<td align="center">ROUND(4.62)</td>
</tr>
<tr>
<td align="center">FOLLR</td>
<td align="center">强制舍位到最近的整数</td>
<td align="center">FLOOR(9,9) &#x3D; 9</td>
</tr>
<tr>
<td align="center">CEIL</td>
<td align="center">强制仅为最近的整数</td>
<td align="center">CEIL(3.2) &#x3D; 4</td>
</tr>
<tr>
<td align="center">POWER</td>
<td align="center">幂函数</td>
<td align="center">POWER(2,3)</td>
</tr>
<tr>
<td align="center">LOG</td>
<td align="center">对数函数</td>
<td align="center">LOG(7,3)</td>
</tr>
<tr>
<td align="center">LN</td>
<td align="center">对数函数</td>
<td align="center">LN(1,0)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQRT</td>
<td align="center">开平方</td>
<td align="center">SQRT(9)</td>
</tr>
<tr>
<td align="center">PI</td>
<td align="center">圆周率</td>
<td align="center">P10</td>
</tr>
<tr>
<td align="center">SIN</td>
<td align="center">三角函数</td>
<td align="center">sin(1)</td>
</tr>
<tr>
<td align="center">TAN</td>
<td align="center">三角函数</td>
<td align="center">TAN(1)</td>
</tr>
<tr>
<td align="center">COT</td>
<td align="center">三角函数</td>
<td align="center">COT(1)</td>
</tr>
<tr>
<td align="center">COS</td>
<td align="center">三角函数</td>
<td align="center">COS(2)</td>
</tr>
<tr>
<td align="center">DADIANS</td>
<td align="center">角度来换成角度</td>
<td align="center">DADIANS(20)</td>
</tr>
<tr>
<td align="center">DEGREES</td>
<td align="center">弧度转换角度</td>
<td align="center">DEGRESS(1)</td>
</tr>
</tbody></table>
<h3 id="获取系统的时间函数"><a href="#获取系统的时间函数" class="headerlink" title="获取系统的时间函数"></a>获取系统的时间函数</h3><ul>
<li><strong>NOW</strong>()函数能获得系统日期和时间，yyyy-MMMM-dd hh:mm:ss</li>
<li><strong>CURDATE</strong>()函数能获得当前系统日期，yyyy&#x3D;MM&#x3D;ddd</li>
<li><strong>CURTIME</strong>()函数能获得当前时间系统信息，hh:mm:ss</li>
</ul>
<h3 id="日期格式化函数-一"><a href="#日期格式化函数-一" class="headerlink" title="日期格式化函数(一)"></a>日期格式化函数(一)</h3><ul>
<li><p>**DATE_FORMAT()**函数用于格式化日期，返回用户想要的日期格式</p>
<pre><code class="sql">DATE_FORMAT(r日期,表达式)

SELECT ename,DATE_FORMAT(hiredate,&quot;%Y&quot;) AS &quot;year&quot;
FROM t_emp; 
</code></pre>
</li>
</ul>
<h3 id="日期格式化函数-二"><a href="#日期格式化函数-二" class="headerlink" title="日期格式化函数(二)"></a>日期格式化函数(二)</h3><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">作用</th>
<th align="center">占位符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%Y</td>
<td align="center">年份</td>
<td align="center">%m</td>
<td align="center">月份</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">日期</td>
<td align="center">%w</td>
<td align="center">星期(数字)</td>
</tr>
<tr>
<td align="center">%W</td>
<td align="center">星期(名称)</td>
<td align="center">%j</td>
<td align="center">本年第几天</td>
</tr>
<tr>
<td align="center">%U</td>
<td align="center">本年第几周</td>
<td align="center">%H</td>
<td align="center">小时(24)</td>
</tr>
<tr>
<td align="center">%h</td>
<td align="center">小时(12)</td>
<td align="center">%i</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">秒</td>
<td align="center">%r</td>
<td align="center">时间(12)</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">时间(24)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>利用日期函数，查询明年你的生日是星期几？</p>
<pre><code class="sql">SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%w&quot;); #数字
SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%W&quot;); #英文星期
</code></pre>
</li>
<li><p>利用日期函数，查询1981年上半年入职的员工多少人？[聚合函数 全表范围不用分组GROUP BY]</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp
WHERE DATE_FORMAT(hiredate,&quot;%Y&quot;)=1981
AND DATE_FORMAT(hiredate,&quot;%m&quot;)&lt;=6 #上半年
</code></pre>
</li>
</ul>
<h3 id="日期计算的注意事项"><a href="#日期计算的注意事项" class="headerlink" title="日期计算的注意事项"></a>日期计算的注意事项</h3><ul>
<li>MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减</li>
</ul>
<h6 id="日期偏移计算"><a href="#日期偏移计算" class="headerlink" title="日期偏移计算"></a>日期偏移计算</h6><ul>
<li><p>DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活</p>
<pre><code class="sql">DATE_ADD(日期,INTERVAL 偏移量 时间单位)

SELECT DATE_ADD(NOW(),INTERVAL 15 DAY); #15天之后
SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); #300分钟之前  2023-10-16 04:48:48
SELECT DATE_FORMAT(
DATE_ADD(DATE_ADD(NOW(),INTERVAL -6 MONTH),INTERVAL -3 DAY),&quot;%Y/%m/%d&quot;); #2023/04/13
</code></pre>
</li>
</ul>
<h6 id="计算日期之间相隔的天数"><a href="#计算日期之间相隔的天数" class="headerlink" title="计算日期之间相隔的天数"></a>计算日期之间相隔的天数</h6><ul>
<li><p>**DATEDIFF()**函数用来计算两个日期之间相差的天数</p>
<pre><code class="sql">DATEDIFF(日期,日期)
</code></pre>
</li>
</ul>
<h3 id="字符函数-一"><a href="#字符函数-一" class="headerlink" title="字符函数(一)"></a>字符函数(一)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOWER</td>
<td align="center">转换小写字符</td>
<td align="center">LOWER(ename)</td>
</tr>
<tr>
<td align="center">UPPER</td>
<td align="center">转换大写字符</td>
<td align="center">UPPER(ename)</td>
</tr>
<tr>
<td align="center">LENGTH</td>
<td align="center">字符数量</td>
<td align="center">LENGTH(ename)</td>
</tr>
<tr>
<td align="center">CONCAT</td>
<td align="center">连接字符串</td>
<td align="center">CONCAT(sal, “$”)</td>
</tr>
<tr>
<td align="center">INSTR</td>
<td align="center">字符出现的位置</td>
<td align="center">INSTR(ename, “A”)</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">插入&#x2F;替换字符</td>
<td align="center">INSERT(“你好”,1,0,”先生”)<br />替换1个字符  0表示不替换—候补</td>
</tr>
<tr>
<td align="center">REPLACE</td>
<td align="center">替换字符</td>
<td align="center">REPLACE(“你好先生”,“先生”,”女士”)<br />先生换成女士</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT
  LOWER(ename),UPPER(ename),LENGTH(ename),CONCAT(sal,&quot;$&quot;),INSTR(ename,&quot;A&quot;)
FROM t_emp;
</code></pre>
<h3 id="字符函数-二"><a href="#字符函数-二" class="headerlink" title="字符函数(二)"></a>字符函数(二)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SUBSTR</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTR(“你好世界”,3,4)<br />3开始位置 4结束位置</td>
</tr>
<tr>
<td align="center">SUBSTRING</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTRING(“你好世界”,3,2)<br />3个字符开始往后截取2个位置</td>
</tr>
<tr>
<td align="center">LPAD</td>
<td align="center">左侧填充字符</td>
<td align="center">LPAD(“Hello”,10,”<em>“)<br />潘</em>* 10最终字符串一共为10个字符<br />电话隐私保护加※号</td>
</tr>
<tr>
<td align="center">RPAD</td>
<td align="center">右侧填充字符</td>
<td align="center">RPAD(“Hello”,10,”*”)</td>
</tr>
<tr>
<td align="center">TRIM</td>
<td align="center">去除首位空格</td>
<td align="center">TRIM(“ 你好先生 “)</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT LPAD(SUBSTRING(&quot;15027597319&quot;,8,4),11,&quot;*&quot;);
SELECT RPAD(SUBSTRING(&quot;潘春尧&quot;,1,1),LENGTH(&quot;潘春尧&quot;)/3,&quot;*&quot;); 
#LENGTH是算英文字符 再除以3就是汉字的字符个数
</code></pre>
<h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul>
<li><p>SQL语句中可以利用条件函数来实现变成语言里的条件判断</p>
<pre><code class="sql">IFNULL(表达式,值)
IF(表达式,值1,值2)
</code></pre>
</li>
<li><p>中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B，打印每名员工获得的礼品<br>[按部门名称作表连接 部门表和员工表 内连接没有部门的没有礼品]</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,d.dname,
  IF(d.dname=&quot;SALES&quot;,&quot;礼品A&quot;,&quot;礼品B&quot;)
FROM t_emp e JOIN t_tept d ON e,deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li><p>复杂的条件判断可以用条件语句来实现，比IF语句功能更强大</p>
<pre><code class="sql">CASE 
  WHEN 表达式 THEN 值1
  WHEN 表达式 THEN 值2
  ......
  ELSE 值N
END
</code></pre>
</li>
<li><p>公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。<strong>SALES</strong>部门去P1地点，<strong>ACCOUNTING</strong>部门去P2地点，<strong>RESEARCH</strong>部门去P3地点，查询每名员工的旅行地点。</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,
  CASE 
    WHEN d.dname=&quot;SALES&quot; THEN &quot;p1&quot;
    WHEN d.dname=&quot;ACCOUNTING&quot; THEN &quot;p2&quot;
    WHEN d.dname=&quot;RESEARCH&quot; THEN &quot;P3&quot;
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h6 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h6><ul>
<li><p>某公司决定为员工调整基本工资，具体调整方案如下：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">条件</th>
<th align="center">涨幅</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SALES部门中工龄超过20年</td>
<td align="center">10%</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SALES部门中工龄不满20年</td>
<td align="center">5%</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">ACCOUNTING部门</td>
<td align="center">+300元</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">RESEARCH部门里低于部门平均底薪</td>
<td align="center">+200元</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">没有部门的员工</td>
<td align="center">+100元</td>
</tr>
</tbody></table>
<pre><code class="sql">[员工表连接部门表]
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
LEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_temp GOURP BY deptno) t
ON e.deptno=t.deptno
SET sal=(
    CASE 
      WHEN d,dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&gt;=20 
      THEN e.sal*1.1
      WHEN d,dname=&quot;ALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&lt;20 
      THEN e.sal*1.50
      WHEN d,dname=&quot;ACCOUNTING&quot; THEN e.sal+300
      WHEN d,dname=&quot;RESEARCH&quot; THEN e.sal&lt;t.avg THEN e.sal+200
      WHEN e.deotno IS NULL THEN e.sal+100
      ELSE e.sal
    END
);
</code></pre>
</li>
</ul>
<h3 id="事务机制-一-进入企业市场的第一步"><a href="#事务机制-一-进入企业市场的第一步" class="headerlink" title="事务机制(一) 进入企业市场的第一步"></a>事务机制(一) 进入企业市场的第一步</h3><h5 id="避免写入直接操作数据文件"><a href="#避免写入直接操作数据文件" class="headerlink" title="避免写入直接操作数据文件"></a>避免写入直接操作数据文件</h5><ul>
<li>如果数据的写入直接操作数据文件是非常危险的事情</li>
</ul>
<h5 id="利用日志来实现间接写入"><a href="#利用日志来实现间接写入" class="headerlink" title="利用日志来实现间接写入"></a>利用日志来实现间接写入</h5><ul>
<li>MySQL总共有5种日志，其中只有redo日志和undo日志与事务有关<br>[<strong>数据库</strong> 拷贝数据给 <strong>undo日志</strong> 记录修改 <strong>redo日志</strong> 与数据库<strong>同步数据</strong>]</li>
</ul>
<h5 id="事务机制-Transaction"><a href="#事务机制-Transaction" class="headerlink" title="事务机制(Transaction)"></a>事务机制(Transaction)</h5><ul>
<li>RDBMS &#x3D; SQL语句 + 事务(ACID)</li>
<li>事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要么全都执行失败</li>
</ul>
<h5 id="事务案例"><a href="#事务案例" class="headerlink" title="事务案例"></a>事务案例</h5><ul>
<li>把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门<br><span style = "color:red"><strong>事务</strong>：<u><em><strong>开启事务</strong></em> [把要修改的数据拷贝到<strong>undo日志</strong>[可恢复]内,做的修改会被记录到<strong>redo日志</strong>[同步]里面] <em><strong>UPDATE语句</strong></em>  <em><strong>DELETE语句  提交事务</strong></em></u></span></li>
</ul>
<h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><ul>
<li><p>默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务</p>
</li>
<li><p>为了让多条SQL语句纳入到一个事务之下，可以手动管理事务</p>
<pre><code class="sql">START TRANSACTION;
SQL语句
[COMMIT|ROLLBACK];

START TRANSACTION;
DELETE FROM t_emp
DELETE FROM t_dept;
SELECT * FROM t_emp;
SELECT * FROM t_dept;
#这些删除修改只是在redo日志文件中进行的修改并未提交 
#虽然SELECT查不到了 但是点开左列的表中数据仍未删除
#只要不提交事务 redo日志就不会和数据库做同步
COMMIT; #把结果提交到日志里面 就会同步了
ROLLBACK; #做标记 回滚 一起失败
</code></pre>
</li>
</ul>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><h6 id="原子性-一致性-隔离性-持久性"><a href="#原子性-一致性-隔离性-持久性" class="headerlink" title="原子性   一致性    隔离性   持久性"></a>原子性   一致性    隔离性   持久性</h6><h4 id="事务的原子性"><a href="#事务的原子性" class="headerlink" title="事务的原子性"></a>事务的原子性</h4><ul>
<li>一个事务中的所有操作要么全部完成，要么全部失败。事务执行后，不允许停留在中间某个状态</li>
</ul>
<h4 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h4><ul>
<li>不管任何给定的时间、并发事务由多少，事务必须保证运行结果的一致性<br>[<strong>阻止事务之间互相读取临时数据</strong>] [A給B 10元 事务<u>没有提交后且回滚了</u> C给A20元 此时A应该有30元 ]</li>
</ul>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><ul>
<li>隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事务</li>
<li>默认情况下A事务，只能看到日志中该事务的相关数据 [A,B事务可以看undo和redo日志]</li>
</ul>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><ul>
<li>事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化</li>
</ul>
<h3 id="事务机制-二"><a href="#事务机制-二" class="headerlink" title="事务机制(二)"></a>事务机制(二)</h3><h4 id="事务的四个隔离级别-可设置相互读取"><a href="#事务的四个隔离级别-可设置相互读取" class="headerlink" title="事务的四个隔离级别(可设置相互读取)"></a>事务的四个隔离级别(可设置相互读取)</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">隔离级别</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">read uncommitted</td>
<td align="center">读取未提交数据</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">read committed</td>
<td align="center">读取已提交数据</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">repeatable read</td>
<td align="center">重复读取</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">serializable</td>
<td align="center">序列化</td>
</tr>
</tbody></table>
<h3 id="业务案例1-购票系统"><a href="#业务案例1-购票系统" class="headerlink" title="业务案例1 [购票系统]"></a>业务案例1 [购票系统]</h3><h6 id="A事务-B事务"><a href="#A事务-B事务" class="headerlink" title="A事务  B事务"></a>A事务  B事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center">未售出</td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<p>A事务看到G8047 1A坐席未售出 用UPDATE把状态修改成已售出 因为没有提交 所以只修改在了undo日志里 真实的数据没有发生改变。此时B事务启动了看到了1A坐席还有票 于是更新且提交了 于是数据已经发生了改变。</p>
<h6 id="A事务"><a href="#A事务" class="headerlink" title="A事务"></a>A事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center"><strong><span style = "color :red">已售出</span></strong></td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<h6 id="所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席"><a href="#所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席" class="headerlink" title="所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席"></a>所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席</h6><h4 id="修改事务隔离级别"><a href="#修改事务隔离级别" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ UNCOMMITTED</strong></span> 代表可以读取其他事务未提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
</code></pre>
<pre><code class="sql">*无标题-查询1
START TRANSACTION;
UPDATE t_emp SET sal=1;
-----------------------
*无标题-查询2
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
#发现员工的sal并未变成1块钱

#解决问题：增加事务隔离级别  一个事务读到了另一个事务的数据
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
COMMIT;
</code></pre>
</li>
</ul>
<h3 id="业务案例2-银行转账"><a href="#业务案例2-银行转账" class="headerlink" title="业务案例2 [银行转账]"></a>业务案例2 [银行转账]</h3><h6 id="Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元"><a href="#Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元" class="headerlink" title="Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元"></a>Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元</h6><h4 id="修改事务隔离级别-1"><a href="#修改事务隔离级别-1" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ COMMITTED</strong></span> 代表只能读取其他事务提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre>
</li>
</ul>
<h3 id="业务案例3-电商案例"><a href="#业务案例3-电商案例" class="headerlink" title="业务案例3 [电商案例]"></a>业务案例3 [电商案例]</h3><p><strong>A事务</strong> 下单购买 商品(价格350元)   <strong>B事务</strong>要对 该商品涨价</p>
<h4 id="修改事务隔离级别【READ为默认级别】"><a href="#修改事务隔离级别【READ为默认级别】" class="headerlink" title="修改事务隔离级别【READ为默认级别】"></a>修改事务隔离级别【READ为默认级别】</h4><ul>
<li><p><span style = "color :red"><strong>REPEATABLE READ</strong></span> 代表事务在执行中反复读取数据，得到的结果是一致性的，<strong>不会受其他事务影响</strong></p>
<pre><code class="sql">#就算事务A提交了数据 也不影响事务B的查询原始数据
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; 
UPDATE t_emp SET sal=1; 
COMMIT;
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
START TRANSACTION; 
SELECT empno,ename,sal FROM t_emp; 
COMMIT;
</code></pre>
<h3 id="事务的序列化"><a href="#事务的序列化" class="headerlink" title="事务的序列化"></a>事务的序列化</h3><ul>
<li><p>由于事务并发执行所带来的各种问题，<strong>前三种隔离级别只适用于在某些业务场景中</strong>，但是序列化的隔离性，让事务逐一执行，就不会产生上述问题了。</p>
<pre><code class="sql">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; ①
UPDATE t_emp SET sal=1; ②
COMMIT; ⑤
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION; ③
SELECT empno,ename,sal FROM t_emp; ④ #此时会等待 只需要执行上方COMMIT
COMMIT;
</code></pre>
<h3 id="数据导入与导出"><a href="#数据导入与导出" class="headerlink" title="数据导入与导出"></a>数据导入与导出</h3><h4 id="数据导出与备份的区别"><a href="#数据导出与备份的区别" class="headerlink" title="数据导出与备份的区别"></a>数据导出与备份的区别</h4><ul>
<li>数据导出，导出的纯粹是业务数据</li>
<li>数据备份，备份的是数据文件、日志文件、索引文件灯</li>
</ul>
<p><strong>全量备份 → 增量备份1 → 增量备份2</strong></p>
<h4 id="数据导出的分类"><a href="#数据导出的分类" class="headerlink" title="数据导出的分类"></a>数据导出的分类</h4><p><strong>数据库</strong>可以导出<strong>SQL文档(数据不多)</strong> 也可以 导出<strong>文本文档(数据巨大)</strong></p>
<h4 id="导出SQL文件-或者手动右键库-存储SQL文件"><a href="#导出SQL文件-或者手动右键库-存储SQL文件" class="headerlink" title="导出SQL文件 [或者手动右键库 存储SQL文件]"></a>导出SQL文件 [或者手动右键库 存储SQL文件]</h4><ul>
<li><p><strong>mysqldump</strong>用来把业务数据导出成SQL文件，其中也包括了表结构</p>
<pre><code class="sql">#导出命令行 不写no-date就导出即包含 表结构 又包含 数据
mysqldump -uroot -p [no-date] 逻辑库 &gt; 路径
# D:/MySQL/demo.sql
</code></pre>
</li>
</ul>
<h4 id="导入SQL文件"><a href="#导入SQL文件" class="headerlink" title="导入SQL文件"></a>导入SQL文件</h4><ul>
<li>source命令用于导入SQL文件，包括创建数据表，写入记录等<pre><code class="sql">sql &gt; USE demo;
sql &gt; SOURCE backup.sql;
</code></pre>
</li>
</ul>
<h6 id="导出纯粹的业务数据"><a href="#导出纯粹的业务数据" class="headerlink" title="导出纯粹的业务数据"></a>导出纯粹的业务数据</h6><blockquote>
<p>若数据巨大 先导出表结构 再导出数据库文档(.txt) 之后再导入 就会快很多</p>
</blockquote>
<ul>
<li><p>t_emp 右键 存储sql文件 <strong>仅结构</strong> 再次右键 导出向导… txt文档 (跳过词法分析与语法优化)</p>
<pre><code class="sql">&quot;empno&quot;    &quot;ename&quot;    &quot;job&quot;    &quot;mgr&quot;    &quot;hiredate&quot;    &quot;sal&quot;    &quot;comm&quot;    &quot;deptno&quot;
&quot;7369&quot;    &quot;SMITH&quot;    &quot;CLERK&quot;    &quot;7902&quot;    &quot;17/12/1980&quot;    &quot;800&quot;        &quot;20&quot;
&quot;7499&quot;    &quot;ALLEN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;20/2/1981&quot;    &quot;1600&quot;    &quot;300&quot;    &quot;30&quot;
&quot;7521&quot;    &quot;WARD&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;22/2/1981&quot;    &quot;1250&quot;    &quot;500&quot;    &quot;30&quot;
&quot;7566&quot;    &quot;JONES&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;2/4/1981&quot;    &quot;2975&quot;        &quot;20&quot;
&quot;7654&quot;    &quot;MARTIN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;28/9/1981&quot;    &quot;1250&quot;    &quot;1400&quot;    &quot;30&quot;
&quot;7698&quot;    &quot;BLAKE&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;1/5/1981&quot;    &quot;2850&quot;        &quot;30&quot;
&quot;7782&quot;    &quot;CLARK&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;9/6/1981&quot;    &quot;2450&quot;        &quot;10&quot;
&quot;7788&quot;    &quot;SCOTT&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;9/12/1982&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7839&quot;    &quot;KING&quot;    &quot;PRESIDENT&quot;        &quot;17/11/1981&quot;    &quot;5000&quot;        &quot;10&quot;
&quot;7844&quot;    &quot;TURNER&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;8/9/1981&quot;    &quot;1500&quot;    &quot;0&quot;    &quot;30&quot;
&quot;7876&quot;    &quot;ADAMS&quot;    &quot;CLERK&quot;    &quot;7788&quot;    &quot;12/1/1983&quot;    &quot;1100&quot;        &quot;20&quot;
&quot;7900&quot;    &quot;JAMES&quot;    &quot;CLERK&quot;    &quot;7698&quot;    &quot;3/12/1981&quot;    &quot;950&quot;        &quot;30&quot;
&quot;7902&quot;    &quot;FORD&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;3/12/1981&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7934&quot;    &quot;MILLER&quot;    &quot;CLERK&quot;    &quot;7782&quot;    &quot;23/1/1982&quot;    &quot;1300&quot;        &quot;10&quot;
</code></pre>
</li>
<li><p>导入回来 先删除t_emp 在dmeo右键 运行文件 导入刚刚右键存储的t_emp的结构(仅结构) 此时员工表结构就回来了 导入向导… 下一步 找到导出的txt文档  第一个数据行1(第一行有效数据) 在导入向导中根据<strong>源字段</strong>匹配<strong>目标字段</strong> (txt+结构&#x3D;数据表)</p>
</li>
</ul>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>