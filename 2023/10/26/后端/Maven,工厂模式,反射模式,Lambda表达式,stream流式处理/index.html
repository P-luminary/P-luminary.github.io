
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Maven,工厂模式,反射模式,Lambda表达式,stream流式处理</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Maven,工厂模式,反射模式,Lambda表达式,stream流式处理 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/26
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#879cff>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h3 id="Maven构建工具"><a href="#Maven构建工具" class="headerlink" title="Maven构建工具"></a>Maven构建工具</h3><h6 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h6><ul>
<li>Maven是项目管理工具，对软件项目提供构建与依赖管理</li>
<li>Maven是Apache下的Java开源项目</li>
<li>Maven为Java项目提供了统一的管理方式，已经成为业界标准</li>
</ul>
<h6 id="Maven核心特性"><a href="#Maven核心特性" class="headerlink" title="Maven核心特性"></a>Maven核心特性</h6><ul>
<li>项目设置遵循统一的规则，保证不同开发环境的兼容性</li>
<li>强大的依赖管理，项目依赖组件自动下载、自动更新</li>
<li>可扩展的插件机制，使用简单，功能丰富</li>
</ul>
<h6 id="Maven的坐标"><a href="#Maven的坐标" class="headerlink" title="Maven的坐标"></a>Maven的坐标</h6><ul>
<li><strong>GroupId</strong>：机构或者团体的英文，采用”逆向域名”形式书写</li>
<li><strong>ArtifactId</strong>：项目名称，说明其用途，例如：cms、oa…</li>
<li><strong>Version</strong>：版本号，一般采用”版本+单词”形式，例如：1.0.0.RELEASE</li>
</ul>
<h3 id="Maven项目标准结构"><a href="#Maven项目标准结构" class="headerlink" title="Maven项目标准结构"></a>Maven项目标准结构</h3><table>
<thead>
<tr>
<th>目录</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>${basedir}</td>
<td>根目录，用于保存pom.xml</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td>
<td>资源目录，保存配置文件、静态图片等</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td>
<td>测试类的源代码</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td>
<td>测试时需要使用的资源文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target</td>
<td>项目输出的目录，用于存储jar、war文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target&#x2F;class</td>
<td>字节码(.class)的编译输出目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;<strong>pom.xml</strong></td>
<td>项目(<strong>P</strong>roject)对象(<strong>O</strong>bject)模型(<strong>M</strong>odel)文件</td>
</tr>
</tbody></table>
<h3 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h3><ul>
<li>Maven利用<strong>dependency</strong>(依赖) 自动下载、管理第三方Jar</li>
<li>在pom.xml文件中配置项目依赖的第三方组件</li>
<li>maven自动将依赖从<strong>远程仓库</strong>下载至<strong>本地仓库</strong>，并在工程中引用</li>
</ul>
<pre><code class="html">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><span style = "color : red"><a target="_blank" rel="noopener" href="https://search.maven.org/">Maven Central Repository Search</a>可以搜索<strong>maven</strong></span></p>
<pre><code class="html">pom.xml
&lt;dependencies&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;com.belerweb&lt;/groupId&gt;
          &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
          &lt;version&gt;2.5.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="java">PinyinTestor.java
import net.sourceforge.pinyin4j.PinyinHelper;

import java.util.Scanner;

public class PinyinTestor &#123;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] pingyin = PinyinHelper.toHanyuPinyinStringArray(str.charAt(0)); //将输入的第一个数据变成字符串数组
        for (String py : pingyin)&#123;
            System.out.println(py);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="本地仓库与中央仓库"><a href="#本地仓库与中央仓库" class="headerlink" title="本地仓库与中央仓库"></a>本地仓库与中央仓库</h3><p><strong>maven</strong> 在项目启动的时候会对 <strong>pom.xml</strong> 进行加载 之后会在<strong>本地仓库</strong> <strong>.m2\repository</strong> 去查找依赖文件(jar包) 如果查不到或不存在 就会去<strong>中央仓库</strong>下载(repo.maven.apache.org)到本地仓库</p>
<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><ul>
<li>Maven可将Java项目打包为<strong>jar、war</strong>包</li>
<li>Maven项目打包是通过<strong>Plugins</strong>(插件)技术实现</li>
<li>Maven输出jar包插件：maven-assembly-plugin</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/32c4c5407cd517b9304127dfdab23e910c4aea0c/data/Maven%E6%89%93%E5%8C%85.png" style="zoom:200%;" />

<pre><code class="html">//阿里云镜像下载地址
&lt;repositories&gt;
  &lt;repository&gt;
      &lt;!-- 创建私服的地址 --&gt;
    &lt;id&gt;aliyun&lt;/id&gt;
    &lt;name&gt;aliyun&lt;/name&gt;
    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3 id="Maven构建Web工程"><a href="#Maven构建Web工程" class="headerlink" title="Maven构建Web工程"></a>Maven构建Web工程</h3><p>创建Maven-Project</p>
<pre><code class="html">Group Id: maven-first
Artifacr Id: maven
Version: 1.0.0-RELEASE
Packaging: jar
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/czc9309/article/details/80304074">IntelliJ IDEA创建maven web项目（IDEA新手适用）_idea maven创建web项目-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45384457/article/details/128532296">IDEA2022版本创建maven web项目（两种方式）最全图文教学_idea创建maven项目没有webapp-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41523340/article/details/122598795">IDEA中创建Maven Web项目的两种方法_idea maven创建web项目-CSDN博客</a><br>Project Structure → Modules → ＋增加Web</p>
<blockquote>
<p><strong>web application exploded</strong>：这个是以文件夹形式发布项目，发布项目时就会自动生成文件夹在指定的output directory；<br><strong>web application archive</strong>：就是war包形式,将项目打成一个war包在指定位置</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63324772/article/details/124516436">Tomcat报404问题解决方案大全(包括tomcat可以正常运行但是报404)_tomcat 404_ISAS的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41926609/article/details/104977944">(.iml的问题)IDEA中用Maven创建web项目部署运行时页面报错404解决方法_maven web项目404-CSDN博客</a></p>
<h3 id="Web应用打包"><a href="#Web应用打包" class="headerlink" title="Web应用打包"></a>Web应用打包</h3><pre><code class="html">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Web_one&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar\war&lt;/packaging&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>打包成war\jar后可以通过tomcat中的临时启动服务器来运行</p>
<h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>mvn archetype:generate</td>
<td>创建Maven工程结构</td>
</tr>
<tr>
<td>mvn <strong>compile</strong></td>
<td>编译源代码 .class</td>
</tr>
<tr>
<td>mvn <strong>test</strong></td>
<td>执行测试用例</td>
</tr>
<tr>
<td>mvn <strong>clean</strong></td>
<td>清除产生的项目</td>
</tr>
<tr>
<td>mvn <strong>package</strong></td>
<td>项目打包</td>
</tr>
<tr>
<td>mvn <strong>install</strong></td>
<td>安装至本地仓库</td>
</tr>
</tbody></table>
<h3 id="修改本地仓库地址"><a href="#修改本地仓库地址" class="headerlink" title="修改本地仓库地址"></a>修改本地仓库地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/781d364e7b198b48320f5f30b0353f09e0a6e491/data/Maven%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></p>
<h3 id="工厂模式-运用于真实项目"><a href="#工厂模式-运用于真实项目" class="headerlink" title="工厂模式 [运用于真实项目]"></a>工厂模式 [运用于真实项目]</h3><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><ul>
<li>设计模式是前辈总结的设计经验</li>
<li>设计模式的目标是代码更容易理解，更容易维护</li>
<li>通过设计模式可以让代码更加可靠</li>
</ul>
<h5 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h5><ul>
<li>创建型模式 [帮助我们如何更精巧的创建对象]</li>
<li>结构型模式 [在软件结构上通过重构\抽象 让软件结构变得更有条理]</li>
<li>行为型模式 [现实中的场景对软件的设计和优化]</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><ul>
<li>工厂模式用于隐藏创建对象的细节</li>
<li>工厂模式核心：工厂类(Factory)</li>
<li>工厂模式可以细分为<strong>简单工厂</strong>、工厂方法与抽象方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e0a6dc8012091ace359e456d27a0e99790d5e4/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂图"></p>
<h6 id="项目应用-i18n国际化-软件分工更明确-软件耦合降低"><a href="#项目应用-i18n国际化-软件分工更明确-软件耦合降低" class="headerlink" title="项目应用-i18n国际化 (软件分工更明确 软件耦合降低)"></a>项目应用-i18n国际化 (软件分工更明确 软件耦合降低)</h6><p>不同国家显示页面的语言不同<br>抽象一个接口！！</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8697c92cea29312070f514788d158aadbde6513f/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81.png"></p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h6 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h6><ul>
<li>反射式在<strong>运行时</strong>动态访问类与对象的技术 [写死的代码不灵活]</li>
<li>反射是JDK1.2版本后的高级特性，隶属于<strong>java.lang.reflect</strong></li>
<li>大多数Java框架都是基于<strong>反射实现参数</strong>配置、<strong>动态注入</strong>等特性</li>
</ul>
<h6 id="初始反射技术"><a href="#初始反射技术" class="headerlink" title="初始反射技术"></a>初始反射技术</h6><pre><code class="java">未运用反射技术
 public static void case1()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next();
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        if(op.equals(&quot;Addition&quot;))&#123;
            mathOperation = new Addition();
        &#125;else if(op.equals(&quot;Subtraction&quot;)) &#123;
            mathOperation = new Subtraction();
        &#125;else if(op.equals(&quot;Multiplication&quot;))&#123;
            mathOperation = new Multiplication();
        &#125;else&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result);
    &#125;

======================================================
运用反射技术
 public static void case2()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next(); ****
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        try &#123;
            mathOperation = (MathOperation) Class.forName(&quot;com.imooc.reflect.&quot; + op).newInstance(); //class.forName加载指定的类 实例化对象 运行时动态决定op创建哪些对象 访问哪些属性****
        &#125;catch(Exception e)&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result); 
    &#125;
</code></pre>
<h3 id="反射的核心类"><a href="#反射的核心类" class="headerlink" title="反射的核心类"></a>反射的核心类</h3><h5 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><strong>Class类</strong></h5><p>Class是JVM中代表”类和接口”的类<br>Class对象具体包含了某个特定类的结构信息<br>通过Class对象可获取对应类的构造方法&#x2F;方法&#x2F;成员变量</p>
<h6 id="Class核心方法"><a href="#Class核心方法" class="headerlink" title="Class核心方法"></a><span style = "color : red">Class核心方法</span></h6><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Class.forName() [传入完整类名包括包]</td>
<td>静态方法,用于获取指定Class对象</td>
</tr>
<tr>
<td>classObj.newInstance()</td>
<td>通过<strong>默认构造方法创建新的对象</strong></td>
</tr>
<tr>
<td>classObj.getConstructor()</td>
<td>获得指定的public修饰构造方法Constructor对象</td>
</tr>
<tr>
<td>classObj.getMethod()</td>
<td>获取指定的public修饰方法Method对象</td>
</tr>
<tr>
<td>classObj.getField()</td>
<td>获取指定的public修饰成员变量Field对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ClassSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

public class ClassSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            System.out.println(&quot;Employee已被加载到jvm&quot;);
            //newInstance通过默认构造方法创建新的对象
            Employee emp = (Employee)employeeClass.newInstance();
            System.out.println(emp);
        &#125; catch (ClassNotFoundException e) &#123;
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h5 id="Constructor构造方法类"><a href="#Constructor构造方法类" class="headerlink" title="Constructor构造方法类"></a><strong>Constructor构造方法类</strong></h5><ul>
<li>Constructor类是对Java类中的构造方法的抽象</li>
<li>Contructor对象包括了具体类的某个具体构造方法的声明</li>
<li>通过Constructor对象调用带参构造方法创建对象</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getConstructor()</td>
<td>获取指定public修饰的构造方法对象</td>
</tr>
<tr>
<td>constructorObj.newInstance()</td>
<td>通过对应的构造方法创建对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ConstructorSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ConstructorSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123; //得到对应的class对象
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            System.out.println(employee);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
        &#125; catch (NoSuchMethodException e) &#123;
            //没有找到与之对应格式的写法
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            //当被调用的方法的内部抛出了异常而没有被捕获时
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a><strong>Method类</strong></h5><ul>
<li>Method对象指代某个类中的方法的描述</li>
<li>Method对象使用classObj.getMethod()方法获取</li>
<li>通过Method对象调用指定对象的对应方法</li>
</ul>
<p><span style = "color : red"><strong>Method核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getMethod()</td>
<td>获取指定public修饰的方法对象</td>
</tr>
<tr>
<td>methodObj.invoke()</td>
<td>调用指定对象的对应方法</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">MethodSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MethodSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Method updateSalaryMethod = employeeClass.getMethod(&quot;updateSalary&quot;, new Class[]&#123; //传入参数
               Float.class
            &#125;);
            Employee employee1 = (Employee)updateSalaryMethod.invoke(employee, new Object[]&#123;1000f&#125;); //若有返回值 要强制转换
            System.out.println(employee1);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Field成员变量类"><a href="#Field成员变量类" class="headerlink" title="Field成员变量类"></a><strong>Field成员变量类</strong></h5><ul>
<li>Field对应某个具体类中的成员变量的声明</li>
<li>Field对象使用**classObj.getField()**方法获取</li>
<li>通过Field对象可为某对象成员变量赋值&#x2F;取值</li>
</ul>
<p><span style = "color : red"><strong>Field类核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getField()</td>
<td>获取指定publicc修饰的成员变量对象</td>
</tr>
<tr>
<td>fieldObj.set()</td>
<td>为某对象指定成员变量赋值</td>
</tr>
<tr>
<td>fieldObj.get()</td>
<td>获取某对象指定成员变量数值</td>
</tr>
</tbody></table>
<p>快速添加包裹try catch → 框上要包裹的 点Code → surround with<br>get()&#x2F;set()都是(在entify中)public共有方法</p>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    public String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">FieldSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

public class FieldSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field enameField = employeeClass.getField(&quot;ename&quot;);
            enameField.set(employee,&quot;李雷&quot;);
            String ename = (String) enameField.get(employee);
            System.out.println(&quot;ename:&quot; + ename);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchFieldException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="getDeclared系列方法"><a href="#getDeclared系列方法" class="headerlink" title="getDeclared系列方法"></a>getDeclared系列方法</h3><ul>
<li><span style = "color:red"><strong>getDeclaredConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong></span> 获取对应对象</li>
<li><strong>getConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong> 只能获取public对象</li>
<li>访问<strong>非作用域内构造方法、方法、成员变量</strong>，会抛出异常</li>
</ul>
<p>public可以直接获取 private只能通过get…获取</p>
<pre><code class="java">Employee.java + getDeclaredSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class getDeclaredSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field[] fields = employeeClass.getDeclaredFields();
            for (Field field : fields)&#123;
//                System.out.println(field.getName());
                if (field.getModifiers() == 1) &#123;//成员变量修饰符 public修饰
                    Object val = field.get(employee);
                    System.out.println(field.getName() + &quot;:&quot; + val);
                &#125; else if (field.getModifiers() == 2) &#123; //private修饰
                    String methodName = &quot;get&quot; + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);//(0,1)是截取字符串 第一个大写字母
                    Method getMethod = employeeClass.getMethod(methodName);
                    Object ret = getMethod.invoke(employee);
                    System.out.println(field.getName() + &quot;:&quot; + ret);
                &#125;
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="反射在项目中的应用"><a href="#反射在项目中的应用" class="headerlink" title="反射在项目中的应用"></a>反射在项目中的应用</h3><h6 id="反射最重要的就是可以在运行时"><a href="#反射最重要的就是可以在运行时" class="headerlink" title="反射最重要的就是可以在运行时"></a>反射最重要的就是可以在运行时</h6><p><a href="seata.io/en-us/">反射的应用网站</a></p>
<p>对原始程序无需任何调整，只需要把对应的接口进行实现，放到线上服务器，再调整配置文件。</p>
<pre><code class="java">Zhcn.java
package com.imooc.i18n;

public class Zhcn implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;生命不息奋斗不止&quot;;
    &#125;
&#125;
=========================================================
En.java
package com.imooc.i18n;

public class En implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;Case to the struggle and cease to the life&quot;;
    &#125;
&#125;
========================================================
接口I18N.java
package com.imooc.i18n;

public interface I18N &#123;
    public String say();
&#125;
</code></pre>
<pre><code class="java">package com.imooc.i18n;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.Properties;

public class Application &#123;
    public static void say()&#123;
        Properties properties = new Properties(); //加载指定的配置文件
        String configPath = Application.class.getResource(&quot;/config.properties&quot;).getPath();
        try &#123;
            configPath = new URLDecoder().decode(configPath,&quot;UTF-8&quot;);//路径中的空格默认得到url编码所以要转换一下
            properties.load(new FileInputStream(configPath)); //内容来源于文件 文件输入流
            String language = properties.getProperty(&quot;language&quot;);
            I18N i18n = (I18N)Class.forName(language).newInstance();
            System.out.println(i18n.say());
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Application.say();
    &#125;
&#125;
</code></pre>
<pre><code class="html">language=com.imooc.i18n.En
或
language=com.imooc.i18n.Zhcn
</code></pre>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li>JDK8(1.8以上)开始支持Lambda表达式，用来让程序编写更优雅</li>
<li>利用Lambda可以更简洁的<strong>实现匿名内部类</strong>与<strong>函数声明与调用</strong></li>
<li>基于Lambda提供<strong>stream流</strong>式处理极大简化对集合的操作</li>
</ul>
<h6 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//实现集合排序
Collections.sort(names,new Comparator&lt;String&gt;()&#123;
  @Override
  public int compare(String a,String b)&#123;
      return b.compareTo(a);
  &#125;  
&#125;);
</code></pre>
<h6 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//通过lambda表达式简化匿名类的编写
Collections.sort(names,(a,b) -&gt; b.compareTo(a));
</code></pre>
<h3 id="Lambda表达式语法-代码脚手架"><a href="#Lambda表达式语法-代码脚手架" class="headerlink" title="Lambda表达式语法 [代码脚手架]"></a><span style = "color : red">Lambda表达式语法</span> [代码脚手架]</h3><p><strong><span style = "color:red">(参数列表) —＞实现语句</span></strong><br>[<u>使用逗号分割参数,参数类型可省略,单参数括号可省略</u>]<br>[<u>单行直接写 多行用{}包括</u>]</p>
<pre><code class="java">MathOperation.java
public interface MathOperation &#123;
    //四则运算接口
    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<pre><code class="java">LambdaSample.java
public class LambdaSample &#123;
    public static void main(String[] args) &#123;
        //标准Lambda使用方法
        //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口,Java称为&quot;函数式接口&quot;
        //1.标注使用方式
        MathOperation addition = (Integer a, Integer b) -&gt; &#123;
            System.out.println(&quot;加法运算&quot;);
            return a+b+0f; //定义的接口是Float
        &#125;;
        System.out.println(addition.operate(5, 5));

        //2.lambda允许忽略参数类型
        MathOperation substration = (a,b) -&gt; &#123;
            return a-b+0f;
        &#125;;
        System.out.println(substration.operate(5, 3));

        //3.单行实现代码可以省略大括号和return
        MathOperation multiplication = (a,b) -&gt; a*b+0f;
        System.out.println(multiplication.operate(3, 5));
    &#125;
&#125;
</code></pre>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>函数式编程是基于函数式接口并使用lambda表达的编程方式</li>
<li>函数式编程理念是将代码作为可重用数据带入到程序运行中</li>
<li>函数式编程强调”<strong>你想做什么</strong>“，而不是”<strong>你想怎么做</strong>“</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>函数式接口是有且只有一个抽象方法的接口</li>
<li>Java中拥有大量函数式接口，如<strong>java.lang.Runnable</strong></li>
<li>JDK8后提供了一系列新的函数式接口，位于<strong>java.util.function</strong></li>
</ul>
<h3 id="函数式接口Perdicate"><a href="#函数式接口Perdicate" class="headerlink" title="函数式接口Perdicate"></a>函数式接口Perdicate</h3><ul>
<li>Perdicate是新增的函数式接口，位于<strong>java.util.function</strong></li>
<li><u>Perdicate用于测试传入的数据是否满足<strong>判断要求</strong></u></li>
<li>Perdicate接口需要实现test()方法进行逻辑判断</li>
</ul>
<p><span style = "color:red"> 用<strong>lambda表达式</strong>来实现<strong>predicate</strong>的验证</span><br>将已有的代码变成可重复使用的资源放入程序中</p>
<pre><code class="java">PredicateSample.java
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

/*
    理解函数式编程
    Perdicate函数式接口的使用方法
 */
public class PredicateSample &#123;
    public static void main(String[] args) &#123;
        Predicate &lt;Integer&gt; predicate = n-&gt;n&gt;4; //隐藏着return
        boolean result = predicate.test(10);
        System.out.println(result);
        List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
        filter(list,n-&gt;n%2==1); //传入函数式接口的实现lambda 取所有奇数
        filter(list,n-&gt;n%2==0); //取所有偶数
        filter(list,n-&gt;n&gt;5 &amp;&amp; n%2==0); //取所有大于5的偶数
    &#125;
    public static void filter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)&#123;
        for (Integer num:list)&#123;
            if (predicate.test(num))&#123;
                System.out.println(num + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="各种函数接口"><a href="#各种函数接口" class="headerlink" title="各种函数接口"></a>各种函数接口</h3><h5 id="JDK8常用函数式接口"><a href="#JDK8常用函数式接口" class="headerlink" title="JDK8常用函数式接口"></a>JDK8常用函数式接口</h5><h6 id="consumer函数接口"><a href="#consumer函数接口" class="headerlink" title="consumer函数接口"></a>consumer函数接口</h6><table>
<thead>
<tr>
<th><strong>接口</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Consumer&lt; T &gt;</strong></td>
<td><strong>对应有一个输入参数无输出的功能代码</strong></td>
</tr>
<tr>
<td><strong>Function&lt; T,R &gt;</strong></td>
<td>对应有一个输入参数且需要返回参数的功能代码</td>
</tr>
<tr>
<td><strong>Predicate&lt; T &gt;</strong></td>
<td>用于条件判断，固定返回布尔值</td>
</tr>
</tbody></table>
<pre><code class="java">ConsumerSample.java
import java.util.function.Consumer;

/*
    Consumer接口的使用
 */
public class ConsumerSample &#123;
    public static void main(String[] args) &#123;
        output(s-&gt; System.out.println(&quot;向控制台打印：&quot; + s));
        //字符串作为网络数据包向某个网站发送
        output(s-&gt;&#123;
            System.out.println(&quot;向XXX网络发送数据包:&quot; + s);
        &#125;);
    &#125;
    public static void output(Consumer&lt;String&gt; consumer)&#123;
        String text = &quot;苦其心志,劳其筋骨&quot;;
        consumer.accept(text);
    &#125;
&#125;
</code></pre>
<h6 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h6><pre><code class="java">FunctionSample.java
import java.util.Random;
import java.util.function.Function;

/*
    利用Function函数式接口生成定长随机字符串[加密解密会用到]
 */
public class FunctionSample &#123;
    public static void main(String[] args) &#123;
        Function&lt;Integer,String&gt; randomStringFunction = l-&gt;&#123;
            String chars = &quot;abcdefghijklmnopqrstuvxwyz0123456789&quot;;
            StringBuffer stringBuffer = new StringBuffer();
            Random random = new Random();
            for (int i = 0; i &lt; l; i++) &#123;
                int position = random.nextInt(chars.length());
                stringBuffer.append(chars.charAt(position));//按指定位置将字符提取并追加
            &#125;
            return stringBuffer.toString();
        &#125;;
        String randowmString = randomStringFunction.apply(16);//生成16位长的字符串
        System.out.println(randowmString);
    &#125;
&#125;
</code></pre>
<h6 id="functionalInterface注解"><a href="#functionalInterface注解" class="headerlink" title="@functionalInterface注解"></a>@functionalInterface注解</h6><pre><code class="java">MathOperation.java
@FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查
public interface MathOperation &#123;
    //四则运算接口

    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<h3 id="函数式编程与面向对象编程比较"><a href="#函数式编程与面向对象编程比较" class="headerlink" title="函数式编程与面向对象编程比较"></a>函数式编程与面向对象编程比较</h3><table>
<thead>
<tr>
<th></th>
<th>面向对象编程</th>
<th>函数式编程</th>
</tr>
</thead>
<tbody><tr>
<td>设计思路</td>
<td>面向对象</td>
<td>面向过程</td>
</tr>
<tr>
<td>开发侧重</td>
<td>侧重过程,重分析,重设计</td>
<td>侧重结果,快速实现</td>
</tr>
<tr>
<td>可读性</td>
<td>结构复杂,相对较差</td>
<td>更适合人眼阅读,可读性更好</td>
</tr>
<tr>
<td>代码量</td>
<td>多</td>
<td>少</td>
</tr>
<tr>
<td>并发问题</td>
<td>设计不当,会出现线程安全问题</td>
<td>不会出现线程安全问题</td>
</tr>
<tr>
<td>健壮性</td>
<td>好</td>
<td>差</td>
</tr>
<tr>
<td>使用场景</td>
<td>中大型项目,多人协作工程</td>
<td>小型应用,要求快速实现</td>
</tr>
</tbody></table>
<h3 id="Stream流式处理"><a href="#Stream流式处理" class="headerlink" title="Stream流式处理"></a>Stream流式处理</h3><ul>
<li>Stream流式处理式建立在Lambda基础上的多数据处理技术 </li>
<li>Stream对集合数据处理进行高度抽象，极大简化代码量</li>
<li>Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理</li>
</ul>
<h3 id="Stream示例"><a href="#Stream示例" class="headerlink" title="Stream示例"></a>Stream示例</h3><pre><code class="java">//获取List集合中最大的偶数
Optional&lt;Integer&gt; op = Arrays.asList(1,2,3,4,5,6).stream()
.filter(x-&gt;x%2==0) //处理完得到一个只包含偶数的list流数据
.sorted((a,b)-&gt;b-a) //大的在前面 小的在后面
.findFirst(); //获取最大的数据
System.out.println(op.get());
</code></pre>
<h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a><span style = "color : red">Stream常用方法</span></h3><table>
<thead>
<tr>
<th>接口</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>循环遍历</td>
</tr>
<tr>
<td>map</td>
<td>map方法用于映射每个元素到对应的结果</td>
</tr>
<tr>
<td>filter</td>
<td>filter方法用于通知设置的条件过滤出元素</td>
</tr>
<tr>
<td>limit</td>
<td>limit方法用于获取指定数量的流</td>
</tr>
<tr>
<td>sorted</td>
<td>sorted方法用于对流进行排序</td>
</tr>
<tr>
<td>Collectors</td>
<td>Collectors类实现将流转换成集合和聚合元素</td>
</tr>
</tbody></table>
<pre><code class="java">StreamGenerator.java
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/*
Stream流对象的五种创建方式
 */
public class StreamGenerator &#123;
    //1.基于数组进行创建
    @Test
    public void generator1()&#123;
        String[] arr = &#123;&quot;Lily&quot;,&quot;Andy&quot;,&quot;Jackson&quot;,&quot;Smith&quot;&#125;;
        Stream&lt;String&gt; stream = Stream.of(arr);
        stream.forEach(s -&gt; System.out.println(s)); //forEach中使用Lambda表达式
    &#125;

    //2.基于集合进行创建
    @Test
    public void generator2()&#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Lily&quot;);
        list.add(&quot;Andy&quot;);
        list.add(&quot;Jackson&quot;);
        list.add(&quot;Smith&quot;);
        Stream&lt;String&gt; stream = list.stream(); //利用集合获取stream
        stream.forEach(s -&gt; System.out.println(s));
    &#125;

    //3.利用generate方法创建无限长度流
    @Test
    public void generator3()&#123;
        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; new Random().nextInt(100000));//Supplier&lt;T&gt; s 创建新对象
        stream.limit(10).forEach(i -&gt; System.out.println(i)); //limit限制长度
    &#125;

    //4.基于迭代器创建流
    @Test
    public void generator4()&#123;
        Stream&lt;Integer&gt; stream = Stream.iterate(1, n -&gt; n + 1);//无限长度自增
        stream.limit(100).forEach(i -&gt; System.out.println(i));
    &#125;

    //5.基于字符序列创建流
    @Test
    public void genetator5()&#123;
        String str = &quot;abcdefg我&quot;;
        IntStream stream = str.chars();
        stream.forEach(c -&gt; System.out.println((char)c));
    &#125;
&#125;
</code></pre>
<pre><code class="java">StreamMethod.java
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamMethod &#123;
    @Test //提取集合中所有偶数并求和
    public void case1()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
        int sum = list.stream() //获取stream对象
                .mapToInt(s -&gt; Integer.parseInt(s)) //对每个元素字符串转为整数
                .filter(n -&gt; n%2==0) //filter对流数据进行过滤
                .sum();//求和
        System.out.println(sum);
    &#125;

    @Test //所有名字首字母大写
    public void case2()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;lily&quot;,&quot;smith&quot;,&quot;jackson&quot;);
        List newList = list.stream()
                .map(s -&gt; s.substring(0, 1).toUpperCase() + s.substring(1)) //首字母大写转换
//                .forEach(s -&gt; System.out.println(s));
                .collect(Collectors.toList()); //collect对流数据进行收集,生成新的List/Set(将重复数据自动清除)
        System.out.println(newList);
    &#125;

    @Test //将所有奇数从大到小进行排序，且不允许出现重复
    public void case3()&#123;
        List&lt;Integer&gt; list = Arrays.asList(1, 60, 38, 21, 51, 60, 51, 73);
        List newList = list.stream().distinct() //去除重复的流数据
                .filter(n -&gt; n%2==1)
                .sorted((a,b) -&gt; b-a) //从大到小的数据排列
                .collect(Collectors.toList());
        System.out.println(newList);
    &#125;
&#125;
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>