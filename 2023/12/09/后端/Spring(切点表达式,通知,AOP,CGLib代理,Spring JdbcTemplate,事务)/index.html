
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Spring</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Spring </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/12/9
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#ff7d73>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><img src="https://raw.githubusercontent.com/P-luminary/images/8fdafeebf37a6ccf8de24be3ce4d857524f07204/data/Spring%E6%A8%A1%E5%9D%97.png" style="zoom: 200%;" />

<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring框架介绍</td>
<td>Spring IoC、DI和AOP等核心概念</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Spring IoC容器</td>
<td>Spring实例化与管理对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>集合对象注入</td>
<td>注入List、Set、Map集合对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>底层原理</td>
<td>Spring Bean的生命周期</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>注解与Java Config</td>
<td>Spring注解分类和常用注解应用</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h6 id="不修改源代码的程序扩展"><a href="#不修改源代码的程序扩展" class="headerlink" title="不修改源代码的程序扩展"></a>不修改源代码的程序扩展</h6><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>理解AOP及名词</td>
<td>Spring AOP开发与配置流程</td>
<td>★★★★★★(面试)</td>
</tr>
<tr>
<td>五种通知类型</td>
<td>Spring五种通知类型与应用场景</td>
<td>★★★</td>
</tr>
<tr>
<td>切点表达式</td>
<td>PointCut切点表达式的语法规则及应用</td>
<td>★★</td>
</tr>
<tr>
<td>代理模式</td>
<td>JDK动态代理和CGLib代理的执行过程</td>
<td>★★★★★★(面试)</td>
</tr>
</tbody></table>
<h3 id="Spring-JDBC与声明式事务"><a href="#Spring-JDBC与声明式事务" class="headerlink" title="Spring JDBC与声明式事务"></a>Spring JDBC与声明式事务</h3><p>JDBC的扩展</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring JDBC</td>
<td>Spring JDBC的环境配置</td>
<td>★★★★</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>基于RestTemplate实现SQL处理</td>
<td>★★★</td>
</tr>
<tr>
<td>配置声明式事务</td>
<td>声明式事务的配置过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>事务传播行为介绍</td>
<td>讲解常用事务传播行为的用途</td>
<td>★★★</td>
</tr>
<tr>
<td>声明式事务注解形式</td>
<td>基于注解使用声明式事务</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h1 id="★★★★★★-Spring-★★★★★★"><a href="#★★★★★★-Spring-★★★★★★" class="headerlink" title="★★★★★★  Spring  ★★★★★★"></a><span style = "color:red">★★★★★★  Spring  ★★★★★★</span></h1><p>IoC容器负责<strong>实例化</strong>，<strong>配置</strong>和<strong>组装</strong>对象。 IoC容器从XML文件获取信息并相应地工作。</p>
<p>IoC容器执行的主要任务是:</p>
<ul>
<li>实例化应用程序类</li>
<li>配置对象</li>
<li>组装对象之间的依赖关系</li>
</ul>
<p>有两种类型的IoC容器</p>
<ul>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ul>
<h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><h6 id="对象的控制权交给第三方进行管理-中间人"><a href="#对象的控制权交给第三方进行管理-中间人" class="headerlink" title="对象的控制权交给第三方进行管理(中间人)"></a>对象的控制权交给第三方进行管理(中间人)</h6><ul>
<li>IoC控制反转，全称Inverse of Control，是一种设计理念</li>
<li>由代理人来创建与管理对象，消费者通过代理人来获取对象</li>
<li>IoC的目的是降低对象之间直接耦合[更好适合对象之间的变化]</li>
<li>加入<strong>IoC容器</strong>将对象统一管理，让对象关联变为弱耦合</li>
</ul>
<p><strong>顾客</strong> ←(快递) <strong>果商冷冻仓库</strong> (批发)→ <strong>苹果</strong></p>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><ul>
<li>IoC是设计理念，是现代程序设计遵循的标准，是宏观目标</li>
<li>DI(Dependency Injection)是具体技术实现，是微观实现</li>
<li>DI在Java中利用<strong>反射</strong>技术实现对象注入(Injection) [不同语言运用不同技术]</li>
</ul>
<h3 id="Spring含义"><a href="#Spring含义" class="headerlink" title="Spring含义"></a>Spring含义</h3><ul>
<li>Spring可以从广义和狭义两个角度看待</li>
<li>广义的Spring是指Spring生态系统</li>
<li>狭义的Spring是指Spring框架(Spring Framework)</li>
</ul>
<h5 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h5><ul>
<li>分布式微服务 SpringCloud</li>
<li>Reactive相应服务</li>
<li>Web apps 是 SpringMVC 中的</li>
<li>Serverless 无服务器内容</li>
<li>Event Driven 和 Batch</li>
<li>Spring Framework     Spring Boot     Spring Cloud     Spring Cloud Data Flow…</li>
</ul>
<h5 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h5><ul>
<li>Spring框架是企业开发复杂性的<strong>一站式</strong>解决方案</li>
<li>Spring框架的核心是<strong>IoC容器</strong>与<strong>AOP面向切面编程</strong></li>
<li>Spring IoC负责创建与管理系统对象，并在此基础上扩展功能(不修改源代码)</li>
</ul>
<h5 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h5><ul>
<li>对象直接引用导致对象硬性关联，程序难以扩展维护 new B new A</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><ul>
<li><p>IoC容器是Spring生态的地基，用于统一创建于管理对象依赖</p>
<p><strong>使用者</strong>直接<strong>提取</strong>Spring IoC容器中的已经将<strong>依赖</strong>ObjectB<strong>注入</strong>到ObjectA 直接提取A</p>
</li>
</ul>
<h5 id="Spring-IoC容器职责-宏观理念"><a href="#Spring-IoC容器职责-宏观理念" class="headerlink" title="Spring IoC容器职责 [宏观理念]"></a>Spring IoC容器职责 [宏观理念]</h5><ul>
<li>对象的控制权交由<strong>第三方</strong>统一管理 <u>(IoC控制反转)</u></li>
<li>利用Java<strong>反射</strong>技术实现<strong>运行时</strong>对象创建与关联 <u>(DI依赖注入)</u> [<strong>技术实现</strong>]</li>
<li>基于配置提高应用程序的可维护性与扩展性</li>
</ul>
<h3 id="Spring-IoC初体验"><a href="#Spring-IoC初体验" class="headerlink" title="Spring IoC初体验"></a>Spring IoC初体验</h3><h6 id="三个小孩吃三种不同的苹果"><a href="#三个小孩吃三种不同的苹果" class="headerlink" title="三个小孩吃三种不同的苹果"></a>三个小孩吃三种不同的苹果</h6><h5 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h5><p><strong>Apple.java</strong></p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;
    Construct(空+满) Getter+Setter
&#125;
</code></pre>
<p><strong>Child.java</strong></p>
<pre><code class="java">public class Child &#123;
    private String name;
    private Apple apple;
    Construct(空+满) Getter+Setter
    public void eat()&#123;
        System.out.println(name + &quot;吃到了&quot; + apple.getOrigin() + &quot;种植的&quot; + apple.getTitle());
    &#125;
&#125;
</code></pre>
<p><strong>Application.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;

public class Application &#123;
    public static void main(String[] args) &#123;
        Apple apple1 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Apple apple2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, &quot;中亚&quot;);
        Apple apple3 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Child lily = new Child(&quot;莉莉&quot;,apple1);
        Child andy = new Child(&quot;安迪&quot;,apple2);
        Child luna = new Child(&quot;露娜&quot;,apple3);
        lily.eat();
        andy.eat();
        luna.eat();
    &#125;
&#125;
</code></pre>
<h5 id="Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理"><a href="#Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理" class="headerlink" title="Spring IoC方式代码[不修改源代码 不用new 引入容器让对象统一管理]"></a><span style = "color:red">Spring IoC方式代码</span>[不修改源代码 不用new 引入容器让对象统一管理]</h5><p><strong>pom.xml</strong></p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p><strong>applicationContext.xml</strong> [静态信息可以放其中]  **<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">SpringIoC核心配置文件 右键resources创建 所有对象的创建以及关联的设置都是在applicationContext.xml这里进行
Spring.io -&gt; Project -&gt; Spring Framework -&gt; LEARN -&gt; Reference Doc. -&gt;  Core

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt; 
并且加入配置Spring[出现在提示页面]

------------------------  更新一次  ------------------------
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--    在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中  --&gt;
     &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sourApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;softApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;沙果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;rdApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;蛇果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;美国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;andy&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;安迪&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;luna&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;露娜&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;rdApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>SpringApplication.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
        //从IoC容器中提取beanId=lily的对象
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        lily.eat();
        Child andy = context.getBean(&quot;andy&quot;, Child.class);
        andy.eat();
        Child luna = context.getBean(&quot;luna&quot;, Child.class);
        luna.eat();
    &#125;
&#125;
————————————————————————————————————————————————————————————————————————————————————
红富士
莉莉吃到了欧洲种植的红富士
安迪吃到了中亚种植的青苹果
露娜吃到了美国种植的蛇果
</code></pre>
<p>利用IoC容器有利于对象与对象之间的<strong>解耦</strong>   springIoC大大提高了程序的维护与延展</p>
<h3 id="XML管理对象-Bean"><a href="#XML管理对象-Bean" class="headerlink" title="XML管理对象(Bean)"></a>XML管理对象(Bean)</h3><ul>
<li>基于XML配置Bean</li>
</ul>
<pre><code class="java">上述的吃苹果例题就是基于xml配置Bean
</code></pre>
<ul>
<li>基于注解配置Bean</li>
<li>基于Java代码配置Bean(java .config)</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
所有都要用bean标签 SpringIoC实例化以后在容器的唯一编号: id=&quot;sweetAppele&quot; SpringIoC就知道创建IoC容器时实例化一个Apple对象同时bean id=&quot;...&quot;
</code></pre>
<h5 id="XML方式创建IoC容器"><a href="#XML方式创建IoC容器" class="headerlink" title="XML方式创建IoC容器"></a>XML方式创建IoC容器</h5><pre><code class="xml">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new 
ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h3 id="实例化Bean的三种方式"><a href="#实例化Bean的三种方式" class="headerlink" title="实例化Bean的三种方式"></a>实例化Bean的三种方式</h3><ul>
<li><span style = "color:red">基于构造方法对象实例化</span> (90%以上)</li>
</ul>
<h6 id="利用构造方法参数名实例化-推荐"><a href="#利用构造方法参数名实例化-推荐" class="headerlink" title="利用构造方法参数名实例化 [推荐]"></a>利用构造方法<span style = "color:red">参数名</span>实例化 [推荐]</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 没有constructor-arg则代表调用默认构造方法实例化 --&gt;
  &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;           
  &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;     
&lt;/bean&gt;
</code></pre>
<p>Apple.java</p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;

    public Apple() &#123;
        System.out.println(&quot;Apple对象已创建,&quot; + this);
    &#125;

    public Apple(String title, String color, String origin) &#123;
        System.out.println(&quot;通过带参构造方法创建对象&quot; + this);
        this.title = title;
        this.color = color;
        this.origin = origin;
    &#125;
    ......
</code></pre>
<p>SpringApplication.java</p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
___________________________________________________________________________
Apple对象已创建,com.imooc.spring.ioc.entity.Apple@39fb3ab6
通过带参构造方法创建对象com.imooc.spring.ioc.entity.Apple@1a968a59
</code></pre>
<h6 id="利用构造方法参数位置实例化"><a href="#利用构造方法参数位置实例化" class="headerlink" title="利用构造方法参数位置实例化"></a>利用构造方法<span style = "color:red">参数位置</span>实例化</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
  &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
  &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li><h3 id="基于静态工厂实例化-在IoC容器之外通过程序组织对象"><a href="#基于静态工厂实例化-在IoC容器之外通过程序组织对象" class="headerlink" title="基于静态工厂实例化 (在IoC容器之外通过程序组织对象)"></a>基于静态工厂实例化 (在IoC容器之外通过程序组织对象)</h3></li>
</ul>
<pre><code class="java">AppleStaticFactory.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

public class AppleStaticFactory &#123;
    public static Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用静态工厂获取对象--&gt;
    &lt;bean id=&quot;apple4&quot; class=&quot;com.imooc.spring.ioc.factory.AppleStaticFactory&quot;
          factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<pre><code class="java">&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">A.java
package com.nhooo;
public class A &#123;
private static final A obj=new A();
private A()&#123;System.out.println(&quot;private constructor&quot;);&#125;
public static A getA()&#123;
    System.out.println(&quot;factory method &quot;);
    return obj;
&#125;
public void msg()&#123;
    System.out.println(&quot;hello user&quot;);
&#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Test.java
package org.sssit;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test &#123;
public static void main(String[] args) &#123;
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    A a=(A)context.getBean(&quot;a&quot;);
    a.msg();
&#125;
&#125;
=============================================================
private constructor
factory method
hello user
</code></pre>
<ul>
<li><h3 id="基于工厂实例方法实例化"><a href="#基于工厂实例方法实例化" class="headerlink" title="基于工厂实例方法实例化"></a>基于工厂实例方法实例化</h3></li>
</ul>
<pre><code class="java">AppleFactoryInstance.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

/**
 * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程
 */
public class AppleFactoryInstance &#123;
    public Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用工厂实例方法获取对象--&gt;
    &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.imooc.spring.ioc.factory.AppleFactoryInstance&quot;/&gt;
    &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="从IoC容器获取bean"><a href="#从IoC容器获取bean" class="headerlink" title="从IoC容器获取bean"></a>从IoC容器获取bean</h3><pre><code class="java">Apple sweetApple = context.getBean(&quot;sweetApple&quot;,Apple.class); 【推荐】
                    或者
Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);
-------------------------------------------------------------
System.out.println(sweetApple.getTitle());
</code></pre>
<pre><code class="java">public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple apple4 = context.getBean(&quot;apple4&quot;, Apple.class); 【推荐】
        System.out.println(apple4.getTitle());
        
        Apple apple3 = (Apple)context.getBean(&quot;apple3&quot;);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
</code></pre>
<h5 id="id与name属性相同点"><a href="#id与name属性相同点" class="headerlink" title="id与name属性相同点"></a>id与name属性相同点</h5><ul>
<li>bean id 与 name 都是设置对象在IoC容器中唯一标识</li>
</ul>
<pre><code class="java">&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;bean name=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
</code></pre>
<ul>
<li>两者在同一个配置文件中都不允许出现重复</li>
<li>两者允许在多个配置文件中出现重复，新对象覆盖旧对象</li>
<li><span style = "color:red"><strong>id要求更为严格，一次只能定义一个对象标识</strong></span> 【推荐】</li>
<li><span style = "color:red"><strong>name更为宽松，一次允许定义多个对象标识</strong></span> </li>
<li>tips: id与name的命名要求有意义，按驼峰命名书写</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg index=&quot;3&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">applicationContext-1.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
 &lt;bean id=&quot;apple2&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士2号&quot;/&gt;
        &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple apple2 = context.getBean(&quot;apple2&quot;,Apple.class);
        System.out.println(apple2.getTitle());
        Apple apple3 = context.getBean(&quot;apple3&quot;,Apple.class);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
______________________________________________________________________
红富士2号
红富士
</code></pre>
<blockquote>
<p>&lt; bean name &#x3D; “apple2, apple7”  class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt;<br>如果使用name(不使用id)可以在后面增加标识名<br>在没有id与name的bean默认使用类名全称作为bean标识<br>&lt; bean class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt; </p>
</blockquote>
<h3 id="路径匹配表达式"><a href="#路径匹配表达式" class="headerlink" title="路径匹配表达式"></a>路径匹配表达式</h3><h5 id="加载单个配置文件"><a href="#加载单个配置文件" class="headerlink" title="加载单个配置文件"></a>加载单个配置文件</h5><pre><code class="java">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h5 id="加载多配置文件"><a href="#加载多配置文件" class="headerlink" title="加载多配置文件"></a>加载多配置文件</h5><pre><code class="java">String[] configLocations = new String[]&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;&#125;;
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
</code></pre>
<h5 id="路径表达式-config-xml-x3D-ApplicationContext-xml"><a href="#路径表达式-config-xml-x3D-ApplicationContext-xml" class="headerlink" title="路径表达式 (config.xml &#x3D; ApplicationContext.xml)"></a>路径表达式 (config.xml &#x3D; ApplicationContext.xml)</h5><table>
<thead>
<tr>
<th>表达式实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:config.xml</td>
<td>扫描classpath根路径(不包含jar)的config.xml</td>
</tr>
<tr>
<td>classpath:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(不包含jar)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath*:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(<strong>包含jar</strong>)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath:config-*.xml</td>
<td>扫描classpath根路径下所有以config-开头的XML文件</td>
</tr>
<tr>
<td>classpath:com&#x2F;**&#x2F;config.xml</td>
<td>扫描com包下(包含任何子包)的config.xml</td>
</tr>
<tr>
<td>file:c:&#x2F;config.xml</td>
<td>扫描c盘根路径config.xml</td>
</tr>
</tbody></table>
<h3 id="对象依赖注入"><a href="#对象依赖注入" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h3><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style = "color:red"><strong>基于setter方法注入对象</strong></span></li>
</ul>
<h6 id="利用setter实现静态数值注入"><a href="#利用setter实现静态数值注入" class="headerlink" title="利用setter实现静态数值注入"></a>利用setter实现静态数值注入</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- IoC容器自动利用反射机制运行时调用setXXX方法为属性赋值 --&gt;
    &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
    &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
    &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="利用setter实现对象注入-【核心操作-ref-x3D-””】"><a href="#利用setter实现对象注入-【核心操作-ref-x3D-””】" class="headerlink" title="利用setter实现对象注入 【核心操作 ref&#x3D;””】"></a>利用setter实现对象注入 【<u>核心操作 ref&#x3D;””</u>】</h6><p>**<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">&lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
    &lt;!-- 利用ref注入依赖对象 --&gt;
    &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">Child.java   #创建好的apple对象赋予給参数进入setApple
public void setApple(Apple apple) &#123;
     System.out.println(&quot;注入的Apple对象：&quot; + apple);
     this.apple = apple;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
    &#125;
&#125;
</code></pre>
<h3 id="体验依赖注入的优势-高效解耦"><a href="#体验依赖注入的优势-高效解耦" class="headerlink" title="体验依赖注入的优势 (高效解耦)"></a>体验依赖注入的优势 (高效解耦)</h3><pre><code class="xml">applicatioinContext-dao.xml    #用于数据库的增删改查
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoImpl&quot;&gt;
//如果更改了数据库类型 只需要重新创建一个java实现接口BookDao的insert 之后只需更改class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">applicatioinContext-service.xml 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.imooc.spring.ioc.bookshop.service.BookService&quot;&gt;
&lt;!--        id=bookDao     --&gt;
       &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">BookDao.java
package com.imooc.spring.ioc.bookshop.dao;

public interface BookDao &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">BookDaoImpl.java
package com.imooc.spring.ioc.bookshop.dao;

public class BookDaoImpl implements BookDao&#123;
    @Override
    public void insert() &#123;
        System.out.println(&quot;向mysql book表插入数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookService.java
package com.imooc.spring.ioc.bookshop.service;

import com.imooc.spring.ioc.bookshop.dao.BookDao;

public class BookService &#123;
    private BookDao bookDao; //接口将在ioc启动的时候动态注入
    public void purchase()&#123;
        System.out.println(&quot;正在执行图书采购业务方法&quot;);
        bookDao.insert();
    &#125;
    public BookDao getBookDao()&#123;
        return bookDao;
    &#125;
    public void setBookDao(BookDao bookDao)&#123;
        this.bookDao = bookDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookShopApplication.java
package com.imooc.spring.ioc.bookshop;

import com.imooc.spring.ioc.bookshop.service.BookService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BookShopApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class);
        bookService.purchase();
    &#125;
&#125;
</code></pre>
<h3 id="利用构造方法实现对象依赖注入"><a href="#利用构造方法实现对象依赖注入" class="headerlink" title="利用构造方法实现对象依赖注入"></a>利用构造方法实现对象依赖注入</h3><h5 id="对象依赖注入-1"><a href="#对象依赖注入-1" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h5><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style="color:red"><strong>基于setter方法注入对象</strong></span></li>
<li>基于构造方法注入对象</li>
</ul>
<pre><code class="java">【com.imooc.spring.ioc.entity】
Child.java + Apple.java 

Apple.java中可以加一个
public void apple()&#123;
        System.out.println(origin+&quot;国家&quot; +color+&quot;的&quot;+title+&quot;食物&quot;);
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.Apple.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;/&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.Apple.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">package com.imooc.Apple;

import com.imooc.Apple.entity.Apple;
import com.imooc.Apple.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        // 添加打印语句，检查属性是否正确注入
        System.out.println(&quot;lily&#39;s name: &quot; + lily.getName());
        System.out.println(&quot;lily&#39;s apple origin: &quot; + lily.getApple().getOrigin());
        System.out.println(&quot;lily&#39;s apple title: &quot; + lily.getApple().getTitle());
        System.out.println(&quot;====================================&quot;);
//        System.out.println(sweetApple.getTitle()+sweetApple.getColor()+sweetApple.getOrigin());
        lily.eat();
        sweetApple.apple();
    &#125;
&#125;
</code></pre>
<h3 id="注入集合对象-1"><a href="#注入集合对象-1" class="headerlink" title="注入集合对象_1"></a>注入集合对象_1</h3><h5 id="注入List-允许重复数据"><a href="#注入List-允许重复数据" class="headerlink" title="注入List [允许重复数据]"></a>注入List [允许重复数据]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someList&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;具体值&lt;/value&gt;
        &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Set-不允许重复数据-自动去除重复"><a href="#注入Set-不允许重复数据-自动去除重复" class="headerlink" title="注入Set  [不允许重复数据 自动去除重复]"></a>注入Set  [不允许重复数据 自动去除重复]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someSet&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;具体值&lt;/value&gt;
      &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someMap&quot;&gt;
    &lt;Map&gt;
        &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&gt;&lt;/entry&gt; #静态数值
      &lt;entry key=&quot;k2&quot; value-ref=&quot;beanId&quot;&gt;&lt;/entry&gt; #对象引用
    &lt;/Map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Properties"><a href="#注入Properties" class="headerlink" title="注入Properties"></a>注入Properties</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someProperties&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;
      &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;
    &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="公司资产配置清单-小案例"><a href="#公司资产配置清单-小案例" class="headerlink" title="公司资产配置清单[小案例]"></a>公司资产配置清单[小案例]</h3><p><strong>constructor-arg：通过 构造函数注入 。</strong></p>
<p><strong>property：通过 setter对应的方法注入</strong> 。</p>
<pre><code class="java">Company.java
package com.imooc.spring.ioc.entity;

import java.util.List;
import java.util.Map;
import java.util.Properties;

public class Company &#123;
    private List&lt;String&gt; rooms;
    private Map&lt;String,Computer&gt; computers; //每一条数据保存的都是Computer型
    private Properties info;//键值对的写

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;rooms=&quot; + rooms +
                &quot;, computers=&quot; + computers +
                &quot;, info=&quot; + info +
                &#39;&#125;&#39;;
    &#125;
    + Getter Setter
&#125;
</code></pre>
<pre><code class="java">Computer.java
public class Computer &#123;
    private String brand;
    private String type;
    private String sn;
    private Float price;
    constructor(空+满)+Getter Setter
&#125;
</code></pre>
<p>如何在ioc容器创建后自动的实例化Company对象并且填充信息呢?<br>所有的工作都在<code>applicationContext.xml</code>中进行的</p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;list&gt; //【允许重复】
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Company;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Company company = context.getBean(&quot;company&quot;, Company.class);
        System.out.println(company);
    &#125;
&#125;
------------------------------------------------------------
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=null, info=null&#125;

Process finished with exit code 0
------------------------------------------------------------
下方xml更新后的显示数据：
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=&#123;dev-88172=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;, dev-88173=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;&#125;, info=&#123;phone=010-12345678, address=北京市朝阳区XX路XX大厦, website=https://p-luminary.github.io&#125;&#125;
https://p-luminary.github.io

Process finished with exit code 0
</code></pre>
<p>list的底层是ArrayList<br>Set的底层是LinkedHashSet [双向有序列表]<br>Map的底层是LinkedHashMap [双向列表 提取也是存放顺序]</p>
<pre><code class="xml">applicationContext.xml [更新一次]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;

或者【简便方法】↓
</code></pre>
<pre><code class="xml">applicationContext.xml 更新二次【新增简便方法】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;【方法一】
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
                &lt;entry key=&quot;dev-88173&quot;&gt;【方法二 (推荐)】
                    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
                        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
                        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
                        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
                        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;phone&quot;&gt;010-12345678&lt;/prop&gt;
                &lt;prop key=&quot;address&quot;&gt;北京市朝阳区XX路XX大厦&lt;/prop&gt;
                &lt;prop key=&quot;website&quot;&gt;https://p-luminary.github.io&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/43856e9419b6b12dba03ffb97458b89e4dd7ec1e/data/constructor%E4%B8%8Eproperty%E5%8C%BA%E5%88%AB.jpg"></p>
<h3 id="查看容器内对象-【-getBeanDefinitionNames-】"><a href="#查看容器内对象-【-getBeanDefinitionNames-】" class="headerlink" title="查看容器内对象 【.getBeanDefinitionNames()】"></a>查看容器内对象 【.getBeanDefinitionNames()】</h3><pre><code class="java">多个同类型的bean会自动增加编号 #1  #2
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;微星&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3000&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;华硕&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;9023283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;5600&quot;/&gt;
    &lt;/bean&gt;

//获取容器内所有beanId数组       
        String[] beanNames = context.getBeanDefinitionNames();
        for (String beanName:beanNames)&#123;
            System.out.println(beanName); //c1 company ...&lt;bean id=&quot;...&quot;&gt;
             System.out.println(&quot;类型：&quot; + context.getBean(beanName).getClass().getName());
            System.out.println(&quot;内容：&quot; + context.getBean(beanName).toString());
        &#125;
        Computer computer = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer&quot;, Computer.class);
        System.out.println(computer.getBrand());
        Computer computer1 = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer#1&quot;, Computer.class);
        System.out.println(computer1.getBrand());
</code></pre>
<h3 id="bean-scope属性"><a href="#bean-scope属性" class="headerlink" title="bean scope属性"></a>bean scope属性</h3><ul>
<li>bean scope属性用于决定对象何时被创建与作用范围</li>
<li>bean scope配置将影响容器内对象的数量</li>
<li>bean scope默认值singleton(单例), 指全局共享同一个对象实例</li>
</ul>
<h5 id="scope用法"><a href="#scope用法" class="headerlink" title="scope用法"></a>scope用法</h5><pre><code class="java">&lt;bean id=&quot;bookDao&quot;
    class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    scope=&quot;prototype&quot;/&gt;
</code></pre>
<h5 id="bean-scope属性清单"><a href="#bean-scope属性清单" class="headerlink" title="bean scope属性清单"></a>bean scope属性清单</h5><table>
<thead>
<tr>
<th>scope属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style = "color:red">singleton</span></td>
<td><span style = "color:red">单例(默认值),每一个容器有且只有唯一的实例,实例被全局共享</span></td>
</tr>
<tr>
<td><span style = "color:red">prototype</span></td>
<td><span style = "color:red">多例,每次使用时都是创建一个实例</span></td>
</tr>
<tr>
<td>request</td>
<td>web环境下,每一个独立请求存在唯一实例</td>
</tr>
<tr>
<td>session</td>
<td>web环境下,每一个session存在有唯一实例</td>
</tr>
<tr>
<td>application</td>
<td>web环境下,ServletContext存在唯一实例</td>
</tr>
<tr>
<td>websocket</td>
<td>每一次WebSocket连接中存在唯一实例</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/59d168487d0ef9aa2a23cf8057d454e1d3f26fc9/data/singleton%E4%B8%8Eprototype%E6%AF%94%E8%BE%83%E5%9B%BE.png"></p>
<h5 id="singleton与prototype对比"><a href="#singleton与prototype对比" class="headerlink" title="singleton与prototype对比"></a>singleton与prototype对比</h5><table>
<thead>
<tr>
<th></th>
<th>singleton</th>
<th>prototype</th>
</tr>
</thead>
<tbody><tr>
<td>对象数量</td>
<td>全局唯一</td>
<td>存在多个</td>
</tr>
<tr>
<td>实例化时机</td>
<td>IoC容器启动时</td>
<td>getBean() 或 对象注入时</td>
</tr>
<tr>
<td>线程安全问题</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>执行效率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public UserDao()&#123;
        System.out.println(&quot;UserDao已创建: &quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    public UserDao userDao;

    public UserService() &#123;
        System.out.println(&quot;UserService已创建: &quot; + this);
    &#125;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        System.out.println(&quot;调用setUserDao: &quot; + userDao);
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java 【单例】

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao1 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao2 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao3 = context.getBean(&quot;userDao&quot;, UserDao.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; &gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出：
UserService已创建: com.imooc.spring.ioc.service.UserService@3dd3bcd
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@7c16905e
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@7c16905e
    
Process finished with exit code 0
</code></pre>
<pre><code class="java">SpringApplication.java 【多例】
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;IoC容器已初始化&quot;);
        UserService userService1 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService2 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService3 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService4 = context.getBean(&quot;userService&quot;, UserService.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出:
IoC容器已初始化
UserService已创建: com.imooc.spring.ioc.service.UserService@5c7fa833
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
UserService已创建: com.imooc.spring.ioc.service.UserService@4b952a2d
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@3159c4b8
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@3159c4b8
UserService已创建: com.imooc.spring.ioc.service.UserService@73846619
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
UserService已创建: com.imooc.spring.ioc.service.UserService@29ca901e
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@5649fd9b
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@5649fd9b

Process finished with exit code 0
</code></pre>
<p><span style = "color : red">一般来说dao类 service类 control类都是单例 因为单例安全根源是运行时发生不断的变化 如果在真正环境中一般不会重新设置那些类，在运行中都是恒定不变的。所以推荐用单例默认<code>singleton</code></span></p>
<h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cbffd1149ca0b5b1b860325d72941880b7ca7fc4/data/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<pre><code class="java">Order.java
package com.imooc.spring.ioc.entity;

public class Order &#123;
    private Float price;
    private Integer quantity;
    private Float total;

    public Order() &#123;
        System.out.println(&quot;创建Order对象&quot; + this);
    &#125;

    public void init()&#123;
        System.out.println(&quot;执行init()方法&quot;);
        total = price * quantity;
    &#125;
    public void pay()&#123;
        System.out.println(&quot;订单金额为：&quot; + total);
    &#125;

    public Float getPrice() &#123;
        return price;
    &#125;

    public void setPrice(Float price) &#123;
        System.out.println(&quot;设置price：&quot; + price);
        this.price = price;
    &#125;

    public Integer getQuantity() &#123;
        return quantity;
    &#125;

    public void setQuantity(Integer quantity) &#123;
        System.out.println(&quot;设置quantity：&quot; + quantity);
        this.quantity = quantity;
    &#125;

    public Float getTotal() &#123;
        return total;
    &#125;

    public void setTotal(Float total) &#123;
        this.total = total;
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;释放与订单对象相关的资源&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;order1&quot; class=&quot;com.imooc.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;======IoC容器已初始化======&quot;);
        Order order1 = context.getBean(&quot;order1&quot;,Order.class);
        order1.pay();
        ((ClassPathXmlApplicationContext)context).registerShutdownHook(); //销毁容器 自动调用bean中设置的destory方法
    &#125;
&#125;

==========================================
创建Order对象com.imooc.spring.ioc.entity.Order@153f5a29
设置price：19.8
设置quantity：1000
执行init()方法
======IoC容器已初始化======
订单金额为：19800.0
释放与订单对象相关的资源

Process finished with exit code 0
</code></pre>
<h3 id="实现极简IoC容器-利用反射机制完成对象的创建和注入"><a href="#实现极简IoC容器-利用反射机制完成对象的创建和注入" class="headerlink" title="实现极简IoC容器 [利用反射机制完成对象的创建和注入]"></a>实现极简IoC容器 [利用反射机制完成对象的创建和注入]</h3><pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        Dom4j是Java的XML解析组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;
            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        jaxen是Xpath表达式解释器--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jaxen&lt;/groupId&gt;
            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
            &lt;version&gt;1.1.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">Apple.java
public class Apple &#123;
    private String title;
    private String color;
    private String origin;
&#125; + Getter Setter
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans&gt;
    &lt;bean id = &quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.context.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; //这里的title是在setter中 public void setTitle(String title)&#123;this.title=title;&#125;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ApplicationContext.java[接口]
package com.imooc.spring.ioc.context;

public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">ClassPathXmlApplicationContext.java
package com.imooc.spring.ioc.context;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext&#123;
    private Map iocContainer = new HashMap();
    public ClassPathXmlApplicationContext()&#123;
        try &#123;
            String filePath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            filePath = new URLDecoder().decode(filePath,&quot;UTF-8&quot;);
            SAXReader reader = new SAXReader();
            Document document = reader.read(new File(filePath));
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);//得到节点的集合
            for (Node node:beans)&#123;
                Element ele = (Element) node;
                String id = ele.attributeValue(&quot;id&quot;);
                String className = ele.attributeValue(&quot;class&quot;);
                Class c = Class.forName(className);//加载指定类
                Object obj = c.newInstance();
                List&lt;Node&gt; properties = ele.selectNodes(&quot;property&quot;);
                for (Node p:properties)&#123;
                    Element property = (Element) p;
                    String propName = property.attributeValue(&quot;name&quot;);
                    String propValue= property.attributeValue(&quot;value&quot;);
//基于property完成注入是通过Setter的set方法，set方法命名的格式为setTitle 属性名第一个字母有个大写
                    String setMethodName = &quot;set&quot; + propName.substring(0,1).toUpperCase()+propName.substring(1);
                    System.out.println(&quot;准备执行&quot; + setMethodName + &quot;方法注入数据&quot;);
                    Method setMethod = c.getMethod(setMethodName, String.class);
                    setMethod.invoke(obj, propValue); //执行哪个对象的实例方法
                &#125;
                iocContainer.put(id,obj); //赋予了bean id
            &#125;
            System.out.println(iocContainer);
            System.out.println(&quot;IoC容器初始化完毕&quot;);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    @Override
    public Object getBean(String beanId) &#123;
        return iocContainer.get(beanId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Application.java
package com.imooc.spring.ioc.context;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Apple apple = (Apple) context.getBean(&quot;sweetApple&quot;);
        System.out.println(apple);
    &#125;
&#125;

=================================================
准备执行setTitle方法注入数据
准备执行setColor方法注入数据
准备执行setOrigin方法注入数据
&#123;sweetApple=com.imooc.spring.ioc.context.Apple@484b61fc&#125;
IoC容器初始化完毕
com.imooc.spring.ioc.context.Apple@484b61fc

Process finished with exit code 0
</code></pre>
<h3 id="四种组件类型注解"><a href="#四种组件类型注解" class="headerlink" title="四种组件类型注解"></a>四种组件类型注解</h3><h5 id="基于注解配置IoC容器"><a href="#基于注解配置IoC容器" class="headerlink" title="基于注解配置IoC容器"></a>基于注解配置IoC容器</h5><h6 id="基于注解的优势"><a href="#基于注解的优势" class="headerlink" title="基于注解的优势"></a>基于注解的优势</h6><ul>
<li>摆脱繁琐的XML形式的bean与依赖注入配置</li>
<li>基于”声明式”的原则,更适合轻量级的现代企业应用</li>
<li>让代码可读性变得更好,研发人员拥有更好的开发体验</li>
</ul>
<h5 id="三类注解"><a href="#三类注解" class="headerlink" title="三类注解"></a><span style = "color:red">三类注解</span></h5><ul>
<li>四种组件类型注解-声明当前类的功能与职责</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<p>   <strong>开启组件扫描</strong></p>
<pre><code class="xml">XML配置开启组件扫描,才能使用注解
&lt;context:component-scan base-package=&quot;com.imooc&quot;&gt;
   &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;com.imooc.exl.*&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<ul>
<li>自动装配注解-根据属性特征自动注入对象</li>
<li>元数据注解-更细化的辅助IoC容器管理对象的注解</li>
</ul>
<h3 id="基于注解初始化IoC容器"><a href="#基于注解初始化IoC容器" class="headerlink" title="基于注解初始化IoC容器"></a>基于注解初始化IoC容器</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Core Technologies (spring.io)</a></p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt; //设置基准的包名去扫描

&lt;/beans&gt;
</code></pre>
<pre><code class="java">controller/UserController.java
package com.imooc.spring.ioc.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao &#123;

&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;

&#125;
</code></pre>
<pre><code class="java">utils/StringUtils.java
package com.imooc.spring.ioc.utils;

import org.springframework.stereotype.Component;

@Component
public class StringUtils &#123;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123; //这些bean在容器中是单例，在初始化的时候创建对象
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
==============================================================
//组件类型解释默认beanId为类名首字母小写
userController:com.imooc.spring.ioc.controller.UserController@4f51b3e0
userDao:com.imooc.spring.ioc.dao.UserDao@4b9e255
userService:com.imooc.spring.ioc.service.UserService@5e57643e
stringUtils:com.imooc.spring.ioc.utils.StringUtils@133e16fd
    
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@51b279c9
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@1ad282e0
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7f416310
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@1cab0bfb
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@5e955596

Process finished with exit code 0
</code></pre>
<h3 id="自动装配与Autowired注解"><a href="#自动装配与Autowired注解" class="headerlink" title="自动装配与Autowired注解"></a>自动装配与Autowired注解</h3><h5 id="两类自动装配注解-Primary-如果有两个写此注解作为主要"><a href="#两类自动装配注解-Primary-如果有两个写此注解作为主要" class="headerlink" title="两类自动装配注解  [@Primary 如果有两个写此注解作为主要]"></a>两类自动装配注解  [@Primary 如果有两个写此注解作为主要]</h5><table>
<thead>
<tr>
<th>分类</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按类型装配</td>
<td>@Autowired</td>
<td>按容器内对象类型动态注入属性,由Spring机构提供</td>
</tr>
<tr>
<td></td>
<td>@Inject</td>
<td>基于JSR-330标准,其他同@Autowired,但不支持required属性</td>
</tr>
<tr>
<td>按名称装配</td>
<td>@Named</td>
<td>与@Inject配合使用,JSR-330规范,按属性名自动装配属性</td>
</tr>
<tr>
<td></td>
<td><span style = "color:red">@Resource</span></td>
<td><span style = "color:red">基于JSR-250规范,优先按名称，再按类型智能匹配</span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>这是默认的自动装配模式，意味着默认情况下没有自动装配</td>
</tr>
<tr>
<td>byName</td>
<td>byName模式根据bean的名称注入对象依赖项。在这种情况属性名称和bean名称必须相同，它在内部调用setter方法</td>
</tr>
<tr>
<td>byType</td>
<td>byType模式根据类型注入对象依赖项，因此属性名称和bean名称可以不同，它在内部调用setter方法</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数模式通过调用类的构造函数来注入依赖项。它会调用具有大量参数的构造函数。</td>
</tr>
<tr>
<td>autodetect</td>
<td>从Spring 3开始不推荐使用</td>
</tr>
</tbody></table>
<h5 id="无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】"><a href="#无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】" class="headerlink" title="无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】"></a>无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】</h5><pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao implements IUserDao&#123;
    public UserDao()&#123;
        System.out.println(&quot;正在创建UseDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserOracleDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;
@Repository
@Primary
public class UserOracleDao implements IUserDao&#123;

    public UserOracleDao()&#123;
        System.out.println(&quot;正在创建UserOracleDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">IUserDao.java [接口]
package com.imooc.spring.ioc.dao;

public interface IUserDao &#123;
&#125;
</code></pre>
<pre><code class="java">DepartmentService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service
public class DepartmentService &#123;
    /**
     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入
     * 2. @Resource未设置name属性
     *  2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配则注入
     *  2.2 按属性名未匹配，则按类型进行匹配，同 @Autowired 需要加入 @Primary解决类型冲突
     *  使用建议: 在使用 @Resource对象时推荐设置name或保证属性名与bean名称一致
     */
    /*方法2.2.1
    @Resource(name = &quot;userOracleDao&quot;)
    private IUserDao udao;*/

    //方法2.2.2
    @Resource
    private IUserDao userOracleDao;
    public void joinDepartment()&#123;
        System.out.println(userOracleDao);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;
    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    private IUserDao udao;

    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java 
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
        DepartmentService departmentService = context.getBean(&quot;departmentService&quot;, DepartmentService.class);
        departmentService.joinDepartment();
    &#125;
&#125;
</code></pre>
<h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a>元数据注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Primary</td>
<td>按类型装配时出现多个相同类型对象,拥有此注解对象优先被注入</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>描述方法,相当于XML中init-method配置的注解版本</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>描述方法,相当于XML中destory-method配置的注解版本</td>
</tr>
<tr>
<td>@Scope</td>
<td>设置对象的scope属性  &#x2F;&#x2F;@Scope(“prototype”)设置多例</td>
</tr>
<tr>
<td>@Value</td>
<td>为属性注入静态数据</td>
</tr>
</tbody></table>
<pre><code class="java">applicationContext.xml 【新增第11行】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--    加载指定路径下的properties文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">config.properties [这里属于动态注入噢~]
  metaData=imooc.com
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

@Service
@(&quot;prototype&quot;) //设置多例 与XML中bean scope完全相同
public class UserService &#123;
    @Value(&quot;$&#123;metaData&#125;&quot;)
    private String metaData; //对此数据的动态注入

    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    @PostConstruct //XML中bean init-method完全相同
    public void init()&#123;
        System.out.println(&quot;初始化UserService对象,metaData=&quot; + metaData);
    &#125;
    private IUserDao udao;


    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
    &#125;
&#125;
</code></pre>
<h3 id="基于Java-Config配置IoC容器"><a href="#基于Java-Config配置IoC容器" class="headerlink" title="基于Java Config配置IoC容器"></a>基于Java Config配置IoC容器</h3><ul>
<li>完全摆脱XML的束缚, 使用独立Java类管理对象与依赖</li>
<li>注解配置相对分散, 利用Java Config可对配置集中管理</li>
<li>可以在编译时进行依赖检查, 不容易出错</li>
</ul>
<h5 id="Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目"><a href="#Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目" class="headerlink" title="Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目"></a>Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Configuration</strong></td>
<td>描述类, 说明当前类是Java Config配置类, 完全替代XML文件</td>
</tr>
<tr>
<td>@<strong>Bean</strong></td>
<td>描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名</td>
</tr>
<tr>
<td>@ImportResource</td>
<td>描述类, 加载静态文件, 可使用@Value注解获取</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>描述类, 同XML的 &lt; context:compoment-scan &gt;标签</td>
</tr>
</tbody></table>
<pre><code class="java">UserController.java
package com.imooc.spring.ioc.controller;

import com.imooc.spring.ioc.service.UserService;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    private UserService userService;

    public UserService getUserService() &#123;
        return userService;
    &#125;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Config.java [作为配置文件]
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        return userDao;
    &#125;
    @Bean
    public UserService userService()&#123;
        UserService userService = new UserService();
        return userService;
    &#125;
    @Bean
    public UserController userController()&#123;
        UserController userController = new UserController();
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
=======================================================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@4f9a3314
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@3b2c72c2
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@491666ad
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@176d53b2
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@971d0d8
config:com.imooc.Config.Config$$EnhancerBySpringCGLIB$$c932e406@51931956
userDao:com.imooc.Config.UserDao@2b4a2ec7
userService:com.imooc.Config.UserService@564718df
userController:com.imooc.Config.UserController@51b7e5df
</code></pre>
<h3 id="JavaConfig-对象依赖注入"><a href="#JavaConfig-对象依赖注入" class="headerlink" title="JavaConfig-对象依赖注入"></a>JavaConfig-对象依赖注入</h3><p>Config的括号增加参数</p>
<pre><code class="java">Config.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
@ComponentScan(basePackages = &quot;com.imooc&quot;) //扫描其他的组件类 因为其他人也会写
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        System.out.println(&quot;已创建&quot;+userDao);
        return userDao;
    &#125;
    @Bean
    //先按name尝试注入,name不存在则按类型注入 冲突则@Primary
    public UserService userService(UserDao userDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        return userService;
    &#125;
    @Bean //&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt;
    public UserController userController(UserService userService)&#123;
        UserController userController = new UserController();
        System.out.println(&quot;已创建&quot; + userController);
        userController.setUserService(userService);
        System.out.println(&quot;调用setUserService:&quot;+userService);
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        System.out.println(&quot;=============================&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;

=================================================================
已创建com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.service.UserService@473b46c3
调用setUserDao:com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.controller.UserController@797badd3
调用setUserService:com.imooc.spring.ioc.service.UserService@473b46c3
=============================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@44a664f2
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@7f9fcf7f
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@2357d90a
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@6328d34a
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@145eaa29
config:com.imooc.spring.ioc.Config$$EnhancerBySpringCGLIB$$8a99aa4c@15bb6bea
userDao:com.imooc.spring.ioc.dao.UserDao@10b48321
userService:com.imooc.spring.ioc.service.UserService@473b46c3
userController:com.imooc.spring.ioc.controller.UserController@797badd3

Process finished with exit code 0
</code></pre>
<pre><code class="java">如果突然想增加一个注入employeeDao
UserService.java 先增加一个私有的名字 再getter+setter
去Conifg.java 括号里新增
public UserService userService(UserDao userDao, EmployeeDao employeeDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        userService.setEmployeeDao(employeeDao);
        return userService;
    &#125;
</code></pre>
<h3 id="Spring-Test测试模块"><a href="#Spring-Test测试模块" class="headerlink" title="Spring Test测试模块"></a>Spring Test测试模块</h3><ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可在Junit单元测试时自动初始化IoC容器</li>
</ul>
<h5 id="Spring与JUnit4整合过程"><a href="#Spring与JUnit4整合过程" class="headerlink" title="Spring与JUnit4整合过程"></a>Spring与JUnit4整合过程</h5><ul>
<li>Maven工程依赖spring-test</li>
<li>利用 <strong>@RunWith</strong> 与 <strong>@ContextConfiguration</strong>描述测试用例类</li>
<li>测试用例类从容器获取对象完成测试用例的执行</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
        &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;
    public void createUser()&#123;
        System.out.println(&quot;调用创建用户业务代码&quot;);
        userDao.insert();
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot;&gt;

    &lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringTestor.java
import com.imooc.spring.ioc.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//将Junit4的执行权交给Spring Test,在测试用例执行前自动初始化IoC容器
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class SpringTestor &#123;
    @Resource
    private UserService userService;

    @Test
    public void testUserService()&#123;
        userService.createUser();
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="介绍AOP"><a href="#介绍AOP" class="headerlink" title="介绍AOP"></a>介绍AOP</h3><p><strong>Aspect Oriented Programming</strong>(AOP)从某种意义上说是对OOP的补充，因为它还提供了模块化的功能。但是模块化的关键单元是方面而不是类。</p>
<h5 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h5><ul>
<li>介绍Spring AOP与相关概念名词</li>
<li>Spring AOP开发与配置流程</li>
<li>Spring 五种通知类型与应用场景</li>
</ul>
<h5 id="Spring中的可插拔组件技术-类似于插件"><a href="#Spring中的可插拔组件技术-类似于插件" class="headerlink" title="Spring中的可插拔组件技术 [类似于插件]"></a>Spring中的可插拔组件技术 [类似于插件]</h5><p>应用程序执行前检测的作用</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/63abc993304f86f346667a404430e2ad28f989cb/data/Spring%E4%B8%AD%E7%9A%84%E5%8F%AF%E6%8F%92%E6%8B%94%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF.jpg"></p>
<h5 id="Spring-AOP-在不修改源码的情况下对程序进行扩展"><a href="#Spring-AOP-在不修改源码的情况下对程序进行扩展" class="headerlink" title="Spring AOP [在不修改源码的情况下对程序进行扩展]"></a>Spring AOP [在不修改源码的情况下对程序进行扩展]</h5><p>[IDEA创建项目出现Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request_id%22:%22170678007016800227455895%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142%5Ev99%5Epc_search_result_base9&amp;utm_term=Cannot">https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request%5Fid%22%3A%22170678007016800227455895%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142^v99^pc_search_result_base9&amp;utm_term=Cannot</a> resolve plugin org.apache.maven.plugins%3Amaven-site-plugin%3A3.3&amp;spm&#x3D;1018.2226.3001.4187)</p>
<ul>
<li>Spring AOP - Aspect Oriented Programming 面向切面编程</li>
<li>AOP的做法是将通用、与业务无关的功能抽象封装为切面类</li>
<li>切面可配置在<strong>目标方法</strong>的执行前、后运行，真正做到即插即用</li>
</ul>
<p>运行前进行拦截在运行前打印时间 再运行代码；没有IoC就没有AOP；写完扩展之后要再applicationContext.xml中新增&lt; aop:config &gt;…来认可切面</p>
<pre><code class="java">aop/dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

import java.util.Date;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
---------------------------------------------
aop/service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        if(1==1)&#123;
            throw new RuntimeException(&quot;用户已存在&quot;);
        &#125;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------
aop/aspect/MethodAspect
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.JoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

//切面类
public class MethodAspect &#123;
    //切面方法,用于扩展额外功能
    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息
    public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;

    public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
    public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 16);
    &#125;
&#125;
====================================================================
----&gt;2024-02-01 18:09:38 050:com.imooc.AOP.UserService.createUser
----&gt;参数个数:0
执行创建用户业务逻辑
新增用户数据
&lt;----返回后通知:null
&lt;----触发后置通知
----&gt;2024-02-01 18:09:38 058:com.imooc.AOP.UserService.generateRandomPassword
----&gt;参数个数:2
----&gt;参数:MD5
----&gt;参数:16
按MD5方式生成16位随机密码
&lt;----返回后通知:PzZo3Fzqe!r4$
&lt;----触发后置通知
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;aop&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--aspectjweaver是Spring AOP的底层依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="Spring-AOP-与-AspectJ的关系-实现类与方法的匹配"><a href="#Spring-AOP-与-AspectJ的关系-实现类与方法的匹配" class="headerlink" title="Spring AOP 与 AspectJ的关系 [实现类与方法的匹配]"></a>Spring AOP 与 <u>AspectJ</u>的关系 [实现类与方法的匹配]</h3><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15949848/6813110">Spring【SpringAOP（通知类型、切点表达式 、多切面配置 、注解配置AOP、原生Spring实现AOP）】(六)-全面详解（学习总结—从入门到深化）_童小纯呀的技术博客_51CTO博客</a></p>
<ul>
<li>Eclips AspectJ 是一种基于Java平台的面向切面编程的语言</li>
<li>Spring AOP使用AspectJWeaver实现类与方法匹配</li>
<li><strong>Spring AOP利用<u>代理模式</u>实现对象运行时功能扩展</strong></li>
</ul>
<h5 id="几个关键概念"><a href="#几个关键概念" class="headerlink" title="几个关键概念"></a>几个关键概念</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面,具体的可插拔组件功能类,通常一个切面只能实现一个通用功能</td>
</tr>
<tr>
<td>Target Class&#x2F;Method</td>
<td>目标类、目标方法,指真正要执行与业务相关的方法</td>
</tr>
<tr>
<td><strong>PointCut</strong></td>
<td>切入点,<strong>使用execution表达式</strong>说明切面要作用再系统的哪些类上</td>
</tr>
<tr>
<td><strong>JoinPoint</strong></td>
<td>连接点,切面运行过程中是包含了目标类&#x2F;方法元数据的对象</td>
</tr>
<tr>
<td>Advice</td>
<td>通知,说明具体的切面的执行时机,Spring包含了不中不同类型通知</td>
</tr>
</tbody></table>
<blockquote>
<p>JoinPoint 连接点,通过连接点可以获取目标类&#x2F;方法的信息<br>public void printExecutionTime(JoinPoint joinPoint){}</p>
</blockquote>
<p><span style = "color:red"><strong>Spring AspectJ AOP实现提供了许多注释：</strong></span></p>
<p><strong>@Aspect</strong> 将该类声明为方面。<br><strong>@Pointcut</strong> 声明切入点表达式。</p>
<p>用于创建建议的注释如下:</p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<h5 id="AOP配置过程"><a href="#AOP配置过程" class="headerlink" title="AOP配置过程"></a>AOP配置过程</h5><ul>
<li>依赖AspectJ</li>
<li>实现切面类&#x2F;方法</li>
<li>配置Aspect Bean</li>
<li>定义PointCut</li>
<li>配置Advice  &#x2F;&#x2F;before通知(Advice)</li>
</ul>
<h3 id="JoinPoint核心方法"><a href="#JoinPoint核心方法" class="headerlink" title="JoinPoint核心方法"></a>JoinPoint核心方法</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object getTarget()</td>
<td>获取IoC容器内目标对象</td>
</tr>
<tr>
<td>Signature getSignature()</td>
<td>获取目标方法</td>
</tr>
<tr>
<td>Object[] getArgs()</td>
<td>获取目标方法<strong>参数</strong></td>
</tr>
</tbody></table>
<pre><code class="java">//很多线上的项目需要跟踪调试却不知道输入的参数是什么 就可以增加切片
public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs(); //传入目标方法的实际参数
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;
</code></pre>
<h3 id="PointCut切点表达式-pointcut"><a href="#PointCut切点表达式-pointcut" class="headerlink" title="PointCut切点表达式 [@pointcut]"></a>PointCut切点表达式 [@pointcut]</h3><p>注释用于定义切入点。我们也可以通过名称引用切入点表达式</p>
<pre><code class="java">@Pointcut(&quot;execution(* Operation.*(..))&quot;)
private void doSomething() &#123;&#125;

//它将应用于所有公共方法
@Pointcut(&quot;execution(public * * (..))&quot;)

//它将应用于Operation类的所有公共方法
@Pointcut(&quot;execution(public Operation.*(..))&quot;)

//它将应用于Operation类的所有方法
@Pointcut(&quot;execution(* Operation.*(..))&quot;)

//它将应用于Employee类的所有公共设置方法
@Pointcut(&quot;execution(public Employee.set*(..))&quot;)

//它将应用于所有返回int值的Operation类方法
@Pointcut(&quot;execution(int Operation.*(..))&quot;)
</code></pre>
<blockquote>
<p>​                   public void com.imooc.service.UserService.createUser(形参1,形参2,..)<br>  ​                    ↑         ↑             ↑                 ↑                 ↑                   ↑                  ↑</p>
<p>execution(public   *     com.imooc       ..                 *       .           *       (          ..          ))<br>*通配符                            ..包通配符[包括所有后代查找]                            (..)参数通配符</p>
<p>第一项public可以默认</p>
</blockquote>
<pre><code class="xml">&lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;/aop:config&gt;

---------------------------------------------------------------------------------
切点表达式训练
&lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
</code></pre>
<h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Before Advice</td>
<td>前置通知,目标方法运行前执行</td>
</tr>
<tr>
<td>After Returning Advice</td>
<td>返回后通知,目标方法返回数值后执行</td>
</tr>
<tr>
<td>After Throwing Advice</td>
<td>异常通知,目标方法抛出异常后执行</td>
</tr>
<tr>
<td>After Advice</td>
<td>后置通知,目标方法运行后执行</td>
</tr>
<tr>
<td><span style = " color : red"><strong>Around Advice</strong></span></td>
<td><span style = "color:red"><strong>最强大通知,自定通知执行时机,可决定目标方法是否运行</strong></span></td>
</tr>
</tbody></table>
<pre><code class="java">@Around(&quot;execution(* com.imooc..*Service.*(..))&quot;) 【通知 切面表达式】
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
</code></pre>
<p><span style = " color : red"><strong>用于创建建议的注释如下：</strong></span></p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<p><span style = " color : red"><strong>让我们看看用于定义建议的xml元素：</strong></span><br><a target="_blank" rel="noopener" href="https://www.cainiaoplus.com/spring/spring-aop-aspectj-xml-configuration-example.html">Spring AOP AspectJ Xml配置示例 - Spring教程 - 菜鸟教程 (cainiaoplus.com)</a><br>**<code>aop: before </code>**在调用实际的业务逻辑方法之前应用。<br>**<code>aop: after </code>**在调用实际的业务逻辑方法之后应用。<br>**<code>aop: 返回后</code>**在调用实际的业务逻辑方法后应用。可用于拦截通知中的返回值。<br>**<code>aop: around </code>**在调用实际的业务逻辑方法之前和之后都将应用。<br>**<code>aop: 投掷后</code>**如果实际的业务逻辑方法抛出异常，则将其应用。</p>
<h5 id="特殊的“通知”-引介增强"><a href="#特殊的“通知”-引介增强" class="headerlink" title="特殊的“通知” - 引介增强"></a>特殊的“通知” - 引介增强</h5><ul>
<li>引介增强是对类的增强,而非方法</li>
<li>引介增强允许再运行时为目标类增加新属性或方法</li>
<li>引介增强允许再运行时改变类的行为,让类随运行环境动态变更</li>
</ul>
<pre><code class="java">MethodAspect.java
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
</code></pre>
<pre><code class="java">MethodAspect.java
     public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    
</code></pre>
<pre><code class="java">MethodAspect.java
public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

打印顺序根据applicationContext.xml代码排列顺序一致
</code></pre>
<pre><code class="xml">applicationContext.xml [最终]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 15);
    &#125;
&#125;
===========================================================
----&gt;2024-01-12 13:40:56 885:com.imooc.spring.aop.service.UserService.createUser
----&gt;参数个数:0
&lt;----异常通知:用户已存在
&lt;----触发后置通知
Exception in thread &quot;main&quot; java.lang.RuntimeException: 用户已存在
    
</code></pre>
<hr>
<hr>
<h5 id="Before示例"><a href="#Before示例" class="headerlink" title="@Before示例"></a>@Before示例</h5><p>在实际业务逻辑方法之前应用AspectJ Before Advice。您可以在此处执行任何操作，例如转换，身份验证等。</p>
<p>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    //它将应用于Operation类的所有方法。
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @Before(&quot;k()&quot;)//在before通知上应用切入点
    public void myadvice(JoinPoint jp)//it is advice (before advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
    &lt;bean id=&quot;trackMyBean&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===========================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<h5 id="apo-before示例"><a href="#apo-before示例" class="headerlink" title="apo:before示例"></a>apo:before示例</h5><p>在实际业务逻辑方法之前应用”先行AspectJ建议”。您可以在此处执行任何操作，例如转换，身份验证等。<br>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
public class TrackOperation&#123;
    public void myadvice(JoinPoint jp)//it is advice
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @Before --&gt;
     &lt;aop:pointcut id=&quot;pointCutBefore&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:before method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutBefore&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
    
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<p>如您所见，在调用msg()，m()和k()方法之前，还会打印出其他问题。</p>
<hr>
<hr>
<h5 id="After示例"><a href="#After示例" class="headerlink" title="@After示例"></a>@After示例</h5><p>在调用实际的业务逻辑方法之后，应用了after建议之后的AspectJ。它可以用来维护日志，安全性，通知等。<br>在这里，我们假设 <strong>Operation.java</strong> ， <strong>applicationContext.xml</strong> 和 <strong>Test.java</strong> 文件与@Before示例中给出的文件相同。</p>
<pre><code class="java">TrackOperation.Java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @After(&quot;k()&quot;)//applying pointcut on after advice
    public void myadvice(JoinPoint jp)//it is advice (after advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;

===============================================================
calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<h5 id="aop-after示例"><a href="#aop-after示例" class="headerlink" title="aop:after示例"></a>aop:after示例</h5><p>在调用实际的业务逻辑方法之后，应用了通知之后的AspectJ。它可用于维护日志，安全性，通知等。<br>在这里，我们假设 **<code>Operation.java </code>**， **<code>TrackOperation.java </code>**和 **<code>Test.java </code>**文件与aop:before 中的示例相同。<br>现在创建定义bean的applicationContext.xml文件。</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @After --&gt;
     &lt;aop:pointcut id=&quot;pointCutAfter&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:after method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<pre><code class="java">calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<p>您可以看到在调用msg()，m()和k()方法之后，还会出现其他问题。</p>
</blockquote>
<hr>
<hr>
<h5 id="AfterReturning示例"><a href="#AfterReturning示例" class="headerlink" title="@AfterReturning示例"></a>@AfterReturning示例</h5><p>通过在<strong>返回建议后</strong>使用，我们可以在建议中获得结果。创建包含以下内容的类业务逻辑。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public int m()&#123;System.out.println(&quot;m() method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k() method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>创建返回建议后包含的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
@Aspect
public class TrackOperation&#123;
    @AfterReturning(pointcut = &quot;execution(* Operation.*(..))&quot;, returning= &quot;result&quot;)
    
    public void myadvice(JoinPoint jp,Object result)  //it is advice (after returning advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
        System.out.println(&quot;Result in advice: &quot;+result);
        System.out.println(&quot;end of after returning advice...&quot;);
    &#125;
&#125;
</code></pre>
<p>文件: applicationContext.xml    与@Before建议示例中给出的</p>
<p>文件: Test.java   现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling m...&quot;);
        System.out.println(e.m());
        System.out.println(&quot;calling k...&quot;);
        System.out.println(e.k());
    &#125;
&#125;
================================================================
calling m...
m() method invoked
additional concern
Method Signature: int com.nhooo.Operation.m()
Result in advice: 2
end of after returning advice...
2
calling k...
k() method invoked
additional concern
Method Signature: int com.nhooo.Operation.k()
Result in advice: 3
end of after returning advice...
3
</code></pre>
<h3 id="环绕通知-public-Object-check-ProceedingJoinPoint-pjp"><a href="#环绕通知-public-Object-check-ProceedingJoinPoint-pjp" class="headerlink" title="环绕通知 [public Object check(ProceedingJoinPoint pjp)]"></a>环绕通知 [public Object check(ProceedingJoinPoint pjp)]</h3><h5 id="利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化"><a href="#利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化" class="headerlink" title="利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]"></a>利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]</h5><pre><code class="java">dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;

---------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;

---------------------------------
service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000); //沉睡 为了触发环绕通知
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">aspect/MethodChecker.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

public class MethodChecker &#123;
    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();//方法执行前
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();//
            long duration = endTime - startTime; //方法执行后 执行时长
            if(duration &gt;= 1000)&#123;//认为执行太慢了 打印信息
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;//方法返回
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;methodChecker&quot; class=&quot;com.imooc.spring.aop.aspect.MethodChecker&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt; &lt;!--所有类进行拦截--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:aspect ref=&quot;methodChecker&quot;&gt;
            &lt;!--环绕通知--&gt;
            &lt;aop:around method=&quot;check&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;

pom.xml
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;

==============================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 13:52:41 475:com.imooc.spring.aop.service.UserService.createUser(3010ms)======

Process finished with exit code 0
</code></pre>
<hr>
<hr>
<h3 id="Around示例"><a href="#Around示例" class="headerlink" title="@Around示例"></a>@Around示例</h3><p>围绕通知的AspectJ在调用实际的业务逻辑方法之前和之后都得到应用。在这里，我们是假设  <strong>applicationContext.xml</strong> 文件与@Before示例中给出的文件相同。创建一个包含实际业务逻辑的类。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg() is invoked&quot;);&#125;
    public void display()&#123;System.out.println(&quot;display() is invoked&quot;);&#125;
&#125;
</code></pre>
<p>创建包含围绕建议的方面类。您需要在advice方法中传递  <strong>PreceedingJoinPoint</strong> 引用，以便我们可以通过调用proce来进行请求()方法。文件: TrackOperation.java</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation
&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void abcPointcut()&#123;&#125;
    
    @Around(&quot;abcPointcut()&quot;)
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable 
    &#123;
        System.out.println(&quot;Additional Concern Before calling actual method&quot;);
        Object obj=pjp.proceed();
        System.out.println(&quot;Additional Concern After calling actual method&quot;);
        return obj;
    &#125;
&#125;
</code></pre>
<p>现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new classPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation op = (Operation) context.getBean(&quot;opBean&quot;);
        op.msg();
        op.display();
    &#125;
&#125;

================================================================
Additional Concern Before calling actual method
msg() is invoked
Additional Concern After calling actual method
Additional Concern Before calling actual method
display() is invoked
Additional Concern After calling actual method
</code></pre>
<h3 id="基于注解配置Spring-AOP"><a href="#基于注解配置Spring-AOP" class="headerlink" title="基于注解配置Spring AOP"></a>基于注解配置Spring AOP</h3><pre><code class="java">aspect/MethodChecher.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
@Component //标记当前类为组件
@Aspect //说明当前类是切面类
public class MethodChecker &#123;
    //环绕通知,参数为PointCut切点表达式
    @Around(&quot;execution(* com.imooc..*Service.*(..))&quot;)
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();
            long duration = endTime - startTime; //执行时长
            if(duration &gt;= 1000)&#123;
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 用户表Dao
 */
@Repository
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
----------------------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 员工表Dao
 */
@Repository
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 用户服务
 */
@Service
public class UserService &#123;
    @Resource
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------------------
service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 员工服务
 */
@Service
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;
========================================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 17:06:18 669:com.imooc.spring.aop.service.UserService.createUser(3015ms)======

Process finished with exit code 0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--初始化IoC容器--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
  ★  &lt;!--启用Spring AOP注解模式--&gt; ★
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="增加了是说明这个类是需要被IoC实例化的"><a href="#增加了是说明这个类是需要被IoC实例化的" class="headerlink" title="增加了是说明这个类是需要被IoC实例化的"></a>增加了是说明这个类是需要被IoC实例化的</h6><ul>
<li>四种组件类型注解-声明当前类的功能与职责 【回忆上面的知识点】</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h3><h6 id="★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★"><a href="#★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★" class="headerlink" title="★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★"></a><span style = "color:red">★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★</span></h6><ul>
<li><span style = "color:blue">Spring基于<strong>代理模式</strong>实现功能动态扩展，包含两种形式：</span><ul>
<li><strong><span style = "color:blue">目标类拥有接口，通过JDK动态代理实现功能扩展 来实现目标类的代理从而实现扩展</span></strong></li>
<li><strong><span style = "color:blue">目标类没有接口，通过CGLib组件实现功能扩展 通过继承的方式实现扩展</span></strong></li>
</ul>
</li>
</ul>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul>
<li>代理模式通过代理对象对原对象的实现功能扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d5a848e492cf6e991719bfdc5cbbd31ef8a31fb/data/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<p>基于UserService接口实现代理类 同时持有与之对应的具体实现</p>
<h6 id="静态代理-每一个具体的委托类都要手动创造一个代理类"><a href="#静态代理-每一个具体的委托类都要手动创造一个代理类" class="headerlink" title="静态代理 [每一个具体的委托类都要手动创造一个代理类]"></a>静态代理 [每一个具体的委托类都要手动创造一个代理类]</h6><pre><code class="java">aop/service/UserService [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;
-------------------------------------
aop/service/UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy.java [代理]
package com.imooc.spring.aop.service;

import java.text.SimpleDateFormat;
import java.util.Date;
//静态代理是指必须手动创建代理类的代理模式使用方式
public class UserServiceProxy implements UserService&#123;
    //持有委托类的对象
    private UserService userService;
    public UserServiceProxy(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        userService.createUser();
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy1.java [代理1]
package com.imooc.spring.aop.service;

public class UserServiceProxy1 implements UserService&#123;
    private UserService userService ;
    public UserServiceProxy1(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        userService.createUser();
        System.out.println(&quot;========后置扩展功能======&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import com.imooc.spring.aop.service.UserServiceImpl;
import com.imooc.spring.aop.service.UserServiceProxy;
import com.imooc.spring.aop.service.UserServiceProxy1;

public class Application &#123;
    public static void main(String[] args) &#123; //类似于二房东
        UserService userService = new UserServiceProxy1(new UserServiceProxy(new UserServiceImpl()));
        userService.createUser();
    &#125;
&#125;
</code></pre>
<h3 id="AOP底层逻辑—JDK动态代理"><a href="#AOP底层逻辑—JDK动态代理" class="headerlink" title="AOP底层逻辑—JDK动态代理"></a>AOP底层逻辑—JDK动态代理</h3><pre><code class="java">aop/service.UserService.java [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;


-------------------------------------
aop/service.EmployeeService.java [接口]
package com.imooc.spring.aop.service;

public interface EmployeeService &#123;
    public void createEmployee();
&#125;
</code></pre>
<pre><code class="java">aop/service.EmployeeServiceImpl.java
package com.imooc.spring.aop.service;

public class EmployeeServiceImpl implements EmployeeService &#123;
    public void createEmployee() &#123;
        System.out.println(&quot;执行创建员工业务逻辑&quot;);
    &#125;
&#125;
--------------------------------------
aop/service.UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ProxyInvocationHandler.java
package com.imooc.spring.aop.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强
 * InvocationHandler实现类与切面类的环绕通知类似
 */
public class ProxyInvocationHandler implements InvocationHandler &#123;
    private Object target;//目标对象
    private ProxyInvocationHandler(Object target)&#123;
        this.target = target;
    &#125;
    /**
     * 在invoke()方法对目标方法进行增强 反射method方法的时候遇见过invoke
     * @param proxy 代理类对象
     * @param method 目标方法对象
     * @param args 目标方法实参
     * @return 目标方法运行后返回值
     * @throws Throwable 目标方法抛出的异常
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        Object ret = method.invoke(target, args);//调用目标方法,ProceedingJoinPoint.proceed()
        return ret;
    &#125;

    public static void main(String[] args) &#123;
        UserService userService = new UserServiceImpl();
        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);
        //动态创建代理类
        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(),
                invocationHandler);
        userServiceProxy.createUser();

        //动态代理,必须实现接口才可以运行
        EmployeeService employeeService = new EmployeeServiceImpl();
        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),
                employeeService.getClass().getInterfaces(),
                new ProxyInvocationHandler(employeeService));
        employeeServiceProxy.createEmployee();
    &#125;
&#125;

=======================================================

=====2024-01-12 19:52:34 179=========
执行创建用户业务逻辑
=====2024-01-12 19:52:34 181=========
执行创建员工业务逻辑

Process finished with exit code 0
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/7942f4deaa97d742e38e14b1326c7064e1a28f50/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png"  />





<h3 id="AOP底层逻辑—CGLib实现代理类"><a href="#AOP底层逻辑—CGLib实现代理类" class="headerlink" title="AOP底层逻辑—CGLib实现代理类"></a>AOP底层逻辑—CGLib实现代理类</h3><ul>
<li>CGLib是运行时字节码增强技术</li>
<li>Spring AOP扩展无接口类使用CGLib</li>
<li>AOP会运行时生成目标继承类字节码的方式进行行为扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7aa4a34eb72920c28d071577e2c074f4cf266e1a/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB.jpg"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/107a911bbe025f10f9f6629b01583a222956ca9f/data/CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%20%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" style="zoom:80%;" />



<h3 id="Spring-JDBC与事务管理"><a href="#Spring-JDBC与事务管理" class="headerlink" title="Spring JDBC与事务管理"></a>Spring JDBC与事务管理</h3><h5 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h5><ul>
<li>Spring JDBC是Spring框架用于处理关系型数据库的模块</li>
<li>Spring JDBC对JDBC API进行封装，极大简化开发工作量</li>
<li>JdbcTemplate是Spring JDBC核心类, 提供数据CRUD方法</li>
</ul>
<h5 id="为什么有了Mybatis还需要Spring-JDBC？"><a href="#为什么有了Mybatis还需要Spring-JDBC？" class="headerlink" title="为什么有了Mybatis还需要Spring JDBC？"></a>为什么有了Mybatis还需要Spring JDBC？</h5><p>因为这两者面向的对象是不一样的<br><strong>mybatis 封装程度</strong>高适合中小企业敏捷开发, 快速完成与数据库交互的工作, 封装程度高 执行效率低【慢】<br>Spring JDBC只是对原始的JDBC的API进行了简单封装 大厂使用【轻量级】可二次封装</p>
<h3 id="Spring-JDBC的使用步骤"><a href="#Spring-JDBC的使用步骤" class="headerlink" title="Spring JDBC的使用步骤"></a>Spring JDBC的使用步骤</h3><ul>
<li><p>Maven工程引入依赖<code>spring-jdbc</code></p>
</li>
<li><p>applicationContext.xml配置<code>DataSource</code>数据源 [<u>用于指向连接哪数据库的哪种服务器 账号密码都是啥</u>]</p>
</li>
<li><p>在Dao注入<code>JdbcTemplate</code>对象, 实现数据CRUD</p>
</li>
</ul>
<h2 id="JdbcTemplate类"><a href="#JdbcTemplate类" class="headerlink" title="JdbcTemplate类"></a>JdbcTemplate类</h2><h6 id="Spring-JdbcTemplate类的方法"><a href="#Spring-JdbcTemplate类的方法" class="headerlink" title="Spring JdbcTemplate类的方法"></a>Spring JdbcTemplate类的方法</h6><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String query)</td>
<td>用于插入，更新和删除记录。</td>
</tr>
<tr>
<td>public int update(String query，Object … args)</td>
<td>用于通过使用给定参数的PreparedStatement插入，更新和删除记录。</td>
</tr>
<tr>
<td>public void execute(String query)</td>
<td>用于执行DDL查询。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>通过使用PreparedStatement回调执行查询。</td>
</tr>
<tr>
<td>public T query(String sql, ResultSetExtractor rse)</td>
<td>用于使用ResultSetExtractor获取记录。</td>
</tr>
<tr>
<td>public List query(String sql, RowMapper rse)</td>
<td>用于使用RowMapper获取记录。</td>
</tr>
</tbody></table>
<h3 id="JdbcTemplate实现增删改查"><a href="#JdbcTemplate实现增删改查" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml [SpringIoC基础配置文件]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API 让IoC容器初始化的时候自动实例化jdbcTemplate 实例化的过程中要将设置好的数据源dataSource注入到jdbcTemplate属性中 此时就完成了实例化--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
&lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
&#125; +Setter Getter
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.jdbc;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        EmployeeDao employeeDao = context.getBean(&quot;employeeDao&quot;, EmployeeDao.class);
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);

    &#125;
&#125;

=======================================================
Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;

Process finished with exit code 0
</code></pre>
<h3 id="JdbcTemplate的数据查询方法"><a href="#JdbcTemplate的数据查询方法" class="headerlink" title="JdbcTemplate的数据查询方法"></a>JdbcTemplate的数据查询方法</h3><pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        //查询单条数据 转换成对象
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;
    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据                             sql  对应的参数数组  转换的Mapper对象
        //多条记录 每一条记录转换为一个实体对象 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;yan&#39;fa&#39;bu&quot;));
    &#125;
&#125;
================================================================
[Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;, Employee&#123;eno=3420, ename=&#39;李四&#39;, salary=8700.0, dname=&#39;研发部&#39;, hiredate=2006-11-11 00:00:00.0&#125;]


Process finished with exit code 0
</code></pre>
<pre><code class="java">★★ 新增 ★★
在没有对应的实体类情况下也可以得到相应的结果 结果被封装成为了Map对象
EmployeeDao.java
//    按列表返回每一条按Map对象列表返回
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;


JdbcTemplateTestor.java
@Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;
================================================================
[&#123;empno=3308, a=6000.0&#125;, &#123;empno=3420, a=8700.0&#125;]

Process finished with exit code 0
</code></pre>
<pre><code class="java">总结  [★★★★ queryForObject query queryForList ★★★★]
 private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        // ★★查询单条数据 转换成对象 ★★
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        // ★★查询复合数据★★                      sql  对应的参数数组  转换的Mapper对象
        // ★★多条记录 每一条记录转换为一个实体对象★★ 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

//    按列表返回每一条按Map对象列表返回
//特殊情况：无法进行实体类的映射则可用直接用queryForList特殊返回Map 来完成对应数据的封装
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

</code></pre>
<h3 id="JdbcTemplate实现增删改查-1"><a href="#JdbcTemplate实现增删改查-1" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="java">★★ 增 ★★
EmployeeDao.java
public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        jdbcTemplate.update(sql,new Object[]&#123;
                employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()
        &#125;);
    &#125;

JdbcTemplateTestor.java
@Test
    public void testinsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;


★★ 更新 ★★
EmployeeDao.java
public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename=?, salary=?, dname=?, hiredate=? WHERE eno=?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次更新1条数据

Process finished with exit code 0


★★ 删除 ★★
EmployeeDao.java
public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno=?&quot;;
        int update = jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
        return update;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次删除1条数据
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>事务式以一种可靠、一致的方法，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<h3 id="编程式事务-手动控制啥时候提交-啥时候回滚"><a href="#编程式事务-手动控制啥时候提交-啥时候回滚" class="headerlink" title="编程式事务 [手动控制啥时候提交 啥时候回滚]"></a>编程式事务 [手动控制啥时候提交 啥时候回滚]</h3><ul>
<li>编程式事务是指通过代码手动提交回滚事务的事务控制方法</li>
<li>SpringJDBC通过TransactionManager事务管理器实现事务控制</li>
<li>事务管理器提供commit&#x2F;rollback方法进行事务提交与回滚</li>
</ul>
<blockquote>
<p>S1需求：公司来了10名新员工 批量导入员工表中 (要么什么都不做，要么把事情做完) 【类似银行存钱】</p>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void bathImport()&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;



applicationContext.xml
&lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    

JdbcTemplateTestor.java
@Resource
    private EmployeeService employeeService;
@Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

此方法是一条一条的增加写入sql操作
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.684 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.564&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.69&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
</code></pre>
<hr>
<hr>
<h3 id="编程式事务-2-放入事务区统一管理"><a href="#编程式事务-2-放入事务区统一管理" class="headerlink" title="编程式事务-2 [放入事务区统一管理]"></a>编程式事务-2 [放入事务区统一管理]</h3><pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private DataSourceTransactionManager transactionManager;
    public void bathImport()&#123;
        //定义了事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务 放在事务区中统一进行管理
        TransactionStatus status = transactionManager.getTransaction(definition);

        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                if (i==3)&#123;
                    throw new RuntimeException(&quot;意料之外的异常&quot;);
                &#125;
                Employee employee = new Employee();
                employee.setEno(8010 + i);
                employee.setEname(&quot;员工&quot; + i);
                employee.setSalary(4000f);
                employee.setDname(&quot;市场部&quot;);
                employee.setHiredate(new Date());
                employeeDao.insert(employee);
            &#125;
            //提交事务
            transactionManager.commit(status);
        &#125; catch (Exception e) &#123;
            //回滚事务
            transactionManager.rollback(status);
            e.printStackTrace();
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public DataSourceTransactionManager getTransactionManager() &#123;
        return transactionManager;
    &#125;

    public void setTransactionManager(DataSourceTransactionManager transactionManager) &#123;
        this.transactionManager = transactionManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
&lt;!--     将属性进行注入 要添加其getter setter--&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    事务管理器 数据源  [整体提交以及回滚] 需要控制的类中注入bean id=&quot;transactionManager&quot; --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById() &#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname() &#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname() &#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testinsert() &#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;

========================================================
都是在一个数据库连接里操作的
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337]
10:01:16.166 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Releasing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337] after transaction
java.lang.RuntimeException: 意料之外的异常
    at com.imooc.spring.jdbc.service.EmployeeService.bathImport(EmployeeService.java:24)
    at JdbcTemplateTestor.testBatchImport(JdbcTemplateTestor.java:63)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
</code></pre>
<p>★★★ 编程式事务 ★★★<br>优点：容易理解 编程快<br>缺点：容易受到人为因素影响 结果致命</p>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><ul>
<li>声明式事务指在<strong>不修改源代码</strong>情况下通过配置形式自动实现事务控制, 声明式事务本质就是AOP环绕通知</li>
<li>当目标方法执行成功时, 自动提交事务</li>
<li>当目标方法抛出运行异常时, 自动事务回滚</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><ul>
<li>配置TransactionManager事务管理器</li>
<li>配置事务通知与事务属性</li>
<li>为事务通知绑定PointCut切点</li>
</ul>
<blockquote>
<p>需求：在不修改原始代码的情况下 配置Service里面的声明式事务</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
 &lt;!-- ★★★★ 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用  propagation是事务传播行为★★★★--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 不支持事务--&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">EmployeeService.java
vpackage com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            //注意噢 这里是被注释的
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">EmployeeDao.java 未改变
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<h3 id="事务传播行为【面试】"><a href="#事务传播行为【面试】" class="headerlink" title="事务传播行为【面试】"></a>事务传播行为【面试】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/dfcdce285d42fc77d69cb614b61e298b10a7252a/data/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B.jpg"></p>
<ul>
<li>事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式</li>
<li><code>XML:&lt;tx:method name=&quot;...&quot; propagation=&quot;REQUIRED&quot;/&gt;</code></li>
<li>注解: <code>@Transactional(propagation=Propagation.REQUIRED)</code></li>
</ul>
<blockquote>
<p>加个BatchService 然后在EmployeeService加一个private BatchService batchService;(getter + setter)  再次插入一个public void startImportJob()<br>进行applicationContext.xml的bean注入<br><bean id="batchService" class="com.imooc.spring.jdbc.service.BatchService"><br>    <property name="employeeDao" ref="employeeDao"/><br></bean></p>
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
    <property name="employeeDao" ref="employeeDao"/>
    <property name="batchService" ref="batchService"/>
</bean>

<p>会被声明式事务范围包裹噢<br>&lt;aop:pointcut id&#x3D;”pointcut” expression&#x3D;”execution(* com.imooc..*Service.*(..))”&#x2F;&gt;</p>
<pre><code class="java">applicationContext.xml
加入 importJob1 importJob2
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
</code></pre>
<p>补充public void startImportJob()</p>
<pre><code class="java">public void startImportJob()&#123;
    //会有关联行为 若2失败则无法导入 1也会回滚
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

//方法： REQUIRES_NEW 不同方法运行在不同事务中 
//事务1开始 事务1挂起事务2开始 事务2提交 事务1恢复 事务1挂起事务3开始 事务3提交事务1恢复 事务1提交
          &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
上面的分这写
</code></pre>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;
 
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;
public class BatchService &#123;

    private EmployeeDao employeeDao;

    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
public class EmployeeDao &#123;
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--为Dao注入JdbcTemplate对象--&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
        &lt;property name=&quot;batchService&quot; ref=&quot;batchService&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;batchService&quot; class=&quot;com.imooc.spring.jdbc.service.BatchService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">jdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="注解配置声明式事务"><a href="#注解配置声明式事务" class="headerlink" title="注解配置声明式事务"></a>注解配置声明式事务</h3><pre><code class="java">//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
写在类上就是所有 
写在方法就是单独方法运用
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
@Repository
public class EmployeeDao &#123;
    @Resource
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;
&#125; getter+setter
     @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.sun.xml.internal.ws.developer.Serialization;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//不需要使用事务 只读操作
@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)
public class BatchService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private BatchService batchService;

    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)
    public Employee findById(Integer eno)&#123;
        return employeeDao.findById(eno);
    &#125;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if(i==3)&#123;
                throw new RuntimeException(&quot;意料之外的异常&quot;);
            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
    &lt;!--数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- 启用注解形式声明式事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">test/java/JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>