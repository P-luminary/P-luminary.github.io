
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || 软件设计师考点</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>软件设计师考点 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/5/6
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/软考" style=color:#1bccbc>
                    软考
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="考试占比"><a href="#考试占比" class="headerlink" title="考试占比"></a>考试占比</h1><p><img src="https://raw.githubusercontent.com/P-luminary/images/08dd53c87a8378186b9e41b70e12b5dbcf28801c/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%94.png" alt="考试占比"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5266e65404ade654c69fc2834998c5c959eda74/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%942.png" alt="考试占比2"></p>
<h1 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h1><p><strong>报名条件：</strong>凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可报考软件设计师。也就是说不限制考生的学历、专业、工作经验及年限、年龄等。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/98615.html">点击查看软件设计师报名条件详解</a>】</p>
<p><strong>报名时间：</strong>上半年一般在&#x3D;&#x3D;3月份报名&#x3D;&#x3D;，下半年在&#x3D;&#x3D;8月份报名&#x3D;&#x3D;，各地报名具体时间不一样，考生届时需要多留意当地报名时间。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x159_1.html">点击查看各地软件设计师报名时间</a>】</p>
<p><strong>考试时间：</strong>上半年一般是&#x3D;&#x3D;5月份开考&#x3D;&#x3D;，下半年一般是&#x3D;&#x3D;11月份开考&#x3D;&#x3D;<br>上午基础知识科目考试为9:00-11:30，下午应用技术科目考试时间为14:00-16:30</p>
<p><strong>报名方式：</strong>考生自己在当地规定时间内进入软考办官网，即中国计算机技术职业资格网的报名入口进行报名。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/105000.html">点击查看软件设计师报名入口</a>】</p>
<p><strong>报名费用：</strong>各地不同，一般在100-160元之间，具体以当地为准，其中辽宁不收取报名费(大连考区除外)【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x164_1.html">点击查看报名费用</a>】</p>
<p><strong>成绩查询：</strong>一般是考后40天左右公布成绩，成绩公布后大家可以在软考办官网进行查询</p>
<p><strong>考试证书：</strong>两科均通过分数线即可领取证书，各地领证时间不同，上半年证书一般集中在9-10月份发放，下半年证书一般集中在次年2-3月份发放。错过证书领取时间，证书由发证机构代为保管，考生可咨询相关领取事宜，但是超过5年没领取的证书将被销毁。软件设计师证书可以在中国计算机技术职业资格网和中国人事考试考试网的“证书查询”栏目进行查询。<strong>【</strong><a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x163_1.html"><strong>点击查看详情</strong></a><strong>】</strong></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>二进制转八进制 八进制转十六进制<br>二进制转十进制 (分权相乘 整数AND小数)<br>十进制转二进制 (短除法)</p>
<h5 id="原码-反码-补码-转码"><a href="#原码-反码-补码-转码" class="headerlink" title="原码 反码 补码 转码"></a>原码 反码 补码 转码</h5><p><em>负数</em></p>
<ul>
<li><h4 id="原码-数字首-负数为1-正数为0"><a href="#原码-数字首-负数为1-正数为0" class="headerlink" title="原码(数字首 负数为1 正数为0)"></a><strong>原码</strong>(数字首 <u>负数为1 正数为0</u>)</h4><ul>
<li>+9 &#x3D; **<span style = "color : red">0</span>**000 1001</li>
<li>-9 &#x3D;  **<span style = "color : red">1</span>**000 1001 </li>
<li>Min → 1111 1111 &#x3D; —127    </li>
<li>Max → 0111 1111 &#x3D; +127</li>
<li>缺点：<strong>0有两种表示方式：+0&#x3D;00000000    -0&#x3D;10000000</strong>[零的二义性给机器判断带来了麻烦] ****</li>
<li><strong><span style = "color : orange"><u>原码的数值0有两种表示方式 +0 -0</u></span></strong></li>
</ul>
<p>比如：1-2&#x3D;-3 → ∵ +1+(-2) → +1 -&gt; 0000 000$1_原$  ;  -2 -&gt; 1000 001$0_原$  </p>
<p>∴ 0000 0001 + 1000 0010 &#x3D; 1000 001$1_原$ &#x3D; -3</p>
<p>为了解决这个问题，科学家使用补码</p>
<p>-33的原码是 *<u><strong>1</strong>010 0001</u>* 反码是 <u><strong>1</strong>101 1110</u></p>
</li>
<li><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a><strong>反码</strong></h4><ul>
<li>原码的符号位不变，其余位取相反得到 </li>
<li>反码存在的意义就是为了由原码计算补码方便</li>
</ul>
</li>
<li><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a><strong>补码</strong></h4><ul>
<li>反码+1得到</li>
<li>优点</li>
</ul>
<p>1、<span style = "color : orange"><strong><u>在补码表示中，0有唯一的编码</u></strong> </span>0 &#x3D; 0000 0000</p>
<p>2、用10000000表示 -128，比原码可多表示一个编码</p>
<p>3、利用补码可以方便地进行运算</p>
</li>
</ul>
<p><em>正数</em></p>
<ul>
<li><strong>原码&#x3D;反码&#x3D;补码</strong></li>
</ul>
<p>☆☆ <strong><span style = "color : green">正数：正数的原码、反码、补码都一样</span></strong> ☆☆</p>
<p>☆☆ <strong><span style = "color : green">负数：负数将原码的符号位保持不变，数值位各位取反再末位加1，就可以将原码转换为补码</span></strong> ☆☆</p>
<p>@@ 计算机中常采用原码、反码、补码和移码表示数据，其中±0编码相同的是<strong>补码和移码</strong><del>[这里一定要考虑正数和负数]</del></p>
<p>@@ 负数-5在计算机中的补码是 ？</p>
<p><u><em><strong>直接从原码变补码、补码变原码</strong></em></u>  <span style = "color : red"><strong>口诀：从右向左复制，直到有1被赋值 其余取相反(<u>符号位 &#x3D;&gt; 第一位不变</u>)</strong></span></p>
<ul>
<li><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4></li>
</ul>
<p>一般运用于浮点运算中的阶码，在<u><strong>补码</strong>的基础上把<strong>首位取反</strong></u></p>
<table>
<thead>
<tr>
<th></th>
<th>数值1 (正数前三都相同)</th>
<th>数值-1</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td>0000 0001</td>
<td>1000 0001</td>
</tr>
<tr>
<td>反码</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>补码</td>
<td><strong>0</strong>000 0001</td>
<td>1111 1111</td>
</tr>
<tr>
<td>移码</td>
<td><strong>1</strong>000 0001</td>
<td>0111 1111</td>
</tr>
</tbody></table>
<h3 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h3><table>
<thead>
<tr>
<th></th>
<th>整数</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>反码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>补码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}$]   ~   2$^{(n-1)}-1$</strong></span>  [少占用一个+0 -0]</td>
</tr>
</tbody></table>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数表示：<br><strong>N &#x3D; M * $R^e$</strong><br>其中M称为<strong>尾数</strong>，e是<strong>指数</strong>，R为<strong>基数</strong></p>
<h6 id="步骤：对阶-→-尾数计算-→-结果格式化"><a href="#步骤：对阶-→-尾数计算-→-结果格式化" class="headerlink" title="步骤：对阶 → 尾数计算 → 结果格式化"></a>步骤：<u>对阶 → 尾数计算 → 结果格式化</u></h6><p><strong>小阶数</strong>朝着<strong>大阶数</strong>化<br>1000 + 119 &#x3D;&gt; 1.0 × 1$0^3$ + <u>1.19 × 1$0^2$</u> &#x3D;&gt;  1.0 × 1$0^3$ + 0.119 × 1$0^3$ &#x3D; 1.119 × 1$0^3$</p>
<p><strong>结果格式化</strong>：如果答案是 0.1119 × 1$0^3$ 把结果变成 1.119 × 1$0^2$<br>确保尾数的第一个位置不能是0, 也不能是1以上的；最多是一位</p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><p>&#x3D;&#x3D;<strong>硬件 &#x3D; 主机 + 外设</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>主机</strong> &#x3D; CPU (<u>CPU &#x3D; 运算器 + 控制器</u>) + <em>内存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>外设</strong> &#x3D; 输入设备 + 输出设备 + <em>外存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<u><strong>存储器</strong> &#x3D; 内存 + 外存</u>&#x3D;&#x3D;</p>
<blockquote>
<p><strong>运算器</strong>：<br>① 算术逻辑单元ALU<br>② 累加寄存器AC<br>③ 数据缓冲寄存器DR <u>[<strong>对内存储器读取的时候 有暂存的作用</strong>]</u><br>④ 状态条件寄存器PSW [<strong><u>存储运算过程中的标志位</u></strong><del>状态信息</del>]</p>
<p><strong>控制器</strong>：<br>① 程序计数器PC<br>② 指令寄存器IR<br>③ 指令译码器<br>④ 时序部件</p>
</blockquote>
<h3 id="计算机体系结构分类-—-Flynn"><a href="#计算机体系结构分类-—-Flynn" class="headerlink" title="计算机体系结构分类 — Flynn"></a>计算机体系结构分类 — Flynn</h3><table>
<thead>
<tr>
<th>体系结构类型</th>
<th>结构</th>
<th>关键特征</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>单指令流单数据流 SISD</td>
<td>控制部分：一个<br />处理器：一个<br />主存模块：多个</td>
<td></td>
<td>单处理器系统(单片机)</td>
</tr>
<tr>
<td>单指令流多数据流 SIMD</td>
<td>控制部分：一个<br />处理器：多个<br />主存模块：多个</td>
<td>各处理器以异步的形式执行同一条指令</td>
<td>并行处理机<br />阵列处理机<br />超级向量处理机</td>
</tr>
<tr>
<td>多指令流单数据流 MISD</td>
<td>控制部分：多个<br />处理器：一个<br />主存模块：多个</td>
<td>被证明不可能，至少是不实际</td>
<td>目前没有，有文献称流水线计算机为此类</td>
</tr>
<tr>
<td>多指令流多数据流 MIMD</td>
<td>控制部分：多个<br />处理器：多个<br />主存模块：多个</td>
<td>能够实现作业、任务、指令等各级全面并行</td>
<td>多处理系统<br />多计算机</td>
</tr>
</tbody></table>
<h3 id="CISC与RISC"><a href="#CISC与RISC" class="headerlink" title="CISC与RISC"></a>CISC与RISC</h3><table>
<thead>
<tr>
<th>指令系统类型</th>
<th>指令</th>
<th>寻址方式</th>
<th>实现方式</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>CISC(复杂)</td>
<td>数量多，使用<strong>频率</strong>差别大，可变长格式</td>
<td>支持多种</td>
<td>微程序控制技术(微码)</td>
<td>研制周期长</td>
</tr>
<tr>
<td>RISC(精简)<del>主流</del></td>
<td>数量少，使用频率接近，定长格式，大部分微单周期指令<br />操作寄存器，只有Load&#x2F;Store操作内存</td>
<td>支持方式少</td>
<td>大量增加了通用寄存器(增加速度)；<br />硬布线逻辑控制为主<br />适合采用流水线</td>
<td><strong>优化编译，有效支持高级语言</strong></td>
</tr>
</tbody></table>
<p>CISC(Complex Instruction Set Computer, 复杂指令集计算机) 进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大而复杂。</p>
<p>RISC(Reduced Instruction Set Computer, 精简指令集计算机) 通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译，提高指令的执行速度，采用硬线控制逻辑，优化编译程序。</p>
<h3 id="流水线-计算-运用于工业-可节省时间"><a href="#流水线-计算-运用于工业-可节省时间" class="headerlink" title="流水线(计算)[运用于工业 可节省时间]"></a>流水线(计算)[运用于工业 可节省时间]</h3><p>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理事针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</p>
<p>执行一条指令分为 <strong>取指</strong> → <strong>分析</strong> → <strong>执行</strong></p>
<h6 id="未使用流水线执行指令情况"><a href="#未使用流水线执行指令情况" class="headerlink" title="未使用流水线执行指令情况"></a>未使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
<th>2</th>
<th></th>
<th></th>
<th>3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
</tr>
</tbody></table>
<h6 id="使用流水线执行指令情况"><a href="#使用流水线执行指令情况" class="headerlink" title="使用流水线执行指令情况"></a>使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>流水线周期<del>取指+分析+执行</del>为运算时间最长的一段</strong></li>
<li><strong><u>流水线运算时间</u>计算公式为：</strong><br><span style = "color : red"><strong>①条指令运算总时长 + (指令条数-1) × 流水线周期</strong></span><br>① 理论公式：**(t1 + t2 +…+ t<del>k</del>) + (n - 1) × △t**<br>② 实践公式：**(k + n-1) × △t**</li>
</ul>
<h6 id="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？"><a href="#若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？" class="headerlink" title="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？"></a>若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？</h6><table>
<thead>
<tr>
<th>取指</th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>.</strong></th>
<th><strong>.</strong></th>
<th><strong>n</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分析</strong></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
<td></td>
</tr>
<tr>
<td><strong>执行</strong></td>
<td></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
</tr>
</tbody></table>
<p>答：1.<u>周期最长的时间是2ns，所以流水线周期是2ns</u><del>每一个流水线的周期就会完成一条指令的运行</del><br>2.<strong>(2+2+1) + (100-1) × 2 &#x3D; 203</strong><del>理论公式①计算</del>  &#x2F;  <strong>[3<del>分三段</del>+ (100 - 1) ] × 2 &#x3D; 204</strong><del>实践公式②计算</del></p>
<ul>
<li><p><strong>流水线吞吐率计算</strong><br>是指在单位时间内流水线所完成的任务数量或输出的结果数量。</p>
<p>流水线吞吐率基本公式：<span style = "color : red"><strong>TP &#x3D; $\frac{指令条数}{流水线运算时间}$</strong></span><br>流水线最大吞吐率：<span style = "color : red"><strong>TP<del>max</del> &#x3D; Lim<del>n→∞</del>$\frac{n}{(k+n-1)△t}$&#x3D;$\frac{1}{△t}$</strong></span></p>
</li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D; 可以算出 TP &#x3D; $\frac{100}{203}$; TP<del>max</del> &#x3D;  $\frac{1}{2}$</p>
<ul>
<li><strong>流水线加速度比</strong><br>是指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比<br><span style = "color : red"><strong>S &#x3D; $\frac{不使用流水线执行时间}{使用流水线执行时间}$</strong></span></li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D;<br>不使用流水线执行时间：(2+2+1) × 100 &#x3D; 500<del>ns</del><br>使用流水线执行时间：203<del>ns</del><br>S &#x3D; $\frac{500}{203}$</p>
<ul>
<li><strong>流水线的效率</strong><br>是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比<br><span style = "color : red"><strong>E &#x3D; $\frac{n个任务占用的时空区}{k个流水段总的时空区}$ &#x3D; $\frac{T<del>0</del>}{KT<del>k</del>}$</strong></span></li>
</ul>
<h6 id="入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出"><a href="#入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出" class="headerlink" title="入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出"></a>入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出</h6><blockquote>
<p>↑ 此方法效率不高，因为在S4所需要的时间太长，导致其他的会遭到空闲状态</p>
</blockquote>
<p>横轴是时间△t；纵轴是空间</p>
<table>
<thead>
<tr>
<th>S4</th>
<th></th>
<th></th>
<th></th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S3</strong></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S2</strong></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S1</strong></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>n个任务占用的时空区：(△t + △t + △t + 3△t) × 4<br>k个流水段总的时空区：15△t × 4<br>E &#x3D; $\frac{(△t + △t + △t + 3△t) × 4}{15△t × 4}$</p>
<h2 id="层次化存储结构"><a href="#层次化存储结构" class="headerlink" title="层次化存储结构"></a>层次化存储结构</h2><p>容量最下层的最大 向上依次递减</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0a35815053da0e6c476e3a1dc86a1aa4bec7233f/data/%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p>
<h3 id="Cache-—-概念"><a href="#Cache-—-概念" class="headerlink" title="Cache — 概念"></a>Cache — 概念</h3><p>Cache的功能：提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即<strong>CPU</strong>与<strong>存储系统</strong>间<u>数据传送带宽限制</u>。<br>在计算机的存储系统体系中，Cache是访问速度最快的层次<br>使用Cache改善系统性能的依据是程序的<strong>局部性原理</strong></p>
<p>如果以<u>h代表对Cache的访问命中率</u>，<u>t<del>1</del>表示Cache的周期时间</u>，<u>t<del>2</del>表示主存储器周期时间</u>，以读操作为例，使用”<strong>Cache + 主存储器</strong>“的系统的平均周期为t<del>3</del>，则 <span style = "color : red"><strong>t<del>3</del> &#x3D; h × t<del>1</del> + (1 - h) × t<del>2</del></strong></span>，其中(1-h)又称为失效率(未命中率)<br>若h&#x3D;95%, t<del>1</del>&#x3D;1ns, t<del>2</del>&#x3D;1ms&#x3D;1000ns  &#x3D;&#x3D;&#x3D;&gt;  t<del>3</del> &#x3D; 1ns × 95% + (1 - 95%) × 1000ns &#x3D; 50.95ns</p>
<blockquote>
<p>CPU在读取数据中首先对Cache中读取，如果读到了则表示对该数据的命中，如果Cache中没有我们需要的数据，CPU会在内存里去调</p>
</blockquote>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><blockquote>
<p>时间局部性<br>空间局部性(<u>适用于数组</u>)<br>工作集理论：工作集是进程运行时被频繁访问的页面集合<del>短时间不被替换成cache</del></p>
</blockquote>
<pre><code class="java">int i, s = 0;  ==&gt;  全局变量直接调用Cache
for(i = 1; i &lt; 1000; i++)   ==&gt; 在内存中循环100w次
    for(j = 1; j &lt; 1000; j++)
        s+=j;
cout &lt;&lt; s &lt;&lt; end;
</code></pre>
<h3 id="内存-外存"><a href="#内存-外存" class="headerlink" title="内存+外存"></a>内存+外存</h3><ul>
<li><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li>ROM<del>BIOS</del> 只读存储器<br>ROM-Read Only Memory只读存储器。断电后信息不丢失，如计算机启动用的BIOS芯片。<br>MROM(Mask ROM, 掩模式ROM)<br>PROM 可编程只读存储器<br>EPROM 可擦写可编程只读存储器<br>EEPROM 点可擦可编程只读存储器<br>Flash Memory 闪存 ≈ SSD</li>
<li>RAM随机存储器<br>DRAM(动态存储器) 不断刷新 速度比SRAM慢 价格低 常用于主存储器<br>SRAM(静态存储器 ) 不需刷新 速度比DRAM快 价格贵  cache属于SRAM<br> <u>CPU → <strong>Cache</strong> → 内存 → 外存</u></li>
</ul>
</li>
<li><h4 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h4><ul>
<li>硬盘：<strong>机械硬盘</strong>HDD(SATA、IDE、SCSI接口)    <strong>固态硬盘</strong>SSD(SATA接口)</li>
<li>光盘：CD&#x2F;VCD：650MB、CD-ROM(只读光盘)、CD-R(一次性写入、永久读)、CD-RW(可重复擦写光盘)<br>DVD：4.7GB、DVD-ROM、DVD-R、DVD-RW</li>
</ul>
</li>
</ul>
<h3 id="主存-—-编址"><a href="#主存-—-编址" class="headerlink" title="主存 — 编址"></a><strong>主存 — 编址</strong></h3><p><strong>8 × 4 位的存储器 &#x3D;&#x3D;&gt; 8个地址空间，每一个存储空间存储了4个bit位的信息</strong></p>
<table>
<thead>
<tr>
<th>000 这一存储空间</th>
<th>存放了4个</th>
<th>bit的</th>
<th>信息容量</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>010</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>011</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>110</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>111</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>@@ 内存地址从AC000H到C7FFFH，共有 <span style = "color : red"> <u><strong>1C000&#x2F; $2^{10}$</strong></u>&#x3D;112</span> <strong>K</strong>个地址单位<br>如果该内存地址按字(16bit)编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个内存单元，则该芯片每个存储单元存储  <span style = "color : red"><u><strong>4</strong></u></span> 位</p>
<blockquote>
<p>原理是后面地址-前面地址+1；  C7FFFH + 1 - AC000H &#x3D; 1C000H<br>K &#x3D; $2^{10}$B   &#x3D;&#x3D;&gt; 共有 1C000&#x2F; $2^{10}$&#x3D;112K 个地址单位</p>
<p>用一系列的芯片组成这样 <strong>112K×16<del>bit位</del></strong> 的内存块，需要28个芯片，每个芯片是16K个存储单元**$\frac{112K×16}{28×16K×a}$ &#x3D; 1**，比值是1因为用这些芯片去成立这个空间。解得a&#x3D;4</p>
</blockquote>
<h3 id="磁盘结构与参数"><a href="#磁盘结构与参数" class="headerlink" title="磁盘结构与参数"></a>磁盘结构与参数</h3><p><span style = "color : red"><strong>存取时间 &#x3D; 寻道时间 + 等待时间(平均定位时间 + 转动延迟)</strong></span><br>注意：<u><strong>寻道时间</strong></u>是指<strong>磁头</strong>移动到<strong>磁道</strong>所需的时间；<u><strong>等待时间</strong></u>为等待读写的<strong>扇区</strong>转到<strong>磁头</strong>下方所用的时间。</p>
<blockquote>
<ul>
<li>硬盘</li>
</ul>
<p><span style = "color : red">机械硬盘(<strong>HDD</strong>)</span>：存储介质 磁介质；参数：[主慈善]**磁(道)头数、柱面数、扇区(**硬盘的基本读写单位，大小是512B)；</p>
<p><strong>硬盘容量 &#x3D; 磁头数 * 柱面数 * 扇区数 * 512B</strong>；<br>性能指标：<u>存储容量、转速、访问时间、传输速率、缓存等</u>；<br>[硬盘内部结构按<strong>扇区、磁道、柱面</strong>的格式组织存储信息]</p>
<p>接口：SATA、<strong>IDE</strong>、SCSI、光纤通道</p>
<p><span style = "color : red">固态硬盘(<strong>SSD</strong>)</span>：存储介质(Flash Memory闪存) 接口 SATA等</p>
</blockquote>
<p>旋转的延迟时间是磁盘转一圈的时间</p>
<p>@@ 假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R<del>0</del>，R<del>1</del>，…… ，R<del>9</del>，R<del>10</del>存放在同一个磁道上，记录的存放顺序如下表所示：</p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
</tr>
</tbody></table>
<p>如果磁盘的旋转周期为33ms，磁头当前处在R<del>0</del>的开始处。若系统使用单缓存区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为<strong>366ms</strong>；若对信息存储进行优化分布后，处理11个记录的最少时间为<strong>66ms</strong></p>
<blockquote>
<p>一圈11个记录 转一圈33ms，则每个记录旋转的时间是3ms，读取一个记录的时间是3ms；告诉单缓存区，转到R0时处理R0需要3ms<del>因为是单缓存区，不能同时进行，必须等R0处理完成才能进入下一个任务处理[处理的途中磁盘仍在转动,磁头仍在向前]</del>，而一个记录正好也需要3ms，所以当处理完R0时，磁头已经到达了R2的位置，所以要再转一圈才能去处理R1，以此类推，除了最后一个R10就可以找到规律，<strong>把R0处理完，再等到指针走到R1的位置的时候转了<u>一圈加一条</u>记录的时间 &#x3D; [33+3] &#x3D; 36ms</strong>，以此类推R0 ~ R9都是这样处理的，所以处理R0~R9共需要 <strong>36ms × 10</strong>，最后一个R10，把它读取出来3ms，再处理完3ms。<strong>综上一共需要 (33+3)×10+6 &#x3D; 366ms</strong>；</p>
<p>优化处理：当处理完R0的时候，磁头正好下一位置是R1，而不用再去等它转动一个周期后；优化后的图为<strong>右侧图二</strong>！旋转+处理&#x3D;(3ms+3ms)×10<del>个</del>&#x3D;<strong>66ms</strong></p>
</blockquote>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>根据总线所处的位置不同，总线通常被分成三种类型，分别是：</p>
<h5 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h5><p>是指微机内部各个<strong>外围的芯片</strong>与<strong>处理器</strong>之间的总线 属于<u>芯片</u>级别</p>
<h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>是指各个<strong>插件板</strong>和<strong>系统板</strong>之间的总线  属于<u>插件版</u>级别</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>数据总线(DB)</strong></u>&#x3D;&#x3D;：用来传输数据信息 双向传输</li>
<li>&#x3D;&#x3D;<u><strong>地址总线(AB)</strong></u>&#x3D;&#x3D;：用来传输数据地址 单向传输</li>
</ul>
<p>地址总线的位数决定了CPU可直接寻址的内存空间大小</p>
<p>若地址总线为n位，寻址空间为2的n次方个B，如微机的地址总线为16位，则最大寻址空间为64KB</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>控制总线(CB)</strong></u>&#x3D;&#x3D;：用来传输控制信号</li>
</ul>
<h5 id="外部总线"><a href="#外部总线" class="headerlink" title="外部总线"></a>外部总线</h5><p>是指<strong>微机</strong>和<strong>外部设备</strong>的总线</p>
<h3 id="系统可靠性分析-—-串联系统与并联系统"><a href="#系统可靠性分析-—-串联系统与并联系统" class="headerlink" title="系统可靠性分析 — 串联系统与并联系统"></a>系统可靠性分析 — 串联系统与并联系统</h3><p>【<strong>串联</strong>】输入 → R1 → R2 → … → Rn → 输出<br><strong>R &#x3D; R1 × R2 × … × Rn</strong><br><strong>λ &#x3D; λ1 + λ2 + … + λn</strong></p>
<p>【<strong>并联</strong>】</p>
<blockquote>
<pre><code>     →R1
</code></pre>
<p>输入 →R2 → 输出<br>         →Rn</p>
</blockquote>
<p><strong>R &#x3D;  1 - (1 - R1) × (1 - R2) × … × (1 - Rn)</strong><br>**μ &#x3D; **$\frac{1}{\frac{1}{λ}\quad\sum_{j&#x3D;1}^{n}\frac{1}{j}}$</p>
<p>【<strong>模冗余系统与混合系统</strong>】</p>
<blockquote>
<p>​         →R1  →↓</p>
<p>输入 →R2   →     表决器  → 输出</p>
<p>​         →Rm →↑</p>
</blockquote>
<p>**R &#x3D; **$\quad\sum_{j&#x3D;1}^{n}{C{^j}{_m}×R{<em>0}{^i}(1-R</em>{0})^{m-i}}$</p>
<p>【<strong>串并联</strong>】</p>
<blockquote>
<p>​           |—  R  —|         |—R—|<br>—R —|—  R  —|—— |           |——<br>​           |—  R  —|         |—R—|</p>
</blockquote>
<p><strong>R×(1-(1-R$)^3$×(1-(1-R$)^2$))</strong></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h6 id="什么是码距？"><a href="#什么是码距？" class="headerlink" title="什么是码距？"></a>什么是码距？</h6><p>一个编码系统的码距是整个编码系统中任意(所有)两个码字的最小距离<br>例：<br>若用1位长度的二进制编码。若A&#x3D;1，B&#x3D;0。这样A,B之间的最小码距为1<br>若用2位长度的二进制编码。若以A&#x3D;11，B&#x3D;00为例，A,B之间的最小码距为2<br>若用3位长度的二进制编码。可选用111,000作为合法编码。A,B之间的最小码距为3<del>[检错可以进一步提高码距]</del></p>
<h6 id="码距与检错、纠错有何关系？"><a href="#码距与检错、纠错有何关系？" class="headerlink" title="码距与检错、纠错有何关系？"></a>码距与检错、纠错有何关系？</h6><p>① 在一个码组内为了检测e个误码, 要求最小码距d应该满足：d&gt;&#x3D;e+1<br>② 在一个码组内为了纠正 t个误码, 要求最小码距d应该满足：d&gt;&#x3D;2t+1</p>
<h3 id="校验码-—-循环冗余校验码CRC"><a href="#校验码-—-循环冗余校验码CRC" class="headerlink" title="校验码 — 循环冗余校验码CRC"></a>校验码 — 循环冗余校验码CRC</h3><h6 id="什么是模2除法？-异或运算相同为0-不同为1"><a href="#什么是模2除法？-异或运算相同为0-不同为1" class="headerlink" title="什么是模2除法？(异或运算相同为0,不同为1)"></a>什么是模2除法？(异或运算<del>相同为0,不同为1</del>)</h6><p>模2除法是指在做除法运算的过程中不计其进位的除法</p>
<blockquote>
<p>加0，多项式阶数为r(等于多项式位数减1)，则加r个0<br>eg：要发送数据1101011011，采用CRC校验，生成多项式10011(加四个0)，则最终发送数据为？<br>1101011011<strong>0000</strong> ÷ 10011 &#x3D;&gt; 采用异或运算<br>[待发送的信息补零 ÷ 多项式系数]<br>仅仅采用了CRC检验，如果检测到一个错误，则丢弃帧。缺重传机制，数据链路层的传输还不是可靠的传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/301330a9af198935e53042758004cd173c401f95/data/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81.jpg"><br><span style = "color : red"><u>CRC编码 &#x3D; <strong>原始报文</strong> 后面补上 <strong>CRC校验码</strong></u></span><br><strong>注意：最后得到的位数必然是校验码位数，不够的需要补0</strong><br>这里得到的结果是11，但是需要凑位数，所以<strong>校验码&#x3D;0011</strong></p>
</blockquote>
<h3 id="校验码-—-海明校验码"><a href="#校验码-—-海明校验码" class="headerlink" title="校验码 — 海明校验码"></a>校验码 — 海明校验码</h3><p>求信息1011的海明码[<strong>$2^r$ ≥ 4<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong>]<br>①<strong>n+r</strong>个数 有 <span style = "color : red"><strong>$2^r$ ≥ n<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong></span>个错<br>确定校验码为3位：$2^3$ ≥ 4 + 3 + 1；分别放在$2^0$&#x3D;1、$2^1$&#x3D;2、$2^2$&#x3D;4 位<br><span style = "color : red">[校验位&#x2F;位置 $2^n$；奇偶校验(0√ 1×)；检验2位的错误, 纠正1位的错误]</span><br>② 列出校验位公式<br>7&#x3D;$2^2$+$2^1$+$2^0$，6&#x3D;$2^2$+$2^1$，5&#x3D;$2^2$+$2^0$，3&#x3D;$2^1$+$2^0$<br>$r_2$&#x3D;$I_4$⊕$I_3$⊕$I_2$<br>$r_1$&#x3D;$I_4$⊕$I_3$⊕$I_1$<br>$r_0$&#x3D;$I_4$⊕$I_2$⊕$I_1$<br>③ 根据公式得<strong>r<del>2</del>&#x3D;0，r<del>1</del>&#x3D;0，r<del>0</del>&#x3D;1</strong><br>④ 将数据加入表格</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>I<del>4</del></td>
<td>I<del>3</del></td>
<td>I<del>2</del></td>
<td></td>
<td>I<del>1</del></td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>r<del>2</del></td>
<td><strong>1</strong></td>
<td>r<del>1</del></td>
<td>r<del>0</del></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>1</td>
<td>校验位</td>
</tr>
</tbody></table>
<blockquote>
<h6 id="求信息1010海明校验码"><a href="#求信息1010海明校验码" class="headerlink" title="@@ 求信息1010海明校验码"></a>@@ 求信息1010海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; 4+r+1&#x3D;&gt; r&#x3D;3   &#x3D;&#x3D;&gt; n+r&#x3D;4+3&#x3D;7 下列表画7列<br>$2^n $&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
<td>二进制</td>
</tr>
<tr>
<td>P<del>1</del>($2^0$)</td>
<td>P<del>2</del>($2^1$)</td>
<td><strong>1</strong></td>
<td>P<del>3</del>($2^2$)</td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong> ↑</td>
<td><strong>0</strong> ↑</td>
<td>1</td>
<td>**1 **↑</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1<del>寻找位数二进制后尾是1的</del> &#x3D;&gt; ③⑤⑦ &#x3D;&gt; 1⊕0⊕0 &#x3D;&gt; 1<br>P2<del>第二位有1</del> &#x3D;&gt; ③⑥⑦ &#x3D;&gt; 1⊕1⊕0 &#x3D;&gt; 0<br>P3<del>最高位有1</del> &#x3D;&gt; ⑤⑥⑦ &#x3D;&gt; 0⊕1⊕0 &#x3D;&gt; 1<br>故海明码：101<strong>1010</strong></p>
</blockquote>
<blockquote>
<h6 id="求信息D8—D1的10101011海明校验码"><a href="#求信息D8—D1的10101011海明校验码" class="headerlink" title="@@ 求信息D8—D1的10101011海明校验码"></a>@@ 求信息D<del>8</del>—D<del>1</del>的10101011海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; n&#x3D;8, 解得r&#x3D;4; 一共要画8+4&#x3D;12列<br>r&#x3D;4 &#x3D;&#x3D;&gt; $2^n$&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>⑫</th>
<th>⑪</th>
<th>⑩</th>
<th>⑨</th>
<th>⑧</th>
<th>⑦</th>
<th>⑥</th>
<th>⑤</th>
<th>④</th>
<th>③</th>
<th>②</th>
<th>①</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1100</td>
<td>1011</td>
<td>1010</td>
<td>1001</td>
<td>1000</td>
<td>0111</td>
<td>0110</td>
<td>0101</td>
<td>0100</td>
<td>0011</td>
<td>0010</td>
<td>0001</td>
<td>二进制</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>P<del>4</del>($2^3$)</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>P<del>3</del>($2^2$)</td>
<td>1</td>
<td>P<del>2</del>($2^1$)</td>
<td>P<del>1</del>($2^0$)</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1 &#x3D;&gt; ③⑤⑦⑨⑪ &#x3D;&gt; 1⊕1⊕1⊕0⊕0 &#x3D;&gt; 1<br>P2 &#x3D;&gt; ③⑥⑦⑩⑪ &#x3D;&gt; 1⊕0⊕1⊕1⊕0 &#x3D;&gt; 1<br>P3 &#x3D;&gt; ⑤⑥⑦⑫ &#x3D;&gt; 1⊕0⊕1⊕1 &#x3D;&gt; 1<br>P4 &#x3D;&gt; ⑨⑩⑪⑫ &#x3D;&gt; 0⊕1⊕0⊕1 &#x3D;&gt; 0<br>故海明校验码为：1010<strong>0</strong>101<strong>1</strong>1<strong>11</strong></p>
</blockquote>
<h3 id="操作系统基本原理"><a href="#操作系统基本原理" class="headerlink" title="操作系统基本原理"></a>操作系统基本原理</h3><h5 id="操作系统-—-概述："><a href="#操作系统-—-概述：" class="headerlink" title="操作系统 — 概述："></a>操作系统 — 概述：</h5><ul>
<li>管理系统的硬件、软件、数据资源</li>
<li>控制程序运行</li>
<li>人机之间的接口</li>
<li>应用软件与硬件之间的接口[API接口]</li>
</ul>
<p><strong>操作系统 — 管理职能：</strong></p>
<ul>
<li>进程管理<ul>
<li>进程的状态</li>
<li><strong>前趋图</strong></li>
<li><strong>PV操作</strong></li>
<li>死锁问题</li>
</ul>
</li>
<li>存储管理<ul>
<li><strong>段页式存储</strong></li>
<li>页面置换算法</li>
</ul>
</li>
<li>文件管理<ul>
<li>索引文件</li>
<li><strong>位示图</strong></li>
</ul>
</li>
<li>作业管理</li>
<li>设备管理</li>
<li>微内核操作系统<ul>
<li>虚设备与SPOOLING技术</li>
</ul>
</li>
</ul>
<p>所属范围：<strong>应用程序</strong>【<strong>语言处理程序</strong>{<strong>操作系统</strong>[计算机硬件]}】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/66ab60b30acd298347efc9b06e3be945f99ebeea/data/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="三态→五态，时间片轮转"></p>
<p><strong>进程管理 — 前趋图</strong></p>
<p>A:绞肉  B:切葱末  C:切姜末  D:搅拌  E:包饺子<br><strong>①</strong> A → B → C → D → E<br><strong>②</strong> A↘<br>     B → D → E<br>     C↗</p>
<p><strong>进程管理 — 进程的同步与互斥</strong></p>
<p><strong>互斥</strong>：千军万马过独木桥<br><strong>同步</strong>：(小明步行, 小红自行车从A到B点) 速度有差异，在一定情况停下等待<br><u>互斥反义词是共享，同步反义词是异步</u><br><strong><u>进程的互斥</u></strong>:是指当有若干个进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占用着释放了该资源。<br><strong><u>进程的同步</u></strong>:是指在并发进程之间存在这一种制约关系，一个进程依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才被唤醒。</p>
<h3 id="进程管理-—-PV操作"><a href="#进程管理-—-PV操作" class="headerlink" title="进程管理 — PV操作"></a>进程管理 — PV操作</h3><p>PV操作是一种实现进程互斥与同步的有效方法。PV操作与信号量的处理相关<br><strong>P表示通过的意思，V表示释放的意思</strong>。<br>P操作可以看作是<strong>获得</strong>或者<strong>请求、消耗</strong>一个信号量<br>V操作可以看作是<strong>释放</strong>或者<strong>发送</strong>一个信号量</p>
<blockquote>
<p><span style = "color : red">P操作会阻塞；</span><br><span style = "color : red">V操作会唤醒P操作；</span><br><span style = "color : red">P操作与V操作成对出现；</span></p>
<p>int f1&#x3D;0;   &#x2F;&#x2F;表示进程P1是否执行完毕</p>
<p>main()<br>{<br>    cobegin<br>    p1();</p>
<p>​    coend<br>}</p>
<p><strong>p1() {</strong><br>    <strong>…</strong><br>    <strong>v(f1);</strong><br>    <strong>v(f1);</strong><br><strong>}</strong></p>
</blockquote>
<p><strong>临界资源</strong>：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等。<br><strong>临界区</strong>：每个进程中访问临界资源的那段代码称为临界区<br><strong>信号量</strong>：信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</p>
<p><strong>P(S)操作：</strong>S-&#x3D;1  →  S&lt;0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行<br><strong>V(S)操作：</strong>S+&#x3D;1 →  S≤0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行</p>
<blockquote>
<p>P(S)、V(S)中的S就是信号量<br>T–进程操作阻塞（不会往下执行）<br>F–继续循环操作（执行下面的内容）</p>
</blockquote>
<h6 id="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"><a href="#单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0" class="headerlink" title="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"></a>单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0</h6><table>
<thead>
<tr>
<th>生产者：(先执行)</th>
<th>消费者：</th>
</tr>
</thead>
<tbody><tr>
<td>生产一个产品；</td>
<td><strong>P</strong>(S2);   [S2&#x3D;0]</td>
</tr>
<tr>
<td><strong>P</strong>(S1);   [S1&#x3D;0, S1&#x3D;-1]</td>
<td>从缓冲区取产品;</td>
</tr>
<tr>
<td>送产品到缓冲区;</td>
<td><strong>V</strong>(S1);</td>
</tr>
<tr>
<td><strong>V</strong>(S2);   [S2&#x3D;1]</td>
<td>消费产品;</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dfaac2ea85671c477f9008c1aa3dc70b68012a90/data/PV%E6%93%8D%E4%BD%9C%E4%BE%8B%E9%A2%98.png"></p>
<p>付款要双方的配合，会有同步的关系；假设没有这个操作；若先进行收银员操作，则没有购书者先购书，收银员无法操作。此时b1有个P操作，P操作需要付款V操作来唤醒；所以一开始的PV是同一信号量P(S1), V(S1)；对于购书者有个等待阻塞操作，等待收银员P(S2), V(S2)。【V(S1)唤醒P(S1)，收费后由收银员的V(S2)唤醒付款的P(S2)】<br>n+1个人进来的话会被阻塞。</p>
<blockquote>
<p>注意：<br>①P操作具备阻塞的职能，V操作不具备阻塞能力。<br>②PV操作关键要找到约束，找到谁是因变量，谁是自变量，谁约束谁。【PV操作是成对出现的】<br>③一对儿PV操作信号量是相同的。<br>看题发现已经存在了一对PV操作，信号量为Sn，Sn的值为n，很容易想到这对PV操作的作用就是控制进入书店的人数的。当人数达到n了，阻止人继续进入书店，这种状态直到有人付款离开书店为止。</p>
<p>再来看题发现还有两对PV操作，首先通过图能知道购书者和收银员之间存在约束关系，收银员要等待购书者付款才能工作，购书者要等待收银员反馈才能离开书店。那么这两对PV操作就是控制这个约束的。</p>
<p>先从购书者分析，购书者开始付款了，收银员才能开始收款，所以a1与b1之间是一对PV操作，进一步分析，如果没有购书者付款，那么收银员是不能执行收款操作的，也就是说收银员进程应该及时阻塞，故b1应该是P（S1）,a1应该是V（S1）。</p>
<p>购书者发起付款操作的时候，不能马上离开书店，因为他要等收银员的反馈，付款成功拿到 小票才能离开，也就是说购书者在等待收银员反馈的时候应该及时阻塞住，故a2与b2之间是一对PV操作，且a2是P（S2），对应的b2就是V（S2）。</p>
<p>再检查一遍看看是否合理呢？</p>
<p>从收银员角度开始，假设没有人付款，P操作能及时阻塞，使得收银员进程不会进入收费状态，所以b1位置放P操作没有问题，进一步分析信号量S1的初始值应该为0，经过b1后S1为-1，阻塞。</p>
<p>从购书者角度看，开始付款的时候激活收银员进程，所以a1是V操作也没有问题，通过a1的操作，S1信号量又为0了，收银员进程可以进行收费了。</p>
<p>再返回收银员角度，收费完毕后要给购书者信号，购书者从才能离开，所以b2为V操作没有问题。</p>
<p>从购书者角度看，a2应该是P操作，应该及时阻塞住。进一步分析，S2信号量也应该是0才符合要求。</p>
<p>😁总结<br>PV操作从做题的角度出发，我认为首先要找到约束关系，就是谁和谁是一对约束，第二步确定这对约束谁是P谁是V（用反证方法推一下看看），最后一步考虑信号量，信号量为多少取决于是否马上阻塞还是说执行几次后再阻塞，这个要结合具体问题具体分析。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">(53条消息) 软考必考题型之PV操作_pv操作中p和v各代表什么_du-hyper的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42539194/article/details/129647813?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&utm_relevant_index=6">(53条消息) 软考–快速掌握操作系统的PV操作_pv操作 软考_韦_恩的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f6094b2857a22777d38b9ed2362cf00c60b926a6/data/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86PV%E6%93%8D%E4%BD%9C.jpg"></p>
<p>箭头的起始位置是V操作，箭头的终止位置是P操作</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/45ad39c827d6c05d3e7d27552d3fd1a7313a574c/data/PV%2B%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%A4%A7%E9%A2%98.jpg"></p>
<h3 id="进程管理-—-死锁问题"><a href="#进程管理-—-死锁问题" class="headerlink" title="进程管理 — 死锁问题"></a>进程管理 — 死锁问题</h3><h6 id="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"><a href="#进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。" class="headerlink" title="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"></a>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</h6><p>资源都被分配且无法得到资源释放</p>
<p>例题：系统有3个进程：A、B、C。这3个进程都需要5个系统资源。如果系统至少有多少个资源，则不可能发生死锁[<u>有多少资源 无论怎么分配都不会产生死锁</u>]</p>
<table>
<thead>
<tr>
<th align="center">进程A</th>
<th align="center">进程B</th>
<th align="center">进程C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong><span style = "color : red">如果每个进程需要n个资源，总共有k个进程 &#x3D;&gt;分配情况：k × (n-1) + 1</span></strong><br>答：每个进程都需要5个资源，共有3个进程 &#x3D;&gt; n &#x3D; 5; k &#x3D; 3 &#x3D;&#x3D;&gt; 3 × (5 - 1) + 1 &#x3D; 12+1 &#x3D;13<br><img src="https://raw.githubusercontent.com/P-luminary/images/b65167c6d6f03ed5726ddd517ab0e89ec0df46c9/data/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98.jpg"></p>
<p>打破<strong>互斥</strong>：让大家同时共享资源<br>打破<strong>保持和等待</strong>：得不到相应的资源就会把资源分享出去，不会霸占并等待别人给与<br>打破<strong>不剥夺</strong>：不去抢别人分配到的资源</p>
<h4 id="银行家算法：分配资源的原则"><a href="#银行家算法：分配资源的原则" class="headerlink" title="银行家算法：分配资源的原则"></a>银行家算法：分配资源的原则</h4><p>√ 当一个进程对资源的最大需求量<strong>不超过</strong>系统重的资源数时可以接纳该进程<br>√ 进程可以<strong>分期请求</strong>资源，但请求的总数不能超过最大需求量<br>√ 当系统现有的资源不能满足尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源</p>
<p><strong>@@</strong> 例：假设系统中有三类互斥资源<strong>R1、R2、R3</strong>，可用资源数分别是<strong>9、8、5</strong>。在T<del>0</del>时刻系统中有<strong>P1、P2、P3、P4、P5</strong>五个进程，这些进程对资源的最大需求量和已分配资源数如下所示，如果进程按<strong>？</strong>序列执行，那么系统状态是安全的<del>不发生死锁</del><br>【列表口诀：<strong>现</strong> <strong>需要</strong> <strong>已</strong>(<u>蚁</u>)<strong>精</strong>(经)子来分娩】<br><strong>剩下的资源</strong>：总资源 — 已分配资源</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c9c14e04f67a7fd291fa566beaa4b0ee4506bb2/data/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.jpg"></p>
<p>A. P1→P2→P4→P5→P3                    <strong>B. P2→P4→P5→P1→P3</strong><br>C. P2→P1→P4→P5→P3                    D. P4→P2→P4→P1→P3</p>
<ul>
<li>若先不执行P2，先执行P1，则右图R1还需资源数还需要5个，则你R1剩下的2个不够分配到，会发生进程死锁。即第一个先执行 P2。</li>
<li>若先执行P2，再执行P1，则我们发现进程P1需要R1资源为5，我们能提供的R1资源为4，所以序列无法进行下去，为不安全序列<br>【<span style = "color :red">只要<strong>现有资源</strong>可以满足<strong>需要资源</strong>的分配即可True，执行完后释放资源给下一步进程使用</span>】</li>
</ul>
<h3 id="存储管理-—-分区存储组织"><a href="#存储管理-—-分区存储组织" class="headerlink" title="存储管理 — 分区存储组织"></a>存储管理 — 分区存储组织</h3><p>某计算机系统的内存大小为128k，采用可变分区分配进行内存分配，当前系统的内存分块情况如下图所示，现有<strong>作业4</strong>申请<strong>内存9k</strong>，几种不同的存储分配算法在分配中，会产生什么样的结果呢？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31409e62be82acbe02077d84d12e51f146d9948e/data/%E6%9C%80%E4%BD%B3-%E6%9C%80%E5%B7%AE-%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png"></p>
<p><strong>最佳适应算法</strong>：分配任务空间时。任务由闲余空间从小到大依次尝试是否能成功分配。若小闲余空间能分配就分配。不可则进入下一个闲余空间进行空间区域切割划分。<strong>缺陷</strong>：内存的碎块(<u>几k的闲余空间</u>)；<br><u><strong>最差适应算法</strong></u>：则逆过来表示(先考虑从大的块中分配出来)<br><strong>循环首次适应法</strong>：(分配较均匀)</p>
<h3 id="存储管理-—-页式存储组织"><a href="#存储管理-—-页式存储组织" class="headerlink" title="存储管理 — 页式存储组织"></a>存储管理 — 页式存储组织</h3><p><strong>逻辑地址</strong>的<strong>页号</strong>对应<strong>物理地址</strong>的<strong>块号</strong>(通过查表可得出)；其<strong>页内地址</strong>都是一样的(调用的时候以页为单位, 偏移量不会有太大的变化)</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4ac7b79184178af545b460f5427fe9c9cd5cb9c5/data/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>例：进程P有6个页面，页号分别为0-5，页面大小为4K，页面转换表如下所示。表中<u>状态位等于<strong>1</strong>和<strong>0</strong>分别表示页面在<strong>内存</strong>和<strong>不在内存</strong></u>。假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制(<strong>6A29H</strong>)；如果进程P要访问的页面4不在内存，那么应该淘汰页号为(<strong>1</strong>)的页面。</p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">页帧号</th>
<th align="center">状态位</th>
<th align="center">访问位</th>
<th align="center">修改位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>(1) A. 1A29H        B. 3A29H        C. 5A29H        D. 6A29H<br>(2) A. 0                  B. 1                  C. 2                 D. 5</p>
<p>4k &#x3D; 4×1024 &#x3D; 2$^{2+10}$ &#x3D; $2^{12}$ 说明一个页内地址是12位，高于12位的就是页号<br>由于进制P要访问的逻辑地址是十六进制5A29H，则一个十六进制位 &#x3D; 4个二进制位<br>说明有3个位是页内地址 &#x3D;&gt; A 2 9；所以页内地址无需求，是为A29<br>页号5需要查表观测它的页帧号是6；然后与后面拼接起来 为6A29H<br>将要淘汰的页号一定是在存在的里面选出 存在的才能淘汰，则1代表存在；<br>就要从页号0 1 2 5中淘汰一个，看其访问位，刚刚访问过的是1不能淘汰，<br>只能淘汰访问位是0的，综上所述，应该淘汰1页号</p>
<h3 id="存储管理-—-段式存储组织"><a href="#存储管理-—-段式存储组织" class="headerlink" title="存储管理 —  段式存储组织"></a>存储管理 —  段式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/540c15f503aa3e817771ddb1ace41a4d15c66015/data/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<h3 id="存储管理-—-段页式存储组织"><a href="#存储管理-—-段页式存储组织" class="headerlink" title="存储管理 — 段页式存储组织"></a>存储管理 — 段页式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/46c912294b0428ab3464f49e504e47de54ea3e01/data/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>先查段表 查完段表 查页表</p>
<h3 id="存储管理-—-快表"><a href="#存储管理-—-快表" class="headerlink" title="存储管理 — 快表"></a>存储管理 — 快表</h3><p><strong>快表</strong>是一块小容量的相联存储器(Associative Memory), 由高速缓存器组成，速度快，并且可以从硬件上保证<strong>按内容</strong>并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。<br>若将这些东西放在内存当中则称为慢表(放在内存)、快表(放在Cache)</p>
<h3 id="存储管理-—-页面置换算法-运用于分层的置换体系中"><a href="#存储管理-—-页面置换算法-运用于分层的置换体系中" class="headerlink" title="存储管理 — 页面置换算法(运用于分层的置换体系中)"></a>存储管理 — 页面置换算法(运用于分层的置换体系中)</h3><h5 id="页面淘汰算法"><a href="#页面淘汰算法" class="headerlink" title="页面淘汰算法"></a>页面淘汰算法</h5><h6 id="☆-最优-Optimal-OPT-算法"><a href="#☆-最优-Optimal-OPT-算法" class="headerlink" title="☆ 最优(Optimal, OPT) 算法"></a>☆ 最优(Optimal, OPT) 算法</h6><h6 id="☆-随机-RAND-算法"><a href="#☆-随机-RAND-算法" class="headerlink" title="☆ 随机(RAND) 算法"></a>☆ 随机(RAND) 算法</h6><h6 id="★-先进先出-FIFO-算法：有可能产生”抖动”"><a href="#★-先进先出-FIFO-算法：有可能产生”抖动”" class="headerlink" title="★ 先进先出(FIFO) 算法：有可能产生”抖动”"></a>★ 先进先出(FIFO) 算法：有可能产生”抖动”</h6><p>抖动：给你更多的资源去处理反而效率降低了<br>例如432143543215序列用3个页面，比4个缺页要少<br><strong>缺页</strong>：当加入内存中的页面序列是全新版本(内存中没有)，则内存内部需要这个版本，因为缺少这个版本<br>第八-九列 编号为4的程序页不缺页(没有往前推进的原因是因为内存中还存有4的残渣[第八列]；有3的残渣[第九列])</p>
<table>
<thead>
<tr>
<th align="center">(9次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">(10次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong>横向</strong>代表：访问的页面序列<br><strong>纵向</strong>代表：内存的几号页面(第一列是编号为4的程序页)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0f77ce658d321b83bdd0b8da87d540cf660ed92/data/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png"><u><strong>LRU</strong></u>：<strong>最近被访问的则不需要被淘汰，淘汰掉最久没有被访问到的</strong><br><u><strong>FIFO</strong></u>：先入先出原则</p>
<h6 id="★-最近最少使用-LRU-算法：不会”抖动”"><a href="#★-最近最少使用-LRU-算法：不会”抖动”" class="headerlink" title="★ 最近最少使用(LRU) 算法：不会”抖动”"></a>★ 最近最少使用(LRU) 算法：不会”抖动”</h6><p>根据局部性原理，刚刚访问过的资源是不会被淘汰出去的</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dcaa41c594fe86047d0f9cbc03a4e3c24c5e9fc/data/%E9%A1%B5%E9%9D%A2%E5%9E%84%E6%96%AD%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<p> <span style = "color : red"><strong>每读一次程序块，先在内存上面查一下表之后读取相应的内存块，所以每一个内存块需要进行两次内存的访问。总共有⑥个块，会产生12次内存的访问</strong></span></p>
<p>A块在2号页有一半，在3号页面也有一半。所以总的缺页次数是5次；<strong>对于指令而言</strong><del>无论占用几个块都会一次性调用</del>不会产生两次垄断，只有一次缺页垄断；∴swap A,B 一次；A上半页一次, 下半页一次；B上半页一次, 下半页一次；1+2+2&#x3D;5次；1k有1024个单元(字节)</p>
<h3 id="文件管理-—-索引文件结构"><a href="#文件管理-—-索引文件结构" class="headerlink" title="文件管理 — 索引文件结构"></a>文件管理 — 索引文件结构</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da6db0bd7d31c5a4b548e3631be05912cdbf38ec/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86.jpg"></p>
<p>一个物理盘块是1K大，一个地址4Byte，除一下，每一个盘块可以存256个地址;    ↓ ↓ ↓ ↓ ↓ ↓</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cebe816153cc666243ca77883f86b9ace46c311/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<p>File1的信息是<strong>二级地址索引表</strong> </p>
<h3 id="操作系统-—-文件和树型目录结构"><a href="#操作系统-—-文件和树型目录结构" class="headerlink" title="操作系统 — 文件和树型目录结构"></a>操作系统 — 文件和树型目录结构</h3><p><strong>文件属性</strong>：R 只读文件属性    A 存档属性    S 系统文件    H 隐藏文件<br><strong>文件名的组成</strong>：驱动号、路径、主文件名、扩展名<br><strong>绝对路径</strong>：是从盘符开始的路径<br><strong>相对路径</strong>：是从当前路径开始的路径<br>若当前目前位：D1，要求F2路径<br>则：<u>绝对路径</u>：&#x2F;D1&#x2F;W1&#x2F;F2； <u>相对路径</u>：W2&#x2F;F2</p>
<h3 id="文件管理-—-空闲存储文件的管理"><a href="#文件管理-—-空闲存储文件的管理" class="headerlink" title="文件管理 — 空闲存储文件的管理"></a>文件管理 — 空闲存储文件的管理</h3><p>空闲区表法(空闲文件目录)、空闲链表法、**<span style = "color : red">位示图法</span>**、成组链接法</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/b80648caa2ce4c11344f2775ce62ebd4b7af9161/data/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%BE%8B%E9%A2%98.jpg"></p>
<p>(1) (4195+1) &#x2F; 32 &#x3D; 131.125 ≈ 第132字<br>(2) 用物理块毫无疑问是要制成1的 所以AC排除，131×32&#x3D;4192 (0→4191)，故第132字中：<br>第0位置→4192   第1位置→4193  第2位置→4194  <strong>第3位置→4195</strong><br><span style = "color : red"><strong>第多少个字是从1开始算, 多少位置是从第0个位置开始算。</strong></span></p>
<blockquote>
<p>第1字         1 0 1 0 0 … 1 1<br>第2字         0 1 1    0 … 0 1<br>第3字         1 1 1 1 0 … 1 0<br>…                …<br>第n字         0 0 0 1 1 … 0 0</p>
</blockquote>
<h3 id="设备管理-—-数据传输控制方式"><a href="#设备管理-—-数据传输控制方式" class="headerlink" title="设备管理 — 数据传输控制方式"></a>设备管理 — 数据传输控制方式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d7d10e539675e94eff1c9c90dcb66f52e6ca4cfb/data/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png"></p>
<h3 id="设备管理-—-虚设备与SPOOLING技术"><a href="#设备管理-—-虚设备与SPOOLING技术" class="headerlink" title="设备管理 — 虚设备与SPOOLING技术"></a>设备管理 — 虚设备与SPOOLING技术</h3><p>要输出输入的先缓存起来(输入井 输出井)<br><img src="https://raw.githubusercontent.com/P-luminary/images/3d1b4c80871fa1aaf9cb194667a35cd042f75d8c/data/SPOOLING%E6%8A%80%E6%9C%AF.jpg"></p>
<h3 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/79a58babdadddeef05bc5890cacd0f3a27dd0d4b/data/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"></p>
<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><span style = "color : red">数据库系统</span></h1><h3 id="三级模式-—-两级映射"><a href="#三级模式-—-两级映射" class="headerlink" title="三级模式 — 两级映射"></a>三级模式 — 两级映射</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/896dd865381624663248207420b70d53681437e2/data/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E2%80%94%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84.jpg"></p>
<p><strong>内模式</strong>：管我们如何去存储这些数据 也叫存储模式，对应于<u>物理级</u><br>概念模式：表之间有一定的关联 逻辑模式 对应<u>概念级</u><br><strong>外模式</strong>：对应着数据库里的视图(对数据更灵活的控制) 子模式或用户模式，对应<u>用户级</u><br>期间都存在着映射(起到逻辑独立性&#x2F;物理独立性)</p>
<blockquote>
<p>什么是外模式？<br>    1）数据库的用户使用的局部数据的逻辑结构和特征的描述<br>    2）数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。（如应用程序A只能看见其相对于的外模式1，应用程序B只能看见其相对于的外模式2，不能看见不属于自己的外模式。相当于是模式的一个子集）</p>
<p>外模式的地位：介于模式与应用之间。</p>
<p>模式与外模式的关系：一对多<br>    1）外模式是模式的子集<br>    2）一个数据库可以有多个外模式，反应了不同的用户的应用需求、看待数据的方式、对数据保密的要求。<br>    3）对于模式中的同一个数据，不同外模式可以对数据的长度、类型等有不同的定义。</p>
<p>外模式与应用的关系：一对多。<br>    1）同一外模式可以为某一个用户的多个应用系统所使用<br>    2）但一个应用程序只能使用一个外模式</p>
<p>外模式的用途：<br>    1）保证数据库安全，每个用户只能看见自己对应外模式的数据<br>    2）保证数据独立性。</p>
<h4 id="总结-外模式是模式的一部分，是部分用户看到的数据库的样子。"><a href="#总结-外模式是模式的一部分，是部分用户看到的数据库的样子。" class="headerlink" title="总结:外模式是模式的一部分，是部分用户看到的数据库的样子。"></a><span style = "color : red"><strong>总结:外模式是模式的一部分，是部分用户看到的数据库的样子。</strong></span></h4></blockquote>
<blockquote>
<p>内模式：<br>    1）数据物理结构和存储方式的描述<br>    2）是数据在数据库内部的表示方式<br>    Ⅰ.记录的存储方式：如顺序存储，按B树结构存储，Hash存储）<br>    Ⅱ.索引的组织方式：B+树索引，hash索引，Join index索引<br>    Ⅲ.数据是否压缩存储<br>    Ⅳ.数据是否加密<br>    注：一个数据库只有一个内模式。</p>
<h4 id="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"><a href="#总结：内模式处于最底层，是对数据在数据库底层的存储的描述。" class="headerlink" title="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"></a><span style = "color : red"><strong>总结：内模式处于最底层，是对数据在数据库底层的存储的描述。</strong></span></h4></blockquote>
<h4 id="数据库特点："><a href="#数据库特点：" class="headerlink" title="数据库特点："></a>数据库特点：</h4><p>数据结构化、数据的共享、冗余度低、<strong>数据独立性高</strong>、数据由<strong>DBMS</strong>统一管理和控制</p>
<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cd0bd56ba2d79a742db12fc000df23ed6ed69281/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bf4edf231e68e25885a3339134cf79b21cf74c8/data/E-R%E6%A8%A1%E5%9E%8B.jpg"></p>
<p> <strong>概念模型</strong> 面向用户 用户角度出发 用户分析<br> <strong>逻辑结构&#x2F;模型</strong><br> <strong>物理结构&#x2F;模型</strong>(数据库对象) 跟计算机系统发生联系</p>
<p>主码：[也称住关键字，它能够唯一标识一个元组。码可以是一个属性或属性组]</p>
<p><strong>框框</strong>表示<strong>实体</strong>[客观存在并相互区别的事物]<br><strong>椭圆</strong>表示<strong>属性</strong>[实体所具有的特征]<br><strong>菱形</strong>表示<strong>联系</strong>[实体与实体之间的关系]<br>域：属性值的取值范围<br>实体型：用实体名及其属性名集合来描述同类实体也称为实体型 <strong>学生(<u>学号</u>, 姓名, 性别</strong>)<br>实体之间有各种各样的连信息(一对一联系1:1、一对多联系1:n、多对多联系m:n)</p>
<p>1个学生对应N个课程，1个课程对应M个学生；所以学生和课程是N:M的关系</p>
<h5 id="集成的方法："><a href="#集成的方法：" class="headerlink" title="集成的方法："></a>集成的方法：</h5><p>多个局部E—R图一次集成<br>逐步集成，用累加的方式一次继承两个局部E—R图</p>
<h5 id="集成产生的冲突及解决办法："><a href="#集成产生的冲突及解决办法：" class="headerlink" title="集成产生的冲突及解决办法："></a>集成产生的冲突及解决办法：</h5><p>属性冲突：包括属性域冲突和属性取值冲突<br>命名冲突：包括同名异义和异名同义<br>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E—R图中所包含的属性个数和属性排列次序不完全相同</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d8bb3486b6917b13f8c21e6c42f0f0ffb0fa797/data/E-R%E6%A8%A1%E5%9E%8B1.png"></p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h6 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h6><blockquote>
<p><strong>并 交 差 笛卡尔积 投影 选择 联接</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7999126ac896482aa27e523291f7266c74684484/data/%E5%B9%B6%20%E4%BA%A4%20%E5%B7%AE%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%20%E6%8A%95%E5%BD%B1%20%E9%80%89%E6%8B%A9%20%E8%81%94%E6%8E%A5.png"></p>
<h4 id="★★★★-考点-★★★★"><a href="#★★★★-考点-★★★★" class="headerlink" title="★★★★ 考点 ★★★★"></a><span style = "color : red">★★★★ 考点 ★★★★</span></h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/49278f5b4160686cf7931eeabcc2ffecca3f9b68/data/%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%92%8C%E8%87%AA%E7%84%B6%E8%81%94%E6%8E%A5.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="规范化理论—函数依赖"><a href="#规范化理论—函数依赖" class="headerlink" title="规范化理论—函数依赖"></a>规范化理论—函数依赖</h3><p> <img src="https://raw.githubusercontent.com/P-luminary/images/51a6a949e29af7425b4db2467e3cea8b9d472cb2/data/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg"></p>
<h3 id="规范化理论—价值与用途"><a href="#规范化理论—价值与用途" class="headerlink" title="规范化理论—价值与用途"></a>规范化理论—价值与用途</h3><p>非规范化的关系模式，可能存在的问题包括：<strong>数据冗余，更新异常，插入异常，删除异常</strong></p>
<p><strong>超键</strong>可能<u>存在</u>冗余属性<br><strong>候选键</strong><u>不存在</u>冗余属性</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eba44424461fb41231f3a2033809728876107800/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E2%80%94%E9%94%AE.jpg"></p>
<h3 id="规范化理论—求候选键"><a href="#规范化理论—求候选键" class="headerlink" title="规范化理论—求候选键"></a>规范化理论—求候选键</h3><p>√ 将关系模式的函数依赖关系用”<span style = "color : red"><strong>有向图</strong></span>“的方式表示<br>√ 找<span style = "color : red"><strong>入度为0</strong></span>的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键<br>√ 若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些<span style = "color : red"><strong>中间结点</strong></span>(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/fedbdbd44be93aebd7ee7900ac880b9bbf416ad6/data/%E6%B1%82%E5%80%99%E9%80%89%E9%94%AE%E5%AE%9E%E4%BE%8B.jpg" style="zoom:200%;" />



<h3 id="规范化理论—范式"><a href="#规范化理论—范式" class="headerlink" title="规范化理论—范式"></a>规范化理论—范式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7c4039b8889ccba887966fa6a9419576d19fb759/data/%E8%8C%83%E5%BC%8F.png"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/d909de9417c222c51a54a62215b672b44c27c50b/data/%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E.jpg"  />



<p><strong>主属性</strong>(SNO CNO)：属性属于候选键的一部分 (在任何一个<strong>候选关键字</strong>里出现过的都是<strong>主属性</strong>)<br>没有<strong>非主属性</strong> 肯定满足<strong>第二范式</strong>和<strong>第三范式</strong></p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4d428c01728bc74188f07efc4e3ccdf9c7477f1f/data/b-C%E8%8C%83%E5%BC%8F.jpg"></p>
<h3 id="规范化理论—综合例题"><a href="#规范化理论—综合例题" class="headerlink" title="规范化理论—综合例题"></a>规范化理论—综合例题</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5d9b49971208e067131389f48c469365519fdad6/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E7%BB%BC%E5%90%88%E4%BE%8B%E9%A2%98.png"  />



<h3 id="规范化理论—模式分解"><a href="#规范化理论—模式分解" class="headerlink" title="规范化理论—模式分解"></a>规范化理论—模式分解</h3><p>当范式级别不够的时候把模式进行拆分 这样范式级别就可以上升<br><img src="https://raw.githubusercontent.com/P-luminary/images/8de9f7295722d81e08fbcd3d1d5e24ab6b1c61cc/data/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3.png"  /></p>
<h3 id="并发控制—基本概念"><a href="#并发控制—基本概念" class="headerlink" title="并发控制—基本概念"></a>并发控制—基本概念</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6fcaefdeb1c71e5d4f06a4792ef956c1ed146d3c/data/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h3><p><strong>√ 实体完整性约束</strong>：约束主键(<u>主键为空 没有输入具体值</u>)<br><strong>√ 参照完整性约束</strong>：填入的数据必须是按照表里主键的内容(允许为空)<br><strong>√ 用户自定义完整性约束</strong>：(年龄不允许输入负数 或者200以上的值)</p>
<p>√ <strong>触发器</strong>(较复杂的要求)：可以写脚本来约束数据库数据的要求</p>
<h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><table>
<thead>
<tr>
<th>措施</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>用户标识和鉴定</td>
<td>最外层的安全保护措施，可以使用用户账户，口令及随机数检验等方式</td>
</tr>
<tr>
<td>存取控制</td>
<td>对用户进行授权，包括操作类型(如<strong>查找, 插入, 删除, 修改</strong>等动作)和数据对象(主要是<strong>数据范围</strong>)的权限</td>
</tr>
<tr>
<td>密码存储和传输</td>
<td>对远程终端信息用密码传输</td>
</tr>
<tr>
<td>视图的保护</td>
<td>对视图进行授权</td>
</tr>
<tr>
<td>审计</td>
<td>使用一个专用文件(日志)或数据库，自动将用户对数据库的所有操作记录下来</td>
</tr>
</tbody></table>
<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p><strong>√ 冷备份</strong>也称为静态备份，是将数据库正常关闭，在停止状态，将数据库的文件全部备份(复制)下来。<br><strong>√ 热备份</strong>也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来 </p>
<table>
<thead>
<tr>
<th align="left">备份方式 &#x2F; 优缺点</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冷备份</td>
<td align="center">非常快速的备份方法只需要复制文件；容易归档(简单复制即可)；容易恢复到某个时间点上(只需要将文件再复制回去)；能与归档方法相结合，做数据库”最佳状态“的恢复；低度维护，高度安全</td>
<td align="center">单独使用时，只能提供到某一个时间点上的恢复；再实施备份的全过程中，数据库必须要作备份二不能做其他工作；若磁盘空间有限只能复制到磁带等其他外部存储设备上，速度会很慢；不能按表或按用户恢复</td>
</tr>
<tr>
<td align="left">热备份</td>
<td align="center">可再表空间或数据库文件级备份，备份的时间短；备份时数据库仍可使用；可达到秒级恢复(恢复到某一时间点上)；可对几乎所有数据库实体做恢复；恢复是快速的</td>
<td align="center">不能出错，否则后果严重；如我热备份不成功所得结果不可用于时间点的恢复；因难于维护，所以要特别小心，不允许”以失败告终“</td>
</tr>
</tbody></table>
<p><strong>√ 完全备份：</strong>备份所有数据<br><strong>√ 差量备份：</strong>仅备份上一次完全备份之后变化的数据<br><strong>√ 增量备份：</strong>备份上一次备份之后变化的数据</p>
<table>
<thead>
<tr>
<th align="center">日</th>
<th align="center">一</th>
<th align="center">二</th>
<th align="center">三</th>
<th align="center">四</th>
<th align="center">五</th>
<th align="center">六</th>
</tr>
</thead>
<tbody><tr>
<td align="center">完</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">差</td>
<td align="center">增</td>
<td align="center">增</td>
</tr>
</tbody></table>
<p>若在周一的增量备份后系统出现故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一增量版</strong><br>如果周三的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一周二周三增量版</strong><br>这样恢复太麻烦，所以提出了<strong>差量备份</strong>, <strong>周四</strong>的差量备份直接针对<strong>周日的差量变化</strong><br>如果周四的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周四的差量版</strong></p>
<ul>
<li><p><strong>静态海量存储</strong>：在系统中无运行事务时进行, 每次存储全部数据库</p>
</li>
<li><p><strong>静态增量存储</strong>：在系统中无运行事务时进行，每次只存储上一个转储后更新过的数据库</p>
</li>
<li><p><strong>动态海量存储</strong>：转储期间允许对数据库进行存取或修改，每次转储全部数据库</p>
</li>
<li><p><strong>动态增量转储</strong>：转储期间允许对数进行存取或修改，每次只转储上一次转储后更新过的数据</p>
</li>
</ul>
<p>日志文件：事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作(增删改查)，并将记录结果保存在独立的 (<u>先写日志 再写数据文件</u>)</p>
<table>
<thead>
<tr>
<th align="center">故障关系</th>
<th align="center">故障原因</th>
<th align="center">解决办法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务本身的可预期故障</td>
<td align="center">本身逻辑</td>
<td align="center">再程序中预先设置Rollback语句</td>
</tr>
<tr>
<td align="center">事务本身的不可预期故障</td>
<td align="center">算数溢出, 违反存储保护</td>
<td align="center">由DBMS的恢复子系统通过日志,撤销事务对数据库的修改,回退到事务初始状态</td>
</tr>
<tr>
<td align="center">系统故障</td>
<td align="center">系统停止运转</td>
<td align="center">通常采用检查点法</td>
</tr>
<tr>
<td align="center">介质故障</td>
<td align="center">外存被破坏</td>
<td align="center">一般使用日志重做业务</td>
</tr>
</tbody></table>
<h3 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h3><p><strong>数据仓库</strong>是面向各各主题的；会记录一些集成式的数据(报表)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c60e0ed20bce0df65d296e7f30cc4c1ee207aeb9/data/%E4%BB%93%E5%BA%93%E6%95%B0%E6%8D%AE.jpg"></p>
<h3 id="反规范化-牺牲空间-规范化程度来换时间"><a href="#反规范化-牺牲空间-规范化程度来换时间" class="headerlink" title="反规范化(牺牲空间+规范化程度来换时间)"></a>反规范化(牺牲<u>空间</u>+<u>规范化程度</u>来换<u>时间</u>)</h3><p>由于规范化会使表不断的拆分，从而导致数据表过多。这样虽然减少了<strong>数据冗余</strong>，<u>提高了增、删、改的速度，但会增加查询的工作量</u>。系统需要进行多次连接，才能进行查询操作，使得系统效率大大下降。</p>
<h6 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h6><p><strong>√ 增加派生性冗余列</strong> (在成绩表里添加 姓名&#x2F;课程名 能够快速查到哪个人成绩多少分)<br><strong>√ 增肌冗余列</strong><br><strong>√ 重新组表</strong>(依据查询效率的原则)<br><strong>√ 分割表</strong>(从效率角度看进行垂直分割、水平分割)</p>
<h3 id="大数据-4V"><a href="#大数据-4V" class="headerlink" title="大数据 4V"></a>大数据 4V</h3><p>Volume 数据量    Velocity 速度    Variety 多样性    Value 价值</p>
<table>
<thead>
<tr>
<th align="center">比较维度</th>
<th align="center">传统数据</th>
<th align="center">大数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据量</td>
<td align="center">GB或TB</td>
<td align="center">PB级或以上</td>
</tr>
<tr>
<td align="center">数据分析需求</td>
<td align="center">现有数据的分析与检测</td>
<td align="center">深度分析(关联分析、回归分析)</td>
</tr>
<tr>
<td align="center">硬件平台</td>
<td align="center">高端服务器</td>
<td align="center">集群平台</td>
</tr>
</tbody></table>
<h6 id="大数据处理系统应该具有的重要特征"><a href="#大数据处理系统应该具有的重要特征" class="headerlink" title="大数据处理系统应该具有的重要特征"></a>大数据处理系统应该具有的重要特征</h6><blockquote>
<p>高度可拓展性<br>高性能<br>高度容错<br>支持异构环境<br>较短的分析延迟<br>易用且开放的接口<br>较低成本<br>向下兼容性</p>
</blockquote>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>中继器</strong>：类似于烽火狼烟<br><strong>网桥</strong>：链接两个同类型的设备<br><strong>交换机</strong>：用来链接多个设备</p>
<blockquote>
<h6 id="按分布范围分"><a href="#按分布范围分" class="headerlink" title="按分布范围分"></a>按分布范围分</h6><p>局域网LAN 城域网MAN 广域网WAN 因特网</p>
<h6 id="按拓扑结构分"><a href="#按拓扑结构分" class="headerlink" title="按拓扑结构分"></a>按拓扑结构分</h6><p>总线型 星型 环型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">名称</th>
<th align="center">主要功能</th>
<th align="center">主要设备及协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">应用层</td>
<td align="center">实现具体的应用功能</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">表示层</td>
<td align="center">数据的格式与表达、加密、压缩</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">会话层</td>
<td align="center">建立、管理和终止会话</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">传输层</td>
<td align="center">端到端的连接</td>
<td align="center">TCP、UDP</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">网络层</td>
<td align="center">分组传输和路由选择</td>
<td align="center">三层交换机、路由器、ARP、RARP、IP、ICMP、IGMP</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">数据链路层</td>
<td align="center">传送以帧为单位的信息</td>
<td align="center">网桥、交换机、网卡、PPTP、L2TP、SLIP、PPP</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">物理层</td>
<td align="center">二进制传输</td>
<td align="center">中继器、集线器</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>TCP&#x2F;IP 协议体系结构</strong><br>(1) 采用 分层结构，将复杂的大问题，划分成若干个简单的小问题<br>(2) TCP&#x2F;IP从下向上，依次划分为 “网络接口层、网络层 、传输层、应用层”<br>【注意】”网络接口层” 对应了 OSI的 物理层和数据链路层<br>(3) 常用协议<br>① 数据链路层 [PPP 点对点协议  PPPoE 基于 局域网的PPP协议 over Ethernet]<br>用于 建立、维护 数据链路(数据通道)<br>② 网络层<br><strong>IP</strong>：互联网协议，是所有通信必须使用的协议；作用：保证数据到达正确的目的地<br><strong>ARP</strong>：地址解析协议，实现 局域网 中主机的 IP地址转网卡的物理地址<br><strong>ICMP</strong>：互联网控制<strong>报文</strong>协议，功能：差错控制和查询主机<br><strong>RARP</strong>：逆向ARP，局域网中 物理地址 转 虚拟IP地址</p>
<blockquote>
<p>ping 127.0.0.1 回环测试本地主机内部网络状态是否正常</p>
</blockquote>
<p>③ 传输层<br><strong>TCP</strong>：传输控制协议，面向连接、可靠通信协议；功能：保证到达目的地的数据是正确的<br><strong>UDP</strong>：用户数据报协议，无连接、不可靠通信协议，用于 大数据传输(流媒体)：音频、视频<br>④ 应用层<br><span style = "color : red">HTTP</span> 超文本传输协议：用于访问网络<br><span style = "color : red">HTTPS</span> 加密&#x2F;安全超文本传输协议<br><strong>SMTP</strong>&#x2F;MIME 简单邮件传输协议：用于<strong>发送电子邮件</strong><br><strong>POP3</strong>&#x2F;IMAP 邮局协议第三版：用于<strong>接收电子邮件</strong><br><strong>FTP</strong> 文件传输协议：用于 上传下载文件<br><strong>TELNET</strong> 远程登录协议<br>DNS 域名解析协议：实现 中英文域名 转换为 数字的IP地址</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f96331264996b03cae2b87dcaf29db2e778b6b2f/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E4%BD%8D.jpg" style="zoom: 67%;" />
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/a17658b559c5998517d83d9117f82c913b7fc241/data/%E5%8D%8F%E8%AE%AE.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/a52a51d3f2d21b7f3f39926b385f47fc4fdda4b6/data/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" style="zoom:200%;" />



<h3 id="DHCP-DNS协议"><a href="#DHCP-DNS协议" class="headerlink" title="DHCP + DNS协议"></a>DHCP + DNS协议</h3><img src="https://raw.githubusercontent.com/P-luminary/images/adf08386618abc9e6c46346884f3860d74c14956/data/DHCP%2BDNS%E5%8D%8F%E8%AE%AE.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/202233c320981b4c100c6837c0ad9cb5b32e68c2/data/DNS%E5%8D%8F%E8%AE%AE%E9%A2%98.jpg"></p>
<h3 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/57a0942867cd04aaeea6f7f50d48aba632b281b1/data/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1.jpg"  />

<blockquote>
<p>★★★ 非常重要 IP地址相关计算题 ★★★</p>
<h5 id="IP地址和子网掩码换算"><a href="#IP地址和子网掩码换算" class="headerlink" title="IP地址和子网掩码换算"></a>IP地址和子网掩码换算</h5><p>已知ip地址和子网位数，例如：C网192.168.1.53&#x2F;27， [子网位数是27]<br><strong>求</strong><br>1.具体的子网掩码<br>2.子网数<br>3.<strong>最大可容纳主机数</strong><br>4.<strong>可用的主机数</strong><br>5.网络地址<br>6.广播地址<br>7.地址范围<br>8.主机号</p>
<h5 id="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："><a href="#一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：" class="headerlink" title="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："></a>一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：</h5><p>**1.**C网默认的子网掩码是：255.255.255.0<br>转换成二进制是：11111111.11111111.11111111.00000000<br>（1代表网络号，0代表主机号）<br>前24位是1，代表网络号，后8位是0，代表主机号<br>&#x3D;&#x3D;已知子网位数是27&#x3D;&#x3D;，代表网络号向主机号借用了3位（8+8+8+3）<br>得：11111111.11111111.11111111.11100000<br>把二进制转换为十进制：255.255.255.224<br>求出192.168.1.53&#x2F;27对应的子网掩码是255.255.255.224</p>
<h6 id="二、子网数"><a href="#二、子网数" class="headerlink" title="二、子网数"></a>二、子网数</h6><p>1.网络号向主机号借了3位（27-24），得**$2^3$&#x3D;8个**</p>
<p><span style = "color : red"><strong>三、最大可容纳主机数</strong></span>（根据求出的子网掩码和给出的子网位数求）1.由一可知子网掩码是：255.255.255.254，转换为二进制是11111111.11111111.11111111.11100000<br>1代表网络号，0代表主机号，有5个0，得最大可容纳主机数是2^5&#x3D;32</p>
<h6 id="四、可用的主机数"><a href="#四、可用的主机数" class="headerlink" title="四、可用的主机数"></a>四、可用的主机数</h6><p>由三可知，最大可容纳主机数是32个，32-2<del>广播地址+网络地址</del>&#x3D;30</p>
<h6 id="五、网络地址（把IP地址和子网掩码进行与运算）"><a href="#五、网络地址（把IP地址和子网掩码进行与运算）" class="headerlink" title="五、网络地址（把IP地址和子网掩码进行与运算）"></a>五、网络地址（把IP地址和子网掩码进行与运算）</h6><p>192.168.1.53&#x2F;27， 把IP地址和子网掩码进行与运算，IP地址转换为二进制：11000000.10101000.00000001. <strong>00110101<del>53</del></strong>;<br>子网掩码255.255.255.254转换为二进制：11111111.11111111.11111111.11100000，<br>进行与运算得：<br>IP地址：  11000000.10101000.00000001. 00110101<br>子网掩码：  11111111.11111111.11111111. 11100000（子网掩码连续全1的是网络地址，后面的是主机地址）<br>11000000.10101000.00000001. 00100000&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;转换为十进制得：192.168.1.32<br>所以网络地址是192.168.1.32</p>
<h6 id="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"><a href="#六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）" class="headerlink" title="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"></a>六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）</h6><p>1.网络地址： 11000000.10101000.00000001. 00100000（标黄部分是网络地址），变为1得：11000000.10101000.00000001. 00111111</p>
<p>2.广播地址转换为十进制：192.168.1.63</p>
<h6 id="七、地址范围"><a href="#七、地址范围" class="headerlink" title="七、地址范围"></a>七、地址范围</h6><p>1.网络地址+1——-广播地址-1，得192.168.1.33—-192.168.1.62</p>
<h6 id="八、主机号（子网掩码取反再和IP做与运算）"><a href="#八、主机号（子网掩码取反再和IP做与运算）" class="headerlink" title="八、主机号（子网掩码取反再和IP做与运算）"></a>八、主机号（子网掩码取反再和IP做与运算）</h6></blockquote>
<p>将一个网络<strong>划分</strong>为多个子网(取部分<strong>主机号</strong>当子网号)<br>将多个网络<strong>合并</strong>为一个大的网络(取部分网络号当主机号)</p>
<h6 id="例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？"><a href="#例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？" class="headerlink" title="例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？"></a>例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？</h6><blockquote>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>168.195.0.0</td>
<td>1010 1000  1100 0011  0000 0000  0000 0000</td>
</tr>
</tbody></table>
<p>$2^R$ ≥ N；R&#x3D;5时 N&#x3D;32 ＞ 27<br><strong>网络位</strong>要向主机位借5位<br>该例中需27个子网，按公式，需借5位</p>
<p>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u><strong>1111 1</strong>000</u>  <u>0000 0000</u> → 255.255.248.0每个子网能容纳的有效主机数为$2^{11}-2$&#x3D;2046台<br>只要划分子网 就是变化的子网掩码 </p>
</blockquote>
<h6 id="例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的"><a href="#例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的" class="headerlink" title="例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？(这两个子网掩码是根据不同的条件而得到的)"></a>例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？<span style = "color : red">(这两个子网掩码是根据不同的条件而得到的)</span></h6><blockquote>
<p>$2^R$ ≥ N；N&#x3D;700；R&#x3D;10 也就是剩余10个零<strong>地址位(<strong>网络位)只要有10位就够了<br>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u>1111 11</strong>00</strong></u>  <u><strong>0000 0000</strong></u> → 255.255.252.0</p>
</blockquote>
<h6 id="无分类编址-无类域间路由"><a href="#无分类编址-无类域间路由" class="headerlink" title="无分类编址(无类域间路由)"></a>无分类编址(无类域间路由)</h6><p><span style = "color : red"><strong>IP地址 :: &#x3D; {&lt;网络前缀&gt;, &lt;主机号&gt;}</strong></span><br>128.14.32.0&#x2F;20 表示的地址块共有$2^{12}$个地址<br>这个地址块的起始地址是128.14.32.0<br>在不需要指出地址块的起始地址时，也可将这样的地址快简称位 “&#x2F;20地址块”<br>128.14.32.0&#x2F;20 地址块的最小地址：128.14.32.0<br>128.14.32.0&#x2F;20 地址块的最大地址：128.14.47.255<br>全0和全1的主机号地址一般不使用</p>
<h6 id="例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；"><a href="#例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；" class="headerlink" title="例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；"></a>例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；</h6><blockquote>
<p>C类地址 24个子网位  8个主机位，题目是&#x2F;20 前面20位为网络号；证明还要从主机号里拿出4个位来做子网号；4个位得到的子网数量是16个</p>
</blockquote>
<h3 id="特殊含义的IP地址"><a href="#特殊含义的IP地址" class="headerlink" title="特殊含义的IP地址"></a>特殊含义的IP地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee02b13442781213029e9fe8c188d1b53c790179/data/%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80.jpg"></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/4aedfd72e38d42a61b4be6086c218703360ec565/data/HTML.jpg"></p>
<h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>灵活性 移动性 成本低 容易扩充</p>
<h6 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h6><p>有接入点模式  无接入点模式(对等网模式)</p>
<blockquote>
<p>无线局域网(WLAN, 802.11, Wi-Fi)<br>无线城域网(WMAN, 802.16, WiMax)<br>无线广域网(WWAN, 3G&#x2F;4G)<br>无线个人网(WPAN, 802.15, Bluetooth)</p>
</blockquote>
<blockquote>
<h5 id="有线接入"><a href="#有线接入" class="headerlink" title="有线接入"></a>有线接入</h5><p>公用交换电话网络(PSTN) <u>原始拨号上网</u> pose机+传真<br>数字数据网(DDN) <u>数字专用网(专线)</u><br>综合业务数字网(ISDN) <u>允许打电话的时候上网</u><br>非对称数字用户线路(ADSL) <u>老旧小区电话线部署</u><br>同轴光纤技术(HFC) <u>家里有线电视</u></p>
</blockquote>
<blockquote>
<h6 id="无线接入"><a href="#无线接入" class="headerlink" title="无线接入"></a>无线接入</h6><p>IEEE 802.11(WiFi)<br>IEEE 802.15(蓝牙Bluetooth)<br>红外(IRDA)<br>WAPI</p>
</blockquote>
<blockquote>
<h6 id="3G-x2F-4G"><a href="#3G-x2F-4G" class="headerlink" title="3G&#x2F;4G"></a>3G&#x2F;4G</h6><p>WCDMA<br>CDMA2000<br>TD-SCDMA (国外多 速率低 功耗大)<br>LTE-Advanced<br>WirelessMAN-Advanceed(802.16m) (WiMAX)</p>
</blockquote>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPV6是设计用于替代现行版本IP协议(IPV4)的下一代IP协议。</p>
<blockquote>
<p>(1) IPV6地址长度位128位，地址空间增大了$2^{96}$倍<br>(2) 灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPV6中选项部分的出现方式也有所变化，使用路由器可以简单路过选项而不做任何处理，加快了报文处理速度<br>(3) IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量<br>(4) 提高安全性。身份认证和隐私权是IPv6的关键特性<br>(5) 支持更多的服务类型<br>(6) 允许协议继续演变，增加新的功能，使之适应未来技术的发展</p>
</blockquote>
<p>**单播地址(Unicast)**：用于单个接口的标识符<br>**任播地址(Anycast)**：泛播地址。一组接口的标识符，IPv4广播地址<br>**组播地址(Multicast)**：IPv6中的组播在功能上与IPv4中的组播类似</p>
<h3 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h3><h6 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h6><blockquote>
<p><strong>保密性</strong>：最小授权原则、防暴露、信息加密、物理加密<br><strong>完整性</strong>：安全协议、校验码、密码校验、数字签名、公证<br><strong>可用性</strong>：综合保障(IP过滤、业务流控制、路由选择控制、审计跟踪)<br><strong>不可抵赖性</strong>：数字签名</p>
</blockquote>
<h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a><span style = "color : red">加密技术</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e8808ad943a5c7fcaf7ae0ce3606fc214c3221/data/%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg"></p>
<h3 id="信息摘要-不能用作加密算法-因为不能解密-（无法篡改）"><a href="#信息摘要-不能用作加密算法-因为不能解密-（无法篡改）" class="headerlink" title="信息摘要(不能用作加密算法 因为不能解密) （无法篡改）"></a>信息摘要(不能用作加密算法 因为不能解密) （无法篡改）</h3><p>单向散列函数(<strong>单向Hash函数</strong>)、固定长度的散列值<br>常用的消息摘要算法有MD5、SHA等，市场上广泛使用的MD5，SHA算法的散列值分别为128和160位，由于SHA通常采用的密钥长度较长，因此安全性高于MD5</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>数字证书</strong>：识别人的身份</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/21de8ce0fc5a2872f99ac597d26aca426a8a436a/data/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" style="zoom:150%;" />



<h3 id="数字信封与PGP"><a href="#数字信封与PGP" class="headerlink" title="数字信封与PGP"></a>数字信封与PGP</h3><blockquote>
<p>发送方将原文用对称密钥加密传输，而将对称密钥用接收公钥加密发送給对方<br>接受方收到电子信封，用自己的私钥解密信封，取出对称密钥解密得原文</p>
</blockquote>
<blockquote>
<p>PGP可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括IDEA、RSA、MD5、ZIP数字压缩算法</p>
<p>PGP承认两种不同的证书格式：PGP证书和X.509证书</p>
<p>PGP证书包含PGP版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的数字签名、证书的有效期、密钥首选的对称加密算法</p>
<p>X.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据：证书发行商名字、证书主题名、<strong>主体公钥信息</strong>、发布者的数字签名</p>
</blockquote>
<h3 id="练习题-—-设计邮件加密系统"><a href="#练习题-—-设计邮件加密系统" class="headerlink" title="练习题 — 设计邮件加密系统"></a>练习题 — 设计邮件加密系统</h3><p>要求邮件以**<u>加密方式传输</u><strong>(<span style = "color : red"><em>加密解密技术</em></span>  )，邮件</strong><u>最大附件内容可达500MB</u><strong>( <em><span style = "color : red">对称加密</span></em>  )，</strong><u>发送者不可抵赖</u>** ( <em><span style = "color : red">数字签名</span></em>  )，若邮件被第三方截获，**<u>第三方无法篡改</u>** ( <em><span style = "color : red">信息摘要技术</span></em>  )。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/207ac6bb3d48784835bb4a14a2bcc0686739bf53/data/%E8%AE%BE%E8%AE%A1%E9%82%AE%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<h3 id="网络安全-—-各个网络层次的安全保障"><a href="#网络安全-—-各个网络层次的安全保障" class="headerlink" title="网络安全 — 各个网络层次的安全保障"></a>网络安全 — 各个网络层次的安全保障</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ebec2885b8f58a32cc399dcb2ba83803ea944fa3/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C.jpg"></p>
<h3 id="网络安全-—-网络威胁与攻击"><a href="#网络安全-—-网络威胁与攻击" class="headerlink" title="网络安全 — 网络威胁与攻击"></a>网络安全 — 网络威胁与攻击</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bfbf181924b0185e3567a2c2e020aca1b7e9341/data/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E4%B8%8E%E6%94%BB%E5%87%BB.jpg"></p>
<h3 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/805b5c52967e5ceefd47b195f8bce4ba3094c02c/data/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF.jpg"></p>
<h1 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a><span style = "color : red">数据结构与算法基础</span></h1><p>数组与矩阵、<strong>线性表</strong>、广义表、<strong>树与二叉树</strong>、图、<strong>排序与查找</strong>、<strong>算法基础及常见的算法</strong></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><table>
<thead>
<tr>
<th align="left">数组类型</th>
<th align="left">存储地址计算</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一维数组a[n]</td>
<td align="left">a[i]的存储地址为：a + i * len</td>
</tr>
<tr>
<td align="left">二维数组a[m] [n]</td>
<td align="left"><span style = "color : red"><strong>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len</strong></span><br /><span style = "color : red"><strong>a[i] [j]的存储地址(按列存储)：a + ( j * m + i) * len</strong></span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1 a[0] [0]</th>
<th>2 a[0] [1]</th>
<th>3 a[0] [2]</th>
</tr>
</thead>
<tbody><tr>
<td>4 a[1] [0]</td>
<td>5 a[1] [1]</td>
<td>6 a[1] [2]</td>
</tr>
<tr>
<td>7 a[2] [0]</td>
<td>8 a[2] [1]</td>
<td>9 a[2] [2]</td>
</tr>
</tbody></table>
<p>已知5行5列的二维数组a中的各元素占两个字节，求元素a[2] [3]按<strong>行</strong>优先存储的存储地址？</p>
<blockquote>
<p>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len<br> (2 * 5 + 3) * 2，a[2] [3]是存储的第14个元素，由于编号是从0开始算的，有13个偏移量<br>∴ a + 13 * 2 &#x3D; 每一个元素所占的字节数    a[0] [0] &#x3D; a</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
</tr>
</thead>
<tbody><tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"><span style = "color : red"><strong>√</strong></span></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e6036b61d33d357a06e724e93e01d06021ed088f/data/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.jpg" style="zoom:150%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是指互相之间存在一种或多种特定关系的数据元素的集合<br><strong>图</strong>包含<strong>树</strong>  <strong>树</strong>包含<strong>线性结构</strong></p>
<p><u>线性结构</u>  <strong>O-O-O-O</strong><br><u>非线性结构</u>  <strong>树 + 图</strong></p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><strong>顺序表</strong> + <strong>链表</strong>(单链表、循环列表、双向链表)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/b3c4a142e06c76bec4aa3e73894168a65b08f6d1/data/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9.jpg"  />



<h3 id="顺序存储与链式存储对比"><a href="#顺序存储与链式存储对比" class="headerlink" title="顺序存储与链式存储对比"></a>顺序存储与链式存储对比</h3><table>
<thead>
<tr>
<th align="left">性能类别</th>
<th align="left">具体项目</th>
<th align="left">顺序存储</th>
<th align="left">链式存储</th>
</tr>
</thead>
<tbody><tr>
<td align="left">空间性能</td>
<td align="left">存储密度</td>
<td align="left">&#x3D;1，更优 (1&#x3D;100%)</td>
<td align="left">&lt; 1 (<u>有节点专门存地址信息</u>)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">容量分配</td>
<td align="left">事先确定</td>
<td align="left">动态变化，更优 (<u>动态改变分配</u>)</td>
</tr>
<tr>
<td align="left">时间性能</td>
<td align="left">查找运算</td>
<td align="left">O(n&#x2F;2)</td>
<td align="left">O(n&#x2F;2)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">读运算</td>
<td align="left">O(1)，更优</td>
<td align="left">O([n+1]&#x2F;2), 最好情况为1，最坏情况为n  (需要一格一格的移)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">插入运算</td>
<td align="left">O(n&#x2F;2)，最好情况为O，最坏情况为n</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">删除运算</td>
<td align="left">O([n-1]&#x2F;2)</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
</tbody></table>
<h3 id="线性表—队列与栈"><a href="#线性表—队列与栈" class="headerlink" title="线性表—队列与栈"></a>线性表—队列与栈</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1a694cbb02c9afc6c9ee673f3b356d875c592b76/data/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"  />



<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><img src="https://raw.githubusercontent.com/P-luminary/images/61bf44a1acf06a88f7ad8469c6878d8c01c947ae/data/%E5%B9%BF%E4%B9%89%E8%A1%A8.jpg"  />



<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1638b875c12489816f5727597393ae6b4c559259/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/47e3cc81bfa782c8f11433d14042d25524d1d7ff/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%912.png"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e4a5b0f38017419dced3d5a0a580be16fc7f7d9a/data/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg"></p>
<h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea18aebfc2bb5b897ee4e065ea0e6328ba2d38aa/data/%E5%8F%8D%E5%90%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230710123815373.png"></p>
<h3 id="查找二叉树"><a href="#查找二叉树" class="headerlink" title="查找二叉树"></a>查找二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ca9dc0f534b3ff73fade234561af98443227670c/data/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="最优二叉树-哈夫曼树"><a href="#最优二叉树-哈夫曼树" class="headerlink" title="最优二叉树(哈夫曼树)"></a>最优二叉树(哈夫曼树)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e8133232bfff828b8fe77098f7fa9d7fca88b148/data/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91).jpg"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec2da880ff33e863050049acc335c60fb09f6e3b/data/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8848e420d3d2f38cfa13a2803afb39fba9249cc8/data/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树和图的最大区别：树是没有环路的"><a href="#树和图的最大区别：树是没有环路的" class="headerlink" title="树和图的最大区别：树是没有环路的"></a><span style = "color : red"><strong>树和图的最大区别：树是没有环路的</strong></span></h3><h3 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea8055908dec7f2d988a189da12eeced78a34fb7/data/%E5%9B%BE%2B%E5%9B%BE%E5%AD%98%E5%82%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg"></p>
<h3 id="邻接图"><a href="#邻接图" class="headerlink" title="邻接图"></a>邻接图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0e743eb4f3e6db6334e95e915528a12ac68514a2/data/%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg"></p>
<h3 id="图的遍历-深度-广度"><a href="#图的遍历-深度-广度" class="headerlink" title="图的遍历(深度+广度)"></a>图的遍历(深度+广度)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7cf480efb37be3cf903977972770cb46f88a1015/data/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(%E6%B7%B1%E5%BA%A6%2B%E5%B9%BF%E5%BA%A6).jpg"></p>
<h3 id="图-—-拓扑排序"><a href="#图-—-拓扑排序" class="headerlink" title="图 — 拓扑排序"></a>图 — 拓扑排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8f52549404943f522f10d2bfefbefbd15bb3bfba/data/%E5%9B%BE%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="图的最小生成树-—-普里姆算法"><a href="#图的最小生成树-—-普里姆算法" class="headerlink" title="图的最小生成树 — 普里姆算法"></a>图的最小生成树 — 普里姆算法</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/48563077b3612e0a2288fb24c5f78d0082384f8d/data/%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.jpg"></p>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p><strong>有穷性</strong>：执行有穷步之后结束<br><strong>确定性</strong>：算法中每一条指令都必须有确切的含义，不能含糊不清<br><strong>输入</strong>：(&gt;&#x3D;0)<br><strong>输出</strong>：(&gt;&#x3D;1)<br><strong>有效性</strong>：算法的每个步骤都能有效执行并能得到确定的结果。例a&#x3D;0, b&#x2F;a就无效</p>
<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><p><strong><span style = "color : red">时间复杂度</span><strong>：是指程序运行从开始到结束所需要的时间。通常分析时间复杂度的方法是从算法中选取一种对于所研究的问题来说是基本运算的操作，以该操作重复执行的次数作为算法的时间量度。一般来说，算法中原操作重复执行的次数是规模n的某个函数T(n)。由于许多情况下要精密计算T(n)是困难的，因此引入了渐进时间复杂度在数量上估计一个算法的执行时间。其定于如下：<br>如果存在两个常数c和m，对于所有的n，当n≥m时有f(n) ≤ cg(n), 则有f(n) &#x3D; O(g(n))，也就是说，随着n的增大，f(n)逐进地不大于g(n)。例如，</strong>一个程序的实际执行时间为T(n)&#x3D;3$n^3$+2$n^2$+n, 则T(n) &#x3D; O($n^3$)</strong>  [以最高的时间复杂度为准！三重for循环时间复杂度是O($n^3$)]</p>
<p><span style = "color : orange"><strong>常见的对算法执行所需时间的量度：</strong></span><br><strong>O(1) &lt; O(lo$g_2$n) &lt; O(n) &lt; O(nlo$g_2$n) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$)</strong></p>
<blockquote>
<p><strong>log的由来</strong>：排序二叉树 找结点 有7个结点的完全二叉树，向下比较 最多比较3次(二叉树的层数) 最坏的情况多少层就比较多少次 所以有<strong>lo$g_2$n</strong>，n就是结点数量</p>
</blockquote>
<p>**<span style = "color : red">空间复杂度：</span>**是指对一个算法在运行过程中临时占用存储空间大小的度量。一个算法的空间复杂度<u><strong>只考虑在运行过程中为局部变量分配的存储空间的大小</strong></u>。</p>
<h3 id="查找-—-顺序查找与二分查找"><a href="#查找-—-顺序查找与二分查找" class="headerlink" title="查找 — 顺序查找与二分查找"></a>查找 — 顺序查找与二分查找</h3><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.jpg"  />



<h3 id="查找-—-散列表"><a href="#查找-—-散列表" class="headerlink" title="查找 — 散列表"></a>查找 — 散列表</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0098e5cad58ccd31a685f565826e8e8832772252/data/%E6%95%A3%E5%88%97%E8%A1%A8.jpg"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6f3e15053fbfd4f677ad2bc4d3e415a22676631d/data/%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f95845259682927312a2712c8786baa1659e1f52/data/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="希尔排序-效率高于直接插入排序"><a href="#希尔排序-效率高于直接插入排序" class="headerlink" title="希尔排序(效率高于直接插入排序)"></a>希尔排序(效率高于直接插入排序)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/85ce49aa669297ebbfd9656a75bc09f78d3b7b5d/data/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230718181340677.png"></p>
<h3 id="堆排序-适合于：不需要求全部-求前一部分"><a href="#堆排序-适合于：不需要求全部-求前一部分" class="headerlink" title="堆排序(适合于：不需要求全部 求前一部分)"></a>堆排序(适合于：不需要求全部 求前一部分)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2972cd322a1e9d4649529aa4e8a98073de6e2de3/data/%E5%A0%86%E6%8E%92.png.jpg" style="zoom:150%;" />



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2969db8aafbafae291aa4e96a9c8391862ca0ab8/data/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" style="zoom:150%;" />



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9a50aee5775d1ca1a8a993d3d0847599d7b52020/data/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/27b826e69885dcb01132ea63609668073c020e2a/data/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dad7782ee80e0729e01210b493c6bf596363784/data/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="算法排序汇总"><a href="#算法排序汇总" class="headerlink" title="算法排序汇总"></a>算法排序汇总</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8e615d2e7034d2bdffafcd507cb102e0fbf9c72e/data/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.jpg" style="zoom:150%;" />



<h1 id="程序设计语言与语言处理程序"><a href="#程序设计语言与语言处理程序" class="headerlink" title="程序设计语言与语言处理程序"></a>程序设计语言与语言处理程序</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/98ebae6a55bb6b68dc4500674cc321737f4cd169/data/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8ee259fcd72bc7b48ab89100ce84af30cb560bfd/data/%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%8E%A8%E5%AF%BC%E6%A0%91.jpg" style="zoom: 150%;" />



<h3 id="有限自动机与正规式"><a href="#有限自动机与正规式" class="headerlink" title="有限自动机与正规式"></a>有限自动机与正规式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ed582973635f109925c4a9ead6047f0e51cf3c6f/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E8%A7%84%E5%BC%8F.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/e961e9530911c0115ffea4127e991575bbcaf5a0/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%BE%8B%E9%A2%98.jpg" style="zoom:150%;" />



<h3 id="程序语言基础—表达式"><a href="#程序语言基础—表达式" class="headerlink" title="程序语言基础—表达式"></a>程序语言基础—表达式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ee55ff5d4ec9b9745f6a8ad4c37066449e0dee96/data/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" style="zoom:150%;" />



<h3 id="函数调用—传值与传址"><a href="#函数调用—传值与传址" class="headerlink" title="函数调用—传值与传址"></a>函数调用—传值与传址</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9cbd1c801ae0a7fcabad837813854de5e63feffe/data/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82.jpg"  />



<h3 id="程序语言基础—各种程序语言特点"><a href="#程序语言基础—各种程序语言特点" class="headerlink" title="程序语言基础—各种程序语言特点"></a>程序语言基础—各种程序语言特点</h3><p><strong>Fortran语言</strong>(科学计算，执行效率高)<br><strong>Pascal语言</strong>(为教学而开发的，表达能力强，Delphi)<br><strong>C语言</strong>(指针操作能力强，高效)<br><strong>Lisp语言</strong>(函数式程序语言，符号处理，人工智能)<br><strong>C++语言</strong>(面向对象，高效)<br><strong>Java语言</strong>(面向对象，中间代码，跨平台)<br><strong>C#语言</strong>(面向对象，中间语言，.Net)<br><strong>Prolog语言</strong>(逻辑推理，简洁性，表达能力，数据库和专家系统)</p>
<h3 id="法律法规-—-课程内容提要"><a href="#法律法规-—-课程内容提要" class="headerlink" title="法律法规 — 课程内容提要"></a>法律法规 — 课程内容提要</h3><h5 id="从所涉及的法律法规角度"><a href="#从所涉及的法律法规角度" class="headerlink" title="从所涉及的法律法规角度"></a>从所涉及的法律法规角度</h5><p>著作权法、计算机软件保护条例、商标法、专利法</p>
<p>@@ 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发便，所以甲对该软件作品享有著作权，乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权</p>
<p>@@ 关于软件著作权产生的时间是<strong>自作品完成创作之日</strong></p>
<h5 id="从试题考点分布的角度"><a href="#从试题考点分布的角度" class="headerlink" title="从试题考点分布的角度"></a><span style = "color :red">从试题考点分布的角度</span></h5><p>保护期限、知识产权人确定、侵权判断</p>
<blockquote>
<p><strong>知识产权</strong>：<br>著作权及邻接权、专利权、工业品外观设计权、商标权、地理标志权、集成电路布图设计权</p>
<p><u>著作权</u>：一般保护作者的利益<br><u>邻接权</u>：别人盗写我出的书，不仅破坏了我的权益，还有**<u>出版商</u><strong>的权益<br><u>地理标志权</u>：</strong>新疆**哈密瓜 只有在标志的地理位置生产(这一区域都拥有)</p>
</blockquote>
<h3 id="法律法规-—-保护期限-知识产权人"><a href="#法律法规-—-保护期限-知识产权人" class="headerlink" title="法律法规 — 保护期限, 知识产权人"></a>法律法规 — 保护期限, 知识产权人</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0d498a6b717c3dfd41334e8799dc508e5a7d4e8c/data/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%BF%9D%E6%8A%A4%E6%9C%9F%E9%99%90%2C%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%BA%BA.jpg" style="zoom:150%;" />



<h3 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h3><h5 id="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"><a href="#中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权" class="headerlink" title="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"></a>中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权</h5><h5 id="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"><a href="#开发软件所用的思想、处理过程、操作方法或者数学概念不受保护" class="headerlink" title="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"></a>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</h5><h6 id="著作权法不适用于下列情形："><a href="#著作权法不适用于下列情形：" class="headerlink" title="著作权法不适用于下列情形："></a>著作权法不适用于下列情形：</h6><p>√ 法律、法规、国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文</p>
<p>√ 时事新闻</p>
<p>√ 历法、通用数表、通用表格和公式</p>
<table>
<thead>
<tr>
<th>不侵权</th>
<th>侵权</th>
</tr>
</thead>
<tbody><tr>
<td>√ 个人学习、研究或欣赏<br />√ 适当引用<br />√ 公开演讲内容<br />√ 用于教学或科学研究<br />√ 复制馆藏作品<br />√ 免费表演他人作品<br />√ 室外公共场所艺术品临摹、绘画、摄影、录像<br />√ 将汉语作品译成少数民族语言作品或盲文出版</td>
<td>√ 未经许可，发表他人作品<br />√ 未经合作作者许可，将与他人合作创作的作品当作自己单独创作的作品发表的<br />√ 未参加创作，在他人作品署名<br />√ 歪曲、篡改他人作品<br />√ 剽窃他人作品的<br />√ 使用他人作品，未付报酬<br />√ 未经出版者许可，使用其出版的图书、期刊的版式设计的</td>
</tr>
</tbody></table>
<h3 id="标准化基础知识—标准的分类"><a href="#标准化基础知识—标准的分类" class="headerlink" title="标准化基础知识—标准的分类"></a>标准化基础知识—标准的分类</h3><p>√ 国际标准：ISO、IEC等国际标准化组织<br>√ 国家标准：GB—中国、ANSI—美国、BS—英国、JIS—日本<br>√ 区域标准：又称为地区标准，如PASC—太平洋地区标准会议、CEN—欧洲标准委员会、ASAC—亚洲标准咨询委员会、ARSO—非洲地区标准化组织<br>√ 行业标准：GJB—中国军用标准、MIT-S—美国军用标准、IEEE—美国电气电子工程协会<br>√ 地方标准：国家的地方一级行政机构制订的标准<br>√ 企业标准<br>√ 项目规范</p>
<p>→ 国标、国外标准代号：标准代号+专业类号+顺序号+年代号<br>→ 我国国家标准代号：强制性代号为GB、推荐性标准代号为GB&#x2F;T、指导性标准代号为GB&#x2F;Z、实物标准代号GSB</p>
<p>→ 行业标准代号：由汉语拼音大写字母组成(如电子行业为SJ)<br>→ 地方标准代号：由DB加上省级行政区划代码的前两位<br>→ 企业标准代号：由Q加上企业代号组成</p>
<h1 id="多媒体基础"><a href="#多媒体基础" class="headerlink" title="多媒体基础"></a>多媒体基础</h1><p>人耳：<strong>20Hz—20kHz</strong>  <u>小于20Hz是次声波 大于20kHz是超声波</u><br>说话：300—3400Hz<br>乐器：20Hz —20kHz<br>白噪音：20 ~ 20kHz</p>
<p><strong>采样</strong>：采样频率、采样精度、采样频率应为声音最高频率的2倍</p>
<blockquote>
<p><strong>采样点密</strong>集程度越高，时间间隔越短，还原度越好<br><strong>采样精度</strong>画格子的数量 y轴平行于x做直线</p>
</blockquote>
<h3 id="图像相关概念"><a href="#图像相关概念" class="headerlink" title="图像相关概念"></a>图像相关概念</h3><h4 id="色彩三要素色"><a href="#色彩三要素色" class="headerlink" title="色彩三要素色"></a>色彩三要素色</h4><p><strong>亮度</strong>是光作用于人眼时所引起的明亮程度的感觉，它与被观察物体的发光强度有关。<br><strong>色相</strong>是当人眼看一种或多种波长的光时所产生的彩色感觉，它反映颜色的种类，是决定颜色的基本特性。<br><strong>饱和度</strong>是指颜色的纯度，也可以叫做纯度、彩度或浓度等，即掺入白光的程度，或者是指颜色的深浅程度。</p>
<blockquote>
<p><strong>HSB彩色模式</strong><br>是根据日常生活中人眼的视觉特征而制定的一套色彩模式。HSB颜色模式以色相、饱和度和亮度描述颜色的基本特征。</p>
<p><strong>CMY颜色模式</strong><br>是采用**青(Cyan、品红或洋红(Magenta)、黄(Yellow)**3种基本颜色按一定比例合成颜色的方法。颜色的产生是来自于照射在颜料上反射回来的光线。<br>图像打印输出时用CMY颜色模式。</p>
<p><strong>Lab颜色模式</strong><br>分别用**亮度或光亮度分量(Luminosity)和两个色度分量(a、b)**来表示颜色<br>L表示亮度。L的值域由0到100，L&#x3D;50时，相当于50%的黑。<br>a表示从洋红色至绿色的范围，<br>b表示从黄色至蓝色的范围，<br>a和b的值域是由+127至-128。</p>
<p><strong>索引颜色模式</strong><br>最多使用256种颜色，当图像被转换为索引颜色模式时，通常会构建一个<strong>调色板存放图像中的颜色并编制颜色索引。</strong></p>
<p><strong>位图模式</strong><br>位图模式的图像只有<strong>黑色与白色两种像素</strong>，每个像素用1位二进制数表示,”0”表示黑色,“1”表示白色。</p>
<p><strong>灰度模式</strong><br>用单一色相表现图像，最多使用256级。图像中的每个像素有一个0(黑色)～255(白色)之间的亮度值。此外，灰度值也可以用黑色油墨覆盖的百分比来表示(0%表示白色，100%表示黑色)。</p>
<p><strong>颜色深度</strong><br>位图图像中各像素的颜色信息是用二进制数据描述的。<br><strong>色彩由颜色深度决定，不是分辨率</strong><br><strong>二进制的位数就是位图图像的颜色深度。颜色深度决定了图像中可以呈现的颜色的最大数目。</strong></p>
<p><strong>分辨率:</strong><br>图像分辨率(Image Resolution):指单位图像线性尺寸中所包含的像素数目，通常以**像素&#x2F;英寸(pixel per inch,ppi)**为计量单位。</p>
</blockquote>
<h6 id="彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度"><a href="#彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度" class="headerlink" title="彩色空间：RGB彩色显示器、YUV(电视, 兼容方案)、CMY[K黑]、HSV(HSB)艺术家角度"></a>彩色空间：RGB<del>彩色显示器</del>、YUV(电视, 兼容方案)、CMY[K<del>黑</del>]、HSV(HSB)<del>艺术家角度</del></h6><p><strong>光的颜色</strong>采取叠加原理<br><strong>印刷的三原色</strong>采取相减原理</p>
<h3 id="媒体的种类"><a href="#媒体的种类" class="headerlink" title="媒体的种类"></a>媒体的种类</h3><p><strong>感觉媒体</strong>，指通过人的感觉器官能<u>直接感受的媒体</u>，如视觉。<br><strong>表示媒体</strong>，用于传播和表达感觉媒体的中介媒体，是信息的表示和表现形式，如<u>JPG编码</u><br><strong>表现媒体</strong>(显示媒体)，是进行信息输入和输出的一类媒体，如<u>显示器</u><br><strong>传输媒体</strong>，是用于通信传输的信息载体，如<u>双绞线</u>。<br><strong>存储媒体</strong>，是存放表示媒体的物理实体，如<u>光盘</u></p>
<blockquote>
<p><strong>感觉</strong>媒体：听觉、触觉、嗅觉；<br><strong>表示</strong>媒体：文字、数字、音频、视频、编码方式；<br><strong>表现</strong>媒体(显示媒体)：输入显示媒体键盘、鼠标和麦克风、输出显示媒体显示器、打印机和音箱<br><strong>存储</strong>媒体：存储数据的物理设备，硬盘、磁盘、光盘U盘<br><strong>传输</strong>媒体：存储数据的物理载体，电缆、光缆和交换设备</p>
</blockquote>
<ul>
<li>D&#x2F;A转换，<strong>数字</strong>音频<strong>模拟</strong>化输出</li>
</ul>
<h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><ul>
<li><strong>波形音频文件容量的计算</strong>  <span style = "color : red"><u>容量&#x3D;声道数 * 采样频率 * 量化位数 * 长度 &#x2F; 8</u></span><br>其中频率单位Hz，量化单位bit，长度秒，容量单位字节B</li>
<li><strong>波形音频文件码率的计算</strong>  <u>码率&#x3D;声道数 * 采样频率 * 量化位数</u>  码率的单位是bps</li>
</ul>
<h5 id="常见波形文件格式"><a href="#常见波形文件格式" class="headerlink" title="常见波形文件格式"></a>常见波形文件格式</h5><ul>
<li>&#x3D;&#x3D;<strong>.wav</strong>&#x3D;&#x3D; 微软和IBM共同开发的PC标准音频格式，未压缩，声音达到CD音质，码率约为1.4Mb&#x2F;s，Windows XP录音机默认音频格式</li>
<li><strong>.mp3</strong> 有损压缩，最常用  互联网、MP3音乐</li>
<li>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</li>
<li><strong>.m4a</strong> 苹果公司的无损压缩</li>
<li><strong>.flac</strong> 无损压缩，高品质数字音乐</li>
<li><strong>.ape</strong> 无损压缩音频格式</li>
</ul>
<p>@@ WAV文件称为波形声音文件，其音质与CD差不多<br>@@ MP3文件能够达到很高的压缩比，并能<strong>保持较高</strong>的音质；通常那个说WAV文件比MP3文件大[比WAV&#x2F;CD好]<br>@@ MIDI不能从CD、磁带、麦克风等录制MIDI文件；通常MIDI文件小于MP3</p>
<h5 id="MIDI格式"><a href="#MIDI格式" class="headerlink" title="MIDI格式"></a>MIDI格式</h5><ul>
<li>MIDI乐器数字接口，垫桌子音乐制造商们建立的通信标准</li>
<li>MIDI传输的不是声音信号，记录声音的信息，是在线音乐的一组指令，是音符、控制参数等指令，它指示MIDI设备要做什么，怎么做; 如演奏哪个音符，音量多大等</li>
<li>.mid 或 .midi</li>
</ul>
<blockquote>
<h2 id="x3D-x3D-知识点总结-x3D-x3D"><a href="#x3D-x3D-知识点总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;知识点总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;知识点总结&#x3D;&#x3D;</h2><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li><strong>位图</strong>：.bmp<del>不压缩</del>    .gif<del>无损压缩</del>    .jpg&#x2F;jpeg<del>有损压缩</del>    .png<del>无损压缩</del>    .tif</li>
<li><strong>矢量图</strong>：.swf    .ai    .dwg    .cdr</li>
</ul>
<h4 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h4><ul>
<li><p>.wav    .mp3<del>有损压缩</del>    .wma<del>有损压缩：录音机(微软)</del>    </p>
</li>
<li><p>.m4a<del>无损压缩(苹果)</del>    .flac<del>无损压缩(高质量数字音乐)</del>    .ape<del>无损压缩音频</del></p>
</li>
<li><p>MIDI [.mid&#x2F;.midi]<del>乐谱</del></p>
</li>
</ul>
<h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><ul>
<li>.mpeg&#x2F;.mp4    H.26X    .avi    .asf    .wmv    .rm&#x2F;.rmvb    .flv    .mkv    .mov</li>
</ul>
<h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><ul>
<li>RM、WMV、ASF</li>
</ul>
</blockquote>
<h2 id="音频信息在计算机中的表示"><a href="#音频信息在计算机中的表示" class="headerlink" title="音频信息在计算机中的表示"></a>音频信息在计算机中的表示</h2><h4 id="波形数字音频"><a href="#波形数字音频" class="headerlink" title="波形数字音频"></a>波形数字音频</h4><h5 id="音频信息处理的流程"><a href="#音频信息处理的流程" class="headerlink" title="音频信息处理的流程"></a>音频信息处理的流程</h5><ul>
<li>A&#x2F;D转换[<strong>采样</strong>]，模拟音频的数字化【影响数字化质量的主要原因】</li>
</ul>
<h3 id="多媒体相关计算问题"><a href="#多媒体相关计算问题" class="headerlink" title="多媒体相关计算问题"></a>多媒体相关计算问题</h3><h6 id="图像容量计算640-水平像素-×480-垂直像素"><a href="#图像容量计算640-水平像素-×480-垂直像素" class="headerlink" title="图像容量计算640(水平像素)×480(垂直像素)"></a>图像容量计算<del>640(水平像素)×480(垂直像素)</del></h6><p>颜色深度的单位是 “位 bit “<strong>，</strong>图像容量的单位是字节B； <strong>1 Byte &#x3D; 8 Bits</strong></p>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">知道<strong>像素，位数</strong></td>
<td align="center">每个像素为16位，图像位640×480像素，求容量：<br />640×480×16÷8&#x3D;614400B</td>
</tr>
<tr>
<td align="center">知道<strong>像素，色数</strong></td>
<td align="center">640×480像素，256色的图像，求容量：<br />640×480×log<del>2</del>(256)÷8&#x3D;307200B</td>
</tr>
</tbody></table>
<h6 id="音频容量计算"><a href="#音频容量计算" class="headerlink" title="音频容量计算"></a><strong>音频</strong>容量计算</h6><p>音频<span style = "color : red"><u>容量 &#x3D; 声道数 * 采样频率(Hz) * 量化位数 * 长度 &#x2F; 8</u></span> </p>
<h6 id="视频容量计算"><a href="#视频容量计算" class="headerlink" title="视频容量计算"></a>视频容量计算</h6><p>视频<u><span style = "color : red">容量 &#x3D; 每帧图像容量(Byte) * 每秒帧数 * 时间 + 音频容量 * 时间</span></u> </p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f98d8d3c2a788f0999bdbeee030b01b7a9bfd1dd/data/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%B8%B8%E8%A7%81%E8%AE%A1%E7%AE%97%E9%A2%98.jpg" style="zoom: 200%;" />



<h3 id="常见的多媒体标准"><a href="#常见的多媒体标准" class="headerlink" title="常见的多媒体标准"></a>常见的多媒体标准</h3><img src="https://raw.githubusercontent.com/P-luminary/images/82d3b6184da3dd2184662eebdcfb18c792f1fbb8/data/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E5%87%86.jpg" style="zoom:150%;" />

<p>&#x3D;&#x3D;@@ <strong>存储动画</strong>的文件格式有<strong>FLC、GIF、SWF</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>网络视频格式</strong>包括<strong>MOV、RM、ASF、WMV</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>多媒体视频图像文件</strong>格式有<strong>AVI、MPG、ASF、MP4</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>声音、音频文件</strong>格式有<strong>WAV、WMA、MP3、MIDI、RA、APE</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ 属于<strong>图像文件</strong>格式有<strong>GIF、BMP、JPG、PNG、TIF</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</p>
</blockquote>
<p>@@ 位图（Bitmap）&#x3D;&gt; <strong>BMP</strong></p>
<p>@@ <strong>语音识别技术</strong>体现了<u><strong>多媒体技术</strong>与<strong>人工智能技术</strong></u>相结合</p>
<h3 id="数据压缩基础"><a href="#数据压缩基础" class="headerlink" title="数据压缩基础"></a>数据压缩基础</h3><h6 id="空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"><a href="#空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余" class="headerlink" title="空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"></a>空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余</h6><blockquote>
<p>空间冗余：图片大面积相同色(白色)，记录哪些信息是白色<br>时间冗余：固定在一个界面跳舞时，后面的物体不会动，墙面不会动。不动的记录下来。有变动的就分析<br>视觉冗余：jpeg人眼视觉识别盲区(视觉边界点压缩)<br>信息熵冗余：不同的信息编码冗余度不一样，通过合理的信息编码<br>结构冗余：某个部件有大量冗余，地砖花纹一样<br>知识冗余：可以通过知识分析得到的信息</p>
</blockquote>
<h3 id="有损压缩与无损压缩"><a href="#有损压缩与无损压缩" class="headerlink" title="有损压缩与无损压缩"></a>有损压缩与无损压缩</h3><p><strong>无损压缩编码法</strong>(Lossless compression coding)：也称之为**<u>冗余压缩法</u><strong>或</strong><u>熵编码法</u>**<br><strong>有损压缩编码法</strong>(Loss compression coding)：**<u>熵压缩法</u>**</p>
<p>jpeg属于有损(比较高的<strong>压缩比</strong>)，无法还原成原始图(位图)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/29624beeddd6478ad781db7390d2f5f06ef4b077/data/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9.jpg" style="zoom:150%;" />



<h1 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a><span style = "color : red">软件开发模型</span></h1><h6 id="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"><a href="#瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型" class="headerlink" title="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"></a>瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型</h6><h6 id="迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"><a href="#迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法" class="headerlink" title="迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"></a>迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法</h6><p>@@ 在面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是<strong>重构</strong>，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为</p>
<h3 id="瀑布模型-SDLC"><a href="#瀑布模型-SDLC" class="headerlink" title="瀑布模型(SDLC)"></a>瀑布模型(SDLC)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/edf996ef9e67822a8fd47b5bb4d82cc0e27df1cc/data/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="原型、演化模型、增量模型"><a href="#原型、演化模型、增量模型" class="headerlink" title="原型、演化模型、增量模型"></a>原型、演化模型、增量模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4192bb3614abbf4dc5fba19b3579e89f2c9733e5/data/%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 200%;" />



<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/bf416fffe7f4d6101f0f259d902725345b8b7073/data/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="V模型-喷泉模型-RAD"><a href="#V模型-喷泉模型-RAD" class="headerlink" title="V模型 喷泉模型 RAD"></a>V模型 喷泉模型 RAD</h3><img src="https://raw.githubusercontent.com/P-luminary/images/cfa6ef57982d81474f45287c3473d6a78b7cac94/data/V%E6%A8%A1%E5%9E%8B%2CRAD%E6%A8%A1%E5%9E%8B%2C%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="构件组装模型-CBSD"><a href="#构件组装模型-CBSD" class="headerlink" title="构件组装模型(CBSD)"></a>构件组装模型(CBSD)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b7dbdfdbadf9e20a5a654b763c50c504059633a6/data/%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B(CBSD).jpg" style="zoom:150%;" />



<h3 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a6d4004b4a88b542a3b60744ea61fa0bc0286a38/data/%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="敏捷开发方法"><a href="#敏捷开发方法" class="headerlink" title="敏捷开发方法"></a>敏捷开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/094d4931d137335862a4652dda044769f4724e11/data/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e9941766b405f6b796c6ad35cf1d00c8dd5e52ec/data/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="需求分类与需求获取"><a href="#需求分类与需求获取" class="headerlink" title="需求分类与需求获取"></a>需求分类与需求获取</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0e7091e237ecadc19e2e7b191c975f4d22a2e920/data/%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%B8%8E%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96.jpg" style="zoom:150%;" />



<h3 id="结构化设计：基本原则、内聚与耦合"><a href="#结构化设计：基本原则、内聚与耦合" class="headerlink" title="结构化设计：基本原则、内聚与耦合"></a>结构化设计：基本原则、内聚与耦合</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dbfbb4b62414e0f7badb40473f22b0df8078b24/data/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2B%E5%86%85%E8%81%9A%E8%80%A6%E5%90%88.jpg"  />



<h3 id="结构化设计-—-系统结构-x2F-模块结构"><a href="#结构化设计-—-系统结构-x2F-模块结构" class="headerlink" title="结构化设计 — 系统结构&#x2F;模块结构"></a>结构化设计 — 系统结构&#x2F;模块结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a003e2c14ea40399387d9f05450bba7019dd4893/data/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E3%80%81%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.jpg"  />



<h3 id="软件测试-—-测试原型与类型"><a href="#软件测试-—-测试原型与类型" class="headerlink" title="软件测试 — 测试原型与类型"></a>软件测试 — 测试原型与类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b84b307d4d1b5810ceddc7301b06ba3c7717ccda/data/%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="软件测试-—-测试用例设计"><a href="#软件测试-—-测试用例设计" class="headerlink" title="软件测试 — 测试用例设计"></a>软件测试 — 测试用例设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/46ed2bab41cbcb40fafbbaa2487b58c157668a67/data/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="软件测试-—-测试阶段"><a href="#软件测试-—-测试阶段" class="headerlink" title="软件测试 — 测试阶段"></a>软件测试 — 测试阶段</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d20a8c0ee445282402c3922a6bf949584ba9f08f/data/%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="McCabe复杂度"><a href="#McCabe复杂度" class="headerlink" title="  McCabe复杂度"></a><span style = "color:red">  McCabe复杂度</span></h3><p>McCabe度量法概念：</p>
<p>McCabe度量法是通过定义环路复杂度，建立程序复杂度的度量，他是基于一个程序模块的程序图中环路的个数。计算G的环路复杂型有两种方法：<br><strong>第一种是<span style = "color:red">V(G)&#x3D;m-n+2（m值得是有向弧数，也就是箭头的个数，n指的是结点个数</span></strong><br><strong>另外一种求法就是<span style = "color:red">闭合区域的个数+1</span></strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/1a9f9515b1e11b17d0b83762ee9bd874c8d450fd/data/McCadbe%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg"  /></p>
<h3 id="系统运行与维护"><a href="#系统运行与维护" class="headerlink" title="系统运行与维护"></a>系统运行与维护</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/44f90a15642e6a63893cbd9523466090a2d41f60/data/%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4.jpg"></p>
<h3 id="软件过程改进—CMMI"><a href="#软件过程改进—CMMI" class="headerlink" title="软件过程改进—CMMI"></a>软件过程改进—CMMI</h3><img src="https://raw.githubusercontent.com/P-luminary/images/555421c326e1c60558f4b1b0f7a2ce5cfd35dbbc/data/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B%E2%80%94CMMI.jpg" style="zoom:150%;" />



<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e4485104aee8d683f76cb7a54045d9308e260f70/data/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2B%E4%BE%8B%E9%A2%98.jpg"  />



<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><h6 id="风险是指”损失或伤害的可能性”"><a href="#风险是指”损失或伤害的可能性”" class="headerlink" title="风险是指”损失或伤害的可能性”"></a>风险是指”损失或伤害的可能性”</h6><p><u>软件风险一般包含<strong>不确定性</strong>和<strong>损失</strong></u>。<u><strong>救火</strong>和<strong>危机管理</strong>是对不适合但经常采用的软件风险管理策略</u>，<u><strong>已知风险</strong>和<strong>未知风险</strong>是对软件风险进行分类的一种方式</u>。<u><strong>员工</strong>和<strong>预算</strong>是在识别项目风险时需要识别的因素</u></p>
<p><strong>项目风险(关心未来)、技术风险(关心变化)、商业风险(关心选择)</strong><br><strong>风险曝光度(Risk Exposure)<strong>：计算方法是</strong>风险出现的概率 × 风险可能造成的损失</strong><br>假设正在开发的软件项目可能存在一个未被发现的错误，而这个错误出现的概率是0.5%，给公司造成的损失将是1000000元，那么这个错误的<strong>风险曝光度</strong>就应该为1000000×0.5%&#x3D;5000元</p>
<h3 id="需求开发-需求分析-OOA-—-相关概念"><a href="#需求开发-需求分析-OOA-—-相关概念" class="headerlink" title="需求开发,需求分析,OOA — 相关概念"></a>需求开发,需求分析,OOA — 相关概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9539033cf94cba3e4edaef3098f61e7ccc9704ea/data/%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91%2C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.OOA.jpg" style="zoom:150%;" />



<h3 id="面向对象设计-—-设计原则"><a href="#面向对象设计-—-设计原则" class="headerlink" title="面向对象设计 — 设计原则"></a>面向对象设计 — 设计原则</h3><p><strong>单一职责原则</strong>：设计目的单一的类 (单一会降低程序的耦合度)<br><strong>开放—封闭原则</strong>: 对<u>扩展</u>开放，对<u>修改</u>封闭 (用新的类去解决问题 不去修改[容易引入错误影响原先])<br><strong>李氏(Liskov)替换原则</strong>：子类可以替换父类 (不要盲目修改父类 不要去<strong>重载</strong>)<br><strong>接口隔离原则</strong>：使用多个专门的接口比使用单个的总接口要好<br><strong>组合重用原则</strong>：要尽量使用组合，而不是继承关系达到重用的目的<br>**迪米特(Demeter)原则(最少知识法则)**：一个对象应当对其他对象又尽可能少的了解  </p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><img src="https://raw.githubusercontent.com/P-luminary/images/fcb3f16cbb5d336b7895d58d40e877ff57652b4e/data/UML.jpg" style="zoom:150%;" />



<h3 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h3><p>**<u>√ 架构模式</u>**：软件设计中的高层决策，例如C&#x2F;S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策<br>**<u>√ 设计模式</u>**：主要关注软件系统的设计，与具体的实现语言无关<br>**<u>√ 惯用法</u>**：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用—计数就是C++语言中的一种惯用法 </p>
<h3 id="面向对象-—-设计模式的分类"><a href="#面向对象-—-设计模式的分类" class="headerlink" title="面向对象 — 设计模式的分类"></a>面向对象 — 设计模式的分类</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9012605b3052dcc5d44c980ca3cac2f2f206697d/data/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB.jpg" style="zoom:150%;" />



<h3 id="面向对象-—-创建型模式"><a href="#面向对象-—-创建型模式" class="headerlink" title="面向对象 — 创建型模式"></a>面向对象 — 创建型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abstract Factory 抽象工厂模式</td>
<td>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需置顶它们具体的类</td>
</tr>
<tr>
<td>Builder 构建器模式</td>
<td>将一个复杂类的表示与其构造相分离，使得相同的构造过程能够得出不同的表示</td>
</tr>
<tr>
<td>Factory Method 工厂方法模式</td>
<td>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工程方法使得子类实例化的过程推迟</td>
</tr>
<tr>
<td>Prototype 原型模式</td>
<td>用原型实例指定创建对象的类型，并且通过拷贝这个原型来<strong>创建新的对象</strong></td>
</tr>
<tr>
<td>Singleton 单例模式</td>
<td>保证一个类只有一个实例，并提供一个访问它的全局访问点</td>
</tr>
</tbody></table>
<h3 id="面向对象-—-结构型模式"><a href="#面向对象-—-结构型模式" class="headerlink" title="面向对象 — 结构型模式"></a>面向对象 — 结构型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Adapter 适配器模式</td>
<td>将一个类的接口转换成用户希望得到的另一种接口。它使原来不相容的接口得以协同工作</td>
<td><strong>转换</strong>接口</td>
</tr>
<tr>
<td>Bridge 桥接模式</td>
<td>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化</td>
<td>继承树拆分</td>
</tr>
<tr>
<td>Composite 组合模式</td>
<td>将对象组合成树型结构以表示”整体—部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</td>
<td>树形目录结构</td>
</tr>
<tr>
<td>Decorator 装饰模式</td>
<td>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的代替，比派生一个子类更加灵活</td>
<td><strong>附加职责</strong></td>
</tr>
<tr>
<td>Facade 外观模式</td>
<td>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</td>
<td>对外统一接口</td>
</tr>
<tr>
<td>Flyweight 享元模式</td>
<td>提供支持大量细粒度对象共享的有效方法</td>
<td></td>
</tr>
<tr>
<td>Proxy 代理模式</td>
<td>为其他对象提供一种代理以控制这个对象的访问</td>
<td></td>
</tr>
</tbody></table>
<h3 id="面向对象-—-行为型模式"><a href="#面向对象-—-行为型模式" class="headerlink" title="面向对象 — 行为型模式"></a>面向对象 — 行为型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Chain of Responsibility 职责链模式</td>
<td>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求</td>
<td><strong>传递职责</strong></td>
</tr>
<tr>
<td>Command 命令模式</td>
<td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</td>
<td>日志记录，可<strong>撤销</strong></td>
</tr>
<tr>
<td>Interpreter 解释器模式</td>
<td>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</td>
<td></td>
</tr>
<tr>
<td>Iterator 迭代器模式</td>
<td>提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</td>
<td></td>
</tr>
<tr>
<td>Mediator 中介者模式</td>
<td>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地互相条用，从而达到低耦合，还可也独立地改变对象间的交互</td>
<td>不直接引用</td>
</tr>
<tr>
<td>Memento 备忘录模式</td>
<td>在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</td>
<td></td>
</tr>
<tr>
<td>Observer 观察者模式</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</td>
<td></td>
</tr>
<tr>
<td>State 状态模式</td>
<td>允许一个对象在其内部状态改变时改变它的行为</td>
<td>状态变成类</td>
</tr>
<tr>
<td>Strategy 策略模式</td>
<td>定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化</td>
<td>多方案切换</td>
</tr>
<tr>
<td>Template Method 模板方法模式</td>
<td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</td>
<td></td>
</tr>
<tr>
<td>Visitor 访问者模式</td>
<td>表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</td>
<td></td>
</tr>
</tbody></table>
<h1 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a><span style = "color : red">数据流图(DFD)</span></h1><h3 id="数据流图基本概念"><a href="#数据流图基本概念" class="headerlink" title="数据流图基本概念"></a>数据流图基本概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/c8df5734504fe26e49886e57a4bb57abd5fda23b/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg"  />



<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&#x3D;</strong></td>
<td>被定义为</td>
<td></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>与</td>
<td>x&#x3D;a+b, 表示x由a和b组成</td>
</tr>
<tr>
<td><strong>[… , …]或[… | …]</strong></td>
<td>或</td>
<td>x&#x3D;[a,b], x&#x3D;[a|b], 表示x由a或由b组成</td>
</tr>
<tr>
<td><strong>{…}</strong></td>
<td>重复</td>
<td>x&#x3D;{a}, 表示x由0个或多个a组成</td>
</tr>
<tr>
<td><strong>(…)</strong></td>
<td>可选</td>
<td>x&#x3D;(a), 表示a可在x中出现, 也可以不出现</td>
</tr>
</tbody></table>
<p>机票 &#x3D; 姓名 + 日期 + 航班号 + 起点 + 终点 + 费用<br>航班号 &#x3D; “Y7100”..”Y8100”<br>终点 &#x3D; [长沙|上海|北京|西安]</p>
<blockquote>
<p>选择四个其中的一个终点 </p>
</blockquote>
<h3 id="数据流图平衡原则"><a href="#数据流图平衡原则" class="headerlink" title="数据流图平衡原则"></a>数据流图平衡原则</h3><h6 id="父图与子图之间的平衡、子图内平衡"><a href="#父图与子图之间的平衡、子图内平衡" class="headerlink" title="父图与子图之间的平衡、子图内平衡"></a>父图与子图之间的平衡、子图内平衡</h6><img src="https://raw.githubusercontent.com/P-luminary/images/1c65b63a43bfe88afc4ce4e4042e655c99848c3c/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%B9%B3%E8%A1%A1%E5%8E%9F%E5%88%99.jpg" style="zoom: 150%;" />



<h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3><img src="https://raw.githubusercontent.com/P-luminary/images/514e5a6749072475b5c75298c83b77800d4abae2/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7.jpg"  />



<h3 id="试题1"><a href="#试题1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/6d1ff8a821e6d03a30594af8710226314ef1e8fa/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E8%AF%95%E9%A2%981.png"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/c2212e4f52fe19b0da0244a88e8b50c5a81d2683/data/%E8%AF%95%E9%A2%981.1.jpg" style="zoom:150%;" />

<h5 id="第一问解析"><a href="#第一问解析" class="headerlink" title="第一问解析"></a>第一问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/99c328ecf6d6a5e5499c59f436bb8d2f28f2a139/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%80%E9%97%AE.png" style="zoom: 200%;" /> 



<h5 id="第二问解析"><a href="#第二问解析" class="headerlink" title="第二问解析"></a>第二问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/a6be0c3e3b020d87eeba748e7bbe8ff9b4a8847e/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom: 200%;" />



<h5 id="第三问解析"><a href="#第三问解析" class="headerlink" title="第三问解析"></a>第三问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/efe71851a6ab49d9ee52166ada7f60650d7c62b4/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%89%E9%97%AE.jpg" style="zoom:150%;" />



<h3 id="试题二"><a href="#试题二" class="headerlink" title="试题二"></a>试题二</h3><img src="https://raw.githubusercontent.com/P-luminary/images/38b4712590b799be692dd850b861ec1db1b23d23/data/%E8%AF%95%E9%A2%982.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cf9bf40bae6cecb18dfdf18be5711806ea7ddcf/data/%E8%AF%95%E9%A2%982.1.jpg"></p>
<h5 id="试题2第一问、第二问"><a href="#试题2第一问、第二问" class="headerlink" title="试题2第一问、第二问"></a>试题2第一问、第二问</h5><img src="https://raw.githubusercontent.com/P-luminary/images/e6d32f02094ef61c5486ff737e8f7c1b285a9f07/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom:200%;" />



<h5 id="试题2第三问-顶层和0层进行匹配-、第四问-从题干推导"><a href="#试题2第三问-顶层和0层进行匹配-、第四问-从题干推导" class="headerlink" title="试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)"></a>试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)</h5><img src="https://raw.githubusercontent.com/P-luminary/images/973540b5ce58d035d1c63fd26275bc3d3691dbef/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%89%E9%97%AE%E7%AC%AC%E5%9B%9B%E9%97%AE.jpg" style="zoom:200%;" />



<h3 id="数据库设计过程-1"><a href="#数据库设计过程-1" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4a7e717516686bf53a3016f10555bd298228bb96/data/1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" style="zoom: 200%;" />



<h3 id="ER模型-—-实体间联系类型"><a href="#ER模型-—-实体间联系类型" class="headerlink" title="ER模型 — 实体间联系类型"></a>ER模型 — 实体间联系类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/aef35208a0e0eef63f136821f90002f1f81ae413/data/ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg" style="zoom:150%;" />



<h3 id="数据库设计答题技巧"><a href="#数据库设计答题技巧" class="headerlink" title="数据库设计答题技巧"></a>数据库设计答题技巧</h3><h6 id="详细分析试题说明"><a href="#详细分析试题说明" class="headerlink" title="详细分析试题说明"></a>详细分析试题说明</h6><h6 id="熟练掌握基本知识"><a href="#熟练掌握基本知识" class="headerlink" title="熟练掌握基本知识"></a>熟练掌握基本知识</h6><h3 id="试题1-1"><a href="#试题1-1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7bc5db4a5d355f37629a9621e0e789c10b5e7359/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />



<h3 id="试题2"><a href="#试题2" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/10655b1b9f65d0e3145e7d58aec329857bad9fc0/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%982.png" style="zoom:150%;" />

<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/d40fd82221eb61d4fdd90e911632ab483c946fbb/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BE%8B%E9%A2%982%E8%A7%A3%E6%9E%90.jpg"  />



<h1 id="UML建模"><a href="#UML建模" class="headerlink" title="UML建模"></a><span style = "color : red">UML建模</span></h1><h6 id="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"><a href="#用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图" class="headerlink" title="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"></a>用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图</h6><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e2480d16b16b8b911584fe9f6ded8b19fcbea258/data/%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" style="zoom:150%;" />



<h3 id="类图与对象图"><a href="#类图与对象图" class="headerlink" title="类图与对象图"></a>类图与对象图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7e6cb7c946c5e51dc027f64e32e230d0af3e07e7/data/%E7%B1%BB%E5%9B%BE%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" style="zoom:150%;" />



<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da0cdf7024603417383dedd7f56ffefdc07b7a84/data/%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg"></p>
<h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/f3191e64c57a67bd754427957ff3998827d6c647/data/%E6%B4%BB%E5%8A%A8%E5%9B%BE.jpg"  />



<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d1f705c371a7460cb2078e7c4a1ee9c0b9c36597/data/%E7%8A%B6%E6%80%81%E5%9B%BE.jpg"></p>
<h3 id="通信图-顺序图-通信图-x3D-交互图"><a href="#通信图-顺序图-通信图-x3D-交互图" class="headerlink" title="通信图 (顺序图+通信图&#x3D;交互图)"></a>通信图 (顺序图+通信图&#x3D;交互图)</h3><p>区别：<strong>顺序图</strong>会强调时间顺序</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/4fd0cbc15294926e42fe33e61b7f0035a208ae7a/data/%E9%80%9A%E4%BF%A1%E5%9B%BE.jpg"  />



<h3 id="试题1-2"><a href="#试题1-2" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/914174f05e1265a79bd512c49afe191e67b83ad2/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981.jpg"  />



<h6 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/ffff4a52c486091b284f830b2cda215a26fadc78/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg"  />



<h3 id="试题2-1"><a href="#试题2-1" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b69f8c920bf06a3a3558f95693f3ea0fd04743ee/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982.jpg"  />



<h6 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/a23639f98414f903a56cad32ca174c6f0cd403d0/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E8%A7%A3%E6%9E%90.jpg" style="zoom: 200%;" />



<h6 id="第二、三问"><a href="#第二、三问" class="headerlink" title="第二、三问"></a>第二、三问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/47d8911eaacde30888938f1e434255a077c68f44/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982%E7%AC%AC%E4%BA%8C%E4%B8%89%E9%97%AE.jpg" style="zoom: 200%;" />



<h1 id="★★数据结构及算法应用★★-下午题"><a href="#★★数据结构及算法应用★★-下午题" class="headerlink" title="★★数据结构及算法应用★★(下午题)"></a>★★<span style = "color : red">数据结构及算法应用</span>★★(下午题)</h1><h6 id="分治法、回溯法、贪心法、动态规划法"><a href="#分治法、回溯法、贪心法、动态规划法" class="headerlink" title="分治法、回溯法、贪心法、动态规划法"></a>分治法、回溯法、贪心法、动态规划法</h6><h3 id="分治法-★★-分解-解决-合并-★★-一般用到递归"><a href="#分治法-★★-分解-解决-合并-★★-一般用到递归" class="headerlink" title="分治法(★★ 分解 解决 合并 ★★) [一般用到递归]"></a>分治法(★★ 分解 解决 合并 ★★) [一般用到递归]</h3><p><strong>对于一个规模为n的问题，若该问题可以容易地解决 (比如说规模n较小) 则直接解决；否则将其分解为k个规模较小的子问题，这些子问题相互独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解</strong></p>
<p>★ 该问题的规模缩小到一定的程度就可以容易地解决<br>★ 该问题可以分解为若干个规模较小的相同子问题<br>★ 利用该问题解决出的子问题的解可以合并为该问题的解<br>★ 该问题所分解出的各个子问题是相互独立的</p>
<h5 id="递归，就是在运行的过程中调用自己"><a href="#递归，就是在运行的过程中调用自己" class="headerlink" title="递归，就是在运行的过程中调用自己"></a>递归，就是在运行的过程中调用自己</h5><pre><code class="java">int F(int n)
&#123;
    if(n==0) return 1;
    if(n==1) return 1;
    if(n&gt;1) return F(n-1)+F(n-2);
&#125;
</code></pre>
<h3 id="分治法-→-二分查找"><a href="#分治法-→-二分查找" class="headerlink" title="分治法 → 二分查找"></a>分治法 → 二分查找</h3><pre><code class="java">function Binary_Search(L,a,b,x)&#123;
    if(a &gt; b) return(-1);
    else&#123;
        m=(a+b)/2;
        if(x==L[m]) return(m);
        else if(x &gt; L[m])
            return(Binary_Search(L,m+1,b,x));
        else
            return(Binary_Search(L,a,m-1,x));
    &#125;
&#125;
</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8d1e0521f94cd0d6b1ddf5bee2749ba0f49990b6/data/%E5%9B%9E%E6%BA%AF%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/13d82930889e1c9e254f8685c57c9d092d5a1634/data/%E8%B4%AA%E5%BF%83%E6%B3%95.png" style="zoom: 200%;" />



<h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/eaa958ff79a07a2e5bb606da5dac0cf195f4f6e1/data/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="数据结构算法例题"><a href="#数据结构算法例题" class="headerlink" title="数据结构算法例题"></a>数据结构算法例题</h3><h6 id="试题1-3"><a href="#试题1-3" class="headerlink" title="试题1"></a>试题1</h6><img src="https://raw.githubusercontent.com/P-luminary/images/6cfb68cba4f6641134b0b229642a0b10a9fbb39b/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981.jpg" style="zoom:200%;" />



<h6 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/780bbd00eefa211c7ff3261c7ce6b7f86e244aca/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />





<h6 id="试题2及解析"><a href="#试题2及解析" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/3894f1902e34206481d9cff7a866422151ce0ee8/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:;" />



<h1 id="★★★★★面向对象程序设计-下午题-★★★★★"><a href="#★★★★★面向对象程序设计-下午题-★★★★★" class="headerlink" title="★★★★★面向对象程序设计(下午题)★★★★★"></a>★★★★★<span style = "color : red">面向对象程序设计</span>(下午题)★★★★★</h1><h3 id="C-类与派生类的定义"><a href="#C-类与派生类的定义" class="headerlink" title="C++ 类与派生类的定义"></a>C++ 类与派生类的定义</h3><pre><code class="c++">class 类名&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;;
</code></pre>
<pre><code class="c++">class 派生类名：继承方法1 基类名1，继承方法2 基类名2,...&#123;
    public:
        派生类的公有数据和函数
    protected:
        派生类的保护数据和函数
    private:
        派生类的私有数据和函数
&#125;;
</code></pre>
<pre><code class="c++">在类外定义函数体的格式如下：
返回值类型 类名 :: 成员函数名(形参表)&#123;
    函数体;
&#125;
::是类的作用域分辨符，用在此处，放在类名后成员函数前，表明后面的成员东西函数属于前面的那个类
</code></pre>
<h3 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++构造函数与析构函数"></a>C++构造函数与析构函数</h3><blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.构造函数的函数名必须与定义它的类同名<br>2.构造函数没有返回值。如果在构造函数前加void是错误的<br>3.构造函数被声明定义为公有函数<br>4.构造函数在建立对象时由系统自动调用</p>
</blockquote>
<blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.析构函数没有任何参数，不能被重载，但是可以是虚函数，一个类只有一个析构函数<br>2.析构函数没有返回值<br>3.析构函数名与类名相同，但在类名前加一个逻辑非运算符 “~” 以表示与构造函数对比区别<br>4.析构函数一般由用户自己定义，在对象消失时由系统自动调用，如果用户没有定义析构函数，系统将自动生成一个不做任何事的默认析构函数</p>
</blockquote>
<pre><code class="c++">对象指针的语法定义形式如下：
    类名 *对象指针名;
</code></pre>
<pre><code class="c++">对象引用的定义形式如下：
    类名 &amp;对象引用名 = 被引用对象;
</code></pre>
<blockquote>
<p>注意：通过对象名或对象引用访问对象的成员，使用的运算符是 “.” 而使用对象指针访问对象成员，使用的运算符是 “-&gt;” </p>
<pre><code class="c++">对象指针名 -&gt; 数据成员名或 : 对象指针名 -&gt; 成员函数名(参数表) 
</code></pre>
</blockquote>
<h3 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a><span style = "color : red">C++虚函数</span></h3><pre><code class="c++">虚函数定义的一般语法形式如下:
virtual 函数类型 函数名(形参表)&#123;
    函数体;
&#125;
纯虚函数定义形式如下：
virtual 函数名 = 0;
</code></pre>
<h3 id="JAVA-类的定义"><a href="#JAVA-类的定义" class="headerlink" title="JAVA 类的定义"></a>JAVA 类的定义</h3><pre><code class="java">类的定义格式如下：
[import包]
[类修饰符] class xxxclass [extends超类] [implements接口]&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;
说明：
import包：引入包中的类
类修饰符：主要由四个修饰符(public、abstract、final、private)
class为关键字, xxxclass为类名，命名遵循Java标识符的命名规则
extends为继承关键字，implements为接口关键字
    
抽象类定义
abstract class Shape&#123;
    abstract public void draw() [定义了draw抽象方法]
&#125;

class Rectangle extends Shape&#123;&#125;
通过extends可以看出来Shape不是接口而是抽象类
</code></pre>
<pre><code class="java">import java.util.*;
(1) class Beverage&#123; //饮料
    String description = &quot;Unknown Beverage&quot;;
    public (2) ()&#123;return description;&#125;
        public (3);
&#125;
abstract class CondimentDecorator extends Beverage&#123;
    //配料
    (4);
&#125;

(1) abstract
(2) String getDescription
(3) abstract int cost()
(4) Beverage beverage
</code></pre>
<h3 id="JAVA-接口的定义"><a href="#JAVA-接口的定义" class="headerlink" title="JAVA 接口的定义"></a>JAVA 接口的定义</h3><pre><code class="java">interface IFactory&#123;&#125;
class SqlServerFactory implements IFactory
通过implements实现关键字来反推interface关键字
</code></pre>
<h3 id="面向程序设计"><a href="#面向程序设计" class="headerlink" title="面向程序设计"></a>面向程序设计</h3><h6 id="试题1及解析"><a href="#试题1及解析" class="headerlink" title="试题1及解析"></a>试题1及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/4d295300a1b912819bf30f980a891b23c6749154/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%981%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />

<h6 id="试题2及解析-1"><a href="#试题2及解析-1" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/2f0c15a8321c8414a2eae0bc4ff245c483b9c943/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />




















    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>