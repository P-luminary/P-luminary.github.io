
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || java复习款</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>java复习款 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/13
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#ffa2c4>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Object类、常用API"><a href="#Object类、常用API" class="headerlink" title="Object类、常用API"></a>Object类、常用API</h1><pre><code class="java">public String toString():返回该对象的字符串表示
public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”
    
java.util.Date类表示特定的瞬间，精确到毫秒
    public Date():分配Date对象并初始化此对象，以表示分配它的时间(精确到秒)
    public Date(long date):分配Date对象并初始化此对象，以表示从标准基准时间1970年1月1日以来的指定毫秒数
    public long getTime():把日期对象转换成对应的时间毫秒值
    
java.text.DateFormat类是日期/时间格式化子类的抽象类
    public SimpleDateFormate(String pattern):用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat[&quot;yyyy-MM-dd HH:mm:ss&quot; =&gt; 2018-01-16 15:06:38]
    public String format(Date date):将Date对象格式化为字符串
    public Date parse(String source):将字符串解析为Date对象
</code></pre>
<h6 id="请使用日期时间相关的API，计算出一个人已经出生了多少天。"><a href="#请使用日期时间相关的API，计算出一个人已经出生了多少天。" class="headerlink" title="请使用日期时间相关的API，计算出一个人已经出生了多少天。"></a>请使用日期时间相关的API，计算出一个人已经出生了多少天。</h6><p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void function() throws Exception &#123;
    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);
    // 获取出生日期,键盘输入
    String birthdayString = new Scanner(System.in).next();
    // 将字符串日期,转成Date对象
    // 创建SimpleDateFormat对象,写日期模式
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    // 调用方法parse,字符串转成日期对象
    Date birthdayDate = sdf.parse(birthdayString);    
    // 获取今天的日期对象
    Date todayDate = new Date();    
    // 将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;    
    if (secone &lt; 0)&#123;
        System.out.println(&quot;还没出生呢&quot;);
    &#125; else &#123;
        System.out.println(secone/1000/60/60/24);
    &#125;
&#125;
</code></pre>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><pre><code class="java">java.util.Calendar
    public static Calendar getInstance():使用默认时区和语言环境获得一个日历
    public int get(int field):返回給定日历字段的值
    public void set(int field, int value):将给定的日历字段设置为定值
    public abstract void add(qint field, int amount):根据日历的规则，为給定的日历字段添加或减去指定的时间量
    public Date getTime():返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Da
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    get方法
        Calendar cal = Calendar.getInstance();
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH)+1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;);
    &#125;

    set方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.YEAR, 2020);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                        // 2020年1月17日
    &#125;
    
    add方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;);
                            // 2018年1月17日
        // 使用add方法
        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天
        cal.add(Calendar.YEAR, -3); // 减3年
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                            // 2015年1月18日; 
    &#125;

    getTime方法

      
</code></pre>
<h3 id="CurrentTimeMillis方法"><a href="#CurrentTimeMillis方法" class="headerlink" title="CurrentTimeMillis方法"></a>CurrentTimeMillis方法</h3><h6 id="验证for循环打印数字1-9999所需要使用的时间（毫秒）"><a href="#验证for循环打印数字1-9999所需要使用的时间（毫秒）" class="headerlink" title="验证for循环打印数字1-9999所需要使用的时间（毫秒）"></a>验证for循环打印数字1-9999所需要使用的时间（毫秒）</h6><pre><code class="java">public class SystemTest1 &#123;
    public static void main(String[] args) &#123;
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 10000; i++) &#123;
            System.out.println(i);
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。(数组拷贝)
</code></pre>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。</p>
<pre><code class="java">备注：StringBuilder已经覆盖重写了Object当中的toString方法。
public StringBuilder():构造一个空的StringBuilder容器
public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去
public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身
public String toString():将当前StringBuilder对象转换为String对象
</code></pre>
<pre><code class="java">append方法
public static void main(String[] args) &#123;
        //创建对象
        StringBuilder builder = new StringBuilder();
        //public StringBuilder append(任意类型)
        StringBuilder builder2 = builder.append(&quot;hello&quot;);
        //对比一下
        System.out.println(&quot;builder:&quot;+builder);
        System.out.println(&quot;builder2:&quot;+builder2);
        System.out.println(builder == builder2); //true
        // 可以添加 任何类型
        builder.append(&quot;hello&quot;);
        builder.append(&quot;world&quot;);
        builder.append(true);
        builder.append(100);
        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。
        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下
        //链式编程
        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);
        System.out.println(&quot;builder:&quot;+builder);
    &#125;

toString方法
通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：
public static void main(String[] args) &#123;
        // 链式创建
        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);
        // 调用方法
        String str = sb.toString();
        System.out.println(str); // HelloWorldJava
    &#125;
</code></pre>
<h3 id="基本类型转换位String"><a href="#基本类型转换位String" class="headerlink" title="基本类型转换位String"></a>基本类型转换位String</h3><pre><code class="java">- public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。
- public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。
- public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。
- public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。
- public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。
- public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。
- public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。
</code></pre>
<pre><code class="java">注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。
public class Demo18WrapperParse &#123;
    public static void main(String[] args) &#123;
        int num = Integer.parseInt(&quot;100&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="Collection、泛型"><a href="#Collection、泛型" class="headerlink" title="Collection、泛型"></a>Collection、泛型</h1><p>集合按照其存储结构可以分为两大类，分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合。集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<pre><code class="java">public boolean add(E e):把给定的对象添加到当前集合中
public void clear():清空集合中所有的元素
public boolean remove(E e):把给定的对象在当前集合中删掉
public boolean contains(E e):判断当前集合中是否包含给定的对象
public boolean isEmpty():判断当前集合是否位空
public int size():返回集合中元素的个数
public Object[] to Array():把集合中的元素，存储到数组中
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;一&quot;);
        coll.add(&quot;二&quot;);
        coll.add(&quot;三&quot;);
        System.out.println(coll);                //[一, 二, 三]
        System.out.println(coll.contains(&quot;二&quot;));     //true
        System.out.println(coll.isEmpty());  //false
        System.out.println(coll.size());     //3
        System.out.println(coll.remove(&quot;二&quot;)); // true
        System.out.println(coll);                  //[一，二]
        System.out.println(coll.contains(&quot;二&quot;));  //false

        Object[] objects = coll.toArray(); //0 1
        for (int i = 0; i &lt; objects.length; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
</code></pre>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<pre><code class="java">public E next():返回迭代的下一个元素
public boolean hasNext():如果仍有元素可以迭代，则返回true
</code></pre>
<pre><code class="java">tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。
public static void main(String[] args) &#123;
        // 使用多态方式 创建对象
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        // 添加元素到集合
        coll.add(&quot;串串星人&quot;);
        coll.add(&quot;吐槽星人&quot;);
        coll.add(&quot;汪星人&quot;);
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator&lt;String&gt; it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext())&#123; //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        &#125;
      &#125;
</code></pre>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<pre><code>for(元素的数据类型 变量 ： collection集合or数组)&#123;
  //操作代码
&#125;
</code></pre>
<pre><code class="java">遍历集合
public static void main(String[] args) &#123;        
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;小河神&quot;);
        coll.add(&quot;老河神&quot;);
        coll.add(&quot;神婆&quot;);
        //使用增强for遍历
        for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素
            System.out.println(s);
    &#125;
&#125;
</code></pre>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre><code class="java">修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125;
class ArrayList&lt;E&gt;&#123;
    public boolean add(E e) &#123; &#125;
    public E get(int index) &#123; &#125;
&#125;

在创建对象的时候确定泛型
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
class ArrayList&lt;Integer&gt;&#123;
    public boolean add(Integer e) &#123; &#125;
    public Integer get(int index) &#123; &#125;
&#125;
</code></pre>
<pre><code class="java">举例自定义泛型类
public class MyGenericClass&lt;MVP&gt;&#123;
    //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型
    private MVP mvp;
    public void setMVP(MVP mvp)&#123;
        this.mvp = mvp;
    &#125;
    public MVP getMVP()&#123;
        return mvp;
    &#125;
&#125;

public class GenericClassDemo &#123;
      public static void main(String[] args) &#123;         
         // 创建一个泛型为String的类
         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();        
         // 调用setMVP
         my.setMVP(&quot;大胡子登登&quot;);
         // 调用getMVP
         String mvp = my.getMVP();
         System.out.println(mvp);
         //创建一个泛型为Integer的类
         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); 
         my2.setMVP(123);         
         Integer mvp2 = my2.getMVP();
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><pre><code class="java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;

public class MyGenericMethod &#123;      
    public &lt;MVP&gt; void show(MVP mvp) &#123;
        System.out.println(mvp.getClass());
    &#125;
    
    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;    
        return mvp;
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><h5 id="1、定义类时确定泛型的类型"><a href="#1、定义类时确定泛型的类型" class="headerlink" title="1、定义类时确定泛型的类型"></a><strong>1、定义类时确定泛型的类型</strong></h5><pre><code class="java">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;

public interface MyGenericInterface&lt;E&gt;&#123;
    public abstract void add(E e);
    
    public abstract E getE();  
&#125;

泛型E的值就是String类型
public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;
    @Override
    public void add(String e) &#123;
        // 省略...
    &#125;

    @Override
    public String getE() &#123;
        return null;
    &#125;
&#125;

</code></pre>
<h5 id="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"><a href="#2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型" class="headerlink" title="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"></a><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></h5><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;
    @Override
    public void add(E e) &#123;
            // 省略...
    &#125;

    @Override
    public E getE() &#123;
        return null;
    &#125;
&#125;

/*
 * 使用
 */
public class GenericInterface &#123;
    public static void main(String[] args) &#123;
        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();  
        my.add(&quot;aa&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过**通配符&lt;?&gt;**表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();
    getElement(list1);
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    getElement(list2);
&#125;
public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;
//？代表可以接收任意类型
</code></pre>
<h5 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h5><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();
    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
&#125;
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;
</code></pre>
<pre><code class="java">Java.util.Collections类下有一个静态的shuffle()方法,如下：

1）static void shuffle(List&lt;?&gt; list)  使用默认随机源对列表进行置换，所有置换发生的可能性都是大致相等的。

2）static void shuffle(List&lt;?&gt; list, Random rand) 使用指定的随机源对指定列表进行置换，所有置换发生的可能性都是大致相等的，假定随机源是公平的。
</code></pre>
<h3 id="扑克牌案例分析"><a href="#扑克牌案例分析" class="headerlink" title="扑克牌案例分析"></a>扑克牌案例分析</h3><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<pre><code class="java">import java.util.ArrayList;
import java.util.Collections;

public class Poker &#123;
    public static void main(String[] args) &#123;
        /*
        * 1: 准备牌操作
        */
        //1.1 创建牌盒 将来存储牌面的 
        ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();
        //1.2 创建花色集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();

        //1.3 创建数字集合
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        //1.4 分别给花色 以及 数字集合添加元素
        colors.add(&quot;♥&quot;);
        colors.add(&quot;♦&quot;);
        colors.add(&quot;♠&quot;);
        colors.add(&quot;♣&quot;);

        for(int i = 2;i&lt;=10;i++)&#123;
            numbers.add(i+&quot;&quot;);
        &#125;
        numbers.add(&quot;J&quot;);
        numbers.add(&quot;Q&quot;);
        numbers.add(&quot;K&quot;);
        numbers.add(&quot;A&quot;);
        //1.5 创造牌  拼接牌操作
        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中
        for (String color : colors) &#123;
            //color每一个花色 
            //遍历数字集合
            for(String number : numbers)&#123;
                //结合
                String card = color+number;
                //存储到牌盒中
                pokerBox.add(card);
            &#125;
        &#125;
        //1.6大王小王
        pokerBox.add(&quot;小☺&quot;);
        pokerBox.add(&quot;大☠&quot;);      
        // System.out.println(pokerBox);
        //洗牌 是不是就是将  牌盒中 牌的索引打乱 
        // Collections类  工具类  都是 静态方法
        // shuffer方法   
        /*
         * static void shuffle(List&lt;?&gt; list) 
         *     使用默认随机源对指定列表进行置换。 
         */
        //2:洗牌
        Collections.shuffle(pokerBox);
        //3 发牌
        //3.1 创建 三个 玩家集合  创建一个底牌集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();      

        //遍历 牌盒  必须知道索引   
        for(int i = 0;i&lt;pokerBox.size();i++)&#123;
            //获取 牌面
            String card = pokerBox.get(i);
            //留出三张底牌 存到 底牌集合中
            if(i&gt;=51)&#123;//存到底牌集合中
                dipai.add(card);
            &#125; else &#123;
                //玩家1   %3  ==0
                if(i%3==0)&#123;
                      player1.add(card);
                &#125;else if(i%3==1)&#123;//玩家2
                      player2.add(card);
                &#125;else&#123;//玩家3
                      player3.add(card);
                &#125;
            &#125;
        &#125;
        //看看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;田伯光：&quot;+player2);
        System.out.println(&quot;绿竹翁：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);  
    &#125;
&#125;
</code></pre>
<h1 id="List、Set、数据结构、Collections"><a href="#List、Set、数据结构、Collections" class="headerlink" title="List、Set、数据结构、Collections"></a>List、Set、数据结构、Collections</h1><h6 id="List集合特有的方法都是跟索引相关"><a href="#List集合特有的方法都是跟索引相关" class="headerlink" title="List集合特有的方法都是跟索引相关"></a>List集合特有的方法都是跟索引相关</h6><pre><code class="java">public void add(int index, E element):将指定的元素，添加到集合中的指定位置上
public E get(int index):返回集合中指定位置的元素
public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素
public E set(int index，E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        
        // 往 尾部添加 指定元素
        list.add(&quot;图图&quot;);
        list.add(&quot;小美&quot;);
        list.add(&quot;不高兴&quot;);
        
        System.out.println(list);
        // add(int index,String s) 往指定位置添加
        list.add(1,&quot;没头脑&quot;);
        
        System.out.println(list);
        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素 
        System.out.println(&quot;删除索引位置为2的元素&quot;);
        System.out.println(list.remove(2));
        
        System.out.println(list);
        
        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改） 
        // 修改指定位置元素
        list.set(0, &quot;三毛&quot;);
        System.out.println(list);
        
        // String get(int index)  获取指定位置元素
        
        // 跟size() 方法一起用  来 遍历的 
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        //还可以使用增强for
        for (String string : list) &#123;
            System.out.println(string);
        &#125;      
    &#125;
</code></pre>
<h1 id="List-ArrayList、LinkedList-的子类"><a href="#List-ArrayList、LinkedList-的子类" class="headerlink" title="List(ArrayList、LinkedList)的子类"></a>List(ArrayList、LinkedList)的子类</h1><p><code>java.util.ArrayList</code> 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。<br><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<pre><code class="java">public void addFirst(E e):将指定元素插入此列表的开头
public void addLast(E e):将指定元素添加到此列表的结尾
public E getFirst():返回此列表的第一个元素
public E removeFirst():移除并返回此列表的第一个元素
public E removeLast():移除并返回此列表的最后一个元素
public E pop():从此列表所表示的堆栈处弹出一个元素
public void push(E e):将元素推入此列表所表示的堆栈
public boolean isEmpty():如果列表不包含元素，则返回true
</code></pre>
<h1 id="Set-HashSet、LinkedHashSet"><a href="#Set-HashSet、LinkedHashSet" class="headerlink" title="Set(HashSet、LinkedHashSet)"></a>Set(HashSet、LinkedHashSet)</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<h4 id="Set集合取出元素的方式可以采用：迭代器、增强for"><a href="#Set集合取出元素的方式可以采用：迭代器、增强for" class="headerlink" title="Set集合取出元素的方式可以采用：迭代器、增强for"></a><span style = "color : red"><strong>Set集合取出元素的方式可以采用：迭代器、增强for</strong></span></h4><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<h4 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><pre><code class="java">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;
public static int getSum(int[] arr)&#123;
    int sum = 0;
    for(int a : arr)&#123;
        sum += a;
    &#125;
    return sum;
&#125;
</code></pre>
<h3 id="Collections-高效添加元素"><a href="#Collections-高效添加元素" class="headerlink" title="Collections(高效添加元素)"></a>Collections(高效添加元素)</h3><pre><code class="java">java.utils.Collections是集合工具类
public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素
public static void shuffle(List&lt;?&gt; list):打乱集合顺序
public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序
public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。
</code></pre>
<pre><code class="java"> public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        //原来写法
        //list.add(12);
        //list.add(14);
        //list.add(15);
        //list.add(1000);
        //采用工具类 完成 往集合中添加元素  
        Collections.addAll(list, 5, 222, 1，2);
        System.out.println(list);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<h3 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h3><pre><code class="java">public int compare(String o1, String o2):比较两个参数的顺序
return o1 - o2 (正数)
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
   ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
   Collections.addAll(arr,&quot;cba&quot;,&quot;aba&quot;,&quot;sba&quot;,&quot;nba&quot;);
   Collections.sort(arr, new Comparator&lt;String&gt;() &#123;
     @Override
     public int compare(String o1, String o2) &#123;
         return o1.charAt(0)-o2.charAt(0);
     &#125;
  &#125;);
  System.out.println(arr);
&#125;
</code></pre>
<pre><code class="java">public class Student_test implements Comparable&lt;Student_test&gt; &#123;
    @Override
    public int compareTo(Student_test o) &#123;
        return this.age-o.age;
    &#125;
Getter Setter toString 
--------------------------------------------------------------
public class Comparable_test &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;Student_test&gt; list = new ArrayList&lt;Student_test&gt;();
        list.add(new Student_test(&quot;rose&quot;,18));
        list.add(new Student_test(&quot;jack&quot;,16));
        list.add(new Student_test(&quot;abc&quot;,16));
        list.add(new Student_test(&quot;ace&quot;,17));
        list.add(new Student_test(&quot;mark&quot;,16));
        for(Student_test student : list)&#123;
            System.out.println(student);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        return o2.getAge()-o1.getAge();//以学生的年龄降序
    &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<p>如果想要规则更多一些，可以参考下面代码：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
       // 年龄降序
    int result = o2.getAge()-o1.getAge();//年龄降序

    if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序
     result = o1.getName().charAt(0)-o2.getName().charAt(0);
    &#125;
     return result;
  &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><code>java.util.Map</code>接口</p>
<p>Collection接口定义了单列集合规范 每次存储<strong>一个</strong>元素 单个元素<br>Map接口定义了双列集合的规范 每次存储<strong>一对儿</strong>元素(Key Value)</p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<pre><code class="java">HashMap&lt;K,V&gt;:存储数据采用的哈希表结构，元素的存取顺序不能保持一致，由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法

LinkedHashMap&lt;K,V&gt;: HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

public V put(K key, V value):把指定的键与指定的值添加到Map集合中
public V remove(Object key):把指定的键所对应的键值对元素 在Map集合中删除，返回被删除元素的值
public V get(Object key):根据指定的键，在Map集合中获取对应的值
boolean containsKey(Object key) 判断集合中是否包含指定的键。
public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)
    
使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 
若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 
</code></pre>
<h3 id="Map集合遍历-键找值-方式"><a href="#Map集合遍历-键找值-方式" class="headerlink" title="Map集合遍历 键找值 方式"></a>Map集合遍历 键找值 方式</h3><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法: keyset()</li>
<li>遍历键的Set集合，得到每一个键</li>
<li>根据键，获取键所对应的值。方法: get(K key)</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys)&#123;
            String value = map.get(key);
            System.out.println(key+&quot; &quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建Map集合对象 
        HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();
        // 添加元素到集合 
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);

        // 获取 所有的 entry对象  entrySet
        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();

        // 遍历得到每一个entry对象
        for (Entry&lt;String, String&gt; entry : entrySet) &#123;
               // 解析 
            String key = entry.getKey();
            String value = entry.getValue();  
            System.out.println(key+&quot;的CP是:&quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要<strong>保证有序，还要速度快</strong>怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<pre><code class="java"> public static void main(String[] args) &#123;
        LinkedHashMap&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;();
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);
        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;String,String&gt; entry : entrySet)&#123;
            System.out.println(entry.getKey()+entry.getValue());
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h3><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，<strong>键代表字符，值代表次数</strong>。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        //友情提示
        System.out.println(&quot;请录入一个字符串:&quot;);
        String line = new Scanner(System.in).nextLine();
        // 定义 每个字符出现次数的方法
        findChar(line);
    &#125;
    private static void findChar(String line) &#123;
        //1:创建一个集合 存储  字符 以及其出现的次数
        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
        //2:遍历字符串
        for (int i = 0; i &lt; line.length(); i++) &#123;
            char c = line.charAt(i);
            //判断 该字符 是否在键集中
            if (!map.containsKey(c)) &#123;//说明这个字符没有出现过
                //那就是第一次
                map.put(c, 1);
            &#125; else &#123;
                //先获取之前的次数
                Integer count = map.get(c);
                //count++;
                //再次存入  更新
                map.put(c, ++count);
            &#125;
        &#125;
        System.out.println(map);
    &#125;
</code></pre>
<h4 id="JDK9对集合添加的优化"><a href="#JDK9对集合添加的优化" class="headerlink" title="JDK9对集合添加的优化"></a>JDK9对集合添加的优化</h4><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<pre><code class="java">public class HelloJDK9 &#123;  
    public static void main(String[] args) &#123;  
        Set&lt;String&gt; str1=Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);  
        //str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  
        System.out.println(str1);  
        Map&lt;String,Integer&gt; str2=Map.of(&quot;a&quot;,1,&quot;b&quot;,2);  
        System.out.println(str2);  
        List&lt;String&gt; str3=List.of(&quot;a&quot;,&quot;b&quot;);  
        System.out.println(str3);  
    &#125;  
&#125; 

1: of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；
2: 返回的集合是不可变的；
</code></pre>
<h3 id="模拟斗地主洗牌发牌"><a href="#模拟斗地主洗牌发牌" class="headerlink" title="模拟斗地主洗牌发牌"></a>模拟斗地主洗牌发牌</h3><h5 id="案例规则"><a href="#案例规则" class="headerlink" title="案例规则"></a>案例规则</h5><ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h5 id="案例需求分析"><a href="#案例需求分析" class="headerlink" title="案例需求分析"></a>案例需求分析</h5><ol>
<li>准备牌：</li>
</ol>
<p>​        完成数字与纸牌的映射关系：</p>
<p>​        使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li>洗牌：</li>
</ol>
<p>​        通过数字完成洗牌发牌</p>
<ol start="3">
<li>发牌：</li>
</ol>
<p>​        将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>​        存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>​        将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li>看牌：</li>
</ol>
<p>​        通过Map集合找到对应字符展示。</p>
<p>​        通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示</p>
<pre><code class="java">public static void main(String[] args) &#123;
        /*
         * 1组装54张扑克牌
         */
        // 1.1 创建Map集合存储
        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();
        // 1.2 创建 花色集合 与 数字集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        // 1.3 存储 花色 与数字
        Collections.addAll(colors, &quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;);
        Collections.addAll(numbers, &quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;);
        // 设置 存储编号变量
        int count = 1;
        pokerMap.put(count++, &quot;大王&quot;);
        pokerMap.put(count++, &quot;小王&quot;);
        // 1.4 创建牌 存储到map集合中
        for (String number : numbers) &#123;
            for (String color : colors) &#123;
                String card = color + number;
                pokerMap.put(count++, card);
            &#125;
        &#125;
        /*
         * 2 将54张牌顺序打乱
         */
        // 取出编号 集合
        Set&lt;Integer&gt; numberSet = pokerMap.keySet();
        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中
        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();
        numberList.addAll(numberSet);

        // 打乱顺序
        Collections.shuffle(numberList);

        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌
        // 3.1 发牌的编号
        // 创建三个玩家编号集合 和一个 底牌编号集合
        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();

        // 3.2发牌的编号
        for (int i = 0; i &lt; numberList.size(); i++) &#123;
            // 获取该编号
            Integer no = numberList.get(i);
            // 发牌
            // 留出底牌
            if (i &gt;= 51) &#123;
                dipaiNo.add(no);
            &#125; else &#123;
                if (i % 3 == 0) &#123;
                    noP1.add(no);
                &#125; else if (i % 3 == 1) &#123;
                    noP2.add(no);
                &#125; else &#123;
                    noP3.add(no);
                &#125;
            &#125;
        &#125;

        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌
        // 4.1 对手中编号进行排序
        Collections.sort(noP1);
        Collections.sort(noP2);
        Collections.sort(noP3);
        Collections.sort(dipaiNo);

        // 4.2 进行牌面的转换
        // 创建三个玩家牌面集合 以及底牌牌面集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();

        // 4.3转换
        for (Integer i : noP1) &#123;
            // 4.4 根据编号找到 牌面 pokerMap
            String card = pokerMap.get(i);
            // 添加到对应的 牌面集合中
            player1.add(card);
        &#125;

        for (Integer i : noP2) &#123;
            String card = pokerMap.get(i);
            player2.add(card);
        &#125;
        for (Integer i : noP3) &#123;
            String card = pokerMap.get(i);
            player3.add(card);
        &#125;
        for (Integer i : dipaiNo) &#123;
            String card = pokerMap.get(i);
            dipai.add(card);
        &#125;

        //4.5 查看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;石破天：&quot;+player2);
        System.out.println(&quot;鸠摩智：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);
    &#125;
</code></pre>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>(<u>工程师不能处理,只能尽量避免</u>)与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>(<u>由于使用不当导致,可以避免的</u>)。</p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<pre><code class="java">throw new 异常类名(参数)
throw new NullPointerExcerption(&quot;要访问的arr数组不存在&quot;);
throw new ArrayIndexOutOfBoundsException(&quot;该索引所在数组不存在，已超出范围&quot;);
</code></pre>
<p>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
<pre><code class="java">public static int getElement(int[] arr, int index)&#123;
        if (index &lt; 0 || index &gt; arr.length - 1)&#123;
            throw new ArrayIndexOutOfBoundsException(&quot;越界&quot;);
        &#125;
        int element = arr[index];
        return element;
    &#125;

    public static void main(String[] args) &#123;
        int[] arr = &#123;1,3,6,8,10&#125;;
        int index = 5;
        int element = getElement(arr, index);
        System.out.println(element);
    &#125;
</code></pre>
<p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<pre><code class="java\">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;    
</code></pre>
<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<pre><code class="java">public class ThrowsDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        read(&quot;a.txt&quot;);
    &#125;

    public static void read(String path)throws FileNotFoundException, IOException &#123;
        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        &#125;
        if (!path.equals(&quot;b.txt&quot;)) &#123;
            throw new IOException();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<pre><code class="java">try&#123;
    编写可能会出现异常的代码
&#125;catch(异常类型 e)&#123;
    处理异常的代码
&#125;
//记录日志/打印异常信息/继续抛出异常
</code></pre>
<p><strong>try：</strong>该代码块中编写可能产生异常的代码。<br><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意：try和catch都不能单独使用,必须连用。</p>
</blockquote>
<pre><code class="java">public String getMessage():获取异常的描述信息，提示给用户的时候提示错误原因
public String toString():获取异常的类型和异常描述信息
public void printStoackTralce():打印异常的跟踪栈信息并输出到控制台
包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
</code></pre>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。[注意:finally不能单独使用。]</p>
<pre><code class="java">try&#123;
     编写可能会出现异常的代码
&#125;catch(异常类型A  e)&#123;  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;catch(异常类型B  e)&#123;  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;
注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。
</code></pre>
<ul>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h3 id="自定义异常练习"><a href="#自定义异常练习" class="headerlink" title="自定义异常练习"></a>自定义异常练习</h3><pre><code class="java">// 业务逻辑异常
public class RegisterException extends Exception &#123;
    /**
     * 空参构造
     */
    public RegisterException() &#123;
    &#125;

    /**
     *
     * @param message 表示异常提示
     */
    public RegisterException(String message) &#123;
        super(message);
    &#125;
&#125;
====================================================
public class Demo &#123;
    // 模拟数据库中已存在账号
    private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;;
   
    public static void main(String[] args) &#123;     
        //调用方法
        try&#123;
              // 可能出现异常的代码
            checkUsername(&quot;nill&quot;);
            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功
        &#125;catch(RegisterException e)&#123;
            //处理异常
            e.printStackTrace();
        &#125;
    &#125;

    //判断当前注册账号是否存在
    //因为是编译期异常，又想调用者去处理 所以声明该异常
    public static boolean checkUsername(String uname) throws LoginException&#123;
        for (String name : names) &#123;
            if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常
                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong></p>
<p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<pre><code class="java">public class Demo01 &#123;
    public static void main(String[] args) &#123;
        //创建自定义线程对象
        MyThread mt = new MyThread(&quot;新的线程！&quot;);
        //开启新线程
        mt.start();
        //在主方法中执行for循环
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(&quot;main线程！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h5><pre><code class="java">public class MyThread extends Thread &#123;
    //定义指定线程名称的构造方法
    public MyThread(String name) &#123;
        //调用父类的String参数的构造方法，指定线程的名称
        super(name);
    &#125;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;：正在执行！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="继承Thread类方式"><a href="#继承Thread类方式" class="headerlink" title="继承Thread类方式"></a>继承Thread类方式</h3><p>完成操作过程中用到了<code>java.lang.Thread</code>类</p>
<pre><code class="java">public Thread():分配一个新的线程对象
public Thread(String name):分配一个指定名字的新的线程对象
public Thread(Runnable target):分配一个带有指定目标新的线程对象
public Thread(Runnable target, String name):分配一个带有指定目标新的线程对象并指定名字
    
常用方法：
public String getName():获取当前线程名称
public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法
public void run():此线程要执行的任务在此处定义代码
public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停
public static Thread currentThread():返回对当前正在执行的线程对象的引用
</code></pre>
<h3 id="实现Runnable接口方式"><a href="#实现Runnable接口方式" class="headerlink" title="实现Runnable接口方式"></a>实现Runnable接口方式</h3><p>采用<code>java.lang.Runnable</code>类，只需要重写run方法即可<br>步骤如下：<br>1.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>2.创建Runnable实现类的实例，并以此实例为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象<br>3.调用线程对象的start()方法来启动线程</p>
<pre><code class="java">public class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 20; i++) &#123;
        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        MyThread mr = new MyThread();
        Thread t = new Thread(mr, &quot;小白&quot;);
        t.start();
        for (int i = 0; i &lt; 20; i++) &#123;
            System.out.println(&quot;旺财&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。</p>
<blockquote>
<p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><p>如果一个类继承Thread, 则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享</p>
<h5 id="实现Runnable接口比继承Thread类所具有的优势："><a href="#实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="实现Runnable接口比继承Thread类所具有的优势："></a>实现Runnable接口比继承Thread类所具有的优势：</h5><p>1.适合多个相同的程序代码的线程去共享同一个资源<br>2.可以避免java中的单继承的局限性<br>3.增加程序的健壮性，实现解耦操作，代码额可以被多个线程共享, 代码和线程独立<br>4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类</p>
<blockquote>
<p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。</p>
</blockquote>
<h3 id="线程同时安全"><a href="#线程同时安全" class="headerlink" title="线程同时安全"></a>线程同时安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<pre><code class="/java">public class Ticket implements Runnable&#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while(true)&#123;
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                   e.printStackTrace();
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
        &#125;
    &#125;
&#125;

public class test &#123;
    public static void main(String[] args) &#123;
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h5 id="怎么使用Java线程同步机制-？"><a href="#怎么使用Java线程同步机制-？" class="headerlink" title="怎么使用Java线程同步机制 ？"></a>怎么使用Java线程同步机制 ？</h5><p>1.同步代码块<br>2.同步方法<br>3.锁机制</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul>
<li>同步代码块： <strong>synchronized</strong> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</li>
</ul>
<pre><code class="java">synchronized(同步锁)&#123;
    需要同步操作的代码
&#125;
------------------------------------------------------------------
public void run() &#123;
        while(true)&#123;
            synchronized (lock)&#123;
                if (ticket &gt; 0)&#123;
                    try &#123;
                        Thread.sleep(10000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    String name = Thread.currentThread().getName();
                    System.out.println(name + ticket--);
                &#125;
            &#125;
       &#125;
</code></pre>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li>同步方法：<strong>synchronized</strong> 修饰的方法, 叫做同步方法. 保证A线程执行该方法的时候, 其他线程只能在方法外等着</li>
</ul>
<pre><code class="java">同步锁是谁?
对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。
</code></pre>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作，同步代码块&#x2F;同步方法 具有的功能Lock都有，除此之外更强大，更体现面向对象。<br>Lock锁也称同步锁，<strong>加锁</strong>与<strong>释放锁</strong>方法化了</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        MyRunnable my = new MyRunnable();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
----------------------------------------------
public class MyRunnable implements Runnable&#123;
    private int ticket = 100;
    Lock lock = new ReentrantLock();
     @Override
      public void run() &#123;
        while(true)&#123;
            lock.lock();
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(50);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><p>在<code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New(新建)</td>
<td>线程刚被创建, 但是并未启动, 还没条用start方法</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态, 可能正在运行自己代码, 也可能没有, 这取决于操作系统处理器</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁, 而该对象锁被其他的线程持有, 则该线程进入Blocked状态; 当该线程持有锁时, 该线程将变成Runnable状态</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个(唤醒)动作时, 该线程进入Waiting状态。进入这个状态后是不能自动唤醒的, 必须等待另一个线程调用<strong>notify</strong>或者<strong>notifyAll</strong>方法才能够唤醒</td>
</tr>
<tr>
<td>TimedWaiting(计时终止)</td>
<td>同waiting状态, 有几个方法有超时参数, 调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法又Thread.sleep、Object.wait</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡, 或者没有因为捕获的异常终止了run方法而死亡</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一个调用了某个对象的 Object.wait 方法的线程会<span style = "color : red">等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。</span></strong> </p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞 争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p> 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/8476427ec1a9ced5d3f5727b207aff6b2f53636c/data/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE(%E9%AB%98%E7%BA%A7).jpg"  />

<pre><code class="java">public class test &#123;
    public static Object obj = new Object();

    public static void main(String[] args) &#123;
// 演示waiting
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while (true) &#123;
                    synchronized (obj) &#123;
                        try &#123;
                            System.out.println(Thread.currentThread().getName() + &quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;);
                            obj.wait(); //无限等待
//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                        System.out.println(Thread.currentThread().getName() + &quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;, &quot;等待线程&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
// while (true)&#123; //每隔3秒 唤醒一次
                try &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 等待3秒钟&quot;);
                    Thread.sleep(3000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;);
                    obj.notify();
                &#125;
            &#125;
// &#125;
        &#125;, &quot;唤醒线程&quot;).start();
    &#125;
&#125;
</code></pre>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>1.wait: 线程不再活动, 不再参与调度, 进入wait set中, 因此不会浪费CPU资源, 也不会去竞争锁, 这时的线程状态即是Waiting。它还要等着别的线程执行一个特别的动作, 也即是”<strong>通知(notify)</strong>“在这个对象上等待的线程从wait set中释放出来, 重新进入到调度队列(ready queue)中<br>2.notify: 选取所通知对象的wait set中的一个线程释放：例如, 餐馆有空位置后, 等候就餐最久的顾客最先入座<br>3.notifyAll: 释放所通知的对象的wait set上的全部线程</p>
<blockquote>
<p>哪怕只通知了一个等待的线程, 被通知线程也不能立即恢复执行, 因为它当初终端的地方是在同步块内, 而此刻它偶已经不持有锁, 所以她需要再次尝试去获取锁(可能面临其他线程的竞争), 成功后才能在当初调用wait方法之后的地方恢复执行</p>
<ul>
<li>如果能获取锁, 线程就从Waiting状态变成Bunnable状态</li>
<li>否则, 从wait set出来, 又进入entry set, 线程就从Waiting状态变成了Blocked状态</li>
</ul>
</blockquote>
<h5 id="调用wait和notify方法需要注意的细节"><a href="#调用wait和notify方法需要注意的细节" class="headerlink" title="调用wait和notify方法需要注意的细节"></a>调用wait和notify方法需要注意的细节</h5><p>1.wait方法与notify方法必须由同一锁对象调用 因为对应锁对象可以通过notify唤醒使用同一锁对象调用的wait方法后的线程<br>2.wait方法与notify方法是属于Object类的方法的 因为锁对象是可以是任意对象，而任意对象的所属类都是继承了Object类的<br>3.wait方法与notify方法必须要在同步代码块或者是同步函数中使用 因为必须通过锁对象调用这2个方法</p>
<pre><code class="java">void notify():唤醒在此对象监视器上等待的单个线程
void notifyAll():唤醒在此对象监视器上等待的所有线程
void wait():导致当前的线程等待, 直到其他线程调用此对象的notify()方法或者notifyAll()方法
void wait(long timeout):导致当前的线程等待, 直到其他线程调用此对象的notify()方法或notifyAll()方法, 或者指定的时间过完
void wait(long timeout, intik nanos):导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法，或者其他线程打断了当前线程，或者指定的时间过完。
</code></pre>
<ul>
<li>wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。</li>
<li>当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常</li>
<li>当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。</li>
<li>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</li>
<li>调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。</li>
<li>notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）</li>
<li>notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）</li>
<li>假设有三个线程执行了obj.wait()，那么obj.notifyAll()则能全部唤醒thread1，thread2，thread3，但是要继续执行obj.wait()的下一条语句，必须获取obj锁，因此，thread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。</li>
<li>当调用obj.notify&#x2F;notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code></p>
<pre><code class="java">Executoturs类中有个创建线程池的方法：
public static ExecutorService nweFixedThreadPool(int nThreads):返回线程池对象(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：
public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象并执行
Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建于使用
</code></pre>
<blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
</blockquote>
<pre><code class="java">public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个教练&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;);
    &#125;
&#125;
==========================================================
public class ThreadPoolDemo &#123;
    public static void main(String[] args) &#123;
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
        // 创建Runnable实例对象
        MyRunnable r = new MyRunnable();

        //自己创建线程对象的方式
        // Thread t = new Thread(r);
        // t.start(); ---&gt; 调用MyRunnable中的run()

        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
        // 再获取个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        //service.shutdown();
    &#125;
&#125;
</code></pre>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h5 id="强调做什么，而不是以什么形式做"><a href="#强调做什么，而不是以什么形式做" class="headerlink" title="强调做什么，而不是以什么形式做"></a><strong>强调做什么，而不是以什么形式做</strong></h5><p>面向对象的思想:</p>
<p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<pre><code class="java">public class Demo01Runnable &#123;
    public static void main(String[] args) &#123;
        // 匿名内部类
        Runnable task = new Runnable() &#123;
            @Override
            public void run() &#123; // 覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;;
        new Thread(task).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<p>上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<pre><code class="java">public class Demo02LambdaRunnable &#123;
    public static void main(String[] args) &#123;
        new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h4><pre><code class="java">public class RunnableImpl implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;多线程任务执行！&quot;);
    &#125;
&#125;

public class Demo03ThreadInitParam &#123;
    public static void main(String[] args) &#123;
        Runnable task = new RunnableImpl();
        new Thread(task).start();
    &#125;
&#125;
</code></pre>
<h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><p><strong>匿名内部类的好处与弊端</strong><br>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<pre><code class="java">public class Demo04ThreadNameless &#123;
    public static void main(String[] args) &#123;
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<pre><code class="java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)
</code></pre>
<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h3 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h3><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li><strong>一些参数</strong></li>
<li><strong>一个箭头</strong></li>
<li><strong>一段代码</strong></li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;
</code></pre>
<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h3 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h3><blockquote>
<p>需求:<br>    使用数组存储多个Person对象<br>    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</p>
</blockquote>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<pre><code class="java">public class Person &#123; 
    private String name;
    private int age;
    
    // 省略构造器、toString方法与Getter Setter 
&#125;

import java.util.Arrays;
import java.util.Comparator;
public class Demo06Comparator &#123;
    public static void main(String[] args) &#123;
          // 本来年龄乱序的对象数组
        Person[] array = &#123;
            new Person(&quot;古力娜扎&quot;, 19),
            new Person(&quot;迪丽热巴&quot;, 18),
               new Person(&quot;马尔扎哈&quot;, 20) &#125;;

          // 匿名内部类
        Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getAge() - o2.getAge();
            &#125;
        &#125;;
        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h6 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h6><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h6 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h6><pre><code class="java">import java.util.Arrays;

public class Demo07ComparatorLambda &#123;
    public static void main(String[] args) &#123;
        Person[] array = &#123;
              new Person(&quot;古力娜扎&quot;, 19),
              new Person(&quot;迪丽热巴&quot;, 18),
              new Person(&quot;马尔扎哈&quot;, 20) &#125;;

        Arrays.sort(array, (Person a, Person b) -&gt; &#123;
              return a.getAge() - b.getAge();
        &#125;);

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><pre><code class="java">public File(String pathname):通过将给定的路径名字字符串转化为抽象路径名来创建新的File实例
public File(String parent, String child):从父路径名字符串和子路径名字符串创建新的File实例
public File(File parent, String child):从父抽象路径名和子路径名字符串创建新的File实例
</code></pre>
<pre><code class="java">// 文件路径名
String pathname = &quot;D:\\aaa.txt&quot;;
File file1 = new File(pathname); 

// 文件路径名
String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;
File file2 = new File(pathname2); 

// 通过父路径和子路径字符串
 String parent = &quot;d:\\aaa&quot;;
 String child = &quot;bbb.txt&quot;;
 File file3 = new File(parent, child);

// 通过父级File对象和子路径字符串
File parentDir = new File(&quot;d:\\aaa&quot;);
String child = &quot;bbb.txt&quot;;
File file4 = new File(parentDir, child);

小贴士：
1. 一个File对象代表硬盘中实际存在的一个文件或者目录。
2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。
</code></pre>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre><code class="java">public String getAbsolutePath():返回此File的绝对路径名字符串
public String getPath():将此File转换为路径名字符串
public String getName():返回由此File表示的文件或目录的名称
public long length():返回由此File表示的文件的长度
</code></pre>
<pre><code class="java">public class FileGet &#123;
    public static void main(String[] args) &#123;
        File f = new File(&quot;d:/aaa/bbb.java&quot;);     
        System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());
        System.out.println(&quot;文件构造路径:&quot;+f.getPath());
        System.out.println(&quot;文件名称:&quot;+f.getName());
        System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);

        File f2 = new File(&quot;d:/aaa&quot;);     
        System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());
        System.out.println(&quot;目录构造路径:&quot;+f2.getPath());
        System.out.println(&quot;目录名称:&quot;+f2.getName());
        System.out.println(&quot;目录长度:&quot;+f2.length());
    &#125;
&#125;
输出结果：
文件绝对路径:d:\aaa\bbb.java
文件构造路径:d:\aaa\bbb.java
文件名称:bbb.java
文件长度:636字节

目录绝对路径:d:\aaa
目录构造路径:d:\aaa
目录名称:aaa
目录长度:4096
API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。
</code></pre>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<pre><code class="java">public class FilePath &#123;
    public static void main(String[] args) &#123;
          // D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
          
        // 项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f2.getAbsolutePath());
    &#125;
&#125;
输出结果：
D:\bbb.java
D:\idea_project_test4\bbb.java
</code></pre>
<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5><pre><code class="java">public boolean exists():此File表示的文件或目录是否真实存在
public boolean isDirectory():此File表示的是否为目录
public boolean isFile():此File表示的是否为文件
</code></pre>
<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5><pre><code class="java">public boolean createNewFile():当且仅当具有该名称的文件尚不存在时候,创建一个新的空文件
public boolean delete():删除由此File表示的文件或目录
public boolean mkdir():创建由此File表示的目录
public boolean mkdirs():创建由此File表示的目录,包括任何必须旦不存在的父目录
</code></pre>
<pre><code class="java">public class FileCreateDelete &#123;
    public static void main(String[] args) throws IOException &#123;
        // 文件的创建
        File f = new File(&quot;aaa.txt&quot;);
        System.out.println(&quot;是否存在:&quot;+f.exists()); // false
        System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true
        System.out.println(&quot;是否存在:&quot;+f.exists()); // true
        
         // 目录的创建
          File f2= new File(&quot;newDir&quot;);    
        System.out.println(&quot;是否存在:&quot;+f2.exists());// false
        System.out.println(&quot;是否创建:&quot;+f2.mkdir());    // true
        System.out.println(&quot;是否存在:&quot;+f2.exists());// true

        // 创建多级目录
          File f3= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f3.mkdir());// false
        File f4= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f4.mkdirs());// true
      
          // 文件的删除
           System.out.println(f.delete());// true
      
          // 目录的删除
        System.out.println(f2.delete());// true
        System.out.println(f4.delete());// false
    &#125;
&#125;
API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。
</code></pre>
<h5 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h5><pre><code class="java">public String[] list():返回一个String数组,表示该FIle目录中的所有子文件或目录
public File[] listFiles():返回一个File数组,表示该FIle目录中的所有的子文件或目录
</code></pre>
<pre><code class="java">public class FileFor &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;d:\\java_code&quot;);
      
          //获取当前目录下的文件以及文件夹的名称。
        String[] names = dir.list();
        for(String name : names)&#123;
            System.out.println(name);
        &#125;
        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息
        File[] files = dir.listFiles();
        for (File file : files) &#123;
            System.out.println(file);
        &#125;
    &#125; //打印全文件地址名称
</code></pre>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h5><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class DiGuiDemo2 &#123;
    public static void main(String[] args) &#123;
          // 创建File对象
        File dir  = new File(&quot;D:\\aaa&quot;);
          // 调用打印目录方法
        printDir(dir);
    &#125;

    public static void  printDir(File dir) &#123;
          // 获取子文件和目录
        File[] files = dir.listFiles();
          // 循环打印
          /*
            判断:
            当是文件时,打印绝对路径.
            当是目录时,继续调用打印目录的方法,形成递归调用.
          */
        for (File file : files) &#123;
            // 判断
            if (file.isFile()) &#123;
                  // 是文件,输出文件绝对路径
                System.out.println(&quot;文件名:&quot;+ file.getAbsolutePath());
            &#125; else &#123;
                  // 是目录,输出目录绝对路径
                System.out.println(&quot;目录:&quot;+file.getAbsolutePath());
                  // 继续遍历,调用printDir,形成递归
                printDir(file);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件搜索案例"><a href="#文件搜索案例" class="headerlink" title="文件搜索案例"></a>文件搜索案例</h4><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        File file = new File(&quot;D:\\NotePad++&quot;);
        printFile(file);
    &#125;
    public static void printFile(File file)&#123;
        File[] files = file.listFiles();
        for (File f1 : files)&#123;
            if (f1.isFile())&#123;
                if (f1.getName().endsWith(&quot;.xml&quot;))&#123;
                    System.out.println(&quot;文件名：&quot;+f1.getAbsolutePath());
                &#125;
            &#125;else &#123;
                printFile(f1);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h4><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code> listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<pre><code class="java">boolean accept(File pathname)：测试pathname是否应该包含在当前File目录中，符合则返回true。
</code></pre>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public class DiGuiDemo4 &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;D:\\aaa&quot;);
        printDir2(dir);
    &#125;
  
    public static void printDir2(File dir) &#123;
          // 匿名内部类方式,创建过滤器子类对象
        File[] files = dir.listFiles(new FileFilter() &#123;
            @Override
            public boolean accept(File pathname) &#123;
                return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();
            &#125;   //public boolean isDirectory():此File表示的是否为目录
        &#125;);
          // 循环打印
        for (File file : files) &#123;
            if (file.isFile()) &#123;
                System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
            &#125; else &#123;
                printDir2(file);
            &#125;
        &#125;
    &#125;
&#125;      
</code></pre>
<h4 id="Lambda优化"><a href="#Lambda优化" class="headerlink" title="Lambda优化"></a>Lambda优化</h4><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<pre><code class="java">()-&gt;&#123; &#125;
</code></pre>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void printDir3(File dir) &#123;
      // lambda的改写
    File[] files = dir.listFiles(f -&gt;&#123; 
          return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory(); 
    &#125;);
      
    // 循环打印
    for (File file : files) &#123;
        if (file.isFile()) &#123;
            System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
          &#125; else &#123;
            printDir3(file);
          &#125;
    &#125;
&#125;
</code></pre>
<h3 id="字节流、字符流"><a href="#字节流、字符流" class="headerlink" title="字节流、字符流"></a>字节流、字符流</h3><h6 id="顶级父类们"><a href="#顶级父类们" class="headerlink" title="顶级父类们"></a>顶级父类们</h6><table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>字节输入流 <strong>InputStream</strong></td>
<td>字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td>字符流</td>
<td>字符输入流 <strong>Reader</strong></td>
<td>字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<h6 id="字节输出流-OutputStream类"><a href="#字节输出流-OutputStream类" class="headerlink" title="字节输出流 OutputStream类"></a>字节输出流 OutputStream类</h6><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输出流并释放与此流相关联的任何系统资源
public void flush():刷新此输出流并强制任何缓冲的输出字节被写出
public void write(byte[] b):将b.length字节从指定的字节数组写入此输出流
public void write(byte[] b, in off, int len):从指定的字节数组写入len字节,从偏移量off开始输出到此输出流
public abstract void write(int b):将指定的字节输出流
// close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h6 id="字节输出流-FileOutputStream类"><a href="#字节输出流-FileOutputStream类" class="headerlink" title="字节输出流 FileOutputStream类"></a>字节输出流 FileOutputStream类</h6><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。<br><code>java.io.FileOutputStream </code>类是文件输出流，用于**<u>将数据写出到文件</u>**。</p>
<pre><code class="java">public FileOutputStream(File file):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name):创建文件输出流以指定的名称写入文件
</code></pre>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<pre><code class="java">public class FileOutputStreamConstructor throws IOException &#123;
    public static void main(String[] args) &#123;
           // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream(&quot;D:\Clash\a.txt&quot;);
        // 普通创建
        File file = new File(&quot;a.txt&quot;);
        FileOutputStream fos = new FileOutputStream(file);
    &#125;
&#125;
</code></pre>
<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><p><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;);
    fos.write(97); //a
    fos.close();
&#125;
// 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
// 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\clash\\a.txt&quot;);
    yte[] b = &quot;黑马程序员&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<pre><code class="java">public FileOutputStream(File file, boolean append):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name, boolean append):创建文件输出流以指定的名称写入文件
</code></pre>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;, true);
    byte[] b = &quot;abcde&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
<h4 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h4><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输入流并释放与此流相关的任何系统资源
public abstract int read():从输入流读取数据的下一个字节
public int read(byte[] b):从输入流中读取一些字节数,并把它们存储到字节数组b中
close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">FileInputStream(File file):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的File对象 file命名
FileInputStream(String name):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的路径名 name命名。  
当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。
</code></pre>
<p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
   FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
   int b;
   while((b=fis.read())!= -1)&#123;
      System.out.println((char)b);
   &#125;
    fis.close();
&#125;
//1. 虽然读取了一个字节，但是会自动提升为int类型。
//2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    byte[] b = new byte[2];
    while((len = fis.read(b)) != -1)&#123;
         System.out.println(new String(b,0,len));
    &#125;
    fis.close();
 &#125;
</code></pre>
<h5 id="实现资源的复制"><a href="#实现资源的复制" class="headerlink" title="实现资源的复制"></a>实现资源的复制</h5><pre><code class="java">public static void main(String[] args) throws IOException &#123;
    // 1.创建流对象
    // 1.1 指定数据源
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    // 1.2 指定目的地
    FileOutputStream fos = new FileOutputStream(&quot;D:\\7-Zip\\c.txt&quot;);
    // 2.读写数据
    // 2.1 定义数组
    byte[] b = new byte[1024];
    // 2.2 定义长度
    int len;
    // 2.3 循环读取
    while((len = fis.read(b))!=-1)&#123;
    // 2.4 写出数据
        fos.write(b,0,len);
    &#125;
    // 3.关闭资源
    fos.close();
    fis.close();
&#125;
// 流的关闭原则：先开后关，后开先关。
</code></pre>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><pre><code class="java">FileReader(File file):创建一个新的FileReader，给定要读取的File对象
FileReader(String fileName):创建一个新的FileReader，给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileReader fr = new FileReader(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    char[] cbuf = new char[1024];
    while((len = fr.read(cbuf))!=-1)&#123;
        System.out.println(new String(cbuf,0,len));
    &#125;
    fr.close();
&#125;
</code></pre>
<h3 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h3><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">void write(int c):写入单个字符
void write(char[] cbuf):写入字符数组
abstract void weite(char[] cbuf, int off, int len):写入字符数组的某一部分,off数组的开始索引,len写的字符个数
void write(String str):写入字符串
void write(String str, int off, int len):写入字符串的某一部分,off字符串的开始索引,len写的字符个数
void flush():刷新该流的缓冲
void close():关闭此流,但要先刷新它
</code></pre>
<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<pre><code class="java">FileWriter(File file):创建一个新的FileWriter,给定要读取的File对象
FileWeiter(String fileName):创建一个新的FileWeiter,给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
            // 使用File对象创建流对象
        File file = new File(&quot;a.txt&quot;);
        FileWriter fw = new FileWriter(file);
      
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter(&quot;b.txt&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><p><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream</p>
<p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</p>
<p><strong>续写和换行</strong>：操作类似于FileOutputStream。</p>
<p><strong><u>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</u></strong></p>
<blockquote>
<p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。在ASCII编码中，一个英文字母字符存储需要1个字节。</p>
<p><strong>字节</strong>：计算机存储容量基本单位是字节（Byte），音译为拜特，8个二进制位组成1个字节，一个标准英文字母占一个字节位置，一个标准汉字占二个字节位置。计算机存储容量大小以字节数来度量。</p>
</blockquote>
<h3 id="异常的处理-回顾"><a href="#异常的处理-回顾" class="headerlink" title="异常的处理(回顾)"></a>异常的处理(回顾)</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
        FileWriter fw = null;
        try &#123;
            fw = new FileWriter(&quot;D:\\Clash\\a.txt&quot;);
            fw.write(&quot;黑马程序员&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try&#123;
                if (fw != null)&#123;
                    fw.close();
                &#125;
            &#125;catch (IOException e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>try (创建流对象语句，如果多个,使用’;’隔开) {<br>    &#x2F;&#x2F; 读写数据<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}</p>
</blockquote>
<pre><code class="java">public class HandleException2 &#123;
    public static void main(String[] args) &#123;
          // 创建流对象
        try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123;
            // 写出数据
            fw.write(&quot;黑马程序员&quot;); //黑马程序员
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<pre><code class="java">public class TryDemo &#123;
    public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        final  FileReader fr  = new FileReader(&quot;in.txt&quot;);
        FileWriter fw = new FileWriter(&quot;out.txt&quot;);
           // 引入到try中
        try (fr; fw) &#123;
              // 定义变量
            int b;
              // 读取数据
              while ((b = fr.read())!=-1) &#123;
                // 写出数据
                fw.write(b);
              &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><pre><code class="java">public Object setProperty(String key, String value):保存一对属性
public String getProperty(String key):使用此属性列表中指定的键搜索属性值
public Set&lt;String&gt; stringPropertyNames():所有键的名称的集合
</code></pre>
<pre><code class="java">public class ProDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties properties = new Properties();
        // 添加键值对元素
        properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;);
        properties.setProperty(&quot;length&quot;, &quot;209385038&quot;);
        properties.setProperty(&quot;location&quot;, &quot;D:\\a.txt&quot;);
        // 打印属性集对象
        System.out.println(properties);
        // 通过键,获取属性值
        System.out.println(properties.getProperty(&quot;filename&quot;));
        System.out.println(properties.getProperty(&quot;length&quot;));
        System.out.println(properties.getProperty(&quot;location&quot;));

        // 遍历属性集,获取所有键的集合
        Set&lt;String&gt; strings = properties.stringPropertyNames();
        // 打印键值对
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+properties.getProperty(key));
        &#125;
    &#125;
&#125;
输出结果：
&#123;filename=a.txt, length=209385038, location=D:\a.txt&#125;
a.txt
209385038
D:\a.txt
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><pre><code class="java">public void load(InputStream inStream):从字节输入流中读取键值对
</code></pre>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<pre><code>filename=a.txt
length=209385038
location=D:\a.txt
</code></pre>
<p>加载代码演示：</p>
<pre><code class="java">public class ProDemo2 &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties pro = new Properties();
        // 加载文本中信息到属性集
        pro.load(new FileInputStream(&quot;read.txt&quot;));
        // 遍历集合并打印
        Set&lt;String&gt; strings = pro.stringPropertyNames();
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));
        &#125;
     &#125;
&#125;
输出结果：
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p><strong>字节缓冲流</strong>  <code>BufferedInputStream</code>, <code>BufferedOutputStream</code><br><strong>字符缓冲流</strong>  <code>BufferedReader</code>, <code>BudfferedWeiter</code></p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><pre><code class="java">public BufferedInputStream(InputStream in):创建一个新的缓冲输入流
public BufferedOutputStream(OutputStream out):创建一个新的缓冲输出流
</code></pre>
<pre><code class="java">// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
</code></pre>
<pre><code class="java">public static void main(String[] args) throws FileNotFoundException &#123;
          // 记录开始时间
        long start = System.currentTimeMillis();
        // 创建流对象
        try (
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));
        )&#123;
              // 读写数据
            int len;
            byte[] bytes = new byte[8*1024];
            while ((len = bis.read(bytes)) != -1) &#123;
                bos.write(bytes, 0 , len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
缓冲流使用数组复制时间:666 毫秒
</code></pre>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><pre><code class="java">public BufferedReader(Reader in):创建一个新的缓冲输入流
public BufferedReader(Writer out):创建一个新的缓冲输出流
</code></pre>
<blockquote>
<p><strong>字节(Byte)</strong> 是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。<br>**字符(Character) ** 是计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
</blockquote>
<h5 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h5><pre><code class="java">BufferedReader：public String readLine():读一行文字
bufferedWeiter：public void newLine():写一行行分隔符，由系统属性定义符号
</code></pre>
<pre><code class="java">readLine代码展示
public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        // 定义字符串,保存读取的一行文字
        String line  = null;
          // 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) &#123;
            System.out.print(line);
            System.out.println(&quot;------&quot;);
        &#125;
        // 释放资源
        br.close();
    &#125;
</code></pre>
<pre><code class="java">newLine代码展示
public static void main(String[] args) throws IOException  &#123;
          // 创建流对象
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));
          // 写出数据
        bw.write(&quot;黑马&quot;);
          // 写出换行
        bw.newLine();
        bw.write(&quot;程序&quot;);
        bw.newLine();
        bw.write(&quot;员&quot;);
        bw.newLine();
        // 释放资源
        bw.close();
    &#125;
&#125;
输出效果:
黑马
程序
员
</code></pre>
<h1 id="练习-文本排序"><a href="#练习-文本排序" class="headerlink" title="练习: 文本排序"></a>练习: 文本排序</h1><p>请将文本信息恢复顺序。</p>
<pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
9.今当远离，临表涕零，不知所言。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
</code></pre>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java"> public static void main(String[] args) throws IOException &#123;
        // 创建map集合,保存文本数据,键为序号,值为文字
        HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();

        // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));

        // 读取数据
        String line  = null;
        while ((line = br.readLine())!=null) &#123;
            // 解析文本
            String[] split = line.split(&quot;\\.&quot;);
            // 保存到集合
            lineMap.put(split[0],split[1]);
        &#125;
        // 释放资源
        br.close();

        // 遍历map集合
        for (int i = 1; i &lt;= lineMap.size(); i++) &#123;
            String key = String.valueOf(i);
            // 获取map中文本
            String value = lineMap.get(key);
              // 写出拼接文本
            bw.write(key+&quot;.&quot;+value);
              // 写出换行
            bw.newLine();
        &#125;
        // 释放资源
        bw.close();
    &#125;
</code></pre>
<blockquote>
<ul>
<li><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</li>
<li>**Integer valueOf(String s):**返回保存指定的 String 的值的 Integer 对象。</li>
<li><strong>Integer valueOf(String s, int radix):</strong> 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</li>
</ul>
</blockquote>
<h2 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流
OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流
</code></pre>
<pre><code class="java">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
          // 定义文件路径
        String FileName = &quot;E:\\out.txt&quot;;
          // 创建流对象,默认UTF8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));
        // 写出数据
          osw.write(&quot;你好&quot;); // 保存为6个字节
        osw.close();
        // 定义文件路径
        String FileName2 = &quot;E:\\out2.txt&quot;;
         // 创建流对象,指定GBK编码
        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);
        // 写出数据
          osw2.write(&quot;你好&quot;);// 保存为4个字节
        osw2.close();
 &#125;
</code></pre>
<h2 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code class="java">public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的ObjectOutputStream。
</code></pre>
<h2 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong><br><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<blockquote>
<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a><strong>一、是什么</strong></h2><p>序列化：就是将对象转化成字节序列的过程。</p>
<p>反序列化：就是讲字节序列转化成对象的过程。</p>
<p>对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。</p>
<h2 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a><strong>二、为什么</strong></h2><p>那么为什么要去进行序列化呢？有以下两个原因</p>
<ol>
<li>持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。</li>
<li>网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。</li>
</ol>
<h2 id="三、怎么做"><a href="#三、怎么做" class="headerlink" title="三、怎么做"></a><strong>三、怎么做</strong></h2><p>怎么去实现对象的序列化呢？</p>
<p>Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。</p>
<ol>
<li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口</li>
<li>实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化</li>
</ol>
<p>下面分别实现Serializable和Externalizable接口来演示序列化和反序列化</p>
</blockquote>
<pre><code class="java">public class Employee implements java.io.Serializable &#123;
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() &#123;
          System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);
    &#125;
&#125;

public final void writeObject (Object obj) : 将指定的对象写出。
    
public class SerializeDemo&#123;
       public static void main(String [] args)   &#123;
        Employee e = new Employee();
        e.name = &quot;zhangsan&quot;;
        e.address = &quot;beiqinglu&quot;;
        e.age = 20; 
        try &#123;
              // 创建序列化流对象
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));
            // 写出对象
            out.writeObject(e);
            // 释放资源
            out.close();
            fileOut.close();
            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。
        &#125; catch(IOException i)   &#123;
            i.printStackTrace();
        &#125;
       &#125;
&#125;
输出结果：
Serialized data is saved
</code></pre>
<h2 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class SerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建 学生对象
        Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);
        Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);
        Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);

        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(student);
        arrayList.add(student2);
        arrayList.add(student3);
        // 序列化操作
        // serializ(arrayList);
        
        // 反序列化  
        ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));
        // 读取对象,强转为ArrayList类型
        ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();
        
          for (int i = 0; i &lt; list.size(); i++ )&#123;
              Student s = list.get(i);
            System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());
          &#125;
    &#125;

    private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;
        // 创建 序列化流 
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));
        // 写出对象
        oos.writeObject(arrayList);
        // 释放资源
        oos.close();
    &#125;
&#125;
</code></pre>
<h2 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；
</code></pre>
<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<pre><code class="java">public class PrintDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        // 调用系统的打印流,控制台直接输出97
        System.out.println(97);
      
        // 创建打印流,指定文件的名称
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);
          
          // 设置系统的打印流流向,输出到ps.txt
        System.setOut(ps);
          // 调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    &#125;
&#125;
</code></pre>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p><code>Socket</code>类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点</p>
<h5 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">public Socket(String host, int port):创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。
</code></pre>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
<p>构造举例，代码如下：</p>
<pre><code class="java">Socket client = new Socket(&quot;127.0.0.1&quot;, 6666);
</code></pre>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public InputStream getInputStream() ： 返回此套接字的输入流。
  - 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。
  - 关闭生成的InputStream也将关闭相关的Socket。
public OutputStream getOutputStream() ： 返回此套接字的输出流。
  - 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。
  - 关闭生成的OutputStream也将关闭相关的Socket。
public void close() ：关闭此套接字。
  - 一旦一个socket被关闭，它不可再使用。
  - 关闭此socket也将关闭相关的InputStream和OutputStream 。 
public void shutdownOutput() ： 禁用此套接字的输出流。   
  - 任何先前写出的数据将被发送，随后终止输出流。 
</code></pre>
<h2 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h2><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h5 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。
ServerSocket server = new ServerSocket(6666);
</code></pre>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public Socket accept():侦听并接受链接，返回一个新的Socket对象，用于和客户端实现通信，该方法一直阻塞直到建立链接
</code></pre>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
        //5.关闭资源.
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.获取流对象 . 输出流
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
        // 4. 关闭资源 .
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
          // =================回写数据=======================
          // 5. 通过 socket 获取输出流
           OutputStream out = server.getOutputStream();
          // 6. 回写数据
           out.write(&quot;我很好,谢谢你&quot;.getBytes());
          // 7.关闭资源.
          out.close();
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.通过Scoket,获取输出流对象 
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
          // ==============解析回写=========================
          // 4. 通过Scoket,获取 输入流对象
          InputStream in = client.getInputStream();
          // 5. 读取数据数据
          byte[] b = new byte[100];
          int len = in.read(b);
          System.out.println(new String(b, 0, len));
        // 6. 关闭资源 .
          in.close();
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<pre><code class="java">修饰符 interface 接口名称 &#123;
    public abstract 返回值类型 方法名称(可选参数信息);
    // 其他非抽象方法内容
&#125;
</code></pre>
<p><span style = "color:red"><strong>由于接口当中抽象方法的 <code>public abstract</code> 是可以省略的</strong></span>，所以定义一个函数式接口很简单：</p>
<pre><code class="java">public interface MyFunctionalInterface&#123;
    void myMethod(); //省略public abstract
&#125;
</code></pre>
<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><p>与<code>@Override</code>注解的作用类似，引入了一个新的注解<code>@FunctionalInterface</code> 该注解可用于上一个接口的定义上</p>
<pre><code class="java">@FunctionalInterface
public interface MyfunctionalInterface&#123;
    void myMethod();
&#125;
</code></pre>
<p><strong>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错</strong>。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<p>对于刚刚定义好的 <code>MyFunctionalInterface</code> 函数式接口，典型使用场景就是作为方法的参数：</p>
<pre><code class="java">public class Demo09FunctionalInterface&#123;
    //使用自定义的函数式接口方法
    private static void deSomething(MyfunctionalInterfalce inter)&#123;
        inter.myMethod(); //调用自定义的函数式接口方法
    &#125;
    
    public static void main(String[] args)&#123;
        //调用使用函数式接口的方法
        doSomething(()-&gt;System.out,println(&quot;Lambda执行啦！&quot;));
    &#125;
&#125;
</code></pre>
<h2 id="Lambda的延迟"><a href="#Lambda的延迟" class="headerlink" title="Lambda的延迟"></a>Lambda的延迟</h2><pre><code class="java">public static void log(int level, MessageBuilder builder)&#123;
        if (level == 1)&#123;
            System.out.println(builder.buildMessage());
        &#125;
    &#125;

    public static void main(String[] args)&#123;
        String msgA = &quot;Hello&quot;;
        String msgB = &quot;world&quot;;
        String msgC = &quot;Java&quot;;
        log(2,() -&gt; &#123;
            System.out.println(&quot;Lambda执行啦！&quot;);
            return msgA+msgB+msgC;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 </p>
<blockquote>
<p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法 来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>
</blockquote>
<h2 id="使用Lambda作为参数和返回值"><a href="#使用Lambda作为参数和返回值" class="headerlink" title="使用Lambda作为参数和返回值"></a>使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。<br>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p>
<pre><code class="java">public class DemoRunnable&#123;
    private static void startThread(Runnable task)&#123;
        new Thread(task).start();
    &#125;
    public static void main(String[] args)&#123;
        startThread(()-&gt;System.out.println(&quot;线程任务执行！&quot;));
    &#125;
&#125;
</code></pre>
<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 <code>java.util.Comparator</code> 接口类型的对象作为排序器时, 就可以调该方法获取</p>
<pre><code class="java">private static Comparable&lt;String&gt; newComparator()&#123;
    return(a,b) -&gt; b.length() - a.length();
    // 其中直接return一个Lambda表达式即可
&#125;

public static void main(String[] args) &#123;
    String[] array = &#123;&quot;abc&quot;,&quot;ab&quot;,&quot;abcd&quot;&#125;;
    System.out.println(Arrays.toString(array));
    Arrays.sort(array,newComparator());
    System.out.println(Arrays.toString(array));
&#125;
</code></pre>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code> 用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，也就意味着对应Lambda表达式需要”<strong>对外提供</strong>“一个符合泛型类型的对象数据</p>
<pre><code class="java">public class Demo08Supplier &#123;
    private static String getString(Supplier&lt;String&gt; function) &#123;
    return function.get();
&#125;
public static void main(String[] args) &#123;
    String msgA = &quot;Hello&quot;;
    String msgB = &quot;World&quot;;
    System.out.println(getString(() ‐&gt; msgA + msgB));
    &#125;
&#125;
</code></pre>
<h4 id="求数组元素最大值"><a href="#求数组元素最大值" class="headerlink" title="求数组元素最大值"></a>求数组元素最大值</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>使用 <code>Supplier</code> 接口作为方法参数类型，通过<code>Lambda</code>表达式求出int数组中的最大值。<br>提示：接口的泛型请使用 <code>java.lang.Integer</code> 类。</p>
<h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">public class Demo02Test &#123;
//定一个方法,方法的参数传递Supplier,泛型使用Integer
    public static int getMax(Supplier&lt;Integer&gt; sup)&#123;
    return sup.get();
&#125;
public static void main(String[] args) &#123;
    int arr[] = &#123;2,3,4,52,333,23&#125;;
    //调用getMax方法,参数传递Lambda
    int maxNum = getMax(()‐&gt;&#123;
    //计算数组的最大值
    int max = arr[0];
    for(int i : arr)&#123;
        if(i&gt;max)&#123;
     max = i;
     &#125;
    &#125;
     return max;
   &#125;);
    System.out.println(maxNum);
    &#125;
&#125;
</code></pre>
<h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><p><code>java.util.function.Consumer</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据， 其数据类型由泛型决定。</p>
<h5 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h5><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>, 意为消费一个指定泛型的数据</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; function)&#123;
    function.accept(&quot;Hello!&quot;);
&#125;
public static void main(String[] args) &#123;
    consumeString(s -&gt; System.out.println(s));
&#125;
</code></pre>
<h5 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h5><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的default方法 <code>andThen</code> 。下面是JDK的源代码：</p>
<pre><code class="java">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;
    Objects.requireNonNull(after);
    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;
&#125;
</code></pre>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 <code>andThen</code> 的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt;two)&#123;
        one.andThen(two).accept(&quot;hello&quot;);
&#125;

    public static void main(String[] args) &#123;
        consumeString(
                s-&gt; System.out.println(s.toUpperCase()),
                s -&gt; System.out.println(s.toLowerCase())
    );
&#125;
// 运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。
</code></pre>
<h4 id="格式化打印信息"><a href="#格式化打印信息" class="headerlink" title="格式化打印信息"></a>格式化打印信息</h4><h6 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h6><p> 下面的字符串数组当中存有多条信息，请按照格式“ <code>姓名：XX。性别：XX。</code>”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 <code>Consumer</code> 接口的Lambda实例，将打印性别的动作作为第二个 <code>Consumer</code>接口的Lambda实 例，将两个 <code>Consumer</code> 接口按照顺序“拼接”到一起。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot; &#125;;
&#125;
</code></pre>
<h6 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h6><pre><code class="java">import java.util.function.Consumer;
public class test &#123;
    private static void printInfo(Consumer&lt;String&gt;one, Consumer&lt;String&gt;two, String[] array)&#123;
        for (String info : array)&#123;
        one.andThen(two).accept(info);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;&#125;;
        printInfo(s-&gt; System.out.print(&quot;姓名:&quot;+s.split(&quot;,&quot;)[0]),
                  s-&gt; System.out.println(&quot;。性别：&quot;+s.split(&quot;,&quot;)[1]+&quot;。&quot;),
                  array
                  );
    &#125;
&#125;
</code></pre>
<h4 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h4><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code>java.util.function.Predicate</code> 接口。</p>
<pre><code class="java">public class Demo15PredicateTest&#123;
    private static void metho(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.test(&quot;HelloWorld&quot;);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &gt; 5);
    &#125;
&#125;
// 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。
</code></pre>
<h5 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h5><p>既然是条件判断，就会存在<strong>与、或、非</strong>三种常见的逻辑关系。其中将两个 <code>Predicate</code> 条件使用“与”逻辑连接起来实 现“<strong>并且</strong>”的效果时，可以使用default方法 and 。其JDK源码为：</p>
<pre><code class="java">defalult Predicate&lt;T&gt; and(Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) &amp;&amp; other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h5><pre><code class="java">defalult Predicate&lt;T&gt; or (Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) || other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：negate-“非”-取反"><a href="#默认方法：negate-“非”-取反" class="headerlink" title="默认方法：negate (“非”[取反])"></a>默认方法：negate (“非”[取反])</h5><pre><code class="java">default Predicate&lt;T&gt; negate()&#123;
    return (t) -&gt; !test(t);
&#125;
</code></pre>
<p>从现实中很容易看出，它是执行了test方法之后，对结果boolean值进行”!”取反而已。一定要在<code>test</code>方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样</p>
<pre><code class="java">public class Demo17PredicateNegate&#123;
    private static void methodW(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.negate().test(&quot;HelloWorld&quot;);
        System.out.println(&quot;字符串很长吗：&quot; + veryLong);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &lt; 5);
    &#125;
&#125;
</code></pre>
<h3 id="集合信息筛选"><a href="#集合信息筛选" class="headerlink" title="集合信息筛选"></a>集合信息筛选</h3><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>数组当中有多条“姓名+性别”的信息如下，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 <code>ArrayList</code> 中，需要同时满足两个条件：</p>
<blockquote>
<ol>
<li>必须为女生； </li>
<li>姓名为4个字。</li>
</ol>
</blockquote>
<pre><code class="java">public class DemoPredicate &#123;
    public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
    &#125;
&#125;
</code></pre>
<h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><pre><code class="java"> public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        List&lt;String&gt; list = filter(array,
                s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]),
                s -&gt; s.split(&quot;,&quot;)[0].length() == 4);
        System.out.println(list);
    &#125;
 private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       List&lt;String&gt; list = new ArrayList&lt;&gt;();
       for (String info : array)&#123;
           if (one.and(two).test(info))&#123;
               list.add(info);
           &#125;
       &#125;
       return list;
 &#125;
</code></pre>
<h4 id="Stream流高级改造"><a href="#Stream流高级改造" class="headerlink" title="Stream流高级改造"></a>Stream流高级改造</h4><pre><code class="java">public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        Arrays.stream(array)
                .filter(s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]))
            //  .filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;))
                .filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3)
                .forEach(System.out::println);
&#125;
</code></pre>
<h4 id="Stream流式思想改造"><a href="#Stream流式思想改造" class="headerlink" title="Stream流式思想改造"></a>Stream流式思想改造</h4><pre><code class="java"> public static void main(String[] args) &#123;
        Stream&lt;String&gt;original = Stream.of(&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; );
        Stream&lt;String&gt;result1 = original.filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;));
        Stream&lt;String&gt;result2 = result1.filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3);
        result2.forEach(System.out::println);
    &#125;
</code></pre>
<h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h4><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者成为后置条件。</p>
<h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p><code>apply Function</code> 接口中最主要的抽象方法为：<code>R apply(T t)</code> ，根据类型T的参数获取类型R的结果。 使用的场景例如：将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p>
<pre><code class="java">private static void method(Function&lt;String,Integer&gt; function)&#123;
     int num = function.apply(&quot;10&quot;);
     System.out.println(num + 10);
&#125;

public static void main(String[] args) &#123;
     method(s -&gt; Integer.parseInt(s));
&#125;
</code></pre>
<h4 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作</p>
<pre><code class="java">default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)&#123;
    Objects.requireNonNull(after);
    return (T t) -&gt; after.apply(apply(t));
&#125;
</code></pre>
<p>该方法同样用于“先做什么，再做什么”的场景，和 <code>Consumer</code> 中的 <code>andThen</code> 差不多：</p>
<pre><code class="java">public class Demo12FunctionAndThen &#123;
    private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
    public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
    &#125;
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。 </p>
<pre><code class="java">private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p>
<blockquote>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
</blockquote>
<h4 id="自定义函数模型拼接"><a href="#自定义函数模型拼接" class="headerlink" title="自定义函数模型拼接"></a>自定义函数模型拼接</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br> <code>String str = &quot;赵丽颖,20&quot;</code></p>
<p>1.将字符串截取数字年龄部分，得到字符串；<br>2.将上一步的字符串转换成为int类型的数字；<br>3.将上一步的int数字累加100，得到结果int数字。</p>
<h5 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">private static int getAgeNum(String str, Function&lt;String, String&gt;one, Function&lt;String, Integer&gt;two, Function&lt;Integer, Integer&gt; three)&#123;
    return one.andThen(two).andThen(three).apply(str);
&#125;

public static void main(String[] args) &#123;
    String str = &quot;赵丽颖,20&quot;;
    int age = getAgeNum(str,
         s -&gt; s.split(&quot;,&quot;)[1],
         s -&gt; Integer.parseInt(s),
         n -&gt; n += 100);
    System.out.println(age);
&#125;
</code></pre>
<h1 id="Stream流、方法引用"><a href="#Stream流、方法引用" class="headerlink" title="Stream流、方法引用"></a>Stream流、方法引用</h1><p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带 来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p>
<p>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现： </p>
<ul>
<li>for循环的语法就是“怎么做” </li>
<li>for循环的循环体才是“做什么”</li>
</ul>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从 第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p>
<p>试想一下，如果希望对集合中的元素进行筛选过滤：<br>1.将集合A根据条件一过滤为子集B；<br>2.然后再根据条件二过滤为子集C。</p>
<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</p>
<h4 id="Stream更优写法"><a href="#Stream更优写法" class="headerlink" title="Stream更优写法"></a>Stream更优写法</h4><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码 中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张无忌&quot;);
        list.add(&quot;周芷若&quot;);
        list.add(&quot;赵敏&quot;);
        list.add(&quot;张强&quot;);
        list.add(&quot;张三丰&quot;);
        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println);

    &#125;
</code></pre>
<blockquote>
<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素（或其地址值)。</p>
</blockquote>
<h5 id="Stream-流-是一个来自数据源的元素队列"><a href="#Stream-流-是一个来自数据源的元素队列" class="headerlink" title="Stream(流)是一个来自数据源的元素队列"></a>Stream(流)是一个来自数据源的元素队列</h5><ul>
<li>元素是特定类型的对象，形成一个队列。java中的stream并不会存储元素，而是按需计算</li>
<li><strong>数据源</strong>流的来源：可以是<strong>集合，数组</strong>等</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者增强for的方式，显示的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法<code>forEach(System.out::println)</code></li>
</ul>
<p>当使用一个流的时候，通常包括三个步骤：获取一个<strong>数据源(source) → 数据转换 → 执行操作获取想要的结果</strong>，每次转换原有Stream对象不改变，返回一个新的Stream对象(可以有多次转换)，这就允许对其操作可以像链条一样排列，变成一个管道</p>
<h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code>是最常用的流接口<br>获取方式：<br>**1.**所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流<br><strong>2.</strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流</p>
<h5 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h5><p>首先<code>java.util.Collection</code>接口中加入了default方法<code>stream</code>用来获取流，所以其所有实现类均可获取流</p>
<pre><code class="java">public static void main(String[] args) &#123;
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream1 = list.stream();

    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream2 = set.stream();

    Vector&lt;String&gt; vector = new Vector&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream3 = vector.stream();
    &#125;
</code></pre>
<h5 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h5><p><code>Java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分<strong>key、value</strong>或<strong>entry</strong>等情况：</p>
<pre><code class="java">public class Demo05GetStream &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        // ...
        Stream&lt;String&gt; keyStream = map.keySet().stream();
        Stream&lt;String&gt; valueStream = map.values().stream();
        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();
    &#125;
&#125;
</code></pre>
<h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <strong>Stream</strong> 接口中提供了静态方法 <strong>of</strong> ，使用很简单：</p>
<pre><code class="java">public static void main(String[] args) &#123;
     String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;;
     Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
<p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p>
<ul>
<li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li>
<li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li>
</ul>
<h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h3><p>虽然方法名字叫 <code>forEach</code>，但是与for循环中的“for-each”昵称不同。<br>该方法接收一个 <code>Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。</p>
<pre><code class="java">void forEach(Consumer&lt;? super ?&gt; action);  
</code></pre>
<h3 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h3><pre><code class="java">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。
Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。
    
import java.util.stream.Stream;
  public class Demo12StreamForEach &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        stream.forEach(name‐&gt; System.out.println(name));
    &#125;
&#125;
</code></pre>
<h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><p>可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。方法签名：</p>
<pre><code class="java">Stream&lt;T&gt; filer(Predicate&lt;? super T&gt; predicate);
</code></pre>
<p>该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<h3 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h3><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">boolean test(T t);
</code></pre>
<p>该方法会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的<code>filter</code>方法将会留用元素；如果结果为false，那么<code>filter</code>方法将会舍弃元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 filter 方法基本使用的代码如：</p>
<pre><code class="java">public class Demo07StreamFilter &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法</p>
<pre><code class="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);
</code></pre>
<p>该接口需要一个 <strong>Function</strong> 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<h3 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h3><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">R apply(T t);
</code></pre>
<p>这可以将一种T类型转换成R类型，这种转换的动作，叫做<strong>映射</strong></p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 <code>map</code> 方法基本使用的代码如：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;10&quot;,&quot;22&quot;,&quot;452&quot;);
    Stream&lt;Integer&gt; result = original.map(str -&gt; Integer.parseInt(str));
    result.forEach(System.out::println);
&#125;
</code></pre>
<p>这段代码中,<code>map</code> 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。</p>
<h3 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h3><p>正如旧集合 <code> Collection</code>  当中的 <code> size</code>  方法一样，流提供 <code> count</code>  方法来数一数其中的元素个数：</p>
<pre><code class="java">long count();
</code></pre>
<p>该方法返回一个long值代表元素个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    System.out.println(result.count()); // 2
&#125;
</code></pre>
<h3 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h3><p><code>limit</code> 方法可以对流进行截取，只取用前n个。方法签名</p>
<pre><code class="java">Stream&lt;T&gt; limit(long maxSize);
</code></pre>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用:</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.limit(2);
    result.forEach(System.out::println); // 张无忌 张三丰
    System.out.println(result.count()); // 2
    &#125;
&#125;
</code></pre>
<h3 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流：<br>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<pre><code class="java">public class Demo11StreamSkip &#123;
    public static void main(String[] args) &#123;
         Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
         Stream&lt;String&gt; result = original.skip(2);
         result.forEach(System.out::println); // 周芷若
&#125;
</code></pre>
<h3 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code> ：</p>
<pre><code class="java">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)
// 这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;);
    Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;);
    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);
    &#125;
&#125;
</code></pre>
<h3 id="集合元素处理-Stream方式）"><a href="#集合元素处理-Stream方式）" class="headerlink" title="集合元素处理(Stream方式）"></a>集合元素处理(Stream方式）</h3><h5 id="题目-Stream流式处理方式"><a href="#题目-Stream流式处理方式" class="headerlink" title="题目(Stream流式处理方式)"></a>题目(Stream流式处理方式)</h5><blockquote>
<p>第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；<br>第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人<br>将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。</p>
</blockquote>
<pre><code class="java">public class Person &#123;
    private String name;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class test &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; one = new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);

        List&lt;String&gt; two = new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);

        // 第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；
        Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == 3).limit(3);
        // 第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人；
        Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2);
        // 将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。
        Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);

    &#125;
&#125;
</code></pre>
<h3 id="Lambda方法引用"><a href="#Lambda方法引用" class="headerlink" title="Lambda方法引用"></a>Lambda方法引用</h3><p>请注意其中的<strong>双冒号 ::</strong> 写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p>
<pre><code class="java">简单的函数式接口以应用Lambda表达式:
@FunctionalInterface
public interface Printable &#123;
    void print(String str);
&#125;
</code></pre>
<pre><code class="java">private static void printString(Printable data)&#123;
    data.print(&quot;Hello, World!&quot;);
&#125;
public static void main(String[] args)&#123;
    printString(System.out::println);
&#125;
</code></pre>
<h3 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a><span style = "color:red">方法引用符</span></h3><h6 id="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑"><a href="#引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑" class="headerlink" title="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?"></a>引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?</h6><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。<u>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者</u>。</p>
<p>例如上例中， <code>System.out</code> 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li>
<li>方法引用写法：<code>System.out::println</code></li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 <code>System.out.println</code> 方法去处理。<br>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p>注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
<p><strong>三种主要使用情况：</strong></p>
<p>情况1：对象名::实例方法名<br>情况2：类名::静态方法名<br>情况3：类名::实例方法名</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yu411W77v/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【方法引用】Java语法中的双冒号::到底是啥意思？_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NK411f7Z5/?spm_id_from=333.788.recommend_more_video.1&vd_source=a4d980c3208d51858f08b3025a6ab2d9">lambda的双冒号是什么意思一个视频简简单单说清楚_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19W4y1W7G2/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【java面试技巧】双冒号之方法引用大家快来看看吧_哔哩哔哩_bilibili</a></p>
</blockquote>
<pre><code class="java">interface A&#123;
    int method(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        A a1 = str -&gt; Integer.valueOf(str);
        System.out.println(a1.method(&quot;111&quot;));

        A a2 = Integer::valueOf;
        System.out.println(a2.method(&quot;444&quot;));

        A a = new A() &#123; //因为A是接口所以直接new不了 加上大括号 匿名内部类
            @Override
            public int method(String str) &#123;
                return new Integer(str); //封装 拆箱
            &#125;
        &#125;;
        A a3 = Integer::new;
        System.out.println(a3.method(&quot;666&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p>
<pre><code class="java">@FunctionalInterface
public interface PrintableInteger &#123;
    void print(int str);
&#125;
-------------------------------------------------------------
public class Demo03PrintOverload &#123;
    private static void printInteger(PrintableInteger data) &#123;
        data.print(1024);
&#125;
public static void main(String[] args) &#123;
    printInteger(System.out::println);
&#125;
    // 这次方法引用将会自动匹配到 println(int) 的重载形式。
</code></pre>
<h4 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h4><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<pre><code class="java">@FuctionalInterface
public interface Calcable &#123;
    double calc(int num);
&#125;
</code></pre>
<pre><code class="java">private static void method(int num, Calcable lambda)&#123;
     System.out.println(lambda.calc(num));
&#125;

public static void main(String[] args) &#123;
     method(10, Math::sqrt);
    // method(‐10, n ‐&gt; Math.abs(n)); 舍弃
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式:  <code>n -&gt; Math.abs(n)</code></li>
<li>方法引用: <code>Math::abs</code></li>
</ul>
<h4 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<pre><code class="java">public interface Greetable &#123;
    void greet();
&#125;
</code></pre>
<p>然后是父类<code>Human</code>内容</p>
<pre><code class="java">public class Human &#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
</code></pre>
<p>最后是子类<code>Man</code>的内容，其中使用了Lambda写法</p>
<pre><code class="java">public class Man extends Human &#123;
    @Override
    public void sayHello() &#123;
        System.out.println(&quot;大家好，我是Man!&quot;);
    &#125;
    //定义方法method，参数传递Greetable接口
    public void method(Greetable g)&#123;
        g.greet();
    &#125;

    public void show()&#123;
        method(super::sayHello);
    &#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li><p>Lambda表达式： <code>() -&gt; super.sayHello()</code></p>
</li>
<li><p>方法引用： <code>super::sayHello</code></p>
</li>
</ul>
<h4 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用**<code>“this::成员方法”</code>**的格式来使用方 法引用。首先是简单的函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface Richable &#123;
    void buy();
&#125;
</code></pre>
<p>下面是一个丈夫 <code>Husband</code> 类：</p>
<pre><code class="java">public class Husband &#123;
    private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
    public void beHappy() &#123;
        marry(() ‐&gt; System.out.println(&quot;买套房子&quot;));
    &#125;
&#125;
</code></pre>
<p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对<code>Husband</code>丈夫类进行修改：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(() ‐&gt; this.buyHouse());
    &#125;
&#125;
</code></pre>
<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(this::buyHouse);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; this.buyHouse()</code> </li>
<li>方法引用： <code>this::buyHouse</code></li>
</ul>
<h4 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h4><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单 的<code>Person</code>类：</p>
<pre><code class="java">public class Person &#123;
    private String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p>
<pre><code class="java">public interface PersonBuilder &#123;
    Person buildPerson(String name);
&#125;
</code></pre>
<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo09Lambda &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
        System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, name ‐&gt; new Person(name));
    &#125;
&#125;
</code></pre>
<p><strong>但是通过构造器引用，有更好的写法：</strong></p>
<pre><code class="java">public class Demo10ConstructorRef &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
           System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, Person::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>name -&gt; new Person(name) </code></li>
<li>方法引用： <code>Person::new</code></li>
</ul>
<h4 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h4><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface ArrayBuilder &#123;
    int[] buildArray(int length);
&#125;
</code></pre>
<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo11ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, length ‐&gt; new int[length]);
    &#125;
&#125;
</code></pre>
<p>但是更好的写法是使用数组的构造器引用：</p>
<pre><code class="java">public class Demo12ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, int[]::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>length -&gt; new int[length] </code></li>
<li>方法引用： <code>int[]::new</code></li>
</ul>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>