
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || Java复习款练习题</title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Java复习款练习题 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/22
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/后端" style=color:#00bcd4>
                    后端
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <h1 id="Collection集合习题"><a href="#Collection集合习题" class="headerlink" title="Collection集合习题"></a>Collection集合习题</h1><h3 id="练习：Collection集合统计元素出现次数"><a href="#练习：Collection集合统计元素出现次数" class="headerlink" title="练习：Collection集合统计元素出现次数"></a>练习：Collection集合统计元素出现次数</h3><p>给定以下代码，请定义方法listTest()统计集合中指定元素出现的次数，如”a”: 2,”b”: 2,”c” :1, “xxx”:0</p>
<pre><code class="java">   public static void main(String[] args) &#123;
        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;a&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;c&quot;);
        System.out.println(&quot;a:&quot;+listTest(list, &quot;a&quot;));
        System.out.println(&quot;b:&quot;+listTest(list, &quot;b&quot;));
        System.out.println(&quot;c:&quot;+listTest(list, &quot;c&quot;));
        System.out.println(&quot;xxx:&quot;+listTest(list, &quot;xxx&quot;));
    &#125;
    private static int listTest(Collection&lt;String&gt; list, String s)&#123;
        int count = 0;
        for (String string : list)&#123;
            if (s.equals(string))&#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：Collection集合数组转集合"><a href="#练习：Collection集合数组转集合" class="headerlink" title="练习：Collection集合数组转集合"></a>练习：Collection集合数组转集合</h3><p>定义一个方法，要求此方法把int数组转成存有相同元素的集合(集合里面的元素是Integer)，并返回。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6&#125;;
        ArrayList&lt;Integer&gt; arrayList = listTest(arr);
        System.out.println(arrayList);
    &#125;
    public static ArrayList&lt;Integer&gt; listTest(int[] arr)&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (Integer a : arr)&#123;
            list.add(a);
        &#125;
        return list;
    &#125;
</code></pre>
<h3 id="练习：Collection集合集合转数组"><a href="#练习：Collection集合集合转数组" class="headerlink" title="练习：Collection集合集合转数组"></a>练习：Collection集合集合转数组</h3><p>定义一个集合，并把集合(集合里面的元素是Integer)转成存有相同元素的数组，并将结果输出在控制台。（可以使用Object[]数组类型接收转换的数组）</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(100);
        list.add(200);
        list.add(300);
        Object[] obj = list.toArray();
        for (int i = 0; i &lt; obj.length; i++) &#123;
            System.out.println(obj[i]);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Object[] toArray()</p>
<p>以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。  因此，调用者可以自由地修改返回的数组。 </p>
</blockquote>
<h3 id="练习：Collection集合contains-方法使用"><a href="#练习：Collection集合contains-方法使用" class="headerlink" title="练习：Collection集合contains()方法使用"></a>练习：Collection集合contains()方法使用</h3><p>定义一个方法listTest(ArrayList &lt; String &gt; a1, String s),要求使用contains()方法判断a1集合里面是否包含s。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;itcast&quot;);
        list.add(&quot;itheima&quot;);
        list.add(&quot;java&quot;);
        System.out.println(listTest(list,&quot;Java&quot;));
    &#125;

    private static boolean listTest(ArrayList&lt;String&gt; a1, String s)&#123;
        if (a1.contains(s))&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：Collection集合isEmpty-方法的使用"><a href="#练习：Collection集合isEmpty-方法的使用" class="headerlink" title="练习：Collection集合isEmpty()方法的使用"></a>练习：Collection集合isEmpty()方法的使用</h3><p>定义一个方法listTest(ArrayList&lt; String &gt; a1), 要求使用isEmpty()判断a1里面是否有元素。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;1&quot;);
        System.out.println(listTest(list));
    &#125;
    public static boolean listTest(ArrayList&lt;String&gt;a1)&#123;
        if (a1.isEmpty())&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：简述迭代器的实现原理"><a href="#练习：简述迭代器的实现原理" class="headerlink" title="练习：简述迭代器的实现原理"></a>练习：简述迭代器的实现原理</h3><p>当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h3 id="练习：Collection集合返回首次出现索引"><a href="#练习：Collection集合返回首次出现索引" class="headerlink" title="练习：Collection集合返回首次出现索引"></a>练习：Collection集合返回首次出现索引</h3><p>定义一个方法listTest(ArrayList&lt; Integer &gt; a1, Integer s)，要求返回s在a1里面第一次出现的索引，如果s没出现过返回-1。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //定义集合，添加数据
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        System.out.println(listTest(list,5));
    &#125;
    private static int listTest(ArrayList&lt;Integer&gt;a1, Integer s)&#123;
        for (int i = 0; i &lt; a1.size(); i++) &#123;
            if (a1.get(i).equals(s))&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<h1 id="File类-amp-递归-amp-FileFilter习题"><a href="#File类-amp-递归-amp-FileFilter习题" class="headerlink" title="File类&amp;递归&amp;FileFilter习题"></a>File类&amp;递归&amp;FileFilter习题</h1><h3 id="练习：检查文件是否存在，文件的创建"><a href="#练习：检查文件是否存在，文件的创建" class="headerlink" title="练习：检查文件是否存在，文件的创建"></a>练习：检查文件是否存在，文件的创建</h3><p>描述：检查D盘下是否存在文件a.txt,如果不存在则创建该文件。</p>
<p><strong>操作步骤:</strong><br>1.使用绝对路径创建对象关联到D盘的a.txt。<br>2.通过文件对象方法判断文件是否存在。<br>3.不存在则调用创建文件的方法创建文件。</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa.txt&quot;);
        if (!f.exists())&#123;
            f.createNewFile();
        &#125;
    &#125;
</code></pre>
<h3 id="练习：单极文件夹的创建"><a href="#练习：单极文件夹的创建" class="headerlink" title="练习：单极文件夹的创建"></a>练习：单极文件夹的创建</h3><p>描述：在D盘下创建一个名为bbb的文件夹。</p>
<p><strong>操作步骤:</strong><br>1.创建文件对象指定路径为d:&#x2F;bbb<br>2.调用文件对象创建文件夹的方法</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa&quot;);
        // File f = new File(&quot;D:\\Clash\\aaa\\bbb&quot;);
        f.mkdir();
        // f.mkdirs(); 创建多级文件夹
    &#125;
</code></pre>
<h3 id="练习：删除文件和文件夹"><a href="#练习：删除文件和文件夹" class="headerlink" title="练习：删除文件和文件夹"></a>练习：删除文件和文件夹</h3><p>描述：将D盘下a.txt文件删除。将D盘下aaa文件夹删除,要求文件夹aaa是一个空文件夹。</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联路径：d:&#x2F;a.txt<br>2.调用文件对象删除文件的方法<br>3.创建文件对象关联路径：d:&#x2F;aaa<br>4 调用文件对象删除文件夹的方法.</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;d:/a.txt&quot;);
        // 删除文件
        f.delete();
        
        // 创建文件夹对象
        File dir = new File(&quot;d:/aaa&quot;);
        // 删除文件夹
        dir.delete();
    &#125;
</code></pre>
<h3 id="获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径"><a href="#获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径" class="headerlink" title="获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径"></a>获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径</h3><p>描述：获取D盘aaa文件夹中b.txt文件的文件名，文件大小，文件的绝对路径和父路径等信息，并将信息输出在控制台。</p>
<p><strong>操作步骤:</strong></p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;D:\\Clash\\a.txt&quot;);
        // 获得文件名
        String filename = f.getName();
        // 获得文件大小
        long filesize = f.length();
        // 获得文件的绝对路径
        String path = f.getAbsolutePath();
        // 获得父文件夹路径，返回字符串
        String parentPath = f.getParent();
        // 获得父文件夹路径，返回文件对象
        File parentFile = f.getParentFile();
        // 输出信息
        System.out.println(&quot;文件名：&quot; + filename);
        System.out.println(&quot;文件大小：&quot; + filesize);
        System.out.println(&quot;文件路径：&quot; + path);
        System.out.println(&quot;文件父路径：&quot; + parentPath);
        System.out.println(&quot;文件父路径：&quot; + parentFile);
    &#125;
</code></pre>
<h3 id="练习-文件夹或文件的判断"><a href="#练习-文件夹或文件的判断" class="headerlink" title="练习:文件夹或文件的判断"></a>练习:文件夹或文件的判断</h3><p>描述:</p>
<p>1.判断File对象是否是文件,是文件则输出：xxx是一个文件，否则输出：xxx不是一个文件。<br>2.判断File对象是否是文件夹,是文件夹则输出：xxx是一个文件夹，否则输出：xxx不是一个文件夹。(xxx是文件名或文件夹名)</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建两个文件对象分别关联到不同的文件，比如：d:&#x2F;a.txt，d:&#x2F;aaa<br>2.调用文件对象的判断是否是文件或是否是文件夹的方法<br>3.获得文件名，根据判断结果输出信息。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
       File f = new File(&quot;D:\\Clash\\a.txt&quot;);
       if (f.isFile())&#123;
           System.out.println(f.getName() + &quot;是文件&quot;);
       &#125;else &#123;
           System.out.println(f.getName() + &quot;不是文件&quot;);
       &#125;

       File f2 = new File(&quot;D:\\Clash&quot;);
       if (f2.isDirectory())&#123;
           System.out.println(f2.getName() + &quot;是文件夹&quot;);
       &#125;else&#123;
           System.out.println(f2.getName() + &quot;不是文件夹&quot;);
       &#125;
    &#125;
</code></pre>
<h3 id="练习：文件夹的获取方式"><a href="#练习：文件夹的获取方式" class="headerlink" title="练习：文件夹的获取方式"></a>练习：文件夹的获取方式</h3><p>描述:</p>
<p>获取指定文件夹下所有的文件，并将所有文件的名字输出到控制台。<br>注意：不包含子文件夹下的文件</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联到指定文件夹，比如：c:&#x2F;aaa<br>2.调用文件对象的listFiles方法获得文件数组<br>3.遍历文件数组将每一个文件的名字输出到控制台</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        File f = new File(&quot;D:\\Clash&quot;);
        File[] files = f.listFiles();
        for (File file : files)&#123;
            System.out.println(file.getName());
        &#125;
    &#125;
</code></pre>
<h1 id="List集合-amp-Set集合习题"><a href="#List集合-amp-Set集合习题" class="headerlink" title="List集合&amp;Set集合习题"></a>List集合&amp;Set集合习题</h1><h3 id="练习：List接口的特点"><a href="#练习：List接口的特点" class="headerlink" title="练习：List接口的特点"></a>练习：List接口的特点</h3><h6 id="简述List接口的特点"><a href="#简述List接口的特点" class="headerlink" title="简述List接口的特点"></a>简述List接口的特点</h6><p>★ 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的读取顺序按照11、22、33的顺序完成的<br>★ 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)<br>★ 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</p>
<h3 id="练习：hashCode和equals方法"><a href="#练习：hashCode和equals方法" class="headerlink" title="练习：hashCode和equals方法"></a>练习：hashCode和equals方法</h3><h6 id="请简述HashSet去除重复元素的原理"><a href="#请简述HashSet去除重复元素的原理" class="headerlink" title="请简述HashSet去除重复元素的原理"></a>请简述HashSet去除重复元素的原理</h6><p>★ 调用被添加元素的hashCode(), 和HashSet中已有元素的hasCode比较是否相同<br>★ 如果不同，直接存储<br>★ 如果相同，调用equals方法比较是否相同<br>★ 不相同，直接存储元素<br>★ 相同，认为是同一元素，不存储</p>
<h3 id="练习：数据结构"><a href="#练习：数据结构" class="headerlink" title="练习：数据结构"></a>练习：数据结构</h3><h6 id="简述常见的数据结构中元素的存储特点"><a href="#简述常见的数据结构中元素的存储特点" class="headerlink" title="简述常见的数据结构中元素的存储特点"></a>简述常见的数据结构中元素的存储特点</h6><p>★ 栈：stack，又称堆栈，对元素的存取特点是<strong>先进后出</strong>。即，存进去的元素，要在后它后面的元素一次取出后，才能取出该元素<br>★ 队列：queue，简称队，对元素的存取特点是<strong>先进先出</strong>。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素<br>★ 数组：Array，是有序的元素序列，对元素的存储特点是：<br>1,查找元素快：通过索引，可以快速访问指定位置的元素<br>2.增删元素慢<br><strong>(1)</strong>.指定索引位置增加元素：需要创建一个新数组，将指定元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置<br><strong>(2)</strong>.指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中<br>★ 链表：linkedlist 对元素的存取有如下的特点：<br>**(1).**多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的      右手拉住下个人的左手，依次类推，这样多个人就连在一起了。<br>**(2).**查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。<br><strong>(3)</strong>.增删元素快：<br>增加元素：只需要修改连接下个元素的地址即可。<br>删除元素：只需要修改连接下个元素的地址即可。</p>
<h3 id="练习：Comparable和Comparator比较器"><a href="#练习：Comparable和Comparator比较器" class="headerlink" title="练习：Comparable和Comparator比较器"></a>练习：Comparable和Comparator比较器</h3><p>简述 <code>Comparable </code>和 <code>Comparator</code> 两个接口的区别</p>
<p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的<code>compareTo</code>方法被称为它的自然比较方法。只能再类中实现<code>compareTo()</code>一次，不能经常修改的代码实现自己想要的排序。实现此接口的对象列表(和数组)可以通过<code>Collections.sort</code> 或 <code>Arrays.sort</code> 从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h3 id="练习：LinkedList方法的使用"><a href="#练习：LinkedList方法的使用" class="headerlink" title="练习：LinkedList方法的使用"></a>练习：LinkedList方法的使用</h3><h6 id="根据要求练习LinkedList方法："><a href="#根据要求练习LinkedList方法：" class="headerlink" title="根据要求练习LinkedList方法："></a>根据要求练习LinkedList方法：</h6><p><strong>(1)</strong>.基本方法：add, set, get, remove, clear, size等方法；<br><strong>(2)</strong>.特有方法：addFirst, addLast, getFirst, getLast, removeFirst, removeLast, push, pop, clear等方法。</p>
<pre><code class="java">(1).基本方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; arr = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹风&quot;);
        arr.add(&quot;西门吹水&quot;);

        // 3.使用add方法在指定索引添加元素
        arr.add(2, &quot;西门吹雨&quot;);

        // 4.使用set方法修改指定位置索引
        arr.set(0, &quot;东门&quot;);

        for (String str : arr) &#123;
            System.out.println(str);
        &#125;
        System.out.println(&quot;--------------&quot;);
        // 5.使用get方法获取指定索引的元素
        System.out.println(arr.get(1));

        // 6.使用size方法获取集合大小
        System.out.println(arr.size());

        // 7.使用remove方法删除指定索引的元素
        arr.remove(3);

        // 8.使用clear清空集合中的元素
        arr.clear();
        System.out.println(arr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">(2).特有方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; linked = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        linked.add(&quot;周杰伦&quot;);
        linked.add(&quot;周星驰&quot;);
        linked.add(&quot;周华健&quot;);
        linked.add(&quot;周润发&quot;);

        // 3.使用addFirst添加元素到集合最前面
        linked.addFirst(&quot;周传雄&quot;);

        // 4.使用addLast添加元素到集合最后面
        linked.addLast(&quot;周渝民&quot;);

        System.out.println(linked);

        // 5.使用getFirst获取集合第一个元素
        System.out.println(linked.getFirst());

        // 6.使用getLast获取集合最后一个元素
        System.out.println(linked.getLast());

        // 7.使用removeLast删除集合第一个元素
        String first = linked.removeFirst();
        System.out.println(first);

        // 8.使用removeLast删除集合最后一个元素
        String last = linked.removeLast();
        System.out.println(last);
        System.out.println(linked);


        // 9.使用pop弹出第一个元素
        String p = linked.pop();
        System.out.println(p);

        // 10.使用push在集合开头插入元素
        linked.push(&quot;周立波&quot;);
        System.out.println(linked);

        // 11.使用clear清空集合
        linked.clear();
        System.out.println(linked);
    &#125;
&#125;
</code></pre>
<h3 id="练习：HashSet存储自定义类型"><a href="#练习：HashSet存储自定义类型" class="headerlink" title="练习：HashSet存储自定义类型"></a>练习：HashSet存储自定义类型</h3><p>定义人类，包含姓名和年龄属性。创建4个人存储到<strong>HashSet</strong>中，姓名和年龄相同的人看做同一人不存储。</p>
<pre><code class="java">// 1.定义Person类.包好姓名年龄属性,重写hashCode()和equals()方法
public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        return name != null ? name.equals(person.name) : person.name == null;
    &#125;

    @Override
    public int hashCode() &#123;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
</code></pre>
<pre><code class="java">ublic class HashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 2.创建HashSet用于存储Person类型
        HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;();

        // 3.添加多个Person到HashSet中
        hashSet.add(new Person(&quot;王昭君&quot;, 21));
        hashSet.add(new Person(&quot;西施&quot;, 21));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));

        // 4.遍历获取HashSet中的内容
        for (Person p : hashSet) &#123;
            System.out.println(p);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：List集合元素替换"><a href="#练习：List集合元素替换" class="headerlink" title="练习：List集合元素替换"></a>练习：List集合元素替换</h3><p>向list集合添加姓名{张三,李四,王五,二丫,钱六,孙七}, 将二丫替换为王小丫</p>
<pre><code class="java">public class ListTest01 &#123;
    public static void main(String[] args) &#123;
        //1.创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        //2.存入数据
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;二丫&quot;);
        list.add(&quot;钱六&quot;);
        list.add(&quot;孙七&quot;);
        //3.遍历集合，找到&quot;二丫&quot;,便将其替换为&quot;王小丫&quot;
        //利用普通for循环遍历List集合
        for(int i = 0;i&lt;list.size();i++) &#123;
            //获取当前元素
            String thisName = list.get(i);
            //如果当前元素是&quot;二丫&quot;
            if(&quot;二丫&quot;.equals(thisName)) &#123;
                //将其改为&quot;王小丫&quot;
                list.set(i, &quot;王小丫&quot;);
            &#125;
        &#125;
        System.out.println(list);
    &#125;
&#125;

//   使用增强for获取LinkedHashSet中的元素
        for (String str : list)&#123;
           if (&quot;二丫&quot;.equals(str))&#123;
                System.out.println(list);
           &#125;
        &#125;
</code></pre>
<h3 id="练习：LinkedHashSet基本使用"><a href="#练习：LinkedHashSet基本使用" class="headerlink" title="练习：LinkedHashSet基本使用"></a>练习：LinkedHashSet基本使用</h3><p>使用LinkedHashSet存储以下元素：”王昭君”,”王昭君”,”西施”,”杨玉环”,”貂蝉”。使用迭代器和增强for循环遍历LinkedHashSet。</p>
<pre><code class="java">public class LinkedHashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建LinkedHashSet
        LinkedHashSet&lt;String&gt; lhSet = new LinkedHashSet&lt;String&gt;();
        // 2.使用add方法添加元素到LinkedHashSet
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;西施&quot;);
        lhSet.add(&quot;杨玉环&quot;);
        lhSet.add(&quot;貂蝉&quot;);
        // 3.使用迭代器获取LinkedHashSet中的元素
        Iterator&lt;String&gt; iterator = lhSet.iterator();
        while (iterator.hasNext()) &#123;
            System.out.println(iterator.next());
        &#125;
        // 4.使用增强for获取LinkedHashSet中的元素
        System.out.println(&quot;---------------------&quot;);
        for (String string : lhSet) &#123;
            System.out.println(string);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：Collections工具类使用"><a href="#练习：Collections工具类使用" class="headerlink" title="练习：Collections工具类使用"></a>练习：Collections工具类使用</h3><p>ArrayList集合中有如下内容： {33,11,77,55}，使用Collections.sort()对ArrayList集合中的数据进行排序，并打印出排序后的结果</p>
<pre><code class="java">public class CollectionsTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建ArrayList
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();

        // 2.使用add方法添加&#123;33,11,77,55&#125;四个元素
        arr.add(33);
        arr.add(11);
        arr.add(77);
        arr.add(55);

        // 3.调用Collections的sort方法,对集合排序
        Collections.sort(arr);

        // 4.使用增强for遍历ArrayList集合
        for (Integer integer : arr) &#123;
            System.out.println(integer);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Map集合习题"><a href="#Map集合习题" class="headerlink" title="Map集合习题"></a>Map集合习题</h1><h3 id="练习：Map接口的特点"><a href="#练习：Map接口的特点" class="headerlink" title="练习：Map接口的特点"></a>练习：Map接口的特点</h3><h6 id="请简述Map-的特点"><a href="#请简述Map-的特点" class="headerlink" title="请简述Map 的特点"></a>请简述Map 的特点</h6><p>★ Map每个元素由键与值两部分组成<br>★ Map键不能重复，每个键对应一个值<br>★ 键和值可以为null</p>
<h3 id="练习：Entry键值对对象"><a href="#练习：Entry键值对对象" class="headerlink" title="练习：Entry键值对对象"></a>练习：Entry键值对对象</h3><h6 id="说出Entry键值对对象遍历Map集合的原理"><a href="#说出Entry键值对对象遍历Map集合的原理" class="headerlink" title="说出Entry键值对对象遍历Map集合的原理"></a>说出Entry键值对对象遍历Map集合的原理</h6><p>Map中存放的是两种对象，一种称为Key(键)，一种称为value(值)，它们在Map中是一一对应关系，这一种对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每个键值对(Entry)对象中获取对应的键与对应的值。</p>
<h3 id="练习：Map接口中的常用方法"><a href="#练习：Map接口中的常用方法" class="headerlink" title="练习：Map接口中的常用方法"></a>练习：Map接口中的常用方法</h3><h6 id="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"><a href="#请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。" class="headerlink" title="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"></a>请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。</h6><pre><code class="java">    public static void main(String[] args) &#123;
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);
        String v1 = hm.put(&quot;李晨&quot;, &quot;白百合&quot;);
        String string = hm.get(&quot;大黑牛&quot;);
        String v2 = hm.remove(&quot;大黑牛&quot;);
        System.out.println(v2);
        System.out.println(hm);
    &#125;
//  范冰冰  &#123;邓超=孙俪, 李晨=白百合, 黄晓明=Baby&#125;
</code></pre>
<h3 id="练习：Map接口中的方法"><a href="#练习：Map接口中的方法" class="headerlink" title="练习：Map接口中的方法"></a>练习：Map接口中的方法</h3><p>往一个Map集合中添加若干元素。获取Map中的所有value，并使用增强for和迭代器遍历输出每个value。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        // 1.创建HashMap
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();

        // 2.使用put添加元素
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);

        // 3.使用Map的values方法获取到所有的value
        Collection&lt;String&gt; values = hm.values();

        // 4.使用增强for获取每个value
        for (String value : values) &#123;
            System.out.println(value);
        &#125;

        System.out.println(&quot;----------------&quot;);
        // 5.使用迭代器获取每个value
        Iterator&lt;String&gt; itr = values.iterator();
        while (itr.hasNext()) &#123;
            System.out.println(itr.next());
        &#125;
    &#125;
</code></pre>
<h3 id="练习：HashMap存储键是自定义对象是String"><a href="#练习：HashMap存储键是自定义对象是String" class="headerlink" title="练习：HashMap存储键是自定义对象是String"></a>练习：HashMap存储键是自定义对象是String</h3><p>请使用Map集合存储自定义数据类型Car做键，对应的价格做值。并使用keySet和entrySet两种方式遍历Map集合。</p>
<pre><code class="java">        // 1.定义汽车类.包含名称和价格属性,重写hashCode和equals方法
    public class Car &#123;
        private String name;
        private String color;
        ...
    &#125;
---------------------------------------------------
    public static void main(String[] args) &#123;
         // 2.创建HashMapkey保存汽车对象,value是汽车价格
        HashMap&lt;Car, Integer&gt; hm = new HashMap&lt;&gt;();

        // 3.添加汽车到HashMap中
        Car c1 = new Car(&quot;长安奔奔&quot;, &quot;黄色&quot;);
        Car c3 = new Car(&quot;奇瑞QQ&quot;, &quot;黑色&quot;);
        Car c2 = new Car(&quot;铃木奥拓&quot;, &quot;白色&quot;);

        hm.put(c1, 10000);
        hm.put(c2, 20000);
        hm.put(c3, 30000);

         // 4.使用keySet方式遍历Map
        Set&lt;Car&gt; keySet = hm.keySet();
        for (Car c : keySet) &#123;
        // 根据key获取value
            Integer value = hm.get(c);
            System.out.println(c.getName() + &quot;,&quot; + c.getColor() + &quot; - &quot; + value);
        &#125;

        System.out.println(&quot;-------------&quot;);

        // 5.使用entrySet方式遍历Map
        Set&lt;Map.Entry&lt;Car, Integer&gt;&gt; entrySet = hm.entrySet();
        for (Map.Entry&lt;Car, Integer&gt; entry : entrySet) &#123;
            Car key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key.getName() + &quot;,&quot; + key.getColor() + &quot; - &quot; + value);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。  该集合由地图支持，因此对地图的更改将反映在集合中，反之亦然。  如果在集合中的迭代正在进行时修改映射（除了通过迭代器自己的<code>remove</code>操作，或者通过迭代器返回的映射条目上的<code>setValue</code>操作），迭代的结果是未定义的。  该组支持元件移除，即从映射中相应的映射，经由<code>Iterator.remove</code> ，  <code>Set.remove</code> ， <code>removeAll</code> ，  <code>retainAll</code>和<code>clear</code>操作。  它不支持<code>add</code>或<code>addAll</code>操作。</p>
</blockquote>
<h3 id="练习：Map集合的使用-一"><a href="#练习：Map集合的使用-一" class="headerlink" title="练习：Map集合的使用(一)"></a>练习：Map集合的使用(一)</h3><h6 id="现在有一个map集合如下："><a href="#现在有一个map集合如下：" class="headerlink" title="现在有一个map集合如下："></a>现在有一个map集合如下：</h6><pre><code class="java">     Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();
     map.put(1, &quot;张三丰&quot;);
     map.put(2, &quot;周芷若&quot;);
     map.put(3, &quot;汪峰&quot;);
     map.put(4, &quot;灭绝师太&quot;);
</code></pre>
<p><strong>要求：</strong></p>
<p>1.遍历集合，并将序号与对应人名打印。<br>2.向该map集合中插入一个编码为5姓名为李晓红的信息<br>3.移除该map中的编号为1的信息<br>4.将map集合中编号为2的姓名信息修改为”周林”</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义HashMap,编号作为key,姓名作为value
        Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
        // 2.使用put方法添加元素
        map.put(1, &quot;张三丰&quot;);
        map.put(2, &quot;周芷若&quot;);
        map.put(3, &quot;汪峰&quot;);
        map.put(4, &quot;灭绝师太&quot;);
        // 3.使用keySet+增强for迭代map中的元素,并打印
        Set&lt;Integer&gt; keySet = map.keySet();
        for (Integer key : keySet) &#123;
            String value = map.get(key);
            System.out.println(key + &quot; -- &quot; + value);
        &#125;
        // 4.使用put向该map集合中插入一个编码为5姓名为李晓红的信息
        map.put(5, &quot;李晓红&quot;);
        // 5.使用remove移除该map中的编号为1的信息
        map.remove(1);
        // 6.使用put将map集合中编号为2的姓名信息修改为&quot;周林&quot;
        map.put(2, &quot;周林&quot;);
        System.out.println(map);
    &#125;
</code></pre>
<h3 id="练习：Map集合的使用-二"><a href="#练习：Map集合的使用-二" class="headerlink" title="练习：Map集合的使用(二)"></a>练习：Map集合的使用(二)</h3><p>有2个数组<br>第一个数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，<br>第二个数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为<strong>key</strong>，<br>第二个数组元素作为<strong>value</strong>存储到Map集合中。如{黑龙江省&#x3D;哈尔滨, 浙江省&#x3D;杭州, …}</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义第一个数组arr1
        String[] arr1 = &#123;&quot;黑龙江省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;广东省&quot;, &quot;福建省&quot;&#125;;
        // 2.定义第二个数组arr2
        String[] arr2 = &#123;&quot;哈尔滨&quot;, &quot;杭州&quot;, &quot;南昌&quot;, &quot;广州&quot;, &quot;福州&quot;&#125;;

        // 3.创建HashMap,key存放省,value存放市
        HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;();

        // 4.使用普通for循环遍历arr1
        for (int i = 0; i &lt; arr1.length; i++) &#123;
        // 5.根据索引到arr1中获取到省
            String key = arr1[i];
        // 6.根据索引到arr2中获取到省会城市
            String value = arr2[i];

        // 7.将省和省会城市添加到HashMap中
            hm.put(key, value);
        &#125;
        // 8.输出HashMap中的内容
        System.out.println(hm);
    &#125;
</code></pre>
<h1 id="Math类习题"><a href="#Math类习题" class="headerlink" title="Math类习题"></a>Math类习题</h1><h3 id="练习：实现字符串123反转"><a href="#练习：实现字符串123反转" class="headerlink" title="练习：实现字符串123反转"></a>练习：实现字符串123反转</h3><p>使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">        public class Test1 &#123;
            public static void main(String[] args) &#123;
                Scanner scanner = new Scanner(System.in);
                String next = scanner.next();
                System.out.println(&quot;录入的字符串:&quot; + next);
                String s = reverseStr(next);
                System.out.println(&quot;反转的字符串:&quot;+ s);
            &#125;
        
            public static String reverseStr(String  str)&#123;
                String s = &quot;&quot;;
                char[] chars = str.toCharArray();
                for (int i = chars.length - 1; i &gt;= 0; i--) &#123;
                    s +=chars[i] ;
                &#125;
                return s;
            &#125;
        &#125;
</code></pre>
<blockquote>
<p>toCharArray() 方法将字符串转换为字符数组</p>
</blockquote>
<h3 id="练习：键盘录入QQ号判断正确性"><a href="#练习：键盘录入QQ号判断正确性" class="headerlink" title="练习：键盘录入QQ号判断正确性"></a>练习：键盘录入QQ号判断正确性</h3><p>必须是5-12位数字，0不能开头</p>
<pre><code class="java">public class Test1 &#123;
    public static void main(String[] args) &#123;
        //1.键盘输入一个qq号码字符串
        Scanner sc = new Scanner(System.in);
        String qq = sc.next();
        //2.调用checkQQ (String qq)方法内实现验证。
        boolean isOK = checkQQ(qq);
        //3.打印验证的结果
        System.out.println(&quot;这个QQ号码是否正确:&quot; + isOK);
    &#125;

    /*
     * 定义方法：checkQQ (String qq)方法内实现验证
     * 指定方法的名称：checkQQ
     * 指定方法的参数：String qq
     * 指定方法的返回值：boolean
     */
    public static boolean checkQQ(String qq) &#123;
        //1.验证字符串的长度5-12位之间；
        if (qq.length() &lt; 5 || qq.length() &gt; 12) &#123;
            return false; //说明qq号码的长度不正确
        &#125;
        //2.验证首位字符不能是字符0；只能是字符&#39;1&#39;--&#39;9&#39;
        if (qq.charAt(0) == &#39;0&#39;) &#123;
            return false;
        &#125;
        //3.验证字符串中的每个字符都必须是数字字符‘0’-‘9’之间的字符
        for (int i = 0; i &lt; qq.length(); i++) &#123;
            char ch = qq.charAt(i);
            //判断字符是否在 数字字符‘0’-‘9’之间的字符
            if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
                return false;//说明qq号码中含有非数字字符
            &#125;
        &#125;
        //4.上述验证都通过了，说明qq号码是正确的
        return true;
    &#125;
 &#125;
</code></pre>
<h3 id="练习：大小写字符转换并统计次数"><a href="#练习：大小写字符转换并统计次数" class="headerlink" title="练习：大小写字符转换并统计次数"></a>练习：大小写字符转换并统计次数</h3><p>键盘录入一个大字符串，再录入一个小字符串。统计小字符串在大字符串中出现的次数。</p>
<pre><code class="java">   /*
* 分析以下需求，并用代码实现
1.键盘录入一个大字符串,再录入一个小字符串
2.统计小字符串在大字符串中出现的次数
3.代码运行打印格式:
请输入大字符串:woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma
请输入小字符串:heima
控制台输出:小字符串heima,在大字符串woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma中共出现3次
             */

    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        // 1.键盘录入一个大字符串,再录入一个小字符串
        System.out.print(&quot;请输入大字符串:&quot;);
        String big = sc.nextLine();
        System.out.print(&quot;请输入小字符串:&quot;);
        String small = sc.nextLine();
        // 2.统计小字符串在大字符串中出现的次数
        int count = getCount(big, small);
        // 3.代码运行打印格式:
        System.out.println(&quot;小字符串&quot; + small + &quot;,在大字符串中共出现&quot; + count + &quot;次&quot;);
    &#125;

    /*
     * 方法功能：统计小字符串在大字符串中出现的次数
     * 参数：big 代表大字符串
     * 参数：small 代表小字符串
     * 返回值：小字符串在大字符串中出现的次数
     */
    public static int getCount(String big, String small) &#123;
        int index = 0;
        int count = 0;
        /*
         * indexOf(String str, int fromIndex)
         * 该方法作用：从fromIndex位置开始查找，字符串str第一次出现的位置；若没找到，放回-1
         */
        while ((index = big.indexOf(small, index)) != -1) &#123;
            index++;
            count++;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：随机小数保留两位"><a href="#练习：随机小数保留两位" class="headerlink" title="练习：随机小数保留两位"></a>练习：随机小数保留两位</h3><p>生成一个<strong>随机100</strong>内小数，转换为保留两位小数的字符串，不考虑四舍五入的问题。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        double random = Math.random()*100;
        System.out.println(&quot;随机数为：&quot;);
        System.out.println(random);
        String str = random + &quot; &quot;;
        int index = str.indexOf(&quot;.&quot;);
        String substring = str.substring(0, index + 3);
        System.out.println(&quot;转换为&quot;);
        System.out.println(substring);
    &#125;
// substring(int strat, int end)中第一个参数是开始位置，第二个参数是结束位置.
</code></pre>
<h3 id="练习：筛选字符串"><a href="#练习：筛选字符串" class="headerlink" title="练习：筛选字符串"></a>练习：筛选字符串</h3><p>定义ArrayList集合，存入多个字符串。长度大于5的字符串，打印删除后的集合。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;bca&quot;);
        list.add(&quot;dadfa&quot;);
        list.add(&quot;dddaaa&quot;);
        list.add(&quot;你好啊&quot;);
        list.add(&quot;我来啦,你干嘛呢&quot;);
        list.add(&quot;别跑啊&quot;);
        System.out.println(&quot;源字符串：&quot;);
        System.out.println(list);
        delStrsFromList01(list);
    &#125;
    private static void delStrsFromList01(ArrayList&lt;String&gt; list)&#123;
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            String str = list.get(i);
            if (str.length() &gt; 3)&#123;
                list2.add(str);
            &#125;
        &#125;
        for (Object str : list2)&#123;
            list.remove(str);
        &#125;
        System.out.println(&quot;新字符：&quot; + list);
    &#125;
</code></pre>
<h3 id="练习：回文字符串"><a href="#练习：回文字符串" class="headerlink" title="练习：回文字符串"></a>练习：回文字符串</h3><p>判断回文字符串。如果一个字符串，从前向后读和从后向前读，都是一个字符串，称为回文串，比如mom，dad，noon。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        String next = scanner.next();
        boolean p = isP(next);
        System.out.println(
                &quot;回文数:&quot; + p
        );
    &#125;

    public static boolean isP(String str) &#123;
        int start = 0;
        int end = str.length() - 1;
        while (start &lt; end) &#123;
            if (str.charAt(start) != str.charAt(end)) &#123;
                return false;
            &#125;
            start++;
            end--;
        &#125;
        return true;
    &#125;
</code></pre>
<blockquote>
<p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
</blockquote>
<h3 id="练习：模拟简单计算器"><a href="#练习：模拟简单计算器" class="headerlink" title="练习：模拟简单计算器"></a>练习：模拟简单计算器</h3><p>模拟简单计算器，可以运算+，—，*，&#x2F;，%。</p>
<ul>
<li>接收三个参数，一个整数，一个运算符，另一个整数。( ‘5’   ‘+’   ‘7’ )</li>
<li>计算出运算结果。</li>
<li>无法运算时，返回null。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        String next = scanner.next();
        int b = scanner.nextInt();
        String count = count(a, next, b);
        System.out.println(a +next +b +&quot;=&quot;+count);
    &#125;

    public static String count(int a, String op , int b )&#123;
        int r=0;
        if (&quot;+&quot;.equals(op))&#123;
            r = a+b;
        &#125;else  if (&quot;-&quot;.equals(op))&#123;
            r = a-b;
        &#125;else  if (&quot;*&quot;.equals(op))&#123;
            r = a*b;
        &#125;else  if (&quot;/&quot;.equals(op))&#123;
            r = a/b;
        &#125;else  if (&quot;%&quot;.equals(op))&#123;
            r = a%b;
        &#125;else &#123;
            return null;
        &#125;
        return r+&quot;&quot;;
    &#125;
</code></pre>
<h3 id="练习：密码是否合法"><a href="#练习：密码是否合法" class="headerlink" title="练习：密码是否合法"></a>练习：密码是否合法</h3><p>校验密码是否合法。合法返回true </p>
<ul>
<li>必须至少8个字符。</li>
<li>必须至少2个大写字符。<code>超越两个就要依次遍历 for循环</code></li>
<li>必须只有字母和数字。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        String s = &quot;qweRY123&quot;;
        System.out.println(s+&quot;密码是否合法&quot;+isTrue(s));
    &#125;
    private static boolean isTrue(String s)&#123;
        if (s.length()&lt;8)&#123;
            return false;
        &#125;

        int countA = 0;
        char[] chars = s.toCharArray();
        for (int i = 0; i &lt; s.length(); i++) &#123;
            char ch = chars[i];
            //2个大写字母
            if (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;)&#123;
                countA++;
            &#125;
            //字母数字
            if ((ch &lt; &#39;0&#39;|| ch&gt;&#39;9&#39;) &amp;&amp; (ch &lt; &#39;A&#39;|| ch&gt;&#39;Z&#39;)&amp;&amp;(ch &lt; &#39;a&#39;|| ch&gt;&#39;z&#39;)) &#123;
                return false;
            &#125;
        &#125;
        if (countA &lt; 2)&#123;
            return false;
        &#125;
        return true;
    &#125;
</code></pre>
<h3 id="练习：模拟用户登录"><a href="#练习：模拟用户登录" class="headerlink" title="练习：模拟用户登录"></a>练习：模拟用户登录</h3><p>模拟用户登录。</p>
<ul>
<li>定义用户类，属性为用户名和密码。</li>
<li>使用集合存储多个用户对象。</li>
<li>录入用户和密码，对比用户信息，匹配成功登录成功，否则登录失败。</li>
<li>登录失败时，当用户名错误，提示没有该用户。</li>
<li>登录失败时，当密码错误时，提示密码有误。</li>
</ul>
<blockquote>
<p>jack-1234    rose-5678    tom-0000<br>请输入用户名：rose<br>请输入密码：5678<br>登录结果：登录成功</p>
</blockquote>
<pre><code class="java">public class User &#123;
    private String username;
    private String pwd;
&#125;
------------------------------------------
public class Test &#123;
    static ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;();
    static &#123;
        list.add(new User(&quot;jack&quot;, &quot;1234&quot;));
        list.add(new User(&quot;rose&quot;, &quot;5678&quot;));
        list.add(new User(&quot;tom&quot;, &quot;0000&quot;));
        for (int i = 0; i &lt; list.size(); i++) &#123;
            list.get(i).show();
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入用户名：&quot;);
        String username = sc.nextLine();
        System.out.println(&quot;请输入密码：&quot;);
        String password = sc.nextLine();
        User u = new User(username, password);
        String login = login(u);
        System.out.println(&quot;登录结果：&quot; + login);
    &#125;
    public static String login(User user) &#123;
        String msg = &quot;&quot;;
        String n = user.getUsername();
        String p = user.getPwd();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            User u = list.get(i);
            String name = u.getUsername();
            String pwd = u.getPwd();
            if (name.equals(n))&#123;
                if (pwd.equals(p))&#123;
                    return &quot;登录成功&quot;;
                &#125;else &#123;
                    return &quot;密码错误&quot;;
                &#125;
            &#125;else &#123;
                msg = &quot;用户名不存在&quot;;
                continue;
                &#125;
            &#125;
        return msg;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p><strong>static代码块</strong>也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，<u>每个代码块只会被执行一次</u>。[ <em><u>在此代码内适用于login方法中的list.size()</u></em> ]<br>static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的，<br>它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p>
</blockquote>
<h1 id="Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类"><a href="#Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类" class="headerlink" title="Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类"></a>Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类</h1><h3 id="练习：简述String和Object中的equals"><a href="#练习：简述String和Object中的equals" class="headerlink" title="练习：简述String和Object中的equals"></a>练习：简述String和Object中的equals</h3><p>简述String类中的equals方法 与 Object类中的equals方法的不同点</p>
<blockquote>
<p><strong>String类</strong>中的equals方法是用来<u>判断两个<strong>对象的内容</strong>是否相同</u>，而<strong>Object 类</strong>中的equals方法是用来<u>判断两个<strong>对象</strong>是否是同一个对象</u>，所谓同一个对象指的是内存中的同一块存储空间。</p>
</blockquote>
<h3 id="练习：Object类的toString方法"><a href="#练习：Object类的toString方法" class="headerlink" title="练习：Object类的toString方法"></a>练习：Object类的toString方法</h3><pre><code class="java">    public class ToStringTest&#123;
        static int i = 1;
        public static void main(String args[])&#123;
            System.out.println(&quot;love &quot; + new ToStringTest());//love java
            ToStringTest a = new ToStringTest();
            a.i++;
            System.out.println(&quot;me &quot; + a.i);//me 2
        &#125;
        public String toString()&#123;
            System.out.print(&quot;I &quot;);//I
            return &quot;java &quot;;
        &#125;
    &#125;
</code></pre>
<p>运行结果：I love java    me 2<br>原因：当执行代码的时候，首先加载静态变量，然后执行main方法，由于main方法内部第一行代码为输出语句，里面new了此类对象，当执行此行代码时会先创建了本类的对象，由于此类重写了toString方法，会先执行toString方法的打印输出，然后返回“java ”，再执行main方法第一行打印输出。在Java中“System.out.println(类对象名);”实际输出的是该对象的toString()方法返回的字符串，即括号中的内容等价于类对象名.toString(),toString方法的好处是在碰到println方法的时候会被自动调用，不用显示的写出来。</p>
<h3 id="练习：Object类equals方法"><a href="#练习：Object类equals方法" class="headerlink" title="练习：Object类equals方法"></a>练习：Object类equals方法</h3><p>看下列程序，不运行说结果，写出答案后，并在IntelliJ IDEA中运行看看自己给的答案与运行结果是否正确，并分析原因。</p>
<pre><code class="java">    (1)
        String s1 = new String(&quot;abc&quot;);
        String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //false
        System.out.println(s1.equals(s2));  //true
    (2)
        String s1 = &quot;abc&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //true
        System.out.println(s1.equals(s2));     //true
    (3)
        String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);        //true
        System.out.println(s1.equals(s2));     //true
    (4)
        String s1 = &quot;ab&quot;;
             String s2 = &quot;abc&quot;;
             String s3 = s1 + &quot;c&quot;;
        System.out.println(s3 == s2);             //false
              System.out.println(s3.equals(s2));  //true
</code></pre>
<h3 id="练习：StringBuilder类与String类的区别"><a href="#练习：StringBuilder类与String类的区别" class="headerlink" title="练习：StringBuilder类与String类的区别"></a>练习：StringBuilder类与String类的区别</h3><p>简述StringBuilder类与String类的区别</p>
<blockquote>
<p><strong>String类</strong>的对象内容不可改变，所以每当进行字符串拼接时，<strong>总是会在内存中创建一个新的对象</strong>，所以经常改变内容的字符串最好不要用String，因为<strong>每次生成对象都会对系统性能产生影响</strong>。</p>
<p><strong>StringBuilder</strong>又称为可变字符序列，是JDK5.0中新增加的一个类，它是一个类似于String的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串，并且能够对其中的字符串进行各种操作。<strong>它的内部拥有一个数组用来存放字符串内容</strong>，进行字符串拼接时，直接在数组中加入新内容，<strong>StringBuilder会自动维护数组的扩容</strong>。</p>
</blockquote>
<h3 id="练习：Date类的使用"><a href="#练习：Date类的使用" class="headerlink" title="练习：Date类的使用"></a>练习：Date类的使用</h3><p>获取当前的日期, 并把这个日期转换为指定格式的字符串, 如2088-08-08 08:08:08</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //获取当前日期对象 now;
        Date now = new Date();
        //创建SimpleDateFormat对象 df,并制定日期格式
        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        //调用df的format(Date  date) 方法,传入now; 接收返回的字符串
        String datestr = df.format(now);
        //打印这个字符串
        System.out.println(datestr);
    &#125;
</code></pre>
<h3 id="练习：DateFormat类方法的使用"><a href="#练习：DateFormat类方法的使用" class="headerlink" title="练习：DateFormat类方法的使用"></a>练习：DateFormat类方法的使用</h3><p>使用SimpleDateFormat类,把2018-03-04转换为2018年03月04日</p>
<pre><code class="java">    public static void main(String[] args) throws ParseException &#123;
        //创建SimpleDateFormat对象df1,指定日期模式为yyyy-MM-dd
        SimpleDateFormat df1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        //调用df1的parse(String str)方法传入2018-03-04,得到对应日期类型
        Date date = df1.parse(&quot;2018-03-04&quot;);
        //创建日期格式化对象df2,在获取格式化对象时可以指定风格
        DateFormat df2 = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
        //调用df2的format(Date date) 传入刚才转换的日期
        String str = df2.format(date);
        System.out.println(str);
    &#125;
</code></pre>
<blockquote>
<p>public Date parse(String text, ParsePosition pos)<br>从字符串中解析文本，产生一个<code>Date</code> 。</p>
</blockquote>
<h3 id="练习：Calendar类方法的使用"><a href="#练习：Calendar类方法的使用" class="headerlink" title="练习：Calendar类方法的使用"></a>练习：Calendar类方法的使用</h3><p>用程序判断2018年2月14日是星期几。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        //创建Calendar对象
        Calendar c = Calendar.getInstance();
        //将给定的日历字段设置到Calendar对象中
        c.set(Calendar.YEAR, 2018);
        c.set(Calendar.MONTH, 1);
        c.set(Calendar.DATE, 14);
        //设置年
        int year = c.get(Calendar.YEAR);
        //设置月
        int month = c.get(Calendar.MONTH)+1;
        //设置日
        int date = c.get(Calendar.DATE);
        //设置星期
        char week = getWeek(c.get(Calendar.DAY_OF_WEEK));
        //输出结果
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日是星期&quot;+week);
    &#125;
    //定义方法，获取星期汉字
    public static char getWeek(int a)&#123;
        char[] c = &#123;&#39; &#39;,&#39;日&#39;,&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;,&#39;六&#39;&#125;;
        return c[a];
    &#125;
&#125;
</code></pre>
<h1 id="Random类-amp-ArrayList集合习题"><a href="#Random类-amp-ArrayList集合习题" class="headerlink" title="Random类&amp;ArrayList集合习题"></a>Random类&amp;ArrayList集合习题</h1><h3 id="练习：随机验证码"><a href="#练习：随机验证码" class="headerlink" title="练习：随机验证码"></a>练习：随机验证码</h3><ul>
<li>随机生成十组六位字符组成的验证码。</li>
<li>验证码由大小写字母、数字字符组成。</li>
</ul>
<p><strong>开发提示</strong>：使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            String s = verifyCode();
            System.out.println(&quot;随机验证码：&quot; + s);
        &#125;
    &#125;
    public static String verifyCode()&#123;
        char[] arr = &#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;;
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            int index = random.nextInt(arr.length);
            code  += arr[index];
        &#125;
        return code;
    &#125;
</code></pre>
<h3 id="练习：输入学生信息保存到集合"><a href="#练习：输入学生信息保存到集合" class="headerlink" title="练习：输入学生信息保存到集合"></a>练习：输入学生信息保存到集合</h3><p>键盘录入学生信息，保存到集合中。</p>
<ul>
<li>循环录入的方式，1：表示继续录入，0：表示结束录入。</li>
<li>定义学生类，属性为姓名，年龄，使用学生对象保存录入数据。</li>
<li>使用ArrayList集合，保存学生对象，录入结束后，遍历集合。</li>
</ul>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
     public void show()&#123;
        System.out.println(&quot;姓名: &quot;+ name + &quot; &quot; + &quot;年龄: &quot; + age);
    &#125;
&#125;
----------------------------------
        public static void main(String[] args) &#123;
            Scanner scanner = new Scanner(System.in);
            ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
            while (true) &#123;
                System.out.println(&quot;1.录入信息 0.退出&quot;);
                int i = scanner.nextInt();
                switch (i) &#123;
                    case 1:
                        inputStu(list , scanner);
                        break;
                    case 0:
                        System.out.println(&quot;录入完毕&quot;);
                &#125;
                if (i == 0)&#123;
                    break;
                &#125;
            &#125;
    
            for (int i = 0; i &lt; list.size(); i++) &#123;
                Student student = list.get(i);
                student.show();
            &#125;
        &#125;
    
        private static void inputStu(ArrayList&lt;Student&gt; list , Scanner sc) &#123;
            System.out.println(&quot;请输入姓名:&quot;);
            String name = sc.next();
            System.out.println(&quot;请输入年龄:&quot;);
            int age = sc.nextInt();
            Student student = new Student(name, age);
            list.add(student);
        &#125;
    &#125;
</code></pre>
<h3 id="练习：随机数-次数打印"><a href="#练习：随机数-次数打印" class="headerlink" title="练习：随机数 次数打印"></a>练习：随机数 次数打印</h3><p>统计数字出现次数。</p>
<ul>
<li>定义getNumList方法，随机生成100个数字，数字范围从1到10。</li>
<li>定义printCount方法，统计每个数字出现的次数并打印到控制台。</li>
</ul>
<pre><code class="java">    public class Test4 &#123;
        public static void main(String[] args) &#123;
            ArrayList&lt;Integer&gt; numList = getNumList();
            //  统计字符数组中字母出现次数
            printCount(numList);
        &#125;
        public static void printCount(ArrayList&lt;Integer&gt; list) &#123;
            int[] count = new int[10];
            // 对应保存数字出现的次数
            for (int i = 0; i &lt; list.size(); i++) &#123;
                int c = list.get(i);
                count[c-1]++;
            &#125;
            // 打印数字和次数
            for (int i = 0 ; i &lt; count.length; i++) &#123;
                    System.out.println(&quot;数字:&quot;+(i+1) + &quot;--&quot; + count[i]+&quot;次&quot;);
            &#125;
        &#125;
        public static ArrayList&lt;Integer&gt; getNumList() &#123;
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            Random r = new Random();
            for (int i = 0; i &lt; 100; i++) &#123;
                int x = r.nextInt(10) + 1;
                list.add(x);
            &#125;
            return list;
        &#125;
    &#125;    
</code></pre>
<h3 id="练习：需求实现"><a href="#练习：需求实现" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><p>模拟统计班级考试分数分布情况，分别统计100-80，79-60，59-40，39-0各个阶段的人数。</p>
<ul>
<li>定义getScoreList方法，随机生成50个数字，数字范围从0到100。</li>
<li>定义countScore方法，统计各个阶段的分数个数。</li>
<li>定义printCount方法，打印各个阶段的统计结果。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; scoreList = getScoreList(); //获取随机分数
        ArrayList&lt;Integer&gt; countList = countScore(scoreList); //定义计数的变量
        printCount(countList);
    &#125;
    public static ArrayList&lt;Integer&gt; countScore(ArrayList&lt;Integer&gt; scoreList) &#123;
        ArrayList&lt;Integer&gt; countList = new ArrayList&lt;&gt;();
        int count100 = 0;
        int count79 = 0;
        int count59 = 0;
        int count39 = 0;

        for (int i = 0; i &lt; scoreList.size(); i++) &#123;
            Integer score = scoreList.get(i);
            if (score &lt;= 100 &amp;&amp; score &gt;= 80) &#123;
                count100++;
            &#125; else if (score &lt;= 79 &amp;&amp; score &gt;= 60) &#123;
                count79++;
            &#125; else if (score &lt;= 59 &amp;&amp; score &gt;= 40) &#123;
                count59++;
            &#125; else &#123;
                count39++;
            &#125;
        &#125;

        countList.add(count100);
        countList.add(count79);
        countList.add(count59);
        countList.add(count39);

        return countList;
    &#125;

    private static ArrayList&lt;Integer&gt; getScoreList()&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 50; i++) &#123;
            int x = r.nextInt(100);
            list.add(x);
        &#125;
        return list;
    &#125;

    private static void printCount(ArrayList&lt;Integer&gt; countList) &#123;
        int start = 100;
        int end = 80;
        for (int i = 0; i &lt; countList.size(); i++) &#123;
            Integer integer = countList.get(i);
            System.out.println(start + &quot;\t分 --&quot; + end + &quot; \t分:&quot; + integer+&quot;人&quot;);
            if (i == 0)&#123;
                start-=21;
                end -=20;
            &#125;else if (i == countList.size()-2)&#123;
                start-=20;
                end-=40;
            &#125;else &#123;
                start -= 20;
                end -= 20;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：添加移除展示元素"><a href="#练习：添加移除展示元素" class="headerlink" title="练习：添加移除展示元素"></a>练习：添加移除展示元素</h3><p>自定义MyList类，实现存取元素的功能。</p>
<ul>
<li>定义add方法，可以保存元素，添加MyList尾部。</li>
<li>定义remove方法，可以获取到最后添加的元素，并从MyList中移除该元素。</li>
<li>定义show方法，可以展示MyList中的元素。</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
        MyList myList = new MyList();
        for (int i = 0; i &lt; 3; i++) &#123;
            myList.add(i);
        &#125;
        System.out.println(&quot;添加元素后:&quot;);
        myList.show();

        Integer remove = myList.remove();
        System.out.println(&quot;获取元素:&quot;);
        System.out.println(remove);
        System.out.println(&quot;获取元素后:&quot;);
        myList.show();
    &#125;
&#125;

class MyList &#123;
    ArrayList&lt;Integer&gt; ml = new ArrayList&lt;&gt;();

    public void add(Integer i) &#123;
        ml.add(i);
    &#125;

    public Integer remove() &#123;
        Integer remove = ml.remove(ml.size() - 1);
        return remove;
    &#125;

    public void show() &#123;
        System.out.println(ml);
    &#125;
&#125;
</code></pre>
<h1 id="线程-amp-同步习题"><a href="#线程-amp-同步习题" class="headerlink" title="线程&amp;同步习题"></a>线程&amp;同步习题</h1><h3 id="练习：多线程开启"><a href="#练习：多线程开启" class="headerlink" title="练习：多线程开启"></a>练习：多线程开启</h3><h6 id="请描述Thread类中的start-方法与run-方法的区别"><a href="#请描述Thread类中的start-方法与run-方法的区别" class="headerlink" title="请描述Thread类中的start()方法与run()方法的区别"></a>请描述Thread类中的start()方法与run()方法的区别</h6><p>线程对象调用run()方法不开启线程，仅是对象调用方法。<br>线程对象调用start()方法开启线程，并让jvm调用run()方法在开启的线程中执行。</p>
<h3 id="练习：创建多线程"><a href="#练习：创建多线程" class="headerlink" title="练习：创建多线程"></a>练习：创建多线程</h3><h6 id="请描述创建线程的两种方法"><a href="#请描述创建线程的两种方法" class="headerlink" title="请描述创建线程的两种方法"></a>请描述创建线程的两种方法</h6><ul>
<li><h5 id="将类声明为Thread的子类"><a href="#将类声明为Thread的子类" class="headerlink" title="将类声明为Thread的子类"></a>将类声明为Thread的子类</h5></li>
</ul>
<p>①.定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。<br>②.创建Thread子类的实例，即创建了线程对象<br>③.调用线程对象的start()方法来启动该线程</p>
<ul>
<li><h5 id="声明一个类实现Runnable接口"><a href="#声明一个类实现Runnable接口" class="headerlink" title="声明一个类实现Runnable接口"></a>声明一个类实现Runnable接口</h5></li>
</ul>
<p>①.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>②,创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，Thread对象才是真正的线程对象<br>③.调用线程对象的start()方法来启动线程</p>
<h3 id="练习：多线程"><a href="#练习：多线程" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请编写程序，分别打印主线程的名称和子线程的名称"><a href="#请编写程序，分别打印主线程的名称和子线程的名称" class="headerlink" title="请编写程序，分别打印主线程的名称和子线程的名称"></a>请编写程序，分别打印主线程的名称和子线程的名称</h6><p>要求使用两种方式实现：<br>          第一种方式：继承Thread类。<br>          第二种方法：实现Runnable接口。</p>
<p><strong>操作步骤描述</strong>：</p>
<ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5></li>
</ul>
<p>①.定义一个子线程的类，继承Thread类<br>②.在子线程类中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称<br>⑤.在main方法中创建子线程对象<br>⑥.调用子线程对象的start方法，开启子线程</p>
<pre><code class="java">// 1.定义一个子线程的类，继承Thread类；
public class SubThread extends Thread&#123;
// 2.在子线程类中重写run方法，在run方法中打印子线程的名称；
    public void run()&#123;
    // 打印子线程的名称
      System.out.println(&quot;subThread:&quot; + Thread.currentThread().getName());
    &#125;
&#125;
// 3.定义一个测试类
public class ThreadDemo&#123;
    public static void main(String[] args)&#123;
// 4.在main方法中打印主线程的名称；
    System.out.println(&quot;main:&quot; + Thread.currentThread().getName());
// 5.在main方法中创建子线程对象；
    SubThread st = new SubThread();
// 6.调用子线程对象的start方法，开启子线程。
    st.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5></li>
</ul>
<p>①.定义一个子任务类，实现Runnable接口<br>②.在子任务中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称；<br>⑤.在main方法中创建一个子任务对象；<br>⑥.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的构造方法；<br>⑦.调用Thread类对象的start方法开启子线程；</p>
<pre><code class="java">// 1.定义一个子任务类，实现Runnable接口。
public class SubRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
// 2.在子任务类中重写run方法，在run方法中打印子线程的名称。
    System.out.println(&quot;SubRunnable:&quot;+ Thread.currentThread().getName());
// 3.定义一个测试类。
   &#125;
&#125;
public class RunnableDemo &#123;
    public static void main(String[] args) &#123;
// 4.在main方法中打印主线程的名称。
    System.out.println(&quot;RunnableDemo:&quot;+ Thread.currentThread().getName());
// 5.在main方法中创建一个子任务对象。
    SubRunnable r = new SubRunnable();
// 6.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的                         构造方法。
    Thread t = new Thread(r);
// 7.调用Thread类对象的start方法开启子线程。
    t.start();
 &#125;
&#125;
</code></pre>
<h3 id="练习：实现Runnable接口的优势"><a href="#练习：实现Runnable接口的优势" class="headerlink" title="练习：实现Runnable接口的优势"></a>练习：实现Runnable接口的优势</h3><h6 id="请描述实现Runnable接口比继承Thread类所具有的优势："><a href="#请描述实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="请描述实现Runnable接口比继承Thread类所具有的优势："></a>请描述实现Runnable接口比继承Thread类所具有的优势：</h6><p>①.适合多个相同的程序代码的线程去共享同一个资源<br>②.可以避免java中的单继承的局限性<br>③.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和数据独立。<br>④.线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</p>
<h3 id="练习：多线程-1"><a href="#练习：多线程-1" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><p>创建多线程对象，开启多线程。在子线程中输出1-100之间的偶数，主线程输出1-100之间的奇数</p>
<p><strong>自定义线程类</strong>：</p>
<pre><code class="java">public class MyThread extends Thread &#123;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 100; i++) &#123;
            if (i % 2 == 0) &#123;
                System.out.println(&quot;子线程打印输出偶数：&quot; + i);
            &#125;
        &#125;
    &#125;
    public class Test11 &#123;
        public static void main(String[] args) &#123;
            //创建自定义线程对象
            MyThread mt = new MyThread();
            //开启线程
            mt.start();
            //在主方法中执行for循环
            for (int i = 1; i &lt;= 100; i++) &#123; 
                if (i % 2 == 1) &#123;
                    System.out.println(&quot;主线程打印输出奇数：&quot; + i);
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：线程状态"><a href="#练习：线程状态" class="headerlink" title="练习：线程状态"></a>练习：线程状态</h3><h6 id="请描述在线程的生命周期中，-有几种状态呢"><a href="#请描述在线程的生命周期中，-有几种状态呢" class="headerlink" title="请描述在线程的生命周期中， 有几种状态呢 ?"></a>请描述在线程的生命周期中， 有几种状态呢 ?</h6><p>1.<strong>NEW(新建)</strong> 线程刚被创建，但是并未启动。</p>
<p>2.<strong>Runnable(可运行)</strong><br>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</p>
<p>3.<strong>Blocked(锁阻塞)</strong><br>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</p>
<p>4.<strong>Waiting(无限等待)</strong><br>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</p>
<p>5.<strong>Timed Waiting(计时等待)</strong><br>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</p>
<p>6.<strong>Teminated(被终止)</strong><br>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</p>
<h1 id="线程池-amp-lambda表达式习题"><a href="#线程池-amp-lambda表达式习题" class="headerlink" title="线程池&amp;lambda表达式习题"></a>线程池&amp;lambda表达式习题</h1><h3 id="练习：线程池概念"><a href="#练习：线程池概念" class="headerlink" title="练习：线程池概念"></a>练习：线程池概念</h3><h5 id="请描述什么是线程池"><a href="#请描述什么是线程池" class="headerlink" title="请描述什么是线程池"></a>请描述什么是线程池</h5><p>线程池：其实就是一个<strong>容纳多个线程的容器</strong>，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复用户创建线程而消耗过多的资源</p>
<h3 id="练习：线程池优点"><a href="#练习：线程池优点" class="headerlink" title="练习：线程池优点"></a>练习：线程池优点</h3><h5 id="请描述合理利用线程池能够带来的三个好处"><a href="#请描述合理利用线程池能够带来的三个好处" class="headerlink" title="请描述合理利用线程池能够带来的三个好处"></a>请描述合理利用线程池能够带来的三个好处</h5><p>1,<strong>降低资源消耗</strong>。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可以执行多个任务<br>2.<strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行<br>3.<strong>提高线程的可管理性</strong>。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<h3 id="练习：Lambda表达式"><a href="#练习：Lambda表达式" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda语法的省略规则"><a href="#请列举Lambda语法的省略规则" class="headerlink" title="请列举Lambda语法的省略规则"></a>请列举Lambda语法的省略规则</h6><p>在Lambda标准格式的基础上，使用省略句写法的规则为：<br>1.小括号内参数的类型可以省略<br>2.如果小括号内有且只有一个参数，则小括号可以省略<br>3.如果大括号内有且只有一个语句，则无论是否有返回值，都可以省略大括号、return、关键字以及语句分号</p>
<h3 id="练习：Lambda表达式-1"><a href="#练习：Lambda表达式-1" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda表达式的3个组成部分，并解释说明"><a href="#请列举Lambda表达式的3个组成部分，并解释说明" class="headerlink" title="请列举Lambda表达式的3个组成部分，并解释说明"></a>请列举Lambda表达式的3个组成部分，并解释说明</h6><p>Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成：<strong>一些参数、一个箭头、一段代码</strong><br><u>Lambda表达式的标准格式</u>：<br>1.小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号分割<br>2.”—&gt;”是新引入的语法格式，代表指向动作<br>3.大括号内的语法与<strong>传统方法体</strong>要求基本一致</p>
<h3 id="练习：Lambda表达式-2"><a href="#练习：Lambda表达式-2" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请描述Lambda的使用前提"><a href="#请描述Lambda的使用前提" class="headerlink" title="请描述Lambda的使用前提"></a>请描述Lambda的使用前提</h6><p>Lambda的语法非常简介，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：<br>1.使用Lambda必须具有接口，且要求接口中<strong>有且只有一个抽象方法</strong>。无论是JDK内置的<code>Runnable、Comparator</code>接口还是自定义的接口，只有<strong>当接口中的抽象方法存在且唯一时</strong>，才能使用Lambda。<br>2.使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例</p>
<h3 id="练习：多线程-2"><a href="#练习：多线程-2" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="代码实现打印输出1-99"><a href="#代码实现打印输出1-99" class="headerlink" title="代码实现打印输出1-99"></a>代码实现打印输出1-99</h6><pre><code class="java">public class Test06 &#123;
    public int start = 1;
    public int end = 99;

public static void main(String[] args) &#123;
    new Test06().method();
 &#125;

public void method() &#123;
    //插入代码处
         Runnable a = () -&gt; &#123;
      for (int i = start; i &lt;end; i++) &#123;
        System.out.println(i);
      &#125;
    &#125;;
      Thread t = new Thread(a);
      t.start();
     &#125;
&#125;
</code></pre>
<h3 id="练习：多线程-3"><a href="#练习：多线程-3" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请问该程序的运行结果是什么-如有问题，请说明原因。"><a href="#请问该程序的运行结果是什么-如有问题，请说明原因。" class="headerlink" title="请问该程序的运行结果是什么?  如有问题，请说明原因。"></a>请问该程序的运行结果是什么?  如有问题，请说明原因。</h6><pre><code class="java">public class Test07implements Runnable &#123;
    public static void main(String[] args) &#123;
      Thread t = new Thread(new Test07());
      t.start();
      &#125;

public void run(int num) &#123;
    for (int i = 0; i &lt; num; i++) &#123;
       System.out.println(i);
    &#125;
  &#125;
&#125;
</code></pre>
<p>在编译时期就会报错</p>
<p>​               Test类没有重写Runnable接口中的run()方法</p>
<p>​               public void run(int num)不是Runnable接口中的run()方法。</p>
<p><strong>注意：Runnable接口中的run()方法，参数列表为空，不带参数。</strong></p>
<h3 id="练习：线程池练习"><a href="#练习：线程池练习" class="headerlink" title="练习：线程池练习"></a>练习：线程池练习</h3><h6 id="使用线程池创建多线程。模拟同学找老师学习Java。"><a href="#使用线程池创建多线程。模拟同学找老师学习Java。" class="headerlink" title="使用线程池创建多线程。模拟同学找老师学习Java。"></a>使用线程池创建多线程。模拟同学找老师学习Java。</h6><p>1.创建线程池对象，包含2个线程。从线程池中获取线程对象，然后调用MyRunnable中的run()。<br>2.在MyRunnable实现类中，首先在控制台打印需求，“我需要一个老师”。模拟需要2秒钟时间老师可以过来指导学生，并在控制台打印老师的姓名。最后，在控制台打印“教我java,教完后，老师回到了办公室”；</p>
<pre><code class="java">class Test implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个老师&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;老师来了&quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我Java，教完后，老师回到了办公室&quot;);
    &#125;
&#125;

class ThreadPoolDemo&#123;
    public static void main(String[] args) &#123;
        ExecutorService service = Executors.newFixedThreadPool(2);
        Test r = new Test();
        service.submit(r);//线程1
        service.submit(r);//线程2
        service.submit(r);//线程3
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-无参无返回"><a href="#练习：Lambda-无参无返回" class="headerlink" title="练习：Lambda(无参无返回)"></a>练习：Lambda(无参无返回)</h3><p>给定一个导演 Director接口，内含唯一的抽象方法makeMovie，且无参数、无返回值，使用lambda表达式在Test中完成调用。</p>
<pre><code class="java">interface Director&#123;
    void makeMovie();
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请使用Lambda【省略格式】调用invokeDirect方法
        invokeDirect(()-&gt; System.out.println(&quot;拍电影啦&quot;));
    &#125;
    private static void invokeDirect(Director director)&#123;
        director.makeMovie();
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-有参有返回"><a href="#练习：Lambda-有参有返回" class="headerlink" title="练习：Lambda(有参有返回)"></a>练习：Lambda(有参有返回)</h3><p>给定一个计算器 Calculator 接口，内含抽象方法 calc (减法)，其功能是可以将两个数字进行相减，并返回差值。使用Lambda表达式在Test中完成调用</p>
<pre><code class="java">interface Calculator&#123;
    int calc(int a, int b);
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß
        invokeCalc(130, 120, (int a, int b) -&gt; &#123;
            return a - b;
        &#125;); //标准格式
        invokeCalc(130,120,(a,b)-&gt; a-b); //省略模式
    &#125;
    private static void invokeCalc(int a, int b, Calculator calculator)&#123;
        int result = calculator.calc(a,b);
        System.out.println(&quot;结果是：&quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h3 id="练习一：Pedicate接口使用"><a href="#练习一：Pedicate接口使用" class="headerlink" title="练习一：Pedicate接口使用"></a>练习一：Pedicate接口使用</h3><p>请在测试类main方法中完成以下需求</p>
<p>已知有Integer[] arr &#x3D; {-12345, 9999, 520, 0,-38,-7758520,941213}</p>
<p>a)     使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数(大于等于0)</p>
<p>b)    使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100</p>
<p>c)     使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数</p>
<p>遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求</p>
<p>​             i.       打印自然数的个数</p>
<p>​            ii.       打印负整数的个数</p>
<p>​           iii.       打印绝对值大于100的偶数的个数</p>
<p>​           iv.       打印是负整数或偶数的数的个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
        Integer[] arr = &#123;-12345, 9999, 520, 0,-38,-7758520,941213&#125;;

        //a)   使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数
        Predicate&lt;Integer&gt; p1 = (s) -&gt; s&gt;=0;
        //b)   使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100
        Predicate&lt;Integer&gt; p2 = (s) -&gt; Math.abs(s)&gt;100;
        //c)   使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数
        Predicate&lt;Integer&gt; p3 = (s) -&gt; s%2==0;

        //e)   遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        int count4 = 0;
        for (Integer i : arr) &#123;
            //统计自然数个数
            if (p1.test(i))&#123;
                count1++;
            &#125;
            //统计负整数个数
            if (p1.negate().test(i))&#123;
                count2++;
            &#125;
            //统计绝对值大于100的偶数个数
            if (p2.and(p3).test(i))&#123;
                count3++;
            &#125;
            //统计是负整数或偶数的数的个数
            if (p1.negate().or(p3).test(i))&#123;
                count4++;
            &#125;
        &#125;
        //分别打印结果
        System.out.println(&quot;自然数的个数为：&quot;+count1);
        System.out.println(&quot;负整数的个数为：&quot;+count2);
        System.out.println(&quot;绝对值大于100的偶数的个数为：&quot;+count3);
        System.out.println(&quot;是负整数或偶数的数的个数为：&quot;+count4);
    &#125;
</code></pre>
<h3 id="练习：Function接口使用"><a href="#练习：Function接口使用" class="headerlink" title="练习：Function接口使用"></a>练习：Function接口使用</h3><p><code>[这是一个功能界面，因此可以用Lambda表达式或方法引用的赋值对象]</code></p>
<blockquote>
<p>Interface Function&lt;T,R&gt;<br>T：函数输入的类型<br>R：函数结果的类型</p>
<p>Interface Map&lt;K,V&gt;<br>K：由此地图维护的键的类型<br>V：映射值的类型</p>
</blockquote>
<p>1.使用lambda表达式分别将以下功能封装到Function对象中</p>
<p>a)    求Integer类型ArrayList中所有元素的平均数</p>
<p>b)    将Map &lt; String,Integer &gt; 中value存到ArrayList &lt; Integer &gt;中</p>
<p>2.已知学生成绩如下</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>岑小村</td>
<td>59</td>
</tr>
<tr>
<td>谷天洛</td>
<td>82</td>
</tr>
<tr>
<td>渣渣辉</td>
<td>98</td>
</tr>
<tr>
<td>蓝小月</td>
<td>65</td>
</tr>
<tr>
<td>皮几万</td>
<td>70</td>
</tr>
</tbody></table>
<p>3.以学生姓名为key成绩为value创建集合并存储数据，使用刚刚创建的Function对象求学生的平均成绩</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //1.   使用lambda表达式分别将以下功能封装到Function对象中
        //a)   求Integer类型ArrayList中所有元素的平均数
        Function&lt;ArrayList&lt;Integer&gt;,Integer&gt; f1 = (list)-&gt;&#123;
            Integer sum = 0;
            for (Integer i : list) &#123;
                sum+=i;
            &#125;
            return sum/list.size();
        &#125;;

        //b)   将Map&lt;String,Integer&gt;中value存到ArrayList&lt;Integer&gt;中
        Function&lt;Map&lt;String,Integer&gt;,ArrayList&lt;Integer&gt;&gt; f2 = (map)-&gt;&#123;
            /*ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (String s : map.keySet()) &#123;
                Integer i = map.get(s);
                list.add(i);
            &#125;*/
            Collection&lt;Integer&gt; values = map.values();
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            list.addAll(values);
            return list;
        &#125;;
        //2 将学生姓名和成绩封装到map中
        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;岑小村&quot;, 59);
        map.put(&quot;谷天洛&quot;, 82);
        map.put(&quot;渣渣辉&quot;, 98);
        map.put(&quot;蓝小月&quot;, 65);
        map.put(&quot;皮几万&quot;, 70);

        //利用Function求平均成绩
        Integer avg = f2.andThen(f1).apply(map);
        System.out.println(&quot;学生平均成绩为：&quot;+avg);
    &#125;
</code></pre>
<h3 id="练习：获取流"><a href="#练习：获取流" class="headerlink" title="练习：获取流"></a>练习：获取流</h3><p>简述单列集合、双列集合、数组分别如何获取Stream流对象，并进行演示</p>
<pre><code class="java">1.java.util.Collection接口中加入了default方法 stream()获取流对象，因此其所有实现类均可通过此方式获取流

2.java.util.Map接口想要获取流，先通过KeySet()、values()或entrySet()方法获取键、值或键值对的单列集合，再通过stream()获取流对象

3.数组获取流，使用Stream接口中的静态方法of(T...values)获取流
public static void main(String[] args) &#123;
  List&lt;String&gt; list = new ArrayList&lt;&gt;();
  Stream&lt;String&gt; stream1 = list.stream();
  Set&lt;String&gt; set = new HashSet&lt;&gt;();
  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

  Stream&lt;String&gt; stream2 = set.stream();
  Stream&lt;String&gt; keyStream = map.keySet().stream();
  Stream&lt;String&gt; valueStream = map.values().stream();
  Stream&lt;Map.Entry&lt;String,String&gt;&gt;entryStream = map.entrySet().stream();

  String[] array = &#123;&quot;东邪&quot;, &quot;西毒&quot;, &quot;南帝&quot;, &quot;北丐&quot;, &quot;中神通&quot;&#125;;
  Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<h3 id="练习：过滤-filter-、结果收集-数组"><a href="#练习：过滤-filter-、结果收集-数组" class="headerlink" title="练习：过滤[filter]、结果收集(数组)"></a>练习：过滤[filter]、结果收集(数组)</h3><p>有如下7个元素黄药师，冯蘅，郭靖，黄蓉，郭芙，郭襄，郭破虏，使用Stream将以郭字开头的元素存入新数组</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; stream = Stream.of(&quot;黄药师&quot;, &quot;冯蘅&quot;, &quot;郭靖&quot;, &quot;黄蓉&quot;, &quot;郭芙&quot;, &quot;郭襄&quot;, &quot;郭破虏&quot;);
        String[] guos = stream.filter(s -&gt; s.startsWith(&quot;郭&quot;)).toArray(String[]::new);
     &#125;
&#125;
// filter 返回由与此给定谓词匹配的此流的元素组成的流。
// toArray 返回一个包含此流的元素的数组 结果: 一个包含此流的元素的数组
</code></pre>
<h3 id="练习：n-取用前几个-limit-、跳过前几个-skip"><a href="#练习：n-取用前几个-limit-、跳过前几个-skip" class="headerlink" title="练习：n 取用前几个[limit]、跳过前几个[skip]"></a>练习：n 取用前几个[limit]、跳过前几个[skip]</h3><p>已知ArrayList集合中有如下元素{陈玄风、梅超风、陆乘风、曲灵风、武眠风、冯默风、罗玉风}，使用Stream<br>1,取出前2个元素并在控制台打印输出。<br>2.取出后2个元素并在控制台打印输出。</p>
<pre><code class="java">import java.util.ArrayList;
    public class Test04 &#123;
      public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;陈玄风&quot;);
        list.add(&quot;梅超风&quot;);
        list.add(&quot;陆乘风&quot;);
        list.add(&quot;曲灵风&quot;);
        list.add(&quot;武眠风&quot;);
        list.add(&quot;冯默风&quot;);
        list.add(&quot;罗玉风&quot;);

        list.stream().limit(2).forEach(System.out::println);
        list.stream().skip(list.size() - 2).forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h3 id="练习：n-映射-map-、逐一消费-forEach"><a href="#练习：n-映射-map-、逐一消费-forEach" class="headerlink" title="练习：n 映射[map]、逐一消费[forEach]"></a>练习：n 映射[map]、逐一消费[forEach]</h3><p>有如下整数1，-2，-3，4，-5<br>使用Stream取元素绝对值并打印</p>
<pre><code class="java">import java.util.stream.Stream;
   public class Test &#123;
      public static void main(String[] args) &#123;
          Stream&lt;Integer&gt; stream = Stream.of(1, -2, -3, 4,-5);
        stream.map(Math::abs).forEach(System.out::println);
     &#125;
&#125;
</code></pre>
<h3 id="练习：组合-concat-、结果收集-list"><a href="#练习：组合-concat-、结果收集-list" class="headerlink" title="练习：组合[concat]、结果收集[list]"></a>练习：组合[concat]、结果收集[list]</h3><p>已知数组arr1中有如下元素{郭靖，杨康}，arr2中有如下元素{黄蓉，穆念慈}，使用Stream将二者合并到List集合</p>
<pre><code class="java">import java.util.stream.Stream;
  public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; streamA = Stream.of(&quot;郭靖&quot;, &quot;杨康&quot;);
        Stream&lt;String&gt; streamB = Stream.of(&quot;黄蓉&quot;, &quot;穆念慈&quot;);
        List&lt;String&gt; strList = Stream.concat(streamA, streamB).collect(Collectors.toList());
     &#125;
&#125;
</code></pre>
<h3 id="练习：获取并发流"><a href="#练习：获取并发流" class="headerlink" title="练习：获取并发流"></a>练习：获取并发流</h3><p>请分别写出获取并发流的两种方式。</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
          Stream&lt;String&gt; parallelStream1 = coll.parallelStream();
        Stream&lt;Integer&gt; parallelStream2 = Stream.of(100, 200, 300, 400).parallel();
     &#125;
&#125;
</code></pre>
<h1 id="函数式接口习题"><a href="#函数式接口习题" class="headerlink" title="函数式接口习题"></a>函数式接口习题</h1><h3 id="练习：函数式接口"><a href="#练习：函数式接口" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①.  定义一个函数式接口CurrentTimePrinter,其中抽象方法void printCurrentTime()，使用注解@FunctionalInterface<br>②. 在测试类中定义static void showLongTime(CurrentTimePrinter timePrinter)，该方法的预期行为是使用timePrinter打印系统当前毫秒值<br>③. 测试showLongTime(),通过lambda表达式完成需求</p>
<pre><code class="java">@FunctionalInterface
public interface CurrentTimePrinter
&#123;
    void printCurrenTime();
&#125;

public class Test01 &#123;
    public static void main(String[] args) &#123;
        showLongTime(()-&gt;System.out.println(System.currentTimeMillis()));
    &#125;

    public static void showLongTime(CurrentTimePrinter timePrinter)&#123;
        timePrinter.printCurrentTime();
    &#125;
&#125;
</code></pre>
<h3 id="练习：函数式接口-1"><a href="#练习：函数式接口-1" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①. 定义一个函数式接口IntCalc,其中抽象方法int calc(int a , int b)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void getProduct(int a , int b ,IntCalc calc), 该方法的预期行为是使用calc得到a和b的乘积并打印结果<br>③. 测试getProduct(),通过lambda表达式完成需求</p>
<p>IntCalc接口：</p>
<pre><code class="java">@FunctionalInterface
 public interface IntCalc &#123;
   int calc(int a, int b);
 &#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test02 &#123;
   public static void main(String[] args) &#123;
     getProduct(2,3,(a,b)-&gt;a*b);
   &#125;
   public static void getProduct(int a, int b, IntCalc intCalc)&#123;
     int product = intCalc.calc(a,b);
     System.out.println(product);

   &#125;
&#125;
</code></pre>
<h3 id="练习：静态方法引用"><a href="#练习：静态方法引用" class="headerlink" title="练习：静态方法引用"></a>练习：静态方法引用</h3><p>①. 定义一个函数式接口NumberToString,其中抽象方法String convert(int num)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void decToHex(int num ,NumberToString nts), 该方法的预期行为是使用nts将一个十进制整数转换成十六进制表示的字符串，**<u>tips：已知该行为与Integer类中的toHexString方法一致</u>**<br>③. 测试decToHex (),使用方法引用完成需求</p>
<pre><code class="java">interface NumberToString&#123;
    String convert(int num);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        decToHex(999, Integer::toHexString);
    &#125;

    public static void decToHex(int num ,NumberToString nts)&#123;
        String convert = nts.convert(num);
        System.out.println(convert);
    &#125;

&#125;
</code></pre>
<h1 id="字节流-amp-字符流-amp-Properties集合习题"><a href="#字节流-amp-字符流-amp-Properties集合习题" class="headerlink" title="字节流&amp;字符流&amp;Properties集合习题"></a>字节流&amp;字符流&amp;Properties集合习题</h1><h3 id="练习：字节输出流写出字节数据"><a href="#练习：字节输出流写出字节数据" class="headerlink" title="练习：字节输出流写出字节数据"></a>练习：字节输出流写出字节数据</h3><p>利用字节输出流一次写一个字节的方式，向D盘的a.txt文件输出字符‘a’</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流FileOutputStream对象并指定文件路径。<br>2.调用字节输出流的write(int byte)方法写出数据</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.txt&quot;);
        // 2.调用字节输出流的write(byte[] buf)方法写出数据。
        byte[] buf = &quot;i love java&quot;.getBytes();
        // 2.调用字节输出流的write(int byte)方法写出数据
        fos.write(97);
        // 3.关闭流
        fos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：文件的续写和换行输出"><a href="#练习：文件的续写和换行输出" class="headerlink" title="练习：文件的续写和换行输出"></a>练习：文件的续写和换行输出</h3><p>在D盘下，有一c.txt 文件中内容为：HelloWorld<br>在c.txt文件原内容基础上，添加五句 I love java，而且要实现一句一行操作(注：原文不可覆盖)。利用字节输出流对象往C盘下c.txt文件输出5句：”i love java”</p>
<p><strong>操作步骤</strong>:</p>
<p>1.利用两个参数的构造方法创建字节输出流对象，参数一指定文件路径，参数二指定为true<br>2.调用字节输出流的write()方法写入数据，在每一行后面加上换行符:”\r\n”</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径,并追加方式
        FileOutputStream fos = new FileOutputStream(&quot;c:/c.txt&quot;,true);
        // 2.调用字节输出流的write方法写出数据
        // 2.1 要输出的字符串
        String content = &quot;i love java \r\n&quot;;
        for (int i = 0; i&lt; 5; i++) &#123;
            fos.write(content.getBytes());
        &#125;
        // 3.关闭流
        fos.close();
    &#125;
&#125;
/*
    定义变量接收读取的字节
        int len = -1;
        // 循环从流中读取数据
        while((len = fis.read()) != -1) &#123;
        System.out.print(new String(buffer,0,len));
&#125;

*/
</code></pre>
<h3 id="练习：字节流复制文件"><a href="#练习：字节流复制文件" class="headerlink" title="练习：字节流复制文件"></a>练习：字节流复制文件</h3><h6 id="描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致"><a href="#描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致" class="headerlink" title="描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)"></a>描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)</h6><p>要求：一次读写一个字节的方式</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输入流对象关联文件路径：E盘下的a.png<br>2.创建字节输出流对象关联文件路径：D盘下的a.png<br>3.使用循环不断从字节输入流读取一个字节，每读取一个字节就利用输出流写出一个字节。<br>4.关闭流，释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;e:/a.png&quot;);
        // 创建字节输出流对象并关联文件
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.png&quot;);
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = fis.read()) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            fos.write(len);
        &#125;
        // 关闭流
        fis.close();
        fos.close();
    &#125;
</code></pre>
<h3 id="练习：IO对象Properties结合使用-设置properties文件"><a href="#练习：IO对象Properties结合使用-设置properties文件" class="headerlink" title="练习：IO对象Properties结合使用,设置properties文件"></a>练习：IO对象Properties结合使用,设置properties文件</h3><p>我有一个文本文件score.txt，我知道数据是键值对形式的，但是不知道内容是什么。<br>请写一个程序判断是否有”lisi”这样的键存在，如果有就改变其实为”100”<br>score.txt文件内容如下：<br>zhangsan &#x3D; 90    lisi &#x3D; 80    wangwu &#x3D; 85<br><strong>操作步骤</strong>:<br>1.创建一个空的Properties集合<br>2.读取数据到集合中<br>3.遍历集合，获取到每一个key<br>4.判断当前的key 是否为 “lisi”，如果是就把”lisi”的值设置为100<br>5.把集合中所有的信息，重新存储到文件中</p>
<table>
<thead>
<tr>
<th>void</th>
<th>store(OutputStream out, String comments)<br />此适合使用load(InputStream)方法加载到Properties表中的格式，将此Propeirties表中的属性列表(键和元素对写入输出流)</th>
</tr>
</thead>
</table>
<pre><code class="java">public class Test02_06 &#123;
    public static void main(String[] args) throws IOException &#123;
//1：创建一个空的集合
        Properties prop = new Properties();
//2:读取数据到集合中
        prop.load(new FileInputStream(&quot;score.txt&quot;));
//3:遍历集合，获取到每一个key
        Set&lt;String&gt; keys = prop.stringPropertyNames();
//获取到每一个key
        for (String key : keys) &#123;
//4:判断当前的key 是否为 &quot;lisi&quot;
            if (&quot;lisi&quot;.equals(key)) &#123;
//把&quot;lisi&quot;的值设置为100
                prop.setProperty(key, &quot;100&quot;);
            &#125;
        &#125;
//把集合中所有的信息，重新存储到文件中
        prop.store(new FileOutputStream(&quot;score.txt&quot;), &quot;haha&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="缓冲流-amp-转换流习题"><a href="#缓冲流-amp-转换流习题" class="headerlink" title="缓冲流&amp;转换流习题"></a>缓冲流&amp;转换流习题</h1><h3 id="练习：高效字节输出流写出字节数据"><a href="#练习：高效字节输出流写出字节数据" class="headerlink" title="练习：高效字节输出流写出字节数据"></a>练习：高效字节输出流写出字节数据</h3><h6 id="描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。"><a href="#描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。" class="headerlink" title="描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。"></a>描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。</h6><p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.调用高效字节输出流对象的write方法写出一个字节<br>4.关闭高效流，释放资源。</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\d.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(int byte)方法写出一个字节数据
        bos.write(97);
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字节输出流写出字节数组数据"><a href="#练习：高效字节输出流写出字节数组数据" class="headerlink" title="练习：高效字节输出流写出字节数组数据"></a>练习：高效字节输出流写出字节数组数据</h3><h6 id="描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”"><a href="#描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”" class="headerlink" title="描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”"></a>描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”</h6><p><strong>操作步骤:</strong></p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.定义字符串存放要输出的数据，然后将字符串转换为字节数组。<br>4.调用高效字节输出流对象的write方法将字节数组输出。<br>5.关闭高效流。</p>
<pre><code class="java">public class Test01_02 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\e.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(byte[] buff)方法写出一个字节数据
        bos.write(&quot;i love java&quot;.getBytes());
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效流文件复制"><a href="#练习：高效流文件复制" class="headerlink" title="练习：高效流文件复制"></a>练习：高效流文件复制</h3><h6 id="描述-利用高效字节输入流和高效字节输出流完成文件的复制。"><a href="#描述-利用高效字节输入流和高效字节输出流完成文件的复制。" class="headerlink" title="描述: 利用高效字节输入流和高效字节输出流完成文件的复制。"></a>描述: 利用高效字节输入流和高效字节输出流完成文件的复制。</h6><p>要求：</p>
<p>1.将C盘下的c.png文件复制到D盘下<br>2.一次读写一个字节数组方式复制</p>
<p>操作步骤:</p>
<p>①.创建字节输入流对象并关联文件路径<br>②.利用字节输入流对象创建高效字节输入流对象<br>③.创建字节输出流对象并关联文件路径<br>④.利用字节输出流对象创建高效字节输出流对象<br>⑤.创建字节数组用来存放读取的字节数<br>⑥.利用高效字节输入流循环读取文件数据，每读取一个字节数组，利用高效字节输出流对象将字节数组的内容输出到目标文件中。直到读取到文件末尾。<br>⑦.关闭高效流对象</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件路径
        FileInputStream fis = new FileInputStream(&quot;c:\\c.png&quot;);
        // 利用字节输出流对象创建高效字节输出流对象
        BufferedInputStream bis = new BufferedInputStream(fis);
        // 创建字节输出流对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:\\c.png&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 定义字节数组接收读取的字节
        byte[] buffer = new byte[1024];
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = bis.read(buffer)) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            bos.write(buffer,0,len);
        &#125;
        // 关闭流
        bis.close();
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字符流和集合的综合使用"><a href="#练习：高效字符流和集合的综合使用" class="headerlink" title="练习：高效字符流和集合的综合使用"></a>练习：高效字符流和集合的综合使用</h3><p>描述:</p>
<p>分析以下需求，并用代码实现<br>实现一个验证码小程序，要求如下：<br>① 在项目根目录下新建一个文件：data.txt,键盘录入3个字符串验证码，并存入data.txt中，要求一个验证码占一行；<br>② 键盘录入一个需要被校验的验证码，如果输入的验证码在data.txt中存在：在控制台提示验证成功，如果不存在控制台提示验证失败</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws IOException &#123;
        writeString2File();
        verifyCode();
    &#125;

    private static void writeString2File() throws IOException &#123;
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i &lt; 3; i++) &#123;
            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个字符串验证码&quot;);
            line = sc.nextLine();
            bw.write(line);
            bw.newLine();
        &#125;
        bw.close();
    &#125;

    private static void verifyCode() throws IOException &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        BufferedReader br = new BufferedReader(new FileReader(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        while(null!=(line = br.readLine()))&#123;
        list.add(line);
    &#125;
        br.close();
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个验证码&quot;);
        String code = sc.nextLine();
        if (list.contains(code))&#123;
            System.out.println(&quot;验证成功&quot;);
        &#125;else &#123;
            System.out.println(&quot;验证失败&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输出流的使用"><a href="#练习：转换输出流的使用" class="headerlink" title="练习：转换输出流的使用"></a>练习：转换输出流的使用</h3><h6 id="描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。"><a href="#描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。" class="headerlink" title="描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。"></a>描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。</h6><p>要求：使用gbk编码保存。<br>注意：idea的默认编码是utf-8,所以可以通过fileàsettingsàfile encodings设置为gbk格式，否则打开a.txt文件看到的将会是乱码。</p>
<p>操作步骤:</p>
<p>1.创建文件字节输出流关联目标文件<br>2.根据文件字节输出流创建转换输出流对象，并指定编码字符集为：gbk<br>3.调用流对象的方法将字符串写出到文件中。<br>4.关闭流并释放资源。</p>
<pre><code class="java">public class Test01_05 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 要保存的字符串
        String content = &quot;我爱Java&quot;;
        // 创建字节输出流对象
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        // 创建转换输出流对象
        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;gbk&quot;);
        // 调用方法写出数据
        osw.write(content);
        // 关闭流释放资源
        osw.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输入流的使用"><a href="#练习：转换输入流的使用" class="headerlink" title="练习：转换输入流的使用"></a>练习：转换输入流的使用</h3><h6 id="描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。"><a href="#描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。" class="headerlink" title="描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。"></a>描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。</h6><p>要求：不能出现乱码的情况。<br>操作步骤:</p>
<p>1.创建字节输入流对象指定文件路径。<br>2.根据字节输入流对象创建转换输入流对象并指定字符集编码为：gbk<br>3.调用转换输入流对象的读取方法读取内容<br>4.关闭流释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        // 创建转换输入流对象
        InputStreamReader isr = new InputStreamReader(fis,&quot;gbk&quot;);
        // 定义字符数组存放读取的内容
        char[] buffer = newchar[1024];
        // 定义变量接收读取的字符个数
        intlen = -1;
        while((len = isr.read(buffer)) != -1) &#123;
            System.out.print(new String(buffer,0,len));
        &#125;
        // 关闭流
        isr.close();
    &#125;
&#125;
</code></pre>
<h1 id="继承-amp-抽象类习题"><a href="#继承-amp-抽象类习题" class="headerlink" title="继承&amp;抽象类习题"></a>继承&amp;抽象类习题</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h5 id="什么叫做类与类的继承，作用是什么？"><a href="#什么叫做类与类的继承，作用是什么？" class="headerlink" title="什么叫做类与类的继承，作用是什么？"></a><span style =  "color :red">什么叫做类与类的继承，作用是什么？</span></h5><p>就是子类继承父类的属性和行为，使得子类对象具有与父亲相同的属性、相同的行为；<br>作用是子类复用父类的内容</p>
<h5 id="继承后，父类与子类之间，各成员有什么样的影响？"><a href="#继承后，父类与子类之间，各成员有什么样的影响？" class="headerlink" title="继承后，父类与子类之间，各成员有什么样的影响？"></a><span style =  "color :red">继承后，父类与子类之间，各成员有什么样的影响？</span></h5><p>成员变量：<br><u>不重名</u>，就没有影响；<u>重名</u>，就近使用，使用super分区父类变量</p>
<p>构造方法：<br><u>无影响</u>，但是子类构造方法默认调用父类构造方法</p>
<p>成员方法：<br>不重名，没有影响；重名，子类重写父类方法</p>
<h5 id="子类中，如何调用父类的成员？如何使用本类的成员？"><a href="#子类中，如何调用父类的成员？如何使用本类的成员？" class="headerlink" title="子类中，如何调用父类的成员？如何使用本类的成员？"></a><span style =  "color :red">子类中，如何调用父类的成员？如何使用本类的成员？</span></h5><p>父类成员方法：super.方法名<br>父类非私有成员变量：super.变量名<br>子类成员方法：this.方法名<br>子类成员变量：this.变量名</p>
<h5 id="抽象方法与普通成员方法有什么区别？"><a href="#抽象方法与普通成员方法有什么区别？" class="headerlink" title="抽象方法与普通成员方法有什么区别？"></a><span style =  "color :red">抽象方法与普通成员方法有什么区别？</span></h5><p>抽象方法使用abstract关键字修饰，没有方法体；成员方法有方法体</p>
<h5 id="抽象类与普通类有什么区别？"><a href="#抽象类与普通类有什么区别？" class="headerlink" title="抽象类与普通类有什么区别？"></a><span style =  "color :red">抽象类与普通类有什么区别？</span></h5><p>方法：<br>抽象类可以包含抽象方法和成员方法；普通类不可以包含抽象方法，只有成员方法</p>
<p>对象：<br>抽象类不可以创建对象；普通类可以创建对象</p>
<h3 id="练习：语法练习"><a href="#练习：语法练习" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承，抽象类</p>
</li>
<li><p>输出<code>A类中numa：10、B类中numb：20、C类中numc：30</code></p>
</li>
</ul>
<pre><code class="java">abstract  class A&#123;
    int numa = 10;
    public abstract void showA();
&#125;

abstract class B extends A&#123;
    int numb = 20;
    public abstract void showB();
&#125;

class C extends B&#123;
    int numc = 30;

    @Override
    public void showA() &#123;
        System.out.println(&quot;A类中numa:&quot;+numa);
    &#125;

    @Override
    public void showB() &#123;
        System.out.println(&quot;B类中numb:&quot;+numb);

    &#125;
    public void showC()&#123;
        System.out.println(&quot;C类中numc:&quot;+numc);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        C c = new C();
        c.showA();
        c.showB();
        c.showC();
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-1"><a href="#练习：语法练习-1" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li>语法点：继承，抽象类</li>
<li>输出<code>动物种类:鸭子，年龄：2岁、 入院原因：感冒、 症状为：发烧</code></li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟农学院动物医疗系统信息。</li>
<li>定义抽象家禽类(Poultry)<ol>
<li>私有成员变量：动物种类(name)，症状(symptom)，年龄(age)， 病因（illness）</li>
<li>提供空参和带参构造方法</li>
<li>成员方法：<ol>
<li>抽象方法症状(showSymptom)</li>
<li>普通方法基本信息(showMsg)</li>
<li>提供setXxx和getXxx方法</li>
</ol>
</li>
</ol>
</li>
<li>定义普通鸭子类(Duck)<ol>
<li>提供空参和带参构造方法</li>
<li>重写showSymptom方法，打印症状信息。</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test3 &#123;
    public static void main(String[] args) &#123;
        Duck duck = new Duck(&quot;鸭子&quot;, &quot;感冒&quot;, &quot;发烧&quot;, 2);
        duck.showMsg();
        duck.showSymptom();
    &#125;
&#125;

/*
1.定义抽象家禽类(Poultry)
*/
abstract class Poultry &#123;
    //    i.成员变量(私有):

    private String name;
    private String illness;

    // 症状(symptom)
    private String symptom;
    //    年龄(age)
    private int age;

    //    ii.成员方法:  showSymptom
    public abstract void showSymptom();

    // 成员方法:  showMsg
    public void showMsg() &#123;
        System.out.print(&quot;动物种类:&quot; + name);
        System.out.println(&quot;,年龄:&quot; + age + &quot;岁&quot;);
        System.out.println(&quot;入院原因:&quot; + illness);
    &#125;

    //    iii.提供空参和带参构造方法
    public Poultry() &#123;
        super();
    &#125;

    public Poultry(String name, String illness, String symptom, int age) &#123;
        this.name = name;
        this.illness = illness;
        this.symptom = symptom;
        this.age = age;
    &#125;

    //    iv.提供setXxx和getXxx方法
    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIllness() &#123;
        return illness;
    &#125;

    public void setIllness(String illness) &#123;
        this.illness = illness;
    &#125;

    public String getSymptom() &#123;
        return symptom;
    &#125;

    public void setSymptom(String symptom) &#123;
        this.symptom = symptom;
    &#125;
&#125;

// Duck 类

class Duck extends Poultry &#123;

    public Duck() &#123;

    &#125;

    public Duck(String name, String illness, String symptom, int age) &#123;

        super(name, illness, symptom, age);

    &#125;

    @Override

    public void showSymptom() &#123;

        System.out.println(&quot;症状为:&quot; + getSymptom());

    &#125;

&#125;
</code></pre>
<h3 id="练习：语法练习-2"><a href="#练习：语法练习-2" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>输出：<code>王小平老师，讲授Java课、 李小乐同学，考试得了90分</code></p>
</li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟教学管理系统师生信息。</li>
<li>定义Person类。<ol>
<li>属性：姓名、年龄</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，显示基本信息showMsg方法</li>
</ol>
</li>
<li>定义Teacher类，继承Person<ol>
<li>属性：学科</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，讲课方法</li>
</ol>
</li>
<li>定义Student类，继承Person<ol>
<li>属性：分数</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，考试方法</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test &#123;

    public static void main(String[] args) &#123;
        //        i.创建老师对象t,并把名称赋值为”王小平”,年龄赋值为30,工资赋值为8000
        Teacher t = new Teacher(&quot;王小平&quot;, 30, &quot;Java&quot;);
        //        iii.调用老师对象t的讲解方法
        t.teach();

        //        iv.创建学生对象 s,并把名称赋值为”李小乐”,年龄赋值为14,成绩赋值为90分.
        Student s = new Student(&quot;李小乐&quot;, 14, 90);
        //        vi.调用学生对象 s 的考试方法
        s.exam();
    &#125;
&#125;

class Person &#123;
    // 名称(name)
    private String name;
    //    年龄(age)
    private int age;

    //    空参构造
    public Person() &#123;
    &#125;
    //  带参构造
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    // setXxx和getXxx方法
    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
/*
 2.定义老师类(Teacher),继承Person类
 */
class Teacher extends Person &#123;
    //    course(科目)
    private String course;
    //    空参构造
    public Teacher() &#123;
    &#125;
    //    带参构造方法
    public Teacher(String name,int age, String course) &#123;
        super(name,age);
        this.course = course;
    &#125;

    //    提供setXxx和getXxx方法
    public String getCourse() &#123;
        return course;
    &#125;
    public void setCourse(String course) &#123;
        this.course = course;
    &#125;

    public void teach() &#123;
        System.out.println(getName() +&quot;老师,讲授&quot;+course +&quot;课&quot;);
    &#125;
&#125;
/*
 3.定义学生类(Student),继承Person类
 */
class Student extends Person &#123;
    //    score(成绩)
    private int score;
    //    无参构造
    public Student() &#123;
        super();
    &#125;
    //    带参构造
    public Student(String name, int age,int score) &#123;
        super(name, age);
        this.score = score;
    &#125;

    //    提供setXxx和getXxx方法
    public int getScore() &#123;
        return score;
    &#125;
    public void setScore(int score) &#123;
        this.score = score;
    &#125;

    public void exam()&#123;
        System.out.println(getName()+&quot;同学,考试得了:&quot;+ score +&quot;分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-3"><a href="#练习：语法练习-3" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>编写步骤</p>
<ol>
<li>模拟汽车网站信息。</li>
<li>定义汽车Auto类<ol>
<li>属性：品牌，车长，价格</li>
</ol>
</li>
<li>定义SUV继承Auto类<ol>
<li>属性：小型车车长标准值：4295，中型车车长标准值：5070。</li>
<li>定义判断车型方法<ol>
<li>判断小型车：小于小型车车长标准值</li>
<li>判断大型车：大于中型车车长标准值</li>
<li>判断中型车：大于小型车车长标准值并且小于等于中型车车长标准值</li>
</ol>
</li>
</ol>
</li>
<li>测试类中，创建若干SUV对象，保存到集合，遍历集合，输出中型SUV。</li>
</ol>
</li>
</ul>
<pre><code class="java">public class Test5 &#123;
    public static void main(String[] args) &#123;
        // 创建SUV对象
        SUV suv1 = new SUV(5079, 750000);
        SUV suv2 = new SUV(4813, 760000);
        SUV suv3 = new SUV(4270, 127800);
        SUV suv4 = new SUV(4545, 188800);

        //添加到集合中
        ArrayList&lt;SUV&gt; list = new ArrayList&lt;&gt;();
        list.add(suv1);
        list.add(suv2);
        list.add(suv3);
        list.add(suv4);

        // 遍历集合,查询中型SUV
        for (int i = 0; i &lt; list.size(); i++) &#123;
            SUV suv = list.get(i);
            if (suv.midSUV())&#123;
                suv.showMsg();
            &#125;
        &#125;
    &#125;
&#125;
// 定义汽车类
class Auto &#123;
    private String type;
    private double length;
    private double price;

    public Auto() &#123;
    &#125;

    public Auto(String type, double length, double price) &#123;
        this.type = type;
        this.length = length;
        this.price = price;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    public double getLength() &#123;
        return length;
    &#125;

    public void setLength(double length) &#123;
        this.length = length;
    &#125;

    public double getPrice() &#123;
        return price;
    &#125;

    public void setPrice(double price) &#123;
        this.price = price;
    &#125;

    public void showMsg() &#123;
        System.out.println(&quot;车型:&quot; + type);
        System.out.println(&quot;\t价格:&quot; + price);
        System.out.println(&quot;\t车长:&quot; + length);

    &#125;

&#125;

// 定义SUV类
class SUV extends Auto &#123;
    // 车长标准
    private int miniLength = 4295;
    private int midLength = 5070;

    public SUV(double length, double price) &#123;
        super(&quot;SUV&quot;, length, price);
    &#125;
    // 判断 小型车
    public boolean miniSUV() &#123;
        return getLength() &lt;= miniLength;
    &#125;

    // 判断 大型车
    public boolean largeSUV() &#123;
        return getLength() &gt; midLength;
    &#125;

    // 判断 中型车
    public boolean midSUV() &#123;
        return getLength() &gt; miniLength &amp;&amp; getLength() &lt;= midLength;
    &#125;
&#125;
</code></pre>
<h1 id="接口-amp-多态"><a href="#接口-amp-多态" class="headerlink" title="接口&amp;多态"></a>接口&amp;多态</h1><h3 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h3><h5 id="什么是接口，如何定义接口？"><a href="#什么是接口，如何定义接口？" class="headerlink" title="什么是接口，如何定义接口？"></a><span style = "color :red">什么是接口，如何定义接口？</span></h5><ul>
<li>接口，是java语言中一种类型，是方法的集合</li>
<li>使用interface关键字定义接口，其中可以定义抽象方法，默认方法，私有方法，静态方法等方法</li>
</ul>
<h5 id="什么叫做多态，条件是什么？"><a href="#什么叫做多态，条件是什么？" class="headerlink" title="什么叫做多态，条件是什么？"></a><span style = "color :red">什么叫做多态，条件是什么？</span></h5><p>一类事物的行为，具有多种表现形式<br>条件：</p>
<ul>
<li>继承或实现[二选一]</li>
<li>方法的重新</li>
<li>父类引用指向子类对象</li>
</ul>
<h5 id="使用多态特性，带来了什么样的好处？"><a href="#使用多态特性，带来了什么样的好处？" class="headerlink" title="使用多态特性，带来了什么样的好处？"></a><span style = "color :red">使用多态特性，带来了什么样的好处？</span></h5><p>增强方法的扩展性和复用性</p>
<h5 id="使用多态特性，注意什么样的弊端？"><a href="#使用多态特性，注意什么样的弊端？" class="headerlink" title="使用多态特性，注意什么样的弊端？"></a><span style = "color :red">使用多态特性，注意什么样的弊端？</span></h5><p>由于类型的提升，导致调用子类对象特有的方法，必须向下转型。</p>
<h3 id="练习：接口"><a href="#练习：接口" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAAA\n  BBBB</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义默认方法showB。</li>
<li>B类中，重写showA方法</li>
<li>测试类中，创建B类对象，调用showA方法，showB方法。</li>
</ol>
<pre><code class="java">interface A&#123;
    public abstract void showA(); //抽象方法
    public default void showB()&#123; //默认方法
        System.out.println(&quot;BBB&quot;);
    &#125;
&#125;

class B implements A&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        B b = new B();
        b.showA();
        b.showB();

    &#125;
&#125;
</code></pre>
<h3 id="练习：接口-1"><a href="#练习：接口-1" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAA\n  BBBB BBBB BBBB BBBB\n CCCC CCCC CCCC CCCC</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义默认方法showB10，showC10，分别调用show10方法，传入参数。</li>
<li>测试类中，创建B对象，调用showA方法，showB10方法，showC10方法</li>
</ol>
<pre><code class="java">interface AA&#123;
    public abstract void showA();
    private void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.print(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
    public default void show10B()&#123;
        show10(&quot;BBBB&quot;);
    &#125;
    public default void show10C()&#123;
        show10(&quot;CCCC&quot;);
    &#125;
&#125;
class BB implements AA&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        BB b = new BB();
        b.showA();
        b.show10B();
        b.show10C();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，静态"><a href="#练习：接口，静态" class="headerlink" title="练习：接口，静态"></a>练习：接口，静态</h3><ul>
<li>编写步骤</li>
</ul>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有静态方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义静态方法showB()，showC()，分别调用show10方法，传入参数。</li>
<li>B类中，定义静态方法showD</li>
<li>测试类中，使用A接口，调用静态showB()方法，showC()方法，</li>
<li>测试类中，使用B类，调用showA方法，showD方法。</li>
</ol>
<pre><code class="java">interface AAA&#123;
    public abstract void showA();

    public static void showB() &#123;
        System.out.println(&quot;static BBBB&quot;);
        show10(&quot;BBBB&quot;);
    &#125;
    public static void showC()&#123;
        System.out.println(&quot;static CCCC&quot;);
        show10(&quot;CCCC&quot;);
    &#125;
    private static void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
&#125;

class BBB implements AAA&#123;

    @Override
    public void showA() &#123;
        System.out.println(&quot;AAA&quot;);
    &#125;
    public void showD()&#123;
        System.out.println(&quot;DDDD&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        AAA.showB();
        AAA.showC();
        BBB bbb = new BBB();
        bbb.showA();
        bbb.showD();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，多态"><a href="#练习：接口，多态" class="headerlink" title="练习：接口，多态"></a>练习：接口，多态</h3><p>输出：<code>star:星星一闪一闪亮晶晶\n    =======\n     sun:太阳引着9大行星旋转\n    sun：光照八分钟，到达地球</code></p>
<p>编写步骤</p>
<ol>
<li>定义接口Universe，提供抽象方法doAnything。</li>
<li>定义普通类Star，提供成员发光shine方法</li>
<li>定义普通类Sun，继承Star类，实现Universe接口</li>
<li>测试类中，创建Star对象，调用shine方法</li>
<li>测试类中，多态的方式创建Sun对象，调用doAnything方法，向下转型，调用shine方法。</li>
</ol>
<pre><code class="java">interface Universe&#123;
    public abstract void doAnything();
&#125;
class Star&#123;
    public void shine()&#123;
        System.out.println(&quot;star:星星一闪一闪亮晶晶&quot;);
    &#125;
&#125;
class Sun extends Star implements  Universe&#123;
    @Override
    public void doAnything() &#123;
        System.out.println(&quot;sun:太阳吸引着9大行星旋转&quot;);
    &#125;
    @Override
    public void shine() &#123;
        System.out.println(&quot;sun:光照八分钟,到达地球&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Star s = new Star();
        s.shine();
        System.out.println(&quot;====================&quot;);
        Universe universe = new Sun();
        universe.doAnything();
        Sun sun = (Sun)universe;
        sun.shine();
    &#125;
&#125;
</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="练习：需求实现-1"><a href="#练习：需求实现-1" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>定义HandleAble接口，具备一个处理字符串数字的抽象方法方法HandleString（String num）。</p>
<ul>
<li>处理方式1：取整数部分。</li>
<li>处理方式2：保留指定位小数，四舍五入。</li>
</ul>
</li>
<li><p>开发提示：</p>
<ul>
<li>匿名内部类[<span style = "color : grey"><u>接口不能带方法体可以匿名内部类</u></span>]的方式，调用所有抽象方法</li>
</ul>
</li>
</ul>
<pre><code class="java">interface HandleAble&#123;
    String handleString(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        String str = &quot;23.23456789&quot;;
        System.out.println(&quot;原字符串是：&quot; + str);
        HandleAble s1 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;
                return str.substring(0,str.indexOf(&quot;.&quot;));
            &#125;
        &#125;;
        System.out.println(&quot;取整后：&quot; + s1.handleString(str));

        int num = 4;

        HandleAble s2 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;

                int i = str.indexOf(&quot;.&quot;) + num + 1;
                char c = str.charAt(i);
                //System.out.println(c);

                if (c &lt;= &#39;4&#39;) &#123;
                    return str.substring(0, i).toString();
                &#125; else &#123;
                    char c1 = (char) (str.charAt(str.indexOf(&quot;.&quot;) + num) + 1);
                    return str.substring(0, i - 1) + c1;

                &#125;
            &#125;
        &#125;;
        String sss = s2.handleString(str);
        System.out.println(&quot;保留&quot; + num + &quot;位小数后:&quot; + sss);
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-2"><a href="#练习：需求实现-2" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟上课出勤情况。</li>
</ul>
<ul>
<li><p>定义学生类：</p>
<ul>
<li>属性：姓名，出勤。</li>
<li>提供基本的构造方法和get方法，set方法。</li>
</ul>
</li>
<li><p>定义讲师类：</p>
<ul>
<li>属性：姓名。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤。</li>
</ul>
</li>
<li><p>定义课程类：</p>
<ul>
<li>属性：课程名称，讲师，学生集合。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：show方法，打印课程信息，老师姓名，学生是否上课情况。</li>
</ul>
</li>
</ul>
<blockquote>
<p>课程名称：Java<br>授课老师：张老师<br>上课：小红<br>上课：小亮<br>旷课：小明</p>
</blockquote>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Student s = new Student(&quot;小红&quot;);
        Student s1 = new Student(&quot;小亮&quot;);
        Student s2 = new Student(&quot;小明&quot;);
        ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;();
        arr.add(s);
        arr.add(s1);
        arr.add(s2);
        Teacher t = new Teacher(&quot;张老师&quot;);
        Course course = new Course(&quot;java&quot;,t,arr);
        t.dianming(arr);
        course.show();

    &#125;
&#125;

class Student&#123;
    private String name;
    private boolean come;

    public Student() &#123;
    &#125;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public boolean isCome() &#123;
        return come;
    &#125;

    public void setCome(boolean come) &#123;
        this.come = come;
    &#125;
&#125;
class Teacher&#123;
    private String name;
    // 点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤
    public void dianming(ArrayList&lt;Student&gt; arr)&#123;
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            if (!student.getName().equals(&quot;小明&quot;))&#123;
                student.setCome(true);
            &#125;
        &#125;
    &#125;
    public Teacher() &#123;
    &#125;

    public Teacher(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
class Course&#123;
    private String name;
    private Teacher t;
    private ArrayList&lt;Student&gt; arr;

    public Course() &#123;
    &#125;

    public Course(String name, Teacher t, ArrayList&lt;Student&gt; arr) &#123;
        this.name = name;
        this.t = t;
        this.arr = arr;
    &#125;
    public void show()&#123;
        System.out.println(&quot;课程名称:&quot; + name);
        System.out.println(&quot;授课老师:&quot; + t.getName());
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            String name = student.getName();
            if (student.isCome()) &#123;
                System.out.println(&quot;上课: &quot; + name);
            &#125; else &#123;
                System.out.println(&quot;旷课: &quot; + name);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-3"><a href="#练习：需求实现-3" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟接待员接待用户，根据用户id，给用户分组。</li>
</ul>
<ul>
<li>定义接口Filter：<ul>
<li>提供抽象方法filterUser（User u）</li>
</ul>
</li>
<li>定义用户类：<ul>
<li>属性：用户类型，用户id</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li>定义接待员类：<ul>
<li>属性：接口Filter</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：接待用户方法，设置用户类型。</li>
</ul>
</li>
<li>测试类：<ul>
<li>初始化50个User对象，id为1-50。</li>
<li>创建三个接待员对象。<ul>
<li>第一个接待员，设置接待规则，将10-19号用户类型设置为v1。</li>
<li>第二个接待员，设置接待规则，将20-29号用户类型设置为v2。</li>
</ul>
</li>
<li>遍历用户集合，给用户分区。</li>
</ul>
</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        ArrayList&lt;User&gt; ulist = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt;= 50; i++) &#123;
            ulist.add(new User(i));
        &#125;

        System.out.println(&quot;未分组:&quot;);
        System.out.println(ulist);

        Reception r1 = new Reception();
        Reception r2 = new Reception();
        Reception r3 = new Reception();
        r1.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 10 &amp;&amp; u.getId() &lt; 20)
                    u.setType(&quot;v1&quot;);
            &#125;
        &#125;);

        r2.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 20 &amp;&amp; u.getId() &lt; 30)
                    u.setType(&quot;v2&quot;);
            &#125;
        &#125;);

        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            r1.recept(user);
            r2.recept(user);
            r3.recept(user);
        &#125;
        System.out.println(&quot;已分组:&quot;);
        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            if (i % 9 == 0) &#123;
                System.out.println();
            &#125;
            System.out.print(user + &quot; &quot;);
        &#125;

    &#125;
&#125;

class Reception &#123;

    Filter f;

    public Filter getF() &#123;
        return f;
    &#125;

    public void setF(Filter f) &#123;
        this.f = f;
    &#125;

    public void recept(User u) &#123;
        if (u.getType() != null)
            return;
        if (f != null) &#123;
            f.filterUser(u);
            return;
        &#125; else &#123;
            u.setType(&quot;A&quot;);
        &#125;
    &#125;
&#125;

class User &#123;

    private String type;

    private int id;

    public User(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    @Override
    public String toString() &#123;
        return id + &quot;-&quot; + type;
    &#125;
&#125;

interface Filter &#123;
    public abstract void filterUser(User u);
&#125;
</code></pre>
<h3 id="练习：需求实现-4"><a href="#练习：需求实现-4" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>模拟工人挑苹果。</p>
</li>
<li><p>定义苹果类：</p>
<ul>
<li>属性：大小，颜色。</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li><p>定义接口CompareAble：</p>
<ul>
<li>定义默认方法compare，挑选较大苹果。</li>
</ul>
</li>
<li><p>定义接口实现类Compare。</p>
</li>
<li><p>定义工人类：</p>
<ul>
<li>成员方法：挑选苹果Apple pickApple（CompareAble，Apple a1，Apple a2）。</li>
</ul>
</li>
<li><p>测试类：</p>
<ul>
<li>创建Worker对象。</li>
<li>创建两个Apple对象，一个Apple（5，”青色”）,一个Apple（3，”红色”）</li>
<li>默认挑选大的苹果，打印苹果信息。</li>
<li>指定颜色挑选，通过匿名内部类实现。</li>
</ul>
</li>
<li><p>代码实现，效果所示：</p>
</li>
</ul>
<blockquote>
<p>默认挑大的：<br>5.0 - 青色<br>挑红的：<br>3.0 - 红色</p>
</blockquote>
<pre><code class="java">interface CompareAble&#123;
    default Apple compare(Apple a1, Apple a2)&#123;
        return a1.getSize() &gt; a2.getSize() ? a1 : a2;
    &#125;
&#125;

class Apple&#123;
    private double size;
    private String color;

    public Apple() &#123;
    &#125;

    public Apple(double size, String color) &#123;
        this.size = size;
        this.color = color;
    &#125;

    public double getSize() &#123;
        return size;
    &#125;

    public void setSize(double size) &#123;
        this.size = size;
    &#125;

    public String getColor() &#123;
        return color;
    &#125;

    public void setColor(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Apple&#123;&quot; +
                &quot;size=&quot; + size +
                &quot;, color=&#39;&quot; + color + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;

class Worker&#123;
    public Apple pickApple(CompareAble c, Apple a1, Apple a2)&#123;
        Apple compare = c.compare(a1,a2);
        return compare;
    &#125;


public class Test &#123;
    public static void main(String[] args) &#123;
        Worker worker = new Worker();
        Apple apple1 = new Apple(5, &quot;青色&quot;);
        Apple apple2 = new Apple(3, &quot;红色&quot;);
        System.out.println(&quot;默认挑大的:&quot;);
        Apple apple = worker.pickApple(new Com(), apple1, apple2);
        System.out.println(apple);

        System.out.println(&quot;挑红的:&quot;);
        Apple apple3 = worker.pickApple(new Com()&#123;
            @Override
            public Apple compare(Apple a1, Apple a2) &#123;
                return &quot;红色&quot;.equals(a1.getColor()) ? a1 : a2;
            &#125;
        &#125;,apple1,apple2);
        System.out.println(apple3);
    &#125;
    &#125;
&#125;

class Com implements CompareAble &#123;

&#125;
</code></pre>
<h1 id="数组习题"><a href="#数组习题" class="headerlink" title="数组习题"></a>数组习题</h1><h3 id="练习：需求实现-5"><a href="#练习：需求实现-5" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"><a href="#模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。" class="headerlink" title="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"></a>模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。</h6><p>输出：<code>黑桃A 黑桃5 方片J</code></p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        String[] poker = getPoker();
// 抽取指定的三种扑克牌
        int num1 = 1;
        int num2 = 5;
        int num3 = 50;
        String[] pk3 = get3(poker , num1 ,num2,num3);
        // 打印抽取的牌
        for (int i = 0; i &lt; pk3.length; i++) &#123;
            System.out.print(pk3[i] + &quot; &quot;);
        &#125;
    &#125;
    private static String[] get3(String[] poker, int i, int i2, int i3)&#123;
        String[] pk3 = new String[3];
        pk3[0] = poker[i - 1];
        pk3[1] = poker[i2 - 1];
        pk3[2] = poker[i3 - 1];
        return pk3;
    &#125;
    private static String[] getPoker()&#123;
        String[] colors=&#123;&quot;黑色&quot;,&quot;红桃&quot;,&quot;梅花&quot;,&quot;方块&quot;&#125;;
        String[] nums=&#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;;
        String[] poker = new String[54];
        int index = 0;
        for (int i = 0; i &lt; colors.length; i++) &#123;
            for (int j = 0; j &lt; nums.length; j++) &#123;
                poker[index] = colors[i] + nums[j];
                index++;
            &#125;
        &#125;
        poker[52] = &quot;小王&quot;;
        poker[53] = &quot;大王&quot;;

        return poker;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-6"><a href="#练习：需求实现-6" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="定义equals方法，比较数组内容是否完全一致。"><a href="#定义equals方法，比较数组内容是否完全一致。" class="headerlink" title="定义equals方法，比较数组内容是否完全一致。"></a>定义equals方法，比较数组内容是否完全一致。</h6><p>开发提示：</p>
<ul>
<li>长度一致，内容一致，定义为完全一致。</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        int[] arr = &#123;1,2,3,4,3,2,1&#125;;
        int[] arr2 = &#123;1,2,3,4,3,2,1&#125;;
        System.out.println(&quot; 是否一致:&quot; +equals(arr ,arr2));

    &#125;
    //  比较数组的内容
    public static boolean equals(int[] arr1, int[] arr2) &#123;
        // 长度不同,返回false
        if (arr1.length != arr2.length) &#123;
            return false;
        &#125;

        //
        for (int i = 0; i &lt; arr1.length; i++) &#123;
            // arr1[i] 和 arr2[i]比较
            /*
             * 所有元素都相同才相同，也就是只要有一个不同，这两个数组就是不同
             */
            if (arr1[i] != arr2[i]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1 id="异常-amp-线程习题"><a href="#异常-amp-线程习题" class="headerlink" title="异常&amp;线程习题"></a>异常&amp;线程习题</h1><h3 id="练习：异常的体系"><a href="#练习：异常的体系" class="headerlink" title="练习：异常的体系"></a>练习：异常的体系</h3><p>1.请描述异常的继承体系<br>异常继承体系：异常的根类是java.lang.Throwable。其下有两个子类：<code>java.lang.Error</code> 与 <code>java.util.Exception</code>。<br>Exception又分为编译时期异常：checked异常<br>                         与运行时期异常：runtime异常</p>
<p>2.请描述你对错误(Error)的理解<br><strong>Error</strong>：表示不可修复的恶性的错误，只能通过修改菜吗规避错误的产生，通常是系统级别的，所以很严重。</p>
<p>3.描述你对异常(Expection的理解)<br><strong>Exception</strong>：表示可修复的良性(相对于错误)的异常，异常产生后程序员可以并且通过代码的方式修正，使程序继续运行，是必须要处理的。</p>
<p>4.描述你对运行时异常(RuntimeException)的理解<br>运行时期异常：runtime异常。在运行时期，检查异常. 在编译时期，运行异常不会编译器检测(不报错)</p>
<h3 id="练习：throw与throws的区别"><a href="#练习：throw与throws的区别" class="headerlink" title="练习：throw与throws的区别"></a>练习：throw与throws的区别</h3><p>1.请描述throw的使用位置,作用是什么?<br>throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，后面语句都不执行</p>
<p>2.请描述throws的使用位置,作用是什么?<br>throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会<strong>将异常对象抛给方法调用处</strong></p>
<h3 id="练习：异常的处理方式"><a href="#练习：异常的处理方式" class="headerlink" title="练习：异常的处理方式"></a>练习：异常的处理方式</h3><p>1.异常处理方式有几种，分别是什么<br>异常的处理方式有两种，分别是使用 <code>throws</code> 和 <code>try...catch...finally</code></p>
<p>2.详细阐述每种方式对异常是如何处理的<br>throws用在方法的声明上后接异常类名，是把异常抛给调用者进行处助理<br>try…catch…finally是捕获异常，自己处理，处理完毕后面的程序可以继续运行<br>    <strong>try</strong>代码块中是可能出现异常的代码<br>    <strong>catch</strong>代码块，是遇到异常，对异常进行处理的代码<br>    <strong>finally</strong>代码块无论是否发生异常，都必须执行的代码，用于释放资源</p>
<h3 id="练习：常见异常，及产生原因"><a href="#练习：常见异常，及产生原因" class="headerlink" title="练习：常见异常，及产生原因"></a>练习：常见异常，及产生原因</h3><h6 id="请列举常见异常，并说明产生原因"><a href="#请列举常见异常，并说明产生原因" class="headerlink" title="请列举常见异常，并说明产生原因"></a>请列举常见异常，并说明产生原因</h6><p><strong>NullPointerException</strong>：空指针异常<br>当应用试图在要求使用对象的方法使用了null时，抛出该异常；譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度</p>
<p><strong>ArrayIndaexOutOfBoundsException</strong>：数组索引越界异常<br>当对数组的索引值为负数或大于等于数组大小时抛出此异常。</p>
<p><strong>ArithmeticException：</strong>算术运算异常<br>程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了</p>
<p><strong>NumberFormatException：</strong>数字格式异常<br>当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常</p>
<h3 id="练习：并行、并发概念"><a href="#练习：并行、并发概念" class="headerlink" title="练习：并行、并发概念"></a>练习：并行、并发概念</h3><h6 id="请简单描述什么是并行，什么是并发"><a href="#请简单描述什么是并行，什么是并发" class="headerlink" title="请简单描述什么是并行，什么是并发?"></a>请简单描述什么是并行，什么是并发?</h6><p>并行：指两个或多个事件在<strong>同一时刻发生</strong>（同时发生）。<br>并发：指两个或多个事件在<strong>同一个时间段</strong>内发生。</p>
<blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不  支持并行。<br>   你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>   你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
</blockquote>
<p><strong>并发</strong>的关键是你有处理多个任务的能力，不一定要同时。<br><strong>并行</strong>的关键是你有同时处理多个任务的能力。<br>它们最关键的点就是：是否是『同时』</p>
<h3 id="练习：进程概念、线程概念、线程与进程联系"><a href="#练习：进程概念、线程概念、线程与进程联系" class="headerlink" title="练习：进程概念、线程概念、线程与进程联系"></a>练习：进程概念、线程概念、线程与进程联系</h3><h6 id="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"><a href="#请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明" class="headerlink" title="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"></a>请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明</h6><p>进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>线程是进程中的一个执行单元，负责当前进程中程序的执行，<strong>一个进程中至少有一个线程</strong>。<strong>一个进程中是可以有多个线程的</strong>，这个应用程序也可以称之为多线程程序。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程, 但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。</p>
<h3 id="练习：自定义异常类"><a href="#练习：自定义异常类" class="headerlink" title="练习：自定义异常类"></a>练习：自定义异常类</h3><p>请使用代码实现<br>每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数<br>如果老师给学生赋值一个负数,抛出一个自定异常</p>
<pre><code class="java">// 1.定义异常类NoScoreException,继承RuntimeException 提供空参和有参构造方法
public class NoScoreException extends RuntimeException &#123;
    //  空参构造
    public NoScoreException() &#123;
            super();
    &#125;
    // 有参构造
    public NoScoreException(String message) &#123;
            super(message);
     &#125;
/* 2.定义学生类(Student)
   a)属性:name,score
   b)提供空参构造
   c)提供有参构造;
    i.使用setXxx方法给名称和score赋值
   d)提供setter和getter方法
    ii.在setScore(int score)方法中
    1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    2.然后在给成员score赋值.*/
public class Student &#123;
    private String name;
    private int score;
    // 空参构造
    public Student() &#123;
        super();
    &#125;
    // c)提供有参构造;
// i.使用setXxx方法给名称和score赋值
    public Student(String name,int score)&#123;
        setName(name);
        setScore(score);
    &#125;
// d)提供setter和getter方法

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getScore() &#123;
        return score;
    &#125;
    // i.在setScore(int score)方法中
    public void setScore(int score) &#123;
// 1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    if(score &lt;0)&#123;
       throw new NoScoreException(&quot;:分数不能为负数:&quot;+score);
    &#125;
// 2.然后在给成员score赋值.
        this.score = score;
    &#125;
&#125;
    /*
3.定义测试类Test9
 a)提供main方法,在main方法中
  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码
  iii.使用空参构造创建Student对象
  iv.调用setScore(int score)方法,传入一个正数,运行程序
  v.调用setScore(int score)方法,传入一个负数,运行程序
 */
public class Test9 &#123;
    public static void main(String[] args) &#123;
//  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
//  Student s = new Student(&quot;景甜&quot;, -10);
//  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码

//  iii.使用空参构造创建Student对象
        Student s = new Student();
//  iv.调用setScore(int score)方法,传入一个正数,运行程序
        s.setScore(100);
//  v.调用setScore(int score)方法,传入一个负数,运行程序
        s.setScore(-5);
    &#125;
&#125;
</code></pre>
<h1 id="网络通信概述-amp-TCP协议习题"><a href="#网络通信概述-amp-TCP协议习题" class="headerlink" title="网络通信概述&amp;TCP协议习题"></a>网络通信概述&amp;TCP协议习题</h1><h3 id="练习：ip地址和端口号概念"><a href="#练习：ip地址和端口号概念" class="headerlink" title="练习：ip地址和端口号概念"></a>练习：ip地址和端口号概念</h3><p>描述:<br>一、请写出IP地址的概念：<br><strong>IP地址：</strong>互联网协议地址(Internet Protocol Address), 俗称IP.IP地址用来给一个网络中的计算机设备做唯一的编号.</p>
<p>二、请写出端口号的概念：<br><strong>端口号:</strong>   端口号用来给计算机里的应用程序(进程)做唯一的标识,用2个字节表示的整数,取值范围0~65535.</p>
<h3 id="练习：UDP协议"><a href="#练习：UDP协议" class="headerlink" title="练习：UDP协议"></a>练习：UDP协议</h3><h6 id="判断下列说法是否正确：（-X-）"><a href="#判断下列说法是否正确：（-X-）" class="headerlink" title="判断下列说法是否正确：（ X ）"></a>判断下列说法是否正确：（ X ）</h6><p>由于UDP面向无连接的协议,可以保证数据完整性,因此在传输重要数据时采用UDP协议.<br><span style = "color : red"><strong>判断错误, 因为面向无连接,容易丢失包,所以不能保证数据完整.</strong></span></p>
<h3 id="练习：TCP协议"><a href="#练习：TCP协议" class="headerlink" title="练习：TCP协议"></a>练习：TCP协议</h3><h6 id="TCP协议中”三次握手”-第一次握手指的是什么："><a href="#TCP协议中”三次握手”-第一次握手指的是什么：" class="headerlink" title="TCP协议中”三次握手”,第一次握手指的是什么："></a>TCP协议中”三次握手”,第一次握手指的是什么：</h6><p><span style = "color : red">第一次握手:客户端向服务器发送请求,等待服务器确认</span></p>
<h3 id="练习：TCP网络协议"><a href="#练习：TCP网络协议" class="headerlink" title="练习：TCP网络协议"></a>练习：TCP网络协议</h3><h6 id="需求说明：创建新项目，按以下要求编写代码："><a href="#需求说明：创建新项目，按以下要求编写代码：" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 服务器端 端口号为8888<br>1: 等待客户端连接  如果有客户端连接 获取到客户端对象<br>2: 获取到客户端对象之后 当前在服务器读取数据客户端传送数据</p>
<pre><code class="java">public class TCPServer &#123;
   public static void main(String[] args) throws Exception &#123;
      //1创建服务器对象 
      ServerSocket  ss = new ServerSocket(8888);
      //2等待客户端连接   如果有客户端连接  获取到客户端对象 
      Socket socket = ss.accept();
      //3当前在服务器中  要读取数据  需要输入流  流由谁提供 客户端
      InputStream in = socket.getInputStream();//获取输入流
      //4:读数据
      int len;
      byte[] buffer = new byte[1024];
      while((len=in.read(buffer))!=-1)&#123;
          System.out.println(new String(buffer, 0, len));
      &#125;
      //释放资源
      in.close();
//       ss.close();服务器一般不会关闭
   &#125;
&#125;
</code></pre>
<h6 id="需求说明：创建新项目，按以下要求编写代码：-1"><a href="#需求说明：创建新项目，按以下要求编写代码：-1" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 客户端<br>访问之前创建的服务器端,服务器端ip127.0.0.1 端口号8888<br>1: 客户端连接服务器,并发送 hello.服务器,我是客户端.<br>2: 开启上一题服务器,等待客户端连接,客户端连接并发送数据 </p>
<pre><code class="java">public class TCPClient &#123;
  public static void main(String[] args) throws Exception &#123;
      //创建 Socket客户端对象
      Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
      //写数据  需要输出流  谁提供 客户端
      OutputStream out = socket.getOutputStream();
      //写数据
      out.write(&quot;hello.服务器,我是客户端.&quot;.getBytes());
      //释放资源
      out.close();
      socket.close();
  &#125;
&#125;
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'hexo-theme-particle',      // The repository of store comments,
        owner: 'P-luminary',
        admin: ['P-luminary'],
        language: 'en',
        id: location.pathname,      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>