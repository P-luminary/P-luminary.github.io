
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/06/25/数学/连续,导数,隐函数,高阶导数/">
        <h2>
            连续、导数、隐函数、高阶导数
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/6/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E6%95%B0%E8%BF%9E%E7%BB%AD.jpg"></p>
<ul>
<li><p>设函数y&#x3D;f(x)在点x0处连续，则y&#x3D;f(x)在x0处的极限存在。</p>
</li>
<li><p>如果x0是函数f(x)的间断点，且<strong>左极限</strong>及<strong>右极限</strong>都存在，则称x0为函数f(x)的<u><strong>第一类间断点</strong></u></p>
</li>
<li><p><u><strong>第一类间断点</strong></u>[可去间断点 + 跳跃间断点]</p>
</li>
<li><p>左右极限都存在且相等时，属于第一类间断点，且为<strong>可去间断点</strong></p>
</li>
<li><p>左右极限都存在但不相等时，属于第一类间断点，且为<strong>跳跃间断点</strong></p>
</li>
<li><p>左右极限至少有一个不存在时，属于第二类间断点</p>
</li>
<li><p>求初等函数的间断点即求不在函数定义域内的点，而使两个分母分别为0的点不在定义域内</p>
</li>
<li><p>初等函数在其定义区间每点处都是连续的，所以找初等函数的间断点，只需要找出其无定义的点即可</p>
</li>
</ul>
<p> <strong>连续函数性质的应用</strong></p>
<p>证明连续的题：</p>
<p>1、先说明函数___在[ , ]上连续，因为… </p>
<p>2、f(?) &gt; 0，f(?) &lt; 0 <strong>根据零点定理**可知函数式在[  ,  ]内至少有… (<u>如果<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912">函数</a>y&#x3D; f(x)在区间[a,b]上的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%BE%E8%B1%A1/20402891">图象</a>是连续不断的一条<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%B2%E7%BA%BF/12004394">曲线</a>，并且有</strong>f(a)·f(b)&lt;0**,那么，函数y&#x3D; f(x)在区间(a,b)内有零点，即至少存在一个c∈(a,b),使得f(c)&#x3D;0,这个c也就是方程f(x)&#x3D; 0的根</u>) </p>
<p>3、<strong>至少</strong>的正根可以根据函数f() &gt; 0, f() &lt; 0来判定，<strong>至多</strong>的正根可以根据函数的导数大于0判断单调递增来说明。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%9B%B6%E7%82%B9%E5%AD%98%E5%9C%A8%E5%AE%9A%E7%90%86.jpg"></p>
<h2 id="连续性-导数-可导性"><a href="#连续性-导数-可导性" class="headerlink" title="连续性+导数(可导性)"></a>连续性+导数(可导性)</h2><ul>
<li>法线：k * k法 &#x3D; -1</li>
<li>两条直线若都存在斜率且平行，则两条直线的斜率相等</li>
<li>sin2x &#x3D; 2sinxcosx      (sin2x)’ &#x3D; 2cos2x</li>
<li>cos2x &#x3D; $2cosx^2$ - 1 &#x3D; 1 - $2sinx^2$    (cos2x)’ &#x3D; -2sin2x</li>
<li>tan2x &#x3D; $sec^2x$ - 1    (tan2x)’ &#x3D; 2sec^2x</li>
</ul>
<p><strong>导数的定义</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89.jpg"></p>
<p><strong>导数的定义技巧1</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A71.jpg"></p>
<p><strong>导数的定义技巧2</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A72.jpg"></p>
<p><strong>导数的定义技巧3</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A73.jpg"></p>
<p><strong>连续性+导数大题</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0%E6%B1%82%E8%BF%9E%E7%BB%AD%E6%80%A7%2B%E5%8F%AF%E5%AF%BC%E6%80%A7.jpg"></p>
<ul>
<li><strong><span style = "color: red">大题部分</span><strong>：解决该类问题的基本思路根据</strong>分段函数</strong>在其分界点处的性质来确定所含常数的值，若一函数在其分界点可导，首先在该点**<u>连续</u><strong>；而在分界点的导数则按导数定义或</strong><u>左右导数</u>**的定义来导</li>
<li>①先根据f(?) 带入两个式子 若 f1(?) &#x3D; f2(?) 则证明该分段函数在x&#x3D;？处是否连续；②之后根据f’-(?) 与 f’+(?)是否相等来判断该分段函数是否可导 </li>
<li>函数y &#x3D; f(x) 在点x0处左可导、右可导，并且左右导数相等，y &#x3D; f(x)在点x0处才可导；<span style = "color : red">函数y &#x3D; f(x)在点x0处可导，必在此点连续</span>；函数y&#x3D;f(x) 在点x0处连续，未必在此点可导</li>
</ul>
<hr>
<hr>
<h2 id="导数-隐函数"><a href="#导数-隐函数" class="headerlink" title="导数+隐函数"></a>导数+隐函数</h2><p>$x^x$&#x3D;$e^xlnx$</p>
<p>对于函数y&#x3D;u(x)$^v$$^x$,其中u(x) &gt; 0求导，可采用<strong>公式变形法</strong>，变形成复合指数函数，y&#x3D;e^[v(x)lnu(x)]</p>
<p>y&#x3D;f(x+1)，y’&#x3D;f’(x+1) + (x+1)’</p>
<ul>
<li><strong>可导的奇函数的导数为<span style = "color : red">偶函数</span>，可导的偶函数的导数为奇函数</strong></li>
<li>隐函数求导方法：求y对x的导数时要用符合函数的求导法则，然后将含有y’的项放到等式的一端，不含y’的项移到另一端，求y‘。【只要见到隐函数里的y’就把它再求导一遍  <u>(+2xy)’ &#x3D; 2y+2xy’、   (y^2) &#x3D; 2y’y</u>】</li>
<li>如<u>对数函数</u>f(x)&#x3D;u(x)^v(x) 求导可用**对数求导法 **[两边取自然对数]</li>
<li>如<u>指数函数</u>y&#x3D;e^v(x)lnu(x) 公式变形法[变形成复合]</li>
<li>欲求由方程F(x,y)&#x3D;0所确定的隐函数y&#x3D;f(x)的导数，要把方程中的x看作自变量，而将y视为x的函数，方程中关于y的函数便是x的复合函数，用复合函数的求导方法，即可得到关于y’的一次方程，从中解得y’即为所求</li>
</ul>
<h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><ul>
<li>求<strong>高阶导数</strong>的方法有不完全归纳法，即求出所给函数的1-3阶或4阶导数后，分析所得结果的规律，写出n阶导数↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/4d914efbf79536c15a6d2ddee182851.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B01.jpg"></p>
<ul>
<li>(x^3^)^(5)^表示x^3^的五阶导数，根据幂函数求导公式易得：第三阶导数为常数，因此第四阶和第五阶导数必为0</li>
</ul>
<p><strong>f(x) &#x3D; x^n^ 的n+1阶导数为0</strong> &#x3D;&gt; <strong>f(x) &#x3D; (x^n^)^(n+1)^  &#x3D; 0</strong></p>
<ul>
<li><strong>(d^2^y)&#x2F;(dx^2^)</strong> 高级模板↓</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0dxdy%E4%B8%8Edt%E6%A8%A1%E6%9D%BF.jpg"></p>
<p><strong>高级二次求导含复合变量</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E7%BA%A7%E4%BA%8C%E6%AC%A1%E6%B1%82%E5%AF%BC%E7%9A%84%E5%A4%8D%E5%90%88%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0.jpg"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/数学" style=color:#879cff>
                数学
            </a>
        </span>
        
    </div>

    <a href="/2022/06/25/数学/连续,导数,隐函数,高阶导数/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/10/英语/刘晓艳翻译/">
        <h2>
            刘晓艳翻译
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/10
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="文章长度"><a href="#文章长度" class="headerlink" title="文章长度"></a>文章长度</h3><p><strong>四级：</strong>140-160 words</p>
<p><strong>六级：</strong>200 words</p>
<h4 id="各档次的评分标准："><a href="#各档次的评分标准：" class="headerlink" title="各档次的评分标准："></a>各档次的评分标准：</h4><p><strong>13-15分</strong> 译文准确表达了原文的意思。用词贴切，行文流畅，基本上无语言错误，仅有个别小错。</p>
<p><span style = "color: red"><strong>10-12分</strong></span> 译文基本上表达了原文的意思。文字通顺、连贯，无重大语言错误。</p>
<h4 id="翻译单词不会写怎么办-谁都可以写成被动"><a href="#翻译单词不会写怎么办-谁都可以写成被动" class="headerlink" title="翻译单词不会写怎么办(谁都可以写成被动)"></a>翻译单词不会写怎么办(谁都可以写成被动)</h4><p><u>人或人称代词做主语都可以考虑成被动</u></p>
<p>① 用该单词的<strong>上位词</strong>来代替该单词(守门员 -&gt; 运动员 -&gt; 男人)(榴莲 -&gt; 食物 -&gt; 东西)(指南针 -&gt; 设备 -&gt; 工具)</p>
<p><strong>②</strong> 用会的单词把这个意思<strong>解释</strong>出来(春联能增加节日氛围 -&gt; 春联能使人们开心)</p>
<p>③ <strong>同义词</strong>或<strong>近义词</strong>改写</p>
<p>④ 大词就吓胡写，小词就装作没看见</p>
<ul>
<li>主谓宾上的是大词，剩下的都是小词(我爱上了美丽的大雁)<ul>
<li>大词：我 爱 大雁</li>
<li>小词：美丽的</li>
</ul>
</li>
</ul>
<pre><code class="java">铁观音一年四季均可采摘，尤其是春秋两季采摘的茶叶品质最佳(先找主谓[定语态 定时态])
Tieguanyin can be picked all the year around with the best
in Spring and Autumn.
Tieguanyin can be picked anytime in a year in Spring and Autumn.
</code></pre>
<pre><code class="java">普洱茶深受中国人喜爱
Pu&#39;er Tea is deeply loved by Chinese people. 
</code></pre>
<pre><code class="java">很多人认为合作比个人能力更重要
Cooperation is claimed to be more crucial than personal ability.
认为：claimed assume argue
重要关键的：crucial essential critical
</code></pre>
<pre><code class="java">人们普遍认为网购已经成为一种流行趋势
Online shopping is aruged to be a popular trend among the young and
the old.
</code></pre>
<pre><code class="java">那时，黄色是专为皇帝使用的颜色，皇家宫殿全都漆成黄色，黄袍总是黄色的，而普通老百姓是禁止穿黄色衣服的
At that time, yellow was designed to use for the emperons the roral
palace was painted yellow and the clothes of king was always yellow too,
However, the ordinary people were not allowed to wear yellow clothes.
</code></pre>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>以意群为单位读句子，确定句子的<strong>时态</strong>和<strong>语态</strong></li>
<li>确定句子的主干，非主干部分通过**定语(修饰名词)<strong>或</strong>状语(除定语外)**方式来翻译</li>
<li>每一句话翻译完，看这句活与下句话之间的逻辑关系，加逻辑关系词</li>
</ul>
<h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p><u>龙井是一种绿茶，主要产自中国东部沿海的浙江省</u>。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> <u>龙井茶独特的香味和口感为其赢得了“中国名茶”的称号，在中国深受大众的欢迎，在海外饮用的人也越来越多</u>。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> <u>龙井茶通常手工制作，其价格可能及其昂贵，也可能比较便宜，这取决于茶的生长地，采摘时间和制作工艺</u>。**<span style = "color: red">&#x2F;&#x2F;</span>** <u>龙井茶富含维生素C和其他多种有益健康的元素。经常喝龙井茶有助于减轻疲劳、延缓衰老</u>。</p>
<pre><code class="java">龙井是一种绿茶(主系表)，(这种绿茶-&gt;which)主要产自中国东部沿海的浙江省
Longjing is a type of green tea which is mainly produceed in Zhejiang 
Province in the east of China.
</code></pre>
<pre><code class="java">龙井茶(因为)独特的香味和口感(状语)为其赢得了“中国名茶”的称号，(主语)在中国深受大众的欢迎
,在海外饮用的人也越来越多。(主谓宾-&gt;龙井茶赢得了称号) 
With its unique taste, the tea gets a name of China&#39;s Famous Tea which is
popular at home and also overseas.
</code></pre>
<pre><code class="java">龙井茶(主)通常(副词做状语)手工(状语by hand)制作(谓)
In fact, Longjing is usually made by hand.
</code></pre>
<pre><code class="java">其价格可能及其昂贵，也可能比较便宜，这(which)取决于茶的生长地，采摘时间和制作工艺
It can be extremely expensive or comparatively cheap, which depends on its
origin, picking time and its craft.
</code></pre>
<pre><code class="java">龙井茶(主)富含(谓)维生素C和其他多种有益健康的元素(宾)。
经常喝龙井茶有助于减轻疲劳(使你快乐)、延缓衰老(使你年轻漂亮)
Besides, it contains rich Vitamin C and many other beneficial elements.
As a result, the tea helps relieve fatigue and delay the aging process
if one drinks it regularly.
</code></pre>
<h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>大运河是世界上最长的人工河，北起北京，南至杭州。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span>  它是中国历史上最宏伟的工程之一。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 大运河始建于公元前4世纪，公园13世纪末建成。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 修建之初是为了运输粮食，后来也用于运输其他商品。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 大运河沿线区域逐渐发展成为中国的工商业中心。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 长久以来，大运河对中国经济发展发挥了重要作用，有力地促进了南北地区之间的人员往来和文化交流。</p>
<pre><code class="java">大运河(主)是(谓)世界上最长的(定语)人工河(宾)，北起北京，南至杭州。
The Grand Canal is one of the longest river in the world, which is from
Beijing to Hangzhou
</code></pre>
<pre><code class="java">它(主)是(系)中国历史上最宏伟的(定)工程之一(表)。
大运河(which)始建于公元前4世纪，公园13世纪末建成。
It is one of the greatest projects in the Chinese history which began
in the 4th century and was completed at the end of 13th century.
</code></pre>
<pre><code class="java">修建之初(他的目的)是为了运输粮食，后来也用于运输其他商品。
Originally, it was to transport grains, and later was used to carry
other commodities.
</code></pre>
<pre><code class="java">大运河沿线(定)区域(主)逐渐发展成为(谓)中国的工商业中心。
The areas along the canal have gradually developed into the center of
industry and commerce in China.
</code></pre>
<pre><code class="java">长久以来，大运河(主)对中国经济发展(状)发挥了(谓)重要作用(宾)
有力地促进了(已有谓语所以ing)南北地区之间的人员往来和文化交流。
For a long time, it has played a key role in the economic development of
China, promoting the personal exchange and cultural communication between
the north and the south grearly.
</code></pre>
<p><span style = "color: red"><strong>单词永远在语境里背</strong></span></p>
<p>——————-(不论演奏过多少回)，the works of Beethoven always attract large audiences.</p>
<blockquote>
<p>no matter how many time they have been performed…<br>no matter how frequently<del>频繁的</del> they have been performed…<br>no matter how frequently performed…</p>
</blockquote>
<p>When you get men into that state of anger, ——————-(他们很容易出麻烦)</p>
<blockquote>
<p>…, they are apt to<del>倾向于</del> make trouble.<br>…, It is easy for them to make trouble.</p>
</blockquote>
<p>——————-(尽管我很崇拜他是个作家), I don’t like him as a man.</p>
<blockquote>
<p>Although I very admire him as a writer…<br>Him as I admire as a writer…</p>
</blockquote>
<p>Only in this way ——————-(我们才能在毕业之后很快适应社会)</p>
<blockquote>
<p>can we adapt to society quickly until we graduate</p>
</blockquote>
<p>His eyes were reading books ——————-(脑子却在胡乱思想)</p>
<blockquote>
<p>but the brain was flying wildly.<br>but he was thinking about something else.<br>while his mind was wandering.</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ff7d73>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/10/英语/刘晓艳翻译/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/08/后端/Java接口+泛型/">
        <h2>
            Java接口+泛型
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h1><p>接口，在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类相似，类描述对象的属性和方法</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p>
<p>接口与类的区别：</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口不能构造方法</li>
<li>接口中所有的方法必须是抽象方法</li>
<li>接口不能包含成员变量，除static和final变量</li>
<li>接口不是被继承了，而是被类实现</li>
<li>接口支持多重继承</li>
</ul>
<h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><pre><code class="java">[可见度] interface 接口名称 [extends 其他的类名
                     ]&#123;
    //声明变量
    //抽象方法
&#125;
</code></pre>
<p><strong>Interface关键词</strong>用来声明一个接口</p>
<pre><code class="java">import java.lang.*;
public interface NameOfInterface&#123;
    //任何类型final，static字段
    //抽象方法
&#125;
</code></pre>
<p>接口的特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字</li>
<li>接口中的方法都是公有的</li>
</ul>
<pre><code class="java">interface Animal&#123;
    public void eat();
    public void travel();
&#125;
</code></pre>
<h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>当类实现接口的时候，类要实现接口中所有的方法，否则类必须声明为抽象的类</p>
<p>类使用implements关键字实现接口，在类声明中Implements关键字放在class声明后面</p>
<pre><code class="java">...implements 接口名称[. 其他接口. 其他接口...]
...
</code></pre>
<pre><code class="java">/*文件名：MammalInt.java*/
public class MammalInt implements Animal&#123;
    public void eat()&#123;
        sout(&quot;Mammal eats&quot;);
    &#125;
    public void travel()&#123;
        sout(&quot;Mammal travels&quot;);
    &#125;
    public int noOfLegs()&#123;
        return 0;
    &#125;
    public static void main(String args[])&#123;
        MammalInt m = new MammalInt();
        m.eat();
        m.travel();
    &#125;
&#125;
运行结果：
Mammal eats
Mammal travels
</code></pre>
<p>重写接口中声明的方法时</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</li>
</ul>
<p>在实现接口的时候：</p>
<ul>
<li>一个类可以同时实现多个接口</li>
<li>一个类只能继承一个类，但是能实现多个接口</li>
<li>一个接口能继承另一个接口</li>
</ul>
<pre><code class="java">//文件名:Sports.java
public interface Sports&#123;
public void setHomeTeam ( String name ) ;
public void setVisiting&#39;Team ( String name ) ;
&#125;

//文件名: Football.java
public interface Football extends Sports&#123;
public void homeTeamScored ( int points ) ;
public void visitingTeamScored ( int points) ;
public void endofQuarter ( int quarter ) ;
&#125;

//文件名:Hockey.java
public interface Hockey extends Sports&#123;
public void homeGoalScored ( ) ;
public void visitingGoalScored ( );
public void endOfPeriod ( int period ) ;
public void overtimePeriod ( int ot ) ;
&#125;
Hockey接口自己声明了四个方法，从Sports接口继承了两个方法
这样实现Hockey接口的类需要实现六个方法
</code></pre>
<h4 id="接口的多重继承"><a href="#接口的多重继承" class="headerlink" title="接口的多重继承"></a>接口的多重继承</h4><p>在Java中，类的多重继承是不合法，但接口允许多重继承</p>
<p>在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口</p>
<pre><code class="java">public interface Hockey extends Sports, Event
</code></pre>
<p>接口允许多重继承，而Sports及Event可能定义或者继承相同的方法</p>
<h4 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h4><p>最常用的继承接口是没有包含任何方法的接口</p>
<p>标识接口作用：给某个对象打个标(盖个戳)，使对象拥有某个或者某些特权</p>
<pre><code class="java">public interface EventListenner&#123;&#125;
</code></pre>
<p><strong>建立一个公共的父接口：</strong>这是由几十个其他接口扩展的Java API，你可要使用一个标记接口来建立一组接口的父接口</p>
<p><strong>向一个类添加数据类型：</strong>实现标记接口的类不需要定义任何接口的方法，该类通过多态性变成一个接口类型</p>
<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>泛型，即“参数化类型”，泛型的本质是为了参数化类型，也就是说在泛型使用中，操作的数据类型被指定为一个参数，<u>这种参数类型可以用在类、接口和方法中</u>，分别被称为泛型类、泛型接口、泛型方法。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>该方法在调用时可以接收不同类型的参数，根据传递给泛型方法的参数类型来调用。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>就是在类名后面添加了个类型参数声明部分</p>
<p>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数也被称为一个类型变量</p>
<pre><code class="java">public class Box&lt;T&gt;&#123;
    private T t;
    
    public void add(T t)&#123;
        this.t = t;
    &#125;
    
    public T get()&#123;
        return t;
    &#125;
    
    public static void main(String[] args)&#123;
        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();
        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();
        integerBox.add(new Integer(10));
        stringBox.add(new String(&quot;Hello World&quot;));
        sout(&quot;Integer Value :%d\n\n&quot;,integerBox.get());
        sout(&quot;String Value :%s\n\n&quot;,stringBox.get());
    &#125;
&#125;

运行结果：
Inerger Value :100
String Value :Hello World
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/05/08/后端/Java接口+泛型/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/07/英语/刘晓艳作文—段落/">
        <h2>
            刘晓艳作文—段落
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><h4 id="因果递进论证-第一句话一般都是虚拟语气"><a href="#因果递进论证-第一句话一般都是虚拟语气" class="headerlink" title="因果递进论证 (第一句话一般都是虚拟语气)"></a>因果递进论证 (第一句话一般都是虚拟语气)</h4><p>如果我们多读书，就怎么了……(<u>视野↑</u> - <u>知识多↑</u> - <u>成功</u>) [顺着往下说]</p>
<h5 id="常-用连词："><a href="#常-用连词：" class="headerlink" title="常 用连词："></a>常 用连词：</h5><ul>
<li>B results from A    A因…导致B，因为…</li>
<li>B is a result of A    B是A的结果，产生影响</li>
<li>A result in b  导致了</li>
<li>A causes &#x2F; bring about &#x2F; give rise to &#x2F; lead to B</li>
</ul>
<p>举例：<u>暴力游戏</u></p>
<p>If teenagers and youngsters spent more time playing violent video games, they would imitate these actions, becoming isolated from others. As a result, they would never communicate with others, which leads to more crimes committed by the young. In the end, there would be more worrying problems in our society.</p>
<p>举例：<u>Why students should be encouraged to develop effective communication skills.</u></p>
<p>If university students could develop effective communication skills, they could make more friends. In additio ns, the more friends they have, the more comfortable life they will have on campus. As a result, they will have a better learning environment, which consequently lead to a more harmonious context throughout the nation.</p>
<p>举例：<u>The use of translation apps</u></p>
<p>The more popular translation apps become, the more time will be saved, which thus results in the effciency of our work. That means more tasks could be completed in a certain period. As a consequence, Chinese economy will be boosted a lot.</p>
<h4 id="分类论证-在论述sth的危害或影响时适用"><a href="#分类论证-在论述sth的危害或影响时适用" class="headerlink" title="分类论证(在论述sth的危害或影响时适用)"></a>分类论证(在论述sth的危害或影响时适用)</h4><ul>
<li>比如说<u>盗版&#x2F;假冒产品&#x2F;不良广告</u>的危害：对<u>个人&#x2F;集体&#x2F;社会&#x2F;国家</u></li>
</ul>
<p><u>the importance of mutual understanding and respect in interpersonal relationships.</u></p>
<p>In a dormitory, if every member could understand and respect each other, they might become more creative and effective in their study. In addition, it is such mutual understanding in interpersonal relationships that will result in a warm campus environment. In the end, there would be less conflict throughout our country. How desirable the vision is.</p>
<ul>
<li>科技发展的好处</li>
</ul>
<p>Firstly if technology develops quickly, we can benefit a lot, saving a lot of time and energy.</p>
<p>Then, it could lead to the rapid development of our whole country, producing more products in limited time.</p>
<ul>
<li>PPT广泛应用</li>
</ul>
<p><u>The use of PowerPoint is becoming increasingly popular in calss</u></p>
<p>The use of PowerPoint, to begin with, will make the knowledge more clear for students in class, thus, it is easy for them to master the key points. In addition, teachers could save a lot of time and make their classes more vividly.</p>
<h4 id="举例论证"><a href="#举例论证" class="headerlink" title="举例论证"></a>举例论证</h4><ul>
<li>阅读名著的好处</li>
</ul>
<p>我的一个朋友，从小就阅读了大量名著，她的爱好就是读名著，每次和他谈话总觉得他的知识面很宽，很博学，作文写得也很好。</p>
<p> 举例开头：</p>
<ul>
<li><p>Although numerous cases are available for this argument, the following one about my <u>XXX</u> is the most suitable.</p>
</li>
<li><p>Countless cases can <u>account for</u> &#x2F; <u>are responsible for</u> &#x2F; <u>contribute to</u> the <u>phenomenon</u> &#x2F; <u>situation</u> &#x2F; <u>my point</u>, but <u>this</u> &#x2F; <u>these</u> will suffice. </p>
</li>
<li><p>I can figure our no better illustration than the folllowing one.</p>
</li>
<li><p>although there are numerous cases in our daily life, the following one is the most typical.</p>
</li>
</ul>
<p>总结：all in all, in conclusion</p>
<ul>
<li>the story tells us that…</li>
<li>this case effectively clarifies the fact that…</li>
</ul>
<p>为什么孩子要远离暴力游戏？</p>
<p>Although there are numerous cases in our daily life, the following one is the most typical. I have a younger brother who was naughty but cute. When he was in primary school, he learned to play video games from his classmates. At the beginning, there no abnormal signs-He went to school normally and returned home normally. Suddenly, one day, he hurt one of his friends cruelly with a knife, which was incredible to all the families. This example effectively clarifies a truth that kids can be easy to imitate behaviors from these games, which might lead to serious consequences.</p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><pre><code class="java">For this part you are allowed 30misnutes to write an essay on
whether violent video ganmes online will cause students&#39; violent
behaviors. You should write at least 120 words but no more than 180 words.
</code></pre>
<ul>
<li>引出中心 + 个人观点</li>
</ul>
<p>&#x3D;&#x3D;<u><span style = "color: red">With</span> the rapid <span style = "color: red">development</span> of science and technology, there is a hot debate about</u> violent video games online. <u><span style = "color: red">From my perspective,</span></u> these games will not cause violent behaviors among teenagers and youngsters.&#x3D;&#x3D;</p>
<ul>
<li>原因引出 + 原因分析(2~3)</li>
</ul>
<p>(and 并列两个句子 加了定语、状语) + (举三个并列句子) + (if引导虚拟语气)</p>
<p><u><span style = "color: red">The reasons for this is not far to seek.</span></u> First of all, by playing online games, <u>students</u> (<strong>who have to spend most of their time on study and prepare various examinations</strong>) <u>can relieve the pressure</u> (<strong>in real life</strong>) and find like-minded peers to communicate with. In addition, these young men know clearly that online video games are virtual. At the same time the violent elements in games are unrealistic. As a consequence, the violence in online games has little impact on real life. In the end, if they were interested in something they like, there would be less violent behaviors in our society.</p>
<p>&#x3D;&#x3D;<u><span style = "color: red">[First and formost , Addtionally , Last but not least]</span></u>&#x3D;&#x3D;</p>
<p><u><span style = "color: red">[The fact that … suggest that …]</span></u></p>
<ul>
<li>总结句(总结 + 措施 + 口号)</li>
</ul>
<p>&#x3D;&#x3D;<u><span style = "color: red">To sum up, it is my belief that</span></u>&#x3D;&#x3D; violent online games will not result in students violent tendency. <u><span style = "color: red">it is necessary that</span></u> parents lead their children to right directions. <u><span style = "color: red">Only in this way can</span></u> these kids make use of these games properly.</p>
<hr>
<hr>
<pre><code class="java">For this part you are allowed 30misnutes to write an essay online
dictionaries.You can start your essay with the sentence&quot;The use of
online dictionaries is becoming increasingly popular.&quot;You should 
write at least 120 words but no more than 180 words.
</code></pre>
<ul>
<li>引出中心 + 个人观点</li>
</ul>
<p>（<u><span style = "color: red">In light of</span> the rapid <span style = "color: red">improvement</span> of  science and technology</u>）the use of online dictionaries is becoming increasingly popular, （which has been brought into the limelight under modern confiditions.） <u><span style = "color: red">As far as I am concerned</span></u>, we should attach importance to online dictionaries now and in the future.</p>
<ul>
<li>原因引出 + 原因分析(2~3)</li>
</ul>
<p>The popularity of online dictionaries, (<u>which really brings much convenience to the everyday life and study of youngsters,</u>) may be explained by many reasons. The main factor is that using online dictionaries can save us plenty of time, which proves to be in accord with people’s pursuit for higher efficiency. Then more importantly, (<u>it is so convenient for us to look up words on the web</u>) because we can efforlessly and rapidly find what we want by tapping words or phrases and the answer comes in no more than several seconds. So why bother to take a thick dictionary whenever or wherever?</p>
<ul>
<li>总结句(总结 + 措施 + 口号)</li>
</ul>
<p>In short, it is a sound conclusion that can be drawn that the use of online dictionaries, to some extent, is beneficial to English learners. So it might the right time to download one to serve us in our daily life.</p>
<h1 id="议论文"><a href="#议论文" class="headerlink" title="议论文"></a><span style = "color: red">议论文</span></h1><p><span style = "color: red">第一段</span><u><strong>引出主题 + 论述观点</strong></u></p>
<p><strong>引出主题：</strong></p>
<ul>
<li>Recently with the <u>development &#x2F; advance &#x2F; progress</u> of science and technology, the phenomenon of … has aroused wide concern.</li>
<li>Nowadays, it is undeniable that … has almost become the biggest concern of the present-day world.</li>
<li>There is no doubt that the issue about sth has caused wide public attention recently.</li>
<li><u><span style = "color: red">Recently with</span> the rapid <span style = "color: red">development</span> of science and technology, there is a hot debate about</u></li>
</ul>
<p><strong>表示个人观点：</strong></p>
<ul>
<li>In my opinion &#x2F; as far as I am concerned &#x2F; <u><span style = "color: red">from my perspective that…</span></u>(就我而言…东西<u>好&#x2F;不好</u>)</li>
</ul>
<p><span style = "color: red">第二段</span>**<u>分析原因</u>**的总起句(三大论证方法)</p>
<p><strong>原因引出：</strong></p>
<ul>
<li><u><span style = "color: red">The reasons for this is not far to seek.</span></u></li>
</ul>
<p><strong>原因分析：</strong></p>
<ul>
<li><p>The majority of people would agree that <strong>sth</strong>(use online dictionaries) has its deep roots. </p>
</li>
<li><p><u><span style = "color: red">As we know, recognizing a problem is the first step in finding a solution.</span></u></p>
</li>
<li><p><u><span style = "color: red">First and formost , Addtionally , Last but not least</span></u> </p>
<p><u><span style = "color: red">The fact that … suggest that …</span></u></p>
</li>
</ul>
<p><span style = "color: red">第三段</span><strong><u>总结 措施 倡议段</u></strong></p>
<p><strong>总结：</strong></p>
<ul>
<li><u><span style = "color: red">From what has been mentioned above, we can safely draw the conclusion that…</span></u></li>
<li>It is high time that enough attention should be poured into this problem.</li>
<li>In short, it is a sound conclusion that can be drawn that…</li>
<li><u><span style = "color: red">To sum up, it is my belief that</span></u></li>
</ul>
<p><strong>措施：</strong><u>我们、政府、家长、学校</u></p>
<ul>
<li>Student, from their early age, could be educated &#x2F; proposed to learn the advantages and disadvantages of living in big cities.</li>
<li>Teachers could broadcast the importance of reading books among students.</li>
<li><u><span style = "color: red">it is necessary that</span></u></li>
</ul>
<p><strong>倡议：</strong></p>
<ul>
<li>So shouldn’t 人 pay much attention to the problem of …</li>
<li>So under no account could 人 divert attention from the issue of sth.</li>
<li><u><span style = "color: red">Only in this way can…</span></u></li>
</ul>
<h1 id="书信作文"><a href="#书信作文" class="headerlink" title="书信作文"></a><span style = "color: red">书信作文</span></h1><p><span style = "color: red">第一段</span><u><strong>问候语+写作目的</strong></u>(比较熟) &#x2F; <u><strong>自我介绍+写作目的</strong></u>(不熟)</p>
<ul>
<li>I am delighted to know that you have a strong desire to learn Chinese in recent days. Therefore, the letter, to be honest, is to recommend a city for you.</li>
</ul>
<h4 id="不熟"><a href="#不熟" class="headerlink" title="不熟"></a>不熟</h4><p><strong>自我介绍：</strong>I am a freshman from the department of (专业) in this university</p>
<p><strong>写作目的：</strong>The aim of my letter is to (文章会给出)</p>
<p><span style = "color: red">第二段</span><u><strong>2~3个原因分析</strong></u></p>
<ul>
<li>When the idea occurs to me, the first 8     city flashing in my mind is Beijing, the capital of China. <u>Firstly</u>, there exists language environment which plays a key role in the process of language learning. As a result, as a modern city, it provides an excellent language environment for language learners. <u>Besides</u>, in one of the biggest cities, people are open-minded, hospitable, and inclusive. You will soon find that you can make friends with them quickly.</li>
</ul>
<p><span style = "color: red">第三段</span><u><strong>总结&#x2F;感谢+期待回信</strong></u></p>
<p><strong>表示感谢：</strong></p>
<ul>
<li>I take the opportunity to show my hearfelt apperciation for your generous assistance you rendered me.</li>
</ul>
<p><strong>期待回信:</strong></p>
<p><u>XXXXXXXXXXXXXXXXXXXXXXXXXXX</u></p>
<p>Finally, I hope that you could take my suggestions into serious consideration, and I am looking forward to your reply at your earliest convenience. Good luck to you with all aspects of life. Yours sincerely, Li Ming </p>
<h1 id="报告作文"><a href="#报告作文" class="headerlink" title="报告作文"></a><span style = "color: red">报告作文</span></h1><p><span style = "color: red">第一段</span><strong><u>时间日期+发生事+事的结果</u></strong>(成功&#x2F;失败)</p>
<ul>
<li>On June 18, Sunday, a volunteer activity in the local Nursing House was organized by the Student Union which proves to be as success.</li>
</ul>
<p><span style = "color: red">第二段</span><u><strong>活动具体是什么事</strong></u>(目的 + 内容 + 感受 + 意义)</p>
<ul>
<li>The activity was aimed at encouraging students to visit the elderly at the Nursing House and help elderly people deal with their troubles in their life. Many students volunteered to participate in this good deed and were engaged in helping the elderly here out by making their meals, washing their clothes and chatting with them. When asked about those volunteers’ feelings about such an experience, all of them responded with a smile, saying “What a wonderful experience and I really appreciate this acticity beacause it makes me learn to care about those who are in heed.”</li>
</ul>
<p><span style = "color: red">第三段</span><strong><u>总结</u></strong></p>
<ul>
<li>To sum up, the activity is quite successful not only for the elderly but for those students involved.</li>
</ul>
<p>·</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#879cff>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/07/英语/刘晓艳作文—段落/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/01/英语/基础语法/">
        <h2>
            基础语法
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><strong>名词性从句(</strong><u>主语、宾语、表语、同位语从句</u>)</p>
<p><strong>形容词性从句(</strong><u>定语从句</u>)</p>
<p><strong>副词性从句</strong>(<u>状语从句</u>)</p>
<h2 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h2><p>先找谓语(动词)，后面有两坨区分 </p>
<ul>
<li><strong>主谓双宾(直宾 &#x2F; 间宾)</strong> (和动词有直接关系的叫直接宾语)</li>
</ul>
<pre><code class="java">She will make him a good wife
主谓双宾 him为间接宾语 可放后面
She will make a good wife for him
</code></pre>
<p>I bring <strong>you</strong> a <strong>wife</strong> &#x3D;&gt; bring wife 所以wife是直接宾语</p>
<p>直宾间宾可以互换位置，但要<strong>加介词</strong></p>
<p>I bring a wife <strong><u>for</u></strong> you</p>
<pre><code class="java">A visit to elderly people brings them great laughter and joy.
(主 + 谓 + 间宾 + 直宾)
A          to elderly people brings great laughter and joy to them.
(主 + 谓 + 直宾 + 介词 + 间宾)
</code></pre>
<pre><code class="java">The unchecked growth of the tourism may render the environment(seriously polluted)
(主 + 谓 + 宾 + 宾补)
</code></pre>
<p>如何区分那两个？ 在中间加be动词，如果通顺就是(宾+宾补)</p>
<ul>
<li>**动词有直接关系的叫直接宾语 **</li>
<li><strong>宾补 与 宾 有关系</strong></li>
</ul>
<hr>
<p>宾语是对动词的引述 表语是对主语的补充</p>
<p><strong>要写主谓宾 就要找是否有 实义动词</strong></p>
<p><strong>要写主系表 就要看动词确实是无实义</strong></p>
<pre><code class="java">765trdx海湖最深处25.5米
The deepest point of Qinghai lake reaches 25.5 meters. 主谓宾，自己加个实义动词
The maximum depth of Qinghai lake is 25.5 meters. 主系表，谓语确定无实义
</code></pre>
<pre><code class="java">泰山方圆约400平方公里
Mount Tai covers an area of about 400 square kilometers.
</code></pre>
<p>主谓宾 和 主系表的区分 看 中间的词有没有具体含义</p>
<pre><code class="java">Peer pressure has a positive side.
主 + 谓 + 宾
</code></pre>
<pre><code class="java">Mutual trust is not a luxury, but it is a necessity.
主 + 系(无实义) + 表(主补)
</code></pre>
<p>系动词&#x2F;谓语动词：</p>
<ul>
<li><strong>动词</strong><ul>
<li>实义动词<ul>
<li>及物vt (及1个物) <ul>
<li>主谓宾</li>
<li>主谓双宾[直宾、间宾]</li>
<li>主谓宾宾补</li>
</ul>
</li>
<li>不及物vi (及2个物) <ul>
<li>[主谓] [不及物动词后面不加宾语 或者 必须接介词再加宾语]</li>
</ul>
</li>
</ul>
</li>
<li>无实义动词<ul>
<li>系动词[主系表(主从)]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="并列句"><a href="#并列句" class="headerlink" title="并列句"></a>并列句</h1><p>两个或以上独立<strong>分句</strong>，通过并列连词链接，各分句主谓完整，各分句意思同等重要，互相独立</p>
<ul>
<li>主要连词：and，or，but，yet</li>
</ul>
<h4 id="主谓一致"><a href="#主谓一致" class="headerlink" title="主谓一致"></a>主谓一致</h4><p>主谓一致指谓语动词必须在<strong>人称</strong>和**数(单复数)**与句子的主语保持一致</p>
<p>围绕着<strong>动词</strong>可以结合(<strong>三态一否</strong>：时态、语态、情态、否定)</p>
<table>
<thead>
<tr>
<th align="center">主语</th>
<th align="center">谓语&#x2F;系动词</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>第三人称&#x2F;单数</strong></td>
<td align="center"><strong>is &#x2F; was &#x2F; has &#x2F; 实义动词要在词尾加 -s 或 -es</strong></td>
</tr>
<tr>
<td align="center"><strong>复数</strong></td>
<td align="center"><strong>are &#x2F; were &#x2F; have &#x2F; 实义动词</strong></td>
</tr>
</tbody></table>
<p>意义一致：指主谓一致取决于<strong>主语的实际意义</strong></p>
<ul>
<li>All of the apples <strong>are</strong> rotten. 所有的苹果都烂了</li>
<li>All of the apple <strong>is</strong> rotten. 整个苹果都烂了</li>
<li><u>The rest of the lecture</u> <strong>is</strong> wonderful.</li>
<li><u>50% of the students in our class</u> <strong>are</strong> girls.</li>
<li><u>A number of</u> new books <strong>are</strong> on the desk.</li>
<li><u>The number</u> of students in you class <strong>is</strong> 50.</li>
</ul>
<p>I + am&#x2F;was&#x2F;have&#x2F;like</p>
<p>You + are&#x2F;were&#x2F;have&#x2F;like</p>
<p><strong>He&#x2F;She&#x2F;It + is&#x2F;was&#x2F;has&#x2F;likes （第三人称单数）</strong></p>
<p>They + are&#x2F;were&#x2F;have&#x2F;like</p>
<h4 id="时态语态"><a href="#时态语态" class="headerlink" title="时态语态"></a><strong>时态语态</strong></h4><p>时态：时间的状态</p>
<p>语态：主动或被动</p>
<h4 id="时态（重点8个）"><a href="#时态（重点8个）" class="headerlink" title="时态（重点8个）"></a>时态（重点8个）</h4><p>英语中的及物动词一般都有主动语态和被动语态两种形式。<u>被动语态</u>由助动词**be+过去分词(done)**构成。</p>
<p>助动词be随着主语的人称、数、时态和语气的不同而变化。(<strong>时态</strong>也可以加<strong>被动</strong>的BUFF噢~)</p>
<p><strong>过去完成时</strong> 一定要有过去的那个<strong>点</strong>(时间) &#x3D;&gt; (现在是12月，5月之前在长沙举办过了一个比赛)</p>
<table>
<thead>
<tr>
<th>时态</th>
<th>一般</th>
<th>进行</th>
<th>完成</th>
<th>完成进行</th>
</tr>
</thead>
<tbody><tr>
<td>现在</td>
<td><strong>do&#x2F;does</strong></td>
<td><strong>be doing</strong></td>
<td><strong>have&#x2F;has done</strong></td>
<td><strong>have&#x2F;has been doing</strong></td>
</tr>
<tr>
<td>过去</td>
<td><strong>did</strong></td>
<td><strong>was&#x2F;were doing</strong></td>
<td><strong>had done</strong></td>
<td>had been doing</td>
</tr>
<tr>
<td>将来</td>
<td><strong>will do</strong></td>
<td>will be doing</td>
<td>will have done</td>
<td>will have been doing</td>
</tr>
<tr>
<td>过去将来</td>
<td>would do</td>
<td>would be doing</td>
<td>would have done</td>
<td>would have been doing</td>
</tr>
</tbody></table>
<p>现在完成时：We <strong>have learned</strong> English for more than ten years.</p>
<p>现在完成进行时：We <strong>have been learning</strong> English for the past three months. (从过去到现在一直在做的一个动作)</p>
<ul>
<li>Do</li>
<li>did过去式：一般过去式</li>
<li>done过去分词：完成时态；被动结构be+done；非谓语</li>
<li>不规则动词变化表</li>
</ul>
<h4 id="时态翻译练习-若没有明显的时间提示-就都写一般现在时"><a href="#时态翻译练习-若没有明显的时间提示-就都写一般现在时" class="headerlink" title="时态翻译练习(若没有明显的时间提示 就都写一般现在时)"></a>时态翻译练习(若没有明显的时间提示 就都写一般现在时)</h4><ul>
<li><p>人们通常在<u>春节和其他节日期间</u>表演狮子舞。(先找句子主干 时间放后面)</p>
<p>People often play (perform) the lion dance during the Spring Festival and other festivals.</p>
</li>
<li><p>它已逐渐演变成了中国文化的独特元素。(从过去到现在 &#x3D;&gt; 现在完成时)</p>
<p>It has gradually become a special element of Chinese culture.</p>
</li>
<li><p>唐朝始于618年，终于907年，(唐朝)是<u>中国历史上</u>最灿烂的时期。(一般过去时，一般现在时[陈述事实])</p>
<p>The Tang Dynasty began in 618 and ended in 907, and it is the most splendid (glorious) period in Chinese history. </p>
<p>The Tang Dynasty was from in 618 and ended in 907, which and it is the most splendid (glorious) period in Chinese history.</p>
</li>
</ul>
<h4 id="被动语态翻译练习-中文会省略”被”字，要学会感受中文被动-x3D-gt-楼盖好了，桥修好了"><a href="#被动语态翻译练习-中文会省略”被”字，要学会感受中文被动-x3D-gt-楼盖好了，桥修好了" class="headerlink" title="被动语态翻译练习 (中文会省略”被”字，要学会感受中文被动) &#x3D;&gt; [楼盖好了，桥修好了]"></a>被动语态翻译练习 (中文会省略”被”字，要学会感受中文被动) &#x3D;&gt; [楼盖好了，桥修好了]</h4><ul>
<li>剪纸<strong>被用来</strong>装饰门窗和房间。**(泛指s)**</li>
</ul>
<p>Paper cuttings <strong>are used</strong> to decorate doors, windows and rooms.</p>
<ul>
<li>自<u>上世纪90年代</u>(?主语)安装缆车以来，参观人(de)数大大增加。 <strong>(缺主语 把宾语变成主语然后被动，有since主句用现在完成时)</strong></li>
</ul>
<p>Since cable cars <strong>were installed</strong> (used) in the 1990s, the number of visitors <strong>has increased</strong> sharply.</p>
<ul>
<li>核能是可以(被)<u>安全(de)</u><strong>开发和利用</strong>的。</li>
</ul>
<p>Nuclear power(energy) can be explored &#x2F; developed and used safely.</p>
<ul>
<li>整个<strong>义务教育</strong>阶段，(?)要求学生(被动)<u>在每学期期末</u>参加期末考试。(缺主语 把宾语变成主语然后被动) Compulsory course：必修课</li>
</ul>
<p>Throughout the whole period of <strong>compulsory education</strong>, students <strong>are required</strong> to take the final exam at the end of each term.</p>
<ul>
<li>今年<u>在长沙</u>(?)举行了一年一度的<u>外国人</u>汉语演讲比赛。 (对象 for sb 对于谁而言)(一般过去时)(主语是比赛 所以是was)</li>
</ul>
<p>An annual Chinese speech <strong>contest</strong> for foreigners <strong>was held</strong> in Changsha this year.</p>
<h1 id="复合句"><a href="#复合句" class="headerlink" title="复合句"></a>复合句</h1><p>看复杂的句子先找<strong>主句</strong>然后再找<strong>主干</strong>(<u>主句</u>表达主要意思 <u>从句</u>表达次要意思)</p>
<h4 id="三大从句"><a href="#三大从句" class="headerlink" title="三大从句"></a>三大从句</h4><ul>
<li>名词性从句(主语&#x2F;宾语&#x2F;表语可以充当名词)<ul>
<li>主语从句(识别及理解、It形式主语的类型)</li>
<li>宾语从句</li>
<li>表语从句</li>
<li>同位语从句</li>
</ul>
</li>
<li>形容词性从句<ul>
<li>定语从句</li>
</ul>
</li>
<li>副词性从句<ul>
<li>状语从句</li>
</ul>
</li>
</ul>
<h3 id="主语从句-把主语变成了一个句子"><a href="#主语从句-把主语变成了一个句子" class="headerlink" title="主语从句(把主语变成了一个句子)"></a>主语从句(把主语变成了一个句子)</h3><p>主语从句的识别及理解、It形式主语的类型</p>
<p>开头为That &#x2F; Whether(是否) 或者 主语 就是<strong>主语从句</strong>(<u>截止到第二个动词前</u>)</p>
<pre><code class="java">[That the little boy got the first prize] made his family relatives (so proud).
主(主从) + 谓 + 宾 + 宾补
==&gt; It made his family relatives so proud that the little boy got the first prize.
</code></pre>
<pre><code class="java">&#123;That people often experience trouble sleeping in a different bed in unfamiliar 
surroundings&#125; is a phenomenon (known as the &quot;first-night&quot; effect).
主&#123;主从&#125; + 系 + 表 + (后置定语)
That无成分，无含义，不能省
</code></pre>
<pre><code class="java">Whether such taxes work is a matter of debate.
主(主从) + 系 + 表
</code></pre>
<pre><code class="java">[How students ultimately handle stress] may depend on their personal 
test-taking abilities.
主(主从) + 谓 + 宾
</code></pre>
<h5 id="形式主语-若it不确定何种意思-就为形式主语-x3D-gt-寻找真正的主语"><a href="#形式主语-若it不确定何种意思-就为形式主语-x3D-gt-寻找真正的主语" class="headerlink" title="形式主语(若it不确定何种意思 就为形式主语 &#x3D;&gt; 寻找真正的主语)"></a>形式主语(若it不确定何种意思 就为形式主语 &#x3D;&gt; 寻找真正的主语)</h5><p>①后面的to do    ②后面的that</p>
<pre><code class="java">In today&#39;s job market, it&#39;s not uncommon for job seekers to submit 
applications for many positions.
It = to submit applications for many positions
</code></pre>
<pre><code class="java">[&#123;It&#39;s&#125; commonly known] that certain diseases are linked with occupations like
lung disease in coal miners.
</code></pre>
<p>常见的形式主语句型</p>
<pre><code class="java">It is surprising that... 令人惊讶的是...
It is obvious that... 显而易见的是...
It&#39;s said that... 据说...
It&#39;s reported that... 据报道...
It&#39;s commonly known that... 众所周知, ...
It is a fact that... 事实上是...
It is a common knowledge that ... 众所周知，...
It + be + 形容词 + that ...
It + be + 过去分词 + that ...
It + be + 名词 + that...
</code></pre>
<h3 id="宾语从句-及物动词后-or-介词后"><a href="#宾语从句-及物动词后-or-介词后" class="headerlink" title="宾语从句(及物动词后 or 介词后)"></a>宾语从句(及物动词后 or 介词后)</h3><p> 及物动词后的宾语从句(<strong>不及物动词</strong> + 介词 + 宾语)</p>
<p>介词后的宾语从句</p>
<pre><code class="java">我明白了 -&gt; 后面的一个字说不清 要一个句子()
I have learned [that love, not time, heals all wounds.]
heal：V.治愈    
wound：n.创伤，伤口
</code></pre>
<pre><code class="java">Therefore, &#123;it is vital that&#125; educators everywhere take a careful look not only at 
[what is being done], but also at [what should be done] in the field of computer 
education.
&#123;&#125;内的为 主从
[]内的为 宾从 现在进行时被动
</code></pre>
<h3 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h3><p><strong>系</strong>动词  后面的就是 表语从句 One is(是什么…)</p>
<pre><code class="java">There are tow worring features of the slowdown. One is [that it has been particularly sharp
in the world&#39;s most populous countries, India and China.]  
</code></pre>
<h3 id="同位语从句-用一句话来解释一个抽象名词"><a href="#同位语从句-用一句话来解释一个抽象名词" class="headerlink" title="同位语从句(用一句话来解释一个抽象名词)"></a>同位语从句(用一句话来解释一个抽象名词)</h3><p><strong>解释一个抽象名词，它是什么……</strong></p>
<p>同位语不是主干(主谓宾、主系表……) <u>[前面的名词n]和 [后面的名词n] 地位相同的时候</u></p>
<p>把和前面相同的名词变成一个<strong>句子</strong> &#x3D;&gt; 同位语从句</p>
<pre><code class="java">There is a popular saying that [family happiness spurs social stability.]
a saying = family happiness spurs social stability
</code></pre>
<p><strong>[n -&gt; 句子]</strong> 用一个句子代替名词：<strong>名词性从句</strong></p>
<p>在句子的<strong>主干</strong>中能**<u>代替名词</u><strong>的成分有：</strong>主语、宾语、表语、同位语**</p>
<hr>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><pre><code class="java">Whether the eyes are &quot;the windows of the soul&quot; is debatable; that they are
intensely important in interpersonal communication is a fact.
</code></pre>
<p>{<strong>Whether</strong> the eyes are “the windows of the soul” } is debatable;</p>
<p>{<strong>that</strong> they are intensely important in interpersonal communication} is a fact.  [主语从句] [they -&gt; eyes]</p>
<pre><code class="java">It is reported &#123;that 49 million Americans are unsure of [where they will
find their next meal.]&#125;
</code></pre>
<pre><code class="java">Dr.White said (that) his team wanted to see &#123;whether living in greener utban areas had
a lasting positive effect on people&#39;s sense of well-being&#125; or &#123;whether the effect
also disappeared after a period of time.&#125;
</code></pre>
<pre><code class="java">As a teacher who has worked in four countries, I have had the experience [that a student
who earns good marks is generally a good student],and [that a student&#39;s final mark in
a subject is usually a grade average of the year&#39;s work.]
两个定语从句 两个同位语从句
</code></pre>
<h3 id="定语从句-类似于形容词，其功能是划定一个范围"><a href="#定语从句-类似于形容词，其功能是划定一个范围" class="headerlink" title="定语从句(类似于形容词，其功能是划定一个范围)"></a>定语从句(类似于形容词，其功能是划定一个范围)</h3><p>规定一个范围 但是<u>用一个形容词搞不定</u> 所以成为了一句话 因此变成了从<strong>句</strong></p>
<p>用<u>一个形容词</u>作定语修饰名词或代词。</p>
<p>若要表达更复杂的意思，则需要借助<u>一个句子</u>来修饰名词</p>
<pre><code class="java">I don&#39;t like (lazy) people.
I don&#39;t like people (who don&#39;t love their own country.)
</code></pre>
<p><strong>定语从句：</strong><u>先行词 + 关系词 + 定语从句</u></p>
<p>I don’t like people (who don’t love their own country.)</p>
<ul>
<li>先行词：被修饰的名词、代词，总在定语从句前面 <u><strong>[people]</strong></u></li>
<li><strong>关系词</strong>：<span style = "color: red">(关系代词，关系副词)</span><u> <strong>连接</strong>主句和从句</u>，<u><strong>指代</strong>先行词</u>，<u>在定语从句中<strong>充当</strong>一定<strong>成分</strong>的词</u> <u><strong>[who 充当主语]</strong></u><ul>
<li>简要作用：(连接、指代、充当成分)</li>
</ul>
</li>
<li>定语从句：不完整的句子</li>
</ul>
<p><strong>先行词：</strong>一个<strong>词</strong>，<strong>短语</strong>，<strong>句子</strong></p>
<pre><code class="java">Another trend【that looks significant in 2015】is (that America&#39;s largest population
group, Millennials, will continue to put off buying a house.)
主 + 【v+...】 + v
【】定从    []宾从        
()表从     &#123;&#125;主从
</code></pre>
<pre><code class="java">And exercise releases hormones【that can improve mood and relieve stress】
,【which can also help learning.】
先行词：hormones
关系词：that，which（这）代替前面一整个句子【exercise ... stress】
</code></pre>
<p>关系代词：<strong>代</strong>词 &#x3D;&gt; 替代一个东西的词 (表中前三个)</p>
<p>关系副词：定语从句标识符 (表中后三个)    </p>
<ul>
<li><strong>时间名词</strong> + when</li>
<li><strong>地点名词</strong> + where;</li>
<li><strong>reason</strong> + why</li>
</ul>
<p>[介词 + 关系代词 &#x3D; 关系副词]</p>
<table>
<thead>
<tr>
<th align="center">先行词</th>
<th align="center">关系词</th>
<th align="center">充当从句成分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事 &#x2F; 物</td>
<td align="center">which &#x2F; that</td>
<td align="center">主语 &#x2F; 宾语</td>
</tr>
<tr>
<td align="center">人</td>
<td align="center">who &#x2F; whom &#x2F; that</td>
<td align="center">主语 &#x2F; 宾语</td>
</tr>
<tr>
<td align="center">人 &#x2F; 物 (所属关系)</td>
<td align="center">whose</td>
<td align="center">定语</td>
</tr>
<tr>
<td align="center">时间</td>
<td align="center">when</td>
<td align="center">状语</td>
</tr>
<tr>
<td align="center">地点</td>
<td align="center">where</td>
<td align="center">状语</td>
</tr>
<tr>
<td align="center">reason原因</td>
<td align="center">why</td>
<td align="center">状语</td>
</tr>
</tbody></table>
<h6 id="【】定从-宾从-表从-主从-lt-gt-同位语从句"><a href="#【】定从-宾从-表从-主从-lt-gt-同位语从句" class="headerlink" title="【】定从    []宾从    ()表从     {}主从     &lt;&gt;同位语从句"></a>【】定从    []宾从    ()表从     {}主从     &lt;&gt;同位语从句</h6><pre><code class="java">We found that[for some lottery winners]【who had won more than 500,000 prounds】
the positive effect was definitely there, but after six months to a year,
they were back to the baseline.
关系代词(who 代指前面的 winners)
</code></pre>
<pre><code class="java">定语从句-关系副词 when
Our schools need both the talent and the organization to educate each child
【who arrives at the school door.】Some show up ready, but many do not at
this critical time【when young brains are developing rapidly.】
At this critical time: 在这一关键时刻
When: 此时，在这时
</code></pre>
<pre><code class="java">定语从句-关系副词 where
Recently I attended several meetings【where we talked about ways to retain
students and keep younger faculty members from going elsewhere.
where：在这里，在...地方
retain：保持，保留，挽留
</code></pre>
<pre><code class="java">定语从句-关系副词 where
The center of American automobile innovation has in the past decade moved
2,000 miles away. It has migrated from Detroit to Silicon Valley,【where
self-driving vehicles are coming to life.】
has moved：现在完成时        in the past decade：时间状语
It：代指汽车研发中心          
</code></pre>
<pre><code class="java">定语从句-关系副词 why
This is the reason【why I was absent from that meeting.】
The reasons why【I recommend Beijing can be listed as follows...】
</code></pre>
<pre><code class="java">定语从句-介词 + 关系代词    
[先行词 + 介词 + which / whom]    modify: v.修改，改变
[介词 + 关系代词 = 关系副词]
Furthermore, humans have the ability to modify the environment(in which) 
they live.
Furthermore, humans have the ability to modify the environment where they live.
英语中通常不用介词收尾，常常把介词提到关系代词前。the environment which they live (in)
</code></pre>
<h4 id="限定性定语从句-与-非限定性定语从句"><a href="#限定性定语从句-与-非限定性定语从句" class="headerlink" title="限定性定语从句 与 非限定性定语从句"></a>限定性定语从句 与 非限定性定语从句</h4><p>区别在于表达方：</p>
<ul>
<li><p>如果想写 那一帮出租司机都绕路了 就用<strong>限定性定语从句</strong>(限定：<u>给它限定个范围</u>)</p>
</li>
<li><p>如果想写 所有出租车司机都绕路了 就用<strong>非限定性定语从句</strong>(不做限定)</p>
</li>
</ul>
<pre><code class="java">【限制性】：知道那里堵车的出租司机换了另一条路。
The cab drivers who knew about the traffic jam took another road.
</code></pre>
<pre><code class="java">The cab drivers，who knew about the traffic jam，took another road.
【非限定性】(非：不限定 ==&gt; 不让它范围有变化)(用逗号隔开)
The cab drivers took another road，who knew about the traffic jam.
出租司机都换了另一条路，出租车司机都知道那里堵车了。
</code></pre>
<pre><code class="java">【限定】：(有一帮女儿是老师，其他的不确定噢~)
She has tow daughters who are teachers.
她有两个(是老师的)女儿.[可能有其他女儿 只不过有两个做老师的女儿]
    
【非限定】：(隔开了就是不限定 没有限制范围 所有的女儿都是老师)
She has tow daughters，who are teachers.
她只有这两个女儿，这两个女儿都是老师
</code></pre>
<h4 id="限定性定语从句-与-同位语从句"><a href="#限定性定语从句-与-同位语从句" class="headerlink" title="限定性定语从句 与 同位语从句"></a>限定性定语从句 与 同位语从句</h4><p>定语从句会缩小范围 &#x3D;&gt; [不知道听到的新闻是什么…]</p>
<p>同位语从句是 一个<strong>句子</strong> 和 一个<strong>名词</strong> 进行对等 &#x3D;&gt; [知道新闻的内容：林肯被谋杀了]</p>
<pre><code class="java">定从：
The news【that you heard】is not true.
that: 指代news 做you heard的宾语
在定语从句中关系词that有含义、充当句子成分
</code></pre>
<pre><code class="java">同位语从句: 林肯在剧院遭到谋杀的新闻是真的
The news &lt;that Lincoln was murdered at a theater&gt; is true.
that: 不充当任何成分，去掉句子照常通顺(句子完整)
在同位语从句中that无含义，不充当句子成分
</code></pre>
<pre><code class="java">The fact &lt;that artisans,【who were looked on as mechanics or skilled
workers in the eighteenth century,】are frequently considered artists
today&gt; is directly attributable to the Arts and Crafts Movement of 
the nineteenth century.
be attributable to: 可归因于    artisan: n.工匠，技工    mechanic：n.机械师
The fact抽象名词 fact是主语 &lt;that为同位语从句 一直到&gt; 谓语
that同位语从句中有动词：,are   工匠经常在今天被认为是艺术家 ↓(这个事实的原因)    
who定语从句中有动词：were looked  (原因：就是十九世纪的那场运动)
所以The fact的动词就是在后面的 is
句子结构：主 &lt;that同位语从句：主【who非限定性定语从句：主谓宾】+谓+宾&gt; +系+表
★翻译原则★：剥洋葱一样从内往外一层一层的翻译
★ 在18世纪的时候工匠通常被人们认为是机械师或技术工人，而到了今天人们会认为工匠是艺术家，
这个事实最主要的原因是十九世纪的这场运动。
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#1bccbc>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/01/英语/基础语法/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/30/英语/刘晓艳作文—基础/">
        <h2>
            刘晓艳作文—基础
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="四级写作常考的题型："><a href="#四级写作常考的题型：" class="headerlink" title="四级写作常考的题型："></a>四级写作常考的题型：</h4><ul>
<li>论说文</li>
<li>书信</li>
<li>其他(新闻稿等)</li>
</ul>
<p><strong>时间：</strong>30分钟(3min审题与构思 + 20min + 2)</p>
<p><strong>字数：</strong>120~180words（12行-15行）</p>
<h1 id="具体要求："><a href="#具体要求：" class="headerlink" title="具体要求："></a>具体要求：</h1><ul>
<li><p>语言**<u>第一位</u><strong>！</strong>单词**：正确 多变     <strong>语法</strong>：正确 多变</p>
</li>
<li><p>结构**<u>第二位</u><strong>！</strong>结构<strong>：句子和句子之间一定要多用</strong>逻辑关系词**</p>
<ul>
<li><p><strong>表示因果</strong>(世界上最重要的一种关系就是因果关系)</p>
<ul>
<li><p>表示原因：</p>
<p>(<strong>because</strong>，<u>in that</u>，as，<u>since</u>) + 句子</p>
<p>(<strong>because of</strong> &#x3D; due to &#x3D; <strong>owing to</strong> &#x3D; thans to) + n&#x2F;ving</p>
</li>
<li><p>表示结果：</p>
<p>so &#x3D; hence &#x3D; <strong>therefore</strong> &#x3D; thereby &#x3D; thus &#x3D; <strong>consequently</strong></p>
<p>&#x3D; in consequence &#x3D; <strong>as a result</strong> &#x2F; consequence</p>
</li>
</ul>
</li>
<li><p><strong>表示对比</strong></p>
<ul>
<li><p>表示”相似性的”对比</p>
<p>likewise &#x3D; similarly &#x3D; <strong>equally</strong> &#x3D; simultaneously </p>
<p>&#x3D; <strong>at the same time</strong> &#x3D; in the meanwhile</p>
</li>
<li><p>表示”差异性的”对比 (但是)</p>
<p>but，by contrast &#x3D; conversely &#x3D; alternatively</p>
<p>&#x3D; <strong>on the contrary</strong> &#x3D; on the other hand &#x3D; otherwise</p>
<p>&#x3D; while &#x3D; whereas</p>
</li>
</ul>
</li>
<li><p><strong>表示递进</strong></p>
<p>​        <strong>besides</strong> &#x3D; also &#x3D; <strong>in addition</strong> &#x3D; moreover &#x3D; furthermore </p>
<p>​        &#x3D; apart &#x2F; aside from this</p>
</li>
<li><p><strong>表示让步</strong> (虽然尽管)</p>
<ul>
<li><p>[ (<strong>Desipite</strong>(介) &#x3D; <strong>in spite of</strong> ) + n &#x2F; ving ] &#x3D; not withstanding &#x3D; although</p>
<p>&#x3D; though &#x3D; as &#x3D; while &#x3D; even (if) &#x3D; much as(用于句首)</p>
<p>&#x3D; granting &#x2F; granted that</p>
</li>
<li><p>Undoubtedly &#x3D; <strong>there is no doubt that…</strong> 毫无疑问的是…</p>
</li>
<li><p>it may be true that… 或许真实的是…</p>
</li>
<li><p><strong>there is no denying that…</strong> 不可否认的是</p>
</li>
</ul>
</li>
<li><p><strong>表示引出新对象</strong></p>
<ul>
<li><p>about &#x3D; concerning &#x3D; regarding &#x3D; with regard to</p>
<p>&#x3D; as for &#x2F; to &#x3D; in respect of 关于</p>
</li>
<li><p>in terms of 就…而论，在…方面</p>
</li>
<li><p>when it comes to …当提到…时</p>
</li>
</ul>
</li>
<li><p><strong>表示总结</strong></p>
<ul>
<li><p>on the whole &#x3D; all in all &#x3D; overall &#x3D; <strong>in conclusion</strong> &#x2F; summary &#x2F; <strong>general</strong></p>
<p>&#x3D; <strong>generally</strong>(speaking) &#x3D; as a whole &#x3D; mainly &#x3D; substantially &#x3D; to sum up</p>
<p>&#x3D; conclude &#x3D; come to the conclusion 总的来说</p>
<p>&#x3D; in short &#x2F; brief &#x3D; <strong>in a word</strong> 简而言之</p>
</li>
</ul>
</li>
<li><p><strong>表示举例</strong></p>
<ul>
<li><p><strong>such as</strong> &#x3D; <strong>for</strong> instance &#x2F; <strong>example</strong> &#x3D; a good case in point &#x3D; to illustrate</p>
<p>&#x3D; as an illustration</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内容**<u>第三位</u>**：(不重要 只是用来凑字数)</p>
</li>
</ul>
<h4 id="句子的类型"><a href="#句子的类型" class="headerlink" title="句子的类型"></a>句子的类型</h4><p><span style = "color: red"><strong>被动</strong>、<strong>There be</strong>、<strong>It结构</strong>(头重脚轻+强调句)、<strong>复合句</strong>(同位语+同位语从句，定语+定语从句，状语+状语从句)、<strong>虚拟语气</strong>(if+it is necessary)、<strong>倒装</strong>(so…that+only-状语)</span></p>
<ul>
<li><p>结构上分为：简单句 并列句 复合句(名词性从句，定语从句，状语从句)</p>
</li>
<li><p>语序上分为：倒装和正常语序</p>
</li>
<li><p>语态上分为：主动和被动</p>
</li>
</ul>
<h1 id="被动结构"><a href="#被动结构" class="headerlink" title="被动结构"></a>被动结构</h1><h4 id="一句话中只能有一个做谓语，其他的多余动词要做非谓语"><a href="#一句话中只能有一个做谓语，其他的多余动词要做非谓语" class="headerlink" title="(一句话中只能有一个做谓语，其他的多余动词要做非谓语)"></a>(一句话中只能有一个做谓语，其他的多余动词要做非谓语)</h4><p><u>一句话上来先找主谓(定语态 定时态)</u> 剩下的东西以状语形式出现</p>
<p><span style = "color:red"><strong>当一句话需要动词却没有动词，可以永远加Be</strong></span></p>
<ul>
<li>前面在修路：The road is being built in front.</li>
<li>全球在变暖：It is becoming warm throughout the world</li>
<li>狗没有找到：The dog wasn’t found</li>
<li>北京西站就要到了：We are arriving at BJ station</li>
<li>他看着我，笑着离开了：He <strong>saw</strong> me，smiling and leaving</li>
<li>有很多人喜欢冬泳：There <strong>are</strong> a host of children and adults liking to swim in winter</li>
<li>有意义就是好好活：Being meaningful is to live well</li>
</ul>
<h1 id="There-be句型"><a href="#There-be句型" class="headerlink" title="There be句型"></a>There be句型</h1><p>当一句话没有主语，并且<u>谓语动词</u>是<strong>“有”</strong>的时候就可以考虑写成 There be 句型</p>
<pre><code class="java">目前关于孩子和父母的关系问题有一个激烈的讨论
There is a hot debate about the topic on the relationship between
parenys and therir chilidren.
</code></pre>
<pre><code class="java">毫无疑问线上词典在大学生中越来越受欢迎
There is no denying that online dictionaries are becoming increasingly popular with college students.
</code></pre>
<pre><code class="java">有两个原因可以解释我的观点
There are tow arguments to account for my perspective
account 不算是谓语 因为前面有介词 变成了动词不定式
</code></pre>
<blockquote>
<p>[语法详解：There be句型的使用规则(含练习题及答案） - 知乎 (zhihu.com)](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147350559#:~:text=%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9AThere">https://zhuanlan.zhihu.com/p/147350559#:~:text=语法详解：There</a> be句型的使用规则 (含练习题及答案） 1 1.There is%2B单数可数名词%2F不可数名词%2B其他 如：There is,some students on the playground. … 5 5.Therebe句型的一般疑问句)</p>
</blockquote>
<h1 id="it结构"><a href="#it结构" class="headerlink" title="it结构"></a>it结构</h1><h5 id="【】定从-宾从-表从-主从"><a href="#【】定从-宾从-表从-主从" class="headerlink" title="【】定从    []宾从  ()表从  {}主从"></a>【】定从    []宾从  ()表从  {}主从</h5><ul>
<li><p>避免头重脚轻</p>
<p><strong>动名词充当主语</strong>可以放句首</p>
<p><strong>不定式充当主语</strong>可以放在句末</p>
<ul>
<li><p>当<strong>动词不定式</strong>充当主语的时候：把动词不定式放在句末去，加it来做形式主语</p>
<pre><code class="java">打你是我的错
Beating you is my fault.
It is my fault to beat you.
</code></pre>
</li>
</ul>
<pre><code class="java">帮助更多的同学建立自信是我们这次活动的目的(主系表)
【Helping more students build confidence】is our purpose of this activity.
Our purpose of this activity is to h elp more students build confidencce.
</code></pre>
</li>
<li><p>主语从句</p>
<p><u>显而易见，众所周知：</u>可以写<strong>开头、中间、结尾</strong>(可以写在任何一个句子前面)</p>
<p>(推荐第一段 以及 第二段前方)</p>
<p>观点看法：perspective、outlook、standpoint</p>
<ul>
<li>It is common knowledge that… 显而易见,众所周知</li>
<li>It is my belief that… &#x3D; I think that… <strong>我认为</strong></li>
<li>It is self-evident that… 显而易见,众所周知</li>
<li>It has been found that… 显而易见,众所周知</li>
<li>It is beyond dispute that… 显而易见,众所周知</li>
<li>It is universally acknowledged that… 显而易见,众所周知</li>
<li>It has been widely accepted that… 显而易见,众所周知</li>
<li>It is generally agreed that… 显而易见,众所周知</li>
</ul>
<pre><code class="java">①大学教育极大地促进了社会的进步是显而易见的
It is beyond dispute that university education promotes the progress of our society obviously.

②我认为养宠物这个话题现在应该引起人们的关注了
It is my perspective that the issue about raising pets should be brought into the limelight under
modern conditions.
</code></pre>
</li>
<li><p><span style = "color: red">强调句型</span>(<strong>谓语</strong>不能强调，其余可以强调)</p>
<p>it is…that…</p>
<pre><code class="java">③也是在明代，由郑和率领的船队曾到印度洋进行了七次大规模探险航行
it is also in the Ming Dynasy that the ships led by ZhengHe went to the Ocean
④随着时间的推移，丝绸之路逐渐变成了一条连接东西方的主要道路，促进了东西方的经济文化交流
As time went by, it is the Silk Road that gradually became a major road
connecting the East and the West, promoting economic and cultural exchanges
between the two parties.
</code></pre>
</li>
</ul>
<h1 id="复合句"><a href="#复合句" class="headerlink" title="复合句"></a>复合句</h1><h5 id="同位语的使用：解释名词的成分-这辈子只能出现在名词后面"><a href="#同位语的使用：解释名词的成分-这辈子只能出现在名词后面" class="headerlink" title="同位语的使用：解释名词的成分(这辈子只能出现在名词后面)"></a><span style = "color: red">同位语</span>的使用：解释名词的成分(这辈子只能出现在名词后面)</h5><p>名词做同位语就是(在<u>名词后</u> <u>再加一个名词</u>来<strong>解释前面那个名词</strong>)</p>
<p>只要在作文中见到名词，都可以在他后面再加一个名词作为它的同位语出现</p>
<pre><code class="java">Hunting for jobs,&lt;a hot topic among undergraduates,&gt; has become the public concern recently.
Optimism, a positive attitude, plays a key role in the general routine of everyday living.
</code></pre>
<pre><code class="java">他已经找到了女朋友这件事情 使家人很开心
简单：The matter makes his families rejoiced.
复杂：The matter that he has found a girlfriend makes his families rejoiced.
</code></pre>
<p>名词 + that + … + suggest that + …</p>
<p><span style = "color: red">The fact that … suggest that …</span>【第二段分析原因时使用】</p>
<pre><code class="java">在大城市生活会增加每天通勤的成本这个事实表明，你在大城市生活会更容易疲倦
The fact that it will increase the cost of your daily commute suggests that
you tend to get tired more easily in big cities.
</code></pre>
<pre><code class="java">当地人非常的好客热情这个事实表明，你会爱上这座城市，不愿意离开的
The fact that the locals are very hospitable and friendly shows that you will love this city,
unwilling to leave there.
(因为一句话已有一个动词存在love 所以unwill要变成非谓语)
</code></pre>
<h4 id="定语和定语从句"><a href="#定语和定语从句" class="headerlink" title="定语和定语从句"></a>定语和定语从句</h4><p>只要在作文中见到<strong>名词</strong>，都可以有意识的在作文中加入<strong>定语</strong>的成分</p>
<p><strong>介、短、定从、非谓语、名词</strong> &#x3D;&gt; 可修饰名词</p>
<ul>
<li><ul>
<li><ul>
<li><strong>先找主谓宾，再加定状补！！！</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">I love the girl singing on the stage
I love the girl who is singing on the stage
I love the girl in front of me (介词短语修饰名词)
I love the mother of that girl (名词修饰名词)
I love the girl of kindness (名词修饰名词)
I love the girl being as kind as an angel (非谓语修饰名词)
I love the girl who keeps so kind (定语从句修饰名词)
</code></pre>
<ul>
<li><u>我们</u>应该<u>尊重</u>那些<strong>正在为梦想奋斗</strong>的<u>穷孩子</u></li>
</ul>
<pre><code class="java">We should respect poor children who are struggling for their dreams.(主从)
We should respect poor children struggling for their dreams. (非谓语)
</code></pre>
<ul>
<li>被上帝抛弃的那个<u>男人</u><strong>最终</strong><u>死去了</u> (at last时间状语比较灵活)</li>
</ul>
<pre><code class="java">The man who was abandoned by God died at last. (过去分词做定语) 
</code></pre>
<ul>
<li>那个老人在他儿子到达的那天去世了(只有在缺少成分的时候才用that)</li>
</ul>
<p><strong><span style = "color: red">(此句子用when 因为句子不充当成分)</span></strong></p>
<pre><code class="java">The old man died on the day when his son arrived
</code></pre>
<ul>
<li>在舞台上唱歌的<u>那个女孩子</u><u><strong>是</strong></u>大雁的<u>女儿</u></li>
</ul>
<pre><code class="java">The girl singing on the stage is the daughter of DaYan.
</code></pre>
<ul>
<li>这是一个关于月亮和六便士的故事(专有名词前面加the )(介词短语修饰名词)</li>
</ul>
<pre><code class="java">This is a fiction about the moon and six pence.
</code></pre>
<ul>
<li>龙井是一种绿茶，主要产自中国东部沿海的浙江省(which可用于指代前面的名词)</li>
</ul>
<pre><code class="java">Longjing is a type of green tea which is mainly produced in
zhejiang Province, the coastal area in east China. 
Longjing is a type of green tea which come from zhejiang 
Province, near the sea.
</code></pre>
<ul>
<li>乌镇是浙江的一座古老水镇，坐落在京杭大运河畔</li>
</ul>
<pre><code class="java">Wuzhen，which is an ancient water town in Zhejiang province, is located by
the beijing-Hangzhou Grand Canal.
    
Wuzhen is an ancient water town in Zhejiang province, which is located by
the beijing-Hangzhou Grand Canal.
</code></pre>
<ul>
<li>功夫是中国武术的俗称。中国武术的起源可以追溯到自卫的需要、狩猎活动以及古代中国的军事训练。它是中国传统体育运动的一种，年轻人老年人都练。</li>
</ul>
<pre><code class="java">Kung Fu is the common name of chinese train which come from protect oneself needs, 
hungting animals and army training in ancient China. Besides, it is a traditional
Chinese sport that both the young and the elderly can practise.
</code></pre>
<ul>
<li>剪纸是中国最流行的传统民间艺术形式之一，中国剪纸有一千五百多年的历史，在明朝和清朝时期特别流行</li>
</ul>
<pre><code class="java">Paeper cutting is one of the most popular arts in china which has a 1500-year history and was quite famous in the Ming and Qing dynasties.
</code></pre>
<ul>
<li>中国人自古以来就在中秋节庆祝丰收，这与北美庆祝感恩节非常相似</li>
</ul>
<pre><code class="java">Chinese have had the tradition to celebrate harvesrt in the Middle-Autumn Festival, 
which proves quite similar to Thanks giving Day in north America.
</code></pre>
<h3 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h3><p>只要确定不是主谓宾，只要没有跟在名词后做<strong>定语</strong>或<strong>同位语</strong></p>
<p>作文中任何一个地方都可以加状语从句</p>
<p>成分：(<strong>介、短、定从、非谓语、名词</strong> )</p>
<p><span style = "color: red"><strong>主 谓 宾 表</strong></span></p>
<p><span style = "color: red"><strong>同位语</strong><u>解释</u>名词 <strong>定语</strong><u>修饰</u>名词 <strong>状语</strong><u>修饰</u>除名词以外的所有成分</span></p>
<ul>
<li>什么是状语：除了名词不能修饰 其余什么都可以修饰</li>
</ul>
<p>He looks <u>extremely</u> handsome (形容词做状语)</p>
<p>At last, succeeded <u>at a highcost</u>(介词短语做状语)</p>
<ul>
<li><p>状语的成分：1. <strong>adv</strong>  2. <strong>介词短语</strong>  3.<strong>非谓语动词</strong>  4.<strong>从句</strong></p>
</li>
<li><p>状语的使用：</p>
<ul>
<li><strong>时间</strong>状语</li>
<li><strong>地点</strong>状语</li>
<li><strong>原因</strong>状语</li>
<li><strong>目的</strong>状语(目的是…，为了…)</li>
<li><strong>条件</strong>状语(如果…)</li>
<li><strong>结果</strong>状语(so…that，如此…以至于)</li>
<li><strong>方式</strong>状语(by、through，通过……)</li>
<li><strong>让步</strong>状语(althrough，虽然…尽管)</li>
<li><strong>伴随</strong>状语(with)</li>
<li><strong>比较</strong>状语(as…as，than…)</li>
<li><strong>副词</strong></li>
</ul>
</li>
</ul>
<pre><code class="java">I love my girlfriend...
原因状语：I love my girlfriend without any reasons
目的：I love my girlfriend in order to marry her
</code></pre>
<h3 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h3><p>表示与<strong>事实相反</strong>，或者<strong>语气委婉</strong>  </p>
<p><span style = "color: red">在第二段原因处可使用</span></p>
<p>If引导的条件状语从句(主将从现)</p>
<p><u>如何把一个正常条件状语从句变成一个虚拟语气？</u></p>
<p><strong>只需要把已经写好的句子的时态，变成它的过去式</strong></p>
<ul>
<li>过去的过去 &#x3D;&gt; 过去完成时</li>
</ul>
<pre><code class="java">If you are a tear in my eye, I will never shed it.
If you were a tear in my eye, I would never shed it.
    
If I was a dog last night, I could sleep in bed with you.
If I had been a dog last night, I could have slept in bed with you.
</code></pre>
<p><u><strong>一般过去时</strong></u>(跟<strong>点</strong>时) 和 <u><strong>现在完成时</strong></u>(一段时间 &#x3D;&gt; 我在河北已经10年了),</p>
<p>在虚拟语气中be的过去式只有were；could &#x3D; would &#x3D; might</p>
<pre><code class="java">如果她能嫁给一个有钱人，她的母亲可能会善待她吧
If she married a rich man her mother could treat her well.
If she had married a rich man he mother could have treated her well.
</code></pre>
<pre><code class="java">如果你花更多的时间在阅读上，你就能更开阔自己的视野
If you spent more time reading, you would broaden your horizons more.
</code></pre>
<ul>
<li>…很重要…很必要  <u>It is necessary &#x2F; important that</u> 【从句用**(should + 动词原形)** 表示虚拟】</li>
</ul>
<p><span style = "color: red">在第三段措施处可使用</span></p>
<pre><code class="java">大学生多参加活动尽快地融入到新环境中是非常必要的
It is necessary that college students should take part in more activities and
integrate into the new environment as soon as possible.
</code></pre>
<ul>
<li>是…的时候了</li>
</ul>
<p><span style = "color: red">在第三段第一句 、最后一句可使用(喊口号)</span></p>
<p>It is high time that…(从句用过去式表示虚拟)</p>
<pre><code class="java">是我们关注这个问题的时候了
It is high time that we put emphasis on th issue.
</code></pre>
<h3 id="倒装"><a href="#倒装" class="headerlink" title="倒装"></a>倒装</h3><p>就是把一句话写成一般疑问句的形式，给一句话提个<strong>be动词</strong>或<strong>助动词</strong>放在句首</p>
<p>倒装的具体用法: (前面倒装 后面不动)</p>
<ul>
<li>so…that… 结构的句子将so引导的部分置于句首时用倒装，如此…以至于</li>
</ul>
<p>作文中出现 <strong><u>形容词&#x2F;副词</u></strong> 的地方 都可以写成so…that句型，所有的 <strong><u>形容词&#x2F;副词</u></strong> 都可以倒装</p>
<pre><code class="java">He was so excited that he cannot help laughing at midnight.
-&gt; So excited was he that he cannnot help laughing at midnight.
</code></pre>
<pre><code class="java">She looks so gorgeous that she can catch the eyes of everyone.
So gorgeous does she look that she can catch the eyes of everyone.
</code></pre>
<pre><code class="java">DaYan runs so quickly that crazy dogs fail to catch up with her.
So quickly does DaYan run that crazy dogs fail to catch up with her.
</code></pre>
<ul>
<li>“only + 状语” 位于句首时用倒装</li>
</ul>
<pre><code class="java">His girlfriend called his name only once.
Only once did his girlfriend call his name.
</code></pre>
<pre><code class="java">My dearest Tom always lives only in my deep heart.
Only in my deep heart does my dearest Tom always live.
</code></pre>
<pre><code class="java">The problem could be resolved only in this way.
Only in this way could the problem be resolved.
</code></pre>
<h3 id="句子的扩写"><a href="#句子的扩写" class="headerlink" title="句子的扩写"></a>句子的扩写</h3><h4 id="同-定-加在名词后）-状语均可"><a href="#同-定-加在名词后）-状语均可" class="headerlink" title="([同 + 定]加在名词后）(状语均可)"></a>([同 + 定]加在名词后）(状语均可)</h4><pre><code class="java">I love Dayan
I, (a university student from the department of Physical education) love
dayan (who is the most graceful and elegant teacher I have ever seen.)
</code></pre>
<pre><code class="java">Violent video games will make children violent.
Violent video games (which are popular online everywhere) will make children
violent (in their daily life beacause they tend to imitate these negative behaviors.)
</code></pre>
<pre><code class="java">Pollution keeps exceedingly serious.
Pollution, (a global issue), keeps exceedingly serious (with the rapid urbanization 
and development of technology.)
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#1bccbc>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/04/30/英语/刘晓艳作文—基础/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/30/后端/Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装/">
        <h2>
            Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java日期时间"><a href="#Java日期时间" class="headerlink" title="Java日期时间"></a>Java日期时间</h1><h4 id="java-uti包提供了Date类来封装当前的日期和时间"><a href="#java-uti包提供了Date类来封装当前的日期和时间" class="headerlink" title="java.uti包提供了Date类来封装当前的日期和时间"></a>java.uti包提供了Date类来封装当前的日期和时间</h4><pre><code class="java">Data() 构造函数使用当前日期和时间来初始化对象
Data(long millisec) 构造函数接收一个参数从1970年1月1日起的毫秒数
</code></pre>
<h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><pre><code class="java">import java.util.Date;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        //初始化Date对象
        Date date = new Date();
        //使用toString()函数显示日期时间
        sout(data.toString());
    &#125;
&#125;
运行结果：
Mon May 04 09:51:52 CDT 2013
</code></pre>
<h4 id="使用SimpleDateFormat格式化时间"><a href="#使用SimpleDateFormat格式化时间" class="headerlink" title="使用SimpleDateFormat格式化时间"></a>使用SimpleDateFormat格式化时间</h4><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。允许你选择任何用户自定义日期时间格式来运行</p>
<pre><code class="java">import java.util.*;
import java.test.*;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        Date dNow = new Date();                     //DateFormat格式化编码
        SimpleDateFormat ft = new SimpleDateFormat(&quot;E yyyy.MM.dd &#39;at&#39; hh:mm:ss a zzz&quot;);
        sout(&quot;Current Date: &quot; + ft.format(dNow));
    &#125;
&#125;
运行结果：
Current Date: Sun 2004.07.18 at 04:14:09 PM PDT
</code></pre>
<h4 id="Java休眠-sleep"><a href="#Java休眠-sleep" class="headerlink" title="Java休眠(sleep)"></a>Java休眠(sleep)</h4><p>下面的程序会休眠3秒</p>
<pre><code class="java">import java.util.*;
public static void main(String args[])&#123;
    try&#123;
        sout(new Date() + &quot;\n&quot;);
        Thread.sleep(5*60*10); //1秒 = 1000毫秒
        sout(new Date() + &quot;\n&quot;);
    &#125; catch(Exception e)&#123;
        sout(&quot;Got an exception!&quot;);
    &#125;
   &#125;
&#125;
</code></pre>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程只需要使用getInstance方法创建即可</p>
<p>创建一个代表系统当前日期的Calendar对象</p>
<ul>
<li><strong>Get设置</strong></li>
</ul>
<pre><code class="java">//获得年份
int year = c1.get(Calendar.YEAR);
</code></pre>
<ul>
<li><strong>Set设置</strong></li>
</ul>
<pre><code class="java">Calendar c1 = Calendar.getInstance(); //默认是当前日期
public void set(int field, int value)
c1.set(Calendar.DATE, 10);
c1.set(Calendar.YEAR, 2008);
</code></pre>
<ul>
<li><strong>Add设置</strong></li>
</ul>
<p>把c1对象的日期加上10，也就是c1所表的日期的10天后的日期，其他所有的数值都会被重新计算</p>
<pre><code class="java">c1.add(Calendar.DATE, 10);
</code></pre>
<ul>
<li><h5 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h5></li>
</ul>
<p>Calendar类实现了公历日历，GregorianCalenda是Calendar类的一个具体实现</p>
<pre><code class="java">import java.util.*;
public class GregorianCalendarDemo&#123;
    public static void main(String args[])&#123;
        String months[] = &#123;&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;&#125;;
        int year;
        //初始化Gregorian日历
        //使用当前时间和日期
        //默认为本地时间和时区
        GergorianCalendar gcalendar = new GergorianCalendar();
        //显示当前时间和日期的信息 sout 为 print 不是 println
        sout(&quot;Date: &quot;);
        sout(&quot;months[gcalendar.get(Calendar.MONTH)]&quot;);
        sout(&quot; &quot; + gcalendar.get(Calendar.DATE) + &quot; &quot;);
        sout(year = gcalendar.get(Calendar.YEAR));
        sout(&quot;Time: &quot;);
        sout(gcalendar.get(Calendar.HOUR) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.MINUTE) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.SECOND));
        //测试当前年份是否为闰年
        if(gcalendar.isLeapYeay(year))&#123;
            sout(&quot;当前年份是闰年&quot;);
        &#125;
        else &#123;
            sout(&quot;当前年份不是闰年&quot;);
          &#125;
    &#125;
&#125;
运行结果：
Date: Apr 22 2009
Time: 11:25:27
当前年份不是闰年
</code></pre>
<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>System.out.println()</p>
<p>println()是一个方法(Method)，而System是系统类(Class)，out是标准输出对象(Object)</p>
<p>这句话的用法是调用系统类System中的标准输出对象out中的方法println()</p>
<h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><pre><code class="java">修饰符 返回值类型 方法名 (参数类型 参数名)&#123;
    ...
    方法体
    ...
    return 返回值:
&#125;
</code></pre>
<ul>
<li>修饰符：是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型</li>
<li>返回值类型：方法可能会返回值。returnValueType是关键字void</li>
<li>方法名：是方法的实际名称</li>
<li>参数类型：当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数</li>
<li>方法体：方法体包括具体的语句，定义该方法的功能</li>
</ul>
<p>void方法的调用一定是一个语句，没有返回值，像任何以分号结束的语句一样</p>
<h4 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h4><p>连续n次打印一个消息：</p>
<pre><code class="java">public static void nPrintln(String message, int n)&#123;
    for(int i = 0; i &lt; n; i++)
        sout(message);
&#125;
</code></pre>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>一个类的两个方法拥有相同的名字，但是有不同的参数列表</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其他必要的步骤来创建一个完整的对象</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它会把所有成员初始化为0</p>
<pre><code class="java">//一个简单的构造函数
static class Myclass&#123;
    int x;
    //以下是构造函数
    MyClass(int i)&#123;
        x = i;
    &#125;
&#125;
//调用构造方法来初始化一个对象
public class ConsDemo&#123;
    public static void main(String args[])&#123;
        MyClass t1 = new MyClass(10);
        MyClass t2 = new MyClass(20);
        sout(t1.x + &quot; &quot; + t2.x);
    &#125;
&#125;
运行结果：
10 20
</code></pre>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>Java支持传递同类型的可变参数给一个方法</p>
<pre><code class="java">typeName...parameterName
</code></pre>
<p>在方法声明中，在指定参数类型后加一个省略号(…)</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的<strong>最后一个参数</strong>，任何普通的参数必须在它之前声明</p>
<pre><code class="java">public calss VarageDemo&#123;
    public static void main(String args[])&#123;
        //调用可变参数的方法
        printMax&#123;34,3,3,2,56.5&#125;;
        printMax(new double[]&#123;1,2,3&#125;);
    &#125;
    
    public static void printMax(double...numbers)&#123;
        if(numbers.length == 0)&#123;
            sout(&quot;No argument passed&quot;);
            return;
        &#125;
        double result = numbers[0];
        for(int i = 1; i &lt; number.length; i++)
            if(number[i] &gt; result)&#123;
                result = numbers[i];
            &#125;
        sout(&quot;The max value is &quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Java流-Stream-、文件-File-和-IO"><a href="#Java流-Stream-、文件-File-和-IO" class="headerlink" title="Java流(Stream)、文件(File) 和 IO"></a>Java流(Stream)、文件(File) 和 IO</h1><p>Java.io包几乎包括了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标</p>
<p>一个流可以理解为一个数据的序列、<strong>输入流</strong>表示<u>一个源读取数据</u>，<strong>输出流</strong>表示<u>一个目标写数据</u>。</p>
<h5 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h5><p>Java的控制台输入由System.in完成</p>
<p>为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个BufferedReader对象中创建一个字符流</p>
<pre><code class="java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</code></pre>
<p>BufferedReader对象创建后，我们可以使用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串</p>
<h5 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h5><p>从BufferedReader对象读取一个字符要使用**read()**方法</p>
<p>从BufferedReader对象读取一个字符串要使用**readLine()**方法</p>
<pre><code class="java">int read() throws IOException
</code></pre>
<p>每次调用read()方法，它从输入流读取<strong>一个字符</strong>并把该字符作为整数值返回。当流结束的时候返回-1。该方法抛出IOException</p>
<p>下面的程序用read()方法从控制台不断读取字符知道用户输入”q”</p>
<pre><code class="java">//使用BufferedReader 在控制台读取字符
import java.io.*;
public class BRRead&#123;
    public static void main(String args[]) throws IOException&#123;
        char c;
        //使用System.in创建BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        sout(&quot;输入字符，按下&#39;q&#39;键退出.&quot;);
        //读取字符
        do&#123;
            c = (char) br.read();
          //c = br.readLine();
            sout(c);
        &#125; while(c != &#39;q&#39;);
    &#125;
&#125;

运行结果：
输入字符，按下&#39;q&#39;键退出.
123abcq
1
2
3
a
b
c
q
</code></pre>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>该流用于从文件<strong>读取数据</strong>，它的对象可以用关键字new来创建，有多重构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<pre><code class="java">InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输入流对象来<strong>读取文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
InputStream f = new FileInputStream(f);
</code></pre>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>该类用来创建一个文件并向文件中<strong>写数据</strong></p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件</p>
<p>有两个构造方法可以用来创建FileOutputStream对象</p>
<p>使用字符串类型的文件名来创建一个输出流对象</p>
<pre><code class="java">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输出流来<strong>写文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
OutputStream f = new FileOutputStream(f);
</code></pre>
<h5 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h5><h5 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h5><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li>**mkdir()**方法创建一个文件夹，成功则返回true，失败则返回false，失败表明File对象指定的路径已经存在，或者由于整个路径害不存在，该文件夹不能被创建</li>
<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹</li>
</ul>
<h1 id="Java-Scanner类"><a href="#Java-Scanner类" class="headerlink" title="Java Scanner类"></a>Java Scanner类</h1><p>Scanner对象的基本语法：</p>
<pre><code class="java">Scanner s = new Scanner(System.in);
</code></pre>
<p>通过Scanner类的<strong>next()</strong> 与 **nextLine()**方法获取输入的字符串</p>
<p>在读取前我们需要使用 <strong>hasNext</strong> 与 <strong>hasNextLine</strong> 判断是否还有输入数据。</p>
<p><strong>使用next方法：</strong></p>
<pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;next方式接收：&quot;);
        //判断是否还有输入
        if(scan.hasNext())&#123;
            String str1 = scan.next();
            sout(&quot;输入的数据为: &quot; + str1);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj
</code></pre>
<h5 id="使用nextLine方法："><a href="#使用nextLine方法：" class="headerlink" title="使用nextLine方法："></a>使用nextLine方法：</h5><pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String[] args)&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;nextLine方式接收: &quot;);
      //判断是否还有输入
        if(scan.hasNextLine())&#123;
            String str2 = scan.nextLine();
            sout(&quot;输入的数据为: &quot; + str2);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj com
</code></pre>
<h5 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h5><p><u>next():</u></p>
<ul>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next()方法胡自动将其去掉</li>
<li>只有输入有效字符才能将其后面输入的空白作为分隔符或结束符</li>
<li>next()不能得到带有空格的字符串</li>
</ul>
<p><u>nextLine()：</u></p>
<ul>
<li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白</li>
</ul>
<p>如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用hasNextXxx() 方法进行验证，再使用 nextXxx()来读取：</p>
<pre><code class="java">import java.util.Scanner;
public calss ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        int i = 0;
        float f = 0.0f;
        sout(&quot;输入整数： &quot;);
        if(scan.hasNextInt())&#123;
            //判断输入的是否是整数
            i = scan.nextInt();
            sout(&quot;整数数据: &quot; + i);
        &#125; else&#123;
            sout(&quot;输入的不是整数！&quot;);
        &#125;
        sout(&quot;输入小数: &quot;);
        if(scan.hasNextFloat())&#123;
            //判断输入的是否是小数
            f = scan.nextFloat();
            sout(&quot;小数数据: &quot; + f);
        &#125; else&#123;
            sout(&quot;输入的不是小数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h5 id="捕获异常-try-x2F-catch"><a href="#捕获异常-try-x2F-catch" class="headerlink" title="捕获异常 try&#x2F;catch"></a>捕获异常 try&#x2F;catch</h5><p>使用 try 和 catch关键字可以捕获异常，try&#x2F;catch 代码块中的代码成为保护代码</p>
<pre><code class="java">try&#123;
    //见识代码执行过程，一旦发现异常则直接跳转至catch，
    //如果没有异常则直接跳转至finally
&#125; catch (ExceptionName e1)&#123;
    //Catch快 可选执行的代码块，如果没有任何异常发生不会执行
    //如果发现异常则进行处理或向上抛出
&#125; finally&#123;
    //必选执行的代码块，不管是否有异常发生
    //及时发生内存溢出异常也会执行，通常用于处理善后清理工作
&#125;
</code></pre>
<h5 id="throws-x2F-throw关键字"><a href="#throws-x2F-throw关键字" class="headerlink" title="throws&#x2F;throw关键字"></a>throws&#x2F;throw关键字</h5><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用throws关键字来声明</p>
<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开</p>
<pre><code class="java">import java.io.*;
public class className&#123;
    public void withdraw(double amount) throws RemoteException, InsufficientFundsException&#123;
        //...
    &#125;
&#125;
</code></pre>
<h5 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h5><p>用来创建在try代码块后面执行的最后一个 代码块，无论是否发生异常，finally代码块中的代码总会被执行</p>
<h5 id="小综合"><a href="#小综合" class="headerlink" title="小综合"></a>小综合</h5><pre><code class="java">public class ExcepTest&#123;
    public static void main(String args[])&#123;
        int a[] = new int[2];
        try&#123;
            sout(&quot;Access element three :&quot; + a[3]);
        &#125; catch(ArrayIndexOutOfBoundsException e)&#123;
            sout(&quot;Exception thrown :&quot; + e);
        &#125; finally&#123;
            a[0] = 6;
            sout(&quot;First element value: &quot; + a[0]);
            sout(&quot;The finally statement is executed&quot;);
        &#125;
    &#125;
&#125;
运行结果：
Exception thrown :java.l
</code></pre>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><p>如果类A是类B的父亲，而类B是类C的父亲，我们也称类C是A的子类，类C是从类A继承而来的，在Java中，类的继承是单一继承，一个子类只能拥有一个父类。</p>
<p>继承中最常使用的两个关键词是<strong>extends</strong>和<strong>implements</strong></p>
<p>这两个关键字的使用决定了一个对象和另一个对象是否是一个关系，我们能实现一个对象获取另一个对象的属性</p>
<p>所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，而除了Object外，所有类必须有一个父类。</p>
<p>通过<strong>extends关键字</strong>可以申明一个类是继承另一个类而来的</p>
<pre><code class="java">public class A&#123;
    private int i;
    protected int j;
    
    public void func()&#123;
        
    &#125;
&#125;

public class B extends A&#123;
    public int z;
    public void fund()&#123;
        
    &#125;
&#125;
类B由类A继承而来的，类B是类A的子类，而类A是Object的子类，这里可以不显示地声明
作为子类，类B的实例拥有类A所有的成员变量，但对于private类型的成员变量类B却没有访问权限
这保障了类A的封装性
</code></pre>
<pre><code class="java">public class Animal&#123;&#125;
public class Mammal extends Animal&#123;&#125;  Animal类是Mammal类的父类
public class Reptile extends Animal&#123;&#125; Animal类是Reptile类的父类
                                       Mammal类和Reptile类是Animal类的子类   
public class Dog extends Mammal&#123;&#125; Dog类既是Mammal类的子类 又是 Animal类的子类
//通过使用关键字 extends,子类可以继承父类的除privat属性外所有的属性
//通过使用 instanceof 操作符,能够确定左边的对象是不是右边类的实例
public class Dog extends Mammal&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Mammal m = new Mammal();
        Dog d = new Dog();
        sout(m instanceof Animal);
        sout(d instanceof Mammal);
        sout(d instanceof Animal);
    &#125;
&#125;
运行结果
true
true
true
</code></pre>
<h4 id="HAS-A关系"><a href="#HAS-A关系" class="headerlink" title="HAS-A关系"></a>HAS-A关系</h4><p>HAS-A代表类和它的成员之间的从属关系，有助于代码的重用和减少代码的错误。</p>
<pre><code class="java">public class Vehicle&#123;&#125;
public class Speed&#123;&#125;
public class Van extends Vehicle&#123;
    private Speed sp;
&#125;
//Van类将实现的细节对用户隐藏起来，因此，用户只需要知道怎样调用Van类来完成某一功能
//而不必知道Van类是自己来做还是调用其他类来做这些工作
</code></pre>
<p>Java只支持单继承，一个类不能继承多个类</p>
<pre><code class="java">（×） public class test extends Animal, Mammal&#123;&#125;  (×)
</code></pre>
<p>Java只支持单继承(<u><strong>继承基本类</strong></u>和<u><strong>抽象类</strong></u>)，可以用接口来实现(<u><strong>多继承接口实现</strong></u>)</p>
<pre><code class="java">public class Apple extends Fruit implements Fruit1, Fruit2&#123;&#125;
一般继承基本类和抽象类用extends关键字，实现接口类的继承用implements关键字。
</code></pre>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写重要的地方是<u>返回值</u>和<u>形参</u>都不能改变，外壳不变，核心重写！</p>
<p>重写的好处在于子类可以根据需要，定义特定与自己的行为。</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        sout(&quot;狗可以跑和走&quot;);
    &#125;
  /*  
      public void bark()&#123;
        sout(&quot;狗可以吠叫&quot;);
    &#125; 
  */
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Animal b = new Dog();
        a.move();
        b.move();
       // a.bark();//此处会报错,因为a的引用类型Animal没有bark方法
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<p>尽管b属于Animal类型，但是它可以运行Dog类的move方法</p>
<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>参数列表与被重写方法的参数列表必须完全相同</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>子类方法的访问权限必须大于或等于父类方法的访问权限：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>声明为static的方法不能被重写，但可以被再次声明</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法</li>
<li>子类和父类不在同一个包中，那么子类可以重写父类的声明为public和protected的非final方法</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
<li>权限受阻：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
</ul>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><p>当需要在子类中调用父类的被重写方法时，要使用super关键字</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        super.move();
        sout(&quot;狗可以跑和走&quot;);
    &#125;
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal b = new Dog();
        b.move();
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载是在一个类里面，<u>方法名字</u>相同，而<u>参数</u>不同，<u>返回类型</u>可以相同也可以不同</p>
<p>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表</p>
<p>重载规则：</p>
<ul>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ul>
<h4 id="重写和重载的区分"><a href="#重写和重载的区分" class="headerlink" title="重写和重载的区分"></a>重写和重载的区分</h4><pre><code class="java">重写 bark(方法名和参数都一样)
class Dog&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
&#125;
class Hound extends Dog&#123;
    public void sniff()&#123;
        sout(&quot;sniff &quot;);
    &#125;
    public void bark()&#123;
        sout(&quot;bowl&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">重载 bark(方法名相同，参数不同)
class DOg&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
    public void bark(int num)&#123;
        for(int i = 0; i &lt; num; i++)&#123;
            sout(&quot;woof &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制(可以降低限制)</td>
</tr>
</tbody></table>
<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>多态是同一种行为具有不同表现形式或形态的能力</p>
<p>多态性是对象多种表现形式的体现</p>
<p>宠物&#x3D;小猫+小狗+蜥蜴</p>
<pre><code class="java">public interface Vegetarian&#123;&#125;
public class Animal&#123;&#125;
public class Deer extends Animal implements Vegetarian&#123;&#125;
</code></pre>
<p>当我们将引用型变量应用于Deer对象的引用</p>
<pre><code class="java">Deer d = new Deer();
Animal a = d;
Vegetarian v = d;
Object o = d;
所有的引用型变量d,a,v,o都指向堆中想通的Deer对象
</code></pre>
<h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><ul>
<li><strong>重写</strong></li>
<li><strong>接口</strong></li>
<li><strong>抽象类和抽象方法</strong></li>
</ul>
<h1 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h1><p>在Java面向对象的概念中，所有的对象都是通过类来秒回的</p>
<p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类除了不能实例化对象之外，类的其他功能依旧存在：成员变量、成员方法、构造方法</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用(通常在设计阶段决定要不要设计抽象类)</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>如果你想设计一个类：包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract关键词同样可以声明抽象方法，抽象方法只包含一个方法名，没有方法体</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号</p>
<pre><code class="java">public abstract class Employee&#123;
    private String name;
    private String address;
    private int number;
    public abstract double computePay();
    //其余代码
&#125;
</code></pre>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么这个类必须是抽象类</li>
<li>任何子类必须重写父亲的抽象方法，或者声明自身为抽象类</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法</p>
<pre><code class="java">public class Salary extends Employee&#123;
    private double salary;
    public double computePay()&#123;
        sout(&quot;Computing salary pay for &quot; + getName());
        return salary/52;
    &#125;
&#125;
</code></pre>
<h1 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h1><p>封装是一种将抽象性函式接口的实作细节部分包装、隐藏起来的方法</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</p>
<p>要访问该类代码和数据，必须通过严格的接口控制</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</p>
<p>适当的粉装可以让代码更容易理解和维护，也增强了代码的安全性</p>
<pre><code class="java">public class EncapTest&#123;
    private String name;
    private String idNum;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIdNum() &#123;
        return idNum;
    &#125;

    public void setIdNum(String idNum) &#123;
        this.idNum = idNum;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>public方法是外部类访问该类成员变量的入口，这些方法称为getter和setter方法</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法</p>
<pre><code class="java">public class RunEncap&#123;
    public static void main(String args[])&#123;
        EncapTest encap = new EncapTest();
        encap.setName(&quot;James&quot;);
        encap.setAge(20);
        encap.setIdNum(&quot;12343ms&quot;);
        sout(&quot;Name : &quot; + encap.getName() 
           + &quot;Age: &quot; + encap.getAge());
    &#125;
&#125;
运行结果：
Name : James Age : 20
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/04/30/后端/Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/28/后端/Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组/">
        <h2>
            Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><ul>
<li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、吃、叫等。</p>
</li>
<li><p><strong>类</strong>：类[class]是一个<strong>模板</strong>，它描述一类对象的<span style =" color : red">行为和状态</span>。</p>
</li>
<li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。</p>
</li>
<li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
</li>
<li><p>编写java时应注意几点：</p>
<p><strong>大小写敏感</strong></p>
<p><strong>类名</strong>：对所有类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写：MyFirstJavaClass</p>
<p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
<p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件时，你应该使用类名作为文件名保存(切记Java是大小写敏感的)，文件名的后缀为java。</p>
<p><strong>主方法入口</strong>：所有的Java程序由<span style =" color : red">public static void main(String[] args)</span>方法开始执行。</p>
</li>
<li><p><strong>Java变量</strong>：局部变量、类变量(静态[static]变量)、成员变量(非静态变量)</p>
</li>
<li><p><strong>方法</strong>：访问权限符 返回值 方法名(参数列表){  方法体  }</p>
<p>​            public          void    method()    {sout(“Hello”);}</p>
<p><strong>interface：</strong>接口，一种抽象的类型，仅有方法和常量的定义</p>
<p><strong>implements</strong>：表示一个类实现了接口</p>
<p><strong>abstract</strong>：抽象方法，抽象类的修饰符</p>
<p><strong>extends：</strong>表示一个类是另一个类的子类(继承)</p>
<p><strong>private：</strong>表示私有字段，或者方法等，只能从类内部访问</p>
<p><strong>protected：</strong>表示字段只能通过类或者子类访问，子类或者在同一个包内的其他类</p>
<p><strong>public：</strong>表示共有属性或方法</p>
<p><strong>static：</strong>表示在类级别定义，所有实例共享的</p>
<p><strong>throw：</strong>抛出异常</p>
<p><strong>throws：</strong>定义方法可能抛出的异常</p>
</li>
<li><p><strong>继承</strong>：在Java中，一个类可以由其他类派生，如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类，利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类(super class)，派生类称为子类(subclass)</p>
</li>
<li><p><strong>接口</strong>：在Java中，接口可理解为对象间互相通信的协议。接口在继承中扮演着很重要的角色。接口值定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
</li>
</ul>
<h1 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h1><ul>
<li>Java中的类和方法[方法就是行为，一个类可以有很多方法]</li>
</ul>
<pre><code class="jaVA">public class Dog&#123;
    String breed;
    int age;
    String color;
    
    void barking()&#123;
        
    &#125;
    void hungry()&#123;
        
    &#125;
    void sleeping()&#123;
        
    &#125;
&#125;
</code></pre>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()、sleeping() 都是Dog类的方法</p>
<hr>
<p><strong>构造方法</strong></p>
<p>每个类都有构造方法，不主动创建编译器将会为该类提供一个默认的构造方法，在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<pre><code class="java">public class Puppy&#123;
    public Puppy()&#123;
        
    &#125;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数：name
    &#125;
&#125;
</code></pre>
<hr>
<p><strong>创建对象</strong></p>
<p>对象是根据类创建的。在java中，使用关键字new来创建一个新的对象。</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型</li>
<li><strong>实例化</strong>：使用关键字new来创建一个对象</li>
<li><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象</li>
</ul>
<pre><code class="java">public class Puppy&#123;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数:name
        sout(&quot;Puppy Name is :&quot; + name);
    &#125;
    public static void main(String[] args)&#123;
        //下面的语句将创建一个Puppy对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
    &#125;
&#125;

打印出下面结果：
Puppy Name is : tommy
</code></pre>
<hr>
<p><strong>访问实例变量和方法</strong></p>
<pre><code class="java">//实例化对象
ObjectReference = new Constructor();
//访问其中的变量
ObjectReference.variableName;
//访问类中的方法
ObjectReference.MethodName();
</code></pre>
<hr>
<p><strong>实例</strong></p>
<p>访问实例变量和调用成员方法：</p>
<pre><code class="java">public class Puppy&#123;
    int puppyAge;
    public Puppy(String name)&#123;
        sout(&quot;Passed Name is :&quot; + name);
    &#125;
    public void setAge(int age)&#123;
        puppyAge = age;
    &#125;
    public int getAge()&#123;
        sout(&quot;Puppy&#39;s age is :&quot; + puppyAge);
        return puppyAge;
    &#125;
    
    public static void main(String[] args)&#123;
        //创建对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
        //通过方法来设定age
        myPuppy.setAge(2);
        //调用另一个方法获取age
        myPuppy.getAge();
        //也可以这样访问成员变量
        sout(&quot;Variable Value :&quot; + myPuppy.puppyAge);
    &#125;
&#125;

输出结果：
Passed Name is :tommy
   &#39;s age is :2
PuppyVariable Value :2
</code></pre>
<hr>
<p><strong>源文件声明规则</strong></p>
<ul>
<li><p>一个源文件中只能有一个public类</p>
</li>
<li><p>一个源文件可以有多个非public类</p>
</li>
<li><p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java</p>
</li>
<li><p>特殊的转义字符序列</p>
</li>
</ul>
<pre><code class="java">\n 换行
\r 回车
\f 换页符
\b 退格
\0 空字符
\s 字符串
\t 制表符
</code></pre>
<hr>
<h1 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h1><p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量称之为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用(类方法中的变量)(局部变量的作用域仅限制在被创造的方法中)</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。(独立于方法之外的变量，不过没有static修饰)</li>
<li><strong>类变量</strong>：类变量(静态变量)也声明在类中，方法体之外，但必须声明为static类型。无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。静态变量除了被声明为常量外很少使用，常量是指声明为public&#x2F;private，final和static类型的变量，常量初始化后不能改变。静态变量存储在静态存储区，经常被声明为常量，很少单独使用static声明变量。类变量被声明为public static final 类型时，类变量名称必须使用大写字母，如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。(独立于方法之外的变量，用static修饰)</li>
</ul>
<p><strong>然后是static</strong></p>
<p><strong>static在java中表示静态</strong></p>
<p><strong>但是这个静态又是什么意思呢？</strong></p>
<p><strong>最开始接触static的时候看书上的概念根本没弄懂！</strong></p>
<p><strong>接触有一段时间java了，在这里面要总结一下我对static的理解：</strong></p>
<p>（概念）static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>
<p>这句话是说，你会用到static修饰一些个变量、方法、方法块什么的，这是你用到static的地方；“但是，java中没有全局变量的概念”，怎么理解这句话？你时刻要记住java是一个面向对象的语言，万事万物皆对象，无论你做什么都需要创建一个对象，然后再调用这个对象的方法，java怎么能允许存在一个在全局都通用的“全局变量”的概念存在呢？所以java中压根就没有所谓的“全局变量”，但是没有这个概念，不代表你不可以实现这个功能，java存在的目的就是让人们使用它去达到人们想要的效果，所以static value就可以达到全局变量的作用，所以，你现在应该可以理解下面这句话了吧。</p>
<p>（概念）用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>现在进一步理解下面两段概念：</p>
<p>（概念）只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //salary是静态的私有变量
    private static double salary;
    //DEPARTMENT是一个常量
    public static final String DEPARTMENT = &quot;Development &quot;;
    public static void main(String args[])&#123;
        salary = 1000;
        sout(DEPARTMENT + &quot;average salary:&quot; + salary);
    &#125;
&#125;
输出结果：
Develment average salary：1000
</code></pre>
<pre><code class="java">public class Variable&#123;
    static int allClicks = 0;    //类变量
    String str = &quot;hello world&quot;; //实例变量
    public void method()&#123;
        int i = 0; //局部变量
    &#125;
&#125;
</code></pre>
<p>实例：</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //这个成员变量对子类可见
    public String name;
    //私有变量，仅在该类可见
    private double salary;
    //在构造器中对name赋值
    public Employee(String empName)&#123;
        name = empName;
    &#125;
    //设定salary的值
    public void setSalary(double empSal)&#123;
        salary = empSal;
    &#125;
    //打印信息
    public void printEmp()&#123;
        sout(&quot;name :&quot; + name);
        sout(&quot;salary :&quot; + salary);
&#125;
    public ststic void main(String args[])&#123;
        Employee empOne = new Employee(&quot;Ransika&quot;);
        empOne.setSalary(1000);
        empOne.printEmp();
    &#125;
&#125;
输出结果：
name : Ransika
salary :1000.0
</code></pre>
<hr>
<h1 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h1><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li><strong>default 默认的：</strong>在同一包内可见，不使用任何修饰符</li>
<li><strong>private 私有的：</strong>在同一类内可见。私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。private访问修饰符的作用主要用来隐藏类的实现细节和保护类的数据</li>
</ul>
<pre><code class="java">public class Logger&#123;
    private String format;
    public String getFormat()&#123;
        return this.format;
    &#125;
    public void setFormat(String format)&#123;
        this.format = format;
    &#125;
&#125;
</code></pre>
<p>实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：<strong>getFormat()</strong> (返回format的值) 和 <strong>setFormat(String)</strong> (设置format的值)</p>
<ul>
<li><strong>public 公有的：</strong>对所有类可见，被声明public的类、方法、构造方法和接口能够被任何其他类访问。如果几个互相访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的共有方法和变量都能被子类继承</li>
</ul>
<pre><code class="java">public static void main(String[] arguments)&#123;
    //...(公有访问控制)
&#125;
</code></pre>
<p>Java程序的main()方法必须设置成共有的，否则，不能运行该类</p>
<ul>
<li><strong>proteed 受保护的：</strong>对同一包内的类和所有子类可见</li>
</ul>
<p>被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。protected访问修饰符不能修饰类和接口，方法和成员变量能够声明protected，但是接口的成员变量和成员方法不能声明为protected，子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了protected访问修饰符，子类重载了父类的openSpeaker()方法。</p>
<pre><code class="java">class AudioPlayer&#123;
    protected boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
class StreamingAudioPlayer&#123;
    boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
</code></pre>
<p>如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法</p>
<p>如果把openSpeaker()方法声明为public，那么所有的类都能够访问该方法</p>
<p>如果我们只想让该方法对其所在的类的子类可见，则将该方法声明为protected</p>
<ul>
<li><strong>访问控制和继承</strong>规则：<ul>
<li>父类中声明为public的方法在子类中也必须为public</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private</li>
<li>父类中声明为private的方法，不能够被继承</li>
</ul>
</li>
</ul>
<h4 id="控制非访问修饰符"><a href="#控制非访问修饰符" class="headerlink" title="控制非访问修饰符"></a>控制非访问修饰符</h4><ul>
<li><p><strong>static 修饰符：</strong>用来创建类方法和类变量</p>
<ul>
<li><strong>静态变量：</strong>static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也成为类变量。局部变量不能被声明为static变量</li>
<li><strong>静态方法：</strong>static关键词用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据</li>
</ul>
<p>对类变量和方法的访问可以直接使用classname.variablename 和 classname.methodname的方式访问 </p>
<p>下面为static修饰符用来创建类方法和类变量</p>
</li>
</ul>
<pre><code class="java">public class InstanceCounter&#123;
    private static int numInstances = 0;
    protected static int getCount()&#123;
        return numInstances;
    &#125;
    
    private static void addInstance()&#123;
        numInstances++;
    &#125;
    
    InstanceCounter()&#123;
        InstanceCounter.addInstance();
    &#125;
    
    public static void main(String[] arguments)&#123;
        sout(&quot;Starting with&quot; + InstanceCounter.getCount() + &quot; instances&quot;);
        for(int i = 0; i &lt; 500; ++i)&#123;
            new InstanceCounter();
        &#125;
        sout(&quot;Created &quot; + InstanceCounter.getCount() + &quot;instances&quot;);
    &#125;
&#125;
输出结果：
Started with 0 instances
Created 500 instances
</code></pre>
<ul>
<li><p><strong>final 修饰符：</strong>用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</p>
<ul>
<li><strong>final变量：</strong>能被显示地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。final修饰符通常和static修饰符一起使用来创建类常量。</li>
</ul>
<pre><code class="java">public class Test&#123;
    final int value = 10;
    //下面是声明常量的实例
    public static final int BOXWIDTH = 6;
    static final String TITLE = &quot;Manger&quot;;
    
    public void changeValue()&#123;
        value = 12; //将输出一个错误
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final方法：</strong> 类中的final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改</li>
</ul>
<p>如图为final修饰符声明方法</p>
<pre><code class="java">public class Test&#123;
    public final void changeName()&#123;
        //方法体
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final类：</strong> final类不能被继承，没有类能够继承final类的任何特性</li>
</ul>
<pre><code class="java">public final class Test&#123;
    //类体
&#125;
</code></pre>
</li>
<li><p><strong>abstrat 修饰符：</strong>用来创建抽象类和抽象方法</p>
<ul>
<li><strong>抽象类：</strong>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被abstract和final修饰，如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则编译错误。抽象类包含抽象方法和非抽象方法。</li>
<li><strong>抽象方法：</strong>是一种没有任何实现的方法，该方法的具体实现由子类提供，抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非子类也是抽象类。抽象类可以不包含抽象方法。</li>
</ul>
<pre><code class="java">abstract class Caraven&#123;
    private double price;
    private String model;
    private String year;
    public abstract void goFast(); //抽象方法
    public abstract void changeColor();
&#125;
</code></pre>
<pre><code class="java">public abstract class SuperClass&#123;
    abstract void m(); //抽象方法
&#125;
class SubClass extends SuperClass&#123;
    //实现抽象方法
    void m()&#123;
        // ......
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>synchronized和volatile 修饰符：</strong> 主要用于线程的编程 （这里不具体研究）</p>
</li>
</ul>
<hr>
<h1 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h1><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>假设a&#x3D;60，b&#x3D;13；</p>
<pre><code class="java">    a = 0011 1100
    b = 0000 1101
----------------------
a &amp; b = 0000 1100
a | b = 0011 1101
a ^ b = 0011 0001
~ a   = 1100 0011
</code></pre>
<h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型(类类型 或 接口类型)</p>
<p>instanof运算符使用格式如下：</p>
<pre><code class="java">(Object reference variable)instanceof(class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真</p>
<pre><code class="java">String name = &quot;James&quot;;
boolean result = name instanceof String;
//由于name是String类型，所以返回真
</code></pre>
<pre><code class="java">class Vehicle&#123;&#125;
public class Car extends Vehicle&#123;
    public static void main(String args[])&#123;
        Vehicle a = new Car();
        boolean result = a instanceof Car;
        sout(result);
    &#125;
&#125;
输出结果：
true
</code></pre>
<h4 id="continue关键字-增强型for循环"><a href="#continue关键字-增强型for循环" class="headerlink" title="continue关键字 + 增强型for循环"></a>continue关键字 + 增强型for循环</h4><p>continue适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代</p>
<p>在<strong>for循环</strong>中，continue语句使程序立刻跳转到更新语句</p>
<p>在<strong>while</strong>或者<strong>do…while循环</strong>中，程序立刻跳转到布尔表达式的判断语句</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        int &#123;&#125; numbers = &#123;10, 20, 30, 40, 50&#125;;
        for(int x : numbers)&#123;
            if(x == 30)&#123;
                continue;
            &#125;
            sout(x);
            sout(&quot;\n&quot;);
        &#125;
    &#125;
&#125;
输出结果：
10
20
40
50
</code></pre>
<h1 id="Java-Number类、Math类、Character类"><a href="#Java-Number类、Math类、Character类" class="headerlink" title="Java Number类、Math类、Character类"></a>Java Number类、Math类、Character类</h1><h4 id="Number包装类型"><a href="#Number包装类型" class="headerlink" title="Number包装类型"></a>Number包装类型</h4><pre><code class="java">byte -&gt; Byte        int -&gt; Integer        short -&gt; Short        long -&gt; Long
double -&gt; Double    float -&gt; Float        boolean -&gt; Boolean    char -&gt; Character
</code></pre>
<p>包装类型都是用final声明了，不可能被继承重写。在实际情况中编译器会自动的将基本类型数据<strong>装箱</strong>成对象类型，或者将对象类型<strong>拆箱</strong>成基本类型</p>
<pre><code class="java">public static void main(String[] args)&#123;
    int num1 = 1;
    //将基本类型数据装箱成对象包装类型
    Integer num2 = num1;
    Integer num3 = 3;
    //将对象数据类拆箱
    int num4 = num3;
&#125;
</code></pre>
<p>下面是一个装箱与拆箱的例子：</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        Integer x = 5;
        x = x + 10;
        sout(x);
    &#125;
&#125;
输出结果：
15
</code></pre>
<h4 id="Math类型"><a href="#Math类型" class="headerlink" title="Math类型"></a>Math类型</h4><p>Java的Math包含了用于执行基本数学运算的属性和方法：初等指数、对数、平方根和三角函数</p>
<p>Math的方法都被定义为static形式，通过Math类可以在主函数中直接调用 sout(“90°正弦值：” + Math.sin(Math.PI &#x2F; 2))；</p>
<p>下表是常用的Number类和Math类的方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>xxxValue()：将number对象转换为xxx数据类型的值并返回</td>
</tr>
<tr>
<td>2</td>
<td>compareTo()：将number对象与参数比较</td>
</tr>
<tr>
<td>3</td>
<td>equals()：判断number对象是否与参数相等</td>
</tr>
<tr>
<td>4</td>
<td>valueOf()：返回一个Integer对象指定的内置数据类型</td>
</tr>
<tr>
<td>5</td>
<td>toString()：以字符串形式返回值</td>
</tr>
<tr>
<td>6</td>
<td>parseInt()：将字符串解析为int类型</td>
</tr>
<tr>
<td>7</td>
<td>abs()：返回参数的绝对值</td>
</tr>
<tr>
<td>8</td>
<td>floor()：返回小于等于给定参数的最大整数</td>
</tr>
<tr>
<td>9</td>
<td>round()：返回一个最接近的int、long型值</td>
</tr>
<tr>
<td>10</td>
<td>exp()：返回自然数底数e的参数次方</td>
</tr>
<tr>
<td>11</td>
<td>log()：返回参数的自然数底数的对数值</td>
</tr>
<tr>
<td>12</td>
<td>pow()：返回第一个参数的第二个参数次方</td>
</tr>
<tr>
<td>13</td>
<td>sqrt()：求参数的算术平方个</td>
</tr>
<tr>
<td>14</td>
<td>random()：返回一个随机数</td>
</tr>
</tbody></table>
<h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>使用字符时，我们通常使用的是内置数据类型char</p>
<ul>
<li>Character类的用法：可以使用Character的构造方法创建一个Character类对象</li>
</ul>
<pre><code class="java">Character ch = new Character(&#39;a&#39;);
----------------------------------
Character ch = &#39;a&#39;;
char c = test(&#39;x&#39;);
</code></pre>
<pre><code class="java">isLetter()是否是一个字母        isDigit()是否是一个数字字符
isUpperCase()是否是大写字母    isLowCase()是否是小写字母
toUpperCase()指定字母的大写形式 isLowerCase()指定字母的小写形式
toString()返回字符的字符串形式，字符串的长度仅为1
</code></pre>
<p>注意：String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</p>
<p>可以通过StringBuffer类 和 StringBuilder类(能够被多次的修改，并且不产生新的未使用对象)</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        StringBuffer sBuffer = new StringBuffer(&quot;test&quot;);
        sBuffer.append(&quot;String Buffer&quot;);
        sout(sBuffer);
    &#125;
&#125;
输出结果：
test String Buffer
</code></pre>
<pre><code class="java">public StringBuffer append(String s) 将指定的字符串追加到此字符序列
public StringBuffer reverse() 将此字符序列用其反转形式取代
public delete(int start, int end) 移除此序列的子字符串中的字符
public insert(int offset, int i) 将int参数的字符串表示形式插入此序列中
replace(int start, int end, String str) 使用给定String中的字符替换此序列的子字符串中的字符
</code></pre>
<h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><h4 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h4><pre><code class="java">dataType[] arrayRefVar;
double[] myList;
</code></pre>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>Java语言使用new操作符来创建数组</p>
<pre><code class="java">arrayRefVar = new dataType[arraySize];
此语法语句做了两件事：
    ①：使用dataType[arraySize]创建了一个数组
    ②：把新创建的数组的应用赋值给变量arrayRefVar
</code></pre>
<p>所以<strong>数组的变量声明</strong>和<strong>创建数组</strong>可以用一条语句完成</p>
<pre><code class="java">dataType[] arrayRefVar = new dataType[arraySize]
</code></pre>
<p>数组的元素时通过索引来访问的，数组索引从0开始，所以索引值从0到arrayRefVar.length-1</p>
<p>定义一个int类型的数组</p>
<pre><code class="java">public class ArrayDemo&#123;
    public static void main(String args[])&#123;
        int data[] = new int[3]; //开辟了一个长度为3的数组
        //在数组使用之前一定要开辟空间(实例化)
        data[0] = 10;
        data[1] = 20;
        data[2] = 30;
        for(int x = 0; x &lt; data.length; x++)&#123;
            sout(data[x]);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h4><p>数组可以作为参数传递给方法</p>
<pre><code class="java">public static void printArray(int[] array)&#123;
    for(int i = 0; i &lt; array.length; i++)&#123;
        sout(array[i] + &quot; &quot;);
    &#125;
&#125;

printArray(new int[]&#123;3, 1, 2, 6, 4, 2&#125;);
</code></pre>
<h4 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h4><pre><code class="java">public static int[] reverse(int[] list)&#123;
    int[] result = new int[list.length];
    for(int i = 0, j = result.length - 1; i &lt; list.length; i++, j--)&#123;
        result[j] = list[i];
    &#125;
    return result;
&#125;
</code></pre>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的</p>
<ul>
<li>给数组赋值：通过<strong>fill</strong>方法</li>
<li>对数组排序：通过<strong>sort</strong>方法，按升序</li>
<li>比较数组：通过<strong>equals</strong>方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过<strong>binarySearch</strong>方法能对排序好的数组进行二分查找法操作</li>
</ul>
<pre><code class="java">public static int binarySearch(Object[], Object key) 
用二分查找算法在给定数组中搜索给定值的对象(Byte,int,double等)
public static boolean equals(long[] a, long[] a2)
如果两个指定的long型数组彼此相等，则返回true。如果两个数组包含相同数量的元素
并且两个元素中的所有相应元素对都是相等的，则认为这两个数组是相等的
public static void fill(int[] a, int val)
将指定的int值分配给指定int型数组指定范围中的每个元素
public static void sort(Object[] a)
对指定对象数组根据其元素的自然顺序进行升序排序
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/04/28/后端/Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/22/英语/作文高分语句模板/">
        <h2>
            作文模板
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <span id="more"></span>

<h1 id="画图作文"><a href="#画图作文" class="headerlink" title="画图作文"></a>画图作文</h1><h4 id="首段：图画描述"><a href="#首段：图画描述" class="headerlink" title="首段：图画描述"></a>首段：图画描述</h4><pre><code class="java">显然，这幅画能自然联系到做好小事的重要性
This drawing, apparently, can be linked to the critical significance of doing small things.
    
图画中，一个年轻人表达了自己对“核废料处理”的担忧
In the picture, the youngster express his worries about &quot;disposing of nuclear waste&quot;.
    
使他感到吃惊的是，他爸爸指着垃圾筐告诉他,如果能把垃圾筐清空，他就能做好一切
To his surprise, his father points at the dustbin, telling him that if he can empty the dustbin there, he can do anything.
</code></pre>
<h4 id="二段：图画主题-现象-意义"><a href="#二段：图画主题-现象-意义" class="headerlink" title="二段：图画主题 + 现象 + 意义"></a>二段：图画主题 + 现象 + 意义</h4><pre><code class="java">父亲的意思是，如果年轻人想要成功
The father means that if young people dream to achieve success,
    - 
就应该明智地从小的工作开始做起
it is sensible for them to start with little jobs.
</code></pre>
<pre><code class="java">确实，在当今社会，很多年轻人忽略身边的各种小事已经成为一种常见现象
Admittedly, in the present-day society, it is a common phenomenon for many teenagers to neglect tiny things in life.
    
例如打扫房间、洗衣服和清理垃圾筐
such as cleaning rooms, washing clothes and emptying dustbins.
    
为什么？因为越来越多的年轻人觉得处理这些小事没有用。一个典型例子就是图画中的小孩。
Why? The reason is that a growing number of young people find it rather useless to deal with these things.
A typical example is the boy in the picture.
</code></pre>
<pre><code class="java">然而，正是这些小事确保年轻人能掌握足够的知识、能力和经验
Nonetheless, it is these small tasks that ensure young people to master sufficient knowledge, competence and experience.
    
事实上，很多聪明人已经意识到这些小事的重要性
Actually, wise people in large numbers have come to recognize the significance of these small things.

做好这些小事带给我们技能，唤起我们对成功的热情，帮助我们进步
Doing small things brings us skills, arouses our passion for success and helps us to make progress.
</code></pre>
<h4 id="尾段：观点-建议-展望"><a href="#尾段：观点-建议-展望" class="headerlink" title="尾段：观点 + 建议 + 展望"></a>尾段：观点 + 建议 + 展望</h4><pre><code class="java">作为一名大学生，我坚信年轻人很有必要通过做好小事提升自己的整体素质
As a college student, I am convinced that it is exceedingly necessary for young people to strengthen our comprehensive
quality by doing small things. 
因此，我们应该教育和鼓励我们的朋友和熟人培养这种积极的意识和习惯
Accordingly, we should educate and encourage our friends and acquaintances to foster this positive awareness and habit.
如果我们不遗余力地这样来做，未来我们的工作和生活将充满光明和希望
We, sparing no efforts to do so, may witness a hopeful and promising future of our work and study.
每个人都应该就牢记大的成功源于每天小的进步
Everyone should bear in mind that a big success originates from everyday small progress.
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ff7d73>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/04/22/英语/作文高分语句模板/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/21/政治/(Mr)社会主义、邓小平理论/">
        <h2>
            社会主义、邓小平理论
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/21
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="社会主义改造理论"><a href="#社会主义改造理论" class="headerlink" title="社会主义改造理论"></a>社会主义改造理论</h1><h4 id="从新民主主义到社会主义的转变"><a href="#从新民主主义到社会主义的转变" class="headerlink" title="从新民主主义到社会主义的转变"></a>从新民主主义到社会主义的转变</h4><h4 id="新民主主义社会的性质"><a href="#新民主主义社会的性质" class="headerlink" title="新民主主义社会的性质"></a>新民主主义社会的性质</h4><p>从<strong>中华人民共和国成立</strong>到<strong>社会主义改造基本完成</strong>，是我国从<strong>新民主主义</strong>到<strong>社会主义</strong>的过渡时期</p>
<h4 id="新民主主义社会的特点"><a href="#新民主主义社会的特点" class="headerlink" title="新民主主义社会的特点"></a>新民主主义社会的特点</h4><ol>
<li>经济成分：个体经济，资本主义经济，社会主义经济</li>
<li>阶级构成：工人阶级、农民阶级和其他小资产阶级、民族资产阶级等基本的阶级力量</li>
<li>主要矛盾：<strong>工人阶级</strong>和<strong>资产阶级</strong>的矛盾</li>
</ol>
<h4 id="党在过度时期的总路线"><a href="#党在过度时期的总路线" class="headerlink" title="党在过度时期的总路线"></a>党在过度时期的总路线</h4><p>1949年党的七届二中全会，提出了使中国“稳步地由<strong>农业国</strong>转变为<strong>工业国</strong>，由<strong>新民主主义国家</strong>转变为<strong>社会主义国家</strong>”(两个转变同时并举的思想)</p>
<p>党在这个过度时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对<strong>农业</strong>、对手工业和<strong>资本主义工商业</strong>的社会主义改造</p>
<p>党在过渡时期总路线的主要内容被概括为“<strong>一化三改</strong>”。<strong>一化：</strong>社会主义工业化。<strong>三改：</strong>对个体农业、手工业和资本主义工商业的社会主义改造。两者相辅相成，互相促进，体现了解放生产力与发展生产力、变革生产关系与发展生产力的有机统一。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/政治" style=color:#ff7d73>
                政治
            </a>
        </span>
        
    </div>

    <a href="/2022/04/21/政治/(Mr)社会主义、邓小平理论/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/10/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/9">
                <span class="page-num">
                    9
                </span>
            </a>
            

            
            <a href="/page/10/">
                <span class="page-num">
                    10
                </span>
            </a>
        </span>
        

        <span class="current">
            11
        </span>

        
        <span>
            <a href="/page/12/">
                <span class="page-num">
                    12
                </span>
            </a>
            
            <a href="/page/13">
                <span class="page-num">
                    13
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/12/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>