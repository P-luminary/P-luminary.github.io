
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/07/03/计算机/计算机基础概论、进制转换、中文字符/">
        <h2>
            计算机基础概论、进制转换、中文字符
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/7/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="计算机基础概论"><a href="#计算机基础概论" class="headerlink" title="计算机基础概论"></a>计算机基础概论</h1><p><strong>题型</strong>：单选题、多选题、判断题、填空题、简答题、分析题、操作题、综合应用题</p>
<h4 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h4><ul>
<li><p><strong>信息是在自然界、人类社会和人类思维活动中普遍存在的一切物质和事物的属性</strong></p>
</li>
<li><p><strong>香农</strong>是<u>信息论</u>的创始人：信息是用来消除不确定性的东西</p>
</li>
<li><p>信息的单位是：<strong>bit</strong></p>
</li>
<li><p>信息的特征：普遍性、时效性、共享性、价值相对性、载体依附性等</p>
</li>
</ul>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul>
<li><strong>数据是指存储在某种媒体上可以加以鉴别的符号资料</strong></li>
<li>数据的分类：<strong>数值</strong>(正负号)和<strong>非数值数据</strong>(文字、图像、声音、动画、视频等)</li>
</ul>
<h4 id="信息与数据的关系"><a href="#信息与数据的关系" class="headerlink" title="信息与数据的关系"></a>信息与数据的关系</h4><ul>
<li><strong>数据是信息的<span style = "color : red">具体表现形式</span>，是信息的载体，而信息是对数据进行加工后得到的结果，信息是数据的逻辑意义</strong></li>
<li>信息的符号化就是数据，数据是信息的具体表现形式</li>
<li>判断题：有信息一定有数据(√)  有数据一定有信息(×)   ∵信息的载体是数据   而数据有些是垃圾数据则不一定有信息</li>
</ul>
<p>一定有数据 有数据一定</p>
<h4 id="信息技术"><a href="#信息技术" class="headerlink" title="信息技术"></a>信息技术</h4><ul>
<li><strong>IT(Information Technology)：信息技术是指人们获取、存储、传递、处理、开发和利用信息资源的相关技术</strong></li>
<li>目前被人们称为3C(Communication、Co6mputer、Control)认证技术的是指(<strong>通信技术</strong>、<strong>计算机技术</strong>和<strong>控制技术</strong>)</li>
<li>信息技术的组成：计算机技术(核心)、通信技术(支柱)、微电子技术(基础)、网络技术和传感技术</li>
<li>信息技术的发展趋势：现代信息技术的发展趋势可概括为：数字化、多媒体化、高速度、网络化、宽频带、智能化</li>
</ul>
<h4 id="信息社会"><a href="#信息社会" class="headerlink" title="信息社会"></a>信息社会</h4><ul>
<li>继工业化社会以后，以信息活动为社会发展的基本活动的新兴社会形态</li>
<li><strong>信息、物质、能量</strong>构成世界三大资源，网络成为人们生活的基础条件</li>
</ul>
<h4 id="计算机文化"><a href="#计算机文化" class="headerlink" title="计算机文化"></a>计算机文化</h4><ul>
<li>人类文化发展的四个里程碑：<strong>语言的产生、文字的使用、印刷术的文明、计算机文化</strong></li>
<li>计算机文化的真正内涵：一个人经过文化教育后所具有的能力由传统的读,写,算上升到新的高度–具有计算机信息处理能力</li>
</ul>
<h4 id="计算机的概念与发展"><a href="#计算机的概念与发展" class="headerlink" title="计算机的概念与发展"></a>计算机的概念与发展</h4><ul>
<li><p>计算机概念：计算机也称之为电脑，是一种具有<strong>计算功能</strong>、<strong>记忆功能</strong>、<strong>逻辑判断</strong>功能的机器设备。它能<strong>接收数据</strong>，<strong>保留数据</strong>，按照预定的程序对<strong>数据进行处理</strong>，并提供和保存处理结果</p>
</li>
<li><h4 id="计算机发展"><a href="#计算机发展" class="headerlink" title="计算机发展"></a>计算机发展</h4><ul>
<li><strong>算盘</strong>：公元六世纪左右，十进制的计算工具，算盘被称为计算机，算盘不是计数工具，而是执行珠算口诀指令的计算工具。缺点是容易出错，依赖人力限制了运算速度</li>
<li>**帕斯卡计算器(补九码)**：1642年发明可进行加法和减法运算(自动)</li>
<li>**莱布尼兹(传教)**：1671年发明可进行四则运算的机器，来解决进位的问题；发明了二进制</li>
<li><strong>巴贝奇</strong>：19世纪，英国数学家查尔斯·巴贝奇最先提出通用数学计算机的基本设计思想。1822年设计了一台“差分机”。1832年，开始设计一种基于计算自动化的程序控制的“分析机”，提出几乎是完整的计算机设计方案，被称为<strong>“计算机之父”</strong>(机械的)(通用计算机之父)<ul>
<li>(查尔斯<strong>巴贝奇</strong>于1834年设计的分析机)是现代通用计算机的雏形</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="电子计算机的诞生-ENIAC-电子数字积分计算机"><a href="#电子计算机的诞生-ENIAC-电子数字积分计算机" class="headerlink" title="电子计算机的诞生(ENIAC:电子数字积分计算机)"></a>电子计算机的诞生(ENIAC:电子数字积分计算机)</h4><ul>
<li>ENIAC：Electronic Numerical Integrator And Computer</li>
<li><strong>第一台真正意义上的电子计算机</strong></li>
<li><u><strong>诞生于1946.2.14美国宾夕法尼亚大学</strong></u></li>
<li><strong>人物：莫克利、艾克特、冯·诺依曼</strong></li>
<li>特点：1、<strong>采用十进制</strong>  2、<strong>使用电子管</strong>  3、无键盘，鼠标等输入设备，不存储程序  4、<strong>应用领域：科学计算</strong>  5、<strong>运算速度5000次&#x2F;s加法</strong>  6、不是冯·诺依曼机</li>
</ul>
</li>
<li><h4 id="计算机历史人物"><a href="#计算机历史人物" class="headerlink" title="计算机历史人物"></a>计算机历史人物</h4><ul>
<li><p><u><strong>巴贝奇</strong></u>：英国数学家，差分机，分析机，有时候被称为<u><strong>(机械)计算机之父</strong></u></p>
</li>
<li><p>莱布尼兹：德国数学家，解决进位的莱布尼兹轮，发明了二进制</p>
</li>
<li><p>布尔：英国数学家，布尔运算，逻辑TRUE对应1，逻辑FALSE对应0</p>
</li>
<li><p>香农：美国数学家，信息论创始人，信息论之父，</p>
<ul>
<li>信息的定义：信息时能够用来消除不确定性的东西，提出“信息熵”符号逻辑和开关理论</li>
</ul>
</li>
<li><h4 id="艾伦·图灵"><a href="#艾伦·图灵" class="headerlink" title="艾伦·图灵"></a>艾伦·图灵</h4><ul>
<li><strong>Alan Turing, 英国数学家，计算机科学家之父，人工智能之父</strong></li>
<li><strong>图灵机</strong>(<u>一种模型，并非真正计算机</u>)(是由图灵在1936年提出的，它是一种精确的通用计算机<strong>模型</strong>，能模拟实际计算机的所有计算行为)奠定了课计算理论的基础<ul>
<li>现代计算机的功能不可能超过图灵机</li>
<li>图灵机不能计算的问题，现代计算机也不可能计算</li>
<li>只有图灵机能解决的计算问题，实际计算机才能解决</li>
</ul>
</li>
<li>图灵测试：由艾伦·麦席森·图灵发明</li>
<li>图灵奖：计算机界的诺贝尔奖，由美国计算机协会(ACM)于1966年设立</li>
</ul>
</li>
<li><h4 id="冯·诺依曼-美籍匈牙利科学家"><a href="#冯·诺依曼-美籍匈牙利科学家" class="headerlink" title="冯·诺依曼[美籍匈牙利科学家]"></a>冯·诺依曼[美籍匈牙利科学家]</h4><ul>
<li><p><strong>公认的电子计算机之父</strong></p>
</li>
<li><p>冯·诺依曼工作原理(计算机<strong>五大</strong>硬件、存储程序、程序控制、计算机内部采用<strong>二进制</strong>)</p>
</li>
<li><p>EDVAC(第一台提出冯·诺依曼原理概念的计算机)</p>
</li>
<li><p>硬件系统 二进制 程序存储和程序控制</p>
<p>@@ E<strong>NI</strong>AC E<strong>DV</strong>AC 你！打我！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="计算机发展分代"><a href="#计算机发展分代" class="headerlink" title="计算机发展分代"></a>计算机发展分代</h4><ul>
<li>几个第一(&#x3D;&#x3D;<u>第一<strong>代</strong>计算机为二进制</u>  <u>第一<strong>台</strong>计算机为十进制</u>&#x3D;&#x3D;)<ul>
<li>世界上<strong>第一台</strong>电子计算机 ENIAC<del>十进制</del>(↑电子计算机的诞生)，占地170平米，篮球场是420平米，占地面积约为半个篮球场<ul>
<li>ENIAC是世界上第一台电子计算机在美国发明的</li>
<li>ENIAC不是存储程序控制的计算机</li>
<li>世界上第一台投入运行的具有存储程序控制的计算机是英国人设计并制造的<strong>EDSAC</strong> 【EDVAC抢先注册】</li>
</ul>
</li>
<li>第一台<strong>冯·诺依曼机</strong><ul>
<li>名称：EDSAC</li>
<li>时间：1949年5月6日</li>
<li>人物：英国剑桥大学教授莫里斯·威尔克斯</li>
<li>意义：是世界上第一台实际运行的存储程序式电子计算机</li>
<li>以EDVAC为蓝本，抢先</li>
</ul>
</li>
<li>第一台<strong>商用电子计算机</strong><ul>
<li>名称：UNIVAC-1</li>
<li>第一台商用计算机是1951年产的(UNIVAC-1)</li>
<li>开发者：莫克利和艾克特，1951年</li>
<li>用途：第一台卖给了美国人口普查部用于人口普查，标志着计算机进入了商业应用时代，标志着计算机时代的真正开始，计算机从此由实验室走向社会</li>
</ul>
</li>
<li>中国第一台每秒钟运算一亿次以上的<strong>“银河-1号句型计算机”</strong> 1983年，速度：每秒1亿次</li>
<li><strong>神威·太湖之光</strong> 第一位(<strong>3,168万亿</strong>次每秒)，<strong>天河二号</strong> 第二位</li>
</ul>
</li>
</ul>
<p><strong><u>电晶集成大(灶)</u></strong></p>
<table>
<thead>
<tr>
<th>年代</th>
<th>名称</th>
<th>元器件</th>
<th>存储器</th>
<th>语言</th>
<th>应用领域</th>
</tr>
</thead>
<tbody><tr>
<td>第一代(1946-1956)</td>
<td>电子管计算机</td>
<td>电子管</td>
<td>水银延迟线、磁鼓、纸袋、卡片</td>
<td>机器、汇编语言</td>
<td>科学计算</td>
</tr>
<tr>
<td><strong>第二代(1956-1964)</strong></td>
<td>晶体管计算机</td>
<td>晶体管</td>
<td><strong>磁芯磁盘磁带</strong></td>
<td><strong>高</strong>级程序设计语言</td>
<td>数据处理</td>
</tr>
<tr>
<td>第三代(1964-1971)</td>
<td>中、小集成电路计算机</td>
<td>集电路</td>
<td>半导体</td>
<td><strong>操作系统</strong>会话语言</td>
<td>各个领域</td>
</tr>
<tr>
<td>第四代(1971-至今)</td>
<td><strong>大规模或超大规模集成电路</strong>计算机[微型计算机]</td>
<td>超集路</td>
<td>高度集成半导体(微处理器为核心的微型计算机)</td>
<td>面向对象设计语言</td>
<td>网络时代</td>
</tr>
<tr>
<td>新一代计算机</td>
<td>未来计算机</td>
<td>量光子</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="计算机特点及分类"><a href="#计算机特点及分类" class="headerlink" title="计算机特点及分类"></a>计算机特点及分类</h4><ul>
<li>计算机特点<ul>
<li>运算速度快</li>
<li>计算精度高</li>
<li>存储容量大</li>
<li>具有逻辑判断能力</li>
<li>工作自动化</li>
<li>通用性强</li>
</ul>
</li>
<li>计算机分类<ul>
<li>根据<span style = "color : red"><strong>处理的对象</strong></span>划分【你的对象是个<strong>魔术混合鸡</strong>】<ul>
<li><strong>模拟计算机：</strong>处理模拟数据，速度快但不精确，通用性差</li>
<li><strong>数字计算机：</strong>处理数字数据，精度高，存储容量大，通用性强</li>
<li><strong>混合计算机：</strong>处理数学数据和模拟数据</li>
</ul>
</li>
<li>根据<span style = "color : red"><strong>计算机的用途</strong></span>划分【专通】<ul>
<li><strong>通用计算机</strong>[家用]：解决一般问题，实用性强，如科学计算、数据处理和过程控制</li>
<li><strong>专用计算机</strong>：用于解决某一特定方面的问题，配有专门开发的软件和硬件，用于<u>自动化控制、工业仪表和军事领域</u></li>
<li>以应用为中心，软件代码小，高度自动化，响应速度快</li>
</ul>
</li>
<li>根据<span style = "color : red"><strong>计算机的规模</strong></span>划分<ul>
<li>巨型机：超级计算机，常用数值计算<ul>
<li>特点：运算速度快、存储容量大结构复杂，价格昂贵</li>
<li>应用领域：气象、军事、航空航天</li>
</ul>
</li>
<li>大型机：金融、证券等大中型企业数据处理或网络服务器</li>
<li>小型机：中小企业、学校等</li>
<li>微型机：个人计算机PC，主要用在办公和家庭，是目前发展最快，应用最广泛的一种计算机，**<u>运算速度快，计算精度高，记忆能力强，存储能量大，具有逻辑判断能力，数据化程度高</u>。体积小，价格便宜，软件丰富，功能齐全**</li>
<li>工作站：具有较强的数据运算以及图像处理能力，配备多个CPU和高分辨率的大屏幕，主要面向专业应用领域：工程计算、动画制作、科学研究、软件开发、模拟仿真等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="计算机的应用领域"><a href="#计算机的应用领域" class="headerlink" title="计算机的应用领域"></a>计算机的应用领域</h4><ul>
<li><strong><u>科学计算</u><strong>：科学和工程中的</strong><u>数值计算，天气预报、军事国防、航空航天</u></strong><br><em>世界上第一代电子计算机主要用于<strong>科学计算</strong></em></li>
<li><strong><u>信息管理</u><strong>：以计算机基础对大量数据进行加工处理，形成有用的信息，是非数值形式的数据处理，广泛应用于</strong><u>办公自动化、事物处理</u><em>*等<br>*计算机应用最广泛的领域是**信息管理</em></strong></li>
<li><strong><u>过程控制</u><strong>：用计算机及时采集监测数据，按最佳值迅速对控制对象进行自动控制或自动调节，广泛应用在</strong><u>冶金，石油，化工，水电，机械和航天等部门</u></strong></li>
<li>人工智能</li>
<li>计算机网络与通信</li>
<li><strong>计算机辅助系统</strong><ul>
<li><u><strong>CAD计算机辅助设计</strong></u> [Computer Assisted Design]</li>
<li><strong>CAA计算辅助分析</strong> [Computer Assisted Analysis]</li>
<li><u><strong>CAM计算机辅助制造</strong></u> [Computer Assisted Manufacturing]</li>
<li>&#x3D;&#x3D;<u><strong>CBE计算机辅助教育</strong></u> [Computer Based Education]&#x3D;&#x3D;</li>
<li><u><strong>CAI计算机辅助教学</strong></u> [Computer Assisted Instruction<del>指导</del>]</li>
<li><strong>CMI计算机管理教学</strong> [Computer management Instruction<del>指导</del>]</li>
<li><strong>CAT计算机辅助测试</strong> [Computer Assisted Testing]</li>
<li><u><strong>CIMS计算机集成制造系统</strong></u> [Computer Integrated Manufacturing System]</li>
</ul>
</li>
<li>人工智能：AI又称机器智能，主要研究智能机器所执行的通常与人类有关的功能：判断-推理<ul>
<li>考点：人工智能不可能取代人类</li>
</ul>
</li>
<li>计算机网络域通信</li>
<li>多媒体技术应用系统</li>
<li>嵌入式系统：以应用为中心，以计算机技术为基础，软硬件灵活变化以适应所嵌入的应用系统，用于专用计算机系统中，主要用于军事和航空航天，逐步适用于工业控制、仪器仪表</li>
</ul>
<h4 id="计算机发展趋势-居委-会-网之多"><a href="#计算机发展趋势-居委-会-网之多" class="headerlink" title="计算机发展趋势(居委[会]网之多)"></a>计算机发展趋势(<u>居委[会]网之多</u>)</h4><ul>
<li><strong>巨型化</strong>：功能上的超级计算机</li>
<li><strong>微型化</strong>：体积上的可穿戴式设备</li>
<li><strong>网络化</strong>：计算机网络</li>
<li><strong>智能化</strong>：具有模拟人的感觉和思维过程的能力，人工智能</li>
<li><strong>多媒体化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E8%AE%BA1.jpg"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E8%AE%BA2.jpg" style="zoom:170%;" />

<hr>
<hr>
<h1 id="进制及进制转换"><a href="#进制及进制转换" class="headerlink" title="进制及进制转换"></a>进制及进制转换</h1><ul>
<li><p>进制的概念：用进位的原则进行计数成为进位计数制，简称进制</p>
</li>
<li><p>和进制有关的概念(**十进制 **&#x3D;&gt; <span style = "color : red"><strong>D</strong></span>)</p>
<ul>
<li>**<u>数码</u>**：一组来表示某种数制的符号，比如二进制的0和1</li>
<li><strong>基数</strong>：数制所使用的数码个数，常用R表示，称为R进制<ul>
<li><strong>R&#x3D;10</strong>，最小值0 ~ 最大值R-1</li>
</ul>
</li>
<li><strong>位权</strong>：数码在不同位置上的权值(123 &#x3D; &gt; 1×10^3-1^ +  2×10^2-1^ + 3×10^1-1^ )</li>
<li>逢十进1 借一当十</li>
<li>写法格式：238D(十进制)</li>
</ul>
</li>
<li><p>(<strong>二进制</strong> &#x3D;&gt; <span style = "color : red"><strong>B</strong></span>）</p>
<ul>
<li>数码：0,1</li>
<li>基数：R&#x3D;2</li>
<li>位权：1,2,4,8,16,32,64,128,256,512,1024…</li>
<li>运算规则：逢2进1，借1当2</li>
<li>写法格式：101B或(101)$_2$</li>
<li>《易经》八卦，莱布尼兹二进制，布尔，香农，冯·诺依曼</li>
<li>优点：电路简单，容易物理实现；工作稳定可靠；二进制运算简单；逻辑性强</li>
</ul>
</li>
<li><p>(<strong>八进制</strong> &#x3D;&gt; <span style = "color : red"><strong>O,8</strong></span>)</p>
<ul>
<li>数码：0 ~ 8-1进制</li>
<li>基数：R&#x3D;8</li>
<li>位权：R^n-1^,1，8,64……</li>
<li>写法格式：207O或者(207)$_8$</li>
<li>运算规则：逢8进1，借1当8</li>
</ul>
</li>
<li><p>(<strong>十六进制</strong> &#x3D;&gt; <span style = "color : red"><strong>H</strong></span>)</p>
<ul>
<li>数码：0 ~ 16-1进制(<strong>0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</strong>)</li>
<li>基数：R&#x3D;16</li>
<li>位权：1,16,256…</li>
<li>写法举例：AB7<strong>H</strong>  或 12(B)^16^</li>
<li>运算规则：逢16进1(1 + F &#x3D; 1 + 15 &#x3D; 10)，借1当16</li>
</ul>
<p>(1<strong>A</strong> + 1 &#x3D; 1<strong>B</strong>)、(<em>1</em>A<strong>H</strong> &#x3D; <em><strong>1×16^1^</strong></em> + A×16^0^ &#x3D; 16+10 &#x3D; 26<strong>D</strong>)</p>
<p><strong><u>10进制的一零是10，8进制的一零是8，2进制的一零是2，16进制的一零是16</u></strong></p>
</li>
<li><p><strong>进制转换</strong></p>
<ul>
<li><strong><u><em>任意进制转十进制</em></u></strong> ：按位权展开，再按照十进制的计算规则计算</li>
</ul>
<p>111.1B &#x3D; 1×2^2^+1×2^1^+1×2^0^+<strong>1×2^-1^</strong>  </p>
<p><em>1</em>FC.4H &#x3D; <em><strong>1×16^2^</strong></em>+15×16^1^+12×16^0^+<strong>4×16^-1^</strong> &#x3D; 508.25<strong>D</strong></p>
<ul>
<li><strong>十进制转任意进制</strong><ul>
<li>整数部分：除基取余倒着连</li>
<li>小数部分：乘基取整顺着连(<strong>若取出后需要减去，直到小数部分乘尽</strong>)</li>
<li>注意“乘不尽”现象，一般题目会告知精确到几位(<strong>十进制</strong>都能精确的转换为<strong>二进制</strong> <strong>×</strong>‘可能乘积乘不尽’)</li>
<li><strong>十进制四舍五入、八进制三舍四入、十六进制七舍八入</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9a911e35e774154ba112f1c2197bbbbbfc4c9ab8/data/2%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.jpg"> </p>
<ul>
<li><strong>十进制转十六进制</strong><ul>
<li>十进制47.6875转十六进制是(2F,BH) <u>转换方法同上↑</u></li>
</ul>
</li>
<li>二、八、十六进制互相转换</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8b6a4243a03095d265f136f772786718e3f5e77d/data/%E8%BF%9B%E5%88%B6%E4%BA%92%E8%BD%AC%E8%A7%84%E5%88%99.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a82aa729176ac2f92a055ba9184c3fff557d839c/data/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E7%AE%97%E6%9C%AF%2B%E9%80%BB%E8%BE%91%E8%A7%84%E5%88%99.jpg"></p>
<ul>
<li><h3 id="进制转换练习题"><a href="#进制转换练习题" class="headerlink" title="进制转换练习题"></a>进制转换练习题</h3></li>
</ul>
<p>快速转换<br>@@ 字符的ASCII码十进制值为71，则其十六进制为( )<br>快速根据位权凑：$16^2$&#x3D;256     $16^1$&#x3D;16    $16^0$&#x3D;1<br>71＜256 ∴肯定有2个16进制的位权就够了 __ __  ∴ <u>4 7</u> &#x3D;&gt;$16^4$ + $16^7$ &#x3D; 64 + 7 &#x3D; 71</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/32832db491b9212f3132f9b7c2e7aee87a4f47e5/data/%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E8%BF%9B%E5%88%B6%E6%8A%80%E5%B7%A7.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/47a8d1f56be7fecb6833e7148e70968577f02204/data/%E9%AB%98%E7%BA%A7%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%A2%98.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eaccfed61d8a5a83b4da683a3fee7117a81c6d2d/data/4d459561b6dd1971bd06999a6e1cf64.jpg"></p>
<ul>
<li><p><strong>异或运算口诀</strong>：<u><strong>相同为0，不同为1</strong></u></p>
</li>
<li><p><span style = "color : red">8 4 2 1 ($_2$)      49 7 1($_7$) <strong>熟悉后也可以套位权 或 短除法</strong></span></p>
</li>
<li><p>任何数转十进制都是<strong>位权展开</strong></p>
</li>
<li><p>对于R进制来说，每一位上可以有 (<u>R</u>) 种可能，二进制每一位有0和1两种可能，十进制数每一位可以有0~9十种可能</p>
</li>
<li><p>8000 - 1 &#x3D; 7FFF(借1当16【<strong>F</strong>】)</p>
</li>
<li><p>有的十进制小数不能精确转换为二进制小数**(√)  比如：0.2**</p>
</li>
<li><p>1GB &#x3D; 2^10^MB，1MB &#x3D; 2^10^KB </p>
</li>
<li><p><strong>8000H &#x3D; 8×16^3^D</strong></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/P-luminary/images/e19e77d06a65b96da637bf8ec0f976691104f336/data/%E8%BF%9B%E5%88%B6%E9%A2%981.jpg"></p>
</li>
</ul>
<h3 id="数据存储单位及计算机中数值的表示"><a href="#数据存储单位及计算机中数值的表示" class="headerlink" title="数据存储单位及计算机中数值的表示"></a>数据存储单位及计算机中数值的表示</h3><h4 id="数据存储单位换算"><a href="#数据存储单位换算" class="headerlink" title="数据存储单位换算"></a>数据存储单位换算</h4><p>计算机中的数据都要占用不同的二进制位，为了便于表示数据量的多少，引入数据单位的概念</p>
<ul>
<li><p><strong>位</strong>(bit [binary digit的缩写])，也称为比特，简记为b，是计算机存储数据的最小单位</p>
<ul>
<li>一个二进制位只能表示0或1，要想表示更大的数，就要把更多的位组合起来，每增加一位，所能表示的数就增大一倍。</li>
<li>带宽，传输速率，Mbps兆位每秒 100Mbps(100兆字节，1个字节等于8位) &#x3D;&gt; 除8 &#x3D; 12.5</li>
</ul>
</li>
<li><p><strong>字节</strong>(Byte，简记为B，1B&#x3D;8bit，计算机存储数据的基本单位)</p>
<ul>
<li>微机的存储器是由一个存储单元构成的，每个存储单元大小就是一个字节，所以存储容器大小也是以字节数衡量</li>
<li><span style = "color : red">单位换算(b→1bit，1B &#x3D; 8b)</span><ul>
<li>1<strong>Bytes</strong> &#x3D; 8bit</li>
<li>1KB&#x3D;$2^{10}B$&#x3D;$$1024B$$</li>
<li>1MB&#x3D;$2^{10}KB$&#x3D;$$1024KB$$&#x3D;$2^{20}B$</li>
<li>1GB&#x3D;$2^{10}MB$&#x3D;$$1024MB$$&#x3D;$2^{30}B$</li>
<li>1TB&#x3D;$$2^{10}GB$$&#x3D;$$1024GB$$&#x3D;$$2^{40}B$$</li>
<li>1PB&#x3D;$$1024TB$$</li>
<li>b B kb MB GB TB PB</li>
<li>硬盘生产商是以1GB&#x3D;1000MB标注的，计算机内部是1GB&#x3D;1024MB</li>
</ul>
</li>
</ul>
<p>@@ <u>1KB等于1000个比特 (×)</u></p>
</li>
<li><p><strong>字</strong>(<strong>Word，计算机处理数据时，<u>CPU通过数据总线一次存取、加工和传送的数据称为字</u></strong>)</p>
<ul>
<li><strong>字长，计算机的运算部件能同时处理的二进制数据的位数称为字长，1个字位数就是字长</strong></li>
<li>字长是衡量计算机<strong>性能</strong>的一个重要指标，&#x3D;&#x3D;<strong>字长越长，速度越快，精度越高</strong>&#x3D;&#x3D;</li>
<li>不同微处理器的字节是不同的，常见的微处理器字长由8位、16位、32位和64位</li>
<li><strong>“64位的电脑”是指计算机CPU字长是64位</strong></li>
<li>63位字长的CPU必须配合支持64位的软件才能达到最佳效果，字长的性能受软件系统的约束</li>
</ul>
</li>
</ul>
<h4 id="计算机中数值的表示—整数-定点数"><a href="#计算机中数值的表示—整数-定点数" class="headerlink" title="计算机中数值的表示—整数(定点数)"></a>计算机中数值的表示—整数(定点数)</h4><h5 id="数值在计算机中如何表示和计算？"><a href="#数值在计算机中如何表示和计算？" class="headerlink" title="数值在计算机中如何表示和计算？"></a>数值在计算机中如何表示和计算？</h5><p>1、数值分为：整数 + 小数</p>
<p>2、计算机中要解决整数和小数在计算机中如何表示的问题—<strong>原码、反码、补码</strong></p>
<p>3、计算机要解决编码后的数值如何进行计算的问题—<strong>补码</strong></p>
<p>定位数：小数点的位置固定，如996.007 —常规计数</p>
<p>浮点数：小数点的位置不固定，如9.96007*$10^2$ —科学计数法</p>
<ul>
<li><span style = "color : red"><strong>无符号数</strong></span>(整个机器字长的全部二进制位均表示数值位，不存在符号位)</li>
</ul>
<p>表示范围：如—&gt; 8位二进制数，有$2^8$种状态</p>
<p><u>0000 0000 ~ 1111 1111</u></p>
<p>​                0 ~ 255 &#x3D; $2^8-1$</p>
<p><span style = "color : blue"><strong>n位无符号整数表达范围是：0 ~ $2^n-1$</strong>    [注意：下面的是有<strong>原码</strong>的前提]</span></p>
<p>@@ 能用<strong>8</strong>位无符号二进制数表示的是(199) ∵ 0 ~ $2^8-1$ &#x3D;&gt; <strong>0 ~ 255</strong> </p>
<p>@@ 表示0<del>512范围内的无符号整数，需要的二进制位数至少是(<strong>10</strong>) ∵ n&#x3D;9时 <u>0</del>(512-1)</u></p>
<ul>
<li><p><strong>有符号数</strong>(把符号位数值化了的数称为机器数。最高位表示符号位，0表示正，1表示负，其余位是数值位)</p>
<p>&#x3D;&#x3D;最高位<strong>0表示正</strong>，最高位<strong>1表示负</strong>&#x3D;&#x3D;</p>
<p>+9 &#x3D; **<span style = "color : red">0</span>**000 1001 &#x3D;&gt; +0001001</p>
<p>-9 &#x3D;  **<span style = "color : red">1</span>**000 1001 &#x3D;&gt; -0001001</p>
<ul>
<li>机器数代表的数字，称为<strong>真值</strong></li>
<li><span style = "color : red">考点：原码、反码、补码的相互转换</span></li>
<li><span style = "color : red">计算机是采用补码形式数值存储和数值运算的</span></li>
<li><span style = "color : red">表示范围</span></li>
</ul>
</li>
</ul>
<h4 id="2、原码、反码、补码及其相互转换"><a href="#2、原码、反码、补码及其相互转换" class="headerlink" title="2、原码、反码、补码及其相互转换"></a>2、原码、反码、补码及其相互转换</h4><ul>
<li><p><em>负数</em></p>
<ul>
<li><p><strong>原码</strong></p>
<ul>
<li>+9 &#x3D; **<span style = "color : red">0</span>**000 1001</li>
<li>-9 &#x3D;  **<span style = "color : red">1</span>**000 1001 </li>
<li>Min → 1111 1111 &#x3D; —127    </li>
<li>Max → 0111 1111 &#x3D; +127</li>
<li>缺点：0有两种表示方式：+0&#x3D;00000000    -0&#x3D;10000000[零的二义性给机器判断带来了麻烦] ****</li>
<li><strong><span style = "color : orange">原码的数值0有两种表示方式 +0 -0</span></strong></li>
</ul>
<p>比如：1-2&#x3D;-3 → ∵ +1+(-2) → +1 -&gt; 0000 000$1_原$  ;  -2 -&gt; 1000 001$0_原$  </p>
<p>∴ 0000 0001 + 1000 0010 &#x3D; 1000 001$1_原$ &#x3D; -3</p>
<p>为了解决这个问题，科学家使用补码</p>
<p>-33的原码是 *<u><strong>1</strong>010 0001</u>* 反码是 <u><strong>1</strong>101 1110</u></p>
</li>
<li><p><strong>反码</strong></p>
<ul>
<li>原码的符号位不变，其余位取相反得到 </li>
<li>反码存在的意义就是为了由原码计算补码方便</li>
</ul>
</li>
<li><p><strong>补码</strong></p>
<ul>
<li>反码+1得到</li>
<li>优点</li>
</ul>
<p>1、<span style = "color : orange"><strong>在补码表示中，0有唯一的编码</strong> </span>0 &#x3D; 0000 0000</p>
<p>2、用10000000表示 -128，比原码可多表示一个编码</p>
<p>3、利用补码可以方便地进行运算</p>
<ul>
<li><strong>补码适合运算，解决了计算机减法的问题</strong>    例如 +1-2&#x3D;?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/cc1dad3239ab71c96619abccf4e76a649f54cd21/data/%E8%B4%9F%E6%95%B0%E7%9A%84%E5%8E%9F%E3%80%81%E5%8F%8D%E3%80%81%E8%A1%A5%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.jpg"></p>
<ul>
<li><em>正数</em><ul>
<li><strong>原码&#x3D;反码&#x3D;补码</strong></li>
</ul>
</li>
</ul>
<p>补码进行 <strong>加法</strong> 运算：<u>符号位</u><strong>参与运算</strong></p>
<p>☆☆ <strong><span style = "color : green">正数：正数的原码、反码、补码都一样</span></strong> ☆☆</p>
<p>☆☆ <strong><span style = "color : green">负数：负数将原码的符号位保持不变，数值位各位取反再末位加1，就可以将原码转换为补码</span></strong> ☆☆</p>
<p>@@ 机器中用数值表示的是<strong>原码+反码+补码</strong>，ASCII码西文字符：abcd…</p>
<p>@@ <span style = "color : red">1000 100$1_原$ → 1111 011$0_反$ → 1111 011$1_补$</span></p>
<p>@@ <u>求1-2的原码是</u>：1000 000$1_原$ </p>
<p>​    +1 &#x3D; 0000 000$1_原$ &#x3D; 0000 000$1_补$</p>
<p>​    +2 &#x3D; 1000 001$0_原$ &#x3D; 1111 110$1_反$ &#x3D; 1111 111$0_补$</p>
<p>0000 000$1_补$ +  1111 111$0_补$ &#x3D;<strong><span style = "color : red">1</span></strong> 1111 111$1_补$  <u>“最前面的溢出数**’1’**进行舍弃”</u></p>
<p>1111 111$1_补$  &#x3D; 1111 111$0_反$ &#x3D; 1000 000$1_原$ &#x3D; -1</p>
<p>@@ 在计算机内部，机器数(<u>原码、反码、补码</u>)的最高位为1表示该数为负数 (√)</p>
<p>最高位<strong>0表示正</strong>，最高位<strong>1表示负</strong></p>
<p>@@ 8位二进制数值编码中，十进制“**-**9”的原码是(<strong>1</strong>000 1001)</p>
<p>@@   -2 -&gt; 1000 001$0_原$  &#x3D;  1111 110$1_反$ &#x3D; 1111 111$0_补$ &#x3D;&gt; 255 - 1 &#x3D; 254</p>
<p>所以！！！ -2 也 意味着等于 +254</p>
<p>@@ 负数-5在计算机中的补码是 ？</p>
<p><u><em><strong>直接从原码变补码、补码变原码</strong></em></u>  <span style = "color : red"><strong>口诀：从右向左复制，直到有1被赋值 其余取相反(<u>符号位 &#x3D;&gt; 第一位不变</u>)</strong></span></p>
<p>-5 &#x3D; 1000 010$1_原$  &#x3D; 1111 101$1_补$</p>
<h3 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a><strong>表示范围</strong></h3><ul>
<li><span style = "color : blue">原码和反码   <strong>-2$^{(n-1)}+1$  ~  +2$^{(n-1)}-1$</strong></span><ul>
<li>1B 原码反码范围[-127, +127]</li>
<li>2B 原码反码范围是[-32767, +32767]</li>
</ul>
</li>
<li><span style = "color : blue">补码               <strong>-2$^{(n-1)}$  ~  +2$^{(n-1)}-1$</strong></span><ul>
<li>1B 补码范围[-128, +127]</li>
<li>2B 补码范围[-32768, +32767]</li>
</ul>
</li>
</ul>
<p>用<strong>原码</strong>表示的<strong>7</strong>位有符号二进制整数的取值范围是(<strong>-63 — +63</strong>)  <strong>-2$^{(n-1)}+1$  ~  +2$^{(n-1)}-1$</strong></p>
<h4 id="3、浮点数"><a href="#3、浮点数" class="headerlink" title="3、浮点数"></a>3、浮点数</h4><ul>
<li>浮点数<ul>
<li>[组成]<ul>
<li>阶码：用定点整数表示，阶码的位数确定了数的范围</li>
<li>数符(+-)：占1位</li>
<li>基数：<strong>基数是隐含的</strong></li>
<li>尾数：小数点右边的位[用定点小数表示；尾数所占的位数确定了位的精度；规定尾数的最高位为1，通过阶码来调整]</li>
</ul>
</li>
<li>[分类]<ul>
<li>单精度浮点数：占32位，26.5作为单精度浮点数在计算机中的表示</li>
<li>双精度浮点数：占64位</li>
<li>考点：双精度浮点数表示的数的范围和精度比单精度浮点数大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@@ 计算机中，<u>浮点数</u>由两部分组成，它们是(<strong>阶码部分 和 尾数部分</strong>)</p>
<p>@@ 浮点数之所以能表示很大或很小的数，是因为使用了(<strong>阶码</strong> -&gt; 科学计数法)</p>
<p>@@ 在浮点数中，尾数的位数确定了位的精度，阶码的位数确定了数的范围。</p>
<p>@@ 用4个字节表示的浮点数<u>11111110</u>&#x3D;&gt; 2$^{—??} $[2的负多少次方]    <u>11010000 00000000 00000000</u>&#x3D;&gt; —______[负的多少]  ∴<strong>阶码和尾数都为负</strong></p>
<ul>
<li><u>0.110101[尾数]</u> × $2^{+5}[阶码]$</li>
</ul>
<h4 id="4、BCD码"><a href="#4、BCD码" class="headerlink" title="4、BCD码"></a>4、BCD码</h4><p>二进制：0，1       —计算机采用的方式</p>
<p>十进制：0,1,2,3,4,5,6,7,8,9         —科学计数法</p>
<p>BCD码：一 一对应，快速转换，且精确</p>
<h3 id="8421-BCD码映射关系"><a href="#8421-BCD码映射关系" class="headerlink" title="8421 BCD码映射关系"></a>8421 BCD码映射关系</h3><table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0000</td>
<td align="center">0001</td>
<td align="center">0010</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">0110</td>
<td align="center">0111</td>
<td align="center">1000</td>
<td align="center">1001</td>
</tr>
</tbody></table>
<p>十进制：    5        +        8        &#x3D;        13            +0110(加6修正)</p>
<p>8421码:   0101            1000    &#x3D;      1101</p>
<hr>
<p>@@ BCD又称为2-10码，是利用四位二进制数表示一位十进制数</p>
<p>@@ 在浮点表示方法中，<strong>基数</strong>是隐含的</p>
<p>@@ 原码的数值0有两种表达方式，补码的数值0有一种表达方式</p>
<p>@@ **[负数]**将原码的符号位保持不变，数值位各位取反再末位加1，就可以将原码转换为补码(前提要说明是正负数[正数是一样的])</p>
<p>@@ 用原码表示的7位有符号二进制整数的取值范围是(-63 ~ +63) [最小是111 1111B；最大是011 1111B]</p>
<p>@@ X&#x3D;(-1000101)2的反码表示&#x3D;&gt; <strong>10111010</strong> [最高位符号位 用1表示负数] [<u><em><strong>直接从原码变补码、补码变原码</strong></em></u>  <span style = "color : red"><strong>口诀：从右向左复制，直到有1被赋值 其余取相反(符号位 &#x3D;&gt; 第一位不变)</strong></span>]</p>
<p>@@ 若某带符号整数的8位二进制补码为 11110001，则该整数对应的十进制数是( 1000 1111 &#x3D; &gt; 注意第一个1是负号！！不要算入数字总和**-15**)    只有原码才可以转十进制 </p>
<p>@@ 最高位可溢出！！ 若8位进制数 结果出来了9位，最高一位溢出省略</p>
<p>@@ <strong><u>内存单元 &#x3D;&gt; 补码</u></strong> <span style = "color : blue"><u>原码和反码</u>   <strong>-2$^{(n-1)}+1$  ~  +2$^{(n-1)}-1$</strong></span>      <span style = "color : blue"><u>补码</u>               <strong>-2$^{(n-1)}$  ~  +2$^{(n-1)}-1$</strong></span></p>
<p>@@ 在用<u><strong>原码</strong>表示整数“0”时，有“000…00” 和 “1000…00”两种表示形式</u>，而<u>在<strong>补码</strong>表示法中，整数”0”只有一种表示形式</u></p>
<p>@@ 通常对一个整数的补码求补码，就会得到该数的原码</p>
<p>@@ <span style = "color : red">正数的 <strong><u>原码&#x3D;反码&#x3D;补码</u></strong></span></p>
<p>@@ “64位计算机”是指计算机的<strong>字长</strong>其越长，计算机运算精度越高</p>
<hr>
<hr>
<h1 id="西文字符在计算机中的表示—ASCII码"><a href="#西文字符在计算机中的表示—ASCII码" class="headerlink" title="西文字符在计算机中的表示—ASCII码"></a>西文字符在计算机中的表示—ASCII码</h1><h3 id="7位码-标准ASCII码-美国标准信息交换代码"><a href="#7位码-标准ASCII码-美国标准信息交换代码" class="headerlink" title="(7位码)标准ASCII码 (美国标准信息交换代码)"></a>(7位码)标准ASCII码 (<u>美国标准信息交换代码</u>)</h3><p><u><strong>American Standard Code for Information Interchange</strong></u></p>
<p>概念：ASCII是国际通用的信息交换标准代码</p>
<p>范围：从0000 0000B到0111 1111B共可表示<strong>128个字符</strong> 【0-127】 <u>最高位是0的128个</u></p>
<h5 id="存储：7位ASCII码，存储占1个字符，实际使用7位，最高位为0"><a href="#存储：7位ASCII码，存储占1个字符，实际使用7位，最高位为0" class="headerlink" title="存储：7位ASCII码，存储占1个字符，实际使用7位，最高位为0"></a>存储：7位ASCII码，存储占1个字符，实际使用7位，最高位为0</h5><h5 id="可打印-不是所有ASCII字符都可以打印的，-x3D-x3D-控制字符不是打印字符-x3D-x3D"><a href="#可打印-不是所有ASCII字符都可以打印的，-x3D-x3D-控制字符不是打印字符-x3D-x3D" class="headerlink" title="可打印 [不是所有ASCII字符都可以打印的，&#x3D;&#x3D;控制字符不是打印字符&#x3D;&#x3D;]"></a>可打印 [<u>不是所有ASCII字符都可以打印的，&#x3D;&#x3D;控制字符不是打印字符&#x3D;&#x3D;</u>]</h5><p><u>[控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等]</u></p>
<h5 id="标准ASCII码比较规律"><a href="#标准ASCII码比较规律" class="headerlink" title="标准ASCII码比较规律"></a>标准ASCII码比较规律</h5><ul>
<li>数字字符(0-9)、大写字母(A-Z)、小写字母(a-z)分别连续编码</li>
<li>空格符       32D (20H)</li>
<li>数字字符0 48D (30H)</li>
<li>数字字符9 57D (39H)</li>
<li>大写数字A 65D (41H)</li>
<li>小写数字a 97D (61H)</li>
<li>控制字符 &lt; 打印字符     </li>
<li>小写英文字母的编码-大写英文字母的编码&#x3D;32</li>
</ul>
<h5 id="标准ASCII码表"><a href="#标准ASCII码表" class="headerlink" title="标准ASCII码表"></a>标准ASCII码表</h5><p>**<span style = "color : red">【65 A    97 a    48 0】</span>**如果你要遛我(A&#x3D;&gt;65)就去(a&#x3D;&gt;97)死吧(0&#x3D;&gt;48)</p>
<p><u>竖着＋横着 &#x3D; 二进制</u> </p>
<p><u>1字节 &#x3D; 8bit</u>    <u>1KB &#x3D; 1024 * 8bit</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/46ce555c8849ef651ffbf1e841a1f1b366c11144/data/ASCII%E8%A1%A8.jpg"></p>
<h3 id="8位码-扩展ASCII码-最高位是1-扩展码-x2F-汉字-需要连续两个开头1"><a href="#8位码-扩展ASCII码-最高位是1-扩展码-x2F-汉字-需要连续两个开头1" class="headerlink" title="(8位码)扩展ASCII码[最高位是1 扩展码&#x2F;汉字(需要连续两个开头1)]"></a>(8位码)扩展ASCII码[最高位是1 扩展码&#x2F;汉字(需要连续两个开头1)]</h3><p>8位ASCII码，占用1个字节，最高位为1</p>
<p>范围：使用1000 0000B ~ 1111 1111B，表示其他的西文字符 <u>最高位是1的128个</u></p>
<p><strong>中文字符最高位也是1，扩展ASCII和GB2312-80的区别在于中文字符是两个连续字节最高位都是1</strong></p>
<hr>
<p>@@ 在ASCII码中，存储5个西文字符的编码需要<strong>5</strong>个字节。 每一个编码占用1个字节</p>
<p>@@ 一个ASCII码在计算机中占用1个字节</p>
<p>&#x3D;&#x3D;@@ 键盘上每个按键对应<strong>唯一</strong>的一个ASCII码 <strong>(×)</strong>&#x3D;&#x3D;</p>
<p>@@ 先高四位编码，后低四位编码。已知一个数在ASCII码表中的坐标是(2,4)，则其ASCII值为(66 -&gt; B)</p>
<p><strong>2 &#x3D;&gt; 0010    4 &#x3D;&gt; 0100           0100是高四位，0010是低四位</strong></p>
<p>@@ 采用ASCII编码，最多能表示128个字符 <strong>(×)</strong>    应该是采用<u><strong>7位的标准的</strong>ASCII编码</u></p>
<p>@@ 一个ASCII码占据<strong>1</strong>个字节</p>
<p>@@ ASCII码表中字符’C’的编码1000011，则字符’G’的编码为**<u>1000111</u>**</p>
<p>C  D  E  F  G  &#x3D;&gt; C到G &#x3D;&gt; 1000011 + 100 &#x3D; 1000111</p>
<p>1  2  3  4   5  &#x3D;&gt; 1+4&#x3D;5</p>
<p><strong><span style = "color : red">@@ 已知字母G的ASCII码对应的十六进制数为47H，则字母J的ASCII码对应的十六进制数为( )</span></strong></p>
<p>G H I J &#x3D;&gt; G到J &#x3D;&gt; 47H + 3 &#x3D; 4<strong>A</strong>H (十六进制加法 只有到了才进，不然可以用字母表示 A&#x3D;10)</p>
<p>1 2 3 4 &#x3D;&gt; 1+3&#x3D;4</p>
<p>@@ 按照ASCII码值从大到小排列顺序 <strong>小写 &gt; 大写 &gt; 数字 &gt; 空格<del>ASCII：32</del></strong></p>
<p>@@ 1个字符在存储的时候占用1个字节B</p>
<p>@@ 字符的ASCII码十进制值为71，则其十六进制为( )</p>
<p>快速根据位权凑：$16^2$&#x3D;256     $16^1$&#x3D;16    $16^0$&#x3D;1</p>
<p>71＜256 ∴肯定有2个16进制的位权就够了 __ __  ∴ <u>4 7</u> &#x3D;&gt;$16^4$ + $16^7$ &#x3D; 64 + 7 &#x3D; 71</p>
<p>@@ ASCII码表中，根据码值从小到大：<strong>空格 &lt; 0-9 &lt; 大写字母 &lt; 小写字母</strong></p>
<p>@@ ASCII码分为<strong>7位码[标准] 和8位码[扩展]</strong></p>
<p>@@ 指令与数据在计算机内是以ASCII码进行存储的 <strong>(×)</strong>    <u><strong>指令与数据在计算机内是以2进制数存储的</strong></u></p>
<p>@@ 二进制数0011 1001，若它为ASCII码[<u><strong>十进制值为</strong>：57；<strong>表示</strong>的(<em>字符</em> )十进制为：9</u>]</p>
<p>@@ 标准ASCII码可表示128个不同的字符，其中不可打印<del>控制符</del>字符{不可显示}有(<strong>33</strong>)个，可打印字符(<strong>95</strong>)个</p>
<p>@@ 根据ASCII编码原理，现在要对50个字符进行编码[表示]，至少需要(<strong>6</strong>)个二进制位 </p>
<p>解：$2^n$ ≥ 50 解得 n &#x3D; 6。<strong>存储</strong>50个字符，需要50个<strong>字节</strong> [存50条电话，需要50个位置]</p>
<p>@@ 在计算机中一个<strong>字节</strong>可以表示( <u>2位十六进制数、一个ASCII码、256种状态</u> )</p>
<p>2位十六进制数：00 ~ FF &#x3D;&gt; 0000 0000 ~ 1111 1111 </p>
<p> <strong>一个字节表示0~255</strong> ：这个简单首先理解到在内存中数据是用十六进制保存的 也就是说 00-FF </p>
<p>00转成十进制就是 0    FF转成十进制就是 255    所以就是 0-255</p>
<p>@@ 用ASCII 码可以表示汉字 <strong>(×)</strong> <u>它是表示西文字符的</u></p>
<blockquote>
<p>一个汉字在计算机中占两个字节的位置 西文字符中的ASCII码表示西文字符是，用的是7位的ASCII码，为了在计算机中存储，最高位（第八位）默认为0，所以可以表示2的7次方个不同的字符；扩展的ASCII码，使用的第八位，不在默认为0，所以最多可以表示2的8次方个字符</p>
</blockquote>
<p>@@ 按照ASCII码编码规则，数字符号’0’ - ‘9’的编码值为 <strong>十六进制数30-39</strong></p>
<p>‘0’ ~ ‘9’ &#x3D;&gt; 48 ~ 57 &#x3D;&gt; 30H ~ 39H</p>
<p>@@ 世界上使用最普遍的字符编码是(ASCII)码，在西文字符中使用最普遍的是(标准ASCII)码</p>
<hr>
<h1 id="中文字符在计算机中的表示"><a href="#中文字符在计算机中的表示" class="headerlink" title="中文字符在计算机中的表示"></a>中文字符在计算机中的表示</h1><p>汉字编码：采用一种科学可行的方法，为每个汉字编写一个唯一的代码，以便计算机辨认、接收和处理。</p>
<p>中文字符处理的基本流程：<strong>输入码 → 交换码 → 机内码 → 地址码 → 输出码</strong></p>
<h4 id="汉字的编码："><a href="#汉字的编码：" class="headerlink" title="汉字的编码："></a>汉字的编码：</h4><ul>
<li><strong>音码</strong>：主要以汉语拼音为基础的编码方案 如：<u>微软拼音、搜狗拼音</u>；特点：重码多、单字输入慢，掌握容易</li>
<li><strong>形码</strong>：根据汉字的字形进行的编码 如：<u>五笔字型</u>；特点：重码少，单字输入比较快，但学习和掌握困难</li>
<li><strong>音形结合码</strong>：自然码；特点：将音形结合起来，减少重码率，提高输入速度</li>
<li><strong>流水码</strong>：区位码输入法  区位码输入法是一字一码，优点是无重码</li>
</ul>
<h4 id="输入码-外码-：-特点"><a href="#输入码-外码-：-特点" class="headerlink" title="输入码(外码)：[特点]"></a>输入码(外码)：[特点]</h4><ul>
<li>利用键盘输入汉字时对汉字的编码</li>
<li>输入码不是唯一的，因为有音码、形码、音形结合码等不同的输入码</li>
</ul>
<h4 id="机内码：-GB2312-80"><a href="#机内码：-GB2312-80" class="headerlink" title="机内码：[GB2312-80]"></a>机内码：[GB2312-80]</h4><ul>
<li>真正的计算机内部用来存储和处理汉字信息的代码</li>
</ul>
<p><strong>区码 01<del>94    国标码 2121H</del>7E7E    内码 A1A1~FEFE</strong><img src="https://raw.githubusercontent.com/P-luminary/images/de7464658d6f6af9cfc15041a87d0a2be5b45d51/data/%E5%86%85%E7%A0%81%E3%80%81%E5%9B%BD%E9%99%85%E7%A0%81%E3%80%81%E5%8C%BA%E4%BD%8D%E7%A0%81.png"></p>
<p>【十六进制】<u>国标码 &#x3D; 区位码 + 20；内码 &#x3D; 国标码 + 80；</u><u><strong>内码 &#x3D; 区位码 + 80H</strong></u> &#x3D;&gt; 十六进制的值大于A0   [<strong><u>大到小 -&gt; 内<del>+80</del>国<del>+20</del>区<del>区位码十进制要转换成十六进制</del>[从右到左] &#x3D;&gt; 内个蛆</u></strong> ]   &#x3D;&#x3D;<strong>区位码是十进制数D、国标码是十六进制H、机内码是十六进制H</strong>&#x3D;&#x3D;</p>
<p>@@ 汉字在计算机内部采用的是<strong>机内码</strong>  注意：不是国标码！！！</p>
<p>@@ 存储一个汉字的机内码需要<strong>2</strong>个字节</p>
<p>@@ 国标码GB2312-80是国家制定的<u>汉字<strong>交换码</strong></u>标准</p>
<p>@@ 五笔型输入码属于<strong>形码</strong></p>
<p>@@ 数值：补码；西文字符：ASCII码。指令和数据在计算机内部都是以<u>二进制</u>形式存储的</p>
<p>@@ 若已知一汉字的国标码是<strong>5E38H</strong>，其机内码是 <strong><u>DEB8</u></strong></p>
<p>5E + 80 &#x3D;&gt; DE    38H + 80H &#x3D;&gt; B8H </p>
<p>对于GB2312来说：<strong>当某字节的最高位为1时，必须和下一个最高位同样为1的字节结合起来代表一个汉字</strong></p>
<p>@@ <strong>[一个汉字的机内码] 汉字的编码 ≥ A1</strong>    在内存中若汉字以GB2312的内码表示，已知存储了6个字节的字符串，其十六进制内容依次为：6AH、<span style = "color : blue"><strong>B1H、D2H</strong></span>、53H、<span style = "color : blue"><strong>C8H、B4H</strong></span>，这个字符串中有**( 2 )**个汉字</p>
<p>@@ 在GB2312中，汉字的国际交换码为该汉字的<strong>区号</strong>和<strong>位号</strong>分别加32之后得到的二进制代码</p>
<p>@@ 汉字内码的每个字节的最高位是1，不同字体的字形描述信息存放在不同字库中。</p>
<h4 id="考点1：区位码是十进制数D、国标码是十六进制H、机内码是十六进制H"><a href="#考点1：区位码是十进制数D、国标码是十六进制H、机内码是十六进制H" class="headerlink" title="考点1：区位码是十进制数D、国标码是十六进制H、机内码是十六进制H"></a>考点1：区位码是十进制数D、国标码是十六进制H、机内码是十六进制H</h4><h4 id="考点2：区位码转国标码，先将区位码的高字节、低字节分别由十进制D转换为十六机制H，再分别＋20H，就是国标码H"><a href="#考点2：区位码转国标码，先将区位码的高字节、低字节分别由十进制D转换为十六机制H，再分别＋20H，就是国标码H" class="headerlink" title="考点2：区位码转国标码，先将区位码的高字节、低字节分别由十进制D转换为十六机制H，再分别＋20H，就是国标码H"></a><span style = "color : red">考点2：区位码转国标码，先将区位码的高字节、低字节分别由十进制D转换为十六机制H，再分别＋20H，就是国标码H</span></h4><h4 id="考点3：国际码转机内码，国标码的高字节、低字节分别-80H，就得到机内码"><a href="#考点3：国际码转机内码，国标码的高字节、低字节分别-80H，就得到机内码" class="headerlink" title="考点3：国际码转机内码，国标码的高字节、低字节分别+80H，就得到机内码"></a>考点3：国际码转机内码，国标码的高字节、低字节分别+80H，就得到机内码</h4><h4 id="考点4：区位码转机内码，先将区位码的高字节、低字节分别由十进制D转换为十六进制H，再分别-A0H，得到机内码"><a href="#考点4：区位码转机内码，先将区位码的高字节、低字节分别由十进制D转换为十六进制H，再分别-A0H，得到机内码" class="headerlink" title="考点4：区位码转机内码，先将区位码的高字节、低字节分别由十进制D转换为十六进制H，再分别+A0H，得到机内码"></a><span style = "color : red">考点4：区位码转机内码，先将区位码的高字节、低字节分别由十进制D转换为十六进制H，再分别+A0H，得到机内码</span></h4><table>
<thead>
<tr>
<th>汉字</th>
<th>区位码(10进制)</th>
<th>国标码(16进制)</th>
<th>机内码(16进制)</th>
</tr>
</thead>
<tbody><tr>
<td>中</td>
<td><strong>5448</strong></td>
<td>5650</td>
<td>D6D0</td>
</tr>
<tr>
<td>国</td>
<td>2590</td>
<td>397A</td>
<td><strong>B9FA</strong></td>
</tr>
<tr>
<td>梦</td>
<td>3546</td>
<td><strong>434E</strong></td>
<td>C3CE</td>
</tr>
</tbody></table>
<ul>
<li>54D -&gt; 36H + 20 &#x3D; 56H + 80 &#x3D; D6</li>
<li>48D -&gt; 30H + 20 &#x3D; 50H + 80 &#x3D; D0</li>
</ul>
<blockquote>
<p>快速转换<br>@@ 字符的ASCII码十进制值为71，则其十六进制为( )<br>快速根据位权凑：$16^2$&#x3D;256     $16^1$&#x3D;16    $16^0$&#x3D;1<br>71＜256 ∴肯定有2个16进制的位权就够了 __ __  ∴ <u>4 7</u> &#x3D;&gt;$16^4$ + $16^7$ &#x3D; 64 + 7 &#x3D; 71</p>
</blockquote>
<h2 id="GB2312-80"><a href="#GB2312-80" class="headerlink" title="GB2312-80"></a>GB2312-80</h2><h5 id="一共7445个，一级汉字3755个"><a href="#一共7445个，一级汉字3755个" class="headerlink" title="一共7445个，一级汉字3755个"></a>一共7445个，一级汉字3755个</h5><p>国际码，全称：《信息交换汉字编码字符集–基本集》</p>
<p>时间：1980年发布，1981年实施，我国第一个汉字编码字符集标准</p>
<p>区位码：全部国际汉字及符号放在94个区、每区94个位的矩阵中，区码范围是01-94、位码范围是01-94，区码和位码组合在一起，区码居高位、位码居底位，形成“区位码”</p>
<h4 id="考点1：区位码是十进制数表示的"><a href="#考点1：区位码是十进制数表示的" class="headerlink" title="考点1：区位码是十进制数表示的"></a>考点1：区位码是十进制数表示的</h4><h4 id="考点2：每个汉字或汉字字符都有唯一的区位码与之对应"><a href="#考点2：每个汉字或汉字字符都有唯一的区位码与之对应" class="headerlink" title="考点2：每个汉字或汉字字符都有唯一的区位码与之对应"></a>考点2：每个汉字或汉字字符都有唯一的区位码与之对应</h4><h4 id="考点3：区位码是两个字符，区码一个字符，位码一个字符"><a href="#考点3：区位码是两个字符，区码一个字符，位码一个字符" class="headerlink" title="考点3：区位码是两个字符，区码一个字符，位码一个字符"></a>考点3：区位码是两个字符，区码一个字符，位码一个字符</h4><h4 id="考点：区位码、国际码相互转换。"><a href="#考点：区位码、国际码相互转换。" class="headerlink" title="考点：区位码、国际码相互转换。"></a>考点：区位码、国际码相互转换。</h4><p>把十进制的区位码转换成十六机制，再加上2020H就得到国际码</p>
<h4 id="考点：国标码GB2312是一种交换码"><a href="#考点：国标码GB2312是一种交换码" class="headerlink" title="考点：国标码GB2312是一种交换码"></a>考点：国标码GB2312是一种交换码</h4><h4 id="考点：国际码是两个字节，每个字节的最高位是0"><a href="#考点：国际码是两个字节，每个字节的最高位是0" class="headerlink" title="考点：国际码是两个字节，每个字节的最高位是0"></a>考点：国际码是两个字节，每个字节的最高位是0</h4><h4 id="考点：国际码GB2312使用十六进制表示-16bit"><a href="#考点：国际码GB2312使用十六进制表示-16bit" class="headerlink" title="考点：国际码GB2312使用十六进制表示 16bit"></a>考点：国际码GB2312使用十六进制表示 16bit</h4><h4 id="考点：中文字符国际码的取值范围是2121H-7E7EH"><a href="#考点：中文字符国际码的取值范围是2121H-7E7EH" class="headerlink" title="考点：中文字符国际码的取值范围是2121H ~ 7E7EH"></a>考点：中文字符国际码的取值范围是2121H ~ 7E7EH</h4><p><u>@@ <strong>为了</strong>解决GB2312码[国标码]和ASCII码的冲突问题，我们把国标码的最高位设置为（<strong>1</strong>），称之为（<strong>机内码</strong>[异性国标码]）</u></p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>全称：《汉字内码扩展规范》时间：1995年制订</p>
<p>两个字节表示一个汉字，向下兼容GB2312和BIG5</p>
<p>收录了21886个符号，包括21003个汉字和883个其他符号</p>
<h2 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h2><p>时间：2000、2005年制订，两个版本</p>
<p>全称：《信息技术中文编码字符集》</p>
<p>特点：可变长编码，采用单字节、双字节和四字节三种方式对字符编码</p>
<p>收录了70000多个符号</p>
<h2 id="BIG5"><a href="#BIG5" class="headerlink" title="BIG5"></a>BIG5</h2><p>属性：港澳台地区使用的繁体字编码方案</p>
<p>两个字节表示一个汉字</p>
<p>13053个繁体字</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>中文名：统一码、万国码    时间：1994年公布</p>
<p>使用两个字节或四个字节表示一个字符 UCS </p>
<p>Unicode编码方案 <strong>UTF-8、UTF-16、UTF-32</strong></p>
<p>能表示<strong>20000以上的汉字数量</strong></p>
<h3 id="乱码的问题"><a href="#乱码的问题" class="headerlink" title="乱码的问题"></a>乱码的问题</h3><p>乱码的原因：使用一种交换码编辑文档，如果对方机器里使用的是另一种不兼容的交换码就会乱码</p>
<p>乱码的解决：统一使用通用的Unicode编码，或者选择安装使用同一种交换码</p>
<h3 id="中文字符在计算机中的表示–输出码"><a href="#中文字符在计算机中的表示–输出码" class="headerlink" title="中文字符在计算机中的表示–输出码"></a>中文字符在计算机中的表示–输出码</h3><p>又叫汉字字形码，有叫汉字字模，用于汉字在显示屏或打印机输出</p>
<ul>
<li><h4 id="点阵字"><a href="#点阵字" class="headerlink" title="点阵字"></a>点阵字</h4></li>
</ul>
<p>使用n*n的点阵表示一个汉字的行形状，每个点使用一位二进制表示，0和1组成</p>
<p>根据输出汉字的要求不同，点阵的多少也不同，简易型汉字16 * 16点阵，提高型汉字24 * 24点阵、32 * 32点阵、48 * 48点阵</p>
<p><strong>点阵规模愈大，字形愈清晰美观，所占存储空间愈大</strong> <u>1字节 &#x3D; 8bit</u>    如：16*16点阵汉字，每个汉字占用16 * 16 &#x2F; 8 &#x3D; 32B  故占32个字节</p>
<p>字库：字模点阵占用空间太大，不作为机内存储，只用来构成“字库”。字库中存放了每个汉字的点阵代码，需要显示输出时，检索字库，输出字模点阵，得到字形。</p>
<p><strong>考点</strong>：<u>汉字的字库属于输出码(字形码)，不是机内码</u></p>
<p>&#x3D;&#x3D;<strong>考点</strong>：有100个24 * 24点阵汉字，所占存储空间是多少？ <strong>100 * 24 * 24 &#x2F; 8 &#x3D; 7200B</strong>&#x3D;&#x3D;</p>
<ul>
<li><h4 id="矢量字"><a href="#矢量字" class="headerlink" title="矢量字"></a>矢量字</h4></li>
</ul>
<p>矢量字体(Vector font)中每一个字形是通过数学曲线来描述的，它包含了字形边界上的关键点，连线的导数信息等，字体的渲染引擎通过读取这些数学矢量，然后进行一定的数学运算来进行渲染。<br>字体实际尺寸可以任意缩放而不变形、变色，显示效果与大小和分辨率无关，因此可产生高质量的汉字输出</p>
<p>矢量字体主要包括Type1 . TrueType、OpenType等几类。<br>厂商：北大方正、makefont等</p>
<ul>
<li><h4 id="点阵字和矢量字的区别"><a href="#点阵字和矢量字的区别" class="headerlink" title="点阵字和矢量字的区别"></a>点阵字和矢量字的区别</h4></li>
</ul>
<p>@@ 每个汉字具有唯一的内码，外码不唯一</p>
<p>@@ 存储一个32 * 32 点阵汉字字型信息的字节数是(<strong>128B</strong>)</p>
<p>@@ 中文字符集中，包含汉字数量最多的是<strong>GBK</strong>     ∵ UTF-8不是专门的中文字符集</p>
<p>@@ <strong>GB18030</strong> 包含汉字数量最多</p>
<hr>
<p>@@ 中文字符的范围是A1A1H到FEFEH，汉字机内码的取值范围是B0A1H ~ F7FEH</p>
<p>@@ 汉字系统中汉字字库里存放的是汉字的<strong>字形码</strong></p>
<p>@@ 不同汉字的机内码长度是相同的 都是2个字节</p>
<p>@@ 区位码输入法的最大优点是<strong>一字一码，无重码</strong></p>
<p>@@ 在计算机内部用机内码而不用国标码表示汉字的原因是<strong>有些情况下，国际码有可能造成误解</strong></p>
<p>@@ **一个汉字的机内码与它的国标码之间的差是8080H **，国标码5E38H -&gt; 机内码 5E38H + 8080H &#x3D;&gt; DEB8H</p>
<p>@@ [上方考点2] 已知汉字”家”的区位码是2850，则其国标码是(<strong>3C52H</strong>) <strong>28</strong>D -&gt; <u><strong>1C</strong>H -&gt; +20H</u> &#x3D;&gt; 3CH</p>
<p>@@ 汉字的国标码由两个字节组成，每个字节的取值均在十进制<strong>33-126</strong>  ∵范围是2121H-7E7E，<u>21 -&gt; 2×16+1 &#x3D;33</u>，<u>7E -&gt; 7×16+14&#x3D;126</u> &#x3D;&gt; <em><strong>33 ~ 126</strong></em></p>
<p>@@ 一个汉字的机内码与国标码之间的差别是<strong>前者各字节的最高二进制位的值均为1，而后者均为0</strong></p>
<p>@@ 若存储500个32 * 32 点阵的汉字字模信息，则需要的存储容量是<strong>64kb</strong> ∵ 500×32×32 &#x2F; 8 <em>(<u>1字节 &#x3D; 8bit</u>)</em> ×1024&#x3D; 64KB</p>
<p>@@ 存储800个24 × 24点阵汉字字形所需的存储容量是( 24 × 24 × 800 )<strong>位</strong> [&#x3D;&#x3D;位的话不除以8，如果问字节B 就要除以8&#x3D;&#x3D;]</p>
<p>@@ 计算机处理汉字时，在<u>输入、存储、和显示阶段</u>所使用的编码是<strong>输入码、机内码、字形码</strong></p>
<p>@@ 根据汉字国标码GB2312-80的规定，一级汉字的排列顺序是按照<strong>汉字拼音字母</strong>，二级的汉字排列顺序是按照<strong>偏旁部首</strong></p>
<p><u>@@ <strong>为了</strong>解决GB2312码[国标码]和ASCII码的冲突问题，我们把国标码的最高位设置为（<strong>1</strong>），称之为（<strong>机内码</strong>[异性国标码]）</u></p>
<p>@@ 点阵属于字形码，输入码包括<strong>括音码、形码、音形结合码、流水码</strong></p>
<p>@@ 汉字国标码每一个字节的取值范围是<strong>2121H - 7E7EH</strong></p>
<p>@@ 汉字输入码包括<strong>音码、形码、音形结合码、流水码</strong></p>
<p>@@ 相同的汉字通过不同的输入方式外码不同，<strong>内码相同</strong></p>
<p>@@ 存储400个24×24的点阵汉字字形所需的存储容量是<strong>28.125</strong>kb ；400×24×24 &#x2F; 8 × 1024 &#x3D; 28.125</p>
<p>@@ <strong>寄存器</strong>用来临时存放参加运算的数据和运算得到的中间结果 </p>
<p>@@ <u>CPU通过数据总线一次存取、加工和传送的数据称为<strong>字</strong>。</u></p>
<p>@@ 计算机的运算部件能同时处理的二进制数据的位数称为<strong>字长</strong>。</p>
<p>@@ 汉字字形码实际上就是用来将汉字显示到屏幕上或打印到纸上所需要的图形数据。<u><em>汉字字形码记录汉字的外形</em></u>，是汉字的<strong>输出形式</strong></p>
<p>@@ ASCII码是一种西文机内码，**<u>一个字符的ASCII码占用的存储空间为1B</u>**</p>
<p>@@ 记录汉字字形通常由两种方法：<strong>点阵法</strong>和<strong>矢量法</strong>，分别对应两种字形编码：<strong>点阵码</strong>和<strong>矢量码</strong></p>
<p>@@ CPU中用于暂时存放操作数和中间运算结果的是<strong>累加器</strong></p>
<p>@@ CPU中，加法运算是由**算术逻辑部件(运算器)**完成的</p>
<p>@@ 不同的CPU其具有的机器指令不同，因此，必须与可兼容的芯片组匹配。</p>
<p>@@ CPU是计算机中不可缺少的组成部分，它包含几十个甚至更多寄存器，用来<strong>临时存放等待处理数据</strong>，也担负着运行系统软件和应用软件的任务。尽管采用各种技术措施后PC机的主存速度有了很大的提高，但与CPU相比仍有较大差距，为了解决主存速度不能完全跟上CPU速度这一矛盾，PC机采用了高速缓存存储器Cache。常用的CPU由一个处理器组成，但是为了提高计算机的速度，CPU也可以由2个、10个甚至几百个几千个处理器组成 </p>
<p>@@ CPU由<strong>运算器</strong>和<strong>控制器</strong>组成</p>
<p>@@ 字长是计算机一次所能处理的实际位数长度，字长是衡量计算性能的一个重要指标。字长一般是8的倍数</p>
<p>@@ 某显示器的分辨率设置为1024 × 768，其含义是<u><strong>横向点数 × 纵向点数</strong></u></p>
<p>@@ <u>第一台<strong>电子计算机</strong></u>采用的<strong>十进制</strong>，没有采用存储程序思想</p>
<p>@@ 未配置任何软件的叫<strong>裸机</strong></p>
<p>@@ 中央处理器：<strong>控制器和运算器</strong></p>
<p>@@ 磁盘采用的是<strong>磁存储原理</strong>；光盘采用的是<strong>激光存储原理</strong></p>
<p>@@ 汉字<strong>内码</strong>是真正的计算机内部用来存储和处理汉字信息的语言</p>
<p>@@ 微型计算机的<strong>显示系统</strong>指的是<u><strong>显示器+显示适配器(显示卡)</strong></u></p>
<p>@@ ENIAC没有今天的鼠标和键盘，人们**<u>只能通过扳动片面化大面板上的无数开关向计算机输入信息</u>**</p>
<p>@@<span style = "color : red"> <u>字节是存储信息的基本单位。bit是<strong>信息量单位</strong></u></span></p>
<p>@@ ASCII称为<strong>美国标准信息交换码</strong></p>
<p>@@ 每一个十进制<strong>整数</strong>都可以精确地转换为二进制整数形式，十进制<strong>小数</strong>转换为二进制方法为乘积取整，顺序排列，<strong>有可能出现循环的情况，不能精确转换 &#x3D;&gt; 十进制小数0.1转换为二进制就会出现不能精确转换的情况</strong></p>
<p>@@ 用于解决某一问题的<u>一个指令序列</u>称为<strong>程序</strong>，<em>所有程序的集合</em>称为<strong>计算机指令系统</strong></p>
<p>@@ MIPS是计算机的<strong>运算速度</strong>单位，计算机的主频单位是Hz赫兹</p>
<p>@@ ASCII码是美国信息交换标准代码，它的每个字符用一个字节表示</p>
<p>@@ 世界上第一代电子计算机主要用于<strong>科学计算</strong></p>
<p>@@ CPU从RAM中既可以读出信息又可以写入信息，但断电后所存的信息就会丢失</p>
<p>@@ 将磁盘上的信息调入内存时，信息写入内存储器的<strong>RAM</strong></p>
<p>@@ 外部设备与总线和微处理器链接的接口电路称为<strong>适配器</strong></p>
<p>@@ 把时间上连续的模拟信号转变为时间上不连续的数字信号，这个取点的过程称之为<strong>采样</strong></p>
<p>@@ 计算机的算法具有<strong>有穷性、确定性、可行性</strong>的性质</p>
<p>@@ 在一个非零无符号二进制整数之后去掉一个0，则此数的值为原数的<strong>1 &#x2F; 2</strong>倍</p>
<p>@@ 设内存储器的容量为1MB, 若首地址的十六进制表示为00000，则末地址的十六进制 表示为FFFF</p>
<p>@@ 字的位数叫<strong>字长</strong>，它是计算机一次可处理的二进制数的位数，是衡量计算机性能的一个重要指标</p>
<p>@@ <strong>指令</strong>由一串二进制码组成，包括<strong>操作码</strong>和<strong>地址码</strong>两部分</p>
<p>@@ 高级语言可以分为两类：<strong>编译型</strong>和<strong>解释型</strong></p>
<p>@@ <strong>软件</strong>是指计算机运行所需的程序，数据和有关文档的总和</p>
<p>@@ 存储器由成千上万个存储单元构成，每个存储单元都有唯一的编号，称为存储单元的<strong>地址</strong></p>
<p>@@ 存储程序工作原理的基本思想是存储程序和<strong>程序控制</strong></p>
<p>@@ <strong>汉字机内码</strong>是计算机内处理汉字信息时所用的汉字代码</p>
<p>@@ **<u>数码</u>**：一组来表示某种数制的符号，比如二进制的0和1    <strong>基数</strong>：数制所使用的数码个数，常用R表示，称为R进制</p>
<p>@@ 在计算机内一切信息存取、传输都是以<strong>二进制</strong>形式进行的集合。</p>
<p>@@ 一个中文字符是2个字节 2Byte&#x3D;2*8bit</p>
<p>@@ 微型计算机的特点：运算速度快，计算精度高，记忆能力强，存储能量大，具有逻辑判断能力，数据化程度高</p>
<p>@@ 云计算是分布式计算技术的一种，最基本的概念是透过网络将庞大的计算机处理程序自动划分成若干个小的程序，再由多部服务器组成的庞大系统，经搜寻、计算分析之后同将处理结果回传给用户。[大的分成小的分给多个主机，同时完成 ]</p>
<p>@@ 1个字节 可以表示 2位十六进制 2位八进制</p>
<p>@@ 合并后居中(居中)、合并单元格(只合并 在最左)、跨越合并(一行一行的)</p>
<p>@@ 有10个盘面，每个划分出1024条磁道，每条磁道划分出2048个扇区，求硬盘空间 &#x3D; 10 *1024 * 2048 * 512 &#x3D; 10GB [盘面要×2]</p>
<p>@@ 硬盘中每个磁道中一个扇区的存储容量是512Byte</p>
<p>@@ 真值：是计算机内部的编码形式 </p>
<p>@@ 操作系统的异步性是指程序的<strong>不确定性</strong>；共享性是指计算机中资源能够被多个程序使用</p>
<p>@@ 计算机指令的执行过程分为<strong>取指令、分析指令和执行指令</strong></p>
<p>@@ CPU单位时间内一次处理的二进制位数称为<strong>字长</strong></p>
<p>@@ M ASCII：77    m&#x3D;77+32&#x3D;109</p>
<p>@@ 一个ASCII码占用 1字节<br> 一个汉字机内码占用2字节<br>一个字节可以表示2十六进制位</p>
<blockquote>
<p><strong><u>与同1(张雨桐是1)    或11(喝11)</u></strong><br>与(&amp;)(逻辑乘) 运算 0&amp;0&#x3D;0, 1&amp;0&#x3D;0, 1&amp;1&#x3D;1<br>或(|)(逻辑加) 运算 0|0&#x3D;0, 0|1&#x3D;1, 1|1&#x3D;1<br>非(<del>) 运算 非运算即取反运算 1变0, 0变1<br>异或(^)</del>相同为0，不同为1~ 运算 0^0&#x3D;0, 0^1&#x3D;1, 1^1&#x3D;0</p>
</blockquote>
<p>@@ 数值∈[0,R-1]</p>
<hr>
<p><strong><span style = "color :red">2023.3.14计算机题目</span></strong></p>
<p>UPS不断供电系统(电池)<br>A盘 B盘用于古代的软盘<br>@@ 把连续的模拟信号按照一定的频率进行采样，得到一系列有限的<strong>离散值</strong><br>@@ 存储载体 + 传输载体<br>@@ 存储器Cache：解决cpu和内存之间速度不匹配<br>@@ 从快到慢：寄存器、Cache、RAM、硬盘、U盘<br>@@ ROM只读存储器、PROM可编程只读存储器、EPROM擦除…<br>@@ MIPS运算速度<br>@@ 数据和信息关系，先有数据，再获取信息；文字图形图形视频 -&gt; 信息；<br>@@  世界上第一款 商用计算机<br>@@ 计算机采用二进制的原因：<strong>①电路简单 ②简化运算 ③可靠性 ④逻辑性 ⑤通用性</strong><br>@@ 冯诺依曼体系的设计思想：程序存储和程序控制<br>@@ 利用区位码输入汉字时，输入<strong>十六进制</strong><del>题目给出不用转换</del>代码”10 23 24 19”<br>&#x3D;&#x3D;① 输入了 <u>2</u> 个汉字<del>一个字节可表示2位十六机制</del>[10,23,24,19四个字节]，共用了 <u>4</u> 个字节&#x3D;&#x3D;<br>② 填写出小李输入的汉字在计算机内部的存储形式<br>已知区位码 1023, 2419，求 机内码十六进制 &#x3D;&gt; AOAO AOAO &#x3D;&gt; BOC3 C4B9<br>[<strong><u>大到小 -&gt; 内<del>+80</del>国<del>+20</del>区<del>区位码十进制要转换成十六进制</del>[从右到左] &#x3D;&gt; 内个蛆</u></strong> ]</p>
<blockquote>
<p>机内码 取值范围 AOAO-FEFE<del>H</del><br>① 西文字符 ASCII码 (标准 扩展) 【复习】大小排序<del>(在Excel内不区分大小写)</del><br>② 整数 采用 补码<br>正整数 原、反、补相同<br>负整数 补 是符号不变，原码取反＋1<br>③ 汉字 采用 机内码 &#x3D; 区位码 + 2020H + 8080H [要注意10进制转换16进制]<br>④ 浮点 采用 阶 和 尾</p>
</blockquote>
<p>+0.377 × $10^8$     +是阶符 8是码  0.377尾数 10-&gt;R是基数  8是指数</p>
<blockquote>
<p>指数是范围 尾数是精度</p>
</blockquote>
<p>@@ 虚拟地址是<strong>用户编程可使用的地址</strong><br>@@ 操作系统通过<strong>逻辑设备名<del>中断号识别I&#x2F;O设备</del></strong><br>@@ <strong>网桥</strong>就是交换机<br>@@ 文件有<strong>只读</strong>属性指的是 文件中的内容被保护，文件可以被删除，移动，保护<br>@@ 内存中数据进入高速缓存 再进入硬盘；硬盘中的数据；<del>[CPU到Cache 内存到CPU]？？</del><br>硬盘内部是磁盘到柱头 外部磁盘缓存 -&gt;系统总线<br>外部：高速缓存 再进入内存<br>内部：硬盘的磁头到硬盘的高速缓存 [硬盘内外之间有自己的高速缓存]</p>
<hr>
<h4 id="铭升练习册填空题"><a href="#铭升练习册填空题" class="headerlink" title="铭升练习册填空题"></a>铭升练习册填空题</h4><p>@@ 基本ASCII码包括<strong>128</strong>个不同的字符<br>@@ 不少微机软件的安装程序都具有相同的文件名，Windows系统也如此，其<strong>安装程序</strong>的文件名一般为<strong>Setup.exe</strong><br>@@ 用24 × 24点阵的汉字字模存储汉字，每个汉字需要<strong>72</strong>字节 24×24÷8<br>@@ CPU的性能指标中，CPU的时钟频率称为<strong>主频</strong><br>@@ 微型计算机中最大最重要的一块继承电路板称为<strong>主板</strong><br>@@ 光盘的读写设备是光盘<strong>驱动器</strong><br>@@ 计算机的工作原理可以概括为<strong>存储程序</strong>和<strong>程序控制</strong><br>@@ 指令的执行过程包括<strong>取指令、分析指令</strong>和<strong>执行指令</strong><br>@@ 输入设备、输出设备和外存储器合称为<strong>外设</strong><br>@@ 存储器被划分为多个存储单元，每个存储单元都被赋予一个唯一的编号，这个编号被称为存储单元的<strong>地址</strong><br>@@ 在Windows中，应用程序中”编辑(E)”菜单，可用<strong>Alt+E</strong><br>@@ 每当运行一个Windows的应用程序，系统都会在<strong>任务栏</strong>上增加一个按钮<br>@@ 若想调整音量的音量大小，可用双击任务栏上的<strong>音量</strong><br>@@ 在win7中，<strong>磁盘清理</strong>程序通过删除无用文件来帮助释放硬盘驱动器的空间；<strong>磁盘碎片整理</strong>整理程序重新安排计算机硬盘上的文件、程序以及未使用的空间。以便程序运行得更快，文件打开得更快<br>@@ 按<strong>Alt+F4</strong>键可以关闭窗口或退出应用程序；如果某个应用程序不再相应用户的操作可以同时按ctrl+shift+esc<br>@@ 若想删除某个输入法可以选择”<strong>控制面板</strong>“中的<strong>区域和语言</strong>选项<br>@@ 在资源管理器窗口中，显示资料的方式有：**(超大,大,中,小)图标、平铺、列表、内容、详细信息**<br>@@ Windows的<strong>回收站</strong>是<strong>硬盘</strong>中的一块区域<br>@@ 按<strong>Alt+PrintScreen</strong>键可以复制活动窗口的图形到剪贴板<br>@@ 用于解析<strong>域名</strong>的协议是DNS<br>@@ 将文件从FTP服务器传输到客户机的过程称为<strong>下载</strong><br>@@ 网址<strong><a target="_blank" rel="noopener" href="http://www.pku.edu.cn/">www.pku.edu.cn</a></strong>中pku.edu.cn是在Internet中注册的<strong>域名</strong><br>@@ 一般拨号入网，是指通过<strong>公用电话系统</strong><del>PSTN</del>与Internet服务器连接<br>@@ 提供不可靠传输的传输层协议是<strong>UDP</strong><br>@@ Internet主要由四大部分组成，其中包括<strong>路由器、主机、信息资源、通信线路</strong><br>@@ 构成局域网的基本构件有<strong>PC机、传输媒体、网卡<del>(网络适配器)</del>、网络连接设备、网络操作系统</strong><br>@@ 被称为最早的网络是<strong>ARPAnet</strong>网<br>@@ 开放系统互联参考模型简称<strong>OSI</strong>参考模型<br>@@ 开放系统互联参考模型<strong>OSI&#x2F;RM</strong><br>@@ 中继器&#x3D;集线器：放大信号；<br>网桥&#x3D;交换机：寻址、存储、转发；<br>网关&#x3D;路由器：分组交换<br>@@ Hub的中文名称是<strong>集线器</strong><br>@@ <strong>双绞线</strong>可以分为<strong>屏蔽<del>抗电磁干扰强</del><strong>和</strong>非屏蔽</strong>两类<br>@@ 在OSI参考模型中，物理层传送数据的单位是<strong>比特</strong><br>@@ 广域网中广泛使用的信息交换技术是<strong>分组交换</strong>技术<br>@@ 根据宽带来分，计算机网络可分为<strong>宽带网</strong>和<strong>基带网<del>PC发出来的未经过调制的原始信号</del></strong><br>@@ 网络中数据传输形式有<strong>线路、报文、分组交换</strong><br>@@ 计算机指令的合集成为<strong>程序</strong><br>@@ 把源程序翻译后的机器语言程序叫做<strong>目标程序</strong><br>@@ 多媒体技术的基本特征主要有<strong>多维性、集成性、交互性</strong><br>@@ word域代码和域结果，按<strong>Shift+F9</strong>键可以实现相互切换<br>@@ word中，图片插入有两种方式：<strong>嵌入方式</strong>和<strong>链接方式</strong><br>@@ 在Excel中，若只需打印工作表的一部分数据时，应先<strong>选定打印区域</strong><br>@@ 所谓<strong>文件</strong>是指逻辑上具有完整意义的信息资源<strong>程序和数据</strong>的集合<br>@@ 窗口转换<strong>Alt+Tab</strong>或<strong>Alt+Esc</strong><br>@@ MS-DOS是微软公司开发的<strong>磁盘</strong>操作系统，是一种在个人计算机上使用的命令行界面操作系统<br>@@ windows支持的文件系统有<strong>FAT16、FAT32</strong>和<strong>NIFS</strong><br>@@ Internet是全球最具有影响力的计算机互联网，也是世界范围最重要的<strong>信息资源网</strong><br>@@ 任务管理器有两大功能：一是显示当前打开的应用程序、<strong>进程</strong>、CPU和内存资源消耗情况<br>@@ 标准ASCII码是用<strong>7</strong>位二进制位来表示128个字符<br>@@ 每个汉字的机内码需要用<strong>2</strong>个字节来表示<br>@@ 标准ASCII码是用<strong>7</strong>位二进制进行编码<br>@@ 在计算机中，对既有整数部分又有小数部分的实数，使用<strong>浮点数</strong>表示<br>@@ 文件是一组<strong>按一定格式记录在外存中的一组相关信息的集合</strong><br>@@ Excel是<strong>电子表格</strong>应用程序<br>@@ 计算机内部件传输信息的公共通路称为总线，一次传输信息的位数称为总线的<strong>宽度</strong><br>@@ 数据总线宽度：决定了<strong>字长</strong>；    地址总线宽度：决定了访问内存的<strong>容量</strong><br>@@ 某台主机属于国内企业系统，其域名应以<strong>com.cn</strong>结尾<br>@@ GIF LZW是运用了无损压缩算法 但是有损压缩<br>@@ 分布式 是 大任务划成任务；分时 是 轮流使用主机资源<br>@@ 一个进程 包括了 多个线程；资源分配是按进程；资源调度是按线程<br>@@ IPV6采用冒号十六进制 IPV4采用点份十进制<br>@@ 快捷方式是指针<br>@@ 卸载程序会修改注册表；注册表存储着文件与程序的关联关系<br>@@ 文件处理软件属于应用软件<br>@@ 用户控制等在文件 选项中<br>@@ 视图选项卡：新建窗口、拆分窗口 &#x3D;&gt; 在多个窗口中编辑一个文档<br>@@ 拆分 将窗口拆分成 上下 两个部分，方便编辑长篇文档<br>@@ 在一个窗口的结果中，显示在所有的窗口中，像任何情况下，只能有一个编译窗口<br>@@ 文件菜单下显示 最近打开过的文档的快捷方式；视图菜单 切换窗口：显示所有当前打开的文档，可选择 活动文档<br>@@ 单间头 双箭头<br>@@ 导入图片有两种方式：<strong>文件导入</strong> + <strong>剪贴板导入</strong><br>@@ 连击两次工具条中的斜体按钮，则这句话的字符格式不改变<br>@@ 默认的整篇文档叫<strong>节</strong><br>@@ word中建立的表格都是<strong>绘制</strong>的表格<br>@@ 图形对象可以同时添加阴影效果和三维效果<br>@@ 灰色不可用 黑色可用<br>@@ 工作表是工作簿的基本构造块<br>@@ 文件 信息 <strong>保护工作簿</strong> 命令：保护工作簿<br>“<strong>结构</strong>“：增加、移动、删除、重命名工作表<br>“<strong>窗口</strong>“：工作簿窗口的大小和位置<br>@@ 保留最近的24次内容<br>@@ 演示文稿不是幻灯片 演示文档由幻灯片组成<br>@@ 幻灯片可以设置页脚[可插入日期和时间]<br>@@ 幻灯片中对象的效果可以自定义<br>@@ 幻灯片打包时连同播放软件一起打包<br>@@ PPT可以插入EXCEL表格 用链接<br>@@ 多媒体技术中使用数字化技术，与模拟方式相比<strong>经济，造价低</strong><br>@@ 软件发展的三个阶段：第一阶段最初运用于科学与工程计算，使用低级语言编制程序；第二阶段先高级程序语言编制程序，并产生了操作系统和数据库管理系统；20世纪80年代初期，出现了”软件危机”。第三阶段为适应开发大型软件的需要，提出了”软件工程”<br>@@ 网关：运行在路由器中的 协议转换软件 称路由器为网关<br>@@ 黑客或病毒攻击<br>@@ 最大化和还原不能同时出现<br>@@ LWZ使用了无损压缩技术<br>@@ CD-ROM一般即指光存储介质，也指CD-ROM驱动器<br>@@ 最多显示50个最近打开的文档<br>@@ RSA不对称加密 DES算法属于加密技术的对称加密<br>@@ ASCII码是<strong>7</strong>位二进制编码<br>@@ H字母是48H  J是4AH<br>@@ 磁盘分区<strong>NTSF</strong><br>@@ 计算机的存储器由千千万万个小单元组成，小单元是1位二进制<br>@@  Alt <strong>交替换挡键</strong><br>@@ Alt+回车 可以打开属性对话框<br>@@ 计算机科学的奠基人<strong>图灵</strong><br>@@ 某次数据传输共传输了10000000字节数据，其中有50bit出错，其中误码率为<br>50&#x2F;(10000000×8)&#x3D;6.25×10$^{-7}$<br>@@ 数据&#x3D;信息+冗余数据<br>@@ 空格 逻辑与 +     -  逻辑非    |逻辑或<br>@@ 二八十六转十进制 都可以用按位权展开<br>@@ 服务器作用：管理网络资源，提供网络服务<br>@@ Win7里不允许更改<strong>网络图标</strong><br>@@ 硬盘使用前先分区 再格式化<br>@@ 数字相同 进制越小 数值越小<br>@@ 有符号的值取值范围  0 11111<del>大</del> - 1 00000<del>小</del><br>@@ 无符号的值取值范围 0 00000    -  1 11111<br>@@ 一个字符的ASCII，占用二进制数的位数是<strong>8</strong>位<br>@@ 一个字符的ASCII编码，占用二进制位数是<strong>7</strong>位<br>@@ 文本框默认浮于文字上方<br>@@ 计算机的通用性使其可以求解不同的算术和逻辑问题，这主要取决于计算机的<strong>可编程性</strong><br>@@ 一个<strong>有符号</strong>的整数，用一个字节的二进制表示其内容分别是10100000 &#x3D; -41 和 11010111 &#x3D; -96<br>@@ 打开任务管理器，在窗口中，<strong>进程</strong>选项卡提供进程信息，<strong>性能</strong>选项卡提供CPU和内存利用率，<strong>联网</strong>选项卡提供了网络使用率和状态信息，<strong>用户</strong>选项卡显示了登录用户信息</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/计算机" style=color:#1bccbc>
                计算机
            </a>
        </span>
        
    </div>

    <a href="/2022/07/03/计算机/计算机基础概论、进制转换、中文字符/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/06/25/数学/连续,导数,隐函数,高阶导数/">
        <h2>
            连续、导数、隐函数、高阶导数
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/6/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E6%95%B0%E8%BF%9E%E7%BB%AD.jpg"></p>
<ul>
<li><p>设函数y&#x3D;f(x)在点x0处连续，则y&#x3D;f(x)在x0处的极限存在。</p>
</li>
<li><p>如果x0是函数f(x)的间断点，且<strong>左极限</strong>及<strong>右极限</strong>都存在，则称x0为函数f(x)的<u><strong>第一类间断点</strong></u></p>
</li>
<li><p><u><strong>第一类间断点</strong></u>[可去间断点 + 跳跃间断点]</p>
</li>
<li><p>左右极限都存在且相等时，属于第一类间断点，且为<strong>可去间断点</strong></p>
</li>
<li><p>左右极限都存在但不相等时，属于第一类间断点，且为<strong>跳跃间断点</strong></p>
</li>
<li><p>左右极限至少有一个不存在时，属于第二类间断点</p>
</li>
<li><p>求初等函数的间断点即求不在函数定义域内的点，而使两个分母分别为0的点不在定义域内</p>
</li>
<li><p>初等函数在其定义区间每点处都是连续的，所以找初等函数的间断点，只需要找出其无定义的点即可</p>
</li>
</ul>
<p> <strong>连续函数性质的应用</strong></p>
<p>证明连续的题：</p>
<p>1、先说明函数___在[ , ]上连续，因为… </p>
<p>2、f(?) &gt; 0，f(?) &lt; 0 <strong>根据零点定理**可知函数式在[  ,  ]内至少有… (<u>如果<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912">函数</a>y&#x3D; f(x)在区间[a,b]上的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9B%BE%E8%B1%A1/20402891">图象</a>是连续不断的一条<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9B%B2%E7%BA%BF/12004394">曲线</a>，并且有</strong>f(a)·f(b)&lt;0**,那么，函数y&#x3D; f(x)在区间(a,b)内有零点，即至少存在一个c∈(a,b),使得f(c)&#x3D;0,这个c也就是方程f(x)&#x3D; 0的根</u>) </p>
<p>3、<strong>至少</strong>的正根可以根据函数f() &gt; 0, f() &lt; 0来判定，<strong>至多</strong>的正根可以根据函数的导数大于0判断单调递增来说明。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%9B%B6%E7%82%B9%E5%AD%98%E5%9C%A8%E5%AE%9A%E7%90%86.jpg"></p>
<h2 id="连续性-导数-可导性"><a href="#连续性-导数-可导性" class="headerlink" title="连续性+导数(可导性)"></a>连续性+导数(可导性)</h2><ul>
<li>法线：k * k法 &#x3D; -1</li>
<li>两条直线若都存在斜率且平行，则两条直线的斜率相等</li>
<li>sin2x &#x3D; 2sinxcosx      (sin2x)’ &#x3D; 2cos2x</li>
<li>cos2x &#x3D; $2cosx^2$ - 1 &#x3D; 1 - $2sinx^2$    (cos2x)’ &#x3D; -2sin2x</li>
<li>tan2x &#x3D; $sec^2x$ - 1    (tan2x)’ &#x3D; 2sec^2x</li>
</ul>
<p><strong>导数的定义</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89.jpg"></p>
<p><strong>导数的定义技巧1</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A71.jpg"></p>
<p><strong>导数的定义技巧2</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A72.jpg"></p>
<p><strong>导数的定义技巧3</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%8A%80%E5%B7%A73.jpg"></p>
<p><strong>连续性+导数大题</strong><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0%E6%B1%82%E8%BF%9E%E7%BB%AD%E6%80%A7%2B%E5%8F%AF%E5%AF%BC%E6%80%A7.jpg"></p>
<ul>
<li><strong><span style = "color: red">大题部分</span><strong>：解决该类问题的基本思路根据</strong>分段函数</strong>在其分界点处的性质来确定所含常数的值，若一函数在其分界点可导，首先在该点**<u>连续</u><strong>；而在分界点的导数则按导数定义或</strong><u>左右导数</u>**的定义来导</li>
<li>①先根据f(?) 带入两个式子 若 f1(?) &#x3D; f2(?) 则证明该分段函数在x&#x3D;？处是否连续；②之后根据f’-(?) 与 f’+(?)是否相等来判断该分段函数是否可导 </li>
<li>函数y &#x3D; f(x) 在点x0处左可导、右可导，并且左右导数相等，y &#x3D; f(x)在点x0处才可导；<span style = "color : red">函数y &#x3D; f(x)在点x0处可导，必在此点连续</span>；函数y&#x3D;f(x) 在点x0处连续，未必在此点可导</li>
</ul>
<hr>
<hr>
<h2 id="导数-隐函数"><a href="#导数-隐函数" class="headerlink" title="导数+隐函数"></a>导数+隐函数</h2><p>$x^x$&#x3D;$e^xlnx$</p>
<p>对于函数y&#x3D;u(x)$^v$$^x$,其中u(x) &gt; 0求导，可采用<strong>公式变形法</strong>，变形成复合指数函数，y&#x3D;e^[v(x)lnu(x)]</p>
<p>y&#x3D;f(x+1)，y’&#x3D;f’(x+1) + (x+1)’</p>
<ul>
<li><strong>可导的奇函数的导数为<span style = "color : red">偶函数</span>，可导的偶函数的导数为奇函数</strong></li>
<li>隐函数求导方法：求y对x的导数时要用符合函数的求导法则，然后将含有y’的项放到等式的一端，不含y’的项移到另一端，求y‘。【只要见到隐函数里的y’就把它再求导一遍  <u>(+2xy)’ &#x3D; 2y+2xy’、   (y^2) &#x3D; 2y’y</u>】</li>
<li>如<u>对数函数</u>f(x)&#x3D;u(x)^v(x) 求导可用**对数求导法 **[两边取自然对数]</li>
<li>如<u>指数函数</u>y&#x3D;e^v(x)lnu(x) 公式变形法[变形成复合]</li>
<li>欲求由方程F(x,y)&#x3D;0所确定的隐函数y&#x3D;f(x)的导数，要把方程中的x看作自变量，而将y视为x的函数，方程中关于y的函数便是x的复合函数，用复合函数的求导方法，即可得到关于y’的一次方程，从中解得y’即为所求</li>
</ul>
<h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><ul>
<li>求<strong>高阶导数</strong>的方法有不完全归纳法，即求出所给函数的1-3阶或4阶导数后，分析所得结果的规律，写出n阶导数↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/4d914efbf79536c15a6d2ddee182851.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B01.jpg"></p>
<ul>
<li>(x^3^)^(5)^表示x^3^的五阶导数，根据幂函数求导公式易得：第三阶导数为常数，因此第四阶和第五阶导数必为0</li>
</ul>
<p><strong>f(x) &#x3D; x^n^ 的n+1阶导数为0</strong> &#x3D;&gt; <strong>f(x) &#x3D; (x^n^)^(n+1)^  &#x3D; 0</strong></p>
<ul>
<li><strong>(d^2^y)&#x2F;(dx^2^)</strong> 高级模板↓</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0dxdy%E4%B8%8Edt%E6%A8%A1%E6%9D%BF.jpg"></p>
<p><strong>高级二次求导含复合变量</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%AB%98%E7%BA%A7%E4%BA%8C%E6%AC%A1%E6%B1%82%E5%AF%BC%E7%9A%84%E5%A4%8D%E5%90%88%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0.jpg"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/数学" style=color:#879cff>
                数学
            </a>
        </span>
        
    </div>

    <a href="/2022/06/25/数学/连续,导数,隐函数,高阶导数/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/10/英语/刘晓艳翻译/">
        <h2>
            刘晓艳翻译
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/10
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="文章长度"><a href="#文章长度" class="headerlink" title="文章长度"></a>文章长度</h3><p><strong>四级：</strong>140-160 words</p>
<p><strong>六级：</strong>200 words</p>
<h4 id="各档次的评分标准："><a href="#各档次的评分标准：" class="headerlink" title="各档次的评分标准："></a>各档次的评分标准：</h4><p><strong>13-15分</strong> 译文准确表达了原文的意思。用词贴切，行文流畅，基本上无语言错误，仅有个别小错。</p>
<p><span style = "color: red"><strong>10-12分</strong></span> 译文基本上表达了原文的意思。文字通顺、连贯，无重大语言错误。</p>
<h4 id="翻译单词不会写怎么办-谁都可以写成被动"><a href="#翻译单词不会写怎么办-谁都可以写成被动" class="headerlink" title="翻译单词不会写怎么办(谁都可以写成被动)"></a>翻译单词不会写怎么办(谁都可以写成被动)</h4><p><u>人或人称代词做主语都可以考虑成被动</u></p>
<p>① 用该单词的<strong>上位词</strong>来代替该单词(守门员 -&gt; 运动员 -&gt; 男人)(榴莲 -&gt; 食物 -&gt; 东西)(指南针 -&gt; 设备 -&gt; 工具)</p>
<p><strong>②</strong> 用会的单词把这个意思<strong>解释</strong>出来(春联能增加节日氛围 -&gt; 春联能使人们开心)</p>
<p>③ <strong>同义词</strong>或<strong>近义词</strong>改写</p>
<p>④ 大词就吓胡写，小词就装作没看见</p>
<ul>
<li>主谓宾上的是大词，剩下的都是小词(我爱上了美丽的大雁)<ul>
<li>大词：我 爱 大雁</li>
<li>小词：美丽的</li>
</ul>
</li>
</ul>
<pre><code class="java">铁观音一年四季均可采摘，尤其是春秋两季采摘的茶叶品质最佳(先找主谓[定语态 定时态])
Tieguanyin can be picked all the year around with the best
in Spring and Autumn.
Tieguanyin can be picked anytime in a year in Spring and Autumn.
</code></pre>
<pre><code class="java">普洱茶深受中国人喜爱
Pu&#39;er Tea is deeply loved by Chinese people. 
</code></pre>
<pre><code class="java">很多人认为合作比个人能力更重要
Cooperation is claimed to be more crucial than personal ability.
认为：claimed assume argue
重要关键的：crucial essential critical
</code></pre>
<pre><code class="java">人们普遍认为网购已经成为一种流行趋势
Online shopping is aruged to be a popular trend among the young and
the old.
</code></pre>
<pre><code class="java">那时，黄色是专为皇帝使用的颜色，皇家宫殿全都漆成黄色，黄袍总是黄色的，而普通老百姓是禁止穿黄色衣服的
At that time, yellow was designed to use for the emperons the roral
palace was painted yellow and the clothes of king was always yellow too,
However, the ordinary people were not allowed to wear yellow clothes.
</code></pre>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li>以意群为单位读句子，确定句子的<strong>时态</strong>和<strong>语态</strong></li>
<li>确定句子的主干，非主干部分通过**定语(修饰名词)<strong>或</strong>状语(除定语外)**方式来翻译</li>
<li>每一句话翻译完，看这句活与下句话之间的逻辑关系，加逻辑关系词</li>
</ul>
<h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p><u>龙井是一种绿茶，主要产自中国东部沿海的浙江省</u>。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> <u>龙井茶独特的香味和口感为其赢得了“中国名茶”的称号，在中国深受大众的欢迎，在海外饮用的人也越来越多</u>。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> <u>龙井茶通常手工制作，其价格可能及其昂贵，也可能比较便宜，这取决于茶的生长地，采摘时间和制作工艺</u>。**<span style = "color: red">&#x2F;&#x2F;</span>** <u>龙井茶富含维生素C和其他多种有益健康的元素。经常喝龙井茶有助于减轻疲劳、延缓衰老</u>。</p>
<pre><code class="java">龙井是一种绿茶(主系表)，(这种绿茶-&gt;which)主要产自中国东部沿海的浙江省
Longjing is a type of green tea which is mainly produceed in Zhejiang 
Province in the east of China.
</code></pre>
<pre><code class="java">龙井茶(因为)独特的香味和口感(状语)为其赢得了“中国名茶”的称号，(主语)在中国深受大众的欢迎
,在海外饮用的人也越来越多。(主谓宾-&gt;龙井茶赢得了称号) 
With its unique taste, the tea gets a name of China&#39;s Famous Tea which is
popular at home and also overseas.
</code></pre>
<pre><code class="java">龙井茶(主)通常(副词做状语)手工(状语by hand)制作(谓)
In fact, Longjing is usually made by hand.
</code></pre>
<pre><code class="java">其价格可能及其昂贵，也可能比较便宜，这(which)取决于茶的生长地，采摘时间和制作工艺
It can be extremely expensive or comparatively cheap, which depends on its
origin, picking time and its craft.
</code></pre>
<pre><code class="java">龙井茶(主)富含(谓)维生素C和其他多种有益健康的元素(宾)。
经常喝龙井茶有助于减轻疲劳(使你快乐)、延缓衰老(使你年轻漂亮)
Besides, it contains rich Vitamin C and many other beneficial elements.
As a result, the tea helps relieve fatigue and delay the aging process
if one drinks it regularly.
</code></pre>
<h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>大运河是世界上最长的人工河，北起北京，南至杭州。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span>  它是中国历史上最宏伟的工程之一。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 大运河始建于公元前4世纪，公园13世纪末建成。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 修建之初是为了运输粮食，后来也用于运输其他商品。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 大运河沿线区域逐渐发展成为中国的工商业中心。<span style = "color: red"><strong>&#x2F;&#x2F;</strong></span> 长久以来，大运河对中国经济发展发挥了重要作用，有力地促进了南北地区之间的人员往来和文化交流。</p>
<pre><code class="java">大运河(主)是(谓)世界上最长的(定语)人工河(宾)，北起北京，南至杭州。
The Grand Canal is one of the longest river in the world, which is from
Beijing to Hangzhou
</code></pre>
<pre><code class="java">它(主)是(系)中国历史上最宏伟的(定)工程之一(表)。
大运河(which)始建于公元前4世纪，公园13世纪末建成。
It is one of the greatest projects in the Chinese history which began
in the 4th century and was completed at the end of 13th century.
</code></pre>
<pre><code class="java">修建之初(他的目的)是为了运输粮食，后来也用于运输其他商品。
Originally, it was to transport grains, and later was used to carry
other commodities.
</code></pre>
<pre><code class="java">大运河沿线(定)区域(主)逐渐发展成为(谓)中国的工商业中心。
The areas along the canal have gradually developed into the center of
industry and commerce in China.
</code></pre>
<pre><code class="java">长久以来，大运河(主)对中国经济发展(状)发挥了(谓)重要作用(宾)
有力地促进了(已有谓语所以ing)南北地区之间的人员往来和文化交流。
For a long time, it has played a key role in the economic development of
China, promoting the personal exchange and cultural communication between
the north and the south grearly.
</code></pre>
<p><span style = "color: red"><strong>单词永远在语境里背</strong></span></p>
<p>——————-(不论演奏过多少回)，the works of Beethoven always attract large audiences.</p>
<blockquote>
<p>no matter how many time they have been performed…<br>no matter how frequently<del>频繁的</del> they have been performed…<br>no matter how frequently performed…</p>
</blockquote>
<p>When you get men into that state of anger, ——————-(他们很容易出麻烦)</p>
<blockquote>
<p>…, they are apt to<del>倾向于</del> make trouble.<br>…, It is easy for them to make trouble.</p>
</blockquote>
<p>——————-(尽管我很崇拜他是个作家), I don’t like him as a man.</p>
<blockquote>
<p>Although I very admire him as a writer…<br>Him as I admire as a writer…</p>
</blockquote>
<p>Only in this way ——————-(我们才能在毕业之后很快适应社会)</p>
<blockquote>
<p>can we adapt to society quickly until we graduate</p>
</blockquote>
<p>His eyes were reading books ——————-(脑子却在胡乱思想)</p>
<blockquote>
<p>but the brain was flying wildly.<br>but he was thinking about something else.<br>while his mind was wandering.</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#879cff>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/10/英语/刘晓艳翻译/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/08/后端/Java接口+泛型/">
        <h2>
            Java接口+泛型
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h1><p>接口，在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类相似，类描述对象的属性和方法</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p>
<p>接口与类的区别：</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口不能构造方法</li>
<li>接口中所有的方法必须是抽象方法</li>
<li>接口不能包含成员变量，除static和final变量</li>
<li>接口不是被继承了，而是被类实现</li>
<li>接口支持多重继承</li>
</ul>
<h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h4><pre><code class="java">[可见度] interface 接口名称 [extends 其他的类名
                     ]&#123;
    //声明变量
    //抽象方法
&#125;
</code></pre>
<p><strong>Interface关键词</strong>用来声明一个接口</p>
<pre><code class="java">import java.lang.*;
public interface NameOfInterface&#123;
    //任何类型final，static字段
    //抽象方法
&#125;
</code></pre>
<p>接口的特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字</li>
<li>接口中的方法都是公有的</li>
</ul>
<pre><code class="java">interface Animal&#123;
    public void eat();
    public void travel();
&#125;
</code></pre>
<h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>当类实现接口的时候，类要实现接口中所有的方法，否则类必须声明为抽象的类</p>
<p>类使用implements关键字实现接口，在类声明中Implements关键字放在class声明后面</p>
<pre><code class="java">...implements 接口名称[. 其他接口. 其他接口...]
...
</code></pre>
<pre><code class="java">/*文件名：MammalInt.java*/
public class MammalInt implements Animal&#123;
    public void eat()&#123;
        sout(&quot;Mammal eats&quot;);
    &#125;
    public void travel()&#123;
        sout(&quot;Mammal travels&quot;);
    &#125;
    public int noOfLegs()&#123;
        return 0;
    &#125;
    public static void main(String args[])&#123;
        MammalInt m = new MammalInt();
        m.eat();
        m.travel();
    &#125;
&#125;
运行结果：
Mammal eats
Mammal travels
</code></pre>
<p>重写接口中声明的方法时</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</li>
</ul>
<p>在实现接口的时候：</p>
<ul>
<li>一个类可以同时实现多个接口</li>
<li>一个类只能继承一个类，但是能实现多个接口</li>
<li>一个接口能继承另一个接口</li>
</ul>
<pre><code class="java">//文件名:Sports.java
public interface Sports&#123;
public void setHomeTeam ( String name ) ;
public void setVisiting&#39;Team ( String name ) ;
&#125;

//文件名: Football.java
public interface Football extends Sports&#123;
public void homeTeamScored ( int points ) ;
public void visitingTeamScored ( int points) ;
public void endofQuarter ( int quarter ) ;
&#125;

//文件名:Hockey.java
public interface Hockey extends Sports&#123;
public void homeGoalScored ( ) ;
public void visitingGoalScored ( );
public void endOfPeriod ( int period ) ;
public void overtimePeriod ( int ot ) ;
&#125;
Hockey接口自己声明了四个方法，从Sports接口继承了两个方法
这样实现Hockey接口的类需要实现六个方法
</code></pre>
<h4 id="接口的多重继承"><a href="#接口的多重继承" class="headerlink" title="接口的多重继承"></a>接口的多重继承</h4><p>在Java中，类的多重继承是不合法，但接口允许多重继承</p>
<p>在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口</p>
<pre><code class="java">public interface Hockey extends Sports, Event
</code></pre>
<p>接口允许多重继承，而Sports及Event可能定义或者继承相同的方法</p>
<h4 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h4><p>最常用的继承接口是没有包含任何方法的接口</p>
<p>标识接口作用：给某个对象打个标(盖个戳)，使对象拥有某个或者某些特权</p>
<pre><code class="java">public interface EventListenner&#123;&#125;
</code></pre>
<p><strong>建立一个公共的父接口：</strong>这是由几十个其他接口扩展的Java API，你可要使用一个标记接口来建立一组接口的父接口</p>
<p><strong>向一个类添加数据类型：</strong>实现标记接口的类不需要定义任何接口的方法，该类通过多态性变成一个接口类型</p>
<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>泛型，即“参数化类型”，泛型的本质是为了参数化类型，也就是说在泛型使用中，操作的数据类型被指定为一个参数，<u>这种参数类型可以用在类、接口和方法中</u>，分别被称为泛型类、泛型接口、泛型方法。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>该方法在调用时可以接收不同类型的参数，根据传递给泛型方法的参数类型来调用。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>就是在类名后面添加了个类型参数声明部分</p>
<p>泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数也被称为一个类型变量</p>
<pre><code class="java">public class Box&lt;T&gt;&#123;
    private T t;
    
    public void add(T t)&#123;
        this.t = t;
    &#125;
    
    public T get()&#123;
        return t;
    &#125;
    
    public static void main(String[] args)&#123;
        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();
        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();
        integerBox.add(new Integer(10));
        stringBox.add(new String(&quot;Hello World&quot;));
        sout(&quot;Integer Value :%d\n\n&quot;,integerBox.get());
        sout(&quot;String Value :%s\n\n&quot;,stringBox.get());
    &#125;
&#125;

运行结果：
Inerger Value :100
String Value :Hello World
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/05/08/后端/Java接口+泛型/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/07/英语/刘晓艳作文—段落/">
        <h2>
            刘晓艳作文—段落
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><h4 id="因果递进论证-第一句话一般都是虚拟语气"><a href="#因果递进论证-第一句话一般都是虚拟语气" class="headerlink" title="因果递进论证 (第一句话一般都是虚拟语气)"></a>因果递进论证 (第一句话一般都是虚拟语气)</h4><p>如果我们多读书，就怎么了……(<u>视野↑</u> - <u>知识多↑</u> - <u>成功</u>) [顺着往下说]</p>
<h5 id="常-用连词："><a href="#常-用连词：" class="headerlink" title="常 用连词："></a>常 用连词：</h5><ul>
<li>B results from A    A因…导致B，因为…</li>
<li>B is a result of A    B是A的结果，产生影响</li>
<li>A result in b  导致了</li>
<li>A causes &#x2F; bring about &#x2F; give rise to &#x2F; lead to B</li>
</ul>
<p>举例：<u>暴力游戏</u></p>
<p>If teenagers and youngsters spent more time playing violent video games, they would imitate these actions, becoming isolated from others. As a result, they would never communicate with others, which leads to more crimes committed by the young. In the end, there would be more worrying problems in our society.</p>
<p>举例：<u>Why students should be encouraged to develop effective communication skills.</u></p>
<p>If university students could develop effective communication skills, they could make more friends. In additio ns, the more friends they have, the more comfortable life they will have on campus. As a result, they will have a better learning environment, which consequently lead to a more harmonious context throughout the nation.</p>
<p>举例：<u>The use of translation apps</u></p>
<p>The more popular translation apps become, the more time will be saved, which thus results in the effciency of our work. That means more tasks could be completed in a certain period. As a consequence, Chinese economy will be boosted a lot.</p>
<h4 id="分类论证-在论述sth的危害或影响时适用"><a href="#分类论证-在论述sth的危害或影响时适用" class="headerlink" title="分类论证(在论述sth的危害或影响时适用)"></a>分类论证(在论述sth的危害或影响时适用)</h4><ul>
<li>比如说<u>盗版&#x2F;假冒产品&#x2F;不良广告</u>的危害：对<u>个人&#x2F;集体&#x2F;社会&#x2F;国家</u></li>
</ul>
<p><u>the importance of mutual understanding and respect in interpersonal relationships.</u></p>
<p>In a dormitory, if every member could understand and respect each other, they might become more creative and effective in their study. In addition, it is such mutual understanding in interpersonal relationships that will result in a warm campus environment. In the end, there would be less conflict throughout our country. How desirable the vision is.</p>
<ul>
<li>科技发展的好处</li>
</ul>
<p>Firstly if technology develops quickly, we can benefit a lot, saving a lot of time and energy.</p>
<p>Then, it could lead to the rapid development of our whole country, producing more products in limited time.</p>
<ul>
<li>PPT广泛应用</li>
</ul>
<p><u>The use of PowerPoint is becoming increasingly popular in calss</u></p>
<p>The use of PowerPoint, to begin with, will make the knowledge more clear for students in class, thus, it is easy for them to master the key points. In addition, teachers could save a lot of time and make their classes more vividly.</p>
<h4 id="举例论证"><a href="#举例论证" class="headerlink" title="举例论证"></a>举例论证</h4><ul>
<li>阅读名著的好处</li>
</ul>
<p>我的一个朋友，从小就阅读了大量名著，她的爱好就是读名著，每次和他谈话总觉得他的知识面很宽，很博学，作文写得也很好。</p>
<p> 举例开头：</p>
<ul>
<li><p>Although numerous cases are available for this argument, the following one about my <u>XXX</u> is the most suitable.</p>
</li>
<li><p>Countless cases can <u>account for</u> &#x2F; <u>are responsible for</u> &#x2F; <u>contribute to</u> the <u>phenomenon</u> &#x2F; <u>situation</u> &#x2F; <u>my point</u>, but <u>this</u> &#x2F; <u>these</u> will suffice. </p>
</li>
<li><p>I can figure our no better illustration than the folllowing one.</p>
</li>
<li><p>although there are numerous cases in our daily life, the following one is the most typical.</p>
</li>
</ul>
<p>总结：all in all, in conclusion</p>
<ul>
<li>the story tells us that…</li>
<li>this case effectively clarifies the fact that…</li>
</ul>
<p>为什么孩子要远离暴力游戏？</p>
<p>Although there are numerous cases in our daily life, the following one is the most typical. I have a younger brother who was naughty but cute. When he was in primary school, he learned to play video games from his classmates. At the beginning, there no abnormal signs-He went to school normally and returned home normally. Suddenly, one day, he hurt one of his friends cruelly with a knife, which was incredible to all the families. This example effectively clarifies a truth that kids can be easy to imitate behaviors from these games, which might lead to serious consequences.</p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><pre><code class="java">For this part you are allowed 30misnutes to write an essay on
whether violent video ganmes online will cause students&#39; violent
behaviors. You should write at least 120 words but no more than 180 words.
</code></pre>
<ul>
<li>引出中心 + 个人观点</li>
</ul>
<p>&#x3D;&#x3D;<u><span style = "color: red">With</span> the rapid <span style = "color: red">development</span> of science and technology, there is a hot debate about</u> violent video games online. <u><span style = "color: red">From my perspective,</span></u> these games will not cause violent behaviors among teenagers and youngsters.&#x3D;&#x3D;</p>
<ul>
<li>原因引出 + 原因分析(2~3)</li>
</ul>
<p>(and 并列两个句子 加了定语、状语) + (举三个并列句子) + (if引导虚拟语气)</p>
<p><u><span style = "color: red">The reasons for this is not far to seek.</span></u> First of all, by playing online games, <u>students</u> (<strong>who have to spend most of their time on study and prepare various examinations</strong>) <u>can relieve the pressure</u> (<strong>in real life</strong>) and find like-minded peers to communicate with. In addition, these young men know clearly that online video games are virtual. At the same time the violent elements in games are unrealistic. As a consequence, the violence in online games has little impact on real life. In the end, if they were interested in something they like, there would be less violent behaviors in our society.</p>
<p>&#x3D;&#x3D;<u><span style = "color: red">[First and formost , Addtionally , Last but not least]</span></u>&#x3D;&#x3D;</p>
<p><u><span style = "color: red">[The fact that … suggest that …]</span></u></p>
<ul>
<li>总结句(总结 + 措施 + 口号)</li>
</ul>
<p>&#x3D;&#x3D;<u><span style = "color: red">To sum up, it is my belief that</span></u>&#x3D;&#x3D; violent online games will not result in students violent tendency. <u><span style = "color: red">it is necessary that</span></u> parents lead their children to right directions. <u><span style = "color: red">Only in this way can</span></u> these kids make use of these games properly.</p>
<hr>
<hr>
<pre><code class="java">For this part you are allowed 30misnutes to write an essay online
dictionaries.You can start your essay with the sentence&quot;The use of
online dictionaries is becoming increasingly popular.&quot;You should 
write at least 120 words but no more than 180 words.
</code></pre>
<ul>
<li>引出中心 + 个人观点</li>
</ul>
<p>（<u><span style = "color: red">In light of</span> the rapid <span style = "color: red">improvement</span> of  science and technology</u>）the use of online dictionaries is becoming increasingly popular, （which has been brought into the limelight under modern confiditions.） <u><span style = "color: red">As far as I am concerned</span></u>, we should attach importance to online dictionaries now and in the future.</p>
<ul>
<li>原因引出 + 原因分析(2~3)</li>
</ul>
<p>The popularity of online dictionaries, (<u>which really brings much convenience to the everyday life and study of youngsters,</u>) may be explained by many reasons. The main factor is that using online dictionaries can save us plenty of time, which proves to be in accord with people’s pursuit for higher efficiency. Then more importantly, (<u>it is so convenient for us to look up words on the web</u>) because we can efforlessly and rapidly find what we want by tapping words or phrases and the answer comes in no more than several seconds. So why bother to take a thick dictionary whenever or wherever?</p>
<ul>
<li>总结句(总结 + 措施 + 口号)</li>
</ul>
<p>In short, it is a sound conclusion that can be drawn that the use of online dictionaries, to some extent, is beneficial to English learners. So it might the right time to download one to serve us in our daily life.</p>
<h1 id="议论文"><a href="#议论文" class="headerlink" title="议论文"></a><span style = "color: red">议论文</span></h1><p><span style = "color: red">第一段</span><u><strong>引出主题 + 论述观点</strong></u></p>
<p><strong>引出主题：</strong></p>
<ul>
<li>Recently with the <u>development &#x2F; advance &#x2F; progress</u> of science and technology, the phenomenon of … has aroused wide concern.</li>
<li>Nowadays, it is undeniable that … has almost become the biggest concern of the present-day world.</li>
<li>There is no doubt that the issue about sth has caused wide public attention recently.</li>
<li><u><span style = "color: red">Recently with</span> the rapid <span style = "color: red">development</span> of science and technology, there is a hot debate about</u></li>
</ul>
<p><strong>表示个人观点：</strong></p>
<ul>
<li>In my opinion &#x2F; as far as I am concerned &#x2F; <u><span style = "color: red">from my perspective that…</span></u>(就我而言…东西<u>好&#x2F;不好</u>)</li>
</ul>
<p><span style = "color: red">第二段</span>**<u>分析原因</u>**的总起句(三大论证方法)</p>
<p><strong>原因引出：</strong></p>
<ul>
<li><u><span style = "color: red">The reasons for this is not far to seek.</span></u></li>
</ul>
<p><strong>原因分析：</strong></p>
<ul>
<li><p>The majority of people would agree that <strong>sth</strong>(use online dictionaries) has its deep roots. </p>
</li>
<li><p><u><span style = "color: red">As we know, recognizing a problem is the first step in finding a solution.</span></u></p>
</li>
<li><p><u><span style = "color: red">First and formost , Addtionally , Last but not least</span></u> </p>
<p><u><span style = "color: red">The fact that … suggest that …</span></u></p>
</li>
</ul>
<p><span style = "color: red">第三段</span><strong><u>总结 措施 倡议段</u></strong></p>
<p><strong>总结：</strong></p>
<ul>
<li><u><span style = "color: red">From what has been mentioned above, we can safely draw the conclusion that…</span></u></li>
<li>It is high time that enough attention should be poured into this problem.</li>
<li>In short, it is a sound conclusion that can be drawn that…</li>
<li><u><span style = "color: red">To sum up, it is my belief that</span></u></li>
</ul>
<p><strong>措施：</strong><u>我们、政府、家长、学校</u></p>
<ul>
<li>Student, from their early age, could be educated &#x2F; proposed to learn the advantages and disadvantages of living in big cities.</li>
<li>Teachers could broadcast the importance of reading books among students.</li>
<li><u><span style = "color: red">it is necessary that</span></u></li>
</ul>
<p><strong>倡议：</strong></p>
<ul>
<li>So shouldn’t 人 pay much attention to the problem of …</li>
<li>So under no account could 人 divert attention from the issue of sth.</li>
<li><u><span style = "color: red">Only in this way can…</span></u></li>
</ul>
<h1 id="书信作文"><a href="#书信作文" class="headerlink" title="书信作文"></a><span style = "color: red">书信作文</span></h1><p><span style = "color: red">第一段</span><u><strong>问候语+写作目的</strong></u>(比较熟) &#x2F; <u><strong>自我介绍+写作目的</strong></u>(不熟)</p>
<ul>
<li>I am delighted to know that you have a strong desire to learn Chinese in recent days. Therefore, the letter, to be honest, is to recommend a city for you.</li>
</ul>
<h4 id="不熟"><a href="#不熟" class="headerlink" title="不熟"></a>不熟</h4><p><strong>自我介绍：</strong>I am a freshman from the department of (专业) in this university</p>
<p><strong>写作目的：</strong>The aim of my letter is to (文章会给出)</p>
<p><span style = "color: red">第二段</span><u><strong>2~3个原因分析</strong></u></p>
<ul>
<li>When the idea occurs to me, the first 8     city flashing in my mind is Beijing, the capital of China. <u>Firstly</u>, there exists language environment which plays a key role in the process of language learning. As a result, as a modern city, it provides an excellent language environment for language learners. <u>Besides</u>, in one of the biggest cities, people are open-minded, hospitable, and inclusive. You will soon find that you can make friends with them quickly.</li>
</ul>
<p><span style = "color: red">第三段</span><u><strong>总结&#x2F;感谢+期待回信</strong></u></p>
<p><strong>表示感谢：</strong></p>
<ul>
<li>I take the opportunity to show my hearfelt apperciation for your generous assistance you rendered me.</li>
</ul>
<p><strong>期待回信:</strong></p>
<p><u>XXXXXXXXXXXXXXXXXXXXXXXXXXX</u></p>
<p>Finally, I hope that you could take my suggestions into serious consideration, and I am looking forward to your reply at your earliest convenience. Good luck to you with all aspects of life. Yours sincerely, Li Ming </p>
<h1 id="报告作文"><a href="#报告作文" class="headerlink" title="报告作文"></a><span style = "color: red">报告作文</span></h1><p><span style = "color: red">第一段</span><strong><u>时间日期+发生事+事的结果</u></strong>(成功&#x2F;失败)</p>
<ul>
<li>On June 18, Sunday, a volunteer activity in the local Nursing House was organized by the Student Union which proves to be as success.</li>
</ul>
<p><span style = "color: red">第二段</span><u><strong>活动具体是什么事</strong></u>(目的 + 内容 + 感受 + 意义)</p>
<ul>
<li>The activity was aimed at encouraging students to visit the elderly at the Nursing House and help elderly people deal with their troubles in their life. Many students volunteered to participate in this good deed and were engaged in helping the elderly here out by making their meals, washing their clothes and chatting with them. When asked about those volunteers’ feelings about such an experience, all of them responded with a smile, saying “What a wonderful experience and I really appreciate this acticity beacause it makes me learn to care about those who are in heed.”</li>
</ul>
<p><span style = "color: red">第三段</span><strong><u>总结</u></strong></p>
<ul>
<li>To sum up, the activity is quite successful not only for the elderly but for those students involved.</li>
</ul>
<p>·</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ffa2c4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/07/英语/刘晓艳作文—段落/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/05/01/英语/基础语法/">
        <h2>
            基础语法
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><strong>名词性从句(</strong><u>主语、宾语、表语、同位语从句</u>)</p>
<p><strong>形容词性从句(</strong><u>定语从句</u>)</p>
<p><strong>副词性从句</strong>(<u>状语从句</u>)</p>
<h2 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h2><p>先找谓语(动词)，后面有两坨区分 </p>
<ul>
<li><strong>主谓双宾(直宾 &#x2F; 间宾)</strong> (和动词有直接关系的叫直接宾语)</li>
</ul>
<pre><code class="java">She will make him a good wife
主谓双宾 him为间接宾语 可放后面
She will make a good wife for him
</code></pre>
<p>I bring <strong>you</strong> a <strong>wife</strong> &#x3D;&gt; bring wife 所以wife是直接宾语</p>
<p>直宾间宾可以互换位置，但要<strong>加介词</strong></p>
<p>I bring a wife <strong><u>for</u></strong> you</p>
<pre><code class="java">A visit to elderly people brings them great laughter and joy.
(主 + 谓 + 间宾 + 直宾)
A          to elderly people brings great laughter and joy to them.
(主 + 谓 + 直宾 + 介词 + 间宾)
</code></pre>
<pre><code class="java">The unchecked growth of the tourism may render the environment(seriously polluted)
(主 + 谓 + 宾 + 宾补)
</code></pre>
<p>如何区分那两个？ 在中间加be动词，如果通顺就是(宾+宾补)</p>
<ul>
<li>**动词有直接关系的叫直接宾语 **</li>
<li><strong>宾补 与 宾 有关系</strong></li>
</ul>
<hr>
<p>宾语是对动词的引述 表语是对主语的补充</p>
<p><strong>要写主谓宾 就要找是否有 实义动词</strong></p>
<p><strong>要写主系表 就要看动词确实是无实义</strong></p>
<pre><code class="java">765trdx海湖最深处25.5米
The deepest point of Qinghai lake reaches 25.5 meters. 主谓宾，自己加个实义动词
The maximum depth of Qinghai lake is 25.5 meters. 主系表，谓语确定无实义
</code></pre>
<pre><code class="java">泰山方圆约400平方公里
Mount Tai covers an area of about 400 square kilometers.
</code></pre>
<p>主谓宾 和 主系表的区分 看 中间的词有没有具体含义</p>
<pre><code class="java">Peer pressure has a positive side.
主 + 谓 + 宾
</code></pre>
<pre><code class="java">Mutual trust is not a luxury, but it is a necessity.
主 + 系(无实义) + 表(主补)
</code></pre>
<p>系动词&#x2F;谓语动词：</p>
<ul>
<li><strong>动词</strong><ul>
<li>实义动词<ul>
<li>及物vt (及1个物) <ul>
<li>主谓宾</li>
<li>主谓双宾[直宾、间宾]</li>
<li>主谓宾宾补</li>
</ul>
</li>
<li>不及物vi (及2个物) <ul>
<li>[主谓] [不及物动词后面不加宾语 或者 必须接介词再加宾语]</li>
</ul>
</li>
</ul>
</li>
<li>无实义动词<ul>
<li>系动词[主系表(主从)]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="并列句"><a href="#并列句" class="headerlink" title="并列句"></a>并列句</h1><p>两个或以上独立<strong>分句</strong>，通过并列连词链接，各分句主谓完整，各分句意思同等重要，互相独立</p>
<ul>
<li>主要连词：and，or，but，yet</li>
</ul>
<h4 id="主谓一致"><a href="#主谓一致" class="headerlink" title="主谓一致"></a>主谓一致</h4><p>主谓一致指谓语动词必须在<strong>人称</strong>和**数(单复数)**与句子的主语保持一致</p>
<p>围绕着<strong>动词</strong>可以结合(<strong>三态一否</strong>：时态、语态、情态、否定)</p>
<table>
<thead>
<tr>
<th align="center">主语</th>
<th align="center">谓语&#x2F;系动词</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>第三人称&#x2F;单数</strong></td>
<td align="center"><strong>is &#x2F; was &#x2F; has &#x2F; 实义动词要在词尾加 -s 或 -es</strong></td>
</tr>
<tr>
<td align="center"><strong>复数</strong></td>
<td align="center"><strong>are &#x2F; were &#x2F; have &#x2F; 实义动词</strong></td>
</tr>
</tbody></table>
<p>意义一致：指主谓一致取决于<strong>主语的实际意义</strong></p>
<ul>
<li>All of the apples <strong>are</strong> rotten. 所有的苹果都烂了</li>
<li>All of the apple <strong>is</strong> rotten. 整个苹果都烂了</li>
<li><u>The rest of the lecture</u> <strong>is</strong> wonderful.</li>
<li><u>50% of the students in our class</u> <strong>are</strong> girls.</li>
<li><u>A number of</u> new books <strong>are</strong> on the desk.</li>
<li><u>The number</u> of students in you class <strong>is</strong> 50.</li>
</ul>
<p>I + am&#x2F;was&#x2F;have&#x2F;like</p>
<p>You + are&#x2F;were&#x2F;have&#x2F;like</p>
<p><strong>He&#x2F;She&#x2F;It + is&#x2F;was&#x2F;has&#x2F;likes （第三人称单数）</strong></p>
<p>They + are&#x2F;were&#x2F;have&#x2F;like</p>
<h4 id="时态语态"><a href="#时态语态" class="headerlink" title="时态语态"></a><strong>时态语态</strong></h4><p>时态：时间的状态</p>
<p>语态：主动或被动</p>
<h4 id="时态（重点8个）"><a href="#时态（重点8个）" class="headerlink" title="时态（重点8个）"></a>时态（重点8个）</h4><p>英语中的及物动词一般都有主动语态和被动语态两种形式。<u>被动语态</u>由助动词**be+过去分词(done)**构成。</p>
<p>助动词be随着主语的人称、数、时态和语气的不同而变化。(<strong>时态</strong>也可以加<strong>被动</strong>的BUFF噢~)</p>
<p><strong>过去完成时</strong> 一定要有过去的那个<strong>点</strong>(时间) &#x3D;&gt; (现在是12月，5月之前在长沙举办过了一个比赛)</p>
<table>
<thead>
<tr>
<th>时态</th>
<th>一般</th>
<th>进行</th>
<th>完成</th>
<th>完成进行</th>
</tr>
</thead>
<tbody><tr>
<td>现在</td>
<td><strong>do&#x2F;does</strong></td>
<td><strong>be doing</strong></td>
<td><strong>have&#x2F;has done</strong></td>
<td><strong>have&#x2F;has been doing</strong></td>
</tr>
<tr>
<td>过去</td>
<td><strong>did</strong></td>
<td><strong>was&#x2F;were doing</strong></td>
<td><strong>had done</strong></td>
<td>had been doing</td>
</tr>
<tr>
<td>将来</td>
<td><strong>will do</strong></td>
<td>will be doing</td>
<td>will have done</td>
<td>will have been doing</td>
</tr>
<tr>
<td>过去将来</td>
<td>would do</td>
<td>would be doing</td>
<td>would have done</td>
<td>would have been doing</td>
</tr>
</tbody></table>
<p>现在完成时：We <strong>have learned</strong> English for more than ten years.</p>
<p>现在完成进行时：We <strong>have been learning</strong> English for the past three months. (从过去到现在一直在做的一个动作)</p>
<ul>
<li>Do</li>
<li>did过去式：一般过去式</li>
<li>done过去分词：完成时态；被动结构be+done；非谓语</li>
<li>不规则动词变化表</li>
</ul>
<h4 id="时态翻译练习-若没有明显的时间提示-就都写一般现在时"><a href="#时态翻译练习-若没有明显的时间提示-就都写一般现在时" class="headerlink" title="时态翻译练习(若没有明显的时间提示 就都写一般现在时)"></a>时态翻译练习(若没有明显的时间提示 就都写一般现在时)</h4><ul>
<li><p>人们通常在<u>春节和其他节日期间</u>表演狮子舞。(先找句子主干 时间放后面)</p>
<p>People often play (perform) the lion dance during the Spring Festival and other festivals.</p>
</li>
<li><p>它已逐渐演变成了中国文化的独特元素。(从过去到现在 &#x3D;&gt; 现在完成时)</p>
<p>It has gradually become a special element of Chinese culture.</p>
</li>
<li><p>唐朝始于618年，终于907年，(唐朝)是<u>中国历史上</u>最灿烂的时期。(一般过去时，一般现在时[陈述事实])</p>
<p>The Tang Dynasty began in 618 and ended in 907, and it is the most splendid (glorious) period in Chinese history. </p>
<p>The Tang Dynasty was from in 618 and ended in 907, which and it is the most splendid (glorious) period in Chinese history.</p>
</li>
</ul>
<h4 id="被动语态翻译练习-中文会省略”被”字，要学会感受中文被动-x3D-gt-楼盖好了，桥修好了"><a href="#被动语态翻译练习-中文会省略”被”字，要学会感受中文被动-x3D-gt-楼盖好了，桥修好了" class="headerlink" title="被动语态翻译练习 (中文会省略”被”字，要学会感受中文被动) &#x3D;&gt; [楼盖好了，桥修好了]"></a>被动语态翻译练习 (中文会省略”被”字，要学会感受中文被动) &#x3D;&gt; [楼盖好了，桥修好了]</h4><ul>
<li>剪纸<strong>被用来</strong>装饰门窗和房间。**(泛指s)**</li>
</ul>
<p>Paper cuttings <strong>are used</strong> to decorate doors, windows and rooms.</p>
<ul>
<li>自<u>上世纪90年代</u>(?主语)安装缆车以来，参观人(de)数大大增加。 <strong>(缺主语 把宾语变成主语然后被动，有since主句用现在完成时)</strong></li>
</ul>
<p>Since cable cars <strong>were installed</strong> (used) in the 1990s, the number of visitors <strong>has increased</strong> sharply.</p>
<ul>
<li>核能是可以(被)<u>安全(de)</u><strong>开发和利用</strong>的。</li>
</ul>
<p>Nuclear power(energy) can be explored &#x2F; developed and used safely.</p>
<ul>
<li>整个<strong>义务教育</strong>阶段，(?)要求学生(被动)<u>在每学期期末</u>参加期末考试。(缺主语 把宾语变成主语然后被动) Compulsory course：必修课</li>
</ul>
<p>Throughout the whole period of <strong>compulsory education</strong>, students <strong>are required</strong> to take the final exam at the end of each term.</p>
<ul>
<li>今年<u>在长沙</u>(?)举行了一年一度的<u>外国人</u>汉语演讲比赛。 (对象 for sb 对于谁而言)(一般过去时)(主语是比赛 所以是was)</li>
</ul>
<p>An annual Chinese speech <strong>contest</strong> for foreigners <strong>was held</strong> in Changsha this year.</p>
<h1 id="复合句"><a href="#复合句" class="headerlink" title="复合句"></a>复合句</h1><p>看复杂的句子先找<strong>主句</strong>然后再找<strong>主干</strong>(<u>主句</u>表达主要意思 <u>从句</u>表达次要意思)</p>
<h4 id="三大从句"><a href="#三大从句" class="headerlink" title="三大从句"></a>三大从句</h4><ul>
<li>名词性从句(主语&#x2F;宾语&#x2F;表语可以充当名词)<ul>
<li>主语从句(识别及理解、It形式主语的类型)</li>
<li>宾语从句</li>
<li>表语从句</li>
<li>同位语从句</li>
</ul>
</li>
<li>形容词性从句<ul>
<li>定语从句</li>
</ul>
</li>
<li>副词性从句<ul>
<li>状语从句</li>
</ul>
</li>
</ul>
<h3 id="主语从句-把主语变成了一个句子"><a href="#主语从句-把主语变成了一个句子" class="headerlink" title="主语从句(把主语变成了一个句子)"></a>主语从句(把主语变成了一个句子)</h3><p>主语从句的识别及理解、It形式主语的类型</p>
<p>开头为That &#x2F; Whether(是否) 或者 主语 就是<strong>主语从句</strong>(<u>截止到第二个动词前</u>)</p>
<pre><code class="java">[That the little boy got the first prize] made his family relatives (so proud).
主(主从) + 谓 + 宾 + 宾补
==&gt; It made his family relatives so proud that the little boy got the first prize.
</code></pre>
<pre><code class="java">&#123;That people often experience trouble sleeping in a different bed in unfamiliar 
surroundings&#125; is a phenomenon (known as the &quot;first-night&quot; effect).
主&#123;主从&#125; + 系 + 表 + (后置定语)
That无成分，无含义，不能省
</code></pre>
<pre><code class="java">Whether such taxes work is a matter of debate.
主(主从) + 系 + 表
</code></pre>
<pre><code class="java">[How students ultimately handle stress] may depend on their personal 
test-taking abilities.
主(主从) + 谓 + 宾
</code></pre>
<h5 id="形式主语-若it不确定何种意思-就为形式主语-x3D-gt-寻找真正的主语"><a href="#形式主语-若it不确定何种意思-就为形式主语-x3D-gt-寻找真正的主语" class="headerlink" title="形式主语(若it不确定何种意思 就为形式主语 &#x3D;&gt; 寻找真正的主语)"></a>形式主语(若it不确定何种意思 就为形式主语 &#x3D;&gt; 寻找真正的主语)</h5><p>①后面的to do    ②后面的that</p>
<pre><code class="java">In today&#39;s job market, it&#39;s not uncommon for job seekers to submit 
applications for many positions.
It = to submit applications for many positions
</code></pre>
<pre><code class="java">[&#123;It&#39;s&#125; commonly known] that certain diseases are linked with occupations like
lung disease in coal miners.
</code></pre>
<p>常见的形式主语句型</p>
<pre><code class="java">It is surprising that... 令人惊讶的是...
It is obvious that... 显而易见的是...
It&#39;s said that... 据说...
It&#39;s reported that... 据报道...
It&#39;s commonly known that... 众所周知, ...
It is a fact that... 事实上是...
It is a common knowledge that ... 众所周知，...
It + be + 形容词 + that ...
It + be + 过去分词 + that ...
It + be + 名词 + that...
</code></pre>
<h3 id="宾语从句-及物动词后-or-介词后"><a href="#宾语从句-及物动词后-or-介词后" class="headerlink" title="宾语从句(及物动词后 or 介词后)"></a>宾语从句(及物动词后 or 介词后)</h3><p> 及物动词后的宾语从句(<strong>不及物动词</strong> + 介词 + 宾语)</p>
<p>介词后的宾语从句</p>
<pre><code class="java">我明白了 -&gt; 后面的一个字说不清 要一个句子()
I have learned [that love, not time, heals all wounds.]
heal：V.治愈    
wound：n.创伤，伤口
</code></pre>
<pre><code class="java">Therefore, &#123;it is vital that&#125; educators everywhere take a careful look not only at 
[what is being done], but also at [what should be done] in the field of computer 
education.
&#123;&#125;内的为 主从
[]内的为 宾从 现在进行时被动
</code></pre>
<h3 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h3><p><strong>系</strong>动词  后面的就是 表语从句 One is(是什么…)</p>
<pre><code class="java">There are tow worring features of the slowdown. One is [that it has been particularly sharp
in the world&#39;s most populous countries, India and China.]  
</code></pre>
<h3 id="同位语从句-用一句话来解释一个抽象名词"><a href="#同位语从句-用一句话来解释一个抽象名词" class="headerlink" title="同位语从句(用一句话来解释一个抽象名词)"></a>同位语从句(用一句话来解释一个抽象名词)</h3><p><strong>解释一个抽象名词，它是什么……</strong></p>
<p>同位语不是主干(主谓宾、主系表……) <u>[前面的名词n]和 [后面的名词n] 地位相同的时候</u></p>
<p>把和前面相同的名词变成一个<strong>句子</strong> &#x3D;&gt; 同位语从句</p>
<pre><code class="java">There is a popular saying that [family happiness spurs social stability.]
a saying = family happiness spurs social stability
</code></pre>
<p><strong>[n -&gt; 句子]</strong> 用一个句子代替名词：<strong>名词性从句</strong></p>
<p>在句子的<strong>主干</strong>中能**<u>代替名词</u><strong>的成分有：</strong>主语、宾语、表语、同位语**</p>
<hr>
<hr>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><pre><code class="java">Whether the eyes are &quot;the windows of the soul&quot; is debatable; that they are
intensely important in interpersonal communication is a fact.
</code></pre>
<p>{<strong>Whether</strong> the eyes are “the windows of the soul” } is debatable;</p>
<p>{<strong>that</strong> they are intensely important in interpersonal communication} is a fact.  [主语从句] [they -&gt; eyes]</p>
<pre><code class="java">It is reported &#123;that 49 million Americans are unsure of [where they will
find their next meal.]&#125;
</code></pre>
<pre><code class="java">Dr.White said (that) his team wanted to see &#123;whether living in greener utban areas had
a lasting positive effect on people&#39;s sense of well-being&#125; or &#123;whether the effect
also disappeared after a period of time.&#125;
</code></pre>
<pre><code class="java">As a teacher who has worked in four countries, I have had the experience [that a student
who earns good marks is generally a good student],and [that a student&#39;s final mark in
a subject is usually a grade average of the year&#39;s work.]
两个定语从句 两个同位语从句
</code></pre>
<h3 id="定语从句-类似于形容词，其功能是划定一个范围"><a href="#定语从句-类似于形容词，其功能是划定一个范围" class="headerlink" title="定语从句(类似于形容词，其功能是划定一个范围)"></a>定语从句(类似于形容词，其功能是划定一个范围)</h3><p>规定一个范围 但是<u>用一个形容词搞不定</u> 所以成为了一句话 因此变成了从<strong>句</strong></p>
<p>用<u>一个形容词</u>作定语修饰名词或代词。</p>
<p>若要表达更复杂的意思，则需要借助<u>一个句子</u>来修饰名词</p>
<pre><code class="java">I don&#39;t like (lazy) people.
I don&#39;t like people (who don&#39;t love their own country.)
</code></pre>
<p><strong>定语从句：</strong><u>先行词 + 关系词 + 定语从句</u></p>
<p>I don’t like people (who don’t love their own country.)</p>
<ul>
<li>先行词：被修饰的名词、代词，总在定语从句前面 <u><strong>[people]</strong></u></li>
<li><strong>关系词</strong>：<span style = "color: red">(关系代词，关系副词)</span><u> <strong>连接</strong>主句和从句</u>，<u><strong>指代</strong>先行词</u>，<u>在定语从句中<strong>充当</strong>一定<strong>成分</strong>的词</u> <u><strong>[who 充当主语]</strong></u><ul>
<li>简要作用：(连接、指代、充当成分)</li>
</ul>
</li>
<li>定语从句：不完整的句子</li>
</ul>
<p><strong>先行词：</strong>一个<strong>词</strong>，<strong>短语</strong>，<strong>句子</strong></p>
<pre><code class="java">Another trend【that looks significant in 2015】is (that America&#39;s largest population
group, Millennials, will continue to put off buying a house.)
主 + 【v+...】 + v
【】定从    []宾从        
()表从     &#123;&#125;主从
</code></pre>
<pre><code class="java">And exercise releases hormones【that can improve mood and relieve stress】
,【which can also help learning.】
先行词：hormones
关系词：that，which（这）代替前面一整个句子【exercise ... stress】
</code></pre>
<p>关系代词：<strong>代</strong>词 &#x3D;&gt; 替代一个东西的词 (表中前三个)</p>
<p>关系副词：定语从句标识符 (表中后三个)    </p>
<ul>
<li><strong>时间名词</strong> + when</li>
<li><strong>地点名词</strong> + where;</li>
<li><strong>reason</strong> + why</li>
</ul>
<p>[介词 + 关系代词 &#x3D; 关系副词]</p>
<table>
<thead>
<tr>
<th align="center">先行词</th>
<th align="center">关系词</th>
<th align="center">充当从句成分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事 &#x2F; 物</td>
<td align="center">which &#x2F; that</td>
<td align="center">主语 &#x2F; 宾语</td>
</tr>
<tr>
<td align="center">人</td>
<td align="center">who &#x2F; whom &#x2F; that</td>
<td align="center">主语 &#x2F; 宾语</td>
</tr>
<tr>
<td align="center">人 &#x2F; 物 (所属关系)</td>
<td align="center">whose</td>
<td align="center">定语</td>
</tr>
<tr>
<td align="center">时间</td>
<td align="center">when</td>
<td align="center">状语</td>
</tr>
<tr>
<td align="center">地点</td>
<td align="center">where</td>
<td align="center">状语</td>
</tr>
<tr>
<td align="center">reason原因</td>
<td align="center">why</td>
<td align="center">状语</td>
</tr>
</tbody></table>
<h6 id="【】定从-宾从-表从-主从-lt-gt-同位语从句"><a href="#【】定从-宾从-表从-主从-lt-gt-同位语从句" class="headerlink" title="【】定从    []宾从    ()表从     {}主从     &lt;&gt;同位语从句"></a>【】定从    []宾从    ()表从     {}主从     &lt;&gt;同位语从句</h6><pre><code class="java">We found that[for some lottery winners]【who had won more than 500,000 prounds】
the positive effect was definitely there, but after six months to a year,
they were back to the baseline.
关系代词(who 代指前面的 winners)
</code></pre>
<pre><code class="java">定语从句-关系副词 when
Our schools need both the talent and the organization to educate each child
【who arrives at the school door.】Some show up ready, but many do not at
this critical time【when young brains are developing rapidly.】
At this critical time: 在这一关键时刻
When: 此时，在这时
</code></pre>
<pre><code class="java">定语从句-关系副词 where
Recently I attended several meetings【where we talked about ways to retain
students and keep younger faculty members from going elsewhere.
where：在这里，在...地方
retain：保持，保留，挽留
</code></pre>
<pre><code class="java">定语从句-关系副词 where
The center of American automobile innovation has in the past decade moved
2,000 miles away. It has migrated from Detroit to Silicon Valley,【where
self-driving vehicles are coming to life.】
has moved：现在完成时        in the past decade：时间状语
It：代指汽车研发中心          
</code></pre>
<pre><code class="java">定语从句-关系副词 why
This is the reason【why I was absent from that meeting.】
The reasons why【I recommend Beijing can be listed as follows...】
</code></pre>
<pre><code class="java">定语从句-介词 + 关系代词    
[先行词 + 介词 + which / whom]    modify: v.修改，改变
[介词 + 关系代词 = 关系副词]
Furthermore, humans have the ability to modify the environment(in which) 
they live.
Furthermore, humans have the ability to modify the environment where they live.
英语中通常不用介词收尾，常常把介词提到关系代词前。the environment which they live (in)
</code></pre>
<h4 id="限定性定语从句-与-非限定性定语从句"><a href="#限定性定语从句-与-非限定性定语从句" class="headerlink" title="限定性定语从句 与 非限定性定语从句"></a>限定性定语从句 与 非限定性定语从句</h4><p>区别在于表达方：</p>
<ul>
<li><p>如果想写 那一帮出租司机都绕路了 就用<strong>限定性定语从句</strong>(限定：<u>给它限定个范围</u>)</p>
</li>
<li><p>如果想写 所有出租车司机都绕路了 就用<strong>非限定性定语从句</strong>(不做限定)</p>
</li>
</ul>
<pre><code class="java">【限制性】：知道那里堵车的出租司机换了另一条路。
The cab drivers who knew about the traffic jam took another road.
</code></pre>
<pre><code class="java">The cab drivers，who knew about the traffic jam，took another road.
【非限定性】(非：不限定 ==&gt; 不让它范围有变化)(用逗号隔开)
The cab drivers took another road，who knew about the traffic jam.
出租司机都换了另一条路，出租车司机都知道那里堵车了。
</code></pre>
<pre><code class="java">【限定】：(有一帮女儿是老师，其他的不确定噢~)
She has tow daughters who are teachers.
她有两个(是老师的)女儿.[可能有其他女儿 只不过有两个做老师的女儿]
    
【非限定】：(隔开了就是不限定 没有限制范围 所有的女儿都是老师)
She has tow daughters，who are teachers.
她只有这两个女儿，这两个女儿都是老师
</code></pre>
<h4 id="限定性定语从句-与-同位语从句"><a href="#限定性定语从句-与-同位语从句" class="headerlink" title="限定性定语从句 与 同位语从句"></a>限定性定语从句 与 同位语从句</h4><p>定语从句会缩小范围 &#x3D;&gt; [不知道听到的新闻是什么…]</p>
<p>同位语从句是 一个<strong>句子</strong> 和 一个<strong>名词</strong> 进行对等 &#x3D;&gt; [知道新闻的内容：林肯被谋杀了]</p>
<pre><code class="java">定从：
The news【that you heard】is not true.
that: 指代news 做you heard的宾语
在定语从句中关系词that有含义、充当句子成分
</code></pre>
<pre><code class="java">同位语从句: 林肯在剧院遭到谋杀的新闻是真的
The news &lt;that Lincoln was murdered at a theater&gt; is true.
that: 不充当任何成分，去掉句子照常通顺(句子完整)
在同位语从句中that无含义，不充当句子成分
</code></pre>
<pre><code class="java">The fact &lt;that artisans,【who were looked on as mechanics or skilled
workers in the eighteenth century,】are frequently considered artists
today&gt; is directly attributable to the Arts and Crafts Movement of 
the nineteenth century.
be attributable to: 可归因于    artisan: n.工匠，技工    mechanic：n.机械师
The fact抽象名词 fact是主语 &lt;that为同位语从句 一直到&gt; 谓语
that同位语从句中有动词：,are   工匠经常在今天被认为是艺术家 ↓(这个事实的原因)    
who定语从句中有动词：were looked  (原因：就是十九世纪的那场运动)
所以The fact的动词就是在后面的 is
句子结构：主 &lt;that同位语从句：主【who非限定性定语从句：主谓宾】+谓+宾&gt; +系+表
★翻译原则★：剥洋葱一样从内往外一层一层的翻译
★ 在18世纪的时候工匠通常被人们认为是机械师或技术工人，而到了今天人们会认为工匠是艺术家，
这个事实最主要的原因是十九世纪的这场运动。
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#1bccbc>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/05/01/英语/基础语法/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/30/英语/刘晓艳作文—基础/">
        <h2>
            刘晓艳作文—基础
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="四级写作常考的题型："><a href="#四级写作常考的题型：" class="headerlink" title="四级写作常考的题型："></a>四级写作常考的题型：</h4><ul>
<li>论说文</li>
<li>书信</li>
<li>其他(新闻稿等)</li>
</ul>
<p><strong>时间：</strong>30分钟(3min审题与构思 + 20min + 2)</p>
<p><strong>字数：</strong>120~180words（12行-15行）</p>
<h1 id="具体要求："><a href="#具体要求：" class="headerlink" title="具体要求："></a>具体要求：</h1><ul>
<li><p>语言**<u>第一位</u><strong>！</strong>单词**：正确 多变     <strong>语法</strong>：正确 多变</p>
</li>
<li><p>结构**<u>第二位</u><strong>！</strong>结构<strong>：句子和句子之间一定要多用</strong>逻辑关系词**</p>
<ul>
<li><p><strong>表示因果</strong>(世界上最重要的一种关系就是因果关系)</p>
<ul>
<li><p>表示原因：</p>
<p>(<strong>because</strong>，<u>in that</u>，as，<u>since</u>) + 句子</p>
<p>(<strong>because of</strong> &#x3D; due to &#x3D; <strong>owing to</strong> &#x3D; thans to) + n&#x2F;ving</p>
</li>
<li><p>表示结果：</p>
<p>so &#x3D; hence &#x3D; <strong>therefore</strong> &#x3D; thereby &#x3D; thus &#x3D; <strong>consequently</strong></p>
<p>&#x3D; in consequence &#x3D; <strong>as a result</strong> &#x2F; consequence</p>
</li>
</ul>
</li>
<li><p><strong>表示对比</strong></p>
<ul>
<li><p>表示”相似性的”对比</p>
<p>likewise &#x3D; similarly &#x3D; <strong>equally</strong> &#x3D; simultaneously </p>
<p>&#x3D; <strong>at the same time</strong> &#x3D; in the meanwhile</p>
</li>
<li><p>表示”差异性的”对比 (但是)</p>
<p>but，by contrast &#x3D; conversely &#x3D; alternatively</p>
<p>&#x3D; <strong>on the contrary</strong> &#x3D; on the other hand &#x3D; otherwise</p>
<p>&#x3D; while &#x3D; whereas</p>
</li>
</ul>
</li>
<li><p><strong>表示递进</strong></p>
<p>​        <strong>besides</strong> &#x3D; also &#x3D; <strong>in addition</strong> &#x3D; moreover &#x3D; furthermore </p>
<p>​        &#x3D; apart &#x2F; aside from this</p>
</li>
<li><p><strong>表示让步</strong> (虽然尽管)</p>
<ul>
<li><p>[ (<strong>Desipite</strong>(介) &#x3D; <strong>in spite of</strong> ) + n &#x2F; ving ] &#x3D; not withstanding &#x3D; although</p>
<p>&#x3D; though &#x3D; as &#x3D; while &#x3D; even (if) &#x3D; much as(用于句首)</p>
<p>&#x3D; granting &#x2F; granted that</p>
</li>
<li><p>Undoubtedly &#x3D; <strong>there is no doubt that…</strong> 毫无疑问的是…</p>
</li>
<li><p>it may be true that… 或许真实的是…</p>
</li>
<li><p><strong>there is no denying that…</strong> 不可否认的是</p>
</li>
</ul>
</li>
<li><p><strong>表示引出新对象</strong></p>
<ul>
<li><p>about &#x3D; concerning &#x3D; regarding &#x3D; with regard to</p>
<p>&#x3D; as for &#x2F; to &#x3D; in respect of 关于</p>
</li>
<li><p>in terms of 就…而论，在…方面</p>
</li>
<li><p>when it comes to …当提到…时</p>
</li>
</ul>
</li>
<li><p><strong>表示总结</strong></p>
<ul>
<li><p>on the whole &#x3D; all in all &#x3D; overall &#x3D; <strong>in conclusion</strong> &#x2F; summary &#x2F; <strong>general</strong></p>
<p>&#x3D; <strong>generally</strong>(speaking) &#x3D; as a whole &#x3D; mainly &#x3D; substantially &#x3D; to sum up</p>
<p>&#x3D; conclude &#x3D; come to the conclusion 总的来说</p>
<p>&#x3D; in short &#x2F; brief &#x3D; <strong>in a word</strong> 简而言之</p>
</li>
</ul>
</li>
<li><p><strong>表示举例</strong></p>
<ul>
<li><p><strong>such as</strong> &#x3D; <strong>for</strong> instance &#x2F; <strong>example</strong> &#x3D; a good case in point &#x3D; to illustrate</p>
<p>&#x3D; as an illustration</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内容**<u>第三位</u>**：(不重要 只是用来凑字数)</p>
</li>
</ul>
<h4 id="句子的类型"><a href="#句子的类型" class="headerlink" title="句子的类型"></a>句子的类型</h4><p><span style = "color: red"><strong>被动</strong>、<strong>There be</strong>、<strong>It结构</strong>(头重脚轻+强调句)、<strong>复合句</strong>(同位语+同位语从句，定语+定语从句，状语+状语从句)、<strong>虚拟语气</strong>(if+it is necessary)、<strong>倒装</strong>(so…that+only-状语)</span></p>
<ul>
<li><p>结构上分为：简单句 并列句 复合句(名词性从句，定语从句，状语从句)</p>
</li>
<li><p>语序上分为：倒装和正常语序</p>
</li>
<li><p>语态上分为：主动和被动</p>
</li>
</ul>
<h1 id="被动结构"><a href="#被动结构" class="headerlink" title="被动结构"></a>被动结构</h1><h4 id="一句话中只能有一个做谓语，其他的多余动词要做非谓语"><a href="#一句话中只能有一个做谓语，其他的多余动词要做非谓语" class="headerlink" title="(一句话中只能有一个做谓语，其他的多余动词要做非谓语)"></a>(一句话中只能有一个做谓语，其他的多余动词要做非谓语)</h4><p><u>一句话上来先找主谓(定语态 定时态)</u> 剩下的东西以状语形式出现</p>
<p><span style = "color:red"><strong>当一句话需要动词却没有动词，可以永远加Be</strong></span></p>
<ul>
<li>前面在修路：The road is being built in front.</li>
<li>全球在变暖：It is becoming warm throughout the world</li>
<li>狗没有找到：The dog wasn’t found</li>
<li>北京西站就要到了：We are arriving at BJ station</li>
<li>他看着我，笑着离开了：He <strong>saw</strong> me，smiling and leaving</li>
<li>有很多人喜欢冬泳：There <strong>are</strong> a host of children and adults liking to swim in winter</li>
<li>有意义就是好好活：Being meaningful is to live well</li>
</ul>
<h1 id="There-be句型"><a href="#There-be句型" class="headerlink" title="There be句型"></a>There be句型</h1><p>当一句话没有主语，并且<u>谓语动词</u>是<strong>“有”</strong>的时候就可以考虑写成 There be 句型</p>
<pre><code class="java">目前关于孩子和父母的关系问题有一个激烈的讨论
There is a hot debate about the topic on the relationship between
parenys and therir chilidren.
</code></pre>
<pre><code class="java">毫无疑问线上词典在大学生中越来越受欢迎
There is no denying that online dictionaries are becoming increasingly popular with college students.
</code></pre>
<pre><code class="java">有两个原因可以解释我的观点
There are tow arguments to account for my perspective
account 不算是谓语 因为前面有介词 变成了动词不定式
</code></pre>
<blockquote>
<p>[语法详解：There be句型的使用规则(含练习题及答案） - 知乎 (zhihu.com)](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147350559#:~:text=%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3%EF%BC%9AThere">https://zhuanlan.zhihu.com/p/147350559#:~:text=语法详解：There</a> be句型的使用规则 (含练习题及答案） 1 1.There is%2B单数可数名词%2F不可数名词%2B其他 如：There is,some students on the playground. … 5 5.Therebe句型的一般疑问句)</p>
</blockquote>
<h1 id="it结构"><a href="#it结构" class="headerlink" title="it结构"></a>it结构</h1><h5 id="【】定从-宾从-表从-主从"><a href="#【】定从-宾从-表从-主从" class="headerlink" title="【】定从    []宾从  ()表从  {}主从"></a>【】定从    []宾从  ()表从  {}主从</h5><ul>
<li><p>避免头重脚轻</p>
<p><strong>动名词充当主语</strong>可以放句首</p>
<p><strong>不定式充当主语</strong>可以放在句末</p>
<ul>
<li><p>当<strong>动词不定式</strong>充当主语的时候：把动词不定式放在句末去，加it来做形式主语</p>
<pre><code class="java">打你是我的错
Beating you is my fault.
It is my fault to beat you.
</code></pre>
</li>
</ul>
<pre><code class="java">帮助更多的同学建立自信是我们这次活动的目的(主系表)
【Helping more students build confidence】is our purpose of this activity.
Our purpose of this activity is to h elp more students build confidencce.
</code></pre>
</li>
<li><p>主语从句</p>
<p><u>显而易见，众所周知：</u>可以写<strong>开头、中间、结尾</strong>(可以写在任何一个句子前面)</p>
<p>(推荐第一段 以及 第二段前方)</p>
<p>观点看法：perspective、outlook、standpoint</p>
<ul>
<li>It is common knowledge that… 显而易见,众所周知</li>
<li>It is my belief that… &#x3D; I think that… <strong>我认为</strong></li>
<li>It is self-evident that… 显而易见,众所周知</li>
<li>It has been found that… 显而易见,众所周知</li>
<li>It is beyond dispute that… 显而易见,众所周知</li>
<li>It is universally acknowledged that… 显而易见,众所周知</li>
<li>It has been widely accepted that… 显而易见,众所周知</li>
<li>It is generally agreed that… 显而易见,众所周知</li>
</ul>
<pre><code class="java">①大学教育极大地促进了社会的进步是显而易见的
It is beyond dispute that university education promotes the progress of our society obviously.

②我认为养宠物这个话题现在应该引起人们的关注了
It is my perspective that the issue about raising pets should be brought into the limelight under
modern conditions.
</code></pre>
</li>
<li><p><span style = "color: red">强调句型</span>(<strong>谓语</strong>不能强调，其余可以强调)</p>
<p>it is…that…</p>
<pre><code class="java">③也是在明代，由郑和率领的船队曾到印度洋进行了七次大规模探险航行
it is also in the Ming Dynasy that the ships led by ZhengHe went to the Ocean
④随着时间的推移，丝绸之路逐渐变成了一条连接东西方的主要道路，促进了东西方的经济文化交流
As time went by, it is the Silk Road that gradually became a major road
connecting the East and the West, promoting economic and cultural exchanges
between the two parties.
</code></pre>
</li>
</ul>
<h1 id="复合句"><a href="#复合句" class="headerlink" title="复合句"></a>复合句</h1><h5 id="同位语的使用：解释名词的成分-这辈子只能出现在名词后面"><a href="#同位语的使用：解释名词的成分-这辈子只能出现在名词后面" class="headerlink" title="同位语的使用：解释名词的成分(这辈子只能出现在名词后面)"></a><span style = "color: red">同位语</span>的使用：解释名词的成分(这辈子只能出现在名词后面)</h5><p>名词做同位语就是(在<u>名词后</u> <u>再加一个名词</u>来<strong>解释前面那个名词</strong>)</p>
<p>只要在作文中见到名词，都可以在他后面再加一个名词作为它的同位语出现</p>
<pre><code class="java">Hunting for jobs,&lt;a hot topic among undergraduates,&gt; has become the public concern recently.
Optimism, a positive attitude, plays a key role in the general routine of everyday living.
</code></pre>
<pre><code class="java">他已经找到了女朋友这件事情 使家人很开心
简单：The matter makes his families rejoiced.
复杂：The matter that he has found a girlfriend makes his families rejoiced.
</code></pre>
<p>名词 + that + … + suggest that + …</p>
<p><span style = "color: red">The fact that … suggest that …</span>【第二段分析原因时使用】</p>
<pre><code class="java">在大城市生活会增加每天通勤的成本这个事实表明，你在大城市生活会更容易疲倦
The fact that it will increase the cost of your daily commute suggests that
you tend to get tired more easily in big cities.
</code></pre>
<pre><code class="java">当地人非常的好客热情这个事实表明，你会爱上这座城市，不愿意离开的
The fact that the locals are very hospitable and friendly shows that you will love this city,
unwilling to leave there.
(因为一句话已有一个动词存在love 所以unwill要变成非谓语)
</code></pre>
<h4 id="定语和定语从句"><a href="#定语和定语从句" class="headerlink" title="定语和定语从句"></a>定语和定语从句</h4><p>只要在作文中见到<strong>名词</strong>，都可以有意识的在作文中加入<strong>定语</strong>的成分</p>
<p><strong>介、短、定从、非谓语、名词</strong> &#x3D;&gt; 可修饰名词</p>
<ul>
<li><ul>
<li><ul>
<li><strong>先找主谓宾，再加定状补！！！</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">I love the girl singing on the stage
I love the girl who is singing on the stage
I love the girl in front of me (介词短语修饰名词)
I love the mother of that girl (名词修饰名词)
I love the girl of kindness (名词修饰名词)
I love the girl being as kind as an angel (非谓语修饰名词)
I love the girl who keeps so kind (定语从句修饰名词)
</code></pre>
<ul>
<li><u>我们</u>应该<u>尊重</u>那些<strong>正在为梦想奋斗</strong>的<u>穷孩子</u></li>
</ul>
<pre><code class="java">We should respect poor children who are struggling for their dreams.(主从)
We should respect poor children struggling for their dreams. (非谓语)
</code></pre>
<ul>
<li>被上帝抛弃的那个<u>男人</u><strong>最终</strong><u>死去了</u> (at last时间状语比较灵活)</li>
</ul>
<pre><code class="java">The man who was abandoned by God died at last. (过去分词做定语) 
</code></pre>
<ul>
<li>那个老人在他儿子到达的那天去世了(只有在缺少成分的时候才用that)</li>
</ul>
<p><strong><span style = "color: red">(此句子用when 因为句子不充当成分)</span></strong></p>
<pre><code class="java">The old man died on the day when his son arrived
</code></pre>
<ul>
<li>在舞台上唱歌的<u>那个女孩子</u><u><strong>是</strong></u>大雁的<u>女儿</u></li>
</ul>
<pre><code class="java">The girl singing on the stage is the daughter of DaYan.
</code></pre>
<ul>
<li>这是一个关于月亮和六便士的故事(专有名词前面加the )(介词短语修饰名词)</li>
</ul>
<pre><code class="java">This is a fiction about the moon and six pence.
</code></pre>
<ul>
<li>龙井是一种绿茶，主要产自中国东部沿海的浙江省(which可用于指代前面的名词)</li>
</ul>
<pre><code class="java">Longjing is a type of green tea which is mainly produced in
zhejiang Province, the coastal area in east China. 
Longjing is a type of green tea which come from zhejiang 
Province, near the sea.
</code></pre>
<ul>
<li>乌镇是浙江的一座古老水镇，坐落在京杭大运河畔</li>
</ul>
<pre><code class="java">Wuzhen，which is an ancient water town in Zhejiang province, is located by
the beijing-Hangzhou Grand Canal.
    
Wuzhen is an ancient water town in Zhejiang province, which is located by
the beijing-Hangzhou Grand Canal.
</code></pre>
<ul>
<li>功夫是中国武术的俗称。中国武术的起源可以追溯到自卫的需要、狩猎活动以及古代中国的军事训练。它是中国传统体育运动的一种，年轻人老年人都练。</li>
</ul>
<pre><code class="java">Kung Fu is the common name of chinese train which come from protect oneself needs, 
hungting animals and army training in ancient China. Besides, it is a traditional
Chinese sport that both the young and the elderly can practise.
</code></pre>
<ul>
<li>剪纸是中国最流行的传统民间艺术形式之一，中国剪纸有一千五百多年的历史，在明朝和清朝时期特别流行</li>
</ul>
<pre><code class="java">Paeper cutting is one of the most popular arts in china which has a 1500-year history and was quite famous in the Ming and Qing dynasties.
</code></pre>
<ul>
<li>中国人自古以来就在中秋节庆祝丰收，这与北美庆祝感恩节非常相似</li>
</ul>
<pre><code class="java">Chinese have had the tradition to celebrate harvesrt in the Middle-Autumn Festival, 
which proves quite similar to Thanks giving Day in north America.
</code></pre>
<h3 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h3><p>只要确定不是主谓宾，只要没有跟在名词后做<strong>定语</strong>或<strong>同位语</strong></p>
<p>作文中任何一个地方都可以加状语从句</p>
<p>成分：(<strong>介、短、定从、非谓语、名词</strong> )</p>
<p><span style = "color: red"><strong>主 谓 宾 表</strong></span></p>
<p><span style = "color: red"><strong>同位语</strong><u>解释</u>名词 <strong>定语</strong><u>修饰</u>名词 <strong>状语</strong><u>修饰</u>除名词以外的所有成分</span></p>
<ul>
<li>什么是状语：除了名词不能修饰 其余什么都可以修饰</li>
</ul>
<p>He looks <u>extremely</u> handsome (形容词做状语)</p>
<p>At last, succeeded <u>at a highcost</u>(介词短语做状语)</p>
<ul>
<li><p>状语的成分：1. <strong>adv</strong>  2. <strong>介词短语</strong>  3.<strong>非谓语动词</strong>  4.<strong>从句</strong></p>
</li>
<li><p>状语的使用：</p>
<ul>
<li><strong>时间</strong>状语</li>
<li><strong>地点</strong>状语</li>
<li><strong>原因</strong>状语</li>
<li><strong>目的</strong>状语(目的是…，为了…)</li>
<li><strong>条件</strong>状语(如果…)</li>
<li><strong>结果</strong>状语(so…that，如此…以至于)</li>
<li><strong>方式</strong>状语(by、through，通过……)</li>
<li><strong>让步</strong>状语(althrough，虽然…尽管)</li>
<li><strong>伴随</strong>状语(with)</li>
<li><strong>比较</strong>状语(as…as，than…)</li>
<li><strong>副词</strong></li>
</ul>
</li>
</ul>
<pre><code class="java">I love my girlfriend...
原因状语：I love my girlfriend without any reasons
目的：I love my girlfriend in order to marry her
</code></pre>
<h3 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h3><p>表示与<strong>事实相反</strong>，或者<strong>语气委婉</strong>  </p>
<p><span style = "color: red">在第二段原因处可使用</span></p>
<p>If引导的条件状语从句(主将从现)</p>
<p><u>如何把一个正常条件状语从句变成一个虚拟语气？</u></p>
<p><strong>只需要把已经写好的句子的时态，变成它的过去式</strong></p>
<ul>
<li>过去的过去 &#x3D;&gt; 过去完成时</li>
</ul>
<pre><code class="java">If you are a tear in my eye, I will never shed it.
If you were a tear in my eye, I would never shed it.
    
If I was a dog last night, I could sleep in bed with you.
If I had been a dog last night, I could have slept in bed with you.
</code></pre>
<p><u><strong>一般过去时</strong></u>(跟<strong>点</strong>时) 和 <u><strong>现在完成时</strong></u>(一段时间 &#x3D;&gt; 我在河北已经10年了),</p>
<p>在虚拟语气中be的过去式只有were；could &#x3D; would &#x3D; might</p>
<pre><code class="java">如果她能嫁给一个有钱人，她的母亲可能会善待她吧
If she married a rich man her mother could treat her well.
If she had married a rich man he mother could have treated her well.
</code></pre>
<pre><code class="java">如果你花更多的时间在阅读上，你就能更开阔自己的视野
If you spent more time reading, you would broaden your horizons more.
</code></pre>
<ul>
<li>…很重要…很必要  <u>It is necessary &#x2F; important that</u> 【从句用**(should + 动词原形)** 表示虚拟】</li>
</ul>
<p><span style = "color: red">在第三段措施处可使用</span></p>
<pre><code class="java">大学生多参加活动尽快地融入到新环境中是非常必要的
It is necessary that college students should take part in more activities and
integrate into the new environment as soon as possible.
</code></pre>
<ul>
<li>是…的时候了</li>
</ul>
<p><span style = "color: red">在第三段第一句 、最后一句可使用(喊口号)</span></p>
<p>It is high time that…(从句用过去式表示虚拟)</p>
<pre><code class="java">是我们关注这个问题的时候了
It is high time that we put emphasis on th issue.
</code></pre>
<h3 id="倒装"><a href="#倒装" class="headerlink" title="倒装"></a>倒装</h3><p>就是把一句话写成一般疑问句的形式，给一句话提个<strong>be动词</strong>或<strong>助动词</strong>放在句首</p>
<p>倒装的具体用法: (前面倒装 后面不动)</p>
<ul>
<li>so…that… 结构的句子将so引导的部分置于句首时用倒装，如此…以至于</li>
</ul>
<p>作文中出现 <strong><u>形容词&#x2F;副词</u></strong> 的地方 都可以写成so…that句型，所有的 <strong><u>形容词&#x2F;副词</u></strong> 都可以倒装</p>
<pre><code class="java">He was so excited that he cannot help laughing at midnight.
-&gt; So excited was he that he cannnot help laughing at midnight.
</code></pre>
<pre><code class="java">She looks so gorgeous that she can catch the eyes of everyone.
So gorgeous does she look that she can catch the eyes of everyone.
</code></pre>
<pre><code class="java">DaYan runs so quickly that crazy dogs fail to catch up with her.
So quickly does DaYan run that crazy dogs fail to catch up with her.
</code></pre>
<ul>
<li>“only + 状语” 位于句首时用倒装</li>
</ul>
<pre><code class="java">His girlfriend called his name only once.
Only once did his girlfriend call his name.
</code></pre>
<pre><code class="java">My dearest Tom always lives only in my deep heart.
Only in my deep heart does my dearest Tom always live.
</code></pre>
<pre><code class="java">The problem could be resolved only in this way.
Only in this way could the problem be resolved.
</code></pre>
<h3 id="句子的扩写"><a href="#句子的扩写" class="headerlink" title="句子的扩写"></a>句子的扩写</h3><h4 id="同-定-加在名词后）-状语均可"><a href="#同-定-加在名词后）-状语均可" class="headerlink" title="([同 + 定]加在名词后）(状语均可)"></a>([同 + 定]加在名词后）(状语均可)</h4><pre><code class="java">I love Dayan
I, (a university student from the department of Physical education) love
dayan (who is the most graceful and elegant teacher I have ever seen.)
</code></pre>
<pre><code class="java">Violent video games will make children violent.
Violent video games (which are popular online everywhere) will make children
violent (in their daily life beacause they tend to imitate these negative behaviors.)
</code></pre>
<pre><code class="java">Pollution keeps exceedingly serious.
Pollution, (a global issue), keeps exceedingly serious (with the rapid urbanization 
and development of technology.)
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ff7d73>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/04/30/英语/刘晓艳作文—基础/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/30/后端/Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装/">
        <h2>
            Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/30
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java日期时间"><a href="#Java日期时间" class="headerlink" title="Java日期时间"></a>Java日期时间</h1><h4 id="java-uti包提供了Date类来封装当前的日期和时间"><a href="#java-uti包提供了Date类来封装当前的日期和时间" class="headerlink" title="java.uti包提供了Date类来封装当前的日期和时间"></a>java.uti包提供了Date类来封装当前的日期和时间</h4><pre><code class="java">Data() 构造函数使用当前日期和时间来初始化对象
Data(long millisec) 构造函数接收一个参数从1970年1月1日起的毫秒数
</code></pre>
<h4 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h4><pre><code class="java">import java.util.Date;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        //初始化Date对象
        Date date = new Date();
        //使用toString()函数显示日期时间
        sout(data.toString());
    &#125;
&#125;
运行结果：
Mon May 04 09:51:52 CDT 2013
</code></pre>
<h4 id="使用SimpleDateFormat格式化时间"><a href="#使用SimpleDateFormat格式化时间" class="headerlink" title="使用SimpleDateFormat格式化时间"></a>使用SimpleDateFormat格式化时间</h4><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。允许你选择任何用户自定义日期时间格式来运行</p>
<pre><code class="java">import java.util.*;
import java.test.*;

public class DateDemo&#123;
    public static void main(String args[])&#123;
        Date dNow = new Date();                     //DateFormat格式化编码
        SimpleDateFormat ft = new SimpleDateFormat(&quot;E yyyy.MM.dd &#39;at&#39; hh:mm:ss a zzz&quot;);
        sout(&quot;Current Date: &quot; + ft.format(dNow));
    &#125;
&#125;
运行结果：
Current Date: Sun 2004.07.18 at 04:14:09 PM PDT
</code></pre>
<h4 id="Java休眠-sleep"><a href="#Java休眠-sleep" class="headerlink" title="Java休眠(sleep)"></a>Java休眠(sleep)</h4><p>下面的程序会休眠3秒</p>
<pre><code class="java">import java.util.*;
public static void main(String args[])&#123;
    try&#123;
        sout(new Date() + &quot;\n&quot;);
        Thread.sleep(5*60*10); //1秒 = 1000毫秒
        sout(new Date() + &quot;\n&quot;);
    &#125; catch(Exception e)&#123;
        sout(&quot;Got an exception!&quot;);
    &#125;
   &#125;
&#125;
</code></pre>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程只需要使用getInstance方法创建即可</p>
<p>创建一个代表系统当前日期的Calendar对象</p>
<ul>
<li><strong>Get设置</strong></li>
</ul>
<pre><code class="java">//获得年份
int year = c1.get(Calendar.YEAR);
</code></pre>
<ul>
<li><strong>Set设置</strong></li>
</ul>
<pre><code class="java">Calendar c1 = Calendar.getInstance(); //默认是当前日期
public void set(int field, int value)
c1.set(Calendar.DATE, 10);
c1.set(Calendar.YEAR, 2008);
</code></pre>
<ul>
<li><strong>Add设置</strong></li>
</ul>
<p>把c1对象的日期加上10，也就是c1所表的日期的10天后的日期，其他所有的数值都会被重新计算</p>
<pre><code class="java">c1.add(Calendar.DATE, 10);
</code></pre>
<ul>
<li><h5 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h5></li>
</ul>
<p>Calendar类实现了公历日历，GregorianCalenda是Calendar类的一个具体实现</p>
<pre><code class="java">import java.util.*;
public class GregorianCalendarDemo&#123;
    public static void main(String args[])&#123;
        String months[] = &#123;&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;&#125;;
        int year;
        //初始化Gregorian日历
        //使用当前时间和日期
        //默认为本地时间和时区
        GergorianCalendar gcalendar = new GergorianCalendar();
        //显示当前时间和日期的信息 sout 为 print 不是 println
        sout(&quot;Date: &quot;);
        sout(&quot;months[gcalendar.get(Calendar.MONTH)]&quot;);
        sout(&quot; &quot; + gcalendar.get(Calendar.DATE) + &quot; &quot;);
        sout(year = gcalendar.get(Calendar.YEAR));
        sout(&quot;Time: &quot;);
        sout(gcalendar.get(Calendar.HOUR) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.MINUTE) + &quot;:&quot;);
        sout(gcalendar.get(Calendar.SECOND));
        //测试当前年份是否为闰年
        if(gcalendar.isLeapYeay(year))&#123;
            sout(&quot;当前年份是闰年&quot;);
        &#125;
        else &#123;
            sout(&quot;当前年份不是闰年&quot;);
          &#125;
    &#125;
&#125;
运行结果：
Date: Apr 22 2009
Time: 11:25:27
当前年份不是闰年
</code></pre>
<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>System.out.println()</p>
<p>println()是一个方法(Method)，而System是系统类(Class)，out是标准输出对象(Object)</p>
<p>这句话的用法是调用系统类System中的标准输出对象out中的方法println()</p>
<h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><pre><code class="java">修饰符 返回值类型 方法名 (参数类型 参数名)&#123;
    ...
    方法体
    ...
    return 返回值:
&#125;
</code></pre>
<ul>
<li>修饰符：是可选的，告诉编译器如何调用该方法，定义了该方法的访问类型</li>
<li>返回值类型：方法可能会返回值。returnValueType是关键字void</li>
<li>方法名：是方法的实际名称</li>
<li>参数类型：当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数</li>
<li>方法体：方法体包括具体的语句，定义该方法的功能</li>
</ul>
<p>void方法的调用一定是一个语句，没有返回值，像任何以分号结束的语句一样</p>
<h4 id="通过值传递参数"><a href="#通过值传递参数" class="headerlink" title="通过值传递参数"></a>通过值传递参数</h4><p>连续n次打印一个消息：</p>
<pre><code class="java">public static void nPrintln(String message, int n)&#123;
    for(int i = 0; i &lt; n; i++)
        sout(message);
&#125;
</code></pre>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>一个类的两个方法拥有相同的名字，但是有不同的参数列表</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其他必要的步骤来创建一个完整的对象</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它会把所有成员初始化为0</p>
<pre><code class="java">//一个简单的构造函数
static class Myclass&#123;
    int x;
    //以下是构造函数
    MyClass(int i)&#123;
        x = i;
    &#125;
&#125;
//调用构造方法来初始化一个对象
public class ConsDemo&#123;
    public static void main(String args[])&#123;
        MyClass t1 = new MyClass(10);
        MyClass t2 = new MyClass(20);
        sout(t1.x + &quot; &quot; + t2.x);
    &#125;
&#125;
运行结果：
10 20
</code></pre>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>Java支持传递同类型的可变参数给一个方法</p>
<pre><code class="java">typeName...parameterName
</code></pre>
<p>在方法声明中，在指定参数类型后加一个省略号(…)</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的<strong>最后一个参数</strong>，任何普通的参数必须在它之前声明</p>
<pre><code class="java">public calss VarageDemo&#123;
    public static void main(String args[])&#123;
        //调用可变参数的方法
        printMax&#123;34,3,3,2,56.5&#125;;
        printMax(new double[]&#123;1,2,3&#125;);
    &#125;
    
    public static void printMax(double...numbers)&#123;
        if(numbers.length == 0)&#123;
            sout(&quot;No argument passed&quot;);
            return;
        &#125;
        double result = numbers[0];
        for(int i = 1; i &lt; number.length; i++)
            if(number[i] &gt; result)&#123;
                result = numbers[i];
            &#125;
        sout(&quot;The max value is &quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Java流-Stream-、文件-File-和-IO"><a href="#Java流-Stream-、文件-File-和-IO" class="headerlink" title="Java流(Stream)、文件(File) 和 IO"></a>Java流(Stream)、文件(File) 和 IO</h1><p>Java.io包几乎包括了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标</p>
<p>一个流可以理解为一个数据的序列、<strong>输入流</strong>表示<u>一个源读取数据</u>，<strong>输出流</strong>表示<u>一个目标写数据</u>。</p>
<h5 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h5><p>Java的控制台输入由System.in完成</p>
<p>为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个BufferedReader对象中创建一个字符流</p>
<pre><code class="java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</code></pre>
<p>BufferedReader对象创建后，我们可以使用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串</p>
<h5 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h5><p>从BufferedReader对象读取一个字符要使用**read()**方法</p>
<p>从BufferedReader对象读取一个字符串要使用**readLine()**方法</p>
<pre><code class="java">int read() throws IOException
</code></pre>
<p>每次调用read()方法，它从输入流读取<strong>一个字符</strong>并把该字符作为整数值返回。当流结束的时候返回-1。该方法抛出IOException</p>
<p>下面的程序用read()方法从控制台不断读取字符知道用户输入”q”</p>
<pre><code class="java">//使用BufferedReader 在控制台读取字符
import java.io.*;
public class BRRead&#123;
    public static void main(String args[]) throws IOException&#123;
        char c;
        //使用System.in创建BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        sout(&quot;输入字符，按下&#39;q&#39;键退出.&quot;);
        //读取字符
        do&#123;
            c = (char) br.read();
          //c = br.readLine();
            sout(c);
        &#125; while(c != &#39;q&#39;);
    &#125;
&#125;

运行结果：
输入字符，按下&#39;q&#39;键退出.
123abcq
1
2
3
a
b
c
q
</code></pre>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p>该流用于从文件<strong>读取数据</strong>，它的对象可以用关键字new来创建，有多重构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<pre><code class="java">InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输入流对象来<strong>读取文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
InputStream f = new FileInputStream(f);
</code></pre>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p>该类用来创建一个文件并向文件中<strong>写数据</strong></p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件</p>
<p>有两个构造方法可以用来创建FileOutputStream对象</p>
<p>使用字符串类型的文件名来创建一个输出流对象</p>
<pre><code class="java">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;);
</code></pre>
<p>也可以使用一个文件对象来创建一个输出流来<strong>写文件</strong>，先使用File()方法创建一个文件对象</p>
<pre><code class="java">File f = new File(&quot;C:/java/hello&quot;);
OutputStream f = new FileOutputStream(f);
</code></pre>
<h5 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h5><h5 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h5><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li>**mkdir()**方法创建一个文件夹，成功则返回true，失败则返回false，失败表明File对象指定的路径已经存在，或者由于整个路径害不存在，该文件夹不能被创建</li>
<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹</li>
</ul>
<h1 id="Java-Scanner类"><a href="#Java-Scanner类" class="headerlink" title="Java Scanner类"></a>Java Scanner类</h1><p>Scanner对象的基本语法：</p>
<pre><code class="java">Scanner s = new Scanner(System.in);
</code></pre>
<p>通过Scanner类的<strong>next()</strong> 与 **nextLine()**方法获取输入的字符串</p>
<p>在读取前我们需要使用 <strong>hasNext</strong> 与 <strong>hasNextLine</strong> 判断是否还有输入数据。</p>
<p><strong>使用next方法：</strong></p>
<pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;next方式接收：&quot;);
        //判断是否还有输入
        if(scan.hasNext())&#123;
            String str1 = scan.next();
            sout(&quot;输入的数据为: &quot; + str1);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj
</code></pre>
<h5 id="使用nextLine方法："><a href="#使用nextLine方法：" class="headerlink" title="使用nextLine方法："></a>使用nextLine方法：</h5><pre><code class="java">import java.util.Scanner;
public class ScannerDemo&#123;
    public static void main(String[] args)&#123;
        Scanner scan = new Scanner(System.in);
        sout(&quot;nextLine方式接收: &quot;);
      //判断是否还有输入
        if(scan.hasNextLine())&#123;
            String str2 = scan.nextLine();
            sout(&quot;输入的数据为: &quot; + str2);
        &#125;
    &#125;
&#125;
输出结果：
next方式接收
youj com
输入的数据为：youj com
</code></pre>
<h5 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h5><p><u>next():</u></p>
<ul>
<li>一定要读取到有效字符后才可以结束输入</li>
<li>对输入有效字符之前遇到的空白，next()方法胡自动将其去掉</li>
<li>只有输入有效字符才能将其后面输入的空白作为分隔符或结束符</li>
<li>next()不能得到带有空格的字符串</li>
</ul>
<p><u>nextLine()：</u></p>
<ul>
<li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符</li>
<li>可以获得空白</li>
</ul>
<p>如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用hasNextXxx() 方法进行验证，再使用 nextXxx()来读取：</p>
<pre><code class="java">import java.util.Scanner;
public calss ScannerDemo&#123;
    public static void main(String args[])&#123;
        Scanner scan = new Scanner(System.in);
        int i = 0;
        float f = 0.0f;
        sout(&quot;输入整数： &quot;);
        if(scan.hasNextInt())&#123;
            //判断输入的是否是整数
            i = scan.nextInt();
            sout(&quot;整数数据: &quot; + i);
        &#125; else&#123;
            sout(&quot;输入的不是整数！&quot;);
        &#125;
        sout(&quot;输入小数: &quot;);
        if(scan.hasNextFloat())&#123;
            //判断输入的是否是小数
            f = scan.nextFloat();
            sout(&quot;小数数据: &quot; + f);
        &#125; else&#123;
            sout(&quot;输入的不是小数！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h5 id="捕获异常-try-x2F-catch"><a href="#捕获异常-try-x2F-catch" class="headerlink" title="捕获异常 try&#x2F;catch"></a>捕获异常 try&#x2F;catch</h5><p>使用 try 和 catch关键字可以捕获异常，try&#x2F;catch 代码块中的代码成为保护代码</p>
<pre><code class="java">try&#123;
    //见识代码执行过程，一旦发现异常则直接跳转至catch，
    //如果没有异常则直接跳转至finally
&#125; catch (ExceptionName e1)&#123;
    //Catch快 可选执行的代码块，如果没有任何异常发生不会执行
    //如果发现异常则进行处理或向上抛出
&#125; finally&#123;
    //必选执行的代码块，不管是否有异常发生
    //及时发生内存溢出异常也会执行，通常用于处理善后清理工作
&#125;
</code></pre>
<h5 id="throws-x2F-throw关键字"><a href="#throws-x2F-throw关键字" class="headerlink" title="throws&#x2F;throw关键字"></a>throws&#x2F;throw关键字</h5><p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用throws关键字来声明</p>
<p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开</p>
<pre><code class="java">import java.io.*;
public class className&#123;
    public void withdraw(double amount) throws RemoteException, InsufficientFundsException&#123;
        //...
    &#125;
&#125;
</code></pre>
<h5 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h5><p>用来创建在try代码块后面执行的最后一个 代码块，无论是否发生异常，finally代码块中的代码总会被执行</p>
<h5 id="小综合"><a href="#小综合" class="headerlink" title="小综合"></a>小综合</h5><pre><code class="java">public class ExcepTest&#123;
    public static void main(String args[])&#123;
        int a[] = new int[2];
        try&#123;
            sout(&quot;Access element three :&quot; + a[3]);
        &#125; catch(ArrayIndexOutOfBoundsException e)&#123;
            sout(&quot;Exception thrown :&quot; + e);
        &#125; finally&#123;
            a[0] = 6;
            sout(&quot;First element value: &quot; + a[0]);
            sout(&quot;The finally statement is executed&quot;);
        &#125;
    &#125;
&#125;
运行结果：
Exception thrown :java.l
</code></pre>
<h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><p>如果类A是类B的父亲，而类B是类C的父亲，我们也称类C是A的子类，类C是从类A继承而来的，在Java中，类的继承是单一继承，一个子类只能拥有一个父类。</p>
<p>继承中最常使用的两个关键词是<strong>extends</strong>和<strong>implements</strong></p>
<p>这两个关键字的使用决定了一个对象和另一个对象是否是一个关系，我们能实现一个对象获取另一个对象的属性</p>
<p>所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，而除了Object外，所有类必须有一个父类。</p>
<p>通过<strong>extends关键字</strong>可以申明一个类是继承另一个类而来的</p>
<pre><code class="java">public class A&#123;
    private int i;
    protected int j;
    
    public void func()&#123;
        
    &#125;
&#125;

public class B extends A&#123;
    public int z;
    public void fund()&#123;
        
    &#125;
&#125;
类B由类A继承而来的，类B是类A的子类，而类A是Object的子类，这里可以不显示地声明
作为子类，类B的实例拥有类A所有的成员变量，但对于private类型的成员变量类B却没有访问权限
这保障了类A的封装性
</code></pre>
<pre><code class="java">public class Animal&#123;&#125;
public class Mammal extends Animal&#123;&#125;  Animal类是Mammal类的父类
public class Reptile extends Animal&#123;&#125; Animal类是Reptile类的父类
                                       Mammal类和Reptile类是Animal类的子类   
public class Dog extends Mammal&#123;&#125; Dog类既是Mammal类的子类 又是 Animal类的子类
//通过使用关键字 extends,子类可以继承父类的除privat属性外所有的属性
//通过使用 instanceof 操作符,能够确定左边的对象是不是右边类的实例
public class Dog extends Mammal&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Mammal m = new Mammal();
        Dog d = new Dog();
        sout(m instanceof Animal);
        sout(d instanceof Mammal);
        sout(d instanceof Animal);
    &#125;
&#125;
运行结果
true
true
true
</code></pre>
<h4 id="HAS-A关系"><a href="#HAS-A关系" class="headerlink" title="HAS-A关系"></a>HAS-A关系</h4><p>HAS-A代表类和它的成员之间的从属关系，有助于代码的重用和减少代码的错误。</p>
<pre><code class="java">public class Vehicle&#123;&#125;
public class Speed&#123;&#125;
public class Van extends Vehicle&#123;
    private Speed sp;
&#125;
//Van类将实现的细节对用户隐藏起来，因此，用户只需要知道怎样调用Van类来完成某一功能
//而不必知道Van类是自己来做还是调用其他类来做这些工作
</code></pre>
<p>Java只支持单继承，一个类不能继承多个类</p>
<pre><code class="java">（×） public class test extends Animal, Mammal&#123;&#125;  (×)
</code></pre>
<p>Java只支持单继承(<u><strong>继承基本类</strong></u>和<u><strong>抽象类</strong></u>)，可以用接口来实现(<u><strong>多继承接口实现</strong></u>)</p>
<pre><code class="java">public class Apple extends Fruit implements Fruit1, Fruit2&#123;&#125;
一般继承基本类和抽象类用extends关键字，实现接口类的继承用implements关键字。
</code></pre>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写重要的地方是<u>返回值</u>和<u>形参</u>都不能改变，外壳不变，核心重写！</p>
<p>重写的好处在于子类可以根据需要，定义特定与自己的行为。</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        sout(&quot;狗可以跑和走&quot;);
    &#125;
  /*  
      public void bark()&#123;
        sout(&quot;狗可以吠叫&quot;);
    &#125; 
  */
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal a = new Animal();
        Animal b = new Dog();
        a.move();
        b.move();
       // a.bark();//此处会报错,因为a的引用类型Animal没有bark方法
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<p>尽管b属于Animal类型，但是它可以运行Dog类的move方法</p>
<h4 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h4><ul>
<li>参数列表与被重写方法的参数列表必须完全相同</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li>
<li>子类方法的访问权限必须大于或等于父类方法的访问权限：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>声明为static的方法不能被重写，但可以被再次声明</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法</li>
<li>子类和父类不在同一个包中，那么子类可以重写父类的声明为public和protected的非final方法</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
<li>权限受阻：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected</li>
</ul>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><p>当需要在子类中调用父类的被重写方法时，要使用super关键字</p>
<pre><code class="java">class Animal&#123;
    public void move()&#123;
        sout(&quot;动物可以移动&quot;);
    &#125;
&#125;
class Dog extends Animal&#123;
    public void move()&#123;
        super.move();
        sout(&quot;狗可以跑和走&quot;);
    &#125;
&#125;
public class TestDog&#123;
    public static void main(String args[])&#123;
        Animal b = new Dog();
        b.move();
    &#125;
&#125;
运行结果：
动物可以移动
狗可以跑和走
</code></pre>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载是在一个类里面，<u>方法名字</u>相同，而<u>参数</u>不同，<u>返回类型</u>可以相同也可以不同</p>
<p>每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表</p>
<p>重载规则：</p>
<ul>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ul>
<h4 id="重写和重载的区分"><a href="#重写和重载的区分" class="headerlink" title="重写和重载的区分"></a>重写和重载的区分</h4><pre><code class="java">重写 bark(方法名和参数都一样)
class Dog&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
&#125;
class Hound extends Dog&#123;
    public void sniff()&#123;
        sout(&quot;sniff &quot;);
    &#125;
    public void bark()&#123;
        sout(&quot;bowl&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">重载 bark(方法名相同，参数不同)
class DOg&#123;
    public void bark()&#123;
        sout(&quot;woof &quot;);
    &#125;
    public void bark(int num)&#123;
        for(int i = 0; i &lt; num; i++)&#123;
            sout(&quot;woof &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制(可以降低限制)</td>
</tr>
</tbody></table>
<h1 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h1><p>多态是同一种行为具有不同表现形式或形态的能力</p>
<p>多态性是对象多种表现形式的体现</p>
<p>宠物&#x3D;小猫+小狗+蜥蜴</p>
<pre><code class="java">public interface Vegetarian&#123;&#125;
public class Animal&#123;&#125;
public class Deer extends Animal implements Vegetarian&#123;&#125;
</code></pre>
<p>当我们将引用型变量应用于Deer对象的引用</p>
<pre><code class="java">Deer d = new Deer();
Animal a = d;
Vegetarian v = d;
Object o = d;
所有的引用型变量d,a,v,o都指向堆中想通的Deer对象
</code></pre>
<h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><ul>
<li><strong>重写</strong></li>
<li><strong>接口</strong></li>
<li><strong>抽象类和抽象方法</strong></li>
</ul>
<h1 id="Java抽象类"><a href="#Java抽象类" class="headerlink" title="Java抽象类"></a>Java抽象类</h1><p>在Java面向对象的概念中，所有的对象都是通过类来秒回的</p>
<p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类除了不能实例化对象之外，类的其他功能依旧存在：成员变量、成员方法、构造方法</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用(通常在设计阶段决定要不要设计抽象类)</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>如果你想设计一个类：包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract关键词同样可以声明抽象方法，抽象方法只包含一个方法名，没有方法体</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号</p>
<pre><code class="java">public abstract class Employee&#123;
    private String name;
    private String address;
    private int number;
    public abstract double computePay();
    //其余代码
&#125;
</code></pre>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么这个类必须是抽象类</li>
<li>任何子类必须重写父亲的抽象方法，或者声明自身为抽象类</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法</p>
<pre><code class="java">public class Salary extends Employee&#123;
    private double salary;
    public double computePay()&#123;
        sout(&quot;Computing salary pay for &quot; + getName());
        return salary/52;
    &#125;
&#125;
</code></pre>
<h1 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h1><p>封装是一种将抽象性函式接口的实作细节部分包装、隐藏起来的方法</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</p>
<p>要访问该类代码和数据，必须通过严格的接口控制</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</p>
<p>适当的粉装可以让代码更容易理解和维护，也增强了代码的安全性</p>
<pre><code class="java">public class EncapTest&#123;
    private String name;
    private String idNum;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIdNum() &#123;
        return idNum;
    &#125;

    public void setIdNum(String idNum) &#123;
        this.idNum = idNum;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre>
<p>public方法是外部类访问该类成员变量的入口，这些方法称为getter和setter方法</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法</p>
<pre><code class="java">public class RunEncap&#123;
    public static void main(String args[])&#123;
        EncapTest encap = new EncapTest();
        encap.setName(&quot;James&quot;);
        encap.setAge(20);
        encap.setIdNum(&quot;12343ms&quot;);
        sout(&quot;Name : &quot; + encap.getName() 
           + &quot;Age: &quot; + encap.getAge());
    &#125;
&#125;
运行结果：
Name : James Age : 20
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/04/30/后端/Java日期+方法+文件流+scanner+异常+继承+重写载+多态+抽象+封装/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/28/后端/Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组/">
        <h2>
            Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><ul>
<li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、吃、叫等。</p>
</li>
<li><p><strong>类</strong>：类[class]是一个<strong>模板</strong>，它描述一类对象的<span style =" color : red">行为和状态</span>。</p>
</li>
<li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。</p>
</li>
<li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
</li>
<li><p>编写java时应注意几点：</p>
<p><strong>大小写敏感</strong></p>
<p><strong>类名</strong>：对所有类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写：MyFirstJavaClass</p>
<p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
<p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件时，你应该使用类名作为文件名保存(切记Java是大小写敏感的)，文件名的后缀为java。</p>
<p><strong>主方法入口</strong>：所有的Java程序由<span style =" color : red">public static void main(String[] args)</span>方法开始执行。</p>
</li>
<li><p><strong>Java变量</strong>：局部变量、类变量(静态[static]变量)、成员变量(非静态变量)</p>
</li>
<li><p><strong>方法</strong>：访问权限符 返回值 方法名(参数列表){  方法体  }</p>
<p>​            public          void    method()    {sout(“Hello”);}</p>
<p><strong>interface：</strong>接口，一种抽象的类型，仅有方法和常量的定义</p>
<p><strong>implements</strong>：表示一个类实现了接口</p>
<p><strong>abstract</strong>：抽象方法，抽象类的修饰符</p>
<p><strong>extends：</strong>表示一个类是另一个类的子类(继承)</p>
<p><strong>private：</strong>表示私有字段，或者方法等，只能从类内部访问</p>
<p><strong>protected：</strong>表示字段只能通过类或者子类访问，子类或者在同一个包内的其他类</p>
<p><strong>public：</strong>表示共有属性或方法</p>
<p><strong>static：</strong>表示在类级别定义，所有实例共享的</p>
<p><strong>throw：</strong>抛出异常</p>
<p><strong>throws：</strong>定义方法可能抛出的异常</p>
</li>
<li><p><strong>继承</strong>：在Java中，一个类可以由其他类派生，如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类，利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类(super class)，派生类称为子类(subclass)</p>
</li>
<li><p><strong>接口</strong>：在Java中，接口可理解为对象间互相通信的协议。接口在继承中扮演着很重要的角色。接口值定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
</li>
</ul>
<h1 id="Java对象和类"><a href="#Java对象和类" class="headerlink" title="Java对象和类"></a>Java对象和类</h1><ul>
<li>Java中的类和方法[方法就是行为，一个类可以有很多方法]</li>
</ul>
<pre><code class="jaVA">public class Dog&#123;
    String breed;
    int age;
    String color;
    
    void barking()&#123;
        
    &#125;
    void hungry()&#123;
        
    &#125;
    void sleeping()&#123;
        
    &#125;
&#125;
</code></pre>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()、sleeping() 都是Dog类的方法</p>
<hr>
<p><strong>构造方法</strong></p>
<p>每个类都有构造方法，不主动创建编译器将会为该类提供一个默认的构造方法，在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<pre><code class="java">public class Puppy&#123;
    public Puppy()&#123;
        
    &#125;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数：name
    &#125;
&#125;
</code></pre>
<hr>
<p><strong>创建对象</strong></p>
<p>对象是根据类创建的。在java中，使用关键字new来创建一个新的对象。</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型</li>
<li><strong>实例化</strong>：使用关键字new来创建一个对象</li>
<li><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象</li>
</ul>
<pre><code class="java">public class Puppy&#123;
    public Puppy(String name)&#123;
        //这个构造器仅有一个参数:name
        sout(&quot;Puppy Name is :&quot; + name);
    &#125;
    public static void main(String[] args)&#123;
        //下面的语句将创建一个Puppy对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
    &#125;
&#125;

打印出下面结果：
Puppy Name is : tommy
</code></pre>
<hr>
<p><strong>访问实例变量和方法</strong></p>
<pre><code class="java">//实例化对象
ObjectReference = new Constructor();
//访问其中的变量
ObjectReference.variableName;
//访问类中的方法
ObjectReference.MethodName();
</code></pre>
<hr>
<p><strong>实例</strong></p>
<p>访问实例变量和调用成员方法：</p>
<pre><code class="java">public class Puppy&#123;
    int puppyAge;
    public Puppy(String name)&#123;
        sout(&quot;Passed Name is :&quot; + name);
    &#125;
    public void setAge(int age)&#123;
        puppyAge = age;
    &#125;
    public int getAge()&#123;
        sout(&quot;Puppy&#39;s age is :&quot; + puppyAge);
        return puppyAge;
    &#125;
    
    public static void main(String[] args)&#123;
        //创建对象
        Puppy myPuppy = new Puppy(&quot;tommy&quot;);
        //通过方法来设定age
        myPuppy.setAge(2);
        //调用另一个方法获取age
        myPuppy.getAge();
        //也可以这样访问成员变量
        sout(&quot;Variable Value :&quot; + myPuppy.puppyAge);
    &#125;
&#125;

输出结果：
Passed Name is :tommy
   &#39;s age is :2
PuppyVariable Value :2
</code></pre>
<hr>
<p><strong>源文件声明规则</strong></p>
<ul>
<li><p>一个源文件中只能有一个public类</p>
</li>
<li><p>一个源文件可以有多个非public类</p>
</li>
<li><p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java</p>
</li>
<li><p>特殊的转义字符序列</p>
</li>
</ul>
<pre><code class="java">\n 换行
\r 回车
\f 换页符
\b 退格
\0 空字符
\s 字符串
\t 制表符
</code></pre>
<hr>
<h1 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h1><p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量称之为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用(类方法中的变量)(局部变量的作用域仅限制在被创造的方法中)</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。(独立于方法之外的变量，不过没有static修饰)</li>
<li><strong>类变量</strong>：类变量(静态变量)也声明在类中，方法体之外，但必须声明为static类型。无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。静态变量除了被声明为常量外很少使用，常量是指声明为public&#x2F;private，final和static类型的变量，常量初始化后不能改变。静态变量存储在静态存储区，经常被声明为常量，很少单独使用static声明变量。类变量被声明为public static final 类型时，类变量名称必须使用大写字母，如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。(独立于方法之外的变量，用static修饰)</li>
</ul>
<p><strong>然后是static</strong></p>
<p><strong>static在java中表示静态</strong></p>
<p><strong>但是这个静态又是什么意思呢？</strong></p>
<p><strong>最开始接触static的时候看书上的概念根本没弄懂！</strong></p>
<p><strong>接触有一段时间java了，在这里面要总结一下我对static的理解：</strong></p>
<p>（概念）static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>
<p>这句话是说，你会用到static修饰一些个变量、方法、方法块什么的，这是你用到static的地方；“但是，java中没有全局变量的概念”，怎么理解这句话？你时刻要记住java是一个面向对象的语言，万事万物皆对象，无论你做什么都需要创建一个对象，然后再调用这个对象的方法，java怎么能允许存在一个在全局都通用的“全局变量”的概念存在呢？所以java中压根就没有所谓的“全局变量”，但是没有这个概念，不代表你不可以实现这个功能，java存在的目的就是让人们使用它去达到人们想要的效果，所以static value就可以达到全局变量的作用，所以，你现在应该可以理解下面这句话了吧。</p>
<p>（概念）用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>现在进一步理解下面两段概念：</p>
<p>（概念）只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //salary是静态的私有变量
    private static double salary;
    //DEPARTMENT是一个常量
    public static final String DEPARTMENT = &quot;Development &quot;;
    public static void main(String args[])&#123;
        salary = 1000;
        sout(DEPARTMENT + &quot;average salary:&quot; + salary);
    &#125;
&#125;
输出结果：
Develment average salary：1000
</code></pre>
<pre><code class="java">public class Variable&#123;
    static int allClicks = 0;    //类变量
    String str = &quot;hello world&quot;; //实例变量
    public void method()&#123;
        int i = 0; //局部变量
    &#125;
&#125;
</code></pre>
<p>实例：</p>
<pre><code class="java">import java.io.*;
public class Employee&#123;
    //这个成员变量对子类可见
    public String name;
    //私有变量，仅在该类可见
    private double salary;
    //在构造器中对name赋值
    public Employee(String empName)&#123;
        name = empName;
    &#125;
    //设定salary的值
    public void setSalary(double empSal)&#123;
        salary = empSal;
    &#125;
    //打印信息
    public void printEmp()&#123;
        sout(&quot;name :&quot; + name);
        sout(&quot;salary :&quot; + salary);
&#125;
    public ststic void main(String args[])&#123;
        Employee empOne = new Employee(&quot;Ransika&quot;);
        empOne.setSalary(1000);
        empOne.printEmp();
    &#125;
&#125;
输出结果：
name : Ransika
salary :1000.0
</code></pre>
<hr>
<h1 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h1><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li><strong>default 默认的：</strong>在同一包内可见，不使用任何修饰符</li>
<li><strong>private 私有的：</strong>在同一类内可见。私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。private访问修饰符的作用主要用来隐藏类的实现细节和保护类的数据</li>
</ul>
<pre><code class="java">public class Logger&#123;
    private String format;
    public String getFormat()&#123;
        return this.format;
    &#125;
    public void setFormat(String format)&#123;
        this.format = format;
    &#125;
&#125;
</code></pre>
<p>实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：<strong>getFormat()</strong> (返回format的值) 和 <strong>setFormat(String)</strong> (设置format的值)</p>
<ul>
<li><strong>public 公有的：</strong>对所有类可见，被声明public的类、方法、构造方法和接口能够被任何其他类访问。如果几个互相访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的共有方法和变量都能被子类继承</li>
</ul>
<pre><code class="java">public static void main(String[] arguments)&#123;
    //...(公有访问控制)
&#125;
</code></pre>
<p>Java程序的main()方法必须设置成共有的，否则，不能运行该类</p>
<ul>
<li><strong>proteed 受保护的：</strong>对同一包内的类和所有子类可见</li>
</ul>
<p>被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。protected访问修饰符不能修饰类和接口，方法和成员变量能够声明protected，但是接口的成员变量和成员方法不能声明为protected，子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了protected访问修饰符，子类重载了父类的openSpeaker()方法。</p>
<pre><code class="java">class AudioPlayer&#123;
    protected boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
class StreamingAudioPlayer&#123;
    boolean openSpeaker(Speaker sp)&#123;
        //实现细节
    &#125;
&#125;
</code></pre>
<p>如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法</p>
<p>如果把openSpeaker()方法声明为public，那么所有的类都能够访问该方法</p>
<p>如果我们只想让该方法对其所在的类的子类可见，则将该方法声明为protected</p>
<ul>
<li><strong>访问控制和继承</strong>规则：<ul>
<li>父类中声明为public的方法在子类中也必须为public</li>
<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private</li>
<li>父类中声明为private的方法，不能够被继承</li>
</ul>
</li>
</ul>
<h4 id="控制非访问修饰符"><a href="#控制非访问修饰符" class="headerlink" title="控制非访问修饰符"></a>控制非访问修饰符</h4><ul>
<li><p><strong>static 修饰符：</strong>用来创建类方法和类变量</p>
<ul>
<li><strong>静态变量：</strong>static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也成为类变量。局部变量不能被声明为static变量</li>
<li><strong>静态方法：</strong>static关键词用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据</li>
</ul>
<p>对类变量和方法的访问可以直接使用classname.variablename 和 classname.methodname的方式访问 </p>
<p>下面为static修饰符用来创建类方法和类变量</p>
</li>
</ul>
<pre><code class="java">public class InstanceCounter&#123;
    private static int numInstances = 0;
    protected static int getCount()&#123;
        return numInstances;
    &#125;
    
    private static void addInstance()&#123;
        numInstances++;
    &#125;
    
    InstanceCounter()&#123;
        InstanceCounter.addInstance();
    &#125;
    
    public static void main(String[] arguments)&#123;
        sout(&quot;Starting with&quot; + InstanceCounter.getCount() + &quot; instances&quot;);
        for(int i = 0; i &lt; 500; ++i)&#123;
            new InstanceCounter();
        &#125;
        sout(&quot;Created &quot; + InstanceCounter.getCount() + &quot;instances&quot;);
    &#125;
&#125;
输出结果：
Started with 0 instances
Created 500 instances
</code></pre>
<ul>
<li><p><strong>final 修饰符：</strong>用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的</p>
<ul>
<li><strong>final变量：</strong>能被显示地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。final修饰符通常和static修饰符一起使用来创建类常量。</li>
</ul>
<pre><code class="java">public class Test&#123;
    final int value = 10;
    //下面是声明常量的实例
    public static final int BOXWIDTH = 6;
    static final String TITLE = &quot;Manger&quot;;
    
    public void changeValue()&#123;
        value = 12; //将输出一个错误
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final方法：</strong> 类中的final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改</li>
</ul>
<p>如图为final修饰符声明方法</p>
<pre><code class="java">public class Test&#123;
    public final void changeName()&#123;
        //方法体
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>final类：</strong> final类不能被继承，没有类能够继承final类的任何特性</li>
</ul>
<pre><code class="java">public final class Test&#123;
    //类体
&#125;
</code></pre>
</li>
<li><p><strong>abstrat 修饰符：</strong>用来创建抽象类和抽象方法</p>
<ul>
<li><strong>抽象类：</strong>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被abstract和final修饰，如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则编译错误。抽象类包含抽象方法和非抽象方法。</li>
<li><strong>抽象方法：</strong>是一种没有任何实现的方法，该方法的具体实现由子类提供，抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非子类也是抽象类。抽象类可以不包含抽象方法。</li>
</ul>
<pre><code class="java">abstract class Caraven&#123;
    private double price;
    private String model;
    private String year;
    public abstract void goFast(); //抽象方法
    public abstract void changeColor();
&#125;
</code></pre>
<pre><code class="java">public abstract class SuperClass&#123;
    abstract void m(); //抽象方法
&#125;
class SubClass extends SuperClass&#123;
    //实现抽象方法
    void m()&#123;
        // ......
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>synchronized和volatile 修饰符：</strong> 主要用于线程的编程 （这里不具体研究）</p>
</li>
</ul>
<hr>
<h1 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h1><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>假设a&#x3D;60，b&#x3D;13；</p>
<pre><code class="java">    a = 0011 1100
    b = 0000 1101
----------------------
a &amp; b = 0000 1100
a | b = 0011 1101
a ^ b = 0011 0001
~ a   = 1100 0011
</code></pre>
<h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型(类类型 或 接口类型)</p>
<p>instanof运算符使用格式如下：</p>
<pre><code class="java">(Object reference variable)instanceof(class/interface type)
</code></pre>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真</p>
<pre><code class="java">String name = &quot;James&quot;;
boolean result = name instanceof String;
//由于name是String类型，所以返回真
</code></pre>
<pre><code class="java">class Vehicle&#123;&#125;
public class Car extends Vehicle&#123;
    public static void main(String args[])&#123;
        Vehicle a = new Car();
        boolean result = a instanceof Car;
        sout(result);
    &#125;
&#125;
输出结果：
true
</code></pre>
<h4 id="continue关键字-增强型for循环"><a href="#continue关键字-增强型for循环" class="headerlink" title="continue关键字 + 增强型for循环"></a>continue关键字 + 增强型for循环</h4><p>continue适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代</p>
<p>在<strong>for循环</strong>中，continue语句使程序立刻跳转到更新语句</p>
<p>在<strong>while</strong>或者<strong>do…while循环</strong>中，程序立刻跳转到布尔表达式的判断语句</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        int &#123;&#125; numbers = &#123;10, 20, 30, 40, 50&#125;;
        for(int x : numbers)&#123;
            if(x == 30)&#123;
                continue;
            &#125;
            sout(x);
            sout(&quot;\n&quot;);
        &#125;
    &#125;
&#125;
输出结果：
10
20
40
50
</code></pre>
<h1 id="Java-Number类、Math类、Character类"><a href="#Java-Number类、Math类、Character类" class="headerlink" title="Java Number类、Math类、Character类"></a>Java Number类、Math类、Character类</h1><h4 id="Number包装类型"><a href="#Number包装类型" class="headerlink" title="Number包装类型"></a>Number包装类型</h4><pre><code class="java">byte -&gt; Byte        int -&gt; Integer        short -&gt; Short        long -&gt; Long
double -&gt; Double    float -&gt; Float        boolean -&gt; Boolean    char -&gt; Character
</code></pre>
<p>包装类型都是用final声明了，不可能被继承重写。在实际情况中编译器会自动的将基本类型数据<strong>装箱</strong>成对象类型，或者将对象类型<strong>拆箱</strong>成基本类型</p>
<pre><code class="java">public static void main(String[] args)&#123;
    int num1 = 1;
    //将基本类型数据装箱成对象包装类型
    Integer num2 = num1;
    Integer num3 = 3;
    //将对象数据类拆箱
    int num4 = num3;
&#125;
</code></pre>
<p>下面是一个装箱与拆箱的例子：</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        Integer x = 5;
        x = x + 10;
        sout(x);
    &#125;
&#125;
输出结果：
15
</code></pre>
<h4 id="Math类型"><a href="#Math类型" class="headerlink" title="Math类型"></a>Math类型</h4><p>Java的Math包含了用于执行基本数学运算的属性和方法：初等指数、对数、平方根和三角函数</p>
<p>Math的方法都被定义为static形式，通过Math类可以在主函数中直接调用 sout(“90°正弦值：” + Math.sin(Math.PI &#x2F; 2))；</p>
<p>下表是常用的Number类和Math类的方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>xxxValue()：将number对象转换为xxx数据类型的值并返回</td>
</tr>
<tr>
<td>2</td>
<td>compareTo()：将number对象与参数比较</td>
</tr>
<tr>
<td>3</td>
<td>equals()：判断number对象是否与参数相等</td>
</tr>
<tr>
<td>4</td>
<td>valueOf()：返回一个Integer对象指定的内置数据类型</td>
</tr>
<tr>
<td>5</td>
<td>toString()：以字符串形式返回值</td>
</tr>
<tr>
<td>6</td>
<td>parseInt()：将字符串解析为int类型</td>
</tr>
<tr>
<td>7</td>
<td>abs()：返回参数的绝对值</td>
</tr>
<tr>
<td>8</td>
<td>floor()：返回小于等于给定参数的最大整数</td>
</tr>
<tr>
<td>9</td>
<td>round()：返回一个最接近的int、long型值</td>
</tr>
<tr>
<td>10</td>
<td>exp()：返回自然数底数e的参数次方</td>
</tr>
<tr>
<td>11</td>
<td>log()：返回参数的自然数底数的对数值</td>
</tr>
<tr>
<td>12</td>
<td>pow()：返回第一个参数的第二个参数次方</td>
</tr>
<tr>
<td>13</td>
<td>sqrt()：求参数的算术平方个</td>
</tr>
<tr>
<td>14</td>
<td>random()：返回一个随机数</td>
</tr>
</tbody></table>
<h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>使用字符时，我们通常使用的是内置数据类型char</p>
<ul>
<li>Character类的用法：可以使用Character的构造方法创建一个Character类对象</li>
</ul>
<pre><code class="java">Character ch = new Character(&#39;a&#39;);
----------------------------------
Character ch = &#39;a&#39;;
char c = test(&#39;x&#39;);
</code></pre>
<pre><code class="java">isLetter()是否是一个字母        isDigit()是否是一个数字字符
isUpperCase()是否是大写字母    isLowCase()是否是小写字母
toUpperCase()指定字母的大写形式 isLowerCase()指定字母的小写形式
toString()返回字符的字符串形式，字符串的长度仅为1
</code></pre>
<p>注意：String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。</p>
<p>可以通过StringBuffer类 和 StringBuilder类(能够被多次的修改，并且不产生新的未使用对象)</p>
<pre><code class="java">public class Test&#123;
    public static void main(String args[])&#123;
        StringBuffer sBuffer = new StringBuffer(&quot;test&quot;);
        sBuffer.append(&quot;String Buffer&quot;);
        sout(sBuffer);
    &#125;
&#125;
输出结果：
test String Buffer
</code></pre>
<pre><code class="java">public StringBuffer append(String s) 将指定的字符串追加到此字符序列
public StringBuffer reverse() 将此字符序列用其反转形式取代
public delete(int start, int end) 移除此序列的子字符串中的字符
public insert(int offset, int i) 将int参数的字符串表示形式插入此序列中
replace(int start, int end, String str) 使用给定String中的字符替换此序列的子字符串中的字符
</code></pre>
<h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><h4 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h4><pre><code class="java">dataType[] arrayRefVar;
double[] myList;
</code></pre>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>Java语言使用new操作符来创建数组</p>
<pre><code class="java">arrayRefVar = new dataType[arraySize];
此语法语句做了两件事：
    ①：使用dataType[arraySize]创建了一个数组
    ②：把新创建的数组的应用赋值给变量arrayRefVar
</code></pre>
<p>所以<strong>数组的变量声明</strong>和<strong>创建数组</strong>可以用一条语句完成</p>
<pre><code class="java">dataType[] arrayRefVar = new dataType[arraySize]
</code></pre>
<p>数组的元素时通过索引来访问的，数组索引从0开始，所以索引值从0到arrayRefVar.length-1</p>
<p>定义一个int类型的数组</p>
<pre><code class="java">public class ArrayDemo&#123;
    public static void main(String args[])&#123;
        int data[] = new int[3]; //开辟了一个长度为3的数组
        //在数组使用之前一定要开辟空间(实例化)
        data[0] = 10;
        data[1] = 20;
        data[2] = 30;
        for(int x = 0; x &lt; data.length; x++)&#123;
            sout(data[x]);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h4><p>数组可以作为参数传递给方法</p>
<pre><code class="java">public static void printArray(int[] array)&#123;
    for(int i = 0; i &lt; array.length; i++)&#123;
        sout(array[i] + &quot; &quot;);
    &#125;
&#125;

printArray(new int[]&#123;3, 1, 2, 6, 4, 2&#125;);
</code></pre>
<h4 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h4><pre><code class="java">public static int[] reverse(int[] list)&#123;
    int[] result = new int[list.length];
    for(int i = 0, j = result.length - 1; i &lt; list.length; i++, j--)&#123;
        result[j] = list[i];
    &#125;
    return result;
&#125;
</code></pre>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>java.util.Arrays类能方便地操作数组，它提供的所有方法都是静态的</p>
<ul>
<li>给数组赋值：通过<strong>fill</strong>方法</li>
<li>对数组排序：通过<strong>sort</strong>方法，按升序</li>
<li>比较数组：通过<strong>equals</strong>方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过<strong>binarySearch</strong>方法能对排序好的数组进行二分查找法操作</li>
</ul>
<pre><code class="java">public static int binarySearch(Object[], Object key) 
用二分查找算法在给定数组中搜索给定值的对象(Byte,int,double等)
public static boolean equals(long[] a, long[] a2)
如果两个指定的long型数组彼此相等，则返回true。如果两个数组包含相同数量的元素
并且两个元素中的所有相应元素对都是相等的，则认为这两个数组是相等的
public static void fill(int[] a, int val)
将指定的int值分配给指定int型数组指定范围中的每个元素
public static void sort(Object[] a)
对指定对象数组根据其元素的自然顺序进行升序排序
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/04/28/后端/Java基础+对象和类+变量类型+修饰符+运算符+各种类+数组/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/04/22/英语/作文高分语句模板/">
        <h2>
            作文模板
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/4/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <span id="more"></span>

<h1 id="画图作文"><a href="#画图作文" class="headerlink" title="画图作文"></a>画图作文</h1><h4 id="首段：图画描述"><a href="#首段：图画描述" class="headerlink" title="首段：图画描述"></a>首段：图画描述</h4><pre><code class="java">显然，这幅画能自然联系到做好小事的重要性
This drawing, apparently, can be linked to the critical significance of doing small things.
    
图画中，一个年轻人表达了自己对“核废料处理”的担忧
In the picture, the youngster express his worries about &quot;disposing of nuclear waste&quot;.
    
使他感到吃惊的是，他爸爸指着垃圾筐告诉他,如果能把垃圾筐清空，他就能做好一切
To his surprise, his father points at the dustbin, telling him that if he can empty the dustbin there, he can do anything.
</code></pre>
<h4 id="二段：图画主题-现象-意义"><a href="#二段：图画主题-现象-意义" class="headerlink" title="二段：图画主题 + 现象 + 意义"></a>二段：图画主题 + 现象 + 意义</h4><pre><code class="java">父亲的意思是，如果年轻人想要成功
The father means that if young people dream to achieve success,
    - 
就应该明智地从小的工作开始做起
it is sensible for them to start with little jobs.
</code></pre>
<pre><code class="java">确实，在当今社会，很多年轻人忽略身边的各种小事已经成为一种常见现象
Admittedly, in the present-day society, it is a common phenomenon for many teenagers to neglect tiny things in life.
    
例如打扫房间、洗衣服和清理垃圾筐
such as cleaning rooms, washing clothes and emptying dustbins.
    
为什么？因为越来越多的年轻人觉得处理这些小事没有用。一个典型例子就是图画中的小孩。
Why? The reason is that a growing number of young people find it rather useless to deal with these things.
A typical example is the boy in the picture.
</code></pre>
<pre><code class="java">然而，正是这些小事确保年轻人能掌握足够的知识、能力和经验
Nonetheless, it is these small tasks that ensure young people to master sufficient knowledge, competence and experience.
    
事实上，很多聪明人已经意识到这些小事的重要性
Actually, wise people in large numbers have come to recognize the significance of these small things.

做好这些小事带给我们技能，唤起我们对成功的热情，帮助我们进步
Doing small things brings us skills, arouses our passion for success and helps us to make progress.
</code></pre>
<h4 id="尾段：观点-建议-展望"><a href="#尾段：观点-建议-展望" class="headerlink" title="尾段：观点 + 建议 + 展望"></a>尾段：观点 + 建议 + 展望</h4><pre><code class="java">作为一名大学生，我坚信年轻人很有必要通过做好小事提升自己的整体素质
As a college student, I am convinced that it is exceedingly necessary for young people to strengthen our comprehensive
quality by doing small things. 
因此，我们应该教育和鼓励我们的朋友和熟人培养这种积极的意识和习惯
Accordingly, we should educate and encourage our friends and acquaintances to foster this positive awareness and habit.
如果我们不遗余力地这样来做，未来我们的工作和生活将充满光明和希望
We, sparing no efforts to do so, may witness a hopeful and promising future of our work and study.
每个人都应该就牢记大的成功源于每天小的进步
Everyone should bear in mind that a big success originates from everyday small progress.
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#00bcd4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2022/04/22/英语/作文高分语句模板/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/10/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/9">
                <span class="page-num">
                    9
                </span>
            </a>
            

            
            <a href="/page/10/">
                <span class="page-num">
                    10
                </span>
            </a>
        </span>
        

        <span class="current">
            11
        </span>

        
        <span>
            <a href="/page/12/">
                <span class="page-num">
                    12
                </span>
            </a>
            
            <a href="/page/13">
                <span class="page-num">
                    13
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/12/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>