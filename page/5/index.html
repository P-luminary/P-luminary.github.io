
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2023/10/26/后端/Maven,工厂模式,反射模式,Lambda表达式,stream流式处理/">
        <h2>
            Maven,工厂模式,反射模式,Lambda表达式,stream流式处理
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/26
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Maven构建工具"><a href="#Maven构建工具" class="headerlink" title="Maven构建工具"></a>Maven构建工具</h3><h6 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h6><ul>
<li>Maven是项目管理工具，对软件项目提供构建与依赖管理</li>
<li>Maven是Apache下的Java开源项目</li>
<li>Maven为Java项目提供了统一的管理方式，已经成为业界标准</li>
</ul>
<h6 id="Maven核心特性"><a href="#Maven核心特性" class="headerlink" title="Maven核心特性"></a>Maven核心特性</h6><ul>
<li>项目设置遵循统一的规则，保证不同开发环境的兼容性</li>
<li>强大的依赖管理，项目依赖组件自动下载、自动更新</li>
<li>可扩展的插件机制，使用简单，功能丰富</li>
</ul>
<h6 id="Maven的坐标"><a href="#Maven的坐标" class="headerlink" title="Maven的坐标"></a>Maven的坐标</h6><ul>
<li><strong>GroupId</strong>：机构或者团体的英文，采用”逆向域名”形式书写</li>
<li><strong>ArtifactId</strong>：项目名称，说明其用途，例如：cms、oa…</li>
<li><strong>Version</strong>：版本号，一般采用”版本+单词”形式，例如：1.0.0.RELEASE</li>
</ul>
<h3 id="Maven项目标准结构"><a href="#Maven项目标准结构" class="headerlink" title="Maven项目标准结构"></a>Maven项目标准结构</h3><table>
<thead>
<tr>
<th>目录</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>${basedir}</td>
<td>根目录，用于保存pom.xml</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td>
<td>资源目录，保存配置文件、静态图片等</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td>
<td>测试类的源代码</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td>
<td>测试时需要使用的资源文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target</td>
<td>项目输出的目录，用于存储jar、war文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target&#x2F;class</td>
<td>字节码(.class)的编译输出目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;<strong>pom.xml</strong></td>
<td>项目(<strong>P</strong>roject)对象(<strong>O</strong>bject)模型(<strong>M</strong>odel)文件</td>
</tr>
</tbody></table>
<h3 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h3><ul>
<li>Maven利用<strong>dependency</strong>(依赖) 自动下载、管理第三方Jar</li>
<li>在pom.xml文件中配置项目依赖的第三方组件</li>
<li>maven自动将依赖从<strong>远程仓库</strong>下载至<strong>本地仓库</strong>，并在工程中引用</li>
</ul>
<pre><code class="html">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><span style = "color : red"><a target="_blank" rel="noopener" href="https://search.maven.org/">Maven Central Repository Search</a>可以搜索<strong>maven</strong></span></p>
<pre><code class="html">pom.xml
&lt;dependencies&gt;
    &lt;dependency&gt;
          &lt;groupId&gt;com.belerweb&lt;/groupId&gt;
          &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
          &lt;version&gt;2.5.1&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="java">PinyinTestor.java
import net.sourceforge.pinyin4j.PinyinHelper;

import java.util.Scanner;

public class PinyinTestor &#123;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] pingyin = PinyinHelper.toHanyuPinyinStringArray(str.charAt(0)); //将输入的第一个数据变成字符串数组
        for (String py : pingyin)&#123;
            System.out.println(py);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="本地仓库与中央仓库"><a href="#本地仓库与中央仓库" class="headerlink" title="本地仓库与中央仓库"></a>本地仓库与中央仓库</h3><p><strong>maven</strong> 在项目启动的时候会对 <strong>pom.xml</strong> 进行加载 之后会在<strong>本地仓库</strong> <strong>.m2\repository</strong> 去查找依赖文件(jar包) 如果查不到或不存在 就会去<strong>中央仓库</strong>下载(repo.maven.apache.org)到本地仓库</p>
<h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><ul>
<li>Maven可将Java项目打包为<strong>jar、war</strong>包</li>
<li>Maven项目打包是通过<strong>Plugins</strong>(插件)技术实现</li>
<li>Maven输出jar包插件：maven-assembly-plugin</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/32c4c5407cd517b9304127dfdab23e910c4aea0c/data/Maven%E6%89%93%E5%8C%85.png" style="zoom:200%;" />

<pre><code class="html">//阿里云镜像下载地址
&lt;repositories&gt;
  &lt;repository&gt;
      &lt;!-- 创建私服的地址 --&gt;
    &lt;id&gt;aliyun&lt;/id&gt;
    &lt;name&gt;aliyun&lt;/name&gt;
    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3 id="Maven构建Web工程"><a href="#Maven构建Web工程" class="headerlink" title="Maven构建Web工程"></a>Maven构建Web工程</h3><p>创建Maven-Project</p>
<pre><code class="html">Group Id: maven-first
Artifacr Id: maven
Version: 1.0.0-RELEASE
Packaging: jar
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/czc9309/article/details/80304074">IntelliJ IDEA创建maven web项目（IDEA新手适用）_idea maven创建web项目-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45384457/article/details/128532296">IDEA2022版本创建maven web项目（两种方式）最全图文教学_idea创建maven项目没有webapp-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41523340/article/details/122598795">IDEA中创建Maven Web项目的两种方法_idea maven创建web项目-CSDN博客</a><br>Project Structure → Modules → ＋增加Web</p>
<blockquote>
<p><strong>web application exploded</strong>：这个是以文件夹形式发布项目，发布项目时就会自动生成文件夹在指定的output directory；<br><strong>web application archive</strong>：就是war包形式,将项目打成一个war包在指定位置</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_63324772/article/details/124516436">Tomcat报404问题解决方案大全(包括tomcat可以正常运行但是报404)_tomcat 404_ISAS的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41926609/article/details/104977944">(.iml的问题)IDEA中用Maven创建web项目部署运行时页面报错404解决方法_maven web项目404-CSDN博客</a></p>
<h3 id="Web应用打包"><a href="#Web应用打包" class="headerlink" title="Web应用打包"></a>Web应用打包</h3><pre><code class="html">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Web_one&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar\war&lt;/packaging&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.2&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>打包成war\jar后可以通过tomcat中的临时启动服务器来运行</p>
<h3 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>mvn archetype:generate</td>
<td>创建Maven工程结构</td>
</tr>
<tr>
<td>mvn <strong>compile</strong></td>
<td>编译源代码 .class</td>
</tr>
<tr>
<td>mvn <strong>test</strong></td>
<td>执行测试用例</td>
</tr>
<tr>
<td>mvn <strong>clean</strong></td>
<td>清除产生的项目</td>
</tr>
<tr>
<td>mvn <strong>package</strong></td>
<td>项目打包</td>
</tr>
<tr>
<td>mvn <strong>install</strong></td>
<td>安装至本地仓库</td>
</tr>
</tbody></table>
<h3 id="修改本地仓库地址"><a href="#修改本地仓库地址" class="headerlink" title="修改本地仓库地址"></a>修改本地仓库地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/781d364e7b198b48320f5f30b0353f09e0a6e491/data/Maven%E4%BF%AE%E6%94%B9%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></p>
<h3 id="工厂模式-运用于真实项目"><a href="#工厂模式-运用于真实项目" class="headerlink" title="工厂模式 [运用于真实项目]"></a>工厂模式 [运用于真实项目]</h3><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><ul>
<li>设计模式是前辈总结的设计经验</li>
<li>设计模式的目标是代码更容易理解，更容易维护</li>
<li>通过设计模式可以让代码更加可靠</li>
</ul>
<h5 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h5><ul>
<li>创建型模式 [帮助我们如何更精巧的创建对象]</li>
<li>结构型模式 [在软件结构上通过重构\抽象 让软件结构变得更有条理]</li>
<li>行为型模式 [现实中的场景对软件的设计和优化]</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><ul>
<li>工厂模式用于隐藏创建对象的细节</li>
<li>工厂模式核心：工厂类(Factory)</li>
<li>工厂模式可以细分为<strong>简单工厂</strong>、工厂方法与抽象方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e0a6dc8012091ace359e456d27a0e99790d5e4/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png" alt="简单工厂图"></p>
<h6 id="项目应用-i18n国际化-软件分工更明确-软件耦合降低"><a href="#项目应用-i18n国际化-软件分工更明确-软件耦合降低" class="headerlink" title="项目应用-i18n国际化 (软件分工更明确 软件耦合降低)"></a>项目应用-i18n国际化 (软件分工更明确 软件耦合降低)</h6><p>不同国家显示页面的语言不同<br>抽象一个接口！！</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8697c92cea29312070f514788d158aadbde6513f/data/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81.png"></p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h6 id="反射Reflect"><a href="#反射Reflect" class="headerlink" title="反射Reflect"></a>反射Reflect</h6><ul>
<li>反射式在<strong>运行时</strong>动态访问类与对象的技术 [写死的代码不灵活]</li>
<li>反射是JDK1.2版本后的高级特性，隶属于<strong>java.lang.reflect</strong></li>
<li>大多数Java框架都是基于<strong>反射实现参数</strong>配置、<strong>动态注入</strong>等特性</li>
</ul>
<h6 id="初始反射技术"><a href="#初始反射技术" class="headerlink" title="初始反射技术"></a>初始反射技术</h6><pre><code class="java">未运用反射技术
 public static void case1()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next();
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        if(op.equals(&quot;Addition&quot;))&#123;
            mathOperation = new Addition();
        &#125;else if(op.equals(&quot;Subtraction&quot;)) &#123;
            mathOperation = new Subtraction();
        &#125;else if(op.equals(&quot;Multiplication&quot;))&#123;
            mathOperation = new Multiplication();
        &#125;else&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result);
    &#125;

======================================================
运用反射技术
 public static void case2()&#123;
        Scanner scanner = new Scanner(System.in);
        System.out.print(&quot;请输入计算类名:&quot;);
        String op = scanner.next(); ****
        System.out.print(&quot;请输入a:&quot;);
        int a = scanner.nextInt();
        System.out.print(&quot;请输入b:&quot;);
        int b = scanner.nextInt();
        MathOperation mathOperation = null;
        try &#123;
            mathOperation = (MathOperation) Class.forName(&quot;com.imooc.reflect.&quot; + op).newInstance(); //class.forName加载指定的类 实例化对象 运行时动态决定op创建哪些对象 访问哪些属性****
        &#125;catch(Exception e)&#123;
            System.out.println(&quot;无效的计算类&quot;);
            return;
        &#125;
        float result = mathOperation.operate(a, b);
        System.out.println(result); 
    &#125;
</code></pre>
<h3 id="反射的核心类"><a href="#反射的核心类" class="headerlink" title="反射的核心类"></a>反射的核心类</h3><h5 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><strong>Class类</strong></h5><p>Class是JVM中代表”类和接口”的类<br>Class对象具体包含了某个特定类的结构信息<br>通过Class对象可获取对应类的构造方法&#x2F;方法&#x2F;成员变量</p>
<h6 id="Class核心方法"><a href="#Class核心方法" class="headerlink" title="Class核心方法"></a><span style = "color : red">Class核心方法</span></h6><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Class.forName() [传入完整类名包括包]</td>
<td>静态方法,用于获取指定Class对象</td>
</tr>
<tr>
<td>classObj.newInstance()</td>
<td>通过<strong>默认构造方法创建新的对象</strong></td>
</tr>
<tr>
<td>classObj.getConstructor()</td>
<td>获得指定的public修饰构造方法Constructor对象</td>
</tr>
<tr>
<td>classObj.getMethod()</td>
<td>获取指定的public修饰方法Method对象</td>
</tr>
<tr>
<td>classObj.getField()</td>
<td>获取指定的public修饰成员变量Field对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ClassSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

public class ClassSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            //Class.forName()方法将指定的类加载到jvm,并返回对应Class对象
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            System.out.println(&quot;Employee已被加载到jvm&quot;);
            //newInstance通过默认构造方法创建新的对象
            Employee emp = (Employee)employeeClass.newInstance();
            System.out.println(emp);
        &#125; catch (ClassNotFoundException e) &#123;
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h5 id="Constructor构造方法类"><a href="#Constructor构造方法类" class="headerlink" title="Constructor构造方法类"></a><strong>Constructor构造方法类</strong></h5><ul>
<li>Constructor类是对Java类中的构造方法的抽象</li>
<li>Contructor对象包括了具体类的某个具体构造方法的声明</li>
<li>通过Constructor对象调用带参构造方法创建对象</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getConstructor()</td>
<td>获取指定public修饰的构造方法对象</td>
</tr>
<tr>
<td>constructorObj.newInstance()</td>
<td>通过对应的构造方法创建对象</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">ConstructorSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ConstructorSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123; //得到对应的class对象
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            System.out.println(employee);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
            //类名与类路径书写错误时抛出&quot;类无法找到&quot;异常
        &#125; catch (NoSuchMethodException e) &#123;
            //没有找到与之对应格式的写法
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            //当被调用的方法的内部抛出了异常而没有被捕获时
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            //对象无法被实例化，抛出&quot;实例化异常&quot;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            //非法访问异常 在程序外或作用域外访问对象或成员变量时抛出
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a><strong>Method类</strong></h5><ul>
<li>Method对象指代某个类中的方法的描述</li>
<li>Method对象使用classObj.getMethod()方法获取</li>
<li>通过Method对象调用指定对象的对应方法</li>
</ul>
<p><span style = "color : red"><strong>Method核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getMethod()</td>
<td>获取指定public修饰的方法对象</td>
</tr>
<tr>
<td>methodObj.invoke()</td>
<td>调用指定对象的对应方法</td>
</tr>
</tbody></table>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">MethodSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MethodSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Method updateSalaryMethod = employeeClass.getMethod(&quot;updateSalary&quot;, new Class[]&#123; //传入参数
               Float.class
            &#125;);
            Employee employee1 = (Employee)updateSalaryMethod.invoke(employee, new Object[]&#123;1000f&#125;); //若有返回值 要强制转换
            System.out.println(employee1);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="Field成员变量类"><a href="#Field成员变量类" class="headerlink" title="Field成员变量类"></a><strong>Field成员变量类</strong></h5><ul>
<li>Field对应某个具体类中的成员变量的声明</li>
<li>Field对象使用**classObj.getField()**方法获取</li>
<li>通过Field对象可为某对象成员变量赋值&#x2F;取值</li>
</ul>
<p><span style = "color : red"><strong>Field类核心方法</strong></span></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>classObj.getField()</td>
<td>获取指定publicc修饰的成员变量对象</td>
</tr>
<tr>
<td>fieldObj.set()</td>
<td>为某对象指定成员变量赋值</td>
</tr>
<tr>
<td>fieldObj.get()</td>
<td>获取某对象指定成员变量数值</td>
</tr>
</tbody></table>
<p>快速添加包裹try catch → 框上要包裹的 点Code → surround with<br>get()&#x2F;set()都是(在entify中)public共有方法</p>
<pre><code class="java">Employee.java
package com.imooc.reflect.entity;

import com.sun.org.apache.bcel.internal.generic.RETURN;

public class Employee &#123;
    static &#123;//静态块初始化
        System.out.println(&quot;Employee类已被加载到jvm,并已初始化&quot;);
    &#125;
    private Integer eno;
    public String ename;
    private Float salary;
    private String dname;

    public Employee() &#123;
        System.out.println(&quot;Employee默认构造方法已被执行&quot;);
    &#125;

    public Employee(Integer eno, String ename, Float salary, String dname) &#123;
        this.eno = eno;
        this.ename = ename;
        this.salary = salary;
        this.dname = dname;
        System.out.println(&quot;Employee带参构造方法已被执行&quot;);
    &#125;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public Employee updateSalary(Float val)&#123;
        this.salary = this.salary + val;
        System.out.println(this.ename + &quot;调薪至&quot; + this.salary + &quot;元&quot;);
        return this;

    &#125;
&#125;
</code></pre>
<pre><code class="java">FieldSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

public class FieldSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field enameField = employeeClass.getField(&quot;ename&quot;);
            enameField.set(employee,&quot;李雷&quot;);
            String ename = (String) enameField.get(employee);
            System.out.println(&quot;ename:&quot; + ename);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchFieldException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="getDeclared系列方法"><a href="#getDeclared系列方法" class="headerlink" title="getDeclared系列方法"></a>getDeclared系列方法</h3><ul>
<li><span style = "color:red"><strong>getDeclaredConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong></span> 获取对应对象</li>
<li><strong>getConstructor(s)</strong> | <strong>Method(s)</strong> | <strong>Field(s)</strong> 只能获取public对象</li>
<li>访问<strong>非作用域内构造方法、方法、成员变量</strong>，会抛出异常</li>
</ul>
<p>public可以直接获取 private只能通过get…获取</p>
<pre><code class="java">Employee.java + getDeclaredSample.java
package com.imooc.reflect;

import com.imooc.reflect.entity.Employee;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class getDeclaredSample &#123;
    public static void main(String[] args) &#123;
        try &#123;
            Class employeeClass = Class.forName(&quot;com.imooc.reflect.entity.Employee&quot;);
            Constructor constructor = employeeClass.getConstructor(new Class[]&#123;
                    Integer.class, String.class, Float.class, String.class
            &#125;);
            Employee employee = (Employee) constructor.newInstance(new Object[]&#123;
                    100, &quot;李磊&quot;, 3000f, &quot;研发部&quot;
            &#125;);
            Field[] fields = employeeClass.getDeclaredFields();
            for (Field field : fields)&#123;
//                System.out.println(field.getName());
                if (field.getModifiers() == 1) &#123;//成员变量修饰符 public修饰
                    Object val = field.get(employee);
                    System.out.println(field.getName() + &quot;:&quot; + val);
                &#125; else if (field.getModifiers() == 2) &#123; //private修饰
                    String methodName = &quot;get&quot; + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);//(0,1)是截取字符串 第一个大写字母
                    Method getMethod = employeeClass.getMethod(methodName);
                    Object ret = getMethod.invoke(employee);
                    System.out.println(field.getName() + &quot;:&quot; + ret);
                &#125;
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (NoSuchMethodException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InvocationTargetException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="反射在项目中的应用"><a href="#反射在项目中的应用" class="headerlink" title="反射在项目中的应用"></a>反射在项目中的应用</h3><h6 id="反射最重要的就是可以在运行时"><a href="#反射最重要的就是可以在运行时" class="headerlink" title="反射最重要的就是可以在运行时"></a>反射最重要的就是可以在运行时</h6><p><a href="seata.io/en-us/">反射的应用网站</a></p>
<p>对原始程序无需任何调整，只需要把对应的接口进行实现，放到线上服务器，再调整配置文件。</p>
<pre><code class="java">Zhcn.java
package com.imooc.i18n;

public class Zhcn implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;生命不息奋斗不止&quot;;
    &#125;
&#125;
=========================================================
En.java
package com.imooc.i18n;

public class En implements I18N&#123;
    @Override
    public String say() &#123;
        return &quot;Case to the struggle and cease to the life&quot;;
    &#125;
&#125;
========================================================
接口I18N.java
package com.imooc.i18n;

public interface I18N &#123;
    public String say();
&#125;
</code></pre>
<pre><code class="java">package com.imooc.i18n;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.Properties;

public class Application &#123;
    public static void say()&#123;
        Properties properties = new Properties(); //加载指定的配置文件
        String configPath = Application.class.getResource(&quot;/config.properties&quot;).getPath();
        try &#123;
            configPath = new URLDecoder().decode(configPath,&quot;UTF-8&quot;);//路径中的空格默认得到url编码所以要转换一下
            properties.load(new FileInputStream(configPath)); //内容来源于文件 文件输入流
            String language = properties.getProperty(&quot;language&quot;);
            I18N i18n = (I18N)Class.forName(language).newInstance();
            System.out.println(i18n.say());
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (InstantiationException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IllegalAccessException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Application.say();
    &#125;
&#125;
</code></pre>
<pre><code class="html">language=com.imooc.i18n.En
或
language=com.imooc.i18n.Zhcn
</code></pre>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li>JDK8(1.8以上)开始支持Lambda表达式，用来让程序编写更优雅</li>
<li>利用Lambda可以更简洁的<strong>实现匿名内部类</strong>与<strong>函数声明与调用</strong></li>
<li>基于Lambda提供<strong>stream流</strong>式处理极大简化对集合的操作</li>
</ul>
<h6 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//实现集合排序
Collections.sort(names,new Comparator&lt;String&gt;()&#123;
  @Override
  public int compare(String a,String b)&#123;
      return b.compareTo(a);
  &#125;  
&#125;);
</code></pre>
<h6 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h6><pre><code class="java">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;,&quot;anna&quot;,&quot;mike&quot;,&quot;xenia&quot;);
//通过lambda表达式简化匿名类的编写
Collections.sort(names,(a,b) -&gt; b.compareTo(a));
</code></pre>
<h3 id="Lambda表达式语法-代码脚手架"><a href="#Lambda表达式语法-代码脚手架" class="headerlink" title="Lambda表达式语法 [代码脚手架]"></a><span style = "color : red">Lambda表达式语法</span> [代码脚手架]</h3><p><strong><span style = "color:red">(参数列表) —＞实现语句</span></strong><br>[<u>使用逗号分割参数,参数类型可省略,单参数括号可省略</u>]<br>[<u>单行直接写 多行用{}包括</u>]</p>
<pre><code class="java">MathOperation.java
public interface MathOperation &#123;
    //四则运算接口
    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<pre><code class="java">LambdaSample.java
public class LambdaSample &#123;
    public static void main(String[] args) &#123;
        //标准Lambda使用方法
        //约束条件：Lambda表达式只能实现有且只有一个抽象方法的接口,Java称为&quot;函数式接口&quot;
        //1.标注使用方式
        MathOperation addition = (Integer a, Integer b) -&gt; &#123;
            System.out.println(&quot;加法运算&quot;);
            return a+b+0f; //定义的接口是Float
        &#125;;
        System.out.println(addition.operate(5, 5));

        //2.lambda允许忽略参数类型
        MathOperation substration = (a,b) -&gt; &#123;
            return a-b+0f;
        &#125;;
        System.out.println(substration.operate(5, 3));

        //3.单行实现代码可以省略大括号和return
        MathOperation multiplication = (a,b) -&gt; a*b+0f;
        System.out.println(multiplication.operate(3, 5));
    &#125;
&#125;
</code></pre>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>函数式编程是基于函数式接口并使用lambda表达的编程方式</li>
<li>函数式编程理念是将代码作为可重用数据带入到程序运行中</li>
<li>函数式编程强调”<strong>你想做什么</strong>“，而不是”<strong>你想怎么做</strong>“</li>
</ul>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><ul>
<li>函数式接口是有且只有一个抽象方法的接口</li>
<li>Java中拥有大量函数式接口，如<strong>java.lang.Runnable</strong></li>
<li>JDK8后提供了一系列新的函数式接口，位于<strong>java.util.function</strong></li>
</ul>
<h3 id="函数式接口Perdicate"><a href="#函数式接口Perdicate" class="headerlink" title="函数式接口Perdicate"></a>函数式接口Perdicate</h3><ul>
<li>Perdicate是新增的函数式接口，位于<strong>java.util.function</strong></li>
<li><u>Perdicate用于测试传入的数据是否满足<strong>判断要求</strong></u></li>
<li>Perdicate接口需要实现test()方法进行逻辑判断</li>
</ul>
<p><span style = "color:red"> 用<strong>lambda表达式</strong>来实现<strong>predicate</strong>的验证</span><br>将已有的代码变成可重复使用的资源放入程序中</p>
<pre><code class="java">PredicateSample.java
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

/*
    理解函数式编程
    Perdicate函数式接口的使用方法
 */
public class PredicateSample &#123;
    public static void main(String[] args) &#123;
        Predicate &lt;Integer&gt; predicate = n-&gt;n&gt;4; //隐藏着return
        boolean result = predicate.test(10);
        System.out.println(result);
        List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
        filter(list,n-&gt;n%2==1); //传入函数式接口的实现lambda 取所有奇数
        filter(list,n-&gt;n%2==0); //取所有偶数
        filter(list,n-&gt;n&gt;5 &amp;&amp; n%2==0); //取所有大于5的偶数
    &#125;
    public static void filter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)&#123;
        for (Integer num:list)&#123;
            if (predicate.test(num))&#123;
                System.out.println(num + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="各种函数接口"><a href="#各种函数接口" class="headerlink" title="各种函数接口"></a>各种函数接口</h3><h5 id="JDK8常用函数式接口"><a href="#JDK8常用函数式接口" class="headerlink" title="JDK8常用函数式接口"></a>JDK8常用函数式接口</h5><h6 id="consumer函数接口"><a href="#consumer函数接口" class="headerlink" title="consumer函数接口"></a>consumer函数接口</h6><table>
<thead>
<tr>
<th><strong>接口</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Consumer&lt; T &gt;</strong></td>
<td><strong>对应有一个输入参数无输出的功能代码</strong></td>
</tr>
<tr>
<td><strong>Function&lt; T,R &gt;</strong></td>
<td>对应有一个输入参数且需要返回参数的功能代码</td>
</tr>
<tr>
<td><strong>Predicate&lt; T &gt;</strong></td>
<td>用于条件判断，固定返回布尔值</td>
</tr>
</tbody></table>
<pre><code class="java">ConsumerSample.java
import java.util.function.Consumer;

/*
    Consumer接口的使用
 */
public class ConsumerSample &#123;
    public static void main(String[] args) &#123;
        output(s-&gt; System.out.println(&quot;向控制台打印：&quot; + s));
        //字符串作为网络数据包向某个网站发送
        output(s-&gt;&#123;
            System.out.println(&quot;向XXX网络发送数据包:&quot; + s);
        &#125;);
    &#125;
    public static void output(Consumer&lt;String&gt; consumer)&#123;
        String text = &quot;苦其心志,劳其筋骨&quot;;
        consumer.accept(text);
    &#125;
&#125;
</code></pre>
<h6 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h6><pre><code class="java">FunctionSample.java
import java.util.Random;
import java.util.function.Function;

/*
    利用Function函数式接口生成定长随机字符串[加密解密会用到]
 */
public class FunctionSample &#123;
    public static void main(String[] args) &#123;
        Function&lt;Integer,String&gt; randomStringFunction = l-&gt;&#123;
            String chars = &quot;abcdefghijklmnopqrstuvxwyz0123456789&quot;;
            StringBuffer stringBuffer = new StringBuffer();
            Random random = new Random();
            for (int i = 0; i &lt; l; i++) &#123;
                int position = random.nextInt(chars.length());
                stringBuffer.append(chars.charAt(position));//按指定位置将字符提取并追加
            &#125;
            return stringBuffer.toString();
        &#125;;
        String randowmString = randomStringFunction.apply(16);//生成16位长的字符串
        System.out.println(randowmString);
    &#125;
&#125;
</code></pre>
<h6 id="functionalInterface注解"><a href="#functionalInterface注解" class="headerlink" title="@functionalInterface注解"></a>@functionalInterface注解</h6><pre><code class="java">MathOperation.java
@FunctionalInterface //通知编译器这是函数式接口，进行抽象方法检查
public interface MathOperation &#123;
    //四则运算接口

    public Float operate(Integer a, Integer b);
&#125;
</code></pre>
<h3 id="函数式编程与面向对象编程比较"><a href="#函数式编程与面向对象编程比较" class="headerlink" title="函数式编程与面向对象编程比较"></a>函数式编程与面向对象编程比较</h3><table>
<thead>
<tr>
<th></th>
<th>面向对象编程</th>
<th>函数式编程</th>
</tr>
</thead>
<tbody><tr>
<td>设计思路</td>
<td>面向对象</td>
<td>面向过程</td>
</tr>
<tr>
<td>开发侧重</td>
<td>侧重过程,重分析,重设计</td>
<td>侧重结果,快速实现</td>
</tr>
<tr>
<td>可读性</td>
<td>结构复杂,相对较差</td>
<td>更适合人眼阅读,可读性更好</td>
</tr>
<tr>
<td>代码量</td>
<td>多</td>
<td>少</td>
</tr>
<tr>
<td>并发问题</td>
<td>设计不当,会出现线程安全问题</td>
<td>不会出现线程安全问题</td>
</tr>
<tr>
<td>健壮性</td>
<td>好</td>
<td>差</td>
</tr>
<tr>
<td>使用场景</td>
<td>中大型项目,多人协作工程</td>
<td>小型应用,要求快速实现</td>
</tr>
</tbody></table>
<h3 id="Stream流式处理"><a href="#Stream流式处理" class="headerlink" title="Stream流式处理"></a>Stream流式处理</h3><ul>
<li>Stream流式处理式建立在Lambda基础上的多数据处理技术 </li>
<li>Stream对集合数据处理进行高度抽象，极大简化代码量</li>
<li>Stream可对集合进行迭代,去重,筛选,排序,聚合等一系列处理</li>
</ul>
<h3 id="Stream示例"><a href="#Stream示例" class="headerlink" title="Stream示例"></a>Stream示例</h3><pre><code class="java">//获取List集合中最大的偶数
Optional&lt;Integer&gt; op = Arrays.asList(1,2,3,4,5,6).stream()
.filter(x-&gt;x%2==0) //处理完得到一个只包含偶数的list流数据
.sorted((a,b)-&gt;b-a) //大的在前面 小的在后面
.findFirst(); //获取最大的数据
System.out.println(op.get());
</code></pre>
<h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a><span style = "color : red">Stream常用方法</span></h3><table>
<thead>
<tr>
<th>接口</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>forEach</td>
<td>循环遍历</td>
</tr>
<tr>
<td>map</td>
<td>map方法用于映射每个元素到对应的结果</td>
</tr>
<tr>
<td>filter</td>
<td>filter方法用于通知设置的条件过滤出元素</td>
</tr>
<tr>
<td>limit</td>
<td>limit方法用于获取指定数量的流</td>
</tr>
<tr>
<td>sorted</td>
<td>sorted方法用于对流进行排序</td>
</tr>
<tr>
<td>Collectors</td>
<td>Collectors类实现将流转换成集合和聚合元素</td>
</tr>
</tbody></table>
<pre><code class="java">StreamGenerator.java
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/*
Stream流对象的五种创建方式
 */
public class StreamGenerator &#123;
    //1.基于数组进行创建
    @Test
    public void generator1()&#123;
        String[] arr = &#123;&quot;Lily&quot;,&quot;Andy&quot;,&quot;Jackson&quot;,&quot;Smith&quot;&#125;;
        Stream&lt;String&gt; stream = Stream.of(arr);
        stream.forEach(s -&gt; System.out.println(s)); //forEach中使用Lambda表达式
    &#125;

    //2.基于集合进行创建
    @Test
    public void generator2()&#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Lily&quot;);
        list.add(&quot;Andy&quot;);
        list.add(&quot;Jackson&quot;);
        list.add(&quot;Smith&quot;);
        Stream&lt;String&gt; stream = list.stream(); //利用集合获取stream
        stream.forEach(s -&gt; System.out.println(s));
    &#125;

    //3.利用generate方法创建无限长度流
    @Test
    public void generator3()&#123;
        Stream&lt;Integer&gt; stream = Stream.generate(() -&gt; new Random().nextInt(100000));//Supplier&lt;T&gt; s 创建新对象
        stream.limit(10).forEach(i -&gt; System.out.println(i)); //limit限制长度
    &#125;

    //4.基于迭代器创建流
    @Test
    public void generator4()&#123;
        Stream&lt;Integer&gt; stream = Stream.iterate(1, n -&gt; n + 1);//无限长度自增
        stream.limit(100).forEach(i -&gt; System.out.println(i));
    &#125;

    //5.基于字符序列创建流
    @Test
    public void genetator5()&#123;
        String str = &quot;abcdefg我&quot;;
        IntStream stream = str.chars();
        stream.forEach(c -&gt; System.out.println((char)c));
    &#125;
&#125;
</code></pre>
<pre><code class="java">StreamMethod.java
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamMethod &#123;
    @Test //提取集合中所有偶数并求和
    public void case1()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
        int sum = list.stream() //获取stream对象
                .mapToInt(s -&gt; Integer.parseInt(s)) //对每个元素字符串转为整数
                .filter(n -&gt; n%2==0) //filter对流数据进行过滤
                .sum();//求和
        System.out.println(sum);
    &#125;

    @Test //所有名字首字母大写
    public void case2()&#123;
        List&lt;String&gt; list = Arrays.asList(&quot;lily&quot;,&quot;smith&quot;,&quot;jackson&quot;);
        List newList = list.stream()
                .map(s -&gt; s.substring(0, 1).toUpperCase() + s.substring(1)) //首字母大写转换
//                .forEach(s -&gt; System.out.println(s));
                .collect(Collectors.toList()); //collect对流数据进行收集,生成新的List/Set(将重复数据自动清除)
        System.out.println(newList);
    &#125;

    @Test //将所有奇数从大到小进行排序，且不允许出现重复
    public void case3()&#123;
        List&lt;Integer&gt; list = Arrays.asList(1, 60, 38, 21, 51, 60, 51, 73);
        List newList = list.stream().distinct() //去除重复的流数据
                .filter(n -&gt; n%2==1)
                .sorted((a,b) -&gt; b-a) //从大到小的数据排列
                .collect(Collectors.toList());
        System.out.println(newList);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/26/后端/Maven,工厂模式,反射模式,Lambda表达式,stream流式处理/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/23/后端/java数据库开发(JDBC)/">
        <h2>
            java数据库开发(JDBC)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="IDEA窗口快捷键"><a href="#IDEA窗口快捷键" class="headerlink" title="IDEA窗口快捷键"></a>IDEA窗口快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Alt+S</td>
<td>Settings面板</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+F&#x2F;R</strong></td>
<td>当前Project中全局查找&#x2F;替换</td>
</tr>
<tr>
<td><strong>Ctrl+Shif+N</strong></td>
<td>文件查找面板</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>快速生成面板</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+A</strong></td>
<td>Find Action模糊<strong>查询快速定位</strong></td>
</tr>
</tbody></table>
<h3 id="代码快捷键"><a href="#代码快捷键" class="headerlink" title="代码快捷键"></a>代码快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+←→</td>
<td>上一个&#x2F;下一个单词</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+Enter</strong></td>
<td><strong>自动完成</strong></td>
</tr>
<tr>
<td>Alt+Enter</td>
<td>智能提示</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+(Shift)+&#x2F;</td>
<td>行注释&#x2F;块注释</td>
</tr>
<tr>
<td>Ctrl+Alt+Shift+J</td>
<td>列操作</td>
</tr>
<tr>
<td>Shift+F6</td>
<td>重命名(当前选择变量修改)</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>选中单词</td>
</tr>
</tbody></table>
<h3 id="代码快速定位"><a href="#代码快速定位" class="headerlink" title="代码快速定位"></a>代码快速定位</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+(Shift)+E</td>
<td>最近访问(编辑)的文件列表</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+1~9</strong></td>
<td><strong>创建书签</strong></td>
</tr>
<tr>
<td><strong>Shift+F11</strong></td>
<td><strong>查看书签</strong></td>
</tr>
<tr>
<td><strong>Ctrl+1~9</strong></td>
<td><strong>快速切换书签</strong></td>
</tr>
<tr>
<td>Alt+←→</td>
<td>切换书签</td>
</tr>
</tbody></table>
<h6 id="Template使用"><a href="#Template使用" class="headerlink" title="Template使用"></a>Template使用</h6><p><strong>Live Templates</strong>可以添加常用快捷字母作为快捷代码</p>
<blockquote>
<p>右方 + “custom”<br>“<strong>Abbreviation</strong>：al”<br>“<strong>Description</strong>：Create ArrayList”<br>“<strong>Template text</strong>：List&lt; String &gt;list &#x3D; new ArrayList();”<br>“<strong>Template text</strong>：List&lt; $VAR1$&gt;$VAR2$ &#x3D; new ArrayList();”<br>点击define设置全部</p>
</blockquote>
<h3 id="运行与打包"><a href="#运行与打包" class="headerlink" title="运行与打包"></a>运行与打包</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Shift+F9</td>
<td>调试</td>
</tr>
<tr>
<td>Shift+F10</td>
<td>运行</td>
</tr>
<tr>
<td>F8</td>
<td>单步运行</td>
</tr>
<tr>
<td>F9</td>
<td>恢复运行至下一个端点</td>
</tr>
<tr>
<td>Shift+Ctrl+F8</td>
<td>查看所有端点</td>
</tr>
</tbody></table>
<h6 id="Jar包核心配置文件设置-加载响应的Class"><a href="#Jar包核心配置文件设置-加载响应的Class" class="headerlink" title="Jar包核心配置文件设置(加载响应的Class)"></a>Jar包核心配置文件设置(加载响应的Class)</h6><h4 id="将编译的类导入jar包"><a href="#将编译的类导入jar包" class="headerlink" title="将编译的类导入jar包"></a>将编译的类导入jar包</h4><p><strong><u>‘……’ compile output</u></strong><br><strong>Project Structure → Artifacts → Outpub Layout</strong></p>
<p>设置jar包的入口类 → Create Manifest… → Main Class(Jar包加载相应目录)</p>
<h4 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h4><p>上述操作完毕后 点<strong>Build</strong> 点<strong>Build Artifacts…</strong> </p>
<h3 id="IDEA快速开发Web应用"><a href="#IDEA快速开发Web应用" class="headerlink" title="IDEA快速开发Web应用"></a>IDEA快速开发Web应用</h3><p>New Project → Java Enterprise → SDK1.8 &#x3D; Java EE7</p>
<h6 id="改变Tomcat启动时自动弹出的地址"><a href="#改变Tomcat启动时自动弹出的地址" class="headerlink" title="改变Tomcat启动时自动弹出的地址"></a>改变Tomcat启动时自动弹出的地址</h6><p><strong>Run&#x2F;Debug Configurations</strong> → Deployment → 下方的 Application context</p>
<h6 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h6><p>Artifacts 中默认存在 <strong>javaweb: war exploded</strong> 代表用文件夹的方式与Tomcat联动<br>点Add → <strong>Web Application: Archive</strong>打包 右侧是待添加 [文件成功发布到jar包中 <strong>‘javaweb’ compile output</strong>] 右侧的<strong>Web facet resources</strong> 是 jsp, html等静态资源双击放到左边[<strong>‘javaweb’module: ‘Web’ facet resources</strong>] 至此javaweb.war包就包含了所有文件。上述操作完毕后 点<strong>Build</strong> 点<strong>Build Artifacts…</strong> build！！之后若在实际运行的时候放在D:\apache-tomcat-8.5.93\webapps内 之后启动<strong>tomcat</strong>[D:\apache-tomcat-8.5.93\bin\startup.bat]就可以显示结果</p>
<h3 id="JDBC-Java-DataBase-Connectivity-快速入门"><a href="#JDBC-Java-DataBase-Connectivity-快速入门" class="headerlink" title="JDBC(Java DataBase Connectivity)快速入门"></a>JDBC(Java DataBase Connectivity)快速入门</h3><p>JDBC作用，<u>在java程序中与关系型数据库进行交互</u></p>
<h6 id="JDBC优点"><a href="#JDBC优点" class="headerlink" title="JDBC优点"></a>JDBC优点</h6><ul>
<li>统一的API，提供一致的开发过程</li>
<li>易于学习，容易上手，代码结构稳定</li>
<li>功能强大，执行效率高，可处理海量数据</li>
</ul>
<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><table>
<thead>
<tr>
<th>1.加载并注册JDBC驱动</th>
</tr>
</thead>
<tbody><tr>
<td>2.创建数据库连接</td>
</tr>
<tr>
<td>3.创建Satement对象</td>
</tr>
<tr>
<td>4.遍历查询结果</td>
</tr>
<tr>
<td>5.关闭连接.释放资源</td>
</tr>
</tbody></table>
<h3 id="Class-forName的作用"><a href="#Class-forName的作用" class="headerlink" title="Class.forName的作用"></a>Class.forName的作用</h3><ul>
<li>Class.forName用于加载指定的JDBC驱动类</li>
<li>Class.forName本质是通知JDBC注册这个驱动类</li>
<li>驱动由数据库厂商自行开发，俩厂家不同链接祖父串了，字符串也不同</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/34bcb468f79e1c2701e12f8c4d8eb06954ed2f38/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<h3 id="创建数据库连接代码"><a href="#创建数据库连接代码" class="headerlink" title="创建数据库连接代码"></a>创建数据库连接代码</h3><pre><code class="sql">String dbDriver = &quot;com.mysql.cj.jdbc.Driver&quot;; //JDBC驱动类
String dbURL = &quot;jdbc:mysql://localhost:3306/imooc&quot;; //连接字符串
String dbUsername =  &quot;root&quot;;
String dbPassword = &quot;123456&quot;;
//1.加载并初始化JDBC驱动
Class.forName(dbDriver);
//2.创建数据库连接
Connection connection = DriverManager.getConnection(dbURL,dbUsername,dbPassword);
</code></pre>
<pre><code class="sql">StandardJDBCSample.java
package com.example.imoocjdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class StandardJDBCSample &#123;
    public static void main(String[] args) &#123;
        Connection conn = null;
        try &#123;
            //1.加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //加载指定的类
            //2.创建数据库连接
            conn = DriverManager.getConnection(
                    &quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;&amp;allowPublicKeyRetrieval=true&quot;,
                    &quot;root&quot;, &quot;root&quot;
            ); //程序和数据库的网络通信桥梁
            //3.创建Satement对象 ResultSet结果集
            Statement stmt = conn.createStatement(); //一条或多条sql语句
            ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM employee WHERE dname=&#39;研发部&#39;&quot;);
            //4.遍历查询结果
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1); //把当前行指定未知的提取 eno
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                if (conn != null &amp;&amp; conn.isClosed() == false) &#123;
                    //5.关闭连接.释放资源
                    conn.close();
                &#125;
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC驱动的秘密"><a href="#JDBC驱动的秘密" class="headerlink" title="JDBC驱动的秘密"></a>JDBC驱动的秘密</h3><h5 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h5><ul>
<li><strong>DriverManager</strong>用于注册&#x2F;管理JDBC驱动程序</li>
<li><strong>DriverManager.getConnection</strong>(连接字符串,用户名,密码)</li>
<li>返回值<strong>Connection</strong>对象,对应数据库的物理网络连接</li>
</ul>
<h5 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h5><ul>
<li><strong>Connection</strong>对象用于JDBC与数据库的网络通信对象</li>
<li>java.sql.Connection是一个接口，具体由驱动厂商实现</li>
<li>所有数据库的操作都建立在Connection上</li>
</ul>
<h3 id="MySQL连接字符串"><a href="#MySQL连接字符串" class="headerlink" title="MySQL连接字符串"></a>MySQL连接字符串</h3><ul>
<li>格式: jdbc:mysql:&#x2F;&#x2F;[主机ip] [:端口]&#x2F;数据库名?参数列表</li>
<li>主机ip与端口是可选设置，默认值为127.0.0.1与3306</li>
<li>参数列表采用url编码,格式:参数1&#x3D;值1&amp;参数2&#x3D;值2</li>
</ul>
<h6 id="MySQL连接字符串常用参数"><a href="#MySQL连接字符串常用参数" class="headerlink" title="MySQL连接字符串常用参数"></a>MySQL连接字符串常用参数</h6><table>
<thead>
<tr>
<th>参数名</th>
<th>建议参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>useSSL</td>
<td>true(生产) false(开发)</td>
<td>是否禁用ssl</td>
</tr>
<tr>
<td>useUnicode</td>
<td>true</td>
<td>启用unicode编码传输数据</td>
</tr>
<tr>
<td>characterEncoding</td>
<td>UTF-8</td>
<td>使用UTF-8编码传输数据</td>
</tr>
<tr>
<td>serverTimezone</td>
<td>Asia&#x2F;Shanghai</td>
<td>使用东8时区时间,UTC+8</td>
</tr>
<tr>
<td>allowPublicKeyRetrieval</td>
<td>true</td>
<td>允许从客户端获取公钥加密传输</td>
</tr>
</tbody></table>
<h6 id="超级异常捕获"><a href="#超级异常捕获" class="headerlink" title="超级异常捕获"></a>超级异常捕获</h6><p>选中所需要的代码区域 → Code → Surround With → 6.try…catch</p>
<h3 id="SQL注入攻击-数据泄露"><a href="#SQL注入攻击-数据泄露" class="headerlink" title="SQL注入攻击 [数据泄露]"></a>SQL注入攻击 [数据泄露]</h3><p>当输入部门名称：**’ or 1&#x3D;1 or 1&#x3D;’**<br>只要在or左右两侧有一个成立就都成立的 输入的数据中并没有对单引号加以处理；</p>
<pre><code class="sql">package com.imooc.jdbc.hrapp.command;

import java.sql.*;
import java.util.Scanner;

/**
 * 数据查询方法
 */
public class QueryCommand implements Command &#123;
    @Override
    public void execute() &#123;
        System.out.print(&quot;请输入部门名称：&quot;);
        Scanner in = new Scanner(System.in);
        String pdname = in.nextLine();
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try &#123;
            //1. 加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            //2. 创建数据库连接
            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
            //3. 创建Statement对象
            stmt = conn.createStatement();
            //结果集
            System.out.println(&quot;select * from employee where dname=&#39;&quot; + pdname + &quot;&#39;&quot;);
            rs = stmt.executeQuery(&quot;select * from employee where dname=&#39;&quot; + pdname + &quot;&#39;&quot;);
            //4. 遍历查询结果
            //rs.next()返回布尔值，代表是否存在下一条记录
            //如果有，返回true,同时结果集提取下一条记录
            //如果没有，返回false，循环就会停止
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);

            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5. 关闭连接,释放资源
            try &#123;
                if(rs != null)&#123;
                    rs.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(stmt != null)&#123;
                    stmt.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                    conn.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="PreparedStatement-解决SQL攻击注入问题-特殊字符转义"><a href="#PreparedStatement-解决SQL攻击注入问题-特殊字符转义" class="headerlink" title="PreparedStatement[解决SQL攻击注入问题(特殊字符转义)]"></a><span style = "color:red">PreparedStatement[解决SQL攻击注入问题(特殊字符转义)]</span></h3><h6 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h6><ul>
<li>SQL注入攻击是指利用SQL漏洞越权获取数据的黑客行为</li>
<li>SQL注入攻击根源是未对原始SQL中的敏感字符做特殊处理</li>
<li>解决方法：放弃Statement改用PreparedStatement处理SQL</li>
</ul>
<h6 id="PreparedStatement-变化的地方用问号替代"><a href="#PreparedStatement-变化的地方用问号替代" class="headerlink" title="PreparedStatement [变化的地方用问号替代]"></a>PreparedStatement [变化的地方用问号替代]</h6><ul>
<li>PreparedStatement预编译Statement是Statement的子接口</li>
<li>PreparedStatement对SQL进行参数化, 预防SQL注入攻击</li>
<li>PreparedStatement比Statement执行效率更高</li>
<li>要用<strong>参数化</strong>的sql语句(问号只能出现在值的地方 且不能二次计算)<br><strong>String sql &#x3D; “select * from employee where <u>dname&#x3D;?</u> and <u>eno &gt; ?</u>“;</strong><br><strong>pstmt &#x3D; conn.prepareStatement(sql);</strong><br><strong>pstmt.setString(1,pdname);</strong> &#x2F;&#x2F;插入多句 自动寻导入上方sql语句<br><strong>pstmt.setInt(2,3500);</strong></li>
</ul>
<pre><code class="sql">//利用PreparedStatement预防SQL注入风险
//当dname值为&#39; or 1=1 or 1=&#39; 时，查询不到任何结果
//SQL:select * from employee where dname = &#39;\&#39; or 1=1 or 1=\”
String sql = &quot;select * from employee where dname=?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1,dname); //设置SQL参数,参数从1开始
ResultSet rs = pstmt.executeQuery();
while(rs.next())&#123;
    ...
&#125;
</code></pre>
<h3 id="JDBC实现写数据"><a href="#JDBC实现写数据" class="headerlink" title="JDBC实现写数据"></a>JDBC实现写数据</h3><h5 id="封装DbUtils工具类-重复代码封装工具类-封装打开和关闭连接方法"><a href="#封装DbUtils工具类-重复代码封装工具类-封装打开和关闭连接方法" class="headerlink" title="封装DbUtils工具类 [重复代码封装工具类(封装打开和关闭连接方法)]"></a>封装DbUtils工具类 [<u>重复代码封装工具类(封装打开和关闭连接方法)</u>]</h5><pre><code class="sql">DbUtils.java
package common;

import kotlin.Result;

import java.sql.*;

public class DbUtils &#123;
    /**
     * 创建新的数据库连接
     * @return 新的Connection对象
     * @throws ClassNotFoundException
     * @throws SQLException
     */
    public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;
        //1. 加载并注册JDBC驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //2. 创建数据库连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    &#125;

    /**
     * 关闭连接，释放资源
     * @param rs 结果集对象
     * @param stmt Statement对象
     * @param conn Connection对象
     */
    public static void closeConnection(ResultSet rs, Statement stmt, Connection conn)&#123;
        try &#123;
            if(rs != null)&#123;
                rs.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(stmt != null)&#123;
                stmt.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                conn.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC执行INSERT语句"><a href="#JDBC执行INSERT语句" class="headerlink" title="JDBC执行INSERT语句"></a>JDBC执行INSERT语句</h3><pre><code class="sql">String sql = &quot;insert into employee(eno,ename) values(?,?)&quot;;
PreparedStatement pstmt = conn.PreparedStatement(sql);
pstmt.setInt(1,10);
pstmt.setString(2,&quot;张三&quot;);
//executeUpdate方法返回记录数
int cnt = pstmt.executeUpdate(); //cnt=1
System.out.println(&quot;数据新增成功&quot;);
</code></pre>
<h3 id="JDBC执行UPDATE语句"><a href="#JDBC执行UPDATE语句" class="headerlink" title="JDBC执行UPDATE语句"></a>JDBC执行UPDATE语句</h3><pre><code class="sql">String sql = &quot;update employee set salary = salary + 1000 where dname=?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1,&quot;研发部&quot;);
//executeUpdate方法返回记录数
int cnt = pstmt.exexuteUpdate();
System.out.println(“研发部”+cnt+&quot;名员工提薪1000元&quot;);
</code></pre>
<h3 id="JDBC执行DELETE语句"><a href="#JDBC执行DELETE语句" class="headerlink" title="JDBC执行DELETE语句"></a>JDBC执行DELETE语句</h3><pre><code class="sql">String sql = &quot;delete from employee where eno = ?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1,3395);
//executeUpdate方法返回记录数
int cnt = pstmt.executeUpdate();
System.out.println(cnt+&quot;名员工数据已被删除&quot;);
</code></pre>
<h3 id="JDBC事务管理方式"><a href="#JDBC事务管理方式" class="headerlink" title="JDBC事务管理方式"></a>JDBC事务管理方式</h3><ul>
<li>事务是以一种可靠的、一致的方式，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<blockquote>
<h6 id="事务的提交操作"><a href="#事务的提交操作" class="headerlink" title="事务的提交操作"></a>事务的提交操作</h6><p>应用程序写操作給事务区等全部完成后事务区再<strong>commit提交</strong>給数据表<strong>一次性写入</strong>給mysql。提交成功后事务区中的数据被清空</p>
<h6 id="事务的回滚操作"><a href="#事务的回滚操作" class="headerlink" title="事务的回滚操作"></a>事务的回滚操作</h6><p>应用程序写操作給事务区，如果+100突然-100程序报错了，由jdbc会向事务区发起rollback回滚操作 清空事务区，最终数据表不会产生任何写操作[<u>要么什么都不做，不要做一半</u>]</p>
</blockquote>
<h3 id="JDBC两种事务模式"><a href="#JDBC两种事务模式" class="headerlink" title="JDBC两种事务模式"></a>JDBC两种事务模式</h3><ul>
<li><h6 id="自动提交事务模式"><a href="#自动提交事务模式" class="headerlink" title="自动提交事务模式"></a>自动提交事务模式</h6></li>
</ul>
<p>​        自动提交模式是指每一次写操作SQL，自动提交事务</p>
<pre><code class="sql">自动提交开启方法:
conn.setAutoCommit(true)
</code></pre>
<p>​        自动事务是JDBC默认行为，此模式无法保证多数据一致性[A钱少了 B钱增加]</p>
<ul>
<li><h6 id="手动提交事务模式"><a href="#手动提交事务模式" class="headerlink" title="手动提交事务模式"></a>手动提交事务模式</h6></li>
</ul>
<p>​        手动提交模式是指显式调用commit()与rollback()方法管理事务</p>
<pre><code class="sql">手动提交开启方法:
conn.setAutoCommit(false)
</code></pre>
<p>​        手动提交事务可保证多数据一致性，但必须手动调用提交&#x2F;回滚方法</p>
<h3 id="实现批量增加员工"><a href="#实现批量增加员工" class="headerlink" title="实现批量增加员工"></a>实现批量增加员工</h3><pre><code class="sql">package test;

import common.DbUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionSample &#123;
    public static void main(String[] args) &#123;
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 1000; i &lt; 2000; i++) &#123;
                if (i==1005)&#123;
//                    throw new RuntimeException(&quot;插入失败&quot;);
                &#125;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
                pstmt.executeUpdate();
            &#125;
            conn.commit(); //提交数据
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="基于实体类实现分页数据封装"><a href="#基于实体类实现分页数据封装" class="headerlink" title="基于实体类实现分页数据封装"></a>基于实体类实现分页数据封装</h3><p>日常开发中如果要对数据进行提取以后最常见的形式是将数据转换为对应的实体类再放到集合中进行保存，即使被关闭数据也不会丢失。</p>
<pre><code class="sql">package common;

import common.entity.Employee;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 分页查询员工数据
 */
public class PaginationCommand implements Command&#123;
    @Override
    public void execute() &#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入页号:&quot;);
        int page = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List&lt;Employee&gt; list = new ArrayList(); //将底下的信息封装到实体类中
        try &#123;
            conn = DbUtils.getConnection(); //?前面第几行 10从这行开始向后取10条记录 limit是分页独有的方言
            String sql = &quot;select * from employee limit ?,10&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1,(page-1)*10); //第二页(2-1)*10从第十条记录开始向后取10条
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(&quot;eno&quot;); //不能在原有字段1前再新增1 按照名字来获取
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                //JDBC获取日期使用java.sql.Date,其继承自java.util.Date
                //所以两者互相兼容
                Date hiredate = rs.getDate(&quot;hiredate&quot;);
                Employee emp = new Employee(); //每产生一条记录都要封装成Employee对象
                emp.setEno(eno);
                emp.setEname(ename);
                emp.setSalary(salary);
                emp.setDname(dname);
                emp.setHiredate(hiredate);//把每一条记录都封装成为了实体类 放入list
                list.add(emp);
            &#125;
            System.out.println(list.size());
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC中Date日期对象的处理"><a href="#JDBC中Date日期对象的处理" class="headerlink" title="JDBC中Date日期对象的处理"></a>JDBC中Date日期对象的处理</h3><pre><code class="sql">package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

/*
   新增员工数据
 */
public class InsertCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号:&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工姓名:&quot;);
        String ename = in.next();
        System.out.println(&quot;请输入员工薪资:&quot;);
        float salary = in.nextFloat();
        System.out.println(&quot;请输入隶属部门:&quot;);
        String dname = in.next();
        System.out.println(&quot;请输入入职日期:&quot;);
        String strHiredate = in.next();
        //String到java.sql.Date分为两步
        //1.前端传入的String字符串转为java.util.Date
        java.util.Date udHiredate = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            udHiredate = sdf.parse(strHiredate);//对原有字符串解析
        &#125; catch (ParseException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //2.java.util.Date转为java.sql.Date
        long time = udHiredate.getTime();//获取从1970到现在的毫秒数
        java.sql.Date sdHiredate = new java.sql.Date(time); //sdHiredate成功表达了strHiredate所表达的时间
        Connection conn = null;
        PreparedStatement pstmt = null;
        //新增数据 获取数据库连接
        try &#123;
            conn = DbUtils.getConnection(); //↓作为写操作的sql一定要是参数化的(pstmt)
            String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) value(?,?,?,?,?)&quot;;
            pstmt = conn.prepareStatement(sql); //sql被解析
            pstmt.setInt(1,eno);
            pstmt.setString(2,ename);
            pstmt.setFloat(3,salary);
            pstmt.setString(4,dname);
            pstmt.setDate(5,sdHiredate); //目标java.sql.Date
            int cnt = pstmt.executeUpdate();//所有要改变数据表的都要使用executeUpdate
            System.out.println(&quot;cnt:&quot; + cnt); //代表本次写入影响的记录数量
            System.out.println(ename + &quot;员工入职手续已办理&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn); //释放所有资源
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="JDBC批量处理"><a href="#JDBC批量处理" class="headerlink" title="JDBC批量处理"></a>JDBC批量处理</h3><p>需要反复执行同时一次性要插入很多数据的操作使用批处理操作</p>
<pre><code class="sql">BatchSample.java
package test;

import common.DbUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Date;

public class BatchSample &#123;
    private static void tc1()&#123;
        //标准未使用批处理
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            long startTime = new Date().getTime();
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 100000; i &lt; 200000; i++) &#123;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
                pstmt.executeUpdate();
            &#125;
            conn.commit(); //提交数据
            long endTime = new Date().getTime();
            System.out.println(&quot;tc1()执行时长: &quot; + (endTime-startTime));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;

    private static void tc2()&#123;
        //使用批处理插入若干数据
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123; //JDBC默认使用自动提交模式
            long startTime = new Date().getTime();
            conn = DbUtils.getConnection();
            conn.setAutoCommit(false); //关闭自动提交
            String sql = &quot;insert ignore into employee(eno,ename,salary,dname) values(?,?,?,?)&quot;;
            for (int i = 200000; i &lt; 300000; i++) &#123;
                pstmt = conn.prepareStatement(sql);
                pstmt.setInt(1,i);
                pstmt.setString(2,&quot;员工&quot; + i);
                pstmt.setFloat(3,4000f);
                pstmt.setString(4,&quot;市场部&quot;);
//                pstmt.executeUpdate();
                pstmt.addBatch();//将参数加入批处理任务
            &#125;
            pstmt.executeBatch();//执行批处理任务
            conn.commit(); //提交数据
            long endTime = new Date().getTime();
            System.out.println(&quot;tc2()执行时长: &quot; + (endTime-startTime));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed()) &#123;
                    conn.rollback(); //回滚数据
                &#125;
            &#125; catch (SQLException ex) &#123;
                throw new RuntimeException(ex);
            &#125;
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        tc1(); //222279ms
        tc2(); //15827 ms
    &#125;
&#125;
</code></pre>
<h3 id="综合数据库的增删改查"><a href="#综合数据库的增删改查" class="headerlink" title="综合数据库的增删改查"></a>综合数据库的增删改查</h3><pre><code class="sql">HumanResourceApplication.java
package test;

import common.*;

import java.util.Scanner;

public class HumanResourceApplication &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;1-查询部门员工&quot;);
        System.out.println(&quot;2-办理员工入职&quot;);
        System.out.println(&quot;3-调整薪资&quot;);
        System.out.println(&quot;4-员工离职&quot;);
        System.out.println(&quot;5-分页查询员工数据&quot;);
        System.out.println(&quot;请选择功能:&quot;);
        Scanner in = new Scanner(System.in);
        Integer cmd = in.nextInt();
        Command command = null;
        switch (cmd)&#123;
            case 1://查询部门员工
                command = new PstmtQueryCommand();
                command.execute();
                break;
            case 2:
                command = new InsertCommand();
                command.execute();
                break;
            case 3:
                command = new UpdateCommand();
                command.execute();
                break;
            case 4:
                command = new DeleteCommand();
                command.execute();
                break;
            case 5:
                command = new PaginationCommand();
                command.execute();
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="插入员工"><a href="#插入员工" class="headerlink" title="插入员工"></a>插入员工</h6><pre><code class="sql">InsertCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

/*
   新增员工数据
 */
public class InsertCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号:&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工姓名:&quot;);
        String ename = in.next();
        System.out.println(&quot;请输入员工薪资:&quot;);
        float salary = in.nextFloat();
        System.out.println(&quot;请输入隶属部门:&quot;);
        String dname = in.next();
        System.out.println(&quot;请输入入职日期:&quot;);
        String strHiredate = in.next();
        //String到java.sql.Date分为两步
        //1.前端传入的String字符串转为java.util.Date
        java.util.Date udHiredate = null;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            udHiredate = sdf.parse(strHiredate);//对原有字符串解析
        &#125; catch (ParseException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //2.java.util.Date转为java.sql.Date
        long time = udHiredate.getTime();//获取从1970到现在的毫秒数
        java.sql.Date sdHiredate = new java.sql.Date(time); //sdHiredate成功表达了strHiredate所表达的时间
        Connection conn = null;
        PreparedStatement pstmt = null;
        //新增数据 获取数据库连接
        try &#123;
            conn = DbUtils.getConnection(); //↓作为写操作的sql一定要是参数化的(pstmt)
            String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) value(?,?,?,?,?)&quot;;
            pstmt = conn.prepareStatement(sql); //sql被解析
            pstmt.setInt(1,eno);
            pstmt.setString(2,ename);
            pstmt.setFloat(3,salary);
            pstmt.setString(4,dname);
            pstmt.setDate(5,sdHiredate); //目标java.sql.Date
            int cnt = pstmt.executeUpdate();//所有要改变数据表的都要使用executeUpdate
            System.out.println(&quot;cnt:&quot; + cnt); //代表本次写入影响的记录数量
            System.out.println(ename + &quot;员工入职手续已办理&quot;);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            DbUtils.closeConnection(null,pstmt,conn); //释放所有资源
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="更新员工数据"><a href="#更新员工数据" class="headerlink" title="更新员工数据"></a>更新员工数据</h6><pre><code class="sql">UpdateCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class UpdateCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号&quot;);
        int eno = in.nextInt();
        System.out.println(&quot;请输入员工新的薪资&quot;);
        float salary = in.nextFloat();
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123;
            conn = DbUtils.getConnection();
            String sql = &quot;update employee set salary=? where dname=?&quot;;
             pstmt = conn.prepareStatement(sql);
             pstmt.setFloat(1,salary);
             pstmt.setInt(2,eno);
             int cnt = pstmt.executeUpdate();
             if (cnt == 1)&#123;
                 System.out.println(&quot;员工薪资调整完毕&quot;);
             &#125;else &#123;
                 System.out.println(&quot;未找到&quot; + eno + &quot;编号员工数据&quot;);
             &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="删除员工数据"><a href="#删除员工数据" class="headerlink" title="删除员工数据"></a>删除员工数据</h6><pre><code class="sql">DeleteCommand.java
package common;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Scanner;

public class DeleteCommand implements Command&#123;
    @Override
    public void execute()&#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入员工编号&quot;);
        int eno = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        try &#123;
            conn = DbUtils.getConnection();
            String sql = &quot;delete from employee where eno = ?&quot;;
             pstmt = conn.prepareStatement(sql);
             pstmt.setFloat(1,eno);
             int cnt = pstmt.executeUpdate();
             if (cnt == 1)&#123;
                 System.out.println(&quot;员工离职手续已完成&quot;);
             &#125;else &#123;
                 System.out.println(&quot;未找到&quot; + eno + &quot;编号员工数据&quot;);
             &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(null,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="查找员工数据"><a href="#查找员工数据" class="headerlink" title="查找员工数据"></a>查找员工数据</h6><pre><code class="sql">PstmtQueryCommand.java
package common;

import java.sql.*;
import java.util.Scanner;

/**
 * PreparedStatement对象使用方法
 */
public class PstmtQueryCommand implements Command &#123;

    public void execute() &#123;
        System.out.print(&quot;请输入部门名称：&quot;);
        Scanner in = new Scanner(System.in);
        String pdname = in.nextLine();
        Connection conn = null;
//        Statement stmt = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            //1. 加载并注册JDBC驱动
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            //2. 创建数据库连接
            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
            //3. 创建PreparedStatement对象
            String sql = &quot;select * from employee where dname=? and eno &gt; ?&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1,pdname); //注意:参数索引从1
            pstmt.setInt(2,3500);
            //结果集
            rs = pstmt.executeQuery();
            //4. 遍历查询结果
            //rs.next()返回布尔值，代表是否存在下一条记录
            //如果有，返回true,同时结果集提取下一条记录
            //如果没有，返回false，循环就会停止
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(dname + &quot;-&quot; + eno + &quot;-&quot; + ename + &quot;-&quot; + salary);

            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            //5. 关闭连接,释放资源
            try &#123;
                if(rs != null)&#123;
                    rs.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(pstmt != null)&#123;
                    pstmt.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;

            try &#123;
                if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                    conn.close();
                &#125;
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="分页查询员工数据"><a href="#分页查询员工数据" class="headerlink" title="分页查询员工数据"></a>分页查询员工数据</h6><pre><code class="sql">PaginationCommand.java
package common;

import common.entity.Employee;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 分页查询员工数据
 */
public class PaginationCommand implements Command&#123;
    @Override
    public void execute() &#123;
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;请输入页号:&quot;);
        int page = in.nextInt();
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        List&lt;Employee&gt; list = new ArrayList(); //将底下的信息封装到实体类中
        try &#123;
            conn = DbUtils.getConnection(); //?前面第几行 10从这行开始向后取10条记录 limit是分页独有的方言
            String sql = &quot;select * from employee limit ?,10&quot;;
            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1,(page-1)*10); //第二页(2-1)*10从第十条记录开始向后取10条
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(&quot;eno&quot;); //不能在原有字段1前再新增1 按照名字来获取
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                //JDBC获取日期使用java.sql.Date,其继承自java.util.Date
                //所以两者互相兼容
                Date hiredate = rs.getDate(&quot;hiredate&quot;);
                Employee emp = new Employee(); //每产生一条记录都要封装成Employee对象
                emp.setEno(eno);
                emp.setEname(ename);
                emp.setSalary(salary);
                emp.setDname(dname);
                emp.setHiredate(hiredate);//把每一条记录都封装成为了实体类 放入list
                list.add(emp);
            &#125;
            System.out.println(list.size());
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="DbUtils【通用】"><a href="#DbUtils【通用】" class="headerlink" title="DbUtils【通用】"></a>DbUtils【通用】</h6><pre><code class="sql">DbUtils.java
package common;

import kotlin.Result;

import java.sql.*;

public class DbUtils &#123;
    /**
     * 创建新的数据库连接
     * @return 新的Connection对象
     * @throws ClassNotFoundException
     * @throws SQLException
     */
    public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;
        //1. 加载并注册JDBC驱动
        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        //2. 创建数据库连接
        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    &#125;

    /**
     * 关闭连接，释放资源
     * @param rs 结果集对象
     * @param stmt Statement对象
     * @param conn Connection对象
     */
    public static void closeConnection(ResultSet rs, Statement stmt, Connection conn)&#123;
        try &#123;
            if(rs != null)&#123;
                rs.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(stmt != null)&#123;
                stmt.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;

        try &#123;
            if(conn != null &amp;&amp; !conn.isClosed() ) &#123;
                conn.close();
            &#125;
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="Employee（entity）"><a href="#Employee（entity）" class="headerlink" title="Employee（entity）"></a>Employee（entity）</h6><pre><code class="sql">package common.entity;

import java.util.Date;

/**
 * 员工实体类
 */
public class Employee &#123;
    /**
     * 1. 具备默认构造函数
     * 2. 属性私有
     * 3. 存在getter与setter
     */
    public Employee()&#123;

    &#125;
    //通常和数据库数据一一对应
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    public Integer getEno() &#123;
        return eno;
    &#125;

    public void setEno(Integer eno) &#123;
        this.eno = eno;
    &#125;

    public String getEname() &#123;
        return ename;
    &#125;

    public void setEname(String ename) &#123;
        this.ename = ename;
    &#125;

    public Float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(Float salary) &#123;
        this.salary = salary;
    &#125;

    public String getDname() &#123;
        return dname;
    &#125;

    public void setDname(String dname) &#123;
        this.dname = dname;
    &#125;

    public Date getHiredate() &#123;
        return hiredate;
    &#125;

    public void setHiredate(Date hiredate) &#123;
        this.hiredate = hiredate;
    &#125;
&#125;
</code></pre>
<h3 id="阿里巴巴Druid连接池-类似于施工仓库-在启动应用时创建连接池"><a href="#阿里巴巴Druid连接池-类似于施工仓库-在启动应用时创建连接池" class="headerlink" title="阿里巴巴Druid连接池[类似于施工仓库 在启动应用时创建连接池]"></a>阿里巴巴Druid连接池[类似于施工仓库 在启动应用时创建连接池]</h3><p>JDBC先去创建与数据库的连接 比较浪费资源和时间</p>
<ul>
<li>Druid是阿里巴巴开源连接池组件，是最好的连接池之一</li>
<li>Druid对数据库连接进行有效管理与重用，最大化程序执行效率</li>
<li>连接池负责创建管理连接，程序只负责取用和归还</li>
</ul>
<p>&#x2F;druid-config.properties要放到resources文件夹内</p>
<pre><code class="sql">druid-config.properties

driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true
username=root
password=root
initialSize=10 #初始数量
maxActive=20 #数据库最大连接数量
#最好初始数量=最大数量 一开始j
</code></pre>
<pre><code class="sql">DruidSample.java
package test;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import common.DbUtils;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.net.URLDecoder;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.Properties;

public class DruidSample &#123;
    public static void main(String[] args) &#123;
        //1.加载属性文件
        Properties properties = new Properties();
        String propertyFile = DruidSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        //空格-&gt;%20 会被转换
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile,&quot;UTF-8&quot;); //%20还原回去
            properties.load(new FileInputStream(propertyFile));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            //2.获取DataSource数据源对象
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
            //3.创建数据库连接
            conn = dataSource.getConnection();
            pstmt = conn.prepareStatement(&quot;select * from employee limit 0,100&quot;);
            rs = pstmt.executeQuery();
            while (rs.next()) &#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(eno + &quot;-&quot; + ename + &quot;-&quot; + salary + &quot;-&quot; + dname);
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="扩展知识：C3P0连接池"><a href="#扩展知识：C3P0连接池" class="headerlink" title="扩展知识：C3P0连接池"></a>扩展知识：C3P0连接池</h3><p>不用属性文件，改用<strong>c3p0-config.xml</strong>保存文件</p>
<blockquote>
<p>在里面&amp;无法转义 要写成  ‘ <u>&amp; amp;</u> ‘</p>
</blockquote>
<h6 id="idea-C3P0时出现java-sql-SQLException-No-suitable-driver的几种解决办法"><a href="#idea-C3P0时出现java-sql-SQLException-No-suitable-driver的几种解决办法" class="headerlink" title="idea C3P0时出现java.sql.SQLException: No suitable driver的几种解决办法"></a>idea C3P0时出现java.sql.SQLException: No suitable driver的几种解决办法</h6><blockquote>
<p>1、对lib包Add as library<br>2、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=c3p0&spm=1001.2101.3001.7020">c3p0</a>-config.xml<strong>必须放在source目录下</strong>，在此目录会被自动读取<br>3、c3p0命名必须是c3p0-config.xml（至少<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=xml%E6%A0%BC%E5%BC%8F&spm=1001.2101.3001.7020">xml格式</a>是这样）<br>4、c3p0-config.xml文件配置错误、书写错误</p>
</blockquote>
<pre><code class="sql">c3p0-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;c3p0-config&gt;
    &lt;default-config&gt;
        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&lt;/property&gt;
        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;
        &lt;!-- 连接池初始连接数量 --&gt;
        &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;
        &lt;!--最大连接数量--&gt;
        &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt;
    &lt;/default-config&gt;
&lt;/c3p0-config&gt;
</code></pre>
<pre><code class="sql">C3P0Sample.java
package test;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import common.DbUtils;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class C3P0Sample &#123;
    public static void main(String[] args) &#123;
        //1.加载配置文件
        //2.创建DataSource
        DataSource dataSource = new ComboPooledDataSource();
        //3.得到数据库连接
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try &#123;
            conn = dataSource.getConnection();
            pstmt = conn.prepareStatement(&quot;select * from employee limit 0,10&quot;);
            rs = pstmt.executeQuery();
            while(rs.next())&#123;
                Integer eno = rs.getInt(1);//JDBC中字段索引从1开始，而非0
                String ename = rs.getString(&quot;ename&quot;);
                Float salary = rs.getFloat(&quot;salary&quot;);
                String dname = rs.getString(&quot;dname&quot;);
                System.out.println(eno + &quot;-&quot; + ename + &quot;-&quot; + salary + &quot;-&quot; + dname);
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            DbUtils.closeConnection(rs,pstmt,conn); //将数据库连接回收到连接池中而不是真正关闭
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Apache-Commos-DBUtils"><a href="#Apache-Commos-DBUtils" class="headerlink" title="Apache Commos DBUtils"></a>Apache Commos DBUtils</h3><ul>
<li>commons-dbutils是Apache提供的开源JDBC工具类库</li>
<li>它是对JDBC的简单封装，学习成本极低</li>
<li>使用commons-dbutils可以极大简化JDBC编码工作量</li>
</ul>
<pre><code class="sql">DbUtilsSample.java 【对数据的查询与更新】
package test;

import com.alibaba.druid.pool.DruidDataSourceFactory;
import common.DbUtils;
import common.entity.Employee;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanListHandler;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

/**
 * Apache DBUtils + Druid 联合使用演示
 */
public class DbUtilsSample &#123;
    private static void query()&#123;
        Properties properties = new Properties();
        String propertyFile = DbUtilsSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile, &quot;UTF-8&quot;);
            properties.load(new FileInputStream(propertyFile));
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
            //利用Apache DbUtils大幅简化了数据的提取过程
            QueryRunner qr = new QueryRunner(dataSource); //查询执行者  ↓连接自动关闭 不用手动写代码
            List&lt;Employee&gt; list = qr.query(&quot;select * from employee limit ?,10&quot;,
                    new BeanListHandler&lt;&gt;(Employee.class),
                    new Object[]&#123;10&#125;);//没有结果集只能new 结果自动转换成List实体类 后面的是问号赋值
            for (Employee emp : list)&#123;
                System.out.println(emp.getEname());
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    private static void update()&#123;
        Properties properties = new Properties();
        String propertyFile = DbUtilsSample.class.getResource(&quot;/druid-config.properties&quot;).getPath();
        Connection conn = null;
        try &#123;
            propertyFile = new URLDecoder().decode(propertyFile,&quot;UTF-8&quot;);
            properties.load(new FileInputStream(propertyFile)); //文件加载
            DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//利用工厂类对properties信息进行载入创建对应的datasource对象
            conn = dataSource.getConnection();//获取数据库连接
            conn.setAutoCommit(false);
            String sql1 = &quot;update employee set salary=salary+1000 where eno=?&quot;;
            String sql2 = &quot;update employee set salary=salary-599 where eno=?&quot;;
            QueryRunner qr = new QueryRunner();
            qr.update(conn, sql1, new Object[]&#123;1000&#125;);//写入表操作都用update
            qr.update(conn, sql2, new Object[]&#123;1001&#125;);//分别完成加工资和减工资的操作
            conn.commit();//如果都执行成功 就提交 否则回滚
        &#125; catch (Exception e) &#123;
           e.printStackTrace();
            try &#123;
                if (conn!=null &amp;&amp; !conn.isClosed())&#123;
                    conn.rollback();
                &#125;
            &#125; catch (SQLException e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;finally &#123;
            try &#123;
                if (conn!=null &amp;&amp; !conn.isClosed())&#123;
                    conn.close(); //对数据库进行回收
                &#125;
            &#125; catch (SQLException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
//        query();
        update();
    &#125;

&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/23/后端/java数据库开发(JDBC)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/17/语法/思诚科技项目实训/">
        <h2>
            思诚科技项目实训
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/17
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="html基础知识"><a href="#html基础知识" class="headerlink" title="html基础知识"></a>html基础知识</h2><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><h6 id="拖拽法"><a href="#拖拽法" class="headerlink" title="拖拽法"></a>拖拽法</h6><h6 id="菜单打开"><a href="#菜单打开" class="headerlink" title="菜单打开"></a>菜单打开</h6><p>拓展插件：Chinese、Open in browser</p>
<h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p>代码格式化</p>
<ul>
<li><p>Tab 往右缩进</p>
</li>
<li><p>Shift + Tab 向左回退</p>
</li>
<li><p>一个Tab等于两个空格</p>
</li>
<li><p>设置一个Tab等于2个空格</p>
</li>
<li><p>设置键盘快捷方式 大写与小写 ctrl+shift+u&#x2F;l</p>
</li>
<li><p>shift + alt + ↓ 快速复制上一行</p>
</li>
<li><p>ctrl + f 搜索</p>
</li>
<li><p>ctrl + h 替换</p>
</li>
<li><p>ctrl + z 撤销</p>
</li>
<li><p>多光标修改 选中修改的 ctrl+d 加上上下移动</p>
</li>
</ul>
<h3 id="快速写代码-按-ctrl-i-自动导入快捷代码"><a href="#快速写代码-按-ctrl-i-自动导入快捷代码" class="headerlink" title="快速写代码 [按 ctrl+i 自动导入快捷代码]"></a>快速写代码 [<u>按 ctrl+i 自动导入快捷代码</u>]</h3><ul>
<li><p>div + Tab 快速输入div块</p>
</li>
<li><p>div.red + Tab    <u>&lt; div class&#x3D;”red”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>div#box.red + Tab    <u>&lt; div id&#x3D;”box” class&#x3D;”red”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>div[name&#x3D;box] [title&#x3D;气泡]   + Tab   <u>&lt; div name&#x3D;”box” title&#x3D;”气泡”&gt; &lt; &#x2F;div&gt;</u></p>
</li>
<li><p>a#link.red[href&#x3D;#] [ title&#x3D;我是连接] + Tab   <u>&lt; a href&#x3D;”#” id&#x3D;”link” class&#x3D;”red” title&#x3D;”我是连接”&gt;&lt; &#x2F;a&gt;</u></p>
</li>
<li><p>div{文本} + Tab   <u>&lt; div&gt;aaaa&lt; &#x2F;div&gt;</u></p>
</li>
<li><p>输入ul&gt;li{项目} + Tab </p>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;牛逼&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>ul#box&gt;li.red[title&#x3D;’”标题”]{项目1}</p>
<pre><code class="html">&lt;ul id=&quot;box&quot;&gt;
  &lt;li class=&quot;red&quot; title=&quot;标题&quot;&gt;项目1&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>ui&gt;li*5  一个ul标签和五个li标签   <strong>大于号是子类</strong>[父子关系]</p>
</li>
<li><p>p*3{段落$}  </p>
<pre><code class="html">&lt;p&gt;段落1&lt;/p&gt;
&lt;p&gt;段落2&lt;/p&gt;
&lt;p&gt;段落3&lt;/p&gt;
</code></pre>
</li>
<li><p>ul#nav&gt;li.item*5{项目列表$} + Tab</p>
<pre><code class="html">&lt;ul id=&quot;nav&quot;&gt;
    &lt;li class=&quot;item&quot; 列表1=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表2=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表3=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表4=&quot;&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;item&quot; 列表5=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
<li><p>div[name&#x3D;”box”]&gt;p.red&gt;span*3{文本$} + Tab</p>
<pre><code class="html">&lt;div name=&quot;box&quot;&gt;
    &lt;p class=&quot;red&quot;&gt;
        &lt;span&gt;文本1&lt;/span&gt;
        &lt;span&gt;文本2&lt;/span&gt;
        &lt;span&gt;文本3&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;
&lt;!--#是id    .是class    [name=&quot;box&quot;]--&gt;
</code></pre>
</li>
<li><p>h${标题$}*6</p>
<pre><code class="html">&lt;h1&gt;标题1&lt;/h1&gt;
&lt;h2&gt;标题2&lt;/h2&gt;
&lt;h3&gt;标题3&lt;/h3&gt;
&lt;h4&gt;标题4&lt;/h4&gt;
&lt;h5&gt;标题5&lt;/h5&gt;
&lt;h6&gt;标题6&lt;/h6&gt;
</code></pre>
</li>
<li><p>h${标题$}*6  <u><strong>按ctrl+i</strong> 自动导入快捷代码</u></p>
</li>
<li><p>(h2{标题}+p{段落})*3  [<u>同类关系</u>]</p>
<pre><code class="html">&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
&lt;h2&gt;标题&lt;/h2&gt;
&lt;p&gt;段落&lt;/p&gt;
</code></pre>
</li>
<li><pre><code class="html">div#faq&gt;h2&#123;常见问题&#125;dl.list&gt;(dt&#123;问题$&#125;+dd&#123;答案$&#125;)*4
div#faq&gt;(h2&#123;常见问题&#125;+dl.list&gt;(dt&#123;问题$&#125;+dd&#123;答案$&#125;)*4)

&lt;div id=&quot;faq&quot;&gt;
    &lt;h2&gt;常见问题&lt;/h2&gt;
    &lt;dl class=&quot;list&quot;&gt;
        &lt;dt&gt;问题1&lt;/dt&gt;
        &lt;dd&gt;答案1&lt;/dd&gt;
        &lt;dt&gt;问题2&lt;/dt&gt;
        &lt;dd&gt;答案2&lt;/dd&gt;
        &lt;dt&gt;问题3&lt;/dt&gt;
        &lt;dd&gt;答案3&lt;/dd&gt;
        &lt;dt&gt;问题4&lt;/dt&gt;
        &lt;dd&gt;答案4&lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>输入 ul&gt;li{列表$$}*10 + Tab 确保位数</p>
<pre><code class="html">&lt;ul&gt;
    &lt;li&gt;列表01&lt;/li&gt;
    &lt;li&gt;列表02&lt;/li&gt;
    &lt;li&gt;列表03&lt;/li&gt;
    &lt;li&gt;列表04&lt;/li&gt;
    &lt;li&gt;列表05&lt;/li&gt;
    &lt;li&gt;列表06&lt;/li&gt;
    &lt;li&gt;列表07&lt;/li&gt;
    &lt;li&gt;列表08&lt;/li&gt;
    &lt;li&gt;列表09&lt;/li&gt;
    &lt;li&gt;列表10&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
</li>
</ul>
<h3 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h3><p>在VsCode预览<code>ctrl + shift + v</code> </p>
<p>中划线：  ’ <strong>~~ 1111 ~~</strong> ‘<br>分割线：’<strong>— + 回车</strong>‘<br>超链接：’<strong>[网易] (<a target="_blank" rel="noopener" href="http://www.163.com/">http://www.163.com</a>)</strong>‘<br>图片:  ‘<strong>! [图片名称] (图片URL)</strong>‘</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        
    </div>

    <a href="/2023/10/17/语法/思诚科技项目实训/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/08/后端/数据库/">
        <h2>
            数据库
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="数据库基础内容"><a href="#数据库基础内容" class="headerlink" title="数据库基础内容"></a>数据库基础内容</h1><h3 id="数据库系统-DBMS"><a href="#数据库系统-DBMS" class="headerlink" title="数据库系统(DBMS)"></a>数据库系统(DBMS)</h3><ul>
<li>关系型数据库系统(RDBMS)是指使用了关系模型的数据库</li>
<li>关系模型中，数据是分类存放的，数据之间可以有联系</li>
<li>淘宝网背后是3000多个数据库并发的<strong>集群</strong></li>
<li>DB2电信金融领域   Oracle数据库集群  <strong><span style = "color:red">MySQL开源灵活</span></strong>  SQL Server教育领域免费</li>
<li><strong>NoSQL数据库</strong>[Redis]指的是数据分类存放，但是数据之间没有关联关系的数据库系统<br>主流NoSQL数据库 &#x3D;&gt; <strong>Redis(内存 双十一秒杀)</strong>   MemCache   <strong>MongoDB(新闻)</strong>   Neo4J<br>NoSQL数据库只是关系型数据库的补充</li>
</ul>
<h3 id="MySQL衍生版"><a href="#MySQL衍生版" class="headerlink" title="MySQL衍生版"></a>MySQL衍生版</h3><p><strong>Oracle</strong>  Percona(Linux系统)  MariaDB</p>
<h3 id="重设root密码-D-x2F-temp-txt"><a href="#重设root密码-D-x2F-temp-txt" class="headerlink" title="重设root密码 (D:&#x2F;temp.txt)"></a>重设root密码 (D:&#x2F;temp.txt)</h3><ul>
<li><p>创建一个Txt文件，定义修改密码的SQL语句</p>
<pre><code class="sql">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 
</code></pre>
</li>
<li><p>Windows PowerSheell(管理员) 窗口打开<br>停止服务</p>
<pre><code class="sql">net stop mysql180

mysqld --defaults-file=&quot;D:\MySQL\MySQL Server 8.0\my.ini&quot; --init-file==&quot;D:/temp.txt&quot; --console
ctrl+C取消
</code></pre>
<p>启动服务</p>
<pre><code class="sql">net start mysql180
</code></pre>
</li>
</ul>
<h3 id="MySQL配置文件"><a href="#MySQL配置文件" class="headerlink" title="MySQL配置文件"></a>MySQL配置文件</h3><ul>
<li><p>在<strong>my.ini</strong>文件中，我们可以设置各种MySQL的配置，例如字符集、端口号、目录地址等等</p>
<p>my.init{客户端配置信息：[client]…    [mysql]…      <strong>数据库配置信息</strong>：[mysqld]…}</p>
</li>
</ul>
<pre><code class="sql">[client]

# pipe=

# socket=MYSQL 端口号

port=3306

# 错误时主板没有轰鸣声
[mysql]
no-beep

# server_type=3
[mysqld]
#端口号
port=3306


# basedir=&quot;D:/MySQL/MySQL Server 8.0/&quot;
# Path to the database root
datadir=D:/MySQL/MySQL Server 8.0\Data

# with an account. 密码认证插件
authentication_policy=mysql_native_password

#默认存储引擎
default-storage-engine=INNODB

# database servers. 开启严格模式
sql-mode=&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&quot;

# General and Slow logging. 用文件记录日志
log-output=FILE
# 关闭日志输出
general-log=0
# 日志文件名称
general_log_file=&quot;PLUMINARY.log&quot;
# 开启慢查询日志
slow-query-log=1
#慢查询日志文件名称
slow_query_log_file=&quot;PLUMINARY-slow.log&quot;
#大于多少秒的执行SQL被记录在慢查询日志
long_query_time=10

# Error Logging.错误日志名称
log-error=&quot;PLUMINARY.err&quot;

# from every other ID in use by any other source or replica. 集群会用到数据库ID
server-id=1

# 把表名转换成小写
lower_case_table_names=1

# 导入导出数据的目录地址
secure-file-priv=&quot;D:/MySQL/MySQL Server 8.0/Uploads&quot;

#最大连接数
max_connections=151
</code></pre>
<h3 id="定义逻辑库、数据表"><a href="#定义逻辑库、数据表" class="headerlink" title="定义逻辑库、数据表"></a>定义逻辑库、数据表</h3><ul>
<li>SQL是用于访问和处理数据的标准的计算机语言</li>
</ul>
<h5 id="SQL语句的注释"><a href="#SQL语句的注释" class="headerlink" title="SQL语句的注释"></a>SQL语句的注释</h5><pre><code class="sql"># 这是一段注释文字
/* 这是另一段注释文字 */
</code></pre>
<h3 id="创建逻辑库"><a href="#创建逻辑库" class="headerlink" title="创建逻辑库"></a>创建逻辑库</h3><pre><code class="sql">CREATE DATABASE 逻辑库名称; #创建
SHOW DATABASES; #展现逻辑库
DROP DATABASE 逻辑库名称; #删除
</code></pre>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre><code class="sql">CREATE TABLE 数据表(
  列名1 数据类型[约束] [COMMENT 注释],
  列名2 数据类型[约束] [COMMENT 注释],
  ......
)[COMMENT = 注释];


CREATA TABLE student(
  id INT UNSIGNED PRIMARY KEY, #主键约束 不可重复
  name VARCHAR(20) NOT NULL, #varchar 字符串 最大不超过20个字符 NOT NULL必填,不允许没有数据
  sex CHAR(1) NOT NULL, #char 字符
  birthday DATE NOT NULL, 
  tel CHAR(11) NOT NULL,
  remark VARCHAR(200)  #备注不超过200字符串
);

INSERT INTO student VALUES(1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);

SHOW tables; #展现数据表名称
DESC student; #数据表结构具体情况
SHOW CREATE TABLE student; #查询当时的sql语句
DROP TABLE student; #删除数据表
</code></pre>
<h3 id="数据定义语言：数据类型"><a href="#数据定义语言：数据类型" class="headerlink" title="数据定义语言：数据类型"></a>数据定义语言：数据类型</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">1字节</td>
<td align="center">小整数</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">2字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center">MEDIUMIINT</td>
<td align="center">3字节</td>
<td align="center">普通整数</td>
</tr>
<tr>
<td align="center"><strong>INT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>较大整数</strong></td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">8字节</td>
<td align="center">大整数</td>
</tr>
<tr>
<td align="center"><strong>FLOAT</strong></td>
<td align="center"><strong>4字节</strong></td>
<td align="center"><strong>单精度浮点数</strong></td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">8字节</td>
<td align="center">双精度浮点数</td>
</tr>
<tr>
<td align="center">DECIMAL[精确钱]</td>
<td align="center">——–</td>
<td align="center">DECIMAL(10,2)</td>
</tr>
</tbody></table>
<ul>
<li>十进制的浮点数无法在计算机中用二进制精确表达 比如0.2</li>
</ul>
<pre><code class="sql">   num FLOAT(20,10) #位数20 小数点后精确10位  在num中输入0.2的时候 变成了0.200000000030
=&gt; num DECIMAL(20,10)
</code></pre>
<h3 id="数据类型：字符串"><a href="#数据类型：字符串" class="headerlink" title="数据类型：字符串"></a>数据类型：字符串</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CHAR</strong></td>
<td align="center">1-255字符</td>
<td align="center">固定长度字符串</td>
</tr>
<tr>
<td align="center"><strong>VARCHAR</strong></td>
<td align="center">1-65535字符</td>
<td align="center">不固定长度字符串</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">1-65535字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">MEDIUMETEXT</td>
<td align="center">1-1千6百万字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">1-42亿字符</td>
<td align="center"><strong>不确定</strong>长度字符串[后不加括号]</td>
</tr>
</tbody></table>
<h4 id="数据类型：日期类型-年月日中间横线分割-要加引号"><a href="#数据类型：日期类型-年月日中间横线分割-要加引号" class="headerlink" title="数据类型：日期类型(年月日中间横线分割 要加引号)"></a>数据类型：日期类型(年月日中间横线分割 要加引号)</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="center">3字节</td>
<td align="center">日期</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">3字节</td>
<td align="center">时间</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="center">1字节</td>
<td align="center">年份</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">8字节</td>
<td align="center">日期时间[电影开始时间]</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">4字节</td>
<td align="center">时间戳</td>
</tr>
</tbody></table>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><pre><code class="sql">ALTER TABLE 表名称
ADD 列1 数据类型 [约束] [COMMENT 注释],
ADD 列2 数据类型 [约束] [COMMENT 注释],
......;

ADD address VARCHAR(200) NOT NULL;
</code></pre>
<h5 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h5><pre><code class="sql">ALTER TABLE 表名称
CHANGE 列1 新列名1 数据类型 [约束] [COMMENT 注释],
CHANGE 列2 新列名2 数据类型 [约束] [COMMENT 注释],
......;

修改字段
ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL;
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名
</code></pre>
<h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><pre><code class="sql">ALTER TABLE 表名称
DROP 列1，
DROP 列2，
......;
</code></pre>
<h3 id="数据库的范式"><a href="#数据库的范式" class="headerlink" title="数据库的范式"></a>数据库的范式</h3><h4 id="第一范式：原子性"><a href="#第一范式：原子性" class="headerlink" title="第一范式：原子性"></a>第一范式：原子性</h4><ul>
<li>第一范式是数据库的基本要求，不满足组这一点就不是关系数据库</li>
<li>数据库的每一列都是<strong>不可分割</strong>的基本数据项，同一列中不能有多个值，也不能存在重复的属性</li>
</ul>
<h6 id="不符合第一范式"><a href="#不符合第一范式" class="headerlink" title="不符合第一范式"></a>不符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三年级1班</td>
</tr>
</tbody></table>
<h6 id="符合第一范式"><a href="#符合第一范式" class="headerlink" title="符合第一范式"></a>符合第一范式</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">姓名</th>
<th align="center">年纪</th>
<th align="center">班级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">刘娜</td>
<td align="center">高三</td>
<td align="center">1班</td>
</tr>
</tbody></table>
<h4 id="第二范式：唯一性"><a href="#第二范式：唯一性" class="headerlink" title="第二范式：唯一性"></a>第二范式：唯一性</h4><ul>
<li>数据表中的<strong>每条记录必须是唯一的</strong>。为了实现区分，通常要为表加上一列用来存储唯一标识，这个唯一属性列被称为主键列</li>
</ul>
<h6 id="无法区分重复的数据"><a href="#无法区分重复的数据" class="headerlink" title="无法区分重复的数据"></a>无法区分重复的数据</h6><table>
<thead>
<tr>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h6 id="数据具有唯一性"><a href="#数据具有唯一性" class="headerlink" title="数据具有唯一性"></a>数据具有唯一性</h6><table>
<thead>
<tr>
<th align="center">流水号</th>
<th align="center">学号</th>
<th align="center">考试成绩</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">201807152687</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
<tr>
<td align="center">201807152694</td>
<td align="center">230</td>
<td align="center">58</td>
<td align="center">2018-07-15</td>
</tr>
</tbody></table>
<h4 id="第三范式：关联性"><a href="#第三范式：关联性" class="headerlink" title="第三范式：关联性"></a>第三范式：关联性</h4><ul>
<li>每列都与主键有直接关系，<strong>不存在传递依赖</strong></li>
</ul>
<h6 id="违反第三范式"><a href="#违反第三范式" class="headerlink" title="违反第三范式"></a>违反第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<p>拿爸爸作为主键 儿子和女儿字段都是依赖于爸爸字段 但是后面的字段<strong>违反了第三范式</strong> <u>女儿的玩具和女儿的衣服是依赖于女儿这个字段的并不依赖于爸爸这个字段</u><br>数据表关系都非常松散 在检索的时候非常慢 因为爸爸主键字段查询非常快 但是查女儿的玩具和女儿的衣服找不到一样的主键</p>
<h6 id="遵守第三范式"><a href="#遵守第三范式" class="headerlink" title="遵守第三范式"></a>遵守第三范式</h6><table>
<thead>
<tr>
<th align="center">爸爸</th>
<th align="center">儿子</th>
<th align="center">女儿</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈华</td>
<td align="center">陈浩</td>
<td align="center">陈婷婷</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">女儿</th>
<th align="center">女儿的玩具</th>
<th align="center">女儿的衣服</th>
</tr>
</thead>
<tbody><tr>
<td align="center">陈婷婷</td>
<td align="center">海绵宝宝</td>
<td align="center">校服</td>
</tr>
</tbody></table>
<ul>
<li>依照第三范式，数据可以拆分保存到不同的数据表，彼此保持关联</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<p>部门字段也是依赖于编号的 两张表没有违反第三范式</p>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><ul>
<li>MySQL中的字段约束共有四种：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">约束名称</th>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键约束</td>
<td align="center">PRIMARY KEY</td>
<td align="center">字段值唯一，且不能为NULL</td>
</tr>
<tr>
<td align="center">非空约束</td>
<td align="center">NOT NULL</td>
<td align="center">字段值不能为NULL</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">UNIQUE</td>
<td align="center">字段值唯一，且可以为NULL</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">FOREIGN KEY</td>
<td align="center">保持关联数据的逻辑性</td>
</tr>
</tbody></table>
<h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul>
<li>主键约束要求字段的值在全表必须唯一，而且不能为NULL值</li>
<li>建议主键一定要使用数字类型，因为数字的检索速度会非常快</li>
<li>如果主键是数字类型，还可也设置自动增长</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
    ......
);
</code></pre>
<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><ul>
<li>非空约束要求字段的值不能为NULL值</li>
<li>NULL值以为没有值，而不是 “” 空字符串</li>
</ul>
<pre><code class="sql">CREATE TABLE t_teacher(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    married BOOLEAN NOT NULL DEFAULT FALSE #若不写则是默认值false
);
</code></pre>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ul>
<li>唯一约束要求字段值如果不为NULL，那么在全表必须唯一</li>
</ul>
<pre><code class="sql">CREATE TABLE t_tracher(
    ......
    tel CHAR(11) NOT NULL UNIQUE
);
</code></pre>
<pre><code class="sql">t_  tb_  一般是真实的表  
v_ vw_   一般是视图虚拟表的意思
</code></pre>
<h6 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h6><pre><code class="sql">CREATE TABLE t_teacher(
    id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(200) NOT NULL,
    tel CHAR(11) NOT NULL UNIQUE, #唯一约束 UNIQUE 字段值唯一，且可以为NULL
    married BOOLEAN NOT NULL DEFAULT FALSE
);
-------------------------------------------------------------------------
CREATE TABLE student(
    id INT UNSIGNED PRIMARY KEY,
    name VARCHAR(20) NOT NULL,
    sex CHAR(1) NOT NULL,
    birthday DATE NOT NULL,
    tel CHAR(11) NOT NULL,
    remark VARCHAR(200)
);
INSERT INTO student VALUES (1,&quot;李强&quot;,&quot;男&quot;,&quot;1995-05-15&quot;,&quot;13312345678&quot;,NULL);
DESC student; 
SHOW CREATE TABLE student;

ALTER TABLE student
ADD address VARCHAR(200) NOT NULL, #添加字段信息
ADD home_tel CHAR(11) NOT NULL;

ALTER TABLE student
MODIFY home_tel VARCHAR(20) NOT NULL; #改字段类型信息

ALTER TABLE student
CHANGE address home_address VARCHAR(200) NOT NULL; #改变字段名

ALTER TABLE student
DROP address; #删除字段
</code></pre>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul>
<li>外键约束用来保证关联数据的逻辑关系</li>
<li>外键约束的定义是写在子表上的</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">部门</th>
<th align="center">电话</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">财务部</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">技术部</td>
<td align="center">1002</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">销售部</td>
<td align="center">1003</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">姓名</th>
<th align="center">性别</th>
<th align="center">部门</th>
<th align="center">入职日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">陈浩</td>
<td align="center">男</td>
<td align="center"><strong>10</strong></td>
<td align="center">2018-05-10</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">李婷婷</td>
<td align="center">女</td>
<td align="center"><strong>30</strong></td>
<td align="center">2018-03-22</td>
</tr>
</tbody></table>
<pre><code class="sql">CREATE TABLE t_dept(
    deptno INT UNSIGNED PRIMARY KEY,
    dname VARCHAR(20) NOT NULL UNIQUE,
    tel CHAR(4) UNIQUE #写了电话必须唯一
);
</code></pre>
<pre><code class="sql">CREATE TABLE t_emp(
    empno INT UNSIGNED PRIMARY KEY,
    ename VARCHAR(20) NOT NULL,
    sex EUNM(&quot;男&quot;,&quot;女&quot;) NOT NULL, #枚举 选择其中一个
    deptno INT UNSIGNED,
    hiredate DATE NOT NULL,
    FOREIGN KEY (deptno) REFERENCES t_dept(deptno) #和父表进行外键约束关联
);
</code></pre>
<p>不允许删除第一个编号 需要先删除第二个表的记录 再删除第一个表记录 逻辑关系有保证</p>
<h3 id="外键约束的闭环问题-【因此开发中放弃外键约束】"><a href="#外键约束的闭环问题-【因此开发中放弃外键约束】" class="headerlink" title="外键约束的闭环问题 【因此开发中放弃外键约束】"></a>外键约束的闭环问题 【因此开发中放弃外键约束】</h3><ul>
<li>如果形成外键闭环，我们将无法删除任何一张表的记录</li>
</ul>
<h3 id="数据排序的好处"><a href="#数据排序的好处" class="headerlink" title="数据排序的好处"></a>数据排序的好处</h3><ul>
<li>一旦数据排序后，查找的速度就会翻倍，现实世界跟程序世界都是如此</li>
</ul>
<h3 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h3><pre><code class="sql">CREATE TABLE 表名称(
    ......,
    INDEX [索引名称] (字段),
    ......
);

#数据库对这个索引字段排序生成二叉树 每个字段都是有索引名称的
CREATE TABLE t_message(
    id INT UNSIGNED PRIMARY KEY,
    content VARCHAR(200) NOT NULL,
    type ENUM(&quot;公告&quot;,&quot;通报&quot;,&quot;个人通知&quot;) NOT NULL,
    create_time TIMESTAMP NOT NULL,
    INDEX idx_type (type)
); #利用二叉树的二分查找去查找索引字段就会非常快
</code></pre>
<h3 id="如何添加与删除索引"><a href="#如何添加与删除索引" class="headerlink" title="如何添加与删除索引"></a>如何添加与删除索引</h3><pre><code class="sql">CREATE INDEX 索引名称 ON 表名(字段); #添加索引
ALTER TABLE 表名称 ADD INDEX [索引名](字段); #添加索引
SHOW INDEX FORM 表名; #展示索引表  PRIMARY KEY AUTO_INCREMENT, #自带索引功能 自带排序
DROP INDEX 索引名称 ON 表名; #删除索引
</code></pre>
<h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><ul>
<li>数据量很大，而且经常被查询的数据表可以设置索引 (日志表很少查询 无需设置 因为数据库要维护二叉树)</li>
<li>索引只添加在<strong>经常被用作检索</strong>条件的字段上面</li>
<li>不要在<strong>大字段</strong>上创建索引</li>
</ul>
<p>(<u>以上均为DDL语句</u>)</p>
<h6 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h6><h3 id="数据操作语句：普通查询"><a href="#数据操作语句：普通查询" class="headerlink" title="数据操作语句：普通查询"></a>数据操作语句：普通查询</h3><h5 id="记录查询"><a href="#记录查询" class="headerlink" title="记录查询"></a>记录查询</h5><ul>
<li>最基本的查询语句是由<strong>SELECT</strong> 和 <strong>FROM</strong>关键字组成</li>
</ul>
<pre><code class="sql">USE demo;
SELECT * FROM t_emp; #FROM是从员工表查数据 *是在结果集里显示员工表所有字段
SELECT empno,ename,sal FROM t_emp; #不查询所有 单独查询想要的
</code></pre>
<ul>
<li>SELECT语句屏蔽了物理层的操作，用户不必关心数据的真实存储，交给数据库高效查找数据</li>
<li>通常情况下 ，SELECT子句中使用了表达式，那么这列的名字就默认为表达式，因此需要一种对列明重命名的机制 [<strong>起别名</strong>：只是对查询的结果集字段改名称]</li>
</ul>
<pre><code class="sql">SELECT
  empno,
  sal*12 AS &quot;income&quot;
FROM t_emp;
</code></pre>
<ul>
<li>上述sql 查询语句的子句执行顺序</li>
</ul>
<p>① <strong>词法分析与优化</strong>：读取SQL语句<br>② <strong>FROM</strong>：选择数据来源<br>③ <strong>SELECT</strong>：选择输出内容</p>
<h3 id="数据操作语言：数据分页"><a href="#数据操作语言：数据分页" class="headerlink" title="数据操作语言：数据分页"></a>数据操作语言：数据分页</h3><ul>
<li>朋友圈只会加载少量部分信息，不用一次性加载全部朋友圈，那样只会浪费CPU时间、内存和网络带宽</li>
<li>如果结果集的记录很多，则可以使用LIMIT关键字限定结果集数量</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... LIMIT 起始位置,偏移量; 
SELECT empno,ename FROM t_emp LIMIT 0,20; #从0往后取20条数据
</code></pre>
<h6 id="数据分页简写"><a href="#数据分页简写" class="headerlink" title="数据分页简写"></a>数据分页简写</h6><ul>
<li>如果LIMIT子句只有一个参数，它表示的是偏移量，起始值默认为0</li>
</ul>
<pre><code class="sql">SELECT empno,ename FROM t_emp LIMIT 10;
SELECT empno,ename FROM t_emp LIMIT 0,10;
FROM → SELECT → LIMIT
</code></pre>
<h3 id="结果集排序"><a href="#结果集排序" class="headerlink" title="结果集排序"></a>结果集排序</h3><ul>
<li>如果没有设置，查询语句不会对结果集进行排序。也就是说，如果想让结果集按照某种顺序排序，就必须使用ORDER BY子句 【<strong>默认升序</strong>】</li>
</ul>
<pre><code class="sql">SELECT ... FROM ... ORDER BY 列名 [ASC|DESC];
SELECT ename,sal FROM t_emp ORDER BY sal;
</code></pre>
<h3 id="排序关键字"><a href="#排序关键字" class="headerlink" title="排序关键字"></a>排序关键字</h3><ul>
<li>ASC代表升序(默认)，DESC代表降序</li>
<li>如果排序列是数字类型，数据库就按照数字大小排序，如果是日期类型就按照日期大小排序，如果是字符串就暗战字符集序号排序。</li>
</ul>
<pre><code class="sql">SELECT ename,sal FROM t_emp ORDER BY hiredate DESC;
</code></pre>
<h6 id="排序字段内容相同的情况"><a href="#排序字段内容相同的情况" class="headerlink" title="排序字段内容相同的情况"></a>排序字段内容相同的情况</h6><ul>
<li>如果两条数据排序字段内容相同 <strong>sal 都是3000</strong><br>默认情况下是按照主键升序</li>
</ul>
<h6 id="多个排序字段"><a href="#多个排序字段" class="headerlink" title="多个排序字段"></a>多个排序字段</h6><ul>
<li>使用ORDER BY规定首要排序顺序条件和次要排序条件。数据库会先按照要排序条件排序，如果遇到首要排序内容相同的记录，那么就会启动次要排序条件接着排序</li>
</ul>
<pre><code class="sql">SELECT ename,sal,hiredate 
FROM t_emp 
ORDER BY hiredate DESC,sal ASC;
#先按照首要排序hiredate降序 再启动次要排序sal降序

SELECT ename,sal,hiredate
FROM t_emp
ORDER BY sal DESC 
LIMIT 0,5  #工资排在前五位进行降序
</code></pre>
<h6 id="排序-分页"><a href="#排序-分页" class="headerlink" title="排序+分页"></a>排序+分页</h6><ul>
<li>ODER BY 子句书写的时候放在LIMIT子句的前面<br><strong>FROM → SELECT → ORDER BY → LIMIT</strong></li>
</ul>
<h3 id="结果集中的重复数据"><a href="#结果集中的重复数据" class="headerlink" title="结果集中的重复数据"></a>结果集中的重复数据</h3><ul>
<li><p>假如我们要查询员工表有多种职业，写出来的sql语句</p>
<pre><code class="sql">SELECT job FROM t_emp; #结果集内可能会出现重复记录
</code></pre>
</li>
<li><p>如果去除重复的数据，可以使用 <strong>DISTINCT</strong> 关键字来实现</p>
<pre><code class="sql">SELECT DISTINCT 字段 FROM ...;
SELECT DISTINCT job FROM t_emp;
</code></pre>
</li>
</ul>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li><p>使用<strong>DISTINCT</strong>的<strong>SELECT</strong>子句中只能查询一列数据，如果查询多列，去除重复记录就会失效</p>
<pre><code class="sql">SELECT DISTINCT job,ename FROM t_emp; #有job相同但是ename不相同 不能查询
</code></pre>
</li>
<li><p><strong>DISTINCT</strong>关键字只能再SELECT子句中使用一次 [必须放在第一个字段前面]</p>
</li>
</ul>
<h3 id="数据操作语言：条件查询-一"><a href="#数据操作语言：条件查询-一" class="headerlink" title="数据操作语言：条件查询(一)"></a>数据操作语言：条件查询(一)</h3><ul>
<li><p>满足某一种或几种条件的记录。这类条件要用<strong>WHERE</strong>子句来实现数据的筛选</p>
<pre><code class="sql">SELECT ... FROM ... WHERE 条件 [AND|OR] 条件 ...;

SELECT empno,ename,sal FROM t_emp
WHERE deptno=10 AND sal&gt;=2000;

SELECT empno,ename,sal
FROM t_emp
WHERE(deptno=10 OR deptno=20) AND sal&gt;=2000;
</code></pre>
</li>
</ul>
<h6 id="四类运算符"><a href="#四类运算符" class="headerlink" title="四类运算符"></a>四类运算符</h6><ul>
<li><p>WHERE语句中的条件运算会用到以下四种运算符</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">数学运算符</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">比较运算符</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">逻辑运算符</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">按位运算符</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="算数运算符-加-减-乘-x2F-除-模"><a href="#算数运算符-加-减-乘-x2F-除-模" class="headerlink" title="算数运算符 [+加  -减  *乘  &#x2F;除  %模]"></a>算数运算符 [+加  -减  *乘  &#x2F;除  %模]</h6><p>NULL值与任何数字加减乘除都是NULL值 如果想要运算 必须加入 <strong>IFNULL</strong>(null,0); 意思是遇到NULL值就用0来计算 10+IFNULL(null,0) &#x3D; 10<br><strong>DATEDIFF</strong>(入职日期-现在的日期)&#x2F;365</p>
<pre><code class="sql">从t_emp表中找出 号位是10 和 总工资≥15000 的并且 计算工龄超过20年的人
SELECT empno,ename,sal,hiredate
FROM t_emp
WHERE deptno=10 AND (sal+IFNULL(NULL,0))*12&gt;=15000
AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
<h6 id="比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40"><a href="#比较运算符-gt-大于-gt-x3D-大于等于-lt-小于-lt-x3D-小于等于-x3D-等于-x3D-不等于-IN包含deptno-IN-10-30-40" class="headerlink" title="比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]"></a>比较运算符 [&gt;大于 &gt;&#x3D;大于等于 &lt;小于 &lt;&#x3D;小于等于 &#x3D;等于 !&#x3D;不等于 IN包含deptno IN(10,30,40)]</h6><pre><code class="sql">查询10 20 30部门里面在1980年以前入职的员工而且不能是SALESMAN职位
SELECT
  empno,ename,sal,deptno,hiredate
FROM t_emp;
WHERE deptno IN(10,20,30) AND job!=&quot;SALESMAN&quot;
AND hiredate&lt;&quot;1985-01-01&quot;;
</code></pre>
<h6 id="续比较运算符"><a href="#续比较运算符" class="headerlink" title="+续比较运算符"></a>+续比较运算符</h6><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">表达式</th>
<th align="center">意义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">IS NULL</td>
<td align="center">为空</td>
<td align="center">comm IS NULL</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">IS NOT NULL</td>
<td align="center">不为空</td>
<td align="center">comm IS NOT NULL</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">BETWEEN AND</td>
<td align="center">范围</td>
<td align="center">sal BETWEEN 2000 AND 3000</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">LIKE</td>
<td align="center">模糊查询</td>
<td align="center">ename LIKE “A%”</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><span style = "color : red"><strong>REGEXP</strong></span></td>
<td align="center"><span style = "color : red"><strong>正则表达式</strong></span></td>
<td align="center"><strong>ename REGEXP “[a-zA-Z]{4}”</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>__代表前方一个未知    %代表前方N个未知</p>
</blockquote>
<pre><code class="sql">SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename LIKE &quot;_LAKE&quot;;

SELECT 
ename,comm,sal
FROM t_emp WHERE comm IS NULL
AND sal BETWEEN 2000 AND 3000;
AND ename REGEXP &quot;^[\\u4e00-\\u9fa5]&#123;2,4&#125;$&quot;; #正则表达汉字范围寻找两到四个中文字符
</code></pre>
<h6 id="按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移"><a href="#按位运算符-amp-位与-位或-位取反-位异或-lt-lt-左移-gt-gt-右移" class="headerlink" title="按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]"></a>按位运算符 [&amp;位与  |位或  ~位取反  ^位异或  &lt;&lt;左移  &gt;&gt;右移]</h6><p>&lt;&lt; 左移  10&lt;&lt;1 把10转换成二进制位 在最右面补上一个0 整体向左移动了一个单位<br>》》左移  10&lt;&lt;1 把10转换成二进制位 在最右面抹去一个0 整体向右移动了一个单位</p>
<h3 id="二进制按位运算"><a href="#二进制按位运算" class="headerlink" title="二进制按位运算"></a>二进制按位运算</h3><ul>
<li>二进制运算的实质是将参与运算的两个操作数，按对应的二进制数逐位进行逻辑运算<br>SELECT 3 &amp; 7;    0011 &amp; 0111 &#x3D; 0011 &#x3D; 3</li>
</ul>
<h3 id="数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或"><a href="#数据操作语言：条件查询-二-AND与-OR或-NOT非-XOR异或" class="headerlink" title="数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]"></a>数据操作语言：条件查询(二) [AND与 OR或 NOT非 XOR异或]</h3><pre><code class="sql">查询10和20之外部门的信息
SELECT
  ename,deptno,sal
FROM t_emp
WHERE NOT deptno IN(10,20) XOR sal&gt;=2000;
</code></pre>
<h3 id="WHERE子句的注意事项"><a href="#WHERE子句的注意事项" class="headerlink" title="WHERE子句的注意事项"></a>WHERE子句的注意事项</h3><ul>
<li>WHERE子句中，条件执行的顺序是从左到右的。所以我们应该把<strong>索引条件，或者筛选掉记录最多的条件</strong>写在最左侧<pre><code class="sql">SELECT empno,ename FROM t_emp
WHERE ename = &quot;FORD&quot; AND sal &gt;= 2000;

SELECT empno,ename FROM t_emp
WHERE deptno = 10 AND sal &gt;= 2000;
</code></pre>
</li>
</ul>
<h3 id="各种子句的执行排序"><a href="#各种子句的执行排序" class="headerlink" title="各种子句的执行排序"></a>各种子句的执行排序</h3><h5 id="FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → SELECT → ORDER BY → LIMIT"></a>FROM → WHERE → SELECT → ORDER BY → LIMIT</h5><p>先表 再查出符合条件的记录 才能从中挑选出符合的字段 先排序后限制</p>
<hr>
<h1 id="数据库高级内容"><a href="#数据库高级内容" class="headerlink" title="数据库高级内容"></a>数据库高级内容</h1><h3 id="数据操作语言：聚合函数"><a href="#数据操作语言：聚合函数" class="headerlink" title="数据操作语言：聚合函数"></a>数据操作语言：聚合函数</h3><ul>
<li><p>聚合函数在数据的查询分析中，应用十分广泛。聚合函数可以对<strong>数据求和</strong>、求<strong>最大值</strong>和<strong>最小值</strong>、求<strong>平均值</strong>等等</p>
</li>
<li><p>求公司员工的平均月收入是多少？</p>
<pre><code class="sql">底薪+佣金(不是null)
SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="SUM函数"><a href="#SUM函数" class="headerlink" title="SUM函数"></a>SUM函数</h5><ul>
<li><p>SUM函数用于求和，只能用于数字类型，字符类型的统计结果为0，日期类型统计结果是毫秒数相加</p>
<pre><code class="sql">SELECT SUM(ename) FROM t_emp

SELECT SUM(sal) FROM t_emp
WHERE deptno IN (10,20);
</code></pre>
</li>
</ul>
<h5 id="MAX函数"><a href="#MAX函数" class="headerlink" title="MAX函数"></a>MAX函数</h5><ul>
<li><p>MAX函数用于获得非空值的最大值</p>
<pre><code class="sql">SELECT MAX(comm) FORM t_emp;

①查询10和20部门中,月收入最高的员工？
SELECT 
MAX(sal+IFNULL(comm,0)) FROM t_temp
FROM t_emp
WHERE deptno IN (10,20);

②查询员工名字最长的是几个字符？
SELECT MAX(LENGTH(ename)) FROM t_emp;

SELECT
SUM(sal),MAX(sal+IFNULL(comm,0)) 
FROM t_emp
WHERE deptno IN(10,20); 
</code></pre>
</li>
</ul>
<h5 id="MIN函数"><a href="#MIN函数" class="headerlink" title="MIN函数"></a>MIN函数</h5><ul>
<li><p>MIN函数用于获得非空值的最小值</p>
<pre><code class="sql">SELECT MIN(empno) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a>AVG函数</h5><ul>
<li><p>AVG函数用于获得非空值的平均值，非数字数据统计结果为0</p>
<pre><code class="sql">SELECT AVG(sal+IFNULL(comm,0)) FROM t_emp;
</code></pre>
</li>
</ul>
<h5 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h5><ul>
<li><p>COUNT(*) [<u>找所有</u>]用于获得包含空值的记录数，COUNT(列名)用于获得包含非空值的记录数</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp; #统计所有   15 
SELECT COUNT(comm) FROM t_emp; #统计数量是非空   5
</code></pre>
</li>
<li><p>查询10和20部门中，底薪超过2000元并且工龄超过15年的员工人数</p>
<pre><code class="sql">SELECT COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20) 
AND sal&gt;=2000
AND DATEDIFF(NOW(),hiredate)/365&gt;=15;
</code></pre>
</li>
<li><p>查询1985年以后入职的员工，底薪超过公司平均底薪的员工数量？</p>
<pre><code class="sql">×××××××××错误示范×××××××××
SELECT COUNT(*) FROM t_emp
WHERE hiredate&gt;=&quot;1985-01-01&quot;
AND sal&gt;AVG(sal); #AVG无法运行 聚合函数不能出现在WHERE里面
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：分组查询"><a href="#数据操作语言：分组查询" class="headerlink" title="数据操作语言：分组查询"></a>数据操作语言：分组查询</h3><h6 id="为什么要分组？"><a href="#为什么要分组？" class="headerlink" title="为什么要分组？"></a>为什么要分组？</h6><ul>
<li>默认情况下汇总函数是对全表范围内的数据做统计</li>
<li>GROUP BY子句的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对每个小区域分别进行数据汇总处理</li>
</ul>
<pre><code class="sql">SELECT deptno,ROUND(AVG(sal))
FROM t_emp
GROUP BY deptno; #分组来计算AVG
</code></pre>
<h3 id="逐级分组"><a href="#逐级分组" class="headerlink" title="逐级分组"></a>逐级分组</h3><ul>
<li>数据库支持多列分组条件，执行的时候逐级分组</li>
<li>查询每个部门里，每种职位的人员数量和平均底薪</li>
</ul>
<pre><code class="sql">#按照部门和工作分组 ↓这种职位人数 ↓这种职位底薪平均值
SELECT deptno,job,COUNT(*),AVG(sal)
FROM t_emp 
GROUP BY deptno,job
ORDER BY deptno; #按照deptno去排序
</code></pre>
<h3 id="对SELECT子句的要求"><a href="#对SELECT子句的要求" class="headerlink" title="对SELECT子句的要求"></a>对SELECT子句的要求</h3><ul>
<li>查询语句中如果含有<strong>GROUP BY</strong>子句，那么SELECT子句中的内容就必须要遵守规定：SELECT子句中可以包括聚合函数，或者GROUP BY子句的分组列，其余内容均不可以出现在<strong>SELECT</strong>子句中</li>
</ul>
<pre><code class="sql">#正确示范
SELECT deptno,COUNT(*),AVG(sal)
FROM t_emp GROUP BY deptno;

#错误示范
SELECT deptno,COUNT(*),AVG(sal),sal
FROM t_emp GROUP BY deptno;
</code></pre>
<h3 id="对分组结果集再次做汇总计算"><a href="#对分组结果集再次做汇总计算" class="headerlink" title="对分组结果集再次做汇总计算"></a>对分组结果集再次做汇总计算</h3><pre><code class="sql">SELECT 
deptno,COUNT(*),AVG(sal),MAX(sal),MIN(sal)
FROM t_emp 
GROUP BY deptno WITH ROLLUP; #WITH ROLLUP对汇总函数再次进行汇总运算
</code></pre>
<h3 id="GROUP-CONCAT函数"><a href="#GROUP-CONCAT函数" class="headerlink" title="GROUP_CONCAT函数"></a>GROUP_CONCAT函数</h3><ul>
<li><p><strong>GROUP_CONCAT</strong>函数可以把分组查询中的<strong>某个字段拼接成一个字符串</strong></p>
</li>
<li><p>查询每个部门内底薪超过2000元的人数和员工姓名</p>
<pre><code class="sql">SELECT deptno,GROUP_CONCAT(ename),COUNT(*)
FROM t_emp 
WHERE sal&gt;=2000
GROUP BY deptno;
</code></pre>
<table>
<thead>
<tr>
<th align="center">deptno</th>
<th align="center">COUNT(*)</th>
<th align="center">GROUP_CONCAT(ename)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">CLARK,KING</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">3</td>
<td align="center">JONES,SCOTT,FORD</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">1</td>
<td align="center">BLAKE</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="各种子句的执行顺序"><a href="#各种子句的执行顺序" class="headerlink" title="各种子句的执行顺序"></a>各种子句的执行顺序</h3><h5 id="FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT"><a href="#FROM-→-WHERE-→-GROUP-BY-→-SELECT-→-ORDER-BY-→-LIMIT" class="headerlink" title="FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT"></a>FROM → WHERE → GROUP BY → SELECT → ORDER BY  → LIMIT</h5><p><strong>WHERE</strong>符合的留下来交给<strong>GROUP BY</strong>去分组之后调用<strong>SELECT</strong>中的聚合函数计算 <strong>ORDER BY</strong>子句对结果排序交给<strong>LIMIT</strong>子句来挑选返回哪些数据</p>
<h3 id="分组查询遇到的困难？"><a href="#分组查询遇到的困难？" class="headerlink" title="分组查询遇到的困难？"></a>分组查询遇到的困难？</h3><ul>
<li><p>查询部门平均底薪超过2000元的部门编号</p>
<pre><code class="sql">#错误演示[因为WHERE语句出现了聚合函数]
SELECT deptno FROM t_emp
WHERE AVG(sal)&gt;=2000
GROUP BY deptno;
</code></pre>
</li>
<li><p><strong>HAVING</strong>语句是紧紧跟着<strong>GROUP BY</strong>语句的 <u>HAVING子句可以写聚合函数作为判断条件</u></p>
<pre><code class="sql">SELECT deptno
FROM t_emp
GROUP BY deptno HAVING AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的用途"><a href="#HAVING子句的用途" class="headerlink" title="HAVING子句的用途"></a>HAVING子句的用途</h3><ul>
<li><p>查询每个部门中，<u>1982年以后入职的员工$<em>{普通条件可以写在WHERE里}$</u><u>超过2个人</u>$</em>{COUNT(*)&gt;&#x3D;2}$的部门编号<br>不能拿<strong>聚合函数</strong>和<strong>某一个字段</strong>做判断</p>
<pre><code class="sql">SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2;
ORDER BY deptno ASC;

SELECT deptno 
FROM t_emp
WHERE hiredate&gt;=&quot;1982-01-01&quot;
GROUP BY deptno HAVING COUNT(*)&gt;=2 AND AVG(sal)&gt;=2000;
</code></pre>
</li>
</ul>
<h3 id="HAVING子句的特殊用法-作用类似于WHERE"><a href="#HAVING子句的特殊用法-作用类似于WHERE" class="headerlink" title="HAVING子句的特殊用法 [作用类似于WHERE]"></a>HAVING子句的特殊用法 [作用类似于WHERE]</h3><ul>
<li><p>按照数字1分组，MySQL会根据SELECT子句中的列进行分组，HAVING子句也可以正常使用<br>能用WHERE就不要先用HAVING 它的作用是給聚合函数做判断</p>
<pre><code class="sql">#不推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
GROUP BY 1 HAVING deptno IN (10,20);

#推荐写法
SELECT deptno,COUNT(*) 
FROM t_emp
WHERE deptno IN(10,20)
GROUP BY 1;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-一"><a href="#数据操作语言：表链接查询-一" class="headerlink" title="数据操作语言：表链接查询(一)"></a>数据操作语言：表链接查询(一)</h3><h5 id="从多张表中提取数据"><a href="#从多张表中提取数据" class="headerlink" title="从多张表中提取数据"></a>从多张表中提取数据</h5><ul>
<li><p>从多张表中提取数据，必须指定关联的条件。如果不定义关联条件就会出现无条件链接，两张表的数据会交叉连接，产生<strong>笛卡尔积</strong></p>
</li>
<li><p>规定了链接条件的表链接语句，就不会出现笛卡尔积 [On条件]</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e JOIN t_dept d #給表起别名
ON e.deptno=d.deptno; #员工部门编号等于部门的部门编号
</code></pre>
</li>
</ul>
<h3 id="表链接的分类"><a href="#表链接的分类" class="headerlink" title="表链接的分类"></a>表链接的分类</h3><ul>
<li>表链接分为两种：<strong>内链接</strong>和<strong>外连接</strong></li>
<li><strong>内链接</strong>是结果集中只保留符合连接条件的记录</li>
<li><strong>外连接</strong>是不管符不符合链接条件，记录都要保留在结果集中</li>
</ul>
<h6 id="内链接"><a href="#内链接" class="headerlink" title="内链接"></a>内链接</h6><pre><code class="sql">SELECT ... FROM 表1
[INNER] JOIN 表2 ON 条件
[INNER] JOIN 表3 ON 条件
...
</code></pre>
<h6 id="内连接的多种语法形式"><a href="#内连接的多种语法形式" class="headerlink" title="内连接的多种语法形式"></a>内连接的多种语法形式</h6><pre><code class="sql">SELECT ... FROM 表1 JOIN 表2 ON 连接条件;
SELECT ... FROM 表1 JOIN 表2 WHERE 连接条件
SELECT ... FROM 表1,表2 WHERE 连接条件;
</code></pre>
<h3 id="内连接练习1"><a href="#内连接练习1" class="headerlink" title="内连接练习1"></a>内连接练习1</h3><ul>
<li><strong>查询每个员工的工号、姓名、部门名称、底薪、职位、工资等级</strong>？且保证工资符合范围</li>
</ul>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname,e.sal,e.job,s.grade
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal;
</code></pre>
<ul>
<li>内连接的数据表不一定必须有同名字段，只要字段之间符合逻辑关系就可以</li>
</ul>
<h3 id="内连接练习2"><a href="#内连接练习2" class="headerlink" title="内连接练习2"></a>内连接练习2</h3><ul>
<li><p>查询与<strong>SCOTT</strong>相同部门的员工都有谁？</p>
</li>
<li><p>相同的数据表也可以做表连接</p>
<pre><code class="sql">SELECT deptno
FROM t_emp
WHERE ename=&quot;SCOTT&quot;; 

#子查询的结果变成了条件  SCOTT本人不算
SELECT deptno
FROM t_emp
WHERE deptno=(SELECT dptno FROM t_emp WHERE ename=&quot;SCOTT&quot;);
AND ename!=&quot;SCOTT&quot;;

#改造快速一些  ON后是筛选条件 和 WHERE作用差不多
SELECT e2.ename
FROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno
WHERE e1.ename=&quot;SCOTT&quot; AND e2.ename!=&quot;SCOTT&quot;; 
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-二"><a href="#数据操作语言：表链接查询-二" class="headerlink" title="数据操作语言：表链接查询(二)"></a>数据操作语言：表链接查询(二)</h3><h5 id="内连接查询练习1"><a href="#内连接查询练习1" class="headerlink" title="内连接查询练习1"></a>内连接查询练习1</h5><ul>
<li>查询底薪超过公司平均底薪的员工信息？<br><span style="color : red"><strong>把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】</strong></span></li>
</ul>
<pre><code class="sql">#错误展示
SELECT e2.empno,e2.ename,e2.sal  #因为ON可以换成WHERE 然而WHERE后面有聚合函数 所以会报错
FORM t_emp e1 JOIN t_emp e2 ON e2.sal&gt;=AVG(e1.sal);

#把聚合函数查询的结果做成一张表 再进行表连接 【分部描述】
SELECT AVG(sal)
FROM t_emp;

SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN(SELECT AVG(sal) avg FROM t_emp) t #avg别名
ON e.sal&gt;=t.avg;
</code></pre>
<ul>
<li>查询RESEARCH部门的人数、最高底薪、最低底薪、平均底薪、平均工龄？</li>
</ul>
<pre><code class="sql">SELECT COUNT(*),MAX(e.sal),MIN(e.sal),AVG(e.sal),AVG(DATEDIFF(NOW(),e.hiredate)/365)
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;RESEARCH&quot;;

SELECT FLOOR(28.9); #变成28 向上取整
SELECT CEIL(1.1);   #变成1  向上取整
</code></pre>
<h5 id="内连接查询练习2"><a href="#内连接查询练习2" class="headerlink" title="内连接查询练习2"></a>内连接查询练习2</h5><ul>
<li><p>查询每种职业的最高工资、最低工资、平均工资、最高工资等级和最低工资等级？</p>
<pre><code class="sql">SELECT 
e.job,MAX(e.sal+IFNULL(e,comm,0)),
MIN(e.sal+IFNULL(e,comm,0)),AVG(e.sal+IFNULL(e,comm,0)),
MAX(s.grade),MIN(s.grade)
FROM t_emp e JOIN t_salgrade s
ON (e.sal+IFNULL(e,comm,0)) BETWEEN s.losal AND s.hisal
GROUP BY e.job;
</code></pre>
</li>
<li><p>查询每个底薪超过部门平均底薪的员工信息 [<strong>用表连接 而不是子查询</strong>]</p>
<pre><code class="sql">SELECT e.empno,e.ename,e.sal
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg FROM t_emp GROUP BY dptno) t #别名t
ON e.deptno=t.deptno AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：表链接查询-三"><a href="#数据操作语言：表链接查询-三" class="headerlink" title="数据操作语言：表链接查询(三)"></a>数据操作语言：表链接查询(三)</h3><h5 id="为什么要使用外连接"><a href="#为什么要使用外连接" class="headerlink" title="为什么要使用外连接"></a>为什么要使用外连接</h5><ul>
<li>如果说陈浩是一名临时人员，没有固定的部门编制(NULL)，那么我们想查询每名员工和他的部门名称，用内连接就会遗漏掉陈浩，所以要引用外连接的语法才能解决这个问题</li>
</ul>
<h5 id="外连接简介"><a href="#外连接简介" class="headerlink" title="外连接简介"></a>外连接简介</h5><ul>
<li><p>外连接与内连接的区别在于，除了符合条件的记录之外，结果集中还会保留不符合条件的记录</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FROM t_emp e  #因为陈浩部门编制是NULL 不能直接JOIN 只能LEFT JOIN
LEFT JOIN t_dept d ON e.deptno=d.deptno; 
</code></pre>
<table>
<thead>
<tr>
<th>7902</th>
<th>FORD</th>
<th>RESEARCH</th>
</tr>
</thead>
<tbody><tr>
<td>7934</td>
<td>MILLER</td>
<td>ACCOUNTING</td>
</tr>
<tr>
<td>8000</td>
<td>陈浩</td>
<td>(<strong>NULL</strong>)</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="左连接和右连接"><a href="#左连接和右连接" class="headerlink" title="左连接和右连接"></a>左连接和右连接</h3><ul>
<li><p>左外连接就是保留左表所有的记录，与右表做连接。如果右表有符合条件的记录就与左表连接。如果右表没有符合条件的记录，就用NULL与左表连接。右外连接也是如此。</p>
<pre><code class="sql">SELECT e.empno,e.ename,d.dname
FORM t_dept d RIGHT JOIN t_emp e #要保留所有的t_emp e
ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="外连接练习1"><a href="#外连接练习1" class="headerlink" title="外连接练习1"></a>外连接练习1</h3><ul>
<li><p>查询每个部门的名称和部门的人数？ [40有部门没员工 要保存空值]<br><u>左外连接把部门表写在左侧    右外连接把部门表写在右侧</u></p>
<pre><code class="sql">SELECT d.dname,COUNT(*)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录 右表有空
ON d.deptno=e.deptno
GROUP BY d.deptno; #因为保留了左表所有记录 所以分组按照部门号分
#最终有一条t_dept与t_emp中的NULL做连接 所以 COUNT算上此记录
#若要将右表的NULL值忽略掉 要在COUNT(d.deptno)这样写

SELECT d.dname,COUNT(d.deptno)
FROM t_dept d LEFT JOIN t_emp e #保留左表的所有记录
ON d.deptno=e.deptno
GROUP BY d.deptno;
</code></pre>
<table>
<thead>
<tr>
<th>dname</th>
<th>COUNT(d.deptno)</th>
</tr>
</thead>
<tbody><tr>
<td>ACCOUNTING</td>
<td>3</td>
</tr>
<tr>
<td>RESEARCH</td>
<td>5</td>
</tr>
<tr>
<td>SALES</td>
<td>6</td>
</tr>
<tr>
<td><strong>OPERATIONS</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody></table>
</li>
<li><p>查询每个部门的名称和部门的人数？如果没有部门的员工，部门名称用NULL代替</p>
</li>
<li><p><strong>UNION关键字</strong>可以将多个查询语句的结果集进行合并</p>
<pre><code class="sql">(查询语句) UNION (查询语句) UNION (查询语句)...
（SELECT d.name,COUNT(e.deptno)
FROM t_dept d LEFT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
）UNION
(SELECT d.dname,COUNT(*)
FROM t_dept d RIGHT JOIN t_emp e
ON d.deptno=e.deptno
GROUP BY d.deptno
);
</code></pre>
</li>
</ul>
<h3 id="数据库操作语言：表连接查询-四"><a href="#数据库操作语言：表连接查询-四" class="headerlink" title="数据库操作语言：表连接查询(四)"></a>数据库操作语言：表连接查询(四)</h3><ul>
<li><p>查询每名员工的编号、姓名、部门、月薪、工资等级、工龄、上司编号、上司姓名、上司部门？<br>[不知道：员工信息 员工的上司信息    两个不知道信息是不能使用子查询的  <u>员工表 部门表 公司等级表</u>]</p>
<pre><code class="sql">#陈浩要保存下来 用外连接
SELECT
e.empno,e.ename,d.dname,
e.sal+IFNULL(e.comm,0),s.grade,
FLOOR(DATEDIFF(NOW(),e.hiredate)/365),
t.empno AS mgrno,t.ename AS mname,t.dname AS mdname #定义上司的数据
FROM t_emp e 
LEFT JOIN t_dept d ON e.deptno=d.deptno #结果集所有记录保存下来跟工资等级表做连接
LEFT JOIN t_salgrade s ON e.sal BETWEEN s.losal AND s.hisal
LEFT JOIN
(SELECT e1.empno,e1.ename,d1.dname
FROM t_emp e1 JOIN t_dept d1
ON e1.deptno=d1.deptno
)t ON e.mgr=t.empno;
</code></pre>
</li>
</ul>
<h3 id="外连接的注意事项"><a href="#外连接的注意事项" class="headerlink" title="外连接的注意事项"></a>外连接的注意事项</h3><ul>
<li><strong>内连接</strong>值保留符合条件的记录，所以查询条件写在ON子句和WHERE子句中的效果是相同的。但是<strong>外连接</strong>里，条件写在WHERE子句里，不符合条件的记录是会被过滤掉的，而不是保留下来的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2af31e5baf5f6fc6e517ef9c13f689a8ab3db3a0/data/%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5WHEWE%E5%92%8CON%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
<h3 id="数据操作语言：子查询-一"><a href="#数据操作语言：子查询-一" class="headerlink" title="数据操作语言：子查询(一)"></a>数据操作语言：子查询(一)</h3><p>WHERE中的子查询是需要反复查询的 不推荐使用，但是把它所得的结果集作为一张表跟其他表做连接是推荐的</p>
<ul>
<li><p>子查询是一种查询中嵌套查询的语句</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="子查询的分类"><a href="#子查询的分类" class="headerlink" title="子查询的分类"></a>子查询的分类</h6><ul>
<li>子查询可以写在三个地方：<strong>WHERE子句、FROM子句、SELECT子句</strong>，但是只有FROM子句子查询是最可取的</li>
</ul>
<h6 id="WHERE子查询"><a href="#WHERE子查询" class="headerlink" title="WHERE子查询"></a>WHERE子查询</h6><ul>
<li><p>这种子查询最简单，最容易理解，但是确实<strong>效率很低</strong>的子查询</p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT empno,ename,sal
FORM t_emp #↓↓↓↓ 比较每条记录都要重写执行子查询 ↓↓↓↓
WHERE sal&gt;=(SELECT AVG(sal) FROM t_emp); #不推荐使用 最好用表连接
</code></pre>
</li>
</ul>
<h6 id="FROM子查询"><a href="#FROM子查询" class="headerlink" title="FROM子查询"></a>FROM子查询</h6><ul>
<li><p>这种子查询只会执行一次，所以<strong>查询效率很高</strong></p>
</li>
<li><p>查询底薪超过公司平均底薪的员工信息</p>
<pre><code class="sql">SELECT
e.empno,e.ename,e.sal,t.avg
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS avg
FORM t_emp 
GROUP BY deptno) t #按照部门编号去分组 起别名
ON e.deptno=t.deptno 
AND e.sal&gt;=t.avg;
</code></pre>
</li>
</ul>
<h6 id="SELECT子查询"><a href="#SELECT子查询" class="headerlink" title="SELECT子查询"></a>SELECT子查询</h6><ul>
<li><p>这种子查询每输出一条记录的时候都要执行一次，<strong>查询效率很低</strong></p>
<pre><code class="sql">SELECT
e.empno,
e.ename,
(SELECT dname FROM t_dept WHERE deptno=e.deptno)
FROM t_emp e;
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：子查询-二"><a href="#数据操作语言：子查询-二" class="headerlink" title="数据操作语言：子查询(二)"></a>数据操作语言：子查询(二)</h3><h5 id="单行子查询和多行子查询-结果集可以作为新表连接"><a href="#单行子查询和多行子查询-结果集可以作为新表连接" class="headerlink" title="单行子查询和多行子查询 [结果集可以作为新表连接]"></a>单行子查询和多行子查询 [结果集可以作为新表连接]</h5><ul>
<li><p>单行子查询的结果集只有一条记录，多行子查询结果集有多行记录</p>
</li>
<li><p>多行子查询只能出现在WHERE子句和FROM子句中</p>
</li>
<li><p>如何用子查询查找FORD和MARTIN两个人的同事</p>
<pre><code class="sql">SELECT ename #排除那俩人之外
FROM t_emp 
WHERE
deptno IN    # deptno = 不行因为后面返回了两条记录
(SELECT deptno FROM t_emp WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;)); #返回两条记录
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;);
</code></pre>
</li>
</ul>
<h3 id="WHERE子句中的多行子查询"><a href="#WHERE子句中的多行子查询" class="headerlink" title="WHERE子句中的多行子查询"></a>WHERE子句中的多行子查询</h3><ul>
<li><p>WHERE子句中，可以使用<strong>IN、ALL、ANY、EXISTS</strong>关键字来处理多行表达式结果集的条件判断</p>
</li>
<li><p>调查”FORD”和”MARTIN”底薪都高的员工信息</p>
<pre><code class="sql">SELECT ename 
FROM t_emp 
WHERE sal &gt; ALL #ALL是sal里的数比结果集里的所有值都大  ANY则是比任何一个人大
(SELECT sal FROM t_emp #结果集里返回了多条记录
WHERE ename IN(&quot;FORD&quot;,&quot;MARTIN&quot;))
AND ename NOT IN(&quot;FORD&quot;,&quot;MARTIN&quot;); #不包含这俩人
</code></pre>
</li>
</ul>
<h3 id="EXISTS关键字"><a href="#EXISTS关键字" class="headerlink" title="EXISTS关键字"></a>EXISTS关键字</h3><ul>
<li><p><strong>EXISTS关键字</strong>是把原来在子查询之外的条件判断，写到了子查询的里面<br>EXISTS用上之后WHERE就不写任何语句了</p>
<pre><code class="sql">SELECT ... FROM 表名 WHERE [NOT] EXISTS(子查询);
</code></pre>
</li>
<li><p>查询工资等级是3级或者4级的员工信息</p>
<pre><code class="sql">#排斥此方法 效率低下
SELECT
FROM t_emp
WHERE EXISTS(
SELECT * FROM t_salgrade
WHERE sal BETWEEN losal AND hisal 
AND grade IN(3,4)
);
</code></pre>
</li>
</ul>
<h1 id="MySQL对数据的基本操作"><a href="#MySQL对数据的基本操作" class="headerlink" title="MySQL对数据的基本操作"></a>MySQL对数据的基本操作</h1><h3 id="数据操作语言：INSERT语句"><a href="#数据操作语言：INSERT语句" class="headerlink" title="数据操作语言：INSERT语句"></a>数据操作语言：INSERT语句</h3><ul>
<li><p><strong>INSERT</strong>语句可以向数据表写入记录，可以是一条记录，也可以是多条记录</p>
<pre><code class="sql">INSERT INTO 表名(字段1,字段2,......) #添加字段可以快速写入 
VALUES(值1,值2,......);

INSERT INTO 表名(字段1,字段2,......) 
VALUES(值1,值2,......),(值1,值2,......); #多条记录

INSERT INTO t_dept(deptno,dname,loc)
VALUES(520,&quot;研发部&quot;,&quot;河北&quot;),(250,&quot;销售部&quot;,&quot;江西&quot;);

#向技术部添加一条员工记录 
#[技术部编号不知道 子查询技术部的编号 结果 写到VALUES子句里面通过INSERT插入员工表里面]
INSERT INTO t_emp
(empno,ename,job,mgr,hiredate,sal,comm,deptno)
VALUES(8001,&quot;潘春尧&quot;,&quot;SALESMAN&quot;,8000,&quot;2023-10-15&quot;,2000,NULL,
(SELECT deptno FROM t_dept WHERE dname=&quot;技术部&quot;)); #子查询单个结果返回
</code></pre>
</li>
</ul>
<h3 id="INSERT语法方言"><a href="#INSERT语法方言" class="headerlink" title="INSERT语法方言"></a>INSERT语法方言</h3><ul>
<li><p>MySQL的INSERT语句有一种方言语法</p>
<pre><code class="sql">INSERT INTO 表名 SET 字段1=值1,字段2=值2,......; #只适合Mysql数据库

(INSERT) INTO t_emp
SET empno=8002,ename=&quot;JACK&quot;,job=&quot;SLAESMAN&quot;,mgr=8000,
hiredate=&quot;1985-01-01&quot;,sal=2500,comm=NULL,deptno=50;

DELETE FROM t_emp WHERE empno=8002;
</code></pre>
</li>
</ul>
<h3 id="IGNORE关键字"><a href="#IGNORE关键字" class="headerlink" title="IGNORE关键字"></a>IGNORE关键字</h3><ul>
<li><p><strong>IGNORE</strong>关键字会让<strong>INSERT</strong>只插入数据库不存在的记录</p>
<pre><code class="sql">INSERT [IGNORE] INTO 表名...;
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;技术部&quot;,&quot;北京&quot;); #40编号是主键被占用了 和已经现存的记录有冲突

#运用方言写
INSERT IGNORE INTO t_dept
SET deptno=40,dname=&quot;技术部&quot;,loc=&quot;北京&quot;;

#多重数据忽略不正确的数据
INSERT IGNORE INTO t_dept(deptno,dname,loc)
VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;);

#VALUES(40,&quot;A&quot;,&quot;北京&quot;),(80,&quot;B&quot;,&quot;上海&quot;)
#&gt; Affected rows: 1
#&gt; 时间: 0.002s
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：UPDATE语句-一"><a href="#数据操作语言：UPDATE语句-一" class="headerlink" title="数据操作语言：UPDATE语句(一)"></a>数据操作语言：UPDATE语句(一)</h3><ul>
<li><p>UPDATE语句用于修改表的记录<br><strong>UPDATE</strong>中的<strong>NIGNORE</strong>直接忽略冲突的语句</p>
<pre><code class="sql">UPDATE [IGNORE] 表名
SET 字段1=值1，字段2=值2,......
[WHERE 条件1...] #有条件的修改记录
[ORDER BY...] #对数据先排序 后修改员工编号＋1 
[LIMIT...]; #取分页数据

#把每个员工的编号和上司的编号+1，用ORDER BY子句完成
UPDATE t_emp 
SET empno=empno+1,mgr=mgr+1
ORDER BY empno DESC;

#把用收入前三名的员工底薪减100元，用LIMIT子句完成
UPDATE t_emp
SET sal=sal-100 
ORDER BY sal+IFNULL(comm,0) DESC #降序 
LIMIT 3; #取前三条记录
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-一"><a href="#UPDATE语句的表连接-一" class="headerlink" title="UPDATE语句的表连接(一)"></a>UPDATE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所以我们可以利用表连接的方式来改造UPDATE语句</p>
<pre><code class="sql">UPDATE 表1 JOIN 表2 ON 条件
SET 字段1=值1,字段2=值2,......;
</code></pre>
</li>
<li><p>表连接的UPDATE语句可以修改多张表的记录[<strong>进化</strong>]</p>
<pre><code class="sql">UPDATE 表1,表2
SET 字段1=值1,字段2=值2,......
WHERE 连接条件;

#把ALLEN调往RESEARCH部门，职务调整为ANALYST
[员工表+部门表]
UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
#//在t_emp表中找到ALLEN + 在t_dept表中找到RESEARCH 
#//然后把d.deptno赋值給e.deptno

UPDATE t_emp e JOIN t_dept d
SET e.deptno=d.deptno,e.job=&quot;ANALYST&quot;,d.loc=&quot;北京&quot;
WHERE e.ename=&quot;ALLEN&quot; AND d.dname=&quot;RESEARCH&quot;
</code></pre>
</li>
<li><p>把底薪低于公司平均底薪的员工，底薪增加150元<br>[运用<strong>表连接</strong>的方法比<strong>WHERE语句</strong>的效率高]</p>
<pre><code class="sql">UPDATE t_emp e JOIN
(SELECT AVG(sal) AS avg FROM t_emp) t
ON e.sal&lt;t.avg
SET e.sal=e.sal+150;
</code></pre>
</li>
</ul>
<h3 id="UPDATE语句的表连接-二"><a href="#UPDATE语句的表连接-二" class="headerlink" title="UPDATE语句的表连接(二)"></a>UPDATE语句的表连接(二)</h3><ul>
<li><p>UPDATE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">UPDATE 表1[LEFT|RIGHT] JOIN 表2 ON 条件 
SET 字段1=值1,字段2=值2,...;
</code></pre>
</li>
<li><p>把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门<br>[把所有员工保留下来 但是陈浩没有部门 用内连接的话会把陈浩忽略掉 要用<strong>左外连接</strong>把左表所有数据保留下来再去跟部门表作连接]</p>
<pre><code class="sql">#把没有部门的员工，或者SALES部门低于2000元底薪的员工，都调往20部门
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno #连接条件 不符合的也保留
SET e.deptno=202
WHERE e.deptno IS NULL OR (d.dname=&quot;SALES&quot; AND e.sal&lt;2000);
</code></pre>
</li>
</ul>
<h3 id="数据操作语言：-DELETE语句-一"><a href="#数据操作语言：-DELETE语句-一" class="headerlink" title="数据操作语言： DELETE语句(一)"></a>数据操作语言： DELETE语句(一)</h3><ul>
<li>DELETE语句用于删除记录<pre><code class="sql">DELETE [IGNORE] FROM 表名
[WHERE 条件1,条件2,...] #按照条件删除记录
[ORDER BY...] #排序后删除
[LIMIT...]; #分页 工资降序排序 排在前五名的删掉
#顺序依次向下 最后一个是DELETE
</code></pre>
</li>
</ul>
<h6 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h6><ul>
<li><p>删除10部门中，工龄超过20年的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=10 AND DATEDIFF(NOW(),hiredate)/365&gt;=20;
</code></pre>
</li>
<li><p>删除20部门中工资最高的员工记录</p>
<pre><code class="sql">DELETE FROM t_emp
WHERE deptno=20
ORDER BY sal+IFNULL(comm,0) DESC
LIMIT 1;
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-一"><a href="#DELETE语句的表连接-一" class="headerlink" title="DELETE语句的表连接(一)"></a>DELETE语句的表连接(一)</h3><ul>
<li><p>因为相关子查询效率非常低，所有我们可以利用表连接的方法来改造<strong>DELETE</strong>语句</p>
<pre><code class="sql">DELETE 表1,...FROM 表1 JOIN 表2 ON 条件 #删除哪张表记录的操作
[WHERE 条件1,条件2,...]
[ORDER BY...]
[LIMIT...];

#删除SALES部门和该部门的全部员工记录
#无需外连接 因为没有部门需要不删除的
DELETE e,d
FROM t_emp e JOIN t_dept d NO e.deptno=d.deptno #部门名称
WHERE d.dname=&quot;SALES&quot;;
</code></pre>
</li>
<li><p>删除<strong>SALES部门</strong>和该部门的全部员工记录[<strong>表连接</strong>]</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT deptno,AVG(sal) AS sal FROM t_emp GOURP BY deptno)
ON e.deptno=t.deptno AND e.sal&lt;t.sal
</code></pre>
</li>
<li><p>删除员工KING和他的直接下属的员工记录，用表连接实现</p>
<pre><code class="sql">DELETE e
FROM t_emp e JOIN
(SELECT empno FROM t_emp WHERE ename=&quot;KING&quot;) t
ON e.mgr=t.empno OR e.empno=t.empno; #KING的下属 OR KING这个人
</code></pre>
</li>
</ul>
<h3 id="DELETE语句的表连接-二"><a href="#DELETE语句的表连接-二" class="headerlink" title="DELETE语句的表连接(二)"></a>DELETE语句的表连接(二)</h3><ul>
<li><p>DELETE语句的表连接既可以是内连接，又可以是外连接</p>
<pre><code class="sql">DELETE 表1,... FROM 表1 [LEFT|RIGHT] JOIN 表2 ON 条件...;
</code></pre>
</li>
<li><p>删除SALES部门的员工，以及没有部门的员工 [左外 因为陈浩没部门要保留 外连接(不可用内连接)]</p>
<pre><code class="sql">DELETE e
FROM t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
WHERE d.dname=&quot;SALES&quot; OR e.deptno IS NULL
</code></pre>
</li>
</ul>
<h3 id="快速删除数据表全部记录"><a href="#快速删除数据表全部记录" class="headerlink" title="快速删除数据表全部记录"></a>快速删除数据表全部记录</h3><ul>
<li><p>DELETE语句实在事务机制下删除记录，删除记录之前，先把将要删除的记录保存到日志文件里面，然后删除记录</p>
</li>
<li><p>TRUNCATE语句再事务机制之外删除记录，速度大于DELETE语句</p>
<pre><code class="sql">TRUNCATE TABLE 表名;
</code></pre>
</li>
</ul>
<h3 id="MySql的内置函数"><a href="#MySql的内置函数" class="headerlink" title="MySql的内置函数"></a>MySql的内置函数</h3><p>数据库函<strong>数分类：数字、字符、日期、条件</strong>函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ABS</td>
<td align="center">绝对值</td>
<td align="center">ABS(-100)</td>
</tr>
<tr>
<td align="center">ROUND</td>
<td align="center">四舍五入</td>
<td align="center">ROUND(4.62)</td>
</tr>
<tr>
<td align="center">FOLLR</td>
<td align="center">强制舍位到最近的整数</td>
<td align="center">FLOOR(9,9) &#x3D; 9</td>
</tr>
<tr>
<td align="center">CEIL</td>
<td align="center">强制仅为最近的整数</td>
<td align="center">CEIL(3.2) &#x3D; 4</td>
</tr>
<tr>
<td align="center">POWER</td>
<td align="center">幂函数</td>
<td align="center">POWER(2,3)</td>
</tr>
<tr>
<td align="center">LOG</td>
<td align="center">对数函数</td>
<td align="center">LOG(7,3)</td>
</tr>
<tr>
<td align="center">LN</td>
<td align="center">对数函数</td>
<td align="center">LN(1,0)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SQRT</td>
<td align="center">开平方</td>
<td align="center">SQRT(9)</td>
</tr>
<tr>
<td align="center">PI</td>
<td align="center">圆周率</td>
<td align="center">P10</td>
</tr>
<tr>
<td align="center">SIN</td>
<td align="center">三角函数</td>
<td align="center">sin(1)</td>
</tr>
<tr>
<td align="center">TAN</td>
<td align="center">三角函数</td>
<td align="center">TAN(1)</td>
</tr>
<tr>
<td align="center">COT</td>
<td align="center">三角函数</td>
<td align="center">COT(1)</td>
</tr>
<tr>
<td align="center">COS</td>
<td align="center">三角函数</td>
<td align="center">COS(2)</td>
</tr>
<tr>
<td align="center">DADIANS</td>
<td align="center">角度来换成角度</td>
<td align="center">DADIANS(20)</td>
</tr>
<tr>
<td align="center">DEGREES</td>
<td align="center">弧度转换角度</td>
<td align="center">DEGRESS(1)</td>
</tr>
</tbody></table>
<h3 id="获取系统的时间函数"><a href="#获取系统的时间函数" class="headerlink" title="获取系统的时间函数"></a>获取系统的时间函数</h3><ul>
<li><strong>NOW</strong>()函数能获得系统日期和时间，yyyy-MMMM-dd hh:mm:ss</li>
<li><strong>CURDATE</strong>()函数能获得当前系统日期，yyyy&#x3D;MM&#x3D;ddd</li>
<li><strong>CURTIME</strong>()函数能获得当前时间系统信息，hh:mm:ss</li>
</ul>
<h3 id="日期格式化函数-一"><a href="#日期格式化函数-一" class="headerlink" title="日期格式化函数(一)"></a>日期格式化函数(一)</h3><ul>
<li><p>**DATE_FORMAT()**函数用于格式化日期，返回用户想要的日期格式</p>
<pre><code class="sql">DATE_FORMAT(r日期,表达式)

SELECT ename,DATE_FORMAT(hiredate,&quot;%Y&quot;) AS &quot;year&quot;
FROM t_emp; 
</code></pre>
</li>
</ul>
<h3 id="日期格式化函数-二"><a href="#日期格式化函数-二" class="headerlink" title="日期格式化函数(二)"></a>日期格式化函数(二)</h3><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">作用</th>
<th align="center">占位符</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%Y</td>
<td align="center">年份</td>
<td align="center">%m</td>
<td align="center">月份</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">日期</td>
<td align="center">%w</td>
<td align="center">星期(数字)</td>
</tr>
<tr>
<td align="center">%W</td>
<td align="center">星期(名称)</td>
<td align="center">%j</td>
<td align="center">本年第几天</td>
</tr>
<tr>
<td align="center">%U</td>
<td align="center">本年第几周</td>
<td align="center">%H</td>
<td align="center">小时(24)</td>
</tr>
<tr>
<td align="center">%h</td>
<td align="center">小时(12)</td>
<td align="center">%i</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">秒</td>
<td align="center">%r</td>
<td align="center">时间(12)</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">时间(24)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><p>利用日期函数，查询明年你的生日是星期几？</p>
<pre><code class="sql">SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%w&quot;); #数字
SELECT DATE_FORMAT(&quot;2019-6-20&quot;,&quot;%W&quot;); #英文星期
</code></pre>
</li>
<li><p>利用日期函数，查询1981年上半年入职的员工多少人？[聚合函数 全表范围不用分组GROUP BY]</p>
<pre><code class="sql">SELECT COUNT(*) FROM t_emp
WHERE DATE_FORMAT(hiredate,&quot;%Y&quot;)=1981
AND DATE_FORMAT(hiredate,&quot;%m&quot;)&lt;=6 #上半年
</code></pre>
</li>
</ul>
<h3 id="日期计算的注意事项"><a href="#日期计算的注意事项" class="headerlink" title="日期计算的注意事项"></a>日期计算的注意事项</h3><ul>
<li>MySQL数据库里面，两个日期不能直接加减，日期也不能与数字加减</li>
</ul>
<h6 id="日期偏移计算"><a href="#日期偏移计算" class="headerlink" title="日期偏移计算"></a>日期偏移计算</h6><ul>
<li><p>DATE_ADD()函数可以实现日期的偏移计算，而且时间单位很灵活</p>
<pre><code class="sql">DATE_ADD(日期,INTERVAL 偏移量 时间单位)

SELECT DATE_ADD(NOW(),INTERVAL 15 DAY); #15天之后
SELECT DATE_ADD(NOW(),INTERVAL -300 MINUTE); #300分钟之前  2023-10-16 04:48:48
SELECT DATE_FORMAT(
DATE_ADD(DATE_ADD(NOW(),INTERVAL -6 MONTH),INTERVAL -3 DAY),&quot;%Y/%m/%d&quot;); #2023/04/13
</code></pre>
</li>
</ul>
<h6 id="计算日期之间相隔的天数"><a href="#计算日期之间相隔的天数" class="headerlink" title="计算日期之间相隔的天数"></a>计算日期之间相隔的天数</h6><ul>
<li><p>**DATEDIFF()**函数用来计算两个日期之间相差的天数</p>
<pre><code class="sql">DATEDIFF(日期,日期)
</code></pre>
</li>
</ul>
<h3 id="字符函数-一"><a href="#字符函数-一" class="headerlink" title="字符函数(一)"></a>字符函数(一)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LOWER</td>
<td align="center">转换小写字符</td>
<td align="center">LOWER(ename)</td>
</tr>
<tr>
<td align="center">UPPER</td>
<td align="center">转换大写字符</td>
<td align="center">UPPER(ename)</td>
</tr>
<tr>
<td align="center">LENGTH</td>
<td align="center">字符数量</td>
<td align="center">LENGTH(ename)</td>
</tr>
<tr>
<td align="center">CONCAT</td>
<td align="center">连接字符串</td>
<td align="center">CONCAT(sal, “$”)</td>
</tr>
<tr>
<td align="center">INSTR</td>
<td align="center">字符出现的位置</td>
<td align="center">INSTR(ename, “A”)</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">插入&#x2F;替换字符</td>
<td align="center">INSERT(“你好”,1,0,”先生”)<br />替换1个字符  0表示不替换—候补</td>
</tr>
<tr>
<td align="center">REPLACE</td>
<td align="center">替换字符</td>
<td align="center">REPLACE(“你好先生”,“先生”,”女士”)<br />先生换成女士</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT
  LOWER(ename),UPPER(ename),LENGTH(ename),CONCAT(sal,&quot;$&quot;),INSTR(ename,&quot;A&quot;)
FROM t_emp;
</code></pre>
<h3 id="字符函数-二"><a href="#字符函数-二" class="headerlink" title="字符函数(二)"></a>字符函数(二)</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
<th align="center">用例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SUBSTR</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTR(“你好世界”,3,4)<br />3开始位置 4结束位置</td>
</tr>
<tr>
<td align="center">SUBSTRING</td>
<td align="center">截取字符串</td>
<td align="center">SUBSTRING(“你好世界”,3,2)<br />3个字符开始往后截取2个位置</td>
</tr>
<tr>
<td align="center">LPAD</td>
<td align="center">左侧填充字符</td>
<td align="center">LPAD(“Hello”,10,”<em>“)<br />潘</em>* 10最终字符串一共为10个字符<br />电话隐私保护加※号</td>
</tr>
<tr>
<td align="center">RPAD</td>
<td align="center">右侧填充字符</td>
<td align="center">RPAD(“Hello”,10,”*”)</td>
</tr>
<tr>
<td align="center">TRIM</td>
<td align="center">去除首位空格</td>
<td align="center">TRIM(“ 你好先生 “)</td>
</tr>
</tbody></table>
<pre><code class="sql">SELECT LPAD(SUBSTRING(&quot;15027597319&quot;,8,4),11,&quot;*&quot;);
SELECT RPAD(SUBSTRING(&quot;潘春尧&quot;,1,1),LENGTH(&quot;潘春尧&quot;)/3,&quot;*&quot;); 
#LENGTH是算英文字符 再除以3就是汉字的字符个数
</code></pre>
<h3 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h3><ul>
<li><p>SQL语句中可以利用条件函数来实现变成语言里的条件判断</p>
<pre><code class="sql">IFNULL(表达式,值)
IF(表达式,值1,值2)
</code></pre>
</li>
<li><p>中秋节公司发放礼品，SALES部门发放礼品A，其余部门发放礼品B，打印每名员工获得的礼品<br>[按部门名称作表连接 部门表和员工表 内连接没有部门的没有礼品]</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,d.dname,
  IF(d.dname=&quot;SALES&quot;,&quot;礼品A&quot;,&quot;礼品B&quot;)
FROM t_emp e JOIN t_tept d ON e,deptno=d.deptno;
</code></pre>
</li>
</ul>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ul>
<li><p>复杂的条件判断可以用条件语句来实现，比IF语句功能更强大</p>
<pre><code class="sql">CASE 
  WHEN 表达式 THEN 值1
  WHEN 表达式 THEN 值2
  ......
  ELSE 值N
END
</code></pre>
</li>
<li><p>公司年庆决定组织员工集体旅游，每个部门旅游目的地是不同的。<strong>SALES</strong>部门去P1地点，<strong>ACCOUNTING</strong>部门去P2地点，<strong>RESEARCH</strong>部门去P3地点，查询每名员工的旅行地点。</p>
<pre><code class="sql">SELECT 
  e.empno,e.ename,
  CASE 
    WHEN d.dname=&quot;SALES&quot; THEN &quot;p1&quot;
    WHEN d.dname=&quot;ACCOUNTING&quot; THEN &quot;p2&quot;
    WHEN d.dname=&quot;RESEARCH&quot; THEN &quot;P3&quot;
FROM t_emp e JOIN t_dept d ON e.deptno=d.deptno;
</code></pre>
</li>
</ul>
<h6 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h6><ul>
<li><p>某公司决定为员工调整基本工资，具体调整方案如下：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">条件</th>
<th align="center">涨幅</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SALES部门中工龄超过20年</td>
<td align="center">10%</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SALES部门中工龄不满20年</td>
<td align="center">5%</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">ACCOUNTING部门</td>
<td align="center">+300元</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">RESEARCH部门里低于部门平均底薪</td>
<td align="center">+200元</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">没有部门的员工</td>
<td align="center">+100元</td>
</tr>
</tbody></table>
<pre><code class="sql">[员工表连接部门表]
UPDATE t_emp e LEFT JOIN t_dept d ON e.deptno=d.deptno
LEFT JOIN (SELECT deptno,AVG(sal) AS avg FROM t_temp GOURP BY deptno) t
ON e.deptno=t.deptno
SET sal=(
    CASE 
      WHEN d,dname=&quot;SALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&gt;=20 
      THEN e.sal*1.1
      WHEN d,dname=&quot;ALES&quot; AND DATEDIFF(NOW(),e.hiredate)/365&lt;20 
      THEN e.sal*1.50
      WHEN d,dname=&quot;ACCOUNTING&quot; THEN e.sal+300
      WHEN d,dname=&quot;RESEARCH&quot; THEN e.sal&lt;t.avg THEN e.sal+200
      WHEN e.deotno IS NULL THEN e.sal+100
      ELSE e.sal
    END
);
</code></pre>
</li>
</ul>
<h3 id="事务机制-一-进入企业市场的第一步"><a href="#事务机制-一-进入企业市场的第一步" class="headerlink" title="事务机制(一) 进入企业市场的第一步"></a>事务机制(一) 进入企业市场的第一步</h3><h5 id="避免写入直接操作数据文件"><a href="#避免写入直接操作数据文件" class="headerlink" title="避免写入直接操作数据文件"></a>避免写入直接操作数据文件</h5><ul>
<li>如果数据的写入直接操作数据文件是非常危险的事情</li>
</ul>
<h5 id="利用日志来实现间接写入"><a href="#利用日志来实现间接写入" class="headerlink" title="利用日志来实现间接写入"></a>利用日志来实现间接写入</h5><ul>
<li>MySQL总共有5种日志，其中只有redo日志和undo日志与事务有关<br>[<strong>数据库</strong> 拷贝数据给 <strong>undo日志</strong> 记录修改 <strong>redo日志</strong> 与数据库<strong>同步数据</strong>]</li>
</ul>
<h5 id="事务机制-Transaction"><a href="#事务机制-Transaction" class="headerlink" title="事务机制(Transaction)"></a>事务机制(Transaction)</h5><ul>
<li>RDBMS &#x3D; SQL语句 + 事务(ACID)</li>
<li>事务是一个或者多个SQL语句组成的整体，要么全部执行成功，要么全都执行失败</li>
</ul>
<h5 id="事务案例"><a href="#事务案例" class="headerlink" title="事务案例"></a>事务案例</h5><ul>
<li>把10部门中MANGER员工调往20部门，其他岗位的员工调往30部门，然后删除10部门<br><span style = "color:red"><strong>事务</strong>：<u><em><strong>开启事务</strong></em> [把要修改的数据拷贝到<strong>undo日志</strong>[可恢复]内,做的修改会被记录到<strong>redo日志</strong>[同步]里面] <em><strong>UPDATE语句</strong></em>  <em><strong>DELETE语句  提交事务</strong></em></u></span></li>
</ul>
<h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><ul>
<li><p>默认情况下，MySQL执行每条SQL语句都会自动开启和提交事务</p>
</li>
<li><p>为了让多条SQL语句纳入到一个事务之下，可以手动管理事务</p>
<pre><code class="sql">START TRANSACTION;
SQL语句
[COMMIT|ROLLBACK];

START TRANSACTION;
DELETE FROM t_emp
DELETE FROM t_dept;
SELECT * FROM t_emp;
SELECT * FROM t_dept;
#这些删除修改只是在redo日志文件中进行的修改并未提交 
#虽然SELECT查不到了 但是点开左列的表中数据仍未删除
#只要不提交事务 redo日志就不会和数据库做同步
COMMIT; #把结果提交到日志里面 就会同步了
ROLLBACK; #做标记 回滚 一起失败
</code></pre>
</li>
</ul>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><h6 id="原子性-一致性-隔离性-持久性"><a href="#原子性-一致性-隔离性-持久性" class="headerlink" title="原子性   一致性    隔离性   持久性"></a>原子性   一致性    隔离性   持久性</h6><h4 id="事务的原子性"><a href="#事务的原子性" class="headerlink" title="事务的原子性"></a>事务的原子性</h4><ul>
<li>一个事务中的所有操作要么全部完成，要么全部失败。事务执行后，不允许停留在中间某个状态</li>
</ul>
<h4 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h4><ul>
<li>不管任何给定的时间、并发事务由多少，事务必须保证运行结果的一致性<br>[<strong>阻止事务之间互相读取临时数据</strong>] [A給B 10元 事务<u>没有提交后且回滚了</u> C给A20元 此时A应该有30元 ]</li>
</ul>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><ul>
<li>隔离性要求事务不受其他并发事务的影响，如同在给定的时间内，该事务是数据库唯一运行的事务</li>
<li>默认情况下A事务，只能看到日志中该事务的相关数据 [A,B事务可以看undo和redo日志]</li>
</ul>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><ul>
<li>事务一旦提交，结果便是永久性的。即便发生宕机，仍然可以依靠事务日志完成数据的持久化</li>
</ul>
<h3 id="事务机制-二"><a href="#事务机制-二" class="headerlink" title="事务机制(二)"></a>事务机制(二)</h3><h4 id="事务的四个隔离级别-可设置相互读取"><a href="#事务的四个隔离级别-可设置相互读取" class="headerlink" title="事务的四个隔离级别(可设置相互读取)"></a>事务的四个隔离级别(可设置相互读取)</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">隔离级别</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">read uncommitted</td>
<td align="center">读取未提交数据</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">read committed</td>
<td align="center">读取已提交数据</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">repeatable read</td>
<td align="center">重复读取</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">serializable</td>
<td align="center">序列化</td>
</tr>
</tbody></table>
<h3 id="业务案例1-购票系统"><a href="#业务案例1-购票系统" class="headerlink" title="业务案例1 [购票系统]"></a>业务案例1 [购票系统]</h3><h6 id="A事务-B事务"><a href="#A事务-B事务" class="headerlink" title="A事务  B事务"></a>A事务  B事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center">未售出</td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<p>A事务看到G8047 1A坐席未售出 用UPDATE把状态修改成已售出 因为没有提交 所以只修改在了undo日志里 真实的数据没有发生改变。此时B事务启动了看到了1A坐席还有票 于是更新且提交了 于是数据已经发生了改变。</p>
<h6 id="A事务"><a href="#A事务" class="headerlink" title="A事务"></a>A事务</h6><table>
<thead>
<tr>
<th align="center">车次</th>
<th align="center">车厢</th>
<th align="center">坐席</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1A</td>
<td align="center"><strong><span style = "color :red">已售出</span></strong></td>
</tr>
<tr>
<td align="center">G8047</td>
<td align="center">1</td>
<td align="center">1B</td>
<td align="center">未售出</td>
</tr>
</tbody></table>
<h6 id="所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席"><a href="#所以在这个案例中我们需要B事务去读取A事务的状态-发现在A事务的临时数据里购买了坐席-那么B事务就可以去购买其他的坐席" class="headerlink" title="所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席"></a>所以在这个案例中我们需要B事务去读取A事务的状态 发现在A事务的临时数据里购买了坐席 那么B事务就可以去购买其他的坐席</h6><h4 id="修改事务隔离级别"><a href="#修改事务隔离级别" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ UNCOMMITTED</strong></span> 代表可以读取其他事务未提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
</code></pre>
<pre><code class="sql">*无标题-查询1
START TRANSACTION;
UPDATE t_emp SET sal=1;
-----------------------
*无标题-查询2
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
#发现员工的sal并未变成1块钱

#解决问题：增加事务隔离级别  一个事务读到了另一个事务的数据
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT empno,enam,sal FROM t_emp;
COMMIT;
</code></pre>
</li>
</ul>
<h3 id="业务案例2-银行转账"><a href="#业务案例2-银行转账" class="headerlink" title="业务案例2 [银行转账]"></a>业务案例2 [银行转账]</h3><h6 id="Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元"><a href="#Scott账户有5000元余额-B事务开始执行支出100元-此时A事务执行转账1000元到该用户-如果AB都正常commit-最终账户余额是5900元-但是如果B事务是一个错误的消费被回滚-退款操作-最终账户应该是6000元。如果允许A事务去读取B事务的临时数据-按照4900-1000-x3D-5900元-若A回滚就凭空少了100元" class="headerlink" title="Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元"></a>Scott账户有5000元余额 B事务开始执行支出100元 此时A事务执行转账1000元到该用户 如果AB都正常commit 最终账户余额是5900元 但是如果B事务是一个错误的消费被回滚[退款操作] 最终账户应该是6000元。如果允许A事务去读取B事务的临时数据 按照4900+1000&#x3D;5900元 若A回滚就凭空少了100元</h6><h4 id="修改事务隔离级别-1"><a href="#修改事务隔离级别-1" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h4><ul>
<li><p><span style = "color :red"><strong>READ COMMITTED</strong></span> 代表只能读取其他事务提交的数据</p>
<pre><code class="sql"># ↓设置当前绘画的事务级别↓ [并非全局]
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
</code></pre>
</li>
</ul>
<h3 id="业务案例3-电商案例"><a href="#业务案例3-电商案例" class="headerlink" title="业务案例3 [电商案例]"></a>业务案例3 [电商案例]</h3><p><strong>A事务</strong> 下单购买 商品(价格350元)   <strong>B事务</strong>要对 该商品涨价</p>
<h4 id="修改事务隔离级别【READ为默认级别】"><a href="#修改事务隔离级别【READ为默认级别】" class="headerlink" title="修改事务隔离级别【READ为默认级别】"></a>修改事务隔离级别【READ为默认级别】</h4><ul>
<li><p><span style = "color :red"><strong>REPEATABLE READ</strong></span> 代表事务在执行中反复读取数据，得到的结果是一致性的，<strong>不会受其他事务影响</strong></p>
<pre><code class="sql">#就算事务A提交了数据 也不影响事务B的查询原始数据
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; 
UPDATE t_emp SET sal=1; 
COMMIT;
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL REPEATALE READ;
START TRANSACTION; 
SELECT empno,ename,sal FROM t_emp; 
COMMIT;
</code></pre>
<h3 id="事务的序列化"><a href="#事务的序列化" class="headerlink" title="事务的序列化"></a>事务的序列化</h3><ul>
<li><p>由于事务并发执行所带来的各种问题，<strong>前三种隔离级别只适用于在某些业务场景中</strong>，但是序列化的隔离性，让事务逐一执行，就不会产生上述问题了。</p>
<pre><code class="sql">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</code></pre>
</li>
</ul>
<pre><code class="sql">START TRANSACTION; ①
UPDATE t_emp SET sal=1; ②
COMMIT; ⑤
-----------------------
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION; ③
SELECT empno,ename,sal FROM t_emp; ④ #此时会等待 只需要执行上方COMMIT
COMMIT;
</code></pre>
<h3 id="数据导入与导出"><a href="#数据导入与导出" class="headerlink" title="数据导入与导出"></a>数据导入与导出</h3><h4 id="数据导出与备份的区别"><a href="#数据导出与备份的区别" class="headerlink" title="数据导出与备份的区别"></a>数据导出与备份的区别</h4><ul>
<li>数据导出，导出的纯粹是业务数据</li>
<li>数据备份，备份的是数据文件、日志文件、索引文件灯</li>
</ul>
<p><strong>全量备份 → 增量备份1 → 增量备份2</strong></p>
<h4 id="数据导出的分类"><a href="#数据导出的分类" class="headerlink" title="数据导出的分类"></a>数据导出的分类</h4><p><strong>数据库</strong>可以导出<strong>SQL文档(数据不多)</strong> 也可以 导出<strong>文本文档(数据巨大)</strong></p>
<h4 id="导出SQL文件-或者手动右键库-存储SQL文件"><a href="#导出SQL文件-或者手动右键库-存储SQL文件" class="headerlink" title="导出SQL文件 [或者手动右键库 存储SQL文件]"></a>导出SQL文件 [或者手动右键库 存储SQL文件]</h4><ul>
<li><p><strong>mysqldump</strong>用来把业务数据导出成SQL文件，其中也包括了表结构</p>
<pre><code class="sql">#导出命令行 不写no-date就导出即包含 表结构 又包含 数据
mysqldump -uroot -p [no-date] 逻辑库 &gt; 路径
# D:/MySQL/demo.sql
</code></pre>
</li>
</ul>
<h4 id="导入SQL文件"><a href="#导入SQL文件" class="headerlink" title="导入SQL文件"></a>导入SQL文件</h4><ul>
<li>source命令用于导入SQL文件，包括创建数据表，写入记录等<pre><code class="sql">sql &gt; USE demo;
sql &gt; SOURCE backup.sql;
</code></pre>
</li>
</ul>
<h6 id="导出纯粹的业务数据"><a href="#导出纯粹的业务数据" class="headerlink" title="导出纯粹的业务数据"></a>导出纯粹的业务数据</h6><blockquote>
<p>若数据巨大 先导出表结构 再导出数据库文档(.txt) 之后再导入 就会快很多</p>
</blockquote>
<ul>
<li><p>t_emp 右键 存储sql文件 <strong>仅结构</strong> 再次右键 导出向导… txt文档 (跳过词法分析与语法优化)</p>
<pre><code class="sql">&quot;empno&quot;    &quot;ename&quot;    &quot;job&quot;    &quot;mgr&quot;    &quot;hiredate&quot;    &quot;sal&quot;    &quot;comm&quot;    &quot;deptno&quot;
&quot;7369&quot;    &quot;SMITH&quot;    &quot;CLERK&quot;    &quot;7902&quot;    &quot;17/12/1980&quot;    &quot;800&quot;        &quot;20&quot;
&quot;7499&quot;    &quot;ALLEN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;20/2/1981&quot;    &quot;1600&quot;    &quot;300&quot;    &quot;30&quot;
&quot;7521&quot;    &quot;WARD&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;22/2/1981&quot;    &quot;1250&quot;    &quot;500&quot;    &quot;30&quot;
&quot;7566&quot;    &quot;JONES&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;2/4/1981&quot;    &quot;2975&quot;        &quot;20&quot;
&quot;7654&quot;    &quot;MARTIN&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;28/9/1981&quot;    &quot;1250&quot;    &quot;1400&quot;    &quot;30&quot;
&quot;7698&quot;    &quot;BLAKE&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;1/5/1981&quot;    &quot;2850&quot;        &quot;30&quot;
&quot;7782&quot;    &quot;CLARK&quot;    &quot;MANAGER&quot;    &quot;7839&quot;    &quot;9/6/1981&quot;    &quot;2450&quot;        &quot;10&quot;
&quot;7788&quot;    &quot;SCOTT&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;9/12/1982&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7839&quot;    &quot;KING&quot;    &quot;PRESIDENT&quot;        &quot;17/11/1981&quot;    &quot;5000&quot;        &quot;10&quot;
&quot;7844&quot;    &quot;TURNER&quot;    &quot;SALESMAN&quot;    &quot;7698&quot;    &quot;8/9/1981&quot;    &quot;1500&quot;    &quot;0&quot;    &quot;30&quot;
&quot;7876&quot;    &quot;ADAMS&quot;    &quot;CLERK&quot;    &quot;7788&quot;    &quot;12/1/1983&quot;    &quot;1100&quot;        &quot;20&quot;
&quot;7900&quot;    &quot;JAMES&quot;    &quot;CLERK&quot;    &quot;7698&quot;    &quot;3/12/1981&quot;    &quot;950&quot;        &quot;30&quot;
&quot;7902&quot;    &quot;FORD&quot;    &quot;ANALYST&quot;    &quot;7566&quot;    &quot;3/12/1981&quot;    &quot;3000&quot;        &quot;20&quot;
&quot;7934&quot;    &quot;MILLER&quot;    &quot;CLERK&quot;    &quot;7782&quot;    &quot;23/1/1982&quot;    &quot;1300&quot;        &quot;10&quot;
</code></pre>
</li>
<li><p>导入回来 先删除t_emp 在dmeo右键 运行文件 导入刚刚右键存储的t_emp的结构(仅结构) 此时员工表结构就回来了 导入向导… 下一步 找到导出的txt文档  第一个数据行1(第一行有效数据) 在导入向导中根据<strong>源字段</strong>匹配<strong>目标字段</strong> (txt+结构&#x3D;数据表)</p>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/08/后端/数据库/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/10/01/后端/油画项目-介于JavaWeb与数据库之间/">
        <h2>
            油画项目(介于JavaWeb与数据库之间)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/10/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="企业门户网站项目实战"><a href="#企业门户网站项目实战" class="headerlink" title="企业门户网站项目实战"></a><span style = "color:red">企业门户网站项目实战</span></h1><ul>
<li>需求说明与环境准备</li>
<li>实现前端展示模块</li>
<li>实现后台数据管理模块</li>
</ul>
<h4 id="MVC架构模型-数据显示与数据处理分开"><a href="#MVC架构模型-数据显示与数据处理分开" class="headerlink" title="(MVC架构模型) 数据显示与数据处理分开"></a>(MVC架构模型) 数据显示与数据处理分开</h4><p><span style = "color:blue"><strong>M</strong>odel模型 <strong>V</strong>iew试图 <strong>C</strong>ontroller控制器</span> [是一种设计理念]</p>
<h6 id="Model-模型"><a href="#Model-模型" class="headerlink" title="Model - 模型"></a>Model - 模型</h6><ul>
<li><p>模型(Model)负责生产业务需要的数据 <u><strong>Service</strong>[结尾]实现业务逻辑</u></p>
<pre><code class="java">public class MathService&#123;
    public List square(int max)&#123;
        List list = new ArrayList();
        for(int i = 0; i &lt;= max; i++)&#123;
            long result = i * i;
            list.add(result);
        &#125;
        return list;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h6 id="Controller-控制器-Java-Web领域是WebServlet"><a href="#Controller-控制器-Java-Web领域是WebServlet" class="headerlink" title="Controller - 控制器  (Java Web领域是WebServlet)"></a>Controller - 控制器  (Java Web领域是WebServlet)</h6><ul>
<li>控制器(Controller)是界面(View)与模型(Model)的粘合剂</li>
</ul>
<pre><code class="java">@WebServlet(&quot;/square&quot;)
public class HelloWord  extends HttpServlet&#123;
    public void doGet(HttpServletRequest req, HttpServletResponse res)&#123;
        //1.接收数据 接收web的http请求参数
        int max = Integer.parselnt(request.getParameter(&quot;max&quot;));
        //2.调用处理类(模型)进行处理 
        MathService ms = new MathService();
        List list = ms.square(max);//前台调用的参数传入square方法中
        req.setAttribute(&quot;squareList&quot;, list);//执行结果放到请求属性中
        //3.跳转界面(View)
        request.getRequestDispatcher(&quot;/result.jsp&quot;).forward(req,res);
    &#125;
&#125;
</code></pre>
<h6 id="View-视图"><a href="#View-视图" class="headerlink" title="View - 视图"></a>View - 视图</h6><ul>
<li>试图(View)用于展示最终结果</li>
</ul>
<pre><code class="java">URL:http://localhost:8080/square?max=100
----------------------------------------
&lt;ul&gt;
&lt;c:foreach items = &quot;$&#123;squareList&#125;&quot; var = &quot;r&quot; varStatus = &quot;idx&quot;&gt;
   &lt;li&gt;$&#123;idx.index&#125;的平方是$&#123;r&#125;&lt;/li&gt;
&lt;/&lt;c:foreach&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="MVC架构模式优点"><a href="#MVC架构模式优点" class="headerlink" title="MVC架构模式优点"></a>MVC架构模式优点</h3><ul>
<li><p>保证了软件层面的解耦，同时保障了团队合作的组织架构</p>
</li>
<li><p>软件团队分工合作，成员各司其职 通过controller联合</p>
</li>
<li><p>组件可灵活替代，互不影响</p>
</li>
</ul>
<p>通过<strong>控制器</strong>将前端传入的参数进行接收调用后台的<strong>模型</strong>产生结果，结果通过控制器保存在当前的属性中在<strong>视图</strong>中进行展现</p>
<h3 id="工程结构与开发规约"><a href="#工程结构与开发规约" class="headerlink" title="工程结构与开发规约"></a>工程结构与开发规约</h3><h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">mgallery - eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc.mgallery //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h3 id="Dao类-Data-Access-Object"><a href="#Dao类-Data-Access-Object" class="headerlink" title="Dao类[Data Access Object]"></a>Dao类[Data Access Object]</h3><ul>
<li>XxxDao类只负责对数据进行读取、写入操作</li>
<li>只负责对数据 <strong>增、删、改、查</strong></li>
</ul>
<pre><code class="java">示例：PaintingDao //针对油画数据进行增删改查
public class PaintingDao&#123;
    public void append()&#123;...&#125; //新增数据
    public void update()&#123;...&#125; //修改数据
    public void delete()&#123;...&#125; //删除数据
    public void findAll()&#123;...&#125; //查询数据
&#125;
</code></pre>
<h3 id="Service与Dao的关系"><a href="#Service与Dao的关系" class="headerlink" title="Service与Dao的关系"></a>Service与Dao的关系</h3><ul>
<li>Service负责进行流程处理，需**持久化[java处理在内存中 存储在数据库防止丢失]**时调用Dao</li>
<li>Dao只负责单纯对数据进行<strong>增删改查</strong>操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a55433ae2d4814ee86fd799f7fd9f9279280c84/data/MVC%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F.jpg"></p>
<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li><p>对一种类的使用形式的统称</p>
</li>
<li><p>JavaBean是一种Java中可重用组件</p>
</li>
<li><p>JavaBean不是技术，而是一种Java类的格式要求</p>
</li>
<li><p>JavaBean在Java领域非常常见，通常用于存储数据</p>
</li>
</ul>
<h3 id="JavaBean格式要求"><a href="#JavaBean格式要求" class="headerlink" title="JavaBean格式要求"></a>JavaBean格式要求</h3><ul>
<li>类必须是pubilc并提供默认构造函数</li>
<li>所有属性private私有化</li>
<li>属性通过getter与setter方法进行读写</li>
</ul>
<pre><code class="java">public class Painting&#123;//类公有化
    public Painting()&#123;...&#125;; //提供默认构造函数，可不写
    private Integer id; //属性私有
    private String pname;
    public Integer getId()&#123;return id;&#125; //getter获取属性值
    public void setId(Integer id)&#123;this.id = id;&#125; //setter设置属性值
    public String getPname()&#123;return pname;&#125;
    public void setPname(String pname)&#123;this.pname = pname;&#125;
&#125;
</code></pre>
<h3 id="创建mgallery工程-ViewControllerServiceDao-VCSD"><a href="#创建mgallery工程-ViewControllerServiceDao-VCSD" class="headerlink" title="创建mgallery工程(ViewControllerServiceDao){VCSD}"></a>创建mgallery工程(ViewControllerServiceDao){VCSD}</h3><ul>
<li>开发<strong>PaintingDao</strong>读取XML数据，实现分页操作</li>
<li>开发<strong>PaintingService</strong>服务类，对PaintingDao进行调用</li>
<li>开发<strong>PaintingController</strong>控制器，调用PaintingService</li>
<li>重写index.html，利用JSP技术读取分页数据</li>
</ul>
<h3 id="关键类与方法"><a href="#关键类与方法" class="headerlink" title="关键类与方法"></a>关键类与方法</h3><ul>
<li><strong>XmlDataSource</strong>类 - XML数据源工具类，简化Dao提取操作</li>
<li><strong>PaintingDao.pagination()</strong> - 数据分页查询方法</li>
<li><strong>PageModel</strong>类 - 分页结果的包装类</li>
</ul>
<h4 id="Dom4j"><a href="#Dom4j" class="headerlink" title="Dom4j"></a>Dom4j</h4><ul>
<li>Dom4j是一个易用的、开源的库，用于解析XML。它应用于Java平台</li>
<li>Dom4j将<strong>XML</strong>视为<strong>Document</strong>对象</li>
<li>XML标签被Dom4j定义为Element对象</li>
</ul>
<h6 id="Dom4j开发流程回顾"><a href="#Dom4j开发流程回顾" class="headerlink" title="Dom4j开发流程回顾"></a>Dom4j开发流程回顾</h6><ul>
<li>SAXReader.read()读取XML文件，得到Document对象</li>
<li>document.selectNodes()利用Xpath得到XML节点集合</li>
<li>遍历XML节点，包装成JavaBean或者集合对象返回</li>
</ul>
<h3 id="开发XmlDataSource-utils"><a href="#开发XmlDataSource-utils" class="headerlink" title="开发XmlDataSource (utils)"></a>开发XmlDataSource (utils)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/5e39cc02ef84b0ba617ad43f8f6b0e3462a002a5/data/XmlDataSource%E5%8E%9F%E7%90%86.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37218227/article/details/109095112">【详细】IntelliJ IDEA: 无法创建Java Class文件_idea 不能新建java class-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45965432/article/details/111316470">IDEA部署Tomcat提示：Warning no artifacts configured-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32706349/article/details/81067650">Class.getResource(“xxx.css”)得到值为null-CSDN博客</a></p>
<pre><code class="java">utils/XmlDataSource.java
package com.example.mgallery.utils;

import com.example.mgallery.entity.Painting;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;

//用于将XML文件解析为Java对象
public class XmlDataSource &#123;
    //通过static静态关键字保证数据全局唯一
    private static List data = new ArrayList(); //油画集合
    private static String dataFile;
    static&#123; //程序运行以后去得到类路径目录下的/painting.xml的路径地址
        dataFile = XmlDataSource.class.getResource(&quot;/painting.xml&quot;).getPath();
        System.out.println(dataFile);
          //若得到特殊字符进行编码转换 空格 c:\new style\painting.xml
        try &#123;
            URLDecoder.decode(dataFile, &quot;UTF-8&quot;);
            //利用Dom4j对XML进行解析 读取XML
            SAXReader reader = new SAXReader();
            //1.获取Document文档对象
            Document document = reader.read(dataFile);
            //2.Xpath得到XML节点集合 获取多个xml节点
            List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting&quot;);
            for (Node node : nodes)&#123;
                Element element = (Element) node;
                String id = element.attributeValue(&quot;id&quot;);//获得id
                String pname = element.elementText(&quot;pname&quot;);//获得子节点
                Painting painting = new Painting();
                painting.setId(Integer.parseInt(id));
                painting.setPname(pname);
                painting.setCategory(Integer.parseInt(element.elementText(&quot;category&quot;)));
                painting.setPrice(Integer.parseInt(element.elementText(&quot;price&quot;)));
                painting.setPreview(element.elementText(&quot;preview&quot;));
                painting.setDescription(element.elementText(&quot;description&quot;));
                data.add(painting);//将List data 保存油画的完整信息

                System.out.println(id + &quot;;&quot; + pname);
            &#125;
        &#125; catch (UnsupportedEncodingException e) &#123;
            e.printStackTrace();
        &#125; catch (DocumentException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    /**
     *  获取所有油画Painting对象
     * @return Painting List
     */
    public static List&lt;Painting&gt; getRawData()&#123;
        return data;
    &#125;
    public static void main(String[] args) &#123;
//        new XmlDataSource();
        List&lt;Painting&gt; ps = XmlDataSource.getRawData();
        System.out.println(ps);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">META-INF/painting.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- 数据文件 --&gt;
&lt;root&gt;
    &lt;painting id=&quot;1&quot;&gt;
        &lt;pname&gt;古典油画鉴赏1&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/1.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏1的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;2&quot;&gt;
        &lt;pname&gt;古典油画鉴赏2&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/2.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏2的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;3&quot;&gt;
        &lt;pname&gt;古典油画鉴赏3&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/3.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏3的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;4&quot;&gt;
        &lt;pname&gt;古典油画鉴赏4&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/4.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏4的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;5&quot;&gt;
        &lt;pname&gt;古典油画鉴赏5&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/5.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏5的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;6&quot;&gt;
        &lt;pname&gt;古典油画鉴赏6&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/6.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏6的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;7&quot;&gt;
        &lt;pname&gt;古典油画鉴赏7&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/7.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏7的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;8&quot;&gt;
        &lt;pname&gt;古典油画鉴赏8&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/8.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏8的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;9&quot;&gt;
        &lt;pname&gt;古典油画鉴赏9&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/9.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏9的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;9&quot;&gt;
        &lt;pname&gt;古典油画鉴赏9&lt;/pname&gt;
        &lt;category&gt;1&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/9.jpg&lt;/preview&gt;
        &lt;description&gt;古典油画鉴赏9的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;10&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏1&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/10.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏1的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;11&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏2&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/11.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏2的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;12&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏3&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/12.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏3的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;13&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏4&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/13.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏4的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;14&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏5&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/14.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏5的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    &lt;painting id=&quot;15&quot;&gt;
        &lt;pname&gt;抽象派油画鉴赏6&lt;/pname&gt;
        &lt;category&gt;2&lt;/category&gt;
        &lt;price&gt;3800&lt;/price&gt;
        &lt;preview&gt;/upload/15.jpg&lt;/preview&gt;
        &lt;description&gt;抽象派油画鉴赏6的描述文本&lt;/description&gt;
    &lt;/painting&gt;
    
&lt;/root&gt;
</code></pre>
<pre><code class="java">entity/Painting.java
public class Painting&#123;
    private Integer id;
    private String pname;
    private Integer category;
    private Integer price;
    private String preview; //油画图片地址
    private String description; //描述
    ......
&#125;
</code></pre>
<h3 id="开发PageMode1-utils"><a href="#开发PageMode1-utils" class="headerlink" title="开发PageMode1 (utils)"></a>开发PageMode1 (utils)</h3><pre><code class="java">utils/PageModel.java
public class PageModel &#123;
    private int page;
    private int totalPages;
    private int rows; //每页几条数据
    private int totalRows; //原始数据多少条
    private int pageStartRow; //当前页是从第几行开始的
    private int pageEndRow; //到第几行结束的 结束行号
    private boolean hasNextPage; //是否下一页(尾页)
    private boolean hasPreviousPage; //是否上一页(首页)
    private List pageData; //当前页面数据

    public PageModel() &#123;
    &#125;

    /**
     * 初始化PageMode1对象，计算分页属性
     * @param page
     * @param rows
     * @param data
     */
    public PageModel(List data, int page, int rows) &#123;
        this.page = page;
        this.rows = rows;
        totalRows = data.size();
        //总页数计算规则：总行数/每页记录数，能整除页数取整，不能整除向上取整
        //18/6=3 | 2/6≈3.33 向上取整=4  intValue()得到整数部分
        //Nath.ceil向上取整  Math.floor浮点数向下取整
        //小细节: 20/6≈3.33 但是totalRows 和 rows都是整数 20/6=3 向上取整还是3
        //仅需在一个后面×1f即可解决问题 (rows*1f)默认类型转换返回浮点数
        totalPages = new Double(Math.ceil(totalRows/(rows * 1f))).intValue();
        pageStartRow = (page - 1) * rows; //0
        pageEndRow = page * rows; //6
        //totalRows:20 | totalPage:4 | rows:6
        //pageEndRow=4*6=24&gt;20 执行subList()抛出下标越界异常
        if (pageEndRow &gt; totalRows)&#123;
            pageEndRow = totalRows; //让20作为结束行号 不会越界
        &#125;
        pageData = data.subList(pageStartRow, pageEndRow); //得到分页数据
        if (page &gt; 1) &#123;
            hasPreviousPage = true;
        &#125;else &#123;
            hasPreviousPage = false;
        &#125;
        if (page &lt; totalPages) &#123; //判断是否存在下一页
            hasNextPage = true;
        &#125;else &#123;
            hasNextPage = false;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        List sample = new ArrayList();
        for (int i = 1; i &lt; 100; i++) &#123;
            sample.add(i);
        &#125;
        PageModel pageModel = new PageModel(sample,6,8);
        System.out.println(pageModel.getPageData()); //当前页的list集合
        System.out.println(pageModel.getTotalPages());
        System.out.println(pageModel.getPageStartRow() + &quot;:&quot; + pageModel.getPageEndRow()) ;
    &#125;
+getter and setter 
</code></pre>
<h3 id="油画数据分页设计思路"><a href="#油画数据分页设计思路" class="headerlink" title="油画数据分页设计思路"></a>油画数据分页设计思路</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/77cb566085a49c9dd441edb8816b96adf848dbd2/data/%E6%B2%B9%E7%94%BB%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.png"></p>
<h6 id="Param注解的使用方法"><a href="#Param注解的使用方法" class="headerlink" title="@Param注解的使用方法"></a>@Param注解的使用方法</h6><p>@Param的作用就是給参数命名，比如在mapper里面某个方法A(int id)，当添加注解后A(@Param(“userId”) int id)，也就是说外部想要取出传入的id值，只需要取它的参数名userId就可以了。若在SQL中，通过#{userId}进行取值給SQL的参数赋值。</p>
<p>快速添加注解只需要在前面 <u>&#x2F;** + 回车</u></p>
<h3 id="油画数据分页展示"><a href="#油画数据分页展示" class="headerlink" title="油画数据分页展示"></a>油画数据分页展示</h3><h5 id="开发PaintingDao与PaintingService"><a href="#开发PaintingDao与PaintingService" class="headerlink" title="开发PaintingDao与PaintingService"></a>开发PaintingDao与PaintingService</h5><pre><code class="java">service/PaintingDao.java
package com.example.mgallery.dao;

import com.example.mgallery.entity.Painting;
import com.example.mgallery.utils.PageModel;
import com.example.mgallery.utils.XmlDataSource;

import java.util.List;

//获得最原始的 对其进行分页处理
public class PaintingDao &#123;
    public PageModel pagination(int page, int rows)&#123;
        //Painting油画对象集合
        List&lt;Painting&gt; list = XmlDataSource.getRawData();
        //PageModel分页处理得到分页数据及分页附加
        PageModel pageModel = new PageModel(list,page,rows);
        return pageModel;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/PaintingService
package com.example.mgallery.service;

import com.example.mgallery.dao.PaintingDao;
import com.example.mgallery.entity.Painting;
import com.example.mgallery.utils.PageModel;

import java.util.List;
//完成业务逻辑 service与dao进行传递调用
public class PaintingService &#123;
    private PaintingDao paintingDao = new PaintingDao();
    public PageModel pagination(int page, int rows)&#123;
        if (rows == 0)&#123;
            throw new RuntimeException(&quot;无效的rows参数&quot;);
        &#125;
        return paintingDao.pagination(page, rows); //调用并返回
    &#125;

    public static void main(String[] args) &#123;
        PaintingService paintingService = new PaintingService();
        PageModel pageModel = paintingService.pagination(2, 6);//每页显示六条
        List&lt;Painting&gt; paintingList = pageModel.getPageData();
        for (Painting painting : paintingList)&#123;
            System.out.println(painting.getPname());
        &#125;
        System.out.println(pageModel.getPageStartRow() + &quot;:&quot; + pageModel.getPageEndRow());

    &#125;
&#125;
</code></pre>
<h5 id="开发PaintingController控制器"><a href="#开发PaintingController控制器" class="headerlink" title="开发PaintingController控制器"></a>开发PaintingController控制器</h5><pre><code class="java">controller/PaintingController.java
package com.example.mgallery.controller;

import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(&quot;/page&quot;)
public class PaintingController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();
    public PaintingController()&#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //1.接收Http数据
        String page = req.getParameter(&quot;p&quot;); //页号
        String rows = req.getParameter(&quot;r&quot;); //每页记录数
        if (page == null)&#123;
            page = &quot;1&quot;; //没传入则默认查询第一个
        &#125;if (rows == null)&#123;
            rows = &quot;6&quot;; //每页默认显示六条数据
        &#125;
        //2.调用Service方法,得到处理结果
        PageModel pageModel = paintingService.pagination(Integer.parseInt(page), Integer.parseInt(rows));
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/src/main/webapp/index.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
&#125;
</code></pre>
<h3 id="前台门户首页-由静态转换为动态"><a href="#前台门户首页-由静态转换为动态" class="headerlink" title="前台门户首页(由静态转换为动态)"></a>前台门户首页(由静态转换为动态)</h3><h5 id="HTML转换JSP变更流程"><a href="#HTML转换JSP变更流程" class="headerlink" title="HTML转换JSP变更流程"></a>HTML转换JSP变更流程</h5><ul>
<li>打开HTML文件，在首行增加 <strong>&lt; %@page contentType % &gt;</strong></li>
<li>更改扩展名从 <strong>.html</strong> 为 <strong>.jsp</strong>，移动到WEB-INF&#x2F;jsp目录下</li>
<li>提示：JSP不要实用&lt;%%&gt;代码块，实用EL+<strong>JSTL</strong>提取数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33271461/article/details/89510144?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-89510144-blog-111500619.235%5Ev38%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-89510144-blog-111500619.235%5Ev38%5Epc_relevant_anti_vip&utm_relevant_index=13">输入（http://localhost:8080/）不能正常访问，但是添加项目名后可以访问-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/G_rainy/article/details/105799165">实例化servlet类[web.LoginServlet]异常 servle-CSDN博客</a></p>
<pre><code class="jsp">WEB-INF/jsp/index.jsp
&lt;%@page contentType = &quot;text/html;charset=utf-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\common.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js\js1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;header&quot;&gt;
    &lt;div class=&quot;logo&quot;&gt;
        &lt;img src=&quot;image\logo.png&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;menu&quot; onclick=&quot;show_menu()&quot; onmouseleave=&quot;show_menu1()&quot;&gt;
        &lt;div class=&quot;menu_title&quot; &gt;&lt;a href=&quot;###&quot;&gt;内容分类&lt;/a&gt;&lt;/div&gt;
        &lt;ul id=&quot;title&quot;&gt;
            &lt;li&gt;现实主义&lt;/li&gt;
            &lt;li&gt;抽象主义&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;auth&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
    &lt;div class=&quot;banner&quot;&gt;
        &lt;img src=&quot;image/welcome.png&quot; class=&quot;banner-img&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-content&quot;&gt;
        &lt;ul&gt;
            &lt;c:forEach items=&quot;$&#123;pageModel.pageData&#125;&quot; var=&quot;painting&quot;&gt; &lt;!--pageModel.java--&gt;
                &lt;li&gt;
                    &lt;img src=&quot;$&#123;painting.preview&#125;&quot; class=&quot;img-li&quot;&gt;  &lt;!--painting.java--&gt;
                    &lt;div class=&quot;info&quot;&gt;
                        &lt;h3&gt;$&#123;painting.pname&#125;&lt;/h3&gt;
                        &lt;p&gt;
                                $&#123;painting.description&#125;
                        &lt;/p&gt;
                        &lt;div class=&quot;img-btn&quot;&gt;
                            &lt;div class=&quot;price&quot;&gt;&lt;fmt:formatNumber pattern=&quot;￥0.00&quot; value=&quot;$&#123;painting.price&#125;&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;/div&gt;
                            &lt;a href=&quot;#&quot; class=&quot;cart&quot;&gt;
                                &lt;div class=&quot;btn&quot;&gt;
                                    &lt;img src=&quot;image/cart.svg&quot;&gt;
                                &lt;/div&gt;
                            &lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/li&gt;
            &lt;/c:forEach&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;page-nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=1&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!--当前页减一就是上一页 否则就是1--&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.hasPreviousPage?pageModel.page-1:1&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;
            &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageModel.totalPages&#125;&quot; var=&quot;pno&quot; step=&quot;1&quot;&gt;
                &lt;li&gt;&lt;span $&#123;pno==pageModel.page?&quot;class=&#39;first-page&#39;&quot;:&quot;&quot;&#125;&gt; &lt;!--选中的页才有⚪圈圈 三目运算符不满足产生空字符串--&gt;
                    &lt;a href=&quot;/mgallery/page?p=$&#123;pno&#125;&quot;&gt;
                            $&#123;pno&#125;
                    &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;/c:forEach&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.hasNextPage?pageModel.page+1:pageModel.totalPages&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.totalPages&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;footer&quot;&gt;
    &lt;p&gt;&lt;span&gt;P_luminary&lt;/span&gt;©2023.10.3 POWERED BY GITHUB.COM&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现分类查询功能-改造代码"><a href="#实现分类查询功能-改造代码" class="headerlink" title="实现分类查询功能 [改造代码]"></a>实现分类查询功能 [改造代码]</h3><p>从Dao层面进行对数据的过滤</p>
<pre><code class="java">PaintingDao.java
package com.example.mgallery.dao;

import com.example.mgallery.entity.Painting;
import com.example.mgallery.utils.PageModel;
import com.example.mgallery.utils.XmlDataSource;

import java.util.ArrayList;
import java.util.List;

//获得最原始的 对其进行分页处理
public class PaintingDao &#123;
    public PageModel pagination(int page, int rows)&#123;
        //Painting油画对象集合
        List&lt;Painting&gt; list = XmlDataSource.getRawData();
        //PageModel分页处理得到分页数据及分页附加
        PageModel pageModel = new PageModel(list,page,rows);
        return pageModel;
    &#125;

    public PageModel pagination(int catagory, int page, int rows)&#123; //int catagory添加Dao层对数据进行筛选
        List&lt;Painting&gt; list = XmlDataSource.getRawData();
        List&lt;Painting&gt; categoryList = new ArrayList();
        for (Painting p : list)&#123;
            //如果等于从外侧添加的筛选条件 则添加categoryList内
            if (p.getCategory() == catagory)&#123;
                categoryList.add(p);
            &#125;
        &#125;
        PageModel pageModel = new PageModel(categoryList,page,rows);
        return  pageModel;
    &#125;
&#125;
----------------------------------------------------------------------
PaintingService.java
package com.example.mgallery.service;

import com.example.mgallery.dao.PaintingDao;
import com.example.mgallery.entity.Painting;
import com.example.mgallery.utils.PageModel;

import java.util.List;
//完成业务逻辑 service与dao进行传递调用
public class PaintingService &#123;
    private PaintingDao paintingDao = new PaintingDao();
    public PageModel pagination(int page, int rows, String...category)&#123;  //最后一个是添加 可选参数(可能/不一定出现一个或多个)
        if (rows == 0)&#123;
            throw new RuntimeException(&quot;无效的rows参数&quot;);
        &#125;
        if (category.length==0 || category[0] == null)&#123;
        return paintingDao.pagination(page, rows); //调用并返回
        &#125;else &#123; //程序进行可选调用 两个不同路径 尽量不要去修改类结构
            return paintingDao.pagination(Integer.parseInt(category[0]), page, rows);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        PaintingService paintingService = new PaintingService();
        PageModel pageModel = paintingService.pagination(2, 6);//每页显示六条
        List&lt;Painting&gt; paintingList = pageModel.getPageData();
        for (Painting painting : paintingList)&#123;
            System.out.println(painting.getPname());
        &#125;
        System.out.println(pageModel.getPageStartRow() + &quot;:&quot; + pageModel.getPageEndRow());

    &#125;
&#125;
---------------------------------------------------------------------
PaintingController.java
package com.example.mgallery.controller;

import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class PaintingController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();
    public PaintingController()&#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //1.接收Http数据
        String page = req.getParameter(&quot;p&quot;); //页号
        String rows = req.getParameter(&quot;r&quot;); //每页记录数
        String category = req.getParameter(&quot;c&quot;);
        if (page == null)&#123;
            page = &quot;1&quot;; //没传入则默认查询第一个
        &#125;if (rows == null)&#123;
            rows = &quot;6&quot;; //每页默认显示六条数据
        &#125;
        //2.调用Service方法,得到处理结果      增加了按类型筛选category
        PageModel pageModel = paintingService.pagination(Integer.parseInt(page), Integer.parseInt(rows), category);
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/index.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
&#125;
---------------------------------------------------------------------
</code></pre>
<pre><code class="jsp">webapp/WEB-INF/jsp/index.jsp
&lt;%@page contentType = &quot;text/html;charset=utf-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\common.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js\js1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%--JSTL混合书写判断 判断c是否存在 存在追加链接--%&gt;
&lt;c:if test=&quot;$&#123;param.c != null&#125;&quot;&gt;
    &lt;c:set var = &quot;categoryParam&quot; value=&quot;&amp;c=$&#123;param.c&#125;&quot;&gt;&lt;/c:set&gt;
&lt;/c:if&gt;
&lt;c:if test=&quot;$&#123;param.c == null&#125;&quot;&gt;
    &lt;c:set var = &quot;categoryParam&quot; value=&quot;&quot;&gt;&lt;/c:set&gt;
&lt;/c:if&gt;
&lt;div class=&quot;header&quot;&gt;
    &lt;div class=&quot;logo&quot;&gt;
        &lt;img src=&quot;image\logo.png&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;menu&quot;   onclick=&quot;show_menu()&quot; onmouseleave=&quot;show_menu1()&quot;&gt;
        &lt;div class=&quot;menu_title&quot; &gt;&lt;a href=&quot;###&quot;&gt;内容分类&lt;/a&gt;&lt;/div&gt;
        &lt;ul id=&quot;title&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?c=1&quot;&gt;现实主义&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?c=2&quot;&gt;抽象主义&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;auth&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
    &lt;div class=&quot;banner&quot;&gt;
        &lt;img src=&quot;image/welcome.png&quot; class=&quot;banner-img&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img-content&quot;&gt;
        &lt;ul&gt;
            &lt;c:forEach items=&quot;$&#123;pageModel.pageData&#125;&quot; var=&quot;painting&quot;&gt;
                &lt;li&gt;
                    &lt;img src=&quot;$&#123;painting.preview&#125;&quot; class=&quot;img-li&quot;&gt;
                    &lt;div class=&quot;info&quot;&gt;
                        &lt;h3&gt;$&#123;painting.pname&#125;&lt;/h3&gt;
                        &lt;p&gt;
                                $&#123;painting.description&#125;
                        &lt;/p&gt;
                        &lt;div class=&quot;img-btn&quot;&gt;
                            &lt;div class=&quot;price&quot;&gt;&lt;fmt:formatNumber pattern=&quot;￥0.00&quot; value=&quot;$&#123;painting.price&#125;&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;/div&gt;
                            &lt;a href=&quot;#&quot; class=&quot;cart&quot;&gt;
                                &lt;div class=&quot;btn&quot;&gt;
                                    &lt;img src=&quot;image/cart.svg&quot;&gt;
                                &lt;/div&gt;
                            &lt;/a&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/li&gt;
            &lt;/c:forEach&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&quot;page-nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=1$&#123;categoryParam&#125;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!--当前页减一就是上一页 否则就是1--&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.hasPreviousPage?pageModel.page-1:1&#125;$&#123;categoryParam&#125;&quot;&gt;上一页&lt;/a&gt;&lt;/li&gt;
            &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageModel.totalPages&#125;&quot; var=&quot;pno&quot; step=&quot;1&quot;&gt;
                &lt;li&gt;&lt;span $&#123;pno==pageModel.page?&quot;class=&#39;first-page&#39;&quot;:&quot;&quot;&#125;&gt; &lt;!--选中的页才有⚪圈圈 三目运算符不满足产生空字符串--&gt;
                     &lt;%--  c不存在，则href=&quot;/mgallery/page?p=1&quot;  c存在，测href=&quot;/mgallery/page?p=1&amp;c=1&quot;  --%&gt;
                    &lt;a href=&quot;/mgallery/page?p=$&#123;pno&#125;$&#123;categoryParam&#125;&quot;&gt;
                            $&#123;pno&#125;
                    &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;/c:forEach&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.hasNextPage?pageModel.page+1:pageModel.totalPages&#125;$&#123;categoryParam&#125;&quot;&gt;下一页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/mgallery/page?p=$&#123;pageModel.totalPages&#125;$&#123;categoryParam&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;footer&quot;&gt;
    &lt;p&gt;&lt;span&gt;P_luminary&lt;/span&gt;©2023.10.3 POWERED BY GITHUB.COM&lt;/p&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h6 id="利用默认首页跳转到任何地址上-常用开发技巧"><a href="#利用默认首页跳转到任何地址上-常用开发技巧" class="headerlink" title="利用默认首页跳转到任何地址上 [常用开发技巧]"></a>利用默认首页跳转到任何地址上 [常用开发技巧]</h6><pre><code class="html">index.html
&lt;script&gt;
    window.location.href=&quot;/page&quot;
&lt;/script&gt;
</code></pre>
<h3 id="实现后台数据管理"><a href="#实现后台数据管理" class="headerlink" title="实现后台数据管理"></a>实现后台数据管理</h3><h5 id="前台与后台的区别"><a href="#前台与后台的区别" class="headerlink" title="前台与后台的区别"></a>前台与后台的区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">前台系统</th>
<th align="center">后台系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开放度</td>
<td align="center">对外开放</td>
<td align="center">不对外开放</td>
</tr>
<tr>
<td align="center">面向群体</td>
<td align="center">客户</td>
<td align="center">企业内部人员</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">提供查询与交互</td>
<td align="center">管理前台数据</td>
</tr>
<tr>
<td align="center">设计侧重点</td>
<td align="center">良好的用户体验</td>
<td align="center">严密的业务逻辑</td>
</tr>
<tr>
<td align="center">访问量</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">典型案例</td>
<td align="center">猫眼电影网 [<u>后台有评论审核系统</u>]</td>
<td align="center">XX公司无纸质化办公系统</td>
</tr>
</tbody></table>
<h5 id="后台实现功能"><a href="#后台实现功能" class="headerlink" title="后台实现功能"></a>后台实现功能</h5><p><strong><u>油画列表  油画预览  删除油画  修改油画  新增与上传油画</u></strong> </p>
<h3 id="实现油画列表功能"><a href="#实现油画列表功能" class="headerlink" title="实现油画列表功能"></a>实现油画列表功能</h3><h5 id="重用pagination方法实现分页列表"><a href="#重用pagination方法实现分页列表" class="headerlink" title="重用pagination方法实现分页列表"></a>重用pagination方法实现分页列表</h5><p>原有的PaintingController不可以继续被用 术业有专攻 要再创建一个使用</p>
<pre><code class="java">ManagementController.java
package com.example.mgallery.controller;

import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
//实现增删改查
@WebServlet(&quot;/management&quot;)
public class ManagementController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();
    public ManagementController() &#123;
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        String method = req.getParameter(&quot;method&quot;);
        if (method.equals(&quot;list&quot;))&#123; //去显示分页的数据
            this.list(req, resp);
        &#125; else if (method.equals(&quot;delete&quot;)) &#123;
            // this.delete(req, resp);
        &#125;
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req, resp);
    &#125;
    // 控制器代码的实现
    private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String p = req.getParameter(&quot;p&quot;);
        String r = req.getParameter(&quot;r&quot;);
        if (p==null)&#123;
            p = &quot;1&quot;;
        &#125;
        if (r==null)&#123;
            r = &quot;6&quot;;
        &#125;
        PageModel pageModel = paintingService.pagination(Integer.parseInt(p), Integer.parseInt(r));
        req.setAttribute(&quot;pageModel&quot;, pageModel);
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/list.jsp&quot;).forward(req, resp);
    &#125;
&#125;
</code></pre>
<pre><code class="html">management.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;门户数据管理平台&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0 auto;
        &#125;
        a&#123;
            text-decoration: none;
        &#125;
        .left&#123;
            float: left;
        &#125;
        .right&#123;
            float: right;
        &#125;
 
        .pg_header&#123;
            position: fixed;
            top: 0;
            width: 100%;
            height: 48px;
            background-color: lightseagreen;
            color: white;
            z-index: 10;
        &#125;
        .pg_header .logo&#123;
            height: 48px;
            width: 200px;
            text-align: center;
            color: white;
        &#125;
        .pg_header .logo a img&#123;
            height: 48px;
            width: 200px;
            cursor: pointer;
        &#125;
        .pg_header .person_info&#123;
            position: relative;
            height: 48px;
            width: 160px;
            /*text-align: center;*/
        &#125;
        .pg_header .person_info img&#123;
            border: 0;
            height: 48px;
            width: 50px;
            /*使用border-radius可以定义边框的圆角程度*/
            border-radius: 50%;
        &#125;
        .pg_header .person_info .info&#123;
            position: absolute;
            width: 150px;
            background-color: lightseagreen;
            top: 50px;
            z-index: 20;
            display: none;
        &#125;
        .pg_header .person_info .info a&#123;
            display: block;
            color: white;
            padding: 5px;
        &#125;
        .pg_header .person_info:hover .info&#123;
            display: block;
        &#125;
        .pg_header .icons&#123;
            line-height: 48px;
            padding: 0 20px 0 5px;
        &#125;
        .pg_header .icons:hover&#123;
            background-color: lightseagreen;
        &#125;
        .pg_header .icons span&#123;
            padding: 1px 5px;
            line-height: 1px;
            border-radius: 50%;
            background-color: red;
            font-size: 12px;
        &#125;
        .pg_content .menu&#123;
            position: absolute;
            top: 50px;
            left: 0;
            bottom: 0;
            width: 300px;
            border:0px;
            border-right: 1px solid #ccc;
        &#125;
        .pg_content .content&#123;
            position: absolute;
            top: 50px;
            right: 0;
            bottom: 0;
            left: 302px;
            overflow: auto;
            min-width: 980px;
            z-index: 8;
            border:0px;
            overflow: hidden;
        &#125;
        .menu_item&#123;
            display: block;
            padding: 10px 20px;
            border-bottom: 1px solid #ccc;
            font-size: 20px; 
            color: #666666;
        &#125;
        
        .menu_item:hover&#123;
            color: white;
            background: lightseagreen;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 顶端导航栏 --&gt;
    &lt;div class=&quot;pg_header&quot;&gt;
        &lt;!-- Logo与名称 --&gt;
        &lt;div class=&quot;logo left&quot;&gt;
            &lt;a href=&quot;javascript:void(0)&quot; target=&quot;_blank&quot;&gt;
                &lt;img src=&quot;image/logo_1.png&quot;&gt;    
            &lt;/a&gt;
            
        &lt;/div&gt;
        
        &lt;!-- 用户头像与菜单 --&gt;
        &lt;div class=&quot;person_info right&quot; style=&quot;vertical-align: top;&quot; &gt;
            &lt;img src=&quot;image/head.png&quot;&gt;
            &lt;span style=&quot;line-height: 50px;vertical-align: top;&quot;&gt;小企鹅&lt;/span&gt;
            &lt;div class=&quot;info&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;我的信息&lt;/a&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;修改密码&lt;/a&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;注销&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;icons right&quot;&gt;
            &lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;pg_content&quot;&gt;
        &lt;!-- 左侧功能区菜单 --&gt;
        &lt;div class=&quot;menu&quot;&gt;
            &lt;a href = &quot;#&quot; class=&quot;menu_item&quot; target=&quot;ifcontent&quot;&gt;油画列表&lt;/a&gt;
            &lt;a href = &quot;#&quot; class=&quot;menu_item&quot; target=&quot;ifcontent&quot;&gt;新增作品&lt;/a&gt;
        &lt;/div&gt;
        &lt;!-- 主体框架 --&gt;
        &lt;div class=&quot;content&quot;&gt;
             &lt;iframe name=&quot;ifcontent&quot; style=&quot;width:100%;height:100%;overflow-y: hidden;border:0px;min-width: 800px;&quot; src=&quot;&quot;&gt;&lt;/iframe&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;门户数据管理平台&lt;/title&gt;
    &lt;style&gt;
        body&#123;
            margin: 0 auto;
        &#125;
        a&#123;
            text-decoration: none;
        &#125;
        .left&#123;
            float: left;
        &#125;
        .right&#123;
            float: right;
        &#125;

        .pg_header&#123;
            position: fixed;
            top: 0;
            width: 100%;
            height: 48px;
            background-color: lightseagreen;
            color: white;
            z-index: 10;
        &#125;
        .pg_header .logo&#123;
            height: 48px;
            width: 200px;
            text-align: center;
            color: white;
        &#125;
        .pg_header .logo a img&#123;
            height: 48px;
            width: 200px;
            cursor: pointer;
        &#125;
        .pg_header .person_info&#123;
            position: relative;
            height: 48px;
            width: 160px;
            /*text-align: center;*/
        &#125;
        .pg_header .person_info img&#123;
            border: 0;
            height: 48px;
            width: 50px;
            /*使用border-radius可以定义边框的圆角程度*/
            border-radius: 50%;
        &#125;
        .pg_header .person_info .info&#123;
            position: absolute;
            width: 150px;
            background-color: lightseagreen;
            top: 50px;
            z-index: 20;
            display: none;
        &#125;
        .pg_header .person_info .info a&#123;
            display: block;
            color: white;
            padding: 5px;
        &#125;
        .pg_header .person_info:hover .info&#123;
            display: block;
        &#125;
        .pg_header .icons&#123;
            line-height: 48px;
            padding: 0 20px 0 5px;
        &#125;
        .pg_header .icons:hover&#123;
            background-color: lightseagreen;
        &#125;
        .pg_header .icons span&#123;
            padding: 1px 5px;
            line-height: 1px;
            border-radius: 50%;
            background-color: red;
            font-size: 12px;
        &#125;
        .pg_content .menu&#123;
            position: absolute;
            top: 50px;
            left: 0;
            bottom: 0;
            width: 300px;
            border:0px;
            border-right: 1px solid #ccc;
        &#125;
        .pg_content .content&#123;
            position: absolute;
            top: 50px;
            right: 0;
            bottom: 0;
            left: 302px;
            overflow: auto;
            min-width: 980px;
            z-index: 8;
            border:0px;
            overflow: hidden;
        &#125;
        .menu_item&#123;
            display: block;
            padding: 10px 20px;
            border-bottom: 1px solid #ccc;
            font-size: 20px;
            color: #666666;
        &#125;

        .menu_item:hover&#123;
            color: white;
            background: lightseagreen;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 顶端导航栏 --&gt;
&lt;div class=&quot;pg_header&quot;&gt;
    &lt;!-- Logo与名称 --&gt;
    &lt;div class=&quot;logo left&quot;&gt;
        &lt;a href=&quot;javascript:void(0)&quot; target=&quot;_blank&quot;&gt;
            &lt;img src=&quot;image/logo_1.png&quot;&gt;
        &lt;/a&gt;

    &lt;/div&gt;

    &lt;!-- 用户头像与菜单 --&gt;
    &lt;div class=&quot;person_info right&quot; style=&quot;vertical-align: top;&quot; &gt;
        &lt;img src=&quot;image/head.png&quot;&gt;
        &lt;span style=&quot;line-height: 50px;vertical-align: top;&quot;&gt;小企鹅&lt;/span&gt;
        &lt;div class=&quot;info&quot;&gt;
            &lt;a href=&quot;javascript:void(0)&quot;&gt;我的信息&lt;/a&gt;
            &lt;a href=&quot;javascript:void(0)&quot;&gt;修改密码&lt;/a&gt;
            &lt;a href=&quot;javascript:void(0)&quot;&gt;注销&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;icons right&quot;&gt;
        &lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;pg_content&quot;&gt;
    &lt;!-- 左侧功能区菜单 --&gt;
    &lt;div class=&quot;menu&quot;&gt;
        &lt;a href = &quot;/mgallery/management?method=list&quot; class=&quot;menu_item&quot; target=&quot;ifcontent&quot;&gt;油画列表&lt;/a&gt;
        &lt;a href = &quot;#&quot; class=&quot;menu_item&quot; target=&quot;ifcontent&quot;&gt;新增作品&lt;/a&gt;
    &lt;/div&gt;
    &lt;!-- 主体框架 --&gt;
    &lt;div class=&quot;content&quot;&gt;
        &lt;iframe name=&quot;ifcontent&quot; style=&quot;width:100%;height:100%;overflow-y: hidden;border:0px;min-width: 800px;&quot; src=&quot;/mgallery/management?method=list&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="利用SweetAlert实现预览功能-美观对话框"><a href="#利用SweetAlert实现预览功能-美观对话框" class="headerlink" title="利用SweetAlert实现预览功能 [美观对话框]"></a>利用SweetAlert实现预览功能 [美观对话框]</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/306de20dd228">正确使用 equals 方法避免产生空指针异常 - 简书 (jianshu.com)</a></p>
<pre><code class="jsp">list.jsp
&lt;%@page contentType = &quot;text/html;charset=utf-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;油画列表&lt;/title&gt;
    &lt;script src=&quot;js\jquery-3.4.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js\sweetalert2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\list.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //对话框显示预览 // 变成jquary对象 对自定义属性名进行提取
        function showPreview(previewObj)&#123;
            var preview = $(previewObj).attr(&quot;data-preview&quot;);
            var pname = $(previewObj).attr(&quot;data-pname&quot;);
            Swal.fire(&#123;
                title: pname,
                html : &quot;&lt;img src=&#39;&quot; + preview + &quot;&#39; style=&#39;width:361px;height:240px&#39;&gt;&quot;,
                showCloseButton: true,
                showConfirmButton: false
            &#125;)
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;fieldset&gt;
            &lt;legend&gt;油画列表&lt;/legend&gt;
            &lt;div style=&quot;height: 40px&quot;&gt;
                &lt;a href=&quot;#&quot; class=&quot;btn-button&quot;&gt;新增&lt;/a&gt;
            &lt;/div&gt;
            &lt;!-- 油画列表 --&gt;
            &lt;table cellspacing=&quot;0px&quot;&gt;
                &lt;thead&gt;
                    &lt;tr style=&quot;width: 150px;&quot;&gt;
                        &lt;th style=&quot;width: 100px&quot;&gt;分类&lt;/th&gt;
                        &lt;th style=&quot;width: 150px;&quot;&gt;名称&lt;/th&gt;
                        &lt;th style=&quot;width: 100px;&quot;&gt;价格&lt;/th&gt;
                        &lt;th style=&quot;width: 400px&quot;&gt;描述&lt;/th&gt;
                        &lt;th style=&quot;width: 100px&quot;&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;c:forEach items=&quot;$&#123;pageModel.pageData &#125;&quot; var=&quot;painting&quot;&gt;
                    &lt;tr&gt;
                        &lt;td&gt;
                            &lt;c:choose&gt;
                                &lt;c:when test=&quot;$&#123;painting.category==1 &#125;&quot;&gt;现实主义&lt;/c:when&gt;
                                &lt;c:when test=&quot;$&#123;painting.category==2 &#125;&quot;&gt;抽象主义&lt;/c:when&gt;
                                &lt;c:otherwise&gt;未知的类型&lt;/c:otherwise&gt;
                            &lt;/c:choose&gt;
                        &lt;/td&gt;
                        &lt;td&gt;$&#123;painting.pname &#125;&lt;/td&gt;
                        &lt;td&gt;&lt;fmt:formatNumber pattern=&quot;¥0.00&quot; value=&quot;$&#123;painting.price &#125;&quot;&gt;&lt;/fmt:formatNumber&gt; &lt;/td&gt;
                        &lt;td&gt;$&#123;painting.description &#125;&lt;/td&gt;
                        &lt;td&gt; &lt;!-- 自定义用 data-preview data-pname    this就是指向这个超链接的本身 --&gt;
                            &lt;a class=&quot;oplink&quot; data-preview=&quot;$&#123;painting.preview&#125;&quot; data-pname = &quot;$&#123;painting.pname&#125;&quot; href=&quot;javascript:void(0)&quot; onclick=&quot;showPreview(this)&quot;&gt;预览&lt;/a&gt;
                            &lt;a class=&quot;oplink&quot; href=&quot;#&quot;&gt;修改&lt;/a&gt;
                            &lt;a class=&quot;oplink&quot; href=&quot;#&quot;&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/c:forEach&gt;
            &lt;/table&gt;
            &lt;!-- 分页组件 --&gt;
            &lt;ul class=&quot;page&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=1&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.hasPreviousPage?pageModel.page-1:1&#125;&quot;&gt;上页&lt;/a&gt;&lt;/li&gt;
                &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageModel.totalPages &#125;&quot; step=&quot;1&quot; var=&quot;pno&quot;&gt;
                    &lt;li $&#123;pno==pageModel.page?&quot;class=&#39;active&#39;&quot;:&quot;&quot;&#125;&gt;
                        &lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pno &#125;&quot;&gt;$&#123;pno &#125;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/c:forEach&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.hasNextPage?pageModel.page+1:pageModel.totalPages&#125;&quot;&gt;下页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.totalPages&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/fieldset&gt;
    &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="处理文件上传页面-表单校验-文件上传-处理XML文件"><a href="#处理文件上传页面-表单校验-文件上传-处理XML文件" class="headerlink" title="处理文件上传页面 [表单校验 文件上传 处理XML文件]"></a>处理文件上传页面 [<u>表单校验 文件上传 处理XML文件</u>]</h3><ul>
<li>利用Apache Commons FileUpload组件实现上传功能</li>
<li>封装可重用的js脚本解决表单校验问题</li>
<li>基于Dom4j对XML文件进行追加操作</li>
</ul>
<pre><code class="jsp">create.jsp
&lt;!-- 新增油画页面 --&gt;
&lt;%@page contentType = &quot;text/html;charset=utf-8&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;新增油画&lt;/title&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\create.css&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;fieldset&gt;
            &lt;legend&gt;新增油画&lt;/legend&gt;
            &lt;form action=&quot;&quot; method=&quot;post&quot;
                autocomplete=&quot;off&quot; enctype=&quot;multipart/form-data&quot;&gt;
                &lt;ul class=&quot;ulform&quot;&gt;
                    &lt;li&gt;
                        &lt;span&gt;油画名称&lt;/span&gt;
                        &lt;span id=&quot;errPname&quot;&gt;&lt;/span&gt;
                        &lt;input id=&quot;pname&quot; name=&quot;pname&quot; /&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;span&gt;油画类型&lt;/span&gt;
                        &lt;span id=&quot;errCategory&quot;&gt;&lt;/span&gt;
                        &lt;select id=&quot;category&quot; name=&quot;category&quot;&gt;
                            &lt;option value=&quot;-1&quot;&gt;请选择油画类型&lt;/option&gt;
                            &lt;option value=&quot;1&quot;&gt;现实主义&lt;/option&gt;
                            &lt;option value=&quot;2&quot;&gt;抽象主义&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;span&gt;油画价格&lt;/span&gt;
                        &lt;span id=&quot;errPrice&quot;&gt;&lt;/span&gt;
                        &lt;input id=&quot;price&quot; name=&quot;price&quot;/&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;span&gt;作品预览&lt;/span&gt;
                        &lt;span id=&quot;errPainting&quot;&gt;&lt;/span&gt;
                        &lt;input id=&quot;painting&quot; name=&quot;painting&quot; type=&quot;file&quot; 
                            style=&quot;padding-left: 0px;&quot; accept=&quot;image/*&quot; /&gt;
                    &lt;/li&gt;

                    &lt;li&gt;
                        &lt;span&gt;详细描述&lt;/span&gt;
                        &lt;span id=&quot;errDescription&quot;&gt;&lt;/span&gt;
                        &lt;textarea
                            id=&quot;description&quot; name=&quot;description&quot;&gt;&lt;/textarea&gt;
                    &lt;/li&gt;
                    &lt;li style=&quot;text-align: center;&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn-button&quot;&gt;提交表单&lt;/button&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/form&gt;
        &lt;/fieldset&gt;
    &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">package com.example.mgallery.controller;

import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Objects;

//实现增删改查
@WebServlet(&quot;/management&quot;)
public class ManagementController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();

    public ManagementController() &#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        //通过method参数区分不同的操作
        String method = req.getParameter(&quot;method&quot;);
        if(Objects.equals(method,&quot;list&quot;)) &#123;//分页查询列表
            this.list(req,resp);
            //正确使用 equals 方法避免产生空指针异常https://www.jianshu.com/p/306de20dd228
        &#125; else if (Objects.equals(method,&quot;delete&quot;)) &#123;
            //
        &#125; else if (Objects.equals(method,&quot;show_create&quot;)) &#123;
            this.showCreatePage(req,resp); //带show的一定是跳转页面
        &#125;
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req,resp);
    &#125;

    // 控制器代码的实现
    private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String p = req.getParameter(&quot;p&quot;);
        String r = req.getParameter(&quot;r&quot;);
        if (p == null) &#123;
            p = &quot;1&quot;;
        &#125;
        if (r == null) &#123;
            r = &quot;6&quot;;
        &#125;
        //2.调用Service方法,得到处理结果      增加了按类型筛选category
        PageModel pageModel = paintingService.pagination(Integer.parseInt(p), Integer.parseInt(r));
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/list.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
    private void showCreatePage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); //请求转发
    &#125;
&#125;
</code></pre>
<h3 id="文件上传必要前提条件"><a href="#文件上传必要前提条件" class="headerlink" title="文件上传必要前提条件"></a>文件上传必要前提条件</h3><ul>
<li>form表单<span style = "color : red">method &#x3D; “<strong>post</strong>“</span> 因为二进制文件不可以放在url中传递</li>
<li>form表单<span style = "color : red">enctype &#x3D; “<strong>multipart&#x2F;form-data</strong>“</span> 允许保存二进制数据存放在请求体中发送到服务端<br><span style = "color : red">enctype&#x3D;”<strong>application&#x2F;x-www-form-urlencoded</strong>“</span> 采用url编码的方式以字符串的形式将数据保存在请求体中发送到服务器</li>
<li>form表单持有<strong>file</strong>类型input进行文件选择</li>
</ul>
<h3 id="Apache-Commons-FileUpload-简化文件上传"><a href="#Apache-Commons-FileUpload-简化文件上传" class="headerlink" title="Apache Commons FileUpload [简化文件上传]"></a>Apache Commons FileUpload [简化文件上传]</h3><h6 id="在java服务器端完成上传文件的处理"><a href="#在java服务器端完成上传文件的处理" class="headerlink" title="在java服务器端完成上传文件的处理"></a>在java服务器端完成上传文件的处理</h6><ul>
<li>FileUpload组件提供了java文件上传底层支持</li>
</ul>
<p>FileItem其本质就是对前台数据进行封装</p>
<pre><code class="java">ManagementController.java
package com.example.mgallery.controller;

import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

//实现增删改查
@WebServlet(&quot;/management&quot;)
public class ManagementController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();

    public ManagementController() &#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        //通过method参数区分不同的操作
        String method = req.getParameter(&quot;method&quot;);
        if(Objects.equals(method,&quot;list&quot;)) &#123;//分页查询列表
            this.list(req,resp);
            //正确使用 equals 方法避免产生空指针异常https://www.jianshu.com/p/306de20dd228
        &#125; else if (Objects.equals(method,&quot;delete&quot;)) &#123;
            //
        &#125; else if (Objects.equals(method,&quot;show_create&quot;)) &#123;
            this.showCreatePage(req,resp); //带show的一定是跳转页面
        &#125; else if (Objects.equals(method, &quot;create&quot;)) &#123;
            this.create(req, resp);
        &#125;
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req,resp);
    &#125;

    // 控制器代码的实现
    private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String p = req.getParameter(&quot;p&quot;);
        String r = req.getParameter(&quot;r&quot;);
        if (p == null) &#123;
            p = &quot;1&quot;;
        &#125;
        if (r == null) &#123;
            r = &quot;6&quot;;
        &#125;
        //2.调用Service方法,得到处理结果      增加了按类型筛选category
        PageModel pageModel = paintingService.pagination(Integer.parseInt(p), Integer.parseInt(r));
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/list.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
    //显示新增页面
    private void showCreatePage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); //请求转发
    &#125;
    //新增油画方法
    private void create(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        /*文件上传时的数据处理与标准表单完全不同
        String pname = req.getParameter(&quot;pname&quot;); form表单enctype = &quot;multipart/form-data&quot;运用后 无法得到字符串格式的数据
        System.out.println(pname);
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); 请求转发*/
        //1.初始化FileUpload组件 包含表单项的数据对象
        FileItemFactory factory = new DiskFileItemFactory();
        /**
         * FileItemFactory 用于将前端表单的数据转换为一个个FileItem对象
         * ServletFileUpload 是为FileUpload组件提供Java web的Http请求解析
         */
        ServletFileUpload sf = new ServletFileUpload(factory);
        //2.遍历所有FileItem
        try &#123;
            List&lt;FileItem&gt; formData = sf.parseRequest(req);//将表单数据转换为FileItem对象 和前台输入项一一对应
            //区分哪个是普通对象 哪个是文件对象
            for (FileItem fi : formData)&#123;
                if (fi.isFormField() == true)&#123;//普通输入框
                    System.out.println(&quot;普通输入项:&quot; + fi.getFieldName() + &quot;:&quot; + fi.getString(&quot;UTF-8&quot;));
                &#125;else &#123; //文件上传框
                    System.out.println(&quot;文件上传项:&quot; + fi.getFieldName()); //没有文本数值不用输出
                    //3.文件保存到服务器目录 已经确定了文件上传项
                    String path = req.getServletContext().getRealPath(&quot;/upload&quot;);
                    System.out.println(&quot;上传文件目录:&quot; + path);
//                    String fileName = &quot;test.jpg&quot;;
                    String fileName = UUID.randomUUID().toString();//随机生成文件名 根据计算机的特性 生成随机唯一字符串
                    //fi.getName()得到原始文件名, 截取最后一个&quot;.&quot;后所有字符串，例如:wxml.jpg -&gt; .jpg
                    String suffix = fi.getName().substring(fi.getName().lastIndexOf(&quot;.&quot;));
                    fi.write(new File(path, fileName + suffix)); //传入文件对象会自动的帮我们把客户端上传的文件传到服务器某个文件中
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Dom4j写操作开发流程"><a href="#Dom4j写操作开发流程" class="headerlink" title="Dom4j写操作开发流程"></a>Dom4j写操作开发流程</h3><ul>
<li>**SAXReader.read()**读取XML文件，得到Document对象</li>
<li><strong>p&#x3D;root,addElement(“painting”)</strong> - 创建新的节点</li>
<li><strong>p.addElement(“pname”)</strong> - 创建新的子节点</li>
<li><strong>document.write(writer)</strong> - 向XML写入新的节点</li>
</ul>
<pre><code class="java">请求转发
请求转发是一种服务器端的行为，通过request对象来完成操作。当客户端发送请求以后，对应的Servlet会做出业务逻辑处理，然后调用forward()方法，将请求发送到服务器中另外的Servlet中去。

实现方法：
request.getRequestDispatcher(&quot;URL地址&quot;).forward(request,response);
响应重定向
响应重定向是一种客户端的行为，通过response对象来完成操作。当客户端第一次发出请求后，服务器中Servlet接收请求以后，通过调用sendRedirect()方法指定另一个Servlet，此时客户端会根据路径再次发出请求访问下一个Servlet，服务器再次接收请求后做出响应返回给客户端。

实现方法：
response.sendRedirect(&quot;URL地址&quot;)
请求转发与响应重定向的区别
1、请求转发以后浏览器URL地址栏不变，响应重定向以后浏览器URL地址栏发生改变
2、请求转发是服务器端行为，响应重定向是客户端行为
3、请求转发只做了一次访问请求，得到一次响应；响应重定向是做了两次请求，得到两次响应
4、请求转发是在服务器内部进行的，所以不可以跨域访问；响应重定向可以做到跨域访问
5、请求转发可以使用request作用域共享数据；响应重定向不可以使用request作用域，但是可以使用session域共享资源
</code></pre>
<pre><code class="java">XmlDataSource.java[新增了append追加操作]
package com.example.mgallery.utils;

import com.example.mgallery.entity.Painting;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.*;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;

//用于将XML文件解析为Java对象
public class XmlDataSource &#123;
    //通过static静态关键字保证数据全局唯一
    private static List data = new ArrayList(); //油画集合
    private static String dataFile;

    static &#123; //程序运行以后去得到类路径目录下的/painting.xml的路径地址
        dataFile = XmlDataSource.class.getResource(&quot;/painting.xml&quot;).getPath();
        reload(); //在所有的写入操作以后都要写入
    &#125;
    private static void reload()&#123;
        //若得到特殊字符进行编码转换 空格 c:\new style\painting.xml
        try &#123;
            URLDecoder.decode(dataFile, &quot;UTF-8&quot;);
            System.out.println(dataFile);
            //利用Dom4j对XML进行解析 读取XML
            SAXReader reader = new SAXReader();
            //1.获取Document文档对象
            Document document = reader.read(dataFile);
            //2.Xpath得到XML节点集合 获取多个xml节点
            List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting&quot;);
            data.clear(); //清空 在空的数据基础上重新添加
            for (Node node : nodes) &#123;
                Element element = (Element) node;
                String id = element.attributeValue(&quot;id&quot;);//获得id
                String pname = element.elementText(&quot;pname&quot;);//获得子节点
                Painting painting = new Painting();
                painting.setId(Integer.parseInt(id));
                painting.setPname(pname);
                painting.setCategory(Integer.parseInt(element.elementText(&quot;category&quot;)));
                painting.setPrice(Integer.parseInt(element.elementText(&quot;price&quot;)));
                painting.setPreview(element.elementText(&quot;preview&quot;));
                painting.setDescription(element.elementText(&quot;description&quot;));
                data.add(painting);//将List data 保存油画的完整信息

                System.out.println(id + &quot;;&quot; + pname);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    /**
     * 获取所有油画Painting对象
     *
     * @return Painting List
     */
    public static List&lt;Painting&gt; getRawData() &#123;
        return data;
    &#125;

    //Dom4j实现XML追加操作
    public static void append(Painting painting) &#123; //末尾追加新的油画
        //1.读取XML文档，得到Document对象
        SAXReader reader = new SAXReader();
        Writer writer = null;
        try &#123;
            Document document = reader.read(dataFile);
            //2.创建新的painting节点
            Element root = document.getRootElement();//得到原始文档xml根节点 &lt;root&gt;
            Element p = root.addElement(&quot;painting&quot;);//创建一个新的子节点
            //3.创建painting节点的各个子节点
            p.addAttribute(&quot;id&quot;, String.valueOf(data.size() + 1)); //生成新的id对象
            p.addElement(&quot;pname&quot;).setText(painting.getPname()); //返回新的节点 设置其文本值
            p.addElement(&quot;category&quot;).setText(painting.getCategory().toString());
            p.addElement(&quot;price&quot;).setText(painting.getPrice().toString());
            p.addElement(&quot;preview&quot;).setText(painting.getPreview());
            p.addElement(&quot;description&quot;).setText(painting.getDescription());
            //4.写入XML，完成追加操作
            writer = new OutputStreamWriter(new FileOutputStream(dataFile), &quot;UTF-8&quot;);
            document.write(writer); //向目标dataFile原始xml中进行新节点的更新
            System.out.println(dataFile);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (writer != null) &#123; //write有开就有关 已经被实例化
                try &#123;
                    writer.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace(); //遇到异常 打印堆栈
                &#125;
            &#125;
            //清空 在空的数据基础上重新添加 无论成功与否都会重新加载数据 如果照片没找到 就清空数据
            reload();
        &#125;

    &#125;

    public static void main(String[] args) &#123;
//        new XmlDataSource();
//        List&lt;Painting&gt; ps = XmlDataSource.getRawData();
//        System.out.println(ps);
        Painting p = new Painting();
        p.setPname(&quot;油画测试&quot;);
        p.setCategory(1);
        p.setPrice(4000);
        p.setPreview(&quot;upload/10.jpg&quot;);
        p.setDescription(&quot;测试油画描述&quot;);
        XmlDataSource.append(p);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ManagementController.java[新增了create方法]
package com.example.mgallery.controller;

import com.example.mgallery.entity.Painting;
import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

//实现增删改查
@WebServlet(&quot;/management&quot;)
public class ManagementController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();

    public ManagementController() &#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        //通过method参数区分不同的操作
        String method = req.getParameter(&quot;method&quot;);
        if(Objects.equals(method,&quot;list&quot;)) &#123;//分页查询列表
            this.list(req,resp);
            //正确使用 equals 方法避免产生空指针异常https://www.jianshu.com/p/306de20dd228
        &#125; else if (Objects.equals(method,&quot;delete&quot;)) &#123;
            //
        &#125; else if (Objects.equals(method,&quot;show_create&quot;)) &#123;
            this.showCreatePage(req,resp); //带show的一定是跳转页面
        &#125; else if (Objects.equals(method, &quot;create&quot;)) &#123;
            this.create(req, resp);
        &#125;
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req,resp);
    &#125;

    // 控制器代码的实现
    private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String p = req.getParameter(&quot;p&quot;);
        String r = req.getParameter(&quot;r&quot;);
        if (p == null) &#123;
            p = &quot;1&quot;;
        &#125;
        if (r == null) &#123;
            r = &quot;6&quot;;
        &#125;
        //2.调用Service方法,得到处理结果      增加了按类型筛选category
        PageModel pageModel = paintingService.pagination(Integer.parseInt(p), Integer.parseInt(r));
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/list.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
    //显示新增页面
    private void showCreatePage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); //请求转发
    &#125;
    //新增油画方法
    private void create(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        /*文件上传时的数据处理与标准表单完全不同
        String pname = req.getParameter(&quot;pname&quot;); form表单enctype = &quot;multipart/form-data&quot;运用后 无法得到字符串格式的数据
        System.out.println(pname);
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); 请求转发*/
        //1.初始化FileUpload组件 包含表单项的数据对象
        FileItemFactory factory = new DiskFileItemFactory();
        /**
         * FileItemFactory 用于将前端表单的数据转换为一个个FileItem对象
         * ServletFileUpload 是为FileUpload组件提供Java web的Http请求解析
         */
        ServletFileUpload sf = new ServletFileUpload(factory);
        //2.遍历所有FileItem
        try &#123;
            List&lt;FileItem&gt; formData = sf.parseRequest(req);//将表单数据转换为FileItem对象 和前台输入项一一对应
            Painting painting = new Painting();//进行封装
            //区分哪个是普通对象 哪个是文件对象
            for (FileItem fi : formData)&#123;
                if (fi.isFormField() == true)&#123;//普通输入框
                    System.out.println(&quot;普通输入项:&quot; + fi.getFieldName() + &quot;:&quot; + fi.getString(&quot;UTF-8&quot;));
                    switch (fi.getFieldName()) &#123; //得到字段名
                        case &quot;pname&quot;:
                            painting.setPname(fi.getString(&quot;UTF-8&quot;));
                            break;
                        case &quot;category&quot;:
                            painting.setCategory(Integer.parseInt(fi.getString(&quot;UTF-8&quot;)));
                            break;
                        case &quot;price&quot;:
                            painting.setPrice(Integer.parseInt(fi.getString(&quot;UTF-8&quot;)));
                            break;
                        case &quot;description&quot;:
                            painting.setDescription(fi.getString(&quot;UTF-8&quot;));
                            break;
                        default:
                            break;
                    &#125;
                &#125;else &#123; //文件上传框
                    System.out.println(&quot;文件上传项:&quot; + fi.getFieldName()); //没有文本数值不用输出
                    //3.文件保存到服务器目录 已经确定了文件上传项
                    String path = req.getServletContext().getRealPath(&quot;/upload&quot;);
                    System.out.println(&quot;上传文件目录:&quot; + path);
//                    String fileName = &quot;test.jpg&quot;;
                    String fileName = UUID.randomUUID().toString();//随机生成文件名 根据计算机的特性 生成随机唯一字符串
                    //fi.getName()得到原始文件名, 截取最后一个&quot;.&quot;后所有字符串，例如:wxml.jpg -&gt; .jpg
                    String suffix = fi.getName().substring(fi.getName().lastIndexOf(&quot;.&quot;));
                    fi.write(new File(path, fileName + suffix)); //传入文件对象会自动的帮我们把客户端上传的文件传到服务器某个文件中
                    painting.setPreview(&quot;upload/&quot; + fileName + suffix); //形成一个完整的可以访问的url地址
                &#125;
            &#125;
            paintingService.create(painting); //新增功能
            //若弹出另一个页面进行另外一个操作 新页面以后的后续操作 和前面的操作紧密联系的 用请求转发 当前请求給下一个功能继续操作
            resp.sendRedirect(&quot;/mgallery/management?method=list&quot;);//响应重定向跳转列表页继续相应的处理 跟前面的新增功能联系不那么紧密
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="开发表单校验JS脚本-可重用的表单校验"><a href="#开发表单校验JS脚本-可重用的表单校验" class="headerlink" title="开发表单校验JS脚本[可重用的表单校验]"></a>开发表单校验JS脚本[可重用的表单校验]</h3><ul>
<li>以独立的js脚本文件存储可被不同表单项重用的校验规则</li>
<li>每一个校验逻辑均独立存储</li>
<li>可自定义触发时机，例如：失去焦点、选择时、提交前…</li>
</ul>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><pre><code class="html">/*
检查是否为空 input表单域选择器    errSelector错误提示选择器    true-校验成功 false-校验失败
*/
function checkEmpty(input, errSelector)&#123;
    var val = $(input).val();
    if($.trim(val)==&quot;&quot;)&#123;
        switchValid(false, input, errSelector, &quot;请输入内容&quot;)
        return false;
    &#125;else&#123;
        switchValid(true, input, errSelector);
        return true;
    &#125;
&#125;
</code></pre>
<h6 id="调用方法1-失去焦点的时候触发onblur"><a href="#调用方法1-失去焦点的时候触发onblur" class="headerlink" title="调用方法1 失去焦点的时候触发onblur"></a>调用方法1 <u>失去焦点的时候触发onblur</u></h6><pre><code class="html">&lt;span&gt;详细描述&lt;/span&gt;
&lt;span id=&quot;errDescription&quot;&gt;&lt;/span&gt;
&lt;textarea id=&quot;description&quot; name=&quot;description&quot; onblur=&quot;checkEmpty(&#39;#description&#39;,&#39;#errDescription&#39;)&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h6 id="调用方法2-在提交前组合校验"><a href="#调用方法2-在提交前组合校验" class="headerlink" title="调用方法2 在提交前组合校验"></a>调用方法2 <u>在提交前组合校验</u></h6><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;
    function checkSubmit()&#123; //提交前表单校验
        var result = true;
        var r1 = checkPname(&#39;#pname&#39;,&#39;#errPname&#39;,-1); //检查名称
        var r2 = checkCategory(&#39;#category&#39;,&#39;#errCategory&#39;); //检查分类
        var r3 = checkPrice(&#39;#price&#39;,&#39;#errPrice&#39;); //检查价格
        var r4 = checkFile(&#39;#painting&#39;, &#39;#errPainting&#39;); //检查上传文件
        var r5 = checkEmpty(&#39;#description&#39;, &#39;#errDescription&#39;); //检查描述
        if(r1 &amp;&amp; r2 &amp;&amp; r3 &amp;&amp; r4 &amp;&amp; r5)&#123;//所有检查通过允许提交表单
            return true;
        &#125;else&#123;
            return false;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<pre><code class="js">validation.js 且在create.jsp中把引用的标签打上js状态 onblur/onchange
/**
 * 隐藏、显示错误信息
 * @param onOff true 验证成功, 隐藏错误     false 校验失败，显示错误
 * @param input 表单域选择器
 * @param errSelector 错误提示选择器
 * @param message 错误信息
 * @returns
 */
function switchValid(onOff, input, errSelector, message) &#123;
    if (onOff == false) &#123;
        $(errSelector).text(message);
        $(input).addClass(&quot;error_input&quot;); //错误标红
        $(errSelector).addClass(&quot;error_message&quot;);
    &#125; else &#123;
        $(errSelector).text(&quot;&quot;);
        $(input).removeClass(&quot;error_input&quot;); //错误标红
        $(errSelector).removeClass(&quot;error_message&quot;);
    &#125;
&#125;

/**
 * 检查是否为空
 * @param input 表单域选择器
 * @param errSelector 错误提示选择器
 * @returns true-校验成功 false-校验失败
 */
function checkEmpty(input, errSelector) &#123;
    var val = $(input).val(); //获取当前选择的数值
    if ($.trim(val) == &quot;&quot;) &#123; //将字符串前后空格删掉
        switchValid(false, input, errSelector, &quot;请输入内容&quot;); //非空校验失败时显示错误
        return false;
    &#125; else &#123;
        switchValid(true, input, errSelector); //正确情况
        return true;
    &#125;
&#125;

function checkCategory(input, errSelector) &#123;
    var val = $(input).val(); //获取当前选择的数值
    if (val == -1) &#123;
        switchValid(false, input, errSelector, &quot;请选择油画类型&quot;); //非空校验失败时显示错误
        return false;
    &#125; else &#123;
        switchValid(true, input, errSelector); //正确情况
        return true;
    &#125;
&#125;

/**
 * 价格必须是整数
 * @param input 表单域选择器
 * @param errSelector 错误提示选择器
 * @returns true-校验成功 false-校验失败
 */
function checkPrice(input, errSelector) &#123;
    var val = $(input).val(); //获取当前选择的数值
    var regex = /^[1-9][0-9]*$/   //利用正则表达式进行校验信息
    if (!regex.test(val)) &#123;
        switchValid(false, input, errSelector, &quot;无效的价格&quot;); //非空校验失败时显示错误
        return false;
    &#125; else &#123;
        switchValid(true, input, errSelector); //正确情况
        return true;
    &#125;
&#125;

/**
 * 上传文件必须是图片
 * @param input 表单域选择器
 * @param errSelector 错误提示选择器
 * @returns true-校验成功 false-校验失败
 */
function checkFile(input, errSelector) &#123;
    if (checkEmpty(input, errSelector) == false) &#123;
        return false;
    &#125;
    var val = $(input).val().toLowerCase()//小写转换 PNG png
    if (val.length &lt; 4) &#123; //x.xxxx
        switchValid(false, input, errSelector, &quot;请选择有效的图片&quot;); //非空校验失败时显示错误
        return false;
    &#125;
    suffix = val.substring(val.length - 3); //拿到最后的扩展名
    if (suffix == &quot;jpg&quot; || suffix == &quot;png&quot; || suffix == &quot;gif&quot;) &#123;
        switchValid(true.input, errSelector);
        return true;
    &#125;else &#123;
        switchValid(false, input, errSelector, &quot;请选择有效的图片&quot;);
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="实现新增油画功能-表单submit全验证"><a href="#实现新增油画功能-表单submit全验证" class="headerlink" title="实现新增油画功能[表单submit全验证]"></a>实现新增油画功能[表单submit全验证]</h3><pre><code class="jsp">添加一个全局验证
create.jsp
&lt;!-- 新增油画页面 --&gt;
&lt;%@page contentType=&quot;text/html;charset=utf-8&quot; %&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;新增油画&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\create.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/validation.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function checkSubmit() &#123;
            var result = true;
            var r1 = checkEmpty(&quot;#pname&quot;, &quot;#errPname&quot;);
            var r2 = checkCategory(&#39;#category&#39;, &#39;#errCategory&#39;);
            var r3 = checkPrice(&#39;#price&#39;, &#39;#errPrice&#39;);
            var r4 = checkFile(&#39;#painting&#39;, &#39;#errPainting&#39;);
            var r5 = checkEmpty(&#39;#description&#39;, &#39;#errDescription&#39;);
            if (r1 &amp;&amp; r2 &amp;&amp; r3 &amp;&amp; r4 &amp;&amp; r5) &#123;
                return true;
            &#125;else &#123;
                return false;
            &#125;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;新增油画&lt;/legend&gt;
        &lt;form action=&quot;/mgallery/management?method=create&quot; method=&quot;post&quot;
              autocomplete=&quot;off&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;return checkSubmit()&quot;&gt;
            &lt;ul class=&quot;ulform&quot;&gt;
                &lt;li&gt;
                    &lt;span&gt;油画名称&lt;/span&gt;
                    &lt;span id=&quot;errPname&quot;&gt;&lt;/span&gt;
                    &lt;input id=&quot;pname&quot; name=&quot;pname&quot; onblur=&quot;checkEmpty(&#39;#pname&#39;,&#39;#errPname&#39;)&quot;&gt; &lt;!--在失去焦点时触发--&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;油画类型&lt;/span&gt;
                    &lt;span id=&quot;errCategory&quot;&gt;&lt;/span&gt;
                    &lt;select id=&quot;category&quot; name=&quot;category&quot; onchange=&quot;checkCategory(&#39;#category&#39;,&#39;#errCategory&#39;)&quot;&gt;
                        &lt;option value=&quot;-1&quot;&gt;请选择油画类型&lt;/option&gt;
                        &lt;option value=&quot;1&quot;&gt;现实主义&lt;/option&gt;
                        &lt;option value=&quot;2&quot;&gt;抽象主义&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;油画价格&lt;/span&gt;
                    &lt;span id=&quot;errPrice&quot;&gt;&lt;/span&gt;
                    &lt;input id=&quot;price&quot; name=&quot;price&quot; onblur=&quot;checkPrice(&#39;#price&#39;,&#39;#errPrice&#39;)&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;作品预览&lt;/span&gt;
                    &lt;span id=&quot;errPainting&quot;&gt;&lt;/span&gt;
                    &lt;input id=&quot;painting&quot; name=&quot;painting&quot; type=&quot;file&quot;
                           style=&quot;padding-left: 0px;&quot; accept=&quot;image/*&quot;
                           onchange=&quot;checkFile(&#39;#painting&#39;,&#39;#errPainting&#39;)&quot;/&gt;
                    &lt;%--    accept=&quot;image/*&quot; 默认保留所有图片格式的文件--%&gt;
                &lt;/li&gt;

                &lt;li&gt;
                    &lt;span&gt;详细描述&lt;/span&gt;
                    &lt;span id=&quot;errDescription&quot;&gt;&lt;/span&gt;
                    &lt;textarea
                            id=&quot;description&quot; name=&quot;description&quot;
                            onblur=&quot;checkEmpty(&#39;#description&#39;,&#39;#errDescription&#39;)&quot;&gt;&lt;/textarea&gt;
                &lt;/li&gt;
                &lt;li style=&quot;text-align: center;&quot;&gt;
                    &lt;button type=&quot;submit&quot; class=&quot;btn-button&quot;&gt;提交表单&lt;/button&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/form&gt;
    &lt;/fieldset&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">management.html  和  list.jsp 添加href超链接 
客户点击新增的时候可以跳转到新增页面 
&lt;a href = &quot;/mgallery/management?method=show_create&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="实现修改页表单数据回填"><a href="#实现修改页表单数据回填" class="headerlink" title="实现修改页表单数据回填"></a>实现修改页表单数据回填</h3><h5 id="修改实现思路"><a href="#修改实现思路" class="headerlink" title="修改实现思路"></a>修改实现思路</h5><ul>
<li>修改与新增的最大不同是在修改前要加载原有数据</li>
<li>在修改页面放置hidden隐藏域保存id编号，随表单提交</li>
<li>对XML更新时，先按id获取原始记录，在此基础上覆盖更新</li>
</ul>
<p>Dao service</p>
<pre><code class="java">PaintingService.java
package com.example.mgallery.service;

import com.example.mgallery.dao.PaintingDao;
import com.example.mgallery.entity.Painting;
import com.example.mgallery.utils.PageModel;

import java.util.List;
//完成业务逻辑 service与dao进行传递调用
public class PaintingService &#123;
    private PaintingDao paintingDao = new PaintingDao();
    public PageModel pagination(int page, int rows, String...category)&#123;  //最后一个是添加 可选参数(可能/不一定出现一个或多个)
        if (rows == 0)&#123;
            throw new RuntimeException(&quot;无效的rows参数&quot;);
        &#125;
        if (category.length==0 || category[0] == null)&#123;
        return paintingDao.pagination(page, rows); //调用并返回
        &#125;else &#123; //程序进行可选调用 两个不同路径 尽量不要去修改类结构
            return paintingDao.pagination(Integer.parseInt(category[0]), page, rows);
        &#125;
    &#125;

    public void create(Painting painting)&#123;
        paintingDao.create(painting);
    &#125;
    // 按编号查询油画 id油画编号 return油画对象
    public Painting findById(Integer id)&#123;
        Painting p = paintingDao.findById(id);
        if (p==null)&#123;
            throw new RuntimeException(&quot;[id=]&quot; + id + &quot;]油画不存在&quot;);
        &#125;
        return p;
    &#125;

    public static void main(String[] args) &#123;
        PaintingService paintingService = new PaintingService();
        PageModel pageModel = paintingService.pagination(2, 6);//每页显示六条
        List&lt;Painting&gt; paintingList = pageModel.getPageData();
        for (Painting painting : paintingList)&#123;
            System.out.println(painting.getPname());
        &#125;
        System.out.println(pageModel.getPageStartRow() + &quot;:&quot; + pageModel.getPageEndRow());

    &#125;
&#125;
</code></pre>
<pre><code class="java">update.jsp
&lt;%@page contentType=&quot;text/html;charset=utf-8&quot; %&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;
&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;
&lt;!-- 修改油画页面 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;作品更新&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css\create.css&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/validation.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        &lt;!-- 提交前表单校验 --&gt;
        function checkSubmit() &#123;
            var result = true;
            var r1 = checkEmpty(&quot;#pname&quot;, &quot;#errPname&quot;);
            var r2 = checkCategory(&#39;#category&#39;, &#39;#errCategory&#39;);
            var r3 = checkPrice(&#39;#price&#39;, &#39;#errPrice&#39;);
            var r4 = checkFile(&#39;#painting&#39;, &#39;#errPainting&#39;);
            var r5 = checkEmpty(&#39;#description&#39;, &#39;#errDescription&#39;);
            if (r1 &amp;&amp; r2 &amp;&amp; r3 &amp;&amp; r4 &amp;&amp; r5) &#123;
                return true;
            &#125; else &#123;
                return false;
            &#125;
        &#125;
        //整个html被解析完后执行代码
        $(function()&#123;//前面的被html解释完才执行 后面的EL表达式jsp渲染在服务器端产生 油画类型默认产生
            $(&quot;#category&quot;).val($&#123;painting.category&#125;)
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;作品名称&lt;/legend&gt;
        &lt;form action=&quot;[这里写更新URL]&quot; method=&quot;post&quot;
              autocomplete=&quot;off&quot; enctype=&quot;multipart/form-data&quot;
              onsubmit=&quot;return checkSubmit()&quot;&gt;
            &lt;ul class=&quot;ulform&quot;&gt;
                &lt;li&gt;
                    &lt;span&gt;油画名称&lt;/span&gt;
                    &lt;span id=&quot;errPname&quot;&gt;&lt;/span&gt;
                    &lt;input id=&quot;pname&quot; name=&quot;pname&quot; onblur=&quot;checkEmpty(&#39;#pname&#39;,&#39;#errPname&#39;)&quot; value=&quot;$&#123;painting.pname&#125;&quot;/&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;油画类型&lt;/span&gt;
                    &lt;span id=&quot;errCategory&quot;&gt;&lt;/span&gt;
                    &lt;select id=&quot;category&quot; name=&quot;category&quot; onchange=&quot;checkCategory(&#39;#category&#39;,&#39;#errCategory&#39;)&quot;
                            value=&quot;$&#123;painting.category&#125;&quot;&gt;
                        &lt;option value=&quot;-1&quot;&gt;请选择油画类型&lt;/option&gt;
                        &lt;option value=&quot;1&quot;&gt;现实主义&lt;/option&gt;
                        &lt;option value=&quot;2&quot;&gt;抽象主义&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;油画价格&lt;/span&gt;
                    &lt;span id=&quot;errPrice&quot;&gt;&lt;/span&gt;
                    &lt;input id=&quot;price&quot; name=&quot;price&quot; onblur=&quot;checkPrice(&#39;#price&#39;,&#39;#errPrice&#39;)&quot; value=&quot;$&#123;painting.price&#125;&quot;/&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;span&gt;作品预览&lt;/span&gt;
                        &lt;span id=&quot; errPainting&quot;&gt;&lt;/span&gt;&lt;br/&gt;
                    &lt;img id=&quot;preview&quot; src=&quot;$&#123;painting.preview&#125;&quot; style=&quot;width:361px;height:240px&quot;/&gt;&lt;br/&gt;
                    &lt;input id=&quot;painting&quot; name=&quot;painting&quot; type=&quot;file&quot; style=&quot;padding-left:0px;&quot; accept=&quot;image/*&quot;/&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;span&gt;详细描述&lt;/span&gt;
                    &lt;span id=&quot;errDescription&quot;&gt;&lt;/span&gt;
                    &lt;textarea
                            id=&quot;description&quot; name=&quot;description&quot;
                            onblur=&quot;checkEmpty(&#39;#description&#39;,&#39;#errDescription&#39;)&quot;
                    &gt;
                        $&#123;painting.description&#125;
                    &lt;/textarea&gt;
                &lt;/li&gt;
                &lt;li style=&quot;text-align: center;&quot;&gt;
                    &lt;button type=&quot;submit&quot; class=&quot;btn-button&quot;&gt;提交表单&lt;/button&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/form&gt;
    &lt;/fieldset&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">ManagmentController.java
package com.example.mgallery.controller;

import com.example.mgallery.entity.Painting;
import com.example.mgallery.service.PaintingService;
import com.example.mgallery.utils.PageModel;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

//实现增删改查
@WebServlet(&quot;/management&quot;)
public class ManagementController extends HttpServlet &#123;
    private PaintingService paintingService = new PaintingService();

    public ManagementController() &#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        //通过method参数区分不同的操作
        String method = req.getParameter(&quot;method&quot;);
        if(Objects.equals(method,&quot;list&quot;)) &#123;//分页查询列表
            this.list(req,resp);
            //正确使用 equals 方法避免产生空指针异常https://www.jianshu.com/p/306de20dd228
        &#125; else if (Objects.equals(method,&quot;delete&quot;)) &#123;
            //
        &#125; else if (Objects.equals(method,&quot;show_create&quot;)) &#123;
            this.showCreatePage(req,resp); //带show的一定是跳转页面
        &#125; else if (Objects.equals(method, &quot;create&quot;)) &#123;
            this.create(req, resp);
        &#125; else if (Objects.equals(method,&quot;show_update&quot;)) &#123;
            this.showUpdatePage(req, resp);
        &#125;
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req,resp);
    &#125;

    // 控制器代码的实现
    private void list(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String p = req.getParameter(&quot;p&quot;);
        String r = req.getParameter(&quot;r&quot;);
        if (p == null) &#123;
            p = &quot;1&quot;;
        &#125;
        if (r == null) &#123;
            r = &quot;6&quot;;
        &#125;
        //2.调用Service方法,得到处理结果      增加了按类型筛选category
        PageModel pageModel = paintingService.pagination(Integer.parseInt(p), Integer.parseInt(r));
        req.setAttribute(&quot;pageModel&quot;,pageModel);//数据解耦最关键的一步
        //3.请求转发至对应JSP(view)进行数据展现
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/list.jsp&quot;).forward(req,resp); //跳转jsp
    &#125;
    //显示新增页面
    private void showCreatePage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); //请求转发
    &#125;
    //新增油画方法
    private void create(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        /*文件上传时的数据处理与标准表单完全不同
        String pname = req.getParameter(&quot;pname&quot;); form表单enctype = &quot;multipart/form-data&quot;运用后 无法得到字符串格式的数据
        System.out.println(pname);
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/create.jsp&quot;).forward(req, resp); 请求转发*/
        //1.初始化FileUpload组件 包含表单项的数据对象
        FileItemFactory factory = new DiskFileItemFactory();
        /**
         * FileItemFactory 用于将前端表单的数据转换为一个个FileItem对象
         * ServletFileUpload 是为FileUpload组件提供Java web的Http请求解析
         */
        ServletFileUpload sf = new ServletFileUpload(factory);
        //2.遍历所有FileItem
        try &#123;
            List&lt;FileItem&gt; formData = sf.parseRequest(req);//将表单数据转换为FileItem对象 和前台输入项一一对应
            Painting painting = new Painting();//进行封装
            //区分哪个是普通对象 哪个是文件对象
            for (FileItem fi : formData)&#123;
                if (fi.isFormField() == true)&#123;//普通输入框
                    System.out.println(&quot;普通输入项:&quot; + fi.getFieldName() + &quot;:&quot; + fi.getString(&quot;UTF-8&quot;));
                    switch (fi.getFieldName()) &#123; //得到字段名
                        case &quot;pname&quot;:
                            painting.setPname(fi.getString(&quot;UTF-8&quot;));
                            break;
                        case &quot;category&quot;:
                            painting.setCategory(Integer.parseInt(fi.getString(&quot;UTF-8&quot;)));
                            break;
                        case &quot;price&quot;:
                            painting.setPrice(Integer.parseInt(fi.getString(&quot;UTF-8&quot;)));
                            break;
                        case &quot;description&quot;:
                            painting.setDescription(fi.getString(&quot;UTF-8&quot;));
                            break;
                        default:
                            break;
                    &#125;
                &#125;else &#123; //文件上传框
                    System.out.println(&quot;文件上传项:&quot; + fi.getFieldName()); //没有文本数值不用输出
                    //3.文件保存到服务器目录 已经确定了文件上传项
                    String path = req.getServletContext().getRealPath(&quot;/upload&quot;);
                    System.out.println(&quot;上传文件目录:&quot; + path);
//                    String fileName = &quot;test.jpg&quot;;
                    String fileName = UUID.randomUUID().toString();//随机生成文件名 根据计算机的特性 生成随机唯一字符串
                    //fi.getName()得到原始文件名, 截取最后一个&quot;.&quot;后所有字符串，例如:wxml.jpg -&gt; .jpg
                    String suffix = fi.getName().substring(fi.getName().lastIndexOf(&quot;.&quot;));
                    fi.write(new File(path, fileName + suffix)); //传入文件对象会自动的帮我们把客户端上传的文件传到服务器某个文件中
                    painting.setPreview(&quot;upload/&quot; + fileName + suffix); //形成一个完整的可以访问的url地址
                &#125;
            &#125;
            paintingService.create(painting); //新增功能
            //若弹出另一个页面进行另外一个操作 新页面以后的后续操作 和前面的操作紧密联系的 用请求转发 当前请求給下一个功能继续操作
            resp.sendRedirect(&quot;/mgallery/management?method=list&quot;);//响应重定向跳转列表页继续相应的处理 跟前面的新增功能联系不那么紧密
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    //显示更新页面
    private void showUpdatePage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String id = req.getParameter(&quot;id&quot;);//前台传来的id号
        Painting painting = paintingService.findById(Integer.parseInt(id));
        req.setAttribute(&quot;painting&quot;, painting); //将得到的放入其中
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/update.jsp&quot;).forward(req,resp);
    &#125;
&#125;
</code></pre>
<pre><code class="jsp">list.jsp
&lt;ul class=&quot;page&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=1&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.hasPreviousPage?pageModel.page-1:1&#125;&quot;&gt;上页&lt;/a&gt;&lt;/li&gt;
                &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageModel.totalPages &#125;&quot; step=&quot;1&quot; var=&quot;pno&quot;&gt;
                    &lt;li $&#123;pno==pageModel.page?&quot;class=&#39;active&#39;&quot;:&quot;&quot;&#125;&gt;
                        &lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pno &#125;&quot;&gt;$&#123;pno &#125;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/c:forEach&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.hasNextPage?pageModel.page+1:pageModel.totalPages&#125;&quot;&gt;下页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;/mgallery/management?method=list&amp;p=$&#123;pageModel.totalPages&#125;&quot;&gt;尾页&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
</code></pre>
<h3 id="利用Dom4j对XML进行更新"><a href="#利用Dom4j对XML进行更新" class="headerlink" title="利用Dom4j对XML进行更新"></a>利用Dom4j对XML进行更新</h3><pre><code class="java">XmlDataSource.java
package com.example.mgallery.utils;

import com.example.mgallery.entity.Painting;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.*;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;

//用于将XML文件解析为Java对象
public class XmlDataSource &#123;
    //通过static静态关键字保证数据全局唯一
    private static List data = new ArrayList(); //油画集合
    private static String dataFile;

    static &#123; //程序运行以后去得到类路径目录下的/painting.xml的路径地址
        dataFile = XmlDataSource.class.getResource(&quot;/painting.xml&quot;).getPath();
        reload(); //在所有的写入操作以后都要写入
    &#125;
    private static void reload()&#123;
        //若得到特殊字符进行编码转换 空格 c:\new style\painting.xml
        try &#123;
            URLDecoder.decode(dataFile, &quot;UTF-8&quot;);
            System.out.println(dataFile);
            //利用Dom4j对XML进行解析 读取XML
            SAXReader reader = new SAXReader();
            //1.获取Document文档对象
            Document document = reader.read(dataFile);
            //2.Xpath得到XML节点集合 获取多个xml节点
            List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting&quot;);
            data.clear(); //清空 在空的数据基础上重新添加
            for (Node node : nodes) &#123;
                Element element = (Element) node;
                String id = element.attributeValue(&quot;id&quot;);//获得id
                String pname = element.elementText(&quot;pname&quot;);//获得子节点
                Painting painting = new Painting();
                painting.setId(Integer.parseInt(id));
                painting.setPname(pname);
                painting.setCategory(Integer.parseInt(element.elementText(&quot;category&quot;)));
                painting.setPrice(Integer.parseInt(element.elementText(&quot;price&quot;)));
                painting.setPreview(element.elementText(&quot;preview&quot;));
                painting.setDescription(element.elementText(&quot;description&quot;));
                data.add(painting);//将List data 保存油画的完整信息

                System.out.println(id + &quot;;&quot; + pname);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    /**
     * 获取所有油画Painting对象
     *
     * @return Painting List
     */
    public static List&lt;Painting&gt; getRawData() &#123;
        return data;
    &#125;

    //Dom4j实现XML追加操作
    public static void append(Painting painting) &#123; //末尾追加新的油画
        //1.读取XML文档，得到Document对象
        SAXReader reader = new SAXReader();
        Writer writer = null;
        try &#123;
            Document document = reader.read(dataFile);
            //2.创建新的painting节点
            Element root = document.getRootElement();//得到原始文档xml根节点 &lt;root&gt;
            Element p = root.addElement(&quot;painting&quot;);//创建一个新的子节点
            //3.创建painting节点的各个子节点
            p.addAttribute(&quot;id&quot;, String.valueOf(data.size() + 1)); //生成新的id对象
            p.addElement(&quot;pname&quot;).setText(painting.getPname()); //返回新的节点 设置其文本值
            p.addElement(&quot;category&quot;).setText(painting.getCategory().toString());
            p.addElement(&quot;price&quot;).setText(painting.getPrice().toString());
            p.addElement(&quot;preview&quot;).setText(painting.getPreview());
            p.addElement(&quot;description&quot;).setText(painting.getDescription());
            //4.写入XML，完成追加操作
            writer = new OutputStreamWriter(new FileOutputStream(dataFile), &quot;UTF-8&quot;);
            document.write(writer); //向目标dataFile原始xml中进行新节点的更新
            System.out.println(dataFile);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (writer != null) &#123; //write有开就有关 已经被实例化
                try &#123;
                    writer.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace(); //遇到异常 打印堆栈
                &#125;
            &#125;
            //清空 在空的数据基础上重新添加 无论成功与否都会重新加载数据 如果照片没找到 就清空数据
            reload();
        &#125;

    &#125;

    public static void main(String[] args) &#123;
//        new XmlDataSource();
//        List&lt;Painting&gt; ps = XmlDataSource.getRawData();
//        System.out.println(ps);
        Painting p = new Painting();
        p.setPname(&quot;油画测试&quot;);
        p.setCategory(1);
        p.setPrice(4000);
        p.setPreview(&quot;upload/10.jpg&quot;);
        p.setDescription(&quot;测试油画描述&quot;);
        XmlDataSource.append(p);
    &#125;

    /**
     * 更新对应id的XML油画数据
     * @param painting 要更新的油画数据
     * @throws IOException
     */
    public static void update(Painting painting)&#123;
        SAXReader reader = new SAXReader();
        Writer writer = null;
        try &#123;
            Document document = reader.read(dataFile);
            //节点路径[@属性名=属性值]
            // /root/paintin[@id=x]  根节点
            List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + painting.getId() + &quot;]&quot;);
            if (nodes.size() == 0)&#123;
                throw new RuntimeException(&quot;id=&quot; + painting.getId() + &quot;编号油画不存在&quot;);
            &#125;
            Element p = (Element) nodes.get(0); //唯一的节点提取出来
            p.selectSingleNode(&quot;pname&quot;).setText(painting.getPname()); //得到指定标签名的唯一节点 指定油画更新id操作
            p.selectSingleNode(&quot;category&quot;).setText(painting.getCategory().toString());
            p.selectSingleNode(&quot;price&quot;).setText(painting.getPrice().toString());
            p.selectSingleNode(&quot;preview&quot;).setText(painting.getPreview());
            p.selectSingleNode(&quot;description&quot;).setText(painting.getDescription());
            writer = new OutputStreamWriter(new FileOutputStream(dataFile),&quot;UTF-8&quot;);
            document.write(writer);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            if (writer != null)&#123;
                try &#123;
                    writer.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            reload(); //对原始集合进行重载更新
        &#125;
    &#125;

    /**
     * 按id号删除XML油画数据
     * @param id 油画id
     * @throws IOException
     */

    public static void delete(Integer id) &#123;
        SAXReader reader = new SAXReader();
        Writer writer = null;
        try &#123;
            Document document = reader.read(dataFile);
            List&lt;Node&gt; nodes = document.selectNodes(&quot;/root/painting[@id=&quot; + id + &quot;]&quot;);
            if(nodes.size() == 0) &#123;
                throw new RuntimeException(&quot;id=&quot; + id + &quot;编号油画不存在&quot;);
            &#125;
            Element p = (Element)nodes.get(0);
            p.getParent().remove(p);
            writer = new OutputStreamWriter(new FileOutputStream(dataFile),&quot;UTF-8&quot;);
            document.write(writer);
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; finally &#123;
            if(writer!=null) &#123;
                try &#123;
                    writer.close();
                &#125; catch (IOException e) &#123;
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                &#125;
            &#125;
            reload();
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><p>CRUD增删改查</p>
<h5 id="工程结构-1"><a href="#工程结构-1" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">mgallery - eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构-src目录下-根据MVC进行结构划分"><a href="#包结构-src目录下-根据MVC进行结构划分" class="headerlink" title="包结构[src目录下 根据MVC进行结构划分]"></a>包结构[src目录下 根据MVC进行结构划分]</h5><pre><code class="java">com.imooc.mgallery //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h3 id="Dao类-Data-Access-Object-1"><a href="#Dao类-Data-Access-Object-1" class="headerlink" title="Dao类[Data Access Object]"></a>Dao类[Data Access Object]</h3><ul>
<li>XxxDao类只负责对数据进行读取、写入操作</li>
<li>只负责对数据 <strong>增、删、改、查</strong></li>
</ul>
<pre><code class="java">示例：PaintingDao //针对油画数据进行增删改查
public class PaintingDao&#123;
    public void append()&#123;...&#125; //新增数据
    public void update()&#123;...&#125; //修改数据
    public void delete()&#123;...&#125; //删除数据
    public void findAll()&#123;...&#125; //查询数据
&#125;
</code></pre>
<h3 id="Service与Dao的关系-1"><a href="#Service与Dao的关系-1" class="headerlink" title="Service与Dao的关系"></a>Service与Dao的关系</h3><ul>
<li>Service负责进行流程处理，需**持久化[java处理在内存中 存储在数据库防止丢失]**时调用Dao</li>
<li>Dao只负责单纯对数据进行<strong>增删改查</strong>操作</li>
<li>Service允许单向调用Dao，反向不允许</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a55433ae2d4814ee86fd799f7fd9f9279280c84/data/MVC%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F.jpg"></p>
<h3 id="JavaBean-1"><a href="#JavaBean-1" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul>
<li><p>对一种类的使用形式的统称</p>
</li>
<li><p>JavaBean是一种Java中可重用组件</p>
</li>
<li><p>JavaBean不是技术，而是一种Java类的格式要求</p>
</li>
<li><p>JavaBean在Java领域非常常见，通常用于存储数据</p>
</li>
</ul>
<h3 id="JavaBean格式要求-1"><a href="#JavaBean格式要求-1" class="headerlink" title="JavaBean格式要求"></a>JavaBean格式要求</h3><ul>
<li>类必须是pubilc并提供默认构造函数</li>
<li>所有属性private私有化</li>
<li>属性通过getter与setter方法进行读写</li>
</ul>
<pre><code class="java">public class Painting&#123;//类公有化
    public Painting()&#123;...&#125;; //提供默认构造函数，可不写
    private Integer id; //属性私有
    private String pname;
    public Integer getId()&#123;return id;&#125; //getter获取属性值
    public void setId(Integer id)&#123;this.id = id;&#125; //setter设置属性值
    public String getPname()&#123;return pname;&#125;
    public void setPname(String pname)&#123;this.pname = pname;&#125;
&#125;
</code></pre>
<h3 id="创建mgallery工程-实现思路"><a href="#创建mgallery工程-实现思路" class="headerlink" title="创建mgallery工程 实现思路"></a>创建mgallery工程 实现思路</h3><ul>
<li>开发PaintingDao读取XML数据，实现分页操作</li>
<li>开发PaintingService服务类，对PaintingDao进行调用</li>
<li>开发PaintingController控制器，调用PaintingService</li>
<li>重写index.html，利用JSP技术读取分页数据</li>
</ul>
<h3 id="关键类与方法-对于前台来说"><a href="#关键类与方法-对于前台来说" class="headerlink" title="关键类与方法[对于前台来说]"></a>关键类与方法[对于前台来说]</h3><ul>
<li><strong>XmlDataSource</strong>类[全局有且只有一份数据保存在内存中] - XML数据源工具类，简化Dao提取操作</li>
<li><strong>PaintingDao.pagination()</strong> - 数据分页查询方法</li>
<li><strong>PageModel</strong>类 - 分页结果的包装类 {分页处理的核心对象}</li>
</ul>
<h3 id="Dom4j-1"><a href="#Dom4j-1" class="headerlink" title="Dom4j"></a>Dom4j</h3><ul>
<li>Dom4j是一个易用的、开源的库，用于解析XML。它应用于Java平台</li>
<li>Dom4j将<strong>XML</strong>视为<strong>Document</strong>对象</li>
<li>XML标签被Dom4j定义为Element对象</li>
</ul>
<h3 id="Dom4j开发流程回顾-1"><a href="#Dom4j开发流程回顾-1" class="headerlink" title="Dom4j开发流程回顾"></a>Dom4j开发流程回顾</h3><ul>
<li>SAXReader.read()读取XML文件，得到Document对象</li>
<li>document.selectNodes()利用Xpath得到XML节点集合</li>
<li>遍历XML节点，包装成JavaBean或者集合对象返回</li>
</ul>
<h3 id="开发XmlDataSource-utils-1"><a href="#开发XmlDataSource-utils-1" class="headerlink" title="开发XmlDataSource (utils)"></a>开发XmlDataSource (utils)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/5e39cc02ef84b0ba617ad43f8f6b0e3462a002a5/data/XmlDataSource%E5%8E%9F%E7%90%86.jpg"></p>
<h3 id="油画数据分页设计思路-1"><a href="#油画数据分页设计思路-1" class="headerlink" title="油画数据分页设计思路"></a>油画数据分页设计思路</h3><p>​      [视图                     控制器                                                    模型]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/77cb566085a49c9dd441edb8816b96adf848dbd2/data/%E6%B2%B9%E7%94%BB%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.png"></p>
<p>浏览器会发送请求查询指定的数据 PaintingController得到分页信息以后 再调用PaintingService 再调用PaintingDao 首先从PaintingDao调用XmlDataSource得到xml所有数据集合传入到PageModel进行分页 再返回PaintingDao-PaintingService-PaintingController放在当前的请求中，将请求跳转至index.jsp对数据进行渲染返回浏览器。</p>
<h3 id="前台系统与后台系统区别"><a href="#前台系统与后台系统区别" class="headerlink" title="前台系统与后台系统区别"></a>前台系统与后台系统区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">前台系统</th>
<th align="center">后台系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开放度</td>
<td align="center">对外开放</td>
<td align="center">不对外开放</td>
</tr>
<tr>
<td align="center">面向群体</td>
<td align="center">客户</td>
<td align="center">企业内部人员</td>
</tr>
<tr>
<td align="center">功能</td>
<td align="center">提供查询与交互</td>
<td align="center">管理前台数据</td>
</tr>
<tr>
<td align="center">设计侧重点</td>
<td align="center">良好的用户体验</td>
<td align="center">严密的业务逻辑</td>
</tr>
<tr>
<td align="center">访问量</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">典型案例</td>
<td align="center">猫眼电影网 [<u>后台有评论审核系统</u>]</td>
<td align="center">XX公司无纸质化办公OA系统</td>
</tr>
</tbody></table>
<h5 id="后台实现功能-1"><a href="#后台实现功能-1" class="headerlink" title="后台实现功能"></a>后台实现功能</h5><p><strong><u>油画列表  油画预览  删除油画  修改油画  新增与上传油画</u></strong> </p>
<h3 id="SweetAlert对话框"><a href="#SweetAlert对话框" class="headerlink" title="SweetAlert对话框"></a>SweetAlert对话框</h3><p>替代了传统的<strong>alert</strong>函数 有精心设计的对话框</p>
<h3 id="新增功能实现难点"><a href="#新增功能实现难点" class="headerlink" title="新增功能实现难点"></a>新增功能实现难点</h3><p><strong>表单校验、文件上传、处理XML文件</strong></p>
<h6 id="文件上传：Apache-Commons-FileUpload"><a href="#文件上传：Apache-Commons-FileUpload" class="headerlink" title="文件上传：Apache Commons FileUpload"></a>文件上传：Apache Commons FileUpload</h6><p>文件上传必要前提条件</p>
<h3 id="文件上传必要前提条件-1"><a href="#文件上传必要前提条件-1" class="headerlink" title="文件上传必要前提条件"></a>文件上传必要前提条件</h3><ul>
<li>form表单<span style = "color : red">method &#x3D; “<strong>post</strong>“</span> 因为二进制文件不可以放在url中传递</li>
<li>form表单<span style = "color : red">enctype &#x3D; “<strong>multipart&#x2F;form-data</strong>“</span> 允许保存二进制数据存放在请求体中发送到服务端<br><span style = "color : red">enctype&#x3D;”<strong>application&#x2F;x-www-form-urlencoded</strong>“</span> 采用url编码的方式以字符串的形式将数据保存在请求体中发送到服务器</li>
<li>form表单持有<strong>file</strong>类型input进行文件选择</li>
</ul>
<p>&#x2F;&#x2F;1.初始化FileUpload组件 包含表单项的数据对象 每个输入项解析成FileItem<br>&#x2F;&#x2F;2.ServletFileUpload* *是为<strong>FileUpload</strong>组件提供<strong>Java web</strong>的<strong>Http</strong>请求解析 将factory传入<br>&#x2F;&#x2F;3.遍历所有FileItem 判断各种框 isFormField(true&#x2F;false)来走是普通框还是文件框  文件框先把文件保存到服务器 UUID使文件名不重复</p>
<h3 id="可重用的表单js"><a href="#可重用的表单js" class="headerlink" title="可重用的表单js"></a>可重用的表单js</h3><p>封装成JavaScript函数 在validation.js中呈现 可以自定义触发条件 别忘了还有个全局触发条件function写上面</p>
<h3 id="实现新增油画功能"><a href="#实现新增油画功能" class="headerlink" title="实现新增油画功能"></a>实现新增油画功能</h3><h6 id="在xml中执行写入操作-利用Dom4j写操作开发"><a href="#在xml中执行写入操作-利用Dom4j写操作开发" class="headerlink" title="在xml中执行写入操作 利用Dom4j写操作开发"></a>在xml中执行写入操作 利用Dom4j写操作开发</h6><ul>
<li>SAXReader.read()读取XML文件，得到Document对象</li>
<li>p&#x3D;root.addElement(“painting”) - 创建新的节点</li>
<li>p.addElement(“pname”) - 创建新的子节点</li>
<li>document.write(write) - 向XML写入新的节点</li>
</ul>
<h3 id="实现修改与删除功能"><a href="#实现修改与删除功能" class="headerlink" title="实现修改与删除功能"></a>实现修改与删除功能</h3><h6 id="所有更新逻辑都是在原始数据基础上覆盖更新，通过id号得到原始的旧数据，对旧的对象进行update"><a href="#所有更新逻辑都是在原始数据基础上覆盖更新，通过id号得到原始的旧数据，对旧的对象进行update" class="headerlink" title="所有更新逻辑都是在原始数据基础上覆盖更新，通过id号得到原始的旧数据，对旧的对象进行update"></a>所有更新逻辑都是在原始数据基础上覆盖更新，通过id号得到原始的旧数据，对旧的对象进行update</h6><p>客户端采用<strong>Ajax</strong>方式提交<strong>Http</strong>请求<br><strong>Controller</strong>方法处理后不再跳转任何<strong>jsp</strong>，而是<span style = "color:red">通过响应输出<strong>JSON</strong>格式字符串</span><br>Tips：作为<strong>Ajax</strong>与服务器交互后，得到的不是整页<strong>HTML</strong>，而是服务器处理后的数据</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/10/01/后端/油画项目-介于JavaWeb与数据库之间/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/09/20/后端/JSON,JQuery,Ajax,Freemarker,百度Echarts,正则表达,过滤器,监听与实践/">
        <h2>
            JSON,JQuery,Ajax,Freemarker,百度Echarts,正则表达,过滤器,监听与实践
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/9/20
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="JSON-JavaScript-Object-Notation-JavaScript对象表示法"><a href="#JSON-JavaScript-Object-Notation-JavaScript对象表示法" class="headerlink" title="JSON (JavaScript Object Notation) [JavaScript对象表示法]"></a>JSON (JavaScript Object Notation) [JavaScript对象表示法]</h4><ul>
<li>掌握JSON语法的书写规则</li>
<li>掌握JSON与JavaScript的交互技巧</li>
<li>掌握JSON与Java之间的序列化与反序列化</li>
</ul>
<p>JSON是轻量级的文本数据交换格式，独立于语言，具有自我描述性，更易理解，已经逐渐替代了XML</p>
<pre><code class="json">&#123;
    &quot;sites&quot;:[
        &#123;&quot;name&quot;:&quot;慕课网&quot;,&quot;url&quot;:&quot;www.imooc.com&quot;&#125;,
        &#123;&quot;name&quot;:&quot;百度&quot;,&quot;url&quot;:&quot;www.baidu.com&quot;&#125;
    ]
&#125;
</code></pre>
<h3 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h3><ul>
<li>数据由键(key)&#x2F;值(value)描述，由逗号分隔</li>
<li>大括号代表一个完整的对象，拥有多个键&#x2F;值对</li>
<li>中括号保存数组，多个对象之间使用逗号分割</li>
</ul>
<p>所有的key和value都要用双引号进行标注</p>
<h3 id="JSON存储员工信息"><a href="#JSON存储员工信息" class="headerlink" title="JSON存储员工信息"></a>JSON存储员工信息</h3><pre><code class="json">[
  &#123;
    &quot;empno&quot;: 7369,
    &quot;ename&quot;: &quot;李宁&quot;,
    &quot;job&quot;: &quot;软件工程师&quot;,
    &quot;hiredate&quot;: &quot;2017-05-12&quot;,
    &quot;salary&quot;: 13000,
    &quot;dname&quot;: &quot;研发部&quot;
  &#125;,
  &#123;
    &quot;empno&quot;: 8848,
    &quot;ename&quot;: &quot;小明&quot;,
    &quot;job&quot;: &quot;销售总监&quot;,
    &quot;hiredate&quot;: &quot;2022-4-23&quot;,
    &quot;salary&quot;: 8000,
    &quot;dname&quot;: &quot;人事部&quot;,
    &quot;customers&quot;: [
      &#123;
        &quot;cname&quot;: &quot;李东&quot;
      &#125;,
      &#123;
        &quot;cname&quot;: &quot;刘楠&quot;
      &#125;
    ]
  &#125;
]
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var json = [
            &#123;
                &quot;empno&quot;: 7369,
                &quot;ename&quot;: &quot;李宁&quot;,
                &quot;job&quot;: &quot;软件工程师&quot;,
                &quot;hiredate&quot;: &quot;2017-05-12&quot;,
                &quot;salary&quot;: 13000,
                &quot;dname&quot;: &quot;研发部&quot;
            &#125;,
            &#123;
                &quot;empno&quot;: 8848,
                &quot;ename&quot;: &quot;小明&quot;,
                &quot;job&quot;: &quot;销售总监&quot;,
                &quot;hiredate&quot;: &quot;2022-4-23&quot;,
                &quot;salary&quot;: 8000,
                &quot;dname&quot;: &quot;人事部&quot;,
                &quot;customers&quot;: [
                    &#123;
                        &quot;cname&quot;: &quot;李东&quot;
                    &#125;,
                    &#123;
                        &quot;cname&quot;: &quot;刘楠&quot;
                    &#125;
                ]
            &#125;
        ];
        //在浏览器控制台中对json内容进行输出
        console.log(json);
        for (var i = 0; i &lt; json.length; i++)&#123;
            var emp = json[i];
            document.write(&quot;&lt;h1&gt;&quot;);
            document.write(emp.empno);
            document.write(&quot;,&quot; + emp.ename);
            document.write(&quot;,&quot; + emp.job);
            document.write(&quot;,&quot; + emp.hiredate);
            document.write(&quot;,&quot; + emp.salary);
            document.write(&quot;,&quot; + emp.dname);
            document.write(&quot;&lt;/h1&gt;&quot;);
            if (emp.customers != null)&#123;
                document.write(&quot;&lt;h2&gt;&quot;+emp.ename+&quot;的顾客是&quot;)
                for (var j = 0; j &lt; emp.customers.length; j++)&#123;
                    var customer = emp.customers[j];
                    document.write(customer.cname + &quot;,&quot;);
                &#125;
                document.write(&quot;&lt;/h2&gt;&quot;);
            &#125;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JSON与字符串相互转换"><a href="#JSON与字符串相互转换" class="headerlink" title="JSON与字符串相互转换"></a>JSON与字符串相互转换</h3><ul>
<li><strong>JSON.parse()方法</strong>将<u>字符串转换为JSON对象</u></li>
<li><strong>JSON.stringify()方法</strong>将<u>JSON对象转换为字符串</u></li>
</ul>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
       var str = &quot;&#123;\&quot;class_name\&quot; : \&quot;五年fdhgfs级三班\&quot;&#125;&quot;; &lt;!--字符串 斜杠进行原意的输出--&gt;
       var json = JSON.parse(str);
       console.log(str);
       console.log(json);
       document.write(&quot;班级：&quot; + json.class_name);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JS中JSON转为字符串"><a href="#JS中JSON转为字符串" class="headerlink" title="JS中JSON转为字符串"></a>JS中JSON转为字符串</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
       var json1 = &quot;&#123;\&quot;class_name\&quot; : \&quot;五年级三班\&quot;&#125;&quot;; &lt;!--字符串 斜杠进行原意的输出--&gt;
       var str1 = JSON.stringify(json1);
       console.log(json1);
       console.log(str1);
       var json2 = &#123;&#125;;
       json2.class_name = &quot;五年级五班&quot;;
       json2.floor = &quot;团委楼四层&quot;;
       json2.teacher = &quot;王义夫&quot;
       console.info(json2);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="JSON与Java交互"><a href="#JSON与Java交互" class="headerlink" title="JSON与Java交互"></a>JSON与Java交互</h3><p>JSON工具包：json与java之间的互相转换</p>
<ul>
<li>FastJson是阿里巴巴著名的JSON序列化与反序列化工具包</li>
<li>FastJson国内拥有大量使用者，拥有API简单，效率高等优点</li>
</ul>
<pre><code class="java">https://repo1.maven.org/maven2/com/alibaba/fastjson/ 下载fastjson
或者配置maven依赖
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="FastJson序列化与JSON注解"><a href="#FastJson序列化与JSON注解" class="headerlink" title="FastJson序列化与JSON注解"></a>FastJson序列化与JSON注解</h3><pre><code class="java">public class Employee&#123;
    private Integer empno;
    private String ename;
    private String job;
    //日期格式化
    @JSONField(name=&quot;hiredate&quot;, format=&quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date hdate;
    private Float salary;
    @JSONField(serialize = false) //不对dname进行序列化
    private String dname;
    ......
&#125;
</code></pre>
<pre><code class="java">public class FastJsonSample1&#123;
    public static void main(String[] args)&#123;
        Employee employee = new Employee();
        employee.setEmpno(4488);
        employee.setEname(&quot;王晓东&quot;);
        employee.setJob(&quot;客户经理&quot;);
        employee.setSalary(1000f);
        employee.setDname(&quot;市场部&quot;);
        //用日期来对时间进行初始化
        --------------//对应上方日期格式化@JSONField-------------------
        Calendar c = Calendar.getInstance();
        c.set(2019,0,30,0,0,0);
        employee.setHdate(c.getTime());//获取所需要的日期对象
        -------------------------------------------------------------
        //FastJSON中提供了JSON对象，完成对象对JSON字符串的转换
        String json = JSON.toJSONString(employee);
        System.out.println(json);
        //                            ↓↓ 原始字符串 反序列化类 ↓↓
        Employee emp = JSON.parseObject(json, Employee.class); //转换为何种对象
        //JSNO.parse()方法将字符串转换为JSON对象
        System.out.println(emp.getEname());
    &#125;
&#125;
</code></pre>
<h3 id="FastJSON对象数组序列化与反序列化"><a href="#FastJSON对象数组序列化与反序列化" class="headerlink" title="FastJSON对象数组序列化与反序列化"></a>FastJSON对象数组序列化与反序列化</h3><p><strong>JSON序列化与反序列化的用途</strong>：数据传输和数据保存 [<u>A电脑中有100个员工信息，通过JSON把数据变成字符串发送給另一个系统，再进行转换</u>]</p>
<pre><code class="java">public class FastJsonSample2&#123;
    public static void main(String[] args)&#123;
        List emplist = new ArrayList();
        for(int i = 1; i &lt;= 100; i++)&#123;
            Employee employee = new Employee();
            employee.setEmpno(4488 + i);
            employee.setEname(&quot;员工&quot; + i);
            emplist.add(employee);
        &#125;
        String json = JSON.toJSONString(emplist);
        System.out.println(json);
        List&lt;Employee&gt; emps = JSON.parseArray(json, Employee.class);
        for(Employee e : emps)&#123;
            System.out.println(e.getEmpno() + &quot;:&quot; + e.getEname());
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<p>JSON教程 <a target="_blank" rel="noopener" href="https://www.cainiaojc.com/json/json_objects.html">https://www.cainiaojc.com/json/json_objects.html</a><br>JSON用于与Web服务器交换数据。数据发送到Web服务器时，数据必须是字符串</p>
<pre><code class="json">JSON格式几乎与JavaScript对象相同 
在JSON中，键必须是字符串，并用双引号引起来 &#123;&quot;name&quot;:&quot;Seagull&quot;&#125;
在JavaScript中，键可以是字符串数字或标识符 &#123;name : &quot;Seagull&quot;&#125; 
JSON字符串类型 &#123;&quot;name&quot;:&quot;Seagull&quot;&#125;
JSON数字类型 &#123;&quot;age&quot;:22&#125;
JSON布尔类型 &#123;&quot;isAdult&quot;:true&#125;
JSON对象类型 &#123;&quot;user&quot;:&#123;&quot;name:&quot;&quot;Seagull&quot;,&quot;age&quot;:22,&quot;city&quot;:&quot;New Delhi&quot;&#125;&#125; 
JSON数组类型 &#123;&quot;user&quot;:[&quot;Seagull&quot;,&quot;Cynthia&quot;,&quot;Tarush&quot;]&#125; 
</code></pre>
<pre><code class="json">//来自服务器的JSON
var httpRequest = new XMLHttpRequest();
httpRequest.onreadystatechange = function() &#123;
   if (this.readyState = 4 &amp;&amp; this.status = 200) &#123;
      var myObj = JSON.parse(this.responseText);
      document.getElementById(&quot;output&quot;).innerHTML = myObj.name;
   &#125;
&#125;;
httpRequest.open(&quot;GET&quot;, &quot;demo.json&quot;, true);
httpRequest.send();
</code></pre>
<p>**JSON.parse()**方法解析JSON字符串来构造JavaScript值或该字符串描述<br>**JSON.stringify()**方法将JavaScript对象或值转换为JSON字符串</p>
<h6 id="解析日期parse"><a href="#解析日期parse" class="headerlink" title="解析日期parse()"></a>解析日期parse()</h6><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;title&gt;JSON.parse() 日期与json转换示例 - 基础教程(cainiaojc.com)&lt;/title&gt;
&lt;body&gt;
&lt;p&gt;如果需要包含日期，则将其写为字符串，然后稍后将其转换回日期对象:&lt;/p&gt;
&lt;p id=&quot;output&quot;&gt;&lt;/p&gt;
&lt;script&gt;
var myJSON = &#39;&#123;&quot;name&quot;:&quot;Seagull&quot;, &quot;birth&quot;:&quot;1997-11-10&quot;, &quot;city&quot;:&quot;New Delhi&quot;&#125;&#39;;
var myObj = JSON.parse(myJSON);
myObj.birth = new Date(myObj.birth);
document.getElementById(&quot;output&quot;).innerHTML = myObj.name + &quot; DOB is, &quot; + myObj.birth;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt; 
/*如果需要包含日期，则将其写为字符串，然后稍后将其转换回日期对象:
Seagull DOB is, Mon Nov 10 1997 08:00:00 GMT+0800 (中国标准时间)*/ 
</code></pre>
<h6 id="解析日期stringify"><a href="#解析日期stringify" class="headerlink" title="解析日期stringify()"></a>解析日期stringify()</h6><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;title&gt;JSON.stringify() 将日期对象转换为字符串示例 - 基础教程(cainiaojc.com)&lt;/title&gt;
&lt;body&gt;
&lt;p&gt; JSON.stringify()方法会将任何日期对象转换为字符串:&lt;/p&gt;
&lt;p id=&quot;output&quot;&gt;&lt;/p&gt;
&lt;script&gt;
var myObj = &#123; name: &quot;Seagull&quot;, today: new Date(), city : &quot;New Delhi&quot; &#125;;
var myJSON = JSON.stringify(myObj);
document.getElementById(&quot;output&quot;).innerHTML = myJSON;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
/*JSON.stringify()方法会将任何日期对象转换为字符串:
&#123;&quot;name&quot;:&quot;Seagull&quot;,&quot;today&quot;:&quot;2023-10-19T09:21:17.353Z&quot;,&quot;city&quot;:&quot;New Delhi&quot;*/
</code></pre>
<p>Java中的this.对象不会被函数内部修改 去寻找定义的值<br>this可以去调到外面的东西 解决了变量名一样的冲突<br>this区分成员变量和局部变量<br>this调用成员方法 </p>
<p>Java中的static是公共的变量池 </p>
<hr>
<h3 id="jQuery-主流的JavaScript库-与Ajax"><a href="#jQuery-主流的JavaScript库-与Ajax" class="headerlink" title="jQuery[主流的JavaScript库]与Ajax"></a>jQuery[主流的JavaScript库]与Ajax</h3><ul>
<li>了解jQuery3的基本使用方法</li>
<li>掌握Ajax处理流程与实现流程</li>
<li>掌握jQuery中Ajax方法的使用</li>
</ul>
<p>jQuery是一个轻量级JS库，使用十分简单；<u>jQuery的核心是<strong>选择器</strong>，<strong>用于获取页面元素</strong></u></p>
<h3 id="jQuery选择器-先引用"><a href="#jQuery选择器-先引用" class="headerlink" title="jQuery选择器 [先引用]"></a>jQuery选择器 [先引用]</h3><script type="text/javascript" src="js/jquery-3.1.1.js"> </script> //引用jQuery
<script type="text/javascript"> //编写自己的代码

jQuery选择器用于选中需要操作的页面元素

###### 语法

1.<span style = "color : red">**jQuery**</span> (选择器表达式)
2.<span style = "color : red">**$**</span> (选择器表达式)

###### <span style = "color:red">基本选择器</span>

|       语法        |                  说明                  |
| :---------------: | :------------------------------------: |
|   **$("#id")**    |     **ID选择器, 指定Id元素的对象**     |
|   **$("标签")**   | **元素选择器, 选择指定标签名的选择器** |
|  **$(".class")**  | **类选择器, 选中拥有指定css类的元素**  |
| **$("S1,S2,SN")** |     **组合选择器, 对元素进行组合**     |

```html
$("#btnSelect").addClass("highlight"); //这个是id <button id="btnSelect">
$(".myclass").addClass("highlight"); //这个是类 <p class="myclass">
```

> 多个选择器","  => a, .myclass

###### 层叠选择器

层叠选择器是根据元素的位置关系来获取元素的选择器表达式

|                            语法                            |    说明    |
| :--------------------------------------------------------: | :--------: |
|                  $("ancestor descendant")                  | 后代选择器 |
|  $("ancestor > descendant") <br />[只选中父节点的子节点]   |  子选择器  |
| $("prev ~ siblings")<br />[只选中元素后所有符合的平级节点] | 兄弟选择器 |

###### 属性选择器

属性选择器是根据元素的属性值来选择元素的选择器表达式

|                             语法                             |              说明              |
| :----------------------------------------------------------: | :----------------------------: |
| $("selector[attribute=value]")<br /><u>input[type='text']</u> |   选中属性值等于具体值的组件   |
|               $("selector[attribute^=value]")                | 选中属性值以某值**开头**的组件 |
| ￥("selector[attribute￥=value]")<br /><u>a[href￥='edu.cn']</u> \|<br /> "￥是$" | 选中属性值以某值**结尾**的组件 |
|               $("selector[attribute*=value]")                |  选中属性值**包含某值**的组件  |

###### 位置选择器

位置选择器是指通过位置获取指定的元素，例如 “获取第3个元素”

|                    语法                     |            说明             |
| :-----------------------------------------: | :-------------------------: |
| $("selector:**first**")<br />.myclass:first |       获取第一个元素        |
|           $("selector:**last**")            |      获取最后一个元素       |
|           $("selector:**even**")            |  获取偶位置的元素(从0开始)  |
|            $("selector:**odd**")            | 获取奇数位置的元素(从0开始) |
|           $("selector:**eq(n)**")           | 获取指定位置的元素(从0开始) |

###### 表单选择器

表单选择器是获取表单元素的简化形式，例如：获取所有文本框

|            语法            |     说明     |
| :------------------------: | :----------: |
|  $("selector:**input**")   | 所有输入元素 |
|   $("selector:**text**")   |  获取文本框  |
| $("selector:**password**") |  获取密码框  |
|  $("selector:**submit**")  | 获取提交按钮 |
|  $("selector:**reset**")   | 获取重置按钮 |

###### 小总结

| $("*")                  | 选取所有元素                                         |
| ----------------------- | ---------------------------------------------------- |
| $("p.intro")            | 选取class为intro的< p >元素                          |
| $(”ul li:first“)        | 选取第一个< ul >元素的第一个< li >元素               |
| $("a[target='_blank']") | 选取所有target属性值等于"_blank"的< a >元素          |
| $(":button")            | 选取所有type="button"的< input >元素和< button >元素 |



### 操作元素属性

- **attr(name|properties|key)** 获取或设置元素属性

```html
<script type="text/javascript" src="js/jquery-3.1.1.js" ></script>
<script type="text/javascript">
    var href_attr = $("a[href*='163']").attr("href"); //一个参数是获取
    alert(href_attr);
    //两个参数是设置 把前面的变成后面的   ↓↓↓↓↓↓↓
    $("a[href*='163']").attr("href", "https://www.163.com");
    var attr = $("a").attr("href");
    alert(attr);
    $("a").removeAttr("href"); //移除后就变成了文本
```



### 操作元素css属性

- **css()** 获取或设置匹配元素的样式属性
- **addClass()** 为每个匹配的元素添加指定的类名
- **removeClass()** 从所有匹配的元素中删除全部或者指定的类

> $("a").css("color")  如果有多个元素 默认返回第一个元素

```html
<script type="text/javascript" src="js/jquery-3.1.1.js" ></script>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(&quot;span&quot;).css(&quot;color&quot;,&quot;red&quot;);
    //简化形式 中间加JSON表达式
    $(&quot;a&quot;).css(&#123;&quot;color&quot; : &quot;red&quot;, &quot;font-size&quot; : &quot;30px&quot;, &quot;font-weight&quot; : &quot;bold&quot;, &quot;font-style&quot; : &quot;italic&quot;&#125;)
    //为选中的选择器增添类效果 为li增加两个css类
    $(&quot;li&quot;).addClass(&quot;highlight myclass&quot;);
    $(&quot;p&quot;).removeClass(&quot;myclass&quot;) //移除类
    var color = $(&quot;a&quot;).css(&quot;color&quot;,&quot;orange&quot;);
    // alert(color)
</code></pre>
<pre><code>


### 设置元素内容

- **val()** 获取或设置输入项的值
- **text()** 获取或设置元素的纯文本
- **html()** 获取或设置元素内部的HTML

```html
.. &lt;input type = &quot;text&quot; name = &quot;uname&quot; value = &quot;admin&quot;/&gt; ..//将初始uname值变admin..
.. &lt;span class = &quot;myclass&quot;&gt;我是myclass类的span标签&lt;/span&gt; ..
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot; &gt;&lt;/script&gt;
&lt;script type = &quot;text/javascript&quot;&gt;
    //获取或设置文本输入框的内容
    $(&quot;input[name=&#39;uname&#39;]&quot;).val(&quot;administrator&quot;);
    
    //text与html方法最大的区别在于对文本中的html标签是否进行转义
    var vspan = $(&quot;span.myclass&quot;).text(&quot;&lt;b&gt;锄禾日当午&lt;/b&gt;&quot;);
    alert(vspan);//锄禾日当午 纯文本中带了&lt;b&gt;标签
    
    var vspan = $(&quot;span.myclass&quot;).html(&quot;&lt;b&gt;锄禾日当午&lt;/b&gt;&quot;);  
    alert(vspan);//&lt;b&gt;锄禾日当午&lt;/b&gt;
&lt;/script&gt;
</code></pre>
<h3 id="jquery事件处理方法"><a href="#jquery事件处理方法" class="headerlink" title="jquery事件处理方法"></a>jquery事件处理方法</h3><ul>
<li><strong>on(“click”, function)</strong> 为选中的页面元素绑定单机事件</li>
<li><strong>click(function)</strong> 是绑定事件的简写形式</li>
<li>处理方法中提供了event参数包含了事件的相关信息</li>
</ul>
<table>
<thead>
<tr>
<th align="center">鼠标事件</th>
<th align="center">键盘事件</th>
<th align="center">表单事件</th>
<th align="center">文档&#x2F;窗口事件</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>click</strong></td>
<td align="center">keypress<br />(键盘完整按下弹起)</td>
<td align="center"><strong>submit</strong><br />(表单提交)</td>
<td align="center"><strong>load</strong><br />（文档加载）</td>
</tr>
<tr>
<td align="center">dblclick(双击)</td>
<td align="center">keydown<br />(键盘按下)</td>
<td align="center">change<br />(表单发生变化)</td>
<td align="center">resize<br />(文档窗口产生变化)</td>
</tr>
<tr>
<td align="center">mouseenter<br />(滑鼠移动)</td>
<td align="center">keyup<br />(键盘弹起)</td>
<td align="center">focus<br />（表单输入项获得焦点）</td>
<td align="center">scroll<br />(文档窗口滚动变化)</td>
</tr>
<tr>
<td align="center">mouseleave<br />(滑鼠移出)</td>
<td align="center"></td>
<td align="center">blur<br />（表单输入项失去焦点)</td>
<td align="center">unload<br />(文档窗口关闭&#x2F;卸载)</td>
</tr>
<tr>
<td align="center">mouseover<br />(滑鼠移动过程)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code class="html">.. &lt;p class = &quot;myclass&quot;&gt;我是拥有myclass的p标签&lt;/p&gt; ..
.. &lt;input type = &quot;text&quot; name = &quot;uname&quot; value = &quot;admin&quot;/&gt; ..
&lt;script type = &quot;text/javascript&quot; src = &quot;js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;
&lt;script type = &quot;text/javascript&quot;&gt;
    $(&quot;p.myclass&quot;).on(&quot;click&quot;, function()&#123;
    //$(this)是指当前事件产生的对象$(&quot;p.myclass&quot;)
    $(this).css(&quot;background-color&quot;, &quot;yellow&quot;);
&#125;)
    $(&quot;span.myclass&quot;).click(function()&#123;
    $(this).css(&quot;background-color&quot;, &quot;lightgreen&quot;);                      
&#125;) 
    
    $(&quot;input[name=&#39;uname&#39;]&quot;).keypress(function(event)&#123;
        console.log(event); //打印事件 F12 每次输入按键的Console
        $(this).css(&quot;color&quot;, &quot;red&quot;);
    &#125;)
    
&lt;/script&gt;
----------------------------------------------------------------
&lt;!DOCTYPE html &gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;script src=&quot;https://cdn,staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
&lt;/script&gt;
&lt;script&gt;
$(document).ready(function()&#123;
 $(&quot;p&quot;).click(function())&#123;
    &lt;!--动作触发后执行的代码--&gt;
    #(this).hide();
&#125;);
&#125;);
&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;
            如果你点我，我就会消失。
        &lt;/p&gt;
        &lt;p&gt;
            点我消失！
        &lt;/p&gt;
    &lt;/body&gt;
</code></pre>
<h3 id="jQuery-hide-和show"><a href="#jQuery-hide-和show" class="headerlink" title="jQuery hide()和show()"></a>jQuery hide()和show()</h3><p>使用hide()和show()方法来隐藏和显示HTML元素</p>
<pre><code class="html">$(&quot;#hide&quot;).click(function()&#123;
    $(&quot;p&quot;).hide();
&#125;);
$(&quot;#show&quot;).click(function()&#123;
    $(&quot;p&quot;).show();
&#125;);
</code></pre>
<h6 id="隐藏速度"><a href="#隐藏速度" class="headerlink" title="隐藏速度"></a>隐藏速度</h6><blockquote>
<p>$(selector).hide(speed,callback);</p>
</blockquote>
<blockquote>
<p>$(selector).show(speed,callback);</p>
</blockquote>
<pre><code class="html">&lt;!DOCTYPE html &gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;script src=&quot;https://cdn,staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
&lt;/script&gt;
&lt;script&gt;
$(document).ready(function()&#123;
$(&quot;button&quot;).click(function()&#123;
    $(&quot;p&quot;).hide(1000);
 &#125;);
&#125;);
&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;button&gt;隐藏&lt;/button&gt;
      &lt;p&gt; 这是个段落&lt;/p&gt;
      &lt;p&gt; 小段落&lt;/p&gt;
    &lt;/body&gt;
</code></pre>
<h3 id="jQuery选择器实验室"><a href="#jQuery选择器实验室" class="headerlink" title="jQuery选择器实验室"></a>jQuery选择器实验室</h3><pre><code class="html">sample2.html
&lt;!DOCTYPE html &gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;title&gt;jQuery实验室&lt;/title&gt;

&lt;style&gt;
.myclass &#123;
    font-style: italic;
    color: darkblue;
&#125;
/* 高亮css类 */
.highlight &#123;
    color: red;
    font-size: 30px;
    background: lightblue;
&#125;
&lt;/style&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;div class=&quot;section&quot;&gt;
        &lt;h2&gt;jQuery选择器实验室&lt;/h2&gt;
        &lt;input style=&quot;height: 24px&quot; id=&quot;txtSelector&quot; /&gt;
        &lt;button id=&quot;btnSelect&quot; style=&quot;height: 30px&quot;&gt;选择&lt;/button&gt;
        &lt;hr /&gt;
        &lt;div&gt;
            &lt;p id=&quot;welcome&quot;&gt;欢迎来到选择器实验室&lt;/p&gt;
            &lt;ul&gt;
                &lt;li&gt;搜索引擎：&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;span&gt; &lt;a
                        style=&quot;color: darkgreen&quot; href=&quot;http://www.so.com&quot;&gt;360&lt;/a&gt;
                &lt;/span&gt;
                &lt;/li&gt;
                &lt;li&gt;电子邮箱：&lt;a href=&quot;http://mail.163.com&quot;&gt;网易邮箱&lt;/a&gt; &lt;span&gt; &lt;a
                        style=&quot;color: darkgreen&quot; href=&quot;http://mail.qq.com&quot;&gt;QQ邮箱&lt;/a&gt;
                &lt;/span&gt;
                &lt;/li&gt;
                &lt;li&gt;中国名校：&lt;a href=&quot;http://www.tsinghua.edu.cn&quot;&gt;清华大学&lt;/a&gt; &lt;span&gt;
                        &lt;a style=&quot;color: darkgreen&quot; href=&quot;https://www.pku.edu.cn/&quot;&gt;北京大学&lt;/a&gt;
                &lt;/span&gt;
                &lt;/li&gt;
            &lt;/ul&gt;

            &lt;span class=&quot;myclass &quot;&gt;我是拥有myclass类的span标签&lt;/span&gt;

            &lt;p class=&quot;myclass&quot;&gt;我是拥有myclass的p标签&lt;/p&gt;
            &lt;form id=&quot;info&quot; action=&quot;#&quot; method=&quot;get&quot;&gt;
                &lt;div&gt;
                    用户名：&lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;admin&quot; /&gt; 密码：&lt;input
                        type=&quot;password&quot; name=&quot;upsd&quot; value=&quot;123456&quot; /&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    婚姻状况： &lt;select id=&quot;marital_status&quot;&gt;
                        &lt;option value=&quot;1&quot;&gt;未婚&lt;/option&gt;
                        &lt;option value=&quot;2&quot;&gt;已婚&lt;/option&gt;
                        &lt;option value=&quot;3&quot;&gt;离异&lt;/option&gt;
                        &lt;option value=&quot;4&quot;&gt;丧偶&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;div class=&quot;left clear-left&quot;&gt;
                    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;
                &lt;/div&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot; &gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        /*
            id选择器使用&quot;#id值&quot;进行选择
            css选择器使用&quot;.css类名&quot;进行选择
            $(&quot;.myclass&quot;).addClass(&quot;highlight&quot;);
        */
        document.getElementById(&quot;btnSelect&quot;).onclick = function()&#123;
            var selector = document.getElementById(&quot;txtSelector&quot;).value;
            //jquery选择器方法 选择器表达式
            $(&quot;*&quot;).removeClass(&quot;highlight&quot;) //在增加高亮之前 在当前页面将所有的类移除
            $(selector).addClass(&quot;highlight&quot;); //对前面所选中的元素追加css类
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Ajax-Asynchronous-JavaScript-And-XML-介绍"><a href="#Ajax-Asynchronous-JavaScript-And-XML-介绍" class="headerlink" title="Ajax(Asynchronous JavaScript And XML)介绍"></a>Ajax(Asynchronous JavaScript And XML)介绍</h3><p>Ajax(异步的 <strong>JavaScript</strong> 和 <strong>XML</strong>)</p>
<ul>
<li>Ajax可以**<u><span style = "color : red">在不刷新页面的前提下，进行页面布局更新，与后台交互</span></u>**<br>[不对整个页面刷新 只对局部数据更新刷新]</li>
<li>Ajax不是新技术，不是W3C的标准</li>
</ul>
<h4 id="Ajax的使用流程"><a href="#Ajax的使用流程" class="headerlink" title="Ajax的使用流程"></a>Ajax的使用流程</h4><ul>
<li>创建<strong>XmlHttpRequest</strong>对象[用于后台与服务器交换数据 是Ajax的核心]</li>
<li>发送Ajax请求</li>
<li>处理服务器响应</li>
</ul>
<h6 id="创建XmlHttpRequest对象"><a href="#创建XmlHttpRequest对象" class="headerlink" title="创建XmlHttpRequest对象"></a>创建XmlHttpRequest对象</h6><pre><code class="java">// 1.创建XmlHttpRequest对象
     var xmlhttp;
      if(windows.XMLHttpRequest)&#123;
       xmlhttp = new XMLHttpRequest();
    &#125;else&#123;
       xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
</code></pre>
<h6 id="发送Ajax请求"><a href="#发送Ajax请求" class="headerlink" title="发送Ajax请求"></a>发送Ajax请求</h6><ul>
<li><strong>xmlhttp.open()</strong> 用于创建请求</li>
</ul>
<pre><code class="java">//创建请求
xmlhttp.open(&quot;Get&quot;,&quot;http://localhost/test?name=admin&quot;,true);
//发送到服务器
xmlhttp.send();
</code></pre>
<h6 id="处理服务器响应"><a href="#处理服务器响应" class="headerlink" title="处理服务器响应"></a>处理服务器响应</h6><ul>
<li><strong>xmlhttp.onreadystatechange()</strong> 事件用于监听Ajax的执行过程</li>
<li><strong>xmlhttp.readyState &#x3D; “<u>number</u>“</strong> 属性说明XMLHttpRequest当前状态</li>
<li>xmlhttp.status 属性服务器响应状态码，200:成功 404:未找到</li>
</ul>
<table>
<thead>
<tr>
<th align="center">readyState指</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">readyState &#x3D; 0</td>
<td align="center">请求未初始化</td>
</tr>
<tr>
<td align="center">readyState &#x3D; 1</td>
<td align="center">服务器连接已建立</td>
</tr>
<tr>
<td align="center">readyState &#x3D; 2</td>
<td align="center">请求已被接收</td>
</tr>
<tr>
<td align="center">readyState &#x3D; 3</td>
<td align="center">请求正在处理</td>
</tr>
<tr>
<td align="center">readyState &#x3D; 4</td>
<td align="center">响应文本已被接收</td>
</tr>
</tbody></table>
<h6 id="完整编写"><a href="#完整编写" class="headerlink" title="完整编写"></a>完整编写</h6><pre><code class="html">&lt;body&gt;
    &lt;input id=&quot;btnLoad&quot; type=&quot;button&quot; value=&quot;加载&quot;&gt;
    &lt;div id=&quot;divContent&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        document.getElementById(&quot;btnLoad&quot;).onclick = function()&#123;
            //1.创建XmlHttpRequest对象
            var xmlhttp;
            if(windows.XMLHttpRequest)&#123;
                xmlhttp = new XMLHttpRequest();
            &#125;else&#123;
                xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
            &#125;
            console.log(xmlhttp); //在控制台console里有数据
            //2.发送Ajax请求 //F12中Network content有Response返回
            xmlhttp.open(&quot;GET&quot;, &quot;/json_war_exploded/news.html&quot;, true)
            //3.处理服务器响应
            xmlhttp.onreadystatechange = function()&#123;
            //响应已被接收且服务器处理成功时才执行
                if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123;
                //获取响应体的文本
                var responseText = xmlhttp.responseText;
                //对服务器结果进行处理 
                alert(t);
                //点击加载后 数据输出在页面的div上
                document.getElementById(&quot;divContent&quot;).innerHTML = t;
                &#125;
            &#125;
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="java">ContentServlet.java
@WebServlet(&quot;/content&quot;)
public class ContentServlet extends HttpServlet&#123;
    public ContentServlet()&#123;
        super();
    &#125;
    //用Ajax进行请求的时候不进行任何页面跳转而是直接输出想产生的数据结果[一般用JSON传递]
    protected void doGet(HttpServletReq req, HttpServletRespon res)&#123;
        res.getWritre().println(&quot;&lt;b style = &#39;color:red&#39;&gt;I&#39;m server content&lt;/b&gt;&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="利用Ajax实现新闻列表-案例"><a href="#利用Ajax实现新闻列表-案例" class="headerlink" title="利用Ajax实现新闻列表[案例]"></a>利用Ajax实现新闻列表[案例]</h3><p>需要下载fast json-1.2.52.jar</p>
<pre><code class="java">News.java
public class News()&#123;
    private String title;
    private String date;
    private String source;
    private String content;
    Getter and Setter + Constructor
&#125;
</code></pre>
<pre><code class="java">NewsListServlet.java
@WebServlet(&quot;/news_list&quot;)
public class NewsListServlet extends HttpServlet&#123;
    public NewsListServlet()&#123;
        super();
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        List list = new ArrayList();
        list.add(new News(&quot;TIOBE:2023年9月份日本排放核污染水&quot;,&quot;2020-9&quot;,&quot;TIOBE&quot;,&quot;...&quot;));
        list.add(new News(&quot;TIOBE:2023年9月份日本排放核污染水&quot;,&quot;2020-9&quot;,&quot;TIOBE&quot;,&quot;...&quot;));
        list.add(new News(&quot;TIOBE:2023年9月份日本排放核污染水&quot;,&quot;2020-9&quot;,&quot;TIOBE&quot;,&quot;...&quot;));
        list.add(new News(&quot;TIOBE:2023年9月份日本排放核污染水&quot;,&quot;2020-9&quot;,&quot;TIOBE&quot;,&quot;...&quot;));
        //用于把List或者java对象給json序列化生成对应的字符串
        String json = JSON.toJSONString(list); //提供的java对象
        System.out.println(json);
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        resp.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;container&quot;&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
        //1.创建XmlHttpRequest对象
        var xmlhttp;
        if(window.XMLHttpRequest)&#123;
            xmlhttp = new XMLHttpRequest();
        &#125;else&#123;
            xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
        &#125;
        //2.发送Ajax请求 //F12中Network content有Response返回
        //true代表异步执行 false代表同步执行
        xmlhttp.open(&quot;GET&quot;, &quot;/json_war_exploded/news_list&quot;, false)
        //同步：在网络发布的过程中 数据没有返回的话会一直处于阻塞的状态(前面的没做完后面的不让做)
        xmlhttp.send();
        console.log(&quot;请求发送完成&quot;);
        if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;
            //获取响应体的文本
            var text = xmlhttp.responseText;
            //对服务器结果进行处理
            console.log(text);
            var json = JSON.parse(text);//内置的json对象
            console.log(json);
            var html = &quot;&quot;;
            for (var i = 0; i &lt; json.length; i++) &#123;
                var news = json[i];
                html = html + &quot;&lt;h1&gt;&quot; + news.title + &quot;&lt;/h1&gt;&quot;;
                html = html + &quot;&lt;h2&gt;&quot; + news.date + &quot;&amp;nbsp&quot; + news.source + &quot;&lt;/h2&gt;&quot;;
                html = html + &quot;&lt;hr/&gt;&quot;
            &#125;
            document.getElementById(&quot;container&quot;).innerHTML = html;
        &#125;
        /*3.处理服务器响应 异步[一直往下进行 onreadystatechange数据监控]
        xmlhttp.onreadystatechange = function()&#123;
            //响应已被接收且服务器处理成功时才执行
            if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123;
                //获取响应体的文本
                var text = xmlhttp.responseText;
                //对服务器结果进行处理
                console.log(text);
                var json = JSON.parse(text);//内置的json对象
                console.log(json);
                var html = &quot;&quot;;
                for (var i = 0; i &lt; json.length; i++) &#123;
                    var news = json[i];
                    html = html + &quot;&lt;h1&gt;&quot; + news.title + &quot;&lt;/h1&gt;&quot;;
                    html = html + &quot;&lt;h2&gt;&quot; + news.date + &quot;&amp;nbsp&quot; + news.source + &quot;&lt;/h2&gt;&quot;;
                    html = html + &quot;&lt;hr/&gt;&quot;;
                &#125;
                //对html进行动态加载
                document.getElementById(&quot;container&quot;).innerHTML = html;
            &#125;
        &#125;*/
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p><strong>xmlhttp</strong>.open(“GET”, “&#x2F;json_war_exploded&#x2F;news_list”, <strong>false</strong>)</p>
<p>**同步(false)**：程序会阻塞 进入等待的状态 数据不返回时程序是不会往下进行的<br><strong>异步(true)</strong>[<u>推荐</u>]：程序不会阻塞 程序依旧往下进行 数据返回是通过触发onreadystatechange数据监控进行处理的</p>
<pre><code class="java">//    2.发送Ajax请求 //F12中Network content有Response返回
        //true代表异步执行 false代表同步执行
        xmlhttp.open(&quot;GET&quot;, &quot;/json_war_exploded/news_list&quot;, false)
        //同步：在网络发布的过程中 数据没有返回的话会一直处于阻塞的状态(前面的没做完后面的不让做)
        xmlhttp.send();
        console.log(&quot;请求发送完成&quot;);
        if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;
            //获取响应体的文本
            var text = xmlhttp.responseText;
            //对服务器结果进行处理
            console.log(text);
            var json = JSON.parse(text);//内置的json对象
            console.log(json);
            var html = &quot;&quot;;
            for (var i = 0; i &lt; json.length; i++) &#123;
                var news = json[i];
                html = html + &quot;&lt;h1&gt;&quot; + news.title + &quot;&lt;/h1&gt;&quot;;
                html = html + &quot;&lt;h2&gt;&quot; + news.date + &quot;&amp;nbsp&quot; + news.source + &quot;&lt;/h2&gt;&quot;;
                html = html + &quot;&lt;hr/&gt;&quot;
            &#125;
            document.getElementById(&quot;container&quot;).innerHTML = html;
        &#125;
        /*3.处理服务器响应 异步[一直往下进行 onreadystatechange数据监控]
        xmlhttp.onreadystatechange = function()&#123;
            //响应已被接收且服务器处理成功时才执行
            if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123;
                //获取响应体的文本
                var text = xmlhttp.responseText;
                //对服务器结果进行处理
                console.log(text);
                var json = JSON.parse(text);//内置的json对象
                console.log(json);
                var html = &quot;&quot;;
                for (var i = 0; i &lt; json.length; i++) &#123;
                    var news = json[i];
                    html = html + &quot;&lt;h1&gt;&quot; + news.title + &quot;&lt;/h1&gt;&quot;;
                    html = html + &quot;&lt;h2&gt;&quot; + news.date + &quot;&amp;nbsp&quot; + news.source + &quot;&lt;/h2&gt;&quot;;
                    html = html + &quot;&lt;hr/&gt;&quot;;
                &#125;
                //对html进行动态加载
                document.getElementById(&quot;container&quot;).innerHTML = html;
            &#125;
        &#125;*/
</code></pre>
<hr>
<pre><code class="html">&lt;button type = &quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;修改内容&lt;/button&gt;
&lt;script&gt;
/* XMLHttpRequest 用于在后台与服务器交换数据。
这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。
*/ 
function loadXMLDoc()&#123;
    //AJAX脚本执行
    var xmlhttp;
    if(windows.XMLHttpRequest)&#123;
        xmlhttp=new XMLHttpRequest();
    &#125;else&#123;
        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    &#125;
&#125;
&lt;/script&gt;

/*
如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：

open(method,url,async)
method：请求的类型；GET 或 POST
url：文件在服务器上的位置
async：true（常用异步）或 false（同步）

对于 web 开发人员来说，发送异步请求是一个巨大的进步。
很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。
通过 AJAX，JavaScript 无需等待服务器的响应，而是：
在等待服务器响应时执行其他脚本
当响应就绪后对响应进行处理
*/ 

xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.html&quot;,true);
xmlhttp.send(); //send(string) 仅用于POST请求 

/*
若需要来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性 
responseText =&gt; 获得字符串形式的相应数据 如果来自服务器的响应并非XML
responseXML =&gt; 获得XML形式的相应数据 如果来自服务器的响应式XML 
*/ 
// responseText 
document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
// responseXML
xmlDoc=xmlhttp.responseXML;
txt=&quot;&quot;;
x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);
    for (i=0;i&lt;x.length;i++)
    &#123;
        txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;
    &#125;
document.getElementById(&quot;myDiv&quot;).innerHTML=txt;
/*onreadystatechange事件中我们规定当服务器响应已做好被处理的准备时所执行的任务
0:请求未初始化  1:服务器连接已建立  2:请求已接收  3:请求处理中  4:请求已完成且响应已就绪 
 */ 
 //如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest对象编写一个标准的函数
 //并为每个 AJAX 任务调用该函数 
 xmlhttp.onreadystatechange=function()
&#123;
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    &#123;
        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="jQuery对Ajax的支持"><a href="#jQuery对Ajax的支持" class="headerlink" title="jQuery对Ajax的支持"></a>jQuery对Ajax的支持</h3><ul>
<li>jQuery对Ajax进行封装，提供了**$.ajax()**方法</li>
<li>语法：**$.ajax(options)**</li>
</ul>
<table>
<thead>
<tr>
<th align="center">常用设置项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>url</strong></td>
<td align="center">发送请求地址</td>
</tr>
<tr>
<td align="center"><strong>type</strong></td>
<td align="center">请求类型get|post</td>
</tr>
<tr>
<td align="center"><strong>data</strong></td>
<td align="center">向服务器传递的参数</td>
</tr>
<tr>
<td align="center"><strong>dataType</strong></td>
<td align="center">服务器响应的数据类型<br />text|<strong>json</strong>|xml|html|jsonp|script</td>
</tr>
<tr>
<td align="center"><strong>success</strong></td>
<td align="center">接收响应时的处理函数</td>
</tr>
<tr>
<td align="center"><strong>error</strong></td>
<td align="center">请求失败时的处理函数</td>
</tr>
</tbody></table>
<pre><code class="html">jquery_news.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(function () &#123;
            $.ajax(&#123;
                &quot;url&quot;: &quot;/json_war_exploded/news_list&quot;,
                &quot;type&quot;: &quot;get&quot;,
                &quot;data&quot;: &quot;t=tiobe&quot;,//多个传参的参数用json格式写
                //&quot;data&quot;: &#123;&quot;t&quot;:&quot;tiobe&quot;, &quot;abc&quot;:&quot;123&quot;, &quot;uu&quot;:&quot;777&quot;&#125;
                //但是实际过程中jquery会以url形式传参 t=tiobe&amp;abc=123&amp;uu=777
                &quot;dataType&quot;: &quot;json&quot;, //解析成json文件
                &quot;success&quot;: function (json)&#123;
                    console.log(json);
                    for (var i = 0; i &lt; json.length; i++)&#123;
                        $(&quot;#container&quot;).append(&quot;&lt;h1&gt;&quot; + json[i].title + &quot;&lt;/h1&gt;&quot;); //append追加
                    &#125;
                &#125;,   //ajax的核心信息 ↓
                &quot;error&quot;: function (xmlhttp, errorText)&#123;
                    console.log(xmlhttp);
                    console.log(errorText);
                    if(xmlhttp.status == &quot;405&quot;)&#123;
                        alert(&quot;无效的请求方式&quot;);
                    &#125;else if(xmlhttp.status == &quot;404&quot;)&#123;
                        alert(&quot;未找到URL资源&quot;);
                    &#125;else if(xmlhttp.status == &quot;500&quot;)&#123;
                        alert(&quot;服务器内部错误，请联系管理员&quot;);
                    &#125;else&#123;
                        alert(&quot;产生异常，请联系管理员&quot;);
                    &#125;
                &#125;
            &#125;)
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id = &quot;container&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现二级联动菜单-省-市-县"><a href="#实现二级联动菜单-省-市-县" class="headerlink" title="实现二级联动菜单 [省 市 县]"></a>实现二级联动菜单 [省 市 县]</h3><pre><code class="java">ChannelServlet.java
package com.example.json;

import com.alibaba.fastjson.JSON;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@WebServlet(&quot;/channel&quot;)
public class ChannelServlet extends HttpServlet &#123;
    public ChannelServlet() &#123;
    &#125;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String level = req.getParameter(&quot;level&quot;);
        String parent = req.getParameter(&quot;parent&quot;);
        List chlist = new ArrayList();
        if(level.equals(&quot;1&quot;)) &#123;
            chlist.add(new Channel(&quot;ai&quot; , &quot;前沿/区块链/人工智能&quot;));
            chlist.add(new Channel(&quot;web&quot; , &quot;前端/小程序/JS&quot;));
        &#125;else if(level.equals(&quot;2&quot;)) &#123;
            if(parent.equals(&quot;ai&quot;)) &#123;
                chlist.add(new Channel(&quot;micro&quot; , &quot;微服务&quot;));
                chlist.add(new Channel(&quot;blockchain&quot; , &quot;区块链&quot;));
                chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;));
            &#125;else if(parent.equals(&quot;web&quot;))&#123;
                chlist.add(new Channel(&quot;html&quot; , &quot;HTML&quot;));
                chlist.add(new Channel(&quot;css&quot; , &quot;CSS&quot;));
                chlist.add(new Channel(&quot;other&quot; , &quot;...&quot;));
            &#125;
        &#125;
        //json序列化
        String json = JSON.toJSONString(chlist);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<pre><code class="html">cascade_menu.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(function()&#123;
            $.ajax(&#123;
                &quot;url&quot; : &quot;/json_war_exploded/channel&quot;,
                &quot;data&quot; : &#123;&quot;level&quot; : &quot;1&quot;&#125;,
                &quot;type&quot; : &quot;get&quot; ,
                &quot;dataType&quot; : &quot;json&quot; ,
                &quot;success&quot; : function(json)&#123;
                    console.log(json);
                    for(var i = 0 ; i &lt; json.length ; i++)&#123;
                        var ch = json[i];
                        //append是在组件内部进行追加内容
                        $(&quot;#lv1&quot;).append(&quot;&lt;option value=&#39;&quot; + ch.code + &quot;&#39;&gt;&quot; + ch.name + &quot;&lt;/option&gt;&quot;)
                    &#125;
                &#125;
            &#125;)
        &#125;)

        $(function()&#123; //on是绑定事件 change是当变化时候发生function
            $(&quot;#lv1&quot;).on(&quot;change&quot; , function()&#123;
                var parent = $(this).val();//val()获取输入项的值
                console.log(parent);
                $.ajax(&#123;
                    &quot;url&quot; : &quot;/json_war_exploded/channel&quot; ,
                    &quot;data&quot; : &#123;&quot;level&quot; : &quot;2&quot; , &quot;parent&quot; : parent&#125;, //parent 一级频道的value值
                    &quot;dataType&quot; : &quot;json&quot; ,
                    &quot;type&quot; : &quot;get&quot; ,
                    &quot;success&quot; : function(json)&#123;
                        console.log(json);
                        //移除所有lv2下的原始option选项
                        $(&quot;#lv2&gt;option&quot;).remove();
                        for(var i = 0 ; i &lt; json.length ; i++)&#123;
                            var ch = json[i];
                            $(&quot;#lv2&quot;).append(&quot;&lt;option value=&#39;&quot; + ch.code +&quot;&#39;&gt;&quot; + ch.name + &quot;&lt;/option&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;)
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;select id=&quot;lv1&quot; style=&quot;width:200px;height:30px&quot;&gt;
    &lt;option selected=&quot;selected&quot;&gt;请选择&lt;/option&gt;
&lt;/select&gt;
&lt;select id=&quot;lv2&quot; style=&quot;width:200px;height:30px&quot;&gt;&lt;/select&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><ul>
<li>正则表达式是检查、匹配字符串的表达式</li>
<li>正则表达式是描述规则、主流语言都有良好支持</li>
<li>字符串校验、查找与替换是正则表达式主要使用场景</li>
</ul>
<h6 id="正则表达式的案例"><a href="#正则表达式的案例" class="headerlink" title="正则表达式的案例"></a>正则表达式的案例</h6><ul>
<li>检查输入的身份证号是否合法(15位、18位)</li>
<li>示例：13010220200328091x</li>
</ul>
<pre><code class="java">正则表达式：(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)
</code></pre>
<h3 id="字符范围匹配"><a href="#字符范围匹配" class="headerlink" title="字符范围匹配"></a>字符范围匹配</h3><table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">说明</th>
<th align="center">正确</th>
<th align="center">错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">精准匹配单个字符</td>
<td align="center">A</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">x|y</td>
<td align="center">允许出现的2个字符</td>
<td align="center">y</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="center">字符集合,允许出现集合内任意单个字符</td>
<td align="center">z</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center">[a-z] [A-Z] [0-9]</td>
<td align="center">字符范围</td>
<td align="center">a D 8</td>
<td align="center">A a A</td>
</tr>
<tr>
<td align="center">[^xyz] [‘^0-9]</td>
<td align="center">集合内字符不允许出现</td>
<td align="center">0 A</td>
<td align="center">y 8</td>
</tr>
</tbody></table>
<h6 id="训练题目"><a href="#训练题目" class="headerlink" title="训练题目"></a>训练题目</h6><ul>
<li>精准匹配字符串”hallo” 或者 “hello” &#x3D;&gt; h**[ae]**llo</li>
<li>请匹配数字范围(0570-0579) &#x3D;&gt; 057[<strong>0-9</strong>]</li>
<li>单选题只允许输入ABCD其中一项 &#x3D;&gt; [<strong>ABCD</strong>] &#x2F; [<strong>A-D</strong>]</li>
</ul>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">说明</th>
<th align="center">正确</th>
<th align="center">错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">匹配任意单个数字</td>
<td align="center">8</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">匹配\d规则之外的任意单个字符</td>
<td align="center">i</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配任意单个字母数字下划线</td>
<td align="center">Y</td>
<td align="center">&amp;</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配\w之外的任意单个字符</td>
<td align="center">&amp;</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配单个空格</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">匹配单个换行符</td>
<td align="center"></td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配任意单个字符(换行符除外)</td>
<td align="center">–</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">\。</td>
<td align="center">特殊字符,只匹配 “.”</td>
<td align="center">.</td>
<td align="center">1</td>
</tr>
</tbody></table>
<h6 id="训练题目-1"><a href="#训练题目-1" class="headerlink" title="训练题目"></a>训练题目</h6><ul>
<li><p>请匹配数字(3213.383219)</p>
<pre><code class="java">\d\d\d\d\.\d\d\d\d\d\d\d
</code></pre>
</li>
<li><p>匹配杭州与宁波的座机号码(0571|0574-XXXXXXXX)</p>
<pre><code class="java">057[14]-\d\d\d\d\d\d\d\d
</code></pre>
</li>
<li><p>请匹配18位身份证号 [第一位1~6和8]</p>
<pre><code class="java">[1234568]\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d[0-9xX]
</code></pre>
</li>
</ul>
<h3 id="多次重复匹配"><a href="#多次重复匹配" class="headerlink" title="多次重复匹配"></a>多次重复匹配</h3><table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">说明</th>
<th align="center">正确</th>
<th align="center">错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A{3}</td>
<td align="center">精准N次匹配</td>
<td align="center">AAA</td>
<td align="center">AA</td>
</tr>
<tr>
<td align="center">A{3,}</td>
<td align="center">最少出现N</td>
<td align="center">AAA</td>
<td align="center">AA</td>
</tr>
<tr>
<td align="center">\d{3,5}</td>
<td align="center">约定出现最少次数与最大次数</td>
<td align="center">1234</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">\d*</td>
<td align="center">可以出现零次至无限次,相当于{0,}</td>
<td align="center">1234</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">\d+</td>
<td align="center">最少出现一次, 相当于{1,}</td>
<td align="center">12</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">\d?</td>
<td align="center">最多出现一次, 相当于{0,1}</td>
<td align="center">1</td>
<td align="center">12</td>
</tr>
</tbody></table>
<h6 id="联系题目"><a href="#联系题目" class="headerlink" title="联系题目"></a>联系题目</h6><ul>
<li><p>验证短信验证码(6位数字) &#x3D;&gt; <strong>\d[6]</strong></p>
</li>
<li><p>请匹配全国座机号(区号3或4位-电话号码7或8位) &#x3D;&gt; <strong>\d[3,4]-\d[7,8]</strong></p>
</li>
<li><p>请匹配英文姓名(例如：James Watson)</p>
<pre><code class="java">[A-Z][a-z]&#123;1,&#125;\s[A-Z][a-z]&#123;0,&#125;
[A-Z][a-z]&#123;1,&#125;\s[A-Z][a-z]*
^[A-Z][a-z]&#123;1,&#125;+\s[A-Z][a-z]*$
</code></pre>
</li>
</ul>
<h3 id="定位匹配"><a href="#定位匹配" class="headerlink" title="定位匹配"></a>定位匹配</h3><table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">说明</th>
<th align="center">正确</th>
<th align="center">错误</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>^A.</strong>*</td>
<td align="center"><span style = "color : red"><strong>头匹配</strong></span></td>
<td align="center">ABC</td>
<td align="center">CBA</td>
</tr>
<tr>
<td align="center">**.<em>A$</em>*</td>
<td align="center"><span style = "color : red"><strong>尾匹配</strong></span></td>
<td align="center">CBA</td>
<td align="center">ABC</td>
</tr>
<tr>
<td align="center">^A.*A$</td>
<td align="center">全字匹配</td>
<td align="center">ACCCA</td>
<td align="center">ACCCB</td>
</tr>
</tbody></table>
<pre><code class="java">abb123123ab =&gt; ^ab.*ab$
</code></pre>
<h3 id="贪婪模式-默认匹配规则"><a href="#贪婪模式-默认匹配规则" class="headerlink" title="贪婪模式[默认匹配规则]"></a>贪婪模式[默认匹配规则]</h3><ul>
<li>在满足条件的情况下尽可能<strong>多</strong>匹配到字符串</li>
<li>示例：111222333     正则：<strong>\d{6,8}</strong></li>
<li>匹配结果：11122233</li>
</ul>
<h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><ul>
<li><p>在满足条件的情况下尽可能<strong>少</strong>匹配到字符串</p>
</li>
<li><p>示例：111222333     正则：<strong>\d{6,8}？</strong></p>
</li>
<li><p>匹配结果：111222</p>
</li>
</ul>
<h6 id="贪婪模式举例"><a href="#贪婪模式举例" class="headerlink" title="贪婪模式举例"></a>贪婪模式举例</h6><pre><code class="java">&lt;a href = &quot;www.baidu.com&quot;&gt; 百度 &lt;/a&gt; &lt;a href =  &quot;www.baidu.com&quot;&gt;新浪&lt;/a&gt;
规则: 想搜索&quot;www.baidu.com&quot; 仅此一个从&quot;开始 从&quot;结束 中间的片段
正则表达式: &quot;.*&quot; 由于默认是贪婪模式 它会找到的结果如下
&quot;www.baidu.com&quot;&gt; 百度 &lt;/a&gt; &lt;a href = “www.sina.com”

改成非贪婪模式 正则表达式：&quot;.*?&quot;
&quot;www.baidu.com&quot;  &quot;www.baidu.com&quot;
</code></pre>
<h3 id="表达式分组"><a href="#表达式分组" class="headerlink" title="表达式分组"></a>表达式分组</h3><ul>
<li>分组将”正则”分组为多个子表达式</li>
<li>示例：abababcdcdcd</li>
<li>正则表达式：(ab){3}(cd){3}</li>
</ul>
<h6 id="训练题目-2"><a href="#训练题目-2" class="headerlink" title="训练题目"></a>训练题目</h6><ul>
<li><p>匹配验证码(4位或6位)</p>
<pre><code class="java">(^\d&#123;4&#125;$)|(^\d&#123;6&#125;$)
</code></pre>
</li>
<li><p>匹配车牌号(冀B-U888G)</p>
<pre><code class="java">^([冀黑粤晋][A-Z])-([A-Z0-9]&#123;5&#125;)$
</code></pre>
</li>
<li><p>中文名字匹配 [Unicall码] [张三…]</p>
<pre><code class="java">^[\u4e00-\u9fa5]&#123;2,8&#125;$
</code></pre>
</li>
<li><p>中英文名字匹配</p>
<pre><code class="java">(^[\u4e00-\u9fa5]&#123;2,8&#125;$)|(^[A-Z][a-z]*$)
</code></pre>
</li>
</ul>
<h3 id="正则表达式验证JavaScript表单"><a href="#正则表达式验证JavaScript表单" class="headerlink" title="正则表达式验证JavaScript表单"></a>正则表达式验证JavaScript表单</h3><pre><code class="html">&lt;body&gt;
    &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;frmInfo&quot;&gt;
        &lt;div id=&quot;err&quot; style=&quot;color : red&quot;&gt;
            
        &lt;/div&gt; 
        &lt;div&gt;
            姓名: &lt;input id=&quot;name&quot; name=&quot;name&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            身份证: &lt;input id=&quot;idno&quot; name=&quot;idno&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;submit&quot;/&gt;
        &lt;/div&gt;
    &lt;/form&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        document.getElementById(&quot;frmInfo&quot;).onsubmit = function()&#123;
            //在JS中定义正则表达式对象只需要在 /正则表达式/
            var regex1 = /^[\u4e00-\u9fa5]&#123;2,8&#125;$/
            var regex2 = /^rehextal
            var name = document.getElementById(&quot;name&quot;).value;
            var idno = document.getElementByid(&quot;inamd&quot;)
            if(regex1.test(name)==false); //返回true或false校验是否成功
                document.getElementById(&quot;err&quot;).innerHTM=&quot;无效姓名&quot;;
                return false;
            &#125;else if(regx2.test(idno) == false)&#123;
                document.getElementById(&quot;err&quot;).innerHTM=&quot;无效身份证号&quot;;
            &#125;else&#123;
                alert(&quot;验证通过准备提交&quot;)
                return true;
            &#125;
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="Java中web页面信息提取"><a href="#Java中web页面信息提取" class="headerlink" title="Java中web页面信息提取"></a>Java中web页面信息提取</h4><pre><code class="html">sample.html
&lt;!DOCTYPEhtml&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;国际主要城市&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;国际主要城市&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;纽约NewYork&lt;/li&gt;
        &lt;li&gt;伦敦London&lt;/li&gt;
        &lt;li&gt;东京Tokyo&lt;/li&gt;
        &lt;li&gt;巴黎Paris&lt;/li&gt;
        &lt;li&gt;香港HongKong&lt;/li&gt;
        &lt;li&gt;新加坡Singapore&lt;/li&gt;
        &lt;li&gt;悉尼Sydney&lt;/li&gt;
        &lt;li&gt;米兰Milano&lt;/li&gt;
        &lt;li&gt;上海Shanghai&lt;/li&gt;
        &lt;li&gt;北京Beijing&lt;/li&gt;
        &lt;li&gt;马德里Madrid&lt;/li&gt;
        &lt;li&gt;莫斯科Moscow&lt;/li&gt;
        &lt;li&gt;首尔Seoul&lt;/li&gt;
        &lt;li&gt;曼谷Bangkok&lt;/li&gt;
        &lt;li&gt;多伦多Toronto&lt;/li&gt;
        &lt;li&gt;布鲁塞尔Brussels&lt;/li&gt;
        &lt;li&gt;芝加哥Chicago&lt;/li&gt;
        &lt;li&gt;吉隆坡KualaLumpur&lt;/li&gt;
        &lt;li&gt;孟买Mumbai&lt;/li&gt;
        &lt;li&gt;华沙Warsaw&lt;/li&gt;
        &lt;li&gt;圣保罗SaoPaulo&lt;/li&gt;
        &lt;li&gt;苏黎世Zurich&lt;/li&gt;
        &lt;li&gt;阿姆斯特丹Amsterdam&lt;/li&gt;
        &lt;li&gt;墨西哥城MexicoCity&lt;/li&gt;
        &lt;li&gt;雅加达Jakarta&lt;/li&gt;
        &lt;li&gt;都柏林Dublin&lt;/li&gt;
        &lt;li&gt;曼谷Bangkok&lt;/li&gt;
        &lt;li&gt;台北Taipei&lt;/li&gt;
        &lt;li&gt;伊斯坦布尔Istanbul&lt;/li&gt;
        &lt;li&gt;里斯本Lisbon&lt;/li&gt;
        &lt;li&gt;罗马Rome&lt;/li&gt;
        &lt;li&gt;法兰克福Frankfurt&lt;/li&gt;
        &lt;li&gt;斯德哥尔摩Stockholm&lt;/li&gt;
        &lt;li&gt;布拉格Prague&lt;/li&gt;
        &lt;li&gt;维也纳Vienna&lt;/li&gt;
        &lt;li&gt;布达佩斯Budapest&lt;/li&gt;
        &lt;li&gt;雅典Athens&lt;/li&gt;
        &lt;li&gt;加拉加斯Caracas&lt;/li&gt;
        &lt;li&gt;洛杉矶LosAngeles&lt;/li&gt;
        &lt;li&gt;新西兰NewZealand&lt;/li&gt;
        &lt;li&gt;圣地亚哥SanDiego&lt;/li&gt;
        &lt;li&gt;布宜诺斯艾利斯BuenosAires&lt;/li&gt;
        &lt;li&gt;华盛顿Washington&lt;/li&gt;
        &lt;li&gt;墨尔本Melbourne&lt;/li&gt;
        &lt;li&gt;约翰内斯堡Johannesburg&lt;/li&gt;
        &lt;li&gt;亚特兰大Atlanta&lt;/li&gt;
        &lt;li&gt;巴塞罗那Barcelona&lt;/li&gt;
        &lt;li&gt;旧金山SanFrancisco&lt;/li&gt;
        &lt;li&gt;马尼拉Manila&lt;/li&gt;
        &lt;li&gt;波哥大Bogota&lt;/li&gt;
        &lt;li&gt;特拉维夫TelAviv-Yafo&lt;/li&gt;
        &lt;li&gt;新德里NewDelhi&lt;/li&gt;
        &lt;li&gt;迪拜Dubai&lt;/li&gt;
        &lt;li&gt;布加勒斯特Bucharest&lt;/li&gt;
        &lt;li&gt;奥斯陆Oslo&lt;/li&gt;
        &lt;li&gt;柏林Berlin&lt;/li&gt;
        &lt;li&gt;赫尔辛基Helsinki&lt;/li&gt;
        &lt;li&gt;日内瓦Geneva&lt;/li&gt;
        &lt;li&gt;利雅得Riyadh&lt;/li&gt;
        &lt;li&gt;哥本哈根Copenhagen&lt;/li&gt;
        &lt;li&gt;汉堡Hamburg&lt;/li&gt;
        &lt;li&gt;开罗Cairo&lt;/li&gt;
        &lt;li&gt;卢森堡Luxembourg&lt;/li&gt;
        &lt;li&gt;班加罗尔Bangalore&lt;/li&gt;
        &lt;li&gt;达拉斯Dallas&lt;/li&gt;
        &lt;li&gt;科威特城Kuwaitcity&lt;/li&gt;
        &lt;li&gt;波士顿Boston&lt;/li&gt;
        &lt;li&gt;慕尼黑Munich&lt;/li&gt;
        &lt;li&gt;迈阿密Miami&lt;/li&gt;
        &lt;li&gt;利马Lima&lt;/li&gt;
        &lt;li&gt;基辅Kiev&lt;/li&gt;
        &lt;li&gt;休斯顿Houston&lt;/li&gt;
        &lt;li&gt;广州Guangzhou&lt;/li&gt;
        &lt;li&gt;贝鲁特Beirut&lt;/li&gt;
        &lt;li&gt;卡拉奇Karachi&lt;/li&gt;
        &lt;li&gt;索菲亚Sophia&lt;/li&gt;
        &lt;li&gt;蒙得维的亚Montevideo&lt;/li&gt;
        &lt;li&gt;里约热内卢RioDEJaneiro&lt;/li&gt;
        &lt;li&gt;胡志明市HoChiMinhCity&lt;/li&gt;
        &lt;li&gt;蒙特利尔Montreal&lt;/li&gt;
        &lt;li&gt;内罗毕Nairobi&lt;/li&gt;
        &lt;li&gt;巴拿马城Panamacity&lt;/li&gt;
        &lt;li&gt;金奈Chennai&lt;/li&gt;
        &lt;li&gt;布里斯班Brisbane&lt;/li&gt;
        &lt;li&gt;卡萨布兰卡Casablanca&lt;/li&gt;
        &lt;li&gt;丹佛Denver&lt;/li&gt;
        &lt;li&gt;基多Quito&lt;/li&gt;
        &lt;li&gt;斯图加特Stuttgart&lt;/li&gt;
        &lt;li&gt;温哥华Vancouver&lt;/li&gt;
        &lt;li&gt;麦纳麦MaiNaMai&lt;/li&gt;
        &lt;li&gt;危地马拉市Guatemalacity&lt;/li&gt;
        &lt;li&gt;开普敦CapeTown&lt;/li&gt;
        &lt;li&gt;圣何塞SanJose&lt;/li&gt;
        &lt;li&gt;西雅图Seattle&lt;/li&gt;
        &lt;li&gt;深圳Shenzhen&lt;/li&gt;
        &lt;li&gt;珀斯Perth&lt;/li&gt;
        &lt;li&gt;加尔各答Calcutta&lt;/li&gt;
        &lt;li&gt;安特卫普Antwerp&lt;/li&gt;
        &lt;li&gt;费城Philadelphia&lt;/li&gt;
        &lt;li&gt;鹿特丹Rotterdam&lt;/li&gt;
        &lt;li&gt;拉各斯Lagos&lt;/li&gt;
        &lt;li&gt;波特兰Portland&lt;/li&gt;
        &lt;li&gt;底特律Detroit&lt;/li&gt;
        &lt;li&gt;曼彻斯特Manchester&lt;/li&gt;
        &lt;li&gt;惠灵顿Wellington&lt;/li&gt;
        &lt;li&gt;里加Riga&lt;/li&gt;
        &lt;li&gt;爱丁堡Edinburgh&lt;/li&gt;
        &lt;li&gt;圣彼得堡StPetersburg&lt;/li&gt;
        &lt;li&gt;圣迭戈SanDiego&lt;/li&gt;
        &lt;li&gt;伊斯兰堡Islamabad&lt;/li&gt;
        &lt;li&gt;伯明翰Birmingham&lt;/li&gt;
        &lt;li&gt;多哈Doha&lt;/li&gt;
        &lt;li&gt;阿拉木图AlmaAtaAlmaty&lt;/li&gt;
        &lt;li&gt;卡尔加里Calgary&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">RegexSample.java
package com.imooc.regex;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexSample &#123;
    public static void main(String[] args) &#123;
        StringBuilder content = new StringBuilder();
        try &#123;//读取文件
            FileInputStream fis = new FileInputStream(&quot;D:/workspace/regex/WebContent/sample.html&quot;);
            InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);
            BufferedReader bufferedReader = new BufferedReader(isr);//缓冲提高读取效率
            String lineText = &quot;&quot;;//每一行
            while((lineText = bufferedReader.readLine()) != null) &#123;//读取完成
//                System.out.println(lineText);
                content.append(lineText + &quot;\n&quot;);//追加到后面完整字符串
            &#125;
            bufferedReader.close();
            System.out.println(content);
        
        &#125; catch (Exception e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        //1.创建正则表达式对象 用group进行分组提取
        //[正则表达式字符串] \\两个斜杠是原意输出 +至少出现一次
        Pattern p = Pattern.compile(&quot;&lt;li&gt;([\\u4e00-\\u9fa5]&#123;2,10&#125;)([a-zA-Z]+)&lt;/li&gt;&quot;);
        //2.匹配正则表达式
        Matcher m = p.matcher(content);
        //3.查找匹配的结果
        while(m.find()) &#123;//原始字符串中进行查找 有返回true 无返回false
//            System.out.println(m.group(0)); //完整字符串
            String chs = m.group(1); //group分组
            String eng = m.group(2);
            System.out.println(chs + &quot;-&quot; + eng);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="初始过滤器-Filter-机场检查"><a href="#初始过滤器-Filter-机场检查" class="headerlink" title="初始过滤器-Filter [机场检查]"></a>初始过滤器-Filter [机场检查]</h1><ul>
<li>过滤器(Filter)是J2EE Servlet模块下的组件</li>
<li>Filter的作用是对URL进行统一的拦截处理</li>
<li>Filter通常用于应用程序层面进行全局处理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d75b8480442f629a7ae682cbcc3c6d6040d674c6/data/%E8%BF%87%E6%BB%A4%E5%99%A8.png"></p>
<h3 id="开发过滤器三要素"><a href="#开发过滤器三要素" class="headerlink" title="开发过滤器三要素"></a>开发过滤器三要素</h3><ul>
<li>任何过滤器都要实现 <strong>javax.servlet.Filter</strong> 接口</li>
<li>在Filter接口的doFIlter()方法中编写过滤器的功能代码</li>
<li>在web.xml中对过滤器进行配置，说明拦截URL的范围</li>
</ul>
<pre><code class="java">MyFirstFilter.java
public class MyFirstFilter implements Filter&#123;
   public void destroy()&#123;&#125;
   public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       System.out.println(&quot;过滤器已生效&quot;);
       chain.doFilter(req, resp);
   &#125;
   public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.MyFirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //对所有url进行拦截
&lt;/filter-mapping&gt;

&lt;!-- 
    filter-mapping标签用于说明过滤器对URL应用的范围
    1. filter-name 过滤器名称与filter.filter-name保持一致
    2. url-pattern 说明过滤器作用范围 &quot;/*&quot;代表对所有url进行过滤
--&gt;
</code></pre>
<pre><code class="html">&lt;body&gt;
    我是默认首页
&lt;/body&gt;
</code></pre>
<pre><code class="java">HelloServlet.java
@WebServlet(&quot;/hello&quot;)
public class HelloServlet extends HttpServlet&#123;
    public HelloServlet()&#123;&#125;
    protected void doGet(HttpServletReq req, HttpServletResp resp)&#123;
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().println(&quot;Hello World!!!&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="过滤器的生命周期"><a href="#过滤器的生命周期" class="headerlink" title="过滤器的生命周期"></a>过滤器的生命周期</h3><ul>
<li>初始化init() - <strong>Filter.init()</strong></li>
<li>提供服务 - <strong>Filter.doFilter()</strong></li>
<li>销毁 - <strong>Filter.destroy()</strong></li>
</ul>
<h3 id="过滤器特性"><a href="#过滤器特性" class="headerlink" title="过滤器特性"></a>过滤器特性</h3><ul>
<li>过滤器对象在Web应用启动时被<strong>创建且全局唯一</strong></li>
<li>唯一的过滤器对象在<strong>并发环境</strong>中采用”<strong>多线程</strong>“提供服务</li>
</ul>
<h3 id="过滤器两种开发方式"><a href="#过滤器两种开发方式" class="headerlink" title="过滤器两种开发方式"></a>过滤器两种开发方式</h3><h5 id="过滤器的配置形式"><a href="#过滤器的配置形式" class="headerlink" title="过滤器的配置形式"></a>过滤器的配置形式</h5><pre><code class="xml">&lt;filter&gt;
   &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
   &lt;filter-class&gt;filter.MyFirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
   &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
   &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //对所有url进行拦截
&lt;/filter-mapping&gt;
</code></pre>
<h5 id="过滤器的注解形式"><a href="#过滤器的注解形式" class="headerlink" title="过滤器的注解形式"></a><span style = "color : red">过滤器的注解形式</span></h5><pre><code class="java">@WebFilter(filterName = &quot;MyAnnoationFilter&quot;, urlPatterns = &quot;/*&quot;)
public class MyAnnoationFilter implements Filter&#123;
    
&#125;
</code></pre>
<hr>
<pre><code class="java">MyAnnoationFilter.java      //自定义过滤器名称  设置去过滤哪些url
@@WebFilter(filterName = &quot;MyAnnoationFilter&quot;, urlPatterns = &quot;/*&quot;)
public class MyAnnoationFilter implements Filter&#123;
    public void destroy()&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
        System.out.println(&quot;过滤器已生效&quot;);
        chain.doFilter(req, resp);
    &#125;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
&#125;
</code></pre>
<h3 id="配置与注解如何选择"><a href="#配置与注解如何选择" class="headerlink" title="配置与注解如何选择"></a>配置与注解如何选择</h3><ul>
<li><span style = "color :blue"><strong>配置形式</strong>维护性更好，适合应用全局过滤 [<strong>中, 大型项目</strong>]</span></li>
<li><strong>注解形式</strong>开发体验更好，适合于小型项目敏捷开发</li>
</ul>
<h3 id="Web中文乱码的解决-需要强制转换"><a href="#Web中文乱码的解决-需要强制转换" class="headerlink" title="Web中文乱码的解决 [需要强制转换]"></a>Web中文乱码的解决 [需要强制转换]</h3><ul>
<li><strong>GET请求</strong>-server.xml增加<strong>URIEncoding &#x3D; “UTF-8”;</strong></li>
<li><strong>POST请求</strong>-使用<strong>request.setCharacterEncoding(“UTF-8”);</strong></li>
<li>响应-<strong>response.setContentType(“text&#x2F;html; charset &#x3D; UTF-8”);</strong></li>
</ul>
<pre><code class="java">CharacterEncodingFilter.java
public class CharacterEncodingFilter implements Filter&#123;
    public void destroy()&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       //上面的不是Httpservlet要自己写HttpServlet并导入 解决post请求中的中文乱码
        HttpServletRequest req = (HttpServletRequest)request;//解决中文乱码问题
        req.serCharacterEncoding(&quot;UTF-8&quot;);
        HttpServletResponse res = (HttpServletResponse)response;//解决中文乱码问题
        res.serContentType(&quot;text/html;charset=UTF-8&quot;);
        chain.doFilter(req, response);
    &#125;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
&#125;
</code></pre>
<h6 id="ServletRequest-最顶级-和-HTTPServletRequest-需继承最顶级-关系所在"><a href="#ServletRequest-最顶级-和-HTTPServletRequest-需继承最顶级-关系所在" class="headerlink" title="ServletRequest[最顶级] 和 HTTPServletRequest[需继承最顶级]关系所在"></a>ServletRequest[最顶级] 和 HTTPServletRequest[需继承最顶级]关系所在</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/2407935960fe789c39d7ed5dcfd439551b455a97/data/ServletRequest%E6%8E%A5%E5%8F%A3.png"></p>
<pre><code class="xml">web.xml
&lt;filter&gt;
    &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.MyFirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;MyFirstFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //对所有url进行拦截
&lt;/filter-mapping&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //对所有url进行拦截
&lt;/filter-mapping&gt;

====================================================================

&lt;!--或者在CharacterEncodingFilter上方进行注解 必须是全局唯一--&gt;
@WebFilter(filterName=&quot;CharacterEncodingFilter&quot;, urlPatterns=&quot;/*&quot;)
</code></pre>
<pre><code class="java">HelloServlet.java
@WebServlet(&quot;/hello&quot;)
public class HelloServlet extends HttpServlet&#123;
    public HelloServlet()&#123;&#125;
    protected void doGet(HttpServletReq req, HttpServletResp resp)&#123;
        resp.getWriter().println(&quot;你好！世界！！&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="过滤器开发技巧"><a href="#过滤器开发技巧" class="headerlink" title="过滤器开发技巧"></a>过滤器开发技巧</h3><h5 id="过滤器参数化"><a href="#过滤器参数化" class="headerlink" title="过滤器参数化"></a>过滤器参数化</h5><ul>
<li>过滤器为了增强灵活性，允许配置信息放在web.xml</li>
<li>在web.xml中配置**&lt; init-param &gt;**设置过滤器参数</li>
</ul>
<h5 id="优化字符集过滤器-为了不去修改java代码"><a href="#优化字符集过滤器-为了不去修改java代码" class="headerlink" title="优化字符集过滤器 [为了不去修改java代码]"></a>优化字符集过滤器 [为了不去修改java代码]</h5><pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;!--方便参数发生变化--&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;v1&lt;/param-name&gt;
        &lt;param-value&gt;GBK&lt;/param-value&gt;
    &lt;/init-param&gt;
    ......
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; //对所有url进行拦截
&lt;/filter-mapping&gt;
-------------------------------------------------------------
&lt;!--或者在CharacterEncodingFilter上方进行注解 必须是全局唯一--&gt;
@WebFilter(filterName=&quot;CharacterEncodingFilter&quot;, urlPatterns=&quot;/*&quot;,initParams=&#123;
    @WebInitParam(name=&quot;encoding&quot;, value=&quot;UTF-8&quot;),
    @WebInitParam(name=&quot;p1&quot;, value=&quot;v1&quot;)
&#125;)
</code></pre>
<pre><code class="java">-------------------------注意init与doFilter----------------------------
public class CharacterEncodingFilter implements Filter&#123;
    private String encoding; //类中的全局私有变量
    public void init(FilterConfig filterConfig)thorws ServletException&#123;
        encoding=filterConfig.getInitParameter(&quot;encoding&quot;);
        System.out.println(encoding); //用debug打开
    &#125;
    public void doFilter(ServletRequest req, ServeltResponse resp, FilterChain chain)throws IOException,ServletException&#123;
       //上面的不是Httpservlet要自己写HttpServlet并导入 解决post请求中的中文乱码
        HttpServletRequest req = (HttpServletRequest)request;//解决中文乱码问题
        req.setCharacterEncoding(&quot;encoding&quot;);
        HttpServletResponse res = (HttpServletResponse)response;//解决中文乱码问题
        res.setContentType(&quot;text/html;charset=&quot; + encoding);// GBK/UTF-8或者其他
        chain.doFilter(req, response);
    &#125;
&#125;
</code></pre>
<h3 id="url-pattern设置过滤范围"><a href="#url-pattern设置过滤范围" class="headerlink" title="url-pattern设置过滤范围"></a>url-pattern设置过滤范围</h3><h5 id="url-pattern常用写法"><a href="#url-pattern常用写法" class="headerlink" title="url-pattern常用写法"></a>url-pattern常用写法</h5><ul>
<li>&#x2F;index.jsp - 执行资源精准匹配</li>
<li>&#x2F;servlet&#x2F;* - 以前缀进行模糊匹配</li>
<li>*.jsp - 以后缀进行模糊匹配</li>
</ul>
<pre><code class="java">SampleServlet1.java
@WebServlet(&quot;/servlet/sample1&quot;)
public class SampleServlet1 extends HttpServlet&#123;
   public SampleServlet1()&#123;&#125;
   protected void doGet(HttpServletRequest req,HttpServletResponse resp)&#123;
       resp.getWriter().println(&quot;I&#39;m&quot; + this.getClass().getSimpleName());
   &#125;
&#125;
</code></pre>
<pre><code class="java">UrlPatternFilter.java
public class UrlPatternFilter implements Filter&#123;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
//上面的不是Httpservlet要自己写HttpServlet并导入 解决post请求中的中文乱码
    HttpServletRequest req = (HttpServletRequest)request;//解决中文乱码问题
    HttpServletResponse res = (HttpServletResponse)response;//解决中文乱码问题
&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;UrlPatternFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.UrlPatternFilter&lt;/filter-class&gt;
&lt;/filter&gt;
    &lt;filter-mapping&gt; &lt;!--  &lt;url-pattern&gt;/test.jsp&lt;/url-pattern&gt; &lt;!--只对其进行过滤 --&gt;
        &lt;param-name&gt;UrlPatternFilter&lt;/param-name&gt;
        &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ......
</code></pre>
<blockquote>
<p>在控制台Console显示：拦截到<a target="_blank" rel="noopener" href="http://localhost:8080/url-pattern/test.jsp">http://localhost:8080/url-pattern/test.jsp</a>  因为这是精准匹配 需要换成 <strong>&#x2F;</strong>*</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3921d7a4ad3d1c7e96c980109c605e1e7568de73/data/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E4%BE%8B.png"></p>
<h3 id="x2F-映射的问题"><a href="#x2F-映射的问题" class="headerlink" title="&#x2F; 映射的问题"></a>&#x2F; 映射的问题</h3><ul>
<li><strong>&#x2F;</strong> 指映射Web应用根路径, 且只会对Servlet生效</li>
<li>默认首页index.jsp会让 <strong>&#x2F;</strong> 失效</li>
<li><strong>&#x2F;</strong> 与 <strong>&#x2F;</strong>* 含义不同, 前者指向根路径, 后者代表所有</li>
</ul>
<pre><code class="java">SampleServlet2.java
@WebServlet(&quot;/&quot;)
public class SampleServlet2 extends HttpServlet&#123;
    public SampleServlet1()&#123;&#125;
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)&#123;
        resp.getWriter().println(&quot;I&#39;m&quot; + this.getClass().getSimpleName());
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;UrlPatternFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.UrlPatternFilter&lt;/filter-class&gt;
&lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;UrlPatternFilter&lt;/param-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;UrlPatternFilter&lt;/param-name&gt;
        &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;UrlPatternFilter&lt;/param-name&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ......
-------------------------------------------------------------
&lt;!--或者在UrlPatternFilter上方进行注解 必须是全局唯一--&gt;
@WebFilter(filterName=&quot;UrlPatternFilter&quot;, urlPatterns=&#123;
    &quot;/&quot;,&quot;/servlet/*&quot;,&quot;*.jsp&quot;
&#125;)
</code></pre>
<p>这个url-pattern 中的**&#x2F;** 只会映射到根路径的SampleServlet2</p>
<blockquote>
<p>@WebServlet(“&#x2F;“)<br>public class SampleServlet2 extends HttpServlet{</p>
</blockquote>
<p>Web.xml中默认配置了首页为<strong>index.jsp</strong> 如果想对默认首页拦截需要写<br>&lt; url-pattern&gt; ***&#x2F;** &lt; &#x2F;url-pattern&gt; 或 &lt; url-pattern&gt; <strong>&#x2F;index.jsp</strong> &lt; &#x2F;url-pattern&gt;<br>默认首页优先级比servlet要高</p>
<h3 id="过滤链"><a href="#过滤链" class="headerlink" title="过滤链"></a>过滤链</h3><h5 id="过滤链开发注意事项"><a href="#过滤链开发注意事项" class="headerlink" title="过滤链开发注意事项"></a>过滤链开发注意事项</h5><ul>
<li>每一个过滤器应具有单独职能</li>
<li>过滤器的执行顺序以**&lt; filter-mapping &gt;**的前后顺序为准</li>
<li>调用**chain.doFilter()**将请求向后传递</li>
</ul>
<pre><code class="java">FilterA.java
public class FilterA implements Filter&#123;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       System.out.println(&quot;I&#39;m Filter A&quot;);
       chain.doFilter(req, resp);
    &#125;
    public void destroy()&#123;&#125;

FilterB.java
public class FilterA implements Filter&#123;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       System.out.println(&quot;I&#39;m Filter B&quot;);
       chain.doFilter(req, resp);
    &#125;
    public void destroy()&#123;&#125;

FilterC.java
public class FilterA implements Filter&#123;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       System.out.println(&quot;I&#39;m Filter C&quot;);
       chain.doFilter(req, resp);
    &#125;
    public void destroy()&#123;&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;FilterA&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.FilterA&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter&gt;
    &lt;filter-name&gt;FilterB&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.FilterA&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter&gt;
    &lt;filter-name&gt;FilterC&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.FilterA&lt;/filter-class&gt;
&lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;FilterA&lt;/param-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;FilterB&lt;/param-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;FilterC&lt;/param-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
---------------------不推荐使用注解--------------------------
用注解方式需要在每个Filter.java上面添加注解 
@WebFilter(filterName=&quot;FilterA&quot;, urlPatterns=&quot;/*&quot;)
public class FilterA implements Filter&#123;
    //按照字母表升序排序 且不区分大小写
&#125;
</code></pre>
<pre><code class="java">HelloServlet.java
@WebServlet(&quot;/hello&quot;)
public class HelloServlet extends HttpServlet&#123;
    public HelloServlet()&#123;&#125;
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException&#123;
        response.getWriter().print(&quot;Hello World!&quot;);
        Sysotem.out.println(&quot;Hello World!&quot;)
    &#125;
&#125;
</code></pre>
<blockquote>
<p>Console显示：顺序由<filter-mapping>决定<br>I’m Filter A      &#x2F;&#x2F;chain.doFilter(req, resp); 请求顺着过滤链往下走<br>I’m Filter B<br>I’m Filter C      &#x2F;&#x2F;过滤链没有格外的过滤器了 回到HelloServlet.java最终处理<br>Hello World!<br>&#x2F;&#x2F;servlet处理完以后按照原先的顺序 逆向由Hello、C、B、A顺序返回</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/feed3d659f7f61c2ae891d07fb5a43a42672e13b/data/%E8%BF%87%E6%BB%A4%E9%93%BE%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p>
<blockquote>
<p>刻意去控制过滤器访问 VPN 仅限中国访问 如果是中国地址就调用<strong>chain.doFilter</strong>进行放行 其本质是防火墙</p>
</blockquote>
<h3 id="多端设备自动匹配-Pc端-移动端"><a href="#多端设备自动匹配-Pc端-移动端" class="headerlink" title="多端设备自动匹配(Pc端 移动端)"></a>多端设备自动匹配(Pc端 移动端)</h3><h5 id="设备适配过滤器"><a href="#设备适配过滤器" class="headerlink" title="设备适配过滤器"></a>设备适配过滤器</h5><pre><code class="html">index.html
自动脑补绘制两个html首页
一个是电脑端的图片展示
一个是手机端的图片展示
</code></pre>
<pre><code class="java">DeviceAdapterFilter.java
public class DeviceAdapterFilter implements Filter&#123;
    public void init(FilterConfig filterConfig)thorws ServletException&#123;&#125;
    public void doFilter(ServletRequest req, ServeltResponse resp)throws IOException,ServletException,FilterChain chain&#123;
       HttpServletRequest req = (HttpServletRequest)request;//强制类型转换
          HttpServletResponse res = (HttpServletResponse)response;
       /*
       /index.html
        PC: /desktop/index.html
        MOBILE: /mobile/index.html

       /test.html
        PC: /desktop/test.html
        MOBILE: /mobile/test.html
       */
       String uri = req.getRequestURI();
       System.out.println(&quot;URI: &quot; + uri);
       if(uri.startsWith(&quot;/desktop&quot;) || uri.startsWith(&quot;/mobile&quot;))&#123;
           chain.doFilter(req, resp);
       &#125;else &#123;    //读取客户端请求头 所有字符串转成小写
           String userAgent = req.getHeader(&quot;user-agent&quot;).toLowerCase(); 
           String targetURL = &quot;&quot;;
           if(userAgent.indexOf(&quot;android&quot;)!=-1 || userAgent.indexOf(&quot;iphone&quot;)!=-1)&#123;
               targetURI = &quot;/mobile&quot; + uri;
               System.out.println(&quot;移动端设备正在访问, 重新跳转URI: &quot; + targetURI)
               res.sendRedircet(targetURI); //向/mobile对应页面进行获取
           &#125;else &#123;
               targetURI = &quot;/desktop&quot; + uri;
                System.out.println(&quot;PC端设备正在访问, 重新跳转URI: &quot; + targetURI)
               res.sendRedircet(targetURI); //向/mobile对应页面进行获取
           &#125;
       &#125;
    &#125;
    public void destroy()&#123;&#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;filter&gt;
    &lt;filter-name&gt;DeviceAdapterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;filter.DeviceAdapterFilter&lt;/filter-class&gt;
&lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;param-name&gt;DeviceAdapterFilter&lt;/param-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;!--对其进行过滤--&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>URI: &#x2F;index.html<br>PC端设备正在访问, 重新跳转URI: &#x2F;desktop&#x2F;index.html<br>URI: &#x2F;desktop&#x2F;index.html</p>
<p>++++++++++++++++++++++++++++++++++++++++++++</p>
<p>URI: &#x2F;index.html<br>移动端设备正在访问, 重新跳转URI: &#x2F;mobile&#x2F;index.html<br>URI: &#x2F;mobile&#x2F;index.html</p>
</blockquote>
<h1 id="监听器、Freemarker"><a href="#监听器、Freemarker" class="headerlink" title="监听器、Freemarker"></a>监听器、Freemarker</h1><h6 id="监听器：对Web应用对象的行为进行监控-触发事件后进行捕获-★★★"><a href="#监听器：对Web应用对象的行为进行监控-触发事件后进行捕获-★★★" class="headerlink" title="监听器：对Web应用对象的行为进行监控 [触发事件后进行捕获] ★★★"></a>监听器：对Web应用对象的行为进行监控 [触发事件后进行捕获] ★★★</h6><h6 id="Freemarker-模板引擎-：模板脚本-数据来实现最终数据的产生-★★★★★"><a href="#Freemarker-模板引擎-：模板脚本-数据来实现最终数据的产生-★★★★★" class="headerlink" title="Freemarker[模板引擎]：模板脚本+数据来实现最终数据的产生 ★★★★★"></a>Freemarker[模板引擎]：模板脚本+数据来实现最终数据的产生 ★★★★★</h6><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p><strong>生活中的”监听器”<strong>：汽车自动刹车系统 自动检测前方障碍物触发自动刹车；实时监控</strong>电表</strong>水表 钱不足直接断电</p>
<h6 id="监听器-Listener"><a href="#监听器-Listener" class="headerlink" title="监听器 - Listener"></a>监听器 - Listener</h6><ul>
<li>监听器(Listener)是J2EE Servlet模块下的组件</li>
<li>Listener的作用对Web应用对象的行为进行监控</li>
<li>通过Listener监听自动触发指定的功能代码</li>
</ul>
<h3 id="三种监听对象"><a href="#三种监听对象" class="headerlink" title="三种监听对象"></a>三种监听对象</h3><ul>
<li><strong>ServletContext</strong> - 对全局ServletContext及其属性进行监听</li>
<li><strong>HttpSession</strong> - 对用户会话及其属性操作进行监听</li>
<li><strong>ServletRequest</strong> - 对请求及属性操作进行监听</li>
</ul>
<h6 id="过滤器与监听器的区别"><a href="#过滤器与监听器的区别" class="headerlink" title="过滤器与监听器的区别"></a>过滤器与监听器的区别</h6><ul>
<li><strong>过滤器</strong>(Filter)的职责是对**<u>URL进行过滤拦截</u>**, 是主动的执行</li>
<li><strong>监听器</strong>(Listener)的职责是对**<u>Web对象进行监听</u>**, 是被动触发</li>
</ul>
<h3 id="开发监听器三要素"><a href="#开发监听器三要素" class="headerlink" title="开发监听器三要素"></a>开发监听器三要素</h3><ul>
<li>实现XxxListener接口, 不同接口对应不同监听对象</li>
<li>实现每个接口中独有的方法, 实现触发监听的后续操作</li>
<li>在web.xml中配置**&lt; listener &gt;**使监听器生效</li>
</ul>
<p>&#96;&#96;</p>
<h3 id="第一个监听器-全局推荐使用配置形式"><a href="#第一个监听器-全局推荐使用配置形式" class="headerlink" title="第一个监听器 [全局推荐使用配置形式]"></a>第一个监听器 [全局推荐使用<u>配置形式</u>]</h3><pre><code class="java">FirstListener.java //Debug启动
@WebListener //启动时tomcat会自动扫描
public class FirstListener implements ServletContextListener&#123;
    //项目初始化所触发
    public void contextInitialized(ServletContextEvent sce)&#123;
        System.out.println(&quot;ServletContext已初始化&quot;);
    &#125;
    //上下文被销毁时所触发 关闭时自动销毁
    public void contextDestoryed(ServletContextEvent sce)&#123;
       System.out.println(&quot;ServletContext已销毁&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;com.imooc.listener.FirstListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h3 id="内置对象监听接口"><a href="#内置对象监听接口" class="headerlink" title="内置对象监听接口"></a>内置对象监听接口</h3><ul>
<li><strong>ServletContextListener</strong> - 监听ServletContext对象创建、销毁等操作</li>
<li><strong>HttpSessionListener</strong> - 监听HttpSession对象创建、销毁等操作</li>
<li><strong>ServletRequestListener</strong> - 监听HttpServletRequest对象创建、销毁等操作</li>
</ul>
<pre><code class="xml">&lt;listener&gt;
    &lt;listener-class&gt;com.example.json.WebListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<pre><code class="java">HelloServlet.java //设置属性的时候会触发WebListener
WebServlet(&quot;/hello&quot;)
public class HelloServlet extends HttpServlet&#123;
    public HelloServlet()&#123;&#125;
    protected void doGet(HttpServletRequest req,HttpServletResponse resp)&#123;
        resp.getWriter().println(&quot;Hello World&quot;);
        req.getServletContext().setAttribute(&quot;sc-attr1&quot;,&quot;sc-attr-value1&quot;);
        req.getSession().setAttribute(&quot;session-attr1&quot;,&quot;session-attr-value1&quot;);
        req.setAttribute(&quot;request-attr1&quot;,&quot;request-attr-value1&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">WebListener.java
package com.example.json;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

public class WebListener implements ServletContextListener, HttpSessionListener, ServletRequestListener &#123;
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;
        System.out.println(&quot;ServletContext已初始化&quot;);
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;
        System.out.println(&quot;ServletContext已被销毁&quot;);
    &#125;

    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;
        HttpSession session = httpSessionEvent.getSession();
        System.out.println(&quot;Session已被创建, SessionId:&quot; + session);
    &#125;

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;
        System.out.println(&quot;Session已被销毁&quot;);
    &#125;

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;
        System.out.println(&quot;HttpServletRequest已被销毁&quot;);
    &#125;

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;
        HttpServletRequest request = (HttpServletRequest)servletRequestEvent.getServletRequest();
        //请求初始化完毕
        System.out.println(&quot;HttpServletRequest已被创建, URI&quot; + request.getRequestURI());
    &#125;
&#125;

//session被创建了以后 第二次从同样的浏览器发出的请求覆盖了sessionid(3min后过期可人为而改变) 隐藏且可用
HttpServletRequest已被创建, URI/json_war_exploded/
Session已被创建, SessionId:org.apache.catalina.session.StandardSessionFacade@71ed02bc
HttpServletRequest已被销毁
HttpServletRequest已被创建, URI/json_war_exploded/
Session已被创建, SessionId:org.apache.catalina.session.StandardSessionFacade@194a08e0
HttpServletRequest已被销毁
</code></pre>
<h3 id="属性监听接口-了解"><a href="#属性监听接口-了解" class="headerlink" title="属性监听接口 [了解]"></a>属性监听接口 [了解]</h3><ul>
<li><strong>ServletContextAttributeListener</strong> - 监听全局属性操作</li>
<li><strong>HttpSessionAttributeListener</strong> - 监听用户会话属性操作</li>
<li><strong>ServletRequestAttributeListener</strong> - 监听请求属性操作</li>
</ul>
<pre><code class="java">web.xml 和 helloServlet.java的代码都一样
</code></pre>
<pre><code class="java">WebAttributeListener.java
package com.example.json;

import javax.servlet.ServletContextAttributeEvent;
import javax.servlet.ServletContextAttributeListener;
import javax.servlet.ServletRequestAttributeEvent;
import javax.servlet.ServletRequestAttributeListener;
import javax.servlet.http.HttpSessionAttributeListener;
import javax.servlet.http.HttpSessionBindingEvent;

public class WebAttributeListener implements ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener &#123;
    @Override
    public void attributeAdded(ServletContextAttributeEvent servletContextAttributeEvent) &#123;
        System.out.println(&quot;ServletContext新增属性：&quot; + servletContextAttributeEvent.getName() + &quot;-&gt;&quot; + servletContextAttributeEvent.getValue());
    &#125;

    @Override
    public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) &#123;

    &#125;

    @Override
    public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) &#123;

    &#125;

    @Override
    public void attributeAdded(ServletRequestAttributeEvent servletRequestAttributeEvent) &#123;
        System.out.println(&quot;ServletRequestAttributeEvent新增属性：&quot; + servletRequestAttributeEvent.getName() + &quot;-&gt;&quot; + servletRequestAttributeEvent.getValue());

    &#125;

    @Override
    public void attributeRemoved(ServletRequestAttributeEvent servletRequestAttributeEvent) &#123;

    &#125;

    @Override
    public void attributeReplaced(ServletRequestAttributeEvent servletRequestAttributeEvent) &#123;

    &#125;

    @Override
    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) &#123;
        System.out.println(&quot;HttpSessionBindingEvent新增属性：&quot; + httpSessionBindingEvent.getName() + &quot;-&gt;&quot; + httpSessionBindingEvent.getValue());
    &#125;

    @Override
    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) &#123;

    &#125;

    @Override
    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) &#123;

    &#125;
&#125;

ServletContext已初始化
[2023-09-28 04:44:52,590] Artifact json:war exploded: Artifact is deployed successfully
[2023-09-28 04:44:52,590] Artifact json:war exploded: Deploy took 394 milliseconds
HttpServletRequest已被创建, URI/json_war_exploded/
ServletContext新增属性：org.apache.jasper.runtime.JspApplicationContextImpl-&gt;org.apache.jasper.runtime.JspApplicationContextImpl@7753fcd4
ServletContext新增属性：org.apache.jasper.compiler.ELInterpreter-&gt;org.apache.jasper.compiler.ELInterpreterFactory$DefaultELInterpreter@3b424c58
ServletContext新增属性：org.apache.jasper.compiler.StringInterpreter-&gt;org.apache.jasper.compiler.StringInterpreterFactory$DefaultStringInterpreter@15bdbfaf
Session已被创建, SessionId:org.apache.catalina.session.StandardSessionFacade@6baa8579
HttpServletRequest已被销毁
HttpServletRequest已被创建, URI/json_war_exploded/
Session已被创建, SessionId:org.apache.catalina.session.StandardSessionFacade@2843a202
HttpServletRequest已被销毁
HttpServletRequest已被创建, URI/json_war_exploded/hello
ServletContext新增属性：sc-attr1-&gt;sc-attr-value1
HttpSessionBindingEvent新增属性：session-attr1-&gt;session-attr-value1
ServletRequestAttributeEvent新增属性：request-attr1-&gt;request-attr-value1
HttpServletRequest已被销毁
</code></pre>
<h3 id="监听器的应用场景"><a href="#监听器的应用场景" class="headerlink" title="监听器的应用场景"></a>监听器的应用场景</h3><p><strong>请求流量分析 [以图表形式展现]</strong></p>
<blockquote>
<p>流程：在应用启动的时候将两个List初始化 一个保存时间一个保存数值 分情况 若时间不存在初始化1 若存在则在原始＋1进行更新操作</p>
</blockquote>
<pre><code class="xml">web.xml
&lt;listener&gt;
  &lt;listener-class&gt;com.example.json.RequestTotalListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<pre><code class="java">RequestTotalListener.java
package com.example.json;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class RequestTotalListener implements ServletContextListener, ServletRequestListener &#123;
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;
        List timeList = new ArrayList(); //时间数据
        List valueList = new ArrayList(); //具体时间访问量数据
        servletContextEvent.getServletContext().setAttribute(&quot;timeList&quot;, timeList);//得到最原始的context
        servletContextEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);//启动ServletContext时自动启动倆请求
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;

    &#125;

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;

    &#125;

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;
        //请求初始化 每来一个新的请求监听器都会执行此方法 记录某一时间点的访问量
        //TimeList：10:02  10:03  10:04  10:05
        //ValueList: 5       7     10    1+1=2
        List&lt;String&gt; timeList = (List)servletRequestEvent.getServletContext().getAttribute(&quot;timeList&quot;);
        List&lt;Integer&gt; valueList = (List)servletRequestEvent.getServletContext().getAttribute(&quot;valueList&quot;);
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm&quot;); //按照小时分钟来取
        String time = sdf.format(date); //date对象传入
        if (timeList.indexOf(time) == -1) &#123; //查找对应的数据在集合中是否存在
            //若时间不存在 则追加时间
            timeList.add(time);
            valueList.add(1);//当前有1个请求被创建
            servletRequestEvent.getServletContext().setAttribute(&quot;timeList&quot;, timeList);
            servletRequestEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);
        &#125;else &#123; //假设时间存在 不增加新数据 在原有数据加1
            int index = timeList.indexOf(time); //10:05返回索引值3
            int value = valueList.get(index);
            valueList.set(index, value+1);
            servletRequestEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">RequestTotalServlet.java
package com.imooc.total;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.alibaba.fastjson.JSON;

/**
 * Servlet implementation class RequestTotalServlet
 */
@WebServlet(&quot;/rt&quot;)
public class RequestTotalServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public RequestTotalServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        ServletContext context = request.getServletContext();//得到全局context对象
        List&lt;String&gt; timeList = (List)context.getAttribute(&quot;timeList&quot;);//提取之前创建的
        List&lt;Integer&gt; valueList = (List)context.getAttribute(&quot;valueList&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        /*response.getWriter().println(timeList.toString()); //打印输出时间数值数据
        response.getWriter().println(&quot;&lt;br/&gt;&quot;);
        response.getWriter().println(valueList.toString());*/
        
        Map result = new HashMap();
        result.put(&quot;timeList&quot;, timeList);
        result.put(&quot;valueList&quot;, valueList);
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="html">text3.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Test Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;I&#39;m test page 3&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<pre><code class="html">&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div id=&quot;main&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;
   &lt;script type = &quot;text/javascript&quot;&gt;
     //基于准备好的dom, 初始化echarts实例
    var myChart = echarts.init(document.getElementById(&#39;main&#39;));
     //指定图表的配置项和数据
    var option = &#123;
        title:&#123;
            text:&#39;Echarts 入门示例&#39;
        &#125;,
        tooltip: &#123;&#125;,
        legend: &#123;
            data: [&#39;销量&#39;]
        &#125;,
        xAxis: &#123;
            data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]
        &#125;,
        yAxis: &#123;&#125;,
        series:[&#123;
            name: &#39;销量&#39;,
            type: &#39;bar&#39;,
            data: [5,20,36,10,10,20]
        &#125;]
    &#125;;
       //使用刚指定的配置项和数据显示图表
       myChart.setOption(option);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h3 id="入门百度Echarts组件"><a href="#入门百度Echarts组件" class="headerlink" title="入门百度Echarts组件"></a>入门百度Echarts组件</h3><h6 id="利用Ajax和Jquery进行前后端通信"><a href="#利用Ajax和Jquery进行前后端通信" class="headerlink" title="利用Ajax和Jquery进行前后端通信"></a>利用Ajax和Jquery进行前后端通信</h6><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Insert title here&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;main&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    //每一秒钟向服务器查询一次数据把变化数据重新写入图表
//需要Javascript定时器完成
    function showChat()&#123;//显示图表
        //基础的通讯部分
    $.ajax(&#123;
        url:&quot;./rt&quot;,
        type:&quot;get&quot;,
        dataType:&quot;json&quot;,
        success:function(json)&#123;
            console.log(json.timeList);
            console.log(json.valueList);
    //基于准备好的dom, 初始化echarts实例
    var myChart = echarts.init(document.getElementById(&#39;main&#39;));
    //指定图表的配置项和数据
    var option = &#123;
        title: &#123;
            text: &#39;请求流量分析统计&#39;
        &#125;,
        tooltip: &#123;&#125;,
        legend: &#123;
            data: [&#39;访问量&#39;]
        &#125;,
        xAxis: &#123;
           // data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]
            data: json.timeList
        &#125;,
        yAxis: &#123;&#125;,
        series: [&#123;
            name: &#39;访问量&#39;,
            type: &#39;line&#39;, //柱状图  line是折线图
           // data: [5, 20, 36, 10, 10, 20] //图中展示的数值 与商法data对应
            data: json.valueList
        &#125;]
    &#125;;
    //激活使用刚指定的配置项和数据显示图表
    myChart.setOption(option);
        &#125;
    &#125;)
&#125;
       window.setInterval(&quot;shwoChart()&quot;, 1000);//间隔某时长去执行指定代码
    //每秒钟通过shwoChart()向服务器&quot;./rt&quot;发送请求 对此请求进行排除用RequestTotalListener去改写
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">RequestTotalListener.java
package com.example.json;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class RequestTotalListener implements ServletContextListener, ServletRequestListener &#123;
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;
        List timeList = new ArrayList(); //时间数据
        List valueList = new ArrayList(); //具体时间访问量数据
        servletContextEvent.getServletContext().setAttribute(&quot;timeList&quot;, timeList);//得到最原始的context
        servletContextEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);//启动ServletContext时自动启动倆请求
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;

    &#125;

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;

    &#125;

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;
        HttpServletRequest request = (HttpServletRequest)servletRequestEvent.getServletRequest();
        String url = request.getRequestURL().toString();
        if (url.endsWith(&quot;/rt&quot;) == true)&#123;
            return; //将rt的url排除之外
        &#125;
        //请求初始化 每来一个新的请求监听器都会执行此方法 记录某一时间点的访问量
        //TimeList：10:02  10:03  10:04  10:05
        //ValueList: 5       7     10    1+1=2
        List&lt;String&gt; timeList = (List)servletRequestEvent.getServletContext().getAttribute(&quot;timeList&quot;);
        List&lt;Integer&gt; valueList = (List)servletRequestEvent.getServletContext().getAttribute(&quot;valueList&quot;);
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm&quot;); //按照小时分钟来取
        String time = sdf.format(date); //date对象传入
        if (timeList.indexOf(time) == -1) &#123; //查找对应的数据在集合中是否存在
            //若时间不存在 则追加时间
            timeList.add(time);
            valueList.add(1);//当前有1个请求被创建
            servletRequestEvent.getServletContext().setAttribute(&quot;timeList&quot;, timeList);
            servletRequestEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);
        &#125;else &#123; //假设时间存在 不增加新数据 在原有数据加1
            int index = timeList.indexOf(time); //10:05返回索引值3
            int value = valueList.get(index);
            valueList.set(index, value+1);
            servletRequestEvent.getServletContext().setAttribute(&quot;valueList&quot;, valueList);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">RequestTotalServlet.java
package com.example.json;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.alibaba.fastjson.JSON;

/**
 * Servlet implementation class RequestTotalServlet
 */
@WebServlet(&quot;/rt&quot;)
public class RequestTotalServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public RequestTotalServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        ServletContext context = request.getServletContext();
        List&lt;String&gt; timeList = (List)context.getAttribute(&quot;timeList&quot;);
        List&lt;Integer&gt; valueList = (List)context.getAttribute(&quot;valueList&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        /*response.getWriter().println(timeList.toString());
        response.getWriter().println(&quot;&lt;br/&gt;&quot;);
        response.getWriter().println(valueList.toString());*/ //将对象进行封装
        
        Map result = new HashMap();
        result.put(&quot;timeList&quot;, timeList);
        result.put(&quot;valueList&quot;, valueList);
        String json = JSON.toJSONString(result); //将java对象转换为json字符串
        response.getWriter().println(json);
    &#125;

    /**
     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        // TODO Auto-generated method stub
        doGet(request, response);
    &#125;
&#125;
</code></pre>
<h3 id="静态数据预加载"><a href="#静态数据预加载" class="headerlink" title="静态数据预加载"></a>静态数据预加载</h3><p>通过监听器在上下文初始化的时候放在系统的全局属性中</p>
<pre><code class="java">Channel.java
public class Channel&#123;
    private String channelName;
    private String url;
    ......
&#125;
</code></pre>
<pre><code class="java">StaticDataListener.java
package com.imooc.listener;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import com.imooc.listener.entity.Channel;

public class StaticDataListener implements ServletContextListener&#123;

    @Override
    public void contextInitialized(ServletContextEvent sce) &#123;
        // TODO Auto-generated method stub
        List list  = new ArrayList();
        list.add(new Channel(&quot;免费课程&quot; , &quot;http://www.imooc.com/1&quot;));
        list.add(new Channel(&quot;实战课程&quot; , &quot;http://www.imooc.com/2&quot;));
        list.add(new Channel(&quot;就业班&quot; , &quot;http://www.imooc.com/3&quot;));
        sce.getServletContext().setAttribute(&quot;channelList&quot;, list);
        //一次性写入到全局属性种
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent sce) &#123;
        // TODO Auto-generated method stub
        
    &#125;

&#125;
</code></pre>
<pre><code class="xml">web.xml
&lt;listener&gt;
    &lt;listener-class&gt;listener.StaticDataListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<pre><code class="jsp">index.jsp
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;c:forEach items=&quot;$&#123;applicationScope.channelList &#125;&quot; var=&quot;c&quot;&gt; &lt;!--有效数据提取--&gt;
    &lt;a href=&quot;$&#123;c.url &#125;&quot;&gt;$&#123;c.channelName &#125;&lt;/a&gt; | 
&lt;/c:forEach&gt;
&lt;hr/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="FreeMarker-FTL-模板引擎-可以替代jsp"><a href="#FreeMarker-FTL-模板引擎-可以替代jsp" class="headerlink" title="FreeMarker(FTL)模板引擎[可以替代jsp]"></a>FreeMarker(FTL)模板引擎[可以替代jsp]</h3><p>FreeMarker是一款用java语言编写的模版引擎，它虽然不是web应用框架，但它很合适作为web应用框架的一个组件。</p>
<p>特点：<br>1.轻量级模版引擎，不需要Servlet环境就可以很轻松的嵌入到应用程序中<br>2.能生成各种文本，如<strong>html，xml，java</strong>等<br>3.入门简单，它是用java编写的，很多语法和java相似</p>
<h6 id="基础语法及入门基础"><a href="#基础语法及入门基础" class="headerlink" title="基础语法及入门基础"></a>基础语法及入门基础</h6><p><strong>freemarker</strong>模板文件(*.ftl)的基本组成部分<br>1.文本：直接输出的内容部分<br>2.注释：不会输出的内容，格式为  <strong>&lt;#– 注释内容 –&gt;</strong><br>3.取值(插值)：代替输出数据模型的部分，格式为${数据模型}或#{数据模型}<br>4.ftl指令：Freemarker指令，类似于HTML标记。</p>
<h6 id="字符输出"><a href="#字符输出" class="headerlink" title="字符输出"></a>字符输出</h6><pre><code class="jsp">$(emp.name?if_exists)  //变量存在,输出该变量,否则不输出
$&#123;emp.name!&#125;　　　　　　 //变量存在，输出该变量，否则不输出
$&#123;emp.name?default(&quot;xxx&quot;)&#125; // 变量不存在，取默认值xxx
$&#123;emp.name!&quot;xxx&quot;&#125;           // 变量不存在，取默认值xxx
</code></pre>
<h6 id="常用内部函数"><a href="#常用内部函数" class="headerlink" title="常用内部函数"></a>常用内部函数</h6><pre><code class="jsp">$&#123;&quot;123&lt;br&gt;456&quot;?html&#125; 　 // 对字符串进行HTML编码，对html中特殊字符进行转义
$&#123;&quot;str&quot;?cap_first&#125; 　　 // 使字符串第一个字母大写 
$&#123;&quot;Str&quot;?lower_case&#125;    // 将字符串转换成小写
$&#123;&quot;Str&quot;?upper_case&#125;   // 将字符串转换成大写
$&#123;&quot;str&quot;?trim&#125;            // 去掉字符串前后的空白字符
</code></pre>
<h6 id="字符串的两种拼接方法"><a href="#字符串的两种拼接方法" class="headerlink" title="字符串的两种拼接方法"></a>字符串的两种拼接方法</h6><pre><code class="jsp">$&#123;&quot;hello$&#123;emp.name!&#125;&quot;&#125; //输出hello+变量名
$&#123;&quot;hello&quot;+emp.name!&#125;   //使用+号来连接,输出hello+变量名
</code></pre>
<h6 id="截取子串"><a href="#截取子串" class="headerlink" title="截取子串"></a>截取子串</h6><pre><code class="jsp">可以通过如下语法来截取子串:
&lt;#assign str = &quot;abcdefghijklmn&quot;/&gt;
// 方法1$&#123;str?substring(0,4)&#125; // 输出abcd
// 方法2$&#123;str[0]&#125;$&#123;str[4]&#125; // 结果是ae
$&#123;str[1..4]&#125; 　　　 // 结果是bcde// 返回指定字符的索引$&#123;str?index_of(&quot;n&quot;)&#125;
</code></pre>
<h6 id="日期输出"><a href="#日期输出" class="headerlink" title="日期输出"></a>日期输出</h6><pre><code class="jsp">$&#123;emp.date?string(&#39;yyyy-MM-dd&#39;)&#125; //日期格式
</code></pre>
<h6 id="数字输出-以数字20为例"><a href="#数字输出-以数字20为例" class="headerlink" title="数字输出(以数字20为例)"></a>数字输出(以数字20为例)</h6><pre><code class="jsp">$&#123;emp.name?string.number&#125; //输出20
$&#123;emp.name?string.currency&#125; //￥20.00
$&#123;emp.name?string.precent&#125; //20%
$&#123;1.222?int&#125; 　　　　　　　　 // 将小数转为int，输出1
&lt;#setting number_format=&quot;percent&quot;/&gt; // 设置数字默认输出方式(&#39;percent&#39;,百分比)
&lt;#assign answer=42/&gt; 　　　　　　　　 // 声明变量 answer 42
#&#123;answer&#125; 　　　　　　　　 // 输出 4,200%
$&#123;answer?string&#125; 　　　　 // 输出 4,200%
$&#123;answer?string.number&#125; 　　// 输出 42
$&#123;answer?string.currency&#125; // 输出 ￥42.00
$&#123;answer?string.percent&#125; 　// 输出 4,200%
#&#123;answer&#125; 　　　　　　　　// 输出 42
</code></pre>
<h6 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h6><pre><code class="jsp">表达式中支持的比较运算符有如下几个:= 或 == ：判断两个值是否相等.
!= ：判断两个值是否不等.
&gt; 或 gt ：判断左边值是否大于右边值
&gt;= 或 gte ：判断左边值是否大于等于右边值
&lt; 或 lt ：判断左边值是否小于右边值
&lt;= 或 lte ：判断左边值是否小于等于右边值
</code></pre>
<h6 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h6><pre><code class="jsp">FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , % 注意：
(1)运算符两边必须是数字
(2)使用+运算符时,如果一边是数字,一边是字符串,就会自动将数字转换为字符串再连接,如:$&#123;3 + &quot;5&quot;&#125;,结果是:35
</code></pre>
<h6 id="FreeMarker中的运算符优先级如下-由高到低排列"><a href="#FreeMarker中的运算符优先级如下-由高到低排列" class="headerlink" title="FreeMarker中的运算符优先级如下(由高到低排列):"></a>FreeMarker中的运算符优先级如下(由高到低排列):</h6><blockquote>
<p>①、一元运算符:!<br>②、内建函数:?<br>③、乘除法:*, &#x2F; , %<br>④、加减法:- , +<br>⑤、比较:&gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; (lt , lte , gt , gte)<br>⑥、相等:&#x3D;&#x3D; , &#x3D; , !&#x3D;<br>⑦、逻辑与:&amp;&amp;<br>⑧、逻辑或:||<br>⑨、数字范围:..实际上,我们在开发过程中应该使用括号来严格区分,这样的可读性好,出错少</p>
</blockquote>
<h6 id="if逻辑判断-注意：elseif-不加空格"><a href="#if逻辑判断-注意：elseif-不加空格" class="headerlink" title="if逻辑判断(注意：elseif 不加空格)"></a>if逻辑判断(注意：elseif 不加空格)</h6><pre><code class="jsp">&lt;#if condition&gt;
...
&lt;#elseif condition2&gt;
...
&lt;#elseif condition3&gt;
...
&lt;#else&gt;
...
&lt;/#if&gt;
</code></pre>
<h6 id="switch-条件可为数字，可为字符串"><a href="#switch-条件可为数字，可为字符串" class="headerlink" title="switch(条件可为数字，可为字符串)"></a>switch(条件可为数字，可为字符串)</h6><pre><code class="jsp">&lt;#switch value&gt;
 &lt;#case refValue1&gt;
....
&lt;#break&gt; 
&lt;#case refValue2&gt; 
....
&lt;#break&gt;
 &lt;#case refValueN&gt;
 ....
&lt;#break&gt;
 &lt;#default&gt;
 ....
 &lt;/#switch&gt;
</code></pre>
<h6 id="集合-amp-循环"><a href="#集合-amp-循环" class="headerlink" title="集合 &amp; 循环"></a>集合 &amp; 循环</h6><pre><code class="jsp">//遍历集合
&lt;#list empList! as emp&gt;
    $&#123;emp.name!&#125;    
&lt;/#list&gt;

//使用&lt;#break&gt;跳出循环
&lt;#if emp_index = 0&gt;&lt;#break&gt;&lt;/#if&gt;

//集合长度判断 
&lt;#if empList?size!=0&gt;&lt;/#if&gt; //判断=的时候,注意只要一个=符号,而不是==
&lt;#assign l=0..100/&gt;       // 定义一个int区间的0~100的集合，数字范围也支持反递增,如100..2
&lt;#list 0..100 as i&gt; 　　// 等效于java for(int i=0; i &lt;= 100; i++)
　　$&#123;i&#125;
&lt;/#list&gt;

// 截取子集合：
empList[3..5] //返回empList集合的子集合,子集合中的元素是empList集合中的第4-6个元素

// 创建集合：
&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;

// 集合连接运算,将两个集合连接成一个新的集合
&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;

// 除此之外,集合元素也可以是表达式,例子如下:
[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]

// seq_contains：判断序列中的元素是否存在
&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;]&gt; 
$&#123;x?seq_contains(&quot;blue&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125;    // yes
$&#123;x?seq_contains(&quot;yellow&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125;  // no
$&#123;x?seq_contains(16)?string(&quot;yes&quot;, &quot;no&quot;)&#125;        // yes
$&#123;x?seq_contains(&quot;16&quot;)?string(&quot;yes&quot;, &quot;no&quot;)&#125;      // no

// seq_index_of：第一次出现的索引
&lt;#assign x = [&quot;red&quot;, 16, &quot;blue&quot;, &quot;cyan&quot;, &quot;blue&quot;]&gt; 
$&#123;x?seq_index_of(&quot;blue&quot;)&#125;  // 2

// sort_by：排序（升序）
&lt;#list movies?sort_by(&quot;showtime&quot;) as movie&gt;&lt;/#list&gt;

// sort_by：排序（降序）
&lt;#list movies?sort_by(&quot;showtime&quot;)?reverse as movie&gt;&lt;/#list&gt;

// 具体介绍：
// 不排序的情况：
&lt;#list movies as moive&gt;
　　&lt;a href=&quot;$&#123;moive.url&#125;&quot;&gt;$&#123;moive.name&#125;&lt;/a&gt;
&lt;/#list&gt;
//要是排序，则用
&lt;#list movies?sort as movie&gt;
　　&lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;
&lt;/#list&gt;
    
/ 这是按元素的首字母排序。若要按list中对象元素的某一属性排序的话，则用
&lt;#list moives?sort_by([&quot;name&quot;]) as movie&gt;
　　&lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;
&lt;/#list&gt;

//这个是按list中对象元素的[name]属性排序的，是升序，如果需要降序的话，如下所示：
&lt;#list movies?sort_by([&quot;name&quot;])?reverse as movie&gt;
　　&lt;a href=&quot;$&#123;movie.url&#125;&quot;&gt;$&#123;movie.name&#125;&lt;/a&gt;
&lt;/#list&gt;
    
//Map对象 创建map
&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125;&gt;

// Map连接运算符
&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125; + &#123;&quot;数学&quot;:87,&quot;Java&quot;:93&#125;&gt;

// Map元素输出
emp.name       // 全部使用点语法
emp[&quot;name&quot;]    // 使用方括号

// FreeMarker支持如下转义字符:
\&quot; ：双引号(u0022)
\&#39; ：单引号(u0027)
\\ ：反斜杠(u005C)
\n ：换行(u000A)
\r ：回车(u000D)
\t ：Tab(u0009)
\b ：退格键(u0008)
\f ：Form feed(u000C)
\l ：&lt;
\g ：&gt;
\a ：&amp;
\&#123; ：&#123;
\xCode ：直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符.
    
// include指令的作用类似于JSP的包含指令:
&lt;#include &quot;/test.ftl&quot; encoding=&quot;UTF-8&quot; parse=true&gt;

// 在上面的语法格式中,两个参数的解释如下:
encoding=&quot;GBK&quot;  // 编码格式
parse=true 　　 // 是否作为ftl语法解析,默认是true，false就是以文本方式引入,
注意:在ftl文件里布尔值都是直接赋值的如parse=true,而不是parse=&quot;true&quot;
    
//import指令
类似于jsp里的import,它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件
&lt;#import &quot;/libs/mylib.ftl&quot; as my&gt;
上面的代码将导入/lib/common.ftl模板文件中的所有变量,
交将这些变量放置在一个名为com的Map对象中，&quot;my&quot;在freemarker里被称作namespace

</code></pre>
<h6 id="数据-模板-x3D-结果"><a href="#数据-模板-x3D-结果" class="headerlink" title="数据 + 模板 &#x3D; 结果"></a>数据 + 模板 &#x3D; 结果</h6><blockquote>
<p>数据 <u>[Java代码]</u><br>User user &#x3D; new User();<br>user.setName(“张三”)；</p>
</blockquote>
<blockquote>
<p>模板 <u>[HTML简化]</u><br>&lt; span &gt;<br>    ${user.name}<br>&lt; &#x2F;span &gt;</p>
</blockquote>
<blockquote>
<p>结果<br>&lt; span &gt;<br> 张三<br>&lt; &#x2F;span &gt;</p>
</blockquote>
<ul>
<li>Freemarker是免费开源的模板引擎技术</li>
<li>Freemarker脚本为(Freemarker Template Language)</li>
<li>Freemarker提供了大量内建函数来简化开发</li>
</ul>
<h3 id="JSP与Freemarker"><a href="#JSP与Freemarker" class="headerlink" title="JSP与Freemarker"></a>JSP与Freemarker</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">JSP</th>
<th align="center">Freemarker</th>
</tr>
</thead>
<tbody><tr>
<td align="center">官方标准</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">执行方式</td>
<td align="center">编译型</td>
<td align="center">解释型</td>
</tr>
<tr>
<td align="center">执行效率</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">开发效率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">扩展能力</td>
<td align="center">弱</td>
<td align="center">强</td>
</tr>
<tr>
<td align="center">数据提取</td>
<td align="center">JSTL + EL</td>
<td align="center">内置标签</td>
</tr>
</tbody></table>
<p>前端工程师把数据写在ftl 然后后端工程师拿着名称去添加后台数据 </p>
<pre><code class="java">package com.example.json;


import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class FreemarkerSample1 &#123;
    public static void main(String[] args) throws IOException, TemplateException &#123;
        //1. 加载模板
        Configuration confige = new Configuration(Configuration.VERSION_2_3_32);
                     // FreemarkerSample1类所在包中加载ftl所在文件
        confige.setClassForTemplateLoading(FreemarkerSample1.class, &quot;&quot;);
        Template t = confige.getTemplate(&quot;sample1.ftl&quot;);
        //2. 创建数据
        Map&lt;String,Object&gt; data = new HashMap&lt;String, Object&gt;();
        data.put(&quot;site&quot;,&quot;百度&quot;);
        data.put(&quot;url&quot;,&quot;https://www.abc.com&quot;);
        data.put(&quot;data&quot;,new Date());
        data.put(&quot;number&quot;,83719.88321);
        Map info = new HashMap();
        info.put(&quot;cpu&quot;,&quot;i5&quot;);
        Computer c1 = new Computer(&quot;123456&quot;,&quot;ALIENWARE&quot;,1,&quot;李四&quot;,new Date(), 12900f)
        data.put(&quot;computer&quot;,c1);
        //3. 产生输出    向目标输出
        t.process(data, new OutputStreamWriter(System.out));
    &#125;
&#125;
</code></pre>
<pre><code class="ftl">$&#123;site&#125;
$&#123;url&#125;
&lt;#--类似于EL表达式--&gt;
</code></pre>
<pre><code class="java">Computer.java
public class Computer&#123;
    private String sn; //序列号
    private String mode1; //型号
    private int state; //状态 1-在用 2-闲置 3-报废
    private String user; //使用人
    private Date dog; //采购日期
    private Float price; //购买价格
    private Map info; //电脑配置信息
    ......
&#125;
</code></pre>
<pre><code class="html">sample1.ftl
&lt;#-- Freemarker取值 --&gt;
$&#123;site&#125;
$&#123;url&#125;

&lt;#-- !默认值 --&gt;
$&#123;author!&quot;不存在的属性&quot;&#125;

&lt;#-- ？string格式化输出 --&gt;
$&#123;date?string(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;)&#125;
$&#123;number?string(&quot;0.00&quot;)&#125;

SN:$&#123;computer.sn&#125;
型号:$&#123;computer.mode1&#125;
状态:$&#123;computer.state&#125;
用户:$&#123;computer.user&#125;
采购时间:$&#123;computer.dop?string(&quot;yyyy年MM月dd日&quot;)&#125;
采购价格:$&#123;computer.price?string(&quot;0.00&quot;)&#125;

//对map的提取
CPU:$&#123;computer.info[&quot;cpu&quot;]&#125;
内存:$&#123;computer.info[&quot;memory&quot;]!&quot;无内存信息&quot;&#125;
</code></pre>
<h3 id="FTL-FreeMarker-Template-Language-取值"><a href="#FTL-FreeMarker-Template-Language-取值" class="headerlink" title="FTL(FreeMarker Template Language)取值"></a>FTL(FreeMarker Template Language)取值</h3><ul>
<li><p><strong>${属性名}</strong> 取值，可对属性进行计算</p>
</li>
<li><p><strong>${属性名!默认值}</strong> 使用默认值[解决空值异常]<br>${author!”不存在的属性”} &#x3D;&gt; 不存在的属性</p>
</li>
<li><p><strong>${属性名?string}</strong> 格式化输出<br>${data?string(“yyyy年MM月dd日 HH:mm:ss SSS”)}</p>
<blockquote>
<p>${number?string(“0.00”)} 小数部位保留两位</p>
</blockquote>
</li>
</ul>
<h6 id="if分支判断"><a href="#if分支判断" class="headerlink" title="if分支判断"></a>if分支判断</h6><pre><code class="java">&lt;#if 条件1&gt;
  条件1成立执行代码
&lt;#if 条件2&gt;
  条件2成立执行代码
&lt;#if 条件3&gt;
  条件3成立执行代码
&lt;#else&gt;
  其他情况下执行代码
</code></pre>
<h6 id="switch分支判断"><a href="#switch分支判断" class="headerlink" title="switch分支判断"></a>switch分支判断</h6><pre><code class="java">&lt;#switch value&gt;
  &lt;#case refValue1&gt;
    ...
    &lt;#break&gt;
  &lt;#case refValue2&gt;
    ...
    &lt;#break&gt;
  &lt;#case refValueN&gt;
    ...
    &lt;#break&gt;
&lt;#default&gt;
...
&lt;/#switch&gt;
</code></pre>
<hr>
<pre><code class="java">sample1.ftl
&lt;#-- Freemarker取值 --&gt;
$&#123;site&#125;
$&#123;url&#125;

&lt;#-- !默认值 --&gt;
$&#123;author!&quot;不存在的属性&quot;&#125;

&lt;#-- ？string格式化输出 --&gt;
$&#123;date?string(&quot;yyyy年MM月dd日 HH:mm:ss SSS&quot;)&#125;
$&#123;number?string(&quot;0.00&quot;)&#125;
&lt;#if computer.sn == &quot;1234567&quot;&gt;
重要设备
&lt;/#if&gt;

SN:$&#123;computer.sn&#125;
型号:$&#123;computer.mode1&#125;
状态:$&#123;computer.state&#125;

&lt;#if computer.state == 1&gt;
状态:正在使用
&lt;#elseif computer.state == 2&gt;
状态:闲置
&lt;#elseif computer.state == 3&gt;
状态:已作废
&lt;/#if&gt;

&lt;#if computer.user??&gt; //??代表判断对象是否为空,true不为空,false为空
用户:$&#123;computer.user&#125;
&lt;/#if&gt;
--------------------------------------------------------
&lt;#switch computer.state&gt;  //同一个属性的不同值进行判断
    &lt;#case1&gt;
        状态：正在使用
        &lt;#break&gt;
    &lt;#case2&gt;
        状态：闲置
        &lt;#break&gt;
    &lt;#case3&gt;
        状态：已作废
        &lt;#break&gt;
    &lt;#default&gt;
        状态：无效状态
--------------------------------------------------------
采购时间:$&#123;computer.dop?string(&quot;yyyy年MM月dd日&quot;)&#125;
采购价格:$&#123;computer.price?string(&quot;0.00&quot;)&#125;

//对map的提取
CPU:$&#123;computer.info[&quot;cpu&quot;]&#125;
内存:$&#123;computer.info[&quot;memory&quot;]!&quot;无内存信息&quot;&#125;
</code></pre>
<h3 id="list迭代列表"><a href="#list迭代列表" class="headerlink" title="list迭代列表"></a>list迭代列表</h3><pre><code class="JAVA">&lt;#list students as stu&gt;
  &lt;li&gt;$&#123;stu_index&#125;-$&#123;stu.name&#125;&lt;/li&gt;
&lt;/#list&gt;
</code></pre>
<h6 id="list迭代Map"><a href="#list迭代Map" class="headerlink" title="list迭代Map"></a>list迭代Map</h6><pre><code class="java">&lt;#list map?keys as key&gt;
  $&#123;key&#125;:$&#123;map[key]&#125;
&lt;/#list&gt;
</code></pre>
<pre><code class="java">FreemarkerSample2.java
package com.example.json;


import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class FreemarkerSample1 &#123;
    public static void main(String[] args) throws IOException, TemplateException &#123;
        //1. 加载模板
        Configuration confige = new Configuration(Configuration.VERSION_2_3_32);
          // FreemarkerSample1类所在包中加载ftl所在文件
        confige.setClassForTemplateLoading(FreemarkerSample2.class, &quot;&quot;);
        Template t = confige.getTemplate(&quot;sample1.ftl&quot;); //得到模板对象
        //2. 创建数据
        Map&lt;String,Object&gt; data = new HashMap&lt;String,object&gt;();
        List&lt;Computer&gt; computers = new ArrayList();
        computers.add(new Computer(&quot;123456&quot;,&quot;ALIENWARE&quot;,2,null,new Date(), 12900f, new HashMap()));
        computers.add(new Computer(&quot;123456&quot;,&quot;HP XXX&quot;,1,&quot;张三&quot;,new Date(), 12900f, new HashMap()));
        computers.add(new Computer(&quot;1233145&quot;,&quot;DELL XXX&quot;,3,&quot;李四&quot;,new Date(), 12900f, new HashMap()));
        computers.add(new Computer(&quot;1234536&quot;,&quot;ACER XXX&quot;,1,&quot;王五&quot;,new Date(), 12900f, new HashMap()));
        computers.add(new Computer(&quot;12344456&quot;,&quot;MSI XXX&quot;,1,&quot;赵六&quot;,new Date(), 12900f, new HashMap()));
        data.put(&quot;computers&quot;, computers);
        //LinkedHashMap可以保证数据按存放顺序进行提取
        Map computerMap = new LinkedHashMap();
        for(Computer c : computers)&#123;
            computerMap.put(c.getSn(), c);
        &#125; //下方新增
        //3. 产生输出    向目标输出
        t.process(data, new OutputStreamWriter(System.out));
    &#125;
&#125;
</code></pre>
<pre><code class="java">sample2.ftl
&lt;#list computers as c&gt; //迭代循环 用变量c
序号:$&#123;c_index&#125; //迭代变量 index保存了循环的索引,从0开始 +1则从1开始
SN:$&#123;c.sn&#125;
型号:$&#123;c.mode1&#125;
&lt;#switch c.state&gt;  //同一个属性的不同值进行判断
    &lt;#case1&gt;
        状态：正在使用
        &lt;#break&gt;
    &lt;#case2&gt;
        状态：闲置
        &lt;#break&gt;
    &lt;#case3&gt;
        状态：已作废
        &lt;#break&gt;
    &lt;#default&gt;
        状态：无效状态
&lt;/#switch&gt;
&lt;#if c.user??&gt;
状态:$&#123;c.state&#125;
&lt;/#if&gt;
用户:$&#123;c.user&#125;
采购时间:$&#123;c.dop?string(&quot;yyyy-MM-dd&quot;)&#125;
采购价格:$&#123;c.price?string(&quot;0.00&quot;)&#125;
&lt;/#list&gt;
-------------------------------------------------------------
&lt;#list computer_map?keys as k &gt;
$&#123;k&#125;-$&#123;computer_map[k].model&#125;
$&#123;computer_map[k].price?string(&quot;0.00&quot;)&#125;
&lt;/#list&gt;
</code></pre>
<h3 id="Freemarker内建函数-看成java代码-就是点”-”换成了问号”-”"><a href="#Freemarker内建函数-看成java代码-就是点”-”换成了问号”-”" class="headerlink" title="Freemarker内建函数[看成java代码 就是点”.”换成了问号”?”]"></a>Freemarker内建函数[<span style = "color : red">看成java代码 就是点”.”换成了问号”?”</span>]</h3><p><strong>freemarker.foofun.cn</strong> 在线学习</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lower_case&#x2F;upper_case</td>
<td align="center">大小写转换</td>
<td align="center">“abcde”?upper_case</td>
</tr>
<tr>
<td align="center">cap_first</td>
<td align="center">首字母大写</td>
<td align="center">“”abcde””?cap_first</td>
</tr>
<tr>
<td align="center">index_of</td>
<td align="center">查找字符索引</td>
<td align="center">“abcde”?index_of(“b”)</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">返回字符串长度</td>
<td align="center">“abcde”?length</td>
</tr>
<tr>
<td align="center">round&#x2F;floor&#x2F;ceiling</td>
<td align="center">四舍五入&#x2F;下取整&#x2F;上取整</td>
<td align="center">pi?floor</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">得到集合元素总数</td>
<td align="center">students?size</td>
</tr>
<tr>
<td align="center">first&#x2F;last</td>
<td align="center">获取第一个&#x2F;最后一个元素</td>
<td align="center">students?first</td>
</tr>
<tr>
<td align="center">sort_by</td>
<td align="center">按某个属性对集合排序</td>
<td align="center">list?sort_by(“time”)</td>
</tr>
</tbody></table>
<pre><code class="java">example:
Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();
data.put(&quot;name&quot;, &quot;jackson&quot;);
----------------------------
$&#123;name?cap_first&#125;
//违禁字母屏蔽
$&#123;words?replace(&quot;blood&quot;, &quot;******&quot;)&#125;
$&#123;words?index_of(&quot;blood&quot;)&#125;
//三目运算 
$&#123;(words?index_of(&quot;blood&quot;) != -1)?string(&quot;包含敏感词汇&quot;,&quot;不包含敏感词汇&quot;)&#125;

公司共有$&#123;computers?size&#125;台电脑
//集合排序 返回一个新的集合
&lt;#list computers?sort_by(&quot;price&quot;) as c &gt;
    $&#123;c.sn&#125;-$&#123;c.price&#125;
&lt;/#list&gt;
//集合排序&#123;降序&#125;
&lt;#list computers?sort_by(&quot;price&quot;)?reverse as c &gt;
    $&#123;c.sn&#125;-$&#123;c.price&#125;
&lt;/#list&gt;
</code></pre>
<h3 id="Freemarker与Servlet整合"><a href="#Freemarker与Servlet整合" class="headerlink" title="Freemarker与Servlet整合"></a>Freemarker与Servlet整合</h3><pre><code class="xml">web.xml
&lt;servlet&gt;
  &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt;
  &lt;servlet-class&gt;freemarkerServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
      &lt;param-name&gt;TemplatePath&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;freemarker&lt;/servlet-name&gt;
  &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt; //地址映射 输入这样的后缀时自动去/WEB-INF/ftl查找
&lt;/servlet-mapping&gt;
</code></pre>
<pre><code class="java">test.ftl
这是一个测试FTL文件

localhost:8080/fm-web/test.ftl
</code></pre>
<pre><code class="java">employee.ftl
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;
    &lt;title&gt;员工列表&lt;/title&gt;
    &lt;link href=&quot;./css/bootstrap.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/bootstrap.js&quot;&gt;&lt;/script&gt;

    &lt;style type=&quot;text/css&quot;&gt;
        .pagination &#123;
            margin: 0px
        &#125;

        .pagination &gt; li &gt; a, .pagination &gt; li &gt; span &#123;
            margin: 0 5px;
            border: 1px solid #dddddd;
        &#125;

        .glyphicon &#123;
            margin-right: 3px;
        &#125;

        .form-control[readonly] &#123;
            cursor: pointer;
            background-color: white;
        &#125;
        #dlgPhoto .modal-body&#123;
            text-align: center;
        &#125;
        .preview&#123;

            max-width: 500px;
        &#125;
    &lt;/style&gt;
    &lt;script&gt;
        $(function () &#123;
            
            $(&quot;#btnAdd&quot;).click(function () &#123;
                $(&#39;#dlgForm&#39;).modal()
            &#125;);
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;h1 style=&quot;text-align: center&quot;&gt;IMOOC员工信息表&lt;/h1&gt;
        &lt;div class=&quot;panel panel-default&quot;&gt;
            &lt;div class=&quot;clearfix panel-heading &quot;&gt;
                &lt;div class=&quot;input-group&quot; style=&quot;width: 500px;&quot;&gt;
                    &lt;button class=&quot;btn btn-primary&quot; id=&quot;btnAdd&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-zoom-in&quot;&gt;&lt;/span&gt;新增
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;table class=&quot;table table-bordered table-hover&quot;&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;序号&lt;/th&gt;
                    &lt;th&gt;员工编号&lt;/th&gt;
                    &lt;th&gt;姓名&lt;/th&gt;
                    &lt;th&gt;部门&lt;/th&gt;
                    &lt;th&gt;职务&lt;/th&gt;
                    &lt;th&gt;工资&lt;/th&gt;
                    &lt;th&gt;&amp;nbsp;&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
//&lt;c:forEach items=&quot;$&#123;applicationScope.employees&#125;&quot; var=&quot;emp&quot; varStatus=&quot;idx&quot;&gt;
                &lt;#list employee_list as emp&gt;
                &lt;tr&gt;
                    &lt;td&gt;$&#123;emp_index + 1&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.empno?string(&quot;0&quot;)&#125;&lt;/td&gt; //整数输出用0初始化
                    &lt;td&gt;$&#123;emp.ename&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.department&#125;&lt;/td&gt;
                    &lt;td&gt;$&#123;emp.job&#125;&lt;/td&gt;
//&lt;td style=&quot;color: red;font-weight: bold&quot;&gt;￥&lt;fmt:formatNumber value=&quot;$&#123;emp.salary&#125;&quot; pattern=&quot;0,000.00&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;/td&gt;
                    &lt;td style=&quot;color: red;font-weight: bold&quot;&gt;￥$&#123;emp.salary?string(&quot;0.00&quot;)&#125;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;/c:forEach&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 表单 --&gt;
&lt;div class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; id=&quot;dlgForm&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
        &lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-header&quot;&gt;
                &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;
                &lt;/button&gt;
                &lt;h4 class=&quot;modal-title&quot;&gt;新增员工&lt;/h4&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-body&quot;&gt;
                &lt;form action=&quot;/untitled_war_exploded/create&quot; method=&quot;post&quot; &gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;empno&quot;&gt;员工编号&lt;/label&gt;
                        &lt;input type=&quot;text&quot; name=&quot;empno&quot; class=&quot;form-control&quot; id=&quot;empno&quot; placeholder=&quot;请输入员工编号&quot;&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;ename&quot;&gt;员工姓名&lt;/label&gt;
                        &lt;input type=&quot;text&quot; name=&quot;ename&quot; class=&quot;form-control&quot; id=&quot;ename&quot; placeholder=&quot;请输入员工姓名&quot;&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label&gt;部门&lt;/label&gt;
                        &lt;select id=&quot;dname&quot; name=&quot;department&quot; class=&quot;form-control&quot;&gt;
                            &lt;option selected=&quot;selected&quot;&gt;请选择部门&lt;/option&gt;
                            &lt;option value=&quot;市场部&quot;&gt;市场部&lt;/option&gt;
                            &lt;option value=&quot;研发部&quot;&gt;研发部&lt;/option&gt;
                            &lt;option value=&quot;后勤部&quot;&gt;后勤部&lt;/option&gt;
                        &lt;/select&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label&gt;职务&lt;/label&gt;
                        &lt;input type=&quot;text&quot; name=&quot;job&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入职务&quot;&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;sal&quot;&gt;工资&lt;/label&gt;
                        &lt;input type=&quot;text&quot; name=&quot;salary&quot; class=&quot;form-control&quot; id=&quot;sal&quot; placeholder=&quot;请输入工资&quot;&gt;
                    &lt;/div&gt;

                    &lt;div class=&quot;form-group&quot; style=&quot;text-align: center;&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;

        &lt;/div&gt;&lt;!-- /.modal-content --&gt;
    &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;
&lt;/div&gt;&lt;!-- /.modal --&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">Employee.java
public class Employee &#123;
    private Integer empno;
    private String ename;
    private String department;
    private String job;
    private Float salary;
    ...
&#125;
</code></pre>
<pre><code class="java">ListServlet.java
package com.imooc.freemarker.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ListServlet
 */
@WebServlet(&quot;/list&quot;)
public class ListServlet extends HttpServlet &#123;
    private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public ListServlet() &#123;
        super();
        // TODO Auto-generated constructor stub
    &#125;

    /**
     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
     */
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        List list = new ArrayList();
        list.add(new Employee(7731,&quot;张三&quot; , &quot;市场部&quot; , &quot;客户代表&quot; , 8000f));
        list.add(new Employee(8871,&quot;李四&quot; , &quot;研发部&quot; , &quot;运维工程师&quot; , 7000f));
        request.getServletContext().setAttribute(&quot;employee_list&quot;, list);
        request.getRequestDispatcher(&quot;/employee.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/09/20/后端/JSON,JQuery,Ajax,Freemarker,百度Echarts,正则表达,过滤器,监听与实践/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/09/12/后端/XML_Schema dtd Dom4j XPath/">
        <h2>
            XML_Schema dtd Dom4j XPath
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/9/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="XML-Extensible-Markup-Language"><a href="#XML-Extensible-Markup-Language" class="headerlink" title="XML(Extensible Markup Language)"></a>XML(Extensible Markup Language)</h2><p>XML可扩展标记语言，编写XML就是编写<strong>标签</strong>，与HTML非常类似，扩展名.xml。有良好的人机可读性</p>
<pre><code class="xml">hr.xml
&lt;employee&gt;
 &lt;name&gt;张三&lt;/name&gt;
 &lt;age&gt;31&lt;/age&gt;
 &lt;height&gt;178&lt;/height&gt;
&lt;/employee&gt;
</code></pre>
<ul>
<li>XML与HTML非常相似，都是编写标签</li>
<li>XML没有预定义标签，HTML存在大量预定义标签</li>
<li>XML重在保存与传输数据，HTML用于显示信息</li>
</ul>
<h2 id="XML用途"><a href="#XML用途" class="headerlink" title="XML用途"></a>XML用途</h2><p><strong>① 程序中有各种设置项提取出来存放在XML文件中，利用XML进行程序的设计</strong></p>
<pre><code class="xml">web.xml - web应用配置文件
&lt;web-app&gt;
 &lt;servlet&gt;
  &lt;servlet-name&gt;InitTest&lt;/servlet-name&gt;
  &lt;servlet-class&gt;moreservlets.InitServlet&lt;/servlet-class&gt;
   &lt;init-param&gt;
    &lt;param-name&gt;param1&lt;/param-name&gt;
    &lt;param-value&gt;value1&lt;/param-value&gt;
   &lt;/init-param&gt;
   &lt;init-param&gt;
    &lt;param-name&gt;param2&lt;/param-name&gt;
    &lt;param-value&gt;2&lt;/param-value&gt;
   &lt;/init-param&gt;
 &lt;/servlet&gt;
&lt;/web-app&gt;
</code></pre>
<p><strong>② 用于保存程序产生的数据 [简单的变成可以把数据库导成xml]</strong></p>
<pre><code class="xml">hr.xml
&lt;employee&gt;
 &lt;name&gt;张三&lt;/name&gt;
 &lt;age&gt;31&lt;/age&gt;
 &lt;height&gt;178&lt;/height&gt;
 &lt;salary&gt;7800&lt;/salary&gt;
&lt;/employee&gt;
</code></pre>
<p><strong>③ 网络间的数据传输</strong></p>
<pre><code class="xml">webservice底层soap协议
&lt;Envelop&gt;
&lt;Body&gt;
&lt;m:reversexmlns:m=&quot;urn:strings-com:IString&quot;&gt;
&lt;theString&gt;Hello,World&lt;/theString&gt;
&lt;/m:reversexmlns:m&gt;
&lt;/Body&gt;
&lt;/Envelop&gt;
</code></pre>
<h2 id="XML文档结构"><a href="#XML文档结构" class="headerlink" title="XML文档结构"></a>XML文档结构</h2><ul>
<li><p><strong>第一行必须是XML声明</strong></p>
<p> XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
version代表版本号1.0
encoding UTF-8设置字符集,用于支持中文
&lt;!-- 人力资源管理系统 --&gt;
&lt;hr&gt;
  &lt;employee no=&quot;3309&quot;&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;31&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;会计部&lt;/dname&gt;
      &lt;addresss&gt;XX大厦-B103&lt;/addresss&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3310&quot;&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;工程部&lt;/dname&gt;
      &lt;addresss&gt;XX大厦-B104&lt;/addresss&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
</li>
<li><p><strong>有且只有一个根节点</strong></p>
</li>
<li><p><strong>XML标签的书写规则与HTML相同</strong></p>
</li>
</ul>
<blockquote>
<h6 id="合法的标签名"><a href="#合法的标签名" class="headerlink" title="合法的标签名"></a>合法的标签名</h6><p>标签名要有意义<br>建议使用英文，小写字母，单词之间使用”-“分割</p>
<h6 id="适当的注释与缩进"><a href="#适当的注释与缩进" class="headerlink" title="适当的注释与缩进"></a>适当的注释与缩进</h6><p>适当的注释与缩进可以让XML文档更容易阅读</p>
<h6 id="合理使用属性"><a href="#合理使用属性" class="headerlink" title="合理使用属性"></a>合理使用属性</h6><p>标签属性用于描述标签不可或缺的信息<br>对标签分组或者为标签设置Id时常用属性表示</p>
<pre><code class="xml">&lt;shop-cart&gt;
&lt;item sn=&quot;771938&quot; category=&quot;电器&quot;&gt;
 &lt;name&gt;XXX空调&lt;/name&gt;
 &lt;price&gt;2000.00&lt;/price&gt;
 &lt;num&gt;1&lt;/num&gt;
&lt;/item&gt;
&lt;item sn=&quot;890321&quot; category=&quot;食品&quot;&gt;
 &lt;name&gt;法式面包&lt;/name&gt;
 &lt;price&gt;10.00&lt;/price&gt;
 &lt;num&gt;5&lt;/num&gt;
&lt;/item&gt;
&lt;/shop-cart&gt;
</code></pre>
<h6 id="特殊字符与CDATA标签"><a href="#特殊字符与CDATA标签" class="headerlink" title="特殊字符与CDATA标签"></a>特殊字符与CDATA标签</h6><p>标签体中，出现”&lt;”、”&gt;”特殊字符，会破坏文档结构</p>
<pre><code class="xml">错误的XML
&lt;question&gt; 1+4&lt;3是否正确？&lt;/question&gt;
</code></pre>
<p><u>解决方案①：使用实体引用</u></p>
<table>
<thead>
<tr>
<th>实体引用</th>
<th>对应符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp; It;</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&amp; gt;</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&amp; amp;</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>&amp; apos;</td>
<td>‘</td>
<td>单引号</td>
</tr>
<tr>
<td>&amp; quot;</td>
<td>“</td>
<td>双引号</td>
</tr>
</tbody></table>
<pre><code class="xml">修改后的XML
&lt;question&gt; 1+4&amp;lt;3是否正确？&lt;/question&gt;
</code></pre>
<p><u>解决方案②：使用CDATA标签</u><br>CDATA指的是不应由XML解析器进行解析的文本数据<br>从”<span style = "color : red"><strong>&lt; ![CDATA[“开始，到”]] &gt;</strong></span>“结束</p>
<pre><code class="xml">&lt;lesson&gt;
&lt;content&gt;
 &lt;![CDATA[
 本节我们来学习html中a标签的使用:
 &lt;body&gt;
  &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;
 &lt;/body&gt;
 ]]&gt;
&lt;/content&gt;
&lt;/lesson&gt;
</code></pre>
<h6 id="有序的子元素"><a href="#有序的子元素" class="headerlink" title="有序的子元素"></a>有序的子元素</h6><p>在XML多层嵌套的子元素中，标签前后顺序应保持一致<br>&lt;…&gt;     &lt;&#x2F;…&gt;</p>
</blockquote>
<h2 id="XML语义约束之DTD"><a href="#XML语义约束之DTD" class="headerlink" title="XML语义约束之DTD"></a>XML语义约束之DTD</h2><p>XML文档结构正确，但可能不是有效的</p>
<ul>
<li>例如，员工档案XML中绝不允许出现 “植物品种” 标签。XML语义约束就是用于规定XML文档中允许出现哪些元素</li>
<li>XML语义约束由两种定义方式：<strong>DTD</strong>与<strong>XML Schema</strong></li>
</ul>
<p><strong>DTD</strong>(Document Type Definition, 文档类型定义) 是一种简单易用的语义约束方式<br>DTD文件的扩展名为.dtd [<u><strong>用于说明HTML中拥有哪些节点可以出现</strong></u>]</p>
<pre><code class="dtd">hr.dtd
&lt;!ELEMENT hr (employee+)&gt;
&lt;!ELEMENT employee (name,age,salary,department)&gt;
&lt;!ATTLIST employee no CDATA &quot;&quot;&gt;
&lt;!ELEMENT name (#PCDATA)&gt;
...
</code></pre>
<pre><code class="dtd">定于hr节点下只允许出现1个employee子节点
&lt;!ELEMENT hr (employee)&gt;

employee节点下必须包含以下四个节点，且按顺序出现
&lt;!ELEMENT employee (name,age,salary,department)
    
定义name标签体只能是文本，#PCDATA代表文本元素
&lt;!ELEMENT name (#PCDATA)&gt;
</code></pre>
<h6 id="DTD定义节点数量"><a href="#DTD定义节点数量" class="headerlink" title="DTD定义节点数量"></a>DTD定义节点数量</h6><ul>
<li>如果某个子节点需要多个重复出现，则需要在子节点后增加相应的描述符<br>[后面带个＋号 最少出现一个]</li>
</ul>
<pre><code class="dtd">hr节点下最少出现1个emploee子节点    [+]
&lt;!ELEMENT hr (employee+)&gt;

hr节点下可出现0..n个employee子节点  [*]
&lt;!ELEMENT hr (employee*)&gt;

hr节点下最多出现1个emploee子节点    [?]
&lt;!ELEMENT hr (employee?)&gt;
</code></pre>
<h6 id="XML引用DTD文件"><a href="#XML引用DTD文件" class="headerlink" title="XML引用DTD文件"></a>XML引用DTD文件</h6><ul>
<li>在XML中使用**&lt; !DOCTYPE &gt;**标签来引用DTD文件</li>
</ul>
<pre><code class="xml">书写格式:
&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;
示例:
&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;
</code></pre>
<h6 id="案例-XML像是描述-dtd像是约束"><a href="#案例-XML像是描述-dtd像是约束" class="headerlink" title="案例 [XML像是描述 dtd像是约束 ]"></a>案例 [XML像是描述 dtd像是约束 ]</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;
&lt;!-- 人力资源管理系统 --&gt;
&lt;hr&gt;
  &lt;employee no=&quot;3309&quot;&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;31&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;会计部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B103&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3310&quot;&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;工程部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B104&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
<pre><code class="dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;!ELEMENT hr (employee+)&gt;
  &lt;!ELEMENT employee (name,age,salary,department)&gt;
  &lt;!--前后顺序必须匹配 一一对应--&gt;
  &lt;!ATTLIST employee no CDATA &quot;&quot;&gt;
  &lt;!ELEMENT name (#PCDATA)&gt;
  &lt;!ELEMENT age (#PCDATA)&gt;
  &lt;!ELEMENT salary (#PCDATA)&gt;
  &lt;!ELEMENT department (dname,address)&gt;
  &lt;!ELEMENT dname (#PCDATA)&gt;
  &lt;!ELEMENT address (#PCDATA)&gt;
  &lt;!--里面是纯文本节点 department有两个子节点--&gt;
</code></pre>
<h2 id="XML-Schema-比dtd更高级"><a href="#XML-Schema-比dtd更高级" class="headerlink" title="XML Schema(比dtd更高级)"></a>XML Schema(比dtd更高级)</h2><ul>
<li>XML Schema比DTD更为复杂，提供了多个功能</li>
<li>XML Schema提供了数据类型、格式限定、数据范围等特性</li>
<li>XML Schema是W3C标准</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;hr xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;hr.xsd&quot;&gt;
&lt;!-- 人力资源管理系统 --&gt;
&lt;hr&gt;
  &lt;employee no=&quot;3309&quot;&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;31&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;会计部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B103&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3310&quot;&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;工程部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B104&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
<pre><code class="dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;element name=&quot;hr&quot;&gt;
&lt;!--complexType标签含义是复杂节点，包含子节点时必须使用这个标签--&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;!-- 节点最少出现一次  --&gt;
        &lt;element name=&quot;employee&quot; minOccurs=&quot;1&quot;&gt;
          &lt;complexType&gt;
            &lt;sequence&gt;
              &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt;
              &lt;element name=&quot;age&quot;&gt;
                &lt;simpleType&gt;
                  &lt;restriction base=&quot;integer&quot;&gt; &lt;!--给年龄做限定--&gt;
                    &lt;minInclusive value=&quot;18&quot;&gt;&lt;/minInclusive&gt;
                    &lt;maxInclusive value=&quot;60&quot;&gt;&lt;/maxInclusive&gt;
                  &lt;/restriction&gt;
                &lt;/simpleType&gt;
              &lt;/element&gt;
              &lt;element name=&quot;department&quot;&gt;
                &lt;complexType&gt;
                  &lt;sequence&gt;
                    &lt;element name=&quot;dname&quot; type=&quot;string&quot;&gt;&lt;/element&gt;
                    &lt;element name=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt;
                  &lt;/sequence&gt;
                &lt;/complexType&gt;
              &lt;/element&gt;
            &lt;/sequence&gt;
          &lt;/complexType&gt;
        &lt;/element&gt;
      &lt;/sequence&gt;
      &lt;!--no在任何employee节点下必须存在--&gt;
      &lt;attribute name=&quot;no&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt;
    &lt;/complexType&gt;
  &lt;/element&gt;
&lt;/schema&gt;
</code></pre>
<h2 id="DOM文档对象模型"><a href="#DOM文档对象模型" class="headerlink" title="DOM文档对象模型"></a>DOM文档对象模型</h2><p>DOM(Document Object Model)定义了访问和操作XML文件的标准方法，DOM把XML文档作为树结构来看，能够通过DOM树来读写所有元素。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1e8123e138b0aca409a798eaf1a702c4633225c3/data/DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png"></p>
<h2 id="Dom4j-以java的形式解析xml"><a href="#Dom4j-以java的形式解析xml" class="headerlink" title="Dom4j[以java的形式解析xml]"></a>Dom4j[以java的形式解析xml]</h2><p>Dom4j是一个易用的、开源的库，用于解析XML。它应用于Java平台，具有性能优异、功能强大和极其易用的特点。</p>
<ul>
<li>Dom4j将XML视为Document对象</li>
<li>XML标签被Dom4j定义为Element对象</li>
</ul>
<h6 id="Dom4j对xml的解析读取和遍历"><a href="#Dom4j对xml的解析读取和遍历" class="headerlink" title="Dom4j对xml的解析读取和遍历"></a>Dom4j对xml的解析读取和遍历</h6><p> [<u><strong>原则是按照documents根节点和子节点依次类推的顺序对其进行分析、解析、提取</strong></u>]</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!-- 人力资源管理系统 --&gt;
&lt;hr&gt;
  &lt;employee no=&quot;3309&quot;&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;31&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;会计部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B103&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3310&quot;&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;工程部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B104&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
<pre><code class="java">package src;

import org.dom4j.Attribute;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.util.List;

public class HrReader&#123;
  public void readXml() throws DocumentException &#123;
    String file = &quot;D:\\JetBrains\\IdeaProjects\\Test_html\\src\\hr.xml&quot;;
    //SAXReader类是读取XML文件的核心类，用于将XML解析后
      SAXReader reader = new SAXReader();
      Document document = reader.read(file);
      //获取XML文档的根节点，即hr标签
      Element root = document.getRootElement();
      //elements方法用于获取指定的标签集合
      List&lt;Element&gt; employees = root.elements(&quot;employee&quot;);
      for (Element employee : employees)&#123;
       /* //element方法用于获取唯一的子节点对象
        Element name = employee.element(&quot;name&quot;);
        //getText()方法用于获取标签文本
        String empName = name.getText();
        System.out.println(empName);
        */
        System.out.println(employee.elementText(&quot;age&quot;));
        System.out.println(employee.elementText(&quot;salary&quot;));
        Element department = employee.element(&quot;department&quot;);
        System.out.println(department.elementText(&quot;dname&quot;));
        System.out.println(department.element(&quot;address&quot;).getText());
        Attribute att = employee.attribute(&quot;no&quot;); /*获取对应文本*/
        System.out.println(att.getText());
        System.out.println(&quot;====================&quot;);
        &#125;
      &#125;

  public static void main(String[] args) throws DocumentException &#123;
    HrReader reader = new HrReader();
    reader.readXml();
  &#125;
&#125;
</code></pre>
<h6 id="Dom4j更新-写入-XML"><a href="#Dom4j更新-写入-XML" class="headerlink" title="Dom4j更新(写入)XML"></a>Dom4j更新(写入)XML</h6><pre><code class="xml">已追加写入的信息
&lt;hr&gt;
 &lt;employee no=&quot;3311&quot;&gt;
    &lt;name&gt;李铁柱&lt;/name&gt;
    &lt;age&gt;28&lt;/age&gt;
    &lt;salary&gt;3600&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;人事部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B105&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
<pre><code class="java">package src;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;

import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

public class HrWriter &#123;
  public void weiteXml()&#123;
    String file = &quot;D:\\JetBrains\\IdeaProjects\\Test_html\\src\\hr.xml&quot;;
    SAXReader reader = new SAXReader();
    try &#123;
      Document document = reader.read(file);
      Element root = document.getRootElement();
      //创建employee子节点 全新空子节点
      Element employee = root.addElement(&quot;employee&quot;);
      employee.addAttribute(&quot;no&quot;,&quot;3311&quot;);
      Element name = employee.addElement(&quot;name&quot;);
      name.setText(&quot;李铁柱&quot;);
      employee.addElement(&quot;age&quot;).setText(&quot;28&quot;);
      employee.addElement(&quot;salary&quot;).setText(&quot;3600&quot;);
      Element department = employee.addElement(&quot;department&quot;);
      department.addElement(&quot;dname&quot;).setText(&quot;人事部&quot;);
      department.addElement(&quot;address&quot;).setText(&quot;XX大厦-B105&quot;);
      //内存中组织的dom模型重新写入到对应文件中
      Writer writer = new OutputStreamWriter(new FileOutputStream(file), &quot;UTF-8&quot;);
      document.write(writer);
      writer.close();
    &#125; catch (Exception e) &#123;
      e.printStackTrace();
    &#125;
  &#125;

  public static void main(String[] args) &#123;
    HrWriter hrWriter = new HrWriter();
    hrWriter.weiteXml();
  &#125;
&#125;
</code></pre>
<h2 id="XPath路径表达式"><a href="#XPath路径表达式" class="headerlink" title="XPath路径表达式"></a>XPath路径表达式</h2><ul>
<li>XPath路径表达式是XML文档中查找数据的语言</li>
<li>掌握XPath可以极大的提高在读取数据时的开发效率</li>
<li>学习XPath本质就是掌握各种形式表达式的使用技巧</li>
</ul>
<h6 id="最常用的基本表达式"><a href="#最常用的基本表达式" class="headerlink" title="最常用的基本表达式"></a>最常用的基本表达式</h6><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nodename</td>
<td>选取此节点的所有子节点</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>从根节点选取</td>
</tr>
<tr>
<td>&#x2F;&#x2F;</td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>bookstore</td>
<td>选取bookstore元素的所有子节点</td>
</tr>
<tr>
<td>&#x2F;bookstore</td>
<td>选取根元素bookstore<br />注释：假如路径起始于正斜杠(&#x2F;), 则此路径始终代表到某元素的绝对路径</td>
</tr>
<tr>
<td>bookstore&#x2F;book</td>
<td>选取属于bookstore的子元素的所有book元素</td>
</tr>
<tr>
<td>&#x2F;&#x2F;book</td>
<td>选取所有book子元素，而不管它们在文档中的位置</td>
</tr>
<tr>
<td>bookstore&#x2F;&#x2F;book</td>
<td>选取属于bookstore元素的后代的所有book元素，而不管它们位于bookstore之下的什么位置</td>
</tr>
<tr>
<td>&#x2F;&#x2F;@lang</td>
<td>选取名为lang的所有属性</td>
</tr>
</tbody></table>
<h6 id="XPath谓语表达式"><a href="#XPath谓语表达式" class="headerlink" title="XPath谓语表达式"></a>XPath谓语表达式</h6><table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bookstore&#x2F;book[1]</td>
<td>选取属于bookstore子元素的第一个book元素</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[last()]</td>
<td>选取属于bookstore子元素的最后一个book元素</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[position()&lt;3]</td>
<td>选取最前面的两个属于bookstore元素的子元素的book元素</td>
</tr>
<tr>
<td>&#x2F;&#x2F;title[@lang]</td>
<td>选取所有拥有名为lang的属性的title元素</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[price&gt;35.00]</td>
<td>选取bookstore元素的所有book元素，且其中的price元素的值须大于35.00</td>
</tr>
<tr>
<td>&#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;title</td>
<td>选取bookstore元素中的book元素的所有title元素，且其中的price元素的值必须大于35.00</td>
</tr>
</tbody></table>
<h2 id="XPath实验室-优先使用-查询数据"><a href="#XPath实验室-优先使用-查询数据" class="headerlink" title="XPath实验室 [优先使用 查询数据]"></a>XPath实验室 [优先使用 查询数据]</h2><h5 id="Jaxen介绍"><a href="#Jaxen介绍" class="headerlink" title="Jaxen介绍"></a>Jaxen介绍</h5><ul>
<li>Jaxen是一个Java编写的开源的XPath库。这是适合多种不同的对象模型，包括DOM，XOM，dom4j和JDOM</li>
<li>Dom4j底层一来Jaxen实现XPath查询</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!-- 人力资源管理系统 --&gt;
&lt;hr&gt;
  &lt;employee no=&quot;3309&quot;&gt;
    &lt;name&gt;张三&lt;/name&gt;
    &lt;age&gt;31&lt;/age&gt;
    &lt;salary&gt;4000&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;会计部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B103&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3310&quot;&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;23&lt;/age&gt;
    &lt;salary&gt;3200&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;工程部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B104&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;

  &lt;employee no=&quot;3311&quot;&gt;
    &lt;name&gt;李铁柱&lt;/name&gt;
    &lt;age&gt;28&lt;/age&gt;
    &lt;salary&gt;3600&lt;/salary&gt;
    &lt;department&gt;
      &lt;dname&gt;人事部&lt;/dname&gt;
      &lt;address&gt;XX大厦-B105&lt;/address&gt;
    &lt;/department&gt;
  &lt;/employee&gt;
&lt;/hr&gt;
</code></pre>
<pre><code class="java">package src;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.util.List;

public class XPathTestor &#123;
  public void xpath(String xpathExp)&#123;
    String file = &quot;D:\\JetBrains\\IdeaProjects\\Test_html\\src\\hr.xml&quot;;
    SAXReader reader = new SAXReader();
    try &#123;
      Document document = reader.read(file);
      //执行xpath表达式 Node不仅查询标签还可以查询属性
      List&lt;Node&gt; nodes = document.selectNodes(xpathExp);
      for (Node node : nodes)&#123;
        //转换成常用的Element对象 父类node强转
        Element emp = (Element)node;
        System.out.println(emp.attribute(&quot;no&quot;));
        System.out.println(emp.elementText(&quot;name&quot;));
        System.out.println(emp.elementText(&quot;age&quot;));
        System.out.println(emp.elementText(&quot;salary&quot;));
        System.out.println(&quot;===========================&quot;);
      &#125;
    &#125; catch (DocumentException e) &#123;
      throw new RuntimeException(e);
    &#125;
  &#125;

  public static void main(String[] args) &#123;
    XPathTestor testor = new XPathTestor();
    //单斜杠要按照根目录一级一级搜索
//    testor.xpath(&quot;/hr/employee&quot;);
    //双斜杠 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置
//    testor.xpath(&quot;//employee&quot;);
//    testor.xpath(&quot;//employee[salary&lt;4000]&quot;);
//    testor.xpath(&quot;//employee[name=&#39;李铁柱&#39;]&quot;);
//    testor.xpath(&quot;//employee[@no=3309]&quot;);
//    testor.xpath(&quot;//employee[1]&quot;);
//    testor.xpath(&quot;//employee[last()]&quot;);
//    testor.xpath(&quot;//employee[position()&lt;6]&quot;); 当前位置小于6
//    testor.xpath(&quot;//employee[1] | //employee[3]&quot;);
  &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/09/12/后端/XML_Schema dtd Dom4j XPath/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/08/22/后端/Java复习款(练习题)/">
        <h2>
            Java复习款练习题
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Collection集合习题"><a href="#Collection集合习题" class="headerlink" title="Collection集合习题"></a>Collection集合习题</h1><h3 id="练习：Collection集合统计元素出现次数"><a href="#练习：Collection集合统计元素出现次数" class="headerlink" title="练习：Collection集合统计元素出现次数"></a>练习：Collection集合统计元素出现次数</h3><p>给定以下代码，请定义方法listTest()统计集合中指定元素出现的次数，如”a”: 2,”b”: 2,”c” :1, “xxx”:0</p>
<pre><code class="java">   public static void main(String[] args) &#123;
        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;a&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;c&quot;);
        System.out.println(&quot;a:&quot;+listTest(list, &quot;a&quot;));
        System.out.println(&quot;b:&quot;+listTest(list, &quot;b&quot;));
        System.out.println(&quot;c:&quot;+listTest(list, &quot;c&quot;));
        System.out.println(&quot;xxx:&quot;+listTest(list, &quot;xxx&quot;));
    &#125;
    private static int listTest(Collection&lt;String&gt; list, String s)&#123;
        int count = 0;
        for (String string : list)&#123;
            if (s.equals(string))&#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：Collection集合数组转集合"><a href="#练习：Collection集合数组转集合" class="headerlink" title="练习：Collection集合数组转集合"></a>练习：Collection集合数组转集合</h3><p>定义一个方法，要求此方法把int数组转成存有相同元素的集合(集合里面的元素是Integer)，并返回。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6&#125;;
        ArrayList&lt;Integer&gt; arrayList = listTest(arr);
        System.out.println(arrayList);
    &#125;
    public static ArrayList&lt;Integer&gt; listTest(int[] arr)&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (Integer a : arr)&#123;
            list.add(a);
        &#125;
        return list;
    &#125;
</code></pre>
<h3 id="练习：Collection集合集合转数组"><a href="#练习：Collection集合集合转数组" class="headerlink" title="练习：Collection集合集合转数组"></a>练习：Collection集合集合转数组</h3><p>定义一个集合，并把集合(集合里面的元素是Integer)转成存有相同元素的数组，并将结果输出在控制台。（可以使用Object[]数组类型接收转换的数组）</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(100);
        list.add(200);
        list.add(300);
        Object[] obj = list.toArray();
        for (int i = 0; i &lt; obj.length; i++) &#123;
            System.out.println(obj[i]);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Object[] toArray()</p>
<p>以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。  因此，调用者可以自由地修改返回的数组。 </p>
</blockquote>
<h3 id="练习：Collection集合contains-方法使用"><a href="#练习：Collection集合contains-方法使用" class="headerlink" title="练习：Collection集合contains()方法使用"></a>练习：Collection集合contains()方法使用</h3><p>定义一个方法listTest(ArrayList &lt; String &gt; a1, String s),要求使用contains()方法判断a1集合里面是否包含s。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;itcast&quot;);
        list.add(&quot;itheima&quot;);
        list.add(&quot;java&quot;);
        System.out.println(listTest(list,&quot;Java&quot;));
    &#125;

    private static boolean listTest(ArrayList&lt;String&gt; a1, String s)&#123;
        if (a1.contains(s))&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：Collection集合isEmpty-方法的使用"><a href="#练习：Collection集合isEmpty-方法的使用" class="headerlink" title="练习：Collection集合isEmpty()方法的使用"></a>练习：Collection集合isEmpty()方法的使用</h3><p>定义一个方法listTest(ArrayList&lt; String &gt; a1), 要求使用isEmpty()判断a1里面是否有元素。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;1&quot;);
        System.out.println(listTest(list));
    &#125;
    public static boolean listTest(ArrayList&lt;String&gt;a1)&#123;
        if (a1.isEmpty())&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：简述迭代器的实现原理"><a href="#练习：简述迭代器的实现原理" class="headerlink" title="练习：简述迭代器的实现原理"></a>练习：简述迭代器的实现原理</h3><p>当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h3 id="练习：Collection集合返回首次出现索引"><a href="#练习：Collection集合返回首次出现索引" class="headerlink" title="练习：Collection集合返回首次出现索引"></a>练习：Collection集合返回首次出现索引</h3><p>定义一个方法listTest(ArrayList&lt; Integer &gt; a1, Integer s)，要求返回s在a1里面第一次出现的索引，如果s没出现过返回-1。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //定义集合，添加数据
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        System.out.println(listTest(list,5));
    &#125;
    private static int listTest(ArrayList&lt;Integer&gt;a1, Integer s)&#123;
        for (int i = 0; i &lt; a1.size(); i++) &#123;
            if (a1.get(i).equals(s))&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<h1 id="File类-amp-递归-amp-FileFilter习题"><a href="#File类-amp-递归-amp-FileFilter习题" class="headerlink" title="File类&amp;递归&amp;FileFilter习题"></a>File类&amp;递归&amp;FileFilter习题</h1><h3 id="练习：检查文件是否存在，文件的创建"><a href="#练习：检查文件是否存在，文件的创建" class="headerlink" title="练习：检查文件是否存在，文件的创建"></a>练习：检查文件是否存在，文件的创建</h3><p>描述：检查D盘下是否存在文件a.txt,如果不存在则创建该文件。</p>
<p><strong>操作步骤:</strong><br>1.使用绝对路径创建对象关联到D盘的a.txt。<br>2.通过文件对象方法判断文件是否存在。<br>3.不存在则调用创建文件的方法创建文件。</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa.txt&quot;);
        if (!f.exists())&#123;
            f.createNewFile();
        &#125;
    &#125;
</code></pre>
<h3 id="练习：单极文件夹的创建"><a href="#练习：单极文件夹的创建" class="headerlink" title="练习：单极文件夹的创建"></a>练习：单极文件夹的创建</h3><p>描述：在D盘下创建一个名为bbb的文件夹。</p>
<p><strong>操作步骤:</strong><br>1.创建文件对象指定路径为d:&#x2F;bbb<br>2.调用文件对象创建文件夹的方法</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa&quot;);
        // File f = new File(&quot;D:\\Clash\\aaa\\bbb&quot;);
        f.mkdir();
        // f.mkdirs(); 创建多级文件夹
    &#125;
</code></pre>
<h3 id="练习：删除文件和文件夹"><a href="#练习：删除文件和文件夹" class="headerlink" title="练习：删除文件和文件夹"></a>练习：删除文件和文件夹</h3><p>描述：将D盘下a.txt文件删除。将D盘下aaa文件夹删除,要求文件夹aaa是一个空文件夹。</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联路径：d:&#x2F;a.txt<br>2.调用文件对象删除文件的方法<br>3.创建文件对象关联路径：d:&#x2F;aaa<br>4 调用文件对象删除文件夹的方法.</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;d:/a.txt&quot;);
        // 删除文件
        f.delete();
        
        // 创建文件夹对象
        File dir = new File(&quot;d:/aaa&quot;);
        // 删除文件夹
        dir.delete();
    &#125;
</code></pre>
<h3 id="获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径"><a href="#获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径" class="headerlink" title="获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径"></a>获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径</h3><p>描述：获取D盘aaa文件夹中b.txt文件的文件名，文件大小，文件的绝对路径和父路径等信息，并将信息输出在控制台。</p>
<p><strong>操作步骤:</strong></p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;D:\\Clash\\a.txt&quot;);
        // 获得文件名
        String filename = f.getName();
        // 获得文件大小
        long filesize = f.length();
        // 获得文件的绝对路径
        String path = f.getAbsolutePath();
        // 获得父文件夹路径，返回字符串
        String parentPath = f.getParent();
        // 获得父文件夹路径，返回文件对象
        File parentFile = f.getParentFile();
        // 输出信息
        System.out.println(&quot;文件名：&quot; + filename);
        System.out.println(&quot;文件大小：&quot; + filesize);
        System.out.println(&quot;文件路径：&quot; + path);
        System.out.println(&quot;文件父路径：&quot; + parentPath);
        System.out.println(&quot;文件父路径：&quot; + parentFile);
    &#125;
</code></pre>
<h3 id="练习-文件夹或文件的判断"><a href="#练习-文件夹或文件的判断" class="headerlink" title="练习:文件夹或文件的判断"></a>练习:文件夹或文件的判断</h3><p>描述:</p>
<p>1.判断File对象是否是文件,是文件则输出：xxx是一个文件，否则输出：xxx不是一个文件。<br>2.判断File对象是否是文件夹,是文件夹则输出：xxx是一个文件夹，否则输出：xxx不是一个文件夹。(xxx是文件名或文件夹名)</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建两个文件对象分别关联到不同的文件，比如：d:&#x2F;a.txt，d:&#x2F;aaa<br>2.调用文件对象的判断是否是文件或是否是文件夹的方法<br>3.获得文件名，根据判断结果输出信息。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
       File f = new File(&quot;D:\\Clash\\a.txt&quot;);
       if (f.isFile())&#123;
           System.out.println(f.getName() + &quot;是文件&quot;);
       &#125;else &#123;
           System.out.println(f.getName() + &quot;不是文件&quot;);
       &#125;

       File f2 = new File(&quot;D:\\Clash&quot;);
       if (f2.isDirectory())&#123;
           System.out.println(f2.getName() + &quot;是文件夹&quot;);
       &#125;else&#123;
           System.out.println(f2.getName() + &quot;不是文件夹&quot;);
       &#125;
    &#125;
</code></pre>
<h3 id="练习：文件夹的获取方式"><a href="#练习：文件夹的获取方式" class="headerlink" title="练习：文件夹的获取方式"></a>练习：文件夹的获取方式</h3><p>描述:</p>
<p>获取指定文件夹下所有的文件，并将所有文件的名字输出到控制台。<br>注意：不包含子文件夹下的文件</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联到指定文件夹，比如：c:&#x2F;aaa<br>2.调用文件对象的listFiles方法获得文件数组<br>3.遍历文件数组将每一个文件的名字输出到控制台</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        File f = new File(&quot;D:\\Clash&quot;);
        File[] files = f.listFiles();
        for (File file : files)&#123;
            System.out.println(file.getName());
        &#125;
    &#125;
</code></pre>
<h1 id="List集合-amp-Set集合习题"><a href="#List集合-amp-Set集合习题" class="headerlink" title="List集合&amp;Set集合习题"></a>List集合&amp;Set集合习题</h1><h3 id="练习：List接口的特点"><a href="#练习：List接口的特点" class="headerlink" title="练习：List接口的特点"></a>练习：List接口的特点</h3><h6 id="简述List接口的特点"><a href="#简述List接口的特点" class="headerlink" title="简述List接口的特点"></a>简述List接口的特点</h6><p>★ 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的读取顺序按照11、22、33的顺序完成的<br>★ 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)<br>★ 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</p>
<h3 id="练习：hashCode和equals方法"><a href="#练习：hashCode和equals方法" class="headerlink" title="练习：hashCode和equals方法"></a>练习：hashCode和equals方法</h3><h6 id="请简述HashSet去除重复元素的原理"><a href="#请简述HashSet去除重复元素的原理" class="headerlink" title="请简述HashSet去除重复元素的原理"></a>请简述HashSet去除重复元素的原理</h6><p>★ 调用被添加元素的hashCode(), 和HashSet中已有元素的hasCode比较是否相同<br>★ 如果不同，直接存储<br>★ 如果相同，调用equals方法比较是否相同<br>★ 不相同，直接存储元素<br>★ 相同，认为是同一元素，不存储</p>
<h3 id="练习：数据结构"><a href="#练习：数据结构" class="headerlink" title="练习：数据结构"></a>练习：数据结构</h3><h6 id="简述常见的数据结构中元素的存储特点"><a href="#简述常见的数据结构中元素的存储特点" class="headerlink" title="简述常见的数据结构中元素的存储特点"></a>简述常见的数据结构中元素的存储特点</h6><p>★ 栈：stack，又称堆栈，对元素的存取特点是<strong>先进后出</strong>。即，存进去的元素，要在后它后面的元素一次取出后，才能取出该元素<br>★ 队列：queue，简称队，对元素的存取特点是<strong>先进先出</strong>。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素<br>★ 数组：Array，是有序的元素序列，对元素的存储特点是：<br>1,查找元素快：通过索引，可以快速访问指定位置的元素<br>2.增删元素慢<br><strong>(1)</strong>.指定索引位置增加元素：需要创建一个新数组，将指定元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置<br><strong>(2)</strong>.指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中<br>★ 链表：linkedlist 对元素的存取有如下的特点：<br>**(1).**多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的      右手拉住下个人的左手，依次类推，这样多个人就连在一起了。<br>**(2).**查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。<br><strong>(3)</strong>.增删元素快：<br>增加元素：只需要修改连接下个元素的地址即可。<br>删除元素：只需要修改连接下个元素的地址即可。</p>
<h3 id="练习：Comparable和Comparator比较器"><a href="#练习：Comparable和Comparator比较器" class="headerlink" title="练习：Comparable和Comparator比较器"></a>练习：Comparable和Comparator比较器</h3><p>简述 <code>Comparable </code>和 <code>Comparator</code> 两个接口的区别</p>
<p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的<code>compareTo</code>方法被称为它的自然比较方法。只能再类中实现<code>compareTo()</code>一次，不能经常修改的代码实现自己想要的排序。实现此接口的对象列表(和数组)可以通过<code>Collections.sort</code> 或 <code>Arrays.sort</code> 从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h3 id="练习：LinkedList方法的使用"><a href="#练习：LinkedList方法的使用" class="headerlink" title="练习：LinkedList方法的使用"></a>练习：LinkedList方法的使用</h3><h6 id="根据要求练习LinkedList方法："><a href="#根据要求练习LinkedList方法：" class="headerlink" title="根据要求练习LinkedList方法："></a>根据要求练习LinkedList方法：</h6><p><strong>(1)</strong>.基本方法：add, set, get, remove, clear, size等方法；<br><strong>(2)</strong>.特有方法：addFirst, addLast, getFirst, getLast, removeFirst, removeLast, push, pop, clear等方法。</p>
<pre><code class="java">(1).基本方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; arr = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹风&quot;);
        arr.add(&quot;西门吹水&quot;);

        // 3.使用add方法在指定索引添加元素
        arr.add(2, &quot;西门吹雨&quot;);

        // 4.使用set方法修改指定位置索引
        arr.set(0, &quot;东门&quot;);

        for (String str : arr) &#123;
            System.out.println(str);
        &#125;
        System.out.println(&quot;--------------&quot;);
        // 5.使用get方法获取指定索引的元素
        System.out.println(arr.get(1));

        // 6.使用size方法获取集合大小
        System.out.println(arr.size());

        // 7.使用remove方法删除指定索引的元素
        arr.remove(3);

        // 8.使用clear清空集合中的元素
        arr.clear();
        System.out.println(arr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">(2).特有方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; linked = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        linked.add(&quot;周杰伦&quot;);
        linked.add(&quot;周星驰&quot;);
        linked.add(&quot;周华健&quot;);
        linked.add(&quot;周润发&quot;);

        // 3.使用addFirst添加元素到集合最前面
        linked.addFirst(&quot;周传雄&quot;);

        // 4.使用addLast添加元素到集合最后面
        linked.addLast(&quot;周渝民&quot;);

        System.out.println(linked);

        // 5.使用getFirst获取集合第一个元素
        System.out.println(linked.getFirst());

        // 6.使用getLast获取集合最后一个元素
        System.out.println(linked.getLast());

        // 7.使用removeLast删除集合第一个元素
        String first = linked.removeFirst();
        System.out.println(first);

        // 8.使用removeLast删除集合最后一个元素
        String last = linked.removeLast();
        System.out.println(last);
        System.out.println(linked);


        // 9.使用pop弹出第一个元素
        String p = linked.pop();
        System.out.println(p);

        // 10.使用push在集合开头插入元素
        linked.push(&quot;周立波&quot;);
        System.out.println(linked);

        // 11.使用clear清空集合
        linked.clear();
        System.out.println(linked);
    &#125;
&#125;
</code></pre>
<h3 id="练习：HashSet存储自定义类型"><a href="#练习：HashSet存储自定义类型" class="headerlink" title="练习：HashSet存储自定义类型"></a>练习：HashSet存储自定义类型</h3><p>定义人类，包含姓名和年龄属性。创建4个人存储到<strong>HashSet</strong>中，姓名和年龄相同的人看做同一人不存储。</p>
<pre><code class="java">// 1.定义Person类.包好姓名年龄属性,重写hashCode()和equals()方法
public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        return name != null ? name.equals(person.name) : person.name == null;
    &#125;

    @Override
    public int hashCode() &#123;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
</code></pre>
<pre><code class="java">ublic class HashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 2.创建HashSet用于存储Person类型
        HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;();

        // 3.添加多个Person到HashSet中
        hashSet.add(new Person(&quot;王昭君&quot;, 21));
        hashSet.add(new Person(&quot;西施&quot;, 21));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));

        // 4.遍历获取HashSet中的内容
        for (Person p : hashSet) &#123;
            System.out.println(p);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：List集合元素替换"><a href="#练习：List集合元素替换" class="headerlink" title="练习：List集合元素替换"></a>练习：List集合元素替换</h3><p>向list集合添加姓名{张三,李四,王五,二丫,钱六,孙七}, 将二丫替换为王小丫</p>
<pre><code class="java">public class ListTest01 &#123;
    public static void main(String[] args) &#123;
        //1.创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        //2.存入数据
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;二丫&quot;);
        list.add(&quot;钱六&quot;);
        list.add(&quot;孙七&quot;);
        //3.遍历集合，找到&quot;二丫&quot;,便将其替换为&quot;王小丫&quot;
        //利用普通for循环遍历List集合
        for(int i = 0;i&lt;list.size();i++) &#123;
            //获取当前元素
            String thisName = list.get(i);
            //如果当前元素是&quot;二丫&quot;
            if(&quot;二丫&quot;.equals(thisName)) &#123;
                //将其改为&quot;王小丫&quot;
                list.set(i, &quot;王小丫&quot;);
            &#125;
        &#125;
        System.out.println(list);
    &#125;
&#125;

//   使用增强for获取LinkedHashSet中的元素
        for (String str : list)&#123;
           if (&quot;二丫&quot;.equals(str))&#123;
                System.out.println(list);
           &#125;
        &#125;
</code></pre>
<h3 id="练习：LinkedHashSet基本使用"><a href="#练习：LinkedHashSet基本使用" class="headerlink" title="练习：LinkedHashSet基本使用"></a>练习：LinkedHashSet基本使用</h3><p>使用LinkedHashSet存储以下元素：”王昭君”,”王昭君”,”西施”,”杨玉环”,”貂蝉”。使用迭代器和增强for循环遍历LinkedHashSet。</p>
<pre><code class="java">public class LinkedHashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建LinkedHashSet
        LinkedHashSet&lt;String&gt; lhSet = new LinkedHashSet&lt;String&gt;();
        // 2.使用add方法添加元素到LinkedHashSet
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;西施&quot;);
        lhSet.add(&quot;杨玉环&quot;);
        lhSet.add(&quot;貂蝉&quot;);
        // 3.使用迭代器获取LinkedHashSet中的元素
        Iterator&lt;String&gt; iterator = lhSet.iterator();
        while (iterator.hasNext()) &#123;
            System.out.println(iterator.next());
        &#125;
        // 4.使用增强for获取LinkedHashSet中的元素
        System.out.println(&quot;---------------------&quot;);
        for (String string : lhSet) &#123;
            System.out.println(string);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：Collections工具类使用"><a href="#练习：Collections工具类使用" class="headerlink" title="练习：Collections工具类使用"></a>练习：Collections工具类使用</h3><p>ArrayList集合中有如下内容： {33,11,77,55}，使用Collections.sort()对ArrayList集合中的数据进行排序，并打印出排序后的结果</p>
<pre><code class="java">public class CollectionsTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建ArrayList
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();

        // 2.使用add方法添加&#123;33,11,77,55&#125;四个元素
        arr.add(33);
        arr.add(11);
        arr.add(77);
        arr.add(55);

        // 3.调用Collections的sort方法,对集合排序
        Collections.sort(arr);

        // 4.使用增强for遍历ArrayList集合
        for (Integer integer : arr) &#123;
            System.out.println(integer);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Map集合习题"><a href="#Map集合习题" class="headerlink" title="Map集合习题"></a>Map集合习题</h1><h3 id="练习：Map接口的特点"><a href="#练习：Map接口的特点" class="headerlink" title="练习：Map接口的特点"></a>练习：Map接口的特点</h3><h6 id="请简述Map-的特点"><a href="#请简述Map-的特点" class="headerlink" title="请简述Map 的特点"></a>请简述Map 的特点</h6><p>★ Map每个元素由键与值两部分组成<br>★ Map键不能重复，每个键对应一个值<br>★ 键和值可以为null</p>
<h3 id="练习：Entry键值对对象"><a href="#练习：Entry键值对对象" class="headerlink" title="练习：Entry键值对对象"></a>练习：Entry键值对对象</h3><h6 id="说出Entry键值对对象遍历Map集合的原理"><a href="#说出Entry键值对对象遍历Map集合的原理" class="headerlink" title="说出Entry键值对对象遍历Map集合的原理"></a>说出Entry键值对对象遍历Map集合的原理</h6><p>Map中存放的是两种对象，一种称为Key(键)，一种称为value(值)，它们在Map中是一一对应关系，这一种对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每个键值对(Entry)对象中获取对应的键与对应的值。</p>
<h3 id="练习：Map接口中的常用方法"><a href="#练习：Map接口中的常用方法" class="headerlink" title="练习：Map接口中的常用方法"></a>练习：Map接口中的常用方法</h3><h6 id="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"><a href="#请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。" class="headerlink" title="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"></a>请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。</h6><pre><code class="java">    public static void main(String[] args) &#123;
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);
        String v1 = hm.put(&quot;李晨&quot;, &quot;白百合&quot;);
        String string = hm.get(&quot;大黑牛&quot;);
        String v2 = hm.remove(&quot;大黑牛&quot;);
        System.out.println(v2);
        System.out.println(hm);
    &#125;
//  范冰冰  &#123;邓超=孙俪, 李晨=白百合, 黄晓明=Baby&#125;
</code></pre>
<h3 id="练习：Map接口中的方法"><a href="#练习：Map接口中的方法" class="headerlink" title="练习：Map接口中的方法"></a>练习：Map接口中的方法</h3><p>往一个Map集合中添加若干元素。获取Map中的所有value，并使用增强for和迭代器遍历输出每个value。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        // 1.创建HashMap
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();

        // 2.使用put添加元素
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);

        // 3.使用Map的values方法获取到所有的value
        Collection&lt;String&gt; values = hm.values();

        // 4.使用增强for获取每个value
        for (String value : values) &#123;
            System.out.println(value);
        &#125;

        System.out.println(&quot;----------------&quot;);
        // 5.使用迭代器获取每个value
        Iterator&lt;String&gt; itr = values.iterator();
        while (itr.hasNext()) &#123;
            System.out.println(itr.next());
        &#125;
    &#125;
</code></pre>
<h3 id="练习：HashMap存储键是自定义对象是String"><a href="#练习：HashMap存储键是自定义对象是String" class="headerlink" title="练习：HashMap存储键是自定义对象是String"></a>练习：HashMap存储键是自定义对象是String</h3><p>请使用Map集合存储自定义数据类型Car做键，对应的价格做值。并使用keySet和entrySet两种方式遍历Map集合。</p>
<pre><code class="java">        // 1.定义汽车类.包含名称和价格属性,重写hashCode和equals方法
    public class Car &#123;
        private String name;
        private String color;
        ...
    &#125;
---------------------------------------------------
    public static void main(String[] args) &#123;
         // 2.创建HashMapkey保存汽车对象,value是汽车价格
        HashMap&lt;Car, Integer&gt; hm = new HashMap&lt;&gt;();

        // 3.添加汽车到HashMap中
        Car c1 = new Car(&quot;长安奔奔&quot;, &quot;黄色&quot;);
        Car c3 = new Car(&quot;奇瑞QQ&quot;, &quot;黑色&quot;);
        Car c2 = new Car(&quot;铃木奥拓&quot;, &quot;白色&quot;);

        hm.put(c1, 10000);
        hm.put(c2, 20000);
        hm.put(c3, 30000);

         // 4.使用keySet方式遍历Map
        Set&lt;Car&gt; keySet = hm.keySet();
        for (Car c : keySet) &#123;
        // 根据key获取value
            Integer value = hm.get(c);
            System.out.println(c.getName() + &quot;,&quot; + c.getColor() + &quot; - &quot; + value);
        &#125;

        System.out.println(&quot;-------------&quot;);

        // 5.使用entrySet方式遍历Map
        Set&lt;Map.Entry&lt;Car, Integer&gt;&gt; entrySet = hm.entrySet();
        for (Map.Entry&lt;Car, Integer&gt; entry : entrySet) &#123;
            Car key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key.getName() + &quot;,&quot; + key.getColor() + &quot; - &quot; + value);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。  该集合由地图支持，因此对地图的更改将反映在集合中，反之亦然。  如果在集合中的迭代正在进行时修改映射（除了通过迭代器自己的<code>remove</code>操作，或者通过迭代器返回的映射条目上的<code>setValue</code>操作），迭代的结果是未定义的。  该组支持元件移除，即从映射中相应的映射，经由<code>Iterator.remove</code> ，  <code>Set.remove</code> ， <code>removeAll</code> ，  <code>retainAll</code>和<code>clear</code>操作。  它不支持<code>add</code>或<code>addAll</code>操作。</p>
</blockquote>
<h3 id="练习：Map集合的使用-一"><a href="#练习：Map集合的使用-一" class="headerlink" title="练习：Map集合的使用(一)"></a>练习：Map集合的使用(一)</h3><h6 id="现在有一个map集合如下："><a href="#现在有一个map集合如下：" class="headerlink" title="现在有一个map集合如下："></a>现在有一个map集合如下：</h6><pre><code class="java">     Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();
     map.put(1, &quot;张三丰&quot;);
     map.put(2, &quot;周芷若&quot;);
     map.put(3, &quot;汪峰&quot;);
     map.put(4, &quot;灭绝师太&quot;);
</code></pre>
<p><strong>要求：</strong></p>
<p>1.遍历集合，并将序号与对应人名打印。<br>2.向该map集合中插入一个编码为5姓名为李晓红的信息<br>3.移除该map中的编号为1的信息<br>4.将map集合中编号为2的姓名信息修改为”周林”</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义HashMap,编号作为key,姓名作为value
        Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
        // 2.使用put方法添加元素
        map.put(1, &quot;张三丰&quot;);
        map.put(2, &quot;周芷若&quot;);
        map.put(3, &quot;汪峰&quot;);
        map.put(4, &quot;灭绝师太&quot;);
        // 3.使用keySet+增强for迭代map中的元素,并打印
        Set&lt;Integer&gt; keySet = map.keySet();
        for (Integer key : keySet) &#123;
            String value = map.get(key);
            System.out.println(key + &quot; -- &quot; + value);
        &#125;
        // 4.使用put向该map集合中插入一个编码为5姓名为李晓红的信息
        map.put(5, &quot;李晓红&quot;);
        // 5.使用remove移除该map中的编号为1的信息
        map.remove(1);
        // 6.使用put将map集合中编号为2的姓名信息修改为&quot;周林&quot;
        map.put(2, &quot;周林&quot;);
        System.out.println(map);
    &#125;
</code></pre>
<h3 id="练习：Map集合的使用-二"><a href="#练习：Map集合的使用-二" class="headerlink" title="练习：Map集合的使用(二)"></a>练习：Map集合的使用(二)</h3><p>有2个数组<br>第一个数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，<br>第二个数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为<strong>key</strong>，<br>第二个数组元素作为<strong>value</strong>存储到Map集合中。如{黑龙江省&#x3D;哈尔滨, 浙江省&#x3D;杭州, …}</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义第一个数组arr1
        String[] arr1 = &#123;&quot;黑龙江省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;广东省&quot;, &quot;福建省&quot;&#125;;
        // 2.定义第二个数组arr2
        String[] arr2 = &#123;&quot;哈尔滨&quot;, &quot;杭州&quot;, &quot;南昌&quot;, &quot;广州&quot;, &quot;福州&quot;&#125;;

        // 3.创建HashMap,key存放省,value存放市
        HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;();

        // 4.使用普通for循环遍历arr1
        for (int i = 0; i &lt; arr1.length; i++) &#123;
        // 5.根据索引到arr1中获取到省
            String key = arr1[i];
        // 6.根据索引到arr2中获取到省会城市
            String value = arr2[i];

        // 7.将省和省会城市添加到HashMap中
            hm.put(key, value);
        &#125;
        // 8.输出HashMap中的内容
        System.out.println(hm);
    &#125;
</code></pre>
<h1 id="Math类习题"><a href="#Math类习题" class="headerlink" title="Math类习题"></a>Math类习题</h1><h3 id="练习：实现字符串123反转"><a href="#练习：实现字符串123反转" class="headerlink" title="练习：实现字符串123反转"></a>练习：实现字符串123反转</h3><p>使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">        public class Test1 &#123;
            public static void main(String[] args) &#123;
                Scanner scanner = new Scanner(System.in);
                String next = scanner.next();
                System.out.println(&quot;录入的字符串:&quot; + next);
                String s = reverseStr(next);
                System.out.println(&quot;反转的字符串:&quot;+ s);
            &#125;
        
            public static String reverseStr(String  str)&#123;
                String s = &quot;&quot;;
                char[] chars = str.toCharArray();
                for (int i = chars.length - 1; i &gt;= 0; i--) &#123;
                    s +=chars[i] ;
                &#125;
                return s;
            &#125;
        &#125;
</code></pre>
<blockquote>
<p>toCharArray() 方法将字符串转换为字符数组</p>
</blockquote>
<h3 id="练习：键盘录入QQ号判断正确性"><a href="#练习：键盘录入QQ号判断正确性" class="headerlink" title="练习：键盘录入QQ号判断正确性"></a>练习：键盘录入QQ号判断正确性</h3><p>必须是5-12位数字，0不能开头</p>
<pre><code class="java">public class Test1 &#123;
    public static void main(String[] args) &#123;
        //1.键盘输入一个qq号码字符串
        Scanner sc = new Scanner(System.in);
        String qq = sc.next();
        //2.调用checkQQ (String qq)方法内实现验证。
        boolean isOK = checkQQ(qq);
        //3.打印验证的结果
        System.out.println(&quot;这个QQ号码是否正确:&quot; + isOK);
    &#125;

    /*
     * 定义方法：checkQQ (String qq)方法内实现验证
     * 指定方法的名称：checkQQ
     * 指定方法的参数：String qq
     * 指定方法的返回值：boolean
     */
    public static boolean checkQQ(String qq) &#123;
        //1.验证字符串的长度5-12位之间；
        if (qq.length() &lt; 5 || qq.length() &gt; 12) &#123;
            return false; //说明qq号码的长度不正确
        &#125;
        //2.验证首位字符不能是字符0；只能是字符&#39;1&#39;--&#39;9&#39;
        if (qq.charAt(0) == &#39;0&#39;) &#123;
            return false;
        &#125;
        //3.验证字符串中的每个字符都必须是数字字符‘0’-‘9’之间的字符
        for (int i = 0; i &lt; qq.length(); i++) &#123;
            char ch = qq.charAt(i);
            //判断字符是否在 数字字符‘0’-‘9’之间的字符
            if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
                return false;//说明qq号码中含有非数字字符
            &#125;
        &#125;
        //4.上述验证都通过了，说明qq号码是正确的
        return true;
    &#125;
 &#125;
</code></pre>
<h3 id="练习：大小写字符转换并统计次数"><a href="#练习：大小写字符转换并统计次数" class="headerlink" title="练习：大小写字符转换并统计次数"></a>练习：大小写字符转换并统计次数</h3><p>键盘录入一个大字符串，再录入一个小字符串。统计小字符串在大字符串中出现的次数。</p>
<pre><code class="java">   /*
* 分析以下需求，并用代码实现
1.键盘录入一个大字符串,再录入一个小字符串
2.统计小字符串在大字符串中出现的次数
3.代码运行打印格式:
请输入大字符串:woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma
请输入小字符串:heima
控制台输出:小字符串heima,在大字符串woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma中共出现3次
             */

    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        // 1.键盘录入一个大字符串,再录入一个小字符串
        System.out.print(&quot;请输入大字符串:&quot;);
        String big = sc.nextLine();
        System.out.print(&quot;请输入小字符串:&quot;);
        String small = sc.nextLine();
        // 2.统计小字符串在大字符串中出现的次数
        int count = getCount(big, small);
        // 3.代码运行打印格式:
        System.out.println(&quot;小字符串&quot; + small + &quot;,在大字符串中共出现&quot; + count + &quot;次&quot;);
    &#125;

    /*
     * 方法功能：统计小字符串在大字符串中出现的次数
     * 参数：big 代表大字符串
     * 参数：small 代表小字符串
     * 返回值：小字符串在大字符串中出现的次数
     */
    public static int getCount(String big, String small) &#123;
        int index = 0;
        int count = 0;
        /*
         * indexOf(String str, int fromIndex)
         * 该方法作用：从fromIndex位置开始查找，字符串str第一次出现的位置；若没找到，放回-1
         */
        while ((index = big.indexOf(small, index)) != -1) &#123;
            index++;
            count++;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：随机小数保留两位"><a href="#练习：随机小数保留两位" class="headerlink" title="练习：随机小数保留两位"></a>练习：随机小数保留两位</h3><p>生成一个<strong>随机100</strong>内小数，转换为保留两位小数的字符串，不考虑四舍五入的问题。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        double random = Math.random()*100;
        System.out.println(&quot;随机数为：&quot;);
        System.out.println(random);
        String str = random + &quot; &quot;;
        int index = str.indexOf(&quot;.&quot;);
        String substring = str.substring(0, index + 3);
        System.out.println(&quot;转换为&quot;);
        System.out.println(substring);
    &#125;
// substring(int strat, int end)中第一个参数是开始位置，第二个参数是结束位置.
</code></pre>
<h3 id="练习：筛选字符串"><a href="#练习：筛选字符串" class="headerlink" title="练习：筛选字符串"></a>练习：筛选字符串</h3><p>定义ArrayList集合，存入多个字符串。长度大于5的字符串，打印删除后的集合。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;bca&quot;);
        list.add(&quot;dadfa&quot;);
        list.add(&quot;dddaaa&quot;);
        list.add(&quot;你好啊&quot;);
        list.add(&quot;我来啦,你干嘛呢&quot;);
        list.add(&quot;别跑啊&quot;);
        System.out.println(&quot;源字符串：&quot;);
        System.out.println(list);
        delStrsFromList01(list);
    &#125;
    private static void delStrsFromList01(ArrayList&lt;String&gt; list)&#123;
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            String str = list.get(i);
            if (str.length() &gt; 3)&#123;
                list2.add(str);
            &#125;
        &#125;
        for (Object str : list2)&#123;
            list.remove(str);
        &#125;
        System.out.println(&quot;新字符：&quot; + list);
    &#125;
</code></pre>
<h3 id="练习：回文字符串"><a href="#练习：回文字符串" class="headerlink" title="练习：回文字符串"></a>练习：回文字符串</h3><p>判断回文字符串。如果一个字符串，从前向后读和从后向前读，都是一个字符串，称为回文串，比如mom，dad，noon。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        String next = scanner.next();
        boolean p = isP(next);
        System.out.println(
                &quot;回文数:&quot; + p
        );
    &#125;

    public static boolean isP(String str) &#123;
        int start = 0;
        int end = str.length() - 1;
        while (start &lt; end) &#123;
            if (str.charAt(start) != str.charAt(end)) &#123;
                return false;
            &#125;
            start++;
            end--;
        &#125;
        return true;
    &#125;
</code></pre>
<blockquote>
<p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
</blockquote>
<h3 id="练习：模拟简单计算器"><a href="#练习：模拟简单计算器" class="headerlink" title="练习：模拟简单计算器"></a>练习：模拟简单计算器</h3><p>模拟简单计算器，可以运算+，—，*，&#x2F;，%。</p>
<ul>
<li>接收三个参数，一个整数，一个运算符，另一个整数。( ‘5’   ‘+’   ‘7’ )</li>
<li>计算出运算结果。</li>
<li>无法运算时，返回null。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        String next = scanner.next();
        int b = scanner.nextInt();
        String count = count(a, next, b);
        System.out.println(a +next +b +&quot;=&quot;+count);
    &#125;

    public static String count(int a, String op , int b )&#123;
        int r=0;
        if (&quot;+&quot;.equals(op))&#123;
            r = a+b;
        &#125;else  if (&quot;-&quot;.equals(op))&#123;
            r = a-b;
        &#125;else  if (&quot;*&quot;.equals(op))&#123;
            r = a*b;
        &#125;else  if (&quot;/&quot;.equals(op))&#123;
            r = a/b;
        &#125;else  if (&quot;%&quot;.equals(op))&#123;
            r = a%b;
        &#125;else &#123;
            return null;
        &#125;
        return r+&quot;&quot;;
    &#125;
</code></pre>
<h3 id="练习：密码是否合法"><a href="#练习：密码是否合法" class="headerlink" title="练习：密码是否合法"></a>练习：密码是否合法</h3><p>校验密码是否合法。合法返回true </p>
<ul>
<li>必须至少8个字符。</li>
<li>必须至少2个大写字符。<code>超越两个就要依次遍历 for循环</code></li>
<li>必须只有字母和数字。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        String s = &quot;qweRY123&quot;;
        System.out.println(s+&quot;密码是否合法&quot;+isTrue(s));
    &#125;
    private static boolean isTrue(String s)&#123;
        if (s.length()&lt;8)&#123;
            return false;
        &#125;

        int countA = 0;
        char[] chars = s.toCharArray();
        for (int i = 0; i &lt; s.length(); i++) &#123;
            char ch = chars[i];
            //2个大写字母
            if (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;)&#123;
                countA++;
            &#125;
            //字母数字
            if ((ch &lt; &#39;0&#39;|| ch&gt;&#39;9&#39;) &amp;&amp; (ch &lt; &#39;A&#39;|| ch&gt;&#39;Z&#39;)&amp;&amp;(ch &lt; &#39;a&#39;|| ch&gt;&#39;z&#39;)) &#123;
                return false;
            &#125;
        &#125;
        if (countA &lt; 2)&#123;
            return false;
        &#125;
        return true;
    &#125;
</code></pre>
<h3 id="练习：模拟用户登录"><a href="#练习：模拟用户登录" class="headerlink" title="练习：模拟用户登录"></a>练习：模拟用户登录</h3><p>模拟用户登录。</p>
<ul>
<li>定义用户类，属性为用户名和密码。</li>
<li>使用集合存储多个用户对象。</li>
<li>录入用户和密码，对比用户信息，匹配成功登录成功，否则登录失败。</li>
<li>登录失败时，当用户名错误，提示没有该用户。</li>
<li>登录失败时，当密码错误时，提示密码有误。</li>
</ul>
<blockquote>
<p>jack-1234    rose-5678    tom-0000<br>请输入用户名：rose<br>请输入密码：5678<br>登录结果：登录成功</p>
</blockquote>
<pre><code class="java">public class User &#123;
    private String username;
    private String pwd;
&#125;
------------------------------------------
public class Test &#123;
    static ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;();
    static &#123;
        list.add(new User(&quot;jack&quot;, &quot;1234&quot;));
        list.add(new User(&quot;rose&quot;, &quot;5678&quot;));
        list.add(new User(&quot;tom&quot;, &quot;0000&quot;));
        for (int i = 0; i &lt; list.size(); i++) &#123;
            list.get(i).show();
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入用户名：&quot;);
        String username = sc.nextLine();
        System.out.println(&quot;请输入密码：&quot;);
        String password = sc.nextLine();
        User u = new User(username, password);
        String login = login(u);
        System.out.println(&quot;登录结果：&quot; + login);
    &#125;
    public static String login(User user) &#123;
        String msg = &quot;&quot;;
        String n = user.getUsername();
        String p = user.getPwd();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            User u = list.get(i);
            String name = u.getUsername();
            String pwd = u.getPwd();
            if (name.equals(n))&#123;
                if (pwd.equals(p))&#123;
                    return &quot;登录成功&quot;;
                &#125;else &#123;
                    return &quot;密码错误&quot;;
                &#125;
            &#125;else &#123;
                msg = &quot;用户名不存在&quot;;
                continue;
                &#125;
            &#125;
        return msg;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p><strong>static代码块</strong>也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，<u>每个代码块只会被执行一次</u>。[ <em><u>在此代码内适用于login方法中的list.size()</u></em> ]<br>static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的，<br>它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p>
</blockquote>
<h1 id="Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类"><a href="#Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类" class="headerlink" title="Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类"></a>Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类</h1><h3 id="练习：简述String和Object中的equals"><a href="#练习：简述String和Object中的equals" class="headerlink" title="练习：简述String和Object中的equals"></a>练习：简述String和Object中的equals</h3><p>简述String类中的equals方法 与 Object类中的equals方法的不同点</p>
<blockquote>
<p><strong>String类</strong>中的equals方法是用来<u>判断两个<strong>对象的内容</strong>是否相同</u>，而<strong>Object 类</strong>中的equals方法是用来<u>判断两个<strong>对象</strong>是否是同一个对象</u>，所谓同一个对象指的是内存中的同一块存储空间。</p>
</blockquote>
<h3 id="练习：Object类的toString方法"><a href="#练习：Object类的toString方法" class="headerlink" title="练习：Object类的toString方法"></a>练习：Object类的toString方法</h3><pre><code class="java">    public class ToStringTest&#123;
        static int i = 1;
        public static void main(String args[])&#123;
            System.out.println(&quot;love &quot; + new ToStringTest());//love java
            ToStringTest a = new ToStringTest();
            a.i++;
            System.out.println(&quot;me &quot; + a.i);//me 2
        &#125;
        public String toString()&#123;
            System.out.print(&quot;I &quot;);//I
            return &quot;java &quot;;
        &#125;
    &#125;
</code></pre>
<p>运行结果：I love java    me 2<br>原因：当执行代码的时候，首先加载静态变量，然后执行main方法，由于main方法内部第一行代码为输出语句，里面new了此类对象，当执行此行代码时会先创建了本类的对象，由于此类重写了toString方法，会先执行toString方法的打印输出，然后返回“java ”，再执行main方法第一行打印输出。在Java中“System.out.println(类对象名);”实际输出的是该对象的toString()方法返回的字符串，即括号中的内容等价于类对象名.toString(),toString方法的好处是在碰到println方法的时候会被自动调用，不用显示的写出来。</p>
<h3 id="练习：Object类equals方法"><a href="#练习：Object类equals方法" class="headerlink" title="练习：Object类equals方法"></a>练习：Object类equals方法</h3><p>看下列程序，不运行说结果，写出答案后，并在IntelliJ IDEA中运行看看自己给的答案与运行结果是否正确，并分析原因。</p>
<pre><code class="java">    (1)
        String s1 = new String(&quot;abc&quot;);
        String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //false
        System.out.println(s1.equals(s2));  //true
    (2)
        String s1 = &quot;abc&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //true
        System.out.println(s1.equals(s2));     //true
    (3)
        String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);        //true
        System.out.println(s1.equals(s2));     //true
    (4)
        String s1 = &quot;ab&quot;;
             String s2 = &quot;abc&quot;;
             String s3 = s1 + &quot;c&quot;;
        System.out.println(s3 == s2);             //false
              System.out.println(s3.equals(s2));  //true
</code></pre>
<h3 id="练习：StringBuilder类与String类的区别"><a href="#练习：StringBuilder类与String类的区别" class="headerlink" title="练习：StringBuilder类与String类的区别"></a>练习：StringBuilder类与String类的区别</h3><p>简述StringBuilder类与String类的区别</p>
<blockquote>
<p><strong>String类</strong>的对象内容不可改变，所以每当进行字符串拼接时，<strong>总是会在内存中创建一个新的对象</strong>，所以经常改变内容的字符串最好不要用String，因为<strong>每次生成对象都会对系统性能产生影响</strong>。</p>
<p><strong>StringBuilder</strong>又称为可变字符序列，是JDK5.0中新增加的一个类，它是一个类似于String的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串，并且能够对其中的字符串进行各种操作。<strong>它的内部拥有一个数组用来存放字符串内容</strong>，进行字符串拼接时，直接在数组中加入新内容，<strong>StringBuilder会自动维护数组的扩容</strong>。</p>
</blockquote>
<h3 id="练习：Date类的使用"><a href="#练习：Date类的使用" class="headerlink" title="练习：Date类的使用"></a>练习：Date类的使用</h3><p>获取当前的日期, 并把这个日期转换为指定格式的字符串, 如2088-08-08 08:08:08</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //获取当前日期对象 now;
        Date now = new Date();
        //创建SimpleDateFormat对象 df,并制定日期格式
        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        //调用df的format(Date  date) 方法,传入now; 接收返回的字符串
        String datestr = df.format(now);
        //打印这个字符串
        System.out.println(datestr);
    &#125;
</code></pre>
<h3 id="练习：DateFormat类方法的使用"><a href="#练习：DateFormat类方法的使用" class="headerlink" title="练习：DateFormat类方法的使用"></a>练习：DateFormat类方法的使用</h3><p>使用SimpleDateFormat类,把2018-03-04转换为2018年03月04日</p>
<pre><code class="java">    public static void main(String[] args) throws ParseException &#123;
        //创建SimpleDateFormat对象df1,指定日期模式为yyyy-MM-dd
        SimpleDateFormat df1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        //调用df1的parse(String str)方法传入2018-03-04,得到对应日期类型
        Date date = df1.parse(&quot;2018-03-04&quot;);
        //创建日期格式化对象df2,在获取格式化对象时可以指定风格
        DateFormat df2 = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
        //调用df2的format(Date date) 传入刚才转换的日期
        String str = df2.format(date);
        System.out.println(str);
    &#125;
</code></pre>
<blockquote>
<p>public Date parse(String text, ParsePosition pos)<br>从字符串中解析文本，产生一个<code>Date</code> 。</p>
</blockquote>
<h3 id="练习：Calendar类方法的使用"><a href="#练习：Calendar类方法的使用" class="headerlink" title="练习：Calendar类方法的使用"></a>练习：Calendar类方法的使用</h3><p>用程序判断2018年2月14日是星期几。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        //创建Calendar对象
        Calendar c = Calendar.getInstance();
        //将给定的日历字段设置到Calendar对象中
        c.set(Calendar.YEAR, 2018);
        c.set(Calendar.MONTH, 1);
        c.set(Calendar.DATE, 14);
        //设置年
        int year = c.get(Calendar.YEAR);
        //设置月
        int month = c.get(Calendar.MONTH)+1;
        //设置日
        int date = c.get(Calendar.DATE);
        //设置星期
        char week = getWeek(c.get(Calendar.DAY_OF_WEEK));
        //输出结果
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日是星期&quot;+week);
    &#125;
    //定义方法，获取星期汉字
    public static char getWeek(int a)&#123;
        char[] c = &#123;&#39; &#39;,&#39;日&#39;,&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;,&#39;六&#39;&#125;;
        return c[a];
    &#125;
&#125;
</code></pre>
<h1 id="Random类-amp-ArrayList集合习题"><a href="#Random类-amp-ArrayList集合习题" class="headerlink" title="Random类&amp;ArrayList集合习题"></a>Random类&amp;ArrayList集合习题</h1><h3 id="练习：随机验证码"><a href="#练习：随机验证码" class="headerlink" title="练习：随机验证码"></a>练习：随机验证码</h3><ul>
<li>随机生成十组六位字符组成的验证码。</li>
<li>验证码由大小写字母、数字字符组成。</li>
</ul>
<p><strong>开发提示</strong>：使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            String s = verifyCode();
            System.out.println(&quot;随机验证码：&quot; + s);
        &#125;
    &#125;
    public static String verifyCode()&#123;
        char[] arr = &#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;;
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            int index = random.nextInt(arr.length);
            code  += arr[index];
        &#125;
        return code;
    &#125;
</code></pre>
<h3 id="练习：输入学生信息保存到集合"><a href="#练习：输入学生信息保存到集合" class="headerlink" title="练习：输入学生信息保存到集合"></a>练习：输入学生信息保存到集合</h3><p>键盘录入学生信息，保存到集合中。</p>
<ul>
<li>循环录入的方式，1：表示继续录入，0：表示结束录入。</li>
<li>定义学生类，属性为姓名，年龄，使用学生对象保存录入数据。</li>
<li>使用ArrayList集合，保存学生对象，录入结束后，遍历集合。</li>
</ul>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
     public void show()&#123;
        System.out.println(&quot;姓名: &quot;+ name + &quot; &quot; + &quot;年龄: &quot; + age);
    &#125;
&#125;
----------------------------------
        public static void main(String[] args) &#123;
            Scanner scanner = new Scanner(System.in);
            ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
            while (true) &#123;
                System.out.println(&quot;1.录入信息 0.退出&quot;);
                int i = scanner.nextInt();
                switch (i) &#123;
                    case 1:
                        inputStu(list , scanner);
                        break;
                    case 0:
                        System.out.println(&quot;录入完毕&quot;);
                &#125;
                if (i == 0)&#123;
                    break;
                &#125;
            &#125;
    
            for (int i = 0; i &lt; list.size(); i++) &#123;
                Student student = list.get(i);
                student.show();
            &#125;
        &#125;
    
        private static void inputStu(ArrayList&lt;Student&gt; list , Scanner sc) &#123;
            System.out.println(&quot;请输入姓名:&quot;);
            String name = sc.next();
            System.out.println(&quot;请输入年龄:&quot;);
            int age = sc.nextInt();
            Student student = new Student(name, age);
            list.add(student);
        &#125;
    &#125;
</code></pre>
<h3 id="练习：随机数-次数打印"><a href="#练习：随机数-次数打印" class="headerlink" title="练习：随机数 次数打印"></a>练习：随机数 次数打印</h3><p>统计数字出现次数。</p>
<ul>
<li>定义getNumList方法，随机生成100个数字，数字范围从1到10。</li>
<li>定义printCount方法，统计每个数字出现的次数并打印到控制台。</li>
</ul>
<pre><code class="java">    public class Test4 &#123;
        public static void main(String[] args) &#123;
            ArrayList&lt;Integer&gt; numList = getNumList();
            //  统计字符数组中字母出现次数
            printCount(numList);
        &#125;
        public static void printCount(ArrayList&lt;Integer&gt; list) &#123;
            int[] count = new int[10];
            // 对应保存数字出现的次数
            for (int i = 0; i &lt; list.size(); i++) &#123;
                int c = list.get(i);
                count[c-1]++;
            &#125;
            // 打印数字和次数
            for (int i = 0 ; i &lt; count.length; i++) &#123;
                    System.out.println(&quot;数字:&quot;+(i+1) + &quot;--&quot; + count[i]+&quot;次&quot;);
            &#125;
        &#125;
        public static ArrayList&lt;Integer&gt; getNumList() &#123;
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            Random r = new Random();
            for (int i = 0; i &lt; 100; i++) &#123;
                int x = r.nextInt(10) + 1;
                list.add(x);
            &#125;
            return list;
        &#125;
    &#125;    
</code></pre>
<h3 id="练习：需求实现"><a href="#练习：需求实现" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><p>模拟统计班级考试分数分布情况，分别统计100-80，79-60，59-40，39-0各个阶段的人数。</p>
<ul>
<li>定义getScoreList方法，随机生成50个数字，数字范围从0到100。</li>
<li>定义countScore方法，统计各个阶段的分数个数。</li>
<li>定义printCount方法，打印各个阶段的统计结果。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; scoreList = getScoreList(); //获取随机分数
        ArrayList&lt;Integer&gt; countList = countScore(scoreList); //定义计数的变量
        printCount(countList);
    &#125;
    public static ArrayList&lt;Integer&gt; countScore(ArrayList&lt;Integer&gt; scoreList) &#123;
        ArrayList&lt;Integer&gt; countList = new ArrayList&lt;&gt;();
        int count100 = 0;
        int count79 = 0;
        int count59 = 0;
        int count39 = 0;

        for (int i = 0; i &lt; scoreList.size(); i++) &#123;
            Integer score = scoreList.get(i);
            if (score &lt;= 100 &amp;&amp; score &gt;= 80) &#123;
                count100++;
            &#125; else if (score &lt;= 79 &amp;&amp; score &gt;= 60) &#123;
                count79++;
            &#125; else if (score &lt;= 59 &amp;&amp; score &gt;= 40) &#123;
                count59++;
            &#125; else &#123;
                count39++;
            &#125;
        &#125;

        countList.add(count100);
        countList.add(count79);
        countList.add(count59);
        countList.add(count39);

        return countList;
    &#125;

    private static ArrayList&lt;Integer&gt; getScoreList()&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 50; i++) &#123;
            int x = r.nextInt(100);
            list.add(x);
        &#125;
        return list;
    &#125;

    private static void printCount(ArrayList&lt;Integer&gt; countList) &#123;
        int start = 100;
        int end = 80;
        for (int i = 0; i &lt; countList.size(); i++) &#123;
            Integer integer = countList.get(i);
            System.out.println(start + &quot;\t分 --&quot; + end + &quot; \t分:&quot; + integer+&quot;人&quot;);
            if (i == 0)&#123;
                start-=21;
                end -=20;
            &#125;else if (i == countList.size()-2)&#123;
                start-=20;
                end-=40;
            &#125;else &#123;
                start -= 20;
                end -= 20;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：添加移除展示元素"><a href="#练习：添加移除展示元素" class="headerlink" title="练习：添加移除展示元素"></a>练习：添加移除展示元素</h3><p>自定义MyList类，实现存取元素的功能。</p>
<ul>
<li>定义add方法，可以保存元素，添加MyList尾部。</li>
<li>定义remove方法，可以获取到最后添加的元素，并从MyList中移除该元素。</li>
<li>定义show方法，可以展示MyList中的元素。</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
        MyList myList = new MyList();
        for (int i = 0; i &lt; 3; i++) &#123;
            myList.add(i);
        &#125;
        System.out.println(&quot;添加元素后:&quot;);
        myList.show();

        Integer remove = myList.remove();
        System.out.println(&quot;获取元素:&quot;);
        System.out.println(remove);
        System.out.println(&quot;获取元素后:&quot;);
        myList.show();
    &#125;
&#125;

class MyList &#123;
    ArrayList&lt;Integer&gt; ml = new ArrayList&lt;&gt;();

    public void add(Integer i) &#123;
        ml.add(i);
    &#125;

    public Integer remove() &#123;
        Integer remove = ml.remove(ml.size() - 1);
        return remove;
    &#125;

    public void show() &#123;
        System.out.println(ml);
    &#125;
&#125;
</code></pre>
<h1 id="线程-amp-同步习题"><a href="#线程-amp-同步习题" class="headerlink" title="线程&amp;同步习题"></a>线程&amp;同步习题</h1><h3 id="练习：多线程开启"><a href="#练习：多线程开启" class="headerlink" title="练习：多线程开启"></a>练习：多线程开启</h3><h6 id="请描述Thread类中的start-方法与run-方法的区别"><a href="#请描述Thread类中的start-方法与run-方法的区别" class="headerlink" title="请描述Thread类中的start()方法与run()方法的区别"></a>请描述Thread类中的start()方法与run()方法的区别</h6><p>线程对象调用run()方法不开启线程，仅是对象调用方法。<br>线程对象调用start()方法开启线程，并让jvm调用run()方法在开启的线程中执行。</p>
<h3 id="练习：创建多线程"><a href="#练习：创建多线程" class="headerlink" title="练习：创建多线程"></a>练习：创建多线程</h3><h6 id="请描述创建线程的两种方法"><a href="#请描述创建线程的两种方法" class="headerlink" title="请描述创建线程的两种方法"></a>请描述创建线程的两种方法</h6><ul>
<li><h5 id="将类声明为Thread的子类"><a href="#将类声明为Thread的子类" class="headerlink" title="将类声明为Thread的子类"></a>将类声明为Thread的子类</h5></li>
</ul>
<p>①.定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。<br>②.创建Thread子类的实例，即创建了线程对象<br>③.调用线程对象的start()方法来启动该线程</p>
<ul>
<li><h5 id="声明一个类实现Runnable接口"><a href="#声明一个类实现Runnable接口" class="headerlink" title="声明一个类实现Runnable接口"></a>声明一个类实现Runnable接口</h5></li>
</ul>
<p>①.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>②,创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，Thread对象才是真正的线程对象<br>③.调用线程对象的start()方法来启动线程</p>
<h3 id="练习：多线程"><a href="#练习：多线程" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请编写程序，分别打印主线程的名称和子线程的名称"><a href="#请编写程序，分别打印主线程的名称和子线程的名称" class="headerlink" title="请编写程序，分别打印主线程的名称和子线程的名称"></a>请编写程序，分别打印主线程的名称和子线程的名称</h6><p>要求使用两种方式实现：<br>          第一种方式：继承Thread类。<br>          第二种方法：实现Runnable接口。</p>
<p><strong>操作步骤描述</strong>：</p>
<ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5></li>
</ul>
<p>①.定义一个子线程的类，继承Thread类<br>②.在子线程类中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称<br>⑤.在main方法中创建子线程对象<br>⑥.调用子线程对象的start方法，开启子线程</p>
<pre><code class="java">// 1.定义一个子线程的类，继承Thread类；
public class SubThread extends Thread&#123;
// 2.在子线程类中重写run方法，在run方法中打印子线程的名称；
    public void run()&#123;
    // 打印子线程的名称
      System.out.println(&quot;subThread:&quot; + Thread.currentThread().getName());
    &#125;
&#125;
// 3.定义一个测试类
public class ThreadDemo&#123;
    public static void main(String[] args)&#123;
// 4.在main方法中打印主线程的名称；
    System.out.println(&quot;main:&quot; + Thread.currentThread().getName());
// 5.在main方法中创建子线程对象；
    SubThread st = new SubThread();
// 6.调用子线程对象的start方法，开启子线程。
    st.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5></li>
</ul>
<p>①.定义一个子任务类，实现Runnable接口<br>②.在子任务中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称；<br>⑤.在main方法中创建一个子任务对象；<br>⑥.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的构造方法；<br>⑦.调用Thread类对象的start方法开启子线程；</p>
<pre><code class="java">// 1.定义一个子任务类，实现Runnable接口。
public class SubRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
// 2.在子任务类中重写run方法，在run方法中打印子线程的名称。
    System.out.println(&quot;SubRunnable:&quot;+ Thread.currentThread().getName());
// 3.定义一个测试类。
   &#125;
&#125;
public class RunnableDemo &#123;
    public static void main(String[] args) &#123;
// 4.在main方法中打印主线程的名称。
    System.out.println(&quot;RunnableDemo:&quot;+ Thread.currentThread().getName());
// 5.在main方法中创建一个子任务对象。
    SubRunnable r = new SubRunnable();
// 6.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的                         构造方法。
    Thread t = new Thread(r);
// 7.调用Thread类对象的start方法开启子线程。
    t.start();
 &#125;
&#125;
</code></pre>
<h3 id="练习：实现Runnable接口的优势"><a href="#练习：实现Runnable接口的优势" class="headerlink" title="练习：实现Runnable接口的优势"></a>练习：实现Runnable接口的优势</h3><h6 id="请描述实现Runnable接口比继承Thread类所具有的优势："><a href="#请描述实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="请描述实现Runnable接口比继承Thread类所具有的优势："></a>请描述实现Runnable接口比继承Thread类所具有的优势：</h6><p>①.适合多个相同的程序代码的线程去共享同一个资源<br>②.可以避免java中的单继承的局限性<br>③.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和数据独立。<br>④.线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</p>
<h3 id="练习：多线程-1"><a href="#练习：多线程-1" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><p>创建多线程对象，开启多线程。在子线程中输出1-100之间的偶数，主线程输出1-100之间的奇数</p>
<p><strong>自定义线程类</strong>：</p>
<pre><code class="java">public class MyThread extends Thread &#123;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 100; i++) &#123;
            if (i % 2 == 0) &#123;
                System.out.println(&quot;子线程打印输出偶数：&quot; + i);
            &#125;
        &#125;
    &#125;
    public class Test11 &#123;
        public static void main(String[] args) &#123;
            //创建自定义线程对象
            MyThread mt = new MyThread();
            //开启线程
            mt.start();
            //在主方法中执行for循环
            for (int i = 1; i &lt;= 100; i++) &#123; 
                if (i % 2 == 1) &#123;
                    System.out.println(&quot;主线程打印输出奇数：&quot; + i);
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：线程状态"><a href="#练习：线程状态" class="headerlink" title="练习：线程状态"></a>练习：线程状态</h3><h6 id="请描述在线程的生命周期中，-有几种状态呢"><a href="#请描述在线程的生命周期中，-有几种状态呢" class="headerlink" title="请描述在线程的生命周期中， 有几种状态呢 ?"></a>请描述在线程的生命周期中， 有几种状态呢 ?</h6><p>1.<strong>NEW(新建)</strong> 线程刚被创建，但是并未启动。</p>
<p>2.<strong>Runnable(可运行)</strong><br>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</p>
<p>3.<strong>Blocked(锁阻塞)</strong><br>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</p>
<p>4.<strong>Waiting(无限等待)</strong><br>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</p>
<p>5.<strong>Timed Waiting(计时等待)</strong><br>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</p>
<p>6.<strong>Teminated(被终止)</strong><br>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</p>
<h1 id="线程池-amp-lambda表达式习题"><a href="#线程池-amp-lambda表达式习题" class="headerlink" title="线程池&amp;lambda表达式习题"></a>线程池&amp;lambda表达式习题</h1><h3 id="练习：线程池概念"><a href="#练习：线程池概念" class="headerlink" title="练习：线程池概念"></a>练习：线程池概念</h3><h5 id="请描述什么是线程池"><a href="#请描述什么是线程池" class="headerlink" title="请描述什么是线程池"></a>请描述什么是线程池</h5><p>线程池：其实就是一个<strong>容纳多个线程的容器</strong>，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复用户创建线程而消耗过多的资源</p>
<h3 id="练习：线程池优点"><a href="#练习：线程池优点" class="headerlink" title="练习：线程池优点"></a>练习：线程池优点</h3><h5 id="请描述合理利用线程池能够带来的三个好处"><a href="#请描述合理利用线程池能够带来的三个好处" class="headerlink" title="请描述合理利用线程池能够带来的三个好处"></a>请描述合理利用线程池能够带来的三个好处</h5><p>1,<strong>降低资源消耗</strong>。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可以执行多个任务<br>2.<strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行<br>3.<strong>提高线程的可管理性</strong>。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<h3 id="练习：Lambda表达式"><a href="#练习：Lambda表达式" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda语法的省略规则"><a href="#请列举Lambda语法的省略规则" class="headerlink" title="请列举Lambda语法的省略规则"></a>请列举Lambda语法的省略规则</h6><p>在Lambda标准格式的基础上，使用省略句写法的规则为：<br>1.小括号内参数的类型可以省略<br>2.如果小括号内有且只有一个参数，则小括号可以省略<br>3.如果大括号内有且只有一个语句，则无论是否有返回值，都可以省略大括号、return、关键字以及语句分号</p>
<h3 id="练习：Lambda表达式-1"><a href="#练习：Lambda表达式-1" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda表达式的3个组成部分，并解释说明"><a href="#请列举Lambda表达式的3个组成部分，并解释说明" class="headerlink" title="请列举Lambda表达式的3个组成部分，并解释说明"></a>请列举Lambda表达式的3个组成部分，并解释说明</h6><p>Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成：<strong>一些参数、一个箭头、一段代码</strong><br><u>Lambda表达式的标准格式</u>：<br>1.小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号分割<br>2.”—&gt;”是新引入的语法格式，代表指向动作<br>3.大括号内的语法与<strong>传统方法体</strong>要求基本一致</p>
<h3 id="练习：Lambda表达式-2"><a href="#练习：Lambda表达式-2" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请描述Lambda的使用前提"><a href="#请描述Lambda的使用前提" class="headerlink" title="请描述Lambda的使用前提"></a>请描述Lambda的使用前提</h6><p>Lambda的语法非常简介，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：<br>1.使用Lambda必须具有接口，且要求接口中<strong>有且只有一个抽象方法</strong>。无论是JDK内置的<code>Runnable、Comparator</code>接口还是自定义的接口，只有<strong>当接口中的抽象方法存在且唯一时</strong>，才能使用Lambda。<br>2.使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例</p>
<h3 id="练习：多线程-2"><a href="#练习：多线程-2" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="代码实现打印输出1-99"><a href="#代码实现打印输出1-99" class="headerlink" title="代码实现打印输出1-99"></a>代码实现打印输出1-99</h6><pre><code class="java">public class Test06 &#123;
    public int start = 1;
    public int end = 99;

public static void main(String[] args) &#123;
    new Test06().method();
 &#125;

public void method() &#123;
    //插入代码处
         Runnable a = () -&gt; &#123;
      for (int i = start; i &lt;end; i++) &#123;
        System.out.println(i);
      &#125;
    &#125;;
      Thread t = new Thread(a);
      t.start();
     &#125;
&#125;
</code></pre>
<h3 id="练习：多线程-3"><a href="#练习：多线程-3" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请问该程序的运行结果是什么-如有问题，请说明原因。"><a href="#请问该程序的运行结果是什么-如有问题，请说明原因。" class="headerlink" title="请问该程序的运行结果是什么?  如有问题，请说明原因。"></a>请问该程序的运行结果是什么?  如有问题，请说明原因。</h6><pre><code class="java">public class Test07implements Runnable &#123;
    public static void main(String[] args) &#123;
      Thread t = new Thread(new Test07());
      t.start();
      &#125;

public void run(int num) &#123;
    for (int i = 0; i &lt; num; i++) &#123;
       System.out.println(i);
    &#125;
  &#125;
&#125;
</code></pre>
<p>在编译时期就会报错</p>
<p>​               Test类没有重写Runnable接口中的run()方法</p>
<p>​               public void run(int num)不是Runnable接口中的run()方法。</p>
<p><strong>注意：Runnable接口中的run()方法，参数列表为空，不带参数。</strong></p>
<h3 id="练习：线程池练习"><a href="#练习：线程池练习" class="headerlink" title="练习：线程池练习"></a>练习：线程池练习</h3><h6 id="使用线程池创建多线程。模拟同学找老师学习Java。"><a href="#使用线程池创建多线程。模拟同学找老师学习Java。" class="headerlink" title="使用线程池创建多线程。模拟同学找老师学习Java。"></a>使用线程池创建多线程。模拟同学找老师学习Java。</h6><p>1.创建线程池对象，包含2个线程。从线程池中获取线程对象，然后调用MyRunnable中的run()。<br>2.在MyRunnable实现类中，首先在控制台打印需求，“我需要一个老师”。模拟需要2秒钟时间老师可以过来指导学生，并在控制台打印老师的姓名。最后，在控制台打印“教我java,教完后，老师回到了办公室”；</p>
<pre><code class="java">class Test implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个老师&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;老师来了&quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我Java，教完后，老师回到了办公室&quot;);
    &#125;
&#125;

class ThreadPoolDemo&#123;
    public static void main(String[] args) &#123;
        ExecutorService service = Executors.newFixedThreadPool(2);
        Test r = new Test();
        service.submit(r);//线程1
        service.submit(r);//线程2
        service.submit(r);//线程3
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-无参无返回"><a href="#练习：Lambda-无参无返回" class="headerlink" title="练习：Lambda(无参无返回)"></a>练习：Lambda(无参无返回)</h3><p>给定一个导演 Director接口，内含唯一的抽象方法makeMovie，且无参数、无返回值，使用lambda表达式在Test中完成调用。</p>
<pre><code class="java">interface Director&#123;
    void makeMovie();
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请使用Lambda【省略格式】调用invokeDirect方法
        invokeDirect(()-&gt; System.out.println(&quot;拍电影啦&quot;));
    &#125;
    private static void invokeDirect(Director director)&#123;
        director.makeMovie();
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-有参有返回"><a href="#练习：Lambda-有参有返回" class="headerlink" title="练习：Lambda(有参有返回)"></a>练习：Lambda(有参有返回)</h3><p>给定一个计算器 Calculator 接口，内含抽象方法 calc (减法)，其功能是可以将两个数字进行相减，并返回差值。使用Lambda表达式在Test中完成调用</p>
<pre><code class="java">interface Calculator&#123;
    int calc(int a, int b);
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß
        invokeCalc(130, 120, (int a, int b) -&gt; &#123;
            return a - b;
        &#125;); //标准格式
        invokeCalc(130,120,(a,b)-&gt; a-b); //省略模式
    &#125;
    private static void invokeCalc(int a, int b, Calculator calculator)&#123;
        int result = calculator.calc(a,b);
        System.out.println(&quot;结果是：&quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h3 id="练习一：Pedicate接口使用"><a href="#练习一：Pedicate接口使用" class="headerlink" title="练习一：Pedicate接口使用"></a>练习一：Pedicate接口使用</h3><p>请在测试类main方法中完成以下需求</p>
<p>已知有Integer[] arr &#x3D; {-12345, 9999, 520, 0,-38,-7758520,941213}</p>
<p>a)     使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数(大于等于0)</p>
<p>b)    使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100</p>
<p>c)     使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数</p>
<p>遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求</p>
<p>​             i.       打印自然数的个数</p>
<p>​            ii.       打印负整数的个数</p>
<p>​           iii.       打印绝对值大于100的偶数的个数</p>
<p>​           iv.       打印是负整数或偶数的数的个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
        Integer[] arr = &#123;-12345, 9999, 520, 0,-38,-7758520,941213&#125;;

        //a)   使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数
        Predicate&lt;Integer&gt; p1 = (s) -&gt; s&gt;=0;
        //b)   使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100
        Predicate&lt;Integer&gt; p2 = (s) -&gt; Math.abs(s)&gt;100;
        //c)   使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数
        Predicate&lt;Integer&gt; p3 = (s) -&gt; s%2==0;

        //e)   遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        int count4 = 0;
        for (Integer i : arr) &#123;
            //统计自然数个数
            if (p1.test(i))&#123;
                count1++;
            &#125;
            //统计负整数个数
            if (p1.negate().test(i))&#123;
                count2++;
            &#125;
            //统计绝对值大于100的偶数个数
            if (p2.and(p3).test(i))&#123;
                count3++;
            &#125;
            //统计是负整数或偶数的数的个数
            if (p1.negate().or(p3).test(i))&#123;
                count4++;
            &#125;
        &#125;
        //分别打印结果
        System.out.println(&quot;自然数的个数为：&quot;+count1);
        System.out.println(&quot;负整数的个数为：&quot;+count2);
        System.out.println(&quot;绝对值大于100的偶数的个数为：&quot;+count3);
        System.out.println(&quot;是负整数或偶数的数的个数为：&quot;+count4);
    &#125;
</code></pre>
<h3 id="练习：Function接口使用"><a href="#练习：Function接口使用" class="headerlink" title="练习：Function接口使用"></a>练习：Function接口使用</h3><p><code>[这是一个功能界面，因此可以用Lambda表达式或方法引用的赋值对象]</code></p>
<blockquote>
<p>Interface Function&lt;T,R&gt;<br>T：函数输入的类型<br>R：函数结果的类型</p>
<p>Interface Map&lt;K,V&gt;<br>K：由此地图维护的键的类型<br>V：映射值的类型</p>
</blockquote>
<p>1.使用lambda表达式分别将以下功能封装到Function对象中</p>
<p>a)    求Integer类型ArrayList中所有元素的平均数</p>
<p>b)    将Map &lt; String,Integer &gt; 中value存到ArrayList &lt; Integer &gt;中</p>
<p>2.已知学生成绩如下</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>岑小村</td>
<td>59</td>
</tr>
<tr>
<td>谷天洛</td>
<td>82</td>
</tr>
<tr>
<td>渣渣辉</td>
<td>98</td>
</tr>
<tr>
<td>蓝小月</td>
<td>65</td>
</tr>
<tr>
<td>皮几万</td>
<td>70</td>
</tr>
</tbody></table>
<p>3.以学生姓名为key成绩为value创建集合并存储数据，使用刚刚创建的Function对象求学生的平均成绩</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //1.   使用lambda表达式分别将以下功能封装到Function对象中
        //a)   求Integer类型ArrayList中所有元素的平均数
        Function&lt;ArrayList&lt;Integer&gt;,Integer&gt; f1 = (list)-&gt;&#123;
            Integer sum = 0;
            for (Integer i : list) &#123;
                sum+=i;
            &#125;
            return sum/list.size();
        &#125;;

        //b)   将Map&lt;String,Integer&gt;中value存到ArrayList&lt;Integer&gt;中
        Function&lt;Map&lt;String,Integer&gt;,ArrayList&lt;Integer&gt;&gt; f2 = (map)-&gt;&#123;
            /*ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (String s : map.keySet()) &#123;
                Integer i = map.get(s);
                list.add(i);
            &#125;*/
            Collection&lt;Integer&gt; values = map.values();
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            list.addAll(values);
            return list;
        &#125;;
        //2 将学生姓名和成绩封装到map中
        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;岑小村&quot;, 59);
        map.put(&quot;谷天洛&quot;, 82);
        map.put(&quot;渣渣辉&quot;, 98);
        map.put(&quot;蓝小月&quot;, 65);
        map.put(&quot;皮几万&quot;, 70);

        //利用Function求平均成绩
        Integer avg = f2.andThen(f1).apply(map);
        System.out.println(&quot;学生平均成绩为：&quot;+avg);
    &#125;
</code></pre>
<h3 id="练习：获取流"><a href="#练习：获取流" class="headerlink" title="练习：获取流"></a>练习：获取流</h3><p>简述单列集合、双列集合、数组分别如何获取Stream流对象，并进行演示</p>
<pre><code class="java">1.java.util.Collection接口中加入了default方法 stream()获取流对象，因此其所有实现类均可通过此方式获取流

2.java.util.Map接口想要获取流，先通过KeySet()、values()或entrySet()方法获取键、值或键值对的单列集合，再通过stream()获取流对象

3.数组获取流，使用Stream接口中的静态方法of(T...values)获取流
public static void main(String[] args) &#123;
  List&lt;String&gt; list = new ArrayList&lt;&gt;();
  Stream&lt;String&gt; stream1 = list.stream();
  Set&lt;String&gt; set = new HashSet&lt;&gt;();
  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

  Stream&lt;String&gt; stream2 = set.stream();
  Stream&lt;String&gt; keyStream = map.keySet().stream();
  Stream&lt;String&gt; valueStream = map.values().stream();
  Stream&lt;Map.Entry&lt;String,String&gt;&gt;entryStream = map.entrySet().stream();

  String[] array = &#123;&quot;东邪&quot;, &quot;西毒&quot;, &quot;南帝&quot;, &quot;北丐&quot;, &quot;中神通&quot;&#125;;
  Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<h3 id="练习：过滤-filter-、结果收集-数组"><a href="#练习：过滤-filter-、结果收集-数组" class="headerlink" title="练习：过滤[filter]、结果收集(数组)"></a>练习：过滤[filter]、结果收集(数组)</h3><p>有如下7个元素黄药师，冯蘅，郭靖，黄蓉，郭芙，郭襄，郭破虏，使用Stream将以郭字开头的元素存入新数组</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; stream = Stream.of(&quot;黄药师&quot;, &quot;冯蘅&quot;, &quot;郭靖&quot;, &quot;黄蓉&quot;, &quot;郭芙&quot;, &quot;郭襄&quot;, &quot;郭破虏&quot;);
        String[] guos = stream.filter(s -&gt; s.startsWith(&quot;郭&quot;)).toArray(String[]::new);
     &#125;
&#125;
// filter 返回由与此给定谓词匹配的此流的元素组成的流。
// toArray 返回一个包含此流的元素的数组 结果: 一个包含此流的元素的数组
</code></pre>
<h3 id="练习：n-取用前几个-limit-、跳过前几个-skip"><a href="#练习：n-取用前几个-limit-、跳过前几个-skip" class="headerlink" title="练习：n 取用前几个[limit]、跳过前几个[skip]"></a>练习：n 取用前几个[limit]、跳过前几个[skip]</h3><p>已知ArrayList集合中有如下元素{陈玄风、梅超风、陆乘风、曲灵风、武眠风、冯默风、罗玉风}，使用Stream<br>1,取出前2个元素并在控制台打印输出。<br>2.取出后2个元素并在控制台打印输出。</p>
<pre><code class="java">import java.util.ArrayList;
    public class Test04 &#123;
      public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;陈玄风&quot;);
        list.add(&quot;梅超风&quot;);
        list.add(&quot;陆乘风&quot;);
        list.add(&quot;曲灵风&quot;);
        list.add(&quot;武眠风&quot;);
        list.add(&quot;冯默风&quot;);
        list.add(&quot;罗玉风&quot;);

        list.stream().limit(2).forEach(System.out::println);
        list.stream().skip(list.size() - 2).forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h3 id="练习：n-映射-map-、逐一消费-forEach"><a href="#练习：n-映射-map-、逐一消费-forEach" class="headerlink" title="练习：n 映射[map]、逐一消费[forEach]"></a>练习：n 映射[map]、逐一消费[forEach]</h3><p>有如下整数1，-2，-3，4，-5<br>使用Stream取元素绝对值并打印</p>
<pre><code class="java">import java.util.stream.Stream;
   public class Test &#123;
      public static void main(String[] args) &#123;
          Stream&lt;Integer&gt; stream = Stream.of(1, -2, -3, 4,-5);
        stream.map(Math::abs).forEach(System.out::println);
     &#125;
&#125;
</code></pre>
<h3 id="练习：组合-concat-、结果收集-list"><a href="#练习：组合-concat-、结果收集-list" class="headerlink" title="练习：组合[concat]、结果收集[list]"></a>练习：组合[concat]、结果收集[list]</h3><p>已知数组arr1中有如下元素{郭靖，杨康}，arr2中有如下元素{黄蓉，穆念慈}，使用Stream将二者合并到List集合</p>
<pre><code class="java">import java.util.stream.Stream;
  public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; streamA = Stream.of(&quot;郭靖&quot;, &quot;杨康&quot;);
        Stream&lt;String&gt; streamB = Stream.of(&quot;黄蓉&quot;, &quot;穆念慈&quot;);
        List&lt;String&gt; strList = Stream.concat(streamA, streamB).collect(Collectors.toList());
     &#125;
&#125;
</code></pre>
<h3 id="练习：获取并发流"><a href="#练习：获取并发流" class="headerlink" title="练习：获取并发流"></a>练习：获取并发流</h3><p>请分别写出获取并发流的两种方式。</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
          Stream&lt;String&gt; parallelStream1 = coll.parallelStream();
        Stream&lt;Integer&gt; parallelStream2 = Stream.of(100, 200, 300, 400).parallel();
     &#125;
&#125;
</code></pre>
<h1 id="函数式接口习题"><a href="#函数式接口习题" class="headerlink" title="函数式接口习题"></a>函数式接口习题</h1><h3 id="练习：函数式接口"><a href="#练习：函数式接口" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①.  定义一个函数式接口CurrentTimePrinter,其中抽象方法void printCurrentTime()，使用注解@FunctionalInterface<br>②. 在测试类中定义static void showLongTime(CurrentTimePrinter timePrinter)，该方法的预期行为是使用timePrinter打印系统当前毫秒值<br>③. 测试showLongTime(),通过lambda表达式完成需求</p>
<pre><code class="java">@FunctionalInterface
public interface CurrentTimePrinter
&#123;
    void printCurrenTime();
&#125;

public class Test01 &#123;
    public static void main(String[] args) &#123;
        showLongTime(()-&gt;System.out.println(System.currentTimeMillis()));
    &#125;

    public static void showLongTime(CurrentTimePrinter timePrinter)&#123;
        timePrinter.printCurrentTime();
    &#125;
&#125;
</code></pre>
<h3 id="练习：函数式接口-1"><a href="#练习：函数式接口-1" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①. 定义一个函数式接口IntCalc,其中抽象方法int calc(int a , int b)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void getProduct(int a , int b ,IntCalc calc), 该方法的预期行为是使用calc得到a和b的乘积并打印结果<br>③. 测试getProduct(),通过lambda表达式完成需求</p>
<p>IntCalc接口：</p>
<pre><code class="java">@FunctionalInterface
 public interface IntCalc &#123;
   int calc(int a, int b);
 &#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test02 &#123;
   public static void main(String[] args) &#123;
     getProduct(2,3,(a,b)-&gt;a*b);
   &#125;
   public static void getProduct(int a, int b, IntCalc intCalc)&#123;
     int product = intCalc.calc(a,b);
     System.out.println(product);

   &#125;
&#125;
</code></pre>
<h3 id="练习：静态方法引用"><a href="#练习：静态方法引用" class="headerlink" title="练习：静态方法引用"></a>练习：静态方法引用</h3><p>①. 定义一个函数式接口NumberToString,其中抽象方法String convert(int num)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void decToHex(int num ,NumberToString nts), 该方法的预期行为是使用nts将一个十进制整数转换成十六进制表示的字符串，**<u>tips：已知该行为与Integer类中的toHexString方法一致</u>**<br>③. 测试decToHex (),使用方法引用完成需求</p>
<pre><code class="java">interface NumberToString&#123;
    String convert(int num);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        decToHex(999, Integer::toHexString);
    &#125;

    public static void decToHex(int num ,NumberToString nts)&#123;
        String convert = nts.convert(num);
        System.out.println(convert);
    &#125;

&#125;
</code></pre>
<h1 id="字节流-amp-字符流-amp-Properties集合习题"><a href="#字节流-amp-字符流-amp-Properties集合习题" class="headerlink" title="字节流&amp;字符流&amp;Properties集合习题"></a>字节流&amp;字符流&amp;Properties集合习题</h1><h3 id="练习：字节输出流写出字节数据"><a href="#练习：字节输出流写出字节数据" class="headerlink" title="练习：字节输出流写出字节数据"></a>练习：字节输出流写出字节数据</h3><p>利用字节输出流一次写一个字节的方式，向D盘的a.txt文件输出字符‘a’</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流FileOutputStream对象并指定文件路径。<br>2.调用字节输出流的write(int byte)方法写出数据</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.txt&quot;);
        // 2.调用字节输出流的write(byte[] buf)方法写出数据。
        byte[] buf = &quot;i love java&quot;.getBytes();
        // 2.调用字节输出流的write(int byte)方法写出数据
        fos.write(97);
        // 3.关闭流
        fos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：文件的续写和换行输出"><a href="#练习：文件的续写和换行输出" class="headerlink" title="练习：文件的续写和换行输出"></a>练习：文件的续写和换行输出</h3><p>在D盘下，有一c.txt 文件中内容为：HelloWorld<br>在c.txt文件原内容基础上，添加五句 I love java，而且要实现一句一行操作(注：原文不可覆盖)。利用字节输出流对象往C盘下c.txt文件输出5句：”i love java”</p>
<p><strong>操作步骤</strong>:</p>
<p>1.利用两个参数的构造方法创建字节输出流对象，参数一指定文件路径，参数二指定为true<br>2.调用字节输出流的write()方法写入数据，在每一行后面加上换行符:”\r\n”</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径,并追加方式
        FileOutputStream fos = new FileOutputStream(&quot;c:/c.txt&quot;,true);
        // 2.调用字节输出流的write方法写出数据
        // 2.1 要输出的字符串
        String content = &quot;i love java \r\n&quot;;
        for (int i = 0; i&lt; 5; i++) &#123;
            fos.write(content.getBytes());
        &#125;
        // 3.关闭流
        fos.close();
    &#125;
&#125;
/*
    定义变量接收读取的字节
        int len = -1;
        // 循环从流中读取数据
        while((len = fis.read()) != -1) &#123;
        System.out.print(new String(buffer,0,len));
&#125;

*/
</code></pre>
<h3 id="练习：字节流复制文件"><a href="#练习：字节流复制文件" class="headerlink" title="练习：字节流复制文件"></a>练习：字节流复制文件</h3><h6 id="描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致"><a href="#描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致" class="headerlink" title="描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)"></a>描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)</h6><p>要求：一次读写一个字节的方式</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输入流对象关联文件路径：E盘下的a.png<br>2.创建字节输出流对象关联文件路径：D盘下的a.png<br>3.使用循环不断从字节输入流读取一个字节，每读取一个字节就利用输出流写出一个字节。<br>4.关闭流，释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;e:/a.png&quot;);
        // 创建字节输出流对象并关联文件
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.png&quot;);
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = fis.read()) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            fos.write(len);
        &#125;
        // 关闭流
        fis.close();
        fos.close();
    &#125;
</code></pre>
<h3 id="练习：IO对象Properties结合使用-设置properties文件"><a href="#练习：IO对象Properties结合使用-设置properties文件" class="headerlink" title="练习：IO对象Properties结合使用,设置properties文件"></a>练习：IO对象Properties结合使用,设置properties文件</h3><p>我有一个文本文件score.txt，我知道数据是键值对形式的，但是不知道内容是什么。<br>请写一个程序判断是否有”lisi”这样的键存在，如果有就改变其实为”100”<br>score.txt文件内容如下：<br>zhangsan &#x3D; 90    lisi &#x3D; 80    wangwu &#x3D; 85<br><strong>操作步骤</strong>:<br>1.创建一个空的Properties集合<br>2.读取数据到集合中<br>3.遍历集合，获取到每一个key<br>4.判断当前的key 是否为 “lisi”，如果是就把”lisi”的值设置为100<br>5.把集合中所有的信息，重新存储到文件中</p>
<table>
<thead>
<tr>
<th>void</th>
<th>store(OutputStream out, String comments)<br />此适合使用load(InputStream)方法加载到Properties表中的格式，将此Propeirties表中的属性列表(键和元素对写入输出流)</th>
</tr>
</thead>
</table>
<pre><code class="java">public class Test02_06 &#123;
    public static void main(String[] args) throws IOException &#123;
//1：创建一个空的集合
        Properties prop = new Properties();
//2:读取数据到集合中
        prop.load(new FileInputStream(&quot;score.txt&quot;));
//3:遍历集合，获取到每一个key
        Set&lt;String&gt; keys = prop.stringPropertyNames();
//获取到每一个key
        for (String key : keys) &#123;
//4:判断当前的key 是否为 &quot;lisi&quot;
            if (&quot;lisi&quot;.equals(key)) &#123;
//把&quot;lisi&quot;的值设置为100
                prop.setProperty(key, &quot;100&quot;);
            &#125;
        &#125;
//把集合中所有的信息，重新存储到文件中
        prop.store(new FileOutputStream(&quot;score.txt&quot;), &quot;haha&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="缓冲流-amp-转换流习题"><a href="#缓冲流-amp-转换流习题" class="headerlink" title="缓冲流&amp;转换流习题"></a>缓冲流&amp;转换流习题</h1><h3 id="练习：高效字节输出流写出字节数据"><a href="#练习：高效字节输出流写出字节数据" class="headerlink" title="练习：高效字节输出流写出字节数据"></a>练习：高效字节输出流写出字节数据</h3><h6 id="描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。"><a href="#描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。" class="headerlink" title="描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。"></a>描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。</h6><p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.调用高效字节输出流对象的write方法写出一个字节<br>4.关闭高效流，释放资源。</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\d.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(int byte)方法写出一个字节数据
        bos.write(97);
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字节输出流写出字节数组数据"><a href="#练习：高效字节输出流写出字节数组数据" class="headerlink" title="练习：高效字节输出流写出字节数组数据"></a>练习：高效字节输出流写出字节数组数据</h3><h6 id="描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”"><a href="#描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”" class="headerlink" title="描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”"></a>描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”</h6><p><strong>操作步骤:</strong></p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.定义字符串存放要输出的数据，然后将字符串转换为字节数组。<br>4.调用高效字节输出流对象的write方法将字节数组输出。<br>5.关闭高效流。</p>
<pre><code class="java">public class Test01_02 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\e.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(byte[] buff)方法写出一个字节数据
        bos.write(&quot;i love java&quot;.getBytes());
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效流文件复制"><a href="#练习：高效流文件复制" class="headerlink" title="练习：高效流文件复制"></a>练习：高效流文件复制</h3><h6 id="描述-利用高效字节输入流和高效字节输出流完成文件的复制。"><a href="#描述-利用高效字节输入流和高效字节输出流完成文件的复制。" class="headerlink" title="描述: 利用高效字节输入流和高效字节输出流完成文件的复制。"></a>描述: 利用高效字节输入流和高效字节输出流完成文件的复制。</h6><p>要求：</p>
<p>1.将C盘下的c.png文件复制到D盘下<br>2.一次读写一个字节数组方式复制</p>
<p>操作步骤:</p>
<p>①.创建字节输入流对象并关联文件路径<br>②.利用字节输入流对象创建高效字节输入流对象<br>③.创建字节输出流对象并关联文件路径<br>④.利用字节输出流对象创建高效字节输出流对象<br>⑤.创建字节数组用来存放读取的字节数<br>⑥.利用高效字节输入流循环读取文件数据，每读取一个字节数组，利用高效字节输出流对象将字节数组的内容输出到目标文件中。直到读取到文件末尾。<br>⑦.关闭高效流对象</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件路径
        FileInputStream fis = new FileInputStream(&quot;c:\\c.png&quot;);
        // 利用字节输出流对象创建高效字节输出流对象
        BufferedInputStream bis = new BufferedInputStream(fis);
        // 创建字节输出流对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:\\c.png&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 定义字节数组接收读取的字节
        byte[] buffer = new byte[1024];
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = bis.read(buffer)) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            bos.write(buffer,0,len);
        &#125;
        // 关闭流
        bis.close();
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字符流和集合的综合使用"><a href="#练习：高效字符流和集合的综合使用" class="headerlink" title="练习：高效字符流和集合的综合使用"></a>练习：高效字符流和集合的综合使用</h3><p>描述:</p>
<p>分析以下需求，并用代码实现<br>实现一个验证码小程序，要求如下：<br>① 在项目根目录下新建一个文件：data.txt,键盘录入3个字符串验证码，并存入data.txt中，要求一个验证码占一行；<br>② 键盘录入一个需要被校验的验证码，如果输入的验证码在data.txt中存在：在控制台提示验证成功，如果不存在控制台提示验证失败</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws IOException &#123;
        writeString2File();
        verifyCode();
    &#125;

    private static void writeString2File() throws IOException &#123;
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i &lt; 3; i++) &#123;
            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个字符串验证码&quot;);
            line = sc.nextLine();
            bw.write(line);
            bw.newLine();
        &#125;
        bw.close();
    &#125;

    private static void verifyCode() throws IOException &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        BufferedReader br = new BufferedReader(new FileReader(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        while(null!=(line = br.readLine()))&#123;
        list.add(line);
    &#125;
        br.close();
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个验证码&quot;);
        String code = sc.nextLine();
        if (list.contains(code))&#123;
            System.out.println(&quot;验证成功&quot;);
        &#125;else &#123;
            System.out.println(&quot;验证失败&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输出流的使用"><a href="#练习：转换输出流的使用" class="headerlink" title="练习：转换输出流的使用"></a>练习：转换输出流的使用</h3><h6 id="描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。"><a href="#描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。" class="headerlink" title="描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。"></a>描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。</h6><p>要求：使用gbk编码保存。<br>注意：idea的默认编码是utf-8,所以可以通过fileàsettingsàfile encodings设置为gbk格式，否则打开a.txt文件看到的将会是乱码。</p>
<p>操作步骤:</p>
<p>1.创建文件字节输出流关联目标文件<br>2.根据文件字节输出流创建转换输出流对象，并指定编码字符集为：gbk<br>3.调用流对象的方法将字符串写出到文件中。<br>4.关闭流并释放资源。</p>
<pre><code class="java">public class Test01_05 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 要保存的字符串
        String content = &quot;我爱Java&quot;;
        // 创建字节输出流对象
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        // 创建转换输出流对象
        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;gbk&quot;);
        // 调用方法写出数据
        osw.write(content);
        // 关闭流释放资源
        osw.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输入流的使用"><a href="#练习：转换输入流的使用" class="headerlink" title="练习：转换输入流的使用"></a>练习：转换输入流的使用</h3><h6 id="描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。"><a href="#描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。" class="headerlink" title="描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。"></a>描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。</h6><p>要求：不能出现乱码的情况。<br>操作步骤:</p>
<p>1.创建字节输入流对象指定文件路径。<br>2.根据字节输入流对象创建转换输入流对象并指定字符集编码为：gbk<br>3.调用转换输入流对象的读取方法读取内容<br>4.关闭流释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        // 创建转换输入流对象
        InputStreamReader isr = new InputStreamReader(fis,&quot;gbk&quot;);
        // 定义字符数组存放读取的内容
        char[] buffer = newchar[1024];
        // 定义变量接收读取的字符个数
        intlen = -1;
        while((len = isr.read(buffer)) != -1) &#123;
            System.out.print(new String(buffer,0,len));
        &#125;
        // 关闭流
        isr.close();
    &#125;
&#125;
</code></pre>
<h1 id="继承-amp-抽象类习题"><a href="#继承-amp-抽象类习题" class="headerlink" title="继承&amp;抽象类习题"></a>继承&amp;抽象类习题</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h5 id="什么叫做类与类的继承，作用是什么？"><a href="#什么叫做类与类的继承，作用是什么？" class="headerlink" title="什么叫做类与类的继承，作用是什么？"></a><span style =  "color :red">什么叫做类与类的继承，作用是什么？</span></h5><p>就是子类继承父类的属性和行为，使得子类对象具有与父亲相同的属性、相同的行为；<br>作用是子类复用父类的内容</p>
<h5 id="继承后，父类与子类之间，各成员有什么样的影响？"><a href="#继承后，父类与子类之间，各成员有什么样的影响？" class="headerlink" title="继承后，父类与子类之间，各成员有什么样的影响？"></a><span style =  "color :red">继承后，父类与子类之间，各成员有什么样的影响？</span></h5><p>成员变量：<br><u>不重名</u>，就没有影响；<u>重名</u>，就近使用，使用super分区父类变量</p>
<p>构造方法：<br><u>无影响</u>，但是子类构造方法默认调用父类构造方法</p>
<p>成员方法：<br>不重名，没有影响；重名，子类重写父类方法</p>
<h5 id="子类中，如何调用父类的成员？如何使用本类的成员？"><a href="#子类中，如何调用父类的成员？如何使用本类的成员？" class="headerlink" title="子类中，如何调用父类的成员？如何使用本类的成员？"></a><span style =  "color :red">子类中，如何调用父类的成员？如何使用本类的成员？</span></h5><p>父类成员方法：super.方法名<br>父类非私有成员变量：super.变量名<br>子类成员方法：this.方法名<br>子类成员变量：this.变量名</p>
<h5 id="抽象方法与普通成员方法有什么区别？"><a href="#抽象方法与普通成员方法有什么区别？" class="headerlink" title="抽象方法与普通成员方法有什么区别？"></a><span style =  "color :red">抽象方法与普通成员方法有什么区别？</span></h5><p>抽象方法使用abstract关键字修饰，没有方法体；成员方法有方法体</p>
<h5 id="抽象类与普通类有什么区别？"><a href="#抽象类与普通类有什么区别？" class="headerlink" title="抽象类与普通类有什么区别？"></a><span style =  "color :red">抽象类与普通类有什么区别？</span></h5><p>方法：<br>抽象类可以包含抽象方法和成员方法；普通类不可以包含抽象方法，只有成员方法</p>
<p>对象：<br>抽象类不可以创建对象；普通类可以创建对象</p>
<h3 id="练习：语法练习"><a href="#练习：语法练习" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承，抽象类</p>
</li>
<li><p>输出<code>A类中numa：10、B类中numb：20、C类中numc：30</code></p>
</li>
</ul>
<pre><code class="java">abstract  class A&#123;
    int numa = 10;
    public abstract void showA();
&#125;

abstract class B extends A&#123;
    int numb = 20;
    public abstract void showB();
&#125;

class C extends B&#123;
    int numc = 30;

    @Override
    public void showA() &#123;
        System.out.println(&quot;A类中numa:&quot;+numa);
    &#125;

    @Override
    public void showB() &#123;
        System.out.println(&quot;B类中numb:&quot;+numb);

    &#125;
    public void showC()&#123;
        System.out.println(&quot;C类中numc:&quot;+numc);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        C c = new C();
        c.showA();
        c.showB();
        c.showC();
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-1"><a href="#练习：语法练习-1" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li>语法点：继承，抽象类</li>
<li>输出<code>动物种类:鸭子，年龄：2岁、 入院原因：感冒、 症状为：发烧</code></li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟农学院动物医疗系统信息。</li>
<li>定义抽象家禽类(Poultry)<ol>
<li>私有成员变量：动物种类(name)，症状(symptom)，年龄(age)， 病因（illness）</li>
<li>提供空参和带参构造方法</li>
<li>成员方法：<ol>
<li>抽象方法症状(showSymptom)</li>
<li>普通方法基本信息(showMsg)</li>
<li>提供setXxx和getXxx方法</li>
</ol>
</li>
</ol>
</li>
<li>定义普通鸭子类(Duck)<ol>
<li>提供空参和带参构造方法</li>
<li>重写showSymptom方法，打印症状信息。</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test3 &#123;
    public static void main(String[] args) &#123;
        Duck duck = new Duck(&quot;鸭子&quot;, &quot;感冒&quot;, &quot;发烧&quot;, 2);
        duck.showMsg();
        duck.showSymptom();
    &#125;
&#125;

/*
1.定义抽象家禽类(Poultry)
*/
abstract class Poultry &#123;
    //    i.成员变量(私有):

    private String name;
    private String illness;

    // 症状(symptom)
    private String symptom;
    //    年龄(age)
    private int age;

    //    ii.成员方法:  showSymptom
    public abstract void showSymptom();

    // 成员方法:  showMsg
    public void showMsg() &#123;
        System.out.print(&quot;动物种类:&quot; + name);
        System.out.println(&quot;,年龄:&quot; + age + &quot;岁&quot;);
        System.out.println(&quot;入院原因:&quot; + illness);
    &#125;

    //    iii.提供空参和带参构造方法
    public Poultry() &#123;
        super();
    &#125;

    public Poultry(String name, String illness, String symptom, int age) &#123;
        this.name = name;
        this.illness = illness;
        this.symptom = symptom;
        this.age = age;
    &#125;

    //    iv.提供setXxx和getXxx方法
    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIllness() &#123;
        return illness;
    &#125;

    public void setIllness(String illness) &#123;
        this.illness = illness;
    &#125;

    public String getSymptom() &#123;
        return symptom;
    &#125;

    public void setSymptom(String symptom) &#123;
        this.symptom = symptom;
    &#125;
&#125;

// Duck 类

class Duck extends Poultry &#123;

    public Duck() &#123;

    &#125;

    public Duck(String name, String illness, String symptom, int age) &#123;

        super(name, illness, symptom, age);

    &#125;

    @Override

    public void showSymptom() &#123;

        System.out.println(&quot;症状为:&quot; + getSymptom());

    &#125;

&#125;
</code></pre>
<h3 id="练习：语法练习-2"><a href="#练习：语法练习-2" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>输出：<code>王小平老师，讲授Java课、 李小乐同学，考试得了90分</code></p>
</li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟教学管理系统师生信息。</li>
<li>定义Person类。<ol>
<li>属性：姓名、年龄</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，显示基本信息showMsg方法</li>
</ol>
</li>
<li>定义Teacher类，继承Person<ol>
<li>属性：学科</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，讲课方法</li>
</ol>
</li>
<li>定义Student类，继承Person<ol>
<li>属性：分数</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，考试方法</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test &#123;

    public static void main(String[] args) &#123;
        //        i.创建老师对象t,并把名称赋值为”王小平”,年龄赋值为30,工资赋值为8000
        Teacher t = new Teacher(&quot;王小平&quot;, 30, &quot;Java&quot;);
        //        iii.调用老师对象t的讲解方法
        t.teach();

        //        iv.创建学生对象 s,并把名称赋值为”李小乐”,年龄赋值为14,成绩赋值为90分.
        Student s = new Student(&quot;李小乐&quot;, 14, 90);
        //        vi.调用学生对象 s 的考试方法
        s.exam();
    &#125;
&#125;

class Person &#123;
    // 名称(name)
    private String name;
    //    年龄(age)
    private int age;

    //    空参构造
    public Person() &#123;
    &#125;
    //  带参构造
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    // setXxx和getXxx方法
    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
/*
 2.定义老师类(Teacher),继承Person类
 */
class Teacher extends Person &#123;
    //    course(科目)
    private String course;
    //    空参构造
    public Teacher() &#123;
    &#125;
    //    带参构造方法
    public Teacher(String name,int age, String course) &#123;
        super(name,age);
        this.course = course;
    &#125;

    //    提供setXxx和getXxx方法
    public String getCourse() &#123;
        return course;
    &#125;
    public void setCourse(String course) &#123;
        this.course = course;
    &#125;

    public void teach() &#123;
        System.out.println(getName() +&quot;老师,讲授&quot;+course +&quot;课&quot;);
    &#125;
&#125;
/*
 3.定义学生类(Student),继承Person类
 */
class Student extends Person &#123;
    //    score(成绩)
    private int score;
    //    无参构造
    public Student() &#123;
        super();
    &#125;
    //    带参构造
    public Student(String name, int age,int score) &#123;
        super(name, age);
        this.score = score;
    &#125;

    //    提供setXxx和getXxx方法
    public int getScore() &#123;
        return score;
    &#125;
    public void setScore(int score) &#123;
        this.score = score;
    &#125;

    public void exam()&#123;
        System.out.println(getName()+&quot;同学,考试得了:&quot;+ score +&quot;分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-3"><a href="#练习：语法练习-3" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>编写步骤</p>
<ol>
<li>模拟汽车网站信息。</li>
<li>定义汽车Auto类<ol>
<li>属性：品牌，车长，价格</li>
</ol>
</li>
<li>定义SUV继承Auto类<ol>
<li>属性：小型车车长标准值：4295，中型车车长标准值：5070。</li>
<li>定义判断车型方法<ol>
<li>判断小型车：小于小型车车长标准值</li>
<li>判断大型车：大于中型车车长标准值</li>
<li>判断中型车：大于小型车车长标准值并且小于等于中型车车长标准值</li>
</ol>
</li>
</ol>
</li>
<li>测试类中，创建若干SUV对象，保存到集合，遍历集合，输出中型SUV。</li>
</ol>
</li>
</ul>
<pre><code class="java">public class Test5 &#123;
    public static void main(String[] args) &#123;
        // 创建SUV对象
        SUV suv1 = new SUV(5079, 750000);
        SUV suv2 = new SUV(4813, 760000);
        SUV suv3 = new SUV(4270, 127800);
        SUV suv4 = new SUV(4545, 188800);

        //添加到集合中
        ArrayList&lt;SUV&gt; list = new ArrayList&lt;&gt;();
        list.add(suv1);
        list.add(suv2);
        list.add(suv3);
        list.add(suv4);

        // 遍历集合,查询中型SUV
        for (int i = 0; i &lt; list.size(); i++) &#123;
            SUV suv = list.get(i);
            if (suv.midSUV())&#123;
                suv.showMsg();
            &#125;
        &#125;
    &#125;
&#125;
// 定义汽车类
class Auto &#123;
    private String type;
    private double length;
    private double price;

    public Auto() &#123;
    &#125;

    public Auto(String type, double length, double price) &#123;
        this.type = type;
        this.length = length;
        this.price = price;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    public double getLength() &#123;
        return length;
    &#125;

    public void setLength(double length) &#123;
        this.length = length;
    &#125;

    public double getPrice() &#123;
        return price;
    &#125;

    public void setPrice(double price) &#123;
        this.price = price;
    &#125;

    public void showMsg() &#123;
        System.out.println(&quot;车型:&quot; + type);
        System.out.println(&quot;\t价格:&quot; + price);
        System.out.println(&quot;\t车长:&quot; + length);

    &#125;

&#125;

// 定义SUV类
class SUV extends Auto &#123;
    // 车长标准
    private int miniLength = 4295;
    private int midLength = 5070;

    public SUV(double length, double price) &#123;
        super(&quot;SUV&quot;, length, price);
    &#125;
    // 判断 小型车
    public boolean miniSUV() &#123;
        return getLength() &lt;= miniLength;
    &#125;

    // 判断 大型车
    public boolean largeSUV() &#123;
        return getLength() &gt; midLength;
    &#125;

    // 判断 中型车
    public boolean midSUV() &#123;
        return getLength() &gt; miniLength &amp;&amp; getLength() &lt;= midLength;
    &#125;
&#125;
</code></pre>
<h1 id="接口-amp-多态"><a href="#接口-amp-多态" class="headerlink" title="接口&amp;多态"></a>接口&amp;多态</h1><h3 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h3><h5 id="什么是接口，如何定义接口？"><a href="#什么是接口，如何定义接口？" class="headerlink" title="什么是接口，如何定义接口？"></a><span style = "color :red">什么是接口，如何定义接口？</span></h5><ul>
<li>接口，是java语言中一种类型，是方法的集合</li>
<li>使用interface关键字定义接口，其中可以定义抽象方法，默认方法，私有方法，静态方法等方法</li>
</ul>
<h5 id="什么叫做多态，条件是什么？"><a href="#什么叫做多态，条件是什么？" class="headerlink" title="什么叫做多态，条件是什么？"></a><span style = "color :red">什么叫做多态，条件是什么？</span></h5><p>一类事物的行为，具有多种表现形式<br>条件：</p>
<ul>
<li>继承或实现[二选一]</li>
<li>方法的重新</li>
<li>父类引用指向子类对象</li>
</ul>
<h5 id="使用多态特性，带来了什么样的好处？"><a href="#使用多态特性，带来了什么样的好处？" class="headerlink" title="使用多态特性，带来了什么样的好处？"></a><span style = "color :red">使用多态特性，带来了什么样的好处？</span></h5><p>增强方法的扩展性和复用性</p>
<h5 id="使用多态特性，注意什么样的弊端？"><a href="#使用多态特性，注意什么样的弊端？" class="headerlink" title="使用多态特性，注意什么样的弊端？"></a><span style = "color :red">使用多态特性，注意什么样的弊端？</span></h5><p>由于类型的提升，导致调用子类对象特有的方法，必须向下转型。</p>
<h3 id="练习：接口"><a href="#练习：接口" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAAA\n  BBBB</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义默认方法showB。</li>
<li>B类中，重写showA方法</li>
<li>测试类中，创建B类对象，调用showA方法，showB方法。</li>
</ol>
<pre><code class="java">interface A&#123;
    public abstract void showA(); //抽象方法
    public default void showB()&#123; //默认方法
        System.out.println(&quot;BBB&quot;);
    &#125;
&#125;

class B implements A&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        B b = new B();
        b.showA();
        b.showB();

    &#125;
&#125;
</code></pre>
<h3 id="练习：接口-1"><a href="#练习：接口-1" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAA\n  BBBB BBBB BBBB BBBB\n CCCC CCCC CCCC CCCC</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义默认方法showB10，showC10，分别调用show10方法，传入参数。</li>
<li>测试类中，创建B对象，调用showA方法，showB10方法，showC10方法</li>
</ol>
<pre><code class="java">interface AA&#123;
    public abstract void showA();
    private void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.print(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
    public default void show10B()&#123;
        show10(&quot;BBBB&quot;);
    &#125;
    public default void show10C()&#123;
        show10(&quot;CCCC&quot;);
    &#125;
&#125;
class BB implements AA&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        BB b = new BB();
        b.showA();
        b.show10B();
        b.show10C();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，静态"><a href="#练习：接口，静态" class="headerlink" title="练习：接口，静态"></a>练习：接口，静态</h3><ul>
<li>编写步骤</li>
</ul>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有静态方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义静态方法showB()，showC()，分别调用show10方法，传入参数。</li>
<li>B类中，定义静态方法showD</li>
<li>测试类中，使用A接口，调用静态showB()方法，showC()方法，</li>
<li>测试类中，使用B类，调用showA方法，showD方法。</li>
</ol>
<pre><code class="java">interface AAA&#123;
    public abstract void showA();

    public static void showB() &#123;
        System.out.println(&quot;static BBBB&quot;);
        show10(&quot;BBBB&quot;);
    &#125;
    public static void showC()&#123;
        System.out.println(&quot;static CCCC&quot;);
        show10(&quot;CCCC&quot;);
    &#125;
    private static void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
&#125;

class BBB implements AAA&#123;

    @Override
    public void showA() &#123;
        System.out.println(&quot;AAA&quot;);
    &#125;
    public void showD()&#123;
        System.out.println(&quot;DDDD&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        AAA.showB();
        AAA.showC();
        BBB bbb = new BBB();
        bbb.showA();
        bbb.showD();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，多态"><a href="#练习：接口，多态" class="headerlink" title="练习：接口，多态"></a>练习：接口，多态</h3><p>输出：<code>star:星星一闪一闪亮晶晶\n    =======\n     sun:太阳引着9大行星旋转\n    sun：光照八分钟，到达地球</code></p>
<p>编写步骤</p>
<ol>
<li>定义接口Universe，提供抽象方法doAnything。</li>
<li>定义普通类Star，提供成员发光shine方法</li>
<li>定义普通类Sun，继承Star类，实现Universe接口</li>
<li>测试类中，创建Star对象，调用shine方法</li>
<li>测试类中，多态的方式创建Sun对象，调用doAnything方法，向下转型，调用shine方法。</li>
</ol>
<pre><code class="java">interface Universe&#123;
    public abstract void doAnything();
&#125;
class Star&#123;
    public void shine()&#123;
        System.out.println(&quot;star:星星一闪一闪亮晶晶&quot;);
    &#125;
&#125;
class Sun extends Star implements  Universe&#123;
    @Override
    public void doAnything() &#123;
        System.out.println(&quot;sun:太阳吸引着9大行星旋转&quot;);
    &#125;
    @Override
    public void shine() &#123;
        System.out.println(&quot;sun:光照八分钟,到达地球&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Star s = new Star();
        s.shine();
        System.out.println(&quot;====================&quot;);
        Universe universe = new Sun();
        universe.doAnything();
        Sun sun = (Sun)universe;
        sun.shine();
    &#125;
&#125;
</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="练习：需求实现-1"><a href="#练习：需求实现-1" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>定义HandleAble接口，具备一个处理字符串数字的抽象方法方法HandleString（String num）。</p>
<ul>
<li>处理方式1：取整数部分。</li>
<li>处理方式2：保留指定位小数，四舍五入。</li>
</ul>
</li>
<li><p>开发提示：</p>
<ul>
<li>匿名内部类[<span style = "color : grey"><u>接口不能带方法体可以匿名内部类</u></span>]的方式，调用所有抽象方法</li>
</ul>
</li>
</ul>
<pre><code class="java">interface HandleAble&#123;
    String handleString(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        String str = &quot;23.23456789&quot;;
        System.out.println(&quot;原字符串是：&quot; + str);
        HandleAble s1 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;
                return str.substring(0,str.indexOf(&quot;.&quot;));
            &#125;
        &#125;;
        System.out.println(&quot;取整后：&quot; + s1.handleString(str));

        int num = 4;

        HandleAble s2 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;

                int i = str.indexOf(&quot;.&quot;) + num + 1;
                char c = str.charAt(i);
                //System.out.println(c);

                if (c &lt;= &#39;4&#39;) &#123;
                    return str.substring(0, i).toString();
                &#125; else &#123;
                    char c1 = (char) (str.charAt(str.indexOf(&quot;.&quot;) + num) + 1);
                    return str.substring(0, i - 1) + c1;

                &#125;
            &#125;
        &#125;;
        String sss = s2.handleString(str);
        System.out.println(&quot;保留&quot; + num + &quot;位小数后:&quot; + sss);
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-2"><a href="#练习：需求实现-2" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟上课出勤情况。</li>
</ul>
<ul>
<li><p>定义学生类：</p>
<ul>
<li>属性：姓名，出勤。</li>
<li>提供基本的构造方法和get方法，set方法。</li>
</ul>
</li>
<li><p>定义讲师类：</p>
<ul>
<li>属性：姓名。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤。</li>
</ul>
</li>
<li><p>定义课程类：</p>
<ul>
<li>属性：课程名称，讲师，学生集合。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：show方法，打印课程信息，老师姓名，学生是否上课情况。</li>
</ul>
</li>
</ul>
<blockquote>
<p>课程名称：Java<br>授课老师：张老师<br>上课：小红<br>上课：小亮<br>旷课：小明</p>
</blockquote>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Student s = new Student(&quot;小红&quot;);
        Student s1 = new Student(&quot;小亮&quot;);
        Student s2 = new Student(&quot;小明&quot;);
        ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;();
        arr.add(s);
        arr.add(s1);
        arr.add(s2);
        Teacher t = new Teacher(&quot;张老师&quot;);
        Course course = new Course(&quot;java&quot;,t,arr);
        t.dianming(arr);
        course.show();

    &#125;
&#125;

class Student&#123;
    private String name;
    private boolean come;

    public Student() &#123;
    &#125;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public boolean isCome() &#123;
        return come;
    &#125;

    public void setCome(boolean come) &#123;
        this.come = come;
    &#125;
&#125;
class Teacher&#123;
    private String name;
    // 点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤
    public void dianming(ArrayList&lt;Student&gt; arr)&#123;
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            if (!student.getName().equals(&quot;小明&quot;))&#123;
                student.setCome(true);
            &#125;
        &#125;
    &#125;
    public Teacher() &#123;
    &#125;

    public Teacher(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
class Course&#123;
    private String name;
    private Teacher t;
    private ArrayList&lt;Student&gt; arr;

    public Course() &#123;
    &#125;

    public Course(String name, Teacher t, ArrayList&lt;Student&gt; arr) &#123;
        this.name = name;
        this.t = t;
        this.arr = arr;
    &#125;
    public void show()&#123;
        System.out.println(&quot;课程名称:&quot; + name);
        System.out.println(&quot;授课老师:&quot; + t.getName());
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            String name = student.getName();
            if (student.isCome()) &#123;
                System.out.println(&quot;上课: &quot; + name);
            &#125; else &#123;
                System.out.println(&quot;旷课: &quot; + name);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-3"><a href="#练习：需求实现-3" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟接待员接待用户，根据用户id，给用户分组。</li>
</ul>
<ul>
<li>定义接口Filter：<ul>
<li>提供抽象方法filterUser（User u）</li>
</ul>
</li>
<li>定义用户类：<ul>
<li>属性：用户类型，用户id</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li>定义接待员类：<ul>
<li>属性：接口Filter</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：接待用户方法，设置用户类型。</li>
</ul>
</li>
<li>测试类：<ul>
<li>初始化50个User对象，id为1-50。</li>
<li>创建三个接待员对象。<ul>
<li>第一个接待员，设置接待规则，将10-19号用户类型设置为v1。</li>
<li>第二个接待员，设置接待规则，将20-29号用户类型设置为v2。</li>
</ul>
</li>
<li>遍历用户集合，给用户分区。</li>
</ul>
</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        ArrayList&lt;User&gt; ulist = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt;= 50; i++) &#123;
            ulist.add(new User(i));
        &#125;

        System.out.println(&quot;未分组:&quot;);
        System.out.println(ulist);

        Reception r1 = new Reception();
        Reception r2 = new Reception();
        Reception r3 = new Reception();
        r1.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 10 &amp;&amp; u.getId() &lt; 20)
                    u.setType(&quot;v1&quot;);
            &#125;
        &#125;);

        r2.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 20 &amp;&amp; u.getId() &lt; 30)
                    u.setType(&quot;v2&quot;);
            &#125;
        &#125;);

        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            r1.recept(user);
            r2.recept(user);
            r3.recept(user);
        &#125;
        System.out.println(&quot;已分组:&quot;);
        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            if (i % 9 == 0) &#123;
                System.out.println();
            &#125;
            System.out.print(user + &quot; &quot;);
        &#125;

    &#125;
&#125;

class Reception &#123;

    Filter f;

    public Filter getF() &#123;
        return f;
    &#125;

    public void setF(Filter f) &#123;
        this.f = f;
    &#125;

    public void recept(User u) &#123;
        if (u.getType() != null)
            return;
        if (f != null) &#123;
            f.filterUser(u);
            return;
        &#125; else &#123;
            u.setType(&quot;A&quot;);
        &#125;
    &#125;
&#125;

class User &#123;

    private String type;

    private int id;

    public User(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    @Override
    public String toString() &#123;
        return id + &quot;-&quot; + type;
    &#125;
&#125;

interface Filter &#123;
    public abstract void filterUser(User u);
&#125;
</code></pre>
<h3 id="练习：需求实现-4"><a href="#练习：需求实现-4" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>模拟工人挑苹果。</p>
</li>
<li><p>定义苹果类：</p>
<ul>
<li>属性：大小，颜色。</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li><p>定义接口CompareAble：</p>
<ul>
<li>定义默认方法compare，挑选较大苹果。</li>
</ul>
</li>
<li><p>定义接口实现类Compare。</p>
</li>
<li><p>定义工人类：</p>
<ul>
<li>成员方法：挑选苹果Apple pickApple（CompareAble，Apple a1，Apple a2）。</li>
</ul>
</li>
<li><p>测试类：</p>
<ul>
<li>创建Worker对象。</li>
<li>创建两个Apple对象，一个Apple（5，”青色”）,一个Apple（3，”红色”）</li>
<li>默认挑选大的苹果，打印苹果信息。</li>
<li>指定颜色挑选，通过匿名内部类实现。</li>
</ul>
</li>
<li><p>代码实现，效果所示：</p>
</li>
</ul>
<blockquote>
<p>默认挑大的：<br>5.0 - 青色<br>挑红的：<br>3.0 - 红色</p>
</blockquote>
<pre><code class="java">interface CompareAble&#123;
    default Apple compare(Apple a1, Apple a2)&#123;
        return a1.getSize() &gt; a2.getSize() ? a1 : a2;
    &#125;
&#125;

class Apple&#123;
    private double size;
    private String color;

    public Apple() &#123;
    &#125;

    public Apple(double size, String color) &#123;
        this.size = size;
        this.color = color;
    &#125;

    public double getSize() &#123;
        return size;
    &#125;

    public void setSize(double size) &#123;
        this.size = size;
    &#125;

    public String getColor() &#123;
        return color;
    &#125;

    public void setColor(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Apple&#123;&quot; +
                &quot;size=&quot; + size +
                &quot;, color=&#39;&quot; + color + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;

class Worker&#123;
    public Apple pickApple(CompareAble c, Apple a1, Apple a2)&#123;
        Apple compare = c.compare(a1,a2);
        return compare;
    &#125;


public class Test &#123;
    public static void main(String[] args) &#123;
        Worker worker = new Worker();
        Apple apple1 = new Apple(5, &quot;青色&quot;);
        Apple apple2 = new Apple(3, &quot;红色&quot;);
        System.out.println(&quot;默认挑大的:&quot;);
        Apple apple = worker.pickApple(new Com(), apple1, apple2);
        System.out.println(apple);

        System.out.println(&quot;挑红的:&quot;);
        Apple apple3 = worker.pickApple(new Com()&#123;
            @Override
            public Apple compare(Apple a1, Apple a2) &#123;
                return &quot;红色&quot;.equals(a1.getColor()) ? a1 : a2;
            &#125;
        &#125;,apple1,apple2);
        System.out.println(apple3);
    &#125;
    &#125;
&#125;

class Com implements CompareAble &#123;

&#125;
</code></pre>
<h1 id="数组习题"><a href="#数组习题" class="headerlink" title="数组习题"></a>数组习题</h1><h3 id="练习：需求实现-5"><a href="#练习：需求实现-5" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"><a href="#模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。" class="headerlink" title="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"></a>模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。</h6><p>输出：<code>黑桃A 黑桃5 方片J</code></p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        String[] poker = getPoker();
// 抽取指定的三种扑克牌
        int num1 = 1;
        int num2 = 5;
        int num3 = 50;
        String[] pk3 = get3(poker , num1 ,num2,num3);
        // 打印抽取的牌
        for (int i = 0; i &lt; pk3.length; i++) &#123;
            System.out.print(pk3[i] + &quot; &quot;);
        &#125;
    &#125;
    private static String[] get3(String[] poker, int i, int i2, int i3)&#123;
        String[] pk3 = new String[3];
        pk3[0] = poker[i - 1];
        pk3[1] = poker[i2 - 1];
        pk3[2] = poker[i3 - 1];
        return pk3;
    &#125;
    private static String[] getPoker()&#123;
        String[] colors=&#123;&quot;黑色&quot;,&quot;红桃&quot;,&quot;梅花&quot;,&quot;方块&quot;&#125;;
        String[] nums=&#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;;
        String[] poker = new String[54];
        int index = 0;
        for (int i = 0; i &lt; colors.length; i++) &#123;
            for (int j = 0; j &lt; nums.length; j++) &#123;
                poker[index] = colors[i] + nums[j];
                index++;
            &#125;
        &#125;
        poker[52] = &quot;小王&quot;;
        poker[53] = &quot;大王&quot;;

        return poker;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-6"><a href="#练习：需求实现-6" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="定义equals方法，比较数组内容是否完全一致。"><a href="#定义equals方法，比较数组内容是否完全一致。" class="headerlink" title="定义equals方法，比较数组内容是否完全一致。"></a>定义equals方法，比较数组内容是否完全一致。</h6><p>开发提示：</p>
<ul>
<li>长度一致，内容一致，定义为完全一致。</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        int[] arr = &#123;1,2,3,4,3,2,1&#125;;
        int[] arr2 = &#123;1,2,3,4,3,2,1&#125;;
        System.out.println(&quot; 是否一致:&quot; +equals(arr ,arr2));

    &#125;
    //  比较数组的内容
    public static boolean equals(int[] arr1, int[] arr2) &#123;
        // 长度不同,返回false
        if (arr1.length != arr2.length) &#123;
            return false;
        &#125;

        //
        for (int i = 0; i &lt; arr1.length; i++) &#123;
            // arr1[i] 和 arr2[i]比较
            /*
             * 所有元素都相同才相同，也就是只要有一个不同，这两个数组就是不同
             */
            if (arr1[i] != arr2[i]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1 id="异常-amp-线程习题"><a href="#异常-amp-线程习题" class="headerlink" title="异常&amp;线程习题"></a>异常&amp;线程习题</h1><h3 id="练习：异常的体系"><a href="#练习：异常的体系" class="headerlink" title="练习：异常的体系"></a>练习：异常的体系</h3><p>1.请描述异常的继承体系<br>异常继承体系：异常的根类是java.lang.Throwable。其下有两个子类：<code>java.lang.Error</code> 与 <code>java.util.Exception</code>。<br>Exception又分为编译时期异常：checked异常<br>                         与运行时期异常：runtime异常</p>
<p>2.请描述你对错误(Error)的理解<br><strong>Error</strong>：表示不可修复的恶性的错误，只能通过修改菜吗规避错误的产生，通常是系统级别的，所以很严重。</p>
<p>3.描述你对异常(Expection的理解)<br><strong>Exception</strong>：表示可修复的良性(相对于错误)的异常，异常产生后程序员可以并且通过代码的方式修正，使程序继续运行，是必须要处理的。</p>
<p>4.描述你对运行时异常(RuntimeException)的理解<br>运行时期异常：runtime异常。在运行时期，检查异常. 在编译时期，运行异常不会编译器检测(不报错)</p>
<h3 id="练习：throw与throws的区别"><a href="#练习：throw与throws的区别" class="headerlink" title="练习：throw与throws的区别"></a>练习：throw与throws的区别</h3><p>1.请描述throw的使用位置,作用是什么?<br>throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，后面语句都不执行</p>
<p>2.请描述throws的使用位置,作用是什么?<br>throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会<strong>将异常对象抛给方法调用处</strong></p>
<h3 id="练习：异常的处理方式"><a href="#练习：异常的处理方式" class="headerlink" title="练习：异常的处理方式"></a>练习：异常的处理方式</h3><p>1.异常处理方式有几种，分别是什么<br>异常的处理方式有两种，分别是使用 <code>throws</code> 和 <code>try...catch...finally</code></p>
<p>2.详细阐述每种方式对异常是如何处理的<br>throws用在方法的声明上后接异常类名，是把异常抛给调用者进行处助理<br>try…catch…finally是捕获异常，自己处理，处理完毕后面的程序可以继续运行<br>    <strong>try</strong>代码块中是可能出现异常的代码<br>    <strong>catch</strong>代码块，是遇到异常，对异常进行处理的代码<br>    <strong>finally</strong>代码块无论是否发生异常，都必须执行的代码，用于释放资源</p>
<h3 id="练习：常见异常，及产生原因"><a href="#练习：常见异常，及产生原因" class="headerlink" title="练习：常见异常，及产生原因"></a>练习：常见异常，及产生原因</h3><h6 id="请列举常见异常，并说明产生原因"><a href="#请列举常见异常，并说明产生原因" class="headerlink" title="请列举常见异常，并说明产生原因"></a>请列举常见异常，并说明产生原因</h6><p><strong>NullPointerException</strong>：空指针异常<br>当应用试图在要求使用对象的方法使用了null时，抛出该异常；譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度</p>
<p><strong>ArrayIndaexOutOfBoundsException</strong>：数组索引越界异常<br>当对数组的索引值为负数或大于等于数组大小时抛出此异常。</p>
<p><strong>ArithmeticException：</strong>算术运算异常<br>程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了</p>
<p><strong>NumberFormatException：</strong>数字格式异常<br>当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常</p>
<h3 id="练习：并行、并发概念"><a href="#练习：并行、并发概念" class="headerlink" title="练习：并行、并发概念"></a>练习：并行、并发概念</h3><h6 id="请简单描述什么是并行，什么是并发"><a href="#请简单描述什么是并行，什么是并发" class="headerlink" title="请简单描述什么是并行，什么是并发?"></a>请简单描述什么是并行，什么是并发?</h6><p>并行：指两个或多个事件在<strong>同一时刻发生</strong>（同时发生）。<br>并发：指两个或多个事件在<strong>同一个时间段</strong>内发生。</p>
<blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不  支持并行。<br>   你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>   你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
</blockquote>
<p><strong>并发</strong>的关键是你有处理多个任务的能力，不一定要同时。<br><strong>并行</strong>的关键是你有同时处理多个任务的能力。<br>它们最关键的点就是：是否是『同时』</p>
<h3 id="练习：进程概念、线程概念、线程与进程联系"><a href="#练习：进程概念、线程概念、线程与进程联系" class="headerlink" title="练习：进程概念、线程概念、线程与进程联系"></a>练习：进程概念、线程概念、线程与进程联系</h3><h6 id="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"><a href="#请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明" class="headerlink" title="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"></a>请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明</h6><p>进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>线程是进程中的一个执行单元，负责当前进程中程序的执行，<strong>一个进程中至少有一个线程</strong>。<strong>一个进程中是可以有多个线程的</strong>，这个应用程序也可以称之为多线程程序。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程, 但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。</p>
<h3 id="练习：自定义异常类"><a href="#练习：自定义异常类" class="headerlink" title="练习：自定义异常类"></a>练习：自定义异常类</h3><p>请使用代码实现<br>每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数<br>如果老师给学生赋值一个负数,抛出一个自定异常</p>
<pre><code class="java">// 1.定义异常类NoScoreException,继承RuntimeException 提供空参和有参构造方法
public class NoScoreException extends RuntimeException &#123;
    //  空参构造
    public NoScoreException() &#123;
            super();
    &#125;
    // 有参构造
    public NoScoreException(String message) &#123;
            super(message);
     &#125;
/* 2.定义学生类(Student)
   a)属性:name,score
   b)提供空参构造
   c)提供有参构造;
    i.使用setXxx方法给名称和score赋值
   d)提供setter和getter方法
    ii.在setScore(int score)方法中
    1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    2.然后在给成员score赋值.*/
public class Student &#123;
    private String name;
    private int score;
    // 空参构造
    public Student() &#123;
        super();
    &#125;
    // c)提供有参构造;
// i.使用setXxx方法给名称和score赋值
    public Student(String name,int score)&#123;
        setName(name);
        setScore(score);
    &#125;
// d)提供setter和getter方法

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getScore() &#123;
        return score;
    &#125;
    // i.在setScore(int score)方法中
    public void setScore(int score) &#123;
// 1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    if(score &lt;0)&#123;
       throw new NoScoreException(&quot;:分数不能为负数:&quot;+score);
    &#125;
// 2.然后在给成员score赋值.
        this.score = score;
    &#125;
&#125;
    /*
3.定义测试类Test9
 a)提供main方法,在main方法中
  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码
  iii.使用空参构造创建Student对象
  iv.调用setScore(int score)方法,传入一个正数,运行程序
  v.调用setScore(int score)方法,传入一个负数,运行程序
 */
public class Test9 &#123;
    public static void main(String[] args) &#123;
//  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
//  Student s = new Student(&quot;景甜&quot;, -10);
//  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码

//  iii.使用空参构造创建Student对象
        Student s = new Student();
//  iv.调用setScore(int score)方法,传入一个正数,运行程序
        s.setScore(100);
//  v.调用setScore(int score)方法,传入一个负数,运行程序
        s.setScore(-5);
    &#125;
&#125;
</code></pre>
<h1 id="网络通信概述-amp-TCP协议习题"><a href="#网络通信概述-amp-TCP协议习题" class="headerlink" title="网络通信概述&amp;TCP协议习题"></a>网络通信概述&amp;TCP协议习题</h1><h3 id="练习：ip地址和端口号概念"><a href="#练习：ip地址和端口号概念" class="headerlink" title="练习：ip地址和端口号概念"></a>练习：ip地址和端口号概念</h3><p>描述:<br>一、请写出IP地址的概念：<br><strong>IP地址：</strong>互联网协议地址(Internet Protocol Address), 俗称IP.IP地址用来给一个网络中的计算机设备做唯一的编号.</p>
<p>二、请写出端口号的概念：<br><strong>端口号:</strong>   端口号用来给计算机里的应用程序(进程)做唯一的标识,用2个字节表示的整数,取值范围0~65535.</p>
<h3 id="练习：UDP协议"><a href="#练习：UDP协议" class="headerlink" title="练习：UDP协议"></a>练习：UDP协议</h3><h6 id="判断下列说法是否正确：（-X-）"><a href="#判断下列说法是否正确：（-X-）" class="headerlink" title="判断下列说法是否正确：（ X ）"></a>判断下列说法是否正确：（ X ）</h6><p>由于UDP面向无连接的协议,可以保证数据完整性,因此在传输重要数据时采用UDP协议.<br><span style = "color : red"><strong>判断错误, 因为面向无连接,容易丢失包,所以不能保证数据完整.</strong></span></p>
<h3 id="练习：TCP协议"><a href="#练习：TCP协议" class="headerlink" title="练习：TCP协议"></a>练习：TCP协议</h3><h6 id="TCP协议中”三次握手”-第一次握手指的是什么："><a href="#TCP协议中”三次握手”-第一次握手指的是什么：" class="headerlink" title="TCP协议中”三次握手”,第一次握手指的是什么："></a>TCP协议中”三次握手”,第一次握手指的是什么：</h6><p><span style = "color : red">第一次握手:客户端向服务器发送请求,等待服务器确认</span></p>
<h3 id="练习：TCP网络协议"><a href="#练习：TCP网络协议" class="headerlink" title="练习：TCP网络协议"></a>练习：TCP网络协议</h3><h6 id="需求说明：创建新项目，按以下要求编写代码："><a href="#需求说明：创建新项目，按以下要求编写代码：" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 服务器端 端口号为8888<br>1: 等待客户端连接  如果有客户端连接 获取到客户端对象<br>2: 获取到客户端对象之后 当前在服务器读取数据客户端传送数据</p>
<pre><code class="java">public class TCPServer &#123;
   public static void main(String[] args) throws Exception &#123;
      //1创建服务器对象 
      ServerSocket  ss = new ServerSocket(8888);
      //2等待客户端连接   如果有客户端连接  获取到客户端对象 
      Socket socket = ss.accept();
      //3当前在服务器中  要读取数据  需要输入流  流由谁提供 客户端
      InputStream in = socket.getInputStream();//获取输入流
      //4:读数据
      int len;
      byte[] buffer = new byte[1024];
      while((len=in.read(buffer))!=-1)&#123;
          System.out.println(new String(buffer, 0, len));
      &#125;
      //释放资源
      in.close();
//       ss.close();服务器一般不会关闭
   &#125;
&#125;
</code></pre>
<h6 id="需求说明：创建新项目，按以下要求编写代码：-1"><a href="#需求说明：创建新项目，按以下要求编写代码：-1" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 客户端<br>访问之前创建的服务器端,服务器端ip127.0.0.1 端口号8888<br>1: 客户端连接服务器,并发送 hello.服务器,我是客户端.<br>2: 开启上一题服务器,等待客户端连接,客户端连接并发送数据 </p>
<pre><code class="java">public class TCPClient &#123;
  public static void main(String[] args) throws Exception &#123;
      //创建 Socket客户端对象
      Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
      //写数据  需要输出流  谁提供 客户端
      OutputStream out = socket.getOutputStream();
      //写数据
      out.write(&quot;hello.服务器,我是客户端.&quot;.getBytes());
      //释放资源
      out.close();
      socket.close();
  &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/08/22/后端/Java复习款(练习题)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/08/13/后端/java复习款/">
        <h2>
            java复习款
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/13
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Object类、常用API"><a href="#Object类、常用API" class="headerlink" title="Object类、常用API"></a>Object类、常用API</h1><pre><code class="java">public String toString():返回该对象的字符串表示
public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”
    
java.util.Date类表示特定的瞬间，精确到毫秒
    public Date():分配Date对象并初始化此对象，以表示分配它的时间(精确到秒)
    public Date(long date):分配Date对象并初始化此对象，以表示从标准基准时间1970年1月1日以来的指定毫秒数
    public long getTime():把日期对象转换成对应的时间毫秒值
    
java.text.DateFormat类是日期/时间格式化子类的抽象类
    public SimpleDateFormate(String pattern):用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat[&quot;yyyy-MM-dd HH:mm:ss&quot; =&gt; 2018-01-16 15:06:38]
    public String format(Date date):将Date对象格式化为字符串
    public Date parse(String source):将字符串解析为Date对象
</code></pre>
<h6 id="请使用日期时间相关的API，计算出一个人已经出生了多少天。"><a href="#请使用日期时间相关的API，计算出一个人已经出生了多少天。" class="headerlink" title="请使用日期时间相关的API，计算出一个人已经出生了多少天。"></a>请使用日期时间相关的API，计算出一个人已经出生了多少天。</h6><p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void function() throws Exception &#123;
    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);
    // 获取出生日期,键盘输入
    String birthdayString = new Scanner(System.in).next();
    // 将字符串日期,转成Date对象
    // 创建SimpleDateFormat对象,写日期模式
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    // 调用方法parse,字符串转成日期对象
    Date birthdayDate = sdf.parse(birthdayString);    
    // 获取今天的日期对象
    Date todayDate = new Date();    
    // 将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;    
    if (secone &lt; 0)&#123;
        System.out.println(&quot;还没出生呢&quot;);
    &#125; else &#123;
        System.out.println(secone/1000/60/60/24);
    &#125;
&#125;
</code></pre>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><pre><code class="java">java.util.Calendar
    public static Calendar getInstance():使用默认时区和语言环境获得一个日历
    public int get(int field):返回給定日历字段的值
    public void set(int field, int value):将给定的日历字段设置为定值
    public abstract void add(qint field, int amount):根据日历的规则，为給定的日历字段添加或减去指定的时间量
    public Date getTime():返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Da
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    get方法
        Calendar cal = Calendar.getInstance();
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH)+1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;);
    &#125;

    set方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.YEAR, 2020);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                        // 2020年1月17日
    &#125;
    
    add方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;);
                            // 2018年1月17日
        // 使用add方法
        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天
        cal.add(Calendar.YEAR, -3); // 减3年
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                            // 2015年1月18日; 
    &#125;

    getTime方法

      
</code></pre>
<h3 id="CurrentTimeMillis方法"><a href="#CurrentTimeMillis方法" class="headerlink" title="CurrentTimeMillis方法"></a>CurrentTimeMillis方法</h3><h6 id="验证for循环打印数字1-9999所需要使用的时间（毫秒）"><a href="#验证for循环打印数字1-9999所需要使用的时间（毫秒）" class="headerlink" title="验证for循环打印数字1-9999所需要使用的时间（毫秒）"></a>验证for循环打印数字1-9999所需要使用的时间（毫秒）</h6><pre><code class="java">public class SystemTest1 &#123;
    public static void main(String[] args) &#123;
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 10000; i++) &#123;
            System.out.println(i);
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。(数组拷贝)
</code></pre>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。</p>
<pre><code class="java">备注：StringBuilder已经覆盖重写了Object当中的toString方法。
public StringBuilder():构造一个空的StringBuilder容器
public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去
public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身
public String toString():将当前StringBuilder对象转换为String对象
</code></pre>
<pre><code class="java">append方法
public static void main(String[] args) &#123;
        //创建对象
        StringBuilder builder = new StringBuilder();
        //public StringBuilder append(任意类型)
        StringBuilder builder2 = builder.append(&quot;hello&quot;);
        //对比一下
        System.out.println(&quot;builder:&quot;+builder);
        System.out.println(&quot;builder2:&quot;+builder2);
        System.out.println(builder == builder2); //true
        // 可以添加 任何类型
        builder.append(&quot;hello&quot;);
        builder.append(&quot;world&quot;);
        builder.append(true);
        builder.append(100);
        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。
        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下
        //链式编程
        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);
        System.out.println(&quot;builder:&quot;+builder);
    &#125;

toString方法
通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：
public static void main(String[] args) &#123;
        // 链式创建
        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);
        // 调用方法
        String str = sb.toString();
        System.out.println(str); // HelloWorldJava
    &#125;
</code></pre>
<h3 id="基本类型转换位String"><a href="#基本类型转换位String" class="headerlink" title="基本类型转换位String"></a>基本类型转换位String</h3><pre><code class="java">- public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。
- public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。
- public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。
- public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。
- public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。
- public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。
- public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。
</code></pre>
<pre><code class="java">注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。
public class Demo18WrapperParse &#123;
    public static void main(String[] args) &#123;
        int num = Integer.parseInt(&quot;100&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="Collection、泛型"><a href="#Collection、泛型" class="headerlink" title="Collection、泛型"></a>Collection、泛型</h1><p>集合按照其存储结构可以分为两大类，分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合。集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<pre><code class="java">public boolean add(E e):把给定的对象添加到当前集合中
public void clear():清空集合中所有的元素
public boolean remove(E e):把给定的对象在当前集合中删掉
public boolean contains(E e):判断当前集合中是否包含给定的对象
public boolean isEmpty():判断当前集合是否位空
public int size():返回集合中元素的个数
public Object[] to Array():把集合中的元素，存储到数组中
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;一&quot;);
        coll.add(&quot;二&quot;);
        coll.add(&quot;三&quot;);
        System.out.println(coll);                //[一, 二, 三]
        System.out.println(coll.contains(&quot;二&quot;));     //true
        System.out.println(coll.isEmpty());  //false
        System.out.println(coll.size());     //3
        System.out.println(coll.remove(&quot;二&quot;)); // true
        System.out.println(coll);                  //[一，二]
        System.out.println(coll.contains(&quot;二&quot;));  //false

        Object[] objects = coll.toArray(); //0 1
        for (int i = 0; i &lt; objects.length; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
</code></pre>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<pre><code class="java">public E next():返回迭代的下一个元素
public boolean hasNext():如果仍有元素可以迭代，则返回true
</code></pre>
<pre><code class="java">tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。
public static void main(String[] args) &#123;
        // 使用多态方式 创建对象
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        // 添加元素到集合
        coll.add(&quot;串串星人&quot;);
        coll.add(&quot;吐槽星人&quot;);
        coll.add(&quot;汪星人&quot;);
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator&lt;String&gt; it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext())&#123; //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        &#125;
      &#125;
</code></pre>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<pre><code>for(元素的数据类型 变量 ： collection集合or数组)&#123;
  //操作代码
&#125;
</code></pre>
<pre><code class="java">遍历集合
public static void main(String[] args) &#123;        
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;小河神&quot;);
        coll.add(&quot;老河神&quot;);
        coll.add(&quot;神婆&quot;);
        //使用增强for遍历
        for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素
            System.out.println(s);
    &#125;
&#125;
</code></pre>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre><code class="java">修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125;
class ArrayList&lt;E&gt;&#123;
    public boolean add(E e) &#123; &#125;
    public E get(int index) &#123; &#125;
&#125;

在创建对象的时候确定泛型
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
class ArrayList&lt;Integer&gt;&#123;
    public boolean add(Integer e) &#123; &#125;
    public Integer get(int index) &#123; &#125;
&#125;
</code></pre>
<pre><code class="java">举例自定义泛型类
public class MyGenericClass&lt;MVP&gt;&#123;
    //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型
    private MVP mvp;
    public void setMVP(MVP mvp)&#123;
        this.mvp = mvp;
    &#125;
    public MVP getMVP()&#123;
        return mvp;
    &#125;
&#125;

public class GenericClassDemo &#123;
      public static void main(String[] args) &#123;         
         // 创建一个泛型为String的类
         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();        
         // 调用setMVP
         my.setMVP(&quot;大胡子登登&quot;);
         // 调用getMVP
         String mvp = my.getMVP();
         System.out.println(mvp);
         //创建一个泛型为Integer的类
         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); 
         my2.setMVP(123);         
         Integer mvp2 = my2.getMVP();
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><pre><code class="java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;

public class MyGenericMethod &#123;      
    public &lt;MVP&gt; void show(MVP mvp) &#123;
        System.out.println(mvp.getClass());
    &#125;
    
    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;    
        return mvp;
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><h5 id="1、定义类时确定泛型的类型"><a href="#1、定义类时确定泛型的类型" class="headerlink" title="1、定义类时确定泛型的类型"></a><strong>1、定义类时确定泛型的类型</strong></h5><pre><code class="java">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;

public interface MyGenericInterface&lt;E&gt;&#123;
    public abstract void add(E e);
    
    public abstract E getE();  
&#125;

泛型E的值就是String类型
public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;
    @Override
    public void add(String e) &#123;
        // 省略...
    &#125;

    @Override
    public String getE() &#123;
        return null;
    &#125;
&#125;

</code></pre>
<h5 id="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"><a href="#2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型" class="headerlink" title="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"></a><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></h5><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;
    @Override
    public void add(E e) &#123;
            // 省略...
    &#125;

    @Override
    public E getE() &#123;
        return null;
    &#125;
&#125;

/*
 * 使用
 */
public class GenericInterface &#123;
    public static void main(String[] args) &#123;
        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();  
        my.add(&quot;aa&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过**通配符&lt;?&gt;**表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();
    getElement(list1);
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    getElement(list2);
&#125;
public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;
//？代表可以接收任意类型
</code></pre>
<h5 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h5><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();
    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
&#125;
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;
</code></pre>
<pre><code class="java">Java.util.Collections类下有一个静态的shuffle()方法,如下：

1）static void shuffle(List&lt;?&gt; list)  使用默认随机源对列表进行置换，所有置换发生的可能性都是大致相等的。

2）static void shuffle(List&lt;?&gt; list, Random rand) 使用指定的随机源对指定列表进行置换，所有置换发生的可能性都是大致相等的，假定随机源是公平的。
</code></pre>
<h3 id="扑克牌案例分析"><a href="#扑克牌案例分析" class="headerlink" title="扑克牌案例分析"></a>扑克牌案例分析</h3><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<pre><code class="java">import java.util.ArrayList;
import java.util.Collections;

public class Poker &#123;
    public static void main(String[] args) &#123;
        /*
        * 1: 准备牌操作
        */
        //1.1 创建牌盒 将来存储牌面的 
        ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();
        //1.2 创建花色集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();

        //1.3 创建数字集合
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        //1.4 分别给花色 以及 数字集合添加元素
        colors.add(&quot;♥&quot;);
        colors.add(&quot;♦&quot;);
        colors.add(&quot;♠&quot;);
        colors.add(&quot;♣&quot;);

        for(int i = 2;i&lt;=10;i++)&#123;
            numbers.add(i+&quot;&quot;);
        &#125;
        numbers.add(&quot;J&quot;);
        numbers.add(&quot;Q&quot;);
        numbers.add(&quot;K&quot;);
        numbers.add(&quot;A&quot;);
        //1.5 创造牌  拼接牌操作
        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中
        for (String color : colors) &#123;
            //color每一个花色 
            //遍历数字集合
            for(String number : numbers)&#123;
                //结合
                String card = color+number;
                //存储到牌盒中
                pokerBox.add(card);
            &#125;
        &#125;
        //1.6大王小王
        pokerBox.add(&quot;小☺&quot;);
        pokerBox.add(&quot;大☠&quot;);      
        // System.out.println(pokerBox);
        //洗牌 是不是就是将  牌盒中 牌的索引打乱 
        // Collections类  工具类  都是 静态方法
        // shuffer方法   
        /*
         * static void shuffle(List&lt;?&gt; list) 
         *     使用默认随机源对指定列表进行置换。 
         */
        //2:洗牌
        Collections.shuffle(pokerBox);
        //3 发牌
        //3.1 创建 三个 玩家集合  创建一个底牌集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();      

        //遍历 牌盒  必须知道索引   
        for(int i = 0;i&lt;pokerBox.size();i++)&#123;
            //获取 牌面
            String card = pokerBox.get(i);
            //留出三张底牌 存到 底牌集合中
            if(i&gt;=51)&#123;//存到底牌集合中
                dipai.add(card);
            &#125; else &#123;
                //玩家1   %3  ==0
                if(i%3==0)&#123;
                      player1.add(card);
                &#125;else if(i%3==1)&#123;//玩家2
                      player2.add(card);
                &#125;else&#123;//玩家3
                      player3.add(card);
                &#125;
            &#125;
        &#125;
        //看看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;田伯光：&quot;+player2);
        System.out.println(&quot;绿竹翁：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);  
    &#125;
&#125;
</code></pre>
<h1 id="List、Set、数据结构、Collections"><a href="#List、Set、数据结构、Collections" class="headerlink" title="List、Set、数据结构、Collections"></a>List、Set、数据结构、Collections</h1><h6 id="List集合特有的方法都是跟索引相关"><a href="#List集合特有的方法都是跟索引相关" class="headerlink" title="List集合特有的方法都是跟索引相关"></a>List集合特有的方法都是跟索引相关</h6><pre><code class="java">public void add(int index, E element):将指定的元素，添加到集合中的指定位置上
public E get(int index):返回集合中指定位置的元素
public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素
public E set(int index，E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        
        // 往 尾部添加 指定元素
        list.add(&quot;图图&quot;);
        list.add(&quot;小美&quot;);
        list.add(&quot;不高兴&quot;);
        
        System.out.println(list);
        // add(int index,String s) 往指定位置添加
        list.add(1,&quot;没头脑&quot;);
        
        System.out.println(list);
        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素 
        System.out.println(&quot;删除索引位置为2的元素&quot;);
        System.out.println(list.remove(2));
        
        System.out.println(list);
        
        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改） 
        // 修改指定位置元素
        list.set(0, &quot;三毛&quot;);
        System.out.println(list);
        
        // String get(int index)  获取指定位置元素
        
        // 跟size() 方法一起用  来 遍历的 
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        //还可以使用增强for
        for (String string : list) &#123;
            System.out.println(string);
        &#125;      
    &#125;
</code></pre>
<h1 id="List-ArrayList、LinkedList-的子类"><a href="#List-ArrayList、LinkedList-的子类" class="headerlink" title="List(ArrayList、LinkedList)的子类"></a>List(ArrayList、LinkedList)的子类</h1><p><code>java.util.ArrayList</code> 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。<br><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<pre><code class="java">public void addFirst(E e):将指定元素插入此列表的开头
public void addLast(E e):将指定元素添加到此列表的结尾
public E getFirst():返回此列表的第一个元素
public E removeFirst():移除并返回此列表的第一个元素
public E removeLast():移除并返回此列表的最后一个元素
public E pop():从此列表所表示的堆栈处弹出一个元素
public void push(E e):将元素推入此列表所表示的堆栈
public boolean isEmpty():如果列表不包含元素，则返回true
</code></pre>
<h1 id="Set-HashSet、LinkedHashSet"><a href="#Set-HashSet、LinkedHashSet" class="headerlink" title="Set(HashSet、LinkedHashSet)"></a>Set(HashSet、LinkedHashSet)</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<h4 id="Set集合取出元素的方式可以采用：迭代器、增强for"><a href="#Set集合取出元素的方式可以采用：迭代器、增强for" class="headerlink" title="Set集合取出元素的方式可以采用：迭代器、增强for"></a><span style = "color : red"><strong>Set集合取出元素的方式可以采用：迭代器、增强for</strong></span></h4><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<h4 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><pre><code class="java">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;
public static int getSum(int[] arr)&#123;
    int sum = 0;
    for(int a : arr)&#123;
        sum += a;
    &#125;
    return sum;
&#125;
</code></pre>
<h3 id="Collections-高效添加元素"><a href="#Collections-高效添加元素" class="headerlink" title="Collections(高效添加元素)"></a>Collections(高效添加元素)</h3><pre><code class="java">java.utils.Collections是集合工具类
public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素
public static void shuffle(List&lt;?&gt; list):打乱集合顺序
public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序
public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。
</code></pre>
<pre><code class="java"> public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        //原来写法
        //list.add(12);
        //list.add(14);
        //list.add(15);
        //list.add(1000);
        //采用工具类 完成 往集合中添加元素  
        Collections.addAll(list, 5, 222, 1，2);
        System.out.println(list);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<h3 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h3><pre><code class="java">public int compare(String o1, String o2):比较两个参数的顺序
return o1 - o2 (正数)
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
   ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
   Collections.addAll(arr,&quot;cba&quot;,&quot;aba&quot;,&quot;sba&quot;,&quot;nba&quot;);
   Collections.sort(arr, new Comparator&lt;String&gt;() &#123;
     @Override
     public int compare(String o1, String o2) &#123;
         return o1.charAt(0)-o2.charAt(0);
     &#125;
  &#125;);
  System.out.println(arr);
&#125;
</code></pre>
<pre><code class="java">public class Student_test implements Comparable&lt;Student_test&gt; &#123;
    @Override
    public int compareTo(Student_test o) &#123;
        return this.age-o.age;
    &#125;
Getter Setter toString 
--------------------------------------------------------------
public class Comparable_test &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;Student_test&gt; list = new ArrayList&lt;Student_test&gt;();
        list.add(new Student_test(&quot;rose&quot;,18));
        list.add(new Student_test(&quot;jack&quot;,16));
        list.add(new Student_test(&quot;abc&quot;,16));
        list.add(new Student_test(&quot;ace&quot;,17));
        list.add(new Student_test(&quot;mark&quot;,16));
        for(Student_test student : list)&#123;
            System.out.println(student);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        return o2.getAge()-o1.getAge();//以学生的年龄降序
    &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<p>如果想要规则更多一些，可以参考下面代码：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
       // 年龄降序
    int result = o2.getAge()-o1.getAge();//年龄降序

    if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序
     result = o1.getName().charAt(0)-o2.getName().charAt(0);
    &#125;
     return result;
  &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><code>java.util.Map</code>接口</p>
<p>Collection接口定义了单列集合规范 每次存储<strong>一个</strong>元素 单个元素<br>Map接口定义了双列集合的规范 每次存储<strong>一对儿</strong>元素(Key Value)</p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<pre><code class="java">HashMap&lt;K,V&gt;:存储数据采用的哈希表结构，元素的存取顺序不能保持一致，由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法

LinkedHashMap&lt;K,V&gt;: HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

public V put(K key, V value):把指定的键与指定的值添加到Map集合中
public V remove(Object key):把指定的键所对应的键值对元素 在Map集合中删除，返回被删除元素的值
public V get(Object key):根据指定的键，在Map集合中获取对应的值
boolean containsKey(Object key) 判断集合中是否包含指定的键。
public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)
    
使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 
若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 
</code></pre>
<h3 id="Map集合遍历-键找值-方式"><a href="#Map集合遍历-键找值-方式" class="headerlink" title="Map集合遍历 键找值 方式"></a>Map集合遍历 键找值 方式</h3><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法: keyset()</li>
<li>遍历键的Set集合，得到每一个键</li>
<li>根据键，获取键所对应的值。方法: get(K key)</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys)&#123;
            String value = map.get(key);
            System.out.println(key+&quot; &quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建Map集合对象 
        HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();
        // 添加元素到集合 
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);

        // 获取 所有的 entry对象  entrySet
        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();

        // 遍历得到每一个entry对象
        for (Entry&lt;String, String&gt; entry : entrySet) &#123;
               // 解析 
            String key = entry.getKey();
            String value = entry.getValue();  
            System.out.println(key+&quot;的CP是:&quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要<strong>保证有序，还要速度快</strong>怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<pre><code class="java"> public static void main(String[] args) &#123;
        LinkedHashMap&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;();
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);
        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;String,String&gt; entry : entrySet)&#123;
            System.out.println(entry.getKey()+entry.getValue());
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h3><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，<strong>键代表字符，值代表次数</strong>。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        //友情提示
        System.out.println(&quot;请录入一个字符串:&quot;);
        String line = new Scanner(System.in).nextLine();
        // 定义 每个字符出现次数的方法
        findChar(line);
    &#125;
    private static void findChar(String line) &#123;
        //1:创建一个集合 存储  字符 以及其出现的次数
        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
        //2:遍历字符串
        for (int i = 0; i &lt; line.length(); i++) &#123;
            char c = line.charAt(i);
            //判断 该字符 是否在键集中
            if (!map.containsKey(c)) &#123;//说明这个字符没有出现过
                //那就是第一次
                map.put(c, 1);
            &#125; else &#123;
                //先获取之前的次数
                Integer count = map.get(c);
                //count++;
                //再次存入  更新
                map.put(c, ++count);
            &#125;
        &#125;
        System.out.println(map);
    &#125;
</code></pre>
<h4 id="JDK9对集合添加的优化"><a href="#JDK9对集合添加的优化" class="headerlink" title="JDK9对集合添加的优化"></a>JDK9对集合添加的优化</h4><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<pre><code class="java">public class HelloJDK9 &#123;  
    public static void main(String[] args) &#123;  
        Set&lt;String&gt; str1=Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);  
        //str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  
        System.out.println(str1);  
        Map&lt;String,Integer&gt; str2=Map.of(&quot;a&quot;,1,&quot;b&quot;,2);  
        System.out.println(str2);  
        List&lt;String&gt; str3=List.of(&quot;a&quot;,&quot;b&quot;);  
        System.out.println(str3);  
    &#125;  
&#125; 

1: of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；
2: 返回的集合是不可变的；
</code></pre>
<h3 id="模拟斗地主洗牌发牌"><a href="#模拟斗地主洗牌发牌" class="headerlink" title="模拟斗地主洗牌发牌"></a>模拟斗地主洗牌发牌</h3><h5 id="案例规则"><a href="#案例规则" class="headerlink" title="案例规则"></a>案例规则</h5><ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h5 id="案例需求分析"><a href="#案例需求分析" class="headerlink" title="案例需求分析"></a>案例需求分析</h5><ol>
<li>准备牌：</li>
</ol>
<p>​        完成数字与纸牌的映射关系：</p>
<p>​        使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li>洗牌：</li>
</ol>
<p>​        通过数字完成洗牌发牌</p>
<ol start="3">
<li>发牌：</li>
</ol>
<p>​        将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>​        存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>​        将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li>看牌：</li>
</ol>
<p>​        通过Map集合找到对应字符展示。</p>
<p>​        通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示</p>
<pre><code class="java">public static void main(String[] args) &#123;
        /*
         * 1组装54张扑克牌
         */
        // 1.1 创建Map集合存储
        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();
        // 1.2 创建 花色集合 与 数字集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        // 1.3 存储 花色 与数字
        Collections.addAll(colors, &quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;);
        Collections.addAll(numbers, &quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;);
        // 设置 存储编号变量
        int count = 1;
        pokerMap.put(count++, &quot;大王&quot;);
        pokerMap.put(count++, &quot;小王&quot;);
        // 1.4 创建牌 存储到map集合中
        for (String number : numbers) &#123;
            for (String color : colors) &#123;
                String card = color + number;
                pokerMap.put(count++, card);
            &#125;
        &#125;
        /*
         * 2 将54张牌顺序打乱
         */
        // 取出编号 集合
        Set&lt;Integer&gt; numberSet = pokerMap.keySet();
        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中
        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();
        numberList.addAll(numberSet);

        // 打乱顺序
        Collections.shuffle(numberList);

        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌
        // 3.1 发牌的编号
        // 创建三个玩家编号集合 和一个 底牌编号集合
        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();

        // 3.2发牌的编号
        for (int i = 0; i &lt; numberList.size(); i++) &#123;
            // 获取该编号
            Integer no = numberList.get(i);
            // 发牌
            // 留出底牌
            if (i &gt;= 51) &#123;
                dipaiNo.add(no);
            &#125; else &#123;
                if (i % 3 == 0) &#123;
                    noP1.add(no);
                &#125; else if (i % 3 == 1) &#123;
                    noP2.add(no);
                &#125; else &#123;
                    noP3.add(no);
                &#125;
            &#125;
        &#125;

        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌
        // 4.1 对手中编号进行排序
        Collections.sort(noP1);
        Collections.sort(noP2);
        Collections.sort(noP3);
        Collections.sort(dipaiNo);

        // 4.2 进行牌面的转换
        // 创建三个玩家牌面集合 以及底牌牌面集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();

        // 4.3转换
        for (Integer i : noP1) &#123;
            // 4.4 根据编号找到 牌面 pokerMap
            String card = pokerMap.get(i);
            // 添加到对应的 牌面集合中
            player1.add(card);
        &#125;

        for (Integer i : noP2) &#123;
            String card = pokerMap.get(i);
            player2.add(card);
        &#125;
        for (Integer i : noP3) &#123;
            String card = pokerMap.get(i);
            player3.add(card);
        &#125;
        for (Integer i : dipaiNo) &#123;
            String card = pokerMap.get(i);
            dipai.add(card);
        &#125;

        //4.5 查看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;石破天：&quot;+player2);
        System.out.println(&quot;鸠摩智：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);
    &#125;
</code></pre>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>(<u>工程师不能处理,只能尽量避免</u>)与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>(<u>由于使用不当导致,可以避免的</u>)。</p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<pre><code class="java">throw new 异常类名(参数)
throw new NullPointerExcerption(&quot;要访问的arr数组不存在&quot;);
throw new ArrayIndexOutOfBoundsException(&quot;该索引所在数组不存在，已超出范围&quot;);
</code></pre>
<p>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
<pre><code class="java">public static int getElement(int[] arr, int index)&#123;
        if (index &lt; 0 || index &gt; arr.length - 1)&#123;
            throw new ArrayIndexOutOfBoundsException(&quot;越界&quot;);
        &#125;
        int element = arr[index];
        return element;
    &#125;

    public static void main(String[] args) &#123;
        int[] arr = &#123;1,3,6,8,10&#125;;
        int index = 5;
        int element = getElement(arr, index);
        System.out.println(element);
    &#125;
</code></pre>
<p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<pre><code class="java\">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;    
</code></pre>
<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<pre><code class="java">public class ThrowsDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        read(&quot;a.txt&quot;);
    &#125;

    public static void read(String path)throws FileNotFoundException, IOException &#123;
        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        &#125;
        if (!path.equals(&quot;b.txt&quot;)) &#123;
            throw new IOException();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<pre><code class="java">try&#123;
    编写可能会出现异常的代码
&#125;catch(异常类型 e)&#123;
    处理异常的代码
&#125;
//记录日志/打印异常信息/继续抛出异常
</code></pre>
<p><strong>try：</strong>该代码块中编写可能产生异常的代码。<br><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意：try和catch都不能单独使用,必须连用。</p>
</blockquote>
<pre><code class="java">public String getMessage():获取异常的描述信息，提示给用户的时候提示错误原因
public String toString():获取异常的类型和异常描述信息
public void printStoackTralce():打印异常的跟踪栈信息并输出到控制台
包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
</code></pre>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。[注意:finally不能单独使用。]</p>
<pre><code class="java">try&#123;
     编写可能会出现异常的代码
&#125;catch(异常类型A  e)&#123;  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;catch(异常类型B  e)&#123;  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;
注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。
</code></pre>
<ul>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h3 id="自定义异常练习"><a href="#自定义异常练习" class="headerlink" title="自定义异常练习"></a>自定义异常练习</h3><pre><code class="java">// 业务逻辑异常
public class RegisterException extends Exception &#123;
    /**
     * 空参构造
     */
    public RegisterException() &#123;
    &#125;

    /**
     *
     * @param message 表示异常提示
     */
    public RegisterException(String message) &#123;
        super(message);
    &#125;
&#125;
====================================================
public class Demo &#123;
    // 模拟数据库中已存在账号
    private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;;
   
    public static void main(String[] args) &#123;     
        //调用方法
        try&#123;
              // 可能出现异常的代码
            checkUsername(&quot;nill&quot;);
            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功
        &#125;catch(RegisterException e)&#123;
            //处理异常
            e.printStackTrace();
        &#125;
    &#125;

    //判断当前注册账号是否存在
    //因为是编译期异常，又想调用者去处理 所以声明该异常
    public static boolean checkUsername(String uname) throws LoginException&#123;
        for (String name : names) &#123;
            if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常
                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong></p>
<p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<pre><code class="java">public class Demo01 &#123;
    public static void main(String[] args) &#123;
        //创建自定义线程对象
        MyThread mt = new MyThread(&quot;新的线程！&quot;);
        //开启新线程
        mt.start();
        //在主方法中执行for循环
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(&quot;main线程！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h5><pre><code class="java">public class MyThread extends Thread &#123;
    //定义指定线程名称的构造方法
    public MyThread(String name) &#123;
        //调用父类的String参数的构造方法，指定线程的名称
        super(name);
    &#125;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;：正在执行！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="继承Thread类方式"><a href="#继承Thread类方式" class="headerlink" title="继承Thread类方式"></a>继承Thread类方式</h3><p>完成操作过程中用到了<code>java.lang.Thread</code>类</p>
<pre><code class="java">public Thread():分配一个新的线程对象
public Thread(String name):分配一个指定名字的新的线程对象
public Thread(Runnable target):分配一个带有指定目标新的线程对象
public Thread(Runnable target, String name):分配一个带有指定目标新的线程对象并指定名字
    
常用方法：
public String getName():获取当前线程名称
public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法
public void run():此线程要执行的任务在此处定义代码
public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停
public static Thread currentThread():返回对当前正在执行的线程对象的引用
</code></pre>
<h3 id="实现Runnable接口方式"><a href="#实现Runnable接口方式" class="headerlink" title="实现Runnable接口方式"></a>实现Runnable接口方式</h3><p>采用<code>java.lang.Runnable</code>类，只需要重写run方法即可<br>步骤如下：<br>1.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>2.创建Runnable实现类的实例，并以此实例为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象<br>3.调用线程对象的start()方法来启动线程</p>
<pre><code class="java">public class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 20; i++) &#123;
        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        MyThread mr = new MyThread();
        Thread t = new Thread(mr, &quot;小白&quot;);
        t.start();
        for (int i = 0; i &lt; 20; i++) &#123;
            System.out.println(&quot;旺财&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。</p>
<blockquote>
<p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><p>如果一个类继承Thread, 则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享</p>
<h5 id="实现Runnable接口比继承Thread类所具有的优势："><a href="#实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="实现Runnable接口比继承Thread类所具有的优势："></a>实现Runnable接口比继承Thread类所具有的优势：</h5><p>1.适合多个相同的程序代码的线程去共享同一个资源<br>2.可以避免java中的单继承的局限性<br>3.增加程序的健壮性，实现解耦操作，代码额可以被多个线程共享, 代码和线程独立<br>4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类</p>
<blockquote>
<p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。</p>
</blockquote>
<h3 id="线程同时安全"><a href="#线程同时安全" class="headerlink" title="线程同时安全"></a>线程同时安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<pre><code class="/java">public class Ticket implements Runnable&#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while(true)&#123;
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                   e.printStackTrace();
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
        &#125;
    &#125;
&#125;

public class test &#123;
    public static void main(String[] args) &#123;
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h5 id="怎么使用Java线程同步机制-？"><a href="#怎么使用Java线程同步机制-？" class="headerlink" title="怎么使用Java线程同步机制 ？"></a>怎么使用Java线程同步机制 ？</h5><p>1.同步代码块<br>2.同步方法<br>3.锁机制</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul>
<li>同步代码块： <strong>synchronized</strong> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</li>
</ul>
<pre><code class="java">synchronized(同步锁)&#123;
    需要同步操作的代码
&#125;
------------------------------------------------------------------
public void run() &#123;
        while(true)&#123;
            synchronized (lock)&#123;
                if (ticket &gt; 0)&#123;
                    try &#123;
                        Thread.sleep(10000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    String name = Thread.currentThread().getName();
                    System.out.println(name + ticket--);
                &#125;
            &#125;
       &#125;
</code></pre>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li>同步方法：<strong>synchronized</strong> 修饰的方法, 叫做同步方法. 保证A线程执行该方法的时候, 其他线程只能在方法外等着</li>
</ul>
<pre><code class="java">同步锁是谁?
对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。
</code></pre>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作，同步代码块&#x2F;同步方法 具有的功能Lock都有，除此之外更强大，更体现面向对象。<br>Lock锁也称同步锁，<strong>加锁</strong>与<strong>释放锁</strong>方法化了</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        MyRunnable my = new MyRunnable();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
----------------------------------------------
public class MyRunnable implements Runnable&#123;
    private int ticket = 100;
    Lock lock = new ReentrantLock();
     @Override
      public void run() &#123;
        while(true)&#123;
            lock.lock();
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(50);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><p>在<code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New(新建)</td>
<td>线程刚被创建, 但是并未启动, 还没条用start方法</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态, 可能正在运行自己代码, 也可能没有, 这取决于操作系统处理器</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁, 而该对象锁被其他的线程持有, 则该线程进入Blocked状态; 当该线程持有锁时, 该线程将变成Runnable状态</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个(唤醒)动作时, 该线程进入Waiting状态。进入这个状态后是不能自动唤醒的, 必须等待另一个线程调用<strong>notify</strong>或者<strong>notifyAll</strong>方法才能够唤醒</td>
</tr>
<tr>
<td>TimedWaiting(计时终止)</td>
<td>同waiting状态, 有几个方法有超时参数, 调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法又Thread.sleep、Object.wait</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡, 或者没有因为捕获的异常终止了run方法而死亡</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一个调用了某个对象的 Object.wait 方法的线程会<span style = "color : red">等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。</span></strong> </p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞 争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p> 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/8476427ec1a9ced5d3f5727b207aff6b2f53636c/data/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE(%E9%AB%98%E7%BA%A7).jpg"  />

<pre><code class="java">public class test &#123;
    public static Object obj = new Object();

    public static void main(String[] args) &#123;
// 演示waiting
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while (true) &#123;
                    synchronized (obj) &#123;
                        try &#123;
                            System.out.println(Thread.currentThread().getName() + &quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;);
                            obj.wait(); //无限等待
//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                        System.out.println(Thread.currentThread().getName() + &quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;, &quot;等待线程&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
// while (true)&#123; //每隔3秒 唤醒一次
                try &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 等待3秒钟&quot;);
                    Thread.sleep(3000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;);
                    obj.notify();
                &#125;
            &#125;
// &#125;
        &#125;, &quot;唤醒线程&quot;).start();
    &#125;
&#125;
</code></pre>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>1.wait: 线程不再活动, 不再参与调度, 进入wait set中, 因此不会浪费CPU资源, 也不会去竞争锁, 这时的线程状态即是Waiting。它还要等着别的线程执行一个特别的动作, 也即是”<strong>通知(notify)</strong>“在这个对象上等待的线程从wait set中释放出来, 重新进入到调度队列(ready queue)中<br>2.notify: 选取所通知对象的wait set中的一个线程释放：例如, 餐馆有空位置后, 等候就餐最久的顾客最先入座<br>3.notifyAll: 释放所通知的对象的wait set上的全部线程</p>
<blockquote>
<p>哪怕只通知了一个等待的线程, 被通知线程也不能立即恢复执行, 因为它当初终端的地方是在同步块内, 而此刻它偶已经不持有锁, 所以她需要再次尝试去获取锁(可能面临其他线程的竞争), 成功后才能在当初调用wait方法之后的地方恢复执行</p>
<ul>
<li>如果能获取锁, 线程就从Waiting状态变成Bunnable状态</li>
<li>否则, 从wait set出来, 又进入entry set, 线程就从Waiting状态变成了Blocked状态</li>
</ul>
</blockquote>
<h5 id="调用wait和notify方法需要注意的细节"><a href="#调用wait和notify方法需要注意的细节" class="headerlink" title="调用wait和notify方法需要注意的细节"></a>调用wait和notify方法需要注意的细节</h5><p>1.wait方法与notify方法必须由同一锁对象调用 因为对应锁对象可以通过notify唤醒使用同一锁对象调用的wait方法后的线程<br>2.wait方法与notify方法是属于Object类的方法的 因为锁对象是可以是任意对象，而任意对象的所属类都是继承了Object类的<br>3.wait方法与notify方法必须要在同步代码块或者是同步函数中使用 因为必须通过锁对象调用这2个方法</p>
<pre><code class="java">void notify():唤醒在此对象监视器上等待的单个线程
void notifyAll():唤醒在此对象监视器上等待的所有线程
void wait():导致当前的线程等待, 直到其他线程调用此对象的notify()方法或者notifyAll()方法
void wait(long timeout):导致当前的线程等待, 直到其他线程调用此对象的notify()方法或notifyAll()方法, 或者指定的时间过完
void wait(long timeout, intik nanos):导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法，或者其他线程打断了当前线程，或者指定的时间过完。
</code></pre>
<ul>
<li>wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。</li>
<li>当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常</li>
<li>当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。</li>
<li>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</li>
<li>调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。</li>
<li>notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）</li>
<li>notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）</li>
<li>假设有三个线程执行了obj.wait()，那么obj.notifyAll()则能全部唤醒thread1，thread2，thread3，但是要继续执行obj.wait()的下一条语句，必须获取obj锁，因此，thread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。</li>
<li>当调用obj.notify&#x2F;notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code></p>
<pre><code class="java">Executoturs类中有个创建线程池的方法：
public static ExecutorService nweFixedThreadPool(int nThreads):返回线程池对象(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：
public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象并执行
Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建于使用
</code></pre>
<blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
</blockquote>
<pre><code class="java">public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个教练&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;);
    &#125;
&#125;
==========================================================
public class ThreadPoolDemo &#123;
    public static void main(String[] args) &#123;
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
        // 创建Runnable实例对象
        MyRunnable r = new MyRunnable();

        //自己创建线程对象的方式
        // Thread t = new Thread(r);
        // t.start(); ---&gt; 调用MyRunnable中的run()

        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
        // 再获取个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        //service.shutdown();
    &#125;
&#125;
</code></pre>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h5 id="强调做什么，而不是以什么形式做"><a href="#强调做什么，而不是以什么形式做" class="headerlink" title="强调做什么，而不是以什么形式做"></a><strong>强调做什么，而不是以什么形式做</strong></h5><p>面向对象的思想:</p>
<p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<pre><code class="java">public class Demo01Runnable &#123;
    public static void main(String[] args) &#123;
        // 匿名内部类
        Runnable task = new Runnable() &#123;
            @Override
            public void run() &#123; // 覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;;
        new Thread(task).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<p>上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<pre><code class="java">public class Demo02LambdaRunnable &#123;
    public static void main(String[] args) &#123;
        new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h4><pre><code class="java">public class RunnableImpl implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;多线程任务执行！&quot;);
    &#125;
&#125;

public class Demo03ThreadInitParam &#123;
    public static void main(String[] args) &#123;
        Runnable task = new RunnableImpl();
        new Thread(task).start();
    &#125;
&#125;
</code></pre>
<h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><p><strong>匿名内部类的好处与弊端</strong><br>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<pre><code class="java">public class Demo04ThreadNameless &#123;
    public static void main(String[] args) &#123;
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<pre><code class="java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)
</code></pre>
<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h3 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h3><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li><strong>一些参数</strong></li>
<li><strong>一个箭头</strong></li>
<li><strong>一段代码</strong></li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;
</code></pre>
<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h3 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h3><blockquote>
<p>需求:<br>    使用数组存储多个Person对象<br>    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</p>
</blockquote>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<pre><code class="java">public class Person &#123; 
    private String name;
    private int age;
    
    // 省略构造器、toString方法与Getter Setter 
&#125;

import java.util.Arrays;
import java.util.Comparator;
public class Demo06Comparator &#123;
    public static void main(String[] args) &#123;
          // 本来年龄乱序的对象数组
        Person[] array = &#123;
            new Person(&quot;古力娜扎&quot;, 19),
            new Person(&quot;迪丽热巴&quot;, 18),
               new Person(&quot;马尔扎哈&quot;, 20) &#125;;

          // 匿名内部类
        Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getAge() - o2.getAge();
            &#125;
        &#125;;
        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h6 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h6><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h6 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h6><pre><code class="java">import java.util.Arrays;

public class Demo07ComparatorLambda &#123;
    public static void main(String[] args) &#123;
        Person[] array = &#123;
              new Person(&quot;古力娜扎&quot;, 19),
              new Person(&quot;迪丽热巴&quot;, 18),
              new Person(&quot;马尔扎哈&quot;, 20) &#125;;

        Arrays.sort(array, (Person a, Person b) -&gt; &#123;
              return a.getAge() - b.getAge();
        &#125;);

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><pre><code class="java">public File(String pathname):通过将给定的路径名字字符串转化为抽象路径名来创建新的File实例
public File(String parent, String child):从父路径名字符串和子路径名字符串创建新的File实例
public File(File parent, String child):从父抽象路径名和子路径名字符串创建新的File实例
</code></pre>
<pre><code class="java">// 文件路径名
String pathname = &quot;D:\\aaa.txt&quot;;
File file1 = new File(pathname); 

// 文件路径名
String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;
File file2 = new File(pathname2); 

// 通过父路径和子路径字符串
 String parent = &quot;d:\\aaa&quot;;
 String child = &quot;bbb.txt&quot;;
 File file3 = new File(parent, child);

// 通过父级File对象和子路径字符串
File parentDir = new File(&quot;d:\\aaa&quot;);
String child = &quot;bbb.txt&quot;;
File file4 = new File(parentDir, child);

小贴士：
1. 一个File对象代表硬盘中实际存在的一个文件或者目录。
2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。
</code></pre>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre><code class="java">public String getAbsolutePath():返回此File的绝对路径名字符串
public String getPath():将此File转换为路径名字符串
public String getName():返回由此File表示的文件或目录的名称
public long length():返回由此File表示的文件的长度
</code></pre>
<pre><code class="java">public class FileGet &#123;
    public static void main(String[] args) &#123;
        File f = new File(&quot;d:/aaa/bbb.java&quot;);     
        System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());
        System.out.println(&quot;文件构造路径:&quot;+f.getPath());
        System.out.println(&quot;文件名称:&quot;+f.getName());
        System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);

        File f2 = new File(&quot;d:/aaa&quot;);     
        System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());
        System.out.println(&quot;目录构造路径:&quot;+f2.getPath());
        System.out.println(&quot;目录名称:&quot;+f2.getName());
        System.out.println(&quot;目录长度:&quot;+f2.length());
    &#125;
&#125;
输出结果：
文件绝对路径:d:\aaa\bbb.java
文件构造路径:d:\aaa\bbb.java
文件名称:bbb.java
文件长度:636字节

目录绝对路径:d:\aaa
目录构造路径:d:\aaa
目录名称:aaa
目录长度:4096
API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。
</code></pre>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<pre><code class="java">public class FilePath &#123;
    public static void main(String[] args) &#123;
          // D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
          
        // 项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f2.getAbsolutePath());
    &#125;
&#125;
输出结果：
D:\bbb.java
D:\idea_project_test4\bbb.java
</code></pre>
<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5><pre><code class="java">public boolean exists():此File表示的文件或目录是否真实存在
public boolean isDirectory():此File表示的是否为目录
public boolean isFile():此File表示的是否为文件
</code></pre>
<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5><pre><code class="java">public boolean createNewFile():当且仅当具有该名称的文件尚不存在时候,创建一个新的空文件
public boolean delete():删除由此File表示的文件或目录
public boolean mkdir():创建由此File表示的目录
public boolean mkdirs():创建由此File表示的目录,包括任何必须旦不存在的父目录
</code></pre>
<pre><code class="java">public class FileCreateDelete &#123;
    public static void main(String[] args) throws IOException &#123;
        // 文件的创建
        File f = new File(&quot;aaa.txt&quot;);
        System.out.println(&quot;是否存在:&quot;+f.exists()); // false
        System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true
        System.out.println(&quot;是否存在:&quot;+f.exists()); // true
        
         // 目录的创建
          File f2= new File(&quot;newDir&quot;);    
        System.out.println(&quot;是否存在:&quot;+f2.exists());// false
        System.out.println(&quot;是否创建:&quot;+f2.mkdir());    // true
        System.out.println(&quot;是否存在:&quot;+f2.exists());// true

        // 创建多级目录
          File f3= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f3.mkdir());// false
        File f4= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f4.mkdirs());// true
      
          // 文件的删除
           System.out.println(f.delete());// true
      
          // 目录的删除
        System.out.println(f2.delete());// true
        System.out.println(f4.delete());// false
    &#125;
&#125;
API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。
</code></pre>
<h5 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h5><pre><code class="java">public String[] list():返回一个String数组,表示该FIle目录中的所有子文件或目录
public File[] listFiles():返回一个File数组,表示该FIle目录中的所有的子文件或目录
</code></pre>
<pre><code class="java">public class FileFor &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;d:\\java_code&quot;);
      
          //获取当前目录下的文件以及文件夹的名称。
        String[] names = dir.list();
        for(String name : names)&#123;
            System.out.println(name);
        &#125;
        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息
        File[] files = dir.listFiles();
        for (File file : files) &#123;
            System.out.println(file);
        &#125;
    &#125; //打印全文件地址名称
</code></pre>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h5><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class DiGuiDemo2 &#123;
    public static void main(String[] args) &#123;
          // 创建File对象
        File dir  = new File(&quot;D:\\aaa&quot;);
          // 调用打印目录方法
        printDir(dir);
    &#125;

    public static void  printDir(File dir) &#123;
          // 获取子文件和目录
        File[] files = dir.listFiles();
          // 循环打印
          /*
            判断:
            当是文件时,打印绝对路径.
            当是目录时,继续调用打印目录的方法,形成递归调用.
          */
        for (File file : files) &#123;
            // 判断
            if (file.isFile()) &#123;
                  // 是文件,输出文件绝对路径
                System.out.println(&quot;文件名:&quot;+ file.getAbsolutePath());
            &#125; else &#123;
                  // 是目录,输出目录绝对路径
                System.out.println(&quot;目录:&quot;+file.getAbsolutePath());
                  // 继续遍历,调用printDir,形成递归
                printDir(file);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件搜索案例"><a href="#文件搜索案例" class="headerlink" title="文件搜索案例"></a>文件搜索案例</h4><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        File file = new File(&quot;D:\\NotePad++&quot;);
        printFile(file);
    &#125;
    public static void printFile(File file)&#123;
        File[] files = file.listFiles();
        for (File f1 : files)&#123;
            if (f1.isFile())&#123;
                if (f1.getName().endsWith(&quot;.xml&quot;))&#123;
                    System.out.println(&quot;文件名：&quot;+f1.getAbsolutePath());
                &#125;
            &#125;else &#123;
                printFile(f1);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h4><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code> listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<pre><code class="java">boolean accept(File pathname)：测试pathname是否应该包含在当前File目录中，符合则返回true。
</code></pre>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public class DiGuiDemo4 &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;D:\\aaa&quot;);
        printDir2(dir);
    &#125;
  
    public static void printDir2(File dir) &#123;
          // 匿名内部类方式,创建过滤器子类对象
        File[] files = dir.listFiles(new FileFilter() &#123;
            @Override
            public boolean accept(File pathname) &#123;
                return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();
            &#125;   //public boolean isDirectory():此File表示的是否为目录
        &#125;);
          // 循环打印
        for (File file : files) &#123;
            if (file.isFile()) &#123;
                System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
            &#125; else &#123;
                printDir2(file);
            &#125;
        &#125;
    &#125;
&#125;      
</code></pre>
<h4 id="Lambda优化"><a href="#Lambda优化" class="headerlink" title="Lambda优化"></a>Lambda优化</h4><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<pre><code class="java">()-&gt;&#123; &#125;
</code></pre>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void printDir3(File dir) &#123;
      // lambda的改写
    File[] files = dir.listFiles(f -&gt;&#123; 
          return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory(); 
    &#125;);
      
    // 循环打印
    for (File file : files) &#123;
        if (file.isFile()) &#123;
            System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
          &#125; else &#123;
            printDir3(file);
          &#125;
    &#125;
&#125;
</code></pre>
<h3 id="字节流、字符流"><a href="#字节流、字符流" class="headerlink" title="字节流、字符流"></a>字节流、字符流</h3><h6 id="顶级父类们"><a href="#顶级父类们" class="headerlink" title="顶级父类们"></a>顶级父类们</h6><table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>字节输入流 <strong>InputStream</strong></td>
<td>字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td>字符流</td>
<td>字符输入流 <strong>Reader</strong></td>
<td>字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<h6 id="字节输出流-OutputStream类"><a href="#字节输出流-OutputStream类" class="headerlink" title="字节输出流 OutputStream类"></a>字节输出流 OutputStream类</h6><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输出流并释放与此流相关联的任何系统资源
public void flush():刷新此输出流并强制任何缓冲的输出字节被写出
public void write(byte[] b):将b.length字节从指定的字节数组写入此输出流
public void write(byte[] b, in off, int len):从指定的字节数组写入len字节,从偏移量off开始输出到此输出流
public abstract void write(int b):将指定的字节输出流
// close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h6 id="字节输出流-FileOutputStream类"><a href="#字节输出流-FileOutputStream类" class="headerlink" title="字节输出流 FileOutputStream类"></a>字节输出流 FileOutputStream类</h6><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。<br><code>java.io.FileOutputStream </code>类是文件输出流，用于**<u>将数据写出到文件</u>**。</p>
<pre><code class="java">public FileOutputStream(File file):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name):创建文件输出流以指定的名称写入文件
</code></pre>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<pre><code class="java">public class FileOutputStreamConstructor throws IOException &#123;
    public static void main(String[] args) &#123;
           // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream(&quot;D:\Clash\a.txt&quot;);
        // 普通创建
        File file = new File(&quot;a.txt&quot;);
        FileOutputStream fos = new FileOutputStream(file);
    &#125;
&#125;
</code></pre>
<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><p><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;);
    fos.write(97); //a
    fos.close();
&#125;
// 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
// 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\clash\\a.txt&quot;);
    yte[] b = &quot;黑马程序员&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<pre><code class="java">public FileOutputStream(File file, boolean append):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name, boolean append):创建文件输出流以指定的名称写入文件
</code></pre>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;, true);
    byte[] b = &quot;abcde&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
<h4 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h4><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输入流并释放与此流相关的任何系统资源
public abstract int read():从输入流读取数据的下一个字节
public int read(byte[] b):从输入流中读取一些字节数,并把它们存储到字节数组b中
close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">FileInputStream(File file):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的File对象 file命名
FileInputStream(String name):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的路径名 name命名。  
当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。
</code></pre>
<p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
   FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
   int b;
   while((b=fis.read())!= -1)&#123;
      System.out.println((char)b);
   &#125;
    fis.close();
&#125;
//1. 虽然读取了一个字节，但是会自动提升为int类型。
//2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    byte[] b = new byte[2];
    while((len = fis.read(b)) != -1)&#123;
         System.out.println(new String(b,0,len));
    &#125;
    fis.close();
 &#125;
</code></pre>
<h5 id="实现资源的复制"><a href="#实现资源的复制" class="headerlink" title="实现资源的复制"></a>实现资源的复制</h5><pre><code class="java">public static void main(String[] args) throws IOException &#123;
    // 1.创建流对象
    // 1.1 指定数据源
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    // 1.2 指定目的地
    FileOutputStream fos = new FileOutputStream(&quot;D:\\7-Zip\\c.txt&quot;);
    // 2.读写数据
    // 2.1 定义数组
    byte[] b = new byte[1024];
    // 2.2 定义长度
    int len;
    // 2.3 循环读取
    while((len = fis.read(b))!=-1)&#123;
    // 2.4 写出数据
        fos.write(b,0,len);
    &#125;
    // 3.关闭资源
    fos.close();
    fis.close();
&#125;
// 流的关闭原则：先开后关，后开先关。
</code></pre>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><pre><code class="java">FileReader(File file):创建一个新的FileReader，给定要读取的File对象
FileReader(String fileName):创建一个新的FileReader，给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileReader fr = new FileReader(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    char[] cbuf = new char[1024];
    while((len = fr.read(cbuf))!=-1)&#123;
        System.out.println(new String(cbuf,0,len));
    &#125;
    fr.close();
&#125;
</code></pre>
<h3 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h3><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">void write(int c):写入单个字符
void write(char[] cbuf):写入字符数组
abstract void weite(char[] cbuf, int off, int len):写入字符数组的某一部分,off数组的开始索引,len写的字符个数
void write(String str):写入字符串
void write(String str, int off, int len):写入字符串的某一部分,off字符串的开始索引,len写的字符个数
void flush():刷新该流的缓冲
void close():关闭此流,但要先刷新它
</code></pre>
<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<pre><code class="java">FileWriter(File file):创建一个新的FileWriter,给定要读取的File对象
FileWeiter(String fileName):创建一个新的FileWeiter,给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
            // 使用File对象创建流对象
        File file = new File(&quot;a.txt&quot;);
        FileWriter fw = new FileWriter(file);
      
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter(&quot;b.txt&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><p><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream</p>
<p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</p>
<p><strong>续写和换行</strong>：操作类似于FileOutputStream。</p>
<p><strong><u>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</u></strong></p>
<blockquote>
<p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。在ASCII编码中，一个英文字母字符存储需要1个字节。</p>
<p><strong>字节</strong>：计算机存储容量基本单位是字节（Byte），音译为拜特，8个二进制位组成1个字节，一个标准英文字母占一个字节位置，一个标准汉字占二个字节位置。计算机存储容量大小以字节数来度量。</p>
</blockquote>
<h3 id="异常的处理-回顾"><a href="#异常的处理-回顾" class="headerlink" title="异常的处理(回顾)"></a>异常的处理(回顾)</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
        FileWriter fw = null;
        try &#123;
            fw = new FileWriter(&quot;D:\\Clash\\a.txt&quot;);
            fw.write(&quot;黑马程序员&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try&#123;
                if (fw != null)&#123;
                    fw.close();
                &#125;
            &#125;catch (IOException e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>try (创建流对象语句，如果多个,使用’;’隔开) {<br>    &#x2F;&#x2F; 读写数据<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}</p>
</blockquote>
<pre><code class="java">public class HandleException2 &#123;
    public static void main(String[] args) &#123;
          // 创建流对象
        try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123;
            // 写出数据
            fw.write(&quot;黑马程序员&quot;); //黑马程序员
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<pre><code class="java">public class TryDemo &#123;
    public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        final  FileReader fr  = new FileReader(&quot;in.txt&quot;);
        FileWriter fw = new FileWriter(&quot;out.txt&quot;);
           // 引入到try中
        try (fr; fw) &#123;
              // 定义变量
            int b;
              // 读取数据
              while ((b = fr.read())!=-1) &#123;
                // 写出数据
                fw.write(b);
              &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><pre><code class="java">public Object setProperty(String key, String value):保存一对属性
public String getProperty(String key):使用此属性列表中指定的键搜索属性值
public Set&lt;String&gt; stringPropertyNames():所有键的名称的集合
</code></pre>
<pre><code class="java">public class ProDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties properties = new Properties();
        // 添加键值对元素
        properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;);
        properties.setProperty(&quot;length&quot;, &quot;209385038&quot;);
        properties.setProperty(&quot;location&quot;, &quot;D:\\a.txt&quot;);
        // 打印属性集对象
        System.out.println(properties);
        // 通过键,获取属性值
        System.out.println(properties.getProperty(&quot;filename&quot;));
        System.out.println(properties.getProperty(&quot;length&quot;));
        System.out.println(properties.getProperty(&quot;location&quot;));

        // 遍历属性集,获取所有键的集合
        Set&lt;String&gt; strings = properties.stringPropertyNames();
        // 打印键值对
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+properties.getProperty(key));
        &#125;
    &#125;
&#125;
输出结果：
&#123;filename=a.txt, length=209385038, location=D:\a.txt&#125;
a.txt
209385038
D:\a.txt
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><pre><code class="java">public void load(InputStream inStream):从字节输入流中读取键值对
</code></pre>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<pre><code>filename=a.txt
length=209385038
location=D:\a.txt
</code></pre>
<p>加载代码演示：</p>
<pre><code class="java">public class ProDemo2 &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties pro = new Properties();
        // 加载文本中信息到属性集
        pro.load(new FileInputStream(&quot;read.txt&quot;));
        // 遍历集合并打印
        Set&lt;String&gt; strings = pro.stringPropertyNames();
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));
        &#125;
     &#125;
&#125;
输出结果：
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p><strong>字节缓冲流</strong>  <code>BufferedInputStream</code>, <code>BufferedOutputStream</code><br><strong>字符缓冲流</strong>  <code>BufferedReader</code>, <code>BudfferedWeiter</code></p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><pre><code class="java">public BufferedInputStream(InputStream in):创建一个新的缓冲输入流
public BufferedOutputStream(OutputStream out):创建一个新的缓冲输出流
</code></pre>
<pre><code class="java">// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
</code></pre>
<pre><code class="java">public static void main(String[] args) throws FileNotFoundException &#123;
          // 记录开始时间
        long start = System.currentTimeMillis();
        // 创建流对象
        try (
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));
        )&#123;
              // 读写数据
            int len;
            byte[] bytes = new byte[8*1024];
            while ((len = bis.read(bytes)) != -1) &#123;
                bos.write(bytes, 0 , len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
缓冲流使用数组复制时间:666 毫秒
</code></pre>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><pre><code class="java">public BufferedReader(Reader in):创建一个新的缓冲输入流
public BufferedReader(Writer out):创建一个新的缓冲输出流
</code></pre>
<blockquote>
<p><strong>字节(Byte)</strong> 是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。<br>**字符(Character) ** 是计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
</blockquote>
<h5 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h5><pre><code class="java">BufferedReader：public String readLine():读一行文字
bufferedWeiter：public void newLine():写一行行分隔符，由系统属性定义符号
</code></pre>
<pre><code class="java">readLine代码展示
public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        // 定义字符串,保存读取的一行文字
        String line  = null;
          // 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) &#123;
            System.out.print(line);
            System.out.println(&quot;------&quot;);
        &#125;
        // 释放资源
        br.close();
    &#125;
</code></pre>
<pre><code class="java">newLine代码展示
public static void main(String[] args) throws IOException  &#123;
          // 创建流对象
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));
          // 写出数据
        bw.write(&quot;黑马&quot;);
          // 写出换行
        bw.newLine();
        bw.write(&quot;程序&quot;);
        bw.newLine();
        bw.write(&quot;员&quot;);
        bw.newLine();
        // 释放资源
        bw.close();
    &#125;
&#125;
输出效果:
黑马
程序
员
</code></pre>
<h1 id="练习-文本排序"><a href="#练习-文本排序" class="headerlink" title="练习: 文本排序"></a>练习: 文本排序</h1><p>请将文本信息恢复顺序。</p>
<pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
9.今当远离，临表涕零，不知所言。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
</code></pre>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java"> public static void main(String[] args) throws IOException &#123;
        // 创建map集合,保存文本数据,键为序号,值为文字
        HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();

        // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));

        // 读取数据
        String line  = null;
        while ((line = br.readLine())!=null) &#123;
            // 解析文本
            String[] split = line.split(&quot;\\.&quot;);
            // 保存到集合
            lineMap.put(split[0],split[1]);
        &#125;
        // 释放资源
        br.close();

        // 遍历map集合
        for (int i = 1; i &lt;= lineMap.size(); i++) &#123;
            String key = String.valueOf(i);
            // 获取map中文本
            String value = lineMap.get(key);
              // 写出拼接文本
            bw.write(key+&quot;.&quot;+value);
              // 写出换行
            bw.newLine();
        &#125;
        // 释放资源
        bw.close();
    &#125;
</code></pre>
<blockquote>
<ul>
<li><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</li>
<li>**Integer valueOf(String s):**返回保存指定的 String 的值的 Integer 对象。</li>
<li><strong>Integer valueOf(String s, int radix):</strong> 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</li>
</ul>
</blockquote>
<h2 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流
OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流
</code></pre>
<pre><code class="java">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
          // 定义文件路径
        String FileName = &quot;E:\\out.txt&quot;;
          // 创建流对象,默认UTF8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));
        // 写出数据
          osw.write(&quot;你好&quot;); // 保存为6个字节
        osw.close();
        // 定义文件路径
        String FileName2 = &quot;E:\\out2.txt&quot;;
         // 创建流对象,指定GBK编码
        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);
        // 写出数据
          osw2.write(&quot;你好&quot;);// 保存为4个字节
        osw2.close();
 &#125;
</code></pre>
<h2 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code class="java">public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的ObjectOutputStream。
</code></pre>
<h2 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong><br><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<blockquote>
<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a><strong>一、是什么</strong></h2><p>序列化：就是将对象转化成字节序列的过程。</p>
<p>反序列化：就是讲字节序列转化成对象的过程。</p>
<p>对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。</p>
<h2 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a><strong>二、为什么</strong></h2><p>那么为什么要去进行序列化呢？有以下两个原因</p>
<ol>
<li>持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。</li>
<li>网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。</li>
</ol>
<h2 id="三、怎么做"><a href="#三、怎么做" class="headerlink" title="三、怎么做"></a><strong>三、怎么做</strong></h2><p>怎么去实现对象的序列化呢？</p>
<p>Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。</p>
<ol>
<li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口</li>
<li>实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化</li>
</ol>
<p>下面分别实现Serializable和Externalizable接口来演示序列化和反序列化</p>
</blockquote>
<pre><code class="java">public class Employee implements java.io.Serializable &#123;
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() &#123;
          System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);
    &#125;
&#125;

public final void writeObject (Object obj) : 将指定的对象写出。
    
public class SerializeDemo&#123;
       public static void main(String [] args)   &#123;
        Employee e = new Employee();
        e.name = &quot;zhangsan&quot;;
        e.address = &quot;beiqinglu&quot;;
        e.age = 20; 
        try &#123;
              // 创建序列化流对象
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));
            // 写出对象
            out.writeObject(e);
            // 释放资源
            out.close();
            fileOut.close();
            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。
        &#125; catch(IOException i)   &#123;
            i.printStackTrace();
        &#125;
       &#125;
&#125;
输出结果：
Serialized data is saved
</code></pre>
<h2 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class SerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建 学生对象
        Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);
        Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);
        Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);

        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(student);
        arrayList.add(student2);
        arrayList.add(student3);
        // 序列化操作
        // serializ(arrayList);
        
        // 反序列化  
        ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));
        // 读取对象,强转为ArrayList类型
        ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();
        
          for (int i = 0; i &lt; list.size(); i++ )&#123;
              Student s = list.get(i);
            System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());
          &#125;
    &#125;

    private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;
        // 创建 序列化流 
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));
        // 写出对象
        oos.writeObject(arrayList);
        // 释放资源
        oos.close();
    &#125;
&#125;
</code></pre>
<h2 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；
</code></pre>
<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<pre><code class="java">public class PrintDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        // 调用系统的打印流,控制台直接输出97
        System.out.println(97);
      
        // 创建打印流,指定文件的名称
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);
          
          // 设置系统的打印流流向,输出到ps.txt
        System.setOut(ps);
          // 调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    &#125;
&#125;
</code></pre>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p><code>Socket</code>类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点</p>
<h5 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">public Socket(String host, int port):创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。
</code></pre>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
<p>构造举例，代码如下：</p>
<pre><code class="java">Socket client = new Socket(&quot;127.0.0.1&quot;, 6666);
</code></pre>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public InputStream getInputStream() ： 返回此套接字的输入流。
  - 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。
  - 关闭生成的InputStream也将关闭相关的Socket。
public OutputStream getOutputStream() ： 返回此套接字的输出流。
  - 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。
  - 关闭生成的OutputStream也将关闭相关的Socket。
public void close() ：关闭此套接字。
  - 一旦一个socket被关闭，它不可再使用。
  - 关闭此socket也将关闭相关的InputStream和OutputStream 。 
public void shutdownOutput() ： 禁用此套接字的输出流。   
  - 任何先前写出的数据将被发送，随后终止输出流。 
</code></pre>
<h2 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h2><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h5 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。
ServerSocket server = new ServerSocket(6666);
</code></pre>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public Socket accept():侦听并接受链接，返回一个新的Socket对象，用于和客户端实现通信，该方法一直阻塞直到建立链接
</code></pre>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
        //5.关闭资源.
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.获取流对象 . 输出流
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
        // 4. 关闭资源 .
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
          // =================回写数据=======================
          // 5. 通过 socket 获取输出流
           OutputStream out = server.getOutputStream();
          // 6. 回写数据
           out.write(&quot;我很好,谢谢你&quot;.getBytes());
          // 7.关闭资源.
          out.close();
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.通过Scoket,获取输出流对象 
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
          // ==============解析回写=========================
          // 4. 通过Scoket,获取 输入流对象
          InputStream in = client.getInputStream();
          // 5. 读取数据数据
          byte[] b = new byte[100];
          int len = in.read(b);
          System.out.println(new String(b, 0, len));
        // 6. 关闭资源 .
          in.close();
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<pre><code class="java">修饰符 interface 接口名称 &#123;
    public abstract 返回值类型 方法名称(可选参数信息);
    // 其他非抽象方法内容
&#125;
</code></pre>
<p><span style = "color:red"><strong>由于接口当中抽象方法的 <code>public abstract</code> 是可以省略的</strong></span>，所以定义一个函数式接口很简单：</p>
<pre><code class="java">public interface MyFunctionalInterface&#123;
    void myMethod(); //省略public abstract
&#125;
</code></pre>
<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><p>与<code>@Override</code>注解的作用类似，引入了一个新的注解<code>@FunctionalInterface</code> 该注解可用于上一个接口的定义上</p>
<pre><code class="java">@FunctionalInterface
public interface MyfunctionalInterface&#123;
    void myMethod();
&#125;
</code></pre>
<p><strong>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错</strong>。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<p>对于刚刚定义好的 <code>MyFunctionalInterface</code> 函数式接口，典型使用场景就是作为方法的参数：</p>
<pre><code class="java">public class Demo09FunctionalInterface&#123;
    //使用自定义的函数式接口方法
    private static void deSomething(MyfunctionalInterfalce inter)&#123;
        inter.myMethod(); //调用自定义的函数式接口方法
    &#125;
    
    public static void main(String[] args)&#123;
        //调用使用函数式接口的方法
        doSomething(()-&gt;System.out,println(&quot;Lambda执行啦！&quot;));
    &#125;
&#125;
</code></pre>
<h2 id="Lambda的延迟"><a href="#Lambda的延迟" class="headerlink" title="Lambda的延迟"></a>Lambda的延迟</h2><pre><code class="java">public static void log(int level, MessageBuilder builder)&#123;
        if (level == 1)&#123;
            System.out.println(builder.buildMessage());
        &#125;
    &#125;

    public static void main(String[] args)&#123;
        String msgA = &quot;Hello&quot;;
        String msgB = &quot;world&quot;;
        String msgC = &quot;Java&quot;;
        log(2,() -&gt; &#123;
            System.out.println(&quot;Lambda执行啦！&quot;);
            return msgA+msgB+msgC;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 </p>
<blockquote>
<p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法 来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>
</blockquote>
<h2 id="使用Lambda作为参数和返回值"><a href="#使用Lambda作为参数和返回值" class="headerlink" title="使用Lambda作为参数和返回值"></a>使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。<br>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p>
<pre><code class="java">public class DemoRunnable&#123;
    private static void startThread(Runnable task)&#123;
        new Thread(task).start();
    &#125;
    public static void main(String[] args)&#123;
        startThread(()-&gt;System.out.println(&quot;线程任务执行！&quot;));
    &#125;
&#125;
</code></pre>
<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 <code>java.util.Comparator</code> 接口类型的对象作为排序器时, 就可以调该方法获取</p>
<pre><code class="java">private static Comparable&lt;String&gt; newComparator()&#123;
    return(a,b) -&gt; b.length() - a.length();
    // 其中直接return一个Lambda表达式即可
&#125;

public static void main(String[] args) &#123;
    String[] array = &#123;&quot;abc&quot;,&quot;ab&quot;,&quot;abcd&quot;&#125;;
    System.out.println(Arrays.toString(array));
    Arrays.sort(array,newComparator());
    System.out.println(Arrays.toString(array));
&#125;
</code></pre>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code> 用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，也就意味着对应Lambda表达式需要”<strong>对外提供</strong>“一个符合泛型类型的对象数据</p>
<pre><code class="java">public class Demo08Supplier &#123;
    private static String getString(Supplier&lt;String&gt; function) &#123;
    return function.get();
&#125;
public static void main(String[] args) &#123;
    String msgA = &quot;Hello&quot;;
    String msgB = &quot;World&quot;;
    System.out.println(getString(() ‐&gt; msgA + msgB));
    &#125;
&#125;
</code></pre>
<h4 id="求数组元素最大值"><a href="#求数组元素最大值" class="headerlink" title="求数组元素最大值"></a>求数组元素最大值</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>使用 <code>Supplier</code> 接口作为方法参数类型，通过<code>Lambda</code>表达式求出int数组中的最大值。<br>提示：接口的泛型请使用 <code>java.lang.Integer</code> 类。</p>
<h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">public class Demo02Test &#123;
//定一个方法,方法的参数传递Supplier,泛型使用Integer
    public static int getMax(Supplier&lt;Integer&gt; sup)&#123;
    return sup.get();
&#125;
public static void main(String[] args) &#123;
    int arr[] = &#123;2,3,4,52,333,23&#125;;
    //调用getMax方法,参数传递Lambda
    int maxNum = getMax(()‐&gt;&#123;
    //计算数组的最大值
    int max = arr[0];
    for(int i : arr)&#123;
        if(i&gt;max)&#123;
     max = i;
     &#125;
    &#125;
     return max;
   &#125;);
    System.out.println(maxNum);
    &#125;
&#125;
</code></pre>
<h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><p><code>java.util.function.Consumer</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据， 其数据类型由泛型决定。</p>
<h5 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h5><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>, 意为消费一个指定泛型的数据</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; function)&#123;
    function.accept(&quot;Hello!&quot;);
&#125;
public static void main(String[] args) &#123;
    consumeString(s -&gt; System.out.println(s));
&#125;
</code></pre>
<h5 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h5><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的default方法 <code>andThen</code> 。下面是JDK的源代码：</p>
<pre><code class="java">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;
    Objects.requireNonNull(after);
    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;
&#125;
</code></pre>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 <code>andThen</code> 的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt;two)&#123;
        one.andThen(two).accept(&quot;hello&quot;);
&#125;

    public static void main(String[] args) &#123;
        consumeString(
                s-&gt; System.out.println(s.toUpperCase()),
                s -&gt; System.out.println(s.toLowerCase())
    );
&#125;
// 运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。
</code></pre>
<h4 id="格式化打印信息"><a href="#格式化打印信息" class="headerlink" title="格式化打印信息"></a>格式化打印信息</h4><h6 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h6><p> 下面的字符串数组当中存有多条信息，请按照格式“ <code>姓名：XX。性别：XX。</code>”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 <code>Consumer</code> 接口的Lambda实例，将打印性别的动作作为第二个 <code>Consumer</code>接口的Lambda实 例，将两个 <code>Consumer</code> 接口按照顺序“拼接”到一起。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot; &#125;;
&#125;
</code></pre>
<h6 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h6><pre><code class="java">import java.util.function.Consumer;
public class test &#123;
    private static void printInfo(Consumer&lt;String&gt;one, Consumer&lt;String&gt;two, String[] array)&#123;
        for (String info : array)&#123;
        one.andThen(two).accept(info);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;&#125;;
        printInfo(s-&gt; System.out.print(&quot;姓名:&quot;+s.split(&quot;,&quot;)[0]),
                  s-&gt; System.out.println(&quot;。性别：&quot;+s.split(&quot;,&quot;)[1]+&quot;。&quot;),
                  array
                  );
    &#125;
&#125;
</code></pre>
<h4 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h4><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code>java.util.function.Predicate</code> 接口。</p>
<pre><code class="java">public class Demo15PredicateTest&#123;
    private static void metho(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.test(&quot;HelloWorld&quot;);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &gt; 5);
    &#125;
&#125;
// 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。
</code></pre>
<h5 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h5><p>既然是条件判断，就会存在<strong>与、或、非</strong>三种常见的逻辑关系。其中将两个 <code>Predicate</code> 条件使用“与”逻辑连接起来实 现“<strong>并且</strong>”的效果时，可以使用default方法 and 。其JDK源码为：</p>
<pre><code class="java">defalult Predicate&lt;T&gt; and(Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) &amp;&amp; other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h5><pre><code class="java">defalult Predicate&lt;T&gt; or (Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) || other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：negate-“非”-取反"><a href="#默认方法：negate-“非”-取反" class="headerlink" title="默认方法：negate (“非”[取反])"></a>默认方法：negate (“非”[取反])</h5><pre><code class="java">default Predicate&lt;T&gt; negate()&#123;
    return (t) -&gt; !test(t);
&#125;
</code></pre>
<p>从现实中很容易看出，它是执行了test方法之后，对结果boolean值进行”!”取反而已。一定要在<code>test</code>方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样</p>
<pre><code class="java">public class Demo17PredicateNegate&#123;
    private static void methodW(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.negate().test(&quot;HelloWorld&quot;);
        System.out.println(&quot;字符串很长吗：&quot; + veryLong);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &lt; 5);
    &#125;
&#125;
</code></pre>
<h3 id="集合信息筛选"><a href="#集合信息筛选" class="headerlink" title="集合信息筛选"></a>集合信息筛选</h3><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>数组当中有多条“姓名+性别”的信息如下，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 <code>ArrayList</code> 中，需要同时满足两个条件：</p>
<blockquote>
<ol>
<li>必须为女生； </li>
<li>姓名为4个字。</li>
</ol>
</blockquote>
<pre><code class="java">public class DemoPredicate &#123;
    public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
    &#125;
&#125;
</code></pre>
<h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><pre><code class="java"> public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        List&lt;String&gt; list = filter(array,
                s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]),
                s -&gt; s.split(&quot;,&quot;)[0].length() == 4);
        System.out.println(list);
    &#125;
 private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       List&lt;String&gt; list = new ArrayList&lt;&gt;();
       for (String info : array)&#123;
           if (one.and(two).test(info))&#123;
               list.add(info);
           &#125;
       &#125;
       return list;
 &#125;
</code></pre>
<h4 id="Stream流高级改造"><a href="#Stream流高级改造" class="headerlink" title="Stream流高级改造"></a>Stream流高级改造</h4><pre><code class="java">public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        Arrays.stream(array)
                .filter(s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]))
            //  .filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;))
                .filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3)
                .forEach(System.out::println);
&#125;
</code></pre>
<h4 id="Stream流式思想改造"><a href="#Stream流式思想改造" class="headerlink" title="Stream流式思想改造"></a>Stream流式思想改造</h4><pre><code class="java"> public static void main(String[] args) &#123;
        Stream&lt;String&gt;original = Stream.of(&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; );
        Stream&lt;String&gt;result1 = original.filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;));
        Stream&lt;String&gt;result2 = result1.filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3);
        result2.forEach(System.out::println);
    &#125;
</code></pre>
<h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h4><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者成为后置条件。</p>
<h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p><code>apply Function</code> 接口中最主要的抽象方法为：<code>R apply(T t)</code> ，根据类型T的参数获取类型R的结果。 使用的场景例如：将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p>
<pre><code class="java">private static void method(Function&lt;String,Integer&gt; function)&#123;
     int num = function.apply(&quot;10&quot;);
     System.out.println(num + 10);
&#125;

public static void main(String[] args) &#123;
     method(s -&gt; Integer.parseInt(s));
&#125;
</code></pre>
<h4 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作</p>
<pre><code class="java">default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)&#123;
    Objects.requireNonNull(after);
    return (T t) -&gt; after.apply(apply(t));
&#125;
</code></pre>
<p>该方法同样用于“先做什么，再做什么”的场景，和 <code>Consumer</code> 中的 <code>andThen</code> 差不多：</p>
<pre><code class="java">public class Demo12FunctionAndThen &#123;
    private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
    public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
    &#125;
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。 </p>
<pre><code class="java">private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p>
<blockquote>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
</blockquote>
<h4 id="自定义函数模型拼接"><a href="#自定义函数模型拼接" class="headerlink" title="自定义函数模型拼接"></a>自定义函数模型拼接</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br> <code>String str = &quot;赵丽颖,20&quot;</code></p>
<p>1.将字符串截取数字年龄部分，得到字符串；<br>2.将上一步的字符串转换成为int类型的数字；<br>3.将上一步的int数字累加100，得到结果int数字。</p>
<h5 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">private static int getAgeNum(String str, Function&lt;String, String&gt;one, Function&lt;String, Integer&gt;two, Function&lt;Integer, Integer&gt; three)&#123;
    return one.andThen(two).andThen(three).apply(str);
&#125;

public static void main(String[] args) &#123;
    String str = &quot;赵丽颖,20&quot;;
    int age = getAgeNum(str,
         s -&gt; s.split(&quot;,&quot;)[1],
         s -&gt; Integer.parseInt(s),
         n -&gt; n += 100);
    System.out.println(age);
&#125;
</code></pre>
<h1 id="Stream流、方法引用"><a href="#Stream流、方法引用" class="headerlink" title="Stream流、方法引用"></a>Stream流、方法引用</h1><p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带 来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p>
<p>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现： </p>
<ul>
<li>for循环的语法就是“怎么做” </li>
<li>for循环的循环体才是“做什么”</li>
</ul>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从 第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p>
<p>试想一下，如果希望对集合中的元素进行筛选过滤：<br>1.将集合A根据条件一过滤为子集B；<br>2.然后再根据条件二过滤为子集C。</p>
<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</p>
<h4 id="Stream更优写法"><a href="#Stream更优写法" class="headerlink" title="Stream更优写法"></a>Stream更优写法</h4><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码 中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张无忌&quot;);
        list.add(&quot;周芷若&quot;);
        list.add(&quot;赵敏&quot;);
        list.add(&quot;张强&quot;);
        list.add(&quot;张三丰&quot;);
        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println);

    &#125;
</code></pre>
<blockquote>
<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素（或其地址值)。</p>
</blockquote>
<h5 id="Stream-流-是一个来自数据源的元素队列"><a href="#Stream-流-是一个来自数据源的元素队列" class="headerlink" title="Stream(流)是一个来自数据源的元素队列"></a>Stream(流)是一个来自数据源的元素队列</h5><ul>
<li>元素是特定类型的对象，形成一个队列。java中的stream并不会存储元素，而是按需计算</li>
<li><strong>数据源</strong>流的来源：可以是<strong>集合，数组</strong>等</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者增强for的方式，显示的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法<code>forEach(System.out::println)</code></li>
</ul>
<p>当使用一个流的时候，通常包括三个步骤：获取一个<strong>数据源(source) → 数据转换 → 执行操作获取想要的结果</strong>，每次转换原有Stream对象不改变，返回一个新的Stream对象(可以有多次转换)，这就允许对其操作可以像链条一样排列，变成一个管道</p>
<h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code>是最常用的流接口<br>获取方式：<br>**1.**所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流<br><strong>2.</strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流</p>
<h5 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h5><p>首先<code>java.util.Collection</code>接口中加入了default方法<code>stream</code>用来获取流，所以其所有实现类均可获取流</p>
<pre><code class="java">public static void main(String[] args) &#123;
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream1 = list.stream();

    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream2 = set.stream();

    Vector&lt;String&gt; vector = new Vector&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream3 = vector.stream();
    &#125;
</code></pre>
<h5 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h5><p><code>Java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分<strong>key、value</strong>或<strong>entry</strong>等情况：</p>
<pre><code class="java">public class Demo05GetStream &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        // ...
        Stream&lt;String&gt; keyStream = map.keySet().stream();
        Stream&lt;String&gt; valueStream = map.values().stream();
        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();
    &#125;
&#125;
</code></pre>
<h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <strong>Stream</strong> 接口中提供了静态方法 <strong>of</strong> ，使用很简单：</p>
<pre><code class="java">public static void main(String[] args) &#123;
     String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;;
     Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
<p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p>
<ul>
<li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li>
<li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li>
</ul>
<h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h3><p>虽然方法名字叫 <code>forEach</code>，但是与for循环中的“for-each”昵称不同。<br>该方法接收一个 <code>Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。</p>
<pre><code class="java">void forEach(Consumer&lt;? super ?&gt; action);  
</code></pre>
<h3 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h3><pre><code class="java">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。
Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。
    
import java.util.stream.Stream;
  public class Demo12StreamForEach &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        stream.forEach(name‐&gt; System.out.println(name));
    &#125;
&#125;
</code></pre>
<h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><p>可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。方法签名：</p>
<pre><code class="java">Stream&lt;T&gt; filer(Predicate&lt;? super T&gt; predicate);
</code></pre>
<p>该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<h3 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h3><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">boolean test(T t);
</code></pre>
<p>该方法会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的<code>filter</code>方法将会留用元素；如果结果为false，那么<code>filter</code>方法将会舍弃元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 filter 方法基本使用的代码如：</p>
<pre><code class="java">public class Demo07StreamFilter &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法</p>
<pre><code class="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);
</code></pre>
<p>该接口需要一个 <strong>Function</strong> 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<h3 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h3><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">R apply(T t);
</code></pre>
<p>这可以将一种T类型转换成R类型，这种转换的动作，叫做<strong>映射</strong></p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 <code>map</code> 方法基本使用的代码如：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;10&quot;,&quot;22&quot;,&quot;452&quot;);
    Stream&lt;Integer&gt; result = original.map(str -&gt; Integer.parseInt(str));
    result.forEach(System.out::println);
&#125;
</code></pre>
<p>这段代码中,<code>map</code> 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。</p>
<h3 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h3><p>正如旧集合 <code> Collection</code>  当中的 <code> size</code>  方法一样，流提供 <code> count</code>  方法来数一数其中的元素个数：</p>
<pre><code class="java">long count();
</code></pre>
<p>该方法返回一个long值代表元素个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    System.out.println(result.count()); // 2
&#125;
</code></pre>
<h3 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h3><p><code>limit</code> 方法可以对流进行截取，只取用前n个。方法签名</p>
<pre><code class="java">Stream&lt;T&gt; limit(long maxSize);
</code></pre>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用:</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.limit(2);
    result.forEach(System.out::println); // 张无忌 张三丰
    System.out.println(result.count()); // 2
    &#125;
&#125;
</code></pre>
<h3 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流：<br>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<pre><code class="java">public class Demo11StreamSkip &#123;
    public static void main(String[] args) &#123;
         Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
         Stream&lt;String&gt; result = original.skip(2);
         result.forEach(System.out::println); // 周芷若
&#125;
</code></pre>
<h3 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code> ：</p>
<pre><code class="java">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)
// 这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;);
    Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;);
    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);
    &#125;
&#125;
</code></pre>
<h3 id="集合元素处理-Stream方式）"><a href="#集合元素处理-Stream方式）" class="headerlink" title="集合元素处理(Stream方式）"></a>集合元素处理(Stream方式）</h3><h5 id="题目-Stream流式处理方式"><a href="#题目-Stream流式处理方式" class="headerlink" title="题目(Stream流式处理方式)"></a>题目(Stream流式处理方式)</h5><blockquote>
<p>第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；<br>第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人<br>将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。</p>
</blockquote>
<pre><code class="java">public class Person &#123;
    private String name;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class test &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; one = new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);

        List&lt;String&gt; two = new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);

        // 第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；
        Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == 3).limit(3);
        // 第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人；
        Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2);
        // 将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。
        Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);

    &#125;
&#125;
</code></pre>
<h3 id="Lambda方法引用"><a href="#Lambda方法引用" class="headerlink" title="Lambda方法引用"></a>Lambda方法引用</h3><p>请注意其中的<strong>双冒号 ::</strong> 写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p>
<pre><code class="java">简单的函数式接口以应用Lambda表达式:
@FunctionalInterface
public interface Printable &#123;
    void print(String str);
&#125;
</code></pre>
<pre><code class="java">private static void printString(Printable data)&#123;
    data.print(&quot;Hello, World!&quot;);
&#125;
public static void main(String[] args)&#123;
    printString(System.out::println);
&#125;
</code></pre>
<h3 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a><span style = "color:red">方法引用符</span></h3><h6 id="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑"><a href="#引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑" class="headerlink" title="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?"></a>引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?</h6><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。<u>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者</u>。</p>
<p>例如上例中， <code>System.out</code> 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li>
<li>方法引用写法：<code>System.out::println</code></li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 <code>System.out.println</code> 方法去处理。<br>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p>注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
<p><strong>三种主要使用情况：</strong></p>
<p>情况1：对象名::实例方法名<br>情况2：类名::静态方法名<br>情况3：类名::实例方法名</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yu411W77v/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【方法引用】Java语法中的双冒号::到底是啥意思？_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NK411f7Z5/?spm_id_from=333.788.recommend_more_video.1&vd_source=a4d980c3208d51858f08b3025a6ab2d9">lambda的双冒号是什么意思一个视频简简单单说清楚_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19W4y1W7G2/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【java面试技巧】双冒号之方法引用大家快来看看吧_哔哩哔哩_bilibili</a></p>
</blockquote>
<pre><code class="java">interface A&#123;
    int method(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        A a1 = str -&gt; Integer.valueOf(str);
        System.out.println(a1.method(&quot;111&quot;));

        A a2 = Integer::valueOf;
        System.out.println(a2.method(&quot;444&quot;));

        A a = new A() &#123; //因为A是接口所以直接new不了 加上大括号 匿名内部类
            @Override
            public int method(String str) &#123;
                return new Integer(str); //封装 拆箱
            &#125;
        &#125;;
        A a3 = Integer::new;
        System.out.println(a3.method(&quot;666&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p>
<pre><code class="java">@FunctionalInterface
public interface PrintableInteger &#123;
    void print(int str);
&#125;
-------------------------------------------------------------
public class Demo03PrintOverload &#123;
    private static void printInteger(PrintableInteger data) &#123;
        data.print(1024);
&#125;
public static void main(String[] args) &#123;
    printInteger(System.out::println);
&#125;
    // 这次方法引用将会自动匹配到 println(int) 的重载形式。
</code></pre>
<h4 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h4><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<pre><code class="java">@FuctionalInterface
public interface Calcable &#123;
    double calc(int num);
&#125;
</code></pre>
<pre><code class="java">private static void method(int num, Calcable lambda)&#123;
     System.out.println(lambda.calc(num));
&#125;

public static void main(String[] args) &#123;
     method(10, Math::sqrt);
    // method(‐10, n ‐&gt; Math.abs(n)); 舍弃
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式:  <code>n -&gt; Math.abs(n)</code></li>
<li>方法引用: <code>Math::abs</code></li>
</ul>
<h4 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<pre><code class="java">public interface Greetable &#123;
    void greet();
&#125;
</code></pre>
<p>然后是父类<code>Human</code>内容</p>
<pre><code class="java">public class Human &#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
</code></pre>
<p>最后是子类<code>Man</code>的内容，其中使用了Lambda写法</p>
<pre><code class="java">public class Man extends Human &#123;
    @Override
    public void sayHello() &#123;
        System.out.println(&quot;大家好，我是Man!&quot;);
    &#125;
    //定义方法method，参数传递Greetable接口
    public void method(Greetable g)&#123;
        g.greet();
    &#125;

    public void show()&#123;
        method(super::sayHello);
    &#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li><p>Lambda表达式： <code>() -&gt; super.sayHello()</code></p>
</li>
<li><p>方法引用： <code>super::sayHello</code></p>
</li>
</ul>
<h4 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用**<code>“this::成员方法”</code>**的格式来使用方 法引用。首先是简单的函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface Richable &#123;
    void buy();
&#125;
</code></pre>
<p>下面是一个丈夫 <code>Husband</code> 类：</p>
<pre><code class="java">public class Husband &#123;
    private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
    public void beHappy() &#123;
        marry(() ‐&gt; System.out.println(&quot;买套房子&quot;));
    &#125;
&#125;
</code></pre>
<p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对<code>Husband</code>丈夫类进行修改：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(() ‐&gt; this.buyHouse());
    &#125;
&#125;
</code></pre>
<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(this::buyHouse);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; this.buyHouse()</code> </li>
<li>方法引用： <code>this::buyHouse</code></li>
</ul>
<h4 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h4><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单 的<code>Person</code>类：</p>
<pre><code class="java">public class Person &#123;
    private String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p>
<pre><code class="java">public interface PersonBuilder &#123;
    Person buildPerson(String name);
&#125;
</code></pre>
<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo09Lambda &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
        System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, name ‐&gt; new Person(name));
    &#125;
&#125;
</code></pre>
<p><strong>但是通过构造器引用，有更好的写法：</strong></p>
<pre><code class="java">public class Demo10ConstructorRef &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
           System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, Person::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>name -&gt; new Person(name) </code></li>
<li>方法引用： <code>Person::new</code></li>
</ul>
<h4 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h4><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface ArrayBuilder &#123;
    int[] buildArray(int length);
&#125;
</code></pre>
<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo11ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, length ‐&gt; new int[length]);
    &#125;
&#125;
</code></pre>
<p>但是更好的写法是使用数组的构造器引用：</p>
<pre><code class="java">public class Demo12ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, int[]::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>length -&gt; new int[length] </code></li>
<li>方法引用： <code>int[]::new</code></li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/08/13/后端/java复习款/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/05/06/软考/软件设计师考点/">
        <h2>
            软件设计师考点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/5/6
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="考试占比"><a href="#考试占比" class="headerlink" title="考试占比"></a>考试占比</h1><p><img src="https://raw.githubusercontent.com/P-luminary/images/08dd53c87a8378186b9e41b70e12b5dbcf28801c/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%94.png" alt="考试占比"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5266e65404ade654c69fc2834998c5c959eda74/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%942.png" alt="考试占比2"></p>
<h1 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h1><p><strong>报名条件：</strong>凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可报考软件设计师。也就是说不限制考生的学历、专业、工作经验及年限、年龄等。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/98615.html">点击查看软件设计师报名条件详解</a>】</p>
<p><strong>报名时间：</strong>上半年一般在&#x3D;&#x3D;3月份报名&#x3D;&#x3D;，下半年在&#x3D;&#x3D;8月份报名&#x3D;&#x3D;，各地报名具体时间不一样，考生届时需要多留意当地报名时间。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x159_1.html">点击查看各地软件设计师报名时间</a>】</p>
<p><strong>考试时间：</strong>上半年一般是&#x3D;&#x3D;5月份开考&#x3D;&#x3D;，下半年一般是&#x3D;&#x3D;11月份开考&#x3D;&#x3D;<br>上午基础知识科目考试为9:00-11:30，下午应用技术科目考试时间为14:00-16:30</p>
<p><strong>报名方式：</strong>考生自己在当地规定时间内进入软考办官网，即中国计算机技术职业资格网的报名入口进行报名。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/105000.html">点击查看软件设计师报名入口</a>】</p>
<p><strong>报名费用：</strong>各地不同，一般在100-160元之间，具体以当地为准，其中辽宁不收取报名费(大连考区除外)【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x164_1.html">点击查看报名费用</a>】</p>
<p><strong>成绩查询：</strong>一般是考后40天左右公布成绩，成绩公布后大家可以在软考办官网进行查询</p>
<p><strong>考试证书：</strong>两科均通过分数线即可领取证书，各地领证时间不同，上半年证书一般集中在9-10月份发放，下半年证书一般集中在次年2-3月份发放。错过证书领取时间，证书由发证机构代为保管，考生可咨询相关领取事宜，但是超过5年没领取的证书将被销毁。软件设计师证书可以在中国计算机技术职业资格网和中国人事考试考试网的“证书查询”栏目进行查询。<strong>【</strong><a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x163_1.html"><strong>点击查看详情</strong></a><strong>】</strong></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>二进制转八进制 八进制转十六进制<br>二进制转十进制 (分权相乘 整数AND小数)<br>十进制转二进制 (短除法)</p>
<h5 id="原码-反码-补码-转码"><a href="#原码-反码-补码-转码" class="headerlink" title="原码 反码 补码 转码"></a>原码 反码 补码 转码</h5><p><em>负数</em></p>
<ul>
<li><h4 id="原码-数字首-负数为1-正数为0"><a href="#原码-数字首-负数为1-正数为0" class="headerlink" title="原码(数字首 负数为1 正数为0)"></a><strong>原码</strong>(数字首 <u>负数为1 正数为0</u>)</h4><ul>
<li>+9 &#x3D; **<span style = "color : red">0</span>**000 1001</li>
<li>-9 &#x3D;  **<span style = "color : red">1</span>**000 1001 </li>
<li>Min → 1111 1111 &#x3D; —127    </li>
<li>Max → 0111 1111 &#x3D; +127</li>
<li>缺点：<strong>0有两种表示方式：+0&#x3D;00000000    -0&#x3D;10000000</strong>[零的二义性给机器判断带来了麻烦] ****</li>
<li><strong><span style = "color : orange"><u>原码的数值0有两种表示方式 +0 -0</u></span></strong></li>
</ul>
<p>比如：1-2&#x3D;-3 → ∵ +1+(-2) → +1 -&gt; 0000 000$1_原$  ;  -2 -&gt; 1000 001$0_原$  </p>
<p>∴ 0000 0001 + 1000 0010 &#x3D; 1000 001$1_原$ &#x3D; -3</p>
<p>为了解决这个问题，科学家使用补码</p>
<p>-33的原码是 *<u><strong>1</strong>010 0001</u>* 反码是 <u><strong>1</strong>101 1110</u></p>
</li>
<li><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a><strong>反码</strong></h4><ul>
<li>原码的符号位不变，其余位取相反得到 </li>
<li>反码存在的意义就是为了由原码计算补码方便</li>
</ul>
</li>
<li><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a><strong>补码</strong></h4><ul>
<li>反码+1得到</li>
<li>优点</li>
</ul>
<p>1、<span style = "color : orange"><strong><u>在补码表示中，0有唯一的编码</u></strong> </span>0 &#x3D; 0000 0000</p>
<p>2、用10000000表示 -128，比原码可多表示一个编码</p>
<p>3、利用补码可以方便地进行运算</p>
</li>
</ul>
<p><em>正数</em></p>
<ul>
<li><strong>原码&#x3D;反码&#x3D;补码</strong></li>
</ul>
<p>☆☆ <strong><span style = "color : green">正数：正数的原码、反码、补码都一样</span></strong> ☆☆</p>
<p>☆☆ <strong><span style = "color : green">负数：负数将原码的符号位保持不变，数值位各位取反再末位加1，就可以将原码转换为补码</span></strong> ☆☆</p>
<p>@@ 计算机中常采用原码、反码、补码和移码表示数据，其中±0编码相同的是<strong>补码和移码</strong><del>[这里一定要考虑正数和负数]</del></p>
<p>@@ 负数-5在计算机中的补码是 ？</p>
<p><u><em><strong>直接从原码变补码、补码变原码</strong></em></u>  <span style = "color : red"><strong>口诀：从右向左复制，直到有1被赋值 其余取相反(<u>符号位 &#x3D;&gt; 第一位不变</u>)</strong></span></p>
<ul>
<li><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4></li>
</ul>
<p>一般运用于浮点运算中的阶码，在<u><strong>补码</strong>的基础上把<strong>首位取反</strong></u></p>
<table>
<thead>
<tr>
<th></th>
<th>数值1 (正数前三都相同)</th>
<th>数值-1</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td>0000 0001</td>
<td>1000 0001</td>
</tr>
<tr>
<td>反码</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>补码</td>
<td><strong>0</strong>000 0001</td>
<td>1111 1111</td>
</tr>
<tr>
<td>移码</td>
<td><strong>1</strong>000 0001</td>
<td>0111 1111</td>
</tr>
</tbody></table>
<h3 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h3><table>
<thead>
<tr>
<th></th>
<th>整数</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>反码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>补码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}$]   ~   2$^{(n-1)}-1$</strong></span>  [少占用一个+0 -0]</td>
</tr>
</tbody></table>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数表示：<br><strong>N &#x3D; M * $R^e$</strong><br>其中M称为<strong>尾数</strong>，e是<strong>指数</strong>，R为<strong>基数</strong></p>
<h6 id="步骤：对阶-→-尾数计算-→-结果格式化"><a href="#步骤：对阶-→-尾数计算-→-结果格式化" class="headerlink" title="步骤：对阶 → 尾数计算 → 结果格式化"></a>步骤：<u>对阶 → 尾数计算 → 结果格式化</u></h6><p><strong>小阶数</strong>朝着<strong>大阶数</strong>化<br>1000 + 119 &#x3D;&gt; 1.0 × 1$0^3$ + <u>1.19 × 1$0^2$</u> &#x3D;&gt;  1.0 × 1$0^3$ + 0.119 × 1$0^3$ &#x3D; 1.119 × 1$0^3$</p>
<p><strong>结果格式化</strong>：如果答案是 0.1119 × 1$0^3$ 把结果变成 1.119 × 1$0^2$<br>确保尾数的第一个位置不能是0, 也不能是1以上的；最多是一位</p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><p>&#x3D;&#x3D;<strong>硬件 &#x3D; 主机 + 外设</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>主机</strong> &#x3D; CPU (<u>CPU &#x3D; 运算器 + 控制器</u>) + <em>内存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>外设</strong> &#x3D; 输入设备 + 输出设备 + <em>外存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<u><strong>存储器</strong> &#x3D; 内存 + 外存</u>&#x3D;&#x3D;</p>
<blockquote>
<p><strong>运算器</strong>：<br>① 算术逻辑单元ALU<br>② 累加寄存器AC<br>③ 数据缓冲寄存器DR <u>[<strong>对内存储器读取的时候 有暂存的作用</strong>]</u><br>④ 状态条件寄存器PSW [<strong><u>存储运算过程中的标志位</u></strong><del>状态信息</del>]</p>
<p><strong>控制器</strong>：<br>① 程序计数器PC<br>② 指令寄存器IR<br>③ 指令译码器<br>④ 时序部件</p>
</blockquote>
<h3 id="计算机体系结构分类-—-Flynn"><a href="#计算机体系结构分类-—-Flynn" class="headerlink" title="计算机体系结构分类 — Flynn"></a>计算机体系结构分类 — Flynn</h3><table>
<thead>
<tr>
<th>体系结构类型</th>
<th>结构</th>
<th>关键特征</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>单指令流单数据流 SISD</td>
<td>控制部分：一个<br />处理器：一个<br />主存模块：多个</td>
<td></td>
<td>单处理器系统(单片机)</td>
</tr>
<tr>
<td>单指令流多数据流 SIMD</td>
<td>控制部分：一个<br />处理器：多个<br />主存模块：多个</td>
<td>各处理器以异步的形式执行同一条指令</td>
<td>并行处理机<br />阵列处理机<br />超级向量处理机</td>
</tr>
<tr>
<td>多指令流单数据流 MISD</td>
<td>控制部分：多个<br />处理器：一个<br />主存模块：多个</td>
<td>被证明不可能，至少是不实际</td>
<td>目前没有，有文献称流水线计算机为此类</td>
</tr>
<tr>
<td>多指令流多数据流 MIMD</td>
<td>控制部分：多个<br />处理器：多个<br />主存模块：多个</td>
<td>能够实现作业、任务、指令等各级全面并行</td>
<td>多处理系统<br />多计算机</td>
</tr>
</tbody></table>
<h3 id="CISC与RISC"><a href="#CISC与RISC" class="headerlink" title="CISC与RISC"></a>CISC与RISC</h3><table>
<thead>
<tr>
<th>指令系统类型</th>
<th>指令</th>
<th>寻址方式</th>
<th>实现方式</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>CISC(复杂)</td>
<td>数量多，使用<strong>频率</strong>差别大，可变长格式</td>
<td>支持多种</td>
<td>微程序控制技术(微码)</td>
<td>研制周期长</td>
</tr>
<tr>
<td>RISC(精简)<del>主流</del></td>
<td>数量少，使用频率接近，定长格式，大部分微单周期指令<br />操作寄存器，只有Load&#x2F;Store操作内存</td>
<td>支持方式少</td>
<td>大量增加了通用寄存器(增加速度)；<br />硬布线逻辑控制为主<br />适合采用流水线</td>
<td><strong>优化编译，有效支持高级语言</strong></td>
</tr>
</tbody></table>
<p>CISC(Complex Instruction Set Computer, 复杂指令集计算机) 进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大而复杂。</p>
<p>RISC(Reduced Instruction Set Computer, 精简指令集计算机) 通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译，提高指令的执行速度，采用硬线控制逻辑，优化编译程序。</p>
<h3 id="流水线-计算-运用于工业-可节省时间"><a href="#流水线-计算-运用于工业-可节省时间" class="headerlink" title="流水线(计算)[运用于工业 可节省时间]"></a>流水线(计算)[运用于工业 可节省时间]</h3><p>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理事针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</p>
<p>执行一条指令分为 <strong>取指</strong> → <strong>分析</strong> → <strong>执行</strong></p>
<h6 id="未使用流水线执行指令情况"><a href="#未使用流水线执行指令情况" class="headerlink" title="未使用流水线执行指令情况"></a>未使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
<th>2</th>
<th></th>
<th></th>
<th>3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
</tr>
</tbody></table>
<h6 id="使用流水线执行指令情况"><a href="#使用流水线执行指令情况" class="headerlink" title="使用流水线执行指令情况"></a>使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>流水线周期<del>取指+分析+执行</del>为运算时间最长的一段</strong></li>
<li><strong><u>流水线运算时间</u>计算公式为：</strong><br><span style = "color : red"><strong>①条指令运算总时长 + (指令条数-1) × 流水线周期</strong></span><br>① 理论公式：**(t1 + t2 +…+ t<del>k</del>) + (n - 1) × △t**<br>② 实践公式：**(k + n-1) × △t**</li>
</ul>
<h6 id="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？"><a href="#若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？" class="headerlink" title="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？"></a>若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？</h6><table>
<thead>
<tr>
<th>取指</th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>.</strong></th>
<th><strong>.</strong></th>
<th><strong>n</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分析</strong></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
<td></td>
</tr>
<tr>
<td><strong>执行</strong></td>
<td></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
</tr>
</tbody></table>
<p>答：1.<u>周期最长的时间是2ns，所以流水线周期是2ns</u><del>每一个流水线的周期就会完成一条指令的运行</del><br>2.<strong>(2+2+1) + (100-1) × 2 &#x3D; 203</strong><del>理论公式①计算</del>  &#x2F;  <strong>[3<del>分三段</del>+ (100 - 1) ] × 2 &#x3D; 204</strong><del>实践公式②计算</del></p>
<ul>
<li><p><strong>流水线吞吐率计算</strong><br>是指在单位时间内流水线所完成的任务数量或输出的结果数量。</p>
<p>流水线吞吐率基本公式：<span style = "color : red"><strong>TP &#x3D; $\frac{指令条数}{流水线运算时间}$</strong></span><br>流水线最大吞吐率：<span style = "color : red"><strong>TP<del>max</del> &#x3D; Lim<del>n→∞</del>$\frac{n}{(k+n-1)△t}$&#x3D;$\frac{1}{△t}$</strong></span></p>
</li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D; 可以算出 TP &#x3D; $\frac{100}{203}$; TP<del>max</del> &#x3D;  $\frac{1}{2}$</p>
<ul>
<li><strong>流水线加速度比</strong><br>是指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比<br><span style = "color : red"><strong>S &#x3D; $\frac{不使用流水线执行时间}{使用流水线执行时间}$</strong></span></li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D;<br>不使用流水线执行时间：(2+2+1) × 100 &#x3D; 500<del>ns</del><br>使用流水线执行时间：203<del>ns</del><br>S &#x3D; $\frac{500}{203}$</p>
<ul>
<li><strong>流水线的效率</strong><br>是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比<br><span style = "color : red"><strong>E &#x3D; $\frac{n个任务占用的时空区}{k个流水段总的时空区}$ &#x3D; $\frac{T<del>0</del>}{KT<del>k</del>}$</strong></span></li>
</ul>
<h6 id="入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出"><a href="#入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出" class="headerlink" title="入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出"></a>入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出</h6><blockquote>
<p>↑ 此方法效率不高，因为在S4所需要的时间太长，导致其他的会遭到空闲状态</p>
</blockquote>
<p>横轴是时间△t；纵轴是空间</p>
<table>
<thead>
<tr>
<th>S4</th>
<th></th>
<th></th>
<th></th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S3</strong></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S2</strong></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S1</strong></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>n个任务占用的时空区：(△t + △t + △t + 3△t) × 4<br>k个流水段总的时空区：15△t × 4<br>E &#x3D; $\frac{(△t + △t + △t + 3△t) × 4}{15△t × 4}$</p>
<h2 id="层次化存储结构"><a href="#层次化存储结构" class="headerlink" title="层次化存储结构"></a>层次化存储结构</h2><p>容量最下层的最大 向上依次递减</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0a35815053da0e6c476e3a1dc86a1aa4bec7233f/data/%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p>
<h3 id="Cache-—-概念"><a href="#Cache-—-概念" class="headerlink" title="Cache — 概念"></a>Cache — 概念</h3><p>Cache的功能：提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即<strong>CPU</strong>与<strong>存储系统</strong>间<u>数据传送带宽限制</u>。<br>在计算机的存储系统体系中，Cache是访问速度最快的层次<br>使用Cache改善系统性能的依据是程序的<strong>局部性原理</strong></p>
<p>如果以<u>h代表对Cache的访问命中率</u>，<u>t<del>1</del>表示Cache的周期时间</u>，<u>t<del>2</del>表示主存储器周期时间</u>，以读操作为例，使用”<strong>Cache + 主存储器</strong>“的系统的平均周期为t<del>3</del>，则 <span style = "color : red"><strong>t<del>3</del> &#x3D; h × t<del>1</del> + (1 - h) × t<del>2</del></strong></span>，其中(1-h)又称为失效率(未命中率)<br>若h&#x3D;95%, t<del>1</del>&#x3D;1ns, t<del>2</del>&#x3D;1ms&#x3D;1000ns  &#x3D;&#x3D;&#x3D;&gt;  t<del>3</del> &#x3D; 1ns × 95% + (1 - 95%) × 1000ns &#x3D; 50.95ns</p>
<blockquote>
<p>CPU在读取数据中首先对Cache中读取，如果读到了则表示对该数据的命中，如果Cache中没有我们需要的数据，CPU会在内存里去调</p>
</blockquote>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><blockquote>
<p>时间局部性<br>空间局部性(<u>适用于数组</u>)<br>工作集理论：工作集是进程运行时被频繁访问的页面集合<del>短时间不被替换成cache</del></p>
</blockquote>
<pre><code class="java">int i, s = 0;  ==&gt;  全局变量直接调用Cache
for(i = 1; i &lt; 1000; i++)   ==&gt; 在内存中循环100w次
    for(j = 1; j &lt; 1000; j++)
        s+=j;
cout &lt;&lt; s &lt;&lt; end;
</code></pre>
<h3 id="内存-外存"><a href="#内存-外存" class="headerlink" title="内存+外存"></a>内存+外存</h3><ul>
<li><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li>ROM<del>BIOS</del> 只读存储器<br>ROM-Read Only Memory只读存储器。断电后信息不丢失，如计算机启动用的BIOS芯片。<br>MROM(Mask ROM, 掩模式ROM)<br>PROM 可编程只读存储器<br>EPROM 可擦写可编程只读存储器<br>EEPROM 点可擦可编程只读存储器<br>Flash Memory 闪存 ≈ SSD</li>
<li>RAM随机存储器<br>DRAM(动态存储器) 不断刷新 速度比SRAM慢 价格低 常用于主存储器<br>SRAM(静态存储器 ) 不需刷新 速度比DRAM快 价格贵  cache属于SRAM<br> <u>CPU → <strong>Cache</strong> → 内存 → 外存</u></li>
</ul>
</li>
<li><h4 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h4><ul>
<li>硬盘：<strong>机械硬盘</strong>HDD(SATA、IDE、SCSI接口)    <strong>固态硬盘</strong>SSD(SATA接口)</li>
<li>光盘：CD&#x2F;VCD：650MB、CD-ROM(只读光盘)、CD-R(一次性写入、永久读)、CD-RW(可重复擦写光盘)<br>DVD：4.7GB、DVD-ROM、DVD-R、DVD-RW</li>
</ul>
</li>
</ul>
<h3 id="主存-—-编址"><a href="#主存-—-编址" class="headerlink" title="主存 — 编址"></a><strong>主存 — 编址</strong></h3><p><strong>8 × 4 位的存储器 &#x3D;&#x3D;&gt; 8个地址空间，每一个存储空间存储了4个bit位的信息</strong></p>
<table>
<thead>
<tr>
<th>000 这一存储空间</th>
<th>存放了4个</th>
<th>bit的</th>
<th>信息容量</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>010</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>011</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>110</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>111</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>@@ 内存地址从AC000H到C7FFFH，共有 <span style = "color : red"> <u><strong>1C000&#x2F; $2^{10}$</strong></u>&#x3D;112</span> <strong>K</strong>个地址单位<br>如果该内存地址按字(16bit)编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个内存单元，则该芯片每个存储单元存储  <span style = "color : red"><u><strong>4</strong></u></span> 位</p>
<blockquote>
<p>原理是后面地址-前面地址+1；  C7FFFH + 1 - AC000H &#x3D; 1C000H<br>K &#x3D; $2^{10}$B   &#x3D;&#x3D;&gt; 共有 1C000&#x2F; $2^{10}$&#x3D;112K 个地址单位</p>
<p>用一系列的芯片组成这样 <strong>112K×16<del>bit位</del></strong> 的内存块，需要28个芯片，每个芯片是16K个存储单元**$\frac{112K×16}{28×16K×a}$ &#x3D; 1**，比值是1因为用这些芯片去成立这个空间。解得a&#x3D;4</p>
</blockquote>
<h3 id="磁盘结构与参数"><a href="#磁盘结构与参数" class="headerlink" title="磁盘结构与参数"></a>磁盘结构与参数</h3><p><span style = "color : red"><strong>存取时间 &#x3D; 寻道时间 + 等待时间(平均定位时间 + 转动延迟)</strong></span><br>注意：<u><strong>寻道时间</strong></u>是指<strong>磁头</strong>移动到<strong>磁道</strong>所需的时间；<u><strong>等待时间</strong></u>为等待读写的<strong>扇区</strong>转到<strong>磁头</strong>下方所用的时间。</p>
<blockquote>
<ul>
<li>硬盘</li>
</ul>
<p><span style = "color : red">机械硬盘(<strong>HDD</strong>)</span>：存储介质 磁介质；参数：[主慈善]**磁(道)头数、柱面数、扇区(**硬盘的基本读写单位，大小是512B)；</p>
<p><strong>硬盘容量 &#x3D; 磁头数 * 柱面数 * 扇区数 * 512B</strong>；<br>性能指标：<u>存储容量、转速、访问时间、传输速率、缓存等</u>；<br>[硬盘内部结构按<strong>扇区、磁道、柱面</strong>的格式组织存储信息]</p>
<p>接口：SATA、<strong>IDE</strong>、SCSI、光纤通道</p>
<p><span style = "color : red">固态硬盘(<strong>SSD</strong>)</span>：存储介质(Flash Memory闪存) 接口 SATA等</p>
</blockquote>
<p>旋转的延迟时间是磁盘转一圈的时间</p>
<p>@@ 假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R<del>0</del>，R<del>1</del>，…… ，R<del>9</del>，R<del>10</del>存放在同一个磁道上，记录的存放顺序如下表所示：</p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
</tr>
</tbody></table>
<p>如果磁盘的旋转周期为33ms，磁头当前处在R<del>0</del>的开始处。若系统使用单缓存区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为<strong>366ms</strong>；若对信息存储进行优化分布后，处理11个记录的最少时间为<strong>66ms</strong></p>
<blockquote>
<p>一圈11个记录 转一圈33ms，则每个记录旋转的时间是3ms，读取一个记录的时间是3ms；告诉单缓存区，转到R0时处理R0需要3ms<del>因为是单缓存区，不能同时进行，必须等R0处理完成才能进入下一个任务处理[处理的途中磁盘仍在转动,磁头仍在向前]</del>，而一个记录正好也需要3ms，所以当处理完R0时，磁头已经到达了R2的位置，所以要再转一圈才能去处理R1，以此类推，除了最后一个R10就可以找到规律，<strong>把R0处理完，再等到指针走到R1的位置的时候转了<u>一圈加一条</u>记录的时间 &#x3D; [33+3] &#x3D; 36ms</strong>，以此类推R0 ~ R9都是这样处理的，所以处理R0~R9共需要 <strong>36ms × 10</strong>，最后一个R10，把它读取出来3ms，再处理完3ms。<strong>综上一共需要 (33+3)×10+6 &#x3D; 366ms</strong>；</p>
<p>优化处理：当处理完R0的时候，磁头正好下一位置是R1，而不用再去等它转动一个周期后；优化后的图为<strong>右侧图二</strong>！旋转+处理&#x3D;(3ms+3ms)×10<del>个</del>&#x3D;<strong>66ms</strong></p>
</blockquote>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>根据总线所处的位置不同，总线通常被分成三种类型，分别是：</p>
<h5 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h5><p>是指微机内部各个<strong>外围的芯片</strong>与<strong>处理器</strong>之间的总线 属于<u>芯片</u>级别</p>
<h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>是指各个<strong>插件板</strong>和<strong>系统板</strong>之间的总线  属于<u>插件版</u>级别</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>数据总线(DB)</strong></u>&#x3D;&#x3D;：用来传输数据信息 双向传输</li>
<li>&#x3D;&#x3D;<u><strong>地址总线(AB)</strong></u>&#x3D;&#x3D;：用来传输数据地址 单向传输</li>
</ul>
<p>地址总线的位数决定了CPU可直接寻址的内存空间大小</p>
<p>若地址总线为n位，寻址空间为2的n次方个B，如微机的地址总线为16位，则最大寻址空间为64KB</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>控制总线(CB)</strong></u>&#x3D;&#x3D;：用来传输控制信号</li>
</ul>
<h5 id="外部总线"><a href="#外部总线" class="headerlink" title="外部总线"></a>外部总线</h5><p>是指<strong>微机</strong>和<strong>外部设备</strong>的总线</p>
<h3 id="系统可靠性分析-—-串联系统与并联系统"><a href="#系统可靠性分析-—-串联系统与并联系统" class="headerlink" title="系统可靠性分析 — 串联系统与并联系统"></a>系统可靠性分析 — 串联系统与并联系统</h3><p>【<strong>串联</strong>】输入 → R1 → R2 → … → Rn → 输出<br><strong>R &#x3D; R1 × R2 × … × Rn</strong><br><strong>λ &#x3D; λ1 + λ2 + … + λn</strong></p>
<p>【<strong>并联</strong>】</p>
<blockquote>
<pre><code>     →R1
</code></pre>
<p>输入 →R2 → 输出<br>         →Rn</p>
</blockquote>
<p><strong>R &#x3D;  1 - (1 - R1) × (1 - R2) × … × (1 - Rn)</strong><br>**μ &#x3D; **$\frac{1}{\frac{1}{λ}\quad\sum_{j&#x3D;1}^{n}\frac{1}{j}}$</p>
<p>【<strong>模冗余系统与混合系统</strong>】</p>
<blockquote>
<p>​         →R1  →↓</p>
<p>输入 →R2   →     表决器  → 输出</p>
<p>​         →Rm →↑</p>
</blockquote>
<p>**R &#x3D; **$\quad\sum_{j&#x3D;1}^{n}{C{^j}{_m}×R{<em>0}{^i}(1-R</em>{0})^{m-i}}$</p>
<p>【<strong>串并联</strong>】</p>
<blockquote>
<p>​           |—  R  —|         |—R—|<br>—R —|—  R  —|—— |           |——<br>​           |—  R  —|         |—R—|</p>
</blockquote>
<p><strong>R×(1-(1-R$)^3$×(1-(1-R$)^2$))</strong></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h6 id="什么是码距？"><a href="#什么是码距？" class="headerlink" title="什么是码距？"></a>什么是码距？</h6><p>一个编码系统的码距是整个编码系统中任意(所有)两个码字的最小距离<br>例：<br>若用1位长度的二进制编码。若A&#x3D;1，B&#x3D;0。这样A,B之间的最小码距为1<br>若用2位长度的二进制编码。若以A&#x3D;11，B&#x3D;00为例，A,B之间的最小码距为2<br>若用3位长度的二进制编码。可选用111,000作为合法编码。A,B之间的最小码距为3<del>[检错可以进一步提高码距]</del></p>
<h6 id="码距与检错、纠错有何关系？"><a href="#码距与检错、纠错有何关系？" class="headerlink" title="码距与检错、纠错有何关系？"></a>码距与检错、纠错有何关系？</h6><p>① 在一个码组内为了检测e个误码, 要求最小码距d应该满足：d&gt;&#x3D;e+1<br>② 在一个码组内为了纠正 t个误码, 要求最小码距d应该满足：d&gt;&#x3D;2t+1</p>
<h3 id="校验码-—-循环冗余校验码CRC"><a href="#校验码-—-循环冗余校验码CRC" class="headerlink" title="校验码 — 循环冗余校验码CRC"></a>校验码 — 循环冗余校验码CRC</h3><h6 id="什么是模2除法？-异或运算相同为0-不同为1"><a href="#什么是模2除法？-异或运算相同为0-不同为1" class="headerlink" title="什么是模2除法？(异或运算相同为0,不同为1)"></a>什么是模2除法？(异或运算<del>相同为0,不同为1</del>)</h6><p>模2除法是指在做除法运算的过程中不计其进位的除法</p>
<blockquote>
<p>加0，多项式阶数为r(等于多项式位数减1)，则加r个0<br>eg：要发送数据1101011011，采用CRC校验，生成多项式10011(加四个0)，则最终发送数据为？<br>1101011011<strong>0000</strong> ÷ 10011 &#x3D;&gt; 采用异或运算<br>[待发送的信息补零 ÷ 多项式系数]<br>仅仅采用了CRC检验，如果检测到一个错误，则丢弃帧。缺重传机制，数据链路层的传输还不是可靠的传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/301330a9af198935e53042758004cd173c401f95/data/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81.jpg"><br><span style = "color : red"><u>CRC编码 &#x3D; <strong>原始报文</strong> 后面补上 <strong>CRC校验码</strong></u></span><br><strong>注意：最后得到的位数必然是校验码位数，不够的需要补0</strong><br>这里得到的结果是11，但是需要凑位数，所以<strong>校验码&#x3D;0011</strong></p>
</blockquote>
<h3 id="校验码-—-海明校验码"><a href="#校验码-—-海明校验码" class="headerlink" title="校验码 — 海明校验码"></a>校验码 — 海明校验码</h3><p>求信息1011的海明码[<strong>$2^r$ ≥ 4<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong>]<br>①<strong>n+r</strong>个数 有 <span style = "color : red"><strong>$2^r$ ≥ n<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong></span>个错<br>确定校验码为3位：$2^3$ ≥ 4 + 3 + 1；分别放在$2^0$&#x3D;1、$2^1$&#x3D;2、$2^2$&#x3D;4 位<br><span style = "color : red">[校验位&#x2F;位置 $2^n$；奇偶校验(0√ 1×)；检验2位的错误, 纠正1位的错误]</span><br>② 列出校验位公式<br>7&#x3D;$2^2$+$2^1$+$2^0$，6&#x3D;$2^2$+$2^1$，5&#x3D;$2^2$+$2^0$，3&#x3D;$2^1$+$2^0$<br>$r_2$&#x3D;$I_4$⊕$I_3$⊕$I_2$<br>$r_1$&#x3D;$I_4$⊕$I_3$⊕$I_1$<br>$r_0$&#x3D;$I_4$⊕$I_2$⊕$I_1$<br>③ 根据公式得<strong>r<del>2</del>&#x3D;0，r<del>1</del>&#x3D;0，r<del>0</del>&#x3D;1</strong><br>④ 将数据加入表格</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>I<del>4</del></td>
<td>I<del>3</del></td>
<td>I<del>2</del></td>
<td></td>
<td>I<del>1</del></td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>r<del>2</del></td>
<td><strong>1</strong></td>
<td>r<del>1</del></td>
<td>r<del>0</del></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>1</td>
<td>校验位</td>
</tr>
</tbody></table>
<blockquote>
<h6 id="求信息1010海明校验码"><a href="#求信息1010海明校验码" class="headerlink" title="@@ 求信息1010海明校验码"></a>@@ 求信息1010海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; 4+r+1&#x3D;&gt; r&#x3D;3   &#x3D;&#x3D;&gt; n+r&#x3D;4+3&#x3D;7 下列表画7列<br>$2^n $&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
<td>二进制</td>
</tr>
<tr>
<td>P<del>1</del>($2^0$)</td>
<td>P<del>2</del>($2^1$)</td>
<td><strong>1</strong></td>
<td>P<del>3</del>($2^2$)</td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong> ↑</td>
<td><strong>0</strong> ↑</td>
<td>1</td>
<td>**1 **↑</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1<del>寻找位数二进制后尾是1的</del> &#x3D;&gt; ③⑤⑦ &#x3D;&gt; 1⊕0⊕0 &#x3D;&gt; 1<br>P2<del>第二位有1</del> &#x3D;&gt; ③⑥⑦ &#x3D;&gt; 1⊕1⊕0 &#x3D;&gt; 0<br>P3<del>最高位有1</del> &#x3D;&gt; ⑤⑥⑦ &#x3D;&gt; 0⊕1⊕0 &#x3D;&gt; 1<br>故海明码：101<strong>1010</strong></p>
</blockquote>
<blockquote>
<h6 id="求信息D8—D1的10101011海明校验码"><a href="#求信息D8—D1的10101011海明校验码" class="headerlink" title="@@ 求信息D8—D1的10101011海明校验码"></a>@@ 求信息D<del>8</del>—D<del>1</del>的10101011海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; n&#x3D;8, 解得r&#x3D;4; 一共要画8+4&#x3D;12列<br>r&#x3D;4 &#x3D;&#x3D;&gt; $2^n$&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>⑫</th>
<th>⑪</th>
<th>⑩</th>
<th>⑨</th>
<th>⑧</th>
<th>⑦</th>
<th>⑥</th>
<th>⑤</th>
<th>④</th>
<th>③</th>
<th>②</th>
<th>①</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1100</td>
<td>1011</td>
<td>1010</td>
<td>1001</td>
<td>1000</td>
<td>0111</td>
<td>0110</td>
<td>0101</td>
<td>0100</td>
<td>0011</td>
<td>0010</td>
<td>0001</td>
<td>二进制</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>P<del>4</del>($2^3$)</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>P<del>3</del>($2^2$)</td>
<td>1</td>
<td>P<del>2</del>($2^1$)</td>
<td>P<del>1</del>($2^0$)</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1 &#x3D;&gt; ③⑤⑦⑨⑪ &#x3D;&gt; 1⊕1⊕1⊕0⊕0 &#x3D;&gt; 1<br>P2 &#x3D;&gt; ③⑥⑦⑩⑪ &#x3D;&gt; 1⊕0⊕1⊕1⊕0 &#x3D;&gt; 1<br>P3 &#x3D;&gt; ⑤⑥⑦⑫ &#x3D;&gt; 1⊕0⊕1⊕1 &#x3D;&gt; 1<br>P4 &#x3D;&gt; ⑨⑩⑪⑫ &#x3D;&gt; 0⊕1⊕0⊕1 &#x3D;&gt; 0<br>故海明校验码为：1010<strong>0</strong>101<strong>1</strong>1<strong>11</strong></p>
</blockquote>
<h3 id="操作系统基本原理"><a href="#操作系统基本原理" class="headerlink" title="操作系统基本原理"></a>操作系统基本原理</h3><h5 id="操作系统-—-概述："><a href="#操作系统-—-概述：" class="headerlink" title="操作系统 — 概述："></a>操作系统 — 概述：</h5><ul>
<li>管理系统的硬件、软件、数据资源</li>
<li>控制程序运行</li>
<li>人机之间的接口</li>
<li>应用软件与硬件之间的接口[API接口]</li>
</ul>
<p><strong>操作系统 — 管理职能：</strong></p>
<ul>
<li>进程管理<ul>
<li>进程的状态</li>
<li><strong>前趋图</strong></li>
<li><strong>PV操作</strong></li>
<li>死锁问题</li>
</ul>
</li>
<li>存储管理<ul>
<li><strong>段页式存储</strong></li>
<li>页面置换算法</li>
</ul>
</li>
<li>文件管理<ul>
<li>索引文件</li>
<li><strong>位示图</strong></li>
</ul>
</li>
<li>作业管理</li>
<li>设备管理</li>
<li>微内核操作系统<ul>
<li>虚设备与SPOOLING技术</li>
</ul>
</li>
</ul>
<p>所属范围：<strong>应用程序</strong>【<strong>语言处理程序</strong>{<strong>操作系统</strong>[计算机硬件]}】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/66ab60b30acd298347efc9b06e3be945f99ebeea/data/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="三态→五态，时间片轮转"></p>
<p><strong>进程管理 — 前趋图</strong></p>
<p>A:绞肉  B:切葱末  C:切姜末  D:搅拌  E:包饺子<br><strong>①</strong> A → B → C → D → E<br><strong>②</strong> A↘<br>     B → D → E<br>     C↗</p>
<p><strong>进程管理 — 进程的同步与互斥</strong></p>
<p><strong>互斥</strong>：千军万马过独木桥<br><strong>同步</strong>：(小明步行, 小红自行车从A到B点) 速度有差异，在一定情况停下等待<br><u>互斥反义词是共享，同步反义词是异步</u><br><strong><u>进程的互斥</u></strong>:是指当有若干个进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占用着释放了该资源。<br><strong><u>进程的同步</u></strong>:是指在并发进程之间存在这一种制约关系，一个进程依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才被唤醒。</p>
<h3 id="进程管理-—-PV操作"><a href="#进程管理-—-PV操作" class="headerlink" title="进程管理 — PV操作"></a>进程管理 — PV操作</h3><p>PV操作是一种实现进程互斥与同步的有效方法。PV操作与信号量的处理相关<br><strong>P表示通过的意思，V表示释放的意思</strong>。<br>P操作可以看作是<strong>获得</strong>或者<strong>请求、消耗</strong>一个信号量<br>V操作可以看作是<strong>释放</strong>或者<strong>发送</strong>一个信号量</p>
<blockquote>
<p><span style = "color : red">P操作会阻塞；</span><br><span style = "color : red">V操作会唤醒P操作；</span><br><span style = "color : red">P操作与V操作成对出现；</span></p>
<p>int f1&#x3D;0;   &#x2F;&#x2F;表示进程P1是否执行完毕</p>
<p>main()<br>{<br>    cobegin<br>    p1();</p>
<p>​    coend<br>}</p>
<p><strong>p1() {</strong><br>    <strong>…</strong><br>    <strong>v(f1);</strong><br>    <strong>v(f1);</strong><br><strong>}</strong></p>
</blockquote>
<p><strong>临界资源</strong>：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等。<br><strong>临界区</strong>：每个进程中访问临界资源的那段代码称为临界区<br><strong>信号量</strong>：信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</p>
<p><strong>P(S)操作：</strong>S-&#x3D;1  →  S&lt;0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行<br><strong>V(S)操作：</strong>S+&#x3D;1 →  S≤0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行</p>
<blockquote>
<p>P(S)、V(S)中的S就是信号量<br>T–进程操作阻塞（不会往下执行）<br>F–继续循环操作（执行下面的内容）</p>
</blockquote>
<h6 id="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"><a href="#单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0" class="headerlink" title="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"></a>单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0</h6><table>
<thead>
<tr>
<th>生产者：(先执行)</th>
<th>消费者：</th>
</tr>
</thead>
<tbody><tr>
<td>生产一个产品；</td>
<td><strong>P</strong>(S2);   [S2&#x3D;0]</td>
</tr>
<tr>
<td><strong>P</strong>(S1);   [S1&#x3D;0, S1&#x3D;-1]</td>
<td>从缓冲区取产品;</td>
</tr>
<tr>
<td>送产品到缓冲区;</td>
<td><strong>V</strong>(S1);</td>
</tr>
<tr>
<td><strong>V</strong>(S2);   [S2&#x3D;1]</td>
<td>消费产品;</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dfaac2ea85671c477f9008c1aa3dc70b68012a90/data/PV%E6%93%8D%E4%BD%9C%E4%BE%8B%E9%A2%98.png"></p>
<p>付款要双方的配合，会有同步的关系；假设没有这个操作；若先进行收银员操作，则没有购书者先购书，收银员无法操作。此时b1有个P操作，P操作需要付款V操作来唤醒；所以一开始的PV是同一信号量P(S1), V(S1)；对于购书者有个等待阻塞操作，等待收银员P(S2), V(S2)。【V(S1)唤醒P(S1)，收费后由收银员的V(S2)唤醒付款的P(S2)】<br>n+1个人进来的话会被阻塞。</p>
<blockquote>
<p>注意：<br>①P操作具备阻塞的职能，V操作不具备阻塞能力。<br>②PV操作关键要找到约束，找到谁是因变量，谁是自变量，谁约束谁。【PV操作是成对出现的】<br>③一对儿PV操作信号量是相同的。<br>看题发现已经存在了一对PV操作，信号量为Sn，Sn的值为n，很容易想到这对PV操作的作用就是控制进入书店的人数的。当人数达到n了，阻止人继续进入书店，这种状态直到有人付款离开书店为止。</p>
<p>再来看题发现还有两对PV操作，首先通过图能知道购书者和收银员之间存在约束关系，收银员要等待购书者付款才能工作，购书者要等待收银员反馈才能离开书店。那么这两对PV操作就是控制这个约束的。</p>
<p>先从购书者分析，购书者开始付款了，收银员才能开始收款，所以a1与b1之间是一对PV操作，进一步分析，如果没有购书者付款，那么收银员是不能执行收款操作的，也就是说收银员进程应该及时阻塞，故b1应该是P（S1）,a1应该是V（S1）。</p>
<p>购书者发起付款操作的时候，不能马上离开书店，因为他要等收银员的反馈，付款成功拿到 小票才能离开，也就是说购书者在等待收银员反馈的时候应该及时阻塞住，故a2与b2之间是一对PV操作，且a2是P（S2），对应的b2就是V（S2）。</p>
<p>再检查一遍看看是否合理呢？</p>
<p>从收银员角度开始，假设没有人付款，P操作能及时阻塞，使得收银员进程不会进入收费状态，所以b1位置放P操作没有问题，进一步分析信号量S1的初始值应该为0，经过b1后S1为-1，阻塞。</p>
<p>从购书者角度看，开始付款的时候激活收银员进程，所以a1是V操作也没有问题，通过a1的操作，S1信号量又为0了，收银员进程可以进行收费了。</p>
<p>再返回收银员角度，收费完毕后要给购书者信号，购书者从才能离开，所以b2为V操作没有问题。</p>
<p>从购书者角度看，a2应该是P操作，应该及时阻塞住。进一步分析，S2信号量也应该是0才符合要求。</p>
<p>😁总结<br>PV操作从做题的角度出发，我认为首先要找到约束关系，就是谁和谁是一对约束，第二步确定这对约束谁是P谁是V（用反证方法推一下看看），最后一步考虑信号量，信号量为多少取决于是否马上阻塞还是说执行几次后再阻塞，这个要结合具体问题具体分析。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">(53条消息) 软考必考题型之PV操作_pv操作中p和v各代表什么_du-hyper的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42539194/article/details/129647813?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&utm_relevant_index=6">(53条消息) 软考–快速掌握操作系统的PV操作_pv操作 软考_韦_恩的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f6094b2857a22777d38b9ed2362cf00c60b926a6/data/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86PV%E6%93%8D%E4%BD%9C.jpg"></p>
<p>箭头的起始位置是V操作，箭头的终止位置是P操作</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/45ad39c827d6c05d3e7d27552d3fd1a7313a574c/data/PV%2B%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%A4%A7%E9%A2%98.jpg"></p>
<h3 id="进程管理-—-死锁问题"><a href="#进程管理-—-死锁问题" class="headerlink" title="进程管理 — 死锁问题"></a>进程管理 — 死锁问题</h3><h6 id="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"><a href="#进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。" class="headerlink" title="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"></a>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</h6><p>资源都被分配且无法得到资源释放</p>
<p>例题：系统有3个进程：A、B、C。这3个进程都需要5个系统资源。如果系统至少有多少个资源，则不可能发生死锁[<u>有多少资源 无论怎么分配都不会产生死锁</u>]</p>
<table>
<thead>
<tr>
<th align="center">进程A</th>
<th align="center">进程B</th>
<th align="center">进程C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong><span style = "color : red">如果每个进程需要n个资源，总共有k个进程 &#x3D;&gt;分配情况：k × (n-1) + 1</span></strong><br>答：每个进程都需要5个资源，共有3个进程 &#x3D;&gt; n &#x3D; 5; k &#x3D; 3 &#x3D;&#x3D;&gt; 3 × (5 - 1) + 1 &#x3D; 12+1 &#x3D;13<br><img src="https://raw.githubusercontent.com/P-luminary/images/b65167c6d6f03ed5726ddd517ab0e89ec0df46c9/data/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98.jpg"></p>
<p>打破<strong>互斥</strong>：让大家同时共享资源<br>打破<strong>保持和等待</strong>：得不到相应的资源就会把资源分享出去，不会霸占并等待别人给与<br>打破<strong>不剥夺</strong>：不去抢别人分配到的资源</p>
<h4 id="银行家算法：分配资源的原则"><a href="#银行家算法：分配资源的原则" class="headerlink" title="银行家算法：分配资源的原则"></a>银行家算法：分配资源的原则</h4><p>√ 当一个进程对资源的最大需求量<strong>不超过</strong>系统重的资源数时可以接纳该进程<br>√ 进程可以<strong>分期请求</strong>资源，但请求的总数不能超过最大需求量<br>√ 当系统现有的资源不能满足尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源</p>
<p><strong>@@</strong> 例：假设系统中有三类互斥资源<strong>R1、R2、R3</strong>，可用资源数分别是<strong>9、8、5</strong>。在T<del>0</del>时刻系统中有<strong>P1、P2、P3、P4、P5</strong>五个进程，这些进程对资源的最大需求量和已分配资源数如下所示，如果进程按<strong>？</strong>序列执行，那么系统状态是安全的<del>不发生死锁</del><br>【列表口诀：<strong>现</strong> <strong>需要</strong> <strong>已</strong>(<u>蚁</u>)<strong>精</strong>(经)子来分娩】<br><strong>剩下的资源</strong>：总资源 — 已分配资源</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c9c14e04f67a7fd291fa566beaa4b0ee4506bb2/data/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.jpg"></p>
<p>A. P1→P2→P4→P5→P3                    <strong>B. P2→P4→P5→P1→P3</strong><br>C. P2→P1→P4→P5→P3                    D. P4→P2→P4→P1→P3</p>
<ul>
<li>若先不执行P2，先执行P1，则右图R1还需资源数还需要5个，则你R1剩下的2个不够分配到，会发生进程死锁。即第一个先执行 P2。</li>
<li>若先执行P2，再执行P1，则我们发现进程P1需要R1资源为5，我们能提供的R1资源为4，所以序列无法进行下去，为不安全序列<br>【<span style = "color :red">只要<strong>现有资源</strong>可以满足<strong>需要资源</strong>的分配即可True，执行完后释放资源给下一步进程使用</span>】</li>
</ul>
<h3 id="存储管理-—-分区存储组织"><a href="#存储管理-—-分区存储组织" class="headerlink" title="存储管理 — 分区存储组织"></a>存储管理 — 分区存储组织</h3><p>某计算机系统的内存大小为128k，采用可变分区分配进行内存分配，当前系统的内存分块情况如下图所示，现有<strong>作业4</strong>申请<strong>内存9k</strong>，几种不同的存储分配算法在分配中，会产生什么样的结果呢？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31409e62be82acbe02077d84d12e51f146d9948e/data/%E6%9C%80%E4%BD%B3-%E6%9C%80%E5%B7%AE-%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png"></p>
<p><strong>最佳适应算法</strong>：分配任务空间时。任务由闲余空间从小到大依次尝试是否能成功分配。若小闲余空间能分配就分配。不可则进入下一个闲余空间进行空间区域切割划分。<strong>缺陷</strong>：内存的碎块(<u>几k的闲余空间</u>)；<br><u><strong>最差适应算法</strong></u>：则逆过来表示(先考虑从大的块中分配出来)<br><strong>循环首次适应法</strong>：(分配较均匀)</p>
<h3 id="存储管理-—-页式存储组织"><a href="#存储管理-—-页式存储组织" class="headerlink" title="存储管理 — 页式存储组织"></a>存储管理 — 页式存储组织</h3><p><strong>逻辑地址</strong>的<strong>页号</strong>对应<strong>物理地址</strong>的<strong>块号</strong>(通过查表可得出)；其<strong>页内地址</strong>都是一样的(调用的时候以页为单位, 偏移量不会有太大的变化)</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4ac7b79184178af545b460f5427fe9c9cd5cb9c5/data/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>例：进程P有6个页面，页号分别为0-5，页面大小为4K，页面转换表如下所示。表中<u>状态位等于<strong>1</strong>和<strong>0</strong>分别表示页面在<strong>内存</strong>和<strong>不在内存</strong></u>。假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制(<strong>6A29H</strong>)；如果进程P要访问的页面4不在内存，那么应该淘汰页号为(<strong>1</strong>)的页面。</p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">页帧号</th>
<th align="center">状态位</th>
<th align="center">访问位</th>
<th align="center">修改位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>(1) A. 1A29H        B. 3A29H        C. 5A29H        D. 6A29H<br>(2) A. 0                  B. 1                  C. 2                 D. 5</p>
<p>4k &#x3D; 4×1024 &#x3D; 2$^{2+10}$ &#x3D; $2^{12}$ 说明一个页内地址是12位，高于12位的就是页号<br>由于进制P要访问的逻辑地址是十六进制5A29H，则一个十六进制位 &#x3D; 4个二进制位<br>说明有3个位是页内地址 &#x3D;&gt; A 2 9；所以页内地址无需求，是为A29<br>页号5需要查表观测它的页帧号是6；然后与后面拼接起来 为6A29H<br>将要淘汰的页号一定是在存在的里面选出 存在的才能淘汰，则1代表存在；<br>就要从页号0 1 2 5中淘汰一个，看其访问位，刚刚访问过的是1不能淘汰，<br>只能淘汰访问位是0的，综上所述，应该淘汰1页号</p>
<h3 id="存储管理-—-段式存储组织"><a href="#存储管理-—-段式存储组织" class="headerlink" title="存储管理 —  段式存储组织"></a>存储管理 —  段式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/540c15f503aa3e817771ddb1ace41a4d15c66015/data/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<h3 id="存储管理-—-段页式存储组织"><a href="#存储管理-—-段页式存储组织" class="headerlink" title="存储管理 — 段页式存储组织"></a>存储管理 — 段页式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/46c912294b0428ab3464f49e504e47de54ea3e01/data/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>先查段表 查完段表 查页表</p>
<h3 id="存储管理-—-快表"><a href="#存储管理-—-快表" class="headerlink" title="存储管理 — 快表"></a>存储管理 — 快表</h3><p><strong>快表</strong>是一块小容量的相联存储器(Associative Memory), 由高速缓存器组成，速度快，并且可以从硬件上保证<strong>按内容</strong>并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。<br>若将这些东西放在内存当中则称为慢表(放在内存)、快表(放在Cache)</p>
<h3 id="存储管理-—-页面置换算法-运用于分层的置换体系中"><a href="#存储管理-—-页面置换算法-运用于分层的置换体系中" class="headerlink" title="存储管理 — 页面置换算法(运用于分层的置换体系中)"></a>存储管理 — 页面置换算法(运用于分层的置换体系中)</h3><h5 id="页面淘汰算法"><a href="#页面淘汰算法" class="headerlink" title="页面淘汰算法"></a>页面淘汰算法</h5><h6 id="☆-最优-Optimal-OPT-算法"><a href="#☆-最优-Optimal-OPT-算法" class="headerlink" title="☆ 最优(Optimal, OPT) 算法"></a>☆ 最优(Optimal, OPT) 算法</h6><h6 id="☆-随机-RAND-算法"><a href="#☆-随机-RAND-算法" class="headerlink" title="☆ 随机(RAND) 算法"></a>☆ 随机(RAND) 算法</h6><h6 id="★-先进先出-FIFO-算法：有可能产生”抖动”"><a href="#★-先进先出-FIFO-算法：有可能产生”抖动”" class="headerlink" title="★ 先进先出(FIFO) 算法：有可能产生”抖动”"></a>★ 先进先出(FIFO) 算法：有可能产生”抖动”</h6><p>抖动：给你更多的资源去处理反而效率降低了<br>例如432143543215序列用3个页面，比4个缺页要少<br><strong>缺页</strong>：当加入内存中的页面序列是全新版本(内存中没有)，则内存内部需要这个版本，因为缺少这个版本<br>第八-九列 编号为4的程序页不缺页(没有往前推进的原因是因为内存中还存有4的残渣[第八列]；有3的残渣[第九列])</p>
<table>
<thead>
<tr>
<th align="center">(9次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">(10次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong>横向</strong>代表：访问的页面序列<br><strong>纵向</strong>代表：内存的几号页面(第一列是编号为4的程序页)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0f77ce658d321b83bdd0b8da87d540cf660ed92/data/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png"><u><strong>LRU</strong></u>：<strong>最近被访问的则不需要被淘汰，淘汰掉最久没有被访问到的</strong><br><u><strong>FIFO</strong></u>：先入先出原则</p>
<h6 id="★-最近最少使用-LRU-算法：不会”抖动”"><a href="#★-最近最少使用-LRU-算法：不会”抖动”" class="headerlink" title="★ 最近最少使用(LRU) 算法：不会”抖动”"></a>★ 最近最少使用(LRU) 算法：不会”抖动”</h6><p>根据局部性原理，刚刚访问过的资源是不会被淘汰出去的</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dcaa41c594fe86047d0f9cbc03a4e3c24c5e9fc/data/%E9%A1%B5%E9%9D%A2%E5%9E%84%E6%96%AD%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<p> <span style = "color : red"><strong>每读一次程序块，先在内存上面查一下表之后读取相应的内存块，所以每一个内存块需要进行两次内存的访问。总共有⑥个块，会产生12次内存的访问</strong></span></p>
<p>A块在2号页有一半，在3号页面也有一半。所以总的缺页次数是5次；<strong>对于指令而言</strong><del>无论占用几个块都会一次性调用</del>不会产生两次垄断，只有一次缺页垄断；∴swap A,B 一次；A上半页一次, 下半页一次；B上半页一次, 下半页一次；1+2+2&#x3D;5次；1k有1024个单元(字节)</p>
<h3 id="文件管理-—-索引文件结构"><a href="#文件管理-—-索引文件结构" class="headerlink" title="文件管理 — 索引文件结构"></a>文件管理 — 索引文件结构</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da6db0bd7d31c5a4b548e3631be05912cdbf38ec/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86.jpg"></p>
<p>一个物理盘块是1K大，一个地址4Byte，除一下，每一个盘块可以存256个地址;    ↓ ↓ ↓ ↓ ↓ ↓</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cebe816153cc666243ca77883f86b9ace46c311/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<p>File1的信息是<strong>二级地址索引表</strong> </p>
<h3 id="操作系统-—-文件和树型目录结构"><a href="#操作系统-—-文件和树型目录结构" class="headerlink" title="操作系统 — 文件和树型目录结构"></a>操作系统 — 文件和树型目录结构</h3><p><strong>文件属性</strong>：R 只读文件属性    A 存档属性    S 系统文件    H 隐藏文件<br><strong>文件名的组成</strong>：驱动号、路径、主文件名、扩展名<br><strong>绝对路径</strong>：是从盘符开始的路径<br><strong>相对路径</strong>：是从当前路径开始的路径<br>若当前目前位：D1，要求F2路径<br>则：<u>绝对路径</u>：&#x2F;D1&#x2F;W1&#x2F;F2； <u>相对路径</u>：W2&#x2F;F2</p>
<h3 id="文件管理-—-空闲存储文件的管理"><a href="#文件管理-—-空闲存储文件的管理" class="headerlink" title="文件管理 — 空闲存储文件的管理"></a>文件管理 — 空闲存储文件的管理</h3><p>空闲区表法(空闲文件目录)、空闲链表法、**<span style = "color : red">位示图法</span>**、成组链接法</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/b80648caa2ce4c11344f2775ce62ebd4b7af9161/data/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%BE%8B%E9%A2%98.jpg"></p>
<p>(1) (4195+1) &#x2F; 32 &#x3D; 131.125 ≈ 第132字<br>(2) 用物理块毫无疑问是要制成1的 所以AC排除，131×32&#x3D;4192 (0→4191)，故第132字中：<br>第0位置→4192   第1位置→4193  第2位置→4194  <strong>第3位置→4195</strong><br><span style = "color : red"><strong>第多少个字是从1开始算, 多少位置是从第0个位置开始算。</strong></span></p>
<blockquote>
<p>第1字         1 0 1 0 0 … 1 1<br>第2字         0 1 1    0 … 0 1<br>第3字         1 1 1 1 0 … 1 0<br>…                …<br>第n字         0 0 0 1 1 … 0 0</p>
</blockquote>
<h3 id="设备管理-—-数据传输控制方式"><a href="#设备管理-—-数据传输控制方式" class="headerlink" title="设备管理 — 数据传输控制方式"></a>设备管理 — 数据传输控制方式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d7d10e539675e94eff1c9c90dcb66f52e6ca4cfb/data/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png"></p>
<h3 id="设备管理-—-虚设备与SPOOLING技术"><a href="#设备管理-—-虚设备与SPOOLING技术" class="headerlink" title="设备管理 — 虚设备与SPOOLING技术"></a>设备管理 — 虚设备与SPOOLING技术</h3><p>要输出输入的先缓存起来(输入井 输出井)<br><img src="https://raw.githubusercontent.com/P-luminary/images/3d1b4c80871fa1aaf9cb194667a35cd042f75d8c/data/SPOOLING%E6%8A%80%E6%9C%AF.jpg"></p>
<h3 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/79a58babdadddeef05bc5890cacd0f3a27dd0d4b/data/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"></p>
<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><span style = "color : red">数据库系统</span></h1><h3 id="三级模式-—-两级映射"><a href="#三级模式-—-两级映射" class="headerlink" title="三级模式 — 两级映射"></a>三级模式 — 两级映射</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/896dd865381624663248207420b70d53681437e2/data/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E2%80%94%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84.jpg"></p>
<p><strong>内模式</strong>：管我们如何去存储这些数据 也叫存储模式，对应于<u>物理级</u><br>概念模式：表之间有一定的关联 逻辑模式 对应<u>概念级</u><br><strong>外模式</strong>：对应着数据库里的视图(对数据更灵活的控制) 子模式或用户模式，对应<u>用户级</u><br>期间都存在着映射(起到逻辑独立性&#x2F;物理独立性)</p>
<blockquote>
<p>什么是外模式？<br>    1）数据库的用户使用的局部数据的逻辑结构和特征的描述<br>    2）数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。（如应用程序A只能看见其相对于的外模式1，应用程序B只能看见其相对于的外模式2，不能看见不属于自己的外模式。相当于是模式的一个子集）</p>
<p>外模式的地位：介于模式与应用之间。</p>
<p>模式与外模式的关系：一对多<br>    1）外模式是模式的子集<br>    2）一个数据库可以有多个外模式，反应了不同的用户的应用需求、看待数据的方式、对数据保密的要求。<br>    3）对于模式中的同一个数据，不同外模式可以对数据的长度、类型等有不同的定义。</p>
<p>外模式与应用的关系：一对多。<br>    1）同一外模式可以为某一个用户的多个应用系统所使用<br>    2）但一个应用程序只能使用一个外模式</p>
<p>外模式的用途：<br>    1）保证数据库安全，每个用户只能看见自己对应外模式的数据<br>    2）保证数据独立性。</p>
<h4 id="总结-外模式是模式的一部分，是部分用户看到的数据库的样子。"><a href="#总结-外模式是模式的一部分，是部分用户看到的数据库的样子。" class="headerlink" title="总结:外模式是模式的一部分，是部分用户看到的数据库的样子。"></a><span style = "color : red"><strong>总结:外模式是模式的一部分，是部分用户看到的数据库的样子。</strong></span></h4></blockquote>
<blockquote>
<p>内模式：<br>    1）数据物理结构和存储方式的描述<br>    2）是数据在数据库内部的表示方式<br>    Ⅰ.记录的存储方式：如顺序存储，按B树结构存储，Hash存储）<br>    Ⅱ.索引的组织方式：B+树索引，hash索引，Join index索引<br>    Ⅲ.数据是否压缩存储<br>    Ⅳ.数据是否加密<br>    注：一个数据库只有一个内模式。</p>
<h4 id="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"><a href="#总结：内模式处于最底层，是对数据在数据库底层的存储的描述。" class="headerlink" title="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"></a><span style = "color : red"><strong>总结：内模式处于最底层，是对数据在数据库底层的存储的描述。</strong></span></h4></blockquote>
<h4 id="数据库特点："><a href="#数据库特点：" class="headerlink" title="数据库特点："></a>数据库特点：</h4><p>数据结构化、数据的共享、冗余度低、<strong>数据独立性高</strong>、数据由<strong>DBMS</strong>统一管理和控制</p>
<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cd0bd56ba2d79a742db12fc000df23ed6ed69281/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bf4edf231e68e25885a3339134cf79b21cf74c8/data/E-R%E6%A8%A1%E5%9E%8B.jpg"></p>
<p> <strong>概念模型</strong> 面向用户 用户角度出发 用户分析<br> <strong>逻辑结构&#x2F;模型</strong><br> <strong>物理结构&#x2F;模型</strong>(数据库对象) 跟计算机系统发生联系</p>
<p>主码：[也称住关键字，它能够唯一标识一个元组。码可以是一个属性或属性组]</p>
<p><strong>框框</strong>表示<strong>实体</strong>[客观存在并相互区别的事物]<br><strong>椭圆</strong>表示<strong>属性</strong>[实体所具有的特征]<br><strong>菱形</strong>表示<strong>联系</strong>[实体与实体之间的关系]<br>域：属性值的取值范围<br>实体型：用实体名及其属性名集合来描述同类实体也称为实体型 <strong>学生(<u>学号</u>, 姓名, 性别</strong>)<br>实体之间有各种各样的连信息(一对一联系1:1、一对多联系1:n、多对多联系m:n)</p>
<p>1个学生对应N个课程，1个课程对应M个学生；所以学生和课程是N:M的关系</p>
<h5 id="集成的方法："><a href="#集成的方法：" class="headerlink" title="集成的方法："></a>集成的方法：</h5><p>多个局部E—R图一次集成<br>逐步集成，用累加的方式一次继承两个局部E—R图</p>
<h5 id="集成产生的冲突及解决办法："><a href="#集成产生的冲突及解决办法：" class="headerlink" title="集成产生的冲突及解决办法："></a>集成产生的冲突及解决办法：</h5><p>属性冲突：包括属性域冲突和属性取值冲突<br>命名冲突：包括同名异义和异名同义<br>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E—R图中所包含的属性个数和属性排列次序不完全相同</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d8bb3486b6917b13f8c21e6c42f0f0ffb0fa797/data/E-R%E6%A8%A1%E5%9E%8B1.png"></p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h6 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h6><blockquote>
<p><strong>并 交 差 笛卡尔积 投影 选择 联接</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7999126ac896482aa27e523291f7266c74684484/data/%E5%B9%B6%20%E4%BA%A4%20%E5%B7%AE%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%20%E6%8A%95%E5%BD%B1%20%E9%80%89%E6%8B%A9%20%E8%81%94%E6%8E%A5.png"></p>
<h4 id="★★★★-考点-★★★★"><a href="#★★★★-考点-★★★★" class="headerlink" title="★★★★ 考点 ★★★★"></a><span style = "color : red">★★★★ 考点 ★★★★</span></h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/49278f5b4160686cf7931eeabcc2ffecca3f9b68/data/%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%92%8C%E8%87%AA%E7%84%B6%E8%81%94%E6%8E%A5.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="规范化理论—函数依赖"><a href="#规范化理论—函数依赖" class="headerlink" title="规范化理论—函数依赖"></a>规范化理论—函数依赖</h3><p> <img src="https://raw.githubusercontent.com/P-luminary/images/51a6a949e29af7425b4db2467e3cea8b9d472cb2/data/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg"></p>
<h3 id="规范化理论—价值与用途"><a href="#规范化理论—价值与用途" class="headerlink" title="规范化理论—价值与用途"></a>规范化理论—价值与用途</h3><p>非规范化的关系模式，可能存在的问题包括：<strong>数据冗余，更新异常，插入异常，删除异常</strong></p>
<p><strong>超键</strong>可能<u>存在</u>冗余属性<br><strong>候选键</strong><u>不存在</u>冗余属性</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eba44424461fb41231f3a2033809728876107800/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E2%80%94%E9%94%AE.jpg"></p>
<h3 id="规范化理论—求候选键"><a href="#规范化理论—求候选键" class="headerlink" title="规范化理论—求候选键"></a>规范化理论—求候选键</h3><p>√ 将关系模式的函数依赖关系用”<span style = "color : red"><strong>有向图</strong></span>“的方式表示<br>√ 找<span style = "color : red"><strong>入度为0</strong></span>的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键<br>√ 若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些<span style = "color : red"><strong>中间结点</strong></span>(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/fedbdbd44be93aebd7ee7900ac880b9bbf416ad6/data/%E6%B1%82%E5%80%99%E9%80%89%E9%94%AE%E5%AE%9E%E4%BE%8B.jpg" style="zoom:200%;" />



<h3 id="规范化理论—范式"><a href="#规范化理论—范式" class="headerlink" title="规范化理论—范式"></a>规范化理论—范式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7c4039b8889ccba887966fa6a9419576d19fb759/data/%E8%8C%83%E5%BC%8F.png"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/d909de9417c222c51a54a62215b672b44c27c50b/data/%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E.jpg"  />



<p><strong>主属性</strong>(SNO CNO)：属性属于候选键的一部分 (在任何一个<strong>候选关键字</strong>里出现过的都是<strong>主属性</strong>)<br>没有<strong>非主属性</strong> 肯定满足<strong>第二范式</strong>和<strong>第三范式</strong></p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4d428c01728bc74188f07efc4e3ccdf9c7477f1f/data/b-C%E8%8C%83%E5%BC%8F.jpg"></p>
<h3 id="规范化理论—综合例题"><a href="#规范化理论—综合例题" class="headerlink" title="规范化理论—综合例题"></a>规范化理论—综合例题</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5d9b49971208e067131389f48c469365519fdad6/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E7%BB%BC%E5%90%88%E4%BE%8B%E9%A2%98.png"  />



<h3 id="规范化理论—模式分解"><a href="#规范化理论—模式分解" class="headerlink" title="规范化理论—模式分解"></a>规范化理论—模式分解</h3><p>当范式级别不够的时候把模式进行拆分 这样范式级别就可以上升<br><img src="https://raw.githubusercontent.com/P-luminary/images/8de9f7295722d81e08fbcd3d1d5e24ab6b1c61cc/data/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3.png"  /></p>
<h3 id="并发控制—基本概念"><a href="#并发控制—基本概念" class="headerlink" title="并发控制—基本概念"></a>并发控制—基本概念</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6fcaefdeb1c71e5d4f06a4792ef956c1ed146d3c/data/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h3><p><strong>√ 实体完整性约束</strong>：约束主键(<u>主键为空 没有输入具体值</u>)<br><strong>√ 参照完整性约束</strong>：填入的数据必须是按照表里主键的内容(允许为空)<br><strong>√ 用户自定义完整性约束</strong>：(年龄不允许输入负数 或者200以上的值)</p>
<p>√ <strong>触发器</strong>(较复杂的要求)：可以写脚本来约束数据库数据的要求</p>
<h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><table>
<thead>
<tr>
<th>措施</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>用户标识和鉴定</td>
<td>最外层的安全保护措施，可以使用用户账户，口令及随机数检验等方式</td>
</tr>
<tr>
<td>存取控制</td>
<td>对用户进行授权，包括操作类型(如<strong>查找, 插入, 删除, 修改</strong>等动作)和数据对象(主要是<strong>数据范围</strong>)的权限</td>
</tr>
<tr>
<td>密码存储和传输</td>
<td>对远程终端信息用密码传输</td>
</tr>
<tr>
<td>视图的保护</td>
<td>对视图进行授权</td>
</tr>
<tr>
<td>审计</td>
<td>使用一个专用文件(日志)或数据库，自动将用户对数据库的所有操作记录下来</td>
</tr>
</tbody></table>
<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p><strong>√ 冷备份</strong>也称为静态备份，是将数据库正常关闭，在停止状态，将数据库的文件全部备份(复制)下来。<br><strong>√ 热备份</strong>也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来 </p>
<table>
<thead>
<tr>
<th align="left">备份方式 &#x2F; 优缺点</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冷备份</td>
<td align="center">非常快速的备份方法只需要复制文件；容易归档(简单复制即可)；容易恢复到某个时间点上(只需要将文件再复制回去)；能与归档方法相结合，做数据库”最佳状态“的恢复；低度维护，高度安全</td>
<td align="center">单独使用时，只能提供到某一个时间点上的恢复；再实施备份的全过程中，数据库必须要作备份二不能做其他工作；若磁盘空间有限只能复制到磁带等其他外部存储设备上，速度会很慢；不能按表或按用户恢复</td>
</tr>
<tr>
<td align="left">热备份</td>
<td align="center">可再表空间或数据库文件级备份，备份的时间短；备份时数据库仍可使用；可达到秒级恢复(恢复到某一时间点上)；可对几乎所有数据库实体做恢复；恢复是快速的</td>
<td align="center">不能出错，否则后果严重；如我热备份不成功所得结果不可用于时间点的恢复；因难于维护，所以要特别小心，不允许”以失败告终“</td>
</tr>
</tbody></table>
<p><strong>√ 完全备份：</strong>备份所有数据<br><strong>√ 差量备份：</strong>仅备份上一次完全备份之后变化的数据<br><strong>√ 增量备份：</strong>备份上一次备份之后变化的数据</p>
<table>
<thead>
<tr>
<th align="center">日</th>
<th align="center">一</th>
<th align="center">二</th>
<th align="center">三</th>
<th align="center">四</th>
<th align="center">五</th>
<th align="center">六</th>
</tr>
</thead>
<tbody><tr>
<td align="center">完</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">差</td>
<td align="center">增</td>
<td align="center">增</td>
</tr>
</tbody></table>
<p>若在周一的增量备份后系统出现故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一增量版</strong><br>如果周三的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一周二周三增量版</strong><br>这样恢复太麻烦，所以提出了<strong>差量备份</strong>, <strong>周四</strong>的差量备份直接针对<strong>周日的差量变化</strong><br>如果周四的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周四的差量版</strong></p>
<ul>
<li><p><strong>静态海量存储</strong>：在系统中无运行事务时进行, 每次存储全部数据库</p>
</li>
<li><p><strong>静态增量存储</strong>：在系统中无运行事务时进行，每次只存储上一个转储后更新过的数据库</p>
</li>
<li><p><strong>动态海量存储</strong>：转储期间允许对数据库进行存取或修改，每次转储全部数据库</p>
</li>
<li><p><strong>动态增量转储</strong>：转储期间允许对数进行存取或修改，每次只转储上一次转储后更新过的数据</p>
</li>
</ul>
<p>日志文件：事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作(增删改查)，并将记录结果保存在独立的 (<u>先写日志 再写数据文件</u>)</p>
<table>
<thead>
<tr>
<th align="center">故障关系</th>
<th align="center">故障原因</th>
<th align="center">解决办法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务本身的可预期故障</td>
<td align="center">本身逻辑</td>
<td align="center">再程序中预先设置Rollback语句</td>
</tr>
<tr>
<td align="center">事务本身的不可预期故障</td>
<td align="center">算数溢出, 违反存储保护</td>
<td align="center">由DBMS的恢复子系统通过日志,撤销事务对数据库的修改,回退到事务初始状态</td>
</tr>
<tr>
<td align="center">系统故障</td>
<td align="center">系统停止运转</td>
<td align="center">通常采用检查点法</td>
</tr>
<tr>
<td align="center">介质故障</td>
<td align="center">外存被破坏</td>
<td align="center">一般使用日志重做业务</td>
</tr>
</tbody></table>
<h3 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h3><p><strong>数据仓库</strong>是面向各各主题的；会记录一些集成式的数据(报表)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c60e0ed20bce0df65d296e7f30cc4c1ee207aeb9/data/%E4%BB%93%E5%BA%93%E6%95%B0%E6%8D%AE.jpg"></p>
<h3 id="反规范化-牺牲空间-规范化程度来换时间"><a href="#反规范化-牺牲空间-规范化程度来换时间" class="headerlink" title="反规范化(牺牲空间+规范化程度来换时间)"></a>反规范化(牺牲<u>空间</u>+<u>规范化程度</u>来换<u>时间</u>)</h3><p>由于规范化会使表不断的拆分，从而导致数据表过多。这样虽然减少了<strong>数据冗余</strong>，<u>提高了增、删、改的速度，但会增加查询的工作量</u>。系统需要进行多次连接，才能进行查询操作，使得系统效率大大下降。</p>
<h6 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h6><p><strong>√ 增加派生性冗余列</strong> (在成绩表里添加 姓名&#x2F;课程名 能够快速查到哪个人成绩多少分)<br><strong>√ 增肌冗余列</strong><br><strong>√ 重新组表</strong>(依据查询效率的原则)<br><strong>√ 分割表</strong>(从效率角度看进行垂直分割、水平分割)</p>
<h3 id="大数据-4V"><a href="#大数据-4V" class="headerlink" title="大数据 4V"></a>大数据 4V</h3><p>Volume 数据量    Velocity 速度    Variety 多样性    Value 价值</p>
<table>
<thead>
<tr>
<th align="center">比较维度</th>
<th align="center">传统数据</th>
<th align="center">大数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据量</td>
<td align="center">GB或TB</td>
<td align="center">PB级或以上</td>
</tr>
<tr>
<td align="center">数据分析需求</td>
<td align="center">现有数据的分析与检测</td>
<td align="center">深度分析(关联分析、回归分析)</td>
</tr>
<tr>
<td align="center">硬件平台</td>
<td align="center">高端服务器</td>
<td align="center">集群平台</td>
</tr>
</tbody></table>
<h6 id="大数据处理系统应该具有的重要特征"><a href="#大数据处理系统应该具有的重要特征" class="headerlink" title="大数据处理系统应该具有的重要特征"></a>大数据处理系统应该具有的重要特征</h6><blockquote>
<p>高度可拓展性<br>高性能<br>高度容错<br>支持异构环境<br>较短的分析延迟<br>易用且开放的接口<br>较低成本<br>向下兼容性</p>
</blockquote>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>中继器</strong>：类似于烽火狼烟<br><strong>网桥</strong>：链接两个同类型的设备<br><strong>交换机</strong>：用来链接多个设备</p>
<blockquote>
<h6 id="按分布范围分"><a href="#按分布范围分" class="headerlink" title="按分布范围分"></a>按分布范围分</h6><p>局域网LAN 城域网MAN 广域网WAN 因特网</p>
<h6 id="按拓扑结构分"><a href="#按拓扑结构分" class="headerlink" title="按拓扑结构分"></a>按拓扑结构分</h6><p>总线型 星型 环型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">名称</th>
<th align="center">主要功能</th>
<th align="center">主要设备及协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">应用层</td>
<td align="center">实现具体的应用功能</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">表示层</td>
<td align="center">数据的格式与表达、加密、压缩</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">会话层</td>
<td align="center">建立、管理和终止会话</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">传输层</td>
<td align="center">端到端的连接</td>
<td align="center">TCP、UDP</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">网络层</td>
<td align="center">分组传输和路由选择</td>
<td align="center">三层交换机、路由器、ARP、RARP、IP、ICMP、IGMP</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">数据链路层</td>
<td align="center">传送以帧为单位的信息</td>
<td align="center">网桥、交换机、网卡、PPTP、L2TP、SLIP、PPP</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">物理层</td>
<td align="center">二进制传输</td>
<td align="center">中继器、集线器</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>TCP&#x2F;IP 协议体系结构</strong><br>(1) 采用 分层结构，将复杂的大问题，划分成若干个简单的小问题<br>(2) TCP&#x2F;IP从下向上，依次划分为 “网络接口层、网络层 、传输层、应用层”<br>【注意】”网络接口层” 对应了 OSI的 物理层和数据链路层<br>(3) 常用协议<br>① 数据链路层 [PPP 点对点协议  PPPoE 基于 局域网的PPP协议 over Ethernet]<br>用于 建立、维护 数据链路(数据通道)<br>② 网络层<br><strong>IP</strong>：互联网协议，是所有通信必须使用的协议；作用：保证数据到达正确的目的地<br><strong>ARP</strong>：地址解析协议，实现 局域网 中主机的 IP地址转网卡的物理地址<br><strong>ICMP</strong>：互联网控制<strong>报文</strong>协议，功能：差错控制和查询主机<br><strong>RARP</strong>：逆向ARP，局域网中 物理地址 转 虚拟IP地址</p>
<blockquote>
<p>ping 127.0.0.1 回环测试本地主机内部网络状态是否正常</p>
</blockquote>
<p>③ 传输层<br><strong>TCP</strong>：传输控制协议，面向连接、可靠通信协议；功能：保证到达目的地的数据是正确的<br><strong>UDP</strong>：用户数据报协议，无连接、不可靠通信协议，用于 大数据传输(流媒体)：音频、视频<br>④ 应用层<br><span style = "color : red">HTTP</span> 超文本传输协议：用于访问网络<br><span style = "color : red">HTTPS</span> 加密&#x2F;安全超文本传输协议<br><strong>SMTP</strong>&#x2F;MIME 简单邮件传输协议：用于<strong>发送电子邮件</strong><br><strong>POP3</strong>&#x2F;IMAP 邮局协议第三版：用于<strong>接收电子邮件</strong><br><strong>FTP</strong> 文件传输协议：用于 上传下载文件<br><strong>TELNET</strong> 远程登录协议<br>DNS 域名解析协议：实现 中英文域名 转换为 数字的IP地址</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f96331264996b03cae2b87dcaf29db2e778b6b2f/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E4%BD%8D.jpg" style="zoom: 67%;" />
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/a17658b559c5998517d83d9117f82c913b7fc241/data/%E5%8D%8F%E8%AE%AE.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/a52a51d3f2d21b7f3f39926b385f47fc4fdda4b6/data/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" style="zoom:200%;" />



<h3 id="DHCP-DNS协议"><a href="#DHCP-DNS协议" class="headerlink" title="DHCP + DNS协议"></a>DHCP + DNS协议</h3><img src="https://raw.githubusercontent.com/P-luminary/images/adf08386618abc9e6c46346884f3860d74c14956/data/DHCP%2BDNS%E5%8D%8F%E8%AE%AE.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/202233c320981b4c100c6837c0ad9cb5b32e68c2/data/DNS%E5%8D%8F%E8%AE%AE%E9%A2%98.jpg"></p>
<h3 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/57a0942867cd04aaeea6f7f50d48aba632b281b1/data/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1.jpg"  />

<blockquote>
<p>★★★ 非常重要 IP地址相关计算题 ★★★</p>
<h5 id="IP地址和子网掩码换算"><a href="#IP地址和子网掩码换算" class="headerlink" title="IP地址和子网掩码换算"></a>IP地址和子网掩码换算</h5><p>已知ip地址和子网位数，例如：C网192.168.1.53&#x2F;27， [子网位数是27]<br><strong>求</strong><br>1.具体的子网掩码<br>2.子网数<br>3.<strong>最大可容纳主机数</strong><br>4.<strong>可用的主机数</strong><br>5.网络地址<br>6.广播地址<br>7.地址范围<br>8.主机号</p>
<h5 id="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："><a href="#一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：" class="headerlink" title="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："></a>一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：</h5><p>**1.**C网默认的子网掩码是：255.255.255.0<br>转换成二进制是：11111111.11111111.11111111.00000000<br>（1代表网络号，0代表主机号）<br>前24位是1，代表网络号，后8位是0，代表主机号<br>&#x3D;&#x3D;已知子网位数是27&#x3D;&#x3D;，代表网络号向主机号借用了3位（8+8+8+3）<br>得：11111111.11111111.11111111.11100000<br>把二进制转换为十进制：255.255.255.224<br>求出192.168.1.53&#x2F;27对应的子网掩码是255.255.255.224</p>
<h6 id="二、子网数"><a href="#二、子网数" class="headerlink" title="二、子网数"></a>二、子网数</h6><p>1.网络号向主机号借了3位（27-24），得**$2^3$&#x3D;8个**</p>
<p><span style = "color : red"><strong>三、最大可容纳主机数</strong></span>（根据求出的子网掩码和给出的子网位数求）1.由一可知子网掩码是：255.255.255.254，转换为二进制是11111111.11111111.11111111.11100000<br>1代表网络号，0代表主机号，有5个0，得最大可容纳主机数是2^5&#x3D;32</p>
<h6 id="四、可用的主机数"><a href="#四、可用的主机数" class="headerlink" title="四、可用的主机数"></a>四、可用的主机数</h6><p>由三可知，最大可容纳主机数是32个，32-2<del>广播地址+网络地址</del>&#x3D;30</p>
<h6 id="五、网络地址（把IP地址和子网掩码进行与运算）"><a href="#五、网络地址（把IP地址和子网掩码进行与运算）" class="headerlink" title="五、网络地址（把IP地址和子网掩码进行与运算）"></a>五、网络地址（把IP地址和子网掩码进行与运算）</h6><p>192.168.1.53&#x2F;27， 把IP地址和子网掩码进行与运算，IP地址转换为二进制：11000000.10101000.00000001. <strong>00110101<del>53</del></strong>;<br>子网掩码255.255.255.254转换为二进制：11111111.11111111.11111111.11100000，<br>进行与运算得：<br>IP地址：  11000000.10101000.00000001. 00110101<br>子网掩码：  11111111.11111111.11111111. 11100000（子网掩码连续全1的是网络地址，后面的是主机地址）<br>11000000.10101000.00000001. 00100000&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;转换为十进制得：192.168.1.32<br>所以网络地址是192.168.1.32</p>
<h6 id="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"><a href="#六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）" class="headerlink" title="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"></a>六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）</h6><p>1.网络地址： 11000000.10101000.00000001. 00100000（标黄部分是网络地址），变为1得：11000000.10101000.00000001. 00111111</p>
<p>2.广播地址转换为十进制：192.168.1.63</p>
<h6 id="七、地址范围"><a href="#七、地址范围" class="headerlink" title="七、地址范围"></a>七、地址范围</h6><p>1.网络地址+1——-广播地址-1，得192.168.1.33—-192.168.1.62</p>
<h6 id="八、主机号（子网掩码取反再和IP做与运算）"><a href="#八、主机号（子网掩码取反再和IP做与运算）" class="headerlink" title="八、主机号（子网掩码取反再和IP做与运算）"></a>八、主机号（子网掩码取反再和IP做与运算）</h6></blockquote>
<p>将一个网络<strong>划分</strong>为多个子网(取部分<strong>主机号</strong>当子网号)<br>将多个网络<strong>合并</strong>为一个大的网络(取部分网络号当主机号)</p>
<h6 id="例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？"><a href="#例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？" class="headerlink" title="例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？"></a>例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？</h6><blockquote>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>168.195.0.0</td>
<td>1010 1000  1100 0011  0000 0000  0000 0000</td>
</tr>
</tbody></table>
<p>$2^R$ ≥ N；R&#x3D;5时 N&#x3D;32 ＞ 27<br><strong>网络位</strong>要向主机位借5位<br>该例中需27个子网，按公式，需借5位</p>
<p>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u><strong>1111 1</strong>000</u>  <u>0000 0000</u> → 255.255.248.0每个子网能容纳的有效主机数为$2^{11}-2$&#x3D;2046台<br>只要划分子网 就是变化的子网掩码 </p>
</blockquote>
<h6 id="例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的"><a href="#例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的" class="headerlink" title="例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？(这两个子网掩码是根据不同的条件而得到的)"></a>例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？<span style = "color : red">(这两个子网掩码是根据不同的条件而得到的)</span></h6><blockquote>
<p>$2^R$ ≥ N；N&#x3D;700；R&#x3D;10 也就是剩余10个零<strong>地址位(<strong>网络位)只要有10位就够了<br>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u>1111 11</strong>00</strong></u>  <u><strong>0000 0000</strong></u> → 255.255.252.0</p>
</blockquote>
<h6 id="无分类编址-无类域间路由"><a href="#无分类编址-无类域间路由" class="headerlink" title="无分类编址(无类域间路由)"></a>无分类编址(无类域间路由)</h6><p><span style = "color : red"><strong>IP地址 :: &#x3D; {&lt;网络前缀&gt;, &lt;主机号&gt;}</strong></span><br>128.14.32.0&#x2F;20 表示的地址块共有$2^{12}$个地址<br>这个地址块的起始地址是128.14.32.0<br>在不需要指出地址块的起始地址时，也可将这样的地址快简称位 “&#x2F;20地址块”<br>128.14.32.0&#x2F;20 地址块的最小地址：128.14.32.0<br>128.14.32.0&#x2F;20 地址块的最大地址：128.14.47.255<br>全0和全1的主机号地址一般不使用</p>
<h6 id="例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；"><a href="#例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；" class="headerlink" title="例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；"></a>例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；</h6><blockquote>
<p>C类地址 24个子网位  8个主机位，题目是&#x2F;20 前面20位为网络号；证明还要从主机号里拿出4个位来做子网号；4个位得到的子网数量是16个</p>
</blockquote>
<h3 id="特殊含义的IP地址"><a href="#特殊含义的IP地址" class="headerlink" title="特殊含义的IP地址"></a>特殊含义的IP地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee02b13442781213029e9fe8c188d1b53c790179/data/%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80.jpg"></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/4aedfd72e38d42a61b4be6086c218703360ec565/data/HTML.jpg"></p>
<h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>灵活性 移动性 成本低 容易扩充</p>
<h6 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h6><p>有接入点模式  无接入点模式(对等网模式)</p>
<blockquote>
<p>无线局域网(WLAN, 802.11, Wi-Fi)<br>无线城域网(WMAN, 802.16, WiMax)<br>无线广域网(WWAN, 3G&#x2F;4G)<br>无线个人网(WPAN, 802.15, Bluetooth)</p>
</blockquote>
<blockquote>
<h5 id="有线接入"><a href="#有线接入" class="headerlink" title="有线接入"></a>有线接入</h5><p>公用交换电话网络(PSTN) <u>原始拨号上网</u> pose机+传真<br>数字数据网(DDN) <u>数字专用网(专线)</u><br>综合业务数字网(ISDN) <u>允许打电话的时候上网</u><br>非对称数字用户线路(ADSL) <u>老旧小区电话线部署</u><br>同轴光纤技术(HFC) <u>家里有线电视</u></p>
</blockquote>
<blockquote>
<h6 id="无线接入"><a href="#无线接入" class="headerlink" title="无线接入"></a>无线接入</h6><p>IEEE 802.11(WiFi)<br>IEEE 802.15(蓝牙Bluetooth)<br>红外(IRDA)<br>WAPI</p>
</blockquote>
<blockquote>
<h6 id="3G-x2F-4G"><a href="#3G-x2F-4G" class="headerlink" title="3G&#x2F;4G"></a>3G&#x2F;4G</h6><p>WCDMA<br>CDMA2000<br>TD-SCDMA (国外多 速率低 功耗大)<br>LTE-Advanced<br>WirelessMAN-Advanceed(802.16m) (WiMAX)</p>
</blockquote>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPV6是设计用于替代现行版本IP协议(IPV4)的下一代IP协议。</p>
<blockquote>
<p>(1) IPV6地址长度位128位，地址空间增大了$2^{96}$倍<br>(2) 灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPV6中选项部分的出现方式也有所变化，使用路由器可以简单路过选项而不做任何处理，加快了报文处理速度<br>(3) IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量<br>(4) 提高安全性。身份认证和隐私权是IPv6的关键特性<br>(5) 支持更多的服务类型<br>(6) 允许协议继续演变，增加新的功能，使之适应未来技术的发展</p>
</blockquote>
<p>**单播地址(Unicast)**：用于单个接口的标识符<br>**任播地址(Anycast)**：泛播地址。一组接口的标识符，IPv4广播地址<br>**组播地址(Multicast)**：IPv6中的组播在功能上与IPv4中的组播类似</p>
<h3 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h3><h6 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h6><blockquote>
<p><strong>保密性</strong>：最小授权原则、防暴露、信息加密、物理加密<br><strong>完整性</strong>：安全协议、校验码、密码校验、数字签名、公证<br><strong>可用性</strong>：综合保障(IP过滤、业务流控制、路由选择控制、审计跟踪)<br><strong>不可抵赖性</strong>：数字签名</p>
</blockquote>
<h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a><span style = "color : red">加密技术</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e8808ad943a5c7fcaf7ae0ce3606fc214c3221/data/%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg"></p>
<h3 id="信息摘要-不能用作加密算法-因为不能解密-（无法篡改）"><a href="#信息摘要-不能用作加密算法-因为不能解密-（无法篡改）" class="headerlink" title="信息摘要(不能用作加密算法 因为不能解密) （无法篡改）"></a>信息摘要(不能用作加密算法 因为不能解密) （无法篡改）</h3><p>单向散列函数(<strong>单向Hash函数</strong>)、固定长度的散列值<br>常用的消息摘要算法有MD5、SHA等，市场上广泛使用的MD5，SHA算法的散列值分别为128和160位，由于SHA通常采用的密钥长度较长，因此安全性高于MD5</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>数字证书</strong>：识别人的身份</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/21de8ce0fc5a2872f99ac597d26aca426a8a436a/data/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" style="zoom:150%;" />



<h3 id="数字信封与PGP"><a href="#数字信封与PGP" class="headerlink" title="数字信封与PGP"></a>数字信封与PGP</h3><blockquote>
<p>发送方将原文用对称密钥加密传输，而将对称密钥用接收公钥加密发送給对方<br>接受方收到电子信封，用自己的私钥解密信封，取出对称密钥解密得原文</p>
</blockquote>
<blockquote>
<p>PGP可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括IDEA、RSA、MD5、ZIP数字压缩算法</p>
<p>PGP承认两种不同的证书格式：PGP证书和X.509证书</p>
<p>PGP证书包含PGP版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的数字签名、证书的有效期、密钥首选的对称加密算法</p>
<p>X.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据：证书发行商名字、证书主题名、<strong>主体公钥信息</strong>、发布者的数字签名</p>
</blockquote>
<h3 id="练习题-—-设计邮件加密系统"><a href="#练习题-—-设计邮件加密系统" class="headerlink" title="练习题 — 设计邮件加密系统"></a>练习题 — 设计邮件加密系统</h3><p>要求邮件以**<u>加密方式传输</u><strong>(<span style = "color : red"><em>加密解密技术</em></span>  )，邮件</strong><u>最大附件内容可达500MB</u><strong>( <em><span style = "color : red">对称加密</span></em>  )，</strong><u>发送者不可抵赖</u>** ( <em><span style = "color : red">数字签名</span></em>  )，若邮件被第三方截获，**<u>第三方无法篡改</u>** ( <em><span style = "color : red">信息摘要技术</span></em>  )。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/207ac6bb3d48784835bb4a14a2bcc0686739bf53/data/%E8%AE%BE%E8%AE%A1%E9%82%AE%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<h3 id="网络安全-—-各个网络层次的安全保障"><a href="#网络安全-—-各个网络层次的安全保障" class="headerlink" title="网络安全 — 各个网络层次的安全保障"></a>网络安全 — 各个网络层次的安全保障</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ebec2885b8f58a32cc399dcb2ba83803ea944fa3/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C.jpg"></p>
<h3 id="网络安全-—-网络威胁与攻击"><a href="#网络安全-—-网络威胁与攻击" class="headerlink" title="网络安全 — 网络威胁与攻击"></a>网络安全 — 网络威胁与攻击</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bfbf181924b0185e3567a2c2e020aca1b7e9341/data/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E4%B8%8E%E6%94%BB%E5%87%BB.jpg"></p>
<h3 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/805b5c52967e5ceefd47b195f8bce4ba3094c02c/data/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF.jpg"></p>
<h1 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a><span style = "color : red">数据结构与算法基础</span></h1><p>数组与矩阵、<strong>线性表</strong>、广义表、<strong>树与二叉树</strong>、图、<strong>排序与查找</strong>、<strong>算法基础及常见的算法</strong></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><table>
<thead>
<tr>
<th align="left">数组类型</th>
<th align="left">存储地址计算</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一维数组a[n]</td>
<td align="left">a[i]的存储地址为：a + i * len</td>
</tr>
<tr>
<td align="left">二维数组a[m] [n]</td>
<td align="left"><span style = "color : red"><strong>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len</strong></span><br /><span style = "color : red"><strong>a[i] [j]的存储地址(按列存储)：a + ( j * m + i) * len</strong></span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1 a[0] [0]</th>
<th>2 a[0] [1]</th>
<th>3 a[0] [2]</th>
</tr>
</thead>
<tbody><tr>
<td>4 a[1] [0]</td>
<td>5 a[1] [1]</td>
<td>6 a[1] [2]</td>
</tr>
<tr>
<td>7 a[2] [0]</td>
<td>8 a[2] [1]</td>
<td>9 a[2] [2]</td>
</tr>
</tbody></table>
<p>已知5行5列的二维数组a中的各元素占两个字节，求元素a[2] [3]按<strong>行</strong>优先存储的存储地址？</p>
<blockquote>
<p>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len<br> (2 * 5 + 3) * 2，a[2] [3]是存储的第14个元素，由于编号是从0开始算的，有13个偏移量<br>∴ a + 13 * 2 &#x3D; 每一个元素所占的字节数    a[0] [0] &#x3D; a</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
</tr>
</thead>
<tbody><tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"><span style = "color : red"><strong>√</strong></span></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e6036b61d33d357a06e724e93e01d06021ed088f/data/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.jpg" style="zoom:150%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是指互相之间存在一种或多种特定关系的数据元素的集合<br><strong>图</strong>包含<strong>树</strong>  <strong>树</strong>包含<strong>线性结构</strong></p>
<p><u>线性结构</u>  <strong>O-O-O-O</strong><br><u>非线性结构</u>  <strong>树 + 图</strong></p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><strong>顺序表</strong> + <strong>链表</strong>(单链表、循环列表、双向链表)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/b3c4a142e06c76bec4aa3e73894168a65b08f6d1/data/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9.jpg"  />



<h3 id="顺序存储与链式存储对比"><a href="#顺序存储与链式存储对比" class="headerlink" title="顺序存储与链式存储对比"></a>顺序存储与链式存储对比</h3><table>
<thead>
<tr>
<th align="left">性能类别</th>
<th align="left">具体项目</th>
<th align="left">顺序存储</th>
<th align="left">链式存储</th>
</tr>
</thead>
<tbody><tr>
<td align="left">空间性能</td>
<td align="left">存储密度</td>
<td align="left">&#x3D;1，更优 (1&#x3D;100%)</td>
<td align="left">&lt; 1 (<u>有节点专门存地址信息</u>)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">容量分配</td>
<td align="left">事先确定</td>
<td align="left">动态变化，更优 (<u>动态改变分配</u>)</td>
</tr>
<tr>
<td align="left">时间性能</td>
<td align="left">查找运算</td>
<td align="left">O(n&#x2F;2)</td>
<td align="left">O(n&#x2F;2)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">读运算</td>
<td align="left">O(1)，更优</td>
<td align="left">O([n+1]&#x2F;2), 最好情况为1，最坏情况为n  (需要一格一格的移)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">插入运算</td>
<td align="left">O(n&#x2F;2)，最好情况为O，最坏情况为n</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">删除运算</td>
<td align="left">O([n-1]&#x2F;2)</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
</tbody></table>
<h3 id="线性表—队列与栈"><a href="#线性表—队列与栈" class="headerlink" title="线性表—队列与栈"></a>线性表—队列与栈</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1a694cbb02c9afc6c9ee673f3b356d875c592b76/data/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"  />



<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><img src="https://raw.githubusercontent.com/P-luminary/images/61bf44a1acf06a88f7ad8469c6878d8c01c947ae/data/%E5%B9%BF%E4%B9%89%E8%A1%A8.jpg"  />



<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1638b875c12489816f5727597393ae6b4c559259/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/47e3cc81bfa782c8f11433d14042d25524d1d7ff/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%912.png"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e4a5b0f38017419dced3d5a0a580be16fc7f7d9a/data/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg"></p>
<h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea18aebfc2bb5b897ee4e065ea0e6328ba2d38aa/data/%E5%8F%8D%E5%90%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230710123815373.png"></p>
<h3 id="查找二叉树"><a href="#查找二叉树" class="headerlink" title="查找二叉树"></a>查找二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ca9dc0f534b3ff73fade234561af98443227670c/data/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="最优二叉树-哈夫曼树"><a href="#最优二叉树-哈夫曼树" class="headerlink" title="最优二叉树(哈夫曼树)"></a>最优二叉树(哈夫曼树)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e8133232bfff828b8fe77098f7fa9d7fca88b148/data/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91).jpg"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec2da880ff33e863050049acc335c60fb09f6e3b/data/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8848e420d3d2f38cfa13a2803afb39fba9249cc8/data/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树和图的最大区别：树是没有环路的"><a href="#树和图的最大区别：树是没有环路的" class="headerlink" title="树和图的最大区别：树是没有环路的"></a><span style = "color : red"><strong>树和图的最大区别：树是没有环路的</strong></span></h3><h3 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea8055908dec7f2d988a189da12eeced78a34fb7/data/%E5%9B%BE%2B%E5%9B%BE%E5%AD%98%E5%82%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg"></p>
<h3 id="邻接图"><a href="#邻接图" class="headerlink" title="邻接图"></a>邻接图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0e743eb4f3e6db6334e95e915528a12ac68514a2/data/%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg"></p>
<h3 id="图的遍历-深度-广度"><a href="#图的遍历-深度-广度" class="headerlink" title="图的遍历(深度+广度)"></a>图的遍历(深度+广度)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7cf480efb37be3cf903977972770cb46f88a1015/data/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(%E6%B7%B1%E5%BA%A6%2B%E5%B9%BF%E5%BA%A6).jpg"></p>
<h3 id="图-—-拓扑排序"><a href="#图-—-拓扑排序" class="headerlink" title="图 — 拓扑排序"></a>图 — 拓扑排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8f52549404943f522f10d2bfefbefbd15bb3bfba/data/%E5%9B%BE%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="图的最小生成树-—-普里姆算法"><a href="#图的最小生成树-—-普里姆算法" class="headerlink" title="图的最小生成树 — 普里姆算法"></a>图的最小生成树 — 普里姆算法</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/48563077b3612e0a2288fb24c5f78d0082384f8d/data/%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.jpg"></p>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p><strong>有穷性</strong>：执行有穷步之后结束<br><strong>确定性</strong>：算法中每一条指令都必须有确切的含义，不能含糊不清<br><strong>输入</strong>：(&gt;&#x3D;0)<br><strong>输出</strong>：(&gt;&#x3D;1)<br><strong>有效性</strong>：算法的每个步骤都能有效执行并能得到确定的结果。例a&#x3D;0, b&#x2F;a就无效</p>
<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><p><strong><span style = "color : red">时间复杂度</span><strong>：是指程序运行从开始到结束所需要的时间。通常分析时间复杂度的方法是从算法中选取一种对于所研究的问题来说是基本运算的操作，以该操作重复执行的次数作为算法的时间量度。一般来说，算法中原操作重复执行的次数是规模n的某个函数T(n)。由于许多情况下要精密计算T(n)是困难的，因此引入了渐进时间复杂度在数量上估计一个算法的执行时间。其定于如下：<br>如果存在两个常数c和m，对于所有的n，当n≥m时有f(n) ≤ cg(n), 则有f(n) &#x3D; O(g(n))，也就是说，随着n的增大，f(n)逐进地不大于g(n)。例如，</strong>一个程序的实际执行时间为T(n)&#x3D;3$n^3$+2$n^2$+n, 则T(n) &#x3D; O($n^3$)</strong>  [以最高的时间复杂度为准！三重for循环时间复杂度是O($n^3$)]</p>
<p><span style = "color : orange"><strong>常见的对算法执行所需时间的量度：</strong></span><br><strong>O(1) &lt; O(lo$g_2$n) &lt; O(n) &lt; O(nlo$g_2$n) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$)</strong></p>
<blockquote>
<p><strong>log的由来</strong>：排序二叉树 找结点 有7个结点的完全二叉树，向下比较 最多比较3次(二叉树的层数) 最坏的情况多少层就比较多少次 所以有<strong>lo$g_2$n</strong>，n就是结点数量</p>
</blockquote>
<p>**<span style = "color : red">空间复杂度：</span>**是指对一个算法在运行过程中临时占用存储空间大小的度量。一个算法的空间复杂度<u><strong>只考虑在运行过程中为局部变量分配的存储空间的大小</strong></u>。</p>
<h3 id="查找-—-顺序查找与二分查找"><a href="#查找-—-顺序查找与二分查找" class="headerlink" title="查找 — 顺序查找与二分查找"></a>查找 — 顺序查找与二分查找</h3><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.jpg"  />



<h3 id="查找-—-散列表"><a href="#查找-—-散列表" class="headerlink" title="查找 — 散列表"></a>查找 — 散列表</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0098e5cad58ccd31a685f565826e8e8832772252/data/%E6%95%A3%E5%88%97%E8%A1%A8.jpg"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6f3e15053fbfd4f677ad2bc4d3e415a22676631d/data/%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f95845259682927312a2712c8786baa1659e1f52/data/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="希尔排序-效率高于直接插入排序"><a href="#希尔排序-效率高于直接插入排序" class="headerlink" title="希尔排序(效率高于直接插入排序)"></a>希尔排序(效率高于直接插入排序)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/85ce49aa669297ebbfd9656a75bc09f78d3b7b5d/data/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230718181340677.png"></p>
<h3 id="堆排序-适合于：不需要求全部-求前一部分"><a href="#堆排序-适合于：不需要求全部-求前一部分" class="headerlink" title="堆排序(适合于：不需要求全部 求前一部分)"></a>堆排序(适合于：不需要求全部 求前一部分)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2972cd322a1e9d4649529aa4e8a98073de6e2de3/data/%E5%A0%86%E6%8E%92.png.jpg" style="zoom:150%;" />



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2969db8aafbafae291aa4e96a9c8391862ca0ab8/data/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" style="zoom:150%;" />



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9a50aee5775d1ca1a8a993d3d0847599d7b52020/data/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/27b826e69885dcb01132ea63609668073c020e2a/data/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dad7782ee80e0729e01210b493c6bf596363784/data/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="算法排序汇总"><a href="#算法排序汇总" class="headerlink" title="算法排序汇总"></a>算法排序汇总</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8e615d2e7034d2bdffafcd507cb102e0fbf9c72e/data/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.jpg" style="zoom:150%;" />



<h1 id="程序设计语言与语言处理程序"><a href="#程序设计语言与语言处理程序" class="headerlink" title="程序设计语言与语言处理程序"></a>程序设计语言与语言处理程序</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/98ebae6a55bb6b68dc4500674cc321737f4cd169/data/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8ee259fcd72bc7b48ab89100ce84af30cb560bfd/data/%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%8E%A8%E5%AF%BC%E6%A0%91.jpg" style="zoom: 150%;" />



<h3 id="有限自动机与正规式"><a href="#有限自动机与正规式" class="headerlink" title="有限自动机与正规式"></a>有限自动机与正规式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ed582973635f109925c4a9ead6047f0e51cf3c6f/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E8%A7%84%E5%BC%8F.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/e961e9530911c0115ffea4127e991575bbcaf5a0/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%BE%8B%E9%A2%98.jpg" style="zoom:150%;" />



<h3 id="程序语言基础—表达式"><a href="#程序语言基础—表达式" class="headerlink" title="程序语言基础—表达式"></a>程序语言基础—表达式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ee55ff5d4ec9b9745f6a8ad4c37066449e0dee96/data/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" style="zoom:150%;" />



<h3 id="函数调用—传值与传址"><a href="#函数调用—传值与传址" class="headerlink" title="函数调用—传值与传址"></a>函数调用—传值与传址</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9cbd1c801ae0a7fcabad837813854de5e63feffe/data/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82.jpg"  />



<h3 id="程序语言基础—各种程序语言特点"><a href="#程序语言基础—各种程序语言特点" class="headerlink" title="程序语言基础—各种程序语言特点"></a>程序语言基础—各种程序语言特点</h3><p><strong>Fortran语言</strong>(科学计算，执行效率高)<br><strong>Pascal语言</strong>(为教学而开发的，表达能力强，Delphi)<br><strong>C语言</strong>(指针操作能力强，高效)<br><strong>Lisp语言</strong>(函数式程序语言，符号处理，人工智能)<br><strong>C++语言</strong>(面向对象，高效)<br><strong>Java语言</strong>(面向对象，中间代码，跨平台)<br><strong>C#语言</strong>(面向对象，中间语言，.Net)<br><strong>Prolog语言</strong>(逻辑推理，简洁性，表达能力，数据库和专家系统)</p>
<h3 id="法律法规-—-课程内容提要"><a href="#法律法规-—-课程内容提要" class="headerlink" title="法律法规 — 课程内容提要"></a>法律法规 — 课程内容提要</h3><h5 id="从所涉及的法律法规角度"><a href="#从所涉及的法律法规角度" class="headerlink" title="从所涉及的法律法规角度"></a>从所涉及的法律法规角度</h5><p>著作权法、计算机软件保护条例、商标法、专利法</p>
<p>@@ 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发便，所以甲对该软件作品享有著作权，乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权</p>
<p>@@ 关于软件著作权产生的时间是<strong>自作品完成创作之日</strong></p>
<h5 id="从试题考点分布的角度"><a href="#从试题考点分布的角度" class="headerlink" title="从试题考点分布的角度"></a><span style = "color :red">从试题考点分布的角度</span></h5><p>保护期限、知识产权人确定、侵权判断</p>
<blockquote>
<p><strong>知识产权</strong>：<br>著作权及邻接权、专利权、工业品外观设计权、商标权、地理标志权、集成电路布图设计权</p>
<p><u>著作权</u>：一般保护作者的利益<br><u>邻接权</u>：别人盗写我出的书，不仅破坏了我的权益，还有**<u>出版商</u><strong>的权益<br><u>地理标志权</u>：</strong>新疆**哈密瓜 只有在标志的地理位置生产(这一区域都拥有)</p>
</blockquote>
<h3 id="法律法规-—-保护期限-知识产权人"><a href="#法律法规-—-保护期限-知识产权人" class="headerlink" title="法律法规 — 保护期限, 知识产权人"></a>法律法规 — 保护期限, 知识产权人</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0d498a6b717c3dfd41334e8799dc508e5a7d4e8c/data/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%BF%9D%E6%8A%A4%E6%9C%9F%E9%99%90%2C%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%BA%BA.jpg" style="zoom:150%;" />



<h3 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h3><h5 id="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"><a href="#中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权" class="headerlink" title="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"></a>中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权</h5><h5 id="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"><a href="#开发软件所用的思想、处理过程、操作方法或者数学概念不受保护" class="headerlink" title="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"></a>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</h5><h6 id="著作权法不适用于下列情形："><a href="#著作权法不适用于下列情形：" class="headerlink" title="著作权法不适用于下列情形："></a>著作权法不适用于下列情形：</h6><p>√ 法律、法规、国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文</p>
<p>√ 时事新闻</p>
<p>√ 历法、通用数表、通用表格和公式</p>
<table>
<thead>
<tr>
<th>不侵权</th>
<th>侵权</th>
</tr>
</thead>
<tbody><tr>
<td>√ 个人学习、研究或欣赏<br />√ 适当引用<br />√ 公开演讲内容<br />√ 用于教学或科学研究<br />√ 复制馆藏作品<br />√ 免费表演他人作品<br />√ 室外公共场所艺术品临摹、绘画、摄影、录像<br />√ 将汉语作品译成少数民族语言作品或盲文出版</td>
<td>√ 未经许可，发表他人作品<br />√ 未经合作作者许可，将与他人合作创作的作品当作自己单独创作的作品发表的<br />√ 未参加创作，在他人作品署名<br />√ 歪曲、篡改他人作品<br />√ 剽窃他人作品的<br />√ 使用他人作品，未付报酬<br />√ 未经出版者许可，使用其出版的图书、期刊的版式设计的</td>
</tr>
</tbody></table>
<h3 id="标准化基础知识—标准的分类"><a href="#标准化基础知识—标准的分类" class="headerlink" title="标准化基础知识—标准的分类"></a>标准化基础知识—标准的分类</h3><p>√ 国际标准：ISO、IEC等国际标准化组织<br>√ 国家标准：GB—中国、ANSI—美国、BS—英国、JIS—日本<br>√ 区域标准：又称为地区标准，如PASC—太平洋地区标准会议、CEN—欧洲标准委员会、ASAC—亚洲标准咨询委员会、ARSO—非洲地区标准化组织<br>√ 行业标准：GJB—中国军用标准、MIT-S—美国军用标准、IEEE—美国电气电子工程协会<br>√ 地方标准：国家的地方一级行政机构制订的标准<br>√ 企业标准<br>√ 项目规范</p>
<p>→ 国标、国外标准代号：标准代号+专业类号+顺序号+年代号<br>→ 我国国家标准代号：强制性代号为GB、推荐性标准代号为GB&#x2F;T、指导性标准代号为GB&#x2F;Z、实物标准代号GSB</p>
<p>→ 行业标准代号：由汉语拼音大写字母组成(如电子行业为SJ)<br>→ 地方标准代号：由DB加上省级行政区划代码的前两位<br>→ 企业标准代号：由Q加上企业代号组成</p>
<h1 id="多媒体基础"><a href="#多媒体基础" class="headerlink" title="多媒体基础"></a>多媒体基础</h1><p>人耳：<strong>20Hz—20kHz</strong>  <u>小于20Hz是次声波 大于20kHz是超声波</u><br>说话：300—3400Hz<br>乐器：20Hz —20kHz<br>白噪音：20 ~ 20kHz</p>
<p><strong>采样</strong>：采样频率、采样精度、采样频率应为声音最高频率的2倍</p>
<blockquote>
<p><strong>采样点密</strong>集程度越高，时间间隔越短，还原度越好<br><strong>采样精度</strong>画格子的数量 y轴平行于x做直线</p>
</blockquote>
<h3 id="图像相关概念"><a href="#图像相关概念" class="headerlink" title="图像相关概念"></a>图像相关概念</h3><h4 id="色彩三要素色"><a href="#色彩三要素色" class="headerlink" title="色彩三要素色"></a>色彩三要素色</h4><p><strong>亮度</strong>是光作用于人眼时所引起的明亮程度的感觉，它与被观察物体的发光强度有关。<br><strong>色相</strong>是当人眼看一种或多种波长的光时所产生的彩色感觉，它反映颜色的种类，是决定颜色的基本特性。<br><strong>饱和度</strong>是指颜色的纯度，也可以叫做纯度、彩度或浓度等，即掺入白光的程度，或者是指颜色的深浅程度。</p>
<blockquote>
<p><strong>HSB彩色模式</strong><br>是根据日常生活中人眼的视觉特征而制定的一套色彩模式。HSB颜色模式以色相、饱和度和亮度描述颜色的基本特征。</p>
<p><strong>CMY颜色模式</strong><br>是采用**青(Cyan、品红或洋红(Magenta)、黄(Yellow)**3种基本颜色按一定比例合成颜色的方法。颜色的产生是来自于照射在颜料上反射回来的光线。<br>图像打印输出时用CMY颜色模式。</p>
<p><strong>Lab颜色模式</strong><br>分别用**亮度或光亮度分量(Luminosity)和两个色度分量(a、b)**来表示颜色<br>L表示亮度。L的值域由0到100，L&#x3D;50时，相当于50%的黑。<br>a表示从洋红色至绿色的范围，<br>b表示从黄色至蓝色的范围，<br>a和b的值域是由+127至-128。</p>
<p><strong>索引颜色模式</strong><br>最多使用256种颜色，当图像被转换为索引颜色模式时，通常会构建一个<strong>调色板存放图像中的颜色并编制颜色索引。</strong></p>
<p><strong>位图模式</strong><br>位图模式的图像只有<strong>黑色与白色两种像素</strong>，每个像素用1位二进制数表示,”0”表示黑色,“1”表示白色。</p>
<p><strong>灰度模式</strong><br>用单一色相表现图像，最多使用256级。图像中的每个像素有一个0(黑色)～255(白色)之间的亮度值。此外，灰度值也可以用黑色油墨覆盖的百分比来表示(0%表示白色，100%表示黑色)。</p>
<p><strong>颜色深度</strong><br>位图图像中各像素的颜色信息是用二进制数据描述的。<br><strong>色彩由颜色深度决定，不是分辨率</strong><br><strong>二进制的位数就是位图图像的颜色深度。颜色深度决定了图像中可以呈现的颜色的最大数目。</strong></p>
<p><strong>分辨率:</strong><br>图像分辨率(Image Resolution):指单位图像线性尺寸中所包含的像素数目，通常以**像素&#x2F;英寸(pixel per inch,ppi)**为计量单位。</p>
</blockquote>
<h6 id="彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度"><a href="#彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度" class="headerlink" title="彩色空间：RGB彩色显示器、YUV(电视, 兼容方案)、CMY[K黑]、HSV(HSB)艺术家角度"></a>彩色空间：RGB<del>彩色显示器</del>、YUV(电视, 兼容方案)、CMY[K<del>黑</del>]、HSV(HSB)<del>艺术家角度</del></h6><p><strong>光的颜色</strong>采取叠加原理<br><strong>印刷的三原色</strong>采取相减原理</p>
<h3 id="媒体的种类"><a href="#媒体的种类" class="headerlink" title="媒体的种类"></a>媒体的种类</h3><p><strong>感觉媒体</strong>，指通过人的感觉器官能<u>直接感受的媒体</u>，如视觉。<br><strong>表示媒体</strong>，用于传播和表达感觉媒体的中介媒体，是信息的表示和表现形式，如<u>JPG编码</u><br><strong>表现媒体</strong>(显示媒体)，是进行信息输入和输出的一类媒体，如<u>显示器</u><br><strong>传输媒体</strong>，是用于通信传输的信息载体，如<u>双绞线</u>。<br><strong>存储媒体</strong>，是存放表示媒体的物理实体，如<u>光盘</u></p>
<blockquote>
<p><strong>感觉</strong>媒体：听觉、触觉、嗅觉；<br><strong>表示</strong>媒体：文字、数字、音频、视频、编码方式；<br><strong>表现</strong>媒体(显示媒体)：输入显示媒体键盘、鼠标和麦克风、输出显示媒体显示器、打印机和音箱<br><strong>存储</strong>媒体：存储数据的物理设备，硬盘、磁盘、光盘U盘<br><strong>传输</strong>媒体：存储数据的物理载体，电缆、光缆和交换设备</p>
</blockquote>
<ul>
<li>D&#x2F;A转换，<strong>数字</strong>音频<strong>模拟</strong>化输出</li>
</ul>
<h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><ul>
<li><strong>波形音频文件容量的计算</strong>  <span style = "color : red"><u>容量&#x3D;声道数 * 采样频率 * 量化位数 * 长度 &#x2F; 8</u></span><br>其中频率单位Hz，量化单位bit，长度秒，容量单位字节B</li>
<li><strong>波形音频文件码率的计算</strong>  <u>码率&#x3D;声道数 * 采样频率 * 量化位数</u>  码率的单位是bps</li>
</ul>
<h5 id="常见波形文件格式"><a href="#常见波形文件格式" class="headerlink" title="常见波形文件格式"></a>常见波形文件格式</h5><ul>
<li>&#x3D;&#x3D;<strong>.wav</strong>&#x3D;&#x3D; 微软和IBM共同开发的PC标准音频格式，未压缩，声音达到CD音质，码率约为1.4Mb&#x2F;s，Windows XP录音机默认音频格式</li>
<li><strong>.mp3</strong> 有损压缩，最常用  互联网、MP3音乐</li>
<li>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</li>
<li><strong>.m4a</strong> 苹果公司的无损压缩</li>
<li><strong>.flac</strong> 无损压缩，高品质数字音乐</li>
<li><strong>.ape</strong> 无损压缩音频格式</li>
</ul>
<p>@@ WAV文件称为波形声音文件，其音质与CD差不多<br>@@ MP3文件能够达到很高的压缩比，并能<strong>保持较高</strong>的音质；通常那个说WAV文件比MP3文件大[比WAV&#x2F;CD好]<br>@@ MIDI不能从CD、磁带、麦克风等录制MIDI文件；通常MIDI文件小于MP3</p>
<h5 id="MIDI格式"><a href="#MIDI格式" class="headerlink" title="MIDI格式"></a>MIDI格式</h5><ul>
<li>MIDI乐器数字接口，垫桌子音乐制造商们建立的通信标准</li>
<li>MIDI传输的不是声音信号，记录声音的信息，是在线音乐的一组指令，是音符、控制参数等指令，它指示MIDI设备要做什么，怎么做; 如演奏哪个音符，音量多大等</li>
<li>.mid 或 .midi</li>
</ul>
<blockquote>
<h2 id="x3D-x3D-知识点总结-x3D-x3D"><a href="#x3D-x3D-知识点总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;知识点总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;知识点总结&#x3D;&#x3D;</h2><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li><strong>位图</strong>：.bmp<del>不压缩</del>    .gif<del>无损压缩</del>    .jpg&#x2F;jpeg<del>有损压缩</del>    .png<del>无损压缩</del>    .tif</li>
<li><strong>矢量图</strong>：.swf    .ai    .dwg    .cdr</li>
</ul>
<h4 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h4><ul>
<li><p>.wav    .mp3<del>有损压缩</del>    .wma<del>有损压缩：录音机(微软)</del>    </p>
</li>
<li><p>.m4a<del>无损压缩(苹果)</del>    .flac<del>无损压缩(高质量数字音乐)</del>    .ape<del>无损压缩音频</del></p>
</li>
<li><p>MIDI [.mid&#x2F;.midi]<del>乐谱</del></p>
</li>
</ul>
<h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><ul>
<li>.mpeg&#x2F;.mp4    H.26X    .avi    .asf    .wmv    .rm&#x2F;.rmvb    .flv    .mkv    .mov</li>
</ul>
<h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><ul>
<li>RM、WMV、ASF</li>
</ul>
</blockquote>
<h2 id="音频信息在计算机中的表示"><a href="#音频信息在计算机中的表示" class="headerlink" title="音频信息在计算机中的表示"></a>音频信息在计算机中的表示</h2><h4 id="波形数字音频"><a href="#波形数字音频" class="headerlink" title="波形数字音频"></a>波形数字音频</h4><h5 id="音频信息处理的流程"><a href="#音频信息处理的流程" class="headerlink" title="音频信息处理的流程"></a>音频信息处理的流程</h5><ul>
<li>A&#x2F;D转换[<strong>采样</strong>]，模拟音频的数字化【影响数字化质量的主要原因】</li>
</ul>
<h3 id="多媒体相关计算问题"><a href="#多媒体相关计算问题" class="headerlink" title="多媒体相关计算问题"></a>多媒体相关计算问题</h3><h6 id="图像容量计算640-水平像素-×480-垂直像素"><a href="#图像容量计算640-水平像素-×480-垂直像素" class="headerlink" title="图像容量计算640(水平像素)×480(垂直像素)"></a>图像容量计算<del>640(水平像素)×480(垂直像素)</del></h6><p>颜色深度的单位是 “位 bit “<strong>，</strong>图像容量的单位是字节B； <strong>1 Byte &#x3D; 8 Bits</strong></p>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">知道<strong>像素，位数</strong></td>
<td align="center">每个像素为16位，图像位640×480像素，求容量：<br />640×480×16÷8&#x3D;614400B</td>
</tr>
<tr>
<td align="center">知道<strong>像素，色数</strong></td>
<td align="center">640×480像素，256色的图像，求容量：<br />640×480×log<del>2</del>(256)÷8&#x3D;307200B</td>
</tr>
</tbody></table>
<h6 id="音频容量计算"><a href="#音频容量计算" class="headerlink" title="音频容量计算"></a><strong>音频</strong>容量计算</h6><p>音频<span style = "color : red"><u>容量 &#x3D; 声道数 * 采样频率(Hz) * 量化位数 * 长度 &#x2F; 8</u></span> </p>
<h6 id="视频容量计算"><a href="#视频容量计算" class="headerlink" title="视频容量计算"></a>视频容量计算</h6><p>视频<u><span style = "color : red">容量 &#x3D; 每帧图像容量(Byte) * 每秒帧数 * 时间 + 音频容量 * 时间</span></u> </p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f98d8d3c2a788f0999bdbeee030b01b7a9bfd1dd/data/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%B8%B8%E8%A7%81%E8%AE%A1%E7%AE%97%E9%A2%98.jpg" style="zoom: 200%;" />



<h3 id="常见的多媒体标准"><a href="#常见的多媒体标准" class="headerlink" title="常见的多媒体标准"></a>常见的多媒体标准</h3><img src="https://raw.githubusercontent.com/P-luminary/images/82d3b6184da3dd2184662eebdcfb18c792f1fbb8/data/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E5%87%86.jpg" style="zoom:150%;" />

<p>&#x3D;&#x3D;@@ <strong>存储动画</strong>的文件格式有<strong>FLC、GIF、SWF</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>网络视频格式</strong>包括<strong>MOV、RM、ASF、WMV</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>多媒体视频图像文件</strong>格式有<strong>AVI、MPG、ASF、MP4</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>声音、音频文件</strong>格式有<strong>WAV、WMA、MP3、MIDI、RA、APE</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ 属于<strong>图像文件</strong>格式有<strong>GIF、BMP、JPG、PNG、TIF</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</p>
</blockquote>
<p>@@ 位图（Bitmap）&#x3D;&gt; <strong>BMP</strong></p>
<p>@@ <strong>语音识别技术</strong>体现了<u><strong>多媒体技术</strong>与<strong>人工智能技术</strong></u>相结合</p>
<h3 id="数据压缩基础"><a href="#数据压缩基础" class="headerlink" title="数据压缩基础"></a>数据压缩基础</h3><h6 id="空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"><a href="#空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余" class="headerlink" title="空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"></a>空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余</h6><blockquote>
<p>空间冗余：图片大面积相同色(白色)，记录哪些信息是白色<br>时间冗余：固定在一个界面跳舞时，后面的物体不会动，墙面不会动。不动的记录下来。有变动的就分析<br>视觉冗余：jpeg人眼视觉识别盲区(视觉边界点压缩)<br>信息熵冗余：不同的信息编码冗余度不一样，通过合理的信息编码<br>结构冗余：某个部件有大量冗余，地砖花纹一样<br>知识冗余：可以通过知识分析得到的信息</p>
</blockquote>
<h3 id="有损压缩与无损压缩"><a href="#有损压缩与无损压缩" class="headerlink" title="有损压缩与无损压缩"></a>有损压缩与无损压缩</h3><p><strong>无损压缩编码法</strong>(Lossless compression coding)：也称之为**<u>冗余压缩法</u><strong>或</strong><u>熵编码法</u>**<br><strong>有损压缩编码法</strong>(Loss compression coding)：**<u>熵压缩法</u>**</p>
<p>jpeg属于有损(比较高的<strong>压缩比</strong>)，无法还原成原始图(位图)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/29624beeddd6478ad781db7390d2f5f06ef4b077/data/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9.jpg" style="zoom:150%;" />



<h1 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a><span style = "color : red">软件开发模型</span></h1><h6 id="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"><a href="#瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型" class="headerlink" title="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"></a>瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型</h6><h6 id="迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"><a href="#迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法" class="headerlink" title="迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"></a>迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法</h6><p>@@ 在面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是<strong>重构</strong>，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为</p>
<h3 id="瀑布模型-SDLC"><a href="#瀑布模型-SDLC" class="headerlink" title="瀑布模型(SDLC)"></a>瀑布模型(SDLC)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/edf996ef9e67822a8fd47b5bb4d82cc0e27df1cc/data/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="原型、演化模型、增量模型"><a href="#原型、演化模型、增量模型" class="headerlink" title="原型、演化模型、增量模型"></a>原型、演化模型、增量模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4192bb3614abbf4dc5fba19b3579e89f2c9733e5/data/%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 200%;" />



<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/bf416fffe7f4d6101f0f259d902725345b8b7073/data/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="V模型-喷泉模型-RAD"><a href="#V模型-喷泉模型-RAD" class="headerlink" title="V模型 喷泉模型 RAD"></a>V模型 喷泉模型 RAD</h3><img src="https://raw.githubusercontent.com/P-luminary/images/cfa6ef57982d81474f45287c3473d6a78b7cac94/data/V%E6%A8%A1%E5%9E%8B%2CRAD%E6%A8%A1%E5%9E%8B%2C%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="构件组装模型-CBSD"><a href="#构件组装模型-CBSD" class="headerlink" title="构件组装模型(CBSD)"></a>构件组装模型(CBSD)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b7dbdfdbadf9e20a5a654b763c50c504059633a6/data/%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B(CBSD).jpg" style="zoom:150%;" />



<h3 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a6d4004b4a88b542a3b60744ea61fa0bc0286a38/data/%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="敏捷开发方法"><a href="#敏捷开发方法" class="headerlink" title="敏捷开发方法"></a>敏捷开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/094d4931d137335862a4652dda044769f4724e11/data/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e9941766b405f6b796c6ad35cf1d00c8dd5e52ec/data/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="需求分类与需求获取"><a href="#需求分类与需求获取" class="headerlink" title="需求分类与需求获取"></a>需求分类与需求获取</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0e7091e237ecadc19e2e7b191c975f4d22a2e920/data/%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%B8%8E%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96.jpg" style="zoom:150%;" />



<h3 id="结构化设计：基本原则、内聚与耦合"><a href="#结构化设计：基本原则、内聚与耦合" class="headerlink" title="结构化设计：基本原则、内聚与耦合"></a>结构化设计：基本原则、内聚与耦合</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dbfbb4b62414e0f7badb40473f22b0df8078b24/data/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2B%E5%86%85%E8%81%9A%E8%80%A6%E5%90%88.jpg"  />



<h3 id="结构化设计-—-系统结构-x2F-模块结构"><a href="#结构化设计-—-系统结构-x2F-模块结构" class="headerlink" title="结构化设计 — 系统结构&#x2F;模块结构"></a>结构化设计 — 系统结构&#x2F;模块结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a003e2c14ea40399387d9f05450bba7019dd4893/data/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E3%80%81%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.jpg"  />



<h3 id="软件测试-—-测试原型与类型"><a href="#软件测试-—-测试原型与类型" class="headerlink" title="软件测试 — 测试原型与类型"></a>软件测试 — 测试原型与类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b84b307d4d1b5810ceddc7301b06ba3c7717ccda/data/%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="软件测试-—-测试用例设计"><a href="#软件测试-—-测试用例设计" class="headerlink" title="软件测试 — 测试用例设计"></a>软件测试 — 测试用例设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/46ed2bab41cbcb40fafbbaa2487b58c157668a67/data/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="软件测试-—-测试阶段"><a href="#软件测试-—-测试阶段" class="headerlink" title="软件测试 — 测试阶段"></a>软件测试 — 测试阶段</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d20a8c0ee445282402c3922a6bf949584ba9f08f/data/%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="McCabe复杂度"><a href="#McCabe复杂度" class="headerlink" title="  McCabe复杂度"></a><span style = "color:red">  McCabe复杂度</span></h3><p>McCabe度量法概念：</p>
<p>McCabe度量法是通过定义环路复杂度，建立程序复杂度的度量，他是基于一个程序模块的程序图中环路的个数。计算G的环路复杂型有两种方法：<br><strong>第一种是<span style = "color:red">V(G)&#x3D;m-n+2（m值得是有向弧数，也就是箭头的个数，n指的是结点个数</span></strong><br><strong>另外一种求法就是<span style = "color:red">闭合区域的个数+1</span></strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/1a9f9515b1e11b17d0b83762ee9bd874c8d450fd/data/McCadbe%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg"  /></p>
<h3 id="系统运行与维护"><a href="#系统运行与维护" class="headerlink" title="系统运行与维护"></a>系统运行与维护</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/44f90a15642e6a63893cbd9523466090a2d41f60/data/%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4.jpg"></p>
<h3 id="软件过程改进—CMMI"><a href="#软件过程改进—CMMI" class="headerlink" title="软件过程改进—CMMI"></a>软件过程改进—CMMI</h3><img src="https://raw.githubusercontent.com/P-luminary/images/555421c326e1c60558f4b1b0f7a2ce5cfd35dbbc/data/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B%E2%80%94CMMI.jpg" style="zoom:150%;" />



<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e4485104aee8d683f76cb7a54045d9308e260f70/data/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2B%E4%BE%8B%E9%A2%98.jpg"  />



<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><h6 id="风险是指”损失或伤害的可能性”"><a href="#风险是指”损失或伤害的可能性”" class="headerlink" title="风险是指”损失或伤害的可能性”"></a>风险是指”损失或伤害的可能性”</h6><p><u>软件风险一般包含<strong>不确定性</strong>和<strong>损失</strong></u>。<u><strong>救火</strong>和<strong>危机管理</strong>是对不适合但经常采用的软件风险管理策略</u>，<u><strong>已知风险</strong>和<strong>未知风险</strong>是对软件风险进行分类的一种方式</u>。<u><strong>员工</strong>和<strong>预算</strong>是在识别项目风险时需要识别的因素</u></p>
<p><strong>项目风险(关心未来)、技术风险(关心变化)、商业风险(关心选择)</strong><br><strong>风险曝光度(Risk Exposure)<strong>：计算方法是</strong>风险出现的概率 × 风险可能造成的损失</strong><br>假设正在开发的软件项目可能存在一个未被发现的错误，而这个错误出现的概率是0.5%，给公司造成的损失将是1000000元，那么这个错误的<strong>风险曝光度</strong>就应该为1000000×0.5%&#x3D;5000元</p>
<h3 id="需求开发-需求分析-OOA-—-相关概念"><a href="#需求开发-需求分析-OOA-—-相关概念" class="headerlink" title="需求开发,需求分析,OOA — 相关概念"></a>需求开发,需求分析,OOA — 相关概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9539033cf94cba3e4edaef3098f61e7ccc9704ea/data/%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91%2C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.OOA.jpg" style="zoom:150%;" />



<h3 id="面向对象设计-—-设计原则"><a href="#面向对象设计-—-设计原则" class="headerlink" title="面向对象设计 — 设计原则"></a>面向对象设计 — 设计原则</h3><p><strong>单一职责原则</strong>：设计目的单一的类 (单一会降低程序的耦合度)<br><strong>开放—封闭原则</strong>: 对<u>扩展</u>开放，对<u>修改</u>封闭 (用新的类去解决问题 不去修改[容易引入错误影响原先])<br><strong>李氏(Liskov)替换原则</strong>：子类可以替换父类 (不要盲目修改父类 不要去<strong>重载</strong>)<br><strong>接口隔离原则</strong>：使用多个专门的接口比使用单个的总接口要好<br><strong>组合重用原则</strong>：要尽量使用组合，而不是继承关系达到重用的目的<br>**迪米特(Demeter)原则(最少知识法则)**：一个对象应当对其他对象又尽可能少的了解  </p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><img src="https://raw.githubusercontent.com/P-luminary/images/fcb3f16cbb5d336b7895d58d40e877ff57652b4e/data/UML.jpg" style="zoom:150%;" />



<h3 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h3><p>**<u>√ 架构模式</u>**：软件设计中的高层决策，例如C&#x2F;S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策<br>**<u>√ 设计模式</u>**：主要关注软件系统的设计，与具体的实现语言无关<br>**<u>√ 惯用法</u>**：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用—计数就是C++语言中的一种惯用法 </p>
<h3 id="面向对象-—-设计模式的分类"><a href="#面向对象-—-设计模式的分类" class="headerlink" title="面向对象 — 设计模式的分类"></a>面向对象 — 设计模式的分类</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9012605b3052dcc5d44c980ca3cac2f2f206697d/data/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB.jpg" style="zoom:150%;" />



<h3 id="面向对象-—-创建型模式"><a href="#面向对象-—-创建型模式" class="headerlink" title="面向对象 — 创建型模式"></a>面向对象 — 创建型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abstract Factory 抽象工厂模式</td>
<td>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需置顶它们具体的类</td>
</tr>
<tr>
<td>Builder 构建器模式</td>
<td>将一个复杂类的表示与其构造相分离，使得相同的构造过程能够得出不同的表示</td>
</tr>
<tr>
<td>Factory Method 工厂方法模式</td>
<td>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工程方法使得子类实例化的过程推迟</td>
</tr>
<tr>
<td>Prototype 原型模式</td>
<td>用原型实例指定创建对象的类型，并且通过拷贝这个原型来<strong>创建新的对象</strong></td>
</tr>
<tr>
<td>Singleton 单例模式</td>
<td>保证一个类只有一个实例，并提供一个访问它的全局访问点</td>
</tr>
</tbody></table>
<h3 id="面向对象-—-结构型模式"><a href="#面向对象-—-结构型模式" class="headerlink" title="面向对象 — 结构型模式"></a>面向对象 — 结构型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Adapter 适配器模式</td>
<td>将一个类的接口转换成用户希望得到的另一种接口。它使原来不相容的接口得以协同工作</td>
<td><strong>转换</strong>接口</td>
</tr>
<tr>
<td>Bridge 桥接模式</td>
<td>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化</td>
<td>继承树拆分</td>
</tr>
<tr>
<td>Composite 组合模式</td>
<td>将对象组合成树型结构以表示”整体—部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</td>
<td>树形目录结构</td>
</tr>
<tr>
<td>Decorator 装饰模式</td>
<td>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的代替，比派生一个子类更加灵活</td>
<td><strong>附加职责</strong></td>
</tr>
<tr>
<td>Facade 外观模式</td>
<td>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</td>
<td>对外统一接口</td>
</tr>
<tr>
<td>Flyweight 享元模式</td>
<td>提供支持大量细粒度对象共享的有效方法</td>
<td></td>
</tr>
<tr>
<td>Proxy 代理模式</td>
<td>为其他对象提供一种代理以控制这个对象的访问</td>
<td></td>
</tr>
</tbody></table>
<h3 id="面向对象-—-行为型模式"><a href="#面向对象-—-行为型模式" class="headerlink" title="面向对象 — 行为型模式"></a>面向对象 — 行为型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Chain of Responsibility 职责链模式</td>
<td>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求</td>
<td><strong>传递职责</strong></td>
</tr>
<tr>
<td>Command 命令模式</td>
<td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</td>
<td>日志记录，可<strong>撤销</strong></td>
</tr>
<tr>
<td>Interpreter 解释器模式</td>
<td>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</td>
<td></td>
</tr>
<tr>
<td>Iterator 迭代器模式</td>
<td>提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</td>
<td></td>
</tr>
<tr>
<td>Mediator 中介者模式</td>
<td>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地互相条用，从而达到低耦合，还可也独立地改变对象间的交互</td>
<td>不直接引用</td>
</tr>
<tr>
<td>Memento 备忘录模式</td>
<td>在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</td>
<td></td>
</tr>
<tr>
<td>Observer 观察者模式</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</td>
<td></td>
</tr>
<tr>
<td>State 状态模式</td>
<td>允许一个对象在其内部状态改变时改变它的行为</td>
<td>状态变成类</td>
</tr>
<tr>
<td>Strategy 策略模式</td>
<td>定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化</td>
<td>多方案切换</td>
</tr>
<tr>
<td>Template Method 模板方法模式</td>
<td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</td>
<td></td>
</tr>
<tr>
<td>Visitor 访问者模式</td>
<td>表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</td>
<td></td>
</tr>
</tbody></table>
<h1 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a><span style = "color : red">数据流图(DFD)</span></h1><h3 id="数据流图基本概念"><a href="#数据流图基本概念" class="headerlink" title="数据流图基本概念"></a>数据流图基本概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/c8df5734504fe26e49886e57a4bb57abd5fda23b/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg"  />



<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&#x3D;</strong></td>
<td>被定义为</td>
<td></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>与</td>
<td>x&#x3D;a+b, 表示x由a和b组成</td>
</tr>
<tr>
<td><strong>[… , …]或[… | …]</strong></td>
<td>或</td>
<td>x&#x3D;[a,b], x&#x3D;[a|b], 表示x由a或由b组成</td>
</tr>
<tr>
<td><strong>{…}</strong></td>
<td>重复</td>
<td>x&#x3D;{a}, 表示x由0个或多个a组成</td>
</tr>
<tr>
<td><strong>(…)</strong></td>
<td>可选</td>
<td>x&#x3D;(a), 表示a可在x中出现, 也可以不出现</td>
</tr>
</tbody></table>
<p>机票 &#x3D; 姓名 + 日期 + 航班号 + 起点 + 终点 + 费用<br>航班号 &#x3D; “Y7100”..”Y8100”<br>终点 &#x3D; [长沙|上海|北京|西安]</p>
<blockquote>
<p>选择四个其中的一个终点 </p>
</blockquote>
<h3 id="数据流图平衡原则"><a href="#数据流图平衡原则" class="headerlink" title="数据流图平衡原则"></a>数据流图平衡原则</h3><h6 id="父图与子图之间的平衡、子图内平衡"><a href="#父图与子图之间的平衡、子图内平衡" class="headerlink" title="父图与子图之间的平衡、子图内平衡"></a>父图与子图之间的平衡、子图内平衡</h6><img src="https://raw.githubusercontent.com/P-luminary/images/1c65b63a43bfe88afc4ce4e4042e655c99848c3c/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%B9%B3%E8%A1%A1%E5%8E%9F%E5%88%99.jpg" style="zoom: 150%;" />



<h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3><img src="https://raw.githubusercontent.com/P-luminary/images/514e5a6749072475b5c75298c83b77800d4abae2/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7.jpg"  />



<h3 id="试题1"><a href="#试题1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/6d1ff8a821e6d03a30594af8710226314ef1e8fa/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E8%AF%95%E9%A2%981.png"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/c2212e4f52fe19b0da0244a88e8b50c5a81d2683/data/%E8%AF%95%E9%A2%981.1.jpg" style="zoom:150%;" />

<h5 id="第一问解析"><a href="#第一问解析" class="headerlink" title="第一问解析"></a>第一问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/99c328ecf6d6a5e5499c59f436bb8d2f28f2a139/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%80%E9%97%AE.png" style="zoom: 200%;" /> 



<h5 id="第二问解析"><a href="#第二问解析" class="headerlink" title="第二问解析"></a>第二问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/a6be0c3e3b020d87eeba748e7bbe8ff9b4a8847e/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom: 200%;" />



<h5 id="第三问解析"><a href="#第三问解析" class="headerlink" title="第三问解析"></a>第三问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/efe71851a6ab49d9ee52166ada7f60650d7c62b4/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%89%E9%97%AE.jpg" style="zoom:150%;" />



<h3 id="试题二"><a href="#试题二" class="headerlink" title="试题二"></a>试题二</h3><img src="https://raw.githubusercontent.com/P-luminary/images/38b4712590b799be692dd850b861ec1db1b23d23/data/%E8%AF%95%E9%A2%982.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cf9bf40bae6cecb18dfdf18be5711806ea7ddcf/data/%E8%AF%95%E9%A2%982.1.jpg"></p>
<h5 id="试题2第一问、第二问"><a href="#试题2第一问、第二问" class="headerlink" title="试题2第一问、第二问"></a>试题2第一问、第二问</h5><img src="https://raw.githubusercontent.com/P-luminary/images/e6d32f02094ef61c5486ff737e8f7c1b285a9f07/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom:200%;" />



<h5 id="试题2第三问-顶层和0层进行匹配-、第四问-从题干推导"><a href="#试题2第三问-顶层和0层进行匹配-、第四问-从题干推导" class="headerlink" title="试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)"></a>试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)</h5><img src="https://raw.githubusercontent.com/P-luminary/images/973540b5ce58d035d1c63fd26275bc3d3691dbef/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%89%E9%97%AE%E7%AC%AC%E5%9B%9B%E9%97%AE.jpg" style="zoom:200%;" />



<h3 id="数据库设计过程-1"><a href="#数据库设计过程-1" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4a7e717516686bf53a3016f10555bd298228bb96/data/1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" style="zoom: 200%;" />



<h3 id="ER模型-—-实体间联系类型"><a href="#ER模型-—-实体间联系类型" class="headerlink" title="ER模型 — 实体间联系类型"></a>ER模型 — 实体间联系类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/aef35208a0e0eef63f136821f90002f1f81ae413/data/ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg" style="zoom:150%;" />



<h3 id="数据库设计答题技巧"><a href="#数据库设计答题技巧" class="headerlink" title="数据库设计答题技巧"></a>数据库设计答题技巧</h3><h6 id="详细分析试题说明"><a href="#详细分析试题说明" class="headerlink" title="详细分析试题说明"></a>详细分析试题说明</h6><h6 id="熟练掌握基本知识"><a href="#熟练掌握基本知识" class="headerlink" title="熟练掌握基本知识"></a>熟练掌握基本知识</h6><h3 id="试题1-1"><a href="#试题1-1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7bc5db4a5d355f37629a9621e0e789c10b5e7359/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />



<h3 id="试题2"><a href="#试题2" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/10655b1b9f65d0e3145e7d58aec329857bad9fc0/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%982.png" style="zoom:150%;" />

<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/d40fd82221eb61d4fdd90e911632ab483c946fbb/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BE%8B%E9%A2%982%E8%A7%A3%E6%9E%90.jpg"  />



<h1 id="UML建模"><a href="#UML建模" class="headerlink" title="UML建模"></a><span style = "color : red">UML建模</span></h1><h6 id="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"><a href="#用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图" class="headerlink" title="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"></a>用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图</h6><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e2480d16b16b8b911584fe9f6ded8b19fcbea258/data/%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" style="zoom:150%;" />



<h3 id="类图与对象图"><a href="#类图与对象图" class="headerlink" title="类图与对象图"></a>类图与对象图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7e6cb7c946c5e51dc027f64e32e230d0af3e07e7/data/%E7%B1%BB%E5%9B%BE%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" style="zoom:150%;" />



<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da0cdf7024603417383dedd7f56ffefdc07b7a84/data/%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg"></p>
<h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/f3191e64c57a67bd754427957ff3998827d6c647/data/%E6%B4%BB%E5%8A%A8%E5%9B%BE.jpg"  />



<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d1f705c371a7460cb2078e7c4a1ee9c0b9c36597/data/%E7%8A%B6%E6%80%81%E5%9B%BE.jpg"></p>
<h3 id="通信图-顺序图-通信图-x3D-交互图"><a href="#通信图-顺序图-通信图-x3D-交互图" class="headerlink" title="通信图 (顺序图+通信图&#x3D;交互图)"></a>通信图 (顺序图+通信图&#x3D;交互图)</h3><p>区别：<strong>顺序图</strong>会强调时间顺序</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/4fd0cbc15294926e42fe33e61b7f0035a208ae7a/data/%E9%80%9A%E4%BF%A1%E5%9B%BE.jpg"  />



<h3 id="试题1-2"><a href="#试题1-2" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/914174f05e1265a79bd512c49afe191e67b83ad2/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981.jpg"  />



<h6 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/ffff4a52c486091b284f830b2cda215a26fadc78/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg"  />



<h3 id="试题2-1"><a href="#试题2-1" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b69f8c920bf06a3a3558f95693f3ea0fd04743ee/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982.jpg"  />



<h6 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/a23639f98414f903a56cad32ca174c6f0cd403d0/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E8%A7%A3%E6%9E%90.jpg" style="zoom: 200%;" />



<h6 id="第二、三问"><a href="#第二、三问" class="headerlink" title="第二、三问"></a>第二、三问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/47d8911eaacde30888938f1e434255a077c68f44/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982%E7%AC%AC%E4%BA%8C%E4%B8%89%E9%97%AE.jpg" style="zoom: 200%;" />



<h1 id="★★数据结构及算法应用★★-下午题"><a href="#★★数据结构及算法应用★★-下午题" class="headerlink" title="★★数据结构及算法应用★★(下午题)"></a>★★<span style = "color : red">数据结构及算法应用</span>★★(下午题)</h1><h6 id="分治法、回溯法、贪心法、动态规划法"><a href="#分治法、回溯法、贪心法、动态规划法" class="headerlink" title="分治法、回溯法、贪心法、动态规划法"></a>分治法、回溯法、贪心法、动态规划法</h6><h3 id="分治法-★★-分解-解决-合并-★★-一般用到递归"><a href="#分治法-★★-分解-解决-合并-★★-一般用到递归" class="headerlink" title="分治法(★★ 分解 解决 合并 ★★) [一般用到递归]"></a>分治法(★★ 分解 解决 合并 ★★) [一般用到递归]</h3><p><strong>对于一个规模为n的问题，若该问题可以容易地解决 (比如说规模n较小) 则直接解决；否则将其分解为k个规模较小的子问题，这些子问题相互独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解</strong></p>
<p>★ 该问题的规模缩小到一定的程度就可以容易地解决<br>★ 该问题可以分解为若干个规模较小的相同子问题<br>★ 利用该问题解决出的子问题的解可以合并为该问题的解<br>★ 该问题所分解出的各个子问题是相互独立的</p>
<h5 id="递归，就是在运行的过程中调用自己"><a href="#递归，就是在运行的过程中调用自己" class="headerlink" title="递归，就是在运行的过程中调用自己"></a>递归，就是在运行的过程中调用自己</h5><pre><code class="java">int F(int n)
&#123;
    if(n==0) return 1;
    if(n==1) return 1;
    if(n&gt;1) return F(n-1)+F(n-2);
&#125;
</code></pre>
<h3 id="分治法-→-二分查找"><a href="#分治法-→-二分查找" class="headerlink" title="分治法 → 二分查找"></a>分治法 → 二分查找</h3><pre><code class="java">function Binary_Search(L,a,b,x)&#123;
    if(a &gt; b) return(-1);
    else&#123;
        m=(a+b)/2;
        if(x==L[m]) return(m);
        else if(x &gt; L[m])
            return(Binary_Search(L,m+1,b,x));
        else
            return(Binary_Search(L,a,m-1,x));
    &#125;
&#125;
</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8d1e0521f94cd0d6b1ddf5bee2749ba0f49990b6/data/%E5%9B%9E%E6%BA%AF%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/13d82930889e1c9e254f8685c57c9d092d5a1634/data/%E8%B4%AA%E5%BF%83%E6%B3%95.png" style="zoom: 200%;" />



<h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/eaa958ff79a07a2e5bb606da5dac0cf195f4f6e1/data/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="数据结构算法例题"><a href="#数据结构算法例题" class="headerlink" title="数据结构算法例题"></a>数据结构算法例题</h3><h6 id="试题1-3"><a href="#试题1-3" class="headerlink" title="试题1"></a>试题1</h6><img src="https://raw.githubusercontent.com/P-luminary/images/6cfb68cba4f6641134b0b229642a0b10a9fbb39b/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981.jpg" style="zoom:200%;" />



<h6 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/780bbd00eefa211c7ff3261c7ce6b7f86e244aca/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />





<h6 id="试题2及解析"><a href="#试题2及解析" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/3894f1902e34206481d9cff7a866422151ce0ee8/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:;" />



<h1 id="★★★★★面向对象程序设计-下午题-★★★★★"><a href="#★★★★★面向对象程序设计-下午题-★★★★★" class="headerlink" title="★★★★★面向对象程序设计(下午题)★★★★★"></a>★★★★★<span style = "color : red">面向对象程序设计</span>(下午题)★★★★★</h1><h3 id="C-类与派生类的定义"><a href="#C-类与派生类的定义" class="headerlink" title="C++ 类与派生类的定义"></a>C++ 类与派生类的定义</h3><pre><code class="c++">class 类名&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;;
</code></pre>
<pre><code class="c++">class 派生类名：继承方法1 基类名1，继承方法2 基类名2,...&#123;
    public:
        派生类的公有数据和函数
    protected:
        派生类的保护数据和函数
    private:
        派生类的私有数据和函数
&#125;;
</code></pre>
<pre><code class="c++">在类外定义函数体的格式如下：
返回值类型 类名 :: 成员函数名(形参表)&#123;
    函数体;
&#125;
::是类的作用域分辨符，用在此处，放在类名后成员函数前，表明后面的成员东西函数属于前面的那个类
</code></pre>
<h3 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++构造函数与析构函数"></a>C++构造函数与析构函数</h3><blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.构造函数的函数名必须与定义它的类同名<br>2.构造函数没有返回值。如果在构造函数前加void是错误的<br>3.构造函数被声明定义为公有函数<br>4.构造函数在建立对象时由系统自动调用</p>
</blockquote>
<blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.析构函数没有任何参数，不能被重载，但是可以是虚函数，一个类只有一个析构函数<br>2.析构函数没有返回值<br>3.析构函数名与类名相同，但在类名前加一个逻辑非运算符 “~” 以表示与构造函数对比区别<br>4.析构函数一般由用户自己定义，在对象消失时由系统自动调用，如果用户没有定义析构函数，系统将自动生成一个不做任何事的默认析构函数</p>
</blockquote>
<pre><code class="c++">对象指针的语法定义形式如下：
    类名 *对象指针名;
</code></pre>
<pre><code class="c++">对象引用的定义形式如下：
    类名 &amp;对象引用名 = 被引用对象;
</code></pre>
<blockquote>
<p>注意：通过对象名或对象引用访问对象的成员，使用的运算符是 “.” 而使用对象指针访问对象成员，使用的运算符是 “-&gt;” </p>
<pre><code class="c++">对象指针名 -&gt; 数据成员名或 : 对象指针名 -&gt; 成员函数名(参数表) 
</code></pre>
</blockquote>
<h3 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a><span style = "color : red">C++虚函数</span></h3><pre><code class="c++">虚函数定义的一般语法形式如下:
virtual 函数类型 函数名(形参表)&#123;
    函数体;
&#125;
纯虚函数定义形式如下：
virtual 函数名 = 0;
</code></pre>
<h3 id="JAVA-类的定义"><a href="#JAVA-类的定义" class="headerlink" title="JAVA 类的定义"></a>JAVA 类的定义</h3><pre><code class="java">类的定义格式如下：
[import包]
[类修饰符] class xxxclass [extends超类] [implements接口]&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;
说明：
import包：引入包中的类
类修饰符：主要由四个修饰符(public、abstract、final、private)
class为关键字, xxxclass为类名，命名遵循Java标识符的命名规则
extends为继承关键字，implements为接口关键字
    
抽象类定义
abstract class Shape&#123;
    abstract public void draw() [定义了draw抽象方法]
&#125;

class Rectangle extends Shape&#123;&#125;
通过extends可以看出来Shape不是接口而是抽象类
</code></pre>
<pre><code class="java">import java.util.*;
(1) class Beverage&#123; //饮料
    String description = &quot;Unknown Beverage&quot;;
    public (2) ()&#123;return description;&#125;
        public (3);
&#125;
abstract class CondimentDecorator extends Beverage&#123;
    //配料
    (4);
&#125;

(1) abstract
(2) String getDescription
(3) abstract int cost()
(4) Beverage beverage
</code></pre>
<h3 id="JAVA-接口的定义"><a href="#JAVA-接口的定义" class="headerlink" title="JAVA 接口的定义"></a>JAVA 接口的定义</h3><pre><code class="java">interface IFactory&#123;&#125;
class SqlServerFactory implements IFactory
通过implements实现关键字来反推interface关键字
</code></pre>
<h3 id="面向程序设计"><a href="#面向程序设计" class="headerlink" title="面向程序设计"></a>面向程序设计</h3><h6 id="试题1及解析"><a href="#试题1及解析" class="headerlink" title="试题1及解析"></a>试题1及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/4d295300a1b912819bf30f980a891b23c6749154/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%981%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />

<h6 id="试题2及解析-1"><a href="#试题2及解析-1" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/2f0c15a8321c8414a2eae0bc4ff245c483b9c943/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />




















            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/软考" style=color:#879cff>
                软考
            </a>
        </span>
        
    </div>

    <a href="/2023/05/06/软考/软件设计师考点/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/4/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
        </span>
        

        <span class="current">
            5
        </span>

        
        <span>
            <a href="/page/6/">
                <span class="page-num">
                    6
                </span>
            </a>
            
            <a href="/page/7">
                <span class="page-num">
                    7
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/6/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>