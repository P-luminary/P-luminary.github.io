
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2022/03/25/语法/MarkDown语法/">
        <h2>
            MarkDown语法
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Markdown快速入门（typora"><a href="#Markdown快速入门（typora" class="headerlink" title="Markdown快速入门（typora)"></a>Markdown快速入门（typora)</h1><h4 id="1、代码块："><a href="#1、代码块：" class="headerlink" title="1、代码块："></a>1、代码块：</h4><pre><code class="java">//代码块语法：
```java
```c++
</code></pre>
<h5 id="①-java代码"><a href="#①-java代码" class="headerlink" title="①. java代码"></a>①. java代码</h5><pre><code class="java">package com.pcy.po;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

@Entity
@Table(name = &quot;t_user&quot;)
public class User&#123;
    
&#125;
</code></pre>
<h5 id="②-c-代码"><a href="#②-c-代码" class="headerlink" title="②. c++代码"></a>②. c++代码</h5><pre><code class="c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
char s[1005];
int main()&#123;
    while(scanf(&quot;%s&quot;,s) != EOF);
    cout &lt;&lt; (int)strlen(s);
    return 0;
&#125;
</code></pre>
<h4 id="2、标题："><a href="#2、标题：" class="headerlink" title="2、标题："></a>2、标题：</h4><pre><code class="java">//标题语法
 # 一级标签
 ## 二级标签
 ### 三级标签
 #### 四级标签
 ##### 五级标签
 ###### 六级标签
</code></pre>
<h1 id="一级标签"><a href="#一级标签" class="headerlink" title="一级标签"></a>一级标签</h1><h2 id="二级标签"><a href="#二级标签" class="headerlink" title="二级标签"></a>二级标签</h2><h3 id="三级标签"><a href="#三级标签" class="headerlink" title="三级标签"></a>三级标签</h3><h4 id="四级标签"><a href="#四级标签" class="headerlink" title="四级标签"></a>四级标签</h4><h5 id="五级标签"><a href="#五级标签" class="headerlink" title="五级标签"></a>五级标签</h5><h6 id="六级标签"><a href="#六级标签" class="headerlink" title="六级标签"></a>六级标签</h6><h4 id="3、字体："><a href="#3、字体：" class="headerlink" title="3、字体："></a>3、字体：</h4><pre><code class="java">//斜体
*第一次写博客*
//加粗
**第一次写博客**
//代码高亮显示
==第一次写博客==
//删除线
~~第一次写博客~~
//下划线
&lt;u&gt;第一次写博客&lt;/u&gt;
//脚注
第一次写博客[^Asuna]
</code></pre>
<p><em>第一次写博客</em><br><strong>第一次写博客</strong><br>&#x3D;&#x3D;第一次写博客&#x3D;&#x3D;<br><del>第一次写博客</del><br><u>第一次写博客</u></p>
<p>第一次写博客[^Asuna]</p>
<h4 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h4><pre><code class="java">//引用语法
&gt;作者：Kirito
&gt;&gt;作者：Kirito
&gt;&gt;&gt;作者：Kirito
+
-
</code></pre>
<blockquote>
<p>作者：Kirito</p>
<blockquote>
<p>作者：Kirito</p>
<blockquote>
<p>作者：Kirito</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线:"></a>5、分割线:</h4><pre><code class="java">//分割线
---
//分割线2
***
</code></pre>
<hr>
<hr>
<h4 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h4><pre><code class="java">//在线图片 || 本地图片
![我的照片](/image/XXX.png 或 用图床上传至GitHub 然后右键复制图片链接 再从浏览器中打开 再右键复制图像链接) --图片路径
[敲重点]Markdown可以通过普通的&lt;img&gt;标签来指定图片的 高度 和 宽度
&lt;img src = &quot;https://raw.githubusercontent.com/P-luminary/image/master/data/avatar.png&quot; width = &quot;50%&quot;&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/image/master/data/avatar.png" alt="我的照片"></p>
<img src="https://raw.githubusercontent.com/P-luminary/image/master/data/avatar.png" width = "20%">



<h4 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h4><pre><code class="java">//超链接语法
[P-luminary GitHub](https://github.com/Luminarness)
</code></pre>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/P-luminary">P-luminary 的 GitHub</a></li>
</ul>
<h4 id="8、列表"><a href="#8、列表" class="headerlink" title="8、列表"></a>8、列表</h4><pre><code class="java">//无序列表 (&quot;-&quot;是实心圈  &quot;+&quot;是空心圈)
- 目录1
- 目录2
- 目录3
//有序列表
数字键 + &quot;.&quot; + 名称
//列表嵌套(需要在子列表中的选项前面添加四个空格)
1. 第一项
    - 第一项嵌套的第一个元素
2. 第二项
    - 第二项嵌套的第二个元素
</code></pre>
<ul>
<li><p>目录1</p>
</li>
<li><p>目录2</p>
</li>
<li><p>目录3</p>
<ol>
<li><p>首页</p>
</li>
<li><p>分类</p>
</li>
<li><p>标签</p>
</li>
<li><p>第一项</p>
<ul>
<li>第一项嵌套的第一个元素</li>
</ul>
</li>
<li><p>第二项</p>
<ul>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h4><pre><code class="java">在Typora中右键 -&gt; 插入 -&gt; 表格
</code></pre>
<table>
<thead>
<tr>
<th>日期</th>
<th>心情</th>
<th>饱和度</th>
</tr>
</thead>
<tbody><tr>
<td>2022-03-25 1:27</td>
<td>非常好</td>
<td>满</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/语法" style=color:#ff7d73>
                语法
            </a>
        </span>
        
    </div>

    <a href="/2022/03/25/语法/MarkDown语法/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/03/25/竞赛-算法/PTA技巧/">
        <h2>
            PTA技巧
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/3/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="时间优化-（写好的代码有测试点运行超时-可以暂时放下-不要浪费时间）"><a href="#时间优化-（写好的代码有测试点运行超时-可以暂时放下-不要浪费时间）" class="headerlink" title="时间优化:（写好的代码有测试点运行超时, 可以暂时放下, 不要浪费时间）"></a>时间优化:（写好的代码有测试点运行超时, 可以暂时放下, 不要浪费时间）</h3><ol>
<li><p>如果出现运行超时考虑是否因为<strong>非法输入</strong>导致死循环</p>
</li>
<li><p>尽量创建全局变量(创建一次，后面赋值)，不要重复创建临时变量</p>
</li>
<li><p>尽量使用scanf，printf，而不使用<del>cin，cout</del> (C++的IO存在缓存(可取消))</p>
</li>
</ol>
<pre><code class="c++">#include &lt;bits/stdc++.h&gt; //万能头
using namespace std;
→→→    ios::sync_with_stdio(false); ←←←
→→→    cin.tie(0);cout.tie(0);    ←←←
</code></pre>
<ol start="4">
<li>使用引用访问容器中的元素(遍历，排序&#x3D;&#x3D;&gt;<u>增强型for循环</u>)</li>
</ol>
<pre><code class="c++">vector&lt;int&gt; vc&#123;0,1,2,3&#125;;
for(int&amp; i : vc)
    cout &lt;&lt; i;
</code></pre>
<ol start="5">
<li><p>使用unordered_map，unordered_set替换map，set可以提升效率(注意改头文件)</p>
</li>
<li><p>为了实现排序功能，尽量使用sort对数组排序，而不要依赖与map和set的自动排序(map，set结构庞大)</p>
</li>
<li><p>一般递归算法都比较慢，深搜(DFS)可以通过剪枝优化，并查集可以进行路径压缩提升效率。</p>
</li>
</ol>
<hr>
<h3 id="时间优化"><a href="#时间优化" class="headerlink" title="时间优化:"></a>时间优化:</h3><ol>
<li><p>为了方便函数调用，可以都用全局变量(但这是个<em>坏习惯</em>)</p>
</li>
<li><p>不确定数据多少的情况，不一定非要用动态数组，可以直接根据题目给的数据范围定义一个较大的数组（大小应大于题目所给的范围），一般情况下不会出现内存超限 [数组大小别超过10^8，二维数组不能超过array(10000)(10000)]</p>
</li>
<li><p><strong>答案错误</strong>很有可能是漏了题目的<u>关键信息</u></p>
</li>
<li><p><strong>格式错误</strong>是因为排版跟题目要求不同，可能<u>多空格或空行</u></p>
</li>
<li><p><strong>段错误</strong>是因为非法访问才会导致，一般情况下是因为<u>数组访问越界</u></p>
</li>
<li><p><strong>涉及到除法的</strong>要考虑除数不能为0，一般会有一个测试点</p>
</li>
<li><p><strong>图论问题</strong>用深搜可以得到大部分的分</p>
</li>
<li><p>选取<strong>适当的结构</strong>(容器)可以让思路更清晰</p>
</li>
<li><p>熟悉编译器的调试功能(Debug)可以更快找出bug</p>
</li>
</ol>
<hr>
<h3 id="必备知识："><a href="#必备知识：" class="headerlink" title="必备知识："></a>必备知识：</h3><p>​    数据结构与算法：</p>
<ol>
<li><p>树：二叉树的遍历方式，平衡二叉树的建树过程，根据两种遍历来建树</p>
</li>
<li><p>图：深搜，广（层）搜，并查集<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzxl/p/7226557.html">（推荐博客）</a>。</p>
</li>
<li><p>堆：堆结构，建堆过程（堆排序）。</p>
</li>
<li><p>链表：根据结点连接链表（一般通过结构体进行模拟）。</p>
</li>
<li><p>排序：熟悉快排和归并排序的排序过程</p>
</li>
</ol>
<h3 id="常用库、函数-黑科技"><a href="#常用库、函数-黑科技" class="headerlink" title="常用库、函数(黑科技)"></a>常用库、函数(黑科技)</h3><h6 id="容器、字符串处理、lambda表达式、自定义排序、类型转换、数值边界、数学函数、auto关键字、堆、常用功能函数-查找-计数-倒序"><a href="#容器、字符串处理、lambda表达式、自定义排序、类型转换、数值边界、数学函数、auto关键字、堆、常用功能函数-查找-计数-倒序" class="headerlink" title="容器、字符串处理、lambda表达式、自定义排序、类型转换、数值边界、数学函数、auto关键字、堆、常用功能函数(查找 计数 倒序)"></a><em>容器、字符串处理、lambda表达式、自定义排序、类型转换、数值边界、数学函数、auto关键字、堆、常用功能函数(查找 计数 倒序)</em></h6><table>
<thead>
<tr>
<th>知识点</th>
<th>说明</th>
<th>推荐博客</th>
</tr>
</thead>
<tbody><tr>
<td>string容器</td>
<td>封装了一些对字符串的常用操作</td>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40946921/article/details/104836507">C++ String详解</a></td>
</tr>
<tr>
<td>regex正则表达式</td>
<td>使用正则表达式来替换、查找字符串</td>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34802416/article/details/79307102">C++ 正则表达式</a></td>
</tr>
<tr>
<td>stirngstream字符串IO类</td>
<td>使用字符串来进行IO操作</td>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuchanming/p/3906176.html">C++ stringstream</a></td>
</tr>
<tr>
<td>常用字符处理函数</td>
<td>isdigit(char ch)</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><p>sort函数排序，自定义结构体比较方式</p>
</li>
<li><p>STL标准库list，vector，queue，stack，map，set</p>
</li>
<li><p>数组(容器)倒序</p>
<ol>
<li>倒序函数: void reverse(typename begin, typename end);</li>
<li>利用反向迭代器倒序(构造new string)</li>
</ol>
</li>
<li><p>auto关键字</p>
</li>
<li><p>find函数</p>
</li>
</ol>
<pre><code class="c++">string str; // string类函数:未找到返回string::npos
if(str.find(&quot;substr&quot;) != string::npos);
    //......
set&lt;int&gt; st;
if(st.find(0) != st.end()); //set、map成员函数: 未找到返回尾迭代器
    //......
vector&lt;int&gt; vc;
if(find(vc.begin(),vc.end(),0) != vc.end()); //序列式容器可以通过algorithm库中的find
    //......
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/竞赛/算法" style=color:#ff7d73>
                竞赛/算法
            </a>
        </span>
        
    </div>

    <a href="/2022/03/25/竞赛-算法/PTA技巧/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2022/01/15/后端/Redis实战篇/">
        <h2>
            Redis实战
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="黑马点评Redis"><a href="#黑马点评Redis" class="headerlink" title="黑马点评Redis"></a>黑马点评Redis</h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/88713189f951d8ab6d78aec97873de573d169d7b/Redis%E5%AE%9E%E6%88%98%E7%AF%87.png"></p>
<h3 id="实现短信的登录和注册"><a href="#实现短信的登录和注册" class="headerlink" title="实现短信的登录和注册"></a>实现短信的登录和注册</h3><pre><code class="java">com/hmdp/controller/UserController.java
package com.hmdp.controller;


import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.RandomUtil;
import com.hmdp.dto.LoginFormDTO;
import com.hmdp.dto.Result;
import com.hmdp.dto.UserDTO;
import com.hmdp.entity.User;
import com.hmdp.entity.UserInfo;
import com.hmdp.service.IUserInfoService;
import com.hmdp.service.IUserService;
import com.hmdp.utils.RegexUtils;
import com.hmdp.utils.SystemConstants;
import com.hmdp.utils.UserHolder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import javax.servlet.http.HttpSession;

import static com.baomidou.mybatisplus.core.toolkit.Wrappers.lambdaQuery;
import static com.baomidou.mybatisplus.core.toolkit.Wrappers.query;


/**
 * &lt;p&gt;
 * 前端控制器
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@Slf4j
@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    @Resource
    private IUserService userService;

    @Resource
    private IUserInfoService userInfoService;

    /**
     * 发送手机验证码
     */
    @PostMapping(&quot;code&quot;)
    public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123;
        return userService.sendCode(phone, session);
    &#125;

    /**
     * 登录功能
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping(&quot;/login&quot;)
    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123;
        String phone = loginForm.getPhone();
        // 校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 校验验证码
        Object cacheCode = session.getAttribute(&quot;code&quot;);
        String code = loginForm.getCode();

        // 不一致 报错
        if (cacheCode == null || !code.equals(cacheCode)) &#123;
            return Result.fail(&quot;验证码错误&quot;);
        &#125;

        // 一致 根据手机号查询用户 用mybatisplus
        User user = userService.getOne(lambdaQuery(User.class).eq(User::getPhone, phone));
        // 判断用户是否存在
        if (ObjectUtil.isEmpty(user)) &#123;
            // 不存在 创建新用户保存
            user = new User();
            user.setPhone(phone);
            user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
            userService.save(user);
        &#125;
        // 存在 保存用户信息到session当中
        UserDTO userDTO = new UserDTO();
        userDTO.setId(user.getId());
        userDTO.setNickName(user.getNickName());
        userDTO.setPhone(user.getPhone());
        session.setAttribute(&quot;user&quot;, userDTO); // 确保保存的是 UserDTO 对象
        return Result.ok();
    &#125;

    /**
     * 登出功能
     * @return 无
     */
    @PostMapping(&quot;/logout&quot;)
    public Result logout()&#123;
        // TODO 实现登出功能
        return Result.fail(&quot;功能未完成&quot;);
    &#125;

    @GetMapping(&quot;/me&quot;)
    public Result me()&#123;
        // TODO 获取当前登录的用户并返回
        UserDTO user = UserHolder.getUser();
        return Result.ok(user);
    &#125;

    @GetMapping(&quot;/info/&#123;id&#125;&quot;)
    public Result info(@PathVariable(&quot;id&quot;) Long userId)&#123;
        // 查询详情
        UserInfo info = userInfoService.getById(userId);
        if (info == null) &#123;
            // 没有详情，应该是第一次查看详情
            return Result.ok();
        &#125;
        info.setCreateTime(null);
        info.setUpdateTime(null);
        // 返回
        return Result.ok(info);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/hmdp/service/impl/UserServiceImpl.java
package com.hmdp.service.impl;

import cn.hutool.core.util.RandomUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.hmdp.dto.LoginFormDTO;
import com.hmdp.dto.Result;
import com.hmdp.entity.User;
import com.hmdp.mapper.UserMapper;
import com.hmdp.service.IUserService;
import com.hmdp.utils.RegexUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpSession;

/**
 * &lt;p&gt;
 * 服务实现类
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;

    @Override
    public Result sendCode(String phone, HttpSession session) &#123;
        // 校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            // 不符合 返回错误信息
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 符合 生成验证码
        String code = RandomUtil.randomNumbers(6);
        // 保存验证码到session
        session.setAttribute(&quot;code&quot;, code);
        // 发送验证码
        log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);
        // 返回ok
        return Result.ok();
    &#125;

    @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/85fe36afc83beb58573eae44931fe1ed0934d272/Session+%E9%AA%8C%E8%AF%81%E7%A0%81.png"></p>
<h3 id="实现登录校验拦截器"><a href="#实现登录校验拦截器" class="headerlink" title="实现登录校验拦截器"></a>实现登录校验拦截器</h3><pre><code class="java">package com.hmdp.config;

import com.hmdp.utils.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        &quot;/user/code&quot;,
                        &quot;/user/login&quot;
                );
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.hmdp.utils;

import com.hmdp.dto.UserDTO;

public class UserHolder &#123;
    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();

    public static void saveUser(UserDTO user)&#123;
        tl.set(user);
    &#125;

    public static UserDTO getUser()&#123;
        return tl.get();
    &#125;

    public static void removeUser()&#123;
        tl.remove();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.hmdp.utils;

import cn.hutool.core.util.ObjectUtil;
import com.hmdp.dto.UserDTO;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class LoginInterceptor implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 获取session
        HttpSession session = request.getSession();
        // 获取session中的用户
        Object user = session.getAttribute(&quot;user&quot;);
        // 判断用户是否存在
        if (ObjectUtil.isEmpty(user)) &#123;
            // 不存在，拦截
            response.setStatus(401);
            return false;
        &#125;
        // 存在，保存用户信息到ThreadLocal
        UserDTO userDTO = (UserDTO) user; // 确保 user 已经是 UserDTO 类型
        UserHolder.saveUser(userDTO);
        // 放行
        return true;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        // 移除用户
        UserHolder.removeUser();
    &#125;
&#125;
</code></pre>
<h4 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a>集群的Session共享问题</h4><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p>
<p>session的替代方案应该满足：数据共享、内存存储、key、value结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5b6d076e24d4cda9ea106bd713ee11a92fe7572c/Redis%E4%BB%A3%E6%9B%BFSession.png"></p>
<p>发送短信验证码后生成的验证码 <strong>保存验证码到Redis</strong> → 以手机号作为Key存储验证码 → 发送验证码</p>
<pre><code class="java">com/hmdp/controller/UserController.java
package com.hmdp.controller;


import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;
import cn.hutool.core.lang.UUID;
import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.RandomUtil;
import com.hmdp.dto.LoginFormDTO;
import com.hmdp.dto.Result;
import com.hmdp.dto.UserDTO;
import com.hmdp.entity.User;
import com.hmdp.entity.UserInfo;
import com.hmdp.service.IUserInfoService;
import com.hmdp.service.IUserService;
import com.hmdp.utils.RegexUtils;
import com.hmdp.utils.SystemConstants;
import com.hmdp.utils.UserHolder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import javax.servlet.http.HttpSession;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import static com.baomidou.mybatisplus.core.toolkit.Wrappers.lambdaQuery;
import static com.baomidou.mybatisplus.core.toolkit.Wrappers.query;


/**
 * &lt;p&gt;
 * 前端控制器
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@Slf4j
@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    @Resource
    private IUserService userService;

    @Resource
    private IUserInfoService userInfoService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;


    /**
     * 发送手机验证码
     */
    @PostMapping(&quot;code&quot;)
    public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123;
        return userService.sendCode(phone, session);
    &#125;

    /**
     * 登录功能
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping(&quot;/login&quot;)
    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123;
        String phone = loginForm.getPhone();
        // 校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) &#123;
            return Result.fail(&quot;手机号格式错误！&quot;);
        &#125;
        // 校验验证码
//        Object cacheCode = session.getAttribute(&quot;code&quot;);
        // 从Redis中获取验证码并校验
        String cacheCode = stringRedisTemplate.opsForValue().get(SystemConstants.LOGIN_CODE_KEY + phone);
        String code = loginForm.getCode();

        // 不一致 报错
        if (cacheCode == null || !code.equals(cacheCode)) &#123;
            return Result.fail(&quot;验证码错误&quot;);
        &#125;

        // 存储

        // 一致 根据手机号查询用户 用mybatisplus
        User user = userService.getOne(lambdaQuery(User.class).eq(User::getPhone, phone));
        // 判断用户是否存在
        if (ObjectUtil.isEmpty(user)) &#123;
            // 不存在 创建新用户保存
            user = new User();
            user.setPhone(phone);
            user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
            userService.save(user);
        &#125;
        // 保存用户信息到redis中
        // 随机生成token，作为登录令牌
        String token = UUID.randomUUID().toString(true);
        // 将User对象转换为Hash存储
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
        // 存储  用了putall 要把userDto转map
        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(),
                CopyOptions.create()
                        .setIgnoreNullValue(true)
                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));
        // 存储   因为存的时候不能设置有效期 要存完以后再去设置有效期
        String tokenKey = SystemConstants.LOGIN_CODE_TOKEN + token;
        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);
        // 设置token有效期 30min
        stringRedisTemplate.expire(tokenKey, SystemConstants.REDIS_TIMEOUT, TimeUnit.MINUTES);
        // 但是我要如果状态在 就不断更新token的有效期 【更新token有效期】



        // 存在 保存用户信息到session当中
//        UserDTO userDTO = new UserDTO();
//        userDTO.setId(user.getId());
//        userDTO.setNickName(user.getNickName());
//        userDTO.setPhone(user.getPhone());
        // 确保保存的是 UserDTO 对象
        session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));
        return Result.ok();
    &#125;

    /**
     * 登出功能
     * @return 无
     */
    @PostMapping(&quot;/logout&quot;)
    public Result logout()&#123;
        // TODO 实现登出功能
        return Result.fail(&quot;功能未完成&quot;);
    &#125;

    @GetMapping(&quot;/me&quot;)
    public Result me()&#123;
        // TODO 获取当前登录的用户并返回
        // userService.login(loginForm, session)
        UserDTO user = UserHolder.getUser();
        return Result.ok(user);
    &#125;

    @GetMapping(&quot;/info/&#123;id&#125;&quot;)
    public Result info(@PathVariable(&quot;id&quot;) Long userId)&#123;
        // 查询详情
        UserInfo info = userInfoService.getById(userId);
        if (info == null) &#123;
            // 没有详情，应该是第一次查看详情
            return Result.ok();
        &#125;
        info.setCreateTime(null);
        info.setUpdateTime(null);
        // 返回
        return Result.ok(info);
    &#125;
&#125;
</code></pre>
<h4 id="解决状态登录刷新的问题【双重拦截器】"><a href="#解决状态登录刷新的问题【双重拦截器】" class="headerlink" title="解决状态登录刷新的问题【双重拦截器】"></a>解决状态登录刷新的问题【双重拦截器】</h4><p>请求 → <strong>拦截器①</strong>(拦截一切路径)[<u>流程：获取token、查询Redis用户、保存到ThreadLocal、刷新Token有效期、放行</u>] → <strong>拦截器②</strong>(拦截需要登录的路径)[查询ThreadLocal的用户, 不存在则拦截、存在则继续]</p>
<pre><code class="java">com/hmdp/utils/LoginInterceptor.java
package com.hmdp.utils;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.ObjectUtil;
import cn.hutool.core.util.StrUtil;
import com.hmdp.dto.UserDTO;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class LoginInterceptor implements HandlerInterceptor &#123;
    // 这个类的对象是手动new出来的 没有通过Spring容器 所以需要通过构造方法去引用
    // 拦截器不能给spring容器因为每次都会经过它去访问

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 判断是否需要拦截(ThreadLocal中是否有用户)
        if (UserHolder.getUser() == null) &#123;
            // 没有，需要拦截，设置状态码
            response.setStatus(401);
            // 拦截
            return false;
        &#125;
        // 有用户 放行
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/hmdp/utils/RefreshTokenInterceptor.java
package com.hmdp.utils;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.StrUtil;
import com.hmdp.dto.UserDTO;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Map;
import java.util.concurrent.TimeUnit;

public class RefreshTokenInterceptor implements HandlerInterceptor &#123;
    // 这个类的对象是手动new出来的 没有通过Spring容器 所以需要通过构造方法去引用
    // 拦截器不能给spring容器因为每次都会经过它去访问
    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String token = request.getHeader(&quot;authorization&quot;);
        if (StrUtil.isBlank(token)) &#123;
            // 不存在：拦截，返回401状态码
//            response.setStatus(401);
            return true;
        &#125;
        String key = SystemConstants.LOGIN_CODE_TOKEN + token;
        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);
        // 判断用户是否存在
//        if (ObjectUtil.isEmpty(user)) &#123;
        if (userMap.isEmpty())&#123;
            // 不存在，拦截
//            response.setStatus(401);
            return true;
        &#125;
        // 将查询到的Hash数据转为UserDTO对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);

        // 存在，保存用户信息到ThreadLocal
//        UserDTO userDTO = (UserDTO) user; // 确保 user 已经是 UserDTO 类型
        UserHolder.saveUser(userDTO);
        // 刷新token有效期
        stringRedisTemplate.expire(key, SystemConstants.REDIS_TIMEOUT, TimeUnit.MINUTES);
        // 放行
        return true;
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        // 移除用户
        UserHolder.removeUser();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/hmdp/config/MvcConfig.java
package com.hmdp.config;

import com.hmdp.utils.LoginInterceptor;
import com.hmdp.utils.RefreshTokenInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.annotation.Resource;

@Configuration
public class MvcConfig implements WebMvcConfigurer &#123;
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        // 登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        &quot;/shop/**&quot;,
                        &quot;/voucher/**&quot;,
                        &quot;/shop-type/**&quot;,
                        &quot;/upload/**&quot;,
                        &quot;/blog/hot&quot;,
                        &quot;/user/code&quot;,
                        &quot;/user/login&quot;
                ).order(1);
        // token刷新拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);
    &#125;
&#125;
</code></pre>
<h4 id="商户查询缓存—练习题"><a href="#商户查询缓存—练习题" class="headerlink" title="商户查询缓存—练习题"></a>商户查询缓存—练习题</h4><pre><code class="java">com/hmdp/controller/ShopTypeController.java
/**
 * &lt;p&gt;
 * 前端控制器
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@RestController
@RequestMapping(&quot;/shop-type&quot;)
public class ShopTypeController &#123;
    @Resource
    private IShopTypeService typeService;

    @GetMapping(&quot;list&quot;)
    public Result queryTypeList() &#123;
//        List&lt;ShopType&gt; typeList = typeService
//                .query().orderByAsc(&quot;sort&quot;).list();
//        return Result.ok(typeList);
        return typeService.listShop();
    &#125;
</code></pre>
<pre><code class="java">com/hmdp/service/impl/ShopTypeServiceImpl.java
/**
 * &lt;p&gt;
 *  服务实现类
 * &lt;/p&gt;
 * @since 2021-12-22
 */
@Service
public class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;

    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Override
    public Result listShop() &#123;
        String shopTypeCache = stringRedisTemplate.opsForValue().get(SystemConstants.CACHE_SHOP_TYPE_KEY);

        if (ObjectUtil.isNotEmpty(shopTypeCache)) &#123;
            Long ttl = stringRedisTemplate.getExpire(SystemConstants.CACHE_SHOP_TYPE_KEY, TimeUnit.MINUTES);
            System.out.println(&quot;TTL for CACHE_SHOP_TYPE_KEY: &quot; + ttl + &quot; minutes&quot;);
            List&lt;ShopType&gt; shopTypeList = JSONUtil.toList(shopTypeCache, ShopType.class);
            return Result.ok(shopTypeList);
        &#125;



        List&lt;ShopType&gt; queryShopTypeList = query().orderByAsc(&quot;sort&quot;).list();
        if (ObjectUtil.isEmpty(queryShopTypeList)) &#123;
            return Result.fail(&quot;查询失败&quot;);
        &#125;
        stringRedisTemplate.opsForValue().set(SystemConstants.CACHE_SHOP_TYPE_KEY, JSONUtil.toJsonStr(queryShopTypeList), SystemConstants.SHOP_TYPE_TTL, TimeUnit.MINUTES);
        return Result.ok(queryShopTypeList);
    &#125;
&#125;
</code></pre>
<h4 id="添加商铺缓存"><a href="#添加商铺缓存" class="headerlink" title="添加商铺缓存"></a>添加商铺缓存</h4><pre><code class="java">com/hmdp/service/impl/ShopServiceImpl.java
package com.hmdp.service.impl;

import cn.hutool.core.util.ObjectUtil;
import cn.hutool.json.JSONUtil;
import com.hmdp.dto.Result;
import com.hmdp.entity.Shop;
import com.hmdp.mapper.ShopMapper;
import com.hmdp.service.IShopService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.hmdp.utils.SystemConstants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * &lt;p&gt;
 *  服务实现类
 * &lt;/p&gt;
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@Service
public class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result queryById(Long id) &#123;
        // 从redis中查询商铺缓存
        String shopJson = stringRedisTemplate.opsForValue().get(SystemConstants.CACHE_SHOP_KEY + id);
        // 判断是否存在
        if (ObjectUtil.isNotEmpty(shopJson)) &#123;
            // 存在，直接返回
            Shop shop = JSONUtil.toBean(shopJson, Shop.class);
            return Result.ok(shop);
        &#125;
        // 不存在，根据id查询数据库
        Shop shop = getById(id);
        // 不存在，返回错误
        if (ObjectUtil.isEmpty(shop)) &#123;
            return Result.fail(&quot;店铺不存在&quot;);
        &#125;
        // 存在，写入redis
        stringRedisTemplate.opsForValue().set(SystemConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));
        // 返回
        return Result.ok(shop);
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0152529cf933c8a2b70030f2d0869f8e7c6579e/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png"></p>
<h4 id="实现商铺缓存与数据库的双写一致性"><a href="#实现商铺缓存与数据库的双写一致性" class="headerlink" title="实现商铺缓存与数据库的双写一致性"></a>实现商铺缓存与数据库的双写一致性</h4><h6 id="先更新后删除"><a href="#先更新后删除" class="headerlink" title="先更新后删除"></a>先更新后删除</h6><pre><code class="java">com/hmdp/controller/ShopController.java
 /**
     * 更新商铺信息
     * @param shop 商铺数据
     * @return 无
     */
    @PutMapping
    public Result updateShop(@RequestBody Shop shop) &#123;
//        shopService.updateById(shop);
        return shopService.update(shop);

    &#125;
</code></pre>
<pre><code class="java">com/hmdp/service/impl/ShopServiceImpl.java
@Override
    public Result update(Shop shop) &#123;
        Long id = shop.getId();
        if (ObjectUtil.isEmpty(id)) &#123;
            return Result.fail(&quot;店铺id不能为空&quot;);
        &#125;
        // 更新数据库
        updateById(shop);
        // 删除缓存
        stringRedisTemplate.delete(SystemConstants.CACHE_SHOP_KEY + id);
        return Result.ok();
    &#125;
</code></pre>
<h4 id="缓存穿透的解决思路"><a href="#缓存穿透的解决思路" class="headerlink" title="缓存穿透的解决思路"></a>缓存穿透的解决思路</h4><ul>
<li><h6 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h6><ul>
<li><strong>优点</strong>：实现简单，维护方便</li>
<li><strong>缺点</strong>：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>缓存null的时候加一个TTL</p>
</blockquote>
</li>
<li><h6 id="布隆过滤器算法-bitMap数组用Hash值去判断"><a href="#布隆过滤器算法-bitMap数组用Hash值去判断" class="headerlink" title="布隆过滤器算法[bitMap数组用Hash值去判断]"></a>布隆过滤器<del>算法</del>[bitMap数组用Hash值去判断]</h6><ul>
<li><strong>优点</strong>：内存占用较少，没有多余key</li>
<li><strong>缺点</strong>：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="缓存击穿的解决思路"><a href="#缓存击穿的解决思路" class="headerlink" title="缓存击穿的解决思路"></a>缓存击穿的解决思路</h4><ul>
<li><h6 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h6></li>
<li><h6 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h6></li>
</ul>
<h4 id="缓存雪崩的解决思路"><a href="#缓存雪崩的解决思路" class="headerlink" title="缓存雪崩的解决思路"></a>缓存雪崩的解决思路</h4><ul>
<li><h6 id="给不同的key的TTL添加随机值"><a href="#给不同的key的TTL添加随机值" class="headerlink" title="给不同的key的TTL添加随机值"></a>给不同的key的TTL添加随机值</h6></li>
<li><p>利用Redis集群提高服务的可用性</p>
</li>
<li><p>给缓存业务添加降级限流策略</p>
</li>
<li><p>给业务添加多级缓存</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/04fe92d2f230e21ce689b82308a43cd4e944d086/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9%E7%AD%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png"></p>
<h4 id="利用互斥锁解决缓存击穿问题setnx设置一把锁"><a href="#利用互斥锁解决缓存击穿问题setnx设置一把锁" class="headerlink" title="利用互斥锁解决缓存击穿问题setnx设置一把锁"></a>利用互斥锁解决缓存击穿问题<del>setnx设置一把锁</del></h4><p><code>setnx</code>当key不存在的时候才会写入<del>赋值</del><br><code>del lock</code><del>释放锁</del>、<br><code>setnx lock </code>获取锁赋值</p>
<blockquote>
<p>在linux中如果用的docker那么就用它<br>docker连接redis<br>首先先找到redis的镜像编码<br><code>docker ps</code><br>找到以后<br><code>docker exec -it 5832be55766e redis-cli</code></p>
</blockquote>
<pre><code class="java">[root@localhost ~]# docker exec -it 5832be55766e redis-cli
127.0.0.1:6379&gt; AUTH pass
OK
127.0.0.1:6379&gt; setnx lock 1
(integer) 1
127.0.0.1:6379&gt; get lock
&quot;1&quot;
127.0.0.1:6379&gt; setnx lock 2
(integer) 0
127.0.0.1:6379&gt; setnx lock 3
(integer) 0
127.0.0.1:6379&gt; setnx lock 2
(integer) 0
127.0.0.1:6379&gt; get lock
&quot;1&quot;
127.0.0.1:6379&gt; del lock
(integer) 1
127.0.0.1:6379&gt; setnx lock 3
(integer) 1
    
--------------------------------------------------------------------------
// 加个有效期TTL 避免锁得不到释放 产生死锁
 private boolean tryLock(String key) &#123;
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.SECONDS);
    // 防止自动拆箱产生空值
        return BooleanUtil.isTrue(flag);
    &#125;

// 释放锁
private void unlock(String key) &#123;
        stringRedisTemplate.delete(key);
    &#125;
</code></pre>
<blockquote>
<p><code>SETNX</code> 是 Redis 的一个命令，它是 “SET if Not eXists” 的缩写，用于在键不存在时设置键的值。如果键已经存在，<code>SETNX</code> 命令不会执行任何操作，并返回 <code>0</code>；如果键不存在，它会设置键的值，并返回 <code>1</code>。</p>
<p>在分布式锁的实现中，<code>SETNX</code> 命令经常被用来尝试获取锁。如果某个键（通常用作锁的标识）不存在，则设置该键并获取锁；如果键已经存在，表示锁已经被其他客户端持有，因此当前客户端无法获取锁。</p>
<p>以下是 <code>SETNX</code> 命令的基本用法：</p>
<pre><code>SETNX key value
</code></pre>
<ul>
<li><code>key</code>：你想要设置的键名。</li>
<li><code>value</code>：你想要设置的值。</li>
</ul>
<p>从 Redis 2.6.12 版本开始，<code>SETNX</code> 命令被 <code>SET</code> 命令的一个选项所取代，该选项允许你执行类似于 <code>SETNX</code> 的操作，同时还能设置键的超时时间（过期时间），这在实现分布式锁时非常有用。以下是使用 <code>SET</code> 命令的示例：</p>
<pre><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]
</code></pre>
<ul>
<li><code>EX seconds</code>：设置键的过期时间为 seconds 秒。</li>
<li><code>PX milliseconds</code>：设置键的过期时间为 milliseconds 毫秒。</li>
<li><code>NX</code>：只在键不存在时执行设置操作。</li>
<li><code>XX</code>：只在键已经存在时执行设置操作。</li>
</ul>
<p>因此，现代的分布式锁实现通常会使用如下命令：</p>
<pre><code>SET lock_key unique_value EX 30 NX
</code></pre>
<p>这里，<code>lock_key</code> 是锁的键名，<code>unique_value</code> 是一个确保释放锁时安全的唯一值（通常是当前时间戳加上一个随机数或者客户端ID），<code>EX 30</code> 设置了键的超时时间为30秒，<code>NX</code> 确保只有在键不存在时才设置键。</p>
<h3 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h3><p>互斥锁通常用于单机应用，确保同一时刻只有一个线程可以执行某个操作。以下是一个简单的示例：</p>
<p>java</p>
<p>复制</p>
<pre><code class="java">import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

public class MutexLock &#123;
    private final StringRedisTemplate redisTemplate;
    private final String lockKey = &quot;mutex_lock_key&quot;;

    public MutexLock(StringRedisTemplate redisTemplate) &#123;
        this.redisTemplate = redisTemplate;
    &#125;

    public boolean tryLock() &#123;
        ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
        // 尝试设置锁，如果设置成功返回true，否则返回false
        return ops.setIfAbsent(lockKey, &quot;locked&quot;);
    &#125;

    public void unlock() &#123;
        // 删除锁
        redisTemplate.delete(lockKey);
    &#125;
&#125;
</code></pre>
<h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><p>分布式锁用于分布式系统，确保在多个不同的机器或服务中只有一个可以执行某个操作。以下是一个简单的示例：</p>
<p>java</p>
<p>复制</p>
<pre><code class="java">import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

public class DistributedLock &#123;
    private final StringRedisTemplate redisTemplate;
    private final String lockKey = &quot;distributed_lock_key&quot;;
    private final long lockTimeout = 30000; // 锁超时时间，例如30秒

    public DistributedLock(StringRedisTemplate redisTemplate) &#123;
        this.redisTemplate = redisTemplate;
    &#125;

    public boolean tryLock() &#123;
        ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
        // 尝试设置锁，并设置超时时间
        Boolean success = ops.setIfAbsent(lockKey, &quot;locked&quot;, lockTimeout, TimeUnit.MILLISECONDS);
        return Boolean.TRUE.equals(success);
    &#125;

    public void unlock() &#123;
        // 删除锁
        redisTemplate.delete(lockKey);
    &#125;
&#125;
</code></pre>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/00e106e4ef12663d48fd34c4849e5d30acd794f4/%E4%BA%92%E6%96%A5%E9%94%81+%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7Jmeter.png"></p>
<h4 id="基于逻辑过期方式解决缓存击穿的问题"><a href="#基于逻辑过期方式解决缓存击穿的问题" class="headerlink" title="基于逻辑过期方式解决缓存击穿的问题"></a>基于<u>逻辑过期</u>方式解决缓存击穿的问题</h4><p>不要直接在类中添加逻辑过期的字段，这样对代码不好<br>① 搞一个<code>RedisData</code>.java 设置一个逻辑过期 然后再去实现<strong>继承</strong><br>② RedisData中搞一个<code>private Object data;</code><br>热点数据需要提前导入</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d4783e106b8e01a6c730c3c0b2186a5cc3121e8f/%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png"></p>
<h4 id="封装Redis工具类"><a href="#封装Redis工具类" class="headerlink" title="封装Redis工具类"></a>封装Redis工具类</h4><h6 id="基于StringRedisTemplate封装一个缓存工具类，满足下列需求"><a href="#基于StringRedisTemplate封装一个缓存工具类，满足下列需求" class="headerlink" title="基于StringRedisTemplate封装一个缓存工具类，满足下列需求:"></a>基于StringRedisTemplate封装一个缓存工具类，满足下列需求:</h6><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间<br>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击<br>穿问题<br>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题<br>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/527a96a618486f36b423b4aded775cbf489d94aa/%E5%B0%81%E8%A3%85Redis%E5%B7%A5%E5%85%B7%E7%B1%BB.png"></p>
<h4 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/746223fa0c9480af5734a475c39fc0e0fdff0fbe/Redis%E6%80%BB%E7%BB%93.png"></p>
<h4 id="优惠券秒杀—全局唯一ID"><a href="#优惠券秒杀—全局唯一ID" class="headerlink" title="优惠券秒杀—全局唯一ID"></a>优惠券秒杀—全局唯一ID</h4><p>全局唯一ID生成策略：</p>
<ul>
<li>UUID</li>
<li>Redis自增</li>
<li>snowflake算法</li>
<li>数据库自增</li>
</ul>
<p>Redis自增ID策略：</p>
<ul>
<li>每天一个Key，方便统计订单量</li>
<li>ID构造是 <strong>时间戳 + 计数器</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3bc6364424551cf0537adafeaccc461f2cc079b6/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id.png"></p>
<h4 id="添加优惠券秒杀针对特价券"><a href="#添加优惠券秒杀针对特价券" class="headerlink" title="添加优惠券秒杀针对特价券"></a>添加优惠券<del>秒杀针对特价券</del></h4><p>每个店铺都可以发布优惠券，分为<strong>平价券</strong>和<strong>特价券</strong>。</p>
<p>平价券可以任意购买，而特价券需要秒杀抢购：</p>
<ul>
<li><code>tb_voucher</code>：优惠券的基本信息，优惠金额、使用规则等</li>
<li><code>tb_seckill_voucher</code>：<strong>优惠券的库存</strong>、<strong>开始抢购时间</strong>、<strong>结束抢购时间</strong>。特价优惠券才需要填写这些信息</li>
</ul>
<pre><code class="mysql">[root@localhost ~]# docker ps
CONTAINER ID   IMAGE                         COMMAND                  CREATED         STATUS             PORTS                                                                                                                                NAMES
03154afad287   seataio/seata-server:1.4.2    &quot;java -Djava.securit…&quot;   11 months ago   Up About an hour   8091/tcp, 0.0.0.0:9200-&gt;9200/tcp, :::9200-&gt;9200/tcp                                                                                  seata-server
c34a590a5649   xuxueli/xxl-job-admin:2.1.2   &quot;sh -c &#39;java -jar /a…&quot;   11 months ago   Up About an hour   0.0.0.0:8280-&gt;8080/tcp, :::8280-&gt;8080/tcp                                                                                            xxl-job-admin
3574b316b5d2   nacos/nacos-server:1.4.0      &quot;bin/docker-startup.…&quot;   11 months ago   Up About an hour   0.0.0.0:8848-&gt;8848/tcp, :::8848-&gt;8848/tcp                                                                                            nacos
951e83eb8120   rabbitmq:3.8.3-management     &quot;docker-entrypoint.s…&quot;   11 months ago   Up About an hour   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, :::5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp, :::15672-&gt;15672/tcp   rabbitmq
6561e8458fa2   influxdb:1.8.0                &quot;/entrypoint.sh infl…&quot;   11 months ago   Up About an hour   0.0.0.0:8086-&gt;8086/tcp, :::8086-&gt;8086/tcp, 0.0.0.0:8088-&gt;8088/tcp, :::8088-&gt;8088/tcp, 0.0.0.0:9083-&gt;8083/tcp, :::9083-&gt;8083/tcp      influxdb
5832be55766e   redis:5.0.0                   &quot;docker-entrypoint.s…&quot;   11 months ago   Up About an hour   0.0.0.0:6379-&gt;6379/tcp, :::6379-&gt;6379/tcp                                                                                            redis
07ecd8b04853   mysql:5.7                     &quot;docker-entrypoint.s…&quot;   11 months ago   Up About an hour   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp                                                                                 mysql
[root@localhost ~]# docker exec -it 5832be55766e redis-cli
127.0.0.1:6379&gt; AUTH pass
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/99d8cd096fcb0717db285cd3e17f449695ef106a/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80-%E6%B7%BB%E5%8A%A0%E4%BC%98%E6%83%A0%E5%88%B8.png" style="zoom:200%;" />



<h4 id="库存超卖问题分析每秒上百上千的并发"><a href="#库存超卖问题分析每秒上百上千的并发" class="headerlink" title="库存超卖问题分析每秒上百上千的并发"></a>库存超卖问题分析<del>每秒上百上千的并发</del></h4><p>超卖问题是经典的多线程安全问题，针对这一问题的常见解决方案就是加锁：<br><img src="https://raw.githubusercontent.com/P-luminary/images/63d691cb03a76ddb679a813165d0febe0de575d7/%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98.png"></p>
<h4 id="秒杀-→-一人一单拒绝黄牛"><a href="#秒杀-→-一人一单拒绝黄牛" class="headerlink" title="秒杀 → 一人一单拒绝黄牛"></a>秒杀 → 一人一单<del>拒绝黄牛</del></h4><h6 id="要求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单"><a href="#要求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单" class="headerlink" title="要求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单"></a>要求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/bfdbe9efd534705181780aeb3072f72c365da1b8/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E5%8A%9F%E8%83%BD.png"></p>
<h4 id="集群下线程的并发安全问题"><a href="#集群下线程的并发安全问题" class="headerlink" title="集群下线程的并发安全问题"></a>集群下线程的并发安全问题</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/38a76e0ddf9fa883d7d1532476c95f642579d0be/%E9%9B%86%E7%BE%A4%E4%B8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98.png"></p>
<h4 id="分布式锁-—-基本原理"><a href="#分布式锁-—-基本原理" class="headerlink" title="分布式锁 — 基本原理"></a>分布式锁 — 基本原理</h4><p><strong>分布式锁：</strong>满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MySQL</th>
<th align="center"><span style = "color:red">Redis</span></th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>互斥</strong></td>
<td align="center">利用mysql本身的互斥锁机制</td>
<td align="center">利用setnx这样的互斥命令</td>
<td align="center">利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td align="center"><strong>高可用</strong></td>
<td align="center">好</td>
<td align="center">好</td>
<td align="center">好</td>
</tr>
<tr>
<td align="center"><strong>高性能</strong></td>
<td align="center">一般</td>
<td align="center">好</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center"><strong>安全性</strong></td>
<td align="center">断开连接，自动释放锁</td>
<td align="center">利用锁超时时间，到期释放</td>
<td align="center">临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><h6 id="实现分布式锁时需要实现的两个基本方法：获取锁、释放锁"><a href="#实现分布式锁时需要实现的两个基本方法：获取锁、释放锁" class="headerlink" title="实现分布式锁时需要实现的两个基本方法：获取锁、释放锁"></a>实现分布式锁时需要实现的两个基本方法：获取锁、释放锁</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/6163af54f533691c19524073894f9fa1647279dd/Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E7%89%88%E6%9C%AC1.png"></p>
<h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/fa5a1ec0c1de3b9a21cb175f1c336956db237ef2/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98.png"></p>
<h4 id="Redis的事务：可以使用看门狗"><a href="#Redis的事务：可以使用看门狗" class="headerlink" title="Redis的事务：可以使用看门狗"></a>Redis的事务：可以使用看门狗</h4><h4 id="Redis的Lua脚本利用Lua去调用Redis-确保原子的一致性"><a href="#Redis的Lua脚本利用Lua去调用Redis-确保原子的一致性" class="headerlink" title="Redis的Lua脚本利用Lua去调用Redis(确保原子的一致性)"></a>Redis的Lua脚本<del>利用Lua去调用Redis(确保原子的一致性)</del></h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站:<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>
<p><code>redis.call(&#39;命令名称&#39;, &#39;key&#39;, &#39;其他参数&#39;, ...)</code></p>
<p>例如我们要执行<u>set name jack</u>，则脚本是这样：<br><code>redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)</code></p>
<p>例如我们要先执行<u>set name Rose</u>，再执行<u>get name</u>，则脚本如下：</p>
<pre><code class="mysql"># 先执行 set name jack
redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)

# 再执行 get name
local name = redis.call(&#39;get&#39;, &#39;name&#39;)

# 返回
return name
</code></pre>
<h6 id="执行Lua脚本"><a href="#执行Lua脚本" class="headerlink" title="执行Lua脚本"></a>执行Lua脚本</h6><p>写好脚本后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<pre><code class="java">127.0.0.1:6379&gt; help @scripting
EVAL script numkeys key [key ...] arg [arg ...]
</code></pre>
<p>要执行<code>redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)</code>这个脚本，语法如下：</p>
<pre><code class="mysql"># 调用脚本 [0是脚本需要的key类型的参数个数 =&gt; 传参的变量]
EVAL &quot;return redis.call(&#39;set&#39;, &#39;name&#39;, &#39;jack&#39;)&quot;  0
</code></pre>
<pre><code class="mysql"># 不带变量
127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#39;set&#39;, &#39;name&#39;, &#39;Jack&#39;)&quot; 0
OK
127.0.0.1:6379&gt; keys *
1) &quot;name&quot;
127.0.0.1:6379&gt; get name
&quot;Jack&quot;
</code></pre>
<p>如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数:【<u>lua语言数组脚标是从1开始的</u>】</p>
<pre><code class="mysql"># 调用脚本【初始版】
127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#39;set&#39;, &#39;name&#39;, &#39;Jack&#39;)&quot; 0
# 调用脚本【进阶版】
127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#39;set&#39;, KEYS[1], ARGV[1])&quot; 1 name Rose
OK
127.0.0.1:6379&gt; get name
&quot;Rose&quot;
127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#39;set&#39;, KEYS[1], ARGV[1])&quot; 1 name heihei
OK
127.0.0.1:6379&gt; get name
&quot;heihei&quot;
</code></pre>
<h3 id="基于Redis的分布式锁-1"><a href="#基于Redis的分布式锁-1" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h3><h6 id="释放锁的业务流程是这样的："><a href="#释放锁的业务流程是这样的：" class="headerlink" title="释放锁的业务流程是这样的："></a>释放锁的业务流程是这样的：</h6><p>1.获取锁中的线程标示<br>2.判断是否与指定的标示 (当前线程标示) 一致<br>3.如果一致则释放锁 (删除)<br>4.如果不一致则什么都不做</p>
<pre><code class="lua">-- 锁的key
-- local key = &quot;lock:order:5&quot;
-- 不能写死就传参
local threadId = KEYS[1]

-- 当前线程标示
-- local threadId = &quot;fagsidajkldw-33&quot;
-- 不能写死就传参
local threadId = ARGV[1]

-- 获取锁中的线程标识 get key
local id = redis.call(&#39;get&#39;, key)
-- 比较线程标示与锁中的标示是否一致
if(id == threadId) then
   -- 释放锁 del key
   return redis.call(&#39;del&#39;, key)
end
return 0

----------------------------- 进阶版 -------------------------------
-- 获取锁中的线程标识 get key
local id = redis.call(&#39;get&#39;, KEYS[1])
-- 比较线程标示与锁中的标示是否一致
if(id == ARGV[1]) then
   -- 释放锁 del key
   return redis.call(&#39;del&#39;, KEYS[1])
end
return 0
----------------------------- 进阶简化版 -------------------------------
-- 这里KEYS[1]就是锁的Key, 这里的ARGV[1]，就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if(redis.call(&#39;GET&#39;, KEYS[1]) == ARGV[1]) then
    -- 一致，则删除锁
    return redis.call(&#39;DEL&#39;, KEYS[1])
end
-- 不一致 直接返回
return 0
</code></pre>
<h4 id="再次改进Redis的分布式锁经典白雪"><a href="#再次改进Redis的分布式锁经典白雪" class="headerlink" title="再次改进Redis的分布式锁经典白雪"></a>再次改进Redis的分布式锁<del>经典白雪</del></h4><blockquote>
<p><strong>基于Redis的分布式锁实现思路</strong>：<br>利用setnx ex获取锁，并设置过期时间，保存线程标示<br>释放锁时先判断线程标示是否与自己一致，一致则删除锁</p>
<p><strong>特性</strong>:<br>利用set nx满足互斥性<br>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性<br>利用Redis集群保证高可用和高并发特性</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/da9c8cc0f1141222278c8180a2f75b8d59036486/Lua%E8%84%9A%E6%9C%AC%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B.png"></p>
<p>需求：基于**<code>Lua脚本</code>**实现分布式锁的释放锁逻辑<br>提示：<code>RedisTemplate</code>调用Lua脚本的API如下：</p>
<pre><code class="java">com/hmdp/utils/SimpleRedisLock.java
package com.hmdp.utils;

import cn.hutool.core.lang.UUID;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;

import java.util.Collections;
import java.util.concurrent.TimeUnit;

public class SimpleRedisLock implements ILock &#123;

    // 不同业务不同锁
    private String name;
    private StringRedisTemplate stringRedisTemplate;
    private static final String KEY_PREFIX = &quot;lock:&quot;;
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + &quot;-&quot;;
    private static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;

    // 是静态的要在静态代码块里面做初始化 这个类一加载 这个代码块就初始化完成了 不用每次释放锁再加载
    static &#123;
        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource(&quot;unlock.lua&quot;));
        UNLOCK_SCRIPT.setResultType(Long.class);
    &#125;

    public SimpleRedisLock(String name,
                           StringRedisTemplate stringRedisTemplate) &#123;
        this.name = name;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;

    @Override
    public boolean tryLock(long timeoutSec) &#123;
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 获取锁
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name,
                        threadId,
                        timeoutSec,
                        TimeUnit.SECONDS);
        // 自动拆箱避免空指针风险
        return Boolean.TRUE.equals(success);
    &#125;

    @Override
    public void unLock() &#123;
        // 调用lua脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                // 制造单集合
                Collections.singletonList(KEY_PREFIX + name),
                ID_PREFIX + Thread.currentThread().getId());
    &#125;

    //    public void unLock() &#123;
//        // 获取线程标识
//        String threadId = ID_PREFIX + Thread.currentThread().getId();
//        // 获取锁
//        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
//        // 判断锁是否ours
//        if (threadId.equals(id)) &#123;
//            // 解锁
//            stringRedisTemplate.delete(KEY_PREFIX + name);
//        &#125;
//    &#125;
&#125;
</code></pre>
<h4 id="基于Redis的分布式锁优化"><a href="#基于Redis的分布式锁优化" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h4><h6 id="基于setnx实现的分布式锁存在下面的问题："><a href="#基于setnx实现的分布式锁存在下面的问题：" class="headerlink" title="基于setnx实现的分布式锁存在下面的问题："></a>基于setnx实现的分布式锁存在下面的问题：</h6><ul>
<li><strong>不可重入</strong>：同一个线程无法多次获取同一把锁</li>
<li><strong>不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制</li>
<li><strong>超时释放</strong>：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li>
<li><strong>主从一致性</strong>：如果Redis提供了主从集群 [<u><strong>写操作访问主节点，读操作访问从节点</strong></u>]，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</li>
</ul>
<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>Redisson是一个在Redis的基础上实现的]ava驻内存数据网格(In-MemoryData Grid)。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p><a target="_blank" rel="noopener" href="https://redisson.org/">Redisson—官方网站</a><br><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson—GitHub地址</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c7bee5bcd50d5eaa3d97e6d131d811376dec9dc8/Redisson%E5%85%A5%E9%97%A8.png"></p>
<h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h4><pre><code class="java">package com.hmdp;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;
import java.util.concurrent.TimeUnit;

@Slf4j
@SpringBootTest
class RedissonTest &#123;

    @Resource
    private RedissonClient redissonClient;

    private RLock lock;

    @BeforeEach
    void setUp() &#123;
        lock = redissonClient.getLock(&quot;order&quot;);
    &#125;

    @Test
    void method1() throws InterruptedException &#123;
        // 尝试获取锁
        boolean isLock = lock.tryLock(1L, TimeUnit.SECONDS);
        if (!isLock) &#123;
            log.error(&quot;获取锁失败 .... 1&quot;);
            return;
        &#125;
        try &#123;
            log.info(&quot;获取锁成功 .... 1&quot;);
            method2();
            log.info(&quot;开始执行业务 ... 1&quot;);
        &#125; finally &#123;
            log.warn(&quot;准备释放锁 .... 1&quot;);
            lock.unlock();
        &#125;
    &#125;
    void method2() &#123;
        // 尝试获取锁
        boolean isLock = lock.tryLock();
        if (!isLock) &#123;
            log.error(&quot;获取锁失败 .... 2&quot;);
            return;
        &#125;
        try &#123;
            log.info(&quot;获取锁成功 .... 2&quot;);
            log.info(&quot;开始执行业务 ... 2&quot;);
        &#125; finally &#123;
            log.warn(&quot;准备释放锁 .... 2&quot;);
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0c634eeb71f9676e5782d1082d2b94351da3d7ae/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png"></p>
<h4 id="Redisson的锁重试和WatchDog机制"><a href="#Redisson的锁重试和WatchDog机制" class="headerlink" title="Redisson的锁重试和WatchDog机制"></a>Redisson的锁重试和WatchDog机制</h4><h5 id="基于Redis的分布式锁优化-1"><a href="#基于Redis的分布式锁优化-1" class="headerlink" title="基于Redis的分布式锁优化"></a>基于Redis的分布式锁优化</h5><h6 id="基于setnx实现的分布式锁存在下面的问题：-1"><a href="#基于setnx实现的分布式锁存在下面的问题：-1" class="headerlink" title="基于setnx实现的分布式锁存在下面的问题："></a>基于setnx实现的分布式锁存在下面的问题：</h6><p><strong>不可重入：</strong>同一个线程无法多次获得同一把锁<br><strong>不可重试：</strong>获取锁只尝试一次就返回false，没有重试机制<br><strong>超时释放：</strong>锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患<br><strong>主从一致性：</strong>如果Redis提供了主从集群主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2022/01/15/后端/Redis实战篇/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/13/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/12">
                <span class="page-num">
                    12
                </span>
            </a>
            

            
            <a href="/page/13/">
                <span class="page-num">
                    13
                </span>
            </a>
        </span>
        

        <span class="current">
            14
        </span>

        

    </div>

    <div class="next">
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>