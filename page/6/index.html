
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2023/08/22/后端/Java复习款(练习题)/">
        <h2>
            Java复习款练习题
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Collection集合习题"><a href="#Collection集合习题" class="headerlink" title="Collection集合习题"></a>Collection集合习题</h1><h3 id="练习：Collection集合统计元素出现次数"><a href="#练习：Collection集合统计元素出现次数" class="headerlink" title="练习：Collection集合统计元素出现次数"></a>练习：Collection集合统计元素出现次数</h3><p>给定以下代码，请定义方法listTest()统计集合中指定元素出现的次数，如”a”: 2,”b”: 2,”c” :1, “xxx”:0</p>
<pre><code class="java">   public static void main(String[] args) &#123;
        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;a&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;b&quot;);
        list.add(&quot;c&quot;);
        System.out.println(&quot;a:&quot;+listTest(list, &quot;a&quot;));
        System.out.println(&quot;b:&quot;+listTest(list, &quot;b&quot;));
        System.out.println(&quot;c:&quot;+listTest(list, &quot;c&quot;));
        System.out.println(&quot;xxx:&quot;+listTest(list, &quot;xxx&quot;));
    &#125;
    private static int listTest(Collection&lt;String&gt; list, String s)&#123;
        int count = 0;
        for (String string : list)&#123;
            if (s.equals(string))&#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：Collection集合数组转集合"><a href="#练习：Collection集合数组转集合" class="headerlink" title="练习：Collection集合数组转集合"></a>练习：Collection集合数组转集合</h3><p>定义一个方法，要求此方法把int数组转成存有相同元素的集合(集合里面的元素是Integer)，并返回。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6&#125;;
        ArrayList&lt;Integer&gt; arrayList = listTest(arr);
        System.out.println(arrayList);
    &#125;
    public static ArrayList&lt;Integer&gt; listTest(int[] arr)&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (Integer a : arr)&#123;
            list.add(a);
        &#125;
        return list;
    &#125;
</code></pre>
<h3 id="练习：Collection集合集合转数组"><a href="#练习：Collection集合集合转数组" class="headerlink" title="练习：Collection集合集合转数组"></a>练习：Collection集合集合转数组</h3><p>定义一个集合，并把集合(集合里面的元素是Integer)转成存有相同元素的数组，并将结果输出在控制台。（可以使用Object[]数组类型接收转换的数组）</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(100);
        list.add(200);
        list.add(300);
        Object[] obj = list.toArray();
        for (int i = 0; i &lt; obj.length; i++) &#123;
            System.out.println(obj[i]);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Object[] toArray()</p>
<p>以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。  因此，调用者可以自由地修改返回的数组。 </p>
</blockquote>
<h3 id="练习：Collection集合contains-方法使用"><a href="#练习：Collection集合contains-方法使用" class="headerlink" title="练习：Collection集合contains()方法使用"></a>练习：Collection集合contains()方法使用</h3><p>定义一个方法listTest(ArrayList &lt; String &gt; a1, String s),要求使用contains()方法判断a1集合里面是否包含s。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;itcast&quot;);
        list.add(&quot;itheima&quot;);
        list.add(&quot;java&quot;);
        System.out.println(listTest(list,&quot;Java&quot;));
    &#125;

    private static boolean listTest(ArrayList&lt;String&gt; a1, String s)&#123;
        if (a1.contains(s))&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：Collection集合isEmpty-方法的使用"><a href="#练习：Collection集合isEmpty-方法的使用" class="headerlink" title="练习：Collection集合isEmpty()方法的使用"></a>练习：Collection集合isEmpty()方法的使用</h3><p>定义一个方法listTest(ArrayList&lt; String &gt; a1), 要求使用isEmpty()判断a1里面是否有元素。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;1&quot;);
        System.out.println(listTest(list));
    &#125;
    public static boolean listTest(ArrayList&lt;String&gt;a1)&#123;
        if (a1.isEmpty())&#123;
            return true;
        &#125;
        return false;
    &#125;
</code></pre>
<h3 id="练习：简述迭代器的实现原理"><a href="#练习：简述迭代器的实现原理" class="headerlink" title="练习：简述迭代器的实现原理"></a>练习：简述迭代器的实现原理</h3><p>当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h3 id="练习：Collection集合返回首次出现索引"><a href="#练习：Collection集合返回首次出现索引" class="headerlink" title="练习：Collection集合返回首次出现索引"></a>练习：Collection集合返回首次出现索引</h3><p>定义一个方法listTest(ArrayList&lt; Integer &gt; a1, Integer s)，要求返回s在a1里面第一次出现的索引，如果s没出现过返回-1。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //定义集合，添加数据
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        System.out.println(listTest(list,5));
    &#125;
    private static int listTest(ArrayList&lt;Integer&gt;a1, Integer s)&#123;
        for (int i = 0; i &lt; a1.size(); i++) &#123;
            if (a1.get(i).equals(s))&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<h1 id="File类-amp-递归-amp-FileFilter习题"><a href="#File类-amp-递归-amp-FileFilter习题" class="headerlink" title="File类&amp;递归&amp;FileFilter习题"></a>File类&amp;递归&amp;FileFilter习题</h1><h3 id="练习：检查文件是否存在，文件的创建"><a href="#练习：检查文件是否存在，文件的创建" class="headerlink" title="练习：检查文件是否存在，文件的创建"></a>练习：检查文件是否存在，文件的创建</h3><p>描述：检查D盘下是否存在文件a.txt,如果不存在则创建该文件。</p>
<p><strong>操作步骤:</strong><br>1.使用绝对路径创建对象关联到D盘的a.txt。<br>2.通过文件对象方法判断文件是否存在。<br>3.不存在则调用创建文件的方法创建文件。</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa.txt&quot;);
        if (!f.exists())&#123;
            f.createNewFile();
        &#125;
    &#125;
</code></pre>
<h3 id="练习：单极文件夹的创建"><a href="#练习：单极文件夹的创建" class="headerlink" title="练习：单极文件夹的创建"></a>练习：单极文件夹的创建</h3><p>描述：在D盘下创建一个名为bbb的文件夹。</p>
<p><strong>操作步骤:</strong><br>1.创建文件对象指定路径为d:&#x2F;bbb<br>2.调用文件对象创建文件夹的方法</p>
<pre><code class="java">    public static void main(String[] args) throws IOException &#123;
        File f = new File(&quot;D:\\Clash\\aaa&quot;);
        // File f = new File(&quot;D:\\Clash\\aaa\\bbb&quot;);
        f.mkdir();
        // f.mkdirs(); 创建多级文件夹
    &#125;
</code></pre>
<h3 id="练习：删除文件和文件夹"><a href="#练习：删除文件和文件夹" class="headerlink" title="练习：删除文件和文件夹"></a>练习：删除文件和文件夹</h3><p>描述：将D盘下a.txt文件删除。将D盘下aaa文件夹删除,要求文件夹aaa是一个空文件夹。</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联路径：d:&#x2F;a.txt<br>2.调用文件对象删除文件的方法<br>3.创建文件对象关联路径：d:&#x2F;aaa<br>4 调用文件对象删除文件夹的方法.</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;d:/a.txt&quot;);
        // 删除文件
        f.delete();
        
        // 创建文件夹对象
        File dir = new File(&quot;d:/aaa&quot;);
        // 删除文件夹
        dir.delete();
    &#125;
</code></pre>
<h3 id="获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径"><a href="#获取文件信息：文件名-文件大小-文件的绝对路径-文件的父路径" class="headerlink" title="获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径"></a>获取文件信息：文件名,文件大小,文件的绝对路径,文件的父路径</h3><p>描述：获取D盘aaa文件夹中b.txt文件的文件名，文件大小，文件的绝对路径和父路径等信息，并将信息输出在控制台。</p>
<p><strong>操作步骤:</strong></p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 创建文件对象
        File f = new File(&quot;D:\\Clash\\a.txt&quot;);
        // 获得文件名
        String filename = f.getName();
        // 获得文件大小
        long filesize = f.length();
        // 获得文件的绝对路径
        String path = f.getAbsolutePath();
        // 获得父文件夹路径，返回字符串
        String parentPath = f.getParent();
        // 获得父文件夹路径，返回文件对象
        File parentFile = f.getParentFile();
        // 输出信息
        System.out.println(&quot;文件名：&quot; + filename);
        System.out.println(&quot;文件大小：&quot; + filesize);
        System.out.println(&quot;文件路径：&quot; + path);
        System.out.println(&quot;文件父路径：&quot; + parentPath);
        System.out.println(&quot;文件父路径：&quot; + parentFile);
    &#125;
</code></pre>
<h3 id="练习-文件夹或文件的判断"><a href="#练习-文件夹或文件的判断" class="headerlink" title="练习:文件夹或文件的判断"></a>练习:文件夹或文件的判断</h3><p>描述:</p>
<p>1.判断File对象是否是文件,是文件则输出：xxx是一个文件，否则输出：xxx不是一个文件。<br>2.判断File对象是否是文件夹,是文件夹则输出：xxx是一个文件夹，否则输出：xxx不是一个文件夹。(xxx是文件名或文件夹名)</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建两个文件对象分别关联到不同的文件，比如：d:&#x2F;a.txt，d:&#x2F;aaa<br>2.调用文件对象的判断是否是文件或是否是文件夹的方法<br>3.获得文件名，根据判断结果输出信息。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
       File f = new File(&quot;D:\\Clash\\a.txt&quot;);
       if (f.isFile())&#123;
           System.out.println(f.getName() + &quot;是文件&quot;);
       &#125;else &#123;
           System.out.println(f.getName() + &quot;不是文件&quot;);
       &#125;

       File f2 = new File(&quot;D:\\Clash&quot;);
       if (f2.isDirectory())&#123;
           System.out.println(f2.getName() + &quot;是文件夹&quot;);
       &#125;else&#123;
           System.out.println(f2.getName() + &quot;不是文件夹&quot;);
       &#125;
    &#125;
</code></pre>
<h3 id="练习：文件夹的获取方式"><a href="#练习：文件夹的获取方式" class="headerlink" title="练习：文件夹的获取方式"></a>练习：文件夹的获取方式</h3><p>描述:</p>
<p>获取指定文件夹下所有的文件，并将所有文件的名字输出到控制台。<br>注意：不包含子文件夹下的文件</p>
<p><strong>操作步骤:</strong></p>
<p>1.创建文件对象关联到指定文件夹，比如：c:&#x2F;aaa<br>2.调用文件对象的listFiles方法获得文件数组<br>3.遍历文件数组将每一个文件的名字输出到控制台</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        File f = new File(&quot;D:\\Clash&quot;);
        File[] files = f.listFiles();
        for (File file : files)&#123;
            System.out.println(file.getName());
        &#125;
    &#125;
</code></pre>
<h1 id="List集合-amp-Set集合习题"><a href="#List集合-amp-Set集合习题" class="headerlink" title="List集合&amp;Set集合习题"></a>List集合&amp;Set集合习题</h1><h3 id="练习：List接口的特点"><a href="#练习：List接口的特点" class="headerlink" title="练习：List接口的特点"></a>练习：List接口的特点</h3><h6 id="简述List接口的特点"><a href="#简述List接口的特点" class="headerlink" title="简述List接口的特点"></a>简述List接口的特点</h6><p>★ 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的读取顺序按照11、22、33的顺序完成的<br>★ 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素(与数组的索引是一个道理)<br>★ 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</p>
<h3 id="练习：hashCode和equals方法"><a href="#练习：hashCode和equals方法" class="headerlink" title="练习：hashCode和equals方法"></a>练习：hashCode和equals方法</h3><h6 id="请简述HashSet去除重复元素的原理"><a href="#请简述HashSet去除重复元素的原理" class="headerlink" title="请简述HashSet去除重复元素的原理"></a>请简述HashSet去除重复元素的原理</h6><p>★ 调用被添加元素的hashCode(), 和HashSet中已有元素的hasCode比较是否相同<br>★ 如果不同，直接存储<br>★ 如果相同，调用equals方法比较是否相同<br>★ 不相同，直接存储元素<br>★ 相同，认为是同一元素，不存储</p>
<h3 id="练习：数据结构"><a href="#练习：数据结构" class="headerlink" title="练习：数据结构"></a>练习：数据结构</h3><h6 id="简述常见的数据结构中元素的存储特点"><a href="#简述常见的数据结构中元素的存储特点" class="headerlink" title="简述常见的数据结构中元素的存储特点"></a>简述常见的数据结构中元素的存储特点</h6><p>★ 栈：stack，又称堆栈，对元素的存取特点是<strong>先进后出</strong>。即，存进去的元素，要在后它后面的元素一次取出后，才能取出该元素<br>★ 队列：queue，简称队，对元素的存取特点是<strong>先进先出</strong>。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素<br>★ 数组：Array，是有序的元素序列，对元素的存储特点是：<br>1,查找元素快：通过索引，可以快速访问指定位置的元素<br>2.增删元素慢<br><strong>(1)</strong>.指定索引位置增加元素：需要创建一个新数组，将指定元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置<br><strong>(2)</strong>.指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中<br>★ 链表：linkedlist 对元素的存取有如下的特点：<br>**(1).**多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的      右手拉住下个人的左手，依次类推，这样多个人就连在一起了。<br>**(2).**查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。<br><strong>(3)</strong>.增删元素快：<br>增加元素：只需要修改连接下个元素的地址即可。<br>删除元素：只需要修改连接下个元素的地址即可。</p>
<h3 id="练习：Comparable和Comparator比较器"><a href="#练习：Comparable和Comparator比较器" class="headerlink" title="练习：Comparable和Comparator比较器"></a>练习：Comparable和Comparator比较器</h3><p>简述 <code>Comparable </code>和 <code>Comparator</code> 两个接口的区别</p>
<p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的<code>compareTo</code>方法被称为它的自然比较方法。只能再类中实现<code>compareTo()</code>一次，不能经常修改的代码实现自己想要的排序。实现此接口的对象列表(和数组)可以通过<code>Collections.sort</code> 或 <code>Arrays.sort</code> 从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h3 id="练习：LinkedList方法的使用"><a href="#练习：LinkedList方法的使用" class="headerlink" title="练习：LinkedList方法的使用"></a>练习：LinkedList方法的使用</h3><h6 id="根据要求练习LinkedList方法："><a href="#根据要求练习LinkedList方法：" class="headerlink" title="根据要求练习LinkedList方法："></a>根据要求练习LinkedList方法：</h6><p><strong>(1)</strong>.基本方法：add, set, get, remove, clear, size等方法；<br><strong>(2)</strong>.特有方法：addFirst, addLast, getFirst, getLast, removeFirst, removeLast, push, pop, clear等方法。</p>
<pre><code class="java">(1).基本方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; arr = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹雪&quot;);
        arr.add(&quot;西门吹风&quot;);
        arr.add(&quot;西门吹水&quot;);

        // 3.使用add方法在指定索引添加元素
        arr.add(2, &quot;西门吹雨&quot;);

        // 4.使用set方法修改指定位置索引
        arr.set(0, &quot;东门&quot;);

        for (String str : arr) &#123;
            System.out.println(str);
        &#125;
        System.out.println(&quot;--------------&quot;);
        // 5.使用get方法获取指定索引的元素
        System.out.println(arr.get(1));

        // 6.使用size方法获取集合大小
        System.out.println(arr.size());

        // 7.使用remove方法删除指定索引的元素
        arr.remove(3);

        // 8.使用clear清空集合中的元素
        arr.clear();
        System.out.println(arr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">(2).特有方法
public static void main(String[] args) &#123;
        // 1.创建LinkedList
        LinkedList&lt;String&gt; linked = new LinkedList&lt;String&gt;();

        // 2.使用add方法添加元素
        linked.add(&quot;周杰伦&quot;);
        linked.add(&quot;周星驰&quot;);
        linked.add(&quot;周华健&quot;);
        linked.add(&quot;周润发&quot;);

        // 3.使用addFirst添加元素到集合最前面
        linked.addFirst(&quot;周传雄&quot;);

        // 4.使用addLast添加元素到集合最后面
        linked.addLast(&quot;周渝民&quot;);

        System.out.println(linked);

        // 5.使用getFirst获取集合第一个元素
        System.out.println(linked.getFirst());

        // 6.使用getLast获取集合最后一个元素
        System.out.println(linked.getLast());

        // 7.使用removeLast删除集合第一个元素
        String first = linked.removeFirst();
        System.out.println(first);

        // 8.使用removeLast删除集合最后一个元素
        String last = linked.removeLast();
        System.out.println(last);
        System.out.println(linked);


        // 9.使用pop弹出第一个元素
        String p = linked.pop();
        System.out.println(p);

        // 10.使用push在集合开头插入元素
        linked.push(&quot;周立波&quot;);
        System.out.println(linked);

        // 11.使用clear清空集合
        linked.clear();
        System.out.println(linked);
    &#125;
&#125;
</code></pre>
<h3 id="练习：HashSet存储自定义类型"><a href="#练习：HashSet存储自定义类型" class="headerlink" title="练习：HashSet存储自定义类型"></a>练习：HashSet存储自定义类型</h3><p>定义人类，包含姓名和年龄属性。创建4个人存储到<strong>HashSet</strong>中，姓名和年龄相同的人看做同一人不存储。</p>
<pre><code class="java">// 1.定义Person类.包好姓名年龄属性,重写hashCode()和equals()方法
public class Person &#123;
    private String name;
    private int age;

    public Person() &#123;
    &#125;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof Person)) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        return name != null ? name.equals(person.name) : person.name == null;
    &#125;

    @Override
    public int hashCode() &#123;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
</code></pre>
<pre><code class="java">ublic class HashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 2.创建HashSet用于存储Person类型
        HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;();

        // 3.添加多个Person到HashSet中
        hashSet.add(new Person(&quot;王昭君&quot;, 21));
        hashSet.add(new Person(&quot;西施&quot;, 21));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));
        hashSet.add(new Person(&quot;杨玉环&quot;, 20));
        hashSet.add(new Person(&quot;貂蝉&quot;, 19));

        // 4.遍历获取HashSet中的内容
        for (Person p : hashSet) &#123;
            System.out.println(p);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：List集合元素替换"><a href="#练习：List集合元素替换" class="headerlink" title="练习：List集合元素替换"></a>练习：List集合元素替换</h3><p>向list集合添加姓名{张三,李四,王五,二丫,钱六,孙七}, 将二丫替换为王小丫</p>
<pre><code class="java">public class ListTest01 &#123;
    public static void main(String[] args) &#123;
        //1.创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        //2.存入数据
        list.add(&quot;张三&quot;);
        list.add(&quot;李四&quot;);
        list.add(&quot;王五&quot;);
        list.add(&quot;二丫&quot;);
        list.add(&quot;钱六&quot;);
        list.add(&quot;孙七&quot;);
        //3.遍历集合，找到&quot;二丫&quot;,便将其替换为&quot;王小丫&quot;
        //利用普通for循环遍历List集合
        for(int i = 0;i&lt;list.size();i++) &#123;
            //获取当前元素
            String thisName = list.get(i);
            //如果当前元素是&quot;二丫&quot;
            if(&quot;二丫&quot;.equals(thisName)) &#123;
                //将其改为&quot;王小丫&quot;
                list.set(i, &quot;王小丫&quot;);
            &#125;
        &#125;
        System.out.println(list);
    &#125;
&#125;

//   使用增强for获取LinkedHashSet中的元素
        for (String str : list)&#123;
           if (&quot;二丫&quot;.equals(str))&#123;
                System.out.println(list);
           &#125;
        &#125;
</code></pre>
<h3 id="练习：LinkedHashSet基本使用"><a href="#练习：LinkedHashSet基本使用" class="headerlink" title="练习：LinkedHashSet基本使用"></a>练习：LinkedHashSet基本使用</h3><p>使用LinkedHashSet存储以下元素：”王昭君”,”王昭君”,”西施”,”杨玉环”,”貂蝉”。使用迭代器和增强for循环遍历LinkedHashSet。</p>
<pre><code class="java">public class LinkedHashSetTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建LinkedHashSet
        LinkedHashSet&lt;String&gt; lhSet = new LinkedHashSet&lt;String&gt;();
        // 2.使用add方法添加元素到LinkedHashSet
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;王昭君&quot;);
        lhSet.add(&quot;西施&quot;);
        lhSet.add(&quot;杨玉环&quot;);
        lhSet.add(&quot;貂蝉&quot;);
        // 3.使用迭代器获取LinkedHashSet中的元素
        Iterator&lt;String&gt; iterator = lhSet.iterator();
        while (iterator.hasNext()) &#123;
            System.out.println(iterator.next());
        &#125;
        // 4.使用增强for获取LinkedHashSet中的元素
        System.out.println(&quot;---------------------&quot;);
        for (String string : lhSet) &#123;
            System.out.println(string);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：Collections工具类使用"><a href="#练习：Collections工具类使用" class="headerlink" title="练习：Collections工具类使用"></a>练习：Collections工具类使用</h3><p>ArrayList集合中有如下内容： {33,11,77,55}，使用Collections.sort()对ArrayList集合中的数据进行排序，并打印出排序后的结果</p>
<pre><code class="java">public class CollectionsTest01 &#123;
    public static void main(String[] args) &#123;
        // 1.创建ArrayList
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();

        // 2.使用add方法添加&#123;33,11,77,55&#125;四个元素
        arr.add(33);
        arr.add(11);
        arr.add(77);
        arr.add(55);

        // 3.调用Collections的sort方法,对集合排序
        Collections.sort(arr);

        // 4.使用增强for遍历ArrayList集合
        for (Integer integer : arr) &#123;
            System.out.println(integer);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="Map集合习题"><a href="#Map集合习题" class="headerlink" title="Map集合习题"></a>Map集合习题</h1><h3 id="练习：Map接口的特点"><a href="#练习：Map接口的特点" class="headerlink" title="练习：Map接口的特点"></a>练习：Map接口的特点</h3><h6 id="请简述Map-的特点"><a href="#请简述Map-的特点" class="headerlink" title="请简述Map 的特点"></a>请简述Map 的特点</h6><p>★ Map每个元素由键与值两部分组成<br>★ Map键不能重复，每个键对应一个值<br>★ 键和值可以为null</p>
<h3 id="练习：Entry键值对对象"><a href="#练习：Entry键值对对象" class="headerlink" title="练习：Entry键值对对象"></a>练习：Entry键值对对象</h3><h6 id="说出Entry键值对对象遍历Map集合的原理"><a href="#说出Entry键值对对象遍历Map集合的原理" class="headerlink" title="说出Entry键值对对象遍历Map集合的原理"></a>说出Entry键值对对象遍历Map集合的原理</h6><p>Map中存放的是两种对象，一种称为Key(键)，一种称为value(值)，它们在Map中是一一对应关系，这一种对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每个键值对(Entry)对象中获取对应的键与对应的值。</p>
<h3 id="练习：Map接口中的常用方法"><a href="#练习：Map接口中的常用方法" class="headerlink" title="练习：Map接口中的常用方法"></a>练习：Map接口中的常用方法</h3><h6 id="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"><a href="#请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。" class="headerlink" title="请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。"></a>请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。</h6><pre><code class="java">    public static void main(String[] args) &#123;
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);
        String v1 = hm.put(&quot;李晨&quot;, &quot;白百合&quot;);
        String string = hm.get(&quot;大黑牛&quot;);
        String v2 = hm.remove(&quot;大黑牛&quot;);
        System.out.println(v2);
        System.out.println(hm);
    &#125;
//  范冰冰  &#123;邓超=孙俪, 李晨=白百合, 黄晓明=Baby&#125;
</code></pre>
<h3 id="练习：Map接口中的方法"><a href="#练习：Map接口中的方法" class="headerlink" title="练习：Map接口中的方法"></a>练习：Map接口中的方法</h3><p>往一个Map集合中添加若干元素。获取Map中的所有value，并使用增强for和迭代器遍历输出每个value。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        // 1.创建HashMap
        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();

        // 2.使用put添加元素
        hm.put(&quot;黄晓明&quot;, &quot;Baby&quot;);
        hm.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        hm.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        hm.put(&quot;大黑牛&quot;, &quot;范冰冰&quot;);

        // 3.使用Map的values方法获取到所有的value
        Collection&lt;String&gt; values = hm.values();

        // 4.使用增强for获取每个value
        for (String value : values) &#123;
            System.out.println(value);
        &#125;

        System.out.println(&quot;----------------&quot;);
        // 5.使用迭代器获取每个value
        Iterator&lt;String&gt; itr = values.iterator();
        while (itr.hasNext()) &#123;
            System.out.println(itr.next());
        &#125;
    &#125;
</code></pre>
<h3 id="练习：HashMap存储键是自定义对象是String"><a href="#练习：HashMap存储键是自定义对象是String" class="headerlink" title="练习：HashMap存储键是自定义对象是String"></a>练习：HashMap存储键是自定义对象是String</h3><p>请使用Map集合存储自定义数据类型Car做键，对应的价格做值。并使用keySet和entrySet两种方式遍历Map集合。</p>
<pre><code class="java">        // 1.定义汽车类.包含名称和价格属性,重写hashCode和equals方法
    public class Car &#123;
        private String name;
        private String color;
        ...
    &#125;
---------------------------------------------------
    public static void main(String[] args) &#123;
         // 2.创建HashMapkey保存汽车对象,value是汽车价格
        HashMap&lt;Car, Integer&gt; hm = new HashMap&lt;&gt;();

        // 3.添加汽车到HashMap中
        Car c1 = new Car(&quot;长安奔奔&quot;, &quot;黄色&quot;);
        Car c3 = new Car(&quot;奇瑞QQ&quot;, &quot;黑色&quot;);
        Car c2 = new Car(&quot;铃木奥拓&quot;, &quot;白色&quot;);

        hm.put(c1, 10000);
        hm.put(c2, 20000);
        hm.put(c3, 30000);

         // 4.使用keySet方式遍历Map
        Set&lt;Car&gt; keySet = hm.keySet();
        for (Car c : keySet) &#123;
        // 根据key获取value
            Integer value = hm.get(c);
            System.out.println(c.getName() + &quot;,&quot; + c.getColor() + &quot; - &quot; + value);
        &#125;

        System.out.println(&quot;-------------&quot;);

        // 5.使用entrySet方式遍历Map
        Set&lt;Map.Entry&lt;Car, Integer&gt;&gt; entrySet = hm.entrySet();
        for (Map.Entry&lt;Car, Integer&gt; entry : entrySet) &#123;
            Car key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key.getName() + &quot;,&quot; + key.getColor() + &quot; - &quot; + value);
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()<br>返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。  该集合由地图支持，因此对地图的更改将反映在集合中，反之亦然。  如果在集合中的迭代正在进行时修改映射（除了通过迭代器自己的<code>remove</code>操作，或者通过迭代器返回的映射条目上的<code>setValue</code>操作），迭代的结果是未定义的。  该组支持元件移除，即从映射中相应的映射，经由<code>Iterator.remove</code> ，  <code>Set.remove</code> ， <code>removeAll</code> ，  <code>retainAll</code>和<code>clear</code>操作。  它不支持<code>add</code>或<code>addAll</code>操作。</p>
</blockquote>
<h3 id="练习：Map集合的使用-一"><a href="#练习：Map集合的使用-一" class="headerlink" title="练习：Map集合的使用(一)"></a>练习：Map集合的使用(一)</h3><h6 id="现在有一个map集合如下："><a href="#现在有一个map集合如下：" class="headerlink" title="现在有一个map集合如下："></a>现在有一个map集合如下：</h6><pre><code class="java">     Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;();
     map.put(1, &quot;张三丰&quot;);
     map.put(2, &quot;周芷若&quot;);
     map.put(3, &quot;汪峰&quot;);
     map.put(4, &quot;灭绝师太&quot;);
</code></pre>
<p><strong>要求：</strong></p>
<p>1.遍历集合，并将序号与对应人名打印。<br>2.向该map集合中插入一个编码为5姓名为李晓红的信息<br>3.移除该map中的编号为1的信息<br>4.将map集合中编号为2的姓名信息修改为”周林”</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义HashMap,编号作为key,姓名作为value
        Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
        // 2.使用put方法添加元素
        map.put(1, &quot;张三丰&quot;);
        map.put(2, &quot;周芷若&quot;);
        map.put(3, &quot;汪峰&quot;);
        map.put(4, &quot;灭绝师太&quot;);
        // 3.使用keySet+增强for迭代map中的元素,并打印
        Set&lt;Integer&gt; keySet = map.keySet();
        for (Integer key : keySet) &#123;
            String value = map.get(key);
            System.out.println(key + &quot; -- &quot; + value);
        &#125;
        // 4.使用put向该map集合中插入一个编码为5姓名为李晓红的信息
        map.put(5, &quot;李晓红&quot;);
        // 5.使用remove移除该map中的编号为1的信息
        map.remove(1);
        // 6.使用put将map集合中编号为2的姓名信息修改为&quot;周林&quot;
        map.put(2, &quot;周林&quot;);
        System.out.println(map);
    &#125;
</code></pre>
<h3 id="练习：Map集合的使用-二"><a href="#练习：Map集合的使用-二" class="headerlink" title="练习：Map集合的使用(二)"></a>练习：Map集合的使用(二)</h3><p>有2个数组<br>第一个数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]，<br>第二个数组为：[哈尔滨,杭州,南昌,广州,福州]，将第一个数组元素作为<strong>key</strong>，<br>第二个数组元素作为<strong>value</strong>存储到Map集合中。如{黑龙江省&#x3D;哈尔滨, 浙江省&#x3D;杭州, …}</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        // 1.定义第一个数组arr1
        String[] arr1 = &#123;&quot;黑龙江省&quot;, &quot;浙江省&quot;, &quot;江西省&quot;, &quot;广东省&quot;, &quot;福建省&quot;&#125;;
        // 2.定义第二个数组arr2
        String[] arr2 = &#123;&quot;哈尔滨&quot;, &quot;杭州&quot;, &quot;南昌&quot;, &quot;广州&quot;, &quot;福州&quot;&#125;;

        // 3.创建HashMap,key存放省,value存放市
        HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;();

        // 4.使用普通for循环遍历arr1
        for (int i = 0; i &lt; arr1.length; i++) &#123;
        // 5.根据索引到arr1中获取到省
            String key = arr1[i];
        // 6.根据索引到arr2中获取到省会城市
            String value = arr2[i];

        // 7.将省和省会城市添加到HashMap中
            hm.put(key, value);
        &#125;
        // 8.输出HashMap中的内容
        System.out.println(hm);
    &#125;
</code></pre>
<h1 id="Math类习题"><a href="#Math类习题" class="headerlink" title="Math类习题"></a>Math类习题</h1><h3 id="练习：实现字符串123反转"><a href="#练习：实现字符串123反转" class="headerlink" title="练习：实现字符串123反转"></a>练习：实现字符串123反转</h3><p>使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">        public class Test1 &#123;
            public static void main(String[] args) &#123;
                Scanner scanner = new Scanner(System.in);
                String next = scanner.next();
                System.out.println(&quot;录入的字符串:&quot; + next);
                String s = reverseStr(next);
                System.out.println(&quot;反转的字符串:&quot;+ s);
            &#125;
        
            public static String reverseStr(String  str)&#123;
                String s = &quot;&quot;;
                char[] chars = str.toCharArray();
                for (int i = chars.length - 1; i &gt;= 0; i--) &#123;
                    s +=chars[i] ;
                &#125;
                return s;
            &#125;
        &#125;
</code></pre>
<blockquote>
<p>toCharArray() 方法将字符串转换为字符数组</p>
</blockquote>
<h3 id="练习：键盘录入QQ号判断正确性"><a href="#练习：键盘录入QQ号判断正确性" class="headerlink" title="练习：键盘录入QQ号判断正确性"></a>练习：键盘录入QQ号判断正确性</h3><p>必须是5-12位数字，0不能开头</p>
<pre><code class="java">public class Test1 &#123;
    public static void main(String[] args) &#123;
        //1.键盘输入一个qq号码字符串
        Scanner sc = new Scanner(System.in);
        String qq = sc.next();
        //2.调用checkQQ (String qq)方法内实现验证。
        boolean isOK = checkQQ(qq);
        //3.打印验证的结果
        System.out.println(&quot;这个QQ号码是否正确:&quot; + isOK);
    &#125;

    /*
     * 定义方法：checkQQ (String qq)方法内实现验证
     * 指定方法的名称：checkQQ
     * 指定方法的参数：String qq
     * 指定方法的返回值：boolean
     */
    public static boolean checkQQ(String qq) &#123;
        //1.验证字符串的长度5-12位之间；
        if (qq.length() &lt; 5 || qq.length() &gt; 12) &#123;
            return false; //说明qq号码的长度不正确
        &#125;
        //2.验证首位字符不能是字符0；只能是字符&#39;1&#39;--&#39;9&#39;
        if (qq.charAt(0) == &#39;0&#39;) &#123;
            return false;
        &#125;
        //3.验证字符串中的每个字符都必须是数字字符‘0’-‘9’之间的字符
        for (int i = 0; i &lt; qq.length(); i++) &#123;
            char ch = qq.charAt(i);
            //判断字符是否在 数字字符‘0’-‘9’之间的字符
            if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;
                return false;//说明qq号码中含有非数字字符
            &#125;
        &#125;
        //4.上述验证都通过了，说明qq号码是正确的
        return true;
    &#125;
 &#125;
</code></pre>
<h3 id="练习：大小写字符转换并统计次数"><a href="#练习：大小写字符转换并统计次数" class="headerlink" title="练习：大小写字符转换并统计次数"></a>练习：大小写字符转换并统计次数</h3><p>键盘录入一个大字符串，再录入一个小字符串。统计小字符串在大字符串中出现的次数。</p>
<pre><code class="java">   /*
* 分析以下需求，并用代码实现
1.键盘录入一个大字符串,再录入一个小字符串
2.统计小字符串在大字符串中出现的次数
3.代码运行打印格式:
请输入大字符串:woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma
请输入小字符串:heima
控制台输出:小字符串heima,在大字符串woaiheima,heimabutongyubaima,wulunheimahaishibaima,zhaodaogongzuojiushihaoma中共出现3次
             */

    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        // 1.键盘录入一个大字符串,再录入一个小字符串
        System.out.print(&quot;请输入大字符串:&quot;);
        String big = sc.nextLine();
        System.out.print(&quot;请输入小字符串:&quot;);
        String small = sc.nextLine();
        // 2.统计小字符串在大字符串中出现的次数
        int count = getCount(big, small);
        // 3.代码运行打印格式:
        System.out.println(&quot;小字符串&quot; + small + &quot;,在大字符串中共出现&quot; + count + &quot;次&quot;);
    &#125;

    /*
     * 方法功能：统计小字符串在大字符串中出现的次数
     * 参数：big 代表大字符串
     * 参数：small 代表小字符串
     * 返回值：小字符串在大字符串中出现的次数
     */
    public static int getCount(String big, String small) &#123;
        int index = 0;
        int count = 0;
        /*
         * indexOf(String str, int fromIndex)
         * 该方法作用：从fromIndex位置开始查找，字符串str第一次出现的位置；若没找到，放回-1
         */
        while ((index = big.indexOf(small, index)) != -1) &#123;
            index++;
            count++;
        &#125;
        return count;
    &#125;
</code></pre>
<h3 id="练习：随机小数保留两位"><a href="#练习：随机小数保留两位" class="headerlink" title="练习：随机小数保留两位"></a>练习：随机小数保留两位</h3><p>生成一个<strong>随机100</strong>内小数，转换为保留两位小数的字符串，不考虑四舍五入的问题。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        double random = Math.random()*100;
        System.out.println(&quot;随机数为：&quot;);
        System.out.println(random);
        String str = random + &quot; &quot;;
        int index = str.indexOf(&quot;.&quot;);
        String substring = str.substring(0, index + 3);
        System.out.println(&quot;转换为&quot;);
        System.out.println(substring);
    &#125;
// substring(int strat, int end)中第一个参数是开始位置，第二个参数是结束位置.
</code></pre>
<h3 id="练习：筛选字符串"><a href="#练习：筛选字符串" class="headerlink" title="练习：筛选字符串"></a>练习：筛选字符串</h3><p>定义ArrayList集合，存入多个字符串。长度大于5的字符串，打印删除后的集合。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;bca&quot;);
        list.add(&quot;dadfa&quot;);
        list.add(&quot;dddaaa&quot;);
        list.add(&quot;你好啊&quot;);
        list.add(&quot;我来啦,你干嘛呢&quot;);
        list.add(&quot;别跑啊&quot;);
        System.out.println(&quot;源字符串：&quot;);
        System.out.println(list);
        delStrsFromList01(list);
    &#125;
    private static void delStrsFromList01(ArrayList&lt;String&gt; list)&#123;
        ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            String str = list.get(i);
            if (str.length() &gt; 3)&#123;
                list2.add(str);
            &#125;
        &#125;
        for (Object str : list2)&#123;
            list.remove(str);
        &#125;
        System.out.println(&quot;新字符：&quot; + list);
    &#125;
</code></pre>
<h3 id="练习：回文字符串"><a href="#练习：回文字符串" class="headerlink" title="练习：回文字符串"></a>练习：回文字符串</h3><p>判断回文字符串。如果一个字符串，从前向后读和从后向前读，都是一个字符串，称为回文串，比如mom，dad，noon。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        String next = scanner.next();
        boolean p = isP(next);
        System.out.println(
                &quot;回文数:&quot; + p
        );
    &#125;

    public static boolean isP(String str) &#123;
        int start = 0;
        int end = str.length() - 1;
        while (start &lt; end) &#123;
            if (str.charAt(start) != str.charAt(end)) &#123;
                return false;
            &#125;
            start++;
            end--;
        &#125;
        return true;
    &#125;
</code></pre>
<blockquote>
<p>charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。</p>
</blockquote>
<h3 id="练习：模拟简单计算器"><a href="#练习：模拟简单计算器" class="headerlink" title="练习：模拟简单计算器"></a>练习：模拟简单计算器</h3><p>模拟简单计算器，可以运算+，—，*，&#x2F;，%。</p>
<ul>
<li>接收三个参数，一个整数，一个运算符，另一个整数。( ‘5’   ‘+’   ‘7’ )</li>
<li>计算出运算结果。</li>
<li>无法运算时，返回null。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        String next = scanner.next();
        int b = scanner.nextInt();
        String count = count(a, next, b);
        System.out.println(a +next +b +&quot;=&quot;+count);
    &#125;

    public static String count(int a, String op , int b )&#123;
        int r=0;
        if (&quot;+&quot;.equals(op))&#123;
            r = a+b;
        &#125;else  if (&quot;-&quot;.equals(op))&#123;
            r = a-b;
        &#125;else  if (&quot;*&quot;.equals(op))&#123;
            r = a*b;
        &#125;else  if (&quot;/&quot;.equals(op))&#123;
            r = a/b;
        &#125;else  if (&quot;%&quot;.equals(op))&#123;
            r = a%b;
        &#125;else &#123;
            return null;
        &#125;
        return r+&quot;&quot;;
    &#125;
</code></pre>
<h3 id="练习：密码是否合法"><a href="#练习：密码是否合法" class="headerlink" title="练习：密码是否合法"></a>练习：密码是否合法</h3><p>校验密码是否合法。合法返回true </p>
<ul>
<li>必须至少8个字符。</li>
<li>必须至少2个大写字符。<code>超越两个就要依次遍历 for循环</code></li>
<li>必须只有字母和数字。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        String s = &quot;qweRY123&quot;;
        System.out.println(s+&quot;密码是否合法&quot;+isTrue(s));
    &#125;
    private static boolean isTrue(String s)&#123;
        if (s.length()&lt;8)&#123;
            return false;
        &#125;

        int countA = 0;
        char[] chars = s.toCharArray();
        for (int i = 0; i &lt; s.length(); i++) &#123;
            char ch = chars[i];
            //2个大写字母
            if (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;)&#123;
                countA++;
            &#125;
            //字母数字
            if ((ch &lt; &#39;0&#39;|| ch&gt;&#39;9&#39;) &amp;&amp; (ch &lt; &#39;A&#39;|| ch&gt;&#39;Z&#39;)&amp;&amp;(ch &lt; &#39;a&#39;|| ch&gt;&#39;z&#39;)) &#123;
                return false;
            &#125;
        &#125;
        if (countA &lt; 2)&#123;
            return false;
        &#125;
        return true;
    &#125;
</code></pre>
<h3 id="练习：模拟用户登录"><a href="#练习：模拟用户登录" class="headerlink" title="练习：模拟用户登录"></a>练习：模拟用户登录</h3><p>模拟用户登录。</p>
<ul>
<li>定义用户类，属性为用户名和密码。</li>
<li>使用集合存储多个用户对象。</li>
<li>录入用户和密码，对比用户信息，匹配成功登录成功，否则登录失败。</li>
<li>登录失败时，当用户名错误，提示没有该用户。</li>
<li>登录失败时，当密码错误时，提示密码有误。</li>
</ul>
<blockquote>
<p>jack-1234    rose-5678    tom-0000<br>请输入用户名：rose<br>请输入密码：5678<br>登录结果：登录成功</p>
</blockquote>
<pre><code class="java">public class User &#123;
    private String username;
    private String pwd;
&#125;
------------------------------------------
public class Test &#123;
    static ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;();
    static &#123;
        list.add(new User(&quot;jack&quot;, &quot;1234&quot;));
        list.add(new User(&quot;rose&quot;, &quot;5678&quot;));
        list.add(new User(&quot;tom&quot;, &quot;0000&quot;));
        for (int i = 0; i &lt; list.size(); i++) &#123;
            list.get(i).show();
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入用户名：&quot;);
        String username = sc.nextLine();
        System.out.println(&quot;请输入密码：&quot;);
        String password = sc.nextLine();
        User u = new User(username, password);
        String login = login(u);
        System.out.println(&quot;登录结果：&quot; + login);
    &#125;
    public static String login(User user) &#123;
        String msg = &quot;&quot;;
        String n = user.getUsername();
        String p = user.getPwd();
        for (int i = 0; i &lt; list.size(); i++) &#123;
            User u = list.get(i);
            String name = u.getUsername();
            String pwd = u.getPwd();
            if (name.equals(n))&#123;
                if (pwd.equals(p))&#123;
                    return &quot;登录成功&quot;;
                &#125;else &#123;
                    return &quot;密码错误&quot;;
                &#125;
            &#125;else &#123;
                msg = &quot;用户名不存在&quot;;
                continue;
                &#125;
            &#125;
        return msg;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p><strong>static代码块</strong>也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，<u>每个代码块只会被执行一次</u>。[ <em><u>在此代码内适用于login方法中的list.size()</u></em> ]<br>static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的，<br>它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p>
</blockquote>
<h1 id="Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类"><a href="#Object类-amp-Date类-amp-Calender-日期-类-amp-StringBuilder类" class="headerlink" title="Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类"></a>Object类&amp;Date类&amp;Calender(日期)类&amp;StringBuilder类</h1><h3 id="练习：简述String和Object中的equals"><a href="#练习：简述String和Object中的equals" class="headerlink" title="练习：简述String和Object中的equals"></a>练习：简述String和Object中的equals</h3><p>简述String类中的equals方法 与 Object类中的equals方法的不同点</p>
<blockquote>
<p><strong>String类</strong>中的equals方法是用来<u>判断两个<strong>对象的内容</strong>是否相同</u>，而<strong>Object 类</strong>中的equals方法是用来<u>判断两个<strong>对象</strong>是否是同一个对象</u>，所谓同一个对象指的是内存中的同一块存储空间。</p>
</blockquote>
<h3 id="练习：Object类的toString方法"><a href="#练习：Object类的toString方法" class="headerlink" title="练习：Object类的toString方法"></a>练习：Object类的toString方法</h3><pre><code class="java">    public class ToStringTest&#123;
        static int i = 1;
        public static void main(String args[])&#123;
            System.out.println(&quot;love &quot; + new ToStringTest());//love java
            ToStringTest a = new ToStringTest();
            a.i++;
            System.out.println(&quot;me &quot; + a.i);//me 2
        &#125;
        public String toString()&#123;
            System.out.print(&quot;I &quot;);//I
            return &quot;java &quot;;
        &#125;
    &#125;
</code></pre>
<p>运行结果：I love java    me 2<br>原因：当执行代码的时候，首先加载静态变量，然后执行main方法，由于main方法内部第一行代码为输出语句，里面new了此类对象，当执行此行代码时会先创建了本类的对象，由于此类重写了toString方法，会先执行toString方法的打印输出，然后返回“java ”，再执行main方法第一行打印输出。在Java中“System.out.println(类对象名);”实际输出的是该对象的toString()方法返回的字符串，即括号中的内容等价于类对象名.toString(),toString方法的好处是在碰到println方法的时候会被自动调用，不用显示的写出来。</p>
<h3 id="练习：Object类equals方法"><a href="#练习：Object类equals方法" class="headerlink" title="练习：Object类equals方法"></a>练习：Object类equals方法</h3><p>看下列程序，不运行说结果，写出答案后，并在IntelliJ IDEA中运行看看自己给的答案与运行结果是否正确，并分析原因。</p>
<pre><code class="java">    (1)
        String s1 = new String(&quot;abc&quot;);
        String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //false
        System.out.println(s1.equals(s2));  //true
    (2)
        String s1 = &quot;abc&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);         //true
        System.out.println(s1.equals(s2));     //true
    (3)
        String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;
              String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);        //true
        System.out.println(s1.equals(s2));     //true
    (4)
        String s1 = &quot;ab&quot;;
             String s2 = &quot;abc&quot;;
             String s3 = s1 + &quot;c&quot;;
        System.out.println(s3 == s2);             //false
              System.out.println(s3.equals(s2));  //true
</code></pre>
<h3 id="练习：StringBuilder类与String类的区别"><a href="#练习：StringBuilder类与String类的区别" class="headerlink" title="练习：StringBuilder类与String类的区别"></a>练习：StringBuilder类与String类的区别</h3><p>简述StringBuilder类与String类的区别</p>
<blockquote>
<p><strong>String类</strong>的对象内容不可改变，所以每当进行字符串拼接时，<strong>总是会在内存中创建一个新的对象</strong>，所以经常改变内容的字符串最好不要用String，因为<strong>每次生成对象都会对系统性能产生影响</strong>。</p>
<p><strong>StringBuilder</strong>又称为可变字符序列，是JDK5.0中新增加的一个类，它是一个类似于String的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串，并且能够对其中的字符串进行各种操作。<strong>它的内部拥有一个数组用来存放字符串内容</strong>，进行字符串拼接时，直接在数组中加入新内容，<strong>StringBuilder会自动维护数组的扩容</strong>。</p>
</blockquote>
<h3 id="练习：Date类的使用"><a href="#练习：Date类的使用" class="headerlink" title="练习：Date类的使用"></a>练习：Date类的使用</h3><p>获取当前的日期, 并把这个日期转换为指定格式的字符串, 如2088-08-08 08:08:08</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //获取当前日期对象 now;
        Date now = new Date();
        //创建SimpleDateFormat对象 df,并制定日期格式
        SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        //调用df的format(Date  date) 方法,传入now; 接收返回的字符串
        String datestr = df.format(now);
        //打印这个字符串
        System.out.println(datestr);
    &#125;
</code></pre>
<h3 id="练习：DateFormat类方法的使用"><a href="#练习：DateFormat类方法的使用" class="headerlink" title="练习：DateFormat类方法的使用"></a>练习：DateFormat类方法的使用</h3><p>使用SimpleDateFormat类,把2018-03-04转换为2018年03月04日</p>
<pre><code class="java">    public static void main(String[] args) throws ParseException &#123;
        //创建SimpleDateFormat对象df1,指定日期模式为yyyy-MM-dd
        SimpleDateFormat df1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        //调用df1的parse(String str)方法传入2018-03-04,得到对应日期类型
        Date date = df1.parse(&quot;2018-03-04&quot;);
        //创建日期格式化对象df2,在获取格式化对象时可以指定风格
        DateFormat df2 = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);
        //调用df2的format(Date date) 传入刚才转换的日期
        String str = df2.format(date);
        System.out.println(str);
    &#125;
</code></pre>
<blockquote>
<p>public Date parse(String text, ParsePosition pos)<br>从字符串中解析文本，产生一个<code>Date</code> 。</p>
</blockquote>
<h3 id="练习：Calendar类方法的使用"><a href="#练习：Calendar类方法的使用" class="headerlink" title="练习：Calendar类方法的使用"></a>练习：Calendar类方法的使用</h3><p>用程序判断2018年2月14日是星期几。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        //创建Calendar对象
        Calendar c = Calendar.getInstance();
        //将给定的日历字段设置到Calendar对象中
        c.set(Calendar.YEAR, 2018);
        c.set(Calendar.MONTH, 1);
        c.set(Calendar.DATE, 14);
        //设置年
        int year = c.get(Calendar.YEAR);
        //设置月
        int month = c.get(Calendar.MONTH)+1;
        //设置日
        int date = c.get(Calendar.DATE);
        //设置星期
        char week = getWeek(c.get(Calendar.DAY_OF_WEEK));
        //输出结果
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日是星期&quot;+week);
    &#125;
    //定义方法，获取星期汉字
    public static char getWeek(int a)&#123;
        char[] c = &#123;&#39; &#39;,&#39;日&#39;,&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;,&#39;六&#39;&#125;;
        return c[a];
    &#125;
&#125;
</code></pre>
<h1 id="Random类-amp-ArrayList集合习题"><a href="#Random类-amp-ArrayList集合习题" class="headerlink" title="Random类&amp;ArrayList集合习题"></a>Random类&amp;ArrayList集合习题</h1><h3 id="练习：随机验证码"><a href="#练习：随机验证码" class="headerlink" title="练习：随机验证码"></a>练习：随机验证码</h3><ul>
<li>随机生成十组六位字符组成的验证码。</li>
<li>验证码由大小写字母、数字字符组成。</li>
</ul>
<p><strong>开发提示</strong>：使用字符数组保存原始字符，利用Random类生成随机索引。</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            String s = verifyCode();
            System.out.println(&quot;随机验证码：&quot; + s);
        &#125;
    &#125;
    public static String verifyCode()&#123;
        char[] arr = &#123;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;;
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            int index = random.nextInt(arr.length);
            code  += arr[index];
        &#125;
        return code;
    &#125;
</code></pre>
<h3 id="练习：输入学生信息保存到集合"><a href="#练习：输入学生信息保存到集合" class="headerlink" title="练习：输入学生信息保存到集合"></a>练习：输入学生信息保存到集合</h3><p>键盘录入学生信息，保存到集合中。</p>
<ul>
<li>循环录入的方式，1：表示继续录入，0：表示结束录入。</li>
<li>定义学生类，属性为姓名，年龄，使用学生对象保存录入数据。</li>
<li>使用ArrayList集合，保存学生对象，录入结束后，遍历集合。</li>
</ul>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
     public void show()&#123;
        System.out.println(&quot;姓名: &quot;+ name + &quot; &quot; + &quot;年龄: &quot; + age);
    &#125;
&#125;
----------------------------------
        public static void main(String[] args) &#123;
            Scanner scanner = new Scanner(System.in);
            ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();
            while (true) &#123;
                System.out.println(&quot;1.录入信息 0.退出&quot;);
                int i = scanner.nextInt();
                switch (i) &#123;
                    case 1:
                        inputStu(list , scanner);
                        break;
                    case 0:
                        System.out.println(&quot;录入完毕&quot;);
                &#125;
                if (i == 0)&#123;
                    break;
                &#125;
            &#125;
    
            for (int i = 0; i &lt; list.size(); i++) &#123;
                Student student = list.get(i);
                student.show();
            &#125;
        &#125;
    
        private static void inputStu(ArrayList&lt;Student&gt; list , Scanner sc) &#123;
            System.out.println(&quot;请输入姓名:&quot;);
            String name = sc.next();
            System.out.println(&quot;请输入年龄:&quot;);
            int age = sc.nextInt();
            Student student = new Student(name, age);
            list.add(student);
        &#125;
    &#125;
</code></pre>
<h3 id="练习：随机数-次数打印"><a href="#练习：随机数-次数打印" class="headerlink" title="练习：随机数 次数打印"></a>练习：随机数 次数打印</h3><p>统计数字出现次数。</p>
<ul>
<li>定义getNumList方法，随机生成100个数字，数字范围从1到10。</li>
<li>定义printCount方法，统计每个数字出现的次数并打印到控制台。</li>
</ul>
<pre><code class="java">    public class Test4 &#123;
        public static void main(String[] args) &#123;
            ArrayList&lt;Integer&gt; numList = getNumList();
            //  统计字符数组中字母出现次数
            printCount(numList);
        &#125;
        public static void printCount(ArrayList&lt;Integer&gt; list) &#123;
            int[] count = new int[10];
            // 对应保存数字出现的次数
            for (int i = 0; i &lt; list.size(); i++) &#123;
                int c = list.get(i);
                count[c-1]++;
            &#125;
            // 打印数字和次数
            for (int i = 0 ; i &lt; count.length; i++) &#123;
                    System.out.println(&quot;数字:&quot;+(i+1) + &quot;--&quot; + count[i]+&quot;次&quot;);
            &#125;
        &#125;
        public static ArrayList&lt;Integer&gt; getNumList() &#123;
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            Random r = new Random();
            for (int i = 0; i &lt; 100; i++) &#123;
                int x = r.nextInt(10) + 1;
                list.add(x);
            &#125;
            return list;
        &#125;
    &#125;    
</code></pre>
<h3 id="练习：需求实现"><a href="#练习：需求实现" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><p>模拟统计班级考试分数分布情况，分别统计100-80，79-60，59-40，39-0各个阶段的人数。</p>
<ul>
<li>定义getScoreList方法，随机生成50个数字，数字范围从0到100。</li>
<li>定义countScore方法，统计各个阶段的分数个数。</li>
<li>定义printCount方法，打印各个阶段的统计结果。</li>
</ul>
<pre><code class="java">    public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; scoreList = getScoreList(); //获取随机分数
        ArrayList&lt;Integer&gt; countList = countScore(scoreList); //定义计数的变量
        printCount(countList);
    &#125;
    public static ArrayList&lt;Integer&gt; countScore(ArrayList&lt;Integer&gt; scoreList) &#123;
        ArrayList&lt;Integer&gt; countList = new ArrayList&lt;&gt;();
        int count100 = 0;
        int count79 = 0;
        int count59 = 0;
        int count39 = 0;

        for (int i = 0; i &lt; scoreList.size(); i++) &#123;
            Integer score = scoreList.get(i);
            if (score &lt;= 100 &amp;&amp; score &gt;= 80) &#123;
                count100++;
            &#125; else if (score &lt;= 79 &amp;&amp; score &gt;= 60) &#123;
                count79++;
            &#125; else if (score &lt;= 59 &amp;&amp; score &gt;= 40) &#123;
                count59++;
            &#125; else &#123;
                count39++;
            &#125;
        &#125;

        countList.add(count100);
        countList.add(count79);
        countList.add(count59);
        countList.add(count39);

        return countList;
    &#125;

    private static ArrayList&lt;Integer&gt; getScoreList()&#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Random r = new Random();
        for (int i = 0; i &lt; 50; i++) &#123;
            int x = r.nextInt(100);
            list.add(x);
        &#125;
        return list;
    &#125;

    private static void printCount(ArrayList&lt;Integer&gt; countList) &#123;
        int start = 100;
        int end = 80;
        for (int i = 0; i &lt; countList.size(); i++) &#123;
            Integer integer = countList.get(i);
            System.out.println(start + &quot;\t分 --&quot; + end + &quot; \t分:&quot; + integer+&quot;人&quot;);
            if (i == 0)&#123;
                start-=21;
                end -=20;
            &#125;else if (i == countList.size()-2)&#123;
                start-=20;
                end-=40;
            &#125;else &#123;
                start -= 20;
                end -= 20;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：添加移除展示元素"><a href="#练习：添加移除展示元素" class="headerlink" title="练习：添加移除展示元素"></a>练习：添加移除展示元素</h3><p>自定义MyList类，实现存取元素的功能。</p>
<ul>
<li>定义add方法，可以保存元素，添加MyList尾部。</li>
<li>定义remove方法，可以获取到最后添加的元素，并从MyList中移除该元素。</li>
<li>定义show方法，可以展示MyList中的元素。</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
        MyList myList = new MyList();
        for (int i = 0; i &lt; 3; i++) &#123;
            myList.add(i);
        &#125;
        System.out.println(&quot;添加元素后:&quot;);
        myList.show();

        Integer remove = myList.remove();
        System.out.println(&quot;获取元素:&quot;);
        System.out.println(remove);
        System.out.println(&quot;获取元素后:&quot;);
        myList.show();
    &#125;
&#125;

class MyList &#123;
    ArrayList&lt;Integer&gt; ml = new ArrayList&lt;&gt;();

    public void add(Integer i) &#123;
        ml.add(i);
    &#125;

    public Integer remove() &#123;
        Integer remove = ml.remove(ml.size() - 1);
        return remove;
    &#125;

    public void show() &#123;
        System.out.println(ml);
    &#125;
&#125;
</code></pre>
<h1 id="线程-amp-同步习题"><a href="#线程-amp-同步习题" class="headerlink" title="线程&amp;同步习题"></a>线程&amp;同步习题</h1><h3 id="练习：多线程开启"><a href="#练习：多线程开启" class="headerlink" title="练习：多线程开启"></a>练习：多线程开启</h3><h6 id="请描述Thread类中的start-方法与run-方法的区别"><a href="#请描述Thread类中的start-方法与run-方法的区别" class="headerlink" title="请描述Thread类中的start()方法与run()方法的区别"></a>请描述Thread类中的start()方法与run()方法的区别</h6><p>线程对象调用run()方法不开启线程，仅是对象调用方法。<br>线程对象调用start()方法开启线程，并让jvm调用run()方法在开启的线程中执行。</p>
<h3 id="练习：创建多线程"><a href="#练习：创建多线程" class="headerlink" title="练习：创建多线程"></a>练习：创建多线程</h3><h6 id="请描述创建线程的两种方法"><a href="#请描述创建线程的两种方法" class="headerlink" title="请描述创建线程的两种方法"></a>请描述创建线程的两种方法</h6><ul>
<li><h5 id="将类声明为Thread的子类"><a href="#将类声明为Thread的子类" class="headerlink" title="将类声明为Thread的子类"></a>将类声明为Thread的子类</h5></li>
</ul>
<p>①.定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务，因此把run()方法称为线程执行体。<br>②.创建Thread子类的实例，即创建了线程对象<br>③.调用线程对象的start()方法来启动该线程</p>
<ul>
<li><h5 id="声明一个类实现Runnable接口"><a href="#声明一个类实现Runnable接口" class="headerlink" title="声明一个类实现Runnable接口"></a>声明一个类实现Runnable接口</h5></li>
</ul>
<p>①.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>②,创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，Thread对象才是真正的线程对象<br>③.调用线程对象的start()方法来启动线程</p>
<h3 id="练习：多线程"><a href="#练习：多线程" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请编写程序，分别打印主线程的名称和子线程的名称"><a href="#请编写程序，分别打印主线程的名称和子线程的名称" class="headerlink" title="请编写程序，分别打印主线程的名称和子线程的名称"></a>请编写程序，分别打印主线程的名称和子线程的名称</h6><p>要求使用两种方式实现：<br>          第一种方式：继承Thread类。<br>          第二种方法：实现Runnable接口。</p>
<p><strong>操作步骤描述</strong>：</p>
<ul>
<li><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5></li>
</ul>
<p>①.定义一个子线程的类，继承Thread类<br>②.在子线程类中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称<br>⑤.在main方法中创建子线程对象<br>⑥.调用子线程对象的start方法，开启子线程</p>
<pre><code class="java">// 1.定义一个子线程的类，继承Thread类；
public class SubThread extends Thread&#123;
// 2.在子线程类中重写run方法，在run方法中打印子线程的名称；
    public void run()&#123;
    // 打印子线程的名称
      System.out.println(&quot;subThread:&quot; + Thread.currentThread().getName());
    &#125;
&#125;
// 3.定义一个测试类
public class ThreadDemo&#123;
    public static void main(String[] args)&#123;
// 4.在main方法中打印主线程的名称；
    System.out.println(&quot;main:&quot; + Thread.currentThread().getName());
// 5.在main方法中创建子线程对象；
    SubThread st = new SubThread();
// 6.调用子线程对象的start方法，开启子线程。
    st.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5></li>
</ul>
<p>①.定义一个子任务类，实现Runnable接口<br>②.在子任务中重写run方法，在run方法中打印子线程的名称<br>③.定义一个测试类<br>④.在main方法中打印主线程的名称；<br>⑤.在main方法中创建一个子任务对象；<br>⑥.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的构造方法；<br>⑦.调用Thread类对象的start方法开启子线程；</p>
<pre><code class="java">// 1.定义一个子任务类，实现Runnable接口。
public class SubRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
// 2.在子任务类中重写run方法，在run方法中打印子线程的名称。
    System.out.println(&quot;SubRunnable:&quot;+ Thread.currentThread().getName());
// 3.定义一个测试类。
   &#125;
&#125;
public class RunnableDemo &#123;
    public static void main(String[] args) &#123;
// 4.在main方法中打印主线程的名称。
    System.out.println(&quot;RunnableDemo:&quot;+ Thread.currentThread().getName());
// 5.在main方法中创建一个子任务对象。
    SubRunnable r = new SubRunnable();
// 6.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的                         构造方法。
    Thread t = new Thread(r);
// 7.调用Thread类对象的start方法开启子线程。
    t.start();
 &#125;
&#125;
</code></pre>
<h3 id="练习：实现Runnable接口的优势"><a href="#练习：实现Runnable接口的优势" class="headerlink" title="练习：实现Runnable接口的优势"></a>练习：实现Runnable接口的优势</h3><h6 id="请描述实现Runnable接口比继承Thread类所具有的优势："><a href="#请描述实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="请描述实现Runnable接口比继承Thread类所具有的优势："></a>请描述实现Runnable接口比继承Thread类所具有的优势：</h6><p>①.适合多个相同的程序代码的线程去共享同一个资源<br>②.可以避免java中的单继承的局限性<br>③.增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和数据独立。<br>④.线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</p>
<h3 id="练习：多线程-1"><a href="#练习：多线程-1" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><p>创建多线程对象，开启多线程。在子线程中输出1-100之间的偶数，主线程输出1-100之间的奇数</p>
<p><strong>自定义线程类</strong>：</p>
<pre><code class="java">public class MyThread extends Thread &#123;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 100; i++) &#123;
            if (i % 2 == 0) &#123;
                System.out.println(&quot;子线程打印输出偶数：&quot; + i);
            &#125;
        &#125;
    &#125;
    public class Test11 &#123;
        public static void main(String[] args) &#123;
            //创建自定义线程对象
            MyThread mt = new MyThread();
            //开启线程
            mt.start();
            //在主方法中执行for循环
            for (int i = 1; i &lt;= 100; i++) &#123; 
                if (i % 2 == 1) &#123;
                    System.out.println(&quot;主线程打印输出奇数：&quot; + i);
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="练习：线程状态"><a href="#练习：线程状态" class="headerlink" title="练习：线程状态"></a>练习：线程状态</h3><h6 id="请描述在线程的生命周期中，-有几种状态呢"><a href="#请描述在线程的生命周期中，-有几种状态呢" class="headerlink" title="请描述在线程的生命周期中， 有几种状态呢 ?"></a>请描述在线程的生命周期中， 有几种状态呢 ?</h6><p>1.<strong>NEW(新建)</strong> 线程刚被创建，但是并未启动。</p>
<p>2.<strong>Runnable(可运行)</strong><br>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</p>
<p>3.<strong>Blocked(锁阻塞)</strong><br>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</p>
<p>4.<strong>Waiting(无限等待)</strong><br>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</p>
<p>5.<strong>Timed Waiting(计时等待)</strong><br>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</p>
<p>6.<strong>Teminated(被终止)</strong><br>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</p>
<h1 id="线程池-amp-lambda表达式习题"><a href="#线程池-amp-lambda表达式习题" class="headerlink" title="线程池&amp;lambda表达式习题"></a>线程池&amp;lambda表达式习题</h1><h3 id="练习：线程池概念"><a href="#练习：线程池概念" class="headerlink" title="练习：线程池概念"></a>练习：线程池概念</h3><h5 id="请描述什么是线程池"><a href="#请描述什么是线程池" class="headerlink" title="请描述什么是线程池"></a>请描述什么是线程池</h5><p>线程池：其实就是一个<strong>容纳多个线程的容器</strong>，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复用户创建线程而消耗过多的资源</p>
<h3 id="练习：线程池优点"><a href="#练习：线程池优点" class="headerlink" title="练习：线程池优点"></a>练习：线程池优点</h3><h5 id="请描述合理利用线程池能够带来的三个好处"><a href="#请描述合理利用线程池能够带来的三个好处" class="headerlink" title="请描述合理利用线程池能够带来的三个好处"></a>请描述合理利用线程池能够带来的三个好处</h5><p>1,<strong>降低资源消耗</strong>。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可以执行多个任务<br>2.<strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行<br>3.<strong>提高线程的可管理性</strong>。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p>
<h3 id="练习：Lambda表达式"><a href="#练习：Lambda表达式" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda语法的省略规则"><a href="#请列举Lambda语法的省略规则" class="headerlink" title="请列举Lambda语法的省略规则"></a>请列举Lambda语法的省略规则</h6><p>在Lambda标准格式的基础上，使用省略句写法的规则为：<br>1.小括号内参数的类型可以省略<br>2.如果小括号内有且只有一个参数，则小括号可以省略<br>3.如果大括号内有且只有一个语句，则无论是否有返回值，都可以省略大括号、return、关键字以及语句分号</p>
<h3 id="练习：Lambda表达式-1"><a href="#练习：Lambda表达式-1" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请列举Lambda表达式的3个组成部分，并解释说明"><a href="#请列举Lambda表达式的3个组成部分，并解释说明" class="headerlink" title="请列举Lambda表达式的3个组成部分，并解释说明"></a>请列举Lambda表达式的3个组成部分，并解释说明</h6><p>Lambda标准格式Lambda省去面向对象的条条框框，格式由3个部分组成：<strong>一些参数、一个箭头、一段代码</strong><br><u>Lambda表达式的标准格式</u>：<br>1.小括号内的语法与传统方法参数列表一致：无参数则留空，多个参数则用逗号分割<br>2.”—&gt;”是新引入的语法格式，代表指向动作<br>3.大括号内的语法与<strong>传统方法体</strong>要求基本一致</p>
<h3 id="练习：Lambda表达式-2"><a href="#练习：Lambda表达式-2" class="headerlink" title="练习：Lambda表达式"></a>练习：Lambda表达式</h3><h6 id="请描述Lambda的使用前提"><a href="#请描述Lambda的使用前提" class="headerlink" title="请描述Lambda的使用前提"></a>请描述Lambda的使用前提</h6><p>Lambda的语法非常简介，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：<br>1.使用Lambda必须具有接口，且要求接口中<strong>有且只有一个抽象方法</strong>。无论是JDK内置的<code>Runnable、Comparator</code>接口还是自定义的接口，只有<strong>当接口中的抽象方法存在且唯一时</strong>，才能使用Lambda。<br>2.使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例</p>
<h3 id="练习：多线程-2"><a href="#练习：多线程-2" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="代码实现打印输出1-99"><a href="#代码实现打印输出1-99" class="headerlink" title="代码实现打印输出1-99"></a>代码实现打印输出1-99</h6><pre><code class="java">public class Test06 &#123;
    public int start = 1;
    public int end = 99;

public static void main(String[] args) &#123;
    new Test06().method();
 &#125;

public void method() &#123;
    //插入代码处
         Runnable a = () -&gt; &#123;
      for (int i = start; i &lt;end; i++) &#123;
        System.out.println(i);
      &#125;
    &#125;;
      Thread t = new Thread(a);
      t.start();
     &#125;
&#125;
</code></pre>
<h3 id="练习：多线程-3"><a href="#练习：多线程-3" class="headerlink" title="练习：多线程"></a>练习：多线程</h3><h6 id="请问该程序的运行结果是什么-如有问题，请说明原因。"><a href="#请问该程序的运行结果是什么-如有问题，请说明原因。" class="headerlink" title="请问该程序的运行结果是什么?  如有问题，请说明原因。"></a>请问该程序的运行结果是什么?  如有问题，请说明原因。</h6><pre><code class="java">public class Test07implements Runnable &#123;
    public static void main(String[] args) &#123;
      Thread t = new Thread(new Test07());
      t.start();
      &#125;

public void run(int num) &#123;
    for (int i = 0; i &lt; num; i++) &#123;
       System.out.println(i);
    &#125;
  &#125;
&#125;
</code></pre>
<p>在编译时期就会报错</p>
<p>​               Test类没有重写Runnable接口中的run()方法</p>
<p>​               public void run(int num)不是Runnable接口中的run()方法。</p>
<p><strong>注意：Runnable接口中的run()方法，参数列表为空，不带参数。</strong></p>
<h3 id="练习：线程池练习"><a href="#练习：线程池练习" class="headerlink" title="练习：线程池练习"></a>练习：线程池练习</h3><h6 id="使用线程池创建多线程。模拟同学找老师学习Java。"><a href="#使用线程池创建多线程。模拟同学找老师学习Java。" class="headerlink" title="使用线程池创建多线程。模拟同学找老师学习Java。"></a>使用线程池创建多线程。模拟同学找老师学习Java。</h6><p>1.创建线程池对象，包含2个线程。从线程池中获取线程对象，然后调用MyRunnable中的run()。<br>2.在MyRunnable实现类中，首先在控制台打印需求，“我需要一个老师”。模拟需要2秒钟时间老师可以过来指导学生，并在控制台打印老师的姓名。最后，在控制台打印“教我java,教完后，老师回到了办公室”；</p>
<pre><code class="java">class Test implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个老师&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;老师来了&quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我Java，教完后，老师回到了办公室&quot;);
    &#125;
&#125;

class ThreadPoolDemo&#123;
    public static void main(String[] args) &#123;
        ExecutorService service = Executors.newFixedThreadPool(2);
        Test r = new Test();
        service.submit(r);//线程1
        service.submit(r);//线程2
        service.submit(r);//线程3
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-无参无返回"><a href="#练习：Lambda-无参无返回" class="headerlink" title="练习：Lambda(无参无返回)"></a>练习：Lambda(无参无返回)</h3><p>给定一个导演 Director接口，内含唯一的抽象方法makeMovie，且无参数、无返回值，使用lambda表达式在Test中完成调用。</p>
<pre><code class="java">interface Director&#123;
    void makeMovie();
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请使用Lambda【省略格式】调用invokeDirect方法
        invokeDirect(()-&gt; System.out.println(&quot;拍电影啦&quot;));
    &#125;
    private static void invokeDirect(Director director)&#123;
        director.makeMovie();
    &#125;
&#125;
</code></pre>
<h3 id="练习：Lambda-有参有返回"><a href="#练习：Lambda-有参有返回" class="headerlink" title="练习：Lambda(有参有返回)"></a>练习：Lambda(有参有返回)</h3><p>给定一个计算器 Calculator 接口，内含抽象方法 calc (减法)，其功能是可以将两个数字进行相减，并返回差值。使用Lambda表达式在Test中完成调用</p>
<pre><code class="java">interface Calculator&#123;
    int calc(int a, int b);
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß
        invokeCalc(130, 120, (int a, int b) -&gt; &#123;
            return a - b;
        &#125;); //标准格式
        invokeCalc(130,120,(a,b)-&gt; a-b); //省略模式
    &#125;
    private static void invokeCalc(int a, int b, Calculator calculator)&#123;
        int result = calculator.calc(a,b);
        System.out.println(&quot;结果是：&quot; + result);
    &#125;
&#125;
</code></pre>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><h3 id="练习一：Pedicate接口使用"><a href="#练习一：Pedicate接口使用" class="headerlink" title="练习一：Pedicate接口使用"></a>练习一：Pedicate接口使用</h3><p>请在测试类main方法中完成以下需求</p>
<p>已知有Integer[] arr &#x3D; {-12345, 9999, 520, 0,-38,-7758520,941213}</p>
<p>a)     使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数(大于等于0)</p>
<p>b)    使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100</p>
<p>c)     使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数</p>
<p>遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求</p>
<p>​             i.       打印自然数的个数</p>
<p>​            ii.       打印负整数的个数</p>
<p>​           iii.       打印绝对值大于100的偶数的个数</p>
<p>​           iv.       打印是负整数或偶数的数的个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
        Integer[] arr = &#123;-12345, 9999, 520, 0,-38,-7758520,941213&#125;;

        //a)   使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数
        Predicate&lt;Integer&gt; p1 = (s) -&gt; s&gt;=0;
        //b)   使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100
        Predicate&lt;Integer&gt; p2 = (s) -&gt; Math.abs(s)&gt;100;
        //c)   使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数
        Predicate&lt;Integer&gt; p3 = (s) -&gt; s%2==0;

        //e)   遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        int count4 = 0;
        for (Integer i : arr) &#123;
            //统计自然数个数
            if (p1.test(i))&#123;
                count1++;
            &#125;
            //统计负整数个数
            if (p1.negate().test(i))&#123;
                count2++;
            &#125;
            //统计绝对值大于100的偶数个数
            if (p2.and(p3).test(i))&#123;
                count3++;
            &#125;
            //统计是负整数或偶数的数的个数
            if (p1.negate().or(p3).test(i))&#123;
                count4++;
            &#125;
        &#125;
        //分别打印结果
        System.out.println(&quot;自然数的个数为：&quot;+count1);
        System.out.println(&quot;负整数的个数为：&quot;+count2);
        System.out.println(&quot;绝对值大于100的偶数的个数为：&quot;+count3);
        System.out.println(&quot;是负整数或偶数的数的个数为：&quot;+count4);
    &#125;
</code></pre>
<h3 id="练习：Function接口使用"><a href="#练习：Function接口使用" class="headerlink" title="练习：Function接口使用"></a>练习：Function接口使用</h3><p><code>[这是一个功能界面，因此可以用Lambda表达式或方法引用的赋值对象]</code></p>
<blockquote>
<p>Interface Function&lt;T,R&gt;<br>T：函数输入的类型<br>R：函数结果的类型</p>
<p>Interface Map&lt;K,V&gt;<br>K：由此地图维护的键的类型<br>V：映射值的类型</p>
</blockquote>
<p>1.使用lambda表达式分别将以下功能封装到Function对象中</p>
<p>a)    求Integer类型ArrayList中所有元素的平均数</p>
<p>b)    将Map &lt; String,Integer &gt; 中value存到ArrayList &lt; Integer &gt;中</p>
<p>2.已知学生成绩如下</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>岑小村</td>
<td>59</td>
</tr>
<tr>
<td>谷天洛</td>
<td>82</td>
</tr>
<tr>
<td>渣渣辉</td>
<td>98</td>
</tr>
<tr>
<td>蓝小月</td>
<td>65</td>
</tr>
<tr>
<td>皮几万</td>
<td>70</td>
</tr>
</tbody></table>
<p>3.以学生姓名为key成绩为value创建集合并存储数据，使用刚刚创建的Function对象求学生的平均成绩</p>
<pre><code class="java">    public static void main(String[] args) &#123;
        //1.   使用lambda表达式分别将以下功能封装到Function对象中
        //a)   求Integer类型ArrayList中所有元素的平均数
        Function&lt;ArrayList&lt;Integer&gt;,Integer&gt; f1 = (list)-&gt;&#123;
            Integer sum = 0;
            for (Integer i : list) &#123;
                sum+=i;
            &#125;
            return sum/list.size();
        &#125;;

        //b)   将Map&lt;String,Integer&gt;中value存到ArrayList&lt;Integer&gt;中
        Function&lt;Map&lt;String,Integer&gt;,ArrayList&lt;Integer&gt;&gt; f2 = (map)-&gt;&#123;
            /*ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (String s : map.keySet()) &#123;
                Integer i = map.get(s);
                list.add(i);
            &#125;*/
            Collection&lt;Integer&gt; values = map.values();
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            list.addAll(values);
            return list;
        &#125;;
        //2 将学生姓名和成绩封装到map中
        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        map.put(&quot;岑小村&quot;, 59);
        map.put(&quot;谷天洛&quot;, 82);
        map.put(&quot;渣渣辉&quot;, 98);
        map.put(&quot;蓝小月&quot;, 65);
        map.put(&quot;皮几万&quot;, 70);

        //利用Function求平均成绩
        Integer avg = f2.andThen(f1).apply(map);
        System.out.println(&quot;学生平均成绩为：&quot;+avg);
    &#125;
</code></pre>
<h3 id="练习：获取流"><a href="#练习：获取流" class="headerlink" title="练习：获取流"></a>练习：获取流</h3><p>简述单列集合、双列集合、数组分别如何获取Stream流对象，并进行演示</p>
<pre><code class="java">1.java.util.Collection接口中加入了default方法 stream()获取流对象，因此其所有实现类均可通过此方式获取流

2.java.util.Map接口想要获取流，先通过KeySet()、values()或entrySet()方法获取键、值或键值对的单列集合，再通过stream()获取流对象

3.数组获取流，使用Stream接口中的静态方法of(T...values)获取流
public static void main(String[] args) &#123;
  List&lt;String&gt; list = new ArrayList&lt;&gt;();
  Stream&lt;String&gt; stream1 = list.stream();
  Set&lt;String&gt; set = new HashSet&lt;&gt;();
  Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

  Stream&lt;String&gt; stream2 = set.stream();
  Stream&lt;String&gt; keyStream = map.keySet().stream();
  Stream&lt;String&gt; valueStream = map.values().stream();
  Stream&lt;Map.Entry&lt;String,String&gt;&gt;entryStream = map.entrySet().stream();

  String[] array = &#123;&quot;东邪&quot;, &quot;西毒&quot;, &quot;南帝&quot;, &quot;北丐&quot;, &quot;中神通&quot;&#125;;
  Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<h3 id="练习：过滤-filter-、结果收集-数组"><a href="#练习：过滤-filter-、结果收集-数组" class="headerlink" title="练习：过滤[filter]、结果收集(数组)"></a>练习：过滤[filter]、结果收集(数组)</h3><p>有如下7个元素黄药师，冯蘅，郭靖，黄蓉，郭芙，郭襄，郭破虏，使用Stream将以郭字开头的元素存入新数组</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; stream = Stream.of(&quot;黄药师&quot;, &quot;冯蘅&quot;, &quot;郭靖&quot;, &quot;黄蓉&quot;, &quot;郭芙&quot;, &quot;郭襄&quot;, &quot;郭破虏&quot;);
        String[] guos = stream.filter(s -&gt; s.startsWith(&quot;郭&quot;)).toArray(String[]::new);
     &#125;
&#125;
// filter 返回由与此给定谓词匹配的此流的元素组成的流。
// toArray 返回一个包含此流的元素的数组 结果: 一个包含此流的元素的数组
</code></pre>
<h3 id="练习：n-取用前几个-limit-、跳过前几个-skip"><a href="#练习：n-取用前几个-limit-、跳过前几个-skip" class="headerlink" title="练习：n 取用前几个[limit]、跳过前几个[skip]"></a>练习：n 取用前几个[limit]、跳过前几个[skip]</h3><p>已知ArrayList集合中有如下元素{陈玄风、梅超风、陆乘风、曲灵风、武眠风、冯默风、罗玉风}，使用Stream<br>1,取出前2个元素并在控制台打印输出。<br>2.取出后2个元素并在控制台打印输出。</p>
<pre><code class="java">import java.util.ArrayList;
    public class Test04 &#123;
      public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;陈玄风&quot;);
        list.add(&quot;梅超风&quot;);
        list.add(&quot;陆乘风&quot;);
        list.add(&quot;曲灵风&quot;);
        list.add(&quot;武眠风&quot;);
        list.add(&quot;冯默风&quot;);
        list.add(&quot;罗玉风&quot;);

        list.stream().limit(2).forEach(System.out::println);
        list.stream().skip(list.size() - 2).forEach(System.out::println);
    &#125;
&#125;
</code></pre>
<h3 id="练习：n-映射-map-、逐一消费-forEach"><a href="#练习：n-映射-map-、逐一消费-forEach" class="headerlink" title="练习：n 映射[map]、逐一消费[forEach]"></a>练习：n 映射[map]、逐一消费[forEach]</h3><p>有如下整数1，-2，-3，4，-5<br>使用Stream取元素绝对值并打印</p>
<pre><code class="java">import java.util.stream.Stream;
   public class Test &#123;
      public static void main(String[] args) &#123;
          Stream&lt;Integer&gt; stream = Stream.of(1, -2, -3, 4,-5);
        stream.map(Math::abs).forEach(System.out::println);
     &#125;
&#125;
</code></pre>
<h3 id="练习：组合-concat-、结果收集-list"><a href="#练习：组合-concat-、结果收集-list" class="headerlink" title="练习：组合[concat]、结果收集[list]"></a>练习：组合[concat]、结果收集[list]</h3><p>已知数组arr1中有如下元素{郭靖，杨康}，arr2中有如下元素{黄蓉，穆念慈}，使用Stream将二者合并到List集合</p>
<pre><code class="java">import java.util.stream.Stream;
  public class Test &#123;
    public static void main(String[] args) &#123;
          Stream&lt;String&gt; streamA = Stream.of(&quot;郭靖&quot;, &quot;杨康&quot;);
        Stream&lt;String&gt; streamB = Stream.of(&quot;黄蓉&quot;, &quot;穆念慈&quot;);
        List&lt;String&gt; strList = Stream.concat(streamA, streamB).collect(Collectors.toList());
     &#125;
&#125;
</code></pre>
<h3 id="练习：获取并发流"><a href="#练习：获取并发流" class="headerlink" title="练习：获取并发流"></a>练习：获取并发流</h3><p>请分别写出获取并发流的两种方式。</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
          Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();
          Stream&lt;String&gt; parallelStream1 = coll.parallelStream();
        Stream&lt;Integer&gt; parallelStream2 = Stream.of(100, 200, 300, 400).parallel();
     &#125;
&#125;
</code></pre>
<h1 id="函数式接口习题"><a href="#函数式接口习题" class="headerlink" title="函数式接口习题"></a>函数式接口习题</h1><h3 id="练习：函数式接口"><a href="#练习：函数式接口" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①.  定义一个函数式接口CurrentTimePrinter,其中抽象方法void printCurrentTime()，使用注解@FunctionalInterface<br>②. 在测试类中定义static void showLongTime(CurrentTimePrinter timePrinter)，该方法的预期行为是使用timePrinter打印系统当前毫秒值<br>③. 测试showLongTime(),通过lambda表达式完成需求</p>
<pre><code class="java">@FunctionalInterface
public interface CurrentTimePrinter
&#123;
    void printCurrenTime();
&#125;

public class Test01 &#123;
    public static void main(String[] args) &#123;
        showLongTime(()-&gt;System.out.println(System.currentTimeMillis()));
    &#125;

    public static void showLongTime(CurrentTimePrinter timePrinter)&#123;
        timePrinter.printCurrentTime();
    &#125;
&#125;
</code></pre>
<h3 id="练习：函数式接口-1"><a href="#练习：函数式接口-1" class="headerlink" title="练习：函数式接口"></a>练习：函数式接口</h3><p>①. 定义一个函数式接口IntCalc,其中抽象方法int calc(int a , int b)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void getProduct(int a , int b ,IntCalc calc), 该方法的预期行为是使用calc得到a和b的乘积并打印结果<br>③. 测试getProduct(),通过lambda表达式完成需求</p>
<p>IntCalc接口：</p>
<pre><code class="java">@FunctionalInterface
 public interface IntCalc &#123;
   int calc(int a, int b);
 &#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">public class Test02 &#123;
   public static void main(String[] args) &#123;
     getProduct(2,3,(a,b)-&gt;a*b);
   &#125;
   public static void getProduct(int a, int b, IntCalc intCalc)&#123;
     int product = intCalc.calc(a,b);
     System.out.println(product);

   &#125;
&#125;
</code></pre>
<h3 id="练习：静态方法引用"><a href="#练习：静态方法引用" class="headerlink" title="练习：静态方法引用"></a>练习：静态方法引用</h3><p>①. 定义一个函数式接口NumberToString,其中抽象方法String convert(int num)，使用注解@FunctionalInterface<br>②. 在测试类中定义static void decToHex(int num ,NumberToString nts), 该方法的预期行为是使用nts将一个十进制整数转换成十六进制表示的字符串，**<u>tips：已知该行为与Integer类中的toHexString方法一致</u>**<br>③. 测试decToHex (),使用方法引用完成需求</p>
<pre><code class="java">interface NumberToString&#123;
    String convert(int num);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        decToHex(999, Integer::toHexString);
    &#125;

    public static void decToHex(int num ,NumberToString nts)&#123;
        String convert = nts.convert(num);
        System.out.println(convert);
    &#125;

&#125;
</code></pre>
<h1 id="字节流-amp-字符流-amp-Properties集合习题"><a href="#字节流-amp-字符流-amp-Properties集合习题" class="headerlink" title="字节流&amp;字符流&amp;Properties集合习题"></a>字节流&amp;字符流&amp;Properties集合习题</h1><h3 id="练习：字节输出流写出字节数据"><a href="#练习：字节输出流写出字节数据" class="headerlink" title="练习：字节输出流写出字节数据"></a>练习：字节输出流写出字节数据</h3><p>利用字节输出流一次写一个字节的方式，向D盘的a.txt文件输出字符‘a’</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流FileOutputStream对象并指定文件路径。<br>2.调用字节输出流的write(int byte)方法写出数据</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.txt&quot;);
        // 2.调用字节输出流的write(byte[] buf)方法写出数据。
        byte[] buf = &quot;i love java&quot;.getBytes();
        // 2.调用字节输出流的write(int byte)方法写出数据
        fos.write(97);
        // 3.关闭流
        fos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：文件的续写和换行输出"><a href="#练习：文件的续写和换行输出" class="headerlink" title="练习：文件的续写和换行输出"></a>练习：文件的续写和换行输出</h3><p>在D盘下，有一c.txt 文件中内容为：HelloWorld<br>在c.txt文件原内容基础上，添加五句 I love java，而且要实现一句一行操作(注：原文不可覆盖)。利用字节输出流对象往C盘下c.txt文件输出5句：”i love java”</p>
<p><strong>操作步骤</strong>:</p>
<p>1.利用两个参数的构造方法创建字节输出流对象，参数一指定文件路径，参数二指定为true<br>2.调用字节输出流的write()方法写入数据，在每一行后面加上换行符:”\r\n”</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 1.创建字节输出流FileOutputStream对象并指定文件路径,并追加方式
        FileOutputStream fos = new FileOutputStream(&quot;c:/c.txt&quot;,true);
        // 2.调用字节输出流的write方法写出数据
        // 2.1 要输出的字符串
        String content = &quot;i love java \r\n&quot;;
        for (int i = 0; i&lt; 5; i++) &#123;
            fos.write(content.getBytes());
        &#125;
        // 3.关闭流
        fos.close();
    &#125;
&#125;
/*
    定义变量接收读取的字节
        int len = -1;
        // 循环从流中读取数据
        while((len = fis.read()) != -1) &#123;
        System.out.print(new String(buffer,0,len));
&#125;

*/
</code></pre>
<h3 id="练习：字节流复制文件"><a href="#练习：字节流复制文件" class="headerlink" title="练习：字节流复制文件"></a>练习：字节流复制文件</h3><h6 id="描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致"><a href="#描述-利用字节流将E盘下的a-png图片复制到D盘下-文件名保存一致" class="headerlink" title="描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)"></a>描述: 利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致)</h6><p>要求：一次读写一个字节的方式</p>
<p><strong>操作步骤</strong>:</p>
<p>1.创建字节输入流对象关联文件路径：E盘下的a.png<br>2.创建字节输出流对象关联文件路径：D盘下的a.png<br>3.使用循环不断从字节输入流读取一个字节，每读取一个字节就利用输出流写出一个字节。<br>4.关闭流，释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;e:/a.png&quot;);
        // 创建字节输出流对象并关联文件
        FileOutputStream fos = new FileOutputStream(&quot;d:/a.png&quot;);
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = fis.read()) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            fos.write(len);
        &#125;
        // 关闭流
        fis.close();
        fos.close();
    &#125;
</code></pre>
<h3 id="练习：IO对象Properties结合使用-设置properties文件"><a href="#练习：IO对象Properties结合使用-设置properties文件" class="headerlink" title="练习：IO对象Properties结合使用,设置properties文件"></a>练习：IO对象Properties结合使用,设置properties文件</h3><p>我有一个文本文件score.txt，我知道数据是键值对形式的，但是不知道内容是什么。<br>请写一个程序判断是否有”lisi”这样的键存在，如果有就改变其实为”100”<br>score.txt文件内容如下：<br>zhangsan &#x3D; 90    lisi &#x3D; 80    wangwu &#x3D; 85<br><strong>操作步骤</strong>:<br>1.创建一个空的Properties集合<br>2.读取数据到集合中<br>3.遍历集合，获取到每一个key<br>4.判断当前的key 是否为 “lisi”，如果是就把”lisi”的值设置为100<br>5.把集合中所有的信息，重新存储到文件中</p>
<table>
<thead>
<tr>
<th>void</th>
<th>store(OutputStream out, String comments)<br />此适合使用load(InputStream)方法加载到Properties表中的格式，将此Propeirties表中的属性列表(键和元素对写入输出流)</th>
</tr>
</thead>
</table>
<pre><code class="java">public class Test02_06 &#123;
    public static void main(String[] args) throws IOException &#123;
//1：创建一个空的集合
        Properties prop = new Properties();
//2:读取数据到集合中
        prop.load(new FileInputStream(&quot;score.txt&quot;));
//3:遍历集合，获取到每一个key
        Set&lt;String&gt; keys = prop.stringPropertyNames();
//获取到每一个key
        for (String key : keys) &#123;
//4:判断当前的key 是否为 &quot;lisi&quot;
            if (&quot;lisi&quot;.equals(key)) &#123;
//把&quot;lisi&quot;的值设置为100
                prop.setProperty(key, &quot;100&quot;);
            &#125;
        &#125;
//把集合中所有的信息，重新存储到文件中
        prop.store(new FileOutputStream(&quot;score.txt&quot;), &quot;haha&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="缓冲流-amp-转换流习题"><a href="#缓冲流-amp-转换流习题" class="headerlink" title="缓冲流&amp;转换流习题"></a>缓冲流&amp;转换流习题</h1><h3 id="练习：高效字节输出流写出字节数据"><a href="#练习：高效字节输出流写出字节数据" class="headerlink" title="练习：高效字节输出流写出字节数据"></a>练习：高效字节输出流写出字节数据</h3><h6 id="描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。"><a href="#描述-利用高效字节输出流往C盘下的d-txt文件输出一个字节数。" class="headerlink" title="描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。"></a>描述: 利用高效字节输出流往C盘下的d.txt文件输出一个字节数。</h6><p><strong>操作步骤</strong>:</p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.调用高效字节输出流对象的write方法写出一个字节<br>4.关闭高效流，释放资源。</p>
<pre><code class="java">public class Test01_01 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\d.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(int byte)方法写出一个字节数据
        bos.write(97);
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字节输出流写出字节数组数据"><a href="#练习：高效字节输出流写出字节数组数据" class="headerlink" title="练习：高效字节输出流写出字节数组数据"></a>练习：高效字节输出流写出字节数组数据</h3><h6 id="描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”"><a href="#描述-利用高效字节输出流往C盘下的e-txt文件写出一个字节数组数据，如写出：”i-love-java”" class="headerlink" title="描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”"></a>描述: 利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java”</h6><p><strong>操作步骤:</strong></p>
<p>1.创建字节输出流对象关联文件路径<br>2.利用字节输出流对象创建高效字节输出流对象<br>3.定义字符串存放要输出的数据，然后将字符串转换为字节数组。<br>4.调用高效字节输出流对象的write方法将字节数组输出。<br>5.关闭高效流。</p>
<pre><code class="java">public class Test01_02 &#123;
    public static void main(String[] args) throws IOException &#123;
        // 创建字节输出流FileOutputStream对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;c:\\e.txt&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 调用高效字节输出流对象的write(byte[] buff)方法写出一个字节数据
        bos.write(&quot;i love java&quot;.getBytes());
        // 关闭流
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效流文件复制"><a href="#练习：高效流文件复制" class="headerlink" title="练习：高效流文件复制"></a>练习：高效流文件复制</h3><h6 id="描述-利用高效字节输入流和高效字节输出流完成文件的复制。"><a href="#描述-利用高效字节输入流和高效字节输出流完成文件的复制。" class="headerlink" title="描述: 利用高效字节输入流和高效字节输出流完成文件的复制。"></a>描述: 利用高效字节输入流和高效字节输出流完成文件的复制。</h6><p>要求：</p>
<p>1.将C盘下的c.png文件复制到D盘下<br>2.一次读写一个字节数组方式复制</p>
<p>操作步骤:</p>
<p>①.创建字节输入流对象并关联文件路径<br>②.利用字节输入流对象创建高效字节输入流对象<br>③.创建字节输出流对象并关联文件路径<br>④.利用字节输出流对象创建高效字节输出流对象<br>⑤.创建字节数组用来存放读取的字节数<br>⑥.利用高效字节输入流循环读取文件数据，每读取一个字节数组，利用高效字节输出流对象将字节数组的内容输出到目标文件中。直到读取到文件末尾。<br>⑦.关闭高效流对象</p>
<pre><code class="java">public class Test01_03 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件路径
        FileInputStream fis = new FileInputStream(&quot;c:\\c.png&quot;);
        // 利用字节输出流对象创建高效字节输出流对象
        BufferedInputStream bis = new BufferedInputStream(fis);
        // 创建字节输出流对象并指定文件路径。
        FileOutputStream fos = new FileOutputStream(&quot;d:\\c.png&quot;);
        // 利用字节输出流创建高效字节输出流对象
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        // 定义字节数组接收读取的字节
        byte[] buffer = new byte[1024];
        // 定义变量接收读取的字节数
        int len = -1;
        // 循环读取图片数据
        while((len = bis.read(buffer)) != -1) &#123;
            // 每读取一个字节的数据就写出到目标文件中
            bos.write(buffer,0,len);
        &#125;
        // 关闭流
        bis.close();
        bos.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：高效字符流和集合的综合使用"><a href="#练习：高效字符流和集合的综合使用" class="headerlink" title="练习：高效字符流和集合的综合使用"></a>练习：高效字符流和集合的综合使用</h3><p>描述:</p>
<p>分析以下需求，并用代码实现<br>实现一个验证码小程序，要求如下：<br>① 在项目根目录下新建一个文件：data.txt,键盘录入3个字符串验证码，并存入data.txt中，要求一个验证码占一行；<br>② 键盘录入一个需要被校验的验证码，如果输入的验证码在data.txt中存在：在控制台提示验证成功，如果不存在控制台提示验证失败</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws IOException &#123;
        writeString2File();
        verifyCode();
    &#125;

    private static void writeString2File() throws IOException &#123;
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i &lt; 3; i++) &#123;
            System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个字符串验证码&quot;);
            line = sc.nextLine();
            bw.write(line);
            bw.newLine();
        &#125;
        bw.close();
    &#125;

    private static void verifyCode() throws IOException &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        BufferedReader br = new BufferedReader(new FileReader(new File(&quot;D:\\Clash\\a.txt&quot;)));
        String line = null;
        while(null!=(line = br.readLine()))&#123;
        list.add(line);
    &#125;
        br.close();
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入一个验证码&quot;);
        String code = sc.nextLine();
        if (list.contains(code))&#123;
            System.out.println(&quot;验证成功&quot;);
        &#125;else &#123;
            System.out.println(&quot;验证失败&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输出流的使用"><a href="#练习：转换输出流的使用" class="headerlink" title="练习：转换输出流的使用"></a>练习：转换输出流的使用</h3><h6 id="描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。"><a href="#描述-现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a-txt文件中。" class="headerlink" title="描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。"></a>描述: 现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。</h6><p>要求：使用gbk编码保存。<br>注意：idea的默认编码是utf-8,所以可以通过fileàsettingsàfile encodings设置为gbk格式，否则打开a.txt文件看到的将会是乱码。</p>
<p>操作步骤:</p>
<p>1.创建文件字节输出流关联目标文件<br>2.根据文件字节输出流创建转换输出流对象，并指定编码字符集为：gbk<br>3.调用流对象的方法将字符串写出到文件中。<br>4.关闭流并释放资源。</p>
<pre><code class="java">public class Test01_05 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 要保存的字符串
        String content = &quot;我爱Java&quot;;
        // 创建字节输出流对象
        FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;);
        // 创建转换输出流对象
        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;gbk&quot;);
        // 调用方法写出数据
        osw.write(content);
        // 关闭流释放资源
        osw.close();
    &#125;
&#125;
</code></pre>
<h3 id="练习：转换输入流的使用"><a href="#练习：转换输入流的使用" class="headerlink" title="练习：转换输入流的使用"></a>练习：转换输入流的使用</h3><h6 id="描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。"><a href="#描述-利用转换输入流将当前项目根目录下使用gbk编码的a-txt文件的内容读取出来，并打印在控制台上。" class="headerlink" title="描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。"></a>描述: 利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。</h6><p>要求：不能出现乱码的情况。<br>操作步骤:</p>
<p>1.创建字节输入流对象指定文件路径。<br>2.根据字节输入流对象创建转换输入流对象并指定字符集编码为：gbk<br>3.调用转换输入流对象的读取方法读取内容<br>4.关闭流释放资源</p>
<pre><code class="java">public class Test01_06 &#123;
    public static void main(String[] args) throws IOException&#123;
        // 创建字节输入流对象并关联文件
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        // 创建转换输入流对象
        InputStreamReader isr = new InputStreamReader(fis,&quot;gbk&quot;);
        // 定义字符数组存放读取的内容
        char[] buffer = newchar[1024];
        // 定义变量接收读取的字符个数
        intlen = -1;
        while((len = isr.read(buffer)) != -1) &#123;
            System.out.print(new String(buffer,0,len));
        &#125;
        // 关闭流
        isr.close();
    &#125;
&#125;
</code></pre>
<h1 id="继承-amp-抽象类习题"><a href="#继承-amp-抽象类习题" class="headerlink" title="继承&amp;抽象类习题"></a>继承&amp;抽象类习题</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h5 id="什么叫做类与类的继承，作用是什么？"><a href="#什么叫做类与类的继承，作用是什么？" class="headerlink" title="什么叫做类与类的继承，作用是什么？"></a><span style =  "color :red">什么叫做类与类的继承，作用是什么？</span></h5><p>就是子类继承父类的属性和行为，使得子类对象具有与父亲相同的属性、相同的行为；<br>作用是子类复用父类的内容</p>
<h5 id="继承后，父类与子类之间，各成员有什么样的影响？"><a href="#继承后，父类与子类之间，各成员有什么样的影响？" class="headerlink" title="继承后，父类与子类之间，各成员有什么样的影响？"></a><span style =  "color :red">继承后，父类与子类之间，各成员有什么样的影响？</span></h5><p>成员变量：<br><u>不重名</u>，就没有影响；<u>重名</u>，就近使用，使用super分区父类变量</p>
<p>构造方法：<br><u>无影响</u>，但是子类构造方法默认调用父类构造方法</p>
<p>成员方法：<br>不重名，没有影响；重名，子类重写父类方法</p>
<h5 id="子类中，如何调用父类的成员？如何使用本类的成员？"><a href="#子类中，如何调用父类的成员？如何使用本类的成员？" class="headerlink" title="子类中，如何调用父类的成员？如何使用本类的成员？"></a><span style =  "color :red">子类中，如何调用父类的成员？如何使用本类的成员？</span></h5><p>父类成员方法：super.方法名<br>父类非私有成员变量：super.变量名<br>子类成员方法：this.方法名<br>子类成员变量：this.变量名</p>
<h5 id="抽象方法与普通成员方法有什么区别？"><a href="#抽象方法与普通成员方法有什么区别？" class="headerlink" title="抽象方法与普通成员方法有什么区别？"></a><span style =  "color :red">抽象方法与普通成员方法有什么区别？</span></h5><p>抽象方法使用abstract关键字修饰，没有方法体；成员方法有方法体</p>
<h5 id="抽象类与普通类有什么区别？"><a href="#抽象类与普通类有什么区别？" class="headerlink" title="抽象类与普通类有什么区别？"></a><span style =  "color :red">抽象类与普通类有什么区别？</span></h5><p>方法：<br>抽象类可以包含抽象方法和成员方法；普通类不可以包含抽象方法，只有成员方法</p>
<p>对象：<br>抽象类不可以创建对象；普通类可以创建对象</p>
<h3 id="练习：语法练习"><a href="#练习：语法练习" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承，抽象类</p>
</li>
<li><p>输出<code>A类中numa：10、B类中numb：20、C类中numc：30</code></p>
</li>
</ul>
<pre><code class="java">abstract  class A&#123;
    int numa = 10;
    public abstract void showA();
&#125;

abstract class B extends A&#123;
    int numb = 20;
    public abstract void showB();
&#125;

class C extends B&#123;
    int numc = 30;

    @Override
    public void showA() &#123;
        System.out.println(&quot;A类中numa:&quot;+numa);
    &#125;

    @Override
    public void showB() &#123;
        System.out.println(&quot;B类中numb:&quot;+numb);

    &#125;
    public void showC()&#123;
        System.out.println(&quot;C类中numc:&quot;+numc);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        C c = new C();
        c.showA();
        c.showB();
        c.showC();
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-1"><a href="#练习：语法练习-1" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li>语法点：继承，抽象类</li>
<li>输出<code>动物种类:鸭子，年龄：2岁、 入院原因：感冒、 症状为：发烧</code></li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟农学院动物医疗系统信息。</li>
<li>定义抽象家禽类(Poultry)<ol>
<li>私有成员变量：动物种类(name)，症状(symptom)，年龄(age)， 病因（illness）</li>
<li>提供空参和带参构造方法</li>
<li>成员方法：<ol>
<li>抽象方法症状(showSymptom)</li>
<li>普通方法基本信息(showMsg)</li>
<li>提供setXxx和getXxx方法</li>
</ol>
</li>
</ol>
</li>
<li>定义普通鸭子类(Duck)<ol>
<li>提供空参和带参构造方法</li>
<li>重写showSymptom方法，打印症状信息。</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test3 &#123;
    public static void main(String[] args) &#123;
        Duck duck = new Duck(&quot;鸭子&quot;, &quot;感冒&quot;, &quot;发烧&quot;, 2);
        duck.showMsg();
        duck.showSymptom();
    &#125;
&#125;

/*
1.定义抽象家禽类(Poultry)
*/
abstract class Poultry &#123;
    //    i.成员变量(私有):

    private String name;
    private String illness;

    // 症状(symptom)
    private String symptom;
    //    年龄(age)
    private int age;

    //    ii.成员方法:  showSymptom
    public abstract void showSymptom();

    // 成员方法:  showMsg
    public void showMsg() &#123;
        System.out.print(&quot;动物种类:&quot; + name);
        System.out.println(&quot;,年龄:&quot; + age + &quot;岁&quot;);
        System.out.println(&quot;入院原因:&quot; + illness);
    &#125;

    //    iii.提供空参和带参构造方法
    public Poultry() &#123;
        super();
    &#125;

    public Poultry(String name, String illness, String symptom, int age) &#123;
        this.name = name;
        this.illness = illness;
        this.symptom = symptom;
        this.age = age;
    &#125;

    //    iv.提供setXxx和getXxx方法
    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getIllness() &#123;
        return illness;
    &#125;

    public void setIllness(String illness) &#123;
        this.illness = illness;
    &#125;

    public String getSymptom() &#123;
        return symptom;
    &#125;

    public void setSymptom(String symptom) &#123;
        this.symptom = symptom;
    &#125;
&#125;

// Duck 类

class Duck extends Poultry &#123;

    public Duck() &#123;

    &#125;

    public Duck(String name, String illness, String symptom, int age) &#123;

        super(name, illness, symptom, age);

    &#125;

    @Override

    public void showSymptom() &#123;

        System.out.println(&quot;症状为:&quot; + getSymptom());

    &#125;

&#125;
</code></pre>
<h3 id="练习：语法练习-2"><a href="#练习：语法练习-2" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>输出：<code>王小平老师，讲授Java课、 李小乐同学，考试得了90分</code></p>
</li>
</ul>
<p>编写步骤：</p>
<ol>
<li>模拟教学管理系统师生信息。</li>
<li>定义Person类。<ol>
<li>属性：姓名、年龄</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，显示基本信息showMsg方法</li>
</ol>
</li>
<li>定义Teacher类，继承Person<ol>
<li>属性：学科</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，讲课方法</li>
</ol>
</li>
<li>定义Student类，继承Person<ol>
<li>属性：分数</li>
<li>构造方法：无参构造方法，有参构造方法</li>
<li>成员方法：getXxx方法，setXxx方法，考试方法</li>
</ol>
</li>
</ol>
<pre><code class="java">public class Test &#123;

    public static void main(String[] args) &#123;
        //        i.创建老师对象t,并把名称赋值为”王小平”,年龄赋值为30,工资赋值为8000
        Teacher t = new Teacher(&quot;王小平&quot;, 30, &quot;Java&quot;);
        //        iii.调用老师对象t的讲解方法
        t.teach();

        //        iv.创建学生对象 s,并把名称赋值为”李小乐”,年龄赋值为14,成绩赋值为90分.
        Student s = new Student(&quot;李小乐&quot;, 14, 90);
        //        vi.调用学生对象 s 的考试方法
        s.exam();
    &#125;
&#125;

class Person &#123;
    // 名称(name)
    private String name;
    //    年龄(age)
    private int age;

    //    空参构造
    public Person() &#123;
    &#125;
    //  带参构造
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    // setXxx和getXxx方法
    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
/*
 2.定义老师类(Teacher),继承Person类
 */
class Teacher extends Person &#123;
    //    course(科目)
    private String course;
    //    空参构造
    public Teacher() &#123;
    &#125;
    //    带参构造方法
    public Teacher(String name,int age, String course) &#123;
        super(name,age);
        this.course = course;
    &#125;

    //    提供setXxx和getXxx方法
    public String getCourse() &#123;
        return course;
    &#125;
    public void setCourse(String course) &#123;
        this.course = course;
    &#125;

    public void teach() &#123;
        System.out.println(getName() +&quot;老师,讲授&quot;+course +&quot;课&quot;);
    &#125;
&#125;
/*
 3.定义学生类(Student),继承Person类
 */
class Student extends Person &#123;
    //    score(成绩)
    private int score;
    //    无参构造
    public Student() &#123;
        super();
    &#125;
    //    带参构造
    public Student(String name, int age,int score) &#123;
        super(name, age);
        this.score = score;
    &#125;

    //    提供setXxx和getXxx方法
    public int getScore() &#123;
        return score;
    &#125;
    public void setScore(int score) &#123;
        this.score = score;
    &#125;

    public void exam()&#123;
        System.out.println(getName()+&quot;同学,考试得了:&quot;+ score +&quot;分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="练习：语法练习-3"><a href="#练习：语法练习-3" class="headerlink" title="练习：语法练习"></a>练习：语法练习</h3><ul>
<li><p>语法点：继承</p>
</li>
<li><p>编写步骤</p>
<ol>
<li>模拟汽车网站信息。</li>
<li>定义汽车Auto类<ol>
<li>属性：品牌，车长，价格</li>
</ol>
</li>
<li>定义SUV继承Auto类<ol>
<li>属性：小型车车长标准值：4295，中型车车长标准值：5070。</li>
<li>定义判断车型方法<ol>
<li>判断小型车：小于小型车车长标准值</li>
<li>判断大型车：大于中型车车长标准值</li>
<li>判断中型车：大于小型车车长标准值并且小于等于中型车车长标准值</li>
</ol>
</li>
</ol>
</li>
<li>测试类中，创建若干SUV对象，保存到集合，遍历集合，输出中型SUV。</li>
</ol>
</li>
</ul>
<pre><code class="java">public class Test5 &#123;
    public static void main(String[] args) &#123;
        // 创建SUV对象
        SUV suv1 = new SUV(5079, 750000);
        SUV suv2 = new SUV(4813, 760000);
        SUV suv3 = new SUV(4270, 127800);
        SUV suv4 = new SUV(4545, 188800);

        //添加到集合中
        ArrayList&lt;SUV&gt; list = new ArrayList&lt;&gt;();
        list.add(suv1);
        list.add(suv2);
        list.add(suv3);
        list.add(suv4);

        // 遍历集合,查询中型SUV
        for (int i = 0; i &lt; list.size(); i++) &#123;
            SUV suv = list.get(i);
            if (suv.midSUV())&#123;
                suv.showMsg();
            &#125;
        &#125;
    &#125;
&#125;
// 定义汽车类
class Auto &#123;
    private String type;
    private double length;
    private double price;

    public Auto() &#123;
    &#125;

    public Auto(String type, double length, double price) &#123;
        this.type = type;
        this.length = length;
        this.price = price;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    public double getLength() &#123;
        return length;
    &#125;

    public void setLength(double length) &#123;
        this.length = length;
    &#125;

    public double getPrice() &#123;
        return price;
    &#125;

    public void setPrice(double price) &#123;
        this.price = price;
    &#125;

    public void showMsg() &#123;
        System.out.println(&quot;车型:&quot; + type);
        System.out.println(&quot;\t价格:&quot; + price);
        System.out.println(&quot;\t车长:&quot; + length);

    &#125;

&#125;

// 定义SUV类
class SUV extends Auto &#123;
    // 车长标准
    private int miniLength = 4295;
    private int midLength = 5070;

    public SUV(double length, double price) &#123;
        super(&quot;SUV&quot;, length, price);
    &#125;
    // 判断 小型车
    public boolean miniSUV() &#123;
        return getLength() &lt;= miniLength;
    &#125;

    // 判断 大型车
    public boolean largeSUV() &#123;
        return getLength() &gt; midLength;
    &#125;

    // 判断 中型车
    public boolean midSUV() &#123;
        return getLength() &gt; miniLength &amp;&amp; getLength() &lt;= midLength;
    &#125;
&#125;
</code></pre>
<h1 id="接口-amp-多态"><a href="#接口-amp-多态" class="headerlink" title="接口&amp;多态"></a>接口&amp;多态</h1><h3 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h3><h5 id="什么是接口，如何定义接口？"><a href="#什么是接口，如何定义接口？" class="headerlink" title="什么是接口，如何定义接口？"></a><span style = "color :red">什么是接口，如何定义接口？</span></h5><ul>
<li>接口，是java语言中一种类型，是方法的集合</li>
<li>使用interface关键字定义接口，其中可以定义抽象方法，默认方法，私有方法，静态方法等方法</li>
</ul>
<h5 id="什么叫做多态，条件是什么？"><a href="#什么叫做多态，条件是什么？" class="headerlink" title="什么叫做多态，条件是什么？"></a><span style = "color :red">什么叫做多态，条件是什么？</span></h5><p>一类事物的行为，具有多种表现形式<br>条件：</p>
<ul>
<li>继承或实现[二选一]</li>
<li>方法的重新</li>
<li>父类引用指向子类对象</li>
</ul>
<h5 id="使用多态特性，带来了什么样的好处？"><a href="#使用多态特性，带来了什么样的好处？" class="headerlink" title="使用多态特性，带来了什么样的好处？"></a><span style = "color :red">使用多态特性，带来了什么样的好处？</span></h5><p>增强方法的扩展性和复用性</p>
<h5 id="使用多态特性，注意什么样的弊端？"><a href="#使用多态特性，注意什么样的弊端？" class="headerlink" title="使用多态特性，注意什么样的弊端？"></a><span style = "color :red">使用多态特性，注意什么样的弊端？</span></h5><p>由于类型的提升，导致调用子类对象特有的方法，必须向下转型。</p>
<h3 id="练习：接口"><a href="#练习：接口" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAAA\n  BBBB</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义默认方法showB。</li>
<li>B类中，重写showA方法</li>
<li>测试类中，创建B类对象，调用showA方法，showB方法。</li>
</ol>
<pre><code class="java">interface A&#123;
    public abstract void showA(); //抽象方法
    public default void showB()&#123; //默认方法
        System.out.println(&quot;BBB&quot;);
    &#125;
&#125;

class B implements A&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        B b = new B();
        b.showA();
        b.showB();

    &#125;
&#125;
</code></pre>
<h3 id="练习：接口-1"><a href="#练习：接口-1" class="headerlink" title="练习：接口"></a>练习：接口</h3><p>输出<code>AAA\n  BBBB BBBB BBBB BBBB\n CCCC CCCC CCCC CCCC</code></p>
<p>编写步骤：</p>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义默认方法showB10，showC10，分别调用show10方法，传入参数。</li>
<li>测试类中，创建B对象，调用showA方法，showB10方法，showC10方法</li>
</ol>
<pre><code class="java">interface AA&#123;
    public abstract void showA();
    private void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.print(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
    public default void show10B()&#123;
        show10(&quot;BBBB&quot;);
    &#125;
    public default void show10C()&#123;
        show10(&quot;CCCC&quot;);
    &#125;
&#125;
class BB implements AA&#123;
    @Override
    public void showA() &#123;
        System.out.println(&quot;AAAA&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        BB b = new BB();
        b.showA();
        b.show10B();
        b.show10C();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，静态"><a href="#练习：接口，静态" class="headerlink" title="练习：接口，静态"></a>练习：接口，静态</h3><ul>
<li>编写步骤</li>
</ul>
<ol>
<li>定义接口A，普通类B实现接口A。</li>
<li>A接口中，定义抽象方法showA。 </li>
<li>A接口中，定义私有静态方法show10（String str），循环打印10次str。</li>
<li>A接口中，定义静态方法showB()，showC()，分别调用show10方法，传入参数。</li>
<li>B类中，定义静态方法showD</li>
<li>测试类中，使用A接口，调用静态showB()方法，showC()方法，</li>
<li>测试类中，使用B类，调用showA方法，showD方法。</li>
</ol>
<pre><code class="java">interface AAA&#123;
    public abstract void showA();

    public static void showB() &#123;
        System.out.println(&quot;static BBBB&quot;);
        show10(&quot;BBBB&quot;);
    &#125;
    public static void showC()&#123;
        System.out.println(&quot;static CCCC&quot;);
        show10(&quot;CCCC&quot;);
    &#125;
    private static void show10(String str)&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(str + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;
&#125;

class BBB implements AAA&#123;

    @Override
    public void showA() &#123;
        System.out.println(&quot;AAA&quot;);
    &#125;
    public void showD()&#123;
        System.out.println(&quot;DDDD&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        AAA.showB();
        AAA.showC();
        BBB bbb = new BBB();
        bbb.showA();
        bbb.showD();
    &#125;
&#125;
</code></pre>
<h3 id="练习：接口，多态"><a href="#练习：接口，多态" class="headerlink" title="练习：接口，多态"></a>练习：接口，多态</h3><p>输出：<code>star:星星一闪一闪亮晶晶\n    =======\n     sun:太阳引着9大行星旋转\n    sun：光照八分钟，到达地球</code></p>
<p>编写步骤</p>
<ol>
<li>定义接口Universe，提供抽象方法doAnything。</li>
<li>定义普通类Star，提供成员发光shine方法</li>
<li>定义普通类Sun，继承Star类，实现Universe接口</li>
<li>测试类中，创建Star对象，调用shine方法</li>
<li>测试类中，多态的方式创建Sun对象，调用doAnything方法，向下转型，调用shine方法。</li>
</ol>
<pre><code class="java">interface Universe&#123;
    public abstract void doAnything();
&#125;
class Star&#123;
    public void shine()&#123;
        System.out.println(&quot;star:星星一闪一闪亮晶晶&quot;);
    &#125;
&#125;
class Sun extends Star implements  Universe&#123;
    @Override
    public void doAnything() &#123;
        System.out.println(&quot;sun:太阳吸引着9大行星旋转&quot;);
    &#125;
    @Override
    public void shine() &#123;
        System.out.println(&quot;sun:光照八分钟,到达地球&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Star s = new Star();
        s.shine();
        System.out.println(&quot;====================&quot;);
        Universe universe = new Sun();
        universe.doAnything();
        Sun sun = (Sun)universe;
        sun.shine();
    &#125;
&#125;
</code></pre>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="练习：需求实现-1"><a href="#练习：需求实现-1" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>定义HandleAble接口，具备一个处理字符串数字的抽象方法方法HandleString（String num）。</p>
<ul>
<li>处理方式1：取整数部分。</li>
<li>处理方式2：保留指定位小数，四舍五入。</li>
</ul>
</li>
<li><p>开发提示：</p>
<ul>
<li>匿名内部类[<span style = "color : grey"><u>接口不能带方法体可以匿名内部类</u></span>]的方式，调用所有抽象方法</li>
</ul>
</li>
</ul>
<pre><code class="java">interface HandleAble&#123;
    String handleString(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        String str = &quot;23.23456789&quot;;
        System.out.println(&quot;原字符串是：&quot; + str);
        HandleAble s1 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;
                return str.substring(0,str.indexOf(&quot;.&quot;));
            &#125;
        &#125;;
        System.out.println(&quot;取整后：&quot; + s1.handleString(str));

        int num = 4;

        HandleAble s2 = new HandleAble() &#123;
            @Override
            public String handleString(String str) &#123;

                int i = str.indexOf(&quot;.&quot;) + num + 1;
                char c = str.charAt(i);
                //System.out.println(c);

                if (c &lt;= &#39;4&#39;) &#123;
                    return str.substring(0, i).toString();
                &#125; else &#123;
                    char c1 = (char) (str.charAt(str.indexOf(&quot;.&quot;) + num) + 1);
                    return str.substring(0, i - 1) + c1;

                &#125;
            &#125;
        &#125;;
        String sss = s2.handleString(str);
        System.out.println(&quot;保留&quot; + num + &quot;位小数后:&quot; + sss);
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-2"><a href="#练习：需求实现-2" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟上课出勤情况。</li>
</ul>
<ul>
<li><p>定义学生类：</p>
<ul>
<li>属性：姓名，出勤。</li>
<li>提供基本的构造方法和get方法，set方法。</li>
</ul>
</li>
<li><p>定义讲师类：</p>
<ul>
<li>属性：姓名。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤。</li>
</ul>
</li>
<li><p>定义课程类：</p>
<ul>
<li>属性：课程名称，讲师，学生集合。</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：show方法，打印课程信息，老师姓名，学生是否上课情况。</li>
</ul>
</li>
</ul>
<blockquote>
<p>课程名称：Java<br>授课老师：张老师<br>上课：小红<br>上课：小亮<br>旷课：小明</p>
</blockquote>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        Student s = new Student(&quot;小红&quot;);
        Student s1 = new Student(&quot;小亮&quot;);
        Student s2 = new Student(&quot;小明&quot;);
        ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;();
        arr.add(s);
        arr.add(s1);
        arr.add(s2);
        Teacher t = new Teacher(&quot;张老师&quot;);
        Course course = new Course(&quot;java&quot;,t,arr);
        t.dianming(arr);
        course.show();

    &#125;
&#125;

class Student&#123;
    private String name;
    private boolean come;

    public Student() &#123;
    &#125;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public boolean isCome() &#123;
        return come;
    &#125;

    public void setCome(boolean come) &#123;
        this.come = come;
    &#125;
&#125;
class Teacher&#123;
    private String name;
    // 点名方法，设置每一位的学生出勤情况。假设，小明今日未出勤
    public void dianming(ArrayList&lt;Student&gt; arr)&#123;
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            if (!student.getName().equals(&quot;小明&quot;))&#123;
                student.setCome(true);
            &#125;
        &#125;
    &#125;
    public Teacher() &#123;
    &#125;

    public Teacher(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
class Course&#123;
    private String name;
    private Teacher t;
    private ArrayList&lt;Student&gt; arr;

    public Course() &#123;
    &#125;

    public Course(String name, Teacher t, ArrayList&lt;Student&gt; arr) &#123;
        this.name = name;
        this.t = t;
        this.arr = arr;
    &#125;
    public void show()&#123;
        System.out.println(&quot;课程名称:&quot; + name);
        System.out.println(&quot;授课老师:&quot; + t.getName());
        for (int i = 0; i &lt; arr.size(); i++) &#123;
            Student student = arr.get(i);
            String name = student.getName();
            if (student.isCome()) &#123;
                System.out.println(&quot;上课: &quot; + name);
            &#125; else &#123;
                System.out.println(&quot;旷课: &quot; + name);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-3"><a href="#练习：需求实现-3" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li>模拟接待员接待用户，根据用户id，给用户分组。</li>
</ul>
<ul>
<li>定义接口Filter：<ul>
<li>提供抽象方法filterUser（User u）</li>
</ul>
</li>
<li>定义用户类：<ul>
<li>属性：用户类型，用户id</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li>定义接待员类：<ul>
<li>属性：接口Filter</li>
<li>提供基本的构造方法和get方法，set方法</li>
<li>成员方法：接待用户方法，设置用户类型。</li>
</ul>
</li>
<li>测试类：<ul>
<li>初始化50个User对象，id为1-50。</li>
<li>创建三个接待员对象。<ul>
<li>第一个接待员，设置接待规则，将10-19号用户类型设置为v1。</li>
<li>第二个接待员，设置接待规则，将20-29号用户类型设置为v2。</li>
</ul>
</li>
<li>遍历用户集合，给用户分区。</li>
</ul>
</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        ArrayList&lt;User&gt; ulist = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt;= 50; i++) &#123;
            ulist.add(new User(i));
        &#125;

        System.out.println(&quot;未分组:&quot;);
        System.out.println(ulist);

        Reception r1 = new Reception();
        Reception r2 = new Reception();
        Reception r3 = new Reception();
        r1.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 10 &amp;&amp; u.getId() &lt; 20)
                    u.setType(&quot;v1&quot;);
            &#125;
        &#125;);

        r2.setF(new Filter() &#123;
            @Override
            public void filterUser(User u) &#123;
                if (u.getId() &gt;= 20 &amp;&amp; u.getId() &lt; 30)
                    u.setType(&quot;v2&quot;);
            &#125;
        &#125;);

        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            r1.recept(user);
            r2.recept(user);
            r3.recept(user);
        &#125;
        System.out.println(&quot;已分组:&quot;);
        for (int i = 0; i &lt; ulist.size(); i++) &#123;
            User user = ulist.get(i);
            if (i % 9 == 0) &#123;
                System.out.println();
            &#125;
            System.out.print(user + &quot; &quot;);
        &#125;

    &#125;
&#125;

class Reception &#123;

    Filter f;

    public Filter getF() &#123;
        return f;
    &#125;

    public void setF(Filter f) &#123;
        this.f = f;
    &#125;

    public void recept(User u) &#123;
        if (u.getType() != null)
            return;
        if (f != null) &#123;
            f.filterUser(u);
            return;
        &#125; else &#123;
            u.setType(&quot;A&quot;);
        &#125;
    &#125;
&#125;

class User &#123;

    private String type;

    private int id;

    public User(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public String getType() &#123;
        return type;
    &#125;

    public void setType(String type) &#123;
        this.type = type;
    &#125;

    @Override
    public String toString() &#123;
        return id + &quot;-&quot; + type;
    &#125;
&#125;

interface Filter &#123;
    public abstract void filterUser(User u);
&#125;
</code></pre>
<h3 id="练习：需求实现-4"><a href="#练习：需求实现-4" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><ul>
<li><p>模拟工人挑苹果。</p>
</li>
<li><p>定义苹果类：</p>
<ul>
<li>属性：大小，颜色。</li>
<li>提供基本的构造方法和get方法，set方法</li>
</ul>
</li>
<li><p>定义接口CompareAble：</p>
<ul>
<li>定义默认方法compare，挑选较大苹果。</li>
</ul>
</li>
<li><p>定义接口实现类Compare。</p>
</li>
<li><p>定义工人类：</p>
<ul>
<li>成员方法：挑选苹果Apple pickApple（CompareAble，Apple a1，Apple a2）。</li>
</ul>
</li>
<li><p>测试类：</p>
<ul>
<li>创建Worker对象。</li>
<li>创建两个Apple对象，一个Apple（5，”青色”）,一个Apple（3，”红色”）</li>
<li>默认挑选大的苹果，打印苹果信息。</li>
<li>指定颜色挑选，通过匿名内部类实现。</li>
</ul>
</li>
<li><p>代码实现，效果所示：</p>
</li>
</ul>
<blockquote>
<p>默认挑大的：<br>5.0 - 青色<br>挑红的：<br>3.0 - 红色</p>
</blockquote>
<pre><code class="java">interface CompareAble&#123;
    default Apple compare(Apple a1, Apple a2)&#123;
        return a1.getSize() &gt; a2.getSize() ? a1 : a2;
    &#125;
&#125;

class Apple&#123;
    private double size;
    private String color;

    public Apple() &#123;
    &#125;

    public Apple(double size, String color) &#123;
        this.size = size;
        this.color = color;
    &#125;

    public double getSize() &#123;
        return size;
    &#125;

    public void setSize(double size) &#123;
        this.size = size;
    &#125;

    public String getColor() &#123;
        return color;
    &#125;

    public void setColor(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Apple&#123;&quot; +
                &quot;size=&quot; + size +
                &quot;, color=&#39;&quot; + color + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;

class Worker&#123;
    public Apple pickApple(CompareAble c, Apple a1, Apple a2)&#123;
        Apple compare = c.compare(a1,a2);
        return compare;
    &#125;


public class Test &#123;
    public static void main(String[] args) &#123;
        Worker worker = new Worker();
        Apple apple1 = new Apple(5, &quot;青色&quot;);
        Apple apple2 = new Apple(3, &quot;红色&quot;);
        System.out.println(&quot;默认挑大的:&quot;);
        Apple apple = worker.pickApple(new Com(), apple1, apple2);
        System.out.println(apple);

        System.out.println(&quot;挑红的:&quot;);
        Apple apple3 = worker.pickApple(new Com()&#123;
            @Override
            public Apple compare(Apple a1, Apple a2) &#123;
                return &quot;红色&quot;.equals(a1.getColor()) ? a1 : a2;
            &#125;
        &#125;,apple1,apple2);
        System.out.println(apple3);
    &#125;
    &#125;
&#125;

class Com implements CompareAble &#123;

&#125;
</code></pre>
<h1 id="数组习题"><a href="#数组习题" class="headerlink" title="数组习题"></a>数组习题</h1><h3 id="练习：需求实现-5"><a href="#练习：需求实现-5" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"><a href="#模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。" class="headerlink" title="模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。"></a>模拟在一副牌中，抽取第1张，第5张，第50张扑克牌。</h6><p>输出：<code>黑桃A 黑桃5 方片J</code></p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        String[] poker = getPoker();
// 抽取指定的三种扑克牌
        int num1 = 1;
        int num2 = 5;
        int num3 = 50;
        String[] pk3 = get3(poker , num1 ,num2,num3);
        // 打印抽取的牌
        for (int i = 0; i &lt; pk3.length; i++) &#123;
            System.out.print(pk3[i] + &quot; &quot;);
        &#125;
    &#125;
    private static String[] get3(String[] poker, int i, int i2, int i3)&#123;
        String[] pk3 = new String[3];
        pk3[0] = poker[i - 1];
        pk3[1] = poker[i2 - 1];
        pk3[2] = poker[i3 - 1];
        return pk3;
    &#125;
    private static String[] getPoker()&#123;
        String[] colors=&#123;&quot;黑色&quot;,&quot;红桃&quot;,&quot;梅花&quot;,&quot;方块&quot;&#125;;
        String[] nums=&#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;;
        String[] poker = new String[54];
        int index = 0;
        for (int i = 0; i &lt; colors.length; i++) &#123;
            for (int j = 0; j &lt; nums.length; j++) &#123;
                poker[index] = colors[i] + nums[j];
                index++;
            &#125;
        &#125;
        poker[52] = &quot;小王&quot;;
        poker[53] = &quot;大王&quot;;

        return poker;
    &#125;
&#125;
</code></pre>
<h3 id="练习：需求实现-6"><a href="#练习：需求实现-6" class="headerlink" title="练习：需求实现"></a>练习：需求实现</h3><h6 id="定义equals方法，比较数组内容是否完全一致。"><a href="#定义equals方法，比较数组内容是否完全一致。" class="headerlink" title="定义equals方法，比较数组内容是否完全一致。"></a>定义equals方法，比较数组内容是否完全一致。</h6><p>开发提示：</p>
<ul>
<li>长度一致，内容一致，定义为完全一致。</li>
</ul>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;

        int[] arr = &#123;1,2,3,4,3,2,1&#125;;
        int[] arr2 = &#123;1,2,3,4,3,2,1&#125;;
        System.out.println(&quot; 是否一致:&quot; +equals(arr ,arr2));

    &#125;
    //  比较数组的内容
    public static boolean equals(int[] arr1, int[] arr2) &#123;
        // 长度不同,返回false
        if (arr1.length != arr2.length) &#123;
            return false;
        &#125;

        //
        for (int i = 0; i &lt; arr1.length; i++) &#123;
            // arr1[i] 和 arr2[i]比较
            /*
             * 所有元素都相同才相同，也就是只要有一个不同，这两个数组就是不同
             */
            if (arr1[i] != arr2[i]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h1 id="异常-amp-线程习题"><a href="#异常-amp-线程习题" class="headerlink" title="异常&amp;线程习题"></a>异常&amp;线程习题</h1><h3 id="练习：异常的体系"><a href="#练习：异常的体系" class="headerlink" title="练习：异常的体系"></a>练习：异常的体系</h3><p>1.请描述异常的继承体系<br>异常继承体系：异常的根类是java.lang.Throwable。其下有两个子类：<code>java.lang.Error</code> 与 <code>java.util.Exception</code>。<br>Exception又分为编译时期异常：checked异常<br>                         与运行时期异常：runtime异常</p>
<p>2.请描述你对错误(Error)的理解<br><strong>Error</strong>：表示不可修复的恶性的错误，只能通过修改菜吗规避错误的产生，通常是系统级别的，所以很严重。</p>
<p>3.描述你对异常(Expection的理解)<br><strong>Exception</strong>：表示可修复的良性(相对于错误)的异常，异常产生后程序员可以并且通过代码的方式修正，使程序继续运行，是必须要处理的。</p>
<p>4.描述你对运行时异常(RuntimeException)的理解<br>运行时期异常：runtime异常。在运行时期，检查异常. 在编译时期，运行异常不会编译器检测(不报错)</p>
<h3 id="练习：throw与throws的区别"><a href="#练习：throw与throws的区别" class="headerlink" title="练习：throw与throws的区别"></a>练习：throw与throws的区别</h3><p>1.请描述throw的使用位置,作用是什么?<br>throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，后面语句都不执行</p>
<p>2.请描述throws的使用位置,作用是什么?<br>throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会<strong>将异常对象抛给方法调用处</strong></p>
<h3 id="练习：异常的处理方式"><a href="#练习：异常的处理方式" class="headerlink" title="练习：异常的处理方式"></a>练习：异常的处理方式</h3><p>1.异常处理方式有几种，分别是什么<br>异常的处理方式有两种，分别是使用 <code>throws</code> 和 <code>try...catch...finally</code></p>
<p>2.详细阐述每种方式对异常是如何处理的<br>throws用在方法的声明上后接异常类名，是把异常抛给调用者进行处助理<br>try…catch…finally是捕获异常，自己处理，处理完毕后面的程序可以继续运行<br>    <strong>try</strong>代码块中是可能出现异常的代码<br>    <strong>catch</strong>代码块，是遇到异常，对异常进行处理的代码<br>    <strong>finally</strong>代码块无论是否发生异常，都必须执行的代码，用于释放资源</p>
<h3 id="练习：常见异常，及产生原因"><a href="#练习：常见异常，及产生原因" class="headerlink" title="练习：常见异常，及产生原因"></a>练习：常见异常，及产生原因</h3><h6 id="请列举常见异常，并说明产生原因"><a href="#请列举常见异常，并说明产生原因" class="headerlink" title="请列举常见异常，并说明产生原因"></a>请列举常见异常，并说明产生原因</h6><p><strong>NullPointerException</strong>：空指针异常<br>当应用试图在要求使用对象的方法使用了null时，抛出该异常；譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度</p>
<p><strong>ArrayIndaexOutOfBoundsException</strong>：数组索引越界异常<br>当对数组的索引值为负数或大于等于数组大小时抛出此异常。</p>
<p><strong>ArithmeticException：</strong>算术运算异常<br>程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了</p>
<p><strong>NumberFormatException：</strong>数字格式异常<br>当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常</p>
<h3 id="练习：并行、并发概念"><a href="#练习：并行、并发概念" class="headerlink" title="练习：并行、并发概念"></a>练习：并行、并发概念</h3><h6 id="请简单描述什么是并行，什么是并发"><a href="#请简单描述什么是并行，什么是并发" class="headerlink" title="请简单描述什么是并行，什么是并发?"></a>请简单描述什么是并行，什么是并发?</h6><p>并行：指两个或多个事件在<strong>同一时刻发生</strong>（同时发生）。<br>并发：指两个或多个事件在<strong>同一个时间段</strong>内发生。</p>
<blockquote>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不  支持并行。<br>   你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>   你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
</blockquote>
<p><strong>并发</strong>的关键是你有处理多个任务的能力，不一定要同时。<br><strong>并行</strong>的关键是你有同时处理多个任务的能力。<br>它们最关键的点就是：是否是『同时』</p>
<h3 id="练习：进程概念、线程概念、线程与进程联系"><a href="#练习：进程概念、线程概念、线程与进程联系" class="headerlink" title="练习：进程概念、线程概念、线程与进程联系"></a>练习：进程概念、线程概念、线程与进程联系</h3><h6 id="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"><a href="#请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明" class="headerlink" title="请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明"></a>请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明</h6><p>进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>线程是进程中的一个执行单元，负责当前进程中程序的执行，<strong>一个进程中至少有一个线程</strong>。<strong>一个进程中是可以有多个线程的</strong>，这个应用程序也可以称之为多线程程序。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程, 但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。</p>
<h3 id="练习：自定义异常类"><a href="#练习：自定义异常类" class="headerlink" title="练习：自定义异常类"></a>练习：自定义异常类</h3><p>请使用代码实现<br>每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数<br>如果老师给学生赋值一个负数,抛出一个自定异常</p>
<pre><code class="java">// 1.定义异常类NoScoreException,继承RuntimeException 提供空参和有参构造方法
public class NoScoreException extends RuntimeException &#123;
    //  空参构造
    public NoScoreException() &#123;
            super();
    &#125;
    // 有参构造
    public NoScoreException(String message) &#123;
            super(message);
     &#125;
/* 2.定义学生类(Student)
   a)属性:name,score
   b)提供空参构造
   c)提供有参构造;
    i.使用setXxx方法给名称和score赋值
   d)提供setter和getter方法
    ii.在setScore(int score)方法中
    1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    2.然后在给成员score赋值.*/
public class Student &#123;
    private String name;
    private int score;
    // 空参构造
    public Student() &#123;
        super();
    &#125;
    // c)提供有参构造;
// i.使用setXxx方法给名称和score赋值
    public Student(String name,int score)&#123;
        setName(name);
        setScore(score);
    &#125;
// d)提供setter和getter方法

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getScore() &#123;
        return score;
    &#125;
    // i.在setScore(int score)方法中
    public void setScore(int score) &#123;
// 1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx.
    if(score &lt;0)&#123;
       throw new NoScoreException(&quot;:分数不能为负数:&quot;+score);
    &#125;
// 2.然后在给成员score赋值.
        this.score = score;
    &#125;
&#125;
    /*
3.定义测试类Test9
 a)提供main方法,在main方法中
  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码
  iii.使用空参构造创建Student对象
  iv.调用setScore(int score)方法,传入一个正数,运行程序
  v.调用setScore(int score)方法,传入一个负数,运行程序
 */
public class Test9 &#123;
    public static void main(String[] args) &#123;
//  i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序
//  Student s = new Student(&quot;景甜&quot;, -10);
//  ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码

//  iii.使用空参构造创建Student对象
        Student s = new Student();
//  iv.调用setScore(int score)方法,传入一个正数,运行程序
        s.setScore(100);
//  v.调用setScore(int score)方法,传入一个负数,运行程序
        s.setScore(-5);
    &#125;
&#125;
</code></pre>
<h1 id="网络通信概述-amp-TCP协议习题"><a href="#网络通信概述-amp-TCP协议习题" class="headerlink" title="网络通信概述&amp;TCP协议习题"></a>网络通信概述&amp;TCP协议习题</h1><h3 id="练习：ip地址和端口号概念"><a href="#练习：ip地址和端口号概念" class="headerlink" title="练习：ip地址和端口号概念"></a>练习：ip地址和端口号概念</h3><p>描述:<br>一、请写出IP地址的概念：<br><strong>IP地址：</strong>互联网协议地址(Internet Protocol Address), 俗称IP.IP地址用来给一个网络中的计算机设备做唯一的编号.</p>
<p>二、请写出端口号的概念：<br><strong>端口号:</strong>   端口号用来给计算机里的应用程序(进程)做唯一的标识,用2个字节表示的整数,取值范围0~65535.</p>
<h3 id="练习：UDP协议"><a href="#练习：UDP协议" class="headerlink" title="练习：UDP协议"></a>练习：UDP协议</h3><h6 id="判断下列说法是否正确：（-X-）"><a href="#判断下列说法是否正确：（-X-）" class="headerlink" title="判断下列说法是否正确：（ X ）"></a>判断下列说法是否正确：（ X ）</h6><p>由于UDP面向无连接的协议,可以保证数据完整性,因此在传输重要数据时采用UDP协议.<br><span style = "color : red"><strong>判断错误, 因为面向无连接,容易丢失包,所以不能保证数据完整.</strong></span></p>
<h3 id="练习：TCP协议"><a href="#练习：TCP协议" class="headerlink" title="练习：TCP协议"></a>练习：TCP协议</h3><h6 id="TCP协议中”三次握手”-第一次握手指的是什么："><a href="#TCP协议中”三次握手”-第一次握手指的是什么：" class="headerlink" title="TCP协议中”三次握手”,第一次握手指的是什么："></a>TCP协议中”三次握手”,第一次握手指的是什么：</h6><p><span style = "color : red">第一次握手:客户端向服务器发送请求,等待服务器确认</span></p>
<h3 id="练习：TCP网络协议"><a href="#练习：TCP网络协议" class="headerlink" title="练习：TCP网络协议"></a>练习：TCP网络协议</h3><h6 id="需求说明：创建新项目，按以下要求编写代码："><a href="#需求说明：创建新项目，按以下要求编写代码：" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 服务器端 端口号为8888<br>1: 等待客户端连接  如果有客户端连接 获取到客户端对象<br>2: 获取到客户端对象之后 当前在服务器读取数据客户端传送数据</p>
<pre><code class="java">public class TCPServer &#123;
   public static void main(String[] args) throws Exception &#123;
      //1创建服务器对象 
      ServerSocket  ss = new ServerSocket(8888);
      //2等待客户端连接   如果有客户端连接  获取到客户端对象 
      Socket socket = ss.accept();
      //3当前在服务器中  要读取数据  需要输入流  流由谁提供 客户端
      InputStream in = socket.getInputStream();//获取输入流
      //4:读数据
      int len;
      byte[] buffer = new byte[1024];
      while((len=in.read(buffer))!=-1)&#123;
          System.out.println(new String(buffer, 0, len));
      &#125;
      //释放资源
      in.close();
//       ss.close();服务器一般不会关闭
   &#125;
&#125;
</code></pre>
<h6 id="需求说明：创建新项目，按以下要求编写代码：-1"><a href="#需求说明：创建新项目，按以下要求编写代码：-1" class="headerlink" title="需求说明：创建新项目，按以下要求编写代码："></a>需求说明：创建新项目，按以下要求编写代码：</h6><p>在项目下创建TCP 客户端<br>访问之前创建的服务器端,服务器端ip127.0.0.1 端口号8888<br>1: 客户端连接服务器,并发送 hello.服务器,我是客户端.<br>2: 开启上一题服务器,等待客户端连接,客户端连接并发送数据 </p>
<pre><code class="java">public class TCPClient &#123;
  public static void main(String[] args) throws Exception &#123;
      //创建 Socket客户端对象
      Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
      //写数据  需要输出流  谁提供 客户端
      OutputStream out = socket.getOutputStream();
      //写数据
      out.write(&quot;hello.服务器,我是客户端.&quot;.getBytes());
      //释放资源
      out.close();
      socket.close();
  &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/08/22/后端/Java复习款(练习题)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/08/13/后端/java复习款/">
        <h2>
            java复习款
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/8/13
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Object类、常用API"><a href="#Object类、常用API" class="headerlink" title="Object类、常用API"></a>Object类、常用API</h1><pre><code class="java">public String toString():返回该对象的字符串表示
public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”
    
java.util.Date类表示特定的瞬间，精确到毫秒
    public Date():分配Date对象并初始化此对象，以表示分配它的时间(精确到秒)
    public Date(long date):分配Date对象并初始化此对象，以表示从标准基准时间1970年1月1日以来的指定毫秒数
    public long getTime():把日期对象转换成对应的时间毫秒值
    
java.text.DateFormat类是日期/时间格式化子类的抽象类
    public SimpleDateFormate(String pattern):用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat[&quot;yyyy-MM-dd HH:mm:ss&quot; =&gt; 2018-01-16 15:06:38]
    public String format(Date date):将Date对象格式化为字符串
    public Date parse(String source):将字符串解析为Date对象
</code></pre>
<h6 id="请使用日期时间相关的API，计算出一个人已经出生了多少天。"><a href="#请使用日期时间相关的API，计算出一个人已经出生了多少天。" class="headerlink" title="请使用日期时间相关的API，计算出一个人已经出生了多少天。"></a>请使用日期时间相关的API，计算出一个人已经出生了多少天。</h6><p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void function() throws Exception &#123;
    System.out.println(&quot;请输入出生日期 格式 YYYY-MM-dd&quot;);
    // 获取出生日期,键盘输入
    String birthdayString = new Scanner(System.in).next();
    // 将字符串日期,转成Date对象
    // 创建SimpleDateFormat对象,写日期模式
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    // 调用方法parse,字符串转成日期对象
    Date birthdayDate = sdf.parse(birthdayString);    
    // 获取今天的日期对象
    Date todayDate = new Date();    
    // 将两个日期转成毫秒值,Date类的方法getTime
    long birthdaySecond = birthdayDate.getTime();
    long todaySecond = todayDate.getTime();
    long secone = todaySecond-birthdaySecond;    
    if (secone &lt; 0)&#123;
        System.out.println(&quot;还没出生呢&quot;);
    &#125; else &#123;
        System.out.println(secone/1000/60/60/24);
    &#125;
&#125;
</code></pre>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><pre><code class="java">java.util.Calendar
    public static Calendar getInstance():使用默认时区和语言环境获得一个日历
    public int get(int field):返回給定日历字段的值
    public void set(int field, int value):将给定的日历字段设置为定值
    public abstract void add(qint field, int amount):根据日历的规则，为給定的日历字段添加或减去指定的时间量
    public Date getTime():返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Da
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    get方法
        Calendar cal = Calendar.getInstance();
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH)+1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;);
    &#125;

    set方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.YEAR, 2020);
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                        // 2020年1月17日
    &#125;
    
    add方法
public static void main(String[] args) &#123;
        Calendar cal = Calendar.getInstance();
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;);
                            // 2018年1月17日
        // 使用add方法
        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天
        cal.add(Calendar.YEAR, -3); // 减3年
        System.out.print(year + &quot;年&quot; + month + &quot;月&quot; + dayOfMonth + &quot;日&quot;); 
                            // 2015年1月18日; 
    &#125;

    getTime方法

      
</code></pre>
<h3 id="CurrentTimeMillis方法"><a href="#CurrentTimeMillis方法" class="headerlink" title="CurrentTimeMillis方法"></a>CurrentTimeMillis方法</h3><h6 id="验证for循环打印数字1-9999所需要使用的时间（毫秒）"><a href="#验证for循环打印数字1-9999所需要使用的时间（毫秒）" class="headerlink" title="验证for循环打印数字1-9999所需要使用的时间（毫秒）"></a>验证for循环打印数字1-9999所需要使用的时间（毫秒）</h6><pre><code class="java">public class SystemTest1 &#123;
    public static void main(String[] args) &#123;
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 10000; i++) &#123;
            System.out.println(i);
        &#125;
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时毫秒：&quot; + (end - start));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。(数组拷贝)
</code></pre>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。</p>
<pre><code class="java">备注：StringBuilder已经覆盖重写了Object当中的toString方法。
public StringBuilder():构造一个空的StringBuilder容器
public StringBuilder(String str):构造一个StringBuilder容器，并将字符串添加进去
public StringBuilder append(...):添加任意类型数据的字符串形式，并返回当前对象自身
public String toString():将当前StringBuilder对象转换为String对象
</code></pre>
<pre><code class="java">append方法
public static void main(String[] args) &#123;
        //创建对象
        StringBuilder builder = new StringBuilder();
        //public StringBuilder append(任意类型)
        StringBuilder builder2 = builder.append(&quot;hello&quot;);
        //对比一下
        System.out.println(&quot;builder:&quot;+builder);
        System.out.println(&quot;builder2:&quot;+builder2);
        System.out.println(builder == builder2); //true
        // 可以添加 任何类型
        builder.append(&quot;hello&quot;);
        builder.append(&quot;world&quot;);
        builder.append(true);
        builder.append(100);
        // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。
        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下
        //链式编程
        builder.append(&quot;hello&quot;).append(&quot;world&quot;).append(true).append(100);
        System.out.println(&quot;builder:&quot;+builder);
    &#125;

toString方法
通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：
public static void main(String[] args) &#123;
        // 链式创建
        StringBuilder sb = new StringBuilder(&quot;Hello&quot;).append(&quot;World&quot;).append(&quot;Java&quot;);
        // 调用方法
        String str = sb.toString();
        System.out.println(str); // HelloWorldJava
    &#125;
</code></pre>
<h3 id="基本类型转换位String"><a href="#基本类型转换位String" class="headerlink" title="基本类型转换位String"></a>基本类型转换位String</h3><pre><code class="java">- public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。
- public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。
- public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。
- public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。
- public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。
- public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。
- public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。
</code></pre>
<pre><code class="java">注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。
public class Demo18WrapperParse &#123;
    public static void main(String[] args) &#123;
        int num = Integer.parseInt(&quot;100&quot;);
    &#125;
&#125;
</code></pre>
<h1 id="Collection、泛型"><a href="#Collection、泛型" class="headerlink" title="Collection、泛型"></a>Collection、泛型</h1><p>集合按照其存储结构可以分为两大类，分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合。集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<pre><code class="java">public boolean add(E e):把给定的对象添加到当前集合中
public void clear():清空集合中所有的元素
public boolean remove(E e):把给定的对象在当前集合中删掉
public boolean contains(E e):判断当前集合中是否包含给定的对象
public boolean isEmpty():判断当前集合是否位空
public int size():返回集合中元素的个数
public Object[] to Array():把集合中的元素，存储到数组中
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;一&quot;);
        coll.add(&quot;二&quot;);
        coll.add(&quot;三&quot;);
        System.out.println(coll);                //[一, 二, 三]
        System.out.println(coll.contains(&quot;二&quot;));     //true
        System.out.println(coll.isEmpty());  //false
        System.out.println(coll.size());     //3
        System.out.println(coll.remove(&quot;二&quot;)); // true
        System.out.println(coll);                  //[一，二]
        System.out.println(coll.contains(&quot;二&quot;));  //false

        Object[] objects = coll.toArray(); //0 1
        for (int i = 0; i &lt; objects.length; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
</code></pre>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<pre><code class="java">public E next():返回迭代的下一个元素
public boolean hasNext():如果仍有元素可以迭代，则返回true
</code></pre>
<pre><code class="java">tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。
public static void main(String[] args) &#123;
        // 使用多态方式 创建对象
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        // 添加元素到集合
        coll.add(&quot;串串星人&quot;);
        coll.add(&quot;吐槽星人&quot;);
        coll.add(&quot;汪星人&quot;);
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator&lt;String&gt; it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext())&#123; //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        &#125;
      &#125;
</code></pre>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<pre><code>for(元素的数据类型 变量 ： collection集合or数组)&#123;
  //操作代码
&#125;
</code></pre>
<pre><code class="java">遍历集合
public static void main(String[] args) &#123;        
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
        coll.add(&quot;小河神&quot;);
        coll.add(&quot;老河神&quot;);
        coll.add(&quot;神婆&quot;);
        //使用增强for遍历
        for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素
            System.out.println(s);
    &#125;
&#125;
</code></pre>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><pre><code class="java">修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125;
class ArrayList&lt;E&gt;&#123;
    public boolean add(E e) &#123; &#125;
    public E get(int index) &#123; &#125;
&#125;

在创建对象的时候确定泛型
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
class ArrayList&lt;Integer&gt;&#123;
    public boolean add(Integer e) &#123; &#125;
    public Integer get(int index) &#123; &#125;
&#125;
</code></pre>
<pre><code class="java">举例自定义泛型类
public class MyGenericClass&lt;MVP&gt;&#123;
    //没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型
    private MVP mvp;
    public void setMVP(MVP mvp)&#123;
        this.mvp = mvp;
    &#125;
    public MVP getMVP()&#123;
        return mvp;
    &#125;
&#125;

public class GenericClassDemo &#123;
      public static void main(String[] args) &#123;         
         // 创建一个泛型为String的类
         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();        
         // 调用setMVP
         my.setMVP(&quot;大胡子登登&quot;);
         // 调用getMVP
         String mvp = my.getMVP();
         System.out.println(mvp);
         //创建一个泛型为Integer的类
         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); 
         my2.setMVP(123);         
         Integer mvp2 = my2.getMVP();
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><pre><code class="java">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;

public class MyGenericMethod &#123;      
    public &lt;MVP&gt; void show(MVP mvp) &#123;
        System.out.println(mvp.getClass());
    &#125;
    
    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;    
        return mvp;
    &#125;
&#125;
</code></pre>
<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><h5 id="1、定义类时确定泛型的类型"><a href="#1、定义类时确定泛型的类型" class="headerlink" title="1、定义类时确定泛型的类型"></a><strong>1、定义类时确定泛型的类型</strong></h5><pre><code class="java">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;

public interface MyGenericInterface&lt;E&gt;&#123;
    public abstract void add(E e);
    
    public abstract E getE();  
&#125;

泛型E的值就是String类型
public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;
    @Override
    public void add(String e) &#123;
        // 省略...
    &#125;

    @Override
    public String getE() &#123;
        return null;
    &#125;
&#125;

</code></pre>
<h5 id="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"><a href="#2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型" class="headerlink" title="2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型"></a><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></h5><pre><code class="java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;
    @Override
    public void add(E e) &#123;
            // 省略...
    &#125;

    @Override
    public E getE() &#123;
        return null;
    &#125;
&#125;

/*
 * 使用
 */
public class GenericInterface &#123;
    public static void main(String[] args) &#123;
        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();  
        my.add(&quot;aa&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过**通配符&lt;?&gt;**表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();
    getElement(list1);
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    getElement(list2);
&#125;
public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;
//？代表可以接收任意类型
</code></pre>
<h5 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h5><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();
    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
&#125;
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;
</code></pre>
<pre><code class="java">Java.util.Collections类下有一个静态的shuffle()方法,如下：

1）static void shuffle(List&lt;?&gt; list)  使用默认随机源对列表进行置换，所有置换发生的可能性都是大致相等的。

2）static void shuffle(List&lt;?&gt; list, Random rand) 使用指定的随机源对指定列表进行置换，所有置换发生的可能性都是大致相等的，假定随机源是公平的。
</code></pre>
<h3 id="扑克牌案例分析"><a href="#扑克牌案例分析" class="headerlink" title="扑克牌案例分析"></a>扑克牌案例分析</h3><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<pre><code class="java">import java.util.ArrayList;
import java.util.Collections;

public class Poker &#123;
    public static void main(String[] args) &#123;
        /*
        * 1: 准备牌操作
        */
        //1.1 创建牌盒 将来存储牌面的 
        ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();
        //1.2 创建花色集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();

        //1.3 创建数字集合
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        //1.4 分别给花色 以及 数字集合添加元素
        colors.add(&quot;♥&quot;);
        colors.add(&quot;♦&quot;);
        colors.add(&quot;♠&quot;);
        colors.add(&quot;♣&quot;);

        for(int i = 2;i&lt;=10;i++)&#123;
            numbers.add(i+&quot;&quot;);
        &#125;
        numbers.add(&quot;J&quot;);
        numbers.add(&quot;Q&quot;);
        numbers.add(&quot;K&quot;);
        numbers.add(&quot;A&quot;);
        //1.5 创造牌  拼接牌操作
        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中
        for (String color : colors) &#123;
            //color每一个花色 
            //遍历数字集合
            for(String number : numbers)&#123;
                //结合
                String card = color+number;
                //存储到牌盒中
                pokerBox.add(card);
            &#125;
        &#125;
        //1.6大王小王
        pokerBox.add(&quot;小☺&quot;);
        pokerBox.add(&quot;大☠&quot;);      
        // System.out.println(pokerBox);
        //洗牌 是不是就是将  牌盒中 牌的索引打乱 
        // Collections类  工具类  都是 静态方法
        // shuffer方法   
        /*
         * static void shuffle(List&lt;?&gt; list) 
         *     使用默认随机源对指定列表进行置换。 
         */
        //2:洗牌
        Collections.shuffle(pokerBox);
        //3 发牌
        //3.1 创建 三个 玩家集合  创建一个底牌集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();      

        //遍历 牌盒  必须知道索引   
        for(int i = 0;i&lt;pokerBox.size();i++)&#123;
            //获取 牌面
            String card = pokerBox.get(i);
            //留出三张底牌 存到 底牌集合中
            if(i&gt;=51)&#123;//存到底牌集合中
                dipai.add(card);
            &#125; else &#123;
                //玩家1   %3  ==0
                if(i%3==0)&#123;
                      player1.add(card);
                &#125;else if(i%3==1)&#123;//玩家2
                      player2.add(card);
                &#125;else&#123;//玩家3
                      player3.add(card);
                &#125;
            &#125;
        &#125;
        //看看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;田伯光：&quot;+player2);
        System.out.println(&quot;绿竹翁：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);  
    &#125;
&#125;
</code></pre>
<h1 id="List、Set、数据结构、Collections"><a href="#List、Set、数据结构、Collections" class="headerlink" title="List、Set、数据结构、Collections"></a>List、Set、数据结构、Collections</h1><h6 id="List集合特有的方法都是跟索引相关"><a href="#List集合特有的方法都是跟索引相关" class="headerlink" title="List集合特有的方法都是跟索引相关"></a>List集合特有的方法都是跟索引相关</h6><pre><code class="java">public void add(int index, E element):将指定的元素，添加到集合中的指定位置上
public E get(int index):返回集合中指定位置的元素
public E remove(int index):移除列表中指定位置的元素，返回的是被移除的元素
public E set(int index，E element):用指定元素替换集合中指定位置的元素，返回值的更新前的元素
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建List集合对象
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        
        // 往 尾部添加 指定元素
        list.add(&quot;图图&quot;);
        list.add(&quot;小美&quot;);
        list.add(&quot;不高兴&quot;);
        
        System.out.println(list);
        // add(int index,String s) 往指定位置添加
        list.add(1,&quot;没头脑&quot;);
        
        System.out.println(list);
        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素 
        System.out.println(&quot;删除索引位置为2的元素&quot;);
        System.out.println(list.remove(2));
        
        System.out.println(list);
        
        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改） 
        // 修改指定位置元素
        list.set(0, &quot;三毛&quot;);
        System.out.println(list);
        
        // String get(int index)  获取指定位置元素
        
        // 跟size() 方法一起用  来 遍历的 
        for(int i = 0;i&lt;list.size();i++)&#123;
            System.out.println(list.get(i));
        &#125;
        //还可以使用增强for
        for (String string : list) &#123;
            System.out.println(string);
        &#125;      
    &#125;
</code></pre>
<h1 id="List-ArrayList、LinkedList-的子类"><a href="#List-ArrayList、LinkedList-的子类" class="headerlink" title="List(ArrayList、LinkedList)的子类"></a>List(ArrayList、LinkedList)的子类</h1><p><code>java.util.ArrayList</code> 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。<br><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<pre><code class="java">public void addFirst(E e):将指定元素插入此列表的开头
public void addLast(E e):将指定元素添加到此列表的结尾
public E getFirst():返回此列表的第一个元素
public E removeFirst():移除并返回此列表的第一个元素
public E removeLast():移除并返回此列表的最后一个元素
public E pop():从此列表所表示的堆栈处弹出一个元素
public void push(E e):将元素推入此列表所表示的堆栈
public boolean isEmpty():如果列表不包含元素，则返回true
</code></pre>
<h1 id="Set-HashSet、LinkedHashSet"><a href="#Set-HashSet、LinkedHashSet" class="headerlink" title="Set(HashSet、LinkedHashSet)"></a>Set(HashSet、LinkedHashSet)</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<h4 id="Set集合取出元素的方式可以采用：迭代器、增强for"><a href="#Set集合取出元素的方式可以采用：迭代器、增强for" class="headerlink" title="Set集合取出元素的方式可以采用：迭代器、增强for"></a><span style = "color : red"><strong>Set集合取出元素的方式可以采用：迭代器、增强for</strong></span></h4><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<h4 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><pre><code class="java">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;
public static int getSum(int[] arr)&#123;
    int sum = 0;
    for(int a : arr)&#123;
        sum += a;
    &#125;
    return sum;
&#125;
</code></pre>
<h3 id="Collections-高效添加元素"><a href="#Collections-高效添加元素" class="headerlink" title="Collections(高效添加元素)"></a>Collections(高效添加元素)</h3><pre><code class="java">java.utils.Collections是集合工具类
public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素
public static void shuffle(List&lt;?&gt; list):打乱集合顺序
public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序
public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。
</code></pre>
<pre><code class="java"> public static void main(String[] args) &#123;
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        //原来写法
        //list.add(12);
        //list.add(14);
        //list.add(15);
        //list.add(1000);
        //采用工具类 完成 往集合中添加元素  
        Collections.addAll(list, 5, 222, 1，2);
        System.out.println(list);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<h3 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h3><pre><code class="java">public int compare(String o1, String o2):比较两个参数的顺序
return o1 - o2 (正数)
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
   ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
   Collections.addAll(arr,&quot;cba&quot;,&quot;aba&quot;,&quot;sba&quot;,&quot;nba&quot;);
   Collections.sort(arr, new Comparator&lt;String&gt;() &#123;
     @Override
     public int compare(String o1, String o2) &#123;
         return o1.charAt(0)-o2.charAt(0);
     &#125;
  &#125;);
  System.out.println(arr);
&#125;
</code></pre>
<pre><code class="java">public class Student_test implements Comparable&lt;Student_test&gt; &#123;
    @Override
    public int compareTo(Student_test o) &#123;
        return this.age-o.age;
    &#125;
Getter Setter toString 
--------------------------------------------------------------
public class Comparable_test &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;Student_test&gt; list = new ArrayList&lt;Student_test&gt;();
        list.add(new Student_test(&quot;rose&quot;,18));
        list.add(new Student_test(&quot;jack&quot;,16));
        list.add(new Student_test(&quot;abc&quot;,16));
        list.add(new Student_test(&quot;ace&quot;,17));
        list.add(new Student_test(&quot;mark&quot;,16));
        for(Student_test student : list)&#123;
            System.out.println(student);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
        return o2.getAge()-o1.getAge();//以学生的年龄降序
    &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<p>如果想要规则更多一些，可以参考下面代码：</p>
<pre><code class="java">Collections.sort(list, new Comparator&lt;Student&gt;() &#123;
    @Override
    public int compare(Student o1, Student o2) &#123;
       // 年龄降序
    int result = o2.getAge()-o1.getAge();//年龄降序

    if(result==0)&#123;//第一个规则判断完了 下一个规则 姓名的首字母 升序
     result = o1.getName().charAt(0)-o2.getName().charAt(0);
    &#125;
     return result;
  &#125;
&#125;);

Student&#123;name=&#39;rose&#39;, age=18&#125;
Student&#123;name=&#39;ace&#39;, age=17&#125;
Student&#123;name=&#39;abc&#39;, age=16&#125;
Student&#123;name=&#39;jack&#39;, age=16&#125;
Student&#123;name=&#39;mark&#39;, age=16&#125;
</code></pre>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p><code>java.util.Map</code>接口</p>
<p>Collection接口定义了单列集合规范 每次存储<strong>一个</strong>元素 单个元素<br>Map接口定义了双列集合的规范 每次存储<strong>一对儿</strong>元素(Key Value)</p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<pre><code class="java">HashMap&lt;K,V&gt;:存储数据采用的哈希表结构，元素的存取顺序不能保持一致，由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法

LinkedHashMap&lt;K,V&gt;: HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。

public V put(K key, V value):把指定的键与指定的值添加到Map集合中
public V remove(Object key):把指定的键所对应的键值对元素 在Map集合中删除，返回被删除元素的值
public V get(Object key):根据指定的键，在Map集合中获取对应的值
boolean containsKey(Object key) 判断集合中是否包含指定的键。
public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)
    
使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 
若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 
</code></pre>
<h3 id="Map集合遍历-键找值-方式"><a href="#Map集合遍历-键找值-方式" class="headerlink" title="Map集合遍历 键找值 方式"></a>Map集合遍历 键找值 方式</h3><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法: keyset()</li>
<li>遍历键的Set集合，得到每一个键</li>
<li>根据键，获取键所对应的值。方法: get(K key)</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);
        Set&lt;String&gt; keys = map.keySet();
        for (String key : keys)&#123;
            String value = map.get(key);
            System.out.println(key+&quot; &quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h3><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        // 创建Map集合对象 
        HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();
        // 添加元素到集合 
        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);
        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);
        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);

        // 获取 所有的 entry对象  entrySet
        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();

        // 遍历得到每一个entry对象
        for (Entry&lt;String, String&gt; entry : entrySet) &#123;
               // 解析 
            String key = entry.getKey();
            String value = entry.getValue();  
            System.out.println(key+&quot;的CP是:&quot;+value);
        &#125;
    &#125;
</code></pre>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要<strong>保证有序，还要速度快</strong>怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<pre><code class="java"> public static void main(String[] args) &#123;
        LinkedHashMap&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;();
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);
        map.put(&quot;李晨&quot;, &quot;范冰冰&quot;);
        map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;);
        Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
        for (Map.Entry&lt;String,String&gt; entry : entrySet)&#123;
            System.out.println(entry.getKey()+entry.getValue());
        &#125;
    &#125;
</code></pre>
<h3 id="Map集合练习"><a href="#Map集合练习" class="headerlink" title="Map集合练习"></a>Map集合练习</h3><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li>获取一个字符串对象</li>
<li>创建一个Map集合，<strong>键代表字符，值代表次数</strong>。</li>
<li>遍历字符串得到每个字符。</li>
<li>判断Map中是否有该键。</li>
<li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li>打印最终结果</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
        //友情提示
        System.out.println(&quot;请录入一个字符串:&quot;);
        String line = new Scanner(System.in).nextLine();
        // 定义 每个字符出现次数的方法
        findChar(line);
    &#125;
    private static void findChar(String line) &#123;
        //1:创建一个集合 存储  字符 以及其出现的次数
        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();
        //2:遍历字符串
        for (int i = 0; i &lt; line.length(); i++) &#123;
            char c = line.charAt(i);
            //判断 该字符 是否在键集中
            if (!map.containsKey(c)) &#123;//说明这个字符没有出现过
                //那就是第一次
                map.put(c, 1);
            &#125; else &#123;
                //先获取之前的次数
                Integer count = map.get(c);
                //count++;
                //再次存入  更新
                map.put(c, ++count);
            &#125;
        &#125;
        System.out.println(map);
    &#125;
</code></pre>
<h4 id="JDK9对集合添加的优化"><a href="#JDK9对集合添加的优化" class="headerlink" title="JDK9对集合添加的优化"></a>JDK9对集合添加的优化</h4><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<pre><code class="java">public class HelloJDK9 &#123;  
    public static void main(String[] args) &#123;  
        Set&lt;String&gt; str1=Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);  
        //str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  
        System.out.println(str1);  
        Map&lt;String,Integer&gt; str2=Map.of(&quot;a&quot;,1,&quot;b&quot;,2);  
        System.out.println(str2);  
        List&lt;String&gt; str3=List.of(&quot;a&quot;,&quot;b&quot;);  
        System.out.println(str3);  
    &#125;  
&#125; 

1: of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；
2: 返回的集合是不可变的；
</code></pre>
<h3 id="模拟斗地主洗牌发牌"><a href="#模拟斗地主洗牌发牌" class="headerlink" title="模拟斗地主洗牌发牌"></a>模拟斗地主洗牌发牌</h3><h5 id="案例规则"><a href="#案例规则" class="headerlink" title="案例规则"></a>案例规则</h5><ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h5 id="案例需求分析"><a href="#案例需求分析" class="headerlink" title="案例需求分析"></a>案例需求分析</h5><ol>
<li>准备牌：</li>
</ol>
<p>​        完成数字与纸牌的映射关系：</p>
<p>​        使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li>洗牌：</li>
</ol>
<p>​        通过数字完成洗牌发牌</p>
<ol start="3">
<li>发牌：</li>
</ol>
<p>​        将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>​        存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>​        将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li>看牌：</li>
</ol>
<p>​        通过Map集合找到对应字符展示。</p>
<p>​        通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示</p>
<pre><code class="java">public static void main(String[] args) &#123;
        /*
         * 1组装54张扑克牌
         */
        // 1.1 创建Map集合存储
        HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;();
        // 1.2 创建 花色集合 与 数字集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        // 1.3 存储 花色 与数字
        Collections.addAll(colors, &quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;);
        Collections.addAll(numbers, &quot;2&quot;, &quot;A&quot;, &quot;K&quot;, &quot;Q&quot;, &quot;J&quot;, &quot;10&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;);
        // 设置 存储编号变量
        int count = 1;
        pokerMap.put(count++, &quot;大王&quot;);
        pokerMap.put(count++, &quot;小王&quot;);
        // 1.4 创建牌 存储到map集合中
        for (String number : numbers) &#123;
            for (String color : colors) &#123;
                String card = color + number;
                pokerMap.put(count++, card);
            &#125;
        &#125;
        /*
         * 2 将54张牌顺序打乱
         */
        // 取出编号 集合
        Set&lt;Integer&gt; numberSet = pokerMap.keySet();
        // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中
        ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;();
        numberList.addAll(numberSet);

        // 打乱顺序
        Collections.shuffle(numberList);

        // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌
        // 3.1 发牌的编号
        // 创建三个玩家编号集合 和一个 底牌编号集合
        ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;();
        ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;();

        // 3.2发牌的编号
        for (int i = 0; i &lt; numberList.size(); i++) &#123;
            // 获取该编号
            Integer no = numberList.get(i);
            // 发牌
            // 留出底牌
            if (i &gt;= 51) &#123;
                dipaiNo.add(no);
            &#125; else &#123;
                if (i % 3 == 0) &#123;
                    noP1.add(no);
                &#125; else if (i % 3 == 1) &#123;
                    noP2.add(no);
                &#125; else &#123;
                    noP3.add(no);
                &#125;
            &#125;
        &#125;

        // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌
        // 4.1 对手中编号进行排序
        Collections.sort(noP1);
        Collections.sort(noP2);
        Collections.sort(noP3);
        Collections.sort(dipaiNo);

        // 4.2 进行牌面的转换
        // 创建三个玩家牌面集合 以及底牌牌面集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();

        // 4.3转换
        for (Integer i : noP1) &#123;
            // 4.4 根据编号找到 牌面 pokerMap
            String card = pokerMap.get(i);
            // 添加到对应的 牌面集合中
            player1.add(card);
        &#125;

        for (Integer i : noP2) &#123;
            String card = pokerMap.get(i);
            player2.add(card);
        &#125;
        for (Integer i : noP3) &#123;
            String card = pokerMap.get(i);
            player3.add(card);
        &#125;
        for (Integer i : dipaiNo) &#123;
            String card = pokerMap.get(i);
            dipai.add(card);
        &#125;

        //4.5 查看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;石破天：&quot;+player2);
        System.out.println(&quot;鸠摩智：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);
    &#125;
</code></pre>
<h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>(<u>工程师不能处理,只能尽量避免</u>)与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>(<u>由于使用不当导致,可以避免的</u>)。</p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<pre><code class="java">throw new 异常类名(参数)
throw new NullPointerExcerption(&quot;要访问的arr数组不存在&quot;);
throw new ArrayIndexOutOfBoundsException(&quot;该索引所在数组不存在，已超出范围&quot;);
</code></pre>
<p>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
<pre><code class="java">public static int getElement(int[] arr, int index)&#123;
        if (index &lt; 0 || index &gt; arr.length - 1)&#123;
            throw new ArrayIndexOutOfBoundsException(&quot;越界&quot;);
        &#125;
        int element = arr[index];
        return element;
    &#125;

    public static void main(String[] args) &#123;
        int[] arr = &#123;1,3,6,8,10&#125;;
        int index = 5;
        int element = getElement(arr, index);
        System.out.println(element);
    &#125;
</code></pre>
<p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<pre><code class="java\">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;    
</code></pre>
<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<pre><code class="java">public class ThrowsDemo2 &#123;
    public static void main(String[] args) throws IOException &#123;
        read(&quot;a.txt&quot;);
    &#125;

    public static void read(String path)throws FileNotFoundException, IOException &#123;
        if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 
            // 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw
            throw new FileNotFoundException(&quot;文件不存在&quot;);
        &#125;
        if (!path.equals(&quot;b.txt&quot;)) &#123;
            throw new IOException();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h3><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<pre><code class="java">try&#123;
    编写可能会出现异常的代码
&#125;catch(异常类型 e)&#123;
    处理异常的代码
&#125;
//记录日志/打印异常信息/继续抛出异常
</code></pre>
<p><strong>try：</strong>该代码块中编写可能产生异常的代码。<br><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意：try和catch都不能单独使用,必须连用。</p>
</blockquote>
<pre><code class="java">public String getMessage():获取异常的描述信息，提示给用户的时候提示错误原因
public String toString():获取异常的类型和异常描述信息
public void printStoackTralce():打印异常的跟踪栈信息并输出到控制台
包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
</code></pre>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。[注意:finally不能单独使用。]</p>
<pre><code class="java">try&#123;
     编写可能会出现异常的代码
&#125;catch(异常类型A  e)&#123;  当try中出现A类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;catch(异常类型B  e)&#123;  当try中出现B类型异常,就用该catch来捕获.
     处理异常的代码
     //记录日志/打印异常信息/继续抛出异常
&#125;
注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。
</code></pre>
<ul>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h3 id="自定义异常练习"><a href="#自定义异常练习" class="headerlink" title="自定义异常练习"></a>自定义异常练习</h3><pre><code class="java">// 业务逻辑异常
public class RegisterException extends Exception &#123;
    /**
     * 空参构造
     */
    public RegisterException() &#123;
    &#125;

    /**
     *
     * @param message 表示异常提示
     */
    public RegisterException(String message) &#123;
        super(message);
    &#125;
&#125;
====================================================
public class Demo &#123;
    // 模拟数据库中已存在账号
    private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;;
   
    public static void main(String[] args) &#123;     
        //调用方法
        try&#123;
              // 可能出现异常的代码
            checkUsername(&quot;nill&quot;);
            System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功
        &#125;catch(RegisterException e)&#123;
            //处理异常
            e.printStackTrace();
        &#125;
    &#125;

    //判断当前注册账号是否存在
    //因为是编译期异常，又想调用者去处理 所以声明该异常
    public static boolean checkUsername(String uname) throws LoginException&#123;
        for (String name : names) &#123;
            if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常
                throw new RegisterException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;);
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong></p>
<p>Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<pre><code class="java">public class Demo01 &#123;
    public static void main(String[] args) &#123;
        //创建自定义线程对象
        MyThread mt = new MyThread(&quot;新的线程！&quot;);
        //开启新线程
        mt.start();
        //在主方法中执行for循环
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(&quot;main线程！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="自定义线程类"><a href="#自定义线程类" class="headerlink" title="自定义线程类"></a>自定义线程类</h5><pre><code class="java">public class MyThread extends Thread &#123;
    //定义指定线程名称的构造方法
    public MyThread(String name) &#123;
        //调用父类的String参数的构造方法，指定线程的名称
        super(name);
    &#125;
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(getName()+&quot;：正在执行！&quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="继承Thread类方式"><a href="#继承Thread类方式" class="headerlink" title="继承Thread类方式"></a>继承Thread类方式</h3><p>完成操作过程中用到了<code>java.lang.Thread</code>类</p>
<pre><code class="java">public Thread():分配一个新的线程对象
public Thread(String name):分配一个指定名字的新的线程对象
public Thread(Runnable target):分配一个带有指定目标新的线程对象
public Thread(Runnable target, String name):分配一个带有指定目标新的线程对象并指定名字
    
常用方法：
public String getName():获取当前线程名称
public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法
public void run():此线程要执行的任务在此处定义代码
public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停
public static Thread currentThread():返回对当前正在执行的线程对象的引用
</code></pre>
<h3 id="实现Runnable接口方式"><a href="#实现Runnable接口方式" class="headerlink" title="实现Runnable接口方式"></a>实现Runnable接口方式</h3><p>采用<code>java.lang.Runnable</code>类，只需要重写run方法即可<br>步骤如下：<br>1.定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体<br>2.创建Runnable实现类的实例，并以此实例为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象<br>3.调用线程对象的start()方法来启动线程</p>
<pre><code class="java">public class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 20; i++) &#123;
        System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Demo &#123;
    public static void main(String[] args) &#123;
        MyThread mr = new MyThread();
        Thread t = new Thread(mr, &quot;小白&quot;);
        t.start();
        for (int i = 0; i &lt; 20; i++) &#123;
            System.out.println(&quot;旺财&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程 代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程 编程的基础。</p>
<blockquote>
<p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><p>如果一个类继承Thread, 则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享</p>
<h5 id="实现Runnable接口比继承Thread类所具有的优势："><a href="#实现Runnable接口比继承Thread类所具有的优势：" class="headerlink" title="实现Runnable接口比继承Thread类所具有的优势："></a>实现Runnable接口比继承Thread类所具有的优势：</h5><p>1.适合多个相同的程序代码的线程去共享同一个资源<br>2.可以避免java中的单继承的局限性<br>3.增加程序的健壮性，实现解耦操作，代码额可以被多个线程共享, 代码和线程独立<br>4.线程池只能放入实现Runnable或Callable类线程，不能直接放入继承Thread的类</p>
<blockquote>
<p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。</p>
</blockquote>
<h3 id="线程同时安全"><a href="#线程同时安全" class="headerlink" title="线程同时安全"></a>线程同时安全</h3><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<pre><code class="/java">public class Ticket implements Runnable&#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while(true)&#123;
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                   e.printStackTrace();
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
        &#125;
    &#125;
&#125;

public class test &#123;
    public static void main(String[] args) &#123;
        Ticket ticket = new Ticket();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h5 id="怎么使用Java线程同步机制-？"><a href="#怎么使用Java线程同步机制-？" class="headerlink" title="怎么使用Java线程同步机制 ？"></a>怎么使用Java线程同步机制 ？</h5><p>1.同步代码块<br>2.同步方法<br>3.锁机制</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul>
<li>同步代码块： <strong>synchronized</strong> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</li>
</ul>
<pre><code class="java">synchronized(同步锁)&#123;
    需要同步操作的代码
&#125;
------------------------------------------------------------------
public void run() &#123;
        while(true)&#123;
            synchronized (lock)&#123;
                if (ticket &gt; 0)&#123;
                    try &#123;
                        Thread.sleep(10000);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    String name = Thread.currentThread().getName();
                    System.out.println(name + ticket--);
                &#125;
            &#125;
       &#125;
</code></pre>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li>同步方法：<strong>synchronized</strong> 修饰的方法, 叫做同步方法. 保证A线程执行该方法的时候, 其他线程只能在方法外等着</li>
</ul>
<pre><code class="java">同步锁是谁?
对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。
</code></pre>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><code>java.util.concurrent.locks.Lock</code>机制提供了比<strong>synchronized</strong>代码块和<strong>synchronized</strong>方法更广泛的锁定操作，同步代码块&#x2F;同步方法 具有的功能Lock都有，除此之外更强大，更体现面向对象。<br>Lock锁也称同步锁，<strong>加锁</strong>与<strong>释放锁</strong>方法化了</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        MyRunnable my = new MyRunnable();
        Thread t1 = new Thread(my,&quot;窗口1 &quot;);
        Thread t2 = new Thread(my,&quot;窗口2 &quot;);
        Thread t3 = new Thread(my,&quot;窗口3 &quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
----------------------------------------------
public class MyRunnable implements Runnable&#123;
    private int ticket = 100;
    Lock lock = new ReentrantLock();
     @Override
      public void run() &#123;
        while(true)&#123;
            lock.lock();
            if (ticket &gt; 0)&#123;
                try &#123;
                    Thread.sleep(50);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
                String name = Thread.currentThread().getName();
                System.out.println(name + ticket--);
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="线程状态概述"><a href="#线程状态概述" class="headerlink" title="线程状态概述"></a>线程状态概述</h3><p>在<code>java.lang.Thread.State</code>这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New(新建)</td>
<td>线程刚被创建, 但是并未启动, 还没条用start方法</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态, 可能正在运行自己代码, 也可能没有, 这取决于操作系统处理器</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁, 而该对象锁被其他的线程持有, 则该线程进入Blocked状态; 当该线程持有锁时, 该线程将变成Runnable状态</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个(唤醒)动作时, 该线程进入Waiting状态。进入这个状态后是不能自动唤醒的, 必须等待另一个线程调用<strong>notify</strong>或者<strong>notifyAll</strong>方法才能够唤醒</td>
</tr>
<tr>
<td>TimedWaiting(计时终止)</td>
<td>同waiting状态, 有几个方法有超时参数, 调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法又Thread.sleep、Object.wait</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡, 或者没有因为捕获的异常终止了run方法而死亡</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一个调用了某个对象的 Object.wait 方法的线程会<span style = "color : red">等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。</span></strong> </p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞 争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p> 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/8476427ec1a9ced5d3f5727b207aff6b2f53636c/data/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE(%E9%AB%98%E7%BA%A7).jpg"  />

<pre><code class="java">public class test &#123;
    public static Object obj = new Object();

    public static void main(String[] args) &#123;
// 演示waiting
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                while (true) &#123;
                    synchronized (obj) &#123;
                        try &#123;
                            System.out.println(Thread.currentThread().getName() + &quot;=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;);
                            obj.wait(); //无限等待
//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来
                        &#125; catch (InterruptedException e) &#123;
                            e.printStackTrace();
                        &#125;
                        System.out.println(Thread.currentThread().getName() + &quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;, &quot;等待线程&quot;).start();
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
// while (true)&#123; //每隔3秒 唤醒一次
                try &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 等待3秒钟&quot;);
                    Thread.sleep(3000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (obj) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;);
                    obj.notify();
                &#125;
            &#125;
// &#125;
        &#125;, &quot;唤醒线程&quot;).start();
    &#125;
&#125;
</code></pre>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>1.wait: 线程不再活动, 不再参与调度, 进入wait set中, 因此不会浪费CPU资源, 也不会去竞争锁, 这时的线程状态即是Waiting。它还要等着别的线程执行一个特别的动作, 也即是”<strong>通知(notify)</strong>“在这个对象上等待的线程从wait set中释放出来, 重新进入到调度队列(ready queue)中<br>2.notify: 选取所通知对象的wait set中的一个线程释放：例如, 餐馆有空位置后, 等候就餐最久的顾客最先入座<br>3.notifyAll: 释放所通知的对象的wait set上的全部线程</p>
<blockquote>
<p>哪怕只通知了一个等待的线程, 被通知线程也不能立即恢复执行, 因为它当初终端的地方是在同步块内, 而此刻它偶已经不持有锁, 所以她需要再次尝试去获取锁(可能面临其他线程的竞争), 成功后才能在当初调用wait方法之后的地方恢复执行</p>
<ul>
<li>如果能获取锁, 线程就从Waiting状态变成Bunnable状态</li>
<li>否则, 从wait set出来, 又进入entry set, 线程就从Waiting状态变成了Blocked状态</li>
</ul>
</blockquote>
<h5 id="调用wait和notify方法需要注意的细节"><a href="#调用wait和notify方法需要注意的细节" class="headerlink" title="调用wait和notify方法需要注意的细节"></a>调用wait和notify方法需要注意的细节</h5><p>1.wait方法与notify方法必须由同一锁对象调用 因为对应锁对象可以通过notify唤醒使用同一锁对象调用的wait方法后的线程<br>2.wait方法与notify方法是属于Object类的方法的 因为锁对象是可以是任意对象，而任意对象的所属类都是继承了Object类的<br>3.wait方法与notify方法必须要在同步代码块或者是同步函数中使用 因为必须通过锁对象调用这2个方法</p>
<pre><code class="java">void notify():唤醒在此对象监视器上等待的单个线程
void notifyAll():唤醒在此对象监视器上等待的所有线程
void wait():导致当前的线程等待, 直到其他线程调用此对象的notify()方法或者notifyAll()方法
void wait(long timeout):导致当前的线程等待, 直到其他线程调用此对象的notify()方法或notifyAll()方法, 或者指定的时间过完
void wait(long timeout, intik nanos):导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法，或者其他线程打断了当前线程，或者指定的时间过完。
</code></pre>
<ul>
<li>wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。</li>
<li>当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常</li>
<li>当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。</li>
<li>在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知</li>
<li>调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。</li>
<li>notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）</li>
<li>notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）</li>
<li>假设有三个线程执行了obj.wait()，那么obj.notifyAll()则能全部唤醒thread1，thread2，thread3，但是要继续执行obj.wait()的下一条语句，必须获取obj锁，因此，thread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。</li>
<li>当调用obj.notify&#x2F;notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code></p>
<pre><code class="java">Executoturs类中有个创建线程池的方法：
public static ExecutorService nweFixedThreadPool(int nThreads):返回线程池对象(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：
public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象并执行
Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建于使用
</code></pre>
<blockquote>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
</blockquote>
<pre><code class="java">public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;我要一个教练&quot;);
        try &#123;
            Thread.sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName());
        System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;);
    &#125;
&#125;
==========================================================
public class ThreadPoolDemo &#123;
    public static void main(String[] args) &#123;
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
        // 创建Runnable实例对象
        MyRunnable r = new MyRunnable();

        //自己创建线程对象的方式
        // Thread t = new Thread(r);
        // t.start(); ---&gt; 调用MyRunnable中的run()

        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
        // 再获取个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        //service.shutdown();
    &#125;
&#125;
</code></pre>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h5 id="强调做什么，而不是以什么形式做"><a href="#强调做什么，而不是以什么形式做" class="headerlink" title="强调做什么，而不是以什么形式做"></a><strong>强调做什么，而不是以什么形式做</strong></h5><p>面向对象的思想:</p>
<p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<pre><code class="java">public class Demo01Runnable &#123;
    public static void main(String[] args) &#123;
        // 匿名内部类
        Runnable task = new Runnable() &#123;
            @Override
            public void run() &#123; // 覆盖重写抽象方法
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;;
        new Thread(task).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<p>上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<pre><code class="java">public class Demo02LambdaRunnable &#123;
    public static void main(String[] args) &#123;
        new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="传统代码"><a href="#传统代码" class="headerlink" title="传统代码"></a>传统代码</h4><pre><code class="java">public class RunnableImpl implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;多线程任务执行！&quot;);
    &#125;
&#125;

public class Demo03ThreadInitParam &#123;
    public static void main(String[] args) &#123;
        Runnable task = new RunnableImpl();
        new Thread(task).start();
    &#125;
&#125;
</code></pre>
<h4 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h4><p><strong>匿名内部类的好处与弊端</strong><br>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<pre><code class="java">public class Demo04ThreadNameless &#123;
    public static void main(String[] args) &#123;
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;多线程任务执行！&quot;);
            &#125;
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<pre><code class="java">() -&gt; System.out.println(&quot;多线程任务执行！&quot;)
</code></pre>
<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h3 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h3><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li><strong>一些参数</strong></li>
<li><strong>一个箭头</strong></li>
<li><strong>一段代码</strong></li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<pre><code>(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;
</code></pre>
<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h3 id="Lambda的参数和返回值"><a href="#Lambda的参数和返回值" class="headerlink" title="Lambda的参数和返回值"></a>Lambda的参数和返回值</h3><blockquote>
<p>需求:<br>    使用数组存储多个Person对象<br>    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</p>
</blockquote>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<pre><code class="java">public class Person &#123; 
    private String name;
    private int age;
    
    // 省略构造器、toString方法与Getter Setter 
&#125;

import java.util.Arrays;
import java.util.Comparator;
public class Demo06Comparator &#123;
    public static void main(String[] args) &#123;
          // 本来年龄乱序的对象数组
        Person[] array = &#123;
            new Person(&quot;古力娜扎&quot;, 19),
            new Person(&quot;迪丽热巴&quot;, 18),
               new Person(&quot;马尔扎哈&quot;, 20) &#125;;

          // 匿名内部类
        Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person o1, Person o2) &#123;
                return o1.getAge() - o2.getAge();
            &#125;
        &#125;;
        Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h6 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h6><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h6 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h6><pre><code class="java">import java.util.Arrays;

public class Demo07ComparatorLambda &#123;
    public static void main(String[] args) &#123;
        Person[] array = &#123;
              new Person(&quot;古力娜扎&quot;, 19),
              new Person(&quot;迪丽热巴&quot;, 18),
              new Person(&quot;马尔扎哈&quot;, 20) &#125;;

        Arrays.sort(array, (Person a, Person b) -&gt; &#123;
              return a.getAge() - b.getAge();
        &#125;);

        for (Person person : array) &#123;
            System.out.println(person);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><pre><code class="java">public File(String pathname):通过将给定的路径名字字符串转化为抽象路径名来创建新的File实例
public File(String parent, String child):从父路径名字符串和子路径名字符串创建新的File实例
public File(File parent, String child):从父抽象路径名和子路径名字符串创建新的File实例
</code></pre>
<pre><code class="java">// 文件路径名
String pathname = &quot;D:\\aaa.txt&quot;;
File file1 = new File(pathname); 

// 文件路径名
String pathname2 = &quot;D:\\aaa\\bbb.txt&quot;;
File file2 = new File(pathname2); 

// 通过父路径和子路径字符串
 String parent = &quot;d:\\aaa&quot;;
 String child = &quot;bbb.txt&quot;;
 File file3 = new File(parent, child);

// 通过父级File对象和子路径字符串
File parentDir = new File(&quot;d:\\aaa&quot;);
String child = &quot;bbb.txt&quot;;
File file4 = new File(parentDir, child);

小贴士：
1. 一个File对象代表硬盘中实际存在的一个文件或者目录。
2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。
</code></pre>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre><code class="java">public String getAbsolutePath():返回此File的绝对路径名字符串
public String getPath():将此File转换为路径名字符串
public String getName():返回由此File表示的文件或目录的名称
public long length():返回由此File表示的文件的长度
</code></pre>
<pre><code class="java">public class FileGet &#123;
    public static void main(String[] args) &#123;
        File f = new File(&quot;d:/aaa/bbb.java&quot;);     
        System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());
        System.out.println(&quot;文件构造路径:&quot;+f.getPath());
        System.out.println(&quot;文件名称:&quot;+f.getName());
        System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);

        File f2 = new File(&quot;d:/aaa&quot;);     
        System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());
        System.out.println(&quot;目录构造路径:&quot;+f2.getPath());
        System.out.println(&quot;目录名称:&quot;+f2.getName());
        System.out.println(&quot;目录长度:&quot;+f2.length());
    &#125;
&#125;
输出结果：
文件绝对路径:d:\aaa\bbb.java
文件构造路径:d:\aaa\bbb.java
文件名称:bbb.java
文件长度:636字节

目录绝对路径:d:\aaa
目录构造路径:d:\aaa
目录名称:aaa
目录长度:4096
API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。
</code></pre>
<h5 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h5><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<pre><code class="java">public class FilePath &#123;
    public static void main(String[] args) &#123;
          // D盘下的bbb.java文件
        File f = new File(&quot;D:\\bbb.java&quot;);
        System.out.println(f.getAbsolutePath());
          
        // 项目下的bbb.java文件
        File f2 = new File(&quot;bbb.java&quot;);
        System.out.println(f2.getAbsolutePath());
    &#125;
&#125;
输出结果：
D:\bbb.java
D:\idea_project_test4\bbb.java
</code></pre>
<h5 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h5><pre><code class="java">public boolean exists():此File表示的文件或目录是否真实存在
public boolean isDirectory():此File表示的是否为目录
public boolean isFile():此File表示的是否为文件
</code></pre>
<h5 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h5><pre><code class="java">public boolean createNewFile():当且仅当具有该名称的文件尚不存在时候,创建一个新的空文件
public boolean delete():删除由此File表示的文件或目录
public boolean mkdir():创建由此File表示的目录
public boolean mkdirs():创建由此File表示的目录,包括任何必须旦不存在的父目录
</code></pre>
<pre><code class="java">public class FileCreateDelete &#123;
    public static void main(String[] args) throws IOException &#123;
        // 文件的创建
        File f = new File(&quot;aaa.txt&quot;);
        System.out.println(&quot;是否存在:&quot;+f.exists()); // false
        System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true
        System.out.println(&quot;是否存在:&quot;+f.exists()); // true
        
         // 目录的创建
          File f2= new File(&quot;newDir&quot;);    
        System.out.println(&quot;是否存在:&quot;+f2.exists());// false
        System.out.println(&quot;是否创建:&quot;+f2.mkdir());    // true
        System.out.println(&quot;是否存在:&quot;+f2.exists());// true

        // 创建多级目录
          File f3= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f3.mkdir());// false
        File f4= new File(&quot;newDira\\newDirb&quot;);
        System.out.println(f4.mkdirs());// true
      
          // 文件的删除
           System.out.println(f.delete());// true
      
          // 目录的删除
        System.out.println(f2.delete());// true
        System.out.println(f4.delete());// false
    &#125;
&#125;
API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。
</code></pre>
<h5 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h5><pre><code class="java">public String[] list():返回一个String数组,表示该FIle目录中的所有子文件或目录
public File[] listFiles():返回一个File数组,表示该FIle目录中的所有的子文件或目录
</code></pre>
<pre><code class="java">public class FileFor &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;d:\\java_code&quot;);
      
          //获取当前目录下的文件以及文件夹的名称。
        String[] names = dir.list();
        for(String name : names)&#123;
            System.out.println(name);
        &#125;
        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息
        File[] files = dir.listFiles();
        for (File file : files) &#123;
            System.out.println(file);
        &#125;
    &#125; //打印全文件地址名称
</code></pre>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h5><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class DiGuiDemo2 &#123;
    public static void main(String[] args) &#123;
          // 创建File对象
        File dir  = new File(&quot;D:\\aaa&quot;);
          // 调用打印目录方法
        printDir(dir);
    &#125;

    public static void  printDir(File dir) &#123;
          // 获取子文件和目录
        File[] files = dir.listFiles();
          // 循环打印
          /*
            判断:
            当是文件时,打印绝对路径.
            当是目录时,继续调用打印目录的方法,形成递归调用.
          */
        for (File file : files) &#123;
            // 判断
            if (file.isFile()) &#123;
                  // 是文件,输出文件绝对路径
                System.out.println(&quot;文件名:&quot;+ file.getAbsolutePath());
            &#125; else &#123;
                  // 是目录,输出目录绝对路径
                System.out.println(&quot;目录:&quot;+file.getAbsolutePath());
                  // 继续遍历,调用printDir,形成递归
                printDir(file);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件搜索案例"><a href="#文件搜索案例" class="headerlink" title="文件搜索案例"></a>文件搜索案例</h4><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<pre><code class="java">public class test &#123;
    public static void main(String[] args) &#123;
        File file = new File(&quot;D:\\NotePad++&quot;);
        printFile(file);
    &#125;
    public static void printFile(File file)&#123;
        File[] files = file.listFiles();
        for (File f1 : files)&#123;
            if (f1.isFile())&#123;
                if (f1.getName().endsWith(&quot;.xml&quot;))&#123;
                    System.out.println(&quot;文件名：&quot;+f1.getAbsolutePath());
                &#125;
            &#125;else &#123;
                printFile(f1);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h4><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code> listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<pre><code class="java">boolean accept(File pathname)：测试pathname是否应该包含在当前File目录中，符合则返回true。
</code></pre>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public class DiGuiDemo4 &#123;
    public static void main(String[] args) &#123;
        File dir = new File(&quot;D:\\aaa&quot;);
        printDir2(dir);
    &#125;
  
    public static void printDir2(File dir) &#123;
          // 匿名内部类方式,创建过滤器子类对象
        File[] files = dir.listFiles(new FileFilter() &#123;
            @Override
            public boolean accept(File pathname) &#123;
                return pathname.getName().endsWith(&quot;.java&quot;)||pathname.isDirectory();
            &#125;   //public boolean isDirectory():此File表示的是否为目录
        &#125;);
          // 循环打印
        for (File file : files) &#123;
            if (file.isFile()) &#123;
                System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
            &#125; else &#123;
                printDir2(file);
            &#125;
        &#125;
    &#125;
&#125;      
</code></pre>
<h4 id="Lambda优化"><a href="#Lambda优化" class="headerlink" title="Lambda优化"></a>Lambda优化</h4><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<pre><code class="java">()-&gt;&#123; &#125;
</code></pre>
<p><strong>代码实现：</strong></p>
<pre><code class="java">public static void printDir3(File dir) &#123;
      // lambda的改写
    File[] files = dir.listFiles(f -&gt;&#123; 
          return f.getName().endsWith(&quot;.java&quot;) || f.isDirectory(); 
    &#125;);
      
    // 循环打印
    for (File file : files) &#123;
        if (file.isFile()) &#123;
            System.out.println(&quot;文件名:&quot; + file.getAbsolutePath());
          &#125; else &#123;
            printDir3(file);
          &#125;
    &#125;
&#125;
</code></pre>
<h3 id="字节流、字符流"><a href="#字节流、字符流" class="headerlink" title="字节流、字符流"></a>字节流、字符流</h3><h6 id="顶级父类们"><a href="#顶级父类们" class="headerlink" title="顶级父类们"></a>顶级父类们</h6><table>
<thead>
<tr>
<th></th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>字节输入流 <strong>InputStream</strong></td>
<td>字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td>字符流</td>
<td>字符输入流 <strong>Reader</strong></td>
<td>字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<h6 id="字节输出流-OutputStream类"><a href="#字节输出流-OutputStream类" class="headerlink" title="字节输出流 OutputStream类"></a>字节输出流 OutputStream类</h6><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输出流并释放与此流相关联的任何系统资源
public void flush():刷新此输出流并强制任何缓冲的输出字节被写出
public void write(byte[] b):将b.length字节从指定的字节数组写入此输出流
public void write(byte[] b, in off, int len):从指定的字节数组写入len字节,从偏移量off开始输出到此输出流
public abstract void write(int b):将指定的字节输出流
// close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h6 id="字节输出流-FileOutputStream类"><a href="#字节输出流-FileOutputStream类" class="headerlink" title="字节输出流 FileOutputStream类"></a>字节输出流 FileOutputStream类</h6><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。<br><code>java.io.FileOutputStream </code>类是文件输出流，用于**<u>将数据写出到文件</u>**。</p>
<pre><code class="java">public FileOutputStream(File file):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name):创建文件输出流以指定的名称写入文件
</code></pre>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<pre><code class="java">public class FileOutputStreamConstructor throws IOException &#123;
    public static void main(String[] args) &#123;
           // 使用文件名称创建流对象
        FileOutputStream fos = new FileOutputStream(&quot;D:\Clash\a.txt&quot;);
        // 普通创建
        File file = new File(&quot;a.txt&quot;);
        FileOutputStream fos = new FileOutputStream(file);
    &#125;
&#125;
</code></pre>
<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><p><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;);
    fos.write(97); //a
    fos.close();
&#125;
// 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
// 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\clash\\a.txt&quot;);
    yte[] b = &quot;黑马程序员&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<pre><code class="java">public FileOutputStream(File file, boolean append):创建文件输出流以写入由指定的File对象表示的文件
public FileOutputStream(String name, boolean append):创建文件输出流以指定的名称写入文件
</code></pre>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileOutputStream fos = new FileOutputStream(&quot;D:\\Clash\\a.txt&quot;, true);
    byte[] b = &quot;abcde&quot;.getBytes();
    fos.write(b);
    fos.close();
&#125;
</code></pre>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
<h4 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h4><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<pre><code class="java">public void close():关闭此输入流并释放与此流相关的任何系统资源
public abstract int read():从输入流读取数据的下一个字节
public int read(byte[] b):从输入流中读取一些字节数,并把它们存储到字节数组b中
close方法，当完成流的操作时，必须调用此方法，释放系统资源。
</code></pre>
<h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">FileInputStream(File file):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的File对象 file命名
FileInputStream(String name):通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的路径名 name命名。  
当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。
</code></pre>
<p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
   FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
   int b;
   while((b=fis.read())!= -1)&#123;
      System.out.println((char)b);
   &#125;
    fis.close();
&#125;
//1. 虽然读取了一个字节，但是会自动提升为int类型。
//2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。
</code></pre>
<p><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    byte[] b = new byte[2];
    while((len = fis.read(b)) != -1)&#123;
         System.out.println(new String(b,0,len));
    &#125;
    fis.close();
 &#125;
</code></pre>
<h5 id="实现资源的复制"><a href="#实现资源的复制" class="headerlink" title="实现资源的复制"></a>实现资源的复制</h5><pre><code class="java">public static void main(String[] args) throws IOException &#123;
    // 1.创建流对象
    // 1.1 指定数据源
    FileInputStream fis = new FileInputStream(&quot;D:\\Clash\\a.txt&quot;);
    // 1.2 指定目的地
    FileOutputStream fos = new FileOutputStream(&quot;D:\\7-Zip\\c.txt&quot;);
    // 2.读写数据
    // 2.1 定义数组
    byte[] b = new byte[1024];
    // 2.2 定义长度
    int len;
    // 2.3 循环读取
    while((len = fis.read(b))!=-1)&#123;
    // 2.4 写出数据
        fos.write(b,0,len);
    &#125;
    // 3.关闭资源
    fos.close();
    fis.close();
&#125;
// 流的关闭原则：先开后关，后开先关。
</code></pre>
<h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><pre><code class="java">FileReader(File file):创建一个新的FileReader，给定要读取的File对象
FileReader(String fileName):创建一个新的FileReader，给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    FileReader fr = new FileReader(&quot;D:\\Clash\\a.txt&quot;);
    int len;
    char[] cbuf = new char[1024];
    while((len = fr.read(cbuf))!=-1)&#123;
        System.out.println(new String(cbuf,0,len));
    &#125;
    fr.close();
&#125;
</code></pre>
<h3 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h3><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<pre><code class="java">void write(int c):写入单个字符
void write(char[] cbuf):写入字符数组
abstract void weite(char[] cbuf, int off, int len):写入字符数组的某一部分,off数组的开始索引,len写的字符个数
void write(String str):写入字符串
void write(String str, int off, int len):写入字符串的某一部分,off字符串的开始索引,len写的字符个数
void flush():刷新该流的缓冲
void close():关闭此流,但要先刷新它
</code></pre>
<h3 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h3><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<pre><code class="java">FileWriter(File file):创建一个新的FileWriter,给定要读取的File对象
FileWeiter(String fileName):创建一个新的FileWeiter,给定要读取的文件的名称
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
            // 使用File对象创建流对象
        File file = new File(&quot;a.txt&quot;);
        FileWriter fw = new FileWriter(file);
      
        // 使用文件名称创建流对象
        FileWriter fw = new FileWriter(&quot;b.txt&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><p><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream</p>
<p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</p>
<p><strong>续写和换行</strong>：操作类似于FileOutputStream。</p>
<p><strong><u>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</u></strong></p>
<blockquote>
<p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号，包括：1、2、3、A、B、C、~！·#￥%……—*（）——+等等。在ASCII编码中，一个英文字母字符存储需要1个字节。</p>
<p><strong>字节</strong>：计算机存储容量基本单位是字节（Byte），音译为拜特，8个二进制位组成1个字节，一个标准英文字母占一个字节位置，一个标准汉字占二个字节位置。计算机存储容量大小以字节数来度量。</p>
</blockquote>
<h3 id="异常的处理-回顾"><a href="#异常的处理-回顾" class="headerlink" title="异常的处理(回顾)"></a>异常的处理(回顾)</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
        FileWriter fw = null;
        try &#123;
            fw = new FileWriter(&quot;D:\\Clash\\a.txt&quot;);
            fw.write(&quot;黑马程序员&quot;);
        &#125;catch (IOException e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try&#123;
                if (fw != null)&#123;
                    fw.close();
                &#125;
            &#125;catch (IOException e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>try (创建流对象语句，如果多个,使用’;’隔开) {<br>    &#x2F;&#x2F; 读写数据<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}</p>
</blockquote>
<pre><code class="java">public class HandleException2 &#123;
    public static void main(String[] args) &#123;
          // 创建流对象
        try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123;
            // 写出数据
            fw.write(&quot;黑马程序员&quot;); //黑马程序员
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<pre><code class="java">public class TryDemo &#123;
    public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        final  FileReader fr  = new FileReader(&quot;in.txt&quot;);
        FileWriter fw = new FileWriter(&quot;out.txt&quot;);
           // 引入到try中
        try (fr; fw) &#123;
              // 定义变量
            int b;
              // 读取数据
              while ((b = fr.read())!=-1) &#123;
                // 写出数据
                fw.write(b);
              &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><pre><code class="java">public Object setProperty(String key, String value):保存一对属性
public String getProperty(String key):使用此属性列表中指定的键搜索属性值
public Set&lt;String&gt; stringPropertyNames():所有键的名称的集合
</code></pre>
<pre><code class="java">public class ProDemo &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties properties = new Properties();
        // 添加键值对元素
        properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;);
        properties.setProperty(&quot;length&quot;, &quot;209385038&quot;);
        properties.setProperty(&quot;location&quot;, &quot;D:\\a.txt&quot;);
        // 打印属性集对象
        System.out.println(properties);
        // 通过键,获取属性值
        System.out.println(properties.getProperty(&quot;filename&quot;));
        System.out.println(properties.getProperty(&quot;length&quot;));
        System.out.println(properties.getProperty(&quot;location&quot;));

        // 遍历属性集,获取所有键的集合
        Set&lt;String&gt; strings = properties.stringPropertyNames();
        // 打印键值对
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+properties.getProperty(key));
        &#125;
    &#125;
&#125;
输出结果：
&#123;filename=a.txt, length=209385038, location=D:\a.txt&#125;
a.txt
209385038
D:\a.txt
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><pre><code class="java">public void load(InputStream inStream):从字节输入流中读取键值对
</code></pre>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<pre><code>filename=a.txt
length=209385038
location=D:\a.txt
</code></pre>
<p>加载代码演示：</p>
<pre><code class="java">public class ProDemo2 &#123;
    public static void main(String[] args) throws FileNotFoundException &#123;
        // 创建属性集对象
        Properties pro = new Properties();
        // 加载文本中信息到属性集
        pro.load(new FileInputStream(&quot;read.txt&quot;));
        // 遍历集合并打印
        Set&lt;String&gt; strings = pro.stringPropertyNames();
        for (String key : strings ) &#123;
              System.out.println(key+&quot; -- &quot;+pro.getProperty(key));
        &#125;
     &#125;
&#125;
输出结果：
filename -- a.txt
length -- 209385038
location -- D:\a.txt
</code></pre>
<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p><strong>字节缓冲流</strong>  <code>BufferedInputStream</code>, <code>BufferedOutputStream</code><br><strong>字符缓冲流</strong>  <code>BufferedReader</code>, <code>BudfferedWeiter</code></p>
<h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><pre><code class="java">public BufferedInputStream(InputStream in):创建一个新的缓冲输入流
public BufferedOutputStream(OutputStream out):创建一个新的缓冲输出流
</code></pre>
<pre><code class="java">// 创建字节缓冲输入流
BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));
// 创建字节缓冲输出流
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
</code></pre>
<pre><code class="java">public static void main(String[] args) throws FileNotFoundException &#123;
          // 记录开始时间
        long start = System.currentTimeMillis();
        // 创建流对象
        try (
            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk9.exe&quot;));
         BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;));
        )&#123;
              // 读写数据
            int len;
            byte[] bytes = new byte[8*1024];
            while ((len = bis.read(bytes)) != -1) &#123;
                bos.write(bytes, 0 , len);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 记录结束时间
        long end = System.currentTimeMillis();
        System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
    &#125;
缓冲流使用数组复制时间:666 毫秒
</code></pre>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><pre><code class="java">public BufferedReader(Reader in):创建一个新的缓冲输入流
public BufferedReader(Writer out):创建一个新的缓冲输出流
</code></pre>
<blockquote>
<p><strong>字节(Byte)</strong> 是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。<br>**字符(Character) ** 是计算机中使用的字母、数字、字和符号，比如’A’、’B’、’$’、’&amp;’等。</p>
</blockquote>
<h5 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h5><pre><code class="java">BufferedReader：public String readLine():读一行文字
bufferedWeiter：public void newLine():写一行行分隔符，由系统属性定义符号
</code></pre>
<pre><code class="java">readLine代码展示
public static void main(String[] args) throws IOException &#123;
           // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        // 定义字符串,保存读取的一行文字
        String line  = null;
          // 循环读取,读取到最后返回null
        while ((line = br.readLine())!=null) &#123;
            System.out.print(line);
            System.out.println(&quot;------&quot;);
        &#125;
        // 释放资源
        br.close();
    &#125;
</code></pre>
<pre><code class="java">newLine代码展示
public static void main(String[] args) throws IOException  &#123;
          // 创建流对象
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));
          // 写出数据
        bw.write(&quot;黑马&quot;);
          // 写出换行
        bw.newLine();
        bw.write(&quot;程序&quot;);
        bw.newLine();
        bw.write(&quot;员&quot;);
        bw.newLine();
        // 释放资源
        bw.close();
    &#125;
&#125;
输出效果:
黑马
程序
员
</code></pre>
<h1 id="练习-文本排序"><a href="#练习-文本排序" class="headerlink" title="练习: 文本排序"></a>练习: 文本排序</h1><p>请将文本信息恢复顺序。</p>
<pre><code>3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。
8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。
4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。
2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。
1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。
9.今当远离，临表涕零，不知所言。
6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。
7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。
5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。
</code></pre>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java"> public static void main(String[] args) throws IOException &#123;
        // 创建map集合,保存文本数据,键为序号,值为文字
        HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();

        // 创建流对象
        BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;));
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;));

        // 读取数据
        String line  = null;
        while ((line = br.readLine())!=null) &#123;
            // 解析文本
            String[] split = line.split(&quot;\\.&quot;);
            // 保存到集合
            lineMap.put(split[0],split[1]);
        &#125;
        // 释放资源
        br.close();

        // 遍历map集合
        for (int i = 1; i &lt;= lineMap.size(); i++) &#123;
            String key = String.valueOf(i);
            // 获取map中文本
            String value = lineMap.get(key);
              // 写出拼接文本
            bw.write(key+&quot;.&quot;+value);
              // 写出换行
            bw.newLine();
        &#125;
        // 释放资源
        bw.close();
    &#125;
</code></pre>
<blockquote>
<ul>
<li><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</li>
<li>**Integer valueOf(String s):**返回保存指定的 String 的值的 Integer 对象。</li>
<li><strong>Integer valueOf(String s, int radix):</strong> 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</li>
</ul>
</blockquote>
<h2 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流
OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流
</code></pre>
<pre><code class="java">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));
OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;);
</code></pre>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
          // 定义文件路径
        String FileName = &quot;E:\\out.txt&quot;;
          // 创建流对象,默认UTF8编码
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));
        // 写出数据
          osw.write(&quot;你好&quot;); // 保存为6个字节
        osw.close();
        // 定义文件路径
        String FileName2 = &quot;E:\\out2.txt&quot;;
         // 创建流对象,指定GBK编码
        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;);
        // 写出数据
          osw2.write(&quot;你好&quot;);// 保存为4个字节
        osw2.close();
 &#125;
</code></pre>
<h2 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code class="java">public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的ObjectOutputStream。
</code></pre>
<h2 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong><br><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法</li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<blockquote>
<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a><strong>一、是什么</strong></h2><p>序列化：就是将对象转化成字节序列的过程。</p>
<p>反序列化：就是讲字节序列转化成对象的过程。</p>
<p>对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。</p>
<h2 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a><strong>二、为什么</strong></h2><p>那么为什么要去进行序列化呢？有以下两个原因</p>
<ol>
<li>持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。</li>
<li>网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。</li>
</ol>
<h2 id="三、怎么做"><a href="#三、怎么做" class="headerlink" title="三、怎么做"></a><strong>三、怎么做</strong></h2><p>怎么去实现对象的序列化呢？</p>
<p>Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。</p>
<ol>
<li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口</li>
<li>实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化</li>
</ol>
<p>下面分别实现Serializable和Externalizable接口来演示序列化和反序列化</p>
</blockquote>
<pre><code class="java">public class Employee implements java.io.Serializable &#123;
    public String name;
    public String address;
    public transient int age; // transient瞬态修饰成员,不会被序列化
    public void addressCheck() &#123;
          System.out.println(&quot;Address  check : &quot; + name + &quot; -- &quot; + address);
    &#125;
&#125;

public final void writeObject (Object obj) : 将指定的对象写出。
    
public class SerializeDemo&#123;
       public static void main(String [] args)   &#123;
        Employee e = new Employee();
        e.name = &quot;zhangsan&quot;;
        e.address = &quot;beiqinglu&quot;;
        e.age = 20; 
        try &#123;
              // 创建序列化流对象
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;));
            // 写出对象
            out.writeObject(e);
            // 释放资源
            out.close();
            fileOut.close();
            System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。
        &#125; catch(IOException i)   &#123;
            i.printStackTrace();
        &#125;
       &#125;
&#125;
输出结果：
Serialized data is saved
</code></pre>
<h2 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><pre><code class="java">public class SerTest &#123;
    public static void main(String[] args) throws Exception &#123;
        // 创建 学生对象
        Student student = new Student(&quot;老王&quot;, &quot;laow&quot;);
        Student student2 = new Student(&quot;老张&quot;, &quot;laoz&quot;);
        Student student3 = new Student(&quot;老李&quot;, &quot;laol&quot;);

        ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(student);
        arrayList.add(student2);
        arrayList.add(student3);
        // 序列化操作
        // serializ(arrayList);
        
        // 反序列化  
        ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(&quot;list.txt&quot;));
        // 读取对象,强转为ArrayList类型
        ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();
        
          for (int i = 0; i &lt; list.size(); i++ )&#123;
              Student s = list.get(i);
            System.out.println(s.getName()+&quot;--&quot;+ s.getPwd());
          &#125;
    &#125;

    private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123;
        // 创建 序列化流 
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;list.txt&quot;));
        // 写出对象
        oos.writeObject(arrayList);
        // 释放资源
        oos.close();
    &#125;
&#125;
</code></pre>
<h2 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<pre><code class="java">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；
</code></pre>
<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<pre><code class="java">public class PrintDemo &#123;
    public static void main(String[] args) throws IOException &#123;
        // 调用系统的打印流,控制台直接输出97
        System.out.println(97);
      
        // 创建打印流,指定文件的名称
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);
          
          // 设置系统的打印流流向,输出到ps.txt
        System.setOut(ps);
          // 调用系统的打印流,ps.txt中输出97
        System.out.println(97);
    &#125;
&#125;
</code></pre>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p><code>Socket</code>类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点</p>
<h5 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">public Socket(String host, int port):创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。
</code></pre>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
<p>构造举例，代码如下：</p>
<pre><code class="java">Socket client = new Socket(&quot;127.0.0.1&quot;, 6666);
</code></pre>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public InputStream getInputStream() ： 返回此套接字的输入流。
  - 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。
  - 关闭生成的InputStream也将关闭相关的Socket。
public OutputStream getOutputStream() ： 返回此套接字的输出流。
  - 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。
  - 关闭生成的OutputStream也将关闭相关的Socket。
public void close() ：关闭此套接字。
  - 一旦一个socket被关闭，它不可再使用。
  - 关闭此socket也将关闭相关的InputStream和OutputStream 。 
public void shutdownOutput() ： 禁用此套接字的输出流。   
  - 任何先前写出的数据将被发送，随后终止输出流。 
</code></pre>
<h2 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h2><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h5 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。
ServerSocket server = new ServerSocket(6666);
</code></pre>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><pre><code class="java">public Socket accept():侦听并接受链接，返回一个新的Socket对象，用于和客户端实现通信，该方法一直阻塞直到建立链接
</code></pre>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
        //5.关闭资源.
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.获取流对象 . 输出流
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
        // 4. 关闭资源 .
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<pre><code class="java">public class ServerTCP &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;服务端启动 , 等待连接 .... &quot;);
        // 1.创建 ServerSocket对象，绑定端口，开始等待连接
        ServerSocket ss = new ServerSocket(6666);
        // 2.接收连接 accept 方法, 返回 socket 对象.
        Socket server = ss.accept();
        // 3.通过socket 获取输入流
        InputStream is = server.getInputStream();
        // 4.一次性读取数据
          // 4.1 创建字节数组
        byte[] b = new byte[1024];
          // 4.2 据读取到字节数组中.
        int len = is.read(b)；
        // 4.3 解析数组,打印字符串信息
        String msg = new String(b, 0, len);
        System.out.println(msg);
          // =================回写数据=======================
          // 5. 通过 socket 获取输出流
           OutputStream out = server.getOutputStream();
          // 6. 回写数据
           out.write(&quot;我很好,谢谢你&quot;.getBytes());
          // 7.关闭资源.
          out.close();
        is.close();
        server.close();
    &#125;
&#125;
</code></pre>
<p><strong>客户端实现：</strong></p>
<pre><code class="java">public class ClientTCP &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;客户端 发送数据&quot;);
        // 1.创建 Socket ( ip , port ) , 确定连接到哪里.
        Socket client = new Socket(&quot;localhost&quot;, 6666);
        // 2.通过Scoket,获取输出流对象 
        OutputStream os = client.getOutputStream();
        // 3.写出数据.
        os.write(&quot;你好么? tcp ,我来了&quot;.getBytes());
          // ==============解析回写=========================
          // 4. 通过Scoket,获取 输入流对象
          InputStream in = client.getInputStream();
          // 5. 读取数据数据
          byte[] b = new byte[100];
          int len = in.read(b);
          System.out.println(new String(b, 0, len));
        // 6. 关闭资源 .
          in.close();
        os.close();
        client.close();
    &#125;
&#125;
</code></pre>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></p>
<p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<pre><code class="java">修饰符 interface 接口名称 &#123;
    public abstract 返回值类型 方法名称(可选参数信息);
    // 其他非抽象方法内容
&#125;
</code></pre>
<p><span style = "color:red"><strong>由于接口当中抽象方法的 <code>public abstract</code> 是可以省略的</strong></span>，所以定义一个函数式接口很简单：</p>
<pre><code class="java">public interface MyFunctionalInterface&#123;
    void myMethod(); //省略public abstract
&#125;
</code></pre>
<h2 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h2><p>与<code>@Override</code>注解的作用类似，引入了一个新的注解<code>@FunctionalInterface</code> 该注解可用于上一个接口的定义上</p>
<pre><code class="java">@FunctionalInterface
public interface MyfunctionalInterface&#123;
    void myMethod();
&#125;
</code></pre>
<p><strong>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错</strong>。需要注 意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p>
<p>对于刚刚定义好的 <code>MyFunctionalInterface</code> 函数式接口，典型使用场景就是作为方法的参数：</p>
<pre><code class="java">public class Demo09FunctionalInterface&#123;
    //使用自定义的函数式接口方法
    private static void deSomething(MyfunctionalInterfalce inter)&#123;
        inter.myMethod(); //调用自定义的函数式接口方法
    &#125;
    
    public static void main(String[] args)&#123;
        //调用使用函数式接口的方法
        doSomething(()-&gt;System.out,println(&quot;Lambda执行啦！&quot;));
    &#125;
&#125;
</code></pre>
<h2 id="Lambda的延迟"><a href="#Lambda的延迟" class="headerlink" title="Lambda的延迟"></a>Lambda的延迟</h2><pre><code class="java">public static void log(int level, MessageBuilder builder)&#123;
        if (level == 1)&#123;
            System.out.println(builder.buildMessage());
        &#125;
    &#125;

    public static void main(String[] args)&#123;
        String msgA = &quot;Hello&quot;;
        String msgB = &quot;world&quot;;
        String msgC = &quot;Java&quot;;
        log(2,() -&gt; &#123;
            System.out.println(&quot;Lambda执行啦！&quot;);
            return msgA+msgB+msgC;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。 </p>
<blockquote>
<p>扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法 来完成。而是否调用其所在方法是在条件判断之后才执行的。</p>
</blockquote>
<h2 id="使用Lambda作为参数和返回值"><a href="#使用Lambda作为参数和返回值" class="headerlink" title="使用Lambda作为参数和返回值"></a>使用Lambda作为参数和返回值</h2><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数 式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。<br>例如 <code>java.lang.Runnable</code> 接口就是一个函数式接口，假设有一个 <code>startThread</code> 方法使用该接口作为参数，那么就 可以使用Lambda进行传参。这种情况其实和 <code>Thread</code> 类的构造方法参数为 <code>Runnable</code> 没有本质区别。</p>
<pre><code class="java">public class DemoRunnable&#123;
    private static void startThread(Runnable task)&#123;
        new Thread(task).start();
    &#125;
    public static void main(String[] args)&#123;
        startThread(()-&gt;System.out.println(&quot;线程任务执行！&quot;));
    &#125;
&#125;
</code></pre>
<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一 个方法来获取一个 <code>java.util.Comparator</code> 接口类型的对象作为排序器时, 就可以调该方法获取</p>
<pre><code class="java">private static Comparable&lt;String&gt; newComparator()&#123;
    return(a,b) -&gt; b.length() - a.length();
    // 其中直接return一个Lambda表达式即可
&#125;

public static void main(String[] args) &#123;
    String[] array = &#123;&quot;abc&quot;,&quot;ab&quot;,&quot;abcd&quot;&#125;;
    System.out.println(Arrays.toString(array));
    Arrays.sort(array,newComparator());
    System.out.println(Arrays.toString(array));
&#125;
</code></pre>
<h2 id="常用函数式接口"><a href="#常用函数式接口" class="headerlink" title="常用函数式接口"></a>常用函数式接口</h2><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><p><code>java.util.function.Supplier&lt;T&gt;</code>接口仅包含一个无参的方法：<code>T get()</code> 用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，也就意味着对应Lambda表达式需要”<strong>对外提供</strong>“一个符合泛型类型的对象数据</p>
<pre><code class="java">public class Demo08Supplier &#123;
    private static String getString(Supplier&lt;String&gt; function) &#123;
    return function.get();
&#125;
public static void main(String[] args) &#123;
    String msgA = &quot;Hello&quot;;
    String msgB = &quot;World&quot;;
    System.out.println(getString(() ‐&gt; msgA + msgB));
    &#125;
&#125;
</code></pre>
<h4 id="求数组元素最大值"><a href="#求数组元素最大值" class="headerlink" title="求数组元素最大值"></a>求数组元素最大值</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>使用 <code>Supplier</code> 接口作为方法参数类型，通过<code>Lambda</code>表达式求出int数组中的最大值。<br>提示：接口的泛型请使用 <code>java.lang.Integer</code> 类。</p>
<h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">public class Demo02Test &#123;
//定一个方法,方法的参数传递Supplier,泛型使用Integer
    public static int getMax(Supplier&lt;Integer&gt; sup)&#123;
    return sup.get();
&#125;
public static void main(String[] args) &#123;
    int arr[] = &#123;2,3,4,52,333,23&#125;;
    //调用getMax方法,参数传递Lambda
    int maxNum = getMax(()‐&gt;&#123;
    //计算数组的最大值
    int max = arr[0];
    for(int i : arr)&#123;
        if(i&gt;max)&#123;
     max = i;
     &#125;
    &#125;
     return max;
   &#125;);
    System.out.println(maxNum);
    &#125;
&#125;
</code></pre>
<h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><p><code>java.util.function.Consumer</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是<strong>消费</strong>一个数据， 其数据类型由泛型决定。</p>
<h5 id="抽象方法：accept"><a href="#抽象方法：accept" class="headerlink" title="抽象方法：accept"></a>抽象方法：accept</h5><p><code>Consumer</code>接口中包含抽象方法<code>void accept(T t)</code>, 意为消费一个指定泛型的数据</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; function)&#123;
    function.accept(&quot;Hello!&quot;);
&#125;
public static void main(String[] args) &#123;
    consumeString(s -&gt; System.out.println(s));
&#125;
</code></pre>
<h5 id="默认方法：andThen"><a href="#默认方法：andThen" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h5><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的default方法 <code>andThen</code> 。下面是JDK的源代码：</p>
<pre><code class="java">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;
    Objects.requireNonNull(after);
    return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;
&#125;
</code></pre>
<p>要想实现组合，需要两个或多个Lambda表达式即可，而 <code>andThen</code> 的语义正是“一步接一步”操作。例如两个步骤组合的情况：</p>
<pre><code class="java">private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt;two)&#123;
        one.andThen(two).accept(&quot;hello&quot;);
&#125;

    public static void main(String[] args) &#123;
        consumeString(
                s-&gt; System.out.println(s.toUpperCase()),
                s -&gt; System.out.println(s.toLowerCase())
    );
&#125;
// 运行结果将会首先打印完全大写的HELLO，然后打印完全小写的hello。当然，通过链式写法可以实现更多步骤的组合。
</code></pre>
<h4 id="格式化打印信息"><a href="#格式化打印信息" class="headerlink" title="格式化打印信息"></a>格式化打印信息</h4><h6 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h6><p> 下面的字符串数组当中存有多条信息，请按照格式“ <code>姓名：XX。性别：XX。</code>”的格式将信息打印出来。要求将打印姓 名的动作作为第一个 <code>Consumer</code> 接口的Lambda实例，将打印性别的动作作为第二个 <code>Consumer</code>接口的Lambda实 例，将两个 <code>Consumer</code> 接口按照顺序“拼接”到一起。</p>
<pre><code class="java">public static void main(String[] args) &#123;
    String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot; &#125;;
&#125;
</code></pre>
<h6 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h6><pre><code class="java">import java.util.function.Consumer;
public class test &#123;
    private static void printInfo(Consumer&lt;String&gt;one, Consumer&lt;String&gt;two, String[] array)&#123;
        for (String info : array)&#123;
        one.andThen(two).accept(info);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;&#125;;
        printInfo(s-&gt; System.out.print(&quot;姓名:&quot;+s.split(&quot;,&quot;)[0]),
                  s-&gt; System.out.println(&quot;。性别：&quot;+s.split(&quot;,&quot;)[1]+&quot;。&quot;),
                  array
                  );
    &#125;
&#125;
</code></pre>
<h4 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h4><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用 <code>java.util.function.Predicate</code> 接口。</p>
<pre><code class="java">public class Demo15PredicateTest&#123;
    private static void metho(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.test(&quot;HelloWorld&quot;);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &gt; 5);
    &#125;
&#125;
// 条件判断的标准是传入的Lambda表达式逻辑，只要字符串长度大于5则认为很长。
</code></pre>
<h5 id="默认方法：and"><a href="#默认方法：and" class="headerlink" title="默认方法：and"></a>默认方法：and</h5><p>既然是条件判断，就会存在<strong>与、或、非</strong>三种常见的逻辑关系。其中将两个 <code>Predicate</code> 条件使用“与”逻辑连接起来实 现“<strong>并且</strong>”的效果时，可以使用default方法 and 。其JDK源码为：</p>
<pre><code class="java">defalult Predicate&lt;T&gt; and(Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) &amp;&amp; other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：or"><a href="#默认方法：or" class="headerlink" title="默认方法：or"></a>默认方法：or</h5><pre><code class="java">defalult Predicate&lt;T&gt; or (Predkicate&lt;? super T&gt; other)&#123;
    Object.requireNonNull(other);
    return (t) -&gt; test(t) || other.test(t);
&#125;
</code></pre>
<p>如何判断一个字符串既包含大写”H”，又包含大写”W”</p>
<pre><code class="java">public class test &#123;
   private static void method(Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       boolean isValid = one.and(two).test(&quot;HelloWorld&quot;);
       System.out.println(&quot;是否符合？&quot;+isValid);
   &#125;

    public static void main(String[] args) &#123;
        method(s -&gt; s.contains(&quot;H&quot;), s -&gt; s.contains(&quot;o&quot;));
    &#125;
&#125; // 是否符合？true
</code></pre>
<h5 id="默认方法：negate-“非”-取反"><a href="#默认方法：negate-“非”-取反" class="headerlink" title="默认方法：negate (“非”[取反])"></a>默认方法：negate (“非”[取反])</h5><pre><code class="java">default Predicate&lt;T&gt; negate()&#123;
    return (t) -&gt; !test(t);
&#125;
</code></pre>
<p>从现实中很容易看出，它是执行了test方法之后，对结果boolean值进行”!”取反而已。一定要在<code>test</code>方法调用之前调用<code>negate</code>方法，正如<code>and</code>和<code>or</code>方法一样</p>
<pre><code class="java">public class Demo17PredicateNegate&#123;
    private static void methodW(Predicate&lt;String&gt; predicate)&#123;
        boolean veryLong = predicate.negate().test(&quot;HelloWorld&quot;);
        System.out.println(&quot;字符串很长吗：&quot; + veryLong);
    &#125;
    public static void main(String[] args)&#123;
        method(s -&gt; s.length() &lt; 5);
    &#125;
&#125;
</code></pre>
<h3 id="集合信息筛选"><a href="#集合信息筛选" class="headerlink" title="集合信息筛选"></a>集合信息筛选</h3><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>数组当中有多条“姓名+性别”的信息如下，请通过 <code>Predicate</code> 接口的拼装将符合要求的字符串筛选到集合 <code>ArrayList</code> 中，需要同时满足两个条件：</p>
<blockquote>
<ol>
<li>必须为女生； </li>
<li>姓名为4个字。</li>
</ol>
</blockquote>
<pre><code class="java">public class DemoPredicate &#123;
    public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
    &#125;
&#125;
</code></pre>
<h5 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h5><pre><code class="java"> public static void main(String[] args) &#123;
        String[] array = &#123;&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        List&lt;String&gt; list = filter(array,
                s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]),
                s -&gt; s.split(&quot;,&quot;)[0].length() == 4);
        System.out.println(list);
    &#125;
 private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt;one, Predicate&lt;String&gt;two)&#123;
       List&lt;String&gt; list = new ArrayList&lt;&gt;();
       for (String info : array)&#123;
           if (one.and(two).test(info))&#123;
               list.add(info);
           &#125;
       &#125;
       return list;
 &#125;
</code></pre>
<h4 id="Stream流高级改造"><a href="#Stream流高级改造" class="headerlink" title="Stream流高级改造"></a>Stream流高级改造</h4><pre><code class="java">public static void main(String[] args) &#123;
        String[] array = &#123; &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; &#125;;
        Arrays.stream(array)
                .filter(s -&gt; &quot;女&quot;.equals(s.split(&quot;,&quot;)[1]))
            //  .filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;))
                .filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3)
                .forEach(System.out::println);
&#125;
</code></pre>
<h4 id="Stream流式思想改造"><a href="#Stream流式思想改造" class="headerlink" title="Stream流式思想改造"></a>Stream流式思想改造</h4><pre><code class="java"> public static void main(String[] args) &#123;
        Stream&lt;String&gt;original = Stream.of(&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; );
        Stream&lt;String&gt;result1 = original.filter(s -&gt; s.split(&quot;,&quot;)[1].startsWith(&quot;女&quot;));
        Stream&lt;String&gt;result2 = result1.filter(s -&gt; s.split(&quot;,&quot;)[0].length()==3);
        result2.forEach(System.out::println);
    &#125;
</code></pre>
<h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h4><p><code>java.util.function.Function&lt;T,R&gt;</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者成为后置条件。</p>
<h4 id="抽象方法：apply"><a href="#抽象方法：apply" class="headerlink" title="抽象方法：apply"></a>抽象方法：apply</h4><p><code>apply Function</code> 接口中最主要的抽象方法为：<code>R apply(T t)</code> ，根据类型T的参数获取类型R的结果。 使用的场景例如：将 <code>String</code> 类型转换为 <code>Integer</code> 类型。</p>
<pre><code class="java">private static void method(Function&lt;String,Integer&gt; function)&#123;
     int num = function.apply(&quot;10&quot;);
     System.out.println(num + 10);
&#125;

public static void main(String[] args) &#123;
     method(s -&gt; Integer.parseInt(s));
&#125;
</code></pre>
<h4 id="默认方法：andThen-1"><a href="#默认方法：andThen-1" class="headerlink" title="默认方法：andThen"></a>默认方法：andThen</h4><p><code>Function</code>接口中有一个默认的<code>andThen</code>方法，用来进行组合操作</p>
<pre><code class="java">default &lt;V&gt; Function&lt;T,V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)&#123;
    Objects.requireNonNull(after);
    return (T t) -&gt; after.apply(apply(t));
&#125;
</code></pre>
<p>该方法同样用于“先做什么，再做什么”的场景，和 <code>Consumer</code> 中的 <code>andThen</code> 差不多：</p>
<pre><code class="java">public class Demo12FunctionAndThen &#123;
    private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
    public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
    &#125;
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。 </p>
<pre><code class="java">private static void method(Function&lt;String, Integer&gt; one, Function&lt;Integer, Integer&gt; two) &#123;
        int num = one.andThen(two).apply(&quot;10&quot;);
        System.out.println(num + 20);
&#125;
public static void main(String[] args) &#123;
        method(str‐&gt;Integer.parseInt(str)+10, i ‐&gt; i *= 10);
&#125;
</code></pre>
<p>第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过 andThen 按照前后顺序组合到了一 起。</p>
<blockquote>
<p>请注意，Function的前置条件泛型和后置条件泛型可以相同。</p>
</blockquote>
<h4 id="自定义函数模型拼接"><a href="#自定义函数模型拼接" class="headerlink" title="自定义函数模型拼接"></a>自定义函数模型拼接</h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>请使用 Function 进行函数模型的拼接，按照顺序需要执行的多个函数操作为：<br> <code>String str = &quot;赵丽颖,20&quot;</code></p>
<p>1.将字符串截取数字年龄部分，得到字符串；<br>2.将上一步的字符串转换成为int类型的数字；<br>3.将上一步的int数字累加100，得到结果int数字。</p>
<h5 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h5><pre><code class="java">private static int getAgeNum(String str, Function&lt;String, String&gt;one, Function&lt;String, Integer&gt;two, Function&lt;Integer, Integer&gt; three)&#123;
    return one.andThen(two).andThen(three).apply(str);
&#125;

public static void main(String[] args) &#123;
    String str = &quot;赵丽颖,20&quot;;
    int age = getAgeNum(str,
         s -&gt; s.split(&quot;,&quot;)[1],
         s -&gt; Integer.parseInt(s),
         n -&gt; n += 100);
    System.out.println(age);
&#125;
</code></pre>
<h1 id="Stream流、方法引用"><a href="#Stream流、方法引用" class="headerlink" title="Stream流、方法引用"></a>Stream流、方法引用</h1><p>说到Stream便容易想到I&#x2F;O Stream，而实际上，谁规定“流”就一定是“IO流”呢？在Java 8中，得益于Lambda所带 来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。</p>
<p>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行 了对比说明。现在，我们仔细体会一下上例代码，可以发现： </p>
<ul>
<li>for循环的语法就是“怎么做” </li>
<li>for循环的循环体才是“做什么”</li>
</ul>
<p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从 第一个到最后一个顺次处理的循环。前者是目的，后者是方式。</p>
<p>试想一下，如果希望对集合中的元素进行筛选过滤：<br>1.将集合A根据条件一过滤为子集B；<br>2.然后再根据条件二过滤为子集C。</p>
<p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</p>
<h4 id="Stream更优写法"><a href="#Stream更优写法" class="headerlink" title="Stream更优写法"></a>Stream更优写法</h4><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码 中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p>
<pre><code class="java">public static void main(String[] args) &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;张无忌&quot;);
        list.add(&quot;周芷若&quot;);
        list.add(&quot;赵敏&quot;);
        list.add(&quot;张强&quot;);
        list.add(&quot;张三丰&quot;);
        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println);

    &#125;
</code></pre>
<blockquote>
<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何 元素（或其地址值)。</p>
</blockquote>
<h5 id="Stream-流-是一个来自数据源的元素队列"><a href="#Stream-流-是一个来自数据源的元素队列" class="headerlink" title="Stream(流)是一个来自数据源的元素队列"></a>Stream(流)是一个来自数据源的元素队列</h5><ul>
<li>元素是特定类型的对象，形成一个队列。java中的stream并不会存储元素，而是按需计算</li>
<li><strong>数据源</strong>流的来源：可以是<strong>集合，数组</strong>等</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者增强for的方式，显示的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法<code>forEach(System.out::println)</code></li>
</ul>
<p>当使用一个流的时候，通常包括三个步骤：获取一个<strong>数据源(source) → 数据转换 → 执行操作获取想要的结果</strong>，每次转换原有Stream对象不改变，返回一个新的Stream对象(可以有多次转换)，这就允许对其操作可以像链条一样排列，变成一个管道</p>
<h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p><code>java.util.stream.Stream&lt;T&gt;</code>是最常用的流接口<br>获取方式：<br>**1.**所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流<br><strong>2.</strong><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流</p>
<h5 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h5><p>首先<code>java.util.Collection</code>接口中加入了default方法<code>stream</code>用来获取流，所以其所有实现类均可获取流</p>
<pre><code class="java">public static void main(String[] args) &#123;
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream1 = list.stream();

    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream2 = set.stream();

    Vector&lt;String&gt; vector = new Vector&lt;&gt;();
    // ...
    Stream&lt;String&gt; stream3 = vector.stream();
    &#125;
</code></pre>
<h5 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h5><p><code>Java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流 需要分<strong>key、value</strong>或<strong>entry</strong>等情况：</p>
<pre><code class="java">public class Demo05GetStream &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        // ...
        Stream&lt;String&gt; keyStream = map.keySet().stream();
        Stream&lt;String&gt; valueStream = map.values().stream();
        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();
    &#125;
&#125;
</code></pre>
<h3 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h3><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以 <strong>Stream</strong> 接口中提供了静态方法 <strong>of</strong> ，使用很简单：</p>
<pre><code class="java">public static void main(String[] args) &#123;
     String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;;
     Stream&lt;String&gt; stream = Stream.of(array);
&#125;
</code></pre>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
<p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： </p>
<ul>
<li><strong>延迟方法</strong>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。） </li>
<li><strong>终结方法</strong>：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，终结方法包括 count 和 forEach 方法。</li>
</ul>
<h3 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h3><p>虽然方法名字叫 <code>forEach</code>，但是与for循环中的“for-each”昵称不同。<br>该方法接收一个 <code>Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。</p>
<pre><code class="java">void forEach(Consumer&lt;? super ?&gt; action);  
</code></pre>
<h3 id="复习Consumer接口"><a href="#复习Consumer接口" class="headerlink" title="复习Consumer接口"></a>复习Consumer接口</h3><pre><code class="java">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。
Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。
    
import java.util.stream.Stream;
  public class Demo12StreamForEach &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        stream.forEach(name‐&gt; System.out.println(name));
    &#125;
&#125;
</code></pre>
<h3 id="过滤：filter"><a href="#过滤：filter" class="headerlink" title="过滤：filter"></a>过滤：filter</h3><p>可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。方法签名：</p>
<pre><code class="java">Stream&lt;T&gt; filer(Predicate&lt;? super T&gt; predicate);
</code></pre>
<p>该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p>
<h3 id="复习Predicate接口"><a href="#复习Predicate接口" class="headerlink" title="复习Predicate接口"></a>复习Predicate接口</h3><p>此前我们已经学习过 <code>java.util.stream.Predicate</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">boolean test(T t);
</code></pre>
<p>该方法会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的<code>filter</code>方法将会留用元素；如果结果为false，那么<code>filter</code>方法将会舍弃元素。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 filter 方法基本使用的代码如：</p>
<pre><code class="java">public class Demo07StreamFilter &#123;
    public static void main(String[] args) &#123;
        Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法</p>
<pre><code class="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);
</code></pre>
<p>该接口需要一个 <strong>Function</strong> 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p>
<h3 id="复习Function接口"><a href="#复习Function接口" class="headerlink" title="复习Function接口"></a>复习Function接口</h3><p>此前我们已经学习过 <code>java.util.stream.Function</code> 函数式接口，其中唯一的抽象方法为：</p>
<pre><code class="java">R apply(T t);
</code></pre>
<p>这可以将一种T类型转换成R类型，这种转换的动作，叫做<strong>映射</strong></p>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>Stream流中的 <code>map</code> 方法基本使用的代码如：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;10&quot;,&quot;22&quot;,&quot;452&quot;);
    Stream&lt;Integer&gt; result = original.map(str -&gt; Integer.parseInt(str));
    result.forEach(System.out::println);
&#125;
</code></pre>
<p>这段代码中,<code>map</code> 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对 象）。</p>
<h3 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h3><p>正如旧集合 <code> Collection</code>  当中的 <code> size</code>  方法一样，流提供 <code> count</code>  方法来数一数其中的元素个数：</p>
<pre><code class="java">long count();
</code></pre>
<p>该方法返回一个long值代表元素个数</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));
    System.out.println(result.count()); // 2
&#125;
</code></pre>
<h3 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h3><p><code>limit</code> 方法可以对流进行截取，只取用前n个。方法签名</p>
<pre><code class="java">Stream&lt;T&gt; limit(long maxSize);
</code></pre>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用:</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
    Stream&lt;String&gt; result = original.limit(2);
    result.forEach(System.out::println); // 张无忌 张三丰
    System.out.println(result.count()); // 2
    &#125;
&#125;
</code></pre>
<h3 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h3><p>如果希望跳过前几个元素，可以使用 <code>skip</code> 方法获取一个截取之后的新流：<br>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p>
<pre><code class="java">public class Demo11StreamSkip &#123;
    public static void main(String[] args) &#123;
         Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);
         Stream&lt;String&gt; result = original.skip(2);
         result.forEach(System.out::println); // 周芷若
&#125;
</code></pre>
<h3 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h3><p>如果有两个流，希望合并成为一个流，那么可以使用 <code>Stream</code> 接口的静态方法 <code>concat</code> ：</p>
<pre><code class="java">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)
// 这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;);
    Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;);
    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);
    &#125;
&#125;
</code></pre>
<h3 id="集合元素处理-Stream方式）"><a href="#集合元素处理-Stream方式）" class="headerlink" title="集合元素处理(Stream方式）"></a>集合元素处理(Stream方式）</h3><h5 id="题目-Stream流式处理方式"><a href="#题目-Stream流式处理方式" class="headerlink" title="题目(Stream流式处理方式)"></a>题目(Stream流式处理方式)</h5><blockquote>
<p>第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；<br>第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人<br>将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。</p>
</blockquote>
<pre><code class="java">public class Person &#123;
    private String name;

    public Person() &#123;
    &#125;

    public Person(String name) &#123;
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class test &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; one = new ArrayList&lt;&gt;();
        one.add(&quot;迪丽热巴&quot;);
        one.add(&quot;宋远桥&quot;);
        one.add(&quot;苏星河&quot;);
        one.add(&quot;石破天&quot;);
        one.add(&quot;石中玉&quot;);
        one.add(&quot;老子&quot;);
        one.add(&quot;庄子&quot;);
        one.add(&quot;洪七公&quot;);

        List&lt;String&gt; two = new ArrayList&lt;&gt;();
        two.add(&quot;古力娜扎&quot;);
        two.add(&quot;张无忌&quot;);
        two.add(&quot;赵丽颖&quot;);
        two.add(&quot;张三丰&quot;);
        two.add(&quot;尼古拉斯赵四&quot;);
        two.add(&quot;张天爱&quot;);
        two.add(&quot;张二狗&quot;);

        // 第一个队伍只要名字为3个字的成员姓名；第一个队伍筛选之后只要前3个人；
        Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == 3).limit(3);
        // 第二个队伍只要姓张的成员姓名；第二个队伍筛选之后不要前2个人；
        Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2);
        // 将两个队伍合并为一个队伍；根据姓名创建Person对象；打印整个队伍的Person对象信息。
        Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);

    &#125;
&#125;
</code></pre>
<h3 id="Lambda方法引用"><a href="#Lambda方法引用" class="headerlink" title="Lambda方法引用"></a>Lambda方法引用</h3><p>请注意其中的<strong>双冒号 ::</strong> 写法，这被称为“<strong>方法引用</strong>”，而双冒号是一种新的语法。</p>
<pre><code class="java">简单的函数式接口以应用Lambda表达式:
@FunctionalInterface
public interface Printable &#123;
    void print(String str);
&#125;
</code></pre>
<pre><code class="java">private static void printString(Printable data)&#123;
    data.print(&quot;Hello, World!&quot;);
&#125;
public static void main(String[] args)&#123;
    printString(System.out::println);
&#125;
</code></pre>
<h3 id="方法引用符"><a href="#方法引用符" class="headerlink" title="方法引用符"></a><span style = "color:red">方法引用符</span></h3><h6 id="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑"><a href="#引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑" class="headerlink" title="引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?"></a>引出：我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?</h6><p>双冒号 <code>::</code> 为引用运算符，而它所在的表达式被称为<strong>方法引用</strong>。<u>如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者</u>。</p>
<p>例如上例中， <code>System.out</code> 对象中有一个重载的 println(String) 方法恰好就是我们所需要的。那么对于 printString 方法的函数式接口参数，对比下面两种写法，完全等效：</p>
<ul>
<li>Lambda表达式写法：<code>s -&gt; System.out.println(s);</code></li>
<li>方法引用写法：<code>System.out::println</code></li>
</ul>
<p>第一种语义是指：拿到参数之后经Lambda之手，继而传递给 <code>System.out.println</code> 方法去处理。<br>第二种等效写法的语义是指：直接让 <code>System.out</code> 中的 <code>println</code> 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</p>
<p>注：Lambda 中 传递的参数 一定是方法引用中 的那个方法可以接收的类型,否则会抛出异常</p>
<p><strong>三种主要使用情况：</strong></p>
<p>情况1：对象名::实例方法名<br>情况2：类名::静态方法名<br>情况3：类名::实例方法名</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yu411W77v/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【方法引用】Java语法中的双冒号::到底是啥意思？_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NK411f7Z5/?spm_id_from=333.788.recommend_more_video.1&vd_source=a4d980c3208d51858f08b3025a6ab2d9">lambda的双冒号是什么意思一个视频简简单单说清楚_哔哩哔哩_bilibili</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19W4y1W7G2/?spm_id_from=333.337.search-card.all.click&vd_source=a4d980c3208d51858f08b3025a6ab2d9">【java面试技巧】双冒号之方法引用大家快来看看吧_哔哩哔哩_bilibili</a></p>
</blockquote>
<pre><code class="java">interface A&#123;
    int method(String str);
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        A a1 = str -&gt; Integer.valueOf(str);
        System.out.println(a1.method(&quot;111&quot;));

        A a2 = Integer::valueOf;
        System.out.println(a2.method(&quot;444&quot;));

        A a = new A() &#123; //因为A是接口所以直接new不了 加上大括号 匿名内部类
            @Override
            public int method(String str) &#123;
                return new Integer(str); //封装 拆箱
            &#125;
        &#125;;
        A a3 = Integer::new;
        System.out.println(a3.method(&quot;666&quot;));
    &#125;
&#125;
</code></pre>
<h3 id="推导与省略"><a href="#推导与省略" class="headerlink" title="推导与省略"></a>推导与省略</h3><p>如果使用Lambda，那么根据“<strong>可推导就是可省略</strong>”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。<br>函数式接口是Lambda的基础，而方法引用是Lambda的孪生兄弟。 下面这段代码将会调用 <code>println</code> 方法的不同重载形式，将函数式接口改为int类型的参数：</p>
<pre><code class="java">@FunctionalInterface
public interface PrintableInteger &#123;
    void print(int str);
&#125;
-------------------------------------------------------------
public class Demo03PrintOverload &#123;
    private static void printInteger(PrintableInteger data) &#123;
        data.print(1024);
&#125;
public static void main(String[] args) &#123;
    printInteger(System.out::println);
&#125;
    // 这次方法引用将会自动匹配到 println(int) 的重载形式。
</code></pre>
<h4 id="通过类名称引用静态方法"><a href="#通过类名称引用静态方法" class="headerlink" title="通过类名称引用静态方法"></a>通过类名称引用静态方法</h4><p>由于在 <code>java.lang.Math</code> 类中已经存在了静态方法 <code>abs</code> ，所以当我们需要通过Lambda来调用该方法时，有两种写法。首先是函数式接口：</p>
<pre><code class="java">@FuctionalInterface
public interface Calcable &#123;
    double calc(int num);
&#125;
</code></pre>
<pre><code class="java">private static void method(int num, Calcable lambda)&#123;
     System.out.println(lambda.calc(num));
&#125;

public static void main(String[] args) &#123;
     method(10, Math::sqrt);
    // method(‐10, n ‐&gt; Math.abs(n)); 舍弃
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式:  <code>n -&gt; Math.abs(n)</code></li>
<li>方法引用: <code>Math::abs</code></li>
</ul>
<h4 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h4><p>如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。首先是函数式接口：</p>
<pre><code class="java">public interface Greetable &#123;
    void greet();
&#125;
</code></pre>
<p>然后是父类<code>Human</code>内容</p>
<pre><code class="java">public class Human &#123;
    public void sayHello()&#123;
        System.out.println(&quot;Hello&quot;);
    &#125;
&#125;
</code></pre>
<p>最后是子类<code>Man</code>的内容，其中使用了Lambda写法</p>
<pre><code class="java">public class Man extends Human &#123;
    @Override
    public void sayHello() &#123;
        System.out.println(&quot;大家好，我是Man!&quot;);
    &#125;
    //定义方法method，参数传递Greetable接口
    public void method(Greetable g)&#123;
        g.greet();
    &#125;

    public void show()&#123;
        method(super::sayHello);
    &#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li><p>Lambda表达式： <code>() -&gt; super.sayHello()</code></p>
</li>
<li><p>方法引用： <code>super::sayHello</code></p>
</li>
</ul>
<h4 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h4><p>this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用**<code>“this::成员方法”</code>**的格式来使用方 法引用。首先是简单的函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface Richable &#123;
    void buy();
&#125;
</code></pre>
<p>下面是一个丈夫 <code>Husband</code> 类：</p>
<pre><code class="java">public class Husband &#123;
    private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
    public void beHappy() &#123;
        marry(() ‐&gt; System.out.println(&quot;买套房子&quot;));
    &#125;
&#125;
</code></pre>
<p>开心方法 <code>beHappy</code> 调用了结婚方法 <code>marry</code> ，后者的参数为函数式接口 <code>Richable</code> ，所以需要一个Lambda表达式。 但是如果这个Lambda表达式的内容已经在本类当中存在了，则可以对<code>Husband</code>丈夫类进行修改：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(() ‐&gt; this.buyHouse());
    &#125;
&#125;
</code></pre>
<p>如果希望取消掉Lambda表达式，用方法引用进行替换，则更好的写法为：</p>
<pre><code class="java">public class Husband &#123;
    private void buyHouse() &#123;
        System.out.println(&quot;买套房子&quot;);
    &#125;
private void marry(Richable lambda) &#123;
        lambda.buy();
    &#125;
public void beHappy() &#123;
        marry(this::buyHouse);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的：</p>
<ul>
<li>Lambda表达式： <code>() -&gt; this.buyHouse()</code> </li>
<li>方法引用： <code>this::buyHouse</code></li>
</ul>
<h4 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h4><p>由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 <code>类名称::new</code> 的格式表示。首先是一个简单 的<code>Person</code>类：</p>
<pre><code class="java">public class Person &#123;
    private String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre>
<p>然后是用来创建 <code>Person</code> 对象的函数式接口：</p>
<pre><code class="java">public interface PersonBuilder &#123;
    Person buildPerson(String name);
&#125;
</code></pre>
<p>要使用这个函数式接口，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo09Lambda &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
        System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, name ‐&gt; new Person(name));
    &#125;
&#125;
</code></pre>
<p><strong>但是通过构造器引用，有更好的写法：</strong></p>
<pre><code class="java">public class Demo10ConstructorRef &#123;
    public static void printName(String name, PersonBuilder builder) &#123;
           System.out.println(builder.buildPerson(name).getName());
    &#125;
    public static void main(String[] args) &#123;
        printName(&quot;赵丽颖&quot;, Person::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>name -&gt; new Person(name) </code></li>
<li>方法引用： <code>Person::new</code></li>
</ul>
<h4 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h4><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时， 需要一个函数式接口：</p>
<pre><code class="java">@FunctionalInterface
public interface ArrayBuilder &#123;
    int[] buildArray(int length);
&#125;
</code></pre>
<p>在应用该接口的时候，可以通过Lambda表达式：</p>
<pre><code class="java">public class Demo11ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, length ‐&gt; new int[length]);
    &#125;
&#125;
</code></pre>
<p>但是更好的写法是使用数组的构造器引用：</p>
<pre><code class="java">public class Demo12ArrayInitRef &#123;
    private static int[] initArray(int length, ArrayBuilder builder) &#123;
        return builder.buildArray(length);
    &#125;
    public static void main(String[] args) &#123;
        int[] array = initArray(10, int[]::new);
    &#125;
&#125;
</code></pre>
<p>在这个例子中，下面两种写法是等效的： </p>
<ul>
<li>Lambda表达式： <code>length -&gt; new int[length] </code></li>
<li>方法引用： <code>int[]::new</code></li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/08/13/后端/java复习款/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/05/06/软考/软件设计师考点/">
        <h2>
            软件设计师考点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/5/6
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="考试占比"><a href="#考试占比" class="headerlink" title="考试占比"></a>考试占比</h1><p><img src="https://raw.githubusercontent.com/P-luminary/images/08dd53c87a8378186b9e41b70e12b5dbcf28801c/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%94.png" alt="考试占比"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5266e65404ade654c69fc2834998c5c959eda74/data/%E8%80%83%E8%AF%95%E5%8D%A0%E6%AF%942.png" alt="考试占比2"></p>
<h1 id="报名"><a href="#报名" class="headerlink" title="报名"></a>报名</h1><p><strong>报名条件：</strong>凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可报考软件设计师。也就是说不限制考生的学历、专业、工作经验及年限、年龄等。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/98615.html">点击查看软件设计师报名条件详解</a>】</p>
<p><strong>报名时间：</strong>上半年一般在&#x3D;&#x3D;3月份报名&#x3D;&#x3D;，下半年在&#x3D;&#x3D;8月份报名&#x3D;&#x3D;，各地报名具体时间不一样，考生届时需要多留意当地报名时间。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x159_1.html">点击查看各地软件设计师报名时间</a>】</p>
<p><strong>考试时间：</strong>上半年一般是&#x3D;&#x3D;5月份开考&#x3D;&#x3D;，下半年一般是&#x3D;&#x3D;11月份开考&#x3D;&#x3D;<br>上午基础知识科目考试为9:00-11:30，下午应用技术科目考试时间为14:00-16:30</p>
<p><strong>报名方式：</strong>考生自己在当地规定时间内进入软考办官网，即中国计算机技术职业资格网的报名入口进行报名。【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/pm1/105000.html">点击查看软件设计师报名入口</a>】</p>
<p><strong>报名费用：</strong>各地不同，一般在100-160元之间，具体以当地为准，其中辽宁不收取报名费(大连考区除外)【<a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x164_1.html">点击查看报名费用</a>】</p>
<p><strong>成绩查询：</strong>一般是考后40天左右公布成绩，成绩公布后大家可以在软考办官网进行查询</p>
<p><strong>考试证书：</strong>两科均通过分数线即可领取证书，各地领证时间不同，上半年证书一般集中在9-10月份发放，下半年证书一般集中在次年2-3月份发放。错过证书领取时间，证书由发证机构代为保管，考生可咨询相关领取事宜，但是超过5年没领取的证书将被销毁。软件设计师证书可以在中国计算机技术职业资格网和中国人事考试考试网的“证书查询”栏目进行查询。<strong>【</strong><a target="_blank" rel="noopener" href="https://www.cnitpm.com/class/4/e4_x163_1.html"><strong>点击查看详情</strong></a><strong>】</strong></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>二进制转八进制 八进制转十六进制<br>二进制转十进制 (分权相乘 整数AND小数)<br>十进制转二进制 (短除法)</p>
<h5 id="原码-反码-补码-转码"><a href="#原码-反码-补码-转码" class="headerlink" title="原码 反码 补码 转码"></a>原码 反码 补码 转码</h5><p><em>负数</em></p>
<ul>
<li><h4 id="原码-数字首-负数为1-正数为0"><a href="#原码-数字首-负数为1-正数为0" class="headerlink" title="原码(数字首 负数为1 正数为0)"></a><strong>原码</strong>(数字首 <u>负数为1 正数为0</u>)</h4><ul>
<li>+9 &#x3D; **<span style = "color : red">0</span>**000 1001</li>
<li>-9 &#x3D;  **<span style = "color : red">1</span>**000 1001 </li>
<li>Min → 1111 1111 &#x3D; —127    </li>
<li>Max → 0111 1111 &#x3D; +127</li>
<li>缺点：<strong>0有两种表示方式：+0&#x3D;00000000    -0&#x3D;10000000</strong>[零的二义性给机器判断带来了麻烦] ****</li>
<li><strong><span style = "color : orange"><u>原码的数值0有两种表示方式 +0 -0</u></span></strong></li>
</ul>
<p>比如：1-2&#x3D;-3 → ∵ +1+(-2) → +1 -&gt; 0000 000$1_原$  ;  -2 -&gt; 1000 001$0_原$  </p>
<p>∴ 0000 0001 + 1000 0010 &#x3D; 1000 001$1_原$ &#x3D; -3</p>
<p>为了解决这个问题，科学家使用补码</p>
<p>-33的原码是 *<u><strong>1</strong>010 0001</u>* 反码是 <u><strong>1</strong>101 1110</u></p>
</li>
<li><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a><strong>反码</strong></h4><ul>
<li>原码的符号位不变，其余位取相反得到 </li>
<li>反码存在的意义就是为了由原码计算补码方便</li>
</ul>
</li>
<li><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a><strong>补码</strong></h4><ul>
<li>反码+1得到</li>
<li>优点</li>
</ul>
<p>1、<span style = "color : orange"><strong><u>在补码表示中，0有唯一的编码</u></strong> </span>0 &#x3D; 0000 0000</p>
<p>2、用10000000表示 -128，比原码可多表示一个编码</p>
<p>3、利用补码可以方便地进行运算</p>
</li>
</ul>
<p><em>正数</em></p>
<ul>
<li><strong>原码&#x3D;反码&#x3D;补码</strong></li>
</ul>
<p>☆☆ <strong><span style = "color : green">正数：正数的原码、反码、补码都一样</span></strong> ☆☆</p>
<p>☆☆ <strong><span style = "color : green">负数：负数将原码的符号位保持不变，数值位各位取反再末位加1，就可以将原码转换为补码</span></strong> ☆☆</p>
<p>@@ 计算机中常采用原码、反码、补码和移码表示数据，其中±0编码相同的是<strong>补码和移码</strong><del>[这里一定要考虑正数和负数]</del></p>
<p>@@ 负数-5在计算机中的补码是 ？</p>
<p><u><em><strong>直接从原码变补码、补码变原码</strong></em></u>  <span style = "color : red"><strong>口诀：从右向左复制，直到有1被赋值 其余取相反(<u>符号位 &#x3D;&gt; 第一位不变</u>)</strong></span></p>
<ul>
<li><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4></li>
</ul>
<p>一般运用于浮点运算中的阶码，在<u><strong>补码</strong>的基础上把<strong>首位取反</strong></u></p>
<table>
<thead>
<tr>
<th></th>
<th>数值1 (正数前三都相同)</th>
<th>数值-1</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td>0000 0001</td>
<td>1000 0001</td>
</tr>
<tr>
<td>反码</td>
<td>0000 0001</td>
<td>1111 1110</td>
</tr>
<tr>
<td>补码</td>
<td><strong>0</strong>000 0001</td>
<td>1111 1111</td>
</tr>
<tr>
<td>移码</td>
<td><strong>1</strong>000 0001</td>
<td>0111 1111</td>
</tr>
</tbody></table>
<h3 id="表示范围"><a href="#表示范围" class="headerlink" title="表示范围"></a>表示范围</h3><table>
<thead>
<tr>
<th></th>
<th>整数</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>反码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}-1$]  ~  2$^{(n-1)}-1$</strong></span></td>
</tr>
<tr>
<td>补码</td>
<td><span style = "color : blue">   <strong>-[2$^{(n-1)}$]   ~   2$^{(n-1)}-1$</strong></span>  [少占用一个+0 -0]</td>
</tr>
</tbody></table>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数表示：<br><strong>N &#x3D; M * $R^e$</strong><br>其中M称为<strong>尾数</strong>，e是<strong>指数</strong>，R为<strong>基数</strong></p>
<h6 id="步骤：对阶-→-尾数计算-→-结果格式化"><a href="#步骤：对阶-→-尾数计算-→-结果格式化" class="headerlink" title="步骤：对阶 → 尾数计算 → 结果格式化"></a>步骤：<u>对阶 → 尾数计算 → 结果格式化</u></h6><p><strong>小阶数</strong>朝着<strong>大阶数</strong>化<br>1000 + 119 &#x3D;&gt; 1.0 × 1$0^3$ + <u>1.19 × 1$0^2$</u> &#x3D;&gt;  1.0 × 1$0^3$ + 0.119 × 1$0^3$ &#x3D; 1.119 × 1$0^3$</p>
<p><strong>结果格式化</strong>：如果答案是 0.1119 × 1$0^3$ 把结果变成 1.119 × 1$0^2$<br>确保尾数的第一个位置不能是0, 也不能是1以上的；最多是一位</p>
<h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><p>&#x3D;&#x3D;<strong>硬件 &#x3D; 主机 + 外设</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>主机</strong> &#x3D; CPU (<u>CPU &#x3D; 运算器 + 控制器</u>) + <em>内存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>外设</strong> &#x3D; 输入设备 + 输出设备 + <em>外存</em>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<u><strong>存储器</strong> &#x3D; 内存 + 外存</u>&#x3D;&#x3D;</p>
<blockquote>
<p><strong>运算器</strong>：<br>① 算术逻辑单元ALU<br>② 累加寄存器AC<br>③ 数据缓冲寄存器DR <u>[<strong>对内存储器读取的时候 有暂存的作用</strong>]</u><br>④ 状态条件寄存器PSW [<strong><u>存储运算过程中的标志位</u></strong><del>状态信息</del>]</p>
<p><strong>控制器</strong>：<br>① 程序计数器PC<br>② 指令寄存器IR<br>③ 指令译码器<br>④ 时序部件</p>
</blockquote>
<h3 id="计算机体系结构分类-—-Flynn"><a href="#计算机体系结构分类-—-Flynn" class="headerlink" title="计算机体系结构分类 — Flynn"></a>计算机体系结构分类 — Flynn</h3><table>
<thead>
<tr>
<th>体系结构类型</th>
<th>结构</th>
<th>关键特征</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>单指令流单数据流 SISD</td>
<td>控制部分：一个<br />处理器：一个<br />主存模块：多个</td>
<td></td>
<td>单处理器系统(单片机)</td>
</tr>
<tr>
<td>单指令流多数据流 SIMD</td>
<td>控制部分：一个<br />处理器：多个<br />主存模块：多个</td>
<td>各处理器以异步的形式执行同一条指令</td>
<td>并行处理机<br />阵列处理机<br />超级向量处理机</td>
</tr>
<tr>
<td>多指令流单数据流 MISD</td>
<td>控制部分：多个<br />处理器：一个<br />主存模块：多个</td>
<td>被证明不可能，至少是不实际</td>
<td>目前没有，有文献称流水线计算机为此类</td>
</tr>
<tr>
<td>多指令流多数据流 MIMD</td>
<td>控制部分：多个<br />处理器：多个<br />主存模块：多个</td>
<td>能够实现作业、任务、指令等各级全面并行</td>
<td>多处理系统<br />多计算机</td>
</tr>
</tbody></table>
<h3 id="CISC与RISC"><a href="#CISC与RISC" class="headerlink" title="CISC与RISC"></a>CISC与RISC</h3><table>
<thead>
<tr>
<th>指令系统类型</th>
<th>指令</th>
<th>寻址方式</th>
<th>实现方式</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>CISC(复杂)</td>
<td>数量多，使用<strong>频率</strong>差别大，可变长格式</td>
<td>支持多种</td>
<td>微程序控制技术(微码)</td>
<td>研制周期长</td>
</tr>
<tr>
<td>RISC(精简)<del>主流</del></td>
<td>数量少，使用频率接近，定长格式，大部分微单周期指令<br />操作寄存器，只有Load&#x2F;Store操作内存</td>
<td>支持方式少</td>
<td>大量增加了通用寄存器(增加速度)；<br />硬布线逻辑控制为主<br />适合采用流水线</td>
<td><strong>优化编译，有效支持高级语言</strong></td>
</tr>
</tbody></table>
<p>CISC(Complex Instruction Set Computer, 复杂指令集计算机) 进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬化，导致机器的指令系统越来越庞大而复杂。</p>
<p>RISC(Reduced Instruction Set Computer, 精简指令集计算机) 通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译，提高指令的执行速度，采用硬线控制逻辑，优化编译程序。</p>
<h3 id="流水线-计算-运用于工业-可节省时间"><a href="#流水线-计算-运用于工业-可节省时间" class="headerlink" title="流水线(计算)[运用于工业 可节省时间]"></a>流水线(计算)[运用于工业 可节省时间]</h3><p>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理事针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</p>
<p>执行一条指令分为 <strong>取指</strong> → <strong>分析</strong> → <strong>执行</strong></p>
<h6 id="未使用流水线执行指令情况"><a href="#未使用流水线执行指令情况" class="headerlink" title="未使用流水线执行指令情况"></a>未使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
<th>2</th>
<th></th>
<th></th>
<th>3</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
</tr>
</tbody></table>
<h6 id="使用流水线执行指令情况"><a href="#使用流水线执行指令情况" class="headerlink" title="使用流水线执行指令情况"></a>使用流水线执行指令情况</h6><table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>流水线周期<del>取指+分析+执行</del>为运算时间最长的一段</strong></li>
<li><strong><u>流水线运算时间</u>计算公式为：</strong><br><span style = "color : red"><strong>①条指令运算总时长 + (指令条数-1) × 流水线周期</strong></span><br>① 理论公式：**(t1 + t2 +…+ t<del>k</del>) + (n - 1) × △t**<br>② 实践公式：**(k + n-1) × △t**</li>
</ul>
<h6 id="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？"><a href="#若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1-ns。那么，流水线周期是多少？-100条指令全部执行完毕需要的时间是多少？" class="headerlink" title="若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？"></a>若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的实践分别是取指2ns，分析2ns，执行1,ns。那么，流水线周期是多少？ 100条指令全部执行完毕需要的时间是多少？</h6><table>
<thead>
<tr>
<th>取指</th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>.</strong></th>
<th><strong>.</strong></th>
<th><strong>n</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分析</strong></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
<td></td>
</tr>
<tr>
<td><strong>执行</strong></td>
<td></td>
<td></td>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>.</strong></td>
<td><strong>.</strong></td>
<td><strong>n</strong></td>
</tr>
</tbody></table>
<p>答：1.<u>周期最长的时间是2ns，所以流水线周期是2ns</u><del>每一个流水线的周期就会完成一条指令的运行</del><br>2.<strong>(2+2+1) + (100-1) × 2 &#x3D; 203</strong><del>理论公式①计算</del>  &#x2F;  <strong>[3<del>分三段</del>+ (100 - 1) ] × 2 &#x3D; 204</strong><del>实践公式②计算</del></p>
<ul>
<li><p><strong>流水线吞吐率计算</strong><br>是指在单位时间内流水线所完成的任务数量或输出的结果数量。</p>
<p>流水线吞吐率基本公式：<span style = "color : red"><strong>TP &#x3D; $\frac{指令条数}{流水线运算时间}$</strong></span><br>流水线最大吞吐率：<span style = "color : red"><strong>TP<del>max</del> &#x3D; Lim<del>n→∞</del>$\frac{n}{(k+n-1)△t}$&#x3D;$\frac{1}{△t}$</strong></span></p>
</li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D; 可以算出 TP &#x3D; $\frac{100}{203}$; TP<del>max</del> &#x3D;  $\frac{1}{2}$</p>
<ul>
<li><strong>流水线加速度比</strong><br>是指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比<br><span style = "color : red"><strong>S &#x3D; $\frac{不使用流水线执行时间}{使用流水线执行时间}$</strong></span></li>
</ul>
<p>&#x3D;&#x3D;<u><em>根据上述题目</em></u>&#x3D;&#x3D;<br>不使用流水线执行时间：(2+2+1) × 100 &#x3D; 500<del>ns</del><br>使用流水线执行时间：203<del>ns</del><br>S &#x3D; $\frac{500}{203}$</p>
<ul>
<li><strong>流水线的效率</strong><br>是指流水线的设备利用率。在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比<br><span style = "color : red"><strong>E &#x3D; $\frac{n个任务占用的时空区}{k个流水段总的时空区}$ &#x3D; $\frac{T<del>0</del>}{KT<del>k</del>}$</strong></span></li>
</ul>
<h6 id="入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出"><a href="#入-→-S1-△t-→-S2-△t-→-S3-△t-→-S4-3△t-→-出" class="headerlink" title="入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出"></a>入 → S1(△t) → S2(△t) → S3(△t) → S4(3△t) → 出</h6><blockquote>
<p>↑ 此方法效率不高，因为在S4所需要的时间太长，导致其他的会遭到空闲状态</p>
</blockquote>
<p>横轴是时间△t；纵轴是空间</p>
<table>
<thead>
<tr>
<th>S4</th>
<th></th>
<th></th>
<th></th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>2</th>
<th>2</th>
<th>3</th>
<th>3</th>
<th>3</th>
<th>4</th>
<th>4</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S3</strong></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S2</strong></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>S1</strong></td>
<td>1</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>n个任务占用的时空区：(△t + △t + △t + 3△t) × 4<br>k个流水段总的时空区：15△t × 4<br>E &#x3D; $\frac{(△t + △t + △t + 3△t) × 4}{15△t × 4}$</p>
<h2 id="层次化存储结构"><a href="#层次化存储结构" class="headerlink" title="层次化存储结构"></a>层次化存储结构</h2><p>容量最下层的最大 向上依次递减</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0a35815053da0e6c476e3a1dc86a1aa4bec7233f/data/%E5%B1%82%E6%AC%A1%E5%8C%96%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p>
<h3 id="Cache-—-概念"><a href="#Cache-—-概念" class="headerlink" title="Cache — 概念"></a>Cache — 概念</h3><p>Cache的功能：提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即<strong>CPU</strong>与<strong>存储系统</strong>间<u>数据传送带宽限制</u>。<br>在计算机的存储系统体系中，Cache是访问速度最快的层次<br>使用Cache改善系统性能的依据是程序的<strong>局部性原理</strong></p>
<p>如果以<u>h代表对Cache的访问命中率</u>，<u>t<del>1</del>表示Cache的周期时间</u>，<u>t<del>2</del>表示主存储器周期时间</u>，以读操作为例，使用”<strong>Cache + 主存储器</strong>“的系统的平均周期为t<del>3</del>，则 <span style = "color : red"><strong>t<del>3</del> &#x3D; h × t<del>1</del> + (1 - h) × t<del>2</del></strong></span>，其中(1-h)又称为失效率(未命中率)<br>若h&#x3D;95%, t<del>1</del>&#x3D;1ns, t<del>2</del>&#x3D;1ms&#x3D;1000ns  &#x3D;&#x3D;&#x3D;&gt;  t<del>3</del> &#x3D; 1ns × 95% + (1 - 95%) × 1000ns &#x3D; 50.95ns</p>
<blockquote>
<p>CPU在读取数据中首先对Cache中读取，如果读到了则表示对该数据的命中，如果Cache中没有我们需要的数据，CPU会在内存里去调</p>
</blockquote>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><blockquote>
<p>时间局部性<br>空间局部性(<u>适用于数组</u>)<br>工作集理论：工作集是进程运行时被频繁访问的页面集合<del>短时间不被替换成cache</del></p>
</blockquote>
<pre><code class="java">int i, s = 0;  ==&gt;  全局变量直接调用Cache
for(i = 1; i &lt; 1000; i++)   ==&gt; 在内存中循环100w次
    for(j = 1; j &lt; 1000; j++)
        s+=j;
cout &lt;&lt; s &lt;&lt; end;
</code></pre>
<h3 id="内存-外存"><a href="#内存-外存" class="headerlink" title="内存+外存"></a>内存+外存</h3><ul>
<li><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul>
<li>ROM<del>BIOS</del> 只读存储器<br>ROM-Read Only Memory只读存储器。断电后信息不丢失，如计算机启动用的BIOS芯片。<br>MROM(Mask ROM, 掩模式ROM)<br>PROM 可编程只读存储器<br>EPROM 可擦写可编程只读存储器<br>EEPROM 点可擦可编程只读存储器<br>Flash Memory 闪存 ≈ SSD</li>
<li>RAM随机存储器<br>DRAM(动态存储器) 不断刷新 速度比SRAM慢 价格低 常用于主存储器<br>SRAM(静态存储器 ) 不需刷新 速度比DRAM快 价格贵  cache属于SRAM<br> <u>CPU → <strong>Cache</strong> → 内存 → 外存</u></li>
</ul>
</li>
<li><h4 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h4><ul>
<li>硬盘：<strong>机械硬盘</strong>HDD(SATA、IDE、SCSI接口)    <strong>固态硬盘</strong>SSD(SATA接口)</li>
<li>光盘：CD&#x2F;VCD：650MB、CD-ROM(只读光盘)、CD-R(一次性写入、永久读)、CD-RW(可重复擦写光盘)<br>DVD：4.7GB、DVD-ROM、DVD-R、DVD-RW</li>
</ul>
</li>
</ul>
<h3 id="主存-—-编址"><a href="#主存-—-编址" class="headerlink" title="主存 — 编址"></a><strong>主存 — 编址</strong></h3><p><strong>8 × 4 位的存储器 &#x3D;&#x3D;&gt; 8个地址空间，每一个存储空间存储了4个bit位的信息</strong></p>
<table>
<thead>
<tr>
<th>000 这一存储空间</th>
<th>存放了4个</th>
<th>bit的</th>
<th>信息容量</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>010</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>011</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>110</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>111</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>@@ 内存地址从AC000H到C7FFFH，共有 <span style = "color : red"> <u><strong>1C000&#x2F; $2^{10}$</strong></u>&#x3D;112</span> <strong>K</strong>个地址单位<br>如果该内存地址按字(16bit)编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个内存单元，则该芯片每个存储单元存储  <span style = "color : red"><u><strong>4</strong></u></span> 位</p>
<blockquote>
<p>原理是后面地址-前面地址+1；  C7FFFH + 1 - AC000H &#x3D; 1C000H<br>K &#x3D; $2^{10}$B   &#x3D;&#x3D;&gt; 共有 1C000&#x2F; $2^{10}$&#x3D;112K 个地址单位</p>
<p>用一系列的芯片组成这样 <strong>112K×16<del>bit位</del></strong> 的内存块，需要28个芯片，每个芯片是16K个存储单元**$\frac{112K×16}{28×16K×a}$ &#x3D; 1**，比值是1因为用这些芯片去成立这个空间。解得a&#x3D;4</p>
</blockquote>
<h3 id="磁盘结构与参数"><a href="#磁盘结构与参数" class="headerlink" title="磁盘结构与参数"></a>磁盘结构与参数</h3><p><span style = "color : red"><strong>存取时间 &#x3D; 寻道时间 + 等待时间(平均定位时间 + 转动延迟)</strong></span><br>注意：<u><strong>寻道时间</strong></u>是指<strong>磁头</strong>移动到<strong>磁道</strong>所需的时间；<u><strong>等待时间</strong></u>为等待读写的<strong>扇区</strong>转到<strong>磁头</strong>下方所用的时间。</p>
<blockquote>
<ul>
<li>硬盘</li>
</ul>
<p><span style = "color : red">机械硬盘(<strong>HDD</strong>)</span>：存储介质 磁介质；参数：[主慈善]**磁(道)头数、柱面数、扇区(**硬盘的基本读写单位，大小是512B)；</p>
<p><strong>硬盘容量 &#x3D; 磁头数 * 柱面数 * 扇区数 * 512B</strong>；<br>性能指标：<u>存储容量、转速、访问时间、传输速率、缓存等</u>；<br>[硬盘内部结构按<strong>扇区、磁道、柱面</strong>的格式组织存储信息]</p>
<p>接口：SATA、<strong>IDE</strong>、SCSI、光纤通道</p>
<p><span style = "color : red">固态硬盘(<strong>SSD</strong>)</span>：存储介质(Flash Memory闪存) 接口 SATA等</p>
</blockquote>
<p>旋转的延迟时间是磁盘转一圈的时间</p>
<p>@@ 假设某磁盘的每个磁道划分成11个物理块，每块存放1个逻辑记录。逻辑记录R<del>0</del>，R<del>1</del>，…… ，R<del>9</del>，R<del>10</del>存放在同一个磁道上，记录的存放顺序如下表所示：</p>
<table>
<thead>
<tr>
<th>物理块</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑记录</td>
<td>R1</td>
<td>R2</td>
<td>R3</td>
<td>R4</td>
<td>R5</td>
<td>R6</td>
<td>R7</td>
<td>R8</td>
<td>R9</td>
<td>R10</td>
<td>R11</td>
</tr>
</tbody></table>
<p>如果磁盘的旋转周期为33ms，磁头当前处在R<del>0</del>的开始处。若系统使用单缓存区顺序处理这些记录，每个记录处理时间为3ms，则处理这11个记录的最长时间为<strong>366ms</strong>；若对信息存储进行优化分布后，处理11个记录的最少时间为<strong>66ms</strong></p>
<blockquote>
<p>一圈11个记录 转一圈33ms，则每个记录旋转的时间是3ms，读取一个记录的时间是3ms；告诉单缓存区，转到R0时处理R0需要3ms<del>因为是单缓存区，不能同时进行，必须等R0处理完成才能进入下一个任务处理[处理的途中磁盘仍在转动,磁头仍在向前]</del>，而一个记录正好也需要3ms，所以当处理完R0时，磁头已经到达了R2的位置，所以要再转一圈才能去处理R1，以此类推，除了最后一个R10就可以找到规律，<strong>把R0处理完，再等到指针走到R1的位置的时候转了<u>一圈加一条</u>记录的时间 &#x3D; [33+3] &#x3D; 36ms</strong>，以此类推R0 ~ R9都是这样处理的，所以处理R0~R9共需要 <strong>36ms × 10</strong>，最后一个R10，把它读取出来3ms，再处理完3ms。<strong>综上一共需要 (33+3)×10+6 &#x3D; 366ms</strong>；</p>
<p>优化处理：当处理完R0的时候，磁头正好下一位置是R1，而不用再去等它转动一个周期后；优化后的图为<strong>右侧图二</strong>！旋转+处理&#x3D;(3ms+3ms)×10<del>个</del>&#x3D;<strong>66ms</strong></p>
</blockquote>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>根据总线所处的位置不同，总线通常被分成三种类型，分别是：</p>
<h5 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h5><p>是指微机内部各个<strong>外围的芯片</strong>与<strong>处理器</strong>之间的总线 属于<u>芯片</u>级别</p>
<h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p>是指各个<strong>插件板</strong>和<strong>系统板</strong>之间的总线  属于<u>插件版</u>级别</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>数据总线(DB)</strong></u>&#x3D;&#x3D;：用来传输数据信息 双向传输</li>
<li>&#x3D;&#x3D;<u><strong>地址总线(AB)</strong></u>&#x3D;&#x3D;：用来传输数据地址 单向传输</li>
</ul>
<p>地址总线的位数决定了CPU可直接寻址的内存空间大小</p>
<p>若地址总线为n位，寻址空间为2的n次方个B，如微机的地址总线为16位，则最大寻址空间为64KB</p>
<ul>
<li>&#x3D;&#x3D;<u><strong>控制总线(CB)</strong></u>&#x3D;&#x3D;：用来传输控制信号</li>
</ul>
<h5 id="外部总线"><a href="#外部总线" class="headerlink" title="外部总线"></a>外部总线</h5><p>是指<strong>微机</strong>和<strong>外部设备</strong>的总线</p>
<h3 id="系统可靠性分析-—-串联系统与并联系统"><a href="#系统可靠性分析-—-串联系统与并联系统" class="headerlink" title="系统可靠性分析 — 串联系统与并联系统"></a>系统可靠性分析 — 串联系统与并联系统</h3><p>【<strong>串联</strong>】输入 → R1 → R2 → … → Rn → 输出<br><strong>R &#x3D; R1 × R2 × … × Rn</strong><br><strong>λ &#x3D; λ1 + λ2 + … + λn</strong></p>
<p>【<strong>并联</strong>】</p>
<blockquote>
<pre><code>     →R1
</code></pre>
<p>输入 →R2 → 输出<br>         →Rn</p>
</blockquote>
<p><strong>R &#x3D;  1 - (1 - R1) × (1 - R2) × … × (1 - Rn)</strong><br>**μ &#x3D; **$\frac{1}{\frac{1}{λ}\quad\sum_{j&#x3D;1}^{n}\frac{1}{j}}$</p>
<p>【<strong>模冗余系统与混合系统</strong>】</p>
<blockquote>
<p>​         →R1  →↓</p>
<p>输入 →R2   →     表决器  → 输出</p>
<p>​         →Rm →↑</p>
</blockquote>
<p>**R &#x3D; **$\quad\sum_{j&#x3D;1}^{n}{C{^j}{_m}×R{<em>0}{^i}(1-R</em>{0})^{m-i}}$</p>
<p>【<strong>串并联</strong>】</p>
<blockquote>
<p>​           |—  R  —|         |—R—|<br>—R —|—  R  —|—— |           |——<br>​           |—  R  —|         |—R—|</p>
</blockquote>
<p><strong>R×(1-(1-R$)^3$×(1-(1-R$)^2$))</strong></p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><h6 id="什么是码距？"><a href="#什么是码距？" class="headerlink" title="什么是码距？"></a>什么是码距？</h6><p>一个编码系统的码距是整个编码系统中任意(所有)两个码字的最小距离<br>例：<br>若用1位长度的二进制编码。若A&#x3D;1，B&#x3D;0。这样A,B之间的最小码距为1<br>若用2位长度的二进制编码。若以A&#x3D;11，B&#x3D;00为例，A,B之间的最小码距为2<br>若用3位长度的二进制编码。可选用111,000作为合法编码。A,B之间的最小码距为3<del>[检错可以进一步提高码距]</del></p>
<h6 id="码距与检错、纠错有何关系？"><a href="#码距与检错、纠错有何关系？" class="headerlink" title="码距与检错、纠错有何关系？"></a>码距与检错、纠错有何关系？</h6><p>① 在一个码组内为了检测e个误码, 要求最小码距d应该满足：d&gt;&#x3D;e+1<br>② 在一个码组内为了纠正 t个误码, 要求最小码距d应该满足：d&gt;&#x3D;2t+1</p>
<h3 id="校验码-—-循环冗余校验码CRC"><a href="#校验码-—-循环冗余校验码CRC" class="headerlink" title="校验码 — 循环冗余校验码CRC"></a>校验码 — 循环冗余校验码CRC</h3><h6 id="什么是模2除法？-异或运算相同为0-不同为1"><a href="#什么是模2除法？-异或运算相同为0-不同为1" class="headerlink" title="什么是模2除法？(异或运算相同为0,不同为1)"></a>什么是模2除法？(异或运算<del>相同为0,不同为1</del>)</h6><p>模2除法是指在做除法运算的过程中不计其进位的除法</p>
<blockquote>
<p>加0，多项式阶数为r(等于多项式位数减1)，则加r个0<br>eg：要发送数据1101011011，采用CRC校验，生成多项式10011(加四个0)，则最终发送数据为？<br>1101011011<strong>0000</strong> ÷ 10011 &#x3D;&gt; 采用异或运算<br>[待发送的信息补零 ÷ 多项式系数]<br>仅仅采用了CRC检验，如果检测到一个错误，则丢弃帧。缺重传机制，数据链路层的传输还不是可靠的传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/301330a9af198935e53042758004cd173c401f95/data/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%E7%A0%81.jpg"><br><span style = "color : red"><u>CRC编码 &#x3D; <strong>原始报文</strong> 后面补上 <strong>CRC校验码</strong></u></span><br><strong>注意：最后得到的位数必然是校验码位数，不够的需要补0</strong><br>这里得到的结果是11，但是需要凑位数，所以<strong>校验码&#x3D;0011</strong></p>
</blockquote>
<h3 id="校验码-—-海明校验码"><a href="#校验码-—-海明校验码" class="headerlink" title="校验码 — 海明校验码"></a>校验码 — 海明校验码</h3><p>求信息1011的海明码[<strong>$2^r$ ≥ 4<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong>]<br>①<strong>n+r</strong>个数 有 <span style = "color : red"><strong>$2^r$ ≥ n<del>信息位</del> + r<del>校验位</del> + 1<del>全部正确</del></strong></span>个错<br>确定校验码为3位：$2^3$ ≥ 4 + 3 + 1；分别放在$2^0$&#x3D;1、$2^1$&#x3D;2、$2^2$&#x3D;4 位<br><span style = "color : red">[校验位&#x2F;位置 $2^n$；奇偶校验(0√ 1×)；检验2位的错误, 纠正1位的错误]</span><br>② 列出校验位公式<br>7&#x3D;$2^2$+$2^1$+$2^0$，6&#x3D;$2^2$+$2^1$，5&#x3D;$2^2$+$2^0$，3&#x3D;$2^1$+$2^0$<br>$r_2$&#x3D;$I_4$⊕$I_3$⊕$I_2$<br>$r_1$&#x3D;$I_4$⊕$I_3$⊕$I_1$<br>$r_0$&#x3D;$I_4$⊕$I_2$⊕$I_1$<br>③ 根据公式得<strong>r<del>2</del>&#x3D;0，r<del>1</del>&#x3D;0，r<del>0</del>&#x3D;1</strong><br>④ 将数据加入表格</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>I<del>4</del></td>
<td>I<del>3</del></td>
<td>I<del>2</del></td>
<td></td>
<td>I<del>1</del></td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>r<del>2</del></td>
<td><strong>1</strong></td>
<td>r<del>1</del></td>
<td>r<del>0</del></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>信息位</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td>1</td>
<td>校验位</td>
</tr>
</tbody></table>
<blockquote>
<h6 id="求信息1010海明校验码"><a href="#求信息1010海明校验码" class="headerlink" title="@@ 求信息1010海明校验码"></a>@@ 求信息1010海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; 4+r+1&#x3D;&gt; r&#x3D;3   &#x3D;&#x3D;&gt; n+r&#x3D;4+3&#x3D;7 下列表画7列<br>$2^n $&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td>110</td>
<td>111</td>
<td>二进制</td>
</tr>
<tr>
<td>P<del>1</del>($2^0$)</td>
<td>P<del>2</del>($2^1$)</td>
<td><strong>1</strong></td>
<td>P<del>3</del>($2^2$)</td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td>校验位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>①001</th>
<th>②010</th>
<th>③011</th>
<th>④100</th>
<th>⑤101</th>
<th>⑥110</th>
<th>⑦111</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>1</strong> ↑</td>
<td><strong>0</strong> ↑</td>
<td>1</td>
<td>**1 **↑</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1<del>寻找位数二进制后尾是1的</del> &#x3D;&gt; ③⑤⑦ &#x3D;&gt; 1⊕0⊕0 &#x3D;&gt; 1<br>P2<del>第二位有1</del> &#x3D;&gt; ③⑥⑦ &#x3D;&gt; 1⊕1⊕0 &#x3D;&gt; 0<br>P3<del>最高位有1</del> &#x3D;&gt; ⑤⑥⑦ &#x3D;&gt; 0⊕1⊕0 &#x3D;&gt; 1<br>故海明码：101<strong>1010</strong></p>
</blockquote>
<blockquote>
<h6 id="求信息D8—D1的10101011海明校验码"><a href="#求信息D8—D1的10101011海明校验码" class="headerlink" title="@@ 求信息D8—D1的10101011海明校验码"></a>@@ 求信息D<del>8</del>—D<del>1</del>的10101011海明校验码</h6><p>$2^r$ ≥ n + r+ 1 &#x3D;&gt; n&#x3D;8, 解得r&#x3D;4; 一共要画8+4&#x3D;12列<br>r&#x3D;4 &#x3D;&#x3D;&gt; $2^n$&#x3D;$2^0$,$2^1$,$2^2$,$2^3$</p>
<table>
<thead>
<tr>
<th>⑫</th>
<th>⑪</th>
<th>⑩</th>
<th>⑨</th>
<th>⑧</th>
<th>⑦</th>
<th>⑥</th>
<th>⑤</th>
<th>④</th>
<th>③</th>
<th>②</th>
<th>①</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>1100</td>
<td>1011</td>
<td>1010</td>
<td>1001</td>
<td>1000</td>
<td>0111</td>
<td>0110</td>
<td>0101</td>
<td>0100</td>
<td>0011</td>
<td>0010</td>
<td>0001</td>
<td>二进制</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>P<del>4</del>($2^3$)</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>P<del>3</del>($2^2$)</td>
<td>1</td>
<td>P<del>2</del>($2^1$)</td>
<td>P<del>1</del>($2^0$)</td>
<td>校验位</td>
</tr>
</tbody></table>
<p>P1 &#x3D;&gt; ③⑤⑦⑨⑪ &#x3D;&gt; 1⊕1⊕1⊕0⊕0 &#x3D;&gt; 1<br>P2 &#x3D;&gt; ③⑥⑦⑩⑪ &#x3D;&gt; 1⊕0⊕1⊕1⊕0 &#x3D;&gt; 1<br>P3 &#x3D;&gt; ⑤⑥⑦⑫ &#x3D;&gt; 1⊕0⊕1⊕1 &#x3D;&gt; 1<br>P4 &#x3D;&gt; ⑨⑩⑪⑫ &#x3D;&gt; 0⊕1⊕0⊕1 &#x3D;&gt; 0<br>故海明校验码为：1010<strong>0</strong>101<strong>1</strong>1<strong>11</strong></p>
</blockquote>
<h3 id="操作系统基本原理"><a href="#操作系统基本原理" class="headerlink" title="操作系统基本原理"></a>操作系统基本原理</h3><h5 id="操作系统-—-概述："><a href="#操作系统-—-概述：" class="headerlink" title="操作系统 — 概述："></a>操作系统 — 概述：</h5><ul>
<li>管理系统的硬件、软件、数据资源</li>
<li>控制程序运行</li>
<li>人机之间的接口</li>
<li>应用软件与硬件之间的接口[API接口]</li>
</ul>
<p><strong>操作系统 — 管理职能：</strong></p>
<ul>
<li>进程管理<ul>
<li>进程的状态</li>
<li><strong>前趋图</strong></li>
<li><strong>PV操作</strong></li>
<li>死锁问题</li>
</ul>
</li>
<li>存储管理<ul>
<li><strong>段页式存储</strong></li>
<li>页面置换算法</li>
</ul>
</li>
<li>文件管理<ul>
<li>索引文件</li>
<li><strong>位示图</strong></li>
</ul>
</li>
<li>作业管理</li>
<li>设备管理</li>
<li>微内核操作系统<ul>
<li>虚设备与SPOOLING技术</li>
</ul>
</li>
</ul>
<p>所属范围：<strong>应用程序</strong>【<strong>语言处理程序</strong>{<strong>操作系统</strong>[计算机硬件]}】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/66ab60b30acd298347efc9b06e3be945f99ebeea/data/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="三态→五态，时间片轮转"></p>
<p><strong>进程管理 — 前趋图</strong></p>
<p>A:绞肉  B:切葱末  C:切姜末  D:搅拌  E:包饺子<br><strong>①</strong> A → B → C → D → E<br><strong>②</strong> A↘<br>     B → D → E<br>     C↗</p>
<p><strong>进程管理 — 进程的同步与互斥</strong></p>
<p><strong>互斥</strong>：千军万马过独木桥<br><strong>同步</strong>：(小明步行, 小红自行车从A到B点) 速度有差异，在一定情况停下等待<br><u>互斥反义词是共享，同步反义词是异步</u><br><strong><u>进程的互斥</u></strong>:是指当有若干个进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占用着释放了该资源。<br><strong><u>进程的同步</u></strong>:是指在并发进程之间存在这一种制约关系，一个进程依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才被唤醒。</p>
<h3 id="进程管理-—-PV操作"><a href="#进程管理-—-PV操作" class="headerlink" title="进程管理 — PV操作"></a>进程管理 — PV操作</h3><p>PV操作是一种实现进程互斥与同步的有效方法。PV操作与信号量的处理相关<br><strong>P表示通过的意思，V表示释放的意思</strong>。<br>P操作可以看作是<strong>获得</strong>或者<strong>请求、消耗</strong>一个信号量<br>V操作可以看作是<strong>释放</strong>或者<strong>发送</strong>一个信号量</p>
<blockquote>
<p><span style = "color : red">P操作会阻塞；</span><br><span style = "color : red">V操作会唤醒P操作；</span><br><span style = "color : red">P操作与V操作成对出现；</span></p>
<p>int f1&#x3D;0;   &#x2F;&#x2F;表示进程P1是否执行完毕</p>
<p>main()<br>{<br>    cobegin<br>    p1();</p>
<p>​    coend<br>}</p>
<p><strong>p1() {</strong><br>    <strong>…</strong><br>    <strong>v(f1);</strong><br>    <strong>v(f1);</strong><br><strong>}</strong></p>
</blockquote>
<p><strong>临界资源</strong>：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等。<br><strong>临界区</strong>：每个进程中访问临界资源的那段代码称为临界区<br><strong>信号量</strong>：信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</p>
<p><strong>P(S)操作：</strong>S-&#x3D;1  →  S&lt;0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行<br><strong>V(S)操作：</strong>S+&#x3D;1 →  S≤0  →<del>T</del>   进程队列 <strong>or</strong> →<del>F</del>向下进行</p>
<blockquote>
<p>P(S)、V(S)中的S就是信号量<br>T–进程操作阻塞（不会往下执行）<br>F–继续循环操作（执行下面的内容）</p>
</blockquote>
<h6 id="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"><a href="#单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0" class="headerlink" title="单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0"></a>单缓冲区生产者、消费者问题PV原语描述：S1初值1，S2初值0</h6><table>
<thead>
<tr>
<th>生产者：(先执行)</th>
<th>消费者：</th>
</tr>
</thead>
<tbody><tr>
<td>生产一个产品；</td>
<td><strong>P</strong>(S2);   [S2&#x3D;0]</td>
</tr>
<tr>
<td><strong>P</strong>(S1);   [S1&#x3D;0, S1&#x3D;-1]</td>
<td>从缓冲区取产品;</td>
</tr>
<tr>
<td>送产品到缓冲区;</td>
<td><strong>V</strong>(S1);</td>
</tr>
<tr>
<td><strong>V</strong>(S2);   [S2&#x3D;1]</td>
<td>消费产品;</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dfaac2ea85671c477f9008c1aa3dc70b68012a90/data/PV%E6%93%8D%E4%BD%9C%E4%BE%8B%E9%A2%98.png"></p>
<p>付款要双方的配合，会有同步的关系；假设没有这个操作；若先进行收银员操作，则没有购书者先购书，收银员无法操作。此时b1有个P操作，P操作需要付款V操作来唤醒；所以一开始的PV是同一信号量P(S1), V(S1)；对于购书者有个等待阻塞操作，等待收银员P(S2), V(S2)。【V(S1)唤醒P(S1)，收费后由收银员的V(S2)唤醒付款的P(S2)】<br>n+1个人进来的话会被阻塞。</p>
<blockquote>
<p>注意：<br>①P操作具备阻塞的职能，V操作不具备阻塞能力。<br>②PV操作关键要找到约束，找到谁是因变量，谁是自变量，谁约束谁。【PV操作是成对出现的】<br>③一对儿PV操作信号量是相同的。<br>看题发现已经存在了一对PV操作，信号量为Sn，Sn的值为n，很容易想到这对PV操作的作用就是控制进入书店的人数的。当人数达到n了，阻止人继续进入书店，这种状态直到有人付款离开书店为止。</p>
<p>再来看题发现还有两对PV操作，首先通过图能知道购书者和收银员之间存在约束关系，收银员要等待购书者付款才能工作，购书者要等待收银员反馈才能离开书店。那么这两对PV操作就是控制这个约束的。</p>
<p>先从购书者分析，购书者开始付款了，收银员才能开始收款，所以a1与b1之间是一对PV操作，进一步分析，如果没有购书者付款，那么收银员是不能执行收款操作的，也就是说收银员进程应该及时阻塞，故b1应该是P（S1）,a1应该是V（S1）。</p>
<p>购书者发起付款操作的时候，不能马上离开书店，因为他要等收银员的反馈，付款成功拿到 小票才能离开，也就是说购书者在等待收银员反馈的时候应该及时阻塞住，故a2与b2之间是一对PV操作，且a2是P（S2），对应的b2就是V（S2）。</p>
<p>再检查一遍看看是否合理呢？</p>
<p>从收银员角度开始，假设没有人付款，P操作能及时阻塞，使得收银员进程不会进入收费状态，所以b1位置放P操作没有问题，进一步分析信号量S1的初始值应该为0，经过b1后S1为-1，阻塞。</p>
<p>从购书者角度看，开始付款的时候激活收银员进程，所以a1是V操作也没有问题，通过a1的操作，S1信号量又为0了，收银员进程可以进行收费了。</p>
<p>再返回收银员角度，收费完毕后要给购书者信号，购书者从才能离开，所以b2为V操作没有问题。</p>
<p>从购书者角度看，a2应该是P操作，应该及时阻塞住。进一步分析，S2信号量也应该是0才符合要求。</p>
<p>😁总结<br>PV操作从做题的角度出发，我认为首先要找到约束关系，就是谁和谁是一对约束，第二步确定这对约束谁是P谁是V（用反证方法推一下看看），最后一步考虑信号量，信号量为多少取决于是否马上阻塞还是说执行几次后再阻塞，这个要结合具体问题具体分析。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">(53条消息) 软考必考题型之PV操作_pv操作中p和v各代表什么_du-hyper的博客-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42539194/article/details/129647813?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-129647813-blog-88802580.235%5Ev35%5Epc_relevant_increate_t0_download_v2&utm_relevant_index=6">(53条消息) 软考–快速掌握操作系统的PV操作_pv操作 软考_韦_恩的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f6094b2857a22777d38b9ed2362cf00c60b926a6/data/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86PV%E6%93%8D%E4%BD%9C.jpg"></p>
<p>箭头的起始位置是V操作，箭头的终止位置是P操作</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/45ad39c827d6c05d3e7d27552d3fd1a7313a574c/data/PV%2B%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%A4%A7%E9%A2%98.jpg"></p>
<h3 id="进程管理-—-死锁问题"><a href="#进程管理-—-死锁问题" class="headerlink" title="进程管理 — 死锁问题"></a>进程管理 — 死锁问题</h3><h6 id="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"><a href="#进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。" class="headerlink" title="进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。"></a>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</h6><p>资源都被分配且无法得到资源释放</p>
<p>例题：系统有3个进程：A、B、C。这3个进程都需要5个系统资源。如果系统至少有多少个资源，则不可能发生死锁[<u>有多少资源 无论怎么分配都不会产生死锁</u>]</p>
<table>
<thead>
<tr>
<th align="center">进程A</th>
<th align="center">进程B</th>
<th align="center">进程C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong><span style = "color : red">如果每个进程需要n个资源，总共有k个进程 &#x3D;&gt;分配情况：k × (n-1) + 1</span></strong><br>答：每个进程都需要5个资源，共有3个进程 &#x3D;&gt; n &#x3D; 5; k &#x3D; 3 &#x3D;&#x3D;&gt; 3 × (5 - 1) + 1 &#x3D; 12+1 &#x3D;13<br><img src="https://raw.githubusercontent.com/P-luminary/images/b65167c6d6f03ed5726ddd517ab0e89ec0df46c9/data/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98.jpg"></p>
<p>打破<strong>互斥</strong>：让大家同时共享资源<br>打破<strong>保持和等待</strong>：得不到相应的资源就会把资源分享出去，不会霸占并等待别人给与<br>打破<strong>不剥夺</strong>：不去抢别人分配到的资源</p>
<h4 id="银行家算法：分配资源的原则"><a href="#银行家算法：分配资源的原则" class="headerlink" title="银行家算法：分配资源的原则"></a>银行家算法：分配资源的原则</h4><p>√ 当一个进程对资源的最大需求量<strong>不超过</strong>系统重的资源数时可以接纳该进程<br>√ 进程可以<strong>分期请求</strong>资源，但请求的总数不能超过最大需求量<br>√ 当系统现有的资源不能满足尚需资源数时，对进程的请求可以<strong>推迟分配</strong>，但总能使进程在有限的时间里得到资源</p>
<p><strong>@@</strong> 例：假设系统中有三类互斥资源<strong>R1、R2、R3</strong>，可用资源数分别是<strong>9、8、5</strong>。在T<del>0</del>时刻系统中有<strong>P1、P2、P3、P4、P5</strong>五个进程，这些进程对资源的最大需求量和已分配资源数如下所示，如果进程按<strong>？</strong>序列执行，那么系统状态是安全的<del>不发生死锁</del><br>【列表口诀：<strong>现</strong> <strong>需要</strong> <strong>已</strong>(<u>蚁</u>)<strong>精</strong>(经)子来分娩】<br><strong>剩下的资源</strong>：总资源 — 已分配资源</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c9c14e04f67a7fd291fa566beaa4b0ee4506bb2/data/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98.jpg"></p>
<p>A. P1→P2→P4→P5→P3                    <strong>B. P2→P4→P5→P1→P3</strong><br>C. P2→P1→P4→P5→P3                    D. P4→P2→P4→P1→P3</p>
<ul>
<li>若先不执行P2，先执行P1，则右图R1还需资源数还需要5个，则你R1剩下的2个不够分配到，会发生进程死锁。即第一个先执行 P2。</li>
<li>若先执行P2，再执行P1，则我们发现进程P1需要R1资源为5，我们能提供的R1资源为4，所以序列无法进行下去，为不安全序列<br>【<span style = "color :red">只要<strong>现有资源</strong>可以满足<strong>需要资源</strong>的分配即可True，执行完后释放资源给下一步进程使用</span>】</li>
</ul>
<h3 id="存储管理-—-分区存储组织"><a href="#存储管理-—-分区存储组织" class="headerlink" title="存储管理 — 分区存储组织"></a>存储管理 — 分区存储组织</h3><p>某计算机系统的内存大小为128k，采用可变分区分配进行内存分配，当前系统的内存分块情况如下图所示，现有<strong>作业4</strong>申请<strong>内存9k</strong>，几种不同的存储分配算法在分配中，会产生什么样的结果呢？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31409e62be82acbe02077d84d12e51f146d9948e/data/%E6%9C%80%E4%BD%B3-%E6%9C%80%E5%B7%AE-%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.png"></p>
<p><strong>最佳适应算法</strong>：分配任务空间时。任务由闲余空间从小到大依次尝试是否能成功分配。若小闲余空间能分配就分配。不可则进入下一个闲余空间进行空间区域切割划分。<strong>缺陷</strong>：内存的碎块(<u>几k的闲余空间</u>)；<br><u><strong>最差适应算法</strong></u>：则逆过来表示(先考虑从大的块中分配出来)<br><strong>循环首次适应法</strong>：(分配较均匀)</p>
<h3 id="存储管理-—-页式存储组织"><a href="#存储管理-—-页式存储组织" class="headerlink" title="存储管理 — 页式存储组织"></a>存储管理 — 页式存储组织</h3><p><strong>逻辑地址</strong>的<strong>页号</strong>对应<strong>物理地址</strong>的<strong>块号</strong>(通过查表可得出)；其<strong>页内地址</strong>都是一样的(调用的时候以页为单位, 偏移量不会有太大的变化)</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4ac7b79184178af545b460f5427fe9c9cd5cb9c5/data/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>例：进程P有6个页面，页号分别为0-5，页面大小为4K，页面转换表如下所示。表中<u>状态位等于<strong>1</strong>和<strong>0</strong>分别表示页面在<strong>内存</strong>和<strong>不在内存</strong></u>。假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制(<strong>6A29H</strong>)；如果进程P要访问的页面4不在内存，那么应该淘汰页号为(<strong>1</strong>)的页面。</p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">页帧号</th>
<th align="center">状态位</th>
<th align="center">访问位</th>
<th align="center">修改位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">一</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>5</strong></td>
<td align="center"><strong>6</strong></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>(1) A. 1A29H        B. 3A29H        C. 5A29H        D. 6A29H<br>(2) A. 0                  B. 1                  C. 2                 D. 5</p>
<p>4k &#x3D; 4×1024 &#x3D; 2$^{2+10}$ &#x3D; $2^{12}$ 说明一个页内地址是12位，高于12位的就是页号<br>由于进制P要访问的逻辑地址是十六进制5A29H，则一个十六进制位 &#x3D; 4个二进制位<br>说明有3个位是页内地址 &#x3D;&gt; A 2 9；所以页内地址无需求，是为A29<br>页号5需要查表观测它的页帧号是6；然后与后面拼接起来 为6A29H<br>将要淘汰的页号一定是在存在的里面选出 存在的才能淘汰，则1代表存在；<br>就要从页号0 1 2 5中淘汰一个，看其访问位，刚刚访问过的是1不能淘汰，<br>只能淘汰访问位是0的，综上所述，应该淘汰1页号</p>
<h3 id="存储管理-—-段式存储组织"><a href="#存储管理-—-段式存储组织" class="headerlink" title="存储管理 —  段式存储组织"></a>存储管理 —  段式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/540c15f503aa3e817771ddb1ace41a4d15c66015/data/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<h3 id="存储管理-—-段页式存储组织"><a href="#存储管理-—-段页式存储组织" class="headerlink" title="存储管理 — 段页式存储组织"></a>存储管理 — 段页式存储组织</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/46c912294b0428ab3464f49e504e47de54ea3e01/data/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87.png"></p>
<p>先查段表 查完段表 查页表</p>
<h3 id="存储管理-—-快表"><a href="#存储管理-—-快表" class="headerlink" title="存储管理 — 快表"></a>存储管理 — 快表</h3><p><strong>快表</strong>是一块小容量的相联存储器(Associative Memory), 由高速缓存器组成，速度快，并且可以从硬件上保证<strong>按内容</strong>并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。<br>若将这些东西放在内存当中则称为慢表(放在内存)、快表(放在Cache)</p>
<h3 id="存储管理-—-页面置换算法-运用于分层的置换体系中"><a href="#存储管理-—-页面置换算法-运用于分层的置换体系中" class="headerlink" title="存储管理 — 页面置换算法(运用于分层的置换体系中)"></a>存储管理 — 页面置换算法(运用于分层的置换体系中)</h3><h5 id="页面淘汰算法"><a href="#页面淘汰算法" class="headerlink" title="页面淘汰算法"></a>页面淘汰算法</h5><h6 id="☆-最优-Optimal-OPT-算法"><a href="#☆-最优-Optimal-OPT-算法" class="headerlink" title="☆ 最优(Optimal, OPT) 算法"></a>☆ 最优(Optimal, OPT) 算法</h6><h6 id="☆-随机-RAND-算法"><a href="#☆-随机-RAND-算法" class="headerlink" title="☆ 随机(RAND) 算法"></a>☆ 随机(RAND) 算法</h6><h6 id="★-先进先出-FIFO-算法：有可能产生”抖动”"><a href="#★-先进先出-FIFO-算法：有可能产生”抖动”" class="headerlink" title="★ 先进先出(FIFO) 算法：有可能产生”抖动”"></a>★ 先进先出(FIFO) 算法：有可能产生”抖动”</h6><p>抖动：给你更多的资源去处理反而效率降低了<br>例如432143543215序列用3个页面，比4个缺页要少<br><strong>缺页</strong>：当加入内存中的页面序列是全新版本(内存中没有)，则内存内部需要这个版本，因为缺少这个版本<br>第八-九列 编号为4的程序页不缺页(没有往前推进的原因是因为内存中还存有4的残渣[第八列]；有3的残渣[第九列])</p>
<table>
<thead>
<tr>
<th align="center">(9次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">(10次)</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">缺页</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong>横向</strong>代表：访问的页面序列<br><strong>纵向</strong>代表：内存的几号页面(第一列是编号为4的程序页)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0f77ce658d321b83bdd0b8da87d540cf660ed92/data/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png"><u><strong>LRU</strong></u>：<strong>最近被访问的则不需要被淘汰，淘汰掉最久没有被访问到的</strong><br><u><strong>FIFO</strong></u>：先入先出原则</p>
<h6 id="★-最近最少使用-LRU-算法：不会”抖动”"><a href="#★-最近最少使用-LRU-算法：不会”抖动”" class="headerlink" title="★ 最近最少使用(LRU) 算法：不会”抖动”"></a>★ 最近最少使用(LRU) 算法：不会”抖动”</h6><p>根据局部性原理，刚刚访问过的资源是不会被淘汰出去的</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dcaa41c594fe86047d0f9cbc03a4e3c24c5e9fc/data/%E9%A1%B5%E9%9D%A2%E5%9E%84%E6%96%AD%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<p> <span style = "color : red"><strong>每读一次程序块，先在内存上面查一下表之后读取相应的内存块，所以每一个内存块需要进行两次内存的访问。总共有⑥个块，会产生12次内存的访问</strong></span></p>
<p>A块在2号页有一半，在3号页面也有一半。所以总的缺页次数是5次；<strong>对于指令而言</strong><del>无论占用几个块都会一次性调用</del>不会产生两次垄断，只有一次缺页垄断；∴swap A,B 一次；A上半页一次, 下半页一次；B上半页一次, 下半页一次；1+2+2&#x3D;5次；1k有1024个单元(字节)</p>
<h3 id="文件管理-—-索引文件结构"><a href="#文件管理-—-索引文件结构" class="headerlink" title="文件管理 — 索引文件结构"></a>文件管理 — 索引文件结构</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da6db0bd7d31c5a4b548e3631be05912cdbf38ec/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86.jpg"></p>
<p>一个物理盘块是1K大，一个地址4Byte，除一下，每一个盘块可以存256个地址;    ↓ ↓ ↓ ↓ ↓ ↓</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cebe816153cc666243ca77883f86b9ace46c311/data/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<p>File1的信息是<strong>二级地址索引表</strong> </p>
<h3 id="操作系统-—-文件和树型目录结构"><a href="#操作系统-—-文件和树型目录结构" class="headerlink" title="操作系统 — 文件和树型目录结构"></a>操作系统 — 文件和树型目录结构</h3><p><strong>文件属性</strong>：R 只读文件属性    A 存档属性    S 系统文件    H 隐藏文件<br><strong>文件名的组成</strong>：驱动号、路径、主文件名、扩展名<br><strong>绝对路径</strong>：是从盘符开始的路径<br><strong>相对路径</strong>：是从当前路径开始的路径<br>若当前目前位：D1，要求F2路径<br>则：<u>绝对路径</u>：&#x2F;D1&#x2F;W1&#x2F;F2； <u>相对路径</u>：W2&#x2F;F2</p>
<h3 id="文件管理-—-空闲存储文件的管理"><a href="#文件管理-—-空闲存储文件的管理" class="headerlink" title="文件管理 — 空闲存储文件的管理"></a>文件管理 — 空闲存储文件的管理</h3><p>空闲区表法(空闲文件目录)、空闲链表法、**<span style = "color : red">位示图法</span>**、成组链接法</p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/b80648caa2ce4c11344f2775ce62ebd4b7af9161/data/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%BE%8B%E9%A2%98.jpg"></p>
<p>(1) (4195+1) &#x2F; 32 &#x3D; 131.125 ≈ 第132字<br>(2) 用物理块毫无疑问是要制成1的 所以AC排除，131×32&#x3D;4192 (0→4191)，故第132字中：<br>第0位置→4192   第1位置→4193  第2位置→4194  <strong>第3位置→4195</strong><br><span style = "color : red"><strong>第多少个字是从1开始算, 多少位置是从第0个位置开始算。</strong></span></p>
<blockquote>
<p>第1字         1 0 1 0 0 … 1 1<br>第2字         0 1 1    0 … 0 1<br>第3字         1 1 1 1 0 … 1 0<br>…                …<br>第n字         0 0 0 1 1 … 0 0</p>
</blockquote>
<h3 id="设备管理-—-数据传输控制方式"><a href="#设备管理-—-数据传输控制方式" class="headerlink" title="设备管理 — 数据传输控制方式"></a>设备管理 — 数据传输控制方式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d7d10e539675e94eff1c9c90dcb66f52e6ca4cfb/data/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png"></p>
<h3 id="设备管理-—-虚设备与SPOOLING技术"><a href="#设备管理-—-虚设备与SPOOLING技术" class="headerlink" title="设备管理 — 虚设备与SPOOLING技术"></a>设备管理 — 虚设备与SPOOLING技术</h3><p>要输出输入的先缓存起来(输入井 输出井)<br><img src="https://raw.githubusercontent.com/P-luminary/images/3d1b4c80871fa1aaf9cb194667a35cd042f75d8c/data/SPOOLING%E6%8A%80%E6%9C%AF.jpg"></p>
<h3 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/79a58babdadddeef05bc5890cacd0f3a27dd0d4b/data/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"></p>
<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><span style = "color : red">数据库系统</span></h1><h3 id="三级模式-—-两级映射"><a href="#三级模式-—-两级映射" class="headerlink" title="三级模式 — 两级映射"></a>三级模式 — 两级映射</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/896dd865381624663248207420b70d53681437e2/data/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E2%80%94%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84.jpg"></p>
<p><strong>内模式</strong>：管我们如何去存储这些数据 也叫存储模式，对应于<u>物理级</u><br>概念模式：表之间有一定的关联 逻辑模式 对应<u>概念级</u><br><strong>外模式</strong>：对应着数据库里的视图(对数据更灵活的控制) 子模式或用户模式，对应<u>用户级</u><br>期间都存在着映射(起到逻辑独立性&#x2F;物理独立性)</p>
<blockquote>
<p>什么是外模式？<br>    1）数据库的用户使用的局部数据的逻辑结构和特征的描述<br>    2）数据库用户的数据视图，是与某一应用程序有关的数据的逻辑表示。（如应用程序A只能看见其相对于的外模式1，应用程序B只能看见其相对于的外模式2，不能看见不属于自己的外模式。相当于是模式的一个子集）</p>
<p>外模式的地位：介于模式与应用之间。</p>
<p>模式与外模式的关系：一对多<br>    1）外模式是模式的子集<br>    2）一个数据库可以有多个外模式，反应了不同的用户的应用需求、看待数据的方式、对数据保密的要求。<br>    3）对于模式中的同一个数据，不同外模式可以对数据的长度、类型等有不同的定义。</p>
<p>外模式与应用的关系：一对多。<br>    1）同一外模式可以为某一个用户的多个应用系统所使用<br>    2）但一个应用程序只能使用一个外模式</p>
<p>外模式的用途：<br>    1）保证数据库安全，每个用户只能看见自己对应外模式的数据<br>    2）保证数据独立性。</p>
<h4 id="总结-外模式是模式的一部分，是部分用户看到的数据库的样子。"><a href="#总结-外模式是模式的一部分，是部分用户看到的数据库的样子。" class="headerlink" title="总结:外模式是模式的一部分，是部分用户看到的数据库的样子。"></a><span style = "color : red"><strong>总结:外模式是模式的一部分，是部分用户看到的数据库的样子。</strong></span></h4></blockquote>
<blockquote>
<p>内模式：<br>    1）数据物理结构和存储方式的描述<br>    2）是数据在数据库内部的表示方式<br>    Ⅰ.记录的存储方式：如顺序存储，按B树结构存储，Hash存储）<br>    Ⅱ.索引的组织方式：B+树索引，hash索引，Join index索引<br>    Ⅲ.数据是否压缩存储<br>    Ⅳ.数据是否加密<br>    注：一个数据库只有一个内模式。</p>
<h4 id="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"><a href="#总结：内模式处于最底层，是对数据在数据库底层的存储的描述。" class="headerlink" title="总结：内模式处于最底层，是对数据在数据库底层的存储的描述。"></a><span style = "color : red"><strong>总结：内模式处于最底层，是对数据在数据库底层的存储的描述。</strong></span></h4></blockquote>
<h4 id="数据库特点："><a href="#数据库特点：" class="headerlink" title="数据库特点："></a>数据库特点：</h4><p>数据结构化、数据的共享、冗余度低、<strong>数据独立性高</strong>、数据由<strong>DBMS</strong>统一管理和控制</p>
<h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cd0bd56ba2d79a742db12fc000df23ed6ed69281/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bf4edf231e68e25885a3339134cf79b21cf74c8/data/E-R%E6%A8%A1%E5%9E%8B.jpg"></p>
<p> <strong>概念模型</strong> 面向用户 用户角度出发 用户分析<br> <strong>逻辑结构&#x2F;模型</strong><br> <strong>物理结构&#x2F;模型</strong>(数据库对象) 跟计算机系统发生联系</p>
<p>主码：[也称住关键字，它能够唯一标识一个元组。码可以是一个属性或属性组]</p>
<p><strong>框框</strong>表示<strong>实体</strong>[客观存在并相互区别的事物]<br><strong>椭圆</strong>表示<strong>属性</strong>[实体所具有的特征]<br><strong>菱形</strong>表示<strong>联系</strong>[实体与实体之间的关系]<br>域：属性值的取值范围<br>实体型：用实体名及其属性名集合来描述同类实体也称为实体型 <strong>学生(<u>学号</u>, 姓名, 性别</strong>)<br>实体之间有各种各样的连信息(一对一联系1:1、一对多联系1:n、多对多联系m:n)</p>
<p>1个学生对应N个课程，1个课程对应M个学生；所以学生和课程是N:M的关系</p>
<h5 id="集成的方法："><a href="#集成的方法：" class="headerlink" title="集成的方法："></a>集成的方法：</h5><p>多个局部E—R图一次集成<br>逐步集成，用累加的方式一次继承两个局部E—R图</p>
<h5 id="集成产生的冲突及解决办法："><a href="#集成产生的冲突及解决办法：" class="headerlink" title="集成产生的冲突及解决办法："></a>集成产生的冲突及解决办法：</h5><p>属性冲突：包括属性域冲突和属性取值冲突<br>命名冲突：包括同名异义和异名同义<br>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E—R图中所包含的属性个数和属性排列次序不完全相同</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d8bb3486b6917b13f8c21e6c42f0f0ffb0fa797/data/E-R%E6%A8%A1%E5%9E%8B1.png"></p>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><h6 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h6><blockquote>
<p><strong>并 交 差 笛卡尔积 投影 选择 联接</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7999126ac896482aa27e523291f7266c74684484/data/%E5%B9%B6%20%E4%BA%A4%20%E5%B7%AE%20%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%20%E6%8A%95%E5%BD%B1%20%E9%80%89%E6%8B%A9%20%E8%81%94%E6%8E%A5.png"></p>
<h4 id="★★★★-考点-★★★★"><a href="#★★★★-考点-★★★★" class="headerlink" title="★★★★ 考点 ★★★★"></a><span style = "color : red">★★★★ 考点 ★★★★</span></h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/49278f5b4160686cf7931eeabcc2ffecca3f9b68/data/%E7%AC%9B%E5%8D%A1%E5%B0%94%E5%92%8C%E8%87%AA%E7%84%B6%E8%81%94%E6%8E%A5.png"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="规范化理论—函数依赖"><a href="#规范化理论—函数依赖" class="headerlink" title="规范化理论—函数依赖"></a>规范化理论—函数依赖</h3><p> <img src="https://raw.githubusercontent.com/P-luminary/images/51a6a949e29af7425b4db2467e3cea8b9d472cb2/data/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg"></p>
<h3 id="规范化理论—价值与用途"><a href="#规范化理论—价值与用途" class="headerlink" title="规范化理论—价值与用途"></a>规范化理论—价值与用途</h3><p>非规范化的关系模式，可能存在的问题包括：<strong>数据冗余，更新异常，插入异常，删除异常</strong></p>
<p><strong>超键</strong>可能<u>存在</u>冗余属性<br><strong>候选键</strong><u>不存在</u>冗余属性</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eba44424461fb41231f3a2033809728876107800/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E2%80%94%E9%94%AE.jpg"></p>
<h3 id="规范化理论—求候选键"><a href="#规范化理论—求候选键" class="headerlink" title="规范化理论—求候选键"></a>规范化理论—求候选键</h3><p>√ 将关系模式的函数依赖关系用”<span style = "color : red"><strong>有向图</strong></span>“的方式表示<br>√ 找<span style = "color : red"><strong>入度为0</strong></span>的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键<br>√ 若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些<span style = "color : red"><strong>中间结点</strong></span>(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/fedbdbd44be93aebd7ee7900ac880b9bbf416ad6/data/%E6%B1%82%E5%80%99%E9%80%89%E9%94%AE%E5%AE%9E%E4%BE%8B.jpg" style="zoom:200%;" />



<h3 id="规范化理论—范式"><a href="#规范化理论—范式" class="headerlink" title="规范化理论—范式"></a>规范化理论—范式</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7c4039b8889ccba887966fa6a9419576d19fb759/data/%E8%8C%83%E5%BC%8F.png"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/d909de9417c222c51a54a62215b672b44c27c50b/data/%E7%AC%AC%E4%B8%80%E4%BA%8C%E4%B8%89%E8%8C%83%E5%BC%8F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E.jpg"  />



<p><strong>主属性</strong>(SNO CNO)：属性属于候选键的一部分 (在任何一个<strong>候选关键字</strong>里出现过的都是<strong>主属性</strong>)<br>没有<strong>非主属性</strong> 肯定满足<strong>第二范式</strong>和<strong>第三范式</strong></p>
<p> <img src="https://raw.githubusercontent.com/P-luminary/images/4d428c01728bc74188f07efc4e3ccdf9c7477f1f/data/b-C%E8%8C%83%E5%BC%8F.jpg"></p>
<h3 id="规范化理论—综合例题"><a href="#规范化理论—综合例题" class="headerlink" title="规范化理论—综合例题"></a>规范化理论—综合例题</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5d9b49971208e067131389f48c469365519fdad6/data/%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA%E7%BB%BC%E5%90%88%E4%BE%8B%E9%A2%98.png"  />



<h3 id="规范化理论—模式分解"><a href="#规范化理论—模式分解" class="headerlink" title="规范化理论—模式分解"></a>规范化理论—模式分解</h3><p>当范式级别不够的时候把模式进行拆分 这样范式级别就可以上升<br><img src="https://raw.githubusercontent.com/P-luminary/images/8de9f7295722d81e08fbcd3d1d5e24ab6b1c61cc/data/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3.png"  /></p>
<h3 id="并发控制—基本概念"><a href="#并发控制—基本概念" class="headerlink" title="并发控制—基本概念"></a>并发控制—基本概念</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6fcaefdeb1c71e5d4f06a4792ef956c1ed146d3c/data/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png"></p>
<h3 id="数据库完整性约束"><a href="#数据库完整性约束" class="headerlink" title="数据库完整性约束"></a>数据库完整性约束</h3><p><strong>√ 实体完整性约束</strong>：约束主键(<u>主键为空 没有输入具体值</u>)<br><strong>√ 参照完整性约束</strong>：填入的数据必须是按照表里主键的内容(允许为空)<br><strong>√ 用户自定义完整性约束</strong>：(年龄不允许输入负数 或者200以上的值)</p>
<p>√ <strong>触发器</strong>(较复杂的要求)：可以写脚本来约束数据库数据的要求</p>
<h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><table>
<thead>
<tr>
<th>措施</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>用户标识和鉴定</td>
<td>最外层的安全保护措施，可以使用用户账户，口令及随机数检验等方式</td>
</tr>
<tr>
<td>存取控制</td>
<td>对用户进行授权，包括操作类型(如<strong>查找, 插入, 删除, 修改</strong>等动作)和数据对象(主要是<strong>数据范围</strong>)的权限</td>
</tr>
<tr>
<td>密码存储和传输</td>
<td>对远程终端信息用密码传输</td>
</tr>
<tr>
<td>视图的保护</td>
<td>对视图进行授权</td>
</tr>
<tr>
<td>审计</td>
<td>使用一个专用文件(日志)或数据库，自动将用户对数据库的所有操作记录下来</td>
</tr>
</tbody></table>
<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p><strong>√ 冷备份</strong>也称为静态备份，是将数据库正常关闭，在停止状态，将数据库的文件全部备份(复制)下来。<br><strong>√ 热备份</strong>也称为动态备份，是利用备份软件，在数据库正常运行的状态下，将数据库中的数据文件备份出来 </p>
<table>
<thead>
<tr>
<th align="left">备份方式 &#x2F; 优缺点</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冷备份</td>
<td align="center">非常快速的备份方法只需要复制文件；容易归档(简单复制即可)；容易恢复到某个时间点上(只需要将文件再复制回去)；能与归档方法相结合，做数据库”最佳状态“的恢复；低度维护，高度安全</td>
<td align="center">单独使用时，只能提供到某一个时间点上的恢复；再实施备份的全过程中，数据库必须要作备份二不能做其他工作；若磁盘空间有限只能复制到磁带等其他外部存储设备上，速度会很慢；不能按表或按用户恢复</td>
</tr>
<tr>
<td align="left">热备份</td>
<td align="center">可再表空间或数据库文件级备份，备份的时间短；备份时数据库仍可使用；可达到秒级恢复(恢复到某一时间点上)；可对几乎所有数据库实体做恢复；恢复是快速的</td>
<td align="center">不能出错，否则后果严重；如我热备份不成功所得结果不可用于时间点的恢复；因难于维护，所以要特别小心，不允许”以失败告终“</td>
</tr>
</tbody></table>
<p><strong>√ 完全备份：</strong>备份所有数据<br><strong>√ 差量备份：</strong>仅备份上一次完全备份之后变化的数据<br><strong>√ 增量备份：</strong>备份上一次备份之后变化的数据</p>
<table>
<thead>
<tr>
<th align="center">日</th>
<th align="center">一</th>
<th align="center">二</th>
<th align="center">三</th>
<th align="center">四</th>
<th align="center">五</th>
<th align="center">六</th>
</tr>
</thead>
<tbody><tr>
<td align="center">完</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">增</td>
<td align="center">差</td>
<td align="center">增</td>
<td align="center">增</td>
</tr>
</tbody></table>
<p>若在周一的增量备份后系统出现故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一增量版</strong><br>如果周三的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周一周二周三增量版</strong><br>这样恢复太麻烦，所以提出了<strong>差量备份</strong>, <strong>周四</strong>的差量备份直接针对<strong>周日的差量变化</strong><br>如果周四的增量备份系统出现了故障，首先恢复<strong>周日</strong>的<strong>完整版</strong>，再其上恢复<strong>周四的差量版</strong></p>
<ul>
<li><p><strong>静态海量存储</strong>：在系统中无运行事务时进行, 每次存储全部数据库</p>
</li>
<li><p><strong>静态增量存储</strong>：在系统中无运行事务时进行，每次只存储上一个转储后更新过的数据库</p>
</li>
<li><p><strong>动态海量存储</strong>：转储期间允许对数据库进行存取或修改，每次转储全部数据库</p>
</li>
<li><p><strong>动态增量转储</strong>：转储期间允许对数进行存取或修改，每次只转储上一次转储后更新过的数据</p>
</li>
</ul>
<p>日志文件：事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作(增删改查)，并将记录结果保存在独立的 (<u>先写日志 再写数据文件</u>)</p>
<table>
<thead>
<tr>
<th align="center">故障关系</th>
<th align="center">故障原因</th>
<th align="center">解决办法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务本身的可预期故障</td>
<td align="center">本身逻辑</td>
<td align="center">再程序中预先设置Rollback语句</td>
</tr>
<tr>
<td align="center">事务本身的不可预期故障</td>
<td align="center">算数溢出, 违反存储保护</td>
<td align="center">由DBMS的恢复子系统通过日志,撤销事务对数据库的修改,回退到事务初始状态</td>
</tr>
<tr>
<td align="center">系统故障</td>
<td align="center">系统停止运转</td>
<td align="center">通常采用检查点法</td>
</tr>
<tr>
<td align="center">介质故障</td>
<td align="center">外存被破坏</td>
<td align="center">一般使用日志重做业务</td>
</tr>
</tbody></table>
<h3 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h3><p><strong>数据仓库</strong>是面向各各主题的；会记录一些集成式的数据(报表)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c60e0ed20bce0df65d296e7f30cc4c1ee207aeb9/data/%E4%BB%93%E5%BA%93%E6%95%B0%E6%8D%AE.jpg"></p>
<h3 id="反规范化-牺牲空间-规范化程度来换时间"><a href="#反规范化-牺牲空间-规范化程度来换时间" class="headerlink" title="反规范化(牺牲空间+规范化程度来换时间)"></a>反规范化(牺牲<u>空间</u>+<u>规范化程度</u>来换<u>时间</u>)</h3><p>由于规范化会使表不断的拆分，从而导致数据表过多。这样虽然减少了<strong>数据冗余</strong>，<u>提高了增、删、改的速度，但会增加查询的工作量</u>。系统需要进行多次连接，才能进行查询操作，使得系统效率大大下降。</p>
<h6 id="技术手段"><a href="#技术手段" class="headerlink" title="技术手段"></a>技术手段</h6><p><strong>√ 增加派生性冗余列</strong> (在成绩表里添加 姓名&#x2F;课程名 能够快速查到哪个人成绩多少分)<br><strong>√ 增肌冗余列</strong><br><strong>√ 重新组表</strong>(依据查询效率的原则)<br><strong>√ 分割表</strong>(从效率角度看进行垂直分割、水平分割)</p>
<h3 id="大数据-4V"><a href="#大数据-4V" class="headerlink" title="大数据 4V"></a>大数据 4V</h3><p>Volume 数据量    Velocity 速度    Variety 多样性    Value 价值</p>
<table>
<thead>
<tr>
<th align="center">比较维度</th>
<th align="center">传统数据</th>
<th align="center">大数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据量</td>
<td align="center">GB或TB</td>
<td align="center">PB级或以上</td>
</tr>
<tr>
<td align="center">数据分析需求</td>
<td align="center">现有数据的分析与检测</td>
<td align="center">深度分析(关联分析、回归分析)</td>
</tr>
<tr>
<td align="center">硬件平台</td>
<td align="center">高端服务器</td>
<td align="center">集群平台</td>
</tr>
</tbody></table>
<h6 id="大数据处理系统应该具有的重要特征"><a href="#大数据处理系统应该具有的重要特征" class="headerlink" title="大数据处理系统应该具有的重要特征"></a>大数据处理系统应该具有的重要特征</h6><blockquote>
<p>高度可拓展性<br>高性能<br>高度容错<br>支持异构环境<br>较短的分析延迟<br>易用且开放的接口<br>较低成本<br>向下兼容性</p>
</blockquote>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p><strong>中继器</strong>：类似于烽火狼烟<br><strong>网桥</strong>：链接两个同类型的设备<br><strong>交换机</strong>：用来链接多个设备</p>
<blockquote>
<h6 id="按分布范围分"><a href="#按分布范围分" class="headerlink" title="按分布范围分"></a>按分布范围分</h6><p>局域网LAN 城域网MAN 广域网WAN 因特网</p>
<h6 id="按拓扑结构分"><a href="#按拓扑结构分" class="headerlink" title="按拓扑结构分"></a>按拓扑结构分</h6><p>总线型 星型 环型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">名称</th>
<th align="center">主要功能</th>
<th align="center">主要设备及协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="center">应用层</td>
<td align="center">实现具体的应用功能</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">表示层</td>
<td align="center">数据的格式与表达、加密、压缩</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">会话层</td>
<td align="center">建立、管理和终止会话</td>
<td align="center">POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">传输层</td>
<td align="center">端到端的连接</td>
<td align="center">TCP、UDP</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">网络层</td>
<td align="center">分组传输和路由选择</td>
<td align="center">三层交换机、路由器、ARP、RARP、IP、ICMP、IGMP</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">数据链路层</td>
<td align="center">传送以帧为单位的信息</td>
<td align="center">网桥、交换机、网卡、PPTP、L2TP、SLIP、PPP</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">物理层</td>
<td align="center">二进制传输</td>
<td align="center">中继器、集线器</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>TCP&#x2F;IP 协议体系结构</strong><br>(1) 采用 分层结构，将复杂的大问题，划分成若干个简单的小问题<br>(2) TCP&#x2F;IP从下向上，依次划分为 “网络接口层、网络层 、传输层、应用层”<br>【注意】”网络接口层” 对应了 OSI的 物理层和数据链路层<br>(3) 常用协议<br>① 数据链路层 [PPP 点对点协议  PPPoE 基于 局域网的PPP协议 over Ethernet]<br>用于 建立、维护 数据链路(数据通道)<br>② 网络层<br><strong>IP</strong>：互联网协议，是所有通信必须使用的协议；作用：保证数据到达正确的目的地<br><strong>ARP</strong>：地址解析协议，实现 局域网 中主机的 IP地址转网卡的物理地址<br><strong>ICMP</strong>：互联网控制<strong>报文</strong>协议，功能：差错控制和查询主机<br><strong>RARP</strong>：逆向ARP，局域网中 物理地址 转 虚拟IP地址</p>
<blockquote>
<p>ping 127.0.0.1 回环测试本地主机内部网络状态是否正常</p>
</blockquote>
<p>③ 传输层<br><strong>TCP</strong>：传输控制协议，面向连接、可靠通信协议；功能：保证到达目的地的数据是正确的<br><strong>UDP</strong>：用户数据报协议，无连接、不可靠通信协议，用于 大数据传输(流媒体)：音频、视频<br>④ 应用层<br><span style = "color : red">HTTP</span> 超文本传输协议：用于访问网络<br><span style = "color : red">HTTPS</span> 加密&#x2F;安全超文本传输协议<br><strong>SMTP</strong>&#x2F;MIME 简单邮件传输协议：用于<strong>发送电子邮件</strong><br><strong>POP3</strong>&#x2F;IMAP 邮局协议第三版：用于<strong>接收电子邮件</strong><br><strong>FTP</strong> 文件传输协议：用于 上传下载文件<br><strong>TELNET</strong> 远程登录协议<br>DNS 域名解析协议：实现 中英文域名 转换为 数字的IP地址</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f96331264996b03cae2b87dcaf29db2e778b6b2f/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E4%BD%8D.jpg" style="zoom: 67%;" />
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/a17658b559c5998517d83d9117f82c913b7fc241/data/%E5%8D%8F%E8%AE%AE.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/a52a51d3f2d21b7f3f39926b385f47fc4fdda4b6/data/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" style="zoom:200%;" />



<h3 id="DHCP-DNS协议"><a href="#DHCP-DNS协议" class="headerlink" title="DHCP + DNS协议"></a>DHCP + DNS协议</h3><img src="https://raw.githubusercontent.com/P-luminary/images/adf08386618abc9e6c46346884f3860d74c14956/data/DHCP%2BDNS%E5%8D%8F%E8%AE%AE.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/202233c320981b4c100c6837c0ad9cb5b32e68c2/data/DNS%E5%8D%8F%E8%AE%AE%E9%A2%98.jpg"></p>
<h3 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/57a0942867cd04aaeea6f7f50d48aba632b281b1/data/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1.jpg"  />

<blockquote>
<p>★★★ 非常重要 IP地址相关计算题 ★★★</p>
<h5 id="IP地址和子网掩码换算"><a href="#IP地址和子网掩码换算" class="headerlink" title="IP地址和子网掩码换算"></a>IP地址和子网掩码换算</h5><p>已知ip地址和子网位数，例如：C网192.168.1.53&#x2F;27， [子网位数是27]<br><strong>求</strong><br>1.具体的子网掩码<br>2.子网数<br>3.<strong>最大可容纳主机数</strong><br>4.<strong>可用的主机数</strong><br>5.网络地址<br>6.广播地址<br>7.地址范围<br>8.主机号</p>
<h5 id="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："><a href="#一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：" class="headerlink" title="一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）："></a>一、如何求具体的子网掩码（根据默认子网掩码和给出的子网位数求）：</h5><p>**1.**C网默认的子网掩码是：255.255.255.0<br>转换成二进制是：11111111.11111111.11111111.00000000<br>（1代表网络号，0代表主机号）<br>前24位是1，代表网络号，后8位是0，代表主机号<br>&#x3D;&#x3D;已知子网位数是27&#x3D;&#x3D;，代表网络号向主机号借用了3位（8+8+8+3）<br>得：11111111.11111111.11111111.11100000<br>把二进制转换为十进制：255.255.255.224<br>求出192.168.1.53&#x2F;27对应的子网掩码是255.255.255.224</p>
<h6 id="二、子网数"><a href="#二、子网数" class="headerlink" title="二、子网数"></a>二、子网数</h6><p>1.网络号向主机号借了3位（27-24），得**$2^3$&#x3D;8个**</p>
<p><span style = "color : red"><strong>三、最大可容纳主机数</strong></span>（根据求出的子网掩码和给出的子网位数求）1.由一可知子网掩码是：255.255.255.254，转换为二进制是11111111.11111111.11111111.11100000<br>1代表网络号，0代表主机号，有5个0，得最大可容纳主机数是2^5&#x3D;32</p>
<h6 id="四、可用的主机数"><a href="#四、可用的主机数" class="headerlink" title="四、可用的主机数"></a>四、可用的主机数</h6><p>由三可知，最大可容纳主机数是32个，32-2<del>广播地址+网络地址</del>&#x3D;30</p>
<h6 id="五、网络地址（把IP地址和子网掩码进行与运算）"><a href="#五、网络地址（把IP地址和子网掩码进行与运算）" class="headerlink" title="五、网络地址（把IP地址和子网掩码进行与运算）"></a>五、网络地址（把IP地址和子网掩码进行与运算）</h6><p>192.168.1.53&#x2F;27， 把IP地址和子网掩码进行与运算，IP地址转换为二进制：11000000.10101000.00000001. <strong>00110101<del>53</del></strong>;<br>子网掩码255.255.255.254转换为二进制：11111111.11111111.11111111.11100000，<br>进行与运算得：<br>IP地址：  11000000.10101000.00000001. 00110101<br>子网掩码：  11111111.11111111.11111111. 11100000（子网掩码连续全1的是网络地址，后面的是主机地址）<br>11000000.10101000.00000001. 00100000&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;转换为十进制得：192.168.1.32<br>所以网络地址是192.168.1.32</p>
<h6 id="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"><a href="#六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）" class="headerlink" title="六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）"></a>六、广播地址（网络地址中的网络地址部分不变，主机地址变为全1，结果就是广播地址）</h6><p>1.网络地址： 11000000.10101000.00000001. 00100000（标黄部分是网络地址），变为1得：11000000.10101000.00000001. 00111111</p>
<p>2.广播地址转换为十进制：192.168.1.63</p>
<h6 id="七、地址范围"><a href="#七、地址范围" class="headerlink" title="七、地址范围"></a>七、地址范围</h6><p>1.网络地址+1——-广播地址-1，得192.168.1.33—-192.168.1.62</p>
<h6 id="八、主机号（子网掩码取反再和IP做与运算）"><a href="#八、主机号（子网掩码取反再和IP做与运算）" class="headerlink" title="八、主机号（子网掩码取反再和IP做与运算）"></a>八、主机号（子网掩码取反再和IP做与运算）</h6></blockquote>
<p>将一个网络<strong>划分</strong>为多个子网(取部分<strong>主机号</strong>当子网号)<br>将多个网络<strong>合并</strong>为一个大的网络(取部分网络号当主机号)</p>
<h6 id="例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？"><a href="#例1，将B类IP地址168-195-0-0划分为27个子网，子网掩码为多少？" class="headerlink" title="例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？"></a>例1，将B类IP地址168.195.0.0划分为27个子网，子网掩码为多少？</h6><blockquote>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td>168.195.0.0</td>
<td>1010 1000  1100 0011  0000 0000  0000 0000</td>
</tr>
</tbody></table>
<p>$2^R$ ≥ N；R&#x3D;5时 N&#x3D;32 ＞ 27<br><strong>网络位</strong>要向主机位借5位<br>该例中需27个子网，按公式，需借5位</p>
<p>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u><strong>1111 1</strong>000</u>  <u>0000 0000</u> → 255.255.248.0每个子网能容纳的有效主机数为$2^{11}-2$&#x3D;2046台<br>只要划分子网 就是变化的子网掩码 </p>
</blockquote>
<h6 id="例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的"><a href="#例2，将B类IP地址168-195-0-0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？-这两个子网掩码是根据不同的条件而得到的" class="headerlink" title="例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？(这两个子网掩码是根据不同的条件而得到的)"></a>例2，将B类IP地址168.195.0.0划分称若干个子网，每个子网内有主机700台，则子网掩码为多少？<span style = "color : red">(这两个子网掩码是根据不同的条件而得到的)</span></h6><blockquote>
<p>$2^R$ ≥ N；N&#x3D;700；R&#x3D;10 也就是剩余10个零<strong>地址位(<strong>网络位)只要有10位就够了<br>子网掩码：<u>1111 1111</u>  <u>1111 1111</u>  <u>1111 11</strong>00</strong></u>  <u><strong>0000 0000</strong></u> → 255.255.252.0</p>
</blockquote>
<h6 id="无分类编址-无类域间路由"><a href="#无分类编址-无类域间路由" class="headerlink" title="无分类编址(无类域间路由)"></a>无分类编址(无类域间路由)</h6><p><span style = "color : red"><strong>IP地址 :: &#x3D; {&lt;网络前缀&gt;, &lt;主机号&gt;}</strong></span><br>128.14.32.0&#x2F;20 表示的地址块共有$2^{12}$个地址<br>这个地址块的起始地址是128.14.32.0<br>在不需要指出地址块的起始地址时，也可将这样的地址快简称位 “&#x2F;20地址块”<br>128.14.32.0&#x2F;20 地址块的最小地址：128.14.32.0<br>128.14.32.0&#x2F;20 地址块的最大地址：128.14.47.255<br>全0和全1的主机号地址一般不使用</p>
<h6 id="例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；"><a href="#例3，分配给某公司网络的地址块是210-115-192-0-x2F-20，该网络可以被划分位-16-个C类子网；" class="headerlink" title="例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；"></a>例3，分配给某公司网络的地址块是210.115.192.0&#x2F;20，该网络可以被划分位(16)个C类子网；</h6><blockquote>
<p>C类地址 24个子网位  8个主机位，题目是&#x2F;20 前面20位为网络号；证明还要从主机号里拿出4个位来做子网号；4个位得到的子网数量是16个</p>
</blockquote>
<h3 id="特殊含义的IP地址"><a href="#特殊含义的IP地址" class="headerlink" title="特殊含义的IP地址"></a>特殊含义的IP地址</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee02b13442781213029e9fe8c188d1b53c790179/data/%E7%89%B9%E6%AE%8A%E7%9A%84IP%E5%9C%B0%E5%9D%80.jpg"></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/4aedfd72e38d42a61b4be6086c218703360ec565/data/HTML.jpg"></p>
<h3 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h3><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>灵活性 移动性 成本低 容易扩充</p>
<h6 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h6><p>有接入点模式  无接入点模式(对等网模式)</p>
<blockquote>
<p>无线局域网(WLAN, 802.11, Wi-Fi)<br>无线城域网(WMAN, 802.16, WiMax)<br>无线广域网(WWAN, 3G&#x2F;4G)<br>无线个人网(WPAN, 802.15, Bluetooth)</p>
</blockquote>
<blockquote>
<h5 id="有线接入"><a href="#有线接入" class="headerlink" title="有线接入"></a>有线接入</h5><p>公用交换电话网络(PSTN) <u>原始拨号上网</u> pose机+传真<br>数字数据网(DDN) <u>数字专用网(专线)</u><br>综合业务数字网(ISDN) <u>允许打电话的时候上网</u><br>非对称数字用户线路(ADSL) <u>老旧小区电话线部署</u><br>同轴光纤技术(HFC) <u>家里有线电视</u></p>
</blockquote>
<blockquote>
<h6 id="无线接入"><a href="#无线接入" class="headerlink" title="无线接入"></a>无线接入</h6><p>IEEE 802.11(WiFi)<br>IEEE 802.15(蓝牙Bluetooth)<br>红外(IRDA)<br>WAPI</p>
</blockquote>
<blockquote>
<h6 id="3G-x2F-4G"><a href="#3G-x2F-4G" class="headerlink" title="3G&#x2F;4G"></a>3G&#x2F;4G</h6><p>WCDMA<br>CDMA2000<br>TD-SCDMA (国外多 速率低 功耗大)<br>LTE-Advanced<br>WirelessMAN-Advanceed(802.16m) (WiMAX)</p>
</blockquote>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>IPV6是设计用于替代现行版本IP协议(IPV4)的下一代IP协议。</p>
<blockquote>
<p>(1) IPV6地址长度位128位，地址空间增大了$2^{96}$倍<br>(2) 灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPV6中选项部分的出现方式也有所变化，使用路由器可以简单路过选项而不做任何处理，加快了报文处理速度<br>(3) IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量<br>(4) 提高安全性。身份认证和隐私权是IPv6的关键特性<br>(5) 支持更多的服务类型<br>(6) 允许协议继续演变，增加新的功能，使之适应未来技术的发展</p>
</blockquote>
<p>**单播地址(Unicast)**：用于单个接口的标识符<br>**任播地址(Anycast)**：泛播地址。一组接口的标识符，IPv4广播地址<br>**组播地址(Multicast)**：IPv6中的组播在功能上与IPv4中的组播类似</p>
<h3 id="信息系统安全属性"><a href="#信息系统安全属性" class="headerlink" title="信息系统安全属性"></a>信息系统安全属性</h3><h6 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h6><blockquote>
<p><strong>保密性</strong>：最小授权原则、防暴露、信息加密、物理加密<br><strong>完整性</strong>：安全协议、校验码、密码校验、数字签名、公证<br><strong>可用性</strong>：综合保障(IP过滤、业务流控制、路由选择控制、审计跟踪)<br><strong>不可抵赖性</strong>：数字签名</p>
</blockquote>
<h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a><span style = "color : red">加密技术</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e8808ad943a5c7fcaf7ae0ce3606fc214c3221/data/%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg"></p>
<h3 id="信息摘要-不能用作加密算法-因为不能解密-（无法篡改）"><a href="#信息摘要-不能用作加密算法-因为不能解密-（无法篡改）" class="headerlink" title="信息摘要(不能用作加密算法 因为不能解密) （无法篡改）"></a>信息摘要(不能用作加密算法 因为不能解密) （无法篡改）</h3><p>单向散列函数(<strong>单向Hash函数</strong>)、固定长度的散列值<br>常用的消息摘要算法有MD5、SHA等，市场上广泛使用的MD5，SHA算法的散列值分别为128和160位，由于SHA通常采用的密钥长度较长，因此安全性高于MD5</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>数字证书</strong>：识别人的身份</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/21de8ce0fc5a2872f99ac597d26aca426a8a436a/data/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" style="zoom:150%;" />



<h3 id="数字信封与PGP"><a href="#数字信封与PGP" class="headerlink" title="数字信封与PGP"></a>数字信封与PGP</h3><blockquote>
<p>发送方将原文用对称密钥加密传输，而将对称密钥用接收公钥加密发送給对方<br>接受方收到电子信封，用自己的私钥解密信封，取出对称密钥解密得原文</p>
</blockquote>
<blockquote>
<p>PGP可用于电子邮件，也可以用于文件存储。采用了杂合算法，包括IDEA、RSA、MD5、ZIP数字压缩算法</p>
<p>PGP承认两种不同的证书格式：PGP证书和X.509证书</p>
<p>PGP证书包含PGP版本号、证书持有者的公钥、证书持有者的信息、证书拥有者的数字签名、证书的有效期、密钥首选的对称加密算法</p>
<p>X.509证书包含证书版本、证书的序列号、签名算法标识、证书有效期、以下数据：证书发行商名字、证书主题名、<strong>主体公钥信息</strong>、发布者的数字签名</p>
</blockquote>
<h3 id="练习题-—-设计邮件加密系统"><a href="#练习题-—-设计邮件加密系统" class="headerlink" title="练习题 — 设计邮件加密系统"></a>练习题 — 设计邮件加密系统</h3><p>要求邮件以**<u>加密方式传输</u><strong>(<span style = "color : red"><em>加密解密技术</em></span>  )，邮件</strong><u>最大附件内容可达500MB</u><strong>( <em><span style = "color : red">对称加密</span></em>  )，</strong><u>发送者不可抵赖</u>** ( <em><span style = "color : red">数字签名</span></em>  )，若邮件被第三方截获，**<u>第三方无法篡改</u>** ( <em><span style = "color : red">信息摘要技术</span></em>  )。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/207ac6bb3d48784835bb4a14a2bcc0686739bf53/data/%E8%AE%BE%E8%AE%A1%E9%82%AE%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"></p>
<h3 id="网络安全-—-各个网络层次的安全保障"><a href="#网络安全-—-各个网络层次的安全保障" class="headerlink" title="网络安全 — 各个网络层次的安全保障"></a>网络安全 — 各个网络层次的安全保障</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ebec2885b8f58a32cc399dcb2ba83803ea944fa3/data/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C.jpg"></p>
<h3 id="网络安全-—-网络威胁与攻击"><a href="#网络安全-—-网络威胁与攻击" class="headerlink" title="网络安全 — 网络威胁与攻击"></a>网络安全 — 网络威胁与攻击</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/1bfbf181924b0185e3567a2c2e020aca1b7e9341/data/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%E7%BD%91%E7%BB%9C%E5%A8%81%E8%83%81%E4%B8%8E%E6%94%BB%E5%87%BB.jpg"></p>
<h3 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/805b5c52967e5ceefd47b195f8bce4ba3094c02c/data/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF.jpg"></p>
<h1 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a><span style = "color : red">数据结构与算法基础</span></h1><p>数组与矩阵、<strong>线性表</strong>、广义表、<strong>树与二叉树</strong>、图、<strong>排序与查找</strong>、<strong>算法基础及常见的算法</strong></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><table>
<thead>
<tr>
<th align="left">数组类型</th>
<th align="left">存储地址计算</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一维数组a[n]</td>
<td align="left">a[i]的存储地址为：a + i * len</td>
</tr>
<tr>
<td align="left">二维数组a[m] [n]</td>
<td align="left"><span style = "color : red"><strong>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len</strong></span><br /><span style = "color : red"><strong>a[i] [j]的存储地址(按列存储)：a + ( j * m + i) * len</strong></span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>1 a[0] [0]</th>
<th>2 a[0] [1]</th>
<th>3 a[0] [2]</th>
</tr>
</thead>
<tbody><tr>
<td>4 a[1] [0]</td>
<td>5 a[1] [1]</td>
<td>6 a[1] [2]</td>
</tr>
<tr>
<td>7 a[2] [0]</td>
<td>8 a[2] [1]</td>
<td>9 a[2] [2]</td>
</tr>
</tbody></table>
<p>已知5行5列的二维数组a中的各元素占两个字节，求元素a[2] [3]按<strong>行</strong>优先存储的存储地址？</p>
<blockquote>
<p>a[i] [j]的存储地址(按行存储)：a + ( i * n + j) * len<br> (2 * 5 + 3) * 2，a[2] [3]是存储的第14个元素，由于编号是从0开始算的，有13个偏移量<br>∴ a + 13 * 2 &#x3D; 每一个元素所占的字节数    a[0] [0] &#x3D; a</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
<th align="center">√</th>
</tr>
</thead>
<tbody><tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"><span style = "color : red"><strong>√</strong></span></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e6036b61d33d357a06e724e93e01d06021ed088f/data/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.jpg" style="zoom:150%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构是指互相之间存在一种或多种特定关系的数据元素的集合<br><strong>图</strong>包含<strong>树</strong>  <strong>树</strong>包含<strong>线性结构</strong></p>
<p><u>线性结构</u>  <strong>O-O-O-O</strong><br><u>非线性结构</u>  <strong>树 + 图</strong></p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><strong>顺序表</strong> + <strong>链表</strong>(单链表、循环列表、双向链表)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/b3c4a142e06c76bec4aa3e73894168a65b08f6d1/data/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9.jpg"  />



<h3 id="顺序存储与链式存储对比"><a href="#顺序存储与链式存储对比" class="headerlink" title="顺序存储与链式存储对比"></a>顺序存储与链式存储对比</h3><table>
<thead>
<tr>
<th align="left">性能类别</th>
<th align="left">具体项目</th>
<th align="left">顺序存储</th>
<th align="left">链式存储</th>
</tr>
</thead>
<tbody><tr>
<td align="left">空间性能</td>
<td align="left">存储密度</td>
<td align="left">&#x3D;1，更优 (1&#x3D;100%)</td>
<td align="left">&lt; 1 (<u>有节点专门存地址信息</u>)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">容量分配</td>
<td align="left">事先确定</td>
<td align="left">动态变化，更优 (<u>动态改变分配</u>)</td>
</tr>
<tr>
<td align="left">时间性能</td>
<td align="left">查找运算</td>
<td align="left">O(n&#x2F;2)</td>
<td align="left">O(n&#x2F;2)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">读运算</td>
<td align="left">O(1)，更优</td>
<td align="left">O([n+1]&#x2F;2), 最好情况为1，最坏情况为n  (需要一格一格的移)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">插入运算</td>
<td align="left">O(n&#x2F;2)，最好情况为O，最坏情况为n</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">删除运算</td>
<td align="left">O([n-1]&#x2F;2)</td>
<td align="left">O(1)，更优 (局部小外科手术)</td>
</tr>
</tbody></table>
<h3 id="线性表—队列与栈"><a href="#线性表—队列与栈" class="headerlink" title="线性表—队列与栈"></a>线性表—队列与栈</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1a694cbb02c9afc6c9ee673f3b356d875c592b76/data/%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98.jpg"  />



<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><img src="https://raw.githubusercontent.com/P-luminary/images/61bf44a1acf06a88f7ad8469c6878d8c01c947ae/data/%E5%B9%BF%E4%B9%89%E8%A1%A8.jpg"  />



<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><img src="https://raw.githubusercontent.com/P-luminary/images/1638b875c12489816f5727597393ae6b4c559259/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/47e3cc81bfa782c8f11433d14042d25524d1d7ff/data/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%912.png"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e4a5b0f38017419dced3d5a0a580be16fc7f7d9a/data/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg"></p>
<h3 id="反向构造二叉树"><a href="#反向构造二叉树" class="headerlink" title="反向构造二叉树"></a>反向构造二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea18aebfc2bb5b897ee4e065ea0e6328ba2d38aa/data/%E5%8F%8D%E5%90%91%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230710123815373.png"></p>
<h3 id="查找二叉树"><a href="#查找二叉树" class="headerlink" title="查找二叉树"></a>查找二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ca9dc0f534b3ff73fade234561af98443227670c/data/%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="最优二叉树-哈夫曼树"><a href="#最优二叉树-哈夫曼树" class="headerlink" title="最优二叉树(哈夫曼树)"></a>最优二叉树(哈夫曼树)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e8133232bfff828b8fe77098f7fa9d7fca88b148/data/%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91(%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91).jpg"></p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec2da880ff33e863050049acc335c60fb09f6e3b/data/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8848e420d3d2f38cfa13a2803afb39fba9249cc8/data/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg"></p>
<h3 id="树和图的最大区别：树是没有环路的"><a href="#树和图的最大区别：树是没有环路的" class="headerlink" title="树和图的最大区别：树是没有环路的"></a><span style = "color : red"><strong>树和图的最大区别：树是没有环路的</strong></span></h3><h3 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ea8055908dec7f2d988a189da12eeced78a34fb7/data/%E5%9B%BE%2B%E5%9B%BE%E5%AD%98%E5%82%A8%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg"></p>
<h3 id="邻接图"><a href="#邻接图" class="headerlink" title="邻接图"></a>邻接图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0e743eb4f3e6db6334e95e915528a12ac68514a2/data/%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg"></p>
<h3 id="图的遍历-深度-广度"><a href="#图的遍历-深度-广度" class="headerlink" title="图的遍历(深度+广度)"></a>图的遍历(深度+广度)</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/7cf480efb37be3cf903977972770cb46f88a1015/data/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86(%E6%B7%B1%E5%BA%A6%2B%E5%B9%BF%E5%BA%A6).jpg"></p>
<h3 id="图-—-拓扑排序"><a href="#图-—-拓扑排序" class="headerlink" title="图 — 拓扑排序"></a>图 — 拓扑排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/8f52549404943f522f10d2bfefbefbd15bb3bfba/data/%E5%9B%BE%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="图的最小生成树-—-普里姆算法"><a href="#图的最小生成树-—-普里姆算法" class="headerlink" title="图的最小生成树 — 普里姆算法"></a>图的最小生成树 — 普里姆算法</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/48563077b3612e0a2288fb24c5f78d0082384f8d/data/%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.jpg"></p>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p><strong>有穷性</strong>：执行有穷步之后结束<br><strong>确定性</strong>：算法中每一条指令都必须有确切的含义，不能含糊不清<br><strong>输入</strong>：(&gt;&#x3D;0)<br><strong>输出</strong>：(&gt;&#x3D;1)<br><strong>有效性</strong>：算法的每个步骤都能有效执行并能得到确定的结果。例a&#x3D;0, b&#x2F;a就无效</p>
<h3 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h3><p><strong><span style = "color : red">时间复杂度</span><strong>：是指程序运行从开始到结束所需要的时间。通常分析时间复杂度的方法是从算法中选取一种对于所研究的问题来说是基本运算的操作，以该操作重复执行的次数作为算法的时间量度。一般来说，算法中原操作重复执行的次数是规模n的某个函数T(n)。由于许多情况下要精密计算T(n)是困难的，因此引入了渐进时间复杂度在数量上估计一个算法的执行时间。其定于如下：<br>如果存在两个常数c和m，对于所有的n，当n≥m时有f(n) ≤ cg(n), 则有f(n) &#x3D; O(g(n))，也就是说，随着n的增大，f(n)逐进地不大于g(n)。例如，</strong>一个程序的实际执行时间为T(n)&#x3D;3$n^3$+2$n^2$+n, 则T(n) &#x3D; O($n^3$)</strong>  [以最高的时间复杂度为准！三重for循环时间复杂度是O($n^3$)]</p>
<p><span style = "color : orange"><strong>常见的对算法执行所需时间的量度：</strong></span><br><strong>O(1) &lt; O(lo$g_2$n) &lt; O(n) &lt; O(nlo$g_2$n) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$)</strong></p>
<blockquote>
<p><strong>log的由来</strong>：排序二叉树 找结点 有7个结点的完全二叉树，向下比较 最多比较3次(二叉树的层数) 最坏的情况多少层就比较多少次 所以有<strong>lo$g_2$n</strong>，n就是结点数量</p>
</blockquote>
<p>**<span style = "color : red">空间复杂度：</span>**是指对一个算法在运行过程中临时占用存储空间大小的度量。一个算法的空间复杂度<u><strong>只考虑在运行过程中为局部变量分配的存储空间的大小</strong></u>。</p>
<h3 id="查找-—-顺序查找与二分查找"><a href="#查找-—-顺序查找与二分查找" class="headerlink" title="查找 — 顺序查找与二分查找"></a>查找 — 顺序查找与二分查找</h3><img src="https://raw.githubusercontent.com/P-luminary/images/master/data/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.jpg"  />



<h3 id="查找-—-散列表"><a href="#查找-—-散列表" class="headerlink" title="查找 — 散列表"></a>查找 — 散列表</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/0098e5cad58ccd31a685f565826e8e8832772252/data/%E6%95%A3%E5%88%97%E8%A1%A8.jpg"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6f3e15053fbfd4f677ad2bc4d3e415a22676631d/data/%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/f95845259682927312a2712c8786baa1659e1f52/data/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p>
<h3 id="希尔排序-效率高于直接插入排序"><a href="#希尔排序-效率高于直接插入排序" class="headerlink" title="希尔排序(效率高于直接插入排序)"></a>希尔排序(效率高于直接插入排序)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/85ce49aa669297ebbfd9656a75bc09f78d3b7b5d/data/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20230718181340677.png"></p>
<h3 id="堆排序-适合于：不需要求全部-求前一部分"><a href="#堆排序-适合于：不需要求全部-求前一部分" class="headerlink" title="堆排序(适合于：不需要求全部 求前一部分)"></a>堆排序(适合于：不需要求全部 求前一部分)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2972cd322a1e9d4649529aa4e8a98073de6e2de3/data/%E5%A0%86%E6%8E%92.png.jpg" style="zoom:150%;" />



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2969db8aafbafae291aa4e96a9c8391862ca0ab8/data/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" style="zoom:150%;" />



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9a50aee5775d1ca1a8a993d3d0847599d7b52020/data/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/27b826e69885dcb01132ea63609668073c020e2a/data/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dad7782ee80e0729e01210b493c6bf596363784/data/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.jpg" style="zoom:150%;" />



<h3 id="算法排序汇总"><a href="#算法排序汇总" class="headerlink" title="算法排序汇总"></a>算法排序汇总</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8e615d2e7034d2bdffafcd507cb102e0fbf9c72e/data/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB.jpg" style="zoom:150%;" />



<h1 id="程序设计语言与语言处理程序"><a href="#程序设计语言与语言处理程序" class="headerlink" title="程序设计语言与语言处理程序"></a>程序设计语言与语言处理程序</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/98ebae6a55bb6b68dc4500674cc321737f4cd169/data/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8ee259fcd72bc7b48ab89100ce84af30cb560bfd/data/%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%8E%A8%E5%AF%BC%E6%A0%91.jpg" style="zoom: 150%;" />



<h3 id="有限自动机与正规式"><a href="#有限自动机与正规式" class="headerlink" title="有限自动机与正规式"></a>有限自动机与正规式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ed582973635f109925c4a9ead6047f0e51cf3c6f/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E8%A7%84%E5%BC%8F.jpg"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/e961e9530911c0115ffea4127e991575bbcaf5a0/data/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%BE%8B%E9%A2%98.jpg" style="zoom:150%;" />



<h3 id="程序语言基础—表达式"><a href="#程序语言基础—表达式" class="headerlink" title="程序语言基础—表达式"></a>程序语言基础—表达式</h3><img src="https://raw.githubusercontent.com/P-luminary/images/ee55ff5d4ec9b9745f6a8ad4c37066449e0dee96/data/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg" style="zoom:150%;" />



<h3 id="函数调用—传值与传址"><a href="#函数调用—传值与传址" class="headerlink" title="函数调用—传值与传址"></a>函数调用—传值与传址</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9cbd1c801ae0a7fcabad837813854de5e63feffe/data/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82.jpg"  />



<h3 id="程序语言基础—各种程序语言特点"><a href="#程序语言基础—各种程序语言特点" class="headerlink" title="程序语言基础—各种程序语言特点"></a>程序语言基础—各种程序语言特点</h3><p><strong>Fortran语言</strong>(科学计算，执行效率高)<br><strong>Pascal语言</strong>(为教学而开发的，表达能力强，Delphi)<br><strong>C语言</strong>(指针操作能力强，高效)<br><strong>Lisp语言</strong>(函数式程序语言，符号处理，人工智能)<br><strong>C++语言</strong>(面向对象，高效)<br><strong>Java语言</strong>(面向对象，中间代码，跨平台)<br><strong>C#语言</strong>(面向对象，中间语言，.Net)<br><strong>Prolog语言</strong>(逻辑推理，简洁性，表达能力，数据库和专家系统)</p>
<h3 id="法律法规-—-课程内容提要"><a href="#法律法规-—-课程内容提要" class="headerlink" title="法律法规 — 课程内容提要"></a>法律法规 — 课程内容提要</h3><h5 id="从所涉及的法律法规角度"><a href="#从所涉及的法律法规角度" class="headerlink" title="从所涉及的法律法规角度"></a>从所涉及的法律法规角度</h5><p>著作权法、计算机软件保护条例、商标法、专利法</p>
<p>@@ 著作权因作品的完成而自动产生，不必履行任何形式的登记或注册手续，也不论其是否已经发便，所以甲对该软件作品享有著作权，乙未经甲的许可擅自使用甲的软件作品的行为，侵犯了甲的软件著作权</p>
<p>@@ 关于软件著作权产生的时间是<strong>自作品完成创作之日</strong></p>
<h5 id="从试题考点分布的角度"><a href="#从试题考点分布的角度" class="headerlink" title="从试题考点分布的角度"></a><span style = "color :red">从试题考点分布的角度</span></h5><p>保护期限、知识产权人确定、侵权判断</p>
<blockquote>
<p><strong>知识产权</strong>：<br>著作权及邻接权、专利权、工业品外观设计权、商标权、地理标志权、集成电路布图设计权</p>
<p><u>著作权</u>：一般保护作者的利益<br><u>邻接权</u>：别人盗写我出的书，不仅破坏了我的权益，还有**<u>出版商</u><strong>的权益<br><u>地理标志权</u>：</strong>新疆**哈密瓜 只有在标志的地理位置生产(这一区域都拥有)</p>
</blockquote>
<h3 id="法律法规-—-保护期限-知识产权人"><a href="#法律法规-—-保护期限-知识产权人" class="headerlink" title="法律法规 — 保护期限, 知识产权人"></a>法律法规 — 保护期限, 知识产权人</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0d498a6b717c3dfd41334e8799dc508e5a7d4e8c/data/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84-%E4%BF%9D%E6%8A%A4%E6%9C%9F%E9%99%90%2C%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%BA%BA.jpg" style="zoom:150%;" />



<h3 id="侵权判定"><a href="#侵权判定" class="headerlink" title="侵权判定"></a>侵权判定</h3><h5 id="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"><a href="#中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权" class="headerlink" title="中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权"></a>中国公民、法人或者其他组织的作品，无论是否发表，都享有著作权</h5><h5 id="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"><a href="#开发软件所用的思想、处理过程、操作方法或者数学概念不受保护" class="headerlink" title="开发软件所用的思想、处理过程、操作方法或者数学概念不受保护"></a>开发软件所用的思想、处理过程、操作方法或者数学概念不受保护</h5><h6 id="著作权法不适用于下列情形："><a href="#著作权法不适用于下列情形：" class="headerlink" title="著作权法不适用于下列情形："></a>著作权法不适用于下列情形：</h6><p>√ 法律、法规、国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文</p>
<p>√ 时事新闻</p>
<p>√ 历法、通用数表、通用表格和公式</p>
<table>
<thead>
<tr>
<th>不侵权</th>
<th>侵权</th>
</tr>
</thead>
<tbody><tr>
<td>√ 个人学习、研究或欣赏<br />√ 适当引用<br />√ 公开演讲内容<br />√ 用于教学或科学研究<br />√ 复制馆藏作品<br />√ 免费表演他人作品<br />√ 室外公共场所艺术品临摹、绘画、摄影、录像<br />√ 将汉语作品译成少数民族语言作品或盲文出版</td>
<td>√ 未经许可，发表他人作品<br />√ 未经合作作者许可，将与他人合作创作的作品当作自己单独创作的作品发表的<br />√ 未参加创作，在他人作品署名<br />√ 歪曲、篡改他人作品<br />√ 剽窃他人作品的<br />√ 使用他人作品，未付报酬<br />√ 未经出版者许可，使用其出版的图书、期刊的版式设计的</td>
</tr>
</tbody></table>
<h3 id="标准化基础知识—标准的分类"><a href="#标准化基础知识—标准的分类" class="headerlink" title="标准化基础知识—标准的分类"></a>标准化基础知识—标准的分类</h3><p>√ 国际标准：ISO、IEC等国际标准化组织<br>√ 国家标准：GB—中国、ANSI—美国、BS—英国、JIS—日本<br>√ 区域标准：又称为地区标准，如PASC—太平洋地区标准会议、CEN—欧洲标准委员会、ASAC—亚洲标准咨询委员会、ARSO—非洲地区标准化组织<br>√ 行业标准：GJB—中国军用标准、MIT-S—美国军用标准、IEEE—美国电气电子工程协会<br>√ 地方标准：国家的地方一级行政机构制订的标准<br>√ 企业标准<br>√ 项目规范</p>
<p>→ 国标、国外标准代号：标准代号+专业类号+顺序号+年代号<br>→ 我国国家标准代号：强制性代号为GB、推荐性标准代号为GB&#x2F;T、指导性标准代号为GB&#x2F;Z、实物标准代号GSB</p>
<p>→ 行业标准代号：由汉语拼音大写字母组成(如电子行业为SJ)<br>→ 地方标准代号：由DB加上省级行政区划代码的前两位<br>→ 企业标准代号：由Q加上企业代号组成</p>
<h1 id="多媒体基础"><a href="#多媒体基础" class="headerlink" title="多媒体基础"></a>多媒体基础</h1><p>人耳：<strong>20Hz—20kHz</strong>  <u>小于20Hz是次声波 大于20kHz是超声波</u><br>说话：300—3400Hz<br>乐器：20Hz —20kHz<br>白噪音：20 ~ 20kHz</p>
<p><strong>采样</strong>：采样频率、采样精度、采样频率应为声音最高频率的2倍</p>
<blockquote>
<p><strong>采样点密</strong>集程度越高，时间间隔越短，还原度越好<br><strong>采样精度</strong>画格子的数量 y轴平行于x做直线</p>
</blockquote>
<h3 id="图像相关概念"><a href="#图像相关概念" class="headerlink" title="图像相关概念"></a>图像相关概念</h3><h4 id="色彩三要素色"><a href="#色彩三要素色" class="headerlink" title="色彩三要素色"></a>色彩三要素色</h4><p><strong>亮度</strong>是光作用于人眼时所引起的明亮程度的感觉，它与被观察物体的发光强度有关。<br><strong>色相</strong>是当人眼看一种或多种波长的光时所产生的彩色感觉，它反映颜色的种类，是决定颜色的基本特性。<br><strong>饱和度</strong>是指颜色的纯度，也可以叫做纯度、彩度或浓度等，即掺入白光的程度，或者是指颜色的深浅程度。</p>
<blockquote>
<p><strong>HSB彩色模式</strong><br>是根据日常生活中人眼的视觉特征而制定的一套色彩模式。HSB颜色模式以色相、饱和度和亮度描述颜色的基本特征。</p>
<p><strong>CMY颜色模式</strong><br>是采用**青(Cyan、品红或洋红(Magenta)、黄(Yellow)**3种基本颜色按一定比例合成颜色的方法。颜色的产生是来自于照射在颜料上反射回来的光线。<br>图像打印输出时用CMY颜色模式。</p>
<p><strong>Lab颜色模式</strong><br>分别用**亮度或光亮度分量(Luminosity)和两个色度分量(a、b)**来表示颜色<br>L表示亮度。L的值域由0到100，L&#x3D;50时，相当于50%的黑。<br>a表示从洋红色至绿色的范围，<br>b表示从黄色至蓝色的范围，<br>a和b的值域是由+127至-128。</p>
<p><strong>索引颜色模式</strong><br>最多使用256种颜色，当图像被转换为索引颜色模式时，通常会构建一个<strong>调色板存放图像中的颜色并编制颜色索引。</strong></p>
<p><strong>位图模式</strong><br>位图模式的图像只有<strong>黑色与白色两种像素</strong>，每个像素用1位二进制数表示,”0”表示黑色,“1”表示白色。</p>
<p><strong>灰度模式</strong><br>用单一色相表现图像，最多使用256级。图像中的每个像素有一个0(黑色)～255(白色)之间的亮度值。此外，灰度值也可以用黑色油墨覆盖的百分比来表示(0%表示白色，100%表示黑色)。</p>
<p><strong>颜色深度</strong><br>位图图像中各像素的颜色信息是用二进制数据描述的。<br><strong>色彩由颜色深度决定，不是分辨率</strong><br><strong>二进制的位数就是位图图像的颜色深度。颜色深度决定了图像中可以呈现的颜色的最大数目。</strong></p>
<p><strong>分辨率:</strong><br>图像分辨率(Image Resolution):指单位图像线性尺寸中所包含的像素数目，通常以**像素&#x2F;英寸(pixel per inch,ppi)**为计量单位。</p>
</blockquote>
<h6 id="彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度"><a href="#彩色空间：RGB彩色显示器、YUV-电视-兼容方案-、CMY-K黑-、HSV-HSB-艺术家角度" class="headerlink" title="彩色空间：RGB彩色显示器、YUV(电视, 兼容方案)、CMY[K黑]、HSV(HSB)艺术家角度"></a>彩色空间：RGB<del>彩色显示器</del>、YUV(电视, 兼容方案)、CMY[K<del>黑</del>]、HSV(HSB)<del>艺术家角度</del></h6><p><strong>光的颜色</strong>采取叠加原理<br><strong>印刷的三原色</strong>采取相减原理</p>
<h3 id="媒体的种类"><a href="#媒体的种类" class="headerlink" title="媒体的种类"></a>媒体的种类</h3><p><strong>感觉媒体</strong>，指通过人的感觉器官能<u>直接感受的媒体</u>，如视觉。<br><strong>表示媒体</strong>，用于传播和表达感觉媒体的中介媒体，是信息的表示和表现形式，如<u>JPG编码</u><br><strong>表现媒体</strong>(显示媒体)，是进行信息输入和输出的一类媒体，如<u>显示器</u><br><strong>传输媒体</strong>，是用于通信传输的信息载体，如<u>双绞线</u>。<br><strong>存储媒体</strong>，是存放表示媒体的物理实体，如<u>光盘</u></p>
<blockquote>
<p><strong>感觉</strong>媒体：听觉、触觉、嗅觉；<br><strong>表示</strong>媒体：文字、数字、音频、视频、编码方式；<br><strong>表现</strong>媒体(显示媒体)：输入显示媒体键盘、鼠标和麦克风、输出显示媒体显示器、打印机和音箱<br><strong>存储</strong>媒体：存储数据的物理设备，硬盘、磁盘、光盘U盘<br><strong>传输</strong>媒体：存储数据的物理载体，电缆、光缆和交换设备</p>
</blockquote>
<ul>
<li>D&#x2F;A转换，<strong>数字</strong>音频<strong>模拟</strong>化输出</li>
</ul>
<h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><ul>
<li><strong>波形音频文件容量的计算</strong>  <span style = "color : red"><u>容量&#x3D;声道数 * 采样频率 * 量化位数 * 长度 &#x2F; 8</u></span><br>其中频率单位Hz，量化单位bit，长度秒，容量单位字节B</li>
<li><strong>波形音频文件码率的计算</strong>  <u>码率&#x3D;声道数 * 采样频率 * 量化位数</u>  码率的单位是bps</li>
</ul>
<h5 id="常见波形文件格式"><a href="#常见波形文件格式" class="headerlink" title="常见波形文件格式"></a>常见波形文件格式</h5><ul>
<li>&#x3D;&#x3D;<strong>.wav</strong>&#x3D;&#x3D; 微软和IBM共同开发的PC标准音频格式，未压缩，声音达到CD音质，码率约为1.4Mb&#x2F;s，Windows XP录音机默认音频格式</li>
<li><strong>.mp3</strong> 有损压缩，最常用  互联网、MP3音乐</li>
<li>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</li>
<li><strong>.m4a</strong> 苹果公司的无损压缩</li>
<li><strong>.flac</strong> 无损压缩，高品质数字音乐</li>
<li><strong>.ape</strong> 无损压缩音频格式</li>
</ul>
<p>@@ WAV文件称为波形声音文件，其音质与CD差不多<br>@@ MP3文件能够达到很高的压缩比，并能<strong>保持较高</strong>的音质；通常那个说WAV文件比MP3文件大[比WAV&#x2F;CD好]<br>@@ MIDI不能从CD、磁带、麦克风等录制MIDI文件；通常MIDI文件小于MP3</p>
<h5 id="MIDI格式"><a href="#MIDI格式" class="headerlink" title="MIDI格式"></a>MIDI格式</h5><ul>
<li>MIDI乐器数字接口，垫桌子音乐制造商们建立的通信标准</li>
<li>MIDI传输的不是声音信号，记录声音的信息，是在线音乐的一组指令，是音符、控制参数等指令，它指示MIDI设备要做什么，怎么做; 如演奏哪个音符，音量多大等</li>
<li>.mid 或 .midi</li>
</ul>
<blockquote>
<h2 id="x3D-x3D-知识点总结-x3D-x3D"><a href="#x3D-x3D-知识点总结-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;知识点总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;知识点总结&#x3D;&#x3D;</h2><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li><strong>位图</strong>：.bmp<del>不压缩</del>    .gif<del>无损压缩</del>    .jpg&#x2F;jpeg<del>有损压缩</del>    .png<del>无损压缩</del>    .tif</li>
<li><strong>矢量图</strong>：.swf    .ai    .dwg    .cdr</li>
</ul>
<h4 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h4><ul>
<li><p>.wav    .mp3<del>有损压缩</del>    .wma<del>有损压缩：录音机(微软)</del>    </p>
</li>
<li><p>.m4a<del>无损压缩(苹果)</del>    .flac<del>无损压缩(高质量数字音乐)</del>    .ape<del>无损压缩音频</del></p>
</li>
<li><p>MIDI [.mid&#x2F;.midi]<del>乐谱</del></p>
</li>
</ul>
<h4 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h4><ul>
<li>.mpeg&#x2F;.mp4    H.26X    .avi    .asf    .wmv    .rm&#x2F;.rmvb    .flv    .mkv    .mov</li>
</ul>
<h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><ul>
<li>RM、WMV、ASF</li>
</ul>
</blockquote>
<h2 id="音频信息在计算机中的表示"><a href="#音频信息在计算机中的表示" class="headerlink" title="音频信息在计算机中的表示"></a>音频信息在计算机中的表示</h2><h4 id="波形数字音频"><a href="#波形数字音频" class="headerlink" title="波形数字音频"></a>波形数字音频</h4><h5 id="音频信息处理的流程"><a href="#音频信息处理的流程" class="headerlink" title="音频信息处理的流程"></a>音频信息处理的流程</h5><ul>
<li>A&#x2F;D转换[<strong>采样</strong>]，模拟音频的数字化【影响数字化质量的主要原因】</li>
</ul>
<h3 id="多媒体相关计算问题"><a href="#多媒体相关计算问题" class="headerlink" title="多媒体相关计算问题"></a>多媒体相关计算问题</h3><h6 id="图像容量计算640-水平像素-×480-垂直像素"><a href="#图像容量计算640-水平像素-×480-垂直像素" class="headerlink" title="图像容量计算640(水平像素)×480(垂直像素)"></a>图像容量计算<del>640(水平像素)×480(垂直像素)</del></h6><p>颜色深度的单位是 “位 bit “<strong>，</strong>图像容量的单位是字节B； <strong>1 Byte &#x3D; 8 Bits</strong></p>
<table>
<thead>
<tr>
<th align="center">条件</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">知道<strong>像素，位数</strong></td>
<td align="center">每个像素为16位，图像位640×480像素，求容量：<br />640×480×16÷8&#x3D;614400B</td>
</tr>
<tr>
<td align="center">知道<strong>像素，色数</strong></td>
<td align="center">640×480像素，256色的图像，求容量：<br />640×480×log<del>2</del>(256)÷8&#x3D;307200B</td>
</tr>
</tbody></table>
<h6 id="音频容量计算"><a href="#音频容量计算" class="headerlink" title="音频容量计算"></a><strong>音频</strong>容量计算</h6><p>音频<span style = "color : red"><u>容量 &#x3D; 声道数 * 采样频率(Hz) * 量化位数 * 长度 &#x2F; 8</u></span> </p>
<h6 id="视频容量计算"><a href="#视频容量计算" class="headerlink" title="视频容量计算"></a>视频容量计算</h6><p>视频<u><span style = "color : red">容量 &#x3D; 每帧图像容量(Byte) * 每秒帧数 * 时间 + 音频容量 * 时间</span></u> </p>
<img src="https://raw.githubusercontent.com/P-luminary/images/f98d8d3c2a788f0999bdbeee030b01b7a9bfd1dd/data/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%B8%B8%E8%A7%81%E8%AE%A1%E7%AE%97%E9%A2%98.jpg" style="zoom: 200%;" />



<h3 id="常见的多媒体标准"><a href="#常见的多媒体标准" class="headerlink" title="常见的多媒体标准"></a>常见的多媒体标准</h3><img src="https://raw.githubusercontent.com/P-luminary/images/82d3b6184da3dd2184662eebdcfb18c792f1fbb8/data/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%87%E5%87%86.jpg" style="zoom:150%;" />

<p>&#x3D;&#x3D;@@ <strong>存储动画</strong>的文件格式有<strong>FLC、GIF、SWF</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>网络视频格式</strong>包括<strong>MOV、RM、ASF、WMV</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>多媒体视频图像文件</strong>格式有<strong>AVI、MPG、ASF、MP4</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ <strong>声音、音频文件</strong>格式有<strong>WAV、WMA、MP3、MIDI、RA、APE</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;@@ 属于<strong>图像文件</strong>格式有<strong>GIF、BMP、JPG、PNG、TIF</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>.wma</strong>&#x3D;&#x3D;微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</p>
</blockquote>
<p>@@ 位图（Bitmap）&#x3D;&gt; <strong>BMP</strong></p>
<p>@@ <strong>语音识别技术</strong>体现了<u><strong>多媒体技术</strong>与<strong>人工智能技术</strong></u>相结合</p>
<h3 id="数据压缩基础"><a href="#数据压缩基础" class="headerlink" title="数据压缩基础"></a>数据压缩基础</h3><h6 id="空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"><a href="#空间冗余-几何冗余-、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余" class="headerlink" title="空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余"></a>空间冗余(几何冗余)、时间冗余、视觉冗余、信息熵冗余、结构冗余、知识冗余</h6><blockquote>
<p>空间冗余：图片大面积相同色(白色)，记录哪些信息是白色<br>时间冗余：固定在一个界面跳舞时，后面的物体不会动，墙面不会动。不动的记录下来。有变动的就分析<br>视觉冗余：jpeg人眼视觉识别盲区(视觉边界点压缩)<br>信息熵冗余：不同的信息编码冗余度不一样，通过合理的信息编码<br>结构冗余：某个部件有大量冗余，地砖花纹一样<br>知识冗余：可以通过知识分析得到的信息</p>
</blockquote>
<h3 id="有损压缩与无损压缩"><a href="#有损压缩与无损压缩" class="headerlink" title="有损压缩与无损压缩"></a>有损压缩与无损压缩</h3><p><strong>无损压缩编码法</strong>(Lossless compression coding)：也称之为**<u>冗余压缩法</u><strong>或</strong><u>熵编码法</u>**<br><strong>有损压缩编码法</strong>(Loss compression coding)：**<u>熵压缩法</u>**</p>
<p>jpeg属于有损(比较高的<strong>压缩比</strong>)，无法还原成原始图(位图)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/29624beeddd6478ad781db7390d2f5f06ef4b077/data/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9.jpg" style="zoom:150%;" />



<h1 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a><span style = "color : red">软件开发模型</span></h1><h6 id="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"><a href="#瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型" class="headerlink" title="瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型"></a>瀑布模型、演化模型、增量模型、螺旋模型、快速原型模型、喷泉模型、V模型</h6><h6 id="迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"><a href="#迭代模型-x2F-迭代开发方法、快速应用开发、构件组成模型-x2F-基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法" class="headerlink" title="迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法"></a>迭代模型&#x2F;迭代开发方法、快速应用开发、构件组成模型&#x2F;基于构件的开发方法、敏捷开发方法、模型驱动的开发方法、基于架构的开发方法</h6><p>@@ 在面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是<strong>重构</strong>，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为</p>
<h3 id="瀑布模型-SDLC"><a href="#瀑布模型-SDLC" class="headerlink" title="瀑布模型(SDLC)"></a>瀑布模型(SDLC)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/edf996ef9e67822a8fd47b5bb4d82cc0e27df1cc/data/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="原型、演化模型、增量模型"><a href="#原型、演化模型、增量模型" class="headerlink" title="原型、演化模型、增量模型"></a>原型、演化模型、增量模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4192bb3614abbf4dc5fba19b3579e89f2c9733e5/data/%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 200%;" />



<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/bf416fffe7f4d6101f0f259d902725345b8b7073/data/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="V模型-喷泉模型-RAD"><a href="#V模型-喷泉模型-RAD" class="headerlink" title="V模型 喷泉模型 RAD"></a>V模型 喷泉模型 RAD</h3><img src="https://raw.githubusercontent.com/P-luminary/images/cfa6ef57982d81474f45287c3473d6a78b7cac94/data/V%E6%A8%A1%E5%9E%8B%2CRAD%E6%A8%A1%E5%9E%8B%2C%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.jpg" style="zoom: 150%;" />



<h3 id="构件组装模型-CBSD"><a href="#构件组装模型-CBSD" class="headerlink" title="构件组装模型(CBSD)"></a>构件组装模型(CBSD)</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b7dbdfdbadf9e20a5a654b763c50c504059633a6/data/%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B(CBSD).jpg" style="zoom:150%;" />



<h3 id="统一过程"><a href="#统一过程" class="headerlink" title="统一过程"></a>统一过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a6d4004b4a88b542a3b60744ea61fa0bc0286a38/data/%E7%BB%9F%E4%B8%80%E8%BF%87%E7%A8%8B.jpg" style="zoom:150%;" />



<h3 id="敏捷开发方法"><a href="#敏捷开发方法" class="headerlink" title="敏捷开发方法"></a>敏捷开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/094d4931d137335862a4652dda044769f4724e11/data/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e9941766b405f6b796c6ad35cf1d00c8dd5e52ec/data/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.jpg" style="zoom:150%;" />



<h3 id="需求分类与需求获取"><a href="#需求分类与需求获取" class="headerlink" title="需求分类与需求获取"></a>需求分类与需求获取</h3><img src="https://raw.githubusercontent.com/P-luminary/images/0e7091e237ecadc19e2e7b191c975f4d22a2e920/data/%E9%9C%80%E6%B1%82%E5%88%86%E7%B1%BB%E4%B8%8E%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96.jpg" style="zoom:150%;" />



<h3 id="结构化设计：基本原则、内聚与耦合"><a href="#结构化设计：基本原则、内聚与耦合" class="headerlink" title="结构化设计：基本原则、内聚与耦合"></a>结构化设计：基本原则、内聚与耦合</h3><img src="https://raw.githubusercontent.com/P-luminary/images/5dbfbb4b62414e0f7badb40473f22b0df8078b24/data/%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2B%E5%86%85%E8%81%9A%E8%80%A6%E5%90%88.jpg"  />



<h3 id="结构化设计-—-系统结构-x2F-模块结构"><a href="#结构化设计-—-系统结构-x2F-模块结构" class="headerlink" title="结构化设计 — 系统结构&#x2F;模块结构"></a>结构化设计 — 系统结构&#x2F;模块结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/a003e2c14ea40399387d9f05450bba7019dd4893/data/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E3%80%81%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84.jpg"  />



<h3 id="软件测试-—-测试原型与类型"><a href="#软件测试-—-测试原型与类型" class="headerlink" title="软件测试 — 测试原型与类型"></a>软件测试 — 测试原型与类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b84b307d4d1b5810ceddc7301b06ba3c7717ccda/data/%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B.jpg" style="zoom:150%;" />



<h3 id="软件测试-—-测试用例设计"><a href="#软件测试-—-测试用例设计" class="headerlink" title="软件测试 — 测试用例设计"></a>软件测试 — 测试用例设计</h3><img src="https://raw.githubusercontent.com/P-luminary/images/46ed2bab41cbcb40fafbbaa2487b58c157668a67/data/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E2%80%94%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="软件测试-—-测试阶段"><a href="#软件测试-—-测试阶段" class="headerlink" title="软件测试 — 测试阶段"></a>软件测试 — 测试阶段</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d20a8c0ee445282402c3922a6bf949584ba9f08f/data/%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5.jpg"  />



<h3 id="McCabe复杂度"><a href="#McCabe复杂度" class="headerlink" title="  McCabe复杂度"></a><span style = "color:red">  McCabe复杂度</span></h3><p>McCabe度量法概念：</p>
<p>McCabe度量法是通过定义环路复杂度，建立程序复杂度的度量，他是基于一个程序模块的程序图中环路的个数。计算G的环路复杂型有两种方法：<br><strong>第一种是<span style = "color:red">V(G)&#x3D;m-n+2（m值得是有向弧数，也就是箭头的个数，n指的是结点个数</span></strong><br><strong>另外一种求法就是<span style = "color:red">闭合区域的个数+1</span></strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/1a9f9515b1e11b17d0b83762ee9bd874c8d450fd/data/McCadbe%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg"  /></p>
<h3 id="系统运行与维护"><a href="#系统运行与维护" class="headerlink" title="系统运行与维护"></a>系统运行与维护</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/44f90a15642e6a63893cbd9523466090a2d41f60/data/%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%92%8C%E7%BB%B4%E6%8A%A4.jpg"></p>
<h3 id="软件过程改进—CMMI"><a href="#软件过程改进—CMMI" class="headerlink" title="软件过程改进—CMMI"></a>软件过程改进—CMMI</h3><img src="https://raw.githubusercontent.com/P-luminary/images/555421c326e1c60558f4b1b0f7a2ce5cfd35dbbc/data/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B%E2%80%94CMMI.jpg" style="zoom:150%;" />



<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e4485104aee8d683f76cb7a54045d9308e260f70/data/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2B%E4%BE%8B%E9%A2%98.jpg"  />



<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><h6 id="风险是指”损失或伤害的可能性”"><a href="#风险是指”损失或伤害的可能性”" class="headerlink" title="风险是指”损失或伤害的可能性”"></a>风险是指”损失或伤害的可能性”</h6><p><u>软件风险一般包含<strong>不确定性</strong>和<strong>损失</strong></u>。<u><strong>救火</strong>和<strong>危机管理</strong>是对不适合但经常采用的软件风险管理策略</u>，<u><strong>已知风险</strong>和<strong>未知风险</strong>是对软件风险进行分类的一种方式</u>。<u><strong>员工</strong>和<strong>预算</strong>是在识别项目风险时需要识别的因素</u></p>
<p><strong>项目风险(关心未来)、技术风险(关心变化)、商业风险(关心选择)</strong><br><strong>风险曝光度(Risk Exposure)<strong>：计算方法是</strong>风险出现的概率 × 风险可能造成的损失</strong><br>假设正在开发的软件项目可能存在一个未被发现的错误，而这个错误出现的概率是0.5%，给公司造成的损失将是1000000元，那么这个错误的<strong>风险曝光度</strong>就应该为1000000×0.5%&#x3D;5000元</p>
<h3 id="需求开发-需求分析-OOA-—-相关概念"><a href="#需求开发-需求分析-OOA-—-相关概念" class="headerlink" title="需求开发,需求分析,OOA — 相关概念"></a>需求开发,需求分析,OOA — 相关概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9539033cf94cba3e4edaef3098f61e7ccc9704ea/data/%E9%9C%80%E6%B1%82%E5%BC%80%E5%8F%91%2C%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.OOA.jpg" style="zoom:150%;" />



<h3 id="面向对象设计-—-设计原则"><a href="#面向对象设计-—-设计原则" class="headerlink" title="面向对象设计 — 设计原则"></a>面向对象设计 — 设计原则</h3><p><strong>单一职责原则</strong>：设计目的单一的类 (单一会降低程序的耦合度)<br><strong>开放—封闭原则</strong>: 对<u>扩展</u>开放，对<u>修改</u>封闭 (用新的类去解决问题 不去修改[容易引入错误影响原先])<br><strong>李氏(Liskov)替换原则</strong>：子类可以替换父类 (不要盲目修改父类 不要去<strong>重载</strong>)<br><strong>接口隔离原则</strong>：使用多个专门的接口比使用单个的总接口要好<br><strong>组合重用原则</strong>：要尽量使用组合，而不是继承关系达到重用的目的<br>**迪米特(Demeter)原则(最少知识法则)**：一个对象应当对其他对象又尽可能少的了解  </p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><img src="https://raw.githubusercontent.com/P-luminary/images/fcb3f16cbb5d336b7895d58d40e877ff57652b4e/data/UML.jpg" style="zoom:150%;" />



<h3 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h3><p>**<u>√ 架构模式</u>**：软件设计中的高层决策，例如C&#x2F;S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策<br>**<u>√ 设计模式</u>**：主要关注软件系统的设计，与具体的实现语言无关<br>**<u>√ 惯用法</u>**：是最底层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用—计数就是C++语言中的一种惯用法 </p>
<h3 id="面向对象-—-设计模式的分类"><a href="#面向对象-—-设计模式的分类" class="headerlink" title="面向对象 — 设计模式的分类"></a>面向对象 — 设计模式的分类</h3><img src="https://raw.githubusercontent.com/P-luminary/images/9012605b3052dcc5d44c980ca3cac2f2f206697d/data/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB.jpg" style="zoom:150%;" />



<h3 id="面向对象-—-创建型模式"><a href="#面向对象-—-创建型模式" class="headerlink" title="面向对象 — 创建型模式"></a>面向对象 — 创建型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abstract Factory 抽象工厂模式</td>
<td>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需置顶它们具体的类</td>
</tr>
<tr>
<td>Builder 构建器模式</td>
<td>将一个复杂类的表示与其构造相分离，使得相同的构造过程能够得出不同的表示</td>
</tr>
<tr>
<td>Factory Method 工厂方法模式</td>
<td>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工程方法使得子类实例化的过程推迟</td>
</tr>
<tr>
<td>Prototype 原型模式</td>
<td>用原型实例指定创建对象的类型，并且通过拷贝这个原型来<strong>创建新的对象</strong></td>
</tr>
<tr>
<td>Singleton 单例模式</td>
<td>保证一个类只有一个实例，并提供一个访问它的全局访问点</td>
</tr>
</tbody></table>
<h3 id="面向对象-—-结构型模式"><a href="#面向对象-—-结构型模式" class="headerlink" title="面向对象 — 结构型模式"></a>面向对象 — 结构型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Adapter 适配器模式</td>
<td>将一个类的接口转换成用户希望得到的另一种接口。它使原来不相容的接口得以协同工作</td>
<td><strong>转换</strong>接口</td>
</tr>
<tr>
<td>Bridge 桥接模式</td>
<td>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化</td>
<td>继承树拆分</td>
</tr>
<tr>
<td>Composite 组合模式</td>
<td>将对象组合成树型结构以表示”整体—部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</td>
<td>树形目录结构</td>
</tr>
<tr>
<td>Decorator 装饰模式</td>
<td>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的代替，比派生一个子类更加灵活</td>
<td><strong>附加职责</strong></td>
</tr>
<tr>
<td>Facade 外观模式</td>
<td>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用</td>
<td>对外统一接口</td>
</tr>
<tr>
<td>Flyweight 享元模式</td>
<td>提供支持大量细粒度对象共享的有效方法</td>
<td></td>
</tr>
<tr>
<td>Proxy 代理模式</td>
<td>为其他对象提供一种代理以控制这个对象的访问</td>
<td></td>
</tr>
</tbody></table>
<h3 id="面向对象-—-行为型模式"><a href="#面向对象-—-行为型模式" class="headerlink" title="面向对象 — 行为型模式"></a>面向对象 — 行为型模式</h3><table>
<thead>
<tr>
<th>设计模式名称</th>
<th>简要说明</th>
<th>速记关键字</th>
</tr>
</thead>
<tbody><tr>
<td>Chain of Responsibility 职责链模式</td>
<td>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求</td>
<td><strong>传递职责</strong></td>
</tr>
<tr>
<td>Command 命令模式</td>
<td>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</td>
<td>日志记录，可<strong>撤销</strong></td>
</tr>
<tr>
<td>Interpreter 解释器模式</td>
<td>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</td>
<td></td>
</tr>
<tr>
<td>Iterator 迭代器模式</td>
<td>提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</td>
<td></td>
</tr>
<tr>
<td>Mediator 中介者模式</td>
<td>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地互相条用，从而达到低耦合，还可也独立地改变对象间的交互</td>
<td>不直接引用</td>
</tr>
<tr>
<td>Memento 备忘录模式</td>
<td>在不破坏封装性的前提下，捕捉一个对象的内部状态，并在该对象之外保存这个状态，从而可以在以后将该对象恢复到原先保存的状态</td>
<td></td>
</tr>
<tr>
<td>Observer 观察者模式</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新</td>
<td></td>
</tr>
<tr>
<td>State 状态模式</td>
<td>允许一个对象在其内部状态改变时改变它的行为</td>
<td>状态变成类</td>
</tr>
<tr>
<td>Strategy 策略模式</td>
<td>定义一系列算法，把它们一个个封装起来，并且使它们之间可相互替换，从而让算法可以独立于使用它的用户而变化</td>
<td>多方案切换</td>
</tr>
<tr>
<td>Template Method 模板方法模式</td>
<td>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</td>
<td></td>
</tr>
<tr>
<td>Visitor 访问者模式</td>
<td>表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</td>
<td></td>
</tr>
</tbody></table>
<h1 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a><span style = "color : red">数据流图(DFD)</span></h1><h3 id="数据流图基本概念"><a href="#数据流图基本概念" class="headerlink" title="数据流图基本概念"></a>数据流图基本概念</h3><img src="https://raw.githubusercontent.com/P-luminary/images/c8df5734504fe26e49886e57a4bb57abd5fda23b/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpg"  />



<h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>&#x3D;</strong></td>
<td>被定义为</td>
<td></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>与</td>
<td>x&#x3D;a+b, 表示x由a和b组成</td>
</tr>
<tr>
<td><strong>[… , …]或[… | …]</strong></td>
<td>或</td>
<td>x&#x3D;[a,b], x&#x3D;[a|b], 表示x由a或由b组成</td>
</tr>
<tr>
<td><strong>{…}</strong></td>
<td>重复</td>
<td>x&#x3D;{a}, 表示x由0个或多个a组成</td>
</tr>
<tr>
<td><strong>(…)</strong></td>
<td>可选</td>
<td>x&#x3D;(a), 表示a可在x中出现, 也可以不出现</td>
</tr>
</tbody></table>
<p>机票 &#x3D; 姓名 + 日期 + 航班号 + 起点 + 终点 + 费用<br>航班号 &#x3D; “Y7100”..”Y8100”<br>终点 &#x3D; [长沙|上海|北京|西安]</p>
<blockquote>
<p>选择四个其中的一个终点 </p>
</blockquote>
<h3 id="数据流图平衡原则"><a href="#数据流图平衡原则" class="headerlink" title="数据流图平衡原则"></a>数据流图平衡原则</h3><h6 id="父图与子图之间的平衡、子图内平衡"><a href="#父图与子图之间的平衡、子图内平衡" class="headerlink" title="父图与子图之间的平衡、子图内平衡"></a>父图与子图之间的平衡、子图内平衡</h6><img src="https://raw.githubusercontent.com/P-luminary/images/1c65b63a43bfe88afc4ce4e4042e655c99848c3c/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E5%B9%B3%E8%A1%A1%E5%8E%9F%E5%88%99.jpg" style="zoom: 150%;" />



<h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3><img src="https://raw.githubusercontent.com/P-luminary/images/514e5a6749072475b5c75298c83b77800d4abae2/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%AD%94%E9%A2%98%E6%8A%80%E5%B7%A7.jpg"  />



<h3 id="试题1"><a href="#试题1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/6d1ff8a821e6d03a30594af8710226314ef1e8fa/data/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E8%AF%95%E9%A2%981.png"  />

<img src="https://raw.githubusercontent.com/P-luminary/images/c2212e4f52fe19b0da0244a88e8b50c5a81d2683/data/%E8%AF%95%E9%A2%981.1.jpg" style="zoom:150%;" />

<h5 id="第一问解析"><a href="#第一问解析" class="headerlink" title="第一问解析"></a>第一问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/99c328ecf6d6a5e5499c59f436bb8d2f28f2a139/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%80%E9%97%AE.png" style="zoom: 200%;" /> 



<h5 id="第二问解析"><a href="#第二问解析" class="headerlink" title="第二问解析"></a>第二问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/a6be0c3e3b020d87eeba748e7bbe8ff9b4a8847e/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom: 200%;" />



<h5 id="第三问解析"><a href="#第三问解析" class="headerlink" title="第三问解析"></a>第三问解析</h5><img src="https://raw.githubusercontent.com/P-luminary/images/efe71851a6ab49d9ee52166ada7f60650d7c62b4/data/%E8%AF%95%E9%A2%981.1%E7%AC%AC%E4%B8%89%E9%97%AE.jpg" style="zoom:150%;" />



<h3 id="试题二"><a href="#试题二" class="headerlink" title="试题二"></a>试题二</h3><img src="https://raw.githubusercontent.com/P-luminary/images/38b4712590b799be692dd850b861ec1db1b23d23/data/%E8%AF%95%E9%A2%982.jpg"  />

<p><img src="https://raw.githubusercontent.com/P-luminary/images/6cf9bf40bae6cecb18dfdf18be5711806ea7ddcf/data/%E8%AF%95%E9%A2%982.1.jpg"></p>
<h5 id="试题2第一问、第二问"><a href="#试题2第一问、第二问" class="headerlink" title="试题2第一问、第二问"></a>试题2第一问、第二问</h5><img src="https://raw.githubusercontent.com/P-luminary/images/e6d32f02094ef61c5486ff737e8f7c1b285a9f07/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E7%AC%AC%E4%BA%8C%E9%97%AE.jpg" style="zoom:200%;" />



<h5 id="试题2第三问-顶层和0层进行匹配-、第四问-从题干推导"><a href="#试题2第三问-顶层和0层进行匹配-、第四问-从题干推导" class="headerlink" title="试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)"></a>试题2第三问 (顶层和0层进行匹配)、第四问(从题干推导)</h5><img src="https://raw.githubusercontent.com/P-luminary/images/973540b5ce58d035d1c63fd26275bc3d3691dbef/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%89%E9%97%AE%E7%AC%AC%E5%9B%9B%E9%97%AE.jpg" style="zoom:200%;" />



<h3 id="数据库设计过程-1"><a href="#数据库设计过程-1" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><img src="https://raw.githubusercontent.com/P-luminary/images/4a7e717516686bf53a3016f10555bd298228bb96/data/1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.jpg" style="zoom: 200%;" />



<h3 id="ER模型-—-实体间联系类型"><a href="#ER模型-—-实体间联系类型" class="headerlink" title="ER模型 — 实体间联系类型"></a>ER模型 — 实体间联系类型</h3><img src="https://raw.githubusercontent.com/P-luminary/images/aef35208a0e0eef63f136821f90002f1f81ae413/data/ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg" style="zoom:150%;" />



<h3 id="数据库设计答题技巧"><a href="#数据库设计答题技巧" class="headerlink" title="数据库设计答题技巧"></a>数据库设计答题技巧</h3><h6 id="详细分析试题说明"><a href="#详细分析试题说明" class="headerlink" title="详细分析试题说明"></a>详细分析试题说明</h6><h6 id="熟练掌握基本知识"><a href="#熟练掌握基本知识" class="headerlink" title="熟练掌握基本知识"></a>熟练掌握基本知识</h6><h3 id="试题1-1"><a href="#试题1-1" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7bc5db4a5d355f37629a9621e0e789c10b5e7359/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />



<h3 id="试题2"><a href="#试题2" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/10655b1b9f65d0e3145e7d58aec329857bad9fc0/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%95%E9%A2%982.png" style="zoom:150%;" />

<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/d40fd82221eb61d4fdd90e911632ab483c946fbb/data/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BE%8B%E9%A2%982%E8%A7%A3%E6%9E%90.jpg"  />



<h1 id="UML建模"><a href="#UML建模" class="headerlink" title="UML建模"></a><span style = "color : red">UML建模</span></h1><h6 id="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"><a href="#用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图" class="headerlink" title="用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图"></a>用例图、类图与对象图、顺序图、活动图、状态图、通信图、构件图</h6><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/e2480d16b16b8b911584fe9f6ded8b19fcbea258/data/%E7%94%A8%E4%BE%8B%E5%9B%BE.jpg" style="zoom:150%;" />



<h3 id="类图与对象图"><a href="#类图与对象图" class="headerlink" title="类图与对象图"></a>类图与对象图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/7e6cb7c946c5e51dc027f64e32e230d0af3e07e7/data/%E7%B1%BB%E5%9B%BE%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" style="zoom:150%;" />



<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/da0cdf7024603417383dedd7f56ffefdc07b7a84/data/%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg"></p>
<h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><img src="https://raw.githubusercontent.com/P-luminary/images/f3191e64c57a67bd754427957ff3998827d6c647/data/%E6%B4%BB%E5%8A%A8%E5%9B%BE.jpg"  />



<h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/d1f705c371a7460cb2078e7c4a1ee9c0b9c36597/data/%E7%8A%B6%E6%80%81%E5%9B%BE.jpg"></p>
<h3 id="通信图-顺序图-通信图-x3D-交互图"><a href="#通信图-顺序图-通信图-x3D-交互图" class="headerlink" title="通信图 (顺序图+通信图&#x3D;交互图)"></a>通信图 (顺序图+通信图&#x3D;交互图)</h3><p>区别：<strong>顺序图</strong>会强调时间顺序</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/4fd0cbc15294926e42fe33e61b7f0035a208ae7a/data/%E9%80%9A%E4%BF%A1%E5%9B%BE.jpg"  />



<h3 id="试题1-2"><a href="#试题1-2" class="headerlink" title="试题1"></a>试题1</h3><img src="https://raw.githubusercontent.com/P-luminary/images/914174f05e1265a79bd512c49afe191e67b83ad2/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981.jpg"  />



<h6 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/ffff4a52c486091b284f830b2cda215a26fadc78/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%981%E8%A7%A3%E6%9E%90.jpg"  />



<h3 id="试题2-1"><a href="#试题2-1" class="headerlink" title="试题2"></a>试题2</h3><img src="https://raw.githubusercontent.com/P-luminary/images/b69f8c920bf06a3a3558f95693f3ea0fd04743ee/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982.jpg"  />



<h6 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/a23639f98414f903a56cad32ca174c6f0cd403d0/data/%E8%AF%95%E9%A2%982%E7%AC%AC%E4%B8%80%E9%97%AE%E8%A7%A3%E6%9E%90.jpg" style="zoom: 200%;" />



<h6 id="第二、三问"><a href="#第二、三问" class="headerlink" title="第二、三问"></a>第二、三问</h6><img src="https://raw.githubusercontent.com/P-luminary/images/47d8911eaacde30888938f1e434255a077c68f44/data/UML%E5%BB%BA%E6%A8%A1%E8%AF%95%E9%A2%982%E7%AC%AC%E4%BA%8C%E4%B8%89%E9%97%AE.jpg" style="zoom: 200%;" />



<h1 id="★★数据结构及算法应用★★-下午题"><a href="#★★数据结构及算法应用★★-下午题" class="headerlink" title="★★数据结构及算法应用★★(下午题)"></a>★★<span style = "color : red">数据结构及算法应用</span>★★(下午题)</h1><h6 id="分治法、回溯法、贪心法、动态规划法"><a href="#分治法、回溯法、贪心法、动态规划法" class="headerlink" title="分治法、回溯法、贪心法、动态规划法"></a>分治法、回溯法、贪心法、动态规划法</h6><h3 id="分治法-★★-分解-解决-合并-★★-一般用到递归"><a href="#分治法-★★-分解-解决-合并-★★-一般用到递归" class="headerlink" title="分治法(★★ 分解 解决 合并 ★★) [一般用到递归]"></a>分治法(★★ 分解 解决 合并 ★★) [一般用到递归]</h3><p><strong>对于一个规模为n的问题，若该问题可以容易地解决 (比如说规模n较小) 则直接解决；否则将其分解为k个规模较小的子问题，这些子问题相互独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解</strong></p>
<p>★ 该问题的规模缩小到一定的程度就可以容易地解决<br>★ 该问题可以分解为若干个规模较小的相同子问题<br>★ 利用该问题解决出的子问题的解可以合并为该问题的解<br>★ 该问题所分解出的各个子问题是相互独立的</p>
<h5 id="递归，就是在运行的过程中调用自己"><a href="#递归，就是在运行的过程中调用自己" class="headerlink" title="递归，就是在运行的过程中调用自己"></a>递归，就是在运行的过程中调用自己</h5><pre><code class="java">int F(int n)
&#123;
    if(n==0) return 1;
    if(n==1) return 1;
    if(n&gt;1) return F(n-1)+F(n-2);
&#125;
</code></pre>
<h3 id="分治法-→-二分查找"><a href="#分治法-→-二分查找" class="headerlink" title="分治法 → 二分查找"></a>分治法 → 二分查找</h3><pre><code class="java">function Binary_Search(L,a,b,x)&#123;
    if(a &gt; b) return(-1);
    else&#123;
        m=(a+b)/2;
        if(x==L[m]) return(m);
        else if(x &gt; L[m])
            return(Binary_Search(L,m+1,b,x));
        else
            return(Binary_Search(L,a,m-1,x));
    &#125;
&#125;
</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/8d1e0521f94cd0d6b1ddf5bee2749ba0f49990b6/data/%E5%9B%9E%E6%BA%AF%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/13d82930889e1c9e254f8685c57c9d092d5a1634/data/%E8%B4%AA%E5%BF%83%E6%B3%95.png" style="zoom: 200%;" />



<h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/eaa958ff79a07a2e5bb606da5dac0cf195f4f6e1/data/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95.jpg" style="zoom: 200%;" />



<h3 id="数据结构算法例题"><a href="#数据结构算法例题" class="headerlink" title="数据结构算法例题"></a>数据结构算法例题</h3><h6 id="试题1-3"><a href="#试题1-3" class="headerlink" title="试题1"></a>试题1</h6><img src="https://raw.githubusercontent.com/P-luminary/images/6cfb68cba4f6641134b0b229642a0b10a9fbb39b/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981.jpg" style="zoom:200%;" />



<h6 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/780bbd00eefa211c7ff3261c7ce6b7f86e244aca/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%981%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />





<h6 id="试题2及解析"><a href="#试题2及解析" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/3894f1902e34206481d9cff7a866422151ce0ee8/data/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:;" />



<h1 id="★★★★★面向对象程序设计-下午题-★★★★★"><a href="#★★★★★面向对象程序设计-下午题-★★★★★" class="headerlink" title="★★★★★面向对象程序设计(下午题)★★★★★"></a>★★★★★<span style = "color : red">面向对象程序设计</span>(下午题)★★★★★</h1><h3 id="C-类与派生类的定义"><a href="#C-类与派生类的定义" class="headerlink" title="C++ 类与派生类的定义"></a>C++ 类与派生类的定义</h3><pre><code class="c++">class 类名&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;;
</code></pre>
<pre><code class="c++">class 派生类名：继承方法1 基类名1，继承方法2 基类名2,...&#123;
    public:
        派生类的公有数据和函数
    protected:
        派生类的保护数据和函数
    private:
        派生类的私有数据和函数
&#125;;
</code></pre>
<pre><code class="c++">在类外定义函数体的格式如下：
返回值类型 类名 :: 成员函数名(形参表)&#123;
    函数体;
&#125;
::是类的作用域分辨符，用在此处，放在类名后成员函数前，表明后面的成员东西函数属于前面的那个类
</code></pre>
<h3 id="C-构造函数与析构函数"><a href="#C-构造函数与析构函数" class="headerlink" title="C++构造函数与析构函数"></a>C++构造函数与析构函数</h3><blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.构造函数的函数名必须与定义它的类同名<br>2.构造函数没有返回值。如果在构造函数前加void是错误的<br>3.构造函数被声明定义为公有函数<br>4.构造函数在建立对象时由系统自动调用</p>
</blockquote>
<blockquote>
<p>构造函数相对于一般函数来说，具有如下特殊的性质：<br>1.析构函数没有任何参数，不能被重载，但是可以是虚函数，一个类只有一个析构函数<br>2.析构函数没有返回值<br>3.析构函数名与类名相同，但在类名前加一个逻辑非运算符 “~” 以表示与构造函数对比区别<br>4.析构函数一般由用户自己定义，在对象消失时由系统自动调用，如果用户没有定义析构函数，系统将自动生成一个不做任何事的默认析构函数</p>
</blockquote>
<pre><code class="c++">对象指针的语法定义形式如下：
    类名 *对象指针名;
</code></pre>
<pre><code class="c++">对象引用的定义形式如下：
    类名 &amp;对象引用名 = 被引用对象;
</code></pre>
<blockquote>
<p>注意：通过对象名或对象引用访问对象的成员，使用的运算符是 “.” 而使用对象指针访问对象成员，使用的运算符是 “-&gt;” </p>
<pre><code class="c++">对象指针名 -&gt; 数据成员名或 : 对象指针名 -&gt; 成员函数名(参数表) 
</code></pre>
</blockquote>
<h3 id="C-虚函数"><a href="#C-虚函数" class="headerlink" title="C++虚函数"></a><span style = "color : red">C++虚函数</span></h3><pre><code class="c++">虚函数定义的一般语法形式如下:
virtual 函数类型 函数名(形参表)&#123;
    函数体;
&#125;
纯虚函数定义形式如下：
virtual 函数名 = 0;
</code></pre>
<h3 id="JAVA-类的定义"><a href="#JAVA-类的定义" class="headerlink" title="JAVA 类的定义"></a>JAVA 类的定义</h3><pre><code class="java">类的定义格式如下：
[import包]
[类修饰符] class xxxclass [extends超类] [implements接口]&#123;
    public:
        公有数据成员或公有函数成员的定义;
    protected:
        保护数据成员或保护函数成员的定义;
    private:
        私有数据成员或私有函数成员的定义;
&#125;
说明：
import包：引入包中的类
类修饰符：主要由四个修饰符(public、abstract、final、private)
class为关键字, xxxclass为类名，命名遵循Java标识符的命名规则
extends为继承关键字，implements为接口关键字
    
抽象类定义
abstract class Shape&#123;
    abstract public void draw() [定义了draw抽象方法]
&#125;

class Rectangle extends Shape&#123;&#125;
通过extends可以看出来Shape不是接口而是抽象类
</code></pre>
<pre><code class="java">import java.util.*;
(1) class Beverage&#123; //饮料
    String description = &quot;Unknown Beverage&quot;;
    public (2) ()&#123;return description;&#125;
        public (3);
&#125;
abstract class CondimentDecorator extends Beverage&#123;
    //配料
    (4);
&#125;

(1) abstract
(2) String getDescription
(3) abstract int cost()
(4) Beverage beverage
</code></pre>
<h3 id="JAVA-接口的定义"><a href="#JAVA-接口的定义" class="headerlink" title="JAVA 接口的定义"></a>JAVA 接口的定义</h3><pre><code class="java">interface IFactory&#123;&#125;
class SqlServerFactory implements IFactory
通过implements实现关键字来反推interface关键字
</code></pre>
<h3 id="面向程序设计"><a href="#面向程序设计" class="headerlink" title="面向程序设计"></a>面向程序设计</h3><h6 id="试题1及解析"><a href="#试题1及解析" class="headerlink" title="试题1及解析"></a>试题1及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/4d295300a1b912819bf30f980a891b23c6749154/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%981%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom:200%;" />

<h6 id="试题2及解析-1"><a href="#试题2及解析-1" class="headerlink" title="试题2及解析"></a>试题2及解析</h6><img src="https://raw.githubusercontent.com/P-luminary/images/2f0c15a8321c8414a2eae0bc4ff245c483b9c943/data/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%95%E9%A2%982%E5%8F%8A%E8%A7%A3%E6%9E%90.jpg" style="zoom: 150%;" />




















            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/软考" style=color:#ff7d73>
                软考
            </a>
        </span>
        
    </div>

    <a href="/2023/05/06/软考/软件设计师考点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/03/22/政治/二十大知识点/">
        <h2>
            二十大知识点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="大会主题"><a href="#大会主题" class="headerlink" title="大会主题"></a>大会主题</h4><p><strong>高举</strong>中国特色社会主义伟大旗帜，<strong>全面贯彻</strong>新时代中国特色社会主义思想，<strong>弘扬</strong>伟大建党精神，自信自强、守正创新、着力奋发、勇毅前行，为全面建设社会主义现代化国家、<strong>全面推进</strong>中华民族伟大复兴而团结奋斗</p>
<h4 id="x3D-x3D-三个务必-x3D-x3D"><a href="#x3D-x3D-三个务必-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;三个务必&#x3D;&#x3D;"></a>&#x3D;&#x3D;三个务必&#x3D;&#x3D;</h4><p>务必不忘初心、牢记使命，务必谦虚谨慎、艰苦奋斗，务必敢于斗争、善于斗争</p>
<h4 id="x3D-x3D-十年来经历了哪三件大事-x3D-x3D-多"><a href="#x3D-x3D-十年来经历了哪三件大事-x3D-x3D-多" class="headerlink" title="&#x3D;&#x3D;十年来经历了哪三件大事&#x3D;&#x3D;[多]"></a>&#x3D;&#x3D;十年来经历了哪三件大事&#x3D;&#x3D;[多]</h4><p>迎来了中国共产党成立一百周年<br>中国特色社会主义进入新时代<br>完成脱贫攻坚、全面建成小康社会的历史任务，实现第一个百年奋斗目标。</p>
<h4 id="五年来的大事-多"><a href="#五年来的大事-多" class="headerlink" title="五年来的大事[多]"></a>五年来的大事[多]</h4><p>坚持加强党的全面领导和党中央集中统一领导<br>统筹疫情防控和经济社会发展取得重大积极成果<br>香港局势实现由乱到治的重大转折<br>坚持开展反分裂、反干涉重大斗争<br>牢牢掌握了我国发展和安全主动权</p>
<h4 id="开辟马克思主义中国化时代化新境界"><a href="#开辟马克思主义中国化时代化新境界" class="headerlink" title="开辟马克思主义中国化时代化新境界"></a>开辟马克思主义中国化时代化新境界</h4><h6 id="两个”行”-选"><a href="#两个”行”-选" class="headerlink" title="两个”行” [选]"></a>两个”行” [选]</h6><p>中国共产党为什么能，中国特色社会主义为什么好，归根到底是<strong>马克思主义行</strong>，是<strong>中国化时代化的马克思主义行</strong></p>
<h6 id="六个”必须坚持”-习近平新时代中国特色社会主义思想的方法论和世界观"><a href="#六个”必须坚持”-习近平新时代中国特色社会主义思想的方法论和世界观" class="headerlink" title="六个”必须坚持”(习近平新时代中国特色社会主义思想的方法论和世界观)"></a>六个”必须坚持”(习近平新时代中国特色社会主义思想的方法论和世界观)</h6><p>必须<strong>坚持人民至上、坚持自信自立、坚持守正创新、坚持问题导向、坚持系统观念、坚持胸怀天下</strong></p>
<h4 id="新时代新征程中国共产党的历史任务"><a href="#新时代新征程中国共产党的历史任务" class="headerlink" title="新时代新征程中国共产党的历史任务"></a>新时代新征程中国共产党的历史任务</h4><h6 id="中心任务"><a href="#中心任务" class="headerlink" title="中心任务"></a>中心任务</h6><p>团结带领全国各族人民<strong>全面建成社会主义现代化强国、实现第二个百年奋斗目标</strong>，<u>以<strong>中国式现代化</strong>全面推进<strong>中华民族伟大复兴</strong></u></p>
<h6 id="中国式现代化"><a href="#中国式现代化" class="headerlink" title="中国式现代化"></a>中国式现代化</h6><p>是中国共产党领导的社会主义现代化<br>是人口规模巨大的现代化<br>是全体人民共同富裕的现代化<br>是物质文明和精神文明相协调的现代化<br>是人与自然和谐共生的现代化<br>是走和平发展道路的现代化</p>
<h6 id="本质要求"><a href="#本质要求" class="headerlink" title="本质要求"></a>本质要求</h6><p>坚持中国共产党领导<br>坚持中国特色社会主义<br>实现高质量发展，发展全过程人民民主<br>丰富人民精神世界，实现全体人民共同富裕<br>促进人与自然和谐共生，<br>推进构建人类命运共同体，构造人类文明形形态</p>
<h4 id="全面建成社会主义现代化强国"><a href="#全面建成社会主义现代化强国" class="headerlink" title="全面建成社会主义现代化强国"></a>全面建成社会主义现代化强国</h4><h6 id="重大原则"><a href="#重大原则" class="headerlink" title="重大原则"></a>重大原则</h6><p>坚持和加强党的全面领导<br>坚持中国特色社会主义道路<br>坚持以人民为中心的发展思想<br>坚持深化改革开放<br>坚持发扬斗争精神</p>
<h4 id="加快构建新发展格局，着力推动高质量发展"><a href="#加快构建新发展格局，着力推动高质量发展" class="headerlink" title="加快构建新发展格局，着力推动高质量发展"></a>加快构建新发展格局，着力推动高质量发展</h4><h6 id="高质量发展"><a href="#高质量发展" class="headerlink" title="高质量发展"></a>高质量发展</h6><p>是全面建设社会主义现代化国家的<strong>首要任务</strong><br>没有坚实的物质技术基础，就不能全面建成社会主义现代化强国</p>
<h6 id="构建高水平社会主义市场经济体制"><a href="#构建高水平社会主义市场经济体制" class="headerlink" title="构建高水平社会主义市场经济体制"></a>构建高水平社会主义市场经济体制</h6><p>建设现代化产业体系<br>全面推进乡村振兴<br>促进区域协调发展<br>推进高水平对外开放</p>
<h4 id="实施科教兴国战略，强化现代化建设人才支撑"><a href="#实施科教兴国战略，强化现代化建设人才支撑" class="headerlink" title="实施科教兴国战略，强化现代化建设人才支撑"></a>实施科教兴国战略，强化现代化建设人才支撑</h4><p>教育、科技、人才是全面建设社会主义现代化国家的<strong>基础性、战略性支撑</strong><br>必须坚持科技是第一生产力、人才是第一资源、创新是第一动力，深入实施科教兴国、人才强国、创新驱动发展战略，开辟发展新领域新赛道，不断塑造发展新动能新优势</p>
<h4 id="发展全过程人民民主，保障人民当家做主"><a href="#发展全过程人民民主，保障人民当家做主" class="headerlink" title="发展全过程人民民主，保障人民当家做主"></a>发展全过程人民民主，保障人民当家做主</h4><p>人民民主是<strong>社会主义的生命、是全面建设社会主义现代化国家的应有之义</strong></p>
<h4 id="积极发展基层民主"><a href="#积极发展基层民主" class="headerlink" title="积极发展基层民主"></a>积极发展基层民主</h4><p>人民当家做主最有效、最广泛的途径</p>
<h4 id="坚持全面依法治国，推进法治中国建设"><a href="#坚持全面依法治国，推进法治中国建设" class="headerlink" title="坚持全面依法治国，推进法治中国建设"></a>坚持全面依法治国，推进法治中国建设</h4><h6 id="全面依法治国-多"><a href="#全面依法治国-多" class="headerlink" title="全面依法治国[多]"></a>全面依法治国[多]</h6><p>关系党执政兴国<br>关系人民幸福安康<br>关系党和国家长治久安</p>
<h4 id="增进民生福祉，提高人民生活品质"><a href="#增进民生福祉，提高人民生活品质" class="headerlink" title="增进民生福祉，提高人民生活品质"></a>增进民生福祉，提高人民生活品质</h4><p><strong>为民造福</strong>是立党为公、执政为民的<strong>本质要求</strong></p>
<h4 id="x3D-x3D-青年强，则国家强【截图】-x3D-x3D"><a href="#x3D-x3D-青年强，则国家强【截图】-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;青年强，则国家强【截图】&#x3D;&#x3D;"></a>&#x3D;&#x3D;青年强，则国家强【截图】&#x3D;&#x3D;</h4><h1 id="x3D-x3D-材料分析题整理-x3D-x3D"><a href="#x3D-x3D-材料分析题整理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;材料分析题整理&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>材料分析题整理</strong>&#x3D;&#x3D;</h1><hr>
<h1 id="政府工作报告-2023-4-3"><a href="#政府工作报告-2023-4-3" class="headerlink" title="政府工作报告[2023.4.3]"></a><span style ="color : red">政府工作报告</span>[2023.4.3]</h1><h4 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h4><p><strong>全国国内生产总值增长3%  GDP</strong><br><strong>城镇新增就业1206万人</strong><br><strong>年末城镇调查失业率降到5.5%</strong><br><strong>居民消费价格上涨2% CPI</strong><br><strong>粮食产量1.37万亿斤，增产74亿斤</strong></p>
<blockquote>
<p>确保粮食安全的底线</p>
</blockquote>
<p>国内生产总值121万亿元 (跨越了121万亿人民币 18万亿美元)<br>五年来经济增长5.2%    十年平均增长6.2%</p>
<p><strong>十年来取得的成就</strong>(五位一体+四个全面)</p>
<h4 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h4><p>预计<strong>GDP</strong>增长5%<br>预计<strong>CPI</strong>居民消费价格上涨2%<br>粮食产量保持在1.37万亿斤以上</p>
<h5 id="23年经济工作的总基调"><a href="#23年经济工作的总基调" class="headerlink" title="23年经济工作的总基调"></a>23年经济工作的总基调</h5><p>稳字当头，稳中求进</p>
<h5 id="党建工作的总基调"><a href="#党建工作的总基调" class="headerlink" title="党建工作的总基调"></a>党建工作的总基调</h5><p>全面从严治党</p>
<h5 id="积极的财政政策要加力提效"><a href="#积极的财政政策要加力提效" class="headerlink" title="积极的财政政策要加力提效"></a>积极的财政政策要加力提效</h5><h5 id="稳健的货币政策要精准有力"><a href="#稳健的货币政策要精准有力" class="headerlink" title="稳健的货币政策要精准有力"></a>稳健的货币政策要精准有力</h5><h5 id="产业政策要发展和安全并举"><a href="#产业政策要发展和安全并举" class="headerlink" title="产业政策要发展和安全并举"></a>产业政策要发展和安全并举</h5><h5 id="科技政策要聚焦自立自强"><a href="#科技政策要聚焦自立自强" class="headerlink" title="科技政策要聚焦自立自强"></a>科技政策要聚焦自立自强</h5><h5 id="社会政策要兜牢民生底线"><a href="#社会政策要兜牢民生底线" class="headerlink" title="社会政策要兜牢民生底线"></a>社会政策要兜牢民生底线</h5><hr>
<h1 id="高频词语"><a href="#高频词语" class="headerlink" title="高频词语"></a><span style ="color : red">高频词语</span></h1><h4 id="人类命运共同体的提出-10周年"><a href="#人类命运共同体的提出-10周年" class="headerlink" title="人类命运共同体的提出[10周年]"></a>人类命运共同体的提出[10周年]</h4><p>2013年3月23日<br>构建人类命运共同体，<strong>核心</strong>就是<u>建设&#x3D;&#x3D;<strong>持久和平[政治]、普遍安全[安全]、共同繁荣[经济]、开放包容[文化]、清洁美丽[生态]</strong>&#x3D;&#x3D;的世界</u>。**<u>[平安繁荣节 -&gt; 平，安，繁，容，洁]</u>**</p>
<h4 id="构建人类命运共同体的价值支撑"><a href="#构建人类命运共同体的价值支撑" class="headerlink" title="构建人类命运共同体的价值支撑"></a>构建人类命运共同体的价值支撑</h4><h6 id="全人类共同价值：和平、发展、公平、正义、民主、自由"><a href="#全人类共同价值：和平、发展、公平、正义、民主、自由" class="headerlink" title="全人类共同价值：和平、发展、公平、正义、民主、自由"></a>全人类共同价值：和平、发展、公平、正义、民主、自由</h6><h4 id="构建人类命运共同体的目标"><a href="#构建人类命运共同体的目标" class="headerlink" title="构建人类命运共同体的目标"></a>构建人类命运共同体的目标</h4><p>建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界</p>
<h4 id="如何推动构建人类命运共同体"><a href="#如何推动构建人类命运共同体" class="headerlink" title="如何推动构建人类命运共同体"></a>如何推动构建人类命运共同体</h4><p><u>以<strong>和平问题</strong>为主体提出了以下5个<strong>内涵</strong></u><br>(1) &#x3D;&#x3D;<strong>政治</strong>上，要<strong>相互尊重、平等协商</strong>，坚决<strong>摒弃冷战思维和强权政治</strong>&#x3D;&#x3D;，走对话而不对抗、结伴而不结盟的国与国交往新路。<br>(2) &#x3D;&#x3D;<strong>安全</strong>上<del>相处之道</del>，要坚持<strong>以对话<del>方法</del>解决争端、以协商<del>方法</del>化解分歧</strong>&#x3D;&#x3D;，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。<br>(3) &#x3D;&#x3D;<strong>经济</strong>上<del>怎么做</del>，要同舟共济，促进贸易和投资自由化便利化、推动经济全球化朝着更加<strong>开放、包容、普惠、平衡、共赢</strong>的方向发展。&#x3D;&#x3D;[以世界贸易组织促进]<br>(4) &#x3D;&#x3D;<strong>文化</strong>上，要尊重世界文明多样性，促进文明交流、加强文明互鉴实现文明共存&#x3D;&#x3D;。<br>(5) &#x3D;&#x3D;<strong>生态</strong>上，要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园&#x3D;&#x3D;。</p>
<h4 id="构建人类命运共同体的中国行动-推动新型国际关系"><a href="#构建人类命运共同体的中国行动-推动新型国际关系" class="headerlink" title="构建人类命运共同体的中国行动 (推动新型国际关系)"></a>构建人类命运共同体的中国行动 (推动新型国际关系)</h4><p>坚定奉行独立自主的和平外交政策</p>
<h4 id="构建人类命运共同体的生动实践"><a href="#构建人类命运共同体的生动实践" class="headerlink" title="构建人类命运共同体的生动实践"></a>构建人类命运共同体的生动实践</h4><p>[丝绸之路经济带、21世纪海上丝绸之路]</p>
<p>“一带一路”：倡议：从愿景<br>原则：共商共建共享<br>理念：丝绸之路的精神：和平合作 开放包容 互学互鉴 合作共赢<br>努力实现<strong>政策沟通、设施联通、贸易畅通、资金融通、民心相通</strong>；这五通-&gt;全方位推动务实合作，打造<strong>政治互信、经济融合、文化包容</strong>的<strong>利益共同体、责任共同体和命运共同体</strong></p>
<h1 id="乡村振兴"><a href="#乡村振兴" class="headerlink" title="乡村振兴"></a>乡村振兴</h1><p><strong>总目标</strong>：农业农村的现代化<br><strong>总方针</strong>：坚持农业农村优先发展[]<br><strong>总要求</strong>：产出兴旺，生态宜居、乡风文明、治理有效、生活富裕<br><strong>制度保障：</strong>建立健全城乡融合发展体制机制和政策体制</p>
<h4 id="乡村振兴战略时间表"><a href="#乡村振兴战略时间表" class="headerlink" title="乡村振兴战略时间表"></a>乡村振兴战略时间表</h4><p>第二步 到2035年农村振兴取得决定性进展，农业农村现代化基本实现<br>第三步 到2050年农村全面振兴、国家强，农村兴</p>
<h4 id="乡村振兴-1"><a href="#乡村振兴-1" class="headerlink" title="乡村振兴"></a>乡村振兴</h4><p>产业、组织、文化、生态、人才振兴</p>
<h4 id="x3D-x3D-推进乡村振兴守住两条底线-x3D-x3D"><a href="#x3D-x3D-推进乡村振兴守住两条底线-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;推进乡村振兴守住两条底线&#x3D;&#x3D;"></a>&#x3D;&#x3D;推进乡村振兴守住两条底线&#x3D;&#x3D;</h4><p>牢牢守住保障<strong>国家粮食安全</strong>底线<br>牢牢守住<strong>不发生规模性返贫</strong>底线</p>
<h4 id="乡村振兴如何做"><a href="#乡村振兴如何做" class="headerlink" title="乡村振兴如何做"></a>乡村振兴如何做</h4><p>坚持农业农村优先发展<br>加快建设农业强国<br>全方位夯实粮食安全根基<br>树立大食物观<br>发展农村特色产业<br>巩固拓展脱贫攻坚成果<br>统筹乡村基础设施和公共服务布局<br>巩固和完善农村基本经济制度<br>深化农村土地制度改革<br>保障进城落户农民合法土地权益<br>完善农业支持保障制度                                                                       </p>
<h1 id="高质量发展-1"><a href="#高质量发展-1" class="headerlink" title="高质量发展"></a>高质量发展</h1><p>&#x3D;&#x3D;<strong>为什么推动高质量发展</strong>？&#x3D;&#x3D;[<u><strong>新发展阶段  新发展理念 新发展格局 高质量发展</strong></u>(三新一高)]<br>保持经济<u>持续健康发展</u>的必然要求<br>适应我国<u>社会主要矛盾变化</u>和<u>全面建成小康社会</u>、<u>全面建设社会主义现代化国家</u>的必然要求<br>遵循<u>经济规律发展</u>的必然要求</p>
<h5 id="我们要实现怎样的高质量发展"><a href="#我们要实现怎样的高质量发展" class="headerlink" title="我们要实现怎样的高质量发展"></a>我们要实现怎样的高质量发展</h5><p>创新 协调 绿色 开放 共享(新发展理念)</p>
<h5 id="推动高质量发展的五个着力点"><a href="#推动高质量发展的五个着力点" class="headerlink" title="推动高质量发展的五个着力点"></a>推动高质量发展的五个着力点</h5><p>构建高水平社会主义市场经济体制<br>建设现代化产业体系<br>全面推进乡村振兴<br>促进区域协调发展<br>推进高水平对外开放</p>
<h1 id="美丽中国"><a href="#美丽中国" class="headerlink" title="美丽中国"></a>美丽中国</h1><h5 id="为什么要重视生态文明建设？"><a href="#为什么要重视生态文明建设？" class="headerlink" title="为什么要重视生态文明建设？"></a>为什么要重视生态文明建设？</h5><p>在”五位一体”总体布局中，生态文明建设<br>在新发展理念中，绿色是其中一项<br>在三大攻坚战中，污染防治是其中一战</p>
<h5 id="生态文明建设要遵循原则-x3D-gt-习近平生态文明思想主要内容"><a href="#生态文明建设要遵循原则-x3D-gt-习近平生态文明思想主要内容" class="headerlink" title="生态文明建设要遵循原则 &#x3D;&gt; 习近平生态文明思想主要内容"></a>生态文明建设要遵循原则 &#x3D;&gt; 习近平生态文明思想主要内容</h5><p>两山理论核心内容：经济发展与保护环境的关系</p>
<h5 id="美丽中国建设评估指标体系"><a href="#美丽中国建设评估指标体系" class="headerlink" title="美丽中国建设评估指标体系"></a>美丽中国建设评估指标体系</h5><p>空气清新、水体洁净、土壤安全、人居整洁、生态良好</p>
<h5 id="美丽中国建设行动指南"><a href="#美丽中国建设行动指南" class="headerlink" title="美丽中国建设行动指南"></a>美丽中国建设行动指南</h5><p>加快发展方式绿色转向<br>深入推进环境污染防治<br>提升生态系统多样性、稳定性、持续性<br>积极稳妥推进碳达峰碳中和</p>
<p><strong>可持续发展道路</strong>是一条<strong>生存发展、生活富裕、生态良好</strong>的文明发展道路</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h5 id="x3D-x3D-导入二十大报告-x3D-x3D"><a href="#x3D-x3D-导入二十大报告-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;导入二十大报告&#x3D;&#x3D;"></a>&#x3D;&#x3D;导入二十大报告&#x3D;&#x3D;</h5><p>用<strong>党的创新理论</strong>武装全党是党的思想建设的<strong>根本任务</strong><br>党的思想建设的首要任务是：<strong>坚定理想信念</strong><br>为民造福是<strong>立党为公、执政为民的本质要求</strong><br><strong>腐败</strong>是危害党的生命力和战斗力的<strong>最大毒瘤</strong>，反腐败是最彻底的自我革命<br><strong>高质量发展</strong>：是全面建设社会主义现代化国家的首要任务，要坚持以推动高质量发展为主体。<br>推动经济社会发展<u>绿色化、低碳化</u>是<strong>实现高质量发展的关键环节</strong><br>人民民主是社会主义的生命，是全面建设社会主义现代化国家的应有之义<br><strong>全过程人民民主</strong>是社会主义民主政治的本质属性，是最广泛，最真实，最管用的民主。<br><strong>协商民主</strong>是<strong>实践全过程人民民主的重要形式</strong>。<strong>基层民主</strong>是<strong>全过程人民民主的重要体现</strong><br>法律政府建设是<strong>全面依法治国的重点任务和主体工程</strong><br>公正司法是<strong>维护社会公平正义的最后一道防线</strong><br>法治社会是<strong>构建法治国家的基础</strong><br>意识形态工作是<strong>为国家立心、为民族立魂的工作</strong>。<br>我们要坚持马克思主义在意识形态领域指导地位的根本制度</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h1 id="全过程民主"><a href="#全过程民主" class="headerlink" title="全过程民主"></a>全过程民主</h1><p><strong>根本保证</strong>：中国共产党的领导<br><strong>制度载体</strong>：人民代表大会制度<br><strong>重要形式</strong>：协商民主<br><strong>重要体现</strong>：基层民主</p>
<p>最广泛[人人享有] 最真实[国家治理高效] 最有用[社会和谐稳定] 全过程人民民主</p>
<h5 id="怎样判断一个国家是不是民主"><a href="#怎样判断一个国家是不是民主" class="headerlink" title="怎样判断一个国家是不是民主"></a>怎样判断一个国家是不是民主</h5><p>人民民主有没有投票权：要看人民有没有广泛参与权<br>要看权利运行规则和程序是否民主，更要看权利是否真正受到人民监督和制约</p>
<h5 id="怎样发展全过程人民民主"><a href="#怎样发展全过程人民民主" class="headerlink" title="怎样发展全过程人民民主"></a>怎样发展全过程人民民主</h5><p>加强人民当家做主<br>全面发展协商民主<br>积极发展基层民主<br>巩固和发展最广泛的爱过统一战线</p>
<h5 id="人民当家做主的制度"><a href="#人民当家做主的制度" class="headerlink" title="人民当家做主的制度"></a>人民当家做主的制度</h5><p>人民代表大会制度 根本政治制度<br>社会主义制度 民族区域自治制度        基本制度×3</p>
<h1 id="新发展格局"><a href="#新发展格局" class="headerlink" title="新发展格局"></a>新发展格局</h1><h5 id="为什么要构建新发展格局-p15"><a href="#为什么要构建新发展格局-p15" class="headerlink" title="为什么要构建新发展格局 p15"></a>为什么要构建新发展格局 p15</h5><p>构建…做到什么？</p>
<p>高水平自立自强 是新发展格局最本质特征<br>经济循环畅通无阻 是新发展格局的关键<br>解放和发展生产力 是新发展格局的重点</p>
<p>&#x3D;&#x3D;★★★★★ 中国式现代化！！&#x3D;&#x3D;</p>
<h4 id="要什么样的现代化？怎样实现现代化？"><a href="#要什么样的现代化？怎样实现现代化？" class="headerlink" title="要什么样的现代化？怎样实现现代化？"></a>要什么样的现代化？怎样实现现代化？</h4><p>要坚守人民至上理念，突出现代化方向的<strong>人民性</strong><br>要秉承独立自主原则，探索现代化道路的<strong>多样性</strong><br>要树立守正创新意识，保持现代化程序的<strong>持续性</strong><br>要保持奋发有为姿态，确保现代化领导的<strong>坚定性</strong></p>
<h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><p>为人类社会现代化理论和实践创新出新的贡献<br>促进人类文明的进步</p>
<h4 id="文明倡导什么样的现代化文明？"><a href="#文明倡导什么样的现代化文明？" class="headerlink" title="文明倡导什么样的现代化文明？"></a>文明倡导什么样的现代化文明？</h4><p>共同倡导尊重世界文化多样性<br>共同倡导弘扬全人类共同价值，和平、发展、公平、正义、民主、自由<br>重视文明传承和创新<br>加强国际人文交流合作</p>
<h4 id="深化党中央机构改革"><a href="#深化党中央机构改革" class="headerlink" title="深化党中央机构改革"></a>深化党中央机构改革</h4><p>组建中央金融委员会<br>组建中央科技委员会<br>组建中央社会工作部</p>
<h4 id="深化国务院机构改革"><a href="#深化国务院机构改革" class="headerlink" title="深化国务院机构改革"></a>深化国务院机构改革</h4><p>重新组建科学技术部</p>
<p>新成立：国家金融监督管理总局</p>
<h1 id="时事热点"><a href="#时事热点" class="headerlink" title="时事热点"></a>时事热点</h1><h4 id="奋进新时代提出"><a href="#奋进新时代提出" class="headerlink" title="奋进新时代提出"></a>奋进新时代提出</h4><p>为实现中华民族伟大复兴提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量</p>
<p>习近平新疆考察：以民族平等、民族团结、民族区域自治、各民族共同繁荣发展为主体内容的民族理论和民族政策</p>
<p>&#x3D;&#x3D;<strong>北京东奥精神</strong>：胸怀大局、自信开放、迎难而上、追求卓越、共创未来&#x3D;&#x3D;</p>
<h4 id="习近平在陕西延安和河南安阳考察"><a href="#习近平在陕西延安和河南安阳考察" class="headerlink" title="习近平在陕西延安和河南安阳考察"></a>习近平在陕西延安和河南安阳考察</h4><p>习近平在当二十大后首次国内考察，考察全面乡村振兴内容；延安和建党精神(红旗渠)</p>
<p>中华优秀传统文化是我们党创新理论的<strong>根</strong>，我们推进马克思主义中国化时代化的途径是<strong>两个相结合</strong></p>
<p><strong>党的七大</strong>在党的历史上具有重要里程碑意义，标志着我们党在政治上思想上组织上走向了成熟</p>
<p><strong>国内考察</strong>最重要的是&#x3D;&#x3D;<strong>延安精神</strong>&#x3D;&#x3D;：<u>正确的政治方向、解放思想实事求是的思想路线、全心全意为人民服务的根本宗旨、自力更新艰苦奋斗的创业精神</u></p>
<p><strong>国外考察</strong>最重要的是<strong>访问俄罗斯</strong>二十大的第一次出访：&#x3D;&#x3D;<strong>友谊之旅、合作之旅、和平之旅</strong>&#x3D;&#x3D;</p>
<p>共产党人的政治灵魂：对共产主义的信仰，对中国特色社会主义的信念。<br>在新时代坚定信仰信念，最重要的就是：坚定中国特色社会主义道路自信、理论自信、制度自信、文化自信。</p>
<p>我们党最鲜明的品格：勇于自我革命<br>党的政治建设的首要任务：保证全党服从中央，维护党中央权威和集中统一领导<br>中国共产党领导是中国特色社会主义最本质的特征，是<strong>中国特色社会主义的最大优势</strong><br>中国共产党的<strong>精神之源</strong>：伟大建党精神。即坚持真理、坚守理念，践行初心，担当使命，不怕牺牲，英勇斗争，对党忠诚，不负人民</p>
<h3 id="中央政治局体系学习"><a href="#中央政治局体系学习" class="headerlink" title="中央政治局体系学习"></a>中央政治局体系学习</h3><p>实现碳达峰碳中和是贯彻新发展理念。</p>
<p>中国共产党领导和我国社会主义制度，决定了我国人权事业的社会主义性质，决定了我们能够保证人民当家做主<br><strong>人民性</strong>是中国人权发展道路最显著的特征。<br><strong>生存权、发展权</strong>是首要的人权<br>生存是享有一切人权的基础，人民幸福生活是最大的人权<br>提高一体推进不敢腐、不能腐。不想腐能力和水平，全面打赢反腐败斗争攻坚战、持久战<br>始终坚持严的主基调不动摇<br>深入贯彻实施新时代强军战略：要把能打仗、大胜仗作为人才工作出发点和落脚点</p>
<h4 id="乡村振兴与共同富裕"><a href="#乡村振兴与共同富裕" class="headerlink" title="乡村振兴与共同富裕"></a>乡村振兴与共同富裕</h4><p>牢牢守住保障国家粮食安全和不发生规模性返贫的底线<br>总目标 总方针 总要求 制度保障</p>
<p>乡村建设是实施乡村振兴战略的重要任务，也是国家现代化建设的重点<br><img src="C:\Users\faily\AppData\Roaming\Typora\typora-user-images\image-20230405091456563.png" alt="image-20230405091456563"></p>
<p>共同富裕是<strong>全体人民的共同富裕</strong>，是人民群众<strong>物质生活和精神生活都富裕</strong><br>共同富裕是<strong>一个长远目标，不同人群不仅实现富裕的程度有高低</strong><br>共同富裕是社会主义的本质要求<br>是中国式现代化的重要特征<br>实现共同富裕不仅是经济问题，而且是关系党的执政基础的重大政治问题<br>要坚持以人民为中心的发展思想，在高质量发展中促进共同富裕。适应我国社会主要矛盾变化，更好满足人民日益增长的美好生活须要</p>
<p>实现共同富裕要<strong>鼓励勤劳创新富裕；坚持基本经济制度；尽力而为量力而行；坚持循序渐进</strong></p>
<h6 id="重要重要文件合集"><a href="#重要重要文件合集" class="headerlink" title="重要重要文件合集"></a>重要重要文件合集</h6><p>《关于加快建设全国统一大市场的意见》<br>建设全国统一大市场是构建新发展格局的基础支撑和内在要求<br>4个工作原则：立足内需，畅通循环；立破并举、完善制度、有效市场、有为政府、系统协同、稳妥推进</p>
<p>政治协商：人民政协政治协商</p>
<p>文化是国家和民族之魂，也是国家治理之魂<br>以推动文化高质量发展为主体，以深化文化领域供给侧结构性改革为<strong>主线</strong></p>
<p>实现网络空间创新发展、安全有序、平等尊重、开发共享的目标<br>吧网络空间建设成为造福全人类的<strong>发展共同体、安全共同体、责任共同体、利益共同体</strong></p>
<h6 id="重大周年纪念"><a href="#重大周年纪念" class="headerlink" title="重大周年纪念"></a>重大周年纪念</h6><p>共青团：中国共产主义青年团<br>习近平给共青团提了4个希望：坚持为党育人；承担责任；心系广大青年；用于自我革命</p>
<p>坚持党的领导是共青团区别于其他青年组织的<strong>根本特质和鲜明优势</strong><br>听党话、跟党走始终是共青团坚守的<strong>政治生命</strong><br>坚定不移跟党走，为党和人民奋斗，是<strong>共青团的初心使命</strong><br>要立足党的事业后续有人这一<strong>根本大计</strong>，牢牢把握培养社会主义建设者和接班人是<strong>根本任务</strong></p>
<p>追求进步，是青年<strong>最宝贵的特质</strong>，也是党和人民最殷切的希望</p>
<p>白皮书<br>矢志不渝跟党走是<strong>中国青年百年奋斗的</strong>最宝贵经验<br>红色基因是<strong>中国青年百年奋斗的最宝贵财富</strong></p>
<h5 id="中央统一战线工作会议"><a href="#中央统一战线工作会议" class="headerlink" title="中央统一战线工作会议"></a>中央统一战线工作会议</h5><p>统一战线的定位：统一战线是党克敌制胜、执政兴国的重要法宝，是团结海内外全】体中华儿女实现中华民族伟大复兴的重要法宝，必须长期坚持<br>决定党和人民事业成败的关键，是最大的政治<br>统战工作的本质要求：大团结大联合<br>统战工作的关键：坚持求同存异，发扬”团结-批评-团结”的优良传统<br>铸牢中华民族共同体意识为党的民族工作主线</p>
<h5 id="庆祝中国人民解放军建军95周年系列活动"><a href="#庆祝中国人民解放军建军95周年系列活动" class="headerlink" title="庆祝中国人民解放军建军95周年系列活动"></a>庆祝中国人民解放军建军95周年系列活动</h5><p>2022年7月27日，中央军委颁授**”八一勋章”**<br>杜富国、钱七虎、聂海胜获得八一勋章</p>
<h5 id="一国两制与祖国统一"><a href="#一国两制与祖国统一" class="headerlink" title="一国两制与祖国统一"></a>一国两制与祖国统一</h5><p>必须全面准确贯彻”一国两制”方针<br>坚持全面中央管制权和保障特别行政区高度自治权相统一<br>必须落实”爱国者治港”<br>必须保持相关的独特定位和优势</p>
<p>怎么做？提高治理水平、不断增强发展动能、切实排解民生忧难、共同维护和谐稳定，”一国两制”方针是一个完整体系<br>中央政府特别行政区拥有全面管制权，这是<strong>特别行政区高度自治源头</strong></p>
<h5 id="九二共识"><a href="#九二共识" class="headerlink" title="九二共识"></a>九二共识</h5><p>推动两岸关系和平发展、推动祖国和平统一经常，是中华儿女的愿望1验证阶段圆满手工**<br>@@，是一国两制的根本主张<br>“台独”分裂行径是祖国统一的最大障碍，是民族复兴的严重隐患</p>
<p>一国两制是对马克思主义国家学说的<strong>创造性</strong>发展<br>一国两制的提出是为了<strong>实现和维护国家统一</strong><br>永恒的主题、<strong>港澳立身之本</strong></p>
<h5 id="重大科技成就"><a href="#重大科技成就" class="headerlink" title="重大科技成就"></a>重大科技成就</h5><p>神舟十三号(翟志刚、王亚平、叶光富)顺利返回，<strong>标志着我国空间站关键</strong></p>
<p>神州十四号(陈东、刘洋)</p>
<p><img src="C:\Users\faily\AppData\Roaming\Typora\typora-user-images\image-20230405102159792.png" alt="image-20230405102159792"></p>
<p>习近平线下参加第一次元首峰会；</p>
<p>巴厘岛峰会以“共同复苏、强劲主题”<br> 元首外交中美关系”指南针”、”定盘量”对两国关系发展着补补课替代的部分<br>正确看待对方内外政策和战略意图是处理好彼此关系的一个重要前提<br>中美建交三点原则：相互尊重，和平共处，合作共赢</p>
<p>台湾问题是<strong>中国核心利益</strong>的核心，是中美关系政治基础中的基础，是中美关系第一条<strong>不可逾越的红线</strong></p>
<p><img src="C:\Users\faily\AppData\Roaming\Typora\typora-user-images\image-20230405104946456.png" alt="image-20230405104946456"></p>
<h1 id="帽子题"><a href="#帽子题" class="headerlink" title="帽子题"></a>帽子题</h1><p>社会主义民主政治的本质和核心：人民当家做主<br>社会主义民主政治最鲜明的特点：人民代表大会制度(人民当家做主的重要途径和实现形式)<br>集中全党全国人民集体智慧、实现科学决策、民主决策的基本原则和主要途径<strong>民主集中制</strong><br>我国政治制度的一大优势，中国共产党领导的政党制度的基本特色：<strong>共产党领导，多党派合作；共产党执政，多党派参政</strong><br>全过程人民民主制度载体：人民代表大会制度<br>人民当家做主最有效、最广泛的途径：<strong>基层群众自治</strong><br>全过程人民民主的重要体现：基层群众自治<br>全面依法治国的总抓手：建设中国特色社会主义法治体系<br>中国特色社会主义法治体系的前提，法治国家法治政府法治社会的制度基础：完善的法律法规体系<br>建设中国特色社会主义法治体系的重点：高效的法治实施体系<br>宪法法律有效实施的重要保障，加强对权利运行制约和监督的迫切要求：严密的法治监督体系<br>依法治国的主体和力量源泉：人民<br>中国特色社会主义法治之魂：党的领导<br>治国之重器：法律<br>法治的龙头环节：立法<br>法治生命线，司法的灵魂，司法活动最高的价值追求：公正<br>社会主义法治的根本要求：党的领导<br>社会主义法治的基本属性，社会主义法治的基本要求：平等<br>治国理政的基本方式：法治<br>重要方式：德治<br>权利保障的前提和基础：宪法保障<br>保障权利保障的重要条件：立法保护<br>权利保障的关键环节：行政保护<br>权利保障的最后防线：司法保护<br>全面依法治国的根本目的：依法保障人民的权益<br>人享有其他各项权利的前提：生命权<br>人们一切行动和生活的前提条件：人身自由权<br>人生观的核心：人生目的<br>人的本质：一切社会关系的总和<br>世界观决定人生观、价值观<br>个人与社会的关系最根本的是个人利益与社会利益的关系<br>代表人类社会迄今最先进的人生追求：服务人民、奉献社会<br>评价人生价值的根本尺度：看一个人的实践活动是否符合社会发展的客观规律，是否促进历史进步<br>人民的精神世界的核心——精神之钙：理想信念<br>兴国之魂：中国精神<br>检验一个人对祖国忠诚程度的试金石：<strong>对骨肉同胞的爱</strong><br>在当代中国爱国主义本质：<strong>爱党爱国爱社会主义高度统一</strong><br>新时代爱国主义主题：<strong>实现中华民族伟大复兴</strong><br>新时代爱国主义着力点：<strong>维护祖国统一</strong><br>文化软实力的竞争本质上是不同文化所代表的核心价值观的竞争<br>文化软实力的灵魂：核心价值观<br>社会主义核心价值观历史底蕴的<strong>集中体现</strong>：深深根植于中华优秀传统文化<br>中华文化的精髓：中华传统美德<br>革命道德的灵魂：坚持社会主义、共产主义理想信念和不屈不挠的精神<br>贯穿中国革命道德始终的一根红线：全心全意为人民服务<br>我国公民道德建设的重点：诚实守信<br>社会主义道德建设的落脚点：个人品德<br>志愿服务精神的精髓：奉献精神</p>
<hr>
<p>1981年，十一届六中全会 《关于建国以来若干历史问题的决议》 实事求是，群众路线，独立自主<br>中华民族精神核心：爱国主义<br>独立自主：中华民族精神之魂、</p>
<h2 id="x3D-x3D-新民主主义-x3D-x3D"><a href="#x3D-x3D-新民主主义-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;新民主主义&#x3D;&#x3D;"></a>&#x3D;&#x3D;新民主主义&#x3D;&#x3D;</h2><p>中国革命的依据、基础、前提：认清国情—《中国革命中国共产党》<br>中国革命的首要问题：分清敌友<br>中国革命的根本任务：推开三座大山<br>帝国主义：首要对象，造成一切灾难的总根源<br>中国革命的中心问题：无产阶级领导权问题<br>新民主主义革命理论的核心问题：无产阶级领导权问题<br>新旧民主革命区别的根本标志：<strong>无产积极领导权</strong>问题<br>新旧民主革命的分水岭：五四革命 (时间跨度)<br>中国革命的基本问题：农民问题<br>中国革命的基本内容：土地革命<br>中国革命的实质：无产阶级领导的农民革命<br>新民主主义战争的实质：无产积极领导的农民战争<br>无产阶级领导权的关键：建立工农联盟的统一战线<br>中国革命的最基本动力：无产阶级<br>中国革命的主力军、同盟军：农民阶级<br>中国革命的同盟者：城市小资产阶级<br>中国革命的动力之一(两面性)：民族资产阶级<br>无产积极领导权实现的关键：巩固工农联盟为基础的统一战线<br>无产阶级领导权的中心问题：农民问题<br>中国革命的特点和优点：武装斗争<br>中国革命急剧特色政策：保护民族工商业<br>具有双重革命性特征：没收官僚垄断资本归新民主主义国家所有<br>中国革命的战略阵地：农民革命根据地</p>
<h3 id="社会主义改造理论"><a href="#社会主义改造理论" class="headerlink" title="社会主义改造理论"></a>社会主义改造理论</h3><p>新民主主义社会经济领导地位：国营经济<br>新民主主义社会经济主体地位：个人(体)经济<br>农业的社会主义改造道路：走互助合作的道路<br>农业的社会主义改造原则：自愿互利、典型示范、国家帮助<br>农业的社会主义改造方针：积极引导、稳步前进<br>农业的社会主义改造步骤：循序渐进<br>资本主义工商业的改造方式：和平赎买<br>资本主义工商业过渡形式：由低到高的国家资本主义<br>一化三改(一体两翼)：社会主义工业化(主体)，对全体农业、手工业、资本主义工商业社会主义改造(两翼)</p>
<h3 id="社会主义建设道路初步探索的理论成果"><a href="#社会主义建设道路初步探索的理论成果" class="headerlink" title="社会主义建设道路初步探索的理论成果"></a>社会主义建设道路初步探索的理论成果</h3><p>中国共产党探索<strong>社会主义建设</strong>的良好开端：《论十大关系》<br>马克思主义与中国实际第二次结合开始：《论十大关系》<br>《论十大关系》提出的基本方针：调动一切积极因素为社会主义事业服务<br>中国特色社会主义建设道路 -&gt; 提出了有别于苏联的中国工业化道路<br>《关于正确处理人民内部矛盾》正确处理人民内部矛盾是明确提出了有别于苏联的中国工业化道路<br>工业化总方针：农业为基础工业为主导，农轻重为序<br>政治思想领域：团结批评团结<br>经济利益领域：统筹兼顾<br>八字方针<br>党群：民主集中制<br>中共八大会议后经济政策方针：即反保守又反冒进，在综合平衡中稳步前进<br>社会主义基本矛盾的性质：人民利益一致基础上的非对抗性矛盾——又相适应又相矛盾<br>解决社会主义基本矛盾的途径和方法：经过社会主义制度本身来解决<br>走中国工业化道路的根本原因：实现民族独立国家富强的内在要求和必要条件<br>一化三改的实质：将生产资料私有制转变公有制<br>第四章帽子 人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民人民</p>
<table>
<thead>
<tr>
<th><strong>刘少奇</strong></th>
<th><strong>使社会主义经济既有计划性又有多样性和灵活性的主张，以及按经济办法管理经济的思想</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>陈云</strong></td>
<td><strong>要建立“适合于我国情况和人民需要的社会主义的市场”的思想</strong></td>
</tr>
<tr>
<td><strong>毛泽东</strong></td>
<td><strong>“两参一改三结合”</strong></td>
</tr>
<tr>
<td><strong>邓小平</strong></td>
<td><strong>关于整顿工业企业，改善和加强企业管理，实行职工代表大会制度等观点</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>毛泽东</th>
<th><em><strong>毛泽东</strong></em> 提出在社会主义经济占优势的条件下“可以消灭了资本主义，又搞资本主义(发展经济)”。</th>
</tr>
</thead>
<tbody><tr>
<td>朱德</td>
<td><em><strong>朱德</strong></em>提出了要<u>注意发展手工业和农业多种经营的思想</u>。</td>
</tr>
<tr>
<td>陈云</td>
<td>&#x3D;&#x3D;<em><strong>陈云</strong></em>提出了“<strong>三个主体，三个补充</strong>“的设想&#x3D;&#x3D;，即在<strong>工商业经营方面</strong><u>，国家经济和集体经济是工商业的主体，一定数量的<strong>个体经济</strong>是国家经济和集体经济的补充；以计划生产为主体，以自由生产为补充；以国家市场为主体，以自由市场为补充</u></td>
</tr>
</tbody></table>
<h3 id="邓小平理论"><a href="#邓小平理论" class="headerlink" title="邓小平理论"></a>邓小平理论</h3><p>十一届三中全会：伟大转折会议，开启了社会主义建设新时期<br>党的十二大第一次明确提出了：建设有中国特色的社会主义的基本命题<br>党的十三大：标志着邓小平理论轮廓形成<br>党的十三大：第一次系统论论述中国特色社会主义理论<br>92南巡讲话：标志着邓小平理论走向成熟<br>党的十四大：邓小平—改革开放和现代化建设总设计师<br>党的十五大：首次提出邓小平理论，邓小平理论写入党章<br>1999年，邓小平理论写入宪法<br>十一届六中全会《关于建国以来》<br>社会主义本质：解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕<br>社会主义本质中根本任务：解放生产力，发展生产力<br>社会主义本质中根本目标：最终达到共同富裕<br>社会主义本质中根本要求：消灭剥削，消除两极分化<br>社会主义初级阶段基本路线：党和国家生命线，人民幸福线<br>社会主义初级阶段基本路线的中心任务：经济建设<br>社会主义初级阶段基本路线的根本动力：坚持改革开放<br>社会主义初级阶段基本路线的根本立足点：自力更生艰苦创业<br>社会主义初级阶段基本路线的立国之本：四项基本原则<br>社会主义初级阶段基本路线的强国之路：改革开放<br>社会主义社会发展的直接动力：改革<br>第一次提出“三个代表”重要思想：江泽民在广东考察<br>第一次提出：建设怎么样的党，怎样建设党的问题：全国党校工作会议<br>“三个代表”重要思想历史起点、逻辑起点：四个如何认识<br>第一次全面论述三个代表重要思想的科学内涵、基本内容：建设80周年讲话<br>三个代表重要思想的关键：与时俱进<br>三个代表重要思想的核心：保持党的先进性<br>三个代表重要思想的本质：执政为民<br>三个代表重要思想写入党章：党的十六大<br>三个代表重要思想：立党之本、执政之基、力量之源<br>党执政兴国的第一要务：发展<br>首次提出发展观：胡锦涛在广东考察<br>党的十七大第一次写入党章<br>十八大也写入党章<br>首次提出科学发展观：十六届三中全会<br>科学发展观初步形成的标志：人口资源环境座谈会<br>科学发展观趋于成熟：党的十七大(写入党章)<br>科学发展第一要义：发展<br>科学发展观核心立场：以人为本<br>科学发展观基本要求：全面协调可持续<br>科学发展观根本方法：统筹兼顾<br>科学发展观回答的时代课题：要实现什么发展，怎样发展的问题<br>科学发展观精神实质：解放思想实事求是，与时俱进求真务实<br>中国特设社会主义理论体系：党十七大<br>党的先进性的集中体现，根本要求：必须代表先进生产力的发展要求、党代表先进生产力<br>先进生产力的集中体现，重要标志：科学技术<br>在改革中我们必须坚持的两大根本原则：以社会主义公有制经济体，共同富裕<br>我国经济体制改革的核心问题、关键：如何正确认识和处理(政府)与市场的关系<br>和平统一，一国两制的核心&#x2F;发展两岸关系和实现和平统一的政治基础：坚持一个中国原则<br>习近平新时代中国特色社会主义思想的核心要义：坚持和发展中国社会主义<br>中国特色社会主义事业总布局：“五位一体”；战略布局：“四个全面”<br>全面社会改革总目标：完善和发展中国特色社会主义制度、推进<br>习思想的总任务：建成社会主义现代化强国 实现中华民族伟大复兴<br>全面深化改革总目标：完善和发展中国特色社会主义制度、推进国家治理能力治理体系现代化<br>全面推进依法治国的总目标：建设中国特色社会主义法治体系、建立社会主义法制国家<br>党在新时代的强军目标：建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成世界一流军队<br>中国特色社会主义最本质的特征：中国共产党的领导<br>中国特色社会主义制度的最大优势：中国共产党领导<br>习思想始终的一根红线：人民至上<br>共产党不可战胜的强大精神力量：敢于斗争，敢于胜利<br>中华民族的根与魂：优秀传统文化<br>新发展理念的根与魂：为人民谋幸福、为民族谋复兴<br>社会主义民主政治发展的必然要求，推进政治文明建设必须遵循的基本方针<br>我国社会主义政治文明区别于资本主义政治文明的本质特征：坚持党的领导、人民当家做主、依法治国有机统一<br>总体国家安全：人民安全是宗旨、政治安全是根本、经济安全是基础、军事,文化,社会安全是保障：国家利益至上是准则；国际安全是依托<br>引领发展的第一动力：创新<br>持续健康发展的内在要求：协调<br>永续发展的必要条件：绿色<br>国家繁荣发展的必由之路：开放<br>中国特色社会主义的本质要求：共享<br>新发展格局的关键：经济循环、畅通无阻<br>新发展格局最本质的特征：高水平的自立自强<br>现代化经济体系的坚实基础&#x2F;着力点&#x2F;国家经济的立身之本&#x2F;财富创造的根本源泉：<strong>实体经济</strong><br>现代化经济体系的战略支撑：创新驱动发展战略<br>发展是第一要务，人才是第一资源，创新是第一动力，科技是第一生产力<br>现代化经济体系的重要基础：乡村振兴战略<br>人民当家做主和依法治国的根本保证：党的领导<br>社会主义民主政治的本质特征：人民当家作主<br>党领导人民治理国家的基本方式&#x2F;国家长久治安的重要保障：依法治国<br>[今年也是]深化党和国家机构改革，全面提高国家治理能力和治理水平：&#x3D;&#x3D;以加强党的全面领导为统领，以国家治理体系和治理能力现代化为导向，以推进党和国家机构职能优化协同高效为着力点&#x3D;&#x3D;<br>中国社会主义民主政治的特有形式：社会主义协商民主<br>社会主义民主最基本的体现，人民政协的主要职能：政治协商、民主监督、参政议政<br>民族区域自治的核心：保障少数民族当家做主，管理本民族本地区事物的权利<br>党的宗教工作的根本方向和目的：积极引导宗教与社会主义社会相适应<br>长期以来特别是党的十八大依赖推进”一国两只”的成功经验：把维护中央对香港澳门特别行政区全面管辖治权和保障特别行政区高度自治权有机结合起来，落实好中央依法行使权利和特别行政区旅行主体责任<br>香港澳门的立身之本，保护香港澳门国际地位和解决香港澳门各种问题的金钥匙：发展<br>两岸关系的政治基础：一国中国原则<br>两岸关系的关键：坚持”九二共识”<br>推动两岸关系和平发展的着眼点和落脚点：为两岸同胞谋福祉<br>一国国家重要的稳定器：核心价值观<br>人民幸福之基，社会和谐之本：民生<br>最大的民主：就业—民生工程，民心工程，根基工程<br>民生治本，改善民主、实现发展成果由人民共享最重要最直接的方式：收入分配<br>最基本的民生：公共安全<br>老百姓解决温饱后的第一需求，最基本的发展环境：平安<br>生态文明的核心：坚持人与自然和谐共生<br>人与自然相处首要态态度：尊重自然；基本原则：顺应自然；首要责任：保护自然<br>全面建成小康社会的首要战役：防范化解重大风险攻坚战<br>全面建成小康社会的底线任务：打赢脱贫攻坚战<br>决定当代中国命运的关键一招&#x2F;关键抉择，当代中国发展进步的活力之源，党和人民事业大踏步赶上时代的重要法宝，坚持和发展中国特色社会主义实现中华民族伟大复兴的必由之路，当代中国最鲜明的特色；<br>中国共产党最鲜明的旗帜：改革开放<br>改革开放的初心和使命：为中国人民谋幸福，为中华民族谋复兴<br>推动人类社会向前发展的根本动力：变革创新<br>推动我国经济发展(国内)：改革开放<br>解决中国现实问题的根本途径：全面深化改革<br>&#x3D;&#x3D;全面深化改革的出发点和落脚点：促进社会公平，增进人民福祉<br>全面深化改革的根本目的：解放发展生产力，促进社会公平正义&#x3D;&#x3D;<br>我国改革开放之所以取得巨大成就，关键在于把党的基本路线作为党和国家的生命线，始终坚持以经济建设为中心同四项基本原则、改革开放这两个基本点统一于中国特色社会主义伟大实践<br>改革成效的评价标准：是否促进经济社会发展，是否给人民群众带来时事政治的获得感<br>&#x3D;&#x3D;国家繁荣富强的根本出路：全面开放<br>国家繁荣富强的必由之路：改革开放&#x3D;&#x3D;<br>正确处理改革发展稳定的关系的结合点：改善人民生活<br>中国特色社会主义的本质要求和重要保障：全面依法治国<br>建立严密的法治监督体系的重点：规范和约束公权力<br>能不能做到依法治国，关键在于党：能否坚持依法执政、各级政府能不能依法行政<br>法治建设的目标：法制国家；法制国家的主题工程：法治政府；法制国家的基础：法治社会<br>新时代党的建设的目的，新时代党的建设的根本原则：坚持和加强党的全面领导<br>根本方针：坚持党要管党，全面从严治党<br>全民从严治党中，”全面”是<strong>基础</strong>，”严”是<strong>关键</strong>，”治”是<strong>要害</strong>，<strong>重点</strong>是抓关键少数，<strong>核心</strong>：坚持和加强党的领导<br>政党第一属性：政治属性；  政治建设：根本性建设<br>政治建设的首要任务：保证全党服从中央，坚持党中央权威和集中统一领导<br>党的基础性建设：思想建设<br>党的思想建设首要任务：坚定理念信念<br>党的思想建设根本任务：用党的创新理论武装全党<br>作风建设的核心：保持党同人民群众的血肉联系<br>全面从严治党的治本之策：加强党的纪律建设<br>全面从严治党的根本之策&#x2F;长远之策：加强党的制度建设<br>十九大 从严治党的重中之重：廉政建设和反腐败斗争<br>二十大 最彻底的自我革命：反腐败斗争<br>我党最鲜明的品格：勇于自我革命<br>跳出历史周期的答案：民主、人民监督、敢于自我革命<br>强军之魂、建军之本：党对军队的绝对领导<br>强军之要：能打仗、打胜仗<br>强军之策、兴国之举：军民融合发展<br>立军之本：政治建军<br>我军鲜明特点和政治优势：作风优良<br>人民军队完全区别与一切旧军队的政治特质和本质优势：党对军队的绝对领导—根本原则<br>我军的最大优势、最大特色，我军同一切其他性质军队的最大区别：政治工作<br>党对军队绝对领导的最高实现形式，确保国家长治久安的”定海神针”：<strong>军委主席负责制</strong><br>基本军事制度：党对军队绝对领导<br>我军发展壮大、制胜未来的关键一招：改革<br>我党建军治军的基本方略：依法治军、从严治军<br>军队建设的出发点和落脚点：提高战斗力<br>人民军队的出发点和落脚点：全心全意为人民服务<br>建设世界一流军队的力量基础：构建中国特色现代军事力量体系<br>军队全面深化改革：军委管总、战区主战、军种主建；<br>实现富国强军统一的重要途径：走军民融合发展的路子<br>实现强国强军统一的重要政治保证，我当我军特有的政治优势：军政军民融合<br>军政军民团结优良传统：军爱民、民拥军<br>中国外交政策的宗旨：维护世界和平、促进共同发展<br>新型国际关系：特别是新在合作共赢<br>中国倡导建立相互尊重、公平正义、合作共赢的新型国际关系<br>新型国际关系核心：维护联合国宪章的宗旨和原则，维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则，维护联合国以及安理会对世界和平承担的首要责任，开展对话、合作而不是对抗，实现共赢、共赢而不是单赢<br>我国外交工作的基本出发点和落脚点：坚决维护国家主权、安全、发展利益<br>外交工作布局：大国是关键，周边是首要，发展中国家是基础，多边是舞台<br>周边外交的方针：与邻为善、与临为伴<br>周边外交理念：亲诚惠容<br>全球治理观&#x2F;一带一路的原则：工商、共建、共享；<br>基层治理的新格局：共建、共治、共享<br>“一带一路”的宗旨&#x2F;理念&#x2F;丝绸之路精神：和平合作、开放包容、互学互鉴、互利共赢<br>“一带一路”的内容：政策沟通、设施联通、贸易畅通、资金融通、民心相通：责任共同体、利益共同体、命运共同体<br>人类命运共同体思想核心：持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界<br>党和国家根本所在命脉所在，全国各族人民利益所系幸福所系：坚持党的领导<br>中国特色社会主义最本质的特征。中国特色社会主义制度最大优势，发挥中国特色社会主义制度优势的根本保障：党的领导<br>中国特色社会主义制度优势之源：党的自身优势<br>改革开放以来党和人民历经千辛万苦、付出巨大代价取得的根本成就：中国特色社会主义<br>中国共产党的历史使命：”四个伟大”：伟大梦想是目标指引前进方向；伟大斗争是手段激发前进动力；伟大工程是保障提供前进保证；伟大事业<del>中国特色社会主义事业</del>是主题开辟前进道路；决定作用——党的建设伟大工程<br>开辟中国特色社会主义道路、开创中国特色社会主义新理论的宣言书：《解放思想、实事求是、团结一致向前看》<br>深化党和国家机构改革的重要任务：转变政府职能，优化政府机构设置和职能配置<br>新时代”三农”工作的总抓手：实施乡村振兴战略<br>乡村振兴战略总目标：推进农业农村现代化<br>十四五规划中”三农”工作摆首要位置：巩固脱贫攻坚成果，防止大规模返贫<br>乡村振兴战略的总要求：产业兴旺、生态宜居、乡风文明、治理有效、生活富裕<br>乡村振兴战略的总方针：坚持农业农村优先发展<br>农村振兴战略的制度保障：<br>十四五发展规划中经济工作的主题：高质量发展<br>实现经济高质量发展的主线：供给侧结构性改革<br>供给侧结构性改革的重点：解放和发展生产力<br>供给侧结#构性改革的关键：理解结构性   </p>
<hr>
<h2 id="材料分析题技巧"><a href="#材料分析题技巧" class="headerlink" title="材料分析题技巧"></a>材料分析题技巧</h2><table>
<thead>
<tr>
<th></th>
<th>原因题</th>
<th>理解题</th>
<th>措施题</th>
</tr>
</thead>
<tbody><tr>
<td>提问线索</td>
<td>为什么&#x2F;必要性&#x2F;依据</td>
<td>如何理解&#x2F;认识&#x2F;看待</td>
<td>如何弘扬&#x2F;践行&#x2F;做到</td>
</tr>
<tr>
<td>审读材料</td>
<td>阅读材料，确定考察主体(关键词)<br />说明”关键词”定义&#x2F;内涵<br />从各领域强调”关键词”重要性 如：<br />中华民族伟大复兴<br />生态文明建设<br />法制国家建设……</td>
<td>将问题进行句式分解：<br />1.分别解释句中的考点概念、内涵<br />2.结合材料说明概念意义、作用或者联系与区别。做出总结<br />#核心：找出关键词<del>关键词与关键词之间的关系</del></td>
<td>阅读材料，总结材料体现措施；联系考点理论思考解决问题措施；<br />按照题目要求，从：个人、家庭、社会、国家等角度谈谈如何采取措施；最后强调要落实</td>
</tr>
<tr>
<td>答题模板</td>
<td>从各领域强调”关键词”重要性 如：<br />中华民族伟大复兴、生态文明建设、法制国家建设等等</td>
<td>1.结合材料说明概念A和概念B的含义<br />2.结合材料，解读概念A与B的重要性，联系和区别<br />3.结合材料强调结论</td>
<td>1.作为大学生(个人)应该怎么做(从材料中启发)<br />2.国家&#x2F;社会&#x2F;政府应该怎样(弘扬美德, 完善法律)以便营造材料</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>证明题</th>
<th>概念题</th>
<th>原因题</th>
</tr>
</thead>
<tbody><tr>
<td>提问线索</td>
<td>结合材料，说明理想信念的力量</td>
<td>本质是什么，含义是什么</td>
<td>为什么&#x2F;必要性&#x2F;依据</td>
</tr>
<tr>
<td>审读材料</td>
<td>理想信念的力量是教材的知识点，可以直接背+材料对应内容</td>
<td>对材料进行归纳总结</td>
<td>阅读材料，确定考察主体(关键字)，寻找主观依据<br />结合材料及社会现实，寻找客观依据<br />从以往角度分析其历史原因<br />从解决问题的现实问题解答现实原因</td>
</tr>
<tr>
<td>答题模板</td>
<td>考核要点：考核知识点+材料<br />结合材料强调结论(改问句为肯定)</td>
<td>考察的就是我们归纳总结能力</td>
<td>主观原因：知识点+材料<br />客观原因：知识点+材料<br />历史原因：联想+材料<br />结合材料强调结论(改问句为肯定)</td>
</tr>
</tbody></table>
<h4 id="x3D-x3D-面对-理想与现实-当代青年怎么做？【万能句】-x3D-x3D"><a href="#x3D-x3D-面对-理想与现实-当代青年怎么做？【万能句】-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;面对 理想与现实 当代青年怎么做？【万能句】&#x3D;&#x3D;"></a>&#x3D;&#x3D;面对 理想与现实 当代青年怎么做？【万能句】&#x3D;&#x3D;</h4><blockquote>
<p><strong>学习上</strong><br>刻苦钻研、不畏艰难、孜孜不倦地学习理论和专业知识，不断提高思想道德和专业知识水平</p>
<p><strong>生活上</strong><br>艰苦朴素、勤俭节约，抵制和反对铺张奢华的思想和生活作风 <del>奢靡</del></p>
<p><strong>工作上</strong><br>奋发图强、不怕困难、不避艰难，努力完成各项任务 </p>
</blockquote>
<blockquote>
<h6 id="①-如何理解”给人温暖就是给自己幸福”？把关键词解释一下、放回原文解释一下"><a href="#①-如何理解”给人温暖就是给自己幸福”？把关键词解释一下、放回原文解释一下" class="headerlink" title="① 如何理解”给人温暖就是给自己幸福”？把关键词解释一下、放回原文解释一下"></a>① 如何理解”给人温暖就是给自己幸福”？<del>把关键词解释一下、放回原文解释一下</del></h6><p>人生价值包括：人的自我价值与社会价值<br>分别解释了…叫做人的自我价值…<br>人的自我价值与社会价值之间的关系</p>
<h6 id="②-怎样理解诚信及其道德力量？-与诚信相关的所有知识点扩展…"><a href="#②-怎样理解诚信及其道德力量？-与诚信相关的所有知识点扩展…" class="headerlink" title="② 怎样理解诚信及其道德力量？[与诚信相关的所有知识点扩展…]"></a>② 怎样理解诚信及其道德力量？[与诚信相关的所有知识点扩展…]</h6><p>诚信是传统美德 职业道德<br>社会主义核心价值观<br>诚信：诚实守信<br>诚信是讲信誉守规则</p>
<blockquote>
<p>解释A与B；论证A与B的关系；结合材料强调结论</p>
</blockquote>
<p>写一条 用一点材料放里面，在哪个地方体现了职业道德规范…</p>
<h4 id="一定要分点写"><a href="#一定要分点写" class="headerlink" title="一定要分点写"></a>一定要分点写</h4><h6 id="③-如何理解全面依法治国是建设社会主义国家的应有之义？"><a href="#③-如何理解全面依法治国是建设社会主义国家的应有之义？" class="headerlink" title="③ 如何理解全面依法治国是建设社会主义国家的应有之义？"></a>③ 如何理解全面依法治国是建设社会主义国家的应有之义？</h6><p>全面依法治国的意义</p>
<blockquote>
<p>全面依法治国是<u>坚持和发展中国特色社会主义的<strong>本质要求和重要保障</strong></u><br>全面依法治国是<u>实现国家治理体系和治理能力现代化的必然要求</u><br>全面依法治国<u>事关我们党执政兴国，事关人民幸福安康，事关党和国家长治久安。</u><br>全面依法治国也是<u>实现中华民族伟大复兴中国梦的必然要求</u></p>
</blockquote>
<h6 id="④-怎样看待”理想很丰满，现实很骨感”这种说法？"><a href="#④-怎样看待”理想很丰满，现实很骨感”这种说法？" class="headerlink" title="④ 怎样看待”理想很丰满，现实很骨感”这种说法？"></a>④ 怎样看待”理想很丰满，现实很骨感”这种说法？</h6><p>问态度，先表态 &#x3D;&gt; 想法比较片面<br>&#x3D;&#x3D;1.<strong>辩证看待理想与现实的矛盾</strong>。理想与现实是<strong>对立统一</strong>的。&#x3D;&#x3D;<br>2.<u>实现理想的<strong>长期性、艰巨性和曲折性</strong></u>。<br>理想受现实的规定和制约<strong>，是在</strong>对现实认识的基础上发展起来的<br>&#x3D;&#x3D;3.<u><strong>艰苦奋斗</strong>是实现理想的<strong>重要条件</strong></u>。&#x3D;&#x3D;<br><u><strong>理想与现实的关系</strong>：理想高于现实，是现实的升华，理想来源于现实，是对现实的反应，理想可以转化为现实。</u><br>理想和现实存在着对立的一面，二者的矛盾与冲突，属于&#x3D;&#x3D;<strong>“应然”<strong>和</strong>“实然”</strong>&#x3D;&#x3D;的矛盾。</p>
<h6 id="⑤-我们应如何从自身做起，构建文明的公共生活秩序？"><a href="#⑤-我们应如何从自身做起，构建文明的公共生活秩序？" class="headerlink" title="⑤ 我们应如何从自身做起，构建文明的公共生活秩序？"></a>⑤ 我们应如何从自身做起，构建文明的公共生活秩序？</h6><p>公共秩序、生活秩序 → 道德素质、法治素养<br>增强自身的社会公德意识和法律意识<br>学习和把握公共生活中的道德与法律规范，提升自身文明素质<br>养成遵守社会公德和遵纪守法的良好行为习惯<br>从身边小事做起，落实落细自己的道德实践经验和法律实践</p>
<h6 id="⑥-如何通过好家风的传承弘扬社会主义核心价值观？"><a href="#⑥-如何通过好家风的传承弘扬社会主义核心价值观？" class="headerlink" title="⑥ 如何通过好家风的传承弘扬社会主义核心价值观？"></a>⑥ 如何通过好家风的传承弘扬社会主义核心价值观？</h6><p>与社会 与社会主义核心价值观的关系  核心价值观是社会主流价值观<br>说明家风是形成社会主流价值的内容<br>个人：传承弘扬好的家风；树立人生正确的三观<br>国家&#x2F;社会：营造良好的社会氛围、加大宣传</p>
<h6 id="⑦-如何理解”伟大革命精神跨越时空、永不过时”？-怎样”把红色基因传承好，确保红色江山永不变色”？"><a href="#⑦-如何理解”伟大革命精神跨越时空、永不过时”？-怎样”把红色基因传承好，确保红色江山永不变色”？" class="headerlink" title="⑦ 如何理解”伟大革命精神跨越时空、永不过时”？ 怎样”把红色基因传承好，确保红色江山永不变色”？"></a>⑦ 如何理解”伟大革命精神跨越时空、永不过时”？ 怎样”把红色基因传承好，确保红色江山永不变色”？</h6><h6 id="⑧-为什么文明出行”既是道德的呼唤，也是法律的要求？”"><a href="#⑧-为什么文明出行”既是道德的呼唤，也是法律的要求？”" class="headerlink" title="⑧ 为什么文明出行”既是道德的呼唤，也是法律的要求？”"></a>⑧ 为什么文明出行”既是道德的呼唤，也是法律的要求？”</h6><p>道德要求 法律要求<br><strong>文明出行</strong>和道德、法律如何产生的关系呢？<br><strong>文明出行</strong>是公共生活的一部分，是公共秩序的一部分 &#x3D;&gt; 要道德 要法律<br>维护社会秩序的两种基本手段：道德和法律。公共生活中的道德和法律所追求的目标是一致的，都是通过规范人们的做法来维护公共生活中的秩序，实现经济社会的稳定和发展。<br>法律支撑和保障、为它所指引的！</p>
<h6 id="⑨"><a href="#⑨" class="headerlink" title="⑨"></a>⑨</h6></blockquote>
<h4 id="措施题："><a href="#措施题：" class="headerlink" title="措施题："></a>措施题：</h4><h6 id="x3D-x3D-当代大学生怎么做-x3D-x3D-：结合材料"><a href="#x3D-x3D-当代大学生怎么做-x3D-x3D-：结合材料" class="headerlink" title="&#x3D;&#x3D;当代大学生怎么做&#x3D;&#x3D;：结合材料"></a>&#x3D;&#x3D;当代大学生怎么做&#x3D;&#x3D;：结合材料</h6><p>1.提高相关意识<br>2.加强学习<br>3.养成习惯<br>4.养成担当责任<br>5.从自身做起，积极参加社会活动</p>
<h6 id="x3D-x3D-全社会该怎么做的问题-x3D-x3D-：结合材料"><a href="#x3D-x3D-全社会该怎么做的问题-x3D-x3D-：结合材料" class="headerlink" title="&#x3D;&#x3D;全社会该怎么做的问题&#x3D;&#x3D;：结合材料"></a>&#x3D;&#x3D;全社会该怎么做的问题&#x3D;&#x3D;：结合材料</h6><p>1.个人传承弘扬好的做法<br>2.家庭应该怎么做<br>3.社会营造氛围，加大宣传<br>4.国家完善法律法规，积极引导，典型示范。</p>
<hr>
<h4 id="红色文化"><a href="#红色文化" class="headerlink" title="红色文化"></a>红色文化</h4><h5 id="红色资源"><a href="#红色资源" class="headerlink" title="红色资源"></a>红色资源</h5><p>是中国共产党领导人民进行革命、建设、改革实践中形成和凝聚的物质、制度、精神载体。红色资源是宝贵的革命历史文化遗产，是党史学习教育鲜活生动的教科书</p>
<h5 id="红色基因"><a href="#红色基因" class="headerlink" title="红色基因"></a>红色基因</h5><p>对于共产党人的人生而言，红色基因是<strong>信仰</strong>，目光远大，追求高远；红色基因是<strong>忠诚</strong>，爱党爱国，矢志不渝；红色基因是<strong>追求</strong>，勇于拼搏,自强不息；红色基因是<strong>忘我</strong>，无私奉献、无怨无悔。这基因让青春常驻，让生命之花绽放</p>
<h6 id="红色基因内容"><a href="#红色基因内容" class="headerlink" title="红色基因内容"></a>红色基因内容</h6><p>@@ “三个代表”重要思想是中国特色社会主义划时代的标志<br>@@ 科学发展观第一要义<strong>发展</strong></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/政治" style=color:#ffa2c4>
                政治
            </a>
        </span>
        
    </div>

    <a href="/2023/03/22/政治/二十大知识点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/03/08/英语/(铭升)菲儿精华/">
        <h2>
            (铭升)菲儿精华
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/8
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><p>主要考法：词义辨析<br>次要考法：语法</p>
<h6 id="1-‘s和of的所属关系"><a href="#1-‘s和of的所属关系" class="headerlink" title="1. ‘s和of的所属关系"></a>1. ‘s和of的所属关系</h6><p><strong>‘s</strong> 所有格主要用于表示<strong>有生命</strong>的人或动物 名词的<strong>所属</strong>关系（the boy’s mother，Jack’s new car) ，<br><strong>of</strong>所有格主要用于表示<strong>无生命</strong>的名词的<strong>所属</strong>关系（the colour of the car, the price of honour)。<br>有of 考白字的(中英文擦边球) 漂亮<strong>地</strong> 没有所属关系时不用的  或者做状语！</p>
<h6 id="2-名词作定语时要用单数，但man、woman除外"><a href="#2-名词作定语时要用单数，但man、woman除外" class="headerlink" title="2. 名词作定语时要用单数，但man、woman除外"></a>2. 名词作定语时要用单数，但man、woman除外</h6><p>&#x3D;&#x3D;名词做定语时，确实一般都是<strong>单数</strong>的&#x3D;&#x3D;，因为这个时候的名词相当于形容词，而形容词是没有复数形式的。 所以我们看到了an apple tree而不是an apples tree，a department store而不是a departments store（虽然一个百货商店会有很多个departments）</p>
<p><strong>充当定语的名词应始终前置</strong></p>
<p>牢记这一点将有助于你理解名词充当定语时所组成短语的含义，例如：</p>
<blockquote>
<p><strong>race</strong> horse 比赛用马<br><strong>horse</strong> race 赛马比赛<br><strong>boat</strong> race 划船比赛<br><strong>love</strong> story 爱情故事<br><strong>war</strong> story 战争故事<br><strong>tennis</strong> ball 网球<br><strong>tennis</strong> shoes 网球鞋<br><strong>bicycle</strong> shop 自行车商店<br><strong>computer</strong> exhibition 电脑展</p>
</blockquote>
<h6 id="3-单复同形常考词-单独使用时候是单数"><a href="#3-单复同形常考词-单独使用时候是单数" class="headerlink" title="3. 单复同形常考词 (单独使用时候是单数)"></a>3. 单复同形常考词 (单独使用时候是单数)</h6><p><strong>fish、deer、sheep、Chinese、corps、counsel、Japanese、means、series、news、species、works</strong></p>
<h6 id="4-只能复数格式的常考词"><a href="#4-只能复数格式的常考词" class="headerlink" title="4. 只能复数格式的常考词"></a>4. 只能复数格式的常考词</h6><p><strong>noodles、vegetables、snacks、thanks、spirits、sports、celebrations、congratulations</strong>(congratulation on 恭喜某人…)</p>
<h6 id="5-A-PAIR-OF-成双成对-几套几把-按套-x2F-把-来定"><a href="#5-A-PAIR-OF-成双成对-几套几把-按套-x2F-把-来定" class="headerlink" title="5. A PAIR OF 成双成对 (几套几把 按套&#x2F;把 来定)"></a>5. A PAIR OF 成双成对 (几套几把 按套&#x2F;把 来定)</h6><p><strong>A</strong> <strong>pair</strong> <strong>of</strong> 在英语需要成双成对的表达： <strong>a pair of</strong> glasses （一副眼镜） a <strong>pair</strong> of scissors （一把剪刀） a <strong>pair</strong> of spectacles （一副眼镜） a <strong>pair</strong> of trousers （一条裤子） a pair of pants （一条裤子） a pair of pliers（一把剪钳）</p>
<h6 id="6-专有名词，the-United-States-书名、电影名、故事、人、事…"><a href="#6-专有名词，the-United-States-书名、电影名、故事、人、事…" class="headerlink" title="6. 专有名词，the United States[书名、电影名、故事、人、事…]"></a>6. 专有名词，the United States[书名、电影名、故事、人、事…]</h6><p>一般来讲，专有名词前面不用定冠词the，但江河海洋，山脉群岛地理名称前要用<strong>定冠词</strong><br>例如：the Yangtze River<strong>长江</strong> 由<strong>两个以上的普通名词</strong>组成的专有名词前，一般要用定冠词。<br>谓语动词的原型是复数 谓语动词加s 是单数 was</p>
<h6 id="7-所属的共同拥有和独自拥有"><a href="#7-所属的共同拥有和独自拥有" class="headerlink" title="7. 所属的共同拥有和独自拥有"></a>7. 所属的共同拥有和独自拥有</h6><p>如果<strong>两人共有</strong>，就是Tom and Peter’s room，在后面的人名后面加’s，room为单数。<br>如果指<strong>两人各自拥有</strong>的，就是Tom’s and Peter’s rooms，在两个人的人名后面都加’s，room为复数。<br>表示有生命的东西的名词及某些表示时间、距离、星球、世界、国家等无生命的东西的名词后加’s来表示所有关系，叫做名词所有格。<br>有the的不能用双数所有格 of前面是the后面不用双重所有格</p>
<h6 id="8-The后不用双重所有格，其余后可以"><a href="#8-The后不用双重所有格，其余后可以" class="headerlink" title="8. The后不用双重所有格，其余后可以"></a>8. The后不用双重所有格，其余后可以</h6><p>双重所有格，也就是将 ‘s 所有格 与 of所有格 结合在一起了；<br>我们来举个栗子：<br>你要开家长会了，你爸却没空。但是你爸有很多朋友，并且your father’s friends are all very kind, 他们都非常友好。于是你爸就叫他一个朋友去家长会了。第二天老师问你，谁来参加你的家长会呀？你怎么回答？回答：我爸<strong>一朋友~ a friend</strong> of my father’s friends，我爸众多朋友中的一个来开~但是这里有个单词friend重复了，读上去也很拗口，怎么搞呢？为了避免名词的重复，我用双重所有格：变成a friend of my father’s. 省略掉friends。<br>a friend of my father，含糊不清，a friend也许是你爸最好的朋友，也许是你爸唯一的朋友，也许是你爸朋友中的一个。而a friend of my father’s 双重所有格，表达的就是，我爸朋友们中的一个。</p>
<h1 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h1><p>判断方法：答案都是冠词<br>考点：</p>
<h6 id="1-特指和泛指-那个，一个-翻译"><a href="#1-特指和泛指-那个，一个-翻译" class="headerlink" title="1. 特指和泛指(那个，一个[翻译])"></a>1. 特指和泛指(<u>那个，一个[翻译]</u>)</h6><p><strong>不定冠词</strong>(<strong>a&#x2F;an</strong>)表示<strong>泛指</strong>；<u>任何一，每一</u>   a different kind表示泛指<br><strong>定冠词</strong>(<strong>the</strong>)表示<strong>特指</strong>、专指、类指；<u>独一无二的</u>；表示人的某个器官手上用the<br><strong>零冠词</strong>表示泛指人或事物、类指。</p>
<p>knowledge不可数名词 前面<strong>不能加</strong>不定冠词(a&#x2F;an) </p>
<blockquote>
<p>in public 在公众场合<br>the public 公众<br>in use 在用着<br><strong>单数可数名词</strong>表示泛指时，前面要用不定冠词a(an)，<br>表示<strong>特指</strong>时，前面要用定冠词the;<br><strong>不可数名词</strong>前不能用a(an)修饰，<br>He is a factory worker. 他是一名工人。<br>No one can see air. 没有人能看见空气。</p>
</blockquote>
<h6 id="2-固定搭配"><a href="#2-固定搭配" class="headerlink" title="2. 固定搭配"></a>2. 固定搭配</h6><p>80%正确方式<br>介词+名词   (一般名词前面没有冠词)<br>burst into laught 名词在介词之后 介词和名词之间没有冠词</p>
<p>动词+名词 (因词而异)<br>名词翻译为 <strong>一个、一项、一种</strong> &#x3D;&gt; 不定冠词</p>
<h6 id="3-抽象概念具体化"><a href="#3-抽象概念具体化" class="headerlink" title="3. 抽象概念具体化"></a>3. 抽象概念具体化</h6><p>抽象名词就是表示<strong>状态，品质，情感</strong>的<strong>没有实物</strong>的名词。比如responsibility（责任）, law（法律），love(爱情)，peace(和平)；具体化就是前面可加冠词（a&#x2F;an）,变成可数名词。</p>
<blockquote>
<p>一般说来抽象名词为不可数名词，但当抽象名词表示具体的东西时，可用作可数名词且词义发生变化，叫抽象名词具体化。主要类型如下：<br>① 抽象名词表示具有某种特性、状态、感情情绪的人或事。如：<br>抽象名词（不可数） 具体化（个体名词，可数名词）<br>in surprise惊讶地 a surprise一件令人惊讶的事<br>win success获得成功 a success一个(件)成功的人(事)<br>win honor赢得荣誉 an honor一个(件)引以为荣的(事)<br>Failure(失败)is the mother of success a failure失败者</p>
</blockquote>
<h6 id="4-发音-s-l-m"><a href="#4-发音-s-l-m" class="headerlink" title="4. 发音 s,l,m"></a>4. 发音 s,l,m</h6><p>冠词确定a&#x2F;an 后面的元音&#x2F;辅音字母<br>张嘴的一刻 牙齿嘴巴舌头没有任何的阻止和碰触 都是元音</p>
<h1 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h1><p>特点：答案均为代词答案<br>考点：</p>
<h6 id="1-every≥3-each-gt-2-both2-all-x3D-3-neither-x3D-2-either-x3D-2-混考"><a href="#1-every≥3-each-gt-2-both2-all-x3D-3-neither-x3D-2-either-x3D-2-混考" class="headerlink" title="1. every≥3, each&gt;2, both2, all&#x3D;3, neither&#x3D;2, either&#x3D;2 混考"></a>1. every≥3, each&gt;2, both2, all&#x3D;3, neither&#x3D;2, either&#x3D;2 混考</h6><blockquote>
<p>every 每个加单数名词 [后面不能直接跟of] 强调整体<br>each 每个加名词单数 强调个体<br>both 两者都 加<strong>复数名词</strong><br>all 三者以上的都加<strong>复数名词</strong><br>neither 两者都不 加单数名词<br>either 两者中任意一个加单数名词<br>any 许多加复数名词</p>
</blockquote>
<h6 id="2-someone-anyone-everyone-every-one-no-one-none-混考"><a href="#2-someone-anyone-everyone-every-one-no-one-none-混考" class="headerlink" title="2. someone, anyone, everyone, every one, no one, none 混考"></a>2. someone, anyone, everyone, every one, no one, none 混考</h6><blockquote>
<p><strong>前三个</strong>在含义上</p>
<ul>
<li>someone专用来特指某人的；<br>anyone是指任何人，并不是特指某一个人；<br>everyone是指每个人。</li>
</ul>
<p><strong>前三个</strong>在用法上</p>
<ul>
<li>someone通常用来表示有人，某人。<br>anyone是通常来表示无论谁，并没有限定范围的，不了解所描述的范围。<br>everyone是通常表示人人</li>
</ul>
<p>no one &#x3D; nobody, 语气比none强，后面不能接of构成的短语。none(人、物)可以接of构成的短语<br>someone, anyone和 everyone分别相当于 somebody,anybody和 everybody这些代词只能指人，后面不跟介词 of构成的短语；<strong>no one后可跟 of 短语</strong>，但只能说 <strong>no one of sb</strong>.,不能说 no one of sth.</p>
<p>none和 some one, every one, any one可以指人,也可以指物,根据后面介词 of的宾语或上下文而定</p>
<p><strong>none与no one</strong>的区别<br>none既可以指人也可以指物，no one&#x3D;nobody，只能指人<br>none强调数量，no one不强调数量<br>none作主语时，谓语动词用单数或复数均可，no one作主语时，谓语动词只能用单数</p>
<p><strong>every one</strong>与<strong>everyone</strong>的区别<br>everyone 只能用来指人，其意思相当于 everybody，在它后面<strong>不能</strong>跟介词of<br>every one是两个词，既可用来指人，也可用来指物，等于each one，后面可跟介词of</p>
</blockquote>
<h6 id="3-Other-the-other-others-the-others-another-混考"><a href="#3-Other-the-other-others-the-others-another-混考" class="headerlink" title="3. Other, the other, others, the others, another 混考"></a>3. Other, the other, others, the others, another 混考</h6><p>有s的后面不再跟s  没s的后面一般要跟名词<br>范围能数的清楚的加the 数不清的不加the<br>the other 如果范围  一方 另一方<br>喝了一瓶再拿一瓶 one and take other one</p>
<blockquote>
<ul>
<li><p><strong>other表示“别的，其它的”,它不能单独使用，后面必须要接可数名词的复数形式</strong>。<br>如：<br>He studies English, math and some <u>other subjects.</u> 他学习英语、数学和一些别的科目。<br>这句话中，就算前面没有some，other后面也只能用复数形式。</p>
</li>
<li><p><strong>the other多指“两者中的另一个”，也可以指三者及以上中剩下的最后一个。可以独立使用，也可以在后面接上名词。</strong><br>如：<br>（1）One of the twins likes apples, <u>the other</u> likes oranges. 这对双胞胎一个喜欢苹果，另一个喜欢桔子。 双胞胎是两个人，所以这是表示两者中的另一个。<br>（2）Four of the five boys are good at English, but the other isn’t. 这五个男孩中，有四个人英语都学得好，但另外那一个学得不好。本句就不止两个人，但只要是剩下的一个，都使用the other. 当然，我们也可以在the other后面加上名词boy.</p>
</li>
<li><p><strong>others 表复数，泛指“别人；别的东西”，它就相当于other+名词复数，因此它的后面不能再接名词。如果句中前面出现了some，后面通常就会用others，即构成“Some…others…”的结构， 这时也可以翻译成“有的……有的……”。</strong><br>如：<br>（1）Some students are dancing, others are singing. 一些学生在跳舞，其他的在唱歌。<br>这句话也可以翻译成“学生们有的在跳舞，有的在唱歌”。Others就相当于other students.<br>（2）Tom likes helping others. 汤姆喜欢帮助别人。</p>
</li>
<li><p><strong>the others 也表复数, 特指“别人；别的东西”，它相当于the other+名词复数，它后面不接名词</strong>。<br>Others是泛指，而the others是特指，怎么理解呢？如果排除一个不确定的数量，剩下的就用others，如上面的some students, some就是一个不确定的数量，所以剩下的数量也就不确定了，于是就用others来泛指。如果排除一个确定的数量，剩下的就应该用the others来特指。如：<br>Five students are dancing, the others are singing. 有五个学生在跳舞，其他的在唱歌。<br>本句中排除的学生是5个，这是一个确定的数量，于是后面也就用the others 来特指。当然，the others 也可以写成the other students.</p>
</li>
<li><p><strong>another表三者及以上中的“再一，另一”个，后接单数名词。这个单词本来就是“an other”两个单词的连写，所以它的前面不可能再用上冠词an.</strong><br>如：<br>（1）Have an another cup of coffee, please. 请再喝一杯咖啡。（错误，不能用an）<br>（2）Have another cup of coffee, please.请再喝一杯咖啡。（正确）<br>本句中如果用the other来代替another, 那意思就暗含这个主人一共只有两杯咖啡，客人喝了一杯，再请他喝另外的那一杯。意思当然就不对了</p>
<p><strong>another后还可以接“数词+名词复数”，这时是把“数词＋名词复数作为一个整体来看待的</strong>。<br>如：<br>She had to stay here for another ten days。她只好又在这儿呆了十天。<br>本句的意思暗含她原来就在这里已经住了若干天了，现在不得不又住一个十天。</p>
</li>
</ul>
</blockquote>
<h6 id="4-it-优先考虑-that-one-ones-those的辨析"><a href="#4-it-优先考虑-that-one-ones-those的辨析" class="headerlink" title="4. it[优先考虑], that, one, ones, those的辨析"></a>4. it[优先考虑], that, one, ones, those的辨析</h6><p>few 后面可数<br>little 后面不可数<br>有a就有一点点<br>没a就一点也没有</p>
<blockquote>
<ul>
<li><p><strong>it特指，代替前文提到过的事物。（同类同物）</strong>时间、地点、温度、想指代的都可以用it、形式主语、形式宾语、强调句<br>如：He is eating a banana. It looks delicious.他正在吃香蕉，这香蕉看起来很美味。<br>The baby is crying,it looks so sad.这个婴儿正在哭泣，它看起来如此伤心。</p>
</li>
<li><p><strong>that特指，代替<u>不可数名词</u>或<u>单数名词</u>，指物。</strong>同类不同一个时<br>如：The weather in Wuhan is hotter than that of Dongguan.（that &#x3D; the weather）武汉的天气比东莞的更热。</p>
</li>
<li><p><strong>one泛指，代替<u>单数名词</u>，可指人或物。（同类异物）</strong> 泛指一个<br>如：I don’t like this book,I’d like a more interesting one.（one&#x3D;book）我不喜欢这本书，我想要一本更有趣的。<br>I like the bananas,please give me one more.我喜欢香蕉，请再给我一个。<br>Among all people here,Tom is the most humorous one.这里所有人中，汤姆是最幽默的一个。</p>
</li>
<li><p><strong>ones泛指，代替<u>复数名词</u>，可指人或物</strong><br>如：There were a few young people with some old ones in the house.（ones&#x3D;people）有几个年轻人和一些老年人在那座房子里。</p>
</li>
<li><p><strong>those特指，代替复数名词。</strong><br>如：The machines are better than those we produced last year.（those&#x3D;the machines&#x3D;the ones）这些机器比我们去年生产的要好。</p>
</li>
</ul>
</blockquote>
<h6 id="5-It的特殊用法"><a href="#5-It的特殊用法" class="headerlink" title="5. It的特殊用法"></a>5. It的特殊用法</h6><blockquote>
<ul>
<li><p><strong>作为代词</strong></p>
</li>
<li><p><strong>t作为形式主语</strong></p>
<p>在<strong>S+V+O</strong>或<strong>S+V+P</strong>句型中，如果我们将名词从句置于主语位，则比较容易出现句子“头重脚轻”的情况，例如：</p>
<p><strong>That we stay away from the crowded city after feeling tired</strong> is a good idea.<br>（在感到疲倦后远离拥挤的城市是一个好主意。）</p>
<p>在上例中，我们须读到句尾“is a good idea”才能够弄清楚这是一个S+V+P的结构，而且如果主语更长的话，理解难度将会呈倍数增长。</p>
<p>语言追求的是简洁高效的表达，上句的结构显然与这种初衷相违背，形式主语it就是用于解决这一问题的：</p>
<p><strong>It</strong> is a good idea <strong>that we stay away from the crowded city after feeling tired.</strong></p>
<p><strong>将位于主语的名词从句置于句尾，再将形式主语it置于主语位置，这样名词从句就与句子的其它成分隔离开了</strong>。</p>
<p>此时我们只需读到“It is a good idea”就能明白这是一个S+V+P句型，整个句子的结构变得更加清晰。</p>
</li>
<li><p><strong>it作为形式宾语</strong></p>
<p>在<strong>S+V+O+C</strong>句型中，我们会用到形式宾语it。</p>
<p>形式宾语的用法和形式主语类似，例如：</p>
<p>We consider <strong>that we sign a contract in a few days</strong> desirable.<br>（我们认为在几天内签个合同是有必要的。）</p>
<p>因为S+V+O+C句型中的宾语是夹在谓语和补语之间，如果处于宾语位置的名词从句过长，读者就很难在短时间内搞懂句子的结构。</p>
<p>所以，我们可以把<strong>形式宾语it置于宾语位置，并将事实上的宾语置于句尾</strong>：<br>We consider <strong>it</strong> desirable <strong>that we sign a contract in a few days.</strong></p>
</li>
<li><p><strong>“dummy it”</strong></p>
<p>这种情况下的it没有任何词义，只是在句中起到填补主语位置的作用，例如：</p>
<p><strong>It</strong> is dark outside.<br>（外面天黑了。）</p>
<p><strong>It</strong> seems that he has been there for years.<br>（似乎他已经在那里很多年了。）</p>
</li>
<li><p><strong>it用于构成强调句</strong></p>
<p>it的另一种用法是构成强调句，强调句的常见形式为：</p>
<p><strong>It + be动词 + 强调部分 + that ….</strong></p>
<p>如果我们分别强调上句的①、②、③部分，可以得到：</p>
<p><u>Tom<del>①</del></u> opened <u>the box<del>②</del></u> <u>with a knife<del>③</del></u></p>
<blockquote>
<p><strong>It</strong> was <u><em>Tom</em></u> that opened the box with a knife.<br>（用小刀打开了那个盒子的是Tom。）</p>
</blockquote>
<blockquote>
<p><strong>It</strong> was <em><u>the box</u></em> that Tom opened with a knife.<br>（Tom用小刀打开的是那个盒子。）</p>
</blockquote>
<blockquote>
<p><strong>It</strong> was <em><u>with a knife</u></em> that Tom opened the box.<br>（Tom打开那个盒子是用的一把小刀。）</p>
</blockquote>
</li>
</ul>
</blockquote>
<h1 id="形容词和副词"><a href="#形容词和副词" class="headerlink" title="形容词和副词"></a>形容词和副词</h1><p>特点：答案为形容词或副词<br>考点：</p>
<h6 id="1-词义辨析"><a href="#1-词义辨析" class="headerlink" title="1. 词义辨析"></a>1. 词义辨析</h6><h6 id="2-形容词的比较级-as原形good-x2F-wellas…-more-than"><a href="#2-形容词的比较级-as原形good-x2F-wellas…-more-than" class="headerlink" title="2. 形容词的比较级(as原形good&#x2F;wellas…,  more than)"></a>2. 形容词的比较级(as原形<del>good&#x2F;well</del>as…,  more than)</h6><p>times 只能三倍以上<br>twice, double 可以两倍<br>倍数 + 长度宽度尺码… + of &#x3D;比较级<br>同级对比 北京比上海 头发和头发比<br>more than that of（同级对比）</p>
<p>英语中的形容词通常用三种形式来表达事物的等级差别，分别是<strong>原级、比较级和最高级</strong>。大部分形容词的比较级和最高级是通过变化词尾来实现的，属于规则变化，但也有少数是不规则变化。<br>英语中有些形容词说明<strong>形状、材质</strong>等，还有形容词<strong>没有程度可分</strong>或<strong>其本身就表示某种程度</strong>，故而<strong>没有比较级和最高级</strong>。</p>
<blockquote>
<h3 id="more-than"><a href="#more-than" class="headerlink" title="more than"></a><strong>more than</strong></h3><p>人口是大小 不是多少 population as large as</p>
<ul>
<li><strong>表示“比……更多”</strong></li>
</ul>
<p><strong>此时more为<u>many或much的比较级</u>，表示数量，后接名词。</strong><br>I made more mistakes than you.<br>我犯的错误比你多。</p>
<p>Last year there were more births than deaths.<br>去年的出生人数多于死亡人数。</p>
<p><strong>若more受much或many的修饰，则应分别与不可数和可数名词连用。</strong></p>
<p>His car cost much more money than mine.<br>他的小汽车所花的钱比我的多得多。</p>
<p>There are many more people than we expected.<br>比我们想象的人要多得多。</p>
<ul>
<li><strong>表示“比…更”</strong></li>
</ul>
<p><strong>此时more后接多音节形容词或副词，构成比较级，表示对两者进行比较。</strong></p>
<p>He is more careful than the others.<br>他比其他人更仔细。</p>
<p>Travelling by train is more relaxing than driving.<br>乘火车旅行比开汽车轻松得多。</p>
<p>This company is more concerned with quality than with quantity.<br>这家公司对质量比对产量更关心。</p>
<ul>
<li><strong>表示“与其说……不如说”</strong></li>
</ul>
<p><strong>此时不是对两个对象进行比较，而是对同一个人或物在两个不同方面进行比较或取舍，此时不论形容词或副词是单音节、双音节还是多音节，一律用more…than…。</strong></p>
<p>He is more lucky than clever.<br>与其说他聪明，不如说他幸运。</p>
<p>He was more frightened than hurt.<br>他伤倒不算什么，可受惊不小。</p>
<p>It is more grey than brown.<br>与其说它是棕色的，倒不如说是灰色的。</p>
<p>He is more (a) scholar than (a) teacher.<br>与其说他是位教师，不如说是位学者。　</p>
<p><strong>(1) 异类同质比较：即指两个不同的人或事物(异类)在同一方面(同质)进行比较。</strong></p>
<p>He is stronger than me.<br>他比我强壮。　　</p>
<p>Our country is more powerful than theirs.<br>我们的国家比他们的国家更强大。</p>
<p><strong>(2) 同类异质比较：即指同一个人或事物(同类)在两个不同的方面(异质)进行比较(注意译文)：</strong></p>
<p>He is more brave than wise.<br>他有勇无谋。　　</p>
<p>He’s more short than fat.<br>与其说他胖，不如说他矮。　　</p>
<p>She is more lucky than clever.<br>与其说她聪明，不如说她幸运。　　</p>
<h3 id="as原形as…"><a href="#as原形as…" class="headerlink" title="as原形as…"></a>as原形as…</h3><ul>
<li><strong>基本模式：as+形容词原级+as-分句</strong></li>
</ul>
<p> 1.主句主语与as-分句主语不同，比较项目相同，此时as-分句有所省略。如：<br>  <strong>Jack</strong> is as clever as <strong>Tom</strong>.</p>
<p> 2.主句主语与as-分句主语相同，但比较项目不同，此时as-分句不可用省略句。如：<br> <strong>The girl</strong> is as brilliant as <strong>she</strong> is beautiful. （这个女孩既漂亮又聪明。）</p>
<p> 3.主句主语与as-分句主语不同，比较项目也不同，此时as-分句不可用省略句。如：<br><strong>Her uncle</strong> was as base and unworthy as <strong>her father</strong> had been upright and honorable.<br>(她叔叔卑鄙龌龊，不像她父亲那样正直可敬。)</p>
<p> 4.基本模式的否定形式：<br> Jack is not as clever as Tom. 或 Jack is less clever than Tom.</p>
<ul>
<li><strong>变体模式：</strong></li>
</ul>
<p><strong>as many&#x2F;much+名词+as-分句：</strong></p>
<p>She has eaten <strong>as many apples as</strong> her sister.<br>He took <strong>as much water as</strong> he needed.</p>
<p><strong>as+形容词原级+名词词组+as-分句：</strong><br>Lucy is <strong>as clever a girl as</strong> her sister.</p>
<p> <strong>变体模式的否定形式：</strong><br>He didn’t take as much water as he needed.</p>
<p>需要注意的是，同一句话，采取基本模式和变体模式，它们的含义基本相同，但句子的侧重点有所不同。例如：</p>
<p>基本模式：I haven’t seen a car as old as this for years.（重点在名词car）<br>变体模式：I haven’t seen as old a car as this for years.（重点在形容词old）</p>
</blockquote>
<h6 id="3-形容词的比较级和倍数考点-倍数-完整比较级"><a href="#3-形容词的比较级和倍数考点-倍数-完整比较级" class="headerlink" title="3. 形容词的比较级和倍数考点(倍数+完整比较级)"></a>3. 形容词的比较级和倍数考点(倍数+完整比较级)</h6><blockquote>
<ul>
<li><strong>倍数 + 比较级 + than  表示的是多几倍</strong></li>
</ul>
<p> He is <strong>two years younger than</strong> you. 他比你小两岁。</p>
<ul>
<li><p><strong>倍数 + as + 形容词或副词的原级 + as + 其</strong></p>
</li>
<li><p><strong>倍+the+名词+of</strong></p>
</li>
</ul>
</blockquote>
<h6 id="4-特殊格式"><a href="#4-特殊格式" class="headerlink" title="4. 特殊格式"></a>4. 特殊格式</h6><blockquote>
<p>① more and more “越来越…”<br>② The more…, the more… “越…, 越…” the不可以省略<br>③ <strong>the</strong> 比较级 of the two (最高级形式表比较级) “两者中比较…的一个”<br>比较级 与 明确的范围 前面加the<br>④ <strong>序数词可以修饰最高级</strong><br>⑤ <strong>one of 后用最高级</strong></p>
</blockquote>
<p>very 不能放在动词前<br>a lone 单独的<br>lonely 孤单的</p>
<h1 id="动词时态-x2F-语态"><a href="#动词时态-x2F-语态" class="headerlink" title="动词时态&#x2F;语态"></a>动词<del>时态&#x2F;语态</del></h1><p>特点：1.答案是不同的动词时，考词义辨析<br>            2.答案是不同的时态时，考语法<br>解法：</p>
<h6 id="1-浏览题目，有没有特殊格式-虚拟-x2F-by"><a href="#1-浏览题目，有没有特殊格式-虚拟-x2F-by" class="headerlink" title="1. 浏览题目，有没有特殊格式(虚拟&#x2F;by)"></a>1. 浏览题目，有没有特殊格式(虚拟&#x2F;by)</h6><h6 id="2-留意答和原文是否有will的将来时，小心主将从现"><a href="#2-留意答和原文是否有will的将来时，小心主将从现" class="headerlink" title="2. 留意答和原文是否有will的将来时，小心主将从现"></a>2. 留意答和原文是否有<u>will的将来时</u>，小心<strong>主将从现</strong></h6><blockquote>
<p><u>if -&gt; 主将从现</u><br>[主将从现] IF条件状语从句、时间状语从句、让步状语从句<br>主句是祈使句时相当于将来时<br><u><strong>判断是否为虚拟语气找关键词、找主从句、找时间状语时态对应、是否时态杂糅</strong></u><br>如果没有now的表明现在时，就不要想太多啦[<strong><u>过，过</u></strong>]</p>
<table>
<thead>
<tr>
<th></th>
<th>if从句</th>
<th>主句</th>
</tr>
</thead>
<tbody><tr>
<td>与<strong>现在</strong>事实相反</td>
<td><strong>did&#x2F;were</strong></td>
<td>[wcms 厕所没水]<br /><strong>would&#x2F;should&#x2F;could&#x2F;might + do(动词原形)</strong></td>
</tr>
<tr>
<td>与<strong>过去</strong>事实相反</td>
<td><strong>had done</strong></td>
<td><strong>would&#x2F;should&#x2F;could&#x2F;might + have done</strong></td>
</tr>
<tr>
<td>与<strong>将来</strong>事实相反</td>
<td><strong>did&#x2F;were <br />to do<br />should do</strong></td>
<td><strong>would&#x2F;should&#x2F;could&#x2F;might + do(动词原形)</strong></td>
</tr>
</tbody></table>
</blockquote>
<h6 id="3-顺序：一被-被动-二单-三单-三时态-根据句意选答案"><a href="#3-顺序：一被-被动-二单-三单-三时态-根据句意选答案" class="headerlink" title="3. 顺序：一被[被动]二单[三单]三时态 (根据句意选答案)"></a>3. 顺序：<strong>一被<del>[被动]</del>二单<del>[三单]</del>三时态</strong> (根据句意选答案)</h6><blockquote>
<p>主动被动、单数复数<br>三单：指<strong>第三人称单数</strong>，指he, she, it</p>
</blockquote>
<h6 id="4-出现答案有had-done，务必保证过去之前"><a href="#4-出现答案有had-done，务必保证过去之前" class="headerlink" title="4. 出现答案有had done，务必保证过去之前"></a>4. 出现答案有<strong>had done</strong>，务必保证过去之前</h6><h6 id="5-出现答案有have-been-doing-完成进行时-答案是-have-done-时，务必牢记一直在做没间断"><a href="#5-出现答案有have-been-doing-完成进行时-答案是-have-done-时，务必牢记一直在做没间断" class="headerlink" title="5. 出现答案有have been doing(完成进行时) 答案是(have done)时，务必牢记一直在做没间断"></a>5. 出现答案有<strong>have been doing</strong>(完成进行时) 答案是(have done)时，务必牢记一直在做没间断</h6><h6 id="6-be-doing-现在正在进行时-；-be-being-done-现在进行时被动-x3D-x3D-轻易不出现-一出现就是答案-x3D-x3D"><a href="#6-be-doing-现在正在进行时-；-be-being-done-现在进行时被动-x3D-x3D-轻易不出现-一出现就是答案-x3D-x3D" class="headerlink" title="6. be doing 现在正在进行时 ； be being done 现在进行时被动 [&#x3D;&#x3D;轻易不出现 一出现就是答案&#x3D;&#x3D;]"></a>6. be doing 现在正在进行时 ； <u>be being done 现在进行时被动 [&#x3D;&#x3D;轻易不出现 一出现就是答案&#x3D;&#x3D;]</u></h6><h6 id="7-过去时，过去完成时"><a href="#7-过去时，过去完成时" class="headerlink" title="7. 过去时，过去完成时"></a>7. 过去时，过去完成时</h6><h1 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h1><p>特点：答案均为介词<br>考点：<strong>固定搭配 (读句意，确定答案)</strong></p>
<h6 id="1-单个介词的使用"><a href="#1-单个介词的使用" class="headerlink" title="1. 单个介词的使用"></a>1. 单个介词的使用</h6><p>under正下方      below下方就行<br>over正上方         about上方就行<br>through 纵穿<br>pass在前面穿过</p>
<blockquote>
<p><img src="https://th.bing.com/th/id/R.a9075585f2320f6dda218168b346e815?rik=qDG3nMsAXU7vag&riu=http://www.englishlearnsite.com/wp-content/uploads/2015/09/prepositions-visual-method.jpg&ehk=/4DqCN2R4i+hAKsJB/X6ZbsdCNppm/SzHDvKDoj6hJY=&risl=&pid=ImgRaw&r=0"></p>
<h6 id="①-on-in-at-的时间选择"><a href="#①-on-in-at-的时间选择" class="headerlink" title="① on, in, at 的时间选择"></a>① <strong>on</strong>, in, at 的时间选择</h6><p>介词：形容词&#x2F;特定&#x2F;范围 用<u><strong>on</strong>[节日<del>带</del>day]  <strong>at</strong>[节日<del>不带day</del>]</u>  <u>On</u> a clod afternoon in December<br><strong>in 用一段较长的时间段前面</strong>，包括年份，月份，季节等。<br><strong>on 主要是用在具体的一天前面</strong>，包括星期几和几月几号。时间在一天之内 特指的 特定的<br><strong>at + 时间点</strong> &#x2F; at noon, at night, at midnight</p>
<p><u>大于1天用in，等于1天用on，小于1天用at</u>，<br>特例<br>in the morning&#x2F;afternoon&#x2F;evening，<br>on a cold&#x2F;warm&#x2F;hot morning&#x2F;afternoon&#x2F;evening，<br>on the morning of July 4th</p>
<h6 id="②-at-the-end-in-the-end-at-the-beginning-in-the-beginning-区别"><a href="#②-at-the-end-in-the-end-at-the-beginning-in-the-beginning-区别" class="headerlink" title="② at the end, in the end, at the beginning, in the beginning 区别"></a>② at the end, in the end, at the beginning, in the beginning 区别</h6><p><strong>at the end</strong> 更多的是用它的字面意思，表示在某个名词的结尾或末端，这个名词可以是一个物理对象，一段时间，一个事件，一个地方，或者更抽象的东西，比如一个人的耐心，<br>而 <strong>in the end</strong> 中的 end 是指一般的“end”区域，是一个习惯用语，意为 “最后，终于，到头来”<br><em><strong><u>at the end 后面要接 of 介词短语</u>，而 in the end 单独在句中作状语，通常用逗号与后面的隔开。</strong></em><br>The heroes celebrated at the end of their journey.<br>In the end, what really matters in a friendship is trust.</p>
<p><strong>at the beginning 常常跟of 短语连用</strong>。<br>At the beginning of this century a great many Europeans went to live in the USA.<br>本世纪初许多欧洲人去美国居住。</p>
<p><strong>in the beginning</strong> 通常单独用作时间状语或定语,而不和of短语连用,意为“<u>起初；在开始的时候</u>” 暗含着后来又变化的意思<br>In the beginning we thought we’d better get it all arranged. 在开始的时候,我们以为不会把它全安排好。</p>
<h6 id="③-in-on-by-加交通工具"><a href="#③-in-on-by-加交通工具" class="headerlink" title="③ in, on, by 加交通工具"></a>③ in, on, by 加交通工具</h6><p>by bus <strong>用车的方式</strong>乘坐<br>&#x3D;&#x3D;<strong>铁包肉用in(bus) <u>take</u>     肉包铁用on(自行车) <u>ride</u></strong>&#x3D;&#x3D;<br>除了自行车[ride bike]   用动词时 一律用take<br>on foot 步行     on farm 在农场</p>
<h6 id="④-in-after-later-表示-“…后”-的区别"><a href="#④-in-after-later-表示-“…后”-的区别" class="headerlink" title="④ in, after, later 表示 “…后” 的区别"></a>④ in, after, later 表示 “…后” 的区别</h6><p><u><strong>after</strong>以<strong>过去</strong>为起点</u>，表示<u><strong>过去</strong>一段时间之后</u>，常用于<strong>过去时态</strong>的句子中。<br>可以用<strong>：时间段+later</strong> 或者 <strong>after+时间段。</strong></p>
<blockquote>
<p>表示某时间点之后 用：after+时间点<br>after ten o’clock：十点之后<br>after April 23rd：4月23号之后</p>
<p>表示某时间点之前 用：before+时间点<br>before ten o’clock：十点之前<br>before April 23rd：4月23号之前</p>
</blockquote>
<p>Two hours <strong>later</strong>, Jcak came back with an axe. 两小时之后，杰克拿着一把斧头回来了。<br>She went <strong>after</strong> three days．她是三天以后走的</p>
<p><u><strong>in</strong>以<strong>现在</strong>为起点</u>，表<u><strong>将来</strong>一段时间以后</u>，常用于<strong>将来时态</strong>的句子中，<br>I will go to London in two weeks. 我两周之后去伦敦<br>She will go in three days．她三天以后要走</p>
<h5 id="on-over-above-under-below-混考"><a href="#on-over-above-under-below-混考" class="headerlink" title="on, over, above, under, below 混考"></a>on, over, above, under, below 混考</h5><blockquote>
<p><strong>on</strong>表示在一物体上，强调<strong>两物相接触</strong><br>She put her coat <strong>on</strong> the bed. 她把大衣放在床上</p>
<p><strong>over</strong>也表示在一物体上，但强调<strong>覆盖这一物体</strong>。试比较<br>She put her coat <strong>over</strong> the sleeping baby.   她把大衣盖在那正在睡觉的孩子身上。</p>
</blockquote>
<blockquote>
<p><strong>on</strong>仅表示“处于……之上”，是<strong>静态</strong>。<br>he farmers walked to their fields with hoes <strong>on</strong> their shoulders.<br>农民们肩上扛着锄头，向田地走去。(仅表示锄头所处的位置。是静态，用on，不用over. )</p>
<p><strong>over</strong>表示“越过”某一高度，具有<strong>动态</strong>之意<br>They dragged heavy stones with ropes over their shoulders.<br>他们肩背绳索拖拽巨石。(绳在肩膀两边弯下去，不用on)</p>
</blockquote>
<blockquote>
<p><strong>above</strong>表示位置<strong>高于某人或某物</strong>。但不一定是正上方，反义词是below.</p>
</blockquote>
<blockquote>
<p><strong>below</strong>与<strong>under</strong> 两者都可表示 “<strong>低于</strong>”<br>under 主要表示<strong>垂直在下的正下方</strong>，两物体可以接触，也可以间隔一定距离。<br>I out the money <strong>under</strong> the mattress. 我把钱放在床垫下面<br><u>表示正下方，两者都可用；不表示正下方，则通常用below</u><br>I out the money <strong>under</strong> the mattress 我把钱放在床垫下面</p>
<p><strong>below</strong>与<strong>under</strong>均可表示数量方面的“<strong>少于</strong>”，但在现代英语中，以用 under 为多见<br>below 表示“少于”，主要用于<u>表示温度、高度以及有纵向标准可比</u>的情况</p>
<p><strong>beneath</strong> 可以用来替换under,但是在<strong>抽象含义</strong>时，最好用beneath<br>He would think it beneath him to tell a lie. 他认为说谎有失他的身份。<br>She married beneath her. 她嫁给了一个比她地位低的人。</p>
</blockquote>
<h6 id="⑥-across，through，over，past-表”通过”区别"><a href="#⑥-across，through，over，past-表”通过”区别" class="headerlink" title="⑥ across，through，over，past 表”通过”区别"></a>⑥ across，through，over，past 表”通过”区别</h6><blockquote>
<p><strong>over</strong> 在某物上方“通过、越过”，与表面不接触</p>
<blockquote>
<p>在表示“从……上面”穿过的时候，across 和 over 可以互换，但是表示“<strong>翻过</strong>”的时候，只用 over<br>The Sawyers are walking over the bridge.（索耶一家正在过桥)<br>The dog jumped over the fence into the garden.（那条狗跳过篱笆进入了花园）</p>
</blockquote>
<p><strong>through</strong> 从某一个物体的里面或者一定范围内穿过、横过，往往是穿过一个有“框”的东西</p>
<blockquote>
<p>比如门窗、树林、隧道等等。<br>The thieves climbed into the kitchen through the window. （小偷们通过窗户翻进了厨房）<br>After walking through the forest, they arrived at the small village. （穿过森林，他们到了那个小山村）</p>
</blockquote>
<p><strong>across</strong> 表示从某一个物体的表面横过、穿过用</p>
<blockquote>
<p>往往是从上面跨过，比如跑过草地、跨过马路等等。<br>The dog is running <strong>across</strong> the grass after the cat. （那只狗正穿过草地追那只猫咪）<br>Can you swim <strong>across</strong> the river?（你能游到河的对岸吗？）</p>
</blockquote>
<p><strong>past</strong> 从旁边经过，可以和含有动词 pass 的句子替换。</p>
<blockquote>
<p>A girl went <strong>past</strong> me in a hurry. （一个女孩匆匆忙忙从我身边走过）<br>A girl <strong>passed</strong> me in a hurry. （一个女孩从我身边匆匆经过）</p>
</blockquote>
</blockquote>
<h6 id="⑦-in，with，by-表”用”的区别"><a href="#⑦-in，with，by-表”用”的区别" class="headerlink" title="⑦ in，with，by 表”用”的区别"></a>⑦ in，with，by 表”用”的区别</h6><p><strong>in</strong>：用语言或原材料</p>
<p><strong>with</strong>: 带有，附带→手里拿着→用（工具物质做某事）[真真实实的东西]。</p>
<blockquote>
<p>常用于<strong>人手可持握</strong>操作的工具<br>cut it with a knife. 用刀切<br>write it down with a pen. 用笔写</p>
</blockquote>
<p><strong>by</strong>：从…旁边经过→通过→通过…方式&#x2F;工具&#x2F;手段&#x2F;媒介。</p>
<blockquote>
<p>常用于<strong>交通工具</strong>和<strong>抽象动作</strong><br>by foot&#x2F;car&#x2F;bus&#x2F;train&#x2F;plane. 走路、坐车、搭公交、乘火车、坐飞机。<br>You can speak Engllish well only by practicing. 只有通过练习你才能说好英语。</p>
</blockquote>
<p><strong>through</strong>：从…中穿过→通过某物→通过某人、某媒介、某行为（作方式状语）</p>
<blockquote>
<p>强调经历了某个过程或具有较强的中介性<br>make progress <strong>through</strong> efforts. 通过努力取得进步。(经历过程）<br>look <strong>through</strong> a telescope. 用望远镜看. (目光从一端进入，从另一端穿出）<br>hear sth. <strong>through</strong> sb. 通过某人听说某事。(中介性）</p>
</blockquote>
<h6 id="扩展1：by表抽象的方式、动作。而with表具体的工具，有形的手段。"><a href="#扩展1：by表抽象的方式、动作。而with表具体的工具，有形的手段。" class="headerlink" title="扩展1：by表抽象的方式、动作。而with表具体的工具，有形的手段。"></a>扩展1：by表抽象的方式、动作。而with表具体的工具，有形的手段。</h6><p>He killed the spider by hitting it.  他把蜘蛛打死了。<br>He killed the spider with a flapper. 他用苍蝇拍把蜘蛛拍死了。</p>
<h6 id="扩展2：在被动句中，by指行为者-人或物-with表工具或物料"><a href="#扩展2：在被动句中，by指行为者-人或物-with表工具或物料" class="headerlink" title="扩展2：在被动句中，by指行为者(人或物), with表工具或物料"></a>扩展2：在被动句中，by指行为者(人或物), with表工具或物料</h6><p>He was killed <strong>by</strong> a heavy stone.  他被一块儿石头砸死了。<br>He was killed <strong>with</strong> a heavy stone.  他被人用一块儿石头砸死了。</p>
<h6 id="⑧-门牌，路名，地名的介词"><a href="#⑧-门牌，路名，地名的介词" class="headerlink" title="⑧ 门牌，路名，地名的介词"></a>⑧ 门牌，路名，地名的介词</h6><p><strong>in：“在某个区域”。</strong></p>
<blockquote>
<p>in the market, in the field, in the street。把“大街” 也视为一个区域。<br>in用在大地名前,城市或比城市更大</p>
</blockquote>
<p><strong>on：“在某物的上面”。（与之接触）</strong></p>
<blockquote>
<p>on在水边,江河湖海之滨</p>
</blockquote>
<p><strong>at：“在附近；在一边&#x2F;一旁”。</strong></p>
<blockquote>
<p>He lives at 152 Base Street.  at用在小地名前,比城市小</p>
</blockquote>
<p>但是若指……范围之内,还是要用in,<br>尽管不是大地名.in the school,in the office<br>街道门牌号码前用at,<br>若仅仅是街道,都可用,in the street,on the street</p>
<h6 id="⑨-Die-of-die-from-made-of-made-from区别"><a href="#⑨-Die-of-die-from-made-of-made-from区别" class="headerlink" title="⑨ Die of, die from, made of, made from区别"></a>⑨ Die of, die from, made of, made from区别</h6><blockquote>
<p><strong>die of</strong><del>内因</del> 用于死因存在与人体身体之内[<strong>illness</strong>]<br><strong>die form</strong><del>外因</del> 用于死因由环境造成的[<strong>earthquake</strong>]</p>
</blockquote>
<blockquote>
<p><strong>made from</strong><del>看不出原材料</del> 和 <strong>made of</strong><del>看得出原材料</del> 区别，是<strong>基于 from 和 of 的基础认知含义</strong>。<br>from 指从哪里来，<br>of 表示某种隶属或从属关系。<br>一座桥是 made from stone，讲造桥用到的<strong>物料来源</strong><br>石头是 made of stone，讲构建成桥的<strong>组分</strong>或者<strong>成分</strong>。</p>
</blockquote>
<h6 id="⑩-except-except-for-except-that-but-besides-beside的区别"><a href="#⑩-except-except-for-except-that-but-besides-beside的区别" class="headerlink" title="⑩ except, except for, except that, but, besides, beside的区别"></a>⑩ except, except for, except that, but, besides, beside的区别</h6><p>你是我不是except, except for, except that</p>
<p>你是我也是besides, beside</p>
<blockquote>
<p><strong>besides表示除……外（还有），是包括在内的意思【加法的概念】。</strong><br>例：Besides tomatoes, I also like potatoes. (包括tomatoes）<br><strong>beside”是介词，有两个意思，“在…旁边<del>常用来表示位置和方向。</del>”和“与…相比”</strong><br>He is standing beside the tree.  他站在在树的旁边。<br>My handwriting looks so childish beside yours.  和你的字相比，我的看起来很幼稚。</p>
</blockquote>
<blockquote>
<p><strong>except与except for均表示除去，是不包括的意思【减法的概念】。</strong><br>但两者从语法角度有区别，不能随意互换。<br>*** 区别一：**except for能放句首，但except不能。<br>例：Except for Jim, who is unwell, they are all ready to leave for America tomorrow. (不包括Jim)</p>
<p>*** 区别二：**except for由于有介词for，故后面只能接名词&#x2F;动名词或名词性短语；<br>except后面既可以接名词或名词性短语，也可以接从句、介词短语甚至动词。<br>    例1. I like all vegetables except (for) tomatoes. (不包括tomatoes)<br>    例2. You are allowed to smoke everywhere except <em>in the lobby</em>. (不包括in the lobby）<br>    例3. The dish you cooked was great except <em>that it could use more salt</em>.（这里不要直译，可译为“你做的这道菜很好吃，就是味道可以稍微再咸一点。”）</p>
<blockquote>
<p><strong>except that 只可惜</strong><br>The regretful thing was the awful weather that degraded the nice scenery.<br>只可惜天公不作美，总是阴雨连绵，影响了景致。</p>
</blockquote>
</blockquote>
<h6 id="⑪-by-时间的特殊用法"><a href="#⑪-by-时间的特殊用法" class="headerlink" title="⑪ by + 时间的特殊用法"></a>⑪ by + 时间的特殊用法</h6><p>by后加某一时间,<strong>表示到某时为止</strong>，不能加某一时间段. [有最后期限的意思]</p>
<h6 id="by-指“在……前（时间）；截至（到）……”："><a href="#by-指“在……前（时间）；截至（到）……”：" class="headerlink" title="by 指“在……前（时间）；截至（到）……”："></a>by 指“在……前（时间）；截至（到）……”：</h6><p>How many English books had you read by the end of last year?  到去年年底以前你…</p>
<p><strong>by后加<u>过去</u>时间，用于主句是过去完成时</strong>。<br>By the time he was 7,he had learnt English himself. 到7岁的时候，他就已经自学了英语</p>
<p><strong>by后加<u>现在</u>时间，用于主句是现在完成时</strong><br>I have done my homework by the time you come. 你回来以前我就把我的回家作业做完了。</p>
<p><strong>by后加将来时间，且从句事件发生在主句事件之前，主句动词可用一般时态。</strong><br>Can you reply to me by tomorrow? 你能在明天之前答复我吗？</p>
<blockquote>
<p><strong>by now 就是现在完成时</strong><br><strong>by + 将来时间,就是将来完成<br>by+ 过去时间,就是过去完成</strong></p>
</blockquote>
<h6 id="by作介词时"><a href="#by作介词时" class="headerlink" title="by作介词时"></a>by作介词时</h6><blockquote>
<ul>
<li><strong>靠近, 在…旁边;</strong><br>A dog sits by her. 一条狗挨着她坐</li>
<li><strong>被, 表被动;</strong><br>I was told the truth by him. 我被他告知了真相</li>
<li><strong>由于; (置于不带the的名词前，表示原因)</strong><br>I found my notebook by chance. 我碰巧找到我的笔记本</li>
<li><strong>在…期间, 处于某种情况;</strong><br>to go on a trip by day. 在白天旅行</li>
<li><strong>经过</strong><br>He walked by me without speaking. 他一言不发地从我身边走过</li>
<li><strong>从…看；按照</strong><br>By my watch it is two o’clock. 我的手表上显示的是两点钟。</li>
</ul>
</blockquote>
</blockquote>
<h1 id="连词看此意"><a href="#连词看此意" class="headerlink" title="连词看此意"></a>连词<del>看此意</del></h1><p>特点：答案均是连词<br>考点：<br>一般考上下文逻辑关系，看句意给答案<br>特殊答案：</p>
<blockquote>
<p><strong>While</strong> 当…是，区别when；<br>while巴拉巴拉     主句pia<del>结束性动作</del><br>when pia      主句巴拉巴拉<del>延续动词、正在进行</del>.<br>as….as…<br>as pia 主句pia</p>
<blockquote>
<p>表示<strong>相对关系</strong>, “而”；表示<strong>让步</strong>, “尽管” <u>一般是加在两个句子的中间起转折作用</u>。while用作连词时，表示“在…(过程)中，在…期间”。常用来引导[时间状语从句]，当主句的主语和while所引导的从句的主语一致时，while从句中的主语、谓语往往可以省去。</p>
</blockquote>
<p><strong>unless</strong> 除非, 否则</p>
<blockquote>
<p>The company won’t keep going <strong>unless</strong> we can get some loan.除非我们能搞到贷款，否则公司就维持不下去了。</p>
</blockquote>
<p><strong>until</strong>：直到…时</p>
<blockquote>
<p><strong>Until</strong> 小心前面考有没有not 意为直到，<u>主句一般为延续性动词</u><br>till用作连词用于肯定句时表示“直到…为止”，指某一动作或状态一直持续到till后面的句子所表示的时间为止，这时主句的谓语动词是[延续性动词]<br>He banged on the door <strong>until</strong> she let him in. 他砰砰打门，一直到她开门让他进去为止。<br>will not …  until</p>
</blockquote>
<p><strong>as</strong> 头, 第二, 中间</p>
<blockquote>
<p>as 用于引出一个持续性动词表示“在…期间”时，其谓语通常只能是那些含有动作(action)和发展(development) 意味的动词，一般不能是那些不用于进行时态的动词(如 be, seem, love, want, agree, see, know, have 等)，</p>
</blockquote>
<p><strong>since</strong>：自…以后</p>
<blockquote>
<p><u>since一般用作介词，从句一般都是表因为</u><br>since用作介词的意思是“从…以来，自从…之后”，其宾语常指过去的一个时间点，其含意通常指持续到说话时刻的动作或情况开始于什么时候。</p>
</blockquote>
<p><strong>as soon as</strong>：一…就… <u>主要是强调主句和从句的动作发生的的时间具有同步性</u></p>
<blockquote>
<p>I recognized him as soon as I saw his back. 我一看到后身，就认出是他。</p>
</blockquote>
<p><strong>once</strong>：一旦</p>
<blockquote>
<p>Once you start a task,you must bear it through.你一旦开始一件任务，就必须把它完成。</p>
</blockquote>
</blockquote>
<h1 id="数词"><a href="#数词" class="headerlink" title="数词"></a>数词</h1><p>特点：答案包含各种类型的数字<br>考点：</p>
<blockquote>
<h6 id="①-形容词比较级的倍数关系"><a href="#①-形容词比较级的倍数关系" class="headerlink" title="① 形容词比较级的倍数关系"></a>① 形容词比较级的倍数关系</h6><p>倍数+比较级的顺序关系  倍数和数字+完整的比较级关系 <strong>倍数+as…as</strong><br>比较级考点：<u>同级比较、倍数与比较级</u>；<br>形容词倍数关系 <strong>倍数+完整的比较级</strong><br>Peter’s jacket looked just the same as Jack’s, but it cost <strong>twice as much as</strong> his.</p>
<h6 id="②-当hundred-thousand-million-billion前面有基数词时"><a href="#②-当hundred-thousand-million-billion前面有基数词时" class="headerlink" title="② 当hundred, thousand, million, billion前面有基数词时"></a>② 当hundred, thousand, million, billion前面有基数词时</h6><p>用单数形式，词尾不加 <strong>-s</strong>; 前面有<strong>many, several, a few</strong>修饰时，仍用单数形式</p>
<h6 id="③-表示概述时"><a href="#③-表示概述时" class="headerlink" title="③ 表示概述时"></a>③ 表示概述时</h6><p>用<strong>ten, hundred, thousand, billion</strong>的复数形式加<strong>of</strong>，后面接复数名词</p>
<h6 id="④-every和数词连用"><a href="#④-every和数词连用" class="headerlink" title="④ every和数词连用"></a>④ every和数词连用</h6><p>可表示”<strong>每隔；每逢</strong>“，在基数词后用复数可数名词，在序数词后用单数可数名词<br>“every other&#x2F;second + 单数名词” 表 “每隔一…”</p>
<blockquote>
<p><strong>基数词：指描述事物数量多少的词。 序数词：指表示顺序的数词</strong>。<br>(1-10)<strong>基数词</strong>）：one. two. three. four. five. six. seven. eight. nine. ten.<br>(1-10)<strong>序数词</strong>） ：first. second. third. fourth. fifth. sixth. seventh. eighth. ninth. tenth.</p>
</blockquote>
<h6 id="⑤-编码排序"><a href="#⑤-编码排序" class="headerlink" title="⑤ 编码排序"></a>⑤ 编码排序</h6><p>(1) 表示数目：the first lesson<del>the序数词</del>, lesson one<del>基数词</del><br>(2) 模糊数字s +of：Hundreds of数以百计的  Thousands of数以千计的<br>(3) “基数词 + 连字符 + 名词”  可以构成复合形容词表示数量，此时名词应用单数形式，<br>相当于“基数词+复数名词的所有格”<br>a ten-minute walk十分钟的步行路程    a three-week holiday 为期三周的假期<br>(4) 分子基, 分母序, 分子大于1, 分母加s  1&#x2F;3 one-third   2&#x2F;3 two-thirds</p>
</blockquote>
<h1 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h1><p>特点：答案全部或部分为非谓语动词<br>做题流程：</p>
<blockquote>
<h6 id="①-确定是否有非谓语答案-所在句中是否有谓语动词"><a href="#①-确定是否有非谓语答案-所在句中是否有谓语动词" class="headerlink" title="① 确定是否有非谓语答案(所在句中是否有谓语动词)"></a>① 确定是否有非谓语答案(所在句中是否有谓语动词)</h6><h6 id="②-若为非谓语动词，判断成分"><a href="#②-若为非谓语动词，判断成分" class="headerlink" title="② 若为非谓语动词，判断成分"></a>② 若为非谓语动词，判断成分</h6><p>​    (1) 有逗号，无连词或无主语或均无，作状语<br>​    放在开头，先确定是否为目的状语<br>​    ing和ed选择取决于逻辑主语</p>
<p>​    (2) 无逗号的整句，则为其他成分<br>​    a. 主语：不定式或动名词(特指泛指)<br>​    b. 宾语：不定式或动名词(固定搭配) (做没做)<br>​    c. 表语：均可(乾坤大挪移) 不能移用分词(ing物，ed人) 能移另外二(没做要做to do)<br>​    d. 宾语补足语：均可<br>​        -普通动词后：to do<br>​        -感官类，使役类动词后：均可<br>​            △ 要做没做，主动做过 to do<br>​            △ 正在做ing【首选ing】<br>​            △ 被动或且被动ed  <strong>have sth done</strong><br>​        -<strong>get, find, keep, leave</strong> 后均可，但必须用to do<br>​        -make oneself done</p>
<p>to在原句里出现一般是介词 doing</p>
<p>feel like doing </p>
<p>can not like doing sth<br>人mean todo(打算做)  物mean doing(事意味着)<br>stop to do停下来去做 doing停下在做的<br>go on with sth        go on to do继续去做另一件事 doing继续原来的事<br>continue 同理<br>放在前面作定语不是ing 就是ed<br><strong>ing表示主动或且进行  ed表示被动或且完成</strong><br>已经落在地上的叶子 完成</p>
<p>被动完成ed 主动进行ing  正在进行ing 要做没做主动做完todo</p>
<p>宾语补足语：感官类 使役类(have let make) to 省略<br>have表达意思是 <strong>有</strong>  have sth to do   <strong>让</strong> have sth done</p>
<p>remember todo没做&#x2F;doing做过<br>regret 遗憾todo 后悔doing</p>
<p>todo 一般都在动词后面</p>
</blockquote>
<h1 id="情态动词"><a href="#情态动词" class="headerlink" title="情态动词"></a>情态动词</h1><p>特点：答案中均含有情态动词<br>考点</p>
<blockquote>
<h6 id="①-基本含义考法-要啥给啥"><a href="#①-基本含义考法-要啥给啥" class="headerlink" title="① 基本含义考法(要啥给啥)"></a>① 基本含义考法(要啥给啥)</h6><h6 id="②-表推测-can-could-may-might-must-should"><a href="#②-表推测-can-could-may-might-must-should" class="headerlink" title="② 表推测(can, could, may, might, must, should)"></a>② <u>表推测</u>(can, could, may, might, must, should)</h6><p>​    (1) <strong>肯定</strong>(can陪葬) (看可能性大小)(CSmust) <u>肯定玩CSm<del>必须滴</del></u></p>
<blockquote>
<p>&#x3D;&#x3D;<strong>can, could</strong>, must, should 用在<strong>肯定句</strong>中表示理论上的可能性，”经验之谈”<br>[万能陪葬can] [can只能用于天下真理]&#x3D;&#x3D;</p>
<blockquote>
<p>说的事情让别人高兴 –&gt; should (70%)<br>说的事情可能让别人不高兴 –&gt; might</p>
</blockquote>
</blockquote>
<p>​    (2) <strong>否定</strong>(can系列，不可能)(may系列，可能不)(CCMM) <u>不可以<del>操操妹妹</del></u></p>
<blockquote>
<p>&#x3D;&#x3D;<strong>can, could</strong>, may, might 用在<strong>否定句</strong>中表推测，翻译成”<strong>不可能</strong>“&#x3D;&#x3D;</p>
</blockquote>
<p>​    (3) <strong>疑问</strong>(can系列)</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>can, could</strong> 用在<strong>疑问句</strong>中表推测，表示’’<strong>可能性</strong>‘’&#x3D;&#x3D;</p>
</blockquote>
<h6 id="③-对过去猜测-have-done-can系列-may系列-must"><a href="#③-对过去猜测-have-done-can系列-may系列-must" class="headerlink" title="③ 对过去猜测(+have done)(can系列 may系列 must)"></a>③ <u>对过去猜测</u>(+have done)(can系列 may系列 must)</h6><p>​    (1) 全能(may系列)</p>
<p>​    (2) 否定疑问(can系列)  </p>
<p>​    (3) 肯定(must) 踢出should<br>解题：<strong>有have非猜则虚；无have非实则猜</strong></p>
</blockquote>
<h1 id="主谓一致"><a href="#主谓一致" class="headerlink" title="主谓一致"></a>主谓一致</h1><p>特点：答案既有动词的单数又有复数<br>解题方法：找动词前面的信号词<br>信号词：</p>
<blockquote>
<h4 id="①-就近原则-后面"><a href="#①-就近原则-后面" class="headerlink" title="① 就近原则 [后面]"></a>① 就近原则 [后面]</h4><p>就近原则是指谓语动词的单、复数形式与<strong>离它最近</strong>的<strong>主语</strong>的单、复数形式保持一致</p>
<ul>
<li><p>&#x3D;&#x3D;由<strong>here、there、where</strong>等引导的倒装句中&#x3D;&#x3D;，(有时主语不止一个时)谓语动词的单、复数形式与靠近它的主语一致<br><u>There</u> <strong>is</strong> &#x3D;&#x3D;<strong>a pen</strong>&#x3D;&#x3D; and several books on the desk.<br><u>Here</u> <strong>is</strong> &#x3D;&#x3D;<strong>Mr. Brown</strong>&#x3D;&#x3D; and his children</p>
</li>
<li><p>&#x3D;&#x3D;由<strong>or、either…or、neither…nor、not only…but also、there be…</strong>&#x3D;&#x3D;等连接的并列成分作主语时【谓语动词的单复数形式应与or<strong>后面的</strong>主语保持一致】<br><u>Either</u> you <u>or</u> &#x3D;&#x3D;she&#x3D;&#x3D; <strong>is</strong> to go.<br><u>Neither</u> the students <u>nor</u> the &#x3D;&#x3D;teacher&#x3D;&#x3D; <strong>knows</strong> anything about it. 学生和老师都不知道这件事</p>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="②-就远原则-前面"><a href="#②-就远原则-前面" class="headerlink" title="② 就远原则 [前面]"></a>② 就远原则 [前面]</h4><ul>
<li><p>当主语后面带有&#x3D;&#x3D;<span style = "color : red"><strong>with、along with、together with</strong>、like(像)、but(除了)、except、besides、<strong>as well as</strong>、no less than、<strong>rather than(而不是)<strong>、</strong>including</strong>、in addition to</span>&#x3D;&#x3D;等连接的短语时，【谓语动词的单、复数形式依然与<strong>前面的</strong>主语(远一点的主语)保持一致】</p>
<p>The teacher <strong><u>together with</u></strong> his students <u><strong>is</strong></u> taking lessons. [is是看together with 前面的主语 而不是 his students]</p>
<p>Nobody <strong>but</strong> two students <strong>is</strong> in the classroom.</p>
<p>Everybody <strong>except</strong> you <strong>is</strong> down on me.</p>
<p>John, <strong>rather than</strong> his roommates, <strong>is</strong> to blame.</p>
<p>Jim, <strong>together with</strong> his classmates, <strong>has</strong>[找Jim] seen the film.</p>
<p>The funds <strong><u>rather than</u></strong> mental support <strong>are</strong> what the organization needs most now.</p>
</li>
</ul>
</blockquote>
<blockquote>
<h3 id="③-其他"><a href="#③-其他" class="headerlink" title="③ 其他"></a>③ 其他</h3><h6 id="more-than-one-名词-单数"><a href="#more-than-one-名词-单数" class="headerlink" title="more than one + 名词(单数)"></a>more than one + 名词(单数)</h6><h6 id="many-a-名词-单数"><a href="#many-a-名词-单数" class="headerlink" title="many a + 名词 (单数)"></a>many a + 名词 (单数)</h6><h6 id="动词不定式，动词-ing形式短语作主语-单数"><a href="#动词不定式，动词-ing形式短语作主语-单数" class="headerlink" title="动词不定式，动词-ing形式短语作主语 (单数)"></a>动词不定式，动词-ing形式短语作主语 (单数)</h6><h6 id="以-ics结尾的学科名词，以-s结尾的名词news-works-plastics-单数"><a href="#以-ics结尾的学科名词，以-s结尾的名词news-works-plastics-单数" class="headerlink" title="以-ics结尾的学科名词，以-s结尾的名词news, works, plastics (单数)"></a>以-ics结尾的学科名词，以-s结尾的名词news, works, plastics (单数)</h6><h6 id="And连接，但为同一物-单数"><a href="#And连接，但为同一物-单数" class="headerlink" title="And连接，但为同一物 (单数)"></a>And连接，但为同一物 (单数)</h6><h6 id="the-following作主语时-表语定"><a href="#the-following作主语时-表语定" class="headerlink" title="the following作主语时 (表语定)"></a>the following作主语时 (表语定)</h6><h6 id="what引导的主语从句-表语定"><a href="#what引导的主语从句-表语定" class="headerlink" title="what引导的主语从句 (表语定)"></a>what引导的主语从句 (表语定)</h6><h6 id="冠词-多个职业名词-冠词个数定-The-math-teacher-and-English-teacher-is…"><a href="#冠词-多个职业名词-冠词个数定-The-math-teacher-and-English-teacher-is…" class="headerlink" title="冠词+多个职业名词 (冠词个数定) The math teacher and English teacher is…"></a>冠词+多个职业名词 (冠词个数定) The math teacher and English teacher is…</h6><h6 id="each-every-no和代词名词-前面定"><a href="#each-every-no和代词名词-前面定" class="headerlink" title="each, every, no和代词名词 (前面定)"></a>each, every, no和代词名词 (前面定)</h6><h6 id="half-of-the-rest-of-most-of-all-of及百分数-或-分数-of-等后接名词-名词定"><a href="#half-of-the-rest-of-most-of-all-of及百分数-或-分数-of-等后接名词-名词定" class="headerlink" title="half of, the rest of, most of, all of及百分数 或 分数+of 等后接名词 (名词定)"></a>half of, the rest of, most of, all of及百分数 或 分数+of 等后接名词 (名词定)</h6><h6 id="The-形容词表示一类人-复数"><a href="#The-形容词表示一类人-复数" class="headerlink" title="The + 形容词表示一类人 (复数)"></a>The + 形容词表示一类人 (复数)</h6><h6 id="and-连接两个形容词去修饰一个名词，指两种不同的事物-复数"><a href="#and-连接两个形容词去修饰一个名词，指两种不同的事物-复数" class="headerlink" title="and 连接两个形容词去修饰一个名词，指两种不同的事物 (复数)"></a>and 连接两个形容词去修饰一个名词，指两种不同的事物 (复数)</h6><h6 id="police-faculty-全体教员-personnel-人员，职员-是集体名词-复数"><a href="#police-faculty-全体教员-personnel-人员，职员-是集体名词-复数" class="headerlink" title="police, faculty (全体教员) personnel (人员，职员) 是集体名词 (复数)"></a>police, faculty (全体教员) personnel (人员，职员) 是集体名词 (复数)</h6><h6 id="One-or-two-more-复数名词-复数"><a href="#One-or-two-more-复数名词-复数" class="headerlink" title="One or two more + 复数名词 (复数)"></a>One or two more + 复数名词 (复数)</h6><h6 id="family-team-committee-party-enemy-audience表集体-单-，集体里的人-复"><a href="#family-team-committee-party-enemy-audience表集体-单-，集体里的人-复" class="headerlink" title="family, team, committee, party, enemy, audience表集体 (单)，集体里的人 (复)"></a>family, team, committee, party, enemy, audience表集体 (单)，集体里的人 (复)</h6><h6 id="All-人复物单"><a href="#All-人复物单" class="headerlink" title="All (人复物单)"></a>All (人复物单)</h6><h6 id="双双对对-复数-加上-“一副”-单数"><a href="#双双对对-复数-加上-“一副”-单数" class="headerlink" title="双双对对 (复数) 加上 “一副” (单数)"></a>双双对对 (复数) 加上 “一副” (单数)</h6><h6 id="one-of-复数名词-定语从句-复数-；the-one-of-复数名词-定语从句-单数"><a href="#one-of-复数名词-定语从句-复数-；the-one-of-复数名词-定语从句-单数" class="headerlink" title="one of + 复数名词 + 定语从句 + (复数)；the one of + 复数名词 + 定语从句 + (单数)"></a>one of + 复数名词 + 定语从句 + (复数)；the one of + 复数名词 + 定语从句 + (单数)</h6><h6 id="“度量衡”-表达整体概念时-单-，数量-复"><a href="#“度量衡”-表达整体概念时-单-，数量-复" class="headerlink" title="“度量衡” 表达整体概念时 (单)，数量 (复)"></a>“度量衡” 表达整体概念时 (单)，数量 (复)</h6></blockquote>
<h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p>特点：</p>
<blockquote>
<p>① 原文和答案中可凑齐一组强调格式 it is&#x2F;was…that&#x2F;who<br>② 谓语动词位置多个do&#x2F;does&#x2F;did</p>
</blockquote>
<p>解题：</p>
<blockquote>
<p>金三角抠洞洞<br>(完整强调：不完整、非强调)<br>It is not until… that…</p>
</blockquote>
<h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p>特点：答案中有明显的倒装答案<br>解题：找倒装句信号词</p>
<blockquote>
<h4 id="①-部分倒装-助动词提前-谓语不动"><a href="#①-部分倒装-助动词提前-谓语不动" class="headerlink" title="① 部分倒装 (助动词提前, 谓语不动)"></a>① 部分倒装 (助动词提前, 谓语不动)</h4><ul>
<li>a&#x2F;n&#x2F;v + <strong>as</strong>&#x2F;though…开头</li>
<li><strong>No sooner</strong> had done… than…<br><strong>Hardly</strong> had done… when…<br><strong>Not until</strong>…did S+V…</li>
<li>否定词或否定短语开头</li>
<li>Only开头，主句倒装</li>
<li>Not only…(倒)…but also…(不倒)…</li>
<li>So&#x2F;Neither&#x2F;Either开头(你好我也好)(我思故我在)</li>
<li>So&#x2F;Such…(倒)…that…</li>
<li>虚拟省略if, Had&#x2F;Were&#x2F;Should 开头的陈述句</li>
</ul>
</blockquote>
<blockquote>
<h4 id="②-全部倒装"><a href="#②-全部倒装" class="headerlink" title="② 全部倒装"></a>② 全部倒装</h4><ul>
<li><p>**here&#x2F;there&#x2F;介词 **+ 地点&#x2F;副词 开头，表语前置</p>
<blockquote>
<p>By his side <strong>stood his son</strong>.</p>
</blockquote>
</li>
<li><p><strong>wish系列</strong><br><strong>as if&#x2F; as though&#x2F; if only</strong></p>
</li>
<li><p>要是没公主系列<br>otherwise, or, but for, without</p>
</li>
<li><p>宁愿做丫鬟系列<br>would rather&#x2F; would sooner&#x2F; would prefer&#x2F; had rather&#x2F; would as soon</p>
</li>
</ul>
</blockquote>
<h1 id="虚拟语气-If-主将从现主句一定要有will、虚拟语气"><a href="#虚拟语气-If-主将从现主句一定要有will、虚拟语气" class="headerlink" title="虚拟语气 (If 主将从现主句一定要有will、虚拟语气)"></a>虚拟语气 (If 主将从现<del>主句一定要有will</del>、虚拟语气)</h1><blockquote>
<p><span style = "color : red"><strong>公主丫鬟系列</strong></span></p>
<p>丫鬟-随从-<strong>从句</strong>-<strong>衣服</strong>-if  (从句)  要穿之前的绿色衣服-&gt;时态往前推一档<br>公主-主子-<strong>主句</strong>–公主服—should&#x2F;w&#x2F;c&#x2F;m (公主服)</p>
<p>&#x3D;&#x3D;<strong>现在</strong>&#x3D;&#x3D; (穿衣服的是丫鬟 丫鬟往前推一档)<br>从句if：do&#x2F;does——&gt;<strong>did</strong>,   is&#x2F;am&#x2F;are——&gt;<strong>were</strong><br>主句：should&#x2F;would&#x2F;could&#x2F;might + <u>do&#x2F;be</u><br>@@ <u>(现在虚拟) 如果我是你，我会接受他的建议</u><br>If I <strong>were</strong> you，I <strong>would accept</strong> his advice.</p>
<p>&#x3D;&#x3D;**过去 **&#x3D;&#x3D;[时态往前推一档] <u>earlier</u><br>从句if：did(将军府红衣服) ——&gt; <strong>had done</strong>(农家绿衣服)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  主句：should&#x2F;would&#x2F;could&#x2F;might  + <u>have done</u><del>丫鬟过去式的原型[先穿公主服+丫鬟过去本体原型]</del><br>@@ <u>(过去虚拟) 如果你以前好好学习，你会通过考试的</u><br>If you <strong>had studied</strong> hard before, you <strong>would have passed</strong> the exam.</p>
<p>&#x3D;&#x3D;<strong>将来</strong>&#x3D;&#x3D;<br>从句if：should do; were to do; did; were [将来-&gt;过去将来]<br>主句：should&#x2F;would&#x2F;could&#x2F;might  + <u>do</u><br>@@ <u>(将来虚拟) 如果明天下雨，我会待在家里</u><br>If it <strong>rained (should rain&#x2F; were to rain)</strong> tomorrow, I would stay at home.</p>
</blockquote>
<ul>
<li>if从句中，<strong>省略if，were，had，should</strong>可以放在句首(用于倒装结构)，<strong>否定词</strong>not不能放在前面</li>
</ul>
<blockquote>
<p>If I were you, I would accept his advice.<br>Were I you,… [最后是句号] [看屁股后面]</p>
<p>@@ <u>Should</u> it rain tomorrow<del>将来</del>, we would have to put off the visit to the YangPu Bridge.<br>看句式 是”Were I you,… [最后是句号]”, 是将来时，<strong>should do &#x2F; were to do</strong> 因为没有to 果断should</p>
</blockquote>
<ul>
<li><h4 id="错综时间虚拟语气-答案有现在、有过去"><a href="#错综时间虚拟语气-答案有现在、有过去" class="headerlink" title="错综时间虚拟语气(答案有现在、有过去)"></a>错综时间虚拟语气(答案有现在、有过去)</h4></li>
</ul>
<blockquote>
<p><u>当从句与主句时间不一致时，动词的形式要根据它所表示的时间作出相应的调整</u><br>If you <u>had followed</u>(follow) my advice<del>(穿衣服的往前推,过去的过去)</del>&#x3D;&#x3D;just now&#x3D;&#x3D;, you <u>would be</u>(be) &#x3D;&#x3D;better now&#x3D;&#x3D;,<br>If you <u>had studied</u>(study) hard &#x3D;&#x3D;<strong>before</strong>&#x3D;&#x3D;, you <u>would be</u> (be) a college student &#x3D;&#x3D;<strong>now</strong>&#x3D;&#x3D;.</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>你认不认识我系列 + 1234词</strong></span></p>
<p>should+do&#x2F;do,  <u>should 可以省略</u><br>① &#x3D;&#x3D;<strong>It’s necessary&#x2F;strange&#x2F;natural&#x2F;important&#x2F;impossible…that 主语 + (should) + 动词原形</strong>&#x3D;&#x3D;<br>It is strange that <u>he <strong>(should) say</strong> so</u>. 他居然会这样说，真是奇怪<br>It is necessary that <u>he <strong>be sent</strong><del>被动</del> to Beijing.</u></p>
<p>② &#x3D;&#x3D;<strong>It is a pity &#x2F;a shame&#x2F; a surprise&#x2F; no wonder that 主句 + (should) + V<del>原形</del></strong>&#x3D;&#x3D;<br>It is a great pity that <u>he (should) think</u> so. 他居然会这样想，真是一件遗憾的事</p>
<p>③ &#x3D;&#x3D;<strong>It is&#x2F; was suggested&#x2F; ordered&#x2F; demanded&#x2F; proposed</strong>&#x2F; (<strong>1234</strong>) + that + 主语 + <strong>(should)+ V<del>原形</del></strong>&#x3D;&#x3D;</p>
<blockquote>
<p>一坚持 二命令 三建议 四要求<br>insited<br>ordered, commanded<br>advised, suggested, proposed<br>demanded, required, requested, desired</p>
</blockquote>
<p>It’s suggested that the plan <strong>should be carried</strong> out.<br>The doctor suggested that he <strong>(should) try</strong> to lose his weight.</p>
<blockquote>
<p>注意：遇到<strong>suggest，insisted</strong></p>
<ul>
<li>suggest：表明，暗示(陈述语句<del>该用啥用啥</del>)；建议(虚拟语气)<br>Her pale face suggested<del>表明</del> that she <strong>was</strong> ill<br>Her friends suggested that she <strong>(should) be sent</strong> to hospitial immediately.</li>
<li>insist：坚持说<del>坚持过去的事</del>(陈述语气)；坚持要求<del>将来还未发生的事</del>(虚拟语气)<br>He insisted that he <strong>didn’t stolen</strong> the money.<br>He insisted that he <strong>(should) be set<del>被放</del></strong> free.</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>以防万一三大词</strong></span><br><strong>for fear that, in case, lest</strong>引导的从句中, 若用虚拟语气时，从句谓语为：(should)+do<br>并且should能省略(for fear that, lest) in case不能省略</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>Wish系列</strong></span>(寻秦记) [项少龙]<br><u>现在</u> 大多数时候穿着丫鬟服<br><u>过去</u> (还未见面)穿<strong>丫鬟装</strong>或<strong>只有裤子<del>could</del>的公主装</strong>did -&gt; have done<br><u>将来</u> 见到项少龙 将来联姻 就要一直穿公主装(一套)了(将来)</p>
<table>
<thead>
<tr>
<th>与现在事实相反</th>
<th>过去时(were)</th>
</tr>
</thead>
<tbody><tr>
<td>与<strong>过去</strong>事实相反</td>
<td><strong>过去完成时</strong>, had+done, <strong>could</strong>, have done</td>
</tr>
<tr>
<td>与<strong>将来</strong>事实相反</td>
<td>Should&#x2F;would&#x2F;could&#x2F;might + 动词原形</td>
</tr>
</tbody></table>
<p>将来要嫁给项少龙 要穿公主装<br>I wish(that) <u>Should&#x2F;would&#x2F;could&#x2F;might + 动词原形</u> he (visit) us tomorrow.<br>现在见到公主穿着丫鬟装<br>I wish(that) he <u><strong>visited</strong></u>(visit) us today.<br>过去穿丫鬟装和只有裤子的公主装<br>I wish he <u>had visited</u>(visit) us yesterday.</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>其他用法</strong></span>(赵倩公主做的一切都是如她所希望的)<br><strong>as if &#x2F; as though(好像)</strong> + 从句 (<u>与<strong>wish</strong>一样</u>)<br>if only(要是…就好了)</p>
<p>@@ If only I <u>were</u>(be) a bird [对现在的虚拟 如果我是一只鸟就好了] 现在是丫鬟装<br>@@ If only you <u>had listened</u>(listen) to our advice! [对过去虚拟，公主装&#x2F;只有裤子的丫鬟装]<br>@@ If only I <u>wcms be</u>(be) a superstar some day.<br>@@ He <strong>looks</strong><del>有s一般现在时</del> as if he <u>were</u> an artist.<br>@@ He <strong>talked</strong><del>过去</del> about the accident as if he <u>had seen</u>.</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>公主宁愿作宫女而没有将来系列</strong></span><br>一眼看不到头没有将来 <strong>将来与现在一样</strong><br><strong>宁愿</strong>{<strong>would rather, would prefer,</strong> would sooner, had rather, would as soon} + 宾语从句中</p>
<p>&#x3D;&#x3D;与<strong>现在</strong>或<strong>将来</strong>事实相反   过去时        动词过去时**&#x2F;were**<br>与<strong>过去</strong>事实相反            过去完成时        <strong>had done</strong>&#x3D;&#x3D;</p>
<p>I would rather you <strong>came</strong>(come) here <u>now</u>.<br>I would rather you <strong>came</strong>(come) here <u>tomorrow</u>.<br>I would rather you <strong>hadn’t told</strong>(not tell)me the truth <u>yesterday</u>.</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>含蓄虚拟语气</strong></span><br>在虚拟语气中，并不总是出现if引导的条件句，而通过其他手段来代替条件句<br>常用的有<strong>otherwise</strong>, <strong>or</strong>, <strong>without</strong>, <strong>but for</strong> (倘没有, 要不是)等 &#x3D;&gt; 给的是&#x3D;&#x3D;<strong>公主系列</strong>&#x3D;&#x3D;</p>
<p>① I <strong>was</strong><del>过去</del> ill that day. <strong>Otherwise</strong>, I <u><strong>would have taken part in</strong></u> the sports meeting.<br>&#x3D;If I <strong>hadn’t been</strong> ill that day, I <u><strong>would have taken</strong></u> part in the sports meeting.<br>② <strong>Without &#x2F; But for</strong> your help, we <strong>couldn’t have finished</strong> the work ahead of time.<br>&#x3D;If it had not been for your help,…</p>
<p>@@ <strong>Without</strong> electricity, human being life <u><strong>would be</strong></u> quite different today<del>现在&#x3D;&gt;公主+be</del><br>@@ <strong>But for</strong> his help, I <u><strong>should</strong> not have succeeded</u><br>@@ He <strong>hesitated</strong> for a moment before kicking the ball, <strong>otherwise</strong> he <u>would have scored</u> a goal.</p>
</blockquote>
<blockquote>
<p><span style = "color : red"><strong>丫鬟该要干某事了系列</strong></span><br>该要干活了后面是丫鬟，丫鬟 <strong>从句</strong>格式 时态往前推一档<br>要干 证明是 将来 丫鬟<br>干某事了 对应的<strong>动作</strong></p>
<ul>
<li>将来 &#x3D;&gt; 从句if：should do; <del>were to do</del>; did; <del>were</del> [将来-&gt;过去将来]<br>should 不能省</li>
<li><strong>It is (high &#x2F; about) time</strong> + (that)从句<br><strong>动词过去式、should(不可省略) + do</strong><br>该是某人做某事的时候了<br>It is high time that <strong>you got</strong> up&#x2F;should get up</li>
</ul>
<p>@@ I’m getting tired；<strong>it’s time</strong> we <strong>went</strong><del>should+do没有should就选went</del> home.<br>@@ You look so tired tonight. It is time you <strong>went to bed</strong></p>
</blockquote>
<p>&#x3D;&#x3D;<strong>but</strong> 后面是真实的句子 该怎样就怎样&#x3D;&#x3D;<br>@@ I would have told<del>过去</del> him the answer had it been possible, but I <strong><u>was</u></strong><del>该用什么用什么</del> so busy then.</p>
<h1 id="反义疑问句"><a href="#反义疑问句" class="headerlink" title="反义疑问句"></a>反义疑问句</h1><p>特点：答案都是反义疑问句<br>解题：<u><strong>前肯后否，前否后肯，你主我主，你助我助</strong></u><br>考点：</p>
<blockquote>
<h6 id="①-否定前缀不算否定句-important-imporsible"><a href="#①-否定前缀不算否定句-important-imporsible" class="headerlink" title="① 否定前缀不算否定句 important imporsible"></a>① 否定前缀不算否定句 important imporsible</h6><h6 id="②-Little-few-seldom-hardly-ralely等否定词算否定句"><a href="#②-Little-few-seldom-hardly-ralely等否定词算否定句" class="headerlink" title="② Little, few, seldom, hardly, ralely等否定词算否定句"></a>② Little, few, seldom, hardly, ralely等否定词算否定句</h6><h6 id="③-Let-us…-祈使句-will-you-Let’s…-祈使句-shall-we"><a href="#③-Let-us…-祈使句-will-you-Let’s…-祈使句-shall-we" class="headerlink" title="③ Let us…,祈使句   will you?   Let’s…,祈使句   shall we?"></a>③ Let us…,<del>祈使句</del>   will you?   Let’s…,<del>祈使句</del>   shall we?</h6><h6 id="④-Do…祈使句-will-you"><a href="#④-Do…祈使句-will-you" class="headerlink" title="④ Do…祈使句, will you?"></a>④ Do…<del>祈使句</del>, will you?</h6><h6 id="⑤-否定前置，以后面内容为准"><a href="#⑤-否定前置，以后面内容为准" class="headerlink" title="⑤ 否定前置，以后面内容为准"></a>⑤ 否定前置，以后面内容为准</h6><h6 id="⑥-名词性从句，动词不定式，动名词做主语，主语代词为it"><a href="#⑥-名词性从句，动词不定式，动名词做主语，主语代词为it" class="headerlink" title="⑥ 名词性从句，动词不定式，动名词做主语，主语代词为it"></a>⑥ 名词性从句，动词不定式，动名词做主语，主语代词为it</h6><h6 id="⑦-对话回答，保持一致。以后为准，变yes，no"><a href="#⑦-对话回答，保持一致。以后为准，变yes，no" class="headerlink" title="⑦ 对话回答，保持一致。以后为准，变yes，no"></a>⑦ 对话回答，保持一致。以后为准，变yes，no</h6></blockquote>
<h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><p><img src="https://raw.githubusercontent.com/P-luminary/images/f2b745460655a7dfd03a0639dfba12ef8439d6ba/data/%E4%B8%80%E5%BC%BA%E4%BA%8C%E5%AE%9A%E4%B8%89%E5%90%8D%E8%AF%8D11.jpg"></p>
<p>特点：答案均为帽帽<br>解题：</p>
<blockquote>
<h6 id="①-一强二定三名词-其前位名词或句子逗号"><a href="#①-一强二定三名词-其前位名词或句子逗号" class="headerlink" title="① **一强二定三名词 **(其前位名词或句子逗号)"></a>① **一强二定三名词 **(其前位名词或句子逗号)</h6><h6 id="②-”连”-字绝"><a href="#②-”连”-字绝" class="headerlink" title="② **”连”**字绝"></a>② **”连”**字绝</h6></blockquote>
<p>考点：</p>
<blockquote>
<h6 id="①-直接可连上：who-whom-which-that"><a href="#①-直接可连上：who-whom-which-that" class="headerlink" title="① 直接可连上：who, whom, which, that"></a>① 直接可连上：who, whom, which, that</h6><h6 id="②-加介词能连上"><a href="#②-加介词能连上" class="headerlink" title="② 加介词能连上"></a>② 加介词能连上</h6><blockquote>
<p>介词 which；介词 whom<br>地点 + 介词 + which 可用 where<br>时间 + 介词 + which 可用 when<br>reason for which 可用 why<br>方法 + 介词 + which 可用 that</p>
</blockquote>
<h6 id="③-前名词后名词，中间变”的”可连-x3D-gt-whose"><a href="#③-前名词后名词，中间变”的”可连-x3D-gt-whose" class="headerlink" title="③ 前名词后名词，中间变”的”可连 &#x3D;&gt; whose"></a>③ 前名词后名词，中间变”的”可连 &#x3D;&gt; whose</h6><blockquote>
<p><strong>用于 “…的” 作定语从句的定语</strong><br><strong><u>前名<del>词</del> 后名<del>词</del> 中变的</u></strong> 能够连上为whose<br>I know the <u>girl</u> <strong>whose</strong> <u>mother</u> is a teacher</p>
</blockquote>
<h6 id="④-有逗号没连词必带帽，该咋戴帽咋戴帽"><a href="#④-有逗号没连词必带帽，该咋戴帽咋戴帽" class="headerlink" title="④ 有逗号没连词必带帽，该咋戴帽咋戴帽"></a>④ 有逗号没连词必带帽，该咋戴帽咋戴帽</h6><h5 id="⑤-帽前介词连前后，只有连上才对头"><a href="#⑤-帽前介词连前后，只有连上才对头" class="headerlink" title="⑤ 帽前介词连前后，只有连上才对头"></a>⑤ 帽前<u>介词</u>连前后，只有连上才对头</h5><h5 id="⑥-只用that，不用which"><a href="#⑥-只用that，不用which" class="headerlink" title="⑥ 只用that，不用which"></a>⑥ 只用that，不用which</h5><p> &lt;1 当先行词是<strong>all, any, few, little, none, anything, everything, nothing, everybody, nobody, everyone, no one</strong> 或被它们修饰时<br> &lt;2  当先行词被<strong>形容词最高级</strong>或<strong>序数词</strong>修饰时<br> &lt;3  当先行词有the very, the only, the same等修饰时<br> &lt;4  当主句以who或which开头时，定语从句的先行词用that<br> &lt;5  当先行词同时包括人和物时，关系词用that<br> &lt;6  当主句是There be 句型时</p>
<h5 id="⑦-只用which，不用that"><a href="#⑦-只用which，不用that" class="headerlink" title="⑦ 只用which，不用that"></a>⑦ 只用which，不用that</h5><p> &lt;1 关系代词前有<strong>介词</strong><br> &lt;2 <strong>非限制性定语从句</strong><br> &lt;3 先行词本身是<strong>that</strong></p>
</blockquote>
<h1 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h1><p><img src="https://raw.githubusercontent.com/P-luminary/images/f2b745460655a7dfd03a0639dfba12ef8439d6ba/data/%E4%B8%80%E5%BC%BA%E4%BA%8C%E5%AE%9A%E4%B8%89%E5%90%8D%E8%AF%8D11.jpg"></p>
<p>特点：答案均为帽帽<br>解题：1.一强二定三名词；2.缺不缺，疑不疑(主谓宾缺不缺) (<strong>主句</strong>有没有疑惑不确定)<br>考点： </p>
<blockquote>
<h5 id="①-不缺不疑用that"><a href="#①-不缺不疑用that" class="headerlink" title="① 不缺不疑用that"></a>① 不缺不疑用that</h5><h5 id="②-缺选what-who-x2F-whom-which-需选项"><a href="#②-缺选what-who-x2F-whom-which-需选项" class="headerlink" title="② 缺选what, who&#x2F;whom, which(需选项)"></a>② 缺选what, who&#x2F;whom, which(需选项)</h5><h5 id="③-不缺有疑，缺啥給啥"><a href="#③-不缺有疑，缺啥給啥" class="headerlink" title="③ 不缺有疑，缺啥給啥"></a>③ 不缺有疑，缺啥給啥</h5><h5 id="④-x3D-x3D-whether-x3D-x3D-与-if-均为-“是否”-的意思。除了直接跟在动词后引导宾语从句可以用if，其余一律用whether"><a href="#④-x3D-x3D-whether-x3D-x3D-与-if-均为-“是否”-的意思。除了直接跟在动词后引导宾语从句可以用if，其余一律用whether" class="headerlink" title="④ &#x3D;&#x3D;whether&#x3D;&#x3D; 与 if 均为 “是否” 的意思。除了直接跟在动词后引导宾语从句可以用if，其余一律用whether"></a>④ &#x3D;&#x3D;whether&#x3D;&#x3D; 与 if 均为 “是否” 的意思。除了直接跟在动词后引导宾语从句可以用if，其余一律用whether</h5><h5 id="⑤-doubt用与肯定句表疑惑；用于否定句，疑问句，表不疑"><a href="#⑤-doubt用与肯定句表疑惑；用于否定句，疑问句，表不疑" class="headerlink" title="⑤ doubt用与肯定句表疑惑；用于否定句，疑问句，表不疑"></a>⑤ doubt用与<u>肯定句</u>表疑惑；用于<u>否定句</u>，疑问句，表不疑</h5><h5 id="⑥-The-reason-why-句子-is-that…；The-reason-for-名词-is-that…-注意有坑"><a href="#⑥-The-reason-why-句子-is-that…；The-reason-for-名词-is-that…-注意有坑" class="headerlink" title="⑥ The reason why + 句子 + is that…；The reason for + 名词 + is that… [注意有坑]"></a>⑥ The reason <u>why + 句子</u> + is that…；The reason <u>for + 名词</u> + is that… [注意有坑]</h5></blockquote>
<hr>
<hr>
<h1 id="阅读理解"><a href="#阅读理解" class="headerlink" title="阅读理解"></a>阅读理解</h1><h4 id="检索类题目-送分题"><a href="#检索类题目-送分题" class="headerlink" title="检索类题目(送分题)"></a>检索类题目(送分题)</h4><p>特点：有黑体标题，有表格，有列表<br>解题：<br>1.阅读第一段、大标题、黑体标题、确定主题<br>2.直接看问题，找到定位词，看一个找一个答案<br>3.要求速度和正确率</p>
<h4 id="记叙文-读全文，需理解"><a href="#记叙文-读全文，需理解" class="headerlink" title="记叙文(读全文，需理解)"></a>记叙文(读全文，需理解)</h4><p>特点：文章中有明显的时间、地点、人物、对话、故事情节等<br>解题：<br>1.一次性读完后面的题目，并画出相应关键词<br>2.从头到尾读全文，遇到题目关键词或相关内容时，仔细选择答案。(会出现乱序题目)<br>3.仔细理解内容后作答，小心深层含义的主题</p>
<p>细节题不要过度解读, 东拉西扯，原文的答案就是答案！！</p>
<h4 id="说明议论类-定位及答案-一一对应"><a href="#说明议论类-定位及答案-一一对应" class="headerlink" title="说明议论类(定位及答案)一一对应"></a>说明议论类(定位及答案)<del>一一对应</del></h4><p>特点：文章是大段大段的说明议论内容<br>解题：<br>1.段落比较大时，先读各段首句。段落比较小时，先读第一段的第一句，并浏览第一段是否有转折词，若有，则其后为重点内容，若无，则，第一句多为主题<br>2.浏览每小题找到定位词。这回原文顺序找该定位词，找到即可定位答案。一 一对应选择答案<br>3.题目多为顺序出题。遇到全文综合考察，放最后一题再做。</p>
<h4 id="题型答案位置"><a href="#题型答案位置" class="headerlink" title="题型答案位置"></a>题型答案位置</h4><h6 id="1-细节题-60-答案在原文-【边上写个-细！！】"><a href="#1-细节题-60-答案在原文-【边上写个-细！！】" class="headerlink" title="1.细节题(60%)(答案在原文) 【边上写个 细！！】"></a>1.细节题(60%)(答案在原文) 【边上写个 细！！】</h6><p>定位词定位答案 → 和原文 一 一 对应(同义转换)</p>
<h6 id="2-词汇题-有序号"><a href="#2-词汇题-有序号" class="headerlink" title="2.词汇题(有序号)"></a>2.词汇题(有序号)</h6><p>答案不可自己猜，原文答案已告知。本句，上句，再下句</p>
<h6 id="3-主旨题"><a href="#3-主旨题" class="headerlink" title="3.主旨题"></a>3.主旨题</h6><p>文章的第一句，或第一段里的转折部分</p>
<h6 id="4-作者观点态度题"><a href="#4-作者观点态度题" class="headerlink" title="4.作者观点态度题"></a>4.作者观点态度题</h6><p>文章的第一句，或第一段里转折部分；文章末尾总结句；建议或观点句子</p>
<h6 id="5-推理题"><a href="#5-推理题" class="headerlink" title="5.推理题"></a>5.推理题</h6><p>答案一般为同义句转换。推的越远越错，附加条件越多越多 [可先跳过此题]</p>
<h6 id="6-判断题"><a href="#6-判断题" class="headerlink" title="6.判断题"></a>6.判断题</h6><p>四个答案分别定为原文，和原文句子进行一一比对即可。耗时，不难</p>
<h6 id="7-实验，数据，故事类"><a href="#7-实验，数据，故事类" class="headerlink" title="7.实验，数据，故事类"></a>7.实验，数据，故事类</h6><p>答案一般为道理。答案在该内容前后的总结句或段落总结句中里</p>
<h4 id="阅读错误总结"><a href="#阅读错误总结" class="headerlink" title="阅读错误总结"></a>阅读错误总结</h4><p>&#x3D;&#x3D;1.题目想当然，看错题目，题目必须仔细看<br>2.一一对应错误，看到个别单词就当做答案，务必读全文，做到答案信息均有出处<br>3.忽略绝对肯定或绝对否定句<br>看到比较绝对的肯定词或否定词，务必原文当中找到出处。否则一般不选<br>4.根据…的观点，想当然认为是坐着或某人的这类题目，一旦出现”根据”字样，务必确认对应答案<br>5.想象力丰富，脑部很多内容，按照脑补选答案。忠于原文，不要把你当成作者，你只是读者&#x3D;&#x3D;</p>
<h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><h6 id="1-中翻英-拆句子-x3D-x3D-翻译主谓宾-定语-一个词前-两个词放后面；-状语-全放后面-x3D-x3D"><a href="#1-中翻英-拆句子-x3D-x3D-翻译主谓宾-定语-一个词前-两个词放后面；-状语-全放后面-x3D-x3D" class="headerlink" title="1.中翻英 [拆句子 &#x3D;&#x3D;翻译主谓宾 (定语)一个词前, 两个词放后面；(状语)全放后面&#x3D;&#x3D;]"></a>1.中翻英 [拆句子 &#x3D;&#x3D;翻译主谓宾 (定语)一个词前, 两个词放后面；(状语)全放后面&#x3D;&#x3D;]</h6><p>①确定所给词的用法&#x2F;拆句子<br>②找句子主干，并翻译<br>③定语状语等，按照规则放好<br>④微调单复数，冠词，时态语态，顺序</p>
<h2 id="感谢信—申请信—邀请信【热点考点】-建议—投诉—道歉信【概率小】"><a href="#感谢信—申请信—邀请信【热点考点】-建议—投诉—道歉信【概率小】" class="headerlink" title="感谢信—申请信—邀请信【热点考点】    建议—投诉—道歉信【概率小】"></a>感谢信—申请信—邀请信【热点考点】    建议—投诉—道歉信【概率小】</h2><p>&#x3D;&#x3D;准备<strong>景点介绍材料</strong>&#x3D;&#x3D; 这两周热点是旅游 介绍南昌旅游景点邀请他来<br>南昌位于… 南昌历史 八一广场 滕王阁 秋水广场</p>
<h4 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h4><p>1.申请、推荐、祝贺信<br>字不够，优点凑<br>2.邀请信<br>字不够，活动内容、细节凑<br>3.感谢信<br>字不够，虚拟假设凑<br>4.建议信<br>先抑后扬，虚拟用法<br>5.投诉信<br>字不够，危害凑<br>6.通知海报<br>字不够，活动内容、细节凑<br>7.发言稿<br>寒暄介绍少不了</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#1bccbc>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2023/03/08/英语/(铭升)菲儿精华/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/02/25/英语/语法单选模块/">
        <h2>
            语法单选模块
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/2/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><strong><span style = "color : red">2023.2.25</span></strong></p>
<h4 id="语法类板块-虚拟-x2F-主将从现-x2F-翻译"><a href="#语法类板块-虚拟-x2F-主将从现-x2F-翻译" class="headerlink" title="语法类板块[虚拟&#x2F;主将从现&#x2F;翻译]"></a><span style = "color : blue">语法类板块</span>[虚拟&#x2F;主将从现&#x2F;翻译]</h4><p>祈使句表将来<br><u>时间、条件、让步状语 &#x3D;&gt; <strong>主将从现</strong></u><br>Ask her to come and see me when she <u>finishes</u> her work.<br>考时态语态时候看有没有 虚拟 或 <strong>By</strong>[没有的话看句子]<del>后面如果是过去时间或过去，句子主句过去完成时。后面是将来完成时，将来或一般现在时</del> the time we got home, I <u>had forgotten</u> all …<br>The teacher demanded that her students <u>be</u> on time for every class. [were&#x2F;be&#x2F;to be&#x2F;must be<del>80%考虚拟：(should)+do</del>]<br><u>Since<del>既然</del></u> you are free tonight, why not drop in and play chess with me? [for&#x2F;unless&#x2F;since&#x2F;though]<del>全是连词的,两句一连,带着连词的那句话就是状语从句</del></p>
<pre><code class="java">连词一般会考句意
连词是While(80%) [对比关系=&gt;用while] [尽管-&gt;引导让步状语从句]
连词是Unless 除非...才能
连词是until 主句中出现not 大概率出现until =&gt; not...until
连词是Since语气比as强 意为:&#39;既然&#39;
unless until若同时出现在答案中;
unless(除非...才)[强调&quot;条件&quot;][前面一般是情态动词]
didn&#39;t until(直到...才)[强调&quot;时间/状态&quot;][前面一般是时态]
as[90%答案]倒装/正如.../固定搭配
I am afraid 标志着转折含义
</code></pre>
<p>所有考介词的点 80%以上都是固定搭配<br>One of the techniques in reading a passage is to read it <u>as</u> a whole.[as&#x2F;for&#x2F;to&#x2F;in] (as a whole作为整体  in a whole总的来说)<br>The company would need another ten thousand dollars <u>1</u> they could buy some new equipment.[(in&#x2F;at&#x2F;by&#x2F;with)which]</p>
<pre><code class="java">in 用语言、原材料[link]
by 抽象概念的方法[交通工具/手]
with[80%]具体的有东西、有实物
</code></pre>
<p><u><strong>It’s important</strong></u> that he <u>(should)+pass</u> the final examination next week.<br><strong>any</strong><del>[包含关系&#x3D;&gt;选不包含关系]</del> 后面有单数&#x2F;复数&#x2F;other<br>时态语态&#x3D;&gt;找by<del>过去-&gt;过去完成时,将来-&gt;将来完成时</del>、<strong>if[作主语,时态往前推一档次]</strong> &#x3D;&gt;虚拟<br>if后有没有时间[找两种时态、but]<strong>错综复杂时态</strong><br>who引导的定语从句在从句里面做主语时候，此时中间一般不能用逗号隔开[只有ing和ed才用逗号隔开<del>脱帽变太监</del>]<br>I went to the tailor’s to <u>have a suit made</u> the other day.[make a suit&#x2F;have a suit be made&#x2F;have made a suit&#x2F;have a suit made<del>两个动词一定有一个非谓语</del>]<strong>have sth done</strong><br><u>It is a long time since</u>         <u>It has been along time before</u></p>
<hr>
<p>介词：形容词&#x2F;特定&#x2F;范围 用on[节日<del>带</del>day]  at[节日<del>不带day</del>]  <u>On</u> a clod afternoon in December<br>by+年月日星期几点几分 [最后期限]  by+小数分数数字 增加多少减少多少上升多少<br>as[80%的正确选项]…as<br>can对应的是能力 不是 能够<br>doing done[同时进行]<br>The reason why is <strong>that</strong>…<br>only to do<br>前肯后否，前否后肯，你主我主，你助我助 [<strong>have to&#x2F;had to 疑问部分常用don’t&#x2F;didn’t</strong>]<br>many of them</p>
<hr>
<p>It is high time (that) should do&#x2F;did<br>倍数+比较级的顺序关系  倍数和数字+完整的比较级关系 <strong>倍数+as…as</strong><br>比较级考点：<u>同级比较、倍数与比较级</u>；同类不同一个时 用that[much higher than <u>that of a professor</u> ]<br>被动变主动 疑问变祈使<br>感官类动词后面是sth 直接接ed<br>should do 不是真实的就是推测的<br>have done 不是真实的就是虚拟的<br>be likely to do 可能做…<br>The reason for…<br>even if 尽管<br>as if 好像<br>since 自从,既然,因为<br>非谓语动词做状语时，直接选ed<br>can’t help doing 禁不住做…</p>
<hr>
<p>so 与 such 顺序 直接跟在so后面的是形容词 <strong>so形容词冠词名词；such冠词形容词名词</strong><br>more and more;  the more, the more<br>it is time that should todo<br>by the time + 一般现在时      主语+will have done<br>could you do some +n for me? 你可以帮我做点…么<br>It might be days before 离…可能还有一段日子<br>All those 后面可以省略that<br>but 后面加动词 but to do[正常情况下] 若but前面出现do时，省略to变do<br>&#x3D;&gt; have nothing to do but do 除了…别无其他事可做；前do后没to<br>such&#x2F;same&#x2F;so&#x2F;as + as…</p>
<blockquote>
<p>while……主句pia   while后面进行 主句结束pia&#x2F;一般动作<br>when….结束pia   主句延续性….balabalabal<br>as….balabala   as…balabalabla</p>
</blockquote>
<p>情态动词表猜测，对于过去的事情的猜测<br>none of 三个或以上，都不</p>
<hr>
<p>宾语从句的主句是过去的 从句所有的时态要往直前推一档[53]<br>he <strong>told</strong> me<br>I am <u>preparing for</u> the exam.<br>&#x3D;&gt; he told me <strong>he was</strong> preparing for the exam.<br>be disappointed at sth 对…很失望<br>there be 结构的非限定形式 there being<br>有2有3看肯定 看否定；both 复数  any 肯定句 neither 和 every用于单数[看似表达每个，其实指整体]<br>sb is said…to do   据说某人…<br>it no use&#x2F;good&#x2F;waste of doing sth…<br>will do &#x2F;shall do &#x2F;be about to do表将来<br>very&#x2F;副词&#x2F;副词排序 频率类副词排序 要跟在所有助动词或实义动词之前 如果各种格式都有要放在第一个助动词之后</p>
<blockquote>
<p>The professor was so popular that he <u>was alsways listened to</u> with enthusiasm.</p>
</blockquote>
<p>suggested 是表明还是建议<del>[虚拟 1234+should do]<br>it is said&#x2F;reported to do<br>miss 人失踪是主动[be doing]     东西丢失是被动 &#x3D;&gt; 被动行为[be done]<br>regret 遗憾todo 后悔doing<br>情态动词后是原形 不是真实的就是推测的</del>must100% should75% maymight30%~<br>考代词 others、the others后面不加名词；another<del>前单后单,前复后复</del> other<del>复数</del>后面加名词；</p>
<hr>
<h2 id="2023-3-4-班级英语模拟考"><a href="#2023-3-4-班级英语模拟考" class="headerlink" title="2023.3.4 班级英语模拟考"></a><strong><span style = "color : red">2023.3.4 班级英语模拟考</span></strong></h2><p>1.有’s的有生命的人或动物<br>Jim was late for two classes this morning. He said that he forgot both of the <strong>room numbers</strong></p>
<p>2.冠词<strong>特指</strong>&amp;&amp;<strong>泛指</strong> satisfaction 抽象概念 不可数<br>Sarah looked at <strong>the</strong> finished painting with <strong>不填</strong> satisfaction.</p>
<p>3.讲英语这件事 不可数 &#x3D;&gt; 不可数 as much as<br>We should speak English as <strong>much</strong> as possible</p>
<p>5.时态是现在，先哭；因为丢了玩具<br>The little girl <strong>cried</strong> her heart out because she <strong>had lost</strong> her toy bear and believed she wasn’t ever going to find it.</p>
<p>6.否定放在非谓语最前面<br>Please tell him <strong>not to draw</strong> on the wall</p>
<p>7.考非谓语格式 两个主动一个被动(跟了by)<br>No one can aovid <strong>being influenced</strong> by advertisements</p>
<p>8.考非谓语动词，逻辑主语是he 被动表主动<br><strong>Dressed</strong> in a white uniform, he looks more like a cook than a doctor.</p>
<blockquote>
<p>be to blame意为”应负责任，应受责备”<del>中文意义是被动</del> ，不可用<del>[to be blamed]</del><br>连系动词：smell &#x2F; taste &#x2F; sound &#x2F; prove<br>一些英文中是被动，但中文中是主动意义的动词&#x3D;&#x3D;<strong><u>be related to &#x2F; be absorbed in &#x2F; be dressed in</u></strong>&#x3D;&#x3D;</p>
</blockquote>
<p>9.前后给了修饰限定的词表特指，介词用On<br>He decided to visit the family <strong>on</strong> Friday night.</p>
<p>10.形容词倍数关系 倍数+完整的比较级<br>Peter’s jacket looked just the same as Jack’s, but it cost <strong>twice as much as</strong> his.</p>
<p>11.主谓一致 <u>一被二单三时态</u> 图书馆被給了… 被动 be done[A C]  主谓一致 主语找信号词<strong>with、like、except、but</strong>，就远原则 library<br>A library with five thousand books <strong>is offered</strong> to the nation as a gift.</p>
<blockquote>
<p><strong>就远一致</strong> 当主语后面带有&#x3D;&#x3D;<span style = "color : red"><strong>with、along with、together with</strong>、<strong>like(像)<strong>、</strong>but(除了)<strong>、</strong>except</strong>、besides、<strong>as well as</strong>、no less than、<strong>rather than(而不是)<strong>、</strong>including</strong>、in addition to</span>&#x3D;&#x3D;等连接的短语时，【谓语动词的单、复数形式依然与<strong>前面的</strong>主语(远一点的主语)保持一致】</p>
<p><strong>就近一致</strong> &#x3D;&#x3D;由<span style = "color : red"><strong>here、there、where</strong></span>等引导的倒装句中；由<span style = "color : red"><strong>or、either…or、neither…nor、not only…but also</strong></span>&#x3D;&#x3D;</p>
</blockquote>
<p>12.倒装Not until 后面 did sb do<br>Not until the early years of the 19th century <strong>did man know</strong> what heat is.</p>
<blockquote>
<p><strong>完全倒装</strong>[ <u>There be</u> + <u>时间、地点、方位副词</u> ]&#x3D;&#x3D;当<span style = "color : red"><u>here、there、out、in、up、then、away、back</u></span>&#x3D;&#x3D;等副词置于句首，谓语动词为be、come、go、lie、run等表示动作的动词时，需完全倒装。</p>
<p><strong>部分倒装</strong> &#x3D;&#x3D;<span style = "color : red">助动词或情态动词 + 主语 + 实义动词、hardly、seldom、neither、nor、little、no sooner</span>置于句首&#x3D;&#x3D;；&#x3D;&#x3D;<span style = "color : red"><strong>so、neither、nor</strong></span> + 助动词或情态动词 +主语&#x3D;&#x3D;；&#x3D;&#x3D;”only + 副词&#x2F;介词短语&#x2F;状语从句” 位于句首时的倒装&#x3D;&#x3D;；&#x3D;&#x3D;<strong>so + 助动词 + 主语表示前面提出的情况也适用于后者</strong>&#x3D;&#x3D; ；&#x3D;&#x3D;as引导的<u>让步状语从句</u>的倒装&#x3D;&#x3D;</p>
<p><strong>反意疑问句</strong>：&#x3D;&#x3D;[<strong><u>前肯后否，前否后肯</u></strong>]&#x3D;&#x3D;</p>
</blockquote>
<p>13.一强二定三名词 时间前是介词肯定连得上 就是强调句<br>It was <strong>on</strong> the National Day <strong>that</strong> she met with her separated sister.</p>
<p>14.时态语态的边 看有没有by[<strong>By后面的句子完整，考主句 by后为一般现在时 主句+将来完成时 ；过去的话 主句是过去完成时</strong>] 特殊的虚拟  &#x3D;&gt; &#x3D;&#x3D;It is important that + (should) do&#x3D;&#x3D;<br>It is important that I <strong>speak</strong> with Mr.Williams immediately.</p>
<blockquote>
<p><strong>It’s time句型（当It’s time后用that从句时应该为“主语＋ should ＋动词原形” 或 “主语＋过去时”）</strong><br>&#x3D;&#x3D;<strong>It is important that + (should) do</strong>&#x3D;&#x3D;<br>It’s required that all sales reports <strong>be finished</strong> no later than Jane 10</p>
<p><strong>would rather, as if（though）引导的句子也需使用虚拟，表示过去的情况用过去完成时，表示现在与将来的情况用过去时</strong></p>
</blockquote>
<p>15.come into effect 生效<br>The new law will come into <strong>effect</strong> on the day it is passed.</p>
<p>16.时态语态 would 小心虚拟语气 &#x3D;&gt; 有If &#x3D;&gt; 看时间 前句last…<br>答案(<u>had been; would have prevented</u> 或 <u>had been, would prevent</u>) <strong>错综虚拟语气</strong><br>If my lawyer <strong>had been</strong> here last Saturday, he <strong>would have prevented</strong> me from going.</p>
<blockquote>
<table>
<thead>
<tr>
<th></th>
<th>if从句</th>
<th>主句</th>
</tr>
</thead>
<tbody><tr>
<td>与<strong>现在</strong>事实相反</td>
<td><strong>did&#x2F;were</strong></td>
<td>[wcms 厕所没水]<br /><strong>would&#x2F;should&#x2F;could&#x2F;might + do(动词原形)</strong></td>
</tr>
<tr>
<td>与<strong>过去</strong>事实相反</td>
<td><strong>had done</strong></td>
<td><strong>would&#x2F;should&#x2F;could&#x2F;might + have done</strong></td>
</tr>
<tr>
<td>与<strong>将来</strong>事实相反</td>
<td><strong>did&#x2F;were <br />to do<br />should do</strong></td>
<td><strong>would&#x2F;should&#x2F;could&#x2F;might + do(动词原形)</strong></td>
</tr>
</tbody></table>
</blockquote>
<p>18.rewarded 回报的钱或物质 awarded 奖赏的是某种荣誉<br>Such noble deeds of the doctors and nurses can’t be only <strong>rewarded</strong> (rewarded&#x2F;awarded) with money. </p>
<p>19.take make get have 固定搭配 appointment任命<br>His new appointment takes <strong>effect</strong> from the beginning of next month.</p>
<hr>
<p>时态 若是事实 则一般现在时<br>John frequently attempts to escape being fined whenever he <strong>breaks</strong> traffic regulations.<br>考非谓语动词 没逗号，就先找动词。&#x3D;&#x3D;<strong>keep get leave ??</strong> 宾语补足语&#x3D;&#x3D; 和宾语发生关系<br>考倒装 倒装助动词 <strong>can there be</strong><br>考帽帽 一强二定三名词  前面to考虑一下定语从句 give sth to sb 如果句子里有 <u>你觉得，我们觉得</u>删掉[<del>you think</del>] please give your vote to <u>whoever</u> you think you can trust[缺宾语].[特指那个人]<br>The task was tough, but <u>1</u> we managed to fulfill it satisfactorily.</p>
<blockquote>
<p>anyhow<del>不管用什么样的方法,强调方法</del> 无论如何 不管怎样<br>anyway<del>即便如此,强调已有条件</del> 无论如何 不管怎样<br>somehow 以某种方式  somewhat 有点，稍微</p>
</blockquote>
<p>注意：&#x3D;&#x3D;<strong>suggest</strong>&#x3D;&#x3D; 表明<del>该咋用咋用</del> &#x2F; 建议<del>虚拟语气</del>； &#x3D;&#x3D;<strong>insisted</strong> 已经发生过的用真实 没发生的用虚拟<del>(should)+do</del>&#x3D;&#x3D;；&#x3D;&#x3D;<strong>regret</strong> 遗憾to do 后悔doing [regret to do&#x2F;doing     遗憾没做todo 后悔做了doing]&#x3D;&#x3D;<br>&#x3D;&#x3D;情态动词&#x3D;&#x3D;：看事情有没有过去  事情过去了 不是b就 是d，情态动词＋had done 不是虚拟就是推测<br>The hot weather  the milk, because it has an unpleasant taste and smell. <strong>D</strong><br>A. must spoil  B. must have spoiled  C.can spoiled   D. should have spoiled</p>
<p>&#x3D;&#x3D;enjoyed&#x3D;&#x3D; 后面 作宾语 123456789 + ing 剩下的to do</p>
<blockquote>
<p>enjoy doing sth.喜欢做某事                    miss doing sth.错过做某事<br>人+spend…doing sth.花费…做某事        <strong>suggest doing sth.建议做某事</strong><br>be busy doing sth.忙于做某事                mind doing sth.介意做某事<br>imagine sb. doing sth.想象…做某事      be worth doing sth值得做某事<br>can’t help doing sth.忍不住做某            consider doing sth.考虑做某事<br>feel like doing sth.想要做某事                **practice doing sth.**练习做某事<br>finish doing sth.完成做某事                    keep (on) doing sth.继续做某事</p>
</blockquote>
<p>有逗号 有连词 就看句意 It may snow, but <u>anyhow</u> I have decided to go out. <u>instead &#x3D; but</u><br>动名词复合结构 I really very much appreciate<del>doing</del> <u>D</u> me that great favour yeasterday.<br>B. you doing D. your doing<br>时态语态 &#x3D;&#x3D;<strong>insisted</strong> 已经发生过的用真实 没发生的用虚拟<del>(should)+do</del>&#x3D;&#x3D;<br>考非谓语 先找到自己的句子中有没有谓语 有谓语的 后面只能用非谓语 feel like doing sth… be busy doing sth<br>考介词80%考固定搭配 be responsible for 对…负责<br>考连词[没有特殊的1234]<br>考帽帽 一强二定三名词 <u><strong>so…that</strong>、such…that、so…as</u><br>考连词 出as 首先考虑  since 有自从的意思<br>get accustomed to 习惯于  to 是介词，如果原句里面to就给了 那么to一般就是介词<br>I find it rather difficult to get accustomed to <u>speaking</u> before such a large audience.<br>It is essential that (should) + do<br>在主谓宾补结构中，宾语过长，要用it作形式宾语，真正的宾语放在后面<br>&#x3D;&#x3D;<strong>regret</strong> 遗憾to do 后悔doing&#x3D;&#x3D;</p>
<hr>
<p><strong>whose</strong> 后面没有the的 用whose</p>
<blockquote>
<p><strong>whose</strong>用于 “…的” 作定语从句的定语<br><u><strong>前名<del>词</del> 后名<del>词</del> 中变的</strong> 能够连上为whose</u><br>I know the <u>girl</u><del>名词</del> <strong>whose</strong> <u>mother</u><del>名词</del> is a teacher</p>
</blockquote>
<p>前面有if不考虑to do   If <u>kept</u> in the refrigerator, …  不是人 就被动<br>考时态语态 找by或虚拟 没有的要看句意 主动&#x2F;被动<br>&#x3D;&#x3D;No sooner…<strong>than</strong><br>Hardly…<strong>when</strong><br><strong>It is time</strong> (should) do&#x3D;&#x3D;</p>
<p>can not help doing sth     fell like doing sth     be worth doing sth</p>
<h4 id="有逗号-有连词，doing-done"><a href="#有逗号-有连词，doing-done" class="headerlink" title="有逗号 有连词，doing done"></a>有逗号 有连词，doing done</h4><p>have 表示有事要做… 主动表被动have sth to do；表示让&#x2F;使 have sth done…<br>Susan, I’d like to have these materials <strong>printed</strong> by ten o’clock<br>regret to do&#x2F;doing     遗憾没做todo 后悔做了doing<br>光秃秃放在前面 首先考虑todo     <u>To became</u> a club member</p>
<p>感官类+实义类 4个词 todo<del>剩下</del> doing<del>正在进行</del> ed<del>被动</del> 都可</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>感官类&#x2F;使役类动词 后面是sth 直接接done</strong>&#x3D;&#x3D;<br>感官&#x2F;使役类动词 可以省略to<br>目的状语放在后面的时候 中间不能有<strong>逗号</strong><br>作宾语补足语  &#x3D;&#x3D;<strong><u>find leave get keep</u></strong> 三个都可以跟，但跟to do后面的to不能省略&#x3D;&#x3D;<br><u>see&#x2F;watch&#x2F;notice&#x2F;observe&#x2F;look at&#x2F;listen to&#x2F;feel&#x2F;<strong>&#x3D;&#x3D;make&#x2F;let&#x2F;have&#x3D;&#x3D;</strong><del>使役类</del></u> 后面<strong>均可</strong>，<u><strong>其余的</strong>都是 to do</u> ；</p>
</blockquote>
<p>The president promised to keep all the board members <strong>informed</strong> of how the negotiations were going on.</p>
<p>While尽管 &#x3D;&gt; 1.对比两者之间while  2.让步状语从句 尽管既然while 3.跟when和as区别   表转折<br>though 表转折 虽然，尽管<br>Now that 既然，由于</p>
<p>有逗号 无连词 有主语 用非谓语<br>遗憾通知你(to do) regret to do 没做、regret doing 做过   inform sb of sth 其余全是通知的意思<br>形式宾语 Our online service<del>宾语</del> <strong>makes it</strong></p>
<h4 id="but-for-虚拟-公主-wcms-do"><a href="#but-for-虚拟-公主-wcms-do" class="headerlink" title="but for 虚拟 公主 wcms+do"></a>but for 虚拟 公主 wcms+do</h4><p>before介词 后面接 动名词<br>You have to work in this position for two years before <strong>being promoted</strong> </p>
<p>consider doing 考虑做…   直接跟在动词后面的 直接选doing<br>Have you ever considered <strong>joining</strong></p>
<p>want to do + 被动<br>…<strong>want</strong> the construction of the classroom building <u>to be completed</u> by the time school starts in August.</p>
<p>前面有名词 先考虑定语从句<br>One kind of vacation <strong>that</strong> many American enjoy is camping</p>
<p><u>unless 时间    until 条件</u> 两个连词首选</p>
<hr>
<p>found是建立的原型 find是找到的原型<br>3.wish虚拟 wcms + do<br>I certainly <strong>wish</strong> he <u>would teach</u> me how.</p>
<p>4.后面不完整 介词+whom<br>there wasn’t a single person <strong>to whom</strong> <u>she could turn for help.</u></p>
<p>7.不缺 关系副词 when where why 和 可省；缺的话直接连; 前面没宾语<br>Our school is no longer <u>what</u> it was 10 years ago, <u>when</u> it was not well equipped</p>
<p>8.idea 后面没主语 idea和后面的连不上 语法和句意连不上<br>Do you have any idea <u>what</u> is actually going on in the classroom?</p>
<p>10.定语前置  ing修饰物 ed修饰人 Mr Smith,<strong>tired</strong> of the <strong>boring</strong> speech<br>Mr Smith, <u>tired</u> of the <u>boring</u> speech, started to read a novel.</p>
<p>12.salary 月&#x2F;工资<br>Some famous singers live on the <u>income</u> from their record sales.</p>
<p>13.affair事件 make sense 有意义<br>In my opinion, what he told us just now about the affair simply doesn’t take any <strong>sense</strong></p>
<p>14.lost(被动)没找到不知道在哪 forgotte完全忘了这件事  miss失踪(主动)  left知道落下哪<br>I can’t find my watch. I must have <u><strong>left</strong></u> it in the hotel.</p>
<p>15.街道有两个边 后面谓语动词是is所以Both不对 Neither不对(不是没边)<br><u>Either</u> side of the street is lied with different shops, <u>all</u> of which sell electronic products.</p>
<p>17.有比较关系<br>There were two boys in the lab, <u>the cleverer of whom</u> did the experiment successfully.</p>
<p>18.找虚拟 建议 should do   prevent sb from doing   forbid sb to do sth<br>It is strongly <strong>suggested</strong> that measures <u>be taken to forbid</u> students to cheat in the exams.</p>
<p>19.几个冠词几个人 is 一个 前面有the冠词 就不填<br>The poet and <u>不填</u> pianist is going to give us a talk this afternoon.</p>
<p>20.insisted 过去用真实 没发生用虚拟<br>He denied <u>having</u> stolen these watches and insisted that he <u>be</u> set free at once.</p>
<hr>
<p>1.The watch and chain <u>is made</u> of gold<br>黄油面包 战争和平 手表和表链 都是一件事</p>
<p>4.<strong>Taking</strong> exercise early in the morning has become part of his retired life<br>动词不定式&#x2F;动名词 作主语</p>
<p>6.Where do you live? I live <u>at 105, Stone Street</u><br>not unless&#x2F;until  &#x3D;&gt;  didn’t <strong>-&gt;</strong> until 其余是 unless<br>街道on 城市区域in 门牌号at</p>
<p>7.Tom does speak Chinese well, but his reading and writing skills leave much <strong>to be improved</strong><br>大多是done 有待提高(<strong>提高,改变,增加,解决,促销,解决</strong> 好的趋势走的) 这件事亟待解决 &#x3D;&gt; <strong>小心将来时</strong>，只要没告诉正在做…  就ed</p>
<p>8.The crazy fans <u>had been waiting</u> patiently for two hours, and they would wait to the movie star arrived.<br><u>将来完成，完成进行，将来正在进行</u>成为答案的几率较大</p>
<p>9.In any case无论如何，After all毕竟，As a result结果是，In this way用这种方式</p>
<p>10.If we work with a strong will, we can overcome any difficulty, <strong><u>howerer</u></strong> great<del>形容词</del> it is.<br>what how不在定语从句里，都是名词性从句。定语从句&#x2F;状语从句 有逗号在前面 &#x3D;&#x3D;<u>however + <strong>adj</strong></u>&#x3D;&#x3D;</p>
<p>12.She likes to eat <strong>vegetables</strong> and she has a nice <strong>vegetable</strong> garden in front of her house.<br><u>零食+蔬菜+面条</u> 单独使用用复数</p>
<p>13.Hardly <u>had they got to the bus stop</u> when the bus suddenly pulled away.<br><strong>Hardly</strong> had sb do</p>
<p>17.What the doctor is uncertain about is <u><strong>whether</strong></u> my mother will recover from the serious disease soon.<br>缺不缺 疑不疑，&#x3D;&gt; 有疑   remind sb of sth</p>
<ol start="20">
<li>Excuse me!<br><u>Yes ?</u><br>How can I get to the nearest post office?<br>情景对话 考中英文差距<br>pardon 再说一遍   Yes？咋啦  What’s wrong?</li>
</ol>
<blockquote>
<p>一般中文翻译对的 英文的含义就是错的，中文翻译出来的不选</p>
</blockquote>
<hr>
<ol>
<li><p>The man (being) used to <em><strong><u>getting</u></strong></em> up early <strong>had</strong><del>前面非谓语</del> his leg broken.<br>　　<u>A. getting</u>  B. get  C. got  D. have got<br>　　　　　　　　　　　　used to do&#x2F; used to doing 带入句意</p>
</li>
<li><p>The TV programme has ______on the children as ______ as the old.<br>　　A. a good effect; good(<u>实际性</u>)　　<u>B. a positive effect; well</u> (习惯性搭配)<br>　　　　　　　　　　　　C. a good affect; well　　D. affect; well</p>
</li>
<li><p>–He____ to the meeting. Have you informed him of it?　　<br> –Sorry. I       to. [忘了]<br> 　　A. hasn’t come; am going　　B. didn’t come; have forgotten<br> 　　<u>C. hasn’t come; forgot</u> 　　D. doesn’t come; will have</p>
</li>
<li><p>–Did you look up the time of trains to Shanghai?<br>　–Yes, the earliest train is ___ to leave at 5:30 am.<br>　　　　　　　　A. likely           B. about [be about to立刻马上出现 后面不跟时间]　　<br>　　　　　　       C. possible[不可能成为答案]         <u>D. due</u><br>　　　　　　be likely to有可能 如果考对话 要看完 完整对话</p>
</li>
<li><p><strong>Everyone</strong> was on time for the meeting ___Chris, who’s usually ten minutes late for everything.<br>　　A. but       B. only　　<u>C. even</u><del>甚至</del>      D. yet<del>副词修饰整个句子,放在前面表强调,或者放在屁股后面</del></p>
</li>
</ol>
<p>　　&gt; 介词查缺补漏：<br>　　&gt; <u>你是我不是<strong>except</strong></u>：你们是学生，我是老师<br>　　&gt; <strong>except</strong><del>(全能)[鹤立鸡群]</del>：你跟我们是不一样的 我们都是30岁以下 你36；别人都不了解你，只有我了解你<br>　　&gt; <strong>except for</strong>：except for由于有介词for，故后面只能接名词&#x2F;动名词或名词性短语<br>　　&gt; except that：except that 只可惜 <u>帽帽词</u>，后面跟<strong>句子</strong>；除了<del>(句子)他不会生气</del>，他都会<br>　　&gt; beside：是介词，有两个意思，“在…旁边”<del>常用来表示位置和方向。</del>和“与…相比”<br>　　&gt; besides：<strong>我是你也是</strong> <u>除了我以外，还有别人喜欢你</u> 表示除……外（还有），是包括在内的意思【加法的概念】<br>　　&gt; but：后面动词 to do；前面有动词 去掉to；but前面必须是(不定&#x2F;人称&#x2F;不定)代词 I have <strong>nothing</strong> but<br>　　<br>6. She was afraid ___ the dog in case it became dangerous.<br> A. of exciting   <u>B. to excite</u>   C. that she excited     D. to be exciting</p>
<blockquote>
<p>be afraid to do sth 害怕做某事<br>be afraid of&#x2F;that 表担忧,担心、语气较弱</p>
</blockquote>
<ol start="7">
<li><p><strong>Collecting<del>主语</del></strong> stamps as a hobby___________ increasingly popular during <u>the past fifty years</u>.<br> A. becomes         B. became        C. has become     D. had become<br> 单数 复数 时态<br> 一被二单三时态<br> 动词做主语 &#x3D;&gt; 用单数<br> recently &#x2F; the past… &#x2F; since 现在完成时</p>
</li>
<li><p><strong>I would have</strong><del>虚拟，后面是真实的</del> come to see you earlier, but I ___ too busy.<br> A. had been     B. were       <u>C. was</u>       D. would be<br> if 小心错综   虚拟后面小心but，but后面是真实的…</p>
</li>
<li><p>–Hi, Tracy, you look tired.<br> –I am tired. I ___ the living-room all day.<br>  A.painted     <u>B. have been painting<del>完成进行</del></u>     C. had painted<del>现在完成</del>    D. have painted<br> 对话要看完整</p>
</li>
<li><p>My uncle___________ until he was forty-five.<br>  A.married     <u>B. didn’t marry</u>    C.was not marrying   D. would marry<br> 直到…<strong>才做</strong><del>了一件什么什么事</del>  &#x3D;&gt; did</p>
</li>
<li><p>I know nothing about the young lady ___________ she is from Beijing.<br>   A. except      B. except for    <u>C. except that</u>    D. besides</p>
<blockquote>
<p><u>你是我不是<strong>except</strong></u>：你们是学生，我是老师<br><strong>except</strong><del>(全能)[鹤立鸡群]</del>：你跟我们是不一样的 我们都是30岁以下 你36；别人都不了解你，只有我了解你<br><strong>except for</strong>：except for由于有介词for，故后面只能接名词&#x2F;动名词或名词性短语<br>except that：except that 只可惜 <u>帽帽词</u>，后面跟<strong>句子</strong>；除了<del>(句子)他不会生气</del>，他都会</p>
</blockquote>
</li>
<li><p>.She <strong>suggested<del>暗示</del></strong> to the police in the police station that ___.<br>   A. Mr. Smith stole the necklace            B. Mr. Smith <strong>should steal</strong><del>should可省</del> the necklace<br>   C. Mr. Smith had stolen the necklace  D. Mr. Smith <strong>steal</strong> the necklace<br>  &#x3D;&#x3D;1234&#x3D;&#x3D; <strong>suggest</strong><del>暗示</del> <u>过去完成</u>  insist</p>
</li>
</ol>
<blockquote>
<p><span style = "color : red">在<u><strong>suggestion、advice、request、order</strong></u>等意为“建议，命令，要求”的名词后，同位语从句中的谓语动词通常用”<strong>should+动词原形</strong>”的虚拟语气结构，句中的should可以省略。</span>&#x3D;&#x3D;demand、proposal、advice、suggestion唯独<strong>定语从句</strong>不能用虚拟该用啥用啥<del>连字诀</del>；若词后的是<strong>同位语从句</strong>，则 <strong>should + do</strong>，&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>insist</strong>&#x3D;&#x3D; 表示坚持，有两种情况，一是”<strong>坚决要求</strong><del>虚拟</del>“；二是”坚持说“<br>&#x3D;&#x3D;<strong>suggest</strong>&#x3D;&#x3D; 一是”<strong>建议</strong><del>虚拟</del>“；二是”陈述事实”</p>
</blockquote>
<ol>
<li>_________good, the food was soon sold out.<br>   A. Tasted     B. Being tasted    <u>C. Tasting</u>    D. Having tasted<br>  &#x3D;&#x3D;感官动词&#x3D;&#x3D; &#x3D;&gt; 连系动词<strong>相当于</strong>(be)无被动<br>  能做连系动词的 <strong>感官类动词</strong> &#x3D;&gt; 前面加be 带入查看。<br>  连系动词没有被动,只有主动格式</li>
<li>–I’d like to have some lunch but I have to stay here doing my work.<br>  –______what you want and I can get it for you.<br>A. To tell me    B. Telling me    C. If you tell me     <u>D. Tell me</u></li>
<li>The wrong you’ve done to him is terrible, for___ you should make an apology to him, I think.<br>  A. this         <u>B. which</u>          C. what         D. that</li>
<li>–Excuse me, I want to have my watch fixed, but I can’t find a repair shop.<br>  –I know_____nearby. Come on, I’ll show you.<br><u>A. one</u><del>特指前面那家</del>              B. it           C. some             D. that</li>
<li>–The two pairs of shoes are _ the same colour.–But they are different ___ colour.<br>   A. of; from     <u>B. of; in</u>        C. in; from     D. in; in<br>  在哪方面不同in<br>  be of + 名词 &#x3D; 形容词</li>
<li>The reason __ their failure you know is ___ they didn’t get fully prepared for the experiment.<br>   A. why.., that    B. that.., why    <u>C. for.., that</u>     D. why.., because<br>  不是句子不能选A</li>
<li>All the preparations______, we’re ready to start.<br>   <u>A. made</u>      B. being made     C. having made    D. have been made<br>  准备被做 </li>
<li>The manager has to get all these washing machines ___.<br>A. to deliver      B. be delivered   <u>C. delivered</u>   D. delivering<br>  get sth done</li>
</ol>
<hr>
<p>can not be + adj &#x3D; 最高级</p>
<p>6.He believes that Nigerians are <strong>one of</strong> <u>the most hard-working</u> people on earth.<br>one of 后面加最高级</p>
<p>8.CR <u>sent</u> humanitatian aid to those <u>affected</u> by the earthquake in Syria.<br>谓语动词 sent   by被动 不是affected就是to be affected 被动完成ed  选affected</p>
<p>9.<u>It</u> was reported that Jackson turned down a very good job offer.<br>It is reported…</p>
<p>10.Terry held <u>a great many roles</u> in his lifetime.<br>修饰名词 名词放在最后 many a意思是许多，后面有a冠词 冠词后面跟单数 &#x3D;&gt; many a role<br>a great many &#x3D; a lot of</p>
<p>12.I got <u>shouted at</u> by me neighbor for parking my car in front of her house.<br>by 被动  &#x3D;&gt; shouted at</p>
<p>13.The bag was snatched by the monkey and taken to a <u>ten-meter-high</u> tree.<br>数词连字符，形容词，全部用连字符都连起来。</p>
<p>14.<u>If</u> disturbed, the bird may abandon the nest, leaving the baby birds to die.<br>因为所以 往往都是过去的，里面有may 可能是 是个条件 选A</p>
<p>15.人称代词 你的BD <strong>B形容词性物主代词 + 名词</strong></p>
<p>介词 + ing &#x2F; adj</p>
<p>you have <u>a</u> huge advantage<del>可数名词，不裸奔&#x3D;&gt;冠词</del> in life</p>
<hr>
<p>2.The amount of money <u>needed</u> for the seriously sick boy was soon collected.<br>非谓语考点 先找谓语 was collected  主语是The amount of money；(which后面少了个be &#x3D;&gt; which was needed)</p>
<p>3.It has become <u>the</u> talk of <u>the</u> town.<br>变成城市里的热门话题  <strong>of后面永远是特指<del>the</del></strong>  of前面有可能是定冠词 有可能是不定冠词</p>
<p>5.He <u>has been out of work</u> since a month ago.<br>since现在完成时 前面要用<strong>延续性动词</strong>  lost是结束性动词(×)</p>
<p>6.The movie <u>anything but</u> boring; it is, in fact, rather exciting and interesting.<br>is 后面不能有all </p>
<blockquote>
<p><strong>anything but</strong> 一点也不 （否定）<br><strong>nothing but</strong> 只有,只不过是…    （肯定&#x3D;&gt;双否表肯）<br><strong>no more</strong>只是 no more than 不再…<br><strong>all but</strong> 几乎,差一点</p>
</blockquote>
<p>7.It is only when you nearly lose someone <u>that</u> you fully realize how much you value him.<br><strong>帽帽第一(50%) 连词第二(30%)</strong>    强调句  </p>
<p>8.Shall Mary come and play with us? &#x3D;&gt; No, <u>unless</u> she has finished her homework.<br>情景对话 unless首先考虑 </p>
<p>9.The plan <u>broke down</u> just because people were unwilling to cooperate.<br>broke down失败、坏了    pulled down推倒、拉倒    turned down拒绝    put down放下</p>
<p>10.Travelers <u>are reminded</u> that they should bring their ID cards with them.<br>时态语态 没有by或虚拟 没有主将从现 硬看  一被二单三时态  &#x3D;&gt; 被提醒  后面should do 前面要一般式 [考时态的时候had been done<del>过去的过去</del>错误的几率大]</p>
<p>11.”Who Moved My Cheese?”, <u>which</u> is a best-selling book, is written by Spencer Johnson.<br><u>有逗号 不可能是名词性从句</u> &#x3D;&gt; 定语从句&#x2F;<strong>状语从句</strong>(只能用ever系列) when是时间状语从句 其余的都要ever(<del>however</del>…)<br>D.what只能引导名词性从句 &#x3D;&#x3D;非限&#x3D;&#x3D; 不能用<strong>that</strong>~</p>
<p>12.Show me your permit, please. –Oh, it’s not in my pocket. It(<strong>must have fallen out</strong>)<br>情态动词 已经掉出去了 过去式(<u>should have fallen out</u>)&#x2F;(<u>must have fallen out</u>) 掉出去了是&#x3D;&#x3D;推测&#x3D;&#x3D; &#x3D;&gt; 推测肯定的</p>
<p>13.If you want to see a doctor, fix the date with him ahead of time. This is a common <u>custom</u> in the USA.<br>habit个人行为举止的习惯    custom习俗惯例<del>急诊需要预约</del></p>
<p>14.Peter won’t drive us to the station. He has <u>too small a car</u> to take us all.<br>too和such的用法 装不下 <strong>too&#x2F;so+形容词+主语+谓语</strong></p>
<p>15.<strong>To save</strong> time and labor, cartoonists generally draw the hands of their characters with only 3 fingers and a thumb.<br>非谓语动词 有逗号没连词没主语前面 光秃秃 先考虑To do &#x3D;&gt;为了节省劳动力<br>前面有连词的话 就ing</p>
<p>16.Which one can I take? –You can take <u>all</u> of them; I’ll keep none<del>不保留</del>.<br>三个或三个以上 肯定句不用any  any用于否定句和疑问</p>
<p>17.at one’s own expense 花钱</p>
<p>18.I <strong>told</strong> you<del>肯定</del> that you shouldn’t waste your time playing the computer games, <u><strong>didn’t I</strong></u><br>反义疑问句：<strong>前肯后否 前否后肯 你主我主 你助我助</strong>  否定前置(我认为,我们认为) I told you肯 told助 &#x3D;&gt; didn’t I</p>
<p>19.I live <u>at 123, King Street</u><br>小到门牌号用at</p>
<p>20.Don’t be joking. It’s time to <u>take up</u> your business <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><br>take up开始做某事     set out to do sth;  go on to do&#x2F;doing；go on with+名词；get down to do sth</p>
<hr>
<p>9.表示时间的多久之后  in&#x2F;after&#x2F;later<br>若句子所在<strong>将来时</strong>&#x3D;&gt; In(+段时间)(随时间推移时间事件发生变化) &#x2F; after(+点时间)(不会随着时间的推移而变化)(4.23日解封)<br>Three days later  After three days</p>
<p>11.修饰人口的 large &#x2F; </p>
<p>12.不是虚拟的就是推测的 must不对</p>
<p>13.谓语动词跟your brother保持一致 <strong>就近原则</strong> 以you为准</p>
<p>14.否定词提前的倒装 would -&gt; did  <strong>D</strong></p>
<p>15.struck    match</p>
<hr>
<p>1.The woman over there is <strong>Julia and Shelley’s</strong> mother<br>俩人共有 is 一个 A  几个撇号s 就是几个</p>
<p>2.When he took his gloves off, I noticed that <strong>each</strong> one had his name written inside.<br>后面是one goloves手套两个脱下来 个体 两个 A</p>
<p>3.It was a difficult job for him. He had tried everthing but it made little <strong>difference</strong><br>固定搭配 made little difference没有进展  make get take have 固定搭配</p>
<p>4.competition 竞争&#x2F;竞赛</p>
<p>5.The teacher praised me for <strong>the</strong> progress I’d made, which was <strong>a</strong> great encouragement to me.<br>冠词 特指取得的进步  一种鼓励 抽象概念具体化 B</p>
<p>6.In a word总而言之  In general总体来讲  in particular特别的</p>
<p>7.I wonder why Jenny <strong>hasn’t written</strong> us recently. We should have heared from her by now.<br>I wonder 现在  现在完成时</p>
<p>8.I have no objection <strong>to spending</strong> the evening with them.<br>object to doing</p>
<p>12.五分之一  one in five，</p>
<p>13.I told your friend how to get to the hotel, but perhaps I <strong>should</strong> have driven her there.<br>情态动词 不是虚拟的 就是推测的 没送 虚拟 <del>B</del>, 我应该送他去 D</p>
<p>14.<strong>But for</strong> your timely warning, we would have been unaware of the danger.<br>would have done 虚拟  &#x3D;&gt; but for虚拟</p>
<p>16.Seldom <strong>did I make</strong> any mistakes during my past few years of working here.<br>seldom 倒装  past few years 过去式 B</p>
<p>18.He’s working hard <u>for fear that</u> he <strong>may fall behind</strong><br>for fear that 虚拟 should + 动词原形，should可以省略</p>
<p>19.Although Anne is happy with her success she wonders <strong>what</strong> will happen to her private life<br>先后顺序it 帽帽 连词 其他；前动(what)后动</p>
<hr>
<p>2.Who are those with the flags?   &#x2F;&#x2F;  A group <strong>calling</strong> it self the League for Peace 【对话基本都有坑】</p>
<p>4.I’d like Jane, <strong>rather than</strong> Joan, to go to the farewell party on behalf of our class<br>would like A rather than B else to do sth 我宁愿A而不是B去做这件事<br>perfer A to B</p>
<p>11.lose heart 失去信心  lose one’s heart 爱上某人</p>
<p>13.for fear that<del>虚拟后面跟公主</del></p>
<p>14.过去式&#x2F;过去完成时(90%)  go out 出去&#x2F;熄灭</p>
<p>15.We will take <strong>whoerer</strong> wants to go there for a sight-seeing 泛指带那些想要去观光的人去观光 不是特指 </p>
<hr>
<p>need doing 主动表被动<br>5.农场farm 用on<br>6.other 后名词复数  one and the other<strong>s</strong><br>7.commit犯罪 comprehension理解 cooperation合作 compromise许诺<br>affair公共事件 variety种类 matter事件 a matter of …的角度<br>by the time 考点<br>less 是 little的比较级<br>few 修饰可数名词<br>little 修饰不可数<br>any 否定 疑问<br>some 肯定<br>whether or<br>国家名称不加冠词<br>doubt 否疑 that<br>单独用 后面 whether</p>
<hr>
<p>对话里出现的同一个事物时 第一个出现时用a 再次出现时用the<br>lesson one &#x2F; the first lesson<br>…at <strong>Gate 21</strong> &#x2F;<del>21St Gate &#x2F; the Gate 21 &#x2F; 21 Gate</del><br>I beg your pardon 再说一遍？<br>gave in 屈服 give up 放弃</p>
<p>…times + more + 名词 + than<br>倍数关系+完整的比较级</p>
<h3 id="独立主格结构"><a href="#独立主格结构" class="headerlink" title="独立主格结构"></a>独立主格结构</h3><p>With + 名词 + ed(被动)&#x2F;ing&#x2F;to do(要做没做)&#x2F;adj&#x2F;adv&#x2F;pron<br>有逗号没连词 句子开头是with 有主语</p>
<p>答案里出现do的原型 90%是错的 (used to <del>do</del>)<br>若前面的动词是do 后面也是do (5%概率题目)</p>
<hr>
<p>1….. <strong>the</strong> news came as <strong>a</strong> shock to us<br>news 前面特指  抽象概念具体化</p>
<p>3.refused to accept <strong>any</strong> of the three suggestions…<br>代词 three </p>
<p>4.Do you mind if I smoke here?     No, Go ahead 不介意，随意<br>Go ahead随意 No，I mind 不介意，我介意</p>
<p>5.What he has done is far from <strong>satisfactory</strong><br>far from<del>一点也不</del>副词短语(修饰形容词 动词) </p>
<p>8.Do you regret paying 500 dollars for your necklace? No,I would gladly pay <strong>twice as much</strong> for it<br>不管多少钱都是不可数 用钱 much 永远是</p>
<p>12.look! Here. Oh, yes, here <strong>comes the bus…it comes</strong>  名到 代不倒</p>
<p>15.on purpose    aim at    by chance    by design故意的、有意的</p>
<p>16.帽帽 后面缺不缺？ 缺了事和人  that which 由于先行词 是人和物 that</p>
<p>17.情态动词动词原形 不是真实的就是推测的 够我们喝了 推测 所以A×陪葬 BD捆绑 C√  两个人喝20瓶 够喝了</p>
<p>18.人mean todo  物mean doing  一旦答案里出to do 和 doing，do一般带那个词原意才可以<del>除非动词就是do</del> 不能轻易出现</p>
<p>19.but todo 但后面有动词原形to 则to要省略</p>
<p>20.do不能随便选啊！！！</p>
<hr>
<p>⑦</p>
<p>1.主谓一致 there be !!    不会有there have  一双鞋以双为准 单数 Here <strong>is</strong> a new pair of shoes</p>
<p>2.Your coffee smells great!  would you like <del><strong>it</strong></del>  用<strong>some</strong>  指的是同一个！</p>
<p>3.生活开销 living <strong>expenses</strong>;  at my own expense        cover bills     charge 多少钱 for sth</p>
<p>4.具体专业不加冠词  my major medicine    she became <strong>a</strong> writer</p>
<p>6.your husband who <strong>is to blame</strong></p>
<blockquote>
<p>主动表被动 谓语动词主动表被动 开始结束 只要不强调<strong>被谁开始被谁结束</strong> 都是主动表被动  不及物动词没有被动格式<br>主动表被动<br>不定式 to blame，to let<br>be+形容词+to do<br>in charge of 负责<br>in the charge of 由…负责<br>“on”<br>“under+名词”</p>
</blockquote>
<p>9.It all depends 看情况吧</p>
<p>13.如果有两顶帽帽 that<del>先行词</del>  which<del>后置定语</del></p>
<p>14.出现我们认为 we think 先砍掉 看别的</p>
<p>16.house <strong>whose</strong> windows 前名后名中变的</p>
<p>17.view 从高处往地处 往远处看的风景</p>
<p>20.charge for收费  change for交换   claim宣称</p>
<hr>
<p>1.<u>Both</u> sides have accused <strong>the other</strong> of breaking the contract 只有两方时候 指对方用the other</p>
<p>2.At the end of the cross-talk, <strong>the</strong> audience<del>特指</del> present in the hall burst into <strong>a</strong> laughter</p>
<p>15.强调搭配 后面句子完整(主谓宾完整) 前面有介词 </p>
<p>16,.主句是过去 时态全部往前推一档  主句 had hoped that John (would spend) a year in….he stayede</p>
<p>17.定语从句 能连上</p>
<p>19.一枪二定三名次 定！！ he gave the reason 能连上 不是which 就是 that；Do you think the reason <strong>which</strong> he gave is believable ?</p>
<p>20.主语从句 缺不缺疑不疑 AD  It is because  &#x2F; that is because</p>
<hr>
<p>时态语态 一单二被三时态<br>6.Now then .children, It’s time<del>过去式</del> you (were washed and dressed) … 不及物动词没有被动 如果是及物动词必须跟宾语<del>没有宾语必须被动</del></p>
<p>9.remain不及物动词 + 介词 + 名词    若是及物动词后面一定是名词</p>
<p>10.not so as 和…不一样   such后一般加名词    so形容词as    as形容词as</p>
<p>13.sb run out of sth    正在进行表将来</p>
<p>15.Did you enjoy yourself yesterday?  Yes. As you saw, <strong>the</strong> party went on in <strong>a</strong> most<del>一种</del> pleasant atmosphere 最高级95%以上全部都是定冠词the    </p>
<p>17.情景对话的回答者 一般不用强调  ….. —It was in the hotel <strong>where</strong> he stayed.</p>
<p>19.Neither<del>双方</del> of them knew what <strong>the other</strong> was doing 指的双方—&gt;<strong>对方</strong>时</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#ffa2c4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2023/02/25/英语/语法单选模块/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/01/19/计算机/信息安全、新一代信息技术/">
        <h2>
            信息安全、新一代信息技术
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/1/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h5 id="信息安全的含义"><a href="#信息安全的含义" class="headerlink" title="信息安全的含义"></a>信息安全的含义</h5><p>&#x3D;&#x3D;<strong>信息安全是指信息网络的硬件、软件及其系统中的数据受到保护，不受偶然的或者恶意的原因而遭到破坏、更改和泄露，系统连续、可靠、正常地运行，信息服务不中断。</strong>&#x3D;&#x3D;</p>
<p>信息安全的基本属性：其中<strong>机密性，完整性，可用性</strong>成为信息安全的金三角CIA<br>信息有：<strong>依附性、普遍性、价值性、时效性、共享性</strong><br><strong><u>信息的采集、存储、发布、处理</u></strong></p>
<p><u>机密性、完整性、不可抵赖性、可用性、可控性</u></p>
<p><u>机密性</u>：防侦收、防辐射、信息加密、物理保密、信息隐形<br><u>完整性</u>：<br>    主要因素:设备故障、误码、人为攻击、计算机病毒等<br>    主要保护方法:协议、纠错编码方法、密码校验和方法、数字签名 、公让竺</p>
<p><u>不可抵赖性</u>(Non-repudiation) : 也称抗抵赖性，在网络环境中，信息交换的双方不能否认其在交换过程中发送信息或接收信息的行为。<br>可用性：信息的可用性涉及面广硬件可用性软件 可用性人员 可用性环境 可用性:主要是自然环境和电磁环境</p>
<p>鉴于信息安全的上述特点，信息安全的目标可以归纳为下列几点。<br>①**真实性:<strong>对信息的来源进行判断，能够对伪造来源的信息进行鉴别。<br>②</strong>保密性:<strong>保证机密信息不被窃听，或窃听者不能了解信息的真实含义。<br>③</strong>完整性:<strong>保证数据的一致性，防止数据被非法用户篡改。<br>④</strong>可用性:<strong>保证合法用户对信息和资源的使用不会被不正当地拒绝。<br>⑤</strong>不可抵赖性:<strong>建立有效的责任机制，防止用户否认其行为，这一点在电子商务中是极其重要的。<br>⑥</strong>可控制性:<strong>对信息的传播及内容具有控制能力。<br>⑦</strong>可审查性:**对出现的网络安全问题提供调查的依据和手段。</p>
<p>信息威胁产生的原因:<br>系统漏洞、协议的开放性、人为因素(最主要的)<br>1.人为的偶然失误 2.计算机犯罪 3.黑客攻击  </p>
<p>信息安全策略<br><strong>信息安全策略是指为保证提供一定级别的安全保护所必须遵守的规则。要实现信息安就要针对信息安全的主要威胁和信息安全所涉及的主要问题,不但从技术上，更应该靠严的安全管理、法律约束安全教育及信息安全</strong>服务。信息安全服务是指做好对信息系统的咨询、集成、监理、测评、认证、运维、审计、培训和风险评估、容灾备份和应急响应工作。风险评估有<strong>定量</strong>和<strong>定性评估</strong>。</p>
<p>@@ Internet设计之初，并未充分考虑到网络安全问题。SSH，FTPS，HTTPS，VPN采用加密</p>
<p>网络具有<strong>虚拟性</strong>和<strong>匿名性</strong><br>计算机及网络在给人类带来极大便利的同时，也不可避免地引发了一系列新的社会问题。<br><code>因此，**有必要建立和调整相应的社会行为礼仪，道德规范和相应的法律制度，从伦理和法制两方面约束人们在计算机使用中的行为。**</code></p>
<p><strong>底线原则</strong>：无害原则、公正原则、平等原则、互利原则<br><strong>自律原则</strong>：自尊原则、自主原则、慎独原则、诚信原则</p>
<h4 id="计算机理论"><a href="#计算机理论" class="headerlink" title="计算机理论"></a>计算机理论</h4><p>信息伦理学与计算机伦理学、网络伦理学虽具有密切的关系，但信息伦理学不完全等同于计算机伦理学或网络伦理学，信息伦理学有着更广阔的研究范围，涵盖了后两者的研究范围。<br>计算机伦理与网络伦理的研究范围既有相似、重合的地方，又有不同之处。<br><strong>计算机理论</strong>：隐私保护，计算机犯罪，知识产权，软件盗版，病毒，黑客，行业行为规范<br><strong>网络理论</strong>：虚信息的散布、信息安全问题[国家安全问题，隐私侵犯]、不良信息的充斥、网络知识产权的侵犯、网络游戏挑战理论极限<br><u>计算机软件分为<strong>商品软件、共享软件、自由软件和公有软件</strong>。</u></p>
<h4 id="计算机病毒定义"><a href="#计算机病毒定义" class="headerlink" title="计算机病毒定义"></a>计算机病毒定义</h4><p><strong><u>计算机病毒是隐藏在计算机系统的数据资源中，利用系统资源进行繁殖并生存，能够影响计算机系统正常运行并通过系统数据资源共享的途径进行传染的程序。</u></strong></p>
<p><u>“计算机病毒”不是天然存在的，而是人故意编制的一种特殊的计算机程序</u>。特征：&#x3D;&#x3D;<strong>感染性、流行性、繁殖性、变种性、潜伏性、针对性、表现性。</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>计算机病毒</strong>代码的结构一般来说包括3大功能模块:&#x3D;&#x3D;<br><u><strong>引导模块</strong>:</u> 引导模块将病毒由外存引入内存，使后两个模块处于活动状态。<br><u><strong>传染模块</strong>:</u> <strong><u>传染模块显然用来将病毒传染到其它对象上去</u></strong><br><u><strong>破坏模块</strong>:</u> 破坏模块实施病毒的破坏作用，如删除文件，格式化磁盘等，由于有些病毒的该模块并没有                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               明显的恶意破坏作用，而只是进行一些视屏或声方面的自我表现作用，故该模块有时又称表现模块</p>
<p>根据病毒存在的媒体，病毒可以划分为: 网络病毒、文件病毒和引导型病毒<br><strong>网络病毒</strong>通过计算机网络传播感染网络中的<u>可执行文件</u><br><strong>文件病毒</strong>感染<u>计算机中的文件</u>(如:com, exe, doc等)<br><strong>引导型病毒</strong>感染<u>启动扇区(Boot)和硬盘的系统引导扇区(MBR)</u></p>
<p>还有这三种情况的<strong>混合型病毒</strong>，例如:多型病毒(文件和引导型)感染文件和引导扇区两种目标，这样的病毒通常都具有复杂的算法，它们使用非常规的办法侵入系统，同时使用了加密和变形算法<br>宏病毒：破坏Excel、PPT、word</p>
<p>计算机病毒传染的过程是这样的：病毒从带毒载体进入内存，一般&#x3D;&#x3D;<strong>利用操作系统的加载机制或引导机制</strong>&#x3D;&#x3D;。当系统运行一个带毒文件或用一带毒系统盘启动时，病毒就进入内存。而从RAM侵入无毒介质则利用了操作系统的读写磁盘中断或加载机制。</p>
<h5 id="破坏程度："><a href="#破坏程度：" class="headerlink" title="破坏程度："></a>破坏程度：</h5><p>良性病毒[<strong>占用大量CPU资源</strong>]<br>恶性病毒[<strong>破坏资源</strong>]</p>
<h5 id="驻留内存："><a href="#驻留内存：" class="headerlink" title="驻留内存："></a>驻留内存：</h5><p>驻留型病毒[启动后，一直占用内存资源]<br>非驻留型病毒[运行时，才会进入内存]</p>
<p><strong>计算机病毒传播途径</strong>：<br><strong>通过软盘</strong>: 通过使用外界被感染的软盘进行传播。<br><strong>通过光盘</strong>: 一些软件在写入光盘前就已经被病毒感染，这种带毒的光盘也是病毒传播的一种途径。<br><strong>通过硬盘</strong>: 通过使用带有病毒的计算机，将干净的软盘或光盘感染再进一步扩散。<br><strong>通过网络</strong>: 通过网络传播病毒是目前病毒传播的一种主要途径。其传播速度快，传播范围广，给防范计算机病毒带来严峻的挑战</p>
<h5 id="病毒的防治："><a href="#病毒的防治：" class="headerlink" title="病毒的防治："></a>病毒的防治：</h5><p><u>安装防，杀，反病毒工具；养成良好的习惯；自觉培养信息安全意识；注意自己的操作系统；将受病毒侵害的计算机尽快隔离；安装个人版防火墙；注意在没有防病毒软件的计算机上，尽量不使用移动存储设备</u></p>
<p>@@ 设置较复杂的口令(包括系统、应用)可以大大减少计算机病毒带来的风险</p>
<h4 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h4><p>下面是密码学中一些常用的术语:<br>1)<strong>明文</strong>(Plaintext&#x2F;Message):指待加密的信息，用P或M表示。日文可以是文本文件、图形、数字化存储的语音流或数字化的视频图像的比特流等。<br>(2)<strong>密文</strong>(Cipertext):指明文经过加密处理后的形式，用C表示。<br>(3)<strong>加密</strong>(Encryption):指用某种方法伪装消息以隐藏它的内容的过程。<br>(4)<strong>加密算法</strong>（Encryption Algorithm) :指将明文变换为密文的变函数，通常用E表示。<br>(5)<strong>解密(<strong>Decryption) :指把密支转换成明文的过程。<br>(6)<strong>解密算法</strong>(Decryption Algorithm):指将密文变换为明文的变换函数，通常用D表示。<br>(7)</strong>(密钞(Key</strong>) :变换函数所用的一个控制参数。加密和解密算法的操作通常是在一组密钥控制下进行的，分别称为加密密钥和解密密钥，通常用K表示。<br>(8)<strong>密码分析(Cryptanalysis)</strong> :指截获密文者试图通过分析截获的密文从而推断出原来的明文或密钥的过程。</p>
<p><strong>古典密码</strong>：替代[全加n]、置换</p>
<p>&#x3D;&#x3D;<strong>对称密码体制</strong>:&#x3D;&#x3D;<br>对称密码体制(Symmetric Encryption)，如果<strong>一个密码算法的加密密钥和解密密钥相同，或由其中一个很容易推导出另一个</strong>，该算法就是对称密码算法。<br>(1)优点:加密、解密处理速度快，保密度高等。<br>(2)缺点:<br>①密钥是保密通信安全的关键，发信方必须安全、<br>妥善地把密钥护送<br>到收信方，不能泄露其内容。如何才能把密钥安全地送到收信方，是对称密码算法的突出问题。对称密码算法的密钥分发过程复杂，所花代价高;<br>②多人通信时密钥组合的数量会出现爆炸性膨胀，使密钥分发更加复杂化，若有个用户进行两两通信，总共需要的密钥数为个;<br>③通信双方必须统一密钥，才能发送保密的信息。如果发信者与收信人素不相识，这就无法向对方发送秘密信息了。<br>④除了密钥管理与分发问题，对称密码算法还存在数字签名困难问题(通信双方拥有同样的消息，接收方可以伪造签名，发送方也可以否<br>认发送过某消息）。</p>
<p>&#x3D;&#x3D;<strong>非对称密码体制</strong>:&#x3D;&#x3D;</p>
<p>加密密钥是公开的，故称为公钥(public key)<br>解密密钥是秘密的，故称为私钥(private key)<br><u>具有鉴别功能</u></p>
<p>优点:网络中的每一个用户只需要保存自己的私钥个用户仅需产生对密钥。密钥少，便于管理;密钥分配简单，不需要秘密的通道和复杂的协议来传送密钥。公钥可基于公开的渠道（如密钥分发中心）分发给其他用户,而私钥则由用户自己保管;可以实现数字签名。</p>
<p>缺点:与对称密码体制相比，非对称密码体制的加密、解密处理速度较慢同等安全强度下密钥位数要求多一些。</p>
<p><u>非对称秘钥应用场景<strong>一</strong></u><br>&#x3D;&#x3D;<u><strong>数字签名</strong>:</u>[<u>防伪造、防抵赖</u>]&#x3D;&#x3D;<br>数宇签名是为了表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面。就像手写的签名一样，具有<strong>不可抵赖性</strong>和<strong>简洁性</strong>。<u>数字签名</u>是掌握<strong>非对称加密</strong>，并非纸质签名！！</p>
<p><u>非对称秘钥应用场景<strong>二</strong></u><br><u><strong>信息加密</strong>:</u><br>消息发送方用公钥加密消息，接收方用私钥解密。</p>
<p>对称密码体制加密解密使用<strong>相同</strong>的密钥；非对称密码体制的加密解密使用<strong>不相同</strong>的密钥，而且加密密钥和解密密钥要求<strong>不能</strong>相互推算。</p>
<p><strong>密钥(Key)</strong> :变换函数所用的一个控制参数。加密和解密算法的操作通常是在一组密钥控制下进行的<br>@@ &#x3D;&#x3D;数字签名可以做到<strong>防止发送方抵赖和接收方伪造</strong>&#x3D;&#x3D;；数字签名(公钥数字签名、电子签章)是一种类似卸载至上的普通的物理签名，但使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算。数字签名的作用：保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生 </p>
<h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><p>防火墙(Firewall）是设置在不同网络（如可信任的企业内部网和不可信的公共网)或网络安全域之间的一系列部件的组合。<br>&#x3D;&#x3D;<strong>防火墙</strong>可以记录Internet活动并防止内部信息泄露[<strong><u>日志可以记录操作</u></strong>]&#x3D;&#x3D;</p>
<p>(1)“隔离”:在不同信任级别的网络之间砌”墙”;<br>(2)“访问控制”:在墙上开“门”并派驻守卫，按照安全策略来进行检杳信息安全、新和放通</p>
<p><strong>基础组网和防护功能</strong><br>防火墙可以限制非法用户进入内部网络，比如黑客、网络破坏者等，禁止存在安全脆弱性的服务和未授权的通信数据包进出网络，并对抗各种攻击。</p>
<p><strong>记录监控网络存取与访问</strong><br>防火墙可以收集关于系统和网络使用和误用的信息并做出日志记录。通过防火墙可以很方便地监视网络的安全性，并在异常时给出报警提示。</p>
<p><strong>限定内部用户访问特殊站点</strong><br>防火墙通过用户身份认证来确定合法用户，并通过事先确定的完全检查策略，来决定内部用户可以使用的服务，以及可以访问的网站。</p>
<p><strong>限制暴露用户点</strong><br>利用防火墙对内部网络的划分，可实现网络中网段的隔离，防止影响一个网段的问题通过整个网络传播，从而限制了局部重点或敏感网络安全回题对全局网络造成的影响。</p>
<p><strong>网络地址转换</strong><br>防火墙可以作为部署NAT的逻辑地址，来缓解地址空间短缺的问题，并消除在变换ISP时带来的重新编址的麻烦。</p>
<p><strong>虚拟专用网</strong><br>防火墙支持具有Internet服务特性的企业内部网络技术体系虚拟专用网络(Virtual Private Network, VPN)。</p>
<p><u><strong>防火墙的不足是</strong>:</u><br>①不能防范不经过防火墙的攻击。<br>②不能防止来自网络内部的攻击和安全问题。<br>③由于防火墙性能上的限制,因此它通常不具备实时监控入侵的能力。<br>④不能防止策略配置不当或错误配置引起的安全威胁。<br>⑤不能防止受病毒感染的文件的传输。<br>⑥不能防止利用服务器系统和网络协议漏洞所进行的攻击。<br>⑦不能防止数据驱动式的攻击。<br>⑧不能防止内部的泄密行为。<br>⑨不能防止本身的安全漏洞的威胁。<br>⑩无法准确做到按内容过滤,无法检测加密的流量。</p>
<p>@@ <strong>防火墙</strong>是一种保护计算机网络安全的技术性措施，是一个用以控制进&#x2F;出两个方向通信的门槛</p>
<p>@@ 防火墙对数据包进行状态监测包过滤，&#x3D;&#x3D;不可以进行过滤的是<strong>数据包中的内容</strong>，可以过滤<strong>源和目的IP地址、源和目的端口、IP协议号</strong>&#x3D;&#x3D;</p>
<p>@@ 防火墙中<strong>地址翻译</strong>的主要作用是<strong>隐藏内部网络地址</strong></p>
<p>@@ 防火墙包括<strong>硬件+软件</strong>的技术</p>
<h4 id="反病毒技术"><a href="#反病毒技术" class="headerlink" title="反病毒技术"></a>反病毒技术</h4><p>反病毒概念:<br>反病毒是一种安全机制，它可以通过识别和处理病毒文件来保证网络安全，避免由病毒文件而引起的数据破坏、权限更改和系统崩溃等情况的发生。</p>
<p>计算机病毒的防治技术分成三个方面：&#x3D;&#x3D;<strong>病毒<u>预防</u>技术、病毒<u>检测</u>技术、病毒<u>消除</u>技术</strong>&#x3D;&#x3D;</p>
<p>计算机病毒的预防技术就是通过一定的技术手段防止计算机病毒对系统的传染和破坏。</p>
<p><em><u>防火墙：个人防火墙</u></em></p>
<hr>
<h2 id="新一代信息技术-0-5分-非重要题型"><a href="#新一代信息技术-0-5分-非重要题型" class="headerlink" title="新一代信息技术[0-5分] [非重要题型]"></a>新一代信息技术[0-5分] [非重要题型]</h2><p>新在哪里？[<strong>云计算、大数据、物联网、人工智能、区块链、人工智能</strong> ]</p>
<p>信息与物质、能量是客观世界的三大构成要素<br>信息是事物运动状态和特征的反映</p>
<p><strong>信息技术(Information Technology, 简称IT)</strong> 指的是用来扩展人们信息器官功能、协助人们更有效地进行信息处理的一门技术。</p>
<p>[扩展感觉器官功能的<strong>感测(获取)技术</strong>、扩展神经系统功能的<strong>通信技术</strong>、扩展大脑功能的<strong>计算与存储技术</strong>、扩展神经系统功能的<strong>通信技术</strong>、扩展效应器官功能的<strong>控制与显示技术</strong>]</p>
<h5 id="云计算定义-是-x3D-x3D-分布式计算、并行计算、网格计算-x3D-x3D-的一种"><a href="#云计算定义-是-x3D-x3D-分布式计算、并行计算、网格计算-x3D-x3D-的一种" class="headerlink" title="云计算定义 [是&#x3D;&#x3D;分布式计算、并行计算、网格计算&#x3D;&#x3D;的一种]"></a>云计算定义 [是&#x3D;&#x3D;分布式计算、并行计算、网格计算&#x3D;&#x3D;的一种]</h5><p>&#x3D;&#x3D;云计算是一种按<strong>使用量</strong><u>付费的模式</u>，这种模式提供<strong>可用的</strong>、<strong>便捷的</strong>、<strong>按需的网络访问</strong>，进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务)，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。&#x3D;&#x3D;</p>
<p><strong>云服务已经不单单是一种分布式计算，而是&#x3D;&#x3D;分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份荣誉和虚拟化&#x3D;&#x3D;等计算机技术混合演进并跃升的结果</strong></p>
<p>云计算是一种通过Internet以服务的方式提供动态可伸缩的虚拟化资源的计算模式，使人们像用电一样享用信息的应用和服务。<br>大型机时代 → PC时代 → 云计算时代</p>
<p>&#x3D;&#x3D;云计算解决方案带来<strong>简单化</strong>，<strong>平台化</strong>和<strong>有服务化</strong>&#x3D;&#x3D;</p>
<p>特征：<u><strong>自助式服务、随时随地使用、可度量的服务、快速资源扩缩、资源池化</strong></u></p>
<h5 id="云计算技术原理"><a href="#云计算技术原理" class="headerlink" title="云计算技术原理"></a>云计算技术原理</h5><p>使用特定的软件、按照指定的<strong>优先级</strong>和<strong>调度算法</strong>、将数据计算和数据存储分配到云计算集群中的各个节点计算机上，节点计算机并行运算，处理存储在本节点上的数据，结果回收合并。</p>
<h5 id="云计算服务模式"><a href="#云计算服务模式" class="headerlink" title="云计算服务模式"></a>云计算服务模式</h5><h6 id="x3D-x3D-IaaS核心技术-基础设施即服务-x3D-x3D-存储服务"><a href="#x3D-x3D-IaaS核心技术-基础设施即服务-x3D-x3D-存储服务" class="headerlink" title="&#x3D;&#x3D;IaaS核心技术  基础设施即服务&#x3D;&#x3D;[存储服务]"></a>&#x3D;&#x3D;IaaS核心技术  基础设施即服务&#x3D;&#x3D;[存储服务]</h6><p><u>虚拟化技术、<strong>分布式存储技术</strong>、高速网络技术、超大规模资源管理技术、云服务计费技术</u><br>[一台电脑当做N台来用] [虚拟化技术服务器整合]<br>虚拟化就是将多台低利用率的服务器上的负载整合到一台服务器上，使服务器硬件资源的利用率尽可能提高利用率</p>
<p><strong>亚马逊公司</strong>是著名的跨境电商，也是当前世界上<strong>最成功的IaaS服务提供者</strong>，拥有非常成功AWS云计算服务平台，为全世界范围内的客户提供云解决方案。</p>
<p>AWS面向用户提供包括弹性计算(存储、数据库、应用程序在内的一整套云计算服务，帮助企业降低投入成本和维护成本。<br>国内类似的有<strong>阿里云、腾讯云、华为云</strong>等。</p>
<h6 id="x3D-x3D-PaaS技术-平台即服务-x3D-x3D-向用户提供虚拟数据的操作系统，数据库管理系统，Web应用系统等服务"><a href="#x3D-x3D-PaaS技术-平台即服务-x3D-x3D-向用户提供虚拟数据的操作系统，数据库管理系统，Web应用系统等服务" class="headerlink" title="&#x3D;&#x3D;PaaS技术  平台即服务&#x3D;&#x3D;[向用户提供虚拟数据的操作系统，数据库管理系统，Web应用系统等服务]"></a>&#x3D;&#x3D;PaaS技术  平台即服务&#x3D;&#x3D;[向用户提供虚拟数据的操作系统，数据库管理系统，Web应用系统等服务]</h6><p>REST技术、<strong>多租户技术</strong>、并行计算技术、应用服务器技术、分布式缓存技术<br><strong>无处不在的网络接入</strong><br>类似的PaaS云平台还有谷歌的GAE (GoogleAppEngine)，支持Python语言、JAVA语言、Go语言和PHP语言等。<br>国内的还有云端软件开发协作平台(码云Gitee)、JEPaaS等。<br>@@ 在云计算服务中，<strong>PaaS</strong>向用户提供虚拟数据的操作系统，数据库管理系统，Web应用系统等服务</p>
<h6 id="x3D-x3D-SaaS核心技术-软件即服务-x3D-x3D"><a href="#x3D-x3D-SaaS核心技术-软件即服务-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;SaaS核心技术  软件即服务&#x3D;&#x3D;"></a>&#x3D;&#x3D;SaaS核心技术  软件即服务&#x3D;&#x3D;</h6><p>① 大规模多租户支持，运行在应用提供商SaaS上的应用能够同时为多个组织和用户使用，能保证用户之间的相互隔离。<u>没有<strong>多租户技术</strong>的支持</u>，SaaS就不可能实现<br>② 认证和安全，认证和安全是多租户的必要条件。当接收到用户发出的操作请求时，其发出请求的用户身份需要被认证，且操作的安全性需要被监控。<br>③ 定价和计费，定价和计费是SaaS模式的客观要求。提供合理、灵活、具体而便于用户选择的定价策略是SaaS成功的关键之一<br>④ 服务整合，它是SaaS长期发展的动力。SaaS应用提供商需要通过与其他产品的整合来提供整套产品的解决方案。<br>⑤ 开发和定制，开发和定制是服务整合的内在需要。一般来讲，每个SaaS应用都提供了完备的软件功能，但是为了能够与其他软件产品进行整合，SaaS应用最好具有一定的二次开发功能，包括公开API，提供沙盒以及脚本运行环境等。</p>
<p>@@ 简答:小亮创业开办公司不久，业务数据量激增，他想购买存储设备，但公司人手少、场地小、资金也不充裕。<br>小亮目前最迫切购买的是哪种服务，并简述理由。<br>小亮迫切购实的是云计算服务<br>【解析】云计算可以提供laaS,PaaS, SaaS服务</p>
<hr>
<h1 id="大数据-不可能处理完的数据"><a href="#大数据-不可能处理完的数据" class="headerlink" title="大数据[不可能处理完的数据]"></a>大数据[不可能处理完的数据]</h1><p>&#x3D;&#x3D;<u>大数据数据价值<strong>密度低，价值低，冗余大</strong></u>&#x3D;&#x3D;</p>
<p>大数据指的是所涉及的资料量规模巨大到无法通过主流软件工具，在合理时间内达到管理、处理并整理成为帮助企业经营决策更积极目的的资讯。</p>
<p>随着大数据时代的到来，“大数据” 已经成为互联网信息技术行业的流行词汇。<br>关于“什么是大数据”这个问题，大家比较认可关于大数据的”5V”说法。大数据的5个”V”，或者说是大数据的4个特点，包含5个层面：<br>&#x3D;&#x3D;<strong>数据量大(Volume)、数据类型繁多(Variety) 、真实性(Veracity)、处理速度快（Velocity)、价值密度低（Value)</strong>&#x3D;&#x3D;。[<strong>大多</strong>数都是<strong>真</strong>的<strong>快</strong>真的<strong>低</strong>]</p>
<p><strong>1.数据量大</strong><br>根据IDC作出的估测，数据一直都在以每年50%的速度增长，也就是说每两年就增长一倍(大数据摩尔定律)<br>人类在最近两年产生的数据量相当于之前产生的全部数据量。预计到2020年，全球将总共拥有35ZB的数据量，相较于2010年，数据量将增长近30倍</p>
<p><strong>2.数据类型繁多</strong>[结构不单一 ]<br>大数据是由结构化和非结构化数据组成的；10%的结构化数据，存储在数据库中；90%的非结构化数据，它们与人类信息密切相关</p>
<p><strong>3.处理速度快</strong><br>从数据的生成到消耗，时间窗口非常小，可用于生成决策的时间非常少1秒定律:这一点也是和传统的数据挖掘技术有着本质的不同</p>
<p><strong>4.价值密度低</strong><br>价值密度低人商业价值高以视频为例，连续不间断监控过程中，可能有用的数据仅仅有一两秒，但具目有很高的商业价值</p>
<h5 id="x3D-x3D-大-数据的影响-x3D-x3D"><a href="#x3D-x3D-大-数据的影响-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;大 数据的影响&#x3D;&#x3D;"></a>&#x3D;&#x3D;大 数据的影响&#x3D;&#x3D;</h5><p>一、&#x3D;&#x3D;<em><strong>全样而非抽样</strong></em>&#x3D;&#x3D;<br>过去由于数据存储和处理能力的限制，通常采用抽样的方法，来推断全集数据的总体特征。现在、大数据可以对全集数据进行处理。</p>
<p>二、&#x3D;&#x3D;<em><strong>效率而非精确</strong></em>&#x3D;&#x3D;<br>过去、采用抽样的方法，必须保证样本分析的精确性，以避免微小误差放大到全集数据。因此，传统的数据分析，先确保数据的精确性，其次才是提高算法的效率。<br>现在、大数据具有“秒极响应”特征，要求迅速给出分析结果，否则就会丧失数据的价值。</p>
<p>三、&#x3D;&#x3D;<em><strong>相关而非因果</strong></em>&#x3D;&#x3D;<br>过去、数据分析的目的，一方面是解释事物背后发展的机理;另一方面，用于预测未来可能发生的事情。<br>在大数据时代，人们追求“<strong>相关性</strong>”，而非“<strong>因果性</strong>“</p>
<p>大数据 &#x3D; 数据 + 大数据技术<br>大数据技术伴随着大数据的采集、存储、分析和应用的相关技术</p>
<p>需要指出的是，大数据技术是许多技术的一个集合体，这些技术也并非全部都是新生事物，诸如关系数据库、数据仓库、数据采集、ETL、OLAP、数据挖掘、数据隐私和安全、数据可视化等技术是已经发展多年的技术，在大数据时代得到不断补充、完善、提高后又有了新的升华，也可以视为大数据技术的一个组成部分。</p>
<h5 id="从数据分析全流程的角度，大数据技术主要包括："><a href="#从数据分析全流程的角度，大数据技术主要包括：" class="headerlink" title="从数据分析全流程的角度，大数据技术主要包括："></a>从数据分析全流程的角度，大数据技术主要包括：</h5><p>数据采集与预处理、数据存储和管理、数据处理与分析、数据安全和隐私保护等几个层面的内容。</p>
<p>(1)<strong>数据采集与预处理</strong><br>采集到的数据，通常无法直接用于后续的数据分析。[数据的抽取]<br>因为对于来源众多、类型多样数据而言，数据缺失和语译模糊等问题是不可避免，因而必须采取相应的措施来解决这些问题，这个过程就叫”数据预处理”。</p>
<p>(2)<strong>数据存储与管理</strong><br>利用分布式文件系统、数据仓库、关系数据库、NoSQL数据库、云数据等，实现对结构化、半结构化和非结构化海量数据的存储和管理。</p>
<p>(3)<strong>数据处理与分析</strong><br>利用分布式并行编程模式和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析; 对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据。</p>
<p>(4)<strong>数据安全与隐私保护</strong><br>在从大数据中挖掘潜在的<u>巨大商业价值</u>和<u>学术价值</u>的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全。</p>
<p>(5)<strong>大数据计算模式</strong><br>大数据计算模式，即依据大数据的不同数据特征和计算特征，从多样性的大数据计算问题和需求中提炼并树立的各种高层笼统或模型。依据大数据处置多样性的需求和以上不同的特征维度，目前呈现了多种典型和重要的大数据计算形式。</p>
<p>批处理计算：Spark是一个针对超大数据集合的低延迟的集群分布式计算系统，比MapReduce快许多。Spark启用了内存分布数据集，除了能够提供交互式查询外，还可以优化迭代工作负载。</p>
<p>&#x3D;&#x3D;<strong>批量处理</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>流计算</strong>&#x3D;&#x3D;<br>流数据也是大数据分析中的重要数据类型。流数据(或数据流)是指在时间分布和数量上无限的一系列动态数据集合体，数据的价值随着时间的流逝而降低，因此必须采用实时计算的方式给出秒级响应。</p>
<p>目前业内已涌现出许多的流计算框架与平台:<br>第一类是商业级的流计算平台，包括IBM InfoSphere Streams等;<br>第二类是开源流计算框架，包括Twitter Storm、Yahoo! S4、Spark Streaming等;<br>第三类是公司为支持自身业务开发的流计算框架，如Facebook使用Puma和HBase相结合来处理实时数据，百度开发了通用实时流数据计算系统DStream，<strong>淘宝开发了通用流数据实时计算系统——银河流数据处理平台。</strong></p>
<p>&#x3D;&#x3D;<strong>图计算</strong>&#x3D;&#x3D;<br>在大数据时代，许多大数据都是以<strong>大规模图</strong>或<strong>网络的形式</strong>呈现，如社交网络、传染病传播途径、交通事故对路网的影响等，此外，许多非图结构的大数据也常常会被转换为图模型后再进行处理分析。Pregel主要用于图遍历、最短路径、PageRank计算等。其他代表性的图计算产品还包括:<br>Facebook针对 Pregel的开源实现 Giraph；Spark下的 GraphX;  图数据处理系统PowerGraph等。</p>
<p><strong>大数据应用</strong><br>大数据产业是指一切与支撑大数据组织管理和价值发现相关的企业经济活动的集合。大数据产业包括IT基础设施层、数据源层、数据管理层、数据分析层、数据平台层和数据应用层。</p>
<p><u>数据源层</u>：大数据生态圈里的数据提供者，是生物(生物信息学领域的各类研究机构）大数据、交通(交通主管部门）大数据、医疗(各大医院、体检机构）大数据、政府（政府部门）大数据、电商（淘宝、天猫、苏宁云商、京东等电商)大数据、社交网络(微博、微信、人人网等)大数据、搜索引擎(百度、谷歌等)大数据等各种数据的来源。</p>
<p><u>数据管理层</u>：包括数据抽取、转换、存储和管理等服务的各类企业或产品,如分布式文件系统（如Hadoop的HDFS和谷歌的GFS)、ETL工具(lnformatica、Datastage、Kettle等)、数据库和数据仓库(Oracle、MySQL、SQL Server、HBASE、GreenPlum等)</p>
<p><u>数据分析层</u>：包括提供分布式计算、数据挖掘、统计分析等服务的各类企业或者产品，如分布式计算框架MapReduce、统计分析软件SPSS和SAS、数据挖掘工具Weka、数据可视化。</p>
<p><u>数据应用层</u>：提供智能交通、智慧医疗、智慧物流、智能电网等行业应用的企业、机构或政府部门，如交通主管部门、各大医疗机构、菜鸟网络、国家电网等。</p>
<p>大数据（Big Data)、人工智能(Artificial Intelligence)、物联网(lnternet of Things）和区块链（Blockchain)<br>等新兴技术的融合突破了传统健康医疗应用在数据分析、数据安全和数据采集方面的局限，协同开启了多元化的健康医疗应用市场。</p>
<hr>
<h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h1><p>简单理解：物物相连的互联网，即物联网。<br>物联网在国际上又称为传感网，万事万物，小到手表、钥匙，大到汽车、楼房，只要嵌入个微型感应芯片，把它变得智能化,这个物体就可以”自动开口说话”。再借助无线网络技术，人们就可以和物体“对话”，物体和物体之间也能”交流”，这就是物联网。<br>互联网，RFID技术，EPC标准，在计算机互联网的基础上，利用射频识别技术，无线数据通信技术等，构造了一个实现全球物品信息实时共享的实物互联网。</p>
<p>&#x3D;&#x3D;<strong>三大特征</strong>：<u>全面感知、可靠传递、智能处理</u>&#x3D;&#x3D;</p>
<hr>
<h5 id="公认的物联网定义"><a href="#公认的物联网定义" class="headerlink" title="公认的物联网定义"></a>公认的物联网定义</h5><p>1.通过射频识别装备，红外传感器，全球定位系统GPS，激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化&#x3D;&#x3D;<strong>识别，定位，跟踪，控制和管理</strong>&#x3D;&#x3D;的一种网络。</p>
<p>2.当每个而不是每种物品能够被唯一标识后，利用识别、通信和计算等技术，在互联网基础上，构建的连接各种物品的网络，就是人们常说的物联网</p>
<p>&#x3D;&#x3D;<u>物联网中的“物”的涵义要满足以下条件才能够被纳入“物联网”的范围:</u>&#x3D;&#x3D;</p>
<blockquote>
<p><strong>要有相应信息的接收器</strong><br><strong>要有数据传输通路</strong><br><strong>要有一定的存储功能</strong><br><strong>要有CPU</strong><br><strong>要有操作系统</strong><br><strong>要有专门的应用程序要有数据发送器</strong><br><strong>遵循物联网的通信协议</strong><br><strong>在世界网络中有可被识别的唯一编号</strong></p>
</blockquote>
<h5 id="物联网的形成与发展"><a href="#物联网的形成与发展" class="headerlink" title="物联网的形成与发展"></a>物联网的形成与发展</h5><p><strong>智能家居:</strong><br>家庭自动化、智能路由、安全监控、智能厨房、家庭机器人、传感检测、智能宠物、智能花园、跟踪设备;<br><strong>智能交通:</strong><br>车联网、智能自行车&#x2F;摩托车(头盔设备)、无人驾驶、无人机、太空探索;<br><strong>企业应用</strong>:<br>医疗保健.零售、克付&#x2F;信用卡、智能办公室、现代农业、建筑施工;<br><strong>产业互联网:</strong><br>现代制造、能源工业、供应链、工业机器人、工业可穿戴设备（智能安全帽等)</p>
<p>物联网的发展跟互联网是分不开的，主要两个层面的意思:<br>第一，物联网的核心和基础依然是互联网，他是在互联网的基础上的延伸和扩展;<br>第二，物联网是比互联网更加庞大的网络，其网络连接延伸到了任何物品与物品之间，这些物品可以通过各种信息传感设备与互联网连接在一起，进行更为复杂的信息交换和通信</p>
<p>物联网有三大特征：<strong>全面感知</strong>[感知方式(部分)、感知信息(二维码、湿度、温度)]；<strong>可靠传递</strong>；<strong>智能处理</strong></p>
<p>物联网是典型的交叉学科，它所涉及的核心技术包括IPv6技术、云计算技术、传感技术、RFID智能识别技术、无线通信技术等。<br>因此，从技术角度讲，物联网专业主要涉及的专业有:计算机科学与工程、电子与电气工程、电子信息与通讯、自动控制、遥感与遥测、精密仪器、电子商务等等。</p>
<h4 id="物联网的层次结构"><a href="#物联网的层次结构" class="headerlink" title="物联网的层次结构"></a>物联网的层次结构</h4><p>&#x3D;&#x3D;<strong>应用层</strong>&#x3D;&#x3D;<br>物联网应用：环境监测、智能电力、智能交通、工业控制    物联网业务中间件<br>**<u>应用层</u>**类似于人类社会的”分工”包括应用基础设施&#x2F;中间件和各种物联网应用，应用基础设施&#x2F;中间件为物联网应用提供信息处理、计算等通用基础服务设施、能力及资源调用接口，以此为基础实现物联网在众多领域的各种应用<br><em><strong>应用层的关键技术：</strong>云计算技术、软件和算法、信息和隐私安全技术、标识和解析技术</em></p>
<blockquote>
<p><strong>1、云计算</strong><br>在这里，云计算和物联网进行深度融合。</p>
<p><strong>2、软件和算法</strong><br>软件和算法在物联网的信忌处理和应用木A十A工云向昵名的物联网智慧性的集中体现。这其中的关键技术主要包括面向服务的<br>体系架构(SOA)和中间件技术，重点包括各种物联网计算系统的感知信息处理、交互与优化软件与算法、物联网计算系统体系结构与软件平台研发等。<br>**面向服务的体系架构(**Service-oriented Architecture,SOA)是一种松耦合的软件组件技术，它将应用程序的不同功能模块化，并通过标准化的接口和调用方式联系起来，实现快速可重用的系统开发和部署。中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。</p>
<p><strong>3、信息和隐私安全技术</strong><br>安全和隐私技术包括安全体系架构、网络安全技术“智能物体”的广泛部署对社会生活带来的安全威胁<br>隐私保护技术、安全管理机制和保证措施等。<br>为实现对物联网广泛部署的”智能物体”的管理，需要进行网络功能和适用性分析，开发适合的管理协议。</p>
<p><strong>4、标识和解析技术</strong><br>是对物理实体、通信实体和应用实体赋予的或其本身固有的一个或-组属性，并能实现正确解析的技术。<br>物联网的标示主要包括物体标示和通信标示，物联网标识和解析技术涉及不同的标识体系、不同体系的互操作、全球解析或区域解析、标识管理等。</p>
<hr>
</blockquote>
<p>&#x3D;&#x3D;<strong>网络层</strong>&#x3D;&#x3D;<br>移动通信网、互联网和其他网：下一代承载网、互联网、专网、异构网融合<br><u><strong>网络层</strong>主要实现信息的传递、路由和控制，包括延伸网、接入网和核心网，网络层可依托公众电信网和互璇网.也可以依托行业专用通信网络。</u><br><em><strong>网络层关键技术：</strong>ZigBee、WIFI无线网络、蓝牙技术、GPS技术</em></p>
<blockquote>
<p><strong>1.ZigBee【<u>仿生学</u>】</strong><br>ZigBee技术是一种<strong>近距离、低复杂度、低功耗、低速率、低成本的双向无线通讯技术。</strong>这一名称来源于蜜蜂的八字舞由于蜜蜂(bee)是靠飞翔和”嗡嗡”(zig)地抖动翅膀的”舞蹈”来与同伴传递花粉所在方位信息，也就是说蜜蜂依靠这样的方式构成了群体中的通信网络。<br>ZigBee网络主要特点是低功耗、低成本、时延短、网络容量大、可靠、安全。主要适合用于自动控制和远程控制领域可以嵌入各种设备。<br>ZigBee协调器Coordinator )<br>ZigBee路由器)( Router)<br>ZigBee终端设备(End-device)<br>一个Zigbee网络由一个协调器节点、多个路由器和多个终端设备节点组成。<br>【家庭、楼宇自动化以及监控类应用】</p>
<p><strong>2.WIFI无线网络</strong><br>Wi-Fi是一种可以将个人电脑、手持设备(如PDA、手机)等终端以无线方式互相连接的技术。<br>WIFI突出优势：<br>其一，无线电波的覆盖范围广<br>其二，传输速度非常快<br>其三，厂商进入该领域的门槛比较低</p>
<p><strong>3.蓝牙技术</strong><br>蓝牙，是一种支持设备短距离通信(-般10m内)的无线电技术。能在包括移动电话、PDA、无线耳机、笔记本电脑、相关外设等众多设备之间进行无线信息交换。</p>
<p>蓝牙应用—蓝牙耳机<br>① 手机中的解码芯片对MP3等音乐文件进行解码，产生数字信号并通过蓝牙发送给蓝牙耳机;<br>② 蓝牙耳机接收数字信号，并通过蓝牙耳机内部的数模转换芯片，把它转换成人耳能听懂的模拟信号<br>③ 将模拟信号进行放大，需要用到耳机内部的信号放大芯片<br>④ 耳机单元接收放大后的信号并出声音，此时耳朵便听到了音乐声<br><u>替代有线</u>：遥感勘测、移动电子商务、数字电子设备、工业控制、智能化建筑、家庭和办公自动化、电子商务、无线公文包、军事</p>
<p>4.GPS技术<br>GPS (Global Positioning System,全球定位系统)定利用P定位卫星，在全球范围内实时进行定位、导航的系统。全球四大卫星导航系统:美国全球定位系统(GPS)、俄罗斯”格洛纳斯”系统、欧洲”伽利略”系统、<strong>中国”北斗”系统</strong>。</p>
</blockquote>
<p>&#x3D;&#x3D;<strong>感知层</strong>&#x3D;&#x3D;<br>数据处理：地距离和中高速短距离传输技术、自组织组网技术、协同信息处理技术、传感网中间件技术<br>数据采集：传感器、二维码&#x2F;条码、RFID、多媒体信息<br><u><strong>感知层</strong>实现对物理世界的智能感知识别、信息采集处理和自动控制,并通过通信模块将物理实体连接到网络层和应用层</u><br><strong>感知层的关键技术</strong>：RFID技术、条形码传感器技术、无线传感器网络技术、产品电子码<em>EPC</em></p>
<blockquote>
<p><strong>1.RFID技术</strong>【信息的采集识别】<br>RFID(Radio Frequency ldentification)，即<strong>射频识别</strong>，俗称电子标签。RFID射频识别是一种**<u>非接触式的自动识别技术</u>**，可识别高速运动物体并可同时识别多个标签，操作快捷方便。通过射频信号自动识别对象并获取相关数据完成信息的自动采集工作,RFID是物联网最关键的一个技术，它为物体贴上电子标签，实现高效灵活的管理。</p>
<p>1)标签(Tag):由耦合元件及芯片组成，每个标签具有唯一的电子编码，附着在物体上标识目标对象;<br>2)阅读器(Reader)或读写器:读取(有时还可以写入)标签信息的设备，可设计为手持式或固定式;<br>3)天线(Antenna):在标签和读取器间传递射频信号</p>
<p>RFID手持机[<u>快递标签打印机</u>]。读写感应器(冲水卡)。</p>
<p>RFID工作原理<br>标签进入磁场古、接收解a读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息(Passive Tag,无源标签或被动标签)，或者主动发送某一频率的信号(Active Tag,有源标签或主动标签);解读器读取信息并解码后，送至中央信息系统进行有关数据处理。</p>
</blockquote>
<blockquote>
<p><strong>2.条码技术</strong><br>条形码是一种信息的图形化处理方法，可以把信息复制成条形码，然后用相应的扫描设备将其中信息输入到计算机中</p>
<p>条形码分为一维条码和二维条码:<br>一维条形码将宽度不等的多个黑条和空白，按一定的编码规则排列，用以表达一组信息的图形标识符。<br>二维条形码是在二维空间水平和竖直方向存储信息的条形码。它的优点是信息容量大，译码可靠性高，纠错能力强，制作成本低，保密与防伪性能好。</p>
</blockquote>
<blockquote>
<p><strong>3.传感器技术</strong><br>传感器是指能感知预定的被测指标并按照一定规律转换成可用信号的器件和装置，通常由敏感元件和转换元件组成。</p>
</blockquote>
<blockquote>
<p><strong>4.无线传感器技术</strong><br>无线传感器网络(WSN, wireless sensor network)<br>多个功能<strong>节点</strong>之间通过无线通信形成一个连接的网络，这个网经我们称为无线传感器网络。<br>它是集分布式信息采集、信息传输和信息处理技术于一体的网络信息系统，以其低成本、微型化、低功耗和灵活的组网方式、铺设方式以及适合移动目标等特点受到广泛重视，是关系国民经济发展和国家安全的重要技术。</p>
<h6 id="无线传感器网络中主要包含两类节点"><a href="#无线传感器网络中主要包含两类节点" class="headerlink" title="无线传感器网络中主要包含两类节点:"></a>无线传感器网络中主要包含两类节点:</h6><p><strong>传感器节点</strong>:  具有感知和通信功能的节点，在传感器网络中负责监控标区域并获取数据，以及完成与其他传感器节点的通信，能够对数据进行简单的处理。<br><strong>Sink节点：</strong>又称为<u><strong>基站节点</strong></u>，负责汇总由传感器节点发送过来的数据，并作进一步数据融合以及其他操作，最终把处理好的数据上传至互联网。</p>
<h6 id="无线传感器网络三种常见拓扑结构："><a href="#无线传感器网络三种常见拓扑结构：" class="headerlink" title="无线传感器网络三种常见拓扑结构："></a>无线传感器网络三种常见拓扑结构：</h6><p><strong>星型拓扑：</strong>具有组网简单、成本低; 但网络覆盖范围小，一旦sink节点发生故障，所有与sink节点连接的传感器节点与网络中心的通信都将中断。星形拓扑结构组网时，电池的使用寿命较长。<br><strong>网状拓扑：</strong>具有组网可靠性高、覆盖范围大的优点但电池使用寿命短、管理复杂。<br><strong>树状拓扑：</strong>具有星形和网状拓扑的一些特点，既保证了网络覆盖范围大，同时又不至于电池使用寿命过短，更加灵活、高效。</p>
<p>无线传感器网络的应用领域<br><strong>1、军事领域的应用</strong><br>在军事领域，由于WSN具有密集型、随机分布的特点，使其非常适合应用于恶劣的战场环境。利用WSN能够实现监测敌军区域内的兵力和装备、实时监视战场状况、定位目标、监测核攻击或者生物化学<br><strong>2、辅助农业生产</strong><br>WSN特别适用于以下方面的生产和科学研究。<br>例如，大棚种植室内及土壤的温度、湿度、光照监测、珍贵经济作物生长规律分析、葡萄优质育种和生产等，可为农村发展与农民增收带来极大的帮助。采用WSN建设农业环境自动监测系统，用一套网络设备完成风、光、水、电、热和农药等的数据采集和环境控制，可有效提高农业集约化生产程度，提高农业生产种植的科学性。<br><strong>3、在生态环境监测和预报中的应用</strong><br>在环境监测和预报方面，无线传感器网络可用于监视农作物灌溉情况、土壤空气情况、家畜和家禽的环境和迁移状况、无线土壤生态学、大面积的地表监测等，可用于行星探测、气象和地理研究、洪水监测等。基于无线传感器网络，可以通过数种传感器来监测降雨量、河水水位和土壤水分，并依此预测山洪爆发描述生态多样性，从而进行动物栖息地生态监测。还可以通过跟踪鸟类、小型动物和昆虫进行种群复杂度的研究等。</p>
<p><strong>4、在医疗系统和健康护理中的应用</strong><br>无线传感网技术通过连续监测提供丰富的背景货料并做预警响应，不仅有望解决这一问题还可大大提高医疗的质量和效率。无线传感网集合了微电子技术、嵌入式计算技术、现代网络及无线通信和分布式信息处理等技术，能够通过各类集成化的微型传感器协同完成对各种环境或监测对象的信息的实时监测、感知和采集。</p>
<p><strong>5、产品电子代码EPC</strong><br>EPC系统(物联网)是在计算机互联网和射频技术RFID的基础上,利用**<u>全球统标识系统编码技术给每一个实体对象个唯一的代码</u>**，构造了一个实现全球物品信息实时共享的实物互联网”Internetof things”。</p>
</blockquote>
<p>&#x3D;&#x3D;<strong>@@ 物联网技术作为智慧城市建设的重要技术，其架构一般可分为<u>感知层</u>，其中<u>网络层和应用层</u>负责信息采集和物物之间的信息传输。</strong>&#x3D;&#x3D;</p>
<h4 id="物联网应用"><a href="#物联网应用" class="headerlink" title="物联网应用"></a>物联网应用</h4><ul>
<li><strong>智慧物流</strong>[存储、运输、快递监测]</li>
<li><strong>智能交通</strong>[共享单车、车联网、智能红绿灯、充电桩监测]</li>
<li><strong>智能安防</strong>[智能安防系统：门禁、报警、监控]</li>
<li><strong>智慧能源环保</strong>[只能井盖监测水位状态、智能水电表实时远程抄表]</li>
<li><strong>智能医疗</strong>[医疗设备、用品可视化]</li>
<li><strong>智慧建筑</strong>[用电照明、消防监测、智慧电梯、楼宇检测、古建筑领域白蚁监测]</li>
<li><strong>智能制造</strong>[工厂机械设备监控、(化工)工厂环境监控 (厂房的环境主要是<strong>采集温湿度，烟感</strong>)]</li>
<li><strong>智能家居</strong>[智能家居系统平台发展]</li>
<li><strong>智能零售</strong>[无人售货机、无人便利店]</li>
<li><strong>智慧农业</strong>[农业种植、畜牧养殖]</li>
</ul>
<p>物联网中传感器节点是在传感器基础上增加了协同计算、通信功能构成了具有感知能力、计算能力和通信能力的传感器节点。智能化是传感器的重要特点，嵌入式智能技术是实现传感器智能化的重要手段。</p>
<p>EPC系统主要由如下六方面组成:</p>
<blockquote>
<p>(1) EPC编码标准<br>(2) EPC标签<br>(3) 识读器<br>(4) Savant(神经网络软件)<br>(5) 对象名解析服务(Object Naming Service: ONS)<br>(6) 实体标记语言(Physical Markup Language PML)</p>
</blockquote>
<p>@@ 在物联网的关键技术中，射频识别(RFID)是一种<strong>信息采集技术</strong></p>
<h6 id="公共支撑技术"><a href="#公共支撑技术" class="headerlink" title="公共支撑技术"></a>公共支撑技术</h6><p>标识解析、安全技术、信息安全、网络管理</p>
<hr>
<h3 id="人工智能-智能化"><a href="#人工智能-智能化" class="headerlink" title="人工智能[智能化]"></a>人工智能[智能化]</h3><p><u><strong>AlphaGo、ChatGPT 阿尔法狗</strong></u></p>
<p>&#x3D;&#x3D;人工智能&gt;机器学习&gt;深度学习&gt;神经网络;<br>主要应用在：智能处理; 图像处理; 机器视觉; 新闻、电影、音乐、购物推荐，人脸检测，机器人，自动驾驶等等。&#x3D;&#x3D;<br><u>人工智能之父</u>：<strong>图灵</strong></p>
<p>@@ <strong>推动人工智能发展的三要素</strong>：<u>&#x3D;&#x3D;<strong>数据、算力、算法</strong>&#x3D;&#x3D;</u>推动了AI的发展<br>@@ 人工智能是一门<strong>综合性交叉学科和边缘学科</strong></p>
<h6 id="机器人三定律"><a href="#机器人三定律" class="headerlink" title="机器人三定律"></a>机器人三定律</h6><p>第一定律：机器人不得伤害人类个体，或者目睹人类个体将遭受危险而袖手不管<br>第二定律：机器人必须服从人给予它的命令，当该命令与第一定律冲突时例外<br>第三定律：机器人在不违反第一、第二定律的情况下要尽可能保护自己的生存</p>
<h5 id="人工智能的概念"><a href="#人工智能的概念" class="headerlink" title="人工智能的概念"></a>人工智能的概念</h5><p>人工智能的定义描述包括以下5种:<br>1、人工智能是不可思议的计算机程序，是机器可以完成人们认为机器不能胜任的事。<br>2、人工智能是与人类思考方式相似的计算机程序，能够遵照思维里的逻辑规律进行思考。<br>3、人工智能是与人类行为相似的计算机程序，只要计算机程序的功能表现与人类在类似环境下行为相似则可以认为该程序是该领域的人工智能程序。<br>4、工智能是会学习的计算机程序，这一定义也符合人类认知的特点，人类的智慧离不开不断的学习。<br>5、人工智能是根据对环境的感知，做出合理的行动，并获得最大收益的计算机程序。</p>
<p>人工智能分为：“<u><strong>弱人工智能、强人工智能、超人工智能</strong></u>”</p>
<p>概念的表示：知识由概念组成，概念是构成人类知识世界的基本单元</p>
<h5 id="机器学习可以分为五个大类："><a href="#机器学习可以分为五个大类：" class="headerlink" title="机器学习可以分为五个大类："></a>机器学习可以分为五个大类：</h5><ul>
<li><strong>监督学习</strong>(SupervisedLearning)：一从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果，动物识别为监督学习。</li>
<li><strong>无监督学习</strong>(Unsupervisedlearning) ：无监督学习与监督学习相比，训练集没有人为标注的结果</li>
<li><strong>半监督学习</strong>(Semi-SupervisedLearning) :这是——种介于监督学习与无监督学习之间的方法。</li>
<li><strong>迁移学习</strong>(TransferLearning):将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集。</li>
<li><strong>增强学习</strong>(Reinforcementlearning) :通过观察周围环境来学习。</li>
</ul>
<p>深度学习(deep learning)中的重要分支一神经网络，或称人工神经网络(artificial neural network,ANN)。<br>1943年，心理学家McCulloch和数学家Pitts参考了生物神经元的结构，发表了抽象的神经元模型MP</p>
<p>人的大脑细胞约有$10^{14}$个</p>
<p><strong>深度学习所涉及的技术主要有:</strong></p>
<blockquote>
<p>线性代数、概率和信息论、欠拟合、过拟合、正则化、最大似然估计和贝叶斯统计、随机梯度下降、监督学习和无监督学习、深度前馈网络、代价函数和反向传播、正则化、稀疏编码和dropout、自适应学习算法、卷积神经网络、循环神经网络、递归神经网络。深度神经网络和深度堆叠网络、LSTM长短时记忆、主成分分析、上自动编码器、表征学习、蒙特卡洛、受限波兹曼机、深度置信网络、softmax回归、决策树和聚类算法、KNN和SVM、生成对抗网络和有向生成网络、机器视觉和图像识别、自然语言处理、语音识别和机器翻译、有限马尔科夫、动态规划、梯度策略算法和增强学习(Q-learning)等等。</p>
</blockquote>
<p><strong>卷积神经网络</strong>(Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络，是深度学习的代表算法之一。<br><strong>卷积神经网络依次为</strong>：输入层–&gt;卷积层-→&gt;最大池化层-&gt;卷积层-&gt;最大池化层-&gt;全连接层-→&gt;输出层<br>【可以在人脸领域大规模应用】</p>
<h5 id="应用深度学习的神经网络进行人脸识别技术原理主要是三大步骤"><a href="#应用深度学习的神经网络进行人脸识别技术原理主要是三大步骤" class="headerlink" title="应用深度学习的神经网络进行人脸识别技术原理主要是三大步骤:"></a>应用深度学习的神经网络进行人脸识别技术原理主要是三大步骤:</h5><blockquote>
<p>一是建立一个包含大批量人脸图像的数据库<br>二是通过各种方式来获得当前要进行识别的目标人脸图像<br>三是将目标人脸图像与数据库中既有的人脸图像进行比对和筛选</p>
</blockquote>
<h5 id="一个完整的视频流人脸识别系统"><a href="#一个完整的视频流人脸识别系统" class="headerlink" title="一个完整的视频流人脸识别系统"></a>一个完整的视频流人脸识别系统</h5><blockquote>
<p>通过OpenCV抓取摄像头的视频流<br>通过MTCNN对每帧图片进行人脸检测和对齐，设置每n个间隔帧进行一次检测<br>通过facenet预训练模型对第二步得到的人脸进行512未的特征值提取<br>收集目标数据集来训练自己的分类模型<br>将第三步得到的512维的特征值作为第四步的输入然后输出，即为人脸识别结果</p>
</blockquote>
<h5 id="人工智能的应用"><a href="#人工智能的应用" class="headerlink" title="人工智能的应用"></a>人工智能的应用</h5><p>智能助理、图像处理、机器视觉、客服服务、安全防护、AI艺术、新一代搜索引擎、机器翻译、自动驾驶、机器人</p>
<h2 id="区块链概述-非对称加密-数字签名"><a href="#区块链概述-非对称加密-数字签名" class="headerlink" title="区块链概述[非对称加密 数字签名]"></a>区块链概述[<u>非对称加密</u> 数字签名]</h2><p>&#x3D;&#x3D;<strong>区块链</strong>[起源于<strong>比特币</strong>]&#x3D;&#x3D;是一个信息技术领域的属于。从本质上讲，它是一个共享数据库，存储于其中的数据或信息。具有&#x3D;&#x3D;<strong>去中心化<del>服务器分布在各地</del>、不可伪造、全程留痕、可以追溯、公开透明、集体维护、合作信任</strong>&#x3D;&#x3D;</p>
<p><strong>价值转移</strong><br>将某一部分价值从A地址转移到B地址，需要A地址精确地减少了这部分价值，而B地址精确地增加了这部分价值。这就是区别于信息转移的价值转移。目前的互联网协议是不支持价值转移功能的。<br>所以，目前的价值往往不是直接传输，而是由一个中心化的第三方来做背书</p>
<p>&#x3D;&#x3D;<strong>区块链是一种按照时间顺序将数据区块以<u>顺序相连的方式</u>组合成的一种<u>链式数据结构</u>，并以密码学方式保证的<u>不可篡改</u>和<u>不可伪造</u>的<u>分布式账本</u>。主要解决交易的信任和安全问题</strong>&#x3D;&#x3D;</p>
<h5 id="区块链技术优势-比特币是区块链的应用"><a href="#区块链技术优势-比特币是区块链的应用" class="headerlink" title="区块链技术优势[比特币是区块链的应用]"></a>区块链技术优势[比特币是区块链的应用]</h5><p>&#x3D;&#x3D;<u>分布式、可共享、隐私性、防篡改</u>&#x3D;&#x3D;</p>
<p><strong>区块链技术的出现</strong>[一个社区的人互相交易记账金额]<br>为快速完成信用建设，实现低成本且安全的价值转移，区块链技术就这样应运而生了。<br>&#x3D;&#x3D;区块链是一个<strong>去中心</strong>化的<strong>分布式帐本</strong>&#x3D;&#x3D;，每个参与者都是一个节点，每个节点都保存着一份相同的帐本，一旦对帐本进行修改，就需要对所有节点的帐本都进行修改。<br>区块链可以在没有第三方信用背书的情况下，在一个开放式的平台上进行远距离的安全支付。<br>&#x3D;&#x3D;<strong>区块链技术的优势</strong>是：<strong>去中心、去国界、透明、能够重构一种新的征信体系</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;<strong>区块链的密码技术</strong>主要是：<strong>数字签名算法、哈希算法</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;<strong>区块链的技术分类</strong>主要是：<strong>公有链、联盟链、私有链</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;<em><strong><u>分布式账本的特征</u></strong></em> ：<u>点对点、抗毁坏、防篡改、全透明</u>&#x3D;&#x3D;</p>
<p><strong>区块链技术的出现区块链信用建设特点</strong><br>1)<strong>区块链是分布式的</strong>，区块链公信力在网络上会有许多独立的节点，每一节点都有一份备份信息。每个有授权的人都可以从任意一个节点下载全部的信息，同时，<u>区块链公信力网络也是不可篡改的</u>。<br>2)在区块链公信力模型中，区块链不制定政策，它<u><strong>使用算法证明机制来保证他的公证人的角色</strong></u>，它实际上是用基于共识的数学方法，在机器之间建立信任并完成信用创造。</p>
<p><strong>区块链系统用户为何记账</strong><br>每一个区块链系统中的用户，都可以去记账，记账的奖励则有两个来源：<strong>手续费</strong>和<strong>打包奖励</strong><br>每个区块都只能由一个人打包</p>
<p><strong>区块链系统如何解决防伪问题</strong><br>1、如何保证区块链上的交易记录是真实的?(身份认证问题)<br>我们必须保证<u>每一条记录都是由”货币”持有者</u>所发出的，而不是由其他人伪造的。<br>&#x3D;&#x3D;<strong>非对称加密</strong>：[数字签名]公钥和私钥    要使用<strong>特定私钥</strong>去对应打开公钥才可看到信息&#x3D;&#x3D;<br>[加密用公钥、解密用私钥]在实际运用中，私钥可以对一串字符进行加密，而公钥可以把私钥加密后的内容解密。<br>私钥必须由用户个人保存好，不能告诉他人。而公钥和地址都是公开的，如果用户想让别人给他钱，只需给对方一个地址即可，如果用户想给别人钱，用户需要将自己的公钥和地址一起发送过去。<br><u>私钥不能通过公钥推导出来</u>    <strong><u>私钥 → 公钥 → 公钥has → 地址</u></strong></p>
<h5 id="3、如何避免双重支付"><a href="#3、如何避免双重支付" class="headerlink" title="3、如何避免双重支付?"></a>3、如何避免双重支付?</h5><blockquote>
<p>举例来说，假设A只有10元钱，但是他几乎同时广播了两条消息，第一条消息是”A付10元钱给B”，第二条消息是”A付10元钱给C<br>此时网络中的用户由于一定的延迟效应，有一部分会先接收到第一条消息，而另一部分会先接收到第二条消息。先接收到第一条消息的用户会对A进行余额检查，所以再接收到第二条消息时，这部分用户就会拒绝第二条消息。同理，先接收到第二条消息的用户也会拒绝后接收到的第一条消息。</p>
</blockquote>
<h5 id="4、如何防止篡改已存在的记录"><a href="#4、如何防止篡改已存在的记录" class="headerlink" title="4、如何防止篡改已存在的记录?"></a>4、如何防止篡改已存在的记录?</h5><blockquote>
<p>是否存在一种可能，A在之后将已经存在的记录删掉或篡改呢?<br>下面将介绍一个解决此问题的原则—-<strong>最长链原则</strong><br><u>所有用户都只承认最长的那根链条，并默认在最长链后继续挖矿和接块。</u></p>
</blockquote>
<blockquote>
<p>A希望抹掉”A付10元钱给B”这个已经存在于链上的信息。举例来说，A的方法是重新打包一个不包含”A付10元钱给B”信息，反而包含”B付10元钱给A”信息的包，并且以这个信息包去重新计算数学题，再重新打一个包，造出一个支链，这个支链上，原信息”A付10元钱给B”就被篡改了。<br>包含篡改信息的区块虽然也被连到了链上，但由于最长链原则，这个支链并不被世界承认，除非A的计算能力超过了世界上其余所有的人算力之和，那A通过不断努力去延长新的支链，使其最终超过主链长度，才能够完成已有信息的篡改，但现实中这种算力集中情况不可能出现。</p>
</blockquote>
<h4 id="区块链应用"><a href="#区块链应用" class="headerlink" title="区块链应用"></a>区块链应用</h4><ol>
<li><strong>区块链电子发票</strong><br>[1.写入开票规则，核准和管控；2.链上申领发票，写入交易订单和身份识别；链上认领发票，更新身份标识；4.验收发票，审核入账，支付报销款]</li>
</ol>
<blockquote>
<p>其次，实现了无纸化报销，因为发票全流程的信息都在链上，报销时只要链上更新发票状态即可，无须再打印为纸质的文件存档；<br>再次，解决了一票多报、虚抵虚报的问题，利用区块链技术，可以确保发票的唯一性和信息记录的不可篡改性；<br>最后，其可以帮助政府部门提升监管力度。</p>
</blockquote>
<ol start="2">
<li><strong>身份认证</strong></li>
<li><strong>股票系统</strong>[Follow My Vote公司裂力于利用区块链技术打造种开源的、可审计的、安全高效的端对端投票系统，防止投票过程中出现安全漏洞。</li>
<li><strong>供应链</strong><br>沃尔玛与IBM以及清华大学展开合作，政府协助下启动了两个独立推进的区块链试点项目，旨在提高供应链数据的准确性，保障食品安全。沃尔玛将区块链技术应用于全球供应链，成本将减少1万亿美元。</li>
<li><strong>金融行业</strong></li>
</ol>
<p>&#x3D;&#x3D;@@ 区块链采用<strong>非对称加密</strong>&#x3D;&#x3D;</p>
<h2 id="虚拟现实VR"><a href="#虚拟现实VR" class="headerlink" title="虚拟现实VR"></a>虚拟现实VR</h2><p>虚拟现实技术应该具备的三个特征：<strong>沉浸感、交互性、想象性</strong> </p>
<p>它是以计算机技术为核心的现代高科技手段，模拟生成逼真的<strong>视、听、触、嗅、味觉</strong>等一体化的虚拟环境，用户借助一些特殊的输入与输出设备，通过自然的方式与虚拟世界中的对象进行交互，从而产生身临其境的感受和体验。</p>
<h5 id="虚拟现实基本特征【3I1M】"><a href="#虚拟现实基本特征【3I1M】" class="headerlink" title="虚拟现实基本特征【3I1M】"></a>虚拟现实基本特征【3I1M】</h5><blockquote>
<p>&#x3D;&#x3D;<strong>沉浸感</strong>(lmmersion):用户感到作为主角存在于模拟环境中的真实程度。<br><strong>交互性</strong>(Interaction):参与者对虚拟环境内物体的可操作程度和从环境中得到反馈的自然程度。<br><strong>构想性</strong>(lmagination):又称自主性，指用户沉静在多维信息空间中，依靠自己的感知和认知能力全方位获取知识，发挥主观能动性，需求解答，形成新的概念。<br><strong>多感知性</strong>(Multi-Sensory):表示计算机技术应该拥有很多感知方式，比如听觉，触觉、嗅觉等等。&#x3D;&#x3D;</p>
<p><strong>自主性</strong>：虚拟环境中物体依据物理定律的移动</p>
</blockquote>
<p>理想的虚拟现实技术应该具有一切人所具有的感知功能。由于相关技术，特别是传感技术的限制，目前大多数虚拟现实技术所具有的感知功能仅限于视觉、听觉、触觉、运动等几种。·</p>
<p>虚拟现实是多种技术的综合，其关键技术和研究内容包括以下几个方面:;</p>
<h5 id="动态环境建模技术"><a href="#动态环境建模技术" class="headerlink" title="动态环境建模技术"></a>动态环境建模技术</h5><p>对真实的环境建立计算机模型的技术，包括基于图像的建模技术、三维扫描建模技术等;<br>工具软件有3DS max，AutoCAD，MAYA，Sketch up等。实时三维计算机图形技术实等现实三维图像等方面的技术。</p>
<h4 id="虚拟现实关键技术"><a href="#虚拟现实关键技术" class="headerlink" title="虚拟现实关键技术"></a>虚拟现实关键技术</h4><p><strong>交互技术:</strong>  用户与计算机交互的技术。键盘和鼠标是目前最常用的工具，但对于三维空间来说，键盘和鼠标不太合适。<br>**显示技术: ** 在VR系统中，双目立体视觉起了很大的作用。当用户戴上特殊的眼镜后，一只眼睛智能看到奇数帧图像，另一只眼睛只能看到偶数帧图像，奇、偶帧之间的不同即视差，就产生了立体感。<br><strong>立体声技术</strong>:  常见的立体声效果是靠左右耳听到的不同位置录制的不同声音来实现的，所以会有一种方向感。<br><strong>感觉反馈技术</strong>:  在VR系统中，用户可以看到一个虚拟的杯子。你可以设法抓住它，但是你的手没有真正接触杯子的的感觉。解决这一问题的常用装置是在手套内层安装一些可以振动的触点来模拟触觉<br><strong>语音输入输出技术:</strong>  人的语音输入VR系统中识别、处理以及反馈等技术<br><strong>系统集成技术:</strong> 通过结构化的综合布线系统和计算机网络技术，将各个分离的设备、功能和信息等集成到相互关联的、统一和协调的系统之中，使资源达到充分共享，实现集中、高效、便利的管理。</p>
<h4 id="x3D-x3D-虚拟现实技术分类-x3D-x3D"><a href="#x3D-x3D-虚拟现实技术分类-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;虚拟现实技术分类&#x3D;&#x3D;"></a>&#x3D;&#x3D;虚拟现实技术分类&#x3D;&#x3D;</h4><p><strong>桌面虚拟现实系统</strong>[DesktopVR]：<br>桌面虚拟现实系统基本上是一套基于普通PC平台的小型桌面虚拟现实系统。桌面虚拟现实的参与者是不完全沉浸的，有时要求参与者使用标准的显示器和立体现实设备、数据手套和六个自由度的三维空间鼠标器，戴上立体眼镜坐在监视器前，在一些专业软件的帮助下，可以通过计算机屏幕观察虚拟境界。</p>
<p>&#x3D;&#x3D;<strong>增强式虚拟现实系统</strong>[AR]&#x3D;&#x3D;：增强式虚拟现实系统允许用户对现实世界进行观察的同时，将虚拟图像叠加在真实物理对象上，为用户提供与所看到的真实环境有关的、存储的计算机中的信息，从而增强用户对真实环境的感受，因此又被称为叠加式或补充现实式虚拟现实系统。</p>
<p><strong>沉浸式虚拟现实系统</strong>(lmmersive VR)：沉浸式虚拟现实系统使用户沉浸在虚拟世界里。沉浸式虚拟现实系统是一种高级的虚拟现实系统，它提供了一个完全沉浸的体验，使用户有一种置身于虚拟境界之中的感觉。</p>
<p><strong>分布式虚拟现实系统</strong>(Distributed VR)<br>分布式虚拟现实系统式虚拟现实技术和网络技术结合的产物;以沉浸式虚拟现实为基础，多个用户或虚拟世界通过网络相连接;多个用户同时加入统一虚拟空间，共享信息，协同工作达到一个更高的境界。</p>
<p>@@ 增强现实比虚拟现实**<u>更注重虚拟场合、更注重临场感</u>**</p>
<h4 id="虚拟现实技术应用"><a href="#虚拟现实技术应用" class="headerlink" title="虚拟现实技术应用"></a><strong>虚拟现实技术应用</strong></h4><p><strong>(1) VR在智慧城市的使用</strong><br>智慧城市就是运用信息和通信技术手段感测、分析、整合城市运行核心系统的各项关键信息，全景智慧城市时空建设上运用虚拟现实技术虚拟真实环境，是一项综合性城市设计的方法，在与用户、工程单位通过观看设计作品，在网上实时相互沟通交流，从而减少办公成本投资，缩短设计周期，提高规划设计质量。<br>虚拟现实技术充分利用计算机辅助设备和虚拟现实技术，虚拟现实景观，实现视觉、听觉模拟，可以使城市景观设计更具创造性、灵活性，可减轻设计人员的劳动强度，提高设计质量，节省投资。</p>
<p><strong>(2) VR在其它领域的应用</strong><br>在医学、娱乐、军事航空航天、房产开发与室内设计、工业仿真、文物古迹、游戏、Web3D、道路桥梁、地理、教育等领域有广泛的应用。如在教育领域，虚拟现实技术在中小学教育、职业教育、高等教育等方面均有应用。在中小学教育方面，结合虚拟现实沉浸式教学的体验，解决课堂教学中的抽象、困难的知识点，实现由传统的“以教促学”的学习方式向学习者通过自身与信息环境的相互作用来得到知识，让学生对课程更感兴趣。</p>
<p>@@ <strong>虚拟化</strong>是大数据处理的特点<br>@@ <strong>全球定位系统、移动电话技术、有限网络</strong>属于物联网关键技术<br>@@ 物联网的核心和基础是<strong>互联网</strong><br>@@ 人工智能应用研究的两个最重要、最广泛的领域是<strong>专家系统、机器学习</strong></p>
<hr>
<h1 id="铭升教育"><a href="#铭升教育" class="headerlink" title="铭升教育"></a><span style = "color : red">铭升教育</span></h1><h4 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h4><h5 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h5><p>1.为什么需要信息安全：因为Internet中存在丰富的信息资源<br>2.什么是信息安全<br>答：信息安全是指 放置任何对数据进行 <strong>未授权访问</strong><del>没有账户</del> 的 安全措施，或者 防止造成信息 有意无意的<strong>泄露、破坏、丢失</strong>等问题的发生，让数据处于 <strong>远离危险、避免威胁</strong> 的状态或特征<br>3.【填空】信息安全的 六个要素 p37<br>&#x3D;&#x3D;**<span style = "color : red">保密性、完整性<del>防伪造</del>、可靠性<del>防伪造</del></span>**、可用性、可控性、不可否认性<del>防抵赖,采用”数字签名”</del>&#x3D;&#x3D;</p>
<h5 id="计算机病毒-概念【背】"><a href="#计算机病毒-概念【背】" class="headerlink" title="计算机病毒 概念【背】"></a>计算机病毒 概念【背】</h5><p>是指 编制或者在计算机程序中插入的破坏计算机功能和数据，影响计算机使用 并且 能够自我复制的一组计算机指令或程序代码<br>【说明】<br>1.计算机病毒 是 程序代码 或 指令<br>2.【填空】计算机病毒的特征：&#x3D;&#x3D;<strong>传染性</strong>、破坏性、潜伏性、隐蔽性、可触发性、不可预见性、变异性、表现性&#x3D;&#x3D; 等<br>【说明】<br>传染性 是病毒 最主要的特征；<br>破坏性 表现在 破坏程序功能、破坏计算机的性能(占用CPU和内存资源)、破坏数据、盗用信息<br>表现性 病毒表现出它的破坏能力<br>3.计算机病毒传播主要途径：计算机网络(Internet和局域网)、移动存储介质(U盘)<br>4.【多选】计算机病毒防治措施<br>答：对计算机病毒采用”<strong>预防为主</strong>“的方针。<br>① 操作系统软件要及时升级、打补丁 【最主要的】<br>② 安装杀毒软件、防火墙软件，并及时升级<br>③ 定期查、杀病毒；<br>④ 不适用来历不明的移动存储介质，不访问不良站点、不打开来历不明的电子邮件、短信等<br>⑤ 控制访问权限，设置访问口令，加强数据加密<br>⑥ 定期制作 系统备份<br>⑦ 使用正版软件、抵制盗版行为<br>⑧ 制订规章制度、加强宣传教育，加强安全防范意识</p>
<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>概念或功能：处于 &#x3D;&#x3D;<strong>内网</strong> 和 <strong>外网</strong>&#x3D;&#x3D; 之间的一道安全屏障。<br>作用：用于过滤 进、出 内网的数据。通过制订安全策略，设置 允许 或 禁止 通过防火墙的数据包，记录通过防火墙的信息和行为，对网络中出现的攻击行为 进行 检测和告警；<br>【考点】<br>① 由于 <strong>内网和外网</strong> 的安全级别要求不同，需要防火墙过滤<br>② 防火墙 采用 被动防御策略<br>③ <u>防火墙 是 <strong>抵御外部攻击</strong>，没有杀毒功能</u>；<u>反病毒软件 是用于监测和清除 病毒，没有抵御黑客攻击功能(杀毒软件)</u><br>④【选择】防火墙 不能 抵御所有攻击；杀毒软件 不能 清除所有病毒<br>⑤ 记录日志</p>
<h4 id="密码技术-1"><a href="#密码技术-1" class="headerlink" title="密码技术"></a>密码技术</h4><p>1.密码的 六个要素<br>明文、加密算法、加密密钥、密文、解密算法、解密密钥<br>2.【重点】加密技术分为：对称加密  和 非对称加密 两类<br>3.对称加密：<br>加密算法 &#x3D; 解密算法<br>加密密钥 &#x3D; 解密密钥<br>4.&#x3D;&#x3D;<strong>非对称加密(公开密钥)</strong>&#x3D;&#x3D;<br>加密算法 与 解密算法 不同<br>加密密钥 与 解密密钥 不同<br>(1)【考题】网络中传输数据：采用 公开密钥 机制<br>如，发送电子邮件、金融服务、身份验证、”数字签名”等<br>(2) 非对称加密有一对密钥<br>① 公开密钥：用于加密 向 密钥所有者 发送的明文<br>② 私密密钥：用于 破解公开密钥的加密；用于 **”数字签名”**，防抵赖</p>
<p>@@ ORC(optical character recognition)是文字识别</p>
<p>@@ MD5数据加密算法  DES报文摘要  公钥基础设施：产生  公开密钥和私密密钥<br><strong>RSA</strong><del>最著名的公钥密码算法</del>、MD5、AES非对称加密算法      PKI属于对称性加密</p>
<p>@@ 用于建立超链接的HTML<strong>标记</strong>是 &lt; a href… &#x2F;a &gt;</p>
<p>@@ 快捷方式是扩展名为<strong>LNK</strong><del>link</del>的文件</p>
<hr>
<p>&#x3D;&#x3D;<strong>计算机病毒</strong>代码的结构一般来说包括3大功能模块:&#x3D;&#x3D;<br><u><strong>引导模块</strong>:</u> 引导模块将病毒由外存引入内存，使后两个模块处于活动状态。<br><u><strong>传染模块</strong>:</u> <strong><u>传染模块显然用来将病毒传染到其它对象上去</u></strong><br><u><strong>破坏模块</strong>:</u> 破坏模块实施病毒的破坏作用，如删除文件，格式化磁盘等，由于有些病毒的该模块并没有                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               明显的恶意破坏作用，而只是进行一些视屏或声方面的自我表现作用，故该模块有时又称表现模块</p>
<p>根据病毒存在的媒体，病毒可以划分为: 网络病毒、文件病毒和引导型病毒<br>&#x3D;&#x3D;<strong>网络病毒</strong>通过计算机网络传播感染网络中的<u>可执行文件</u><br><strong>文件病毒</strong>感染<u>计算机中的文件</u>(如:com, exe, doc等)<br><strong>引导型病毒</strong>感染<u>启动扇区(Boot)和硬盘的系统引导扇区(MBR)</u>&#x3D;&#x3D;</p>
<p>还有这三种情况的<strong>混合型病毒</strong>，例如:多型病毒(文件和引导型)感染文件和引导扇区两种目标，这样的病毒通常都具有复杂的算法，它们使用非常规的办法侵入系统，同时使用了加密和变形算法<br>宏病毒：破坏Excel、PPT、word</p>
<p>计算机病毒传染的过程是这样的：病毒从带毒载体进入内存，一般<strong>利用操作系统的加载机制或引导机制</strong>。当系统运行一个带毒文件或用一带毒系统盘启动时，病毒就进入内存。而从RAM侵入无毒介质则利用了操作系统的读写磁盘中断或加载机制。</p>
<p>@@ 解调&#x3D;&gt; 模拟 ~ 数字     解调&#x3D;&gt; 数字 ~ 模拟<br>@@ 经典的Internet数据传输速率可以从10Mbps - 10Gbps<br>@@ 木马 &#x3D;&gt; 植入威胁(本身PC成为服务器)<br>@@ BBS贴吧、论坛、电子公告板<br>@@ 调制拨号接入网 调制解调机器；网卡是通过 局域网接入<br>@@ C类地址属于 小型规模地址网络  多目的地址传送是:<strong>广播地址</strong><br>@@ Windows操作系统中受限用户在默认情况下可以访问操作自己的文件，这种权限策略称为<strong>最小权限原则</strong><br>@@ 防火墙的安全策略 ①除了允许的，其他的都禁止<del>Windows7</del> ②除了禁止的，其他都允许 </p>
<hr>
<p>@@ 计算机病毒可以通过计算机网络进行传播，可以通过不移动的计算机硬件设备进行传播，可以通过移动存储设备进行传播，还可以通过<strong>点对点通信</strong>系统和<strong>无线通道</strong>传播<br>@@ 威胁信息安全的因素有很多：”黑客入侵、计算机病毒、自然灾害(来自<strong>自然灾害、恶劣的场地环境、电磁辐射和电磁干扰、网络设备自然老化</strong>)<br>@@  <strong>被动攻击</strong>是指在不干扰网络信息系统正常工作的情况下，进行<strong>监听、截获、窃取、破译和业务流量分析</strong>等。被动攻击不会使系统瘫痪，但更加难以检测<br>@@ <strong>电子商务安全技术</strong>有：<u>加密技术、数字签名、认证中心(CA)、Internet电子邮箱的安全协议</u>；<del>不包括防火墙技术</del><br>@@ 虚拟专用网(VPN)即虚拟私有网络，是一种利用公用网络来构建的<strong>私有专用网络</strong>；被定义为通过一个公用网络建立一个临时的、安全的链接，是一条穿过混乱的公用网络的安全、稳定的隧道，是对企业内部网的扩展<br>@@  使用大量垃圾，占用宽带的攻击破坏的是数据的<strong>可用性</strong> [发送大量垃圾信息可占用带宽(造成堵塞), 导致实体计算机用户无法再需要的时候访问网络资源和得到服务，破坏了数据的<strong>可用性</strong>]<br>@@ 信息安全包括四大要素：<strong>技术、制度、流程、人</strong><br>@@ 网络连接设备的安全漏洞属于结构隐患。结构隐患一般指<strong>网络拓扑结构</strong>的隐患和<strong>网络硬件</strong>的安全隐患<br>@@ 目前信息安全技术主要有: <strong>密码技术、防火墙技术、虚拟专用网(VPN)技术、数字证书技术、其他安全保密技术</strong><br>@@ <strong>虚拟专用网(VPN)<strong>是将物理分布在不同地点的网络通过公用骨干网(Internet)连接而成的逻辑上的</strong>虚拟子网</strong>，为了保障信息的安全，VPN技术采用了鉴别、访问控制、保密性和完整性等措施，以防信息被泄露、篡改和复制<br>@@ 对称密钥加密又称<strong>单钥加密</strong>，加密密钥和解密密钥相同，或从一个可以推出另一个<br>@@ <strong>公钥密码</strong>体制中，公钥用来加密(可公开)，私钥用来解密(不可公开)；公钥和私钥是不同的<br>@@ 加强网络安全的最重要的基础措施是<strong>设计有效的网络安全策略</strong><br>@@ 云计算是对<strong>并行计算、网格计算、分布式计算、存储</strong>技术的发展与运用<br>@@ 智能客服系统、人脸识别属于<strong>人工智能</strong></p>
<hr>
<p>@@ 程序与软件<del>程序文档</del>的集合<br>@@ 计算机网络按使用性质<strong>公用网+私用网</strong><br>@@ 蠕虫在网络中传染 占用CPU内存 主要造成<strong>拒绝式服务</strong><br>@@ ETC是<strong>物联网</strong> 没有采用人工智能<br>@@ 货物搬运属于<strong>物联网</strong>但也有人工智能在里面<br>@@ 输入设备：光驱、数码相机    刻录机是输出设备<br>@@ 每段首行首字据页左边界的距离称为<strong>左缩进</strong>，第二行，相对第一行左侧的偏移量是<strong>首行缩进</strong><br>@@ 链接网络并选择一个网络来传输数据包的计算机，被称为<strong>路由器</strong><br>@@ 多媒体技术和超文本技术的结合，形成了<strong>超媒体</strong><br>@@ 数据窃取是指敏感数据<strong>拷贝</strong>和<strong>监听</strong><br>@@ 人工智能的关键技术包括<strong>计算机视觉、生物特征识别、机器学习、语音识别、自然语言识别、机器人技术&#x2F;专家系统</strong><br>@@ CPU的内外位置不同分为<strong>内部总线</strong>和<strong>外部总线</strong> 其中内部总线称为<strong>片</strong>cip[内部总线是CPU内部数据传输通道]<br>@@ 主板上的是系统总线 主板之外和外设相连的实外部总线<br>@@ 多媒体具有<strong>多样性、继承性…</strong><br>@@ 计算机病毒的基本构造有<strong>引导部分、传染部分、表现部分</strong><br>@@ 机器学习是使计算机有人工智能<br>@@ Aero效果 半透明主题<br>@@ 区位码是数字编码。将所有字符分为<br>@@ 汉字在计算机内部的编码是<strong>机内码</strong><br>@@ 汉字打印输出有<strong>点阵方式</strong>和<strong>矢量图</strong><br>@@ MIS是管理信息系统 是应用软件<br>@@ 汉字字库中存放着汉字的 字体字形字号<br>@@ 比特币的特点：<strong>不可伪造、匿名性、不可篡改、可回溯</strong><br>@@ VR中使用的输入设备包括<strong>三维扫描仪、声学跟踪器、光学跟踪器、数据手套</strong>    <strong>数据手套</strong>是虚拟现实中的典型设备<br>@@ 公钥密码常用于<strong>数据加密、数字签名</strong><br>@@ 在人工智能的关键技术中，<strong>生物特征识别</strong>是通过指纹、面部对人的身份进行验证<br>@@ Excel中X轴是分类轴<br>@@ 秘钥分配中心技术中，常用于对称密码体制中的<strong>加密密钥</strong>的分配；密钥认证中心技术，更多地用于公开密码体制中的<strong>公开密钥</strong><br>@@ 内存储器和外存储器的最大区别<strong>是否被CPU直接访问、断电后是否会丢失信息</strong><br>@@ 硬盘 U盘 光盘 按照存储速度的快到慢<br>@@ 智能终端的操作系统：Android、Harmony、IOS<br>@@ 不同工作簿的单元格引用，工作表改名或移动后 数据自动更新不受影响<br>@@ 表示层 提供数据格式转换服务    应用层 给用户的应用提供网络服务<br>@@ 压缩率最大的是JPEG<br>@@ 区块链的链是整个账本状态变化的日志记录<br>@@ 人脸识别是人工智能<br>@@ 计算机系统中，<strong>数据、程序、有关的文档</strong>的集合称为软件<br>@@ 资源管理器按<strong>大小、修改日期、类型</strong>方式排列<br>@@ 输入了不正确的拼音码可以<strong>退格键、ESC</strong><br>@@ 硬分页符是自带的，不是人为插入的，不可删除<br>@@ 顶级域名类型包括<strong>国家、通用域名、基础结构域(ARPA)</strong><br>@@ CMYK 青色，洋红色(品红)，黄色，黑色<br>@@ 数字签名应具有<strong>可公开检验、唯一性、不可抵赖性、不可伪造性</strong>‘<br>@@ 百度视图体现了人工智能中的<strong>机器视觉</strong><br>@@ 物联网已经广泛应用于<strong>智能交通、智慧医疗、智能安防、智能物流</strong><br>@@ 动画是用一定的技术手段，将若干静态画面连续呈现形成的，这些静态画面一般称为<strong>帧</strong><br>@@ </p>
<p>@@ CGA VGA TVGA EGA 显示卡的总线接口类型</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/计算机" style=color:#ffa2c4>
                计算机
            </a>
        </span>
        
    </div>

    <a href="/2023/01/19/计算机/信息安全、新一代信息技术/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/01/16/政治/(思修)第六章-法律特征,依法治国,维护宪法,遵学收守用法/">
        <h2>
            (思修)第六章-法律特征,依法治国,维护宪法,遵学收守用法
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/1/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="学习法治思想-提升法治素养"><a href="#学习法治思想-提升法治素养" class="headerlink" title="学习法治思想 提升法治素养"></a>学习法治思想 提升法治素养</h1><h3 id="社会主义法律的特征和运行"><a href="#社会主义法律的特征和运行" class="headerlink" title="社会主义法律的特征和运行"></a>社会主义法律的特征和运行</h3><h4 id="法律及其历史发展"><a href="#法律及其历史发展" class="headerlink" title="法律及其历史发展"></a>法律及其历史发展</h4><p><strong>(一) 法律的含义</strong></p>
<h6 id="1-法律是由国家创制和实施的行为规范。"><a href="#1-法律是由国家创制和实施的行为规范。" class="headerlink" title="1.法律是由国家创制和实施的行为规范。"></a>1.<strong>法律</strong>是由国家创制和实施的<strong>行为规范</strong>。</h6><p><strong>法律是由国家</strong>制定或认可<strong>并由国家</strong>强制力<strong>保证实施的</strong>，<strong>反应由</strong>特定社会物质生活条件<strong>所决定的</strong>统治阶级意志<strong>的规范体系</strong>。</p>
<p>国家创制法律规范的方式主要有两种: 一是国家机关在<strong>法定的职权范围内</strong>依照法定程序，制定、修改、废止<strong>规范性法律文件</strong>; 二是国家机关赋予某些既存<strong>社会规范法律效力</strong>，或者赋予<strong>先前的判例法律效力</strong>。法律不但由国家制定和认可，而且由国<strong>家强制力保证实施</strong>。</p>
<h6 id="2-法律由一定的社会物质生活条件所决定。"><a href="#2-法律由一定的社会物质生活条件所决定。" class="headerlink" title="2.法律由一定的社会物质生活条件所决定。"></a>2.法律由<strong>一定的社会物质生活条件所决定</strong>。</h6><p>法律作为上层建筑的重要组成部分，不是凭空出现的，而是产生于特定社会物质生活条件基础之上。<br>&#x3D;&#x3D;<strong>物质资料生产方式</strong>对法律产生决定性影响&#x3D;&#x3D;</p>
<h6 id="3-法律是统治阶级意志的体现。"><a href="#3-法律是统治阶级意志的体现。" class="headerlink" title="3.法律是统治阶级意志的体现。"></a>3.法律是<strong>统治阶级意志的体现</strong>。</h6><p>法律所体现的统治阶级<strong>意志具有整体性</strong>，不是统治阶级内部个别人的意志，也不是统治者个人意志的简单相加。法律所体现的<strong>统治阶级意志</strong>，并不是统治阶级意志的全部，仅仅是<strong>上升为国家意志的那部分意志</strong></p>
<p><strong>(二)  法律的历史发展</strong><br>法律不是从来就有的，也不是永恒存在的。它随着<strong>私有制、阶级和国家的产生而产生，也将随着私有制、阶级和国家的消亡而消亡。</strong><br>法律作为<strong>上层建筑</strong>的<strong>重要组成部分</strong>，其<strong>基本内容</strong>和<strong>性质</strong>总是<strong>与所在社会的生产关系相适应</strong>。<strong>奴隶制法律、封建制法律、资本主义法律</strong>都是&#x3D;&#x3D;建立在<strong>私有制经济基础</strong>之上的<strong>剥削阶级类型</strong>法律&#x3D;&#x3D;，而<strong>社会主义法律</strong>则是人类历史上<strong>以公有制为基础的新型法律</strong>。</p>
<p><strong>1.奴隶制法律。</strong><br>奴隶制法律<strong>通常采用最极端的经济剥削</strong>和<strong>政治压迫</strong>的方式其基本特征:<br>一是具有<strong>明显的原始习惯残留痕迹</strong>，[殉葬]<br>二是<strong>否认奴隶的法律人格</strong>，<br>三是存在<strong>严格的等级划分</strong>，<br>四是<strong>刑罚方式极其残酷</strong>。</p>
<p><strong>2.封建制法律。</strong><br>封建社会是以<strong>农业为基础</strong>的<strong>自然经济</strong>占主导地位的社会。基本特征:<br>一是确立农民对封建地主的<strong>人身依附关系</strong><br>二是实行<strong>封建等级制度</strong><br>三是<strong>维护专制皇权</strong><br>四是<strong>刑罚严酷</strong> [诛九族]</p>
<p><strong>3.资本主义法律。</strong><br>资本主义法律是资产阶级共同意志的体现，是资产阶级统治工人阶级和其他劳动人民的工具，其<strong>根本任务</strong>是<strong>维护资产阶级的政治、经济和社会秩序</strong>。<br>资本主义法律规定的自由、民主、平等等价值原则是形式上的，归根结底是为了<strong>维护资产阶级根本利益</strong>，所以<strong>属于剥削阶级类型</strong>的法律。&#x3D;&#x3D;资本主义<strong>法律</strong>的基本特征主要体现为<strong>四个原则</strong>:<br>一是与资本主义<strong>私有制</strong>相适应的<strong>私有财产神圣不可侵犯原则</strong><br>二是与资本主义<strong>市场经济</strong>相适应的<strong>契约自由原则</strong><br>三是与资本主义<strong>民主政治</strong>相适应的<strong>法律面前人人平等原则</strong><br>四是与资产阶级<strong>人道主义</strong>相适应的<strong>人权保障原则</strong>。&#x3D;&#x3D;</p>
<p><strong>4.社会主义法律。</strong><br>社会主义法律是<strong>新型的法律制度</strong>有着与以往剥削阶级类型法律制度不同的经济基础与阶级本质。<br>社会主义法律反映了社会主义生产关系的本质要求,为实现普遍意义的<strong>平等、自由</strong>奠定了坚实基础，开辟了广阔空间，实现了对历史上各种类型法律制度的超越。</p>
<h4 id="我国社会主义法律的本质特征"><a href="#我国社会主义法律的本质特征" class="headerlink" title="我国社会主义法律的本质特征"></a>我国社会主义法律的本质特征</h4><p>我国社会主义法律，是在中国共产党领导新民主主义革命时期孕育民共和国成立后不断形成和发展起来的。改革开放以来，我国法治建访发展时期，形成了以<strong>宪法</strong>为<strong>统帅</strong>的<strong>中国特色社会主义法律体系</strong>，为中巨人民当家作主、推进改革开放和建设社会主义现代化国家提供了<strong>坚实法治保障</strong></p>
<p>(一）我国社会主义法律体现了<strong>党的主张</strong>和<strong>人民意志</strong>的统一。<br>我国社会主义法律既具<strong>有鲜明的阶级性</strong>，又<strong>具有广泛的人民性</strong>，体现了阶级性与人民性的统一。<br>(二)  我国社会主义法律具有<strong>科学性</strong>和<strong>先进性</strong>。<br>从本质上说，我国社会主义法律更能<strong>尊重和反映社会发展规律</strong>，具有科学性和先进性。<br>(三)  我国社会主义法律是中国特色社会主义建设的<strong>重要保障</strong>。<br>法的社会作用是从法在社会生活中要实现的目的角度来认识的。我国法律的社会作用体现了社会主义的本质要求，<strong>经济发展、政治清明、文化昌盛、社会公正、生态良好，</strong>都离不开社会主义法律的引领、规范和保障。</p>
<h4 id="我国社会主义法律的运行"><a href="#我国社会主义法律的运行" class="headerlink" title="我国社会主义法律的运行"></a>我国社会主义法律的运行</h4><p>&#x3D;&#x3D;<strong>法律的运行</strong>是一个从<strong>创制、实施</strong>到<strong>实现</strong>的过程。这个过程主要包括<strong>法律制定、法律执行、法律适用、法律遵守</strong>等环节。&#x3D;&#x3D;<br><span style = "color : red"><strong>法律制定</strong>是国家对权利和义务，即<strong>社会利益</strong>和<strong>负担</strong>进行的<strong>权威性分配</strong></span>;<br>法律的<strong>执行、适用、遵守</strong>则把法律规范转化为法律实践，把法定的权利和义务转化为现实的权利和义务。我国社会主义法律的运行具有鲜明的中国特色</p>
<p><strong>守法</strong>是法律实施和实现的<strong>基本途径</strong></p>
<p>(一)  法律制定<br><strong>法律制定</strong>是指有立法权的国家机关，依照法定职权和程序制定规范性法律文件的活动，是法律运行的<strong>起始性和关键性环节</strong>。<br>&#x3D;&#x3D;根据宪法规定:&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th align="left">机关</th>
<th align="left">立法权限</th>
</tr>
</thead>
<tbody><tr>
<td align="left">全国人民代表大会及其常务委员会行使<strong>国家立法权</strong></td>
<td align="left">负责<strong>修改宪法、制定法律</strong></td>
</tr>
<tr>
<td align="left"><strong>国务院</strong></td>
<td align="left">根据宪法和法律<strong>制定行政法规</strong>。</td>
</tr>
<tr>
<td align="left">国家监察委员会</td>
<td align="left">根据宪法和法律制定<strong>监察法规</strong>。</td>
</tr>
<tr>
<td align="left">中央军委</td>
<td align="left">根据宪法和法律制定<strong>军事法规</strong>。</td>
</tr>
<tr>
<td align="left"><strong>国务院各部门</strong></td>
<td align="left">根据宪法、法律和行政法规，在本部门的权限范围内，<strong>制定有关部门规章</strong></td>
</tr>
<tr>
<td align="left">省、自治区、直辖市的人民代表大会及其常委会</td>
<td align="left">根据本行政区域的具体情况和实际需要，在不与宪法、法律和行政法规相抵触的前提下，可以<strong>指定地方性法规</strong></td>
</tr>
<tr>
<td align="left">设区的市的人民代表大会及其常委会</td>
<td align="left">根据本市的具体情况和实际需要，在不与宪法、法律、行政法规和本省、自治区的地方性法规相抵触的前提下，可以制定<strong>地方性法规</strong>，报省、自治区的人民代表大会常委会批准后施行。</td>
</tr>
<tr>
<td align="left">省、自治区、直辖市、设区的市的人民政府</td>
<td align="left">根据法律、行政法规和本省、自治区、直辖市的<strong>地方性法规</strong>，制定<strong>地方政府规章</strong>。</td>
</tr>
<tr>
<td align="left">自治区、自治州、自治县的人民代表大会</td>
<td align="left">根据当地民族的具体情况<strong>制定自治条例</strong>和<strong>单行条例</strong>。</td>
</tr>
<tr>
<td align="left">特别行政区立法机关</td>
<td align="left">根据特别行政区基本法自主地制定<strong>本行政区的法律</strong></td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;我国立法贯彻<strong>公正、公平、公开</strong>原则，坚持<strong>科学立法、民主立法、依法立法</strong>&#x3D;&#x3D;，表达<strong>人民的共同意志和诉求</strong>。立法活动必须遵循法定程序。就全国人民代表大会的立法程序而言，大体包括法律案的<strong>提出</strong>、法律案的<strong>审议</strong>、法律案的<strong>表决</strong>和法律的<strong>公布</strong>四个环节。</p>
<p><strong>(二）法律执行</strong><br>&#x3D;&#x3D;<strong>广义上</strong>&#x3D;&#x3D;，法律执行是指<strong>国家机关及其公职人员</strong>，在国家和公共事务管理中依照法定<strong>职权和程序</strong>，贯彻和实施<strong>法律的活动</strong>;<br>&#x3D;&#x3D;<strong>狭义上</strong>&#x3D;&#x3D;，法律执行则是指国家行政机关及其公职人员执行法律的活动，也被称为<strong>行政执法</strong>。</p>
<p>&#x3D;&#x3D;<strong>行政执法</strong>是法律<strong>实施</strong>和<strong>实现</strong>的重要环节&#x3D;&#x3D;，必须坚持<strong>合法性、合理性、信赖保护、效率</strong>等<strong>基本原则</strong>。<br>我国<strong>行政执法的主体</strong>大体分为两类:<br>一是<strong>中央和地方各级政府</strong>，包括国务院和地方各级人民政府;<br>二是各级政府中享有执法权的<strong>下属行政机构</strong>。此外，<br>法律授权的社会组织、行政机关依法委托的社会组织可以在一定范围内执行法律并承担相应的法律责任。</p>
<p><strong>(三)  法律适用</strong><br><strong>法律适用</strong><u>是指国家司法机关及其公职人员依照法定职权和程序<strong>适用法律</strong>处理案件的专门活动</u>。<br>&#x3D;&#x3D;<strong>司法机关</strong>是指<strong>国家审判机关</strong><del>人民法院代表国家行使审判权</del>和<strong>检察机关</strong><del>人民检察院代表国家行使法律监督权</del>。&#x3D;&#x3D;<br>人民法院代表国家行使<strong>审判权</strong>，人民检察院代表国家行使<strong>法律监督权</strong>，其他任何国家机关、社会组织和个人，不得行使国家司法权。人民法院和人民检察院根据法律法规公正司法，保护自然人、法人和其他组织的合法权利，解决法律纠纷，惩治讳法犯罪行为，维护法律秩序。<br>司法的基本要求：<strong>正确、合法、合理、及时</strong><br><u>司法公正：<strong>社会公正的最后一道防线；法律至高无上权威的保障</strong></u></p>
<p><strong>(四）法律遵守</strong><br>法律遵守是指<strong>国家机关、社会组织和公民个人</strong>依照法律规定行使权力或权利以及履行职责或义务的活动。守法是<strong>法律实施</strong>和<strong>实现</strong>的基本途径。</p>
<h3 id="坚持全面依法治国"><a href="#坚持全面依法治国" class="headerlink" title="坚持全面依法治国"></a>坚持全面依法治国</h3><p><strong>(一) 习近平法治思想的形成和意义</strong></p>
<p>1.形成<br>党的<strong>十八大以来</strong>，习近平高度重视全面依法治国，创造性提出了一系列全面依法治国新理念新思想新战略，形成习近平法治思想，指导和推动了社会主义法治建设发生历史性变革、取得历史性成就，全面依法治国实践取得重大进展。<br><strong>习近平法治思想</strong>，立足新时代中国特色社会主义伟大实践，全面系统地创新发展了中国特色社会主义法治理论，实现了<strong>马克思主义法治理论的新飞跃</strong>。</p>
<p>2.意义<br>习近平法治思想是经过长期发展而形成的内涵丰富论述深刻、逻辑严密、系统完备的<strong>法治理论体系</strong>，为建设法治中国指明了前进方向，在中国特色社会主义法治建设进程中具有重大<strong>政治意义、理论意义、实践意义</strong>。<br>习近平法治思想从历史和现实相贯通、国际和国内相关联、理论和实际相结合上深刻回答了<strong>新时代为什么实行全面依法治国、怎样实行全面依法治国</strong>等一系列重大问题，是顺应实现中华民族伟大复兴时代要求应运而生的重大理论创新成果，是<strong>马克思主义法治理论中国化最新成果</strong>，是<strong>习近平新时代中国特色社会主义思想</strong>的<strong>重要组成部分</strong>。</p>
<p><strong>(二）习近平法治思想的主要内容</strong></p>
<p>1.关于<strong>政治方向</strong>，这一思想深刻回答全面依法治国<strong>由谁引领依靠谁、走什么道路</strong>等<strong>大是大非问题</strong>，指明了中国特色社会主义法治的前进方向;<br>2.关于<strong>战略地位</strong>，这一思想深刻回答<strong>为什么要全面依法治国的问题</strong>，深刻揭示全面依法治国是新时代坚持和发展中国特色社会主义的<strong>基本方略</strong>，是党领导人民治理国家的基本方式;<br>3.关于<strong>工作布局</strong>，这一思想深刻回答全面依法治国<strong>如何谋篇布局</strong>的问题，明确全面依法治国的<strong>总目标、总抓手和基本思路</strong>;<br>4.关于<strong>主要任务</strong>，这一思想深刻回答全面依法治国如何突破的问题，指明中国特色社会主义法治的<strong>战略安排</strong>;<br>5.关于<strong>重大关系</strong>，这一思想深刻回答如何正确处理政治与法治、改革与法治德治与法治等重大问题，揭示法治中国建设的<strong>认识论</strong>和<strong>方法论</strong>;<br>6.关于<strong>重要保障</strong>，这一思想深刻回答全面依法治国需要什么保障的问题，指明全面依法治国的人才支撑和”<strong>关键少数</strong>“</p>
<h6 id="中国特色社会主义法治道路的核心要义"><a href="#中国特色社会主义法治道路的核心要义" class="headerlink" title="中国特色社会主义法治道路的核心要义"></a>中国特色社会主义法治道路的<strong>核心要义</strong></h6><ul>
<li>坚持党的领导</li>
<li>坚持中国特色社会主义制度</li>
<li>贯彻中国特色社会主义法治理论</li>
</ul>
<h4 id="坚持走中国特色社会主义法治道路"><a href="#坚持走中国特色社会主义法治道路" class="headerlink" title="坚持走中国特色社会主义法治道路"></a>坚持走中国特色社会主义法治道路</h4><p>&#x3D;&#x3D;<strong>(一）为什么要走中国特色社会主义法治道路</strong>&#x3D;&#x3D;<br>1.走中国特色社会主义法治道路，是<strong>历史的必然结论</strong>。要不要走法治道路、走什么样的法治道路，是近代以来中国人民面临的历史性课题。<br>2.走中国特色社会主义法治道路，是由我国<strong>社会主义国家性质</strong>所决定的。我国宪法明确规定:”<strong>社会主义制度</strong>是中华人民共和国的<strong>根本制度</strong>。”这一根本制度保证了人民当家作主的主体地位，也保证了人民在全面依法治国中的中心地位，这是我们的<strong>最大制度优势</strong>。<br>3.走中国特色社会主义法治道路，是<strong>立足我国基本国情的必然选择</strong>。走什么样的法治道路，脱离不开一个国家的基本国情。</p>
<p>&#x3D;&#x3D;<strong>(二）坚持中国特色社会主义法治道路必须遵循的原则</strong>&#x3D;&#x3D;<br>1.&#x3D;&#x3D;<strong>坚持中国共产党的领导</strong>&#x3D;&#x3D;。<u>党的领导是中国特色社会主义<strong>最本质的特征</strong>，是社会主义法治<strong>最根本的保证</strong>，我国是人民民主专政的社会主义国家，党的领导是中国特色社会主义<strong>法治之魂</strong>，这是我们的法治同西方资本主义国家的法治<strong>最大的区别</strong></u> [<u><em>领导立法、保证执法、支持司法、带头守法</em></u> ]<br>2.&#x3D;&#x3D;坚持<strong>人民主体地位</strong>&#x3D;&#x3D;。<u>全面依法治国<strong>最广泛、最深厚的基础</strong>是人民，必须坚持为了人民、依靠人民。推进全面依法治国，<strong>根本目的</strong>是<strong>依法保障人民权益</strong>。必须始终牢牢把握<strong>坚持党的领导、人民当家做主、依法治国有机统一</strong>。积极回应人民群众新要求新期待，不断增强人民群众获得感、幸福感、安全感，<strong>用法律保障人民安居乐业</strong></u><br>3.&#x3D;&#x3D;坚持<strong>法律面前人人平等</strong>&#x3D;&#x3D;。<u><strong>平等</strong>是社会主义法律的<strong>基本属性</strong>，是社会主义法治的<strong>基本要求</strong></u>。</p>
<blockquote>
<p>第一，它可以充分显示中国特色社会主义制度的优越性<br>第二，它鲜明地反对法外特权、法外开恩，对掌握公权力的人形成制约<br>第三，它鲜明地反对法律适应上的各种歧视<br>第四，它要求人人都严格依法办事</p>
</blockquote>
<p>4.&#x3D;&#x3D;坚持<strong>依法治国</strong>和<strong>以德治国</strong>相结合&#x3D;&#x3D;。<u>法治和德治，是治国理政不可或缺的两种方式，如<strong>车之两轮</strong>或<strong>鸟之两翼</strong></u>，忽视其中任何一个,都将难以实现国家的长治久安。做到<strong>法安天下，德润人心</strong><br>5.&#x3D;&#x3D;<strong>坚持从中国实际出发</strong>&#x3D;&#x3D;。必须从我国实际出发，既不能罔顾国情阶段，也不能因循守旧、墨守成规。</p>
<h4 id="建设法治中国"><a href="#建设法治中国" class="headerlink" title="建设法治中国"></a>建设法治中国</h4><p><strong>全面依法治国</strong>是一个系统工程，要整体谋划，更加注重<strong>系统性、整体性、协同性</strong>。<br>全面依法治国的宏伟目标是建设法治中国，要以<strong>建设中国特色社会主义法治体系</strong>为<strong>总抓手</strong>，坚持<u>依法<strong>治国</strong>、依法<strong>执政</strong>、依法<strong>行政</strong>共同推进，法治国家、法治政府、法治社会一体建设</u>，坚持<strong>全面推进科学立法、严格执法公正司法、全民守法</strong>。</p>
<p><strong>(一）建设中国特色社会主义法治体系</strong><br>全面依法治国涉及很多方面，必须有一个总揽全局、牵引各方的<strong>总抓手</strong>，这个总抓手就是<strong>建设中国特色社会主义法治体系</strong>。<br>建设中国特色社会主义法治体系，就是要形成<br>&#x3D;&#x3D;<strong>1.完备的法律规范体系</strong><br><strong>2.高效的法治实施体系</strong><br><strong>3.严密的法治监督体系</strong><br><strong>4.有力的法治保障体系</strong><br><strong>5.完善的党内法规体系</strong>&#x3D;&#x3D;<br>【关键词】规范；实施；监督；保障；党内法律</p>
<p>&#x3D;&#x3D;1.完备的<strong>法律规范</strong>体系。是中国特色社会主义法治体系的<strong>前提</strong>，是法治国家、法治政府、法治社会的<strong>制度基础</strong>。<br>2.高效的<strong>法治实施</strong>体系。是建设中国特色社会主义法治体系的<strong>重点</strong>。<br>3.严密的<strong>法治监督</strong>体系。是指以<strong>规范和约束公权力为重点</strong>建立的有效的法治化权力监督网络。[<u>审判的案件终身追责</u>]<br>4.有力的<strong>法治保障</strong>体系。是全面依法治国的<strong>重要依托</strong>，包括<strong>政治和组织保障、人才和物质条件保障、法治文化保障</strong>等。<br>5.完善的<strong>党内法规</strong>体系。是中国特色社会主义法治体系的<strong>本质要求和重要内容</strong>。&#x3D;&#x3D;</p>
<p>3.的扩展 &#x3D;&gt;</p>
<blockquote>
<p>&#x3D;&#x3D;<strong>完善法制监督体系的重点内容</strong>：&#x3D;&#x3D;<br>健全宪法实施和监督制度、<br>强化对行政权力的制约和监督、<br>加强对司法活动的监督、<br>对法治运行全过程全方位的监督、<br>深化国家监察体制改革。</p>
</blockquote>
<p>5.的扩展 &#x3D;&gt;</p>
<blockquote>
<p><strong>完善党内法治体系的重点内容</strong>：<br>党章：党的组织法规制度、党的领导法规制度、党的自身建设法规制度</p>
</blockquote>
<p><strong>(二）坚持依法治国、依法执政、依法行政共同推进法治国家、法治政府、法治社会一体建设。</strong><br>&#x3D;&#x3D;<u><strong>依法治国、依法执政、依法行政</strong>是一个<strong>有机整体</strong>，<strong>关键</strong>在于<strong>党要坚持依法执政、各级政府要坚持依法行政</strong>。</u>&#x3D;&#x3D;<br>法治国家、法治政府、法治社会相辅相成，<strong>法治国家</strong>是法治建设的<strong>目标</strong>，<strong>法治政府</strong>是建设法治国家的<strong>重点</strong>，<strong>法治社会</strong>是构筑法治国家的<strong>基础</strong>。</p>
<blockquote>
<p>&#x3D;&#x3D;法制国家是法治建设的<strong>目标</strong><br>法治政府是建设法治国家的<strong>重点任务、主体工程</strong><br>法治社会是构筑法制国家的<strong>基础&#x2F;基础工程</strong>&#x3D;&#x3D;</p>
</blockquote>
<p>推进<strong>全面依法治国，法治社会建设</strong>是<strong>基础工程</strong>。建设<strong>信仰法治、公平正义、保障权利、守法诚信、充满活力、和谐有序</strong>的<strong>社会主义法治社会</strong>，是增强人民群众获得感、幸福感、安全感的<strong>重要举措</strong>。</p>
<p>(三）坚持全面推进科学立法、严格执法、公正司法、全民守法<br>&#x3D;&#x3D;1.<strong>科学立法</strong>是全面依法治国的<strong>前提</strong>，<br>2.<strong>严格执法</strong>是全面依法治国的<strong>关键</strong>，<br>3.<strong>公正司法</strong>是全面依法治国的<strong>重点</strong>，<br>4.<strong>全民守法</strong>是全面依法治国的<strong>基础</strong>。&#x3D;&#x3D;</p>
<p><strong>公正是法治的生命线</strong>，是司法活动最高的价值追求，公正司法维护社会公平正义的最后一道防线。</p>
<h4 id="x3D-x3D-全面依法治国的意义-x3D-x3D"><a href="#x3D-x3D-全面依法治国的意义-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;全面依法治国的意义&#x3D;&#x3D;"></a>&#x3D;&#x3D;全面依法治国的意义&#x3D;&#x3D;</h4><p>全面依法治国是<u>坚持和发展中国特色社会主义的<strong>本质要求和重要保障</strong></u><br>全面依法治国是<u>实现国家治理体系和治理能力现代化的必然要求</u><br>全面依法治国<u>事关我们党执政兴国，事关人民幸福安康，事关党和国家长治久安。</u><br>全面依法治国也是<u>实现中华民族伟大复兴中国梦的必然要求</u></p>
<h3 id="维护宪法权威"><a href="#维护宪法权威" class="headerlink" title="维护宪法权威"></a>维护宪法权威</h3><h4 id="我国宪法的形参和发展"><a href="#我国宪法的形参和发展" class="headerlink" title="我国宪法的形参和发展"></a>我国宪法的形参和发展</h4><p><strong>(一）我国宪法的形成</strong><br>1931年《中华苏维埃共和国宪法大纲》<br>1946年《陕甘宁边区宪法原则》<br><u><strong>1949年《中国人民政治协商会议共同纲领》</strong></u><br>[四]<u><strong>1954年《中华人民共和国宪法》</strong></u><br>[部]1975年宪法[受到文化大革命的影响]<br>[宪]1978年宪法[受到文化大革命的影响]<br>[法]<u><strong>1982年宪法</strong></u>（<strong>现行宪法</strong>)<br>宪法修正案：<strong>1988年、1993年、1999年、2004年、2018年</strong><del>确立科学发展观、习近平新时代中国特色社会主义写入宪法</del><br>新中国成立后的第一部法律《婚姻法》</p>
<p><strong>(二)  我国现行宪法的修改</strong><br>回顾党领导的宪法建设史，可以得出这样几点结论。<br>&#x3D;&#x3D;一是<strong>制定和实施宪法，推进依法治国，建设法治国家</strong>，是实现<strong>国家富强、民族振兴、社会进步、人民幸福</strong>的<strong>必然要求</strong>。<br>二是我国<strong>现行宪法</strong>是在深刻总结我国社会主义<strong>革命、建设、改革</strong>的<strong>成功经验基础上制定</strong>和<strong>不断完善的</strong>，是党领导人民长期奋斗的历史逻辑、理论逻辑、实践逻辑的必然结果。<br>三是<strong>只有中国共产党</strong>才能坚持立党为公、执政为民，充分发扬民主，领导人民制定出体现人民意志的宪法，领导人民实施宪法。<br>四是<strong>党高度重视</strong>发挥<strong>宪法在治国理政中的重要作用</strong>，坚定维护宪法尊严和权威，推动宪法完善和发展，这是<strong>我国宪法保持生机活力</strong>的<strong>根本原因</strong>所在。&#x3D;&#x3D;</p>
<h4 id="我国宪法的地位和基本原则-选"><a href="#我国宪法的地位和基本原则-选" class="headerlink" title="我国宪法的地位和基本原则[选]"></a>我国宪法的地位和基本原则[选]</h4><h5 id="x3D-x3D-社会主义法律的本质特征-x3D-x3D"><a href="#x3D-x3D-社会主义法律的本质特征-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;社会主义法律的本质特征&#x3D;&#x3D;"></a>&#x3D;&#x3D;社会主义法律的本质特征&#x3D;&#x3D;</h5><p>1.我国社会主义法律体现<strong>党的主张和人民意志的统一</strong><br>我国社会主义法律既<strong>具有鲜明的阶级性</strong>，又具有<strong>广泛的人民性</strong>，<strong>体现了阶段性与人民性的统一</strong></p>
<p>2.我国社会主义法律具有<strong>科学性</strong>和<strong>先进性</strong> + [阶级性 人民性]</p>
<p>3.我国社会主义法律是中国特色社会主义制度的保障</p>
<p><strong>(一）我国宪法的地位</strong><br>我国宪法实现了<strong>党的主张</strong>和<strong>人民意志</strong>的高度统一，具有<strong>显著优势、坚实基础、强大生命力</strong>。宪法至上地位主要体现在其特有的作用、效力和内容等方面。我国宪法是<strong>具有最高的法律地位</strong>、法律权威、法律效力，是<strong>国家各项制度和法律法规的总依据</strong><br>宪法在中国特色社会主义法律体系中居于<strong>统帅地位</strong>，是其他法律的立法基础和立法依据。</p>
<p>&#x3D;&#x3D;<u>1.我国宪法是<strong>国家的根本法</strong>，是党<strong>和人民意志的集中体现</strong>。</u><br>2.<u>我国宪法是<strong>国家各项制度</strong>和<strong>法律法规</strong>的<strong>总依据</strong></u>。<strong>宪法</strong>在中国特色社会主义法律体系中居于<strong>统帅地位</strong>。<br>3.<u>我国宪法规定了<strong>国家的根本制度</strong></u>。<br>我国宪法确立了<strong>中国共产党的领导地位</strong>，规定了国家的根本任务、领导核心、指导思想、基本原则、发展道路、奋斗目标。<br>4.宪法是<strong>实现国家认同、凝聚社会共识、促进个人发展</strong>的<strong>基本准则</strong>，是维系一个国家、一个民族凝聚力的<strong>根本纽带</strong>。&#x3D;&#x3D;</p>
<p><strong>宪法</strong>的制定：由国家成立<strong>专门委员会起草</strong>，提交全国人民代表大会通过<br><strong>宪法</strong>的修改：全国人大常委会或<strong>五分之一以上的全国人大代表</strong>提出议案，并由<strong>全国人大以全体代表的三分之二</strong>以上的<strong>多数</strong>通过</p>
<p><u><strong>国体</strong></u>：我国宪法确定了工人阶级领导的、以工农联盟为基础的人民民主专政的国体<br><u>根本制度</u>：确立了社会主义制度是中华人民共和国的根本制度<br><u><strong>政体</strong></u>：确立了人民代表大会制度的政体<br><u>社会主义基本<strong>政治</strong>制度</u>：确立了中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度<br><u>社会主义基本<strong>经济</strong>制度</u>：公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制</p>
<p>精神纽带是核心价值观<br>精神家园是文化<br>根本纽带是宪法</p>
<p><strong>(二)  我国宪法的基本原则</strong><br>&#x3D;&#x3D;1.<strong><u>党的领导原则</u>。中国共产党</strong>是中国特色社会主义事业的<strong>领导核心</strong>。<br>2.<strong><u>人民当家作主</u><strong>原则。</strong>人民当家作主</strong>是社会主义民主政治的<strong>本质和核心</strong>。<br>3.<strong><u>尊重和保障人权</u><strong>原则。</strong>法治</strong>是<strong>人权</strong>得以<strong>实现的保障</strong><br>4.<strong><u>社会主义法治</u><strong>原则。我国宪法明确规定; “中华人民共和国实行依法治国，建设</strong>社会主义法治国家</strong>。”<strong>社会主义法治原则</strong>要求坚持<strong>宪法法律至上、法律面前人人平等</strong>，推进<strong>国家各项工作法治化</strong>，维护<strong>社会公平正义</strong>，维护<strong>社会主义法制的统一和尊严</strong>。<br>5.<strong><u>民主集中制</u><strong>原则。民主集中制是我国</strong>国家组织形式和活动方式</strong>的<strong>基本原则</strong>，是我<strong>国国家制度的突出特点和优势</strong>，也是集中全党全国人民集体智慧，实现科学决策、民主决策的<strong>基本原则</strong>和<strong>主要途径</strong>。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;宪法的<strong>根基</strong>在于人民的<strong>发自内心的拥护</strong>，宪法的<strong>伟力</strong>在于<strong>人民出自真诚的信仰</strong>。&#x3D;&#x3D;</p>
<h4 id="加强宪法实施与监督"><a href="#加强宪法实施与监督" class="headerlink" title="加强宪法实施与监督"></a>加强宪法实施与监督</h4><p>(一）加强宪法实施【怎么实施】<br><u>加强宪法实施，我们党<strong>首先</strong>要坚持<strong>依宪执政</strong></u>，国家权力机关要加强和改进立法工作，国家行政机关、监察机关和司法机关要严格执行法律，维护宪法法律尊严。<br>1.坚持<strong>依宪执政</strong>。宪法是我们党长期执政的根本法律据，我们党首先要带头尊崇和执行宪法。<br>2.坚持<strong>依法立法</strong>。国家权力机关要加强和改进立法工作<br>3.坚持<strong>严格执法</strong>。国家行政机关要坚持依宪施政、依法行政，严格规范政府行为</p>
<h3 id="自觉尊法学法守法用法"><a href="#自觉尊法学法守法用法" class="headerlink" title="自觉尊法学法守法用法"></a>自觉尊法学法守法用法</h3><h4 id="培养社会主义法治思维"><a href="#培养社会主义法治思维" class="headerlink" title="培养社会主义法治思维"></a>培养社会主义法治思维</h4><p><strong>(一)  法治思维及其内涵</strong><br>&#x3D;&#x3D;<strong>法治思维</strong>是指以<strong>法治价值</strong>和<strong>法治精神</strong>为导向，运用法律原则、法律规则、法律方法思考和处理问题的<strong>思维模式</strong>。&#x3D;&#x3D;<br>内涵:<br>&#x3D;&#x3D;第一，法治思维以<strong>法治价值</strong>和<strong>法治精神</strong>为指导蕴含着公正、平等、民主、人权等法治理念，是一种<strong>正当性思维</strong>。<br>第二，法治思维以<strong>法律原则</strong>和<strong>法律规则</strong>为依据指导人们的社会行为，是一种<strong>规范性思维</strong>。<br>第三，法治思维以<strong>法律手段</strong>与<strong>法律方法</strong>为依托分析问题、处理问题、解决纠纷，是一种<strong>逻辑思维</strong>。<br>第四，法治思维是一种<strong>符合规律、尊重事实</strong>的<strong>科学思维</strong>。&#x3D;&#x3D;</p>
<p><strong>(二)  法治思维的基本内容</strong><br>法治思维的内涵丰富、外延宽广，主要表现为<strong>价值取向</strong>和<strong>规则意识</strong>两个方面。<br><strong>价值取向</strong>是指如何看待和对待法律<br><strong>规则意识</strong>是指如何用法律看待和对待自身<br>一般来讲，法治思维主要包括<strong>法律至上、权力制约、公平正义、权利保障、程序正当</strong>等内容。</p>
<p><strong>1.法律至上。</strong><br><u><strong>法律至上</strong>是指在国家或社会的所有规范中，法律是地位最高、效力最广、强制力最大的规范</u>。法律至上具体表现为法律的&#x3D;&#x3D;<strong>普遍适用性、优先适用性</strong>和<strong>不可违抗性</strong>&#x3D;&#x3D;</p>
<p><strong>2.权力制约。</strong><br><strong>权力制约</strong>是指国家机关的权力必须受到法律的<strong>规制和约束。</strong><br>&#x3D;&#x3D;权力制约包括<strong>权力由法定、有权必有责、用权受监督、违法受追究</strong>四项要求。&#x3D;&#x3D;</p>
<p><strong>3.公平正义。</strong><br><strong>公平正义</strong>是指社会的政治利益、经济利益和其他利益在全体社会成员之间合理、公平分配和占有。一般来讲，&#x3D;&#x3D;公平正义主要包括<strong>权利公平、机会公平、规则公平</strong>和<strong>救济公平</strong>。&#x3D;&#x3D;</p>
<ol>
<li>&#x3D;&#x3D;<strong>权利公平</strong>包括三重含义;&#x3D;&#x3D;<br>一是权利主体平等，国家对每个权利主体”不偏袒””非歧视”;<br>二是享有的权利特别是基本权利平等;<br>三是权利保护和权利救济平等。</li>
<li>&#x3D;&#x3D;<strong>机会公平</strong>是指生活在同一社会中的成员拥有相同的发展机会和发展前景反对任何形式的歧视。&#x3D;&#x3D;<br>机会公平包括:<br>① 国家和社会要积极为社会成员的发展创造条件，并努力创造平等的起点;<br>② 社会成员的发展进步权要受到同等尊重，不断拓展社会成员的发展领域;<br>③ 不仅要关注当代人的机会平等，还要考虑后代人的机会平等。</li>
<li>&#x3D;&#x3D;<strong>公平正义</strong>。&#x3D;&#x3D;<br><u>规则公平</u>是指对所有人适用同一规则和标准，不得因人而异。包括:<br>①法律<strong>规则</strong>面前人人平等<br>②法律<strong>内容</strong>面前人人平等<br>③法律<strong>保护</strong>面前人人平等<br>任何人不得享有法律之外的特权，任何人也不会被法律排除在保护之外。<br><u>救济公平</u>是指为权利受到侵害或处于弱势地位的公民提供平等有效的救济。<br>救济公平包括:<br><u>司法救济</u>司法要公正对待每一个当事人，致力于实现司法公正;<br><u>行政救济</u>公平，即政府对需要救济的社会成员提供的救济服务要一律平等，不得区别对待;<br><u>社会救济</u>公平，即社会对需要救济的社会成员提供的社会救济服务要一律平等，不得厚此薄彼。</li>
</ol>
<p>4.<strong>权利保障</strong>主要是指对公民权利的法律保障，具体包括公民权利的<strong>宪法保障、立法保障、行政保障和司法保障。</strong><br>&#x3D;&#x3D;<strong>宪法保障</strong>是权利保障的<strong>前提和基础</strong>&#x3D;&#x3D;。宪法表明尊重和保障人权的鲜明态度，确立保障权利的有效机制，明确列出宪法保障的公民基本权利，能够推动整个国家和法律体系加强权利保障。<br>&#x3D;&#x3D;<strong>立法保障</strong>是权利保障的<strong>重要条件</strong>&#x3D;&#x3D;。宪法有关基本权利的规定一般较为原则，各具体权利的保障由立法机关通过立法作出明确规定。<br>&#x3D;&#x3D;<strong>行政保障</strong>是权利保障的<strong>关键环节</strong>&#x3D;&#x3D;。行政机关在行使行政管理权的过程中必然要涉及处置社会成员的利益问题，很容易发生损害或侵犯公民权利的现象。行政机关是否能够有效地保护公民权利，直接反映出一个国家的权利保障状况。<br>&#x3D;&#x3D;<strong>司法保障</strong>是公民权利保障的<strong>最后防线</strong>&#x3D;&#x3D;，既是解决个人之间权利纠纷的有效渠道也是纠正和遏制行政机关侵犯公民权利的有力机制。</p>
<p>5.<strong>程序正当</strong>。做一件事情，往往需要按照一定的程序只有按照程序做，才能防止主观任性、无序混乱。只有严格按照法律程序办事办案，处理结果才可能公正并具有公信力和权威性。程序的正当，表现&#x3D;&#x3D;在程序的<strong>合法性、中立性、参与性、公开性、时限性</strong>等方面&#x3D;&#x3D;</p>
<h4 id="依法行使权利与履行义务"><a href="#依法行使权利与履行义务" class="headerlink" title="依法行使权利与履行义务"></a>依法行使权利与履行义务</h4><p><strong>(一)  法律权利与法律义务</strong></p>
<p>1.法律权利<br>&#x3D;&#x3D;<strong>法律权利</strong>是指由一定的社会物质生活条件所制约的行为自由，是法律所允许的权利人为了满足自己的利益而采取的、由其他人的法律义务所保障的法律手段。&#x3D;&#x3D;</p>
<p><strong>特征:</strong><br>&#x3D;&#x3D;一是法律权利的内容、种类和实现程度<strong>受社会物质生活条件的制约</strong>。<br>二是法律权利的内容、分配和实现方式<strong>因社会制度</strong>和<strong>国家法律</strong>的不同而<strong>存在差异</strong>。<br>三是法律权利不仅由法律规定或认可，而且<strong>受法律维护或保障</strong>，具有<strong>不可侵犯性</strong>。<br>四是法律权利<strong>必须依法行使</strong>，不能不择手段地行使法律权利。&#x3D;&#x3D;</p>
<p>2.法律义务<br>法律义务是指由一定的社会物质生活条件所制约的社会责任，是保证法律所规定的义务人按照权利人要求从事一定行为或不从事一定行为以满足权利人利益的法律手段。<br>两种形式: 一种是&#x3D;&#x3D;<strong>作为</strong>&#x3D;&#x3D;，是指义务人实施<strong>积极的行为</strong>; 另一种是&#x3D;&#x3D;<strong>不作为</strong>&#x3D;&#x3D;，是指义务人<strong>不得实施某种行为</strong>。<br>特点:<br>&#x3D;&#x3D;第一，法律义务<strong>是历史的</strong>。<br>第二，法律义务<strong>源于现实需要</strong>。<br>第三，法律义务<strong>必须依法设定</strong>。<br>第四，法律义务<strong>可能发生变化</strong>。&#x3D;&#x3D;</p>
<p>3.<strong>法律权利</strong>与<strong>法律义务</strong>的<strong>关系</strong>。<br>①<u>法律权利与法律义务就像<strong>一枚硬币的两面，不可分割，相互依存</strong>。</u><br>②<u><strong>法律权利的实现</strong>必须<strong>以</strong>相应<strong>法律义务的履行</strong>为<strong>条件</strong>;<strong>法律义务的设定和履行</strong>也必须以<strong>法律权利的行使</strong>为根据。</u><br>③离开了法律权利，法律义务就失去了履行的<strong>价值和动力</strong>;离开了法律义务，法律权利也<strong>形同虚设</strong>。<br>④有些法律权利和法律义务具有<strong>复合性的关系</strong>，即一个行为可以同时<strong>是权利行为和义务行为</strong>，如<strong>劳动</strong>的权利和义务、<strong>接受义务教育</strong>的权利和义务等。</p>
<p>&#x3D;&#x3D;<strong>(二）我国宪法法律规定的权利</strong>&#x3D;&#x3D;<br>1.<span style= "color:red"><strong>政治权利</strong></span>，是公民<strong>参与国家政治活动</strong>的权利和自由的<strong>统称</strong>。<br>一是&#x3D;&#x3D;<strong>选举权</strong>&#x3D;&#x3D;，即选举权与被选举权，是指人们依法享有的参加创设或组织国家权力机关、代表机关的权利。<br>二是&#x3D;&#x3D;<strong>表达权</strong>&#x3D;&#x3D;，即公民依法享有的<u>表达自己对国家公共生活的看法、观点、意见的权利</u>。表达权对于一个国家的政治、经济、文化、科技、道德的发展具有基础性作用。<br>三是&#x3D;&#x3D;<strong>民主管理权</strong>&#x3D;&#x3D;，即公民根据宪法法律规定，管理国家事务、经济和文化事业以及社会事务的权利。<br>四是&#x3D;&#x3D;<strong>监督权</strong>&#x3D;&#x3D;，即公民依据宪法法律规定监督国家机关及其工作人员活动的</p>
<p>2.<span style= "color:red"><strong>人身权利</strong></span>，是指公民的人身不受非法侵犯的权利。它是公民参加国家政治、经济与社会生活的<strong>基础</strong>，是公民权利的重要内容。<br>包括:<br>一是&#x3D;&#x3D;<strong>生命健康权</strong>&#x3D;&#x3D;，即<strong>维持生命存在的权利</strong>。是人<strong>最基本、最原始</strong>的权利，具有<strong>神圣性与不可转让性</strong>，不可非法剥夺，享有<u>生命权是人享有<strong>其他各项权利的前提</strong></u>。<br>二是&#x3D;&#x3D;<strong>人身自由权</strong>&#x3D;&#x3D;，是我们一切<strong>行动</strong>和<strong>生活</strong>的前提。<br>三是&#x3D;&#x3D;<strong>人格尊严权</strong>&#x3D;&#x3D;，<strong>人格尊严权的基本内容</strong>有<strong>姓名权、肖像权、名誉权、荣誉权、隐私权</strong>等。<br>四是&#x3D;&#x3D;<strong>住宅安全权</strong>&#x3D;&#x3D;，也称<strong>住宅不受侵犯权</strong>，即公民居住、生活、休息的场所<strong>不受非法侵入</strong>或<strong>搜查的权利</strong>。<br>五是&#x3D;&#x3D;<strong>通信自由权</strong>&#x3D;&#x3D;，即公民通过书信、电报、传真、电话及其他通信手段，根据自己的意愿进行通信，不受他人干涉的权利。</p>
<p>3.<span style= "color:red"><strong>财产权利</strong></span>，是指公民、法人或其他组织通过劳动或其他合法方式<strong>取得财产</strong>和<strong>占有、使用、收益、处分</strong>财产的权利。<br>财产权主要包括:<br><u>一是<strong>私有财产权</strong>，即公民个人所有的以财产利益为内容，直接体现财产利益的民事权利。</u><br><u>二是<strong>继承权</strong>，是指继承人依法取得被继承人遗产的资格。</u></p>
<p>4.<span style= "color:red"><strong>社会经济权利</strong></span>，是指公民要求国家根据社会经济的发展状况，积极采取措施干预社会经济生活，加强社会建设，提供社会服务，以促进公民的自由和幸福，保障公民过上健康而有尊严的生活的权利。<br>主要包括:<br>一是<strong>劳动权</strong>是指一切有劳动能力的公民有获得劳动的机会和适当的劳动条件和报酬的权利。<br>二是<strong>休息权</strong>，是指劳动者在付出一定的劳动以后所享有的休息和休养的权利，是劳动权存在和发展的基础。<br>三是<strong>社会保障权</strong>。是指公民享有的要求国家提供维持有尊严的生活条件的权利。如<strong>国家和社会的保障、社会保障制度</strong>等。<br>四是<strong>物质帮助权</strong>，是指公民在法定条件下有从国家和社会获得物质帮助权利，如<strong>社会保险、社会救济</strong>和<strong>医疗卫生事业</strong>等。</p>
<p>5.<strong>宗教信仰自由</strong>，是指公民依据内心的信念，自愿地信仰宗教的自由。具体内容包<strong>括信仰宗教的自由、从事宗教活动的自由、举行或参加宗教仪式</strong>的自由等。<br>我国宪法规定:“<strong>国家保护正常的宗教活动。任何人不得利用宗教进行破坏社会秩序、损害公民身体健康、妨碍国家教育制度的活动。宗教团体和宗教事务不受外国势力的支配。</strong>“</p>
<p>6.<strong>文化教育权利</strong>，是公民按照宪法的规定在文化和教育领域享有的权利，主要包括<strong>教育方面的权利</strong>和<strong>文化活动方面的权利</strong>。<br><strong>教育方面的权利</strong>主要表现为<strong>受教育权</strong>。受教育权是公民在教育领域享有的基本权利，是公民接受文化、科学等方面训练的权利。<br><strong>文化活动方面的权利</strong>主要表现为<strong>公民的文化权利</strong>，主要包括<strong>科学研究的自由、文学艺术创作的自由、进行其他文化活动的自由</strong>三方面内容。</p>
<p><strong>(三）依法行使法律权利</strong><br>&#x3D;&#x3D;<strong>1.权利行使目的的正当性。</strong>&#x3D;&#x3D;<br><u>公民在行使法律权利时，不仅要在<strong>形式上</strong>符合相关法律的规定，也要<strong>符合立法意图和精神</strong>，不得违反宪法法律确定的基本原则，保障权利行使的正当性。</u><br>此外，行使权利不得破坏公序良俗，妨碍法律的社会功能和法律价值的实现。如赋予公民言论自由权的目的在于<strong>保障思想自由，不能将该权利作为打击不同意见、钳制思想自由的手段</strong>; 赋予公民宗教信仰自由的目的在于保障精神自由，不能借此宣传邪教和迷信思想。</p>
<p>&#x3D;&#x3D;<strong>⒉.权利行使的必要限度。</strong>&#x3D;&#x3D;<br>任何权利的行使都不是绝对的，都有其相应的限度，必须依照法律规定的限度来行使权利。<br>我国宪法规定:“<strong>中华人民共和国公民在行使自由和权利的时候，不得损害国家的、社会的、集体的利益和其他公民的合法的自由和权利</strong>“如果因行使自己权利而损害了国家、集体或他人的利益，超出了国家法律所许可和保障的范围与界限，则不再是行使权利而是侵权，会受到法律追究。</p>
<p>&#x3D;&#x3D;<strong>3.权利行使方式的法定性。</strong>&#x3D;&#x3D;<br>权利行使的方式分为<strong>口头方式、书面方式和行为方式</strong><br>有时口头方式和书面方式可以兼用。</p>
<p>&#x3D;&#x3D;<strong>4.权利行使的正当程序。</strong>&#x3D;&#x3D;<br>由于一个人行使权利的过程可能就是另一个人履行义务的过程，所以<strong>程序正当原则</strong>同样适用于权利行使过程。<br>通常情况下，行使权利的程序是法律规定的。<br>如<strong>选举程序</strong>:  确定<strong>选民资格、选民登记、发放选民证</strong><br><strong>推荐候选人、选举投票、确定当选人</strong>等流程;<br>我国专利法对<strong>专利的申请、审查和批准程序</strong>作了规定<br>公民应当严格依照法律规定的程序行使相关权利。</p>
<p><strong>(四）依法履行法律义务</strong><br>&#x3D;&#x3D;1.<strong>维护国家统一和民族团结</strong>的义务。&#x3D;&#x3D;<br><strong>维护国家统一</strong>是整个<strong>社会共同体存在和发展的基础</strong>，也是以宪法为核心的整个法律制度存在的基础。同时，<strong>国家统一</strong>也是公民实现法律权利与自由的<strong>前提</strong>。<br>《<strong>反分裂国家法</strong>》明确规定：“<strong>维护国家主权和领土完整是包括台湾同胞在内的全中国人民的共同义务。</strong>“</p>
<p>2.我国&#x3D;&#x3D;宪法规定了若干具体义务&#x3D;&#x3D;，主要包括以下:<br>&#x3D;&#x3D;一是<strong>保守国家秘密</strong><br>二是<strong>爱护公共财产</strong><br>三是<strong>遵守劳动纪律</strong><br>四是<strong>遵守公共秩序</strong><br>五是<strong>尊重社会公德<del>[遵纪守法]</del></strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;3.维护<strong>祖国安全、荣誉和利益</strong>的义务&#x3D;&#x3D;。<br><strong>国家安全</strong>是指国家的领土完整和主权不受侵犯，国家政权不受威胁。<strong>国家安全</strong>是国家政权稳定和公民依法行使权利与自由的<strong>根本保障</strong>。<br><strong>国家荣誉</strong>是指国家的声誉和尊严。<br><strong>国家利益，对外</strong>主要是指<strong>民族的政治经济、文化</strong>等方面的权利和利益;<strong>对内</strong>主要是指<strong>公共利益</strong>。</p>
<p>&#x3D;&#x3D;<strong>4.依法服兵役的义务。</strong>&#x3D;&#x3D;<br>我国实行<strong>义务兵</strong>与<strong>志愿兵</strong>相结合、<strong>民兵与预备役</strong>相结合的<strong>兵役制度</strong>。我国公民都有义务依法服兵役。根据我国兵役法规定，每年<strong>12月31日以前年满18周岁的男性公民，应当被征集服现役</strong>。同时，我国兵役法对服兵役的主体作了限制性规定。<br>①有<strong>严重生理缺陷或者严重残疾</strong>不适合服兵役的人，<strong>免服兵役</strong>;<br>②依照法律<strong>被剥夺政治权利的人，不得服兵役</strong>;<br>③应征公民是<strong>维持家庭生活唯一劳动力的</strong>，可以<strong>缓征</strong>;<br>④应征公民正在被依法侦查、起诉、审判的或者被判处徒刑、拘役、管制正刑的，<strong>不征集</strong>;<br>⑤<strong>普通高等学校毕业生</strong>的征集年龄可以放宽至<strong>24周岁</strong>。</p>
<p>&#x3D;&#x3D;<strong>5.依法纳税的义务。</strong>&#x3D;&#x3D;<br>在现代社会中，<strong>税收</strong>是<strong>国家财政收入</strong>的<strong>主要来源</strong>，纳税是公民应该履行的一项<strong>基本义务</strong>。<br>根据我国个人所得税法的规定，<strong>在中国境内有住所或者无住所而在境内居住满一年的个人，从中国境内和境外取得的所得，依法缴纳个人所得税。</strong></p>
<h4 id="不断提升法治素养-x3D-x3D-当代大学生如何提升自身素养-x3D-x3D-？"><a href="#不断提升法治素养-x3D-x3D-当代大学生如何提升自身素养-x3D-x3D-？" class="headerlink" title="不断提升法治素养[&#x3D;&#x3D;当代大学生如何提升自身素养&#x3D;&#x3D;？]"></a>不断提升法治素养[&#x3D;&#x3D;当代大学生如何提升自身素养&#x3D;&#x3D;？]</h4><p>&#x3D;&#x3D;<strong>(一）尊重法律权威</strong>&#x3D;&#x3D;<br>人民权益要靠法律保障，法律权威要靠人民维护。人民是国家的主人翁，是法治国家的建设者和捍卫者，尊重法律权威是其法定义务和必备素质。<br>做法要求<br>&#x3D;&#x3D;① <strong>尊重法律权威</strong>，就要<strong>信仰法律</strong>，对法律常怀敬畏之心;<br>② 就要<strong>遵守法律</strong>，用实际行动捍卫法律尊严，保障法律实施;<br>③ 就要<strong>服从法律</strong>，拥护法律的规定，接受法律的约束，履行法定的义务，服从依法进行的管理，承担相应的法律责任;<br>④ 就要<strong>维护法律</strong>，争当法律权威的守望者、公平正义的守护者、具有良知的护法者。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>(二)  学习法律知识</strong>&#x3D;&#x3D;<br>1.<strong>学习和掌握基本的法律知识</strong>，是<strong>提升法治素养的前提</strong>。<br>参与法治实践的方式和途径越来越多，如:<br>一是<strong>参与立法讨论</strong><br>二是<strong>旁听司法审判</strong><br>三是<strong>参与校园法治文化活动</strong></p>
<p>&#x3D;&#x3D;<strong>(三）养成守法习惯</strong>&#x3D;&#x3D;<br>1.<strong>增强规则意识</strong>。<br>养成规则意识、坚持守法守规是每一个法治国家公民的基本素养。大学生参与社会活动，实施个人行为，都要<strong>以法律为依据，不得违反法律规范</strong>。</p>
<p><strong>2.守住法律底线。</strong><br>**<u>法律红线不可逾越，法律底线不可触碰</u>**。法律不能成为”橡皮泥””稻草人”，触犯法律底线就要受到追究。</p>
<p>&#x3D;&#x3D;<strong>(四）提高用法能力</strong>&#x3D;&#x3D;<br>1.<strong>维护自身权利</strong>。<br>大学生要增强权利意识，用法处理纠纷，依法维权护权。2.<strong>维护社会利益</strong>。<br>大学生除了要运用法律维护自身权利外，还要通过法律维护社会公共利益，对违法犯罪行为要敢于揭露、勇于抵制，消除袖手旁观、畏缩不前的恐惧心理，抵制遇事回避的惧法现象。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/政治" style=color:#00bcd4>
                政治
            </a>
        </span>
        
    </div>

    <a href="/2023/01/16/政治/(思修)第六章-法律特征,依法治国,维护宪法,遵学收守用法/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/01/15/政治/(思修)第五章-道德核心原则、优秀道德成果、向善道德实践/">
        <h2>
            (思修)第五章-道德核心原则、优秀道德成果、向善道德实践
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="遵守道德规范，锤炼道德品格"><a href="#遵守道德规范，锤炼道德品格" class="headerlink" title="遵守道德规范，锤炼道德品格"></a>遵守道德规范，锤炼道德品格</h1><h4 id="社会主义道德的核心与原则"><a href="#社会主义道德的核心与原则" class="headerlink" title="社会主义道德的核心与原则"></a>社会主义道德的核心与原则</h4><h5 id="坚持马克思主义道德观"><a href="#坚持马克思主义道德观" class="headerlink" title="坚持马克思主义道德观"></a>坚持马克思主义道德观</h5><p><strong>(一）道德的含义</strong><br>&#x3D;&#x3D;<strong>道德</strong>是一种特殊的<strong>社会意识形态</strong>，它是以善恶为评价方式，主要依靠<strong>社会舆论、传统习俗和内心信念</strong>来发挥作用的<strong>行为规范的总和</strong>。&#x3D;&#x3D;<br><strong>核心价值观</strong> 是评价 <u>是非曲直</u> 的标准<br><strong>道德</strong> 是评价 <u>善恶</u> 的标准</p>
<p><strong>(二)  道德的起源</strong></p>
<h6 id="x3D-x3D-”天意神启论”-‘’先天人性论”-“情感欲望论”-‘’动物本能论’’-x3D-x3D"><a href="#x3D-x3D-”天意神启论”-‘’先天人性论”-“情感欲望论”-‘’动物本能论’’-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;”天意神启论” ‘’先天人性论” “情感欲望论” ‘’动物本能论’’&#x3D;&#x3D;"></a>&#x3D;&#x3D;”天意神启论” ‘’先天人性论” “情感欲望论” ‘’动物本能论’’&#x3D;&#x3D;</h6><p>1.自古以来，人们就在探讨道德的起源并提出了种种见解或理论。<br>可以说，在马克思主义产生之前，这些关于道德起源的观点，要么是<strong>主观唯心主义</strong>或<strong>客观唯心主义</strong>的注解，要么是旧唯物主义形而上学的分析，均<strong>无法正确揭示道德的起源</strong>。</p>
<p>2.&#x3D;&#x3D;马克思主义道德的<strong>科学起源</strong>&#x3D;&#x3D;<br>马克思主义道德观认为，人类社会的实际情况是，”<strong>物质生活的生产方式</strong>制约着整个社会生活、政治生活和精神生活的过程”。</p>
<h4 id="x3D-x3D-马克思主义道德起源的三个条件-x3D-x3D"><a href="#x3D-x3D-马克思主义道德起源的三个条件-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;马克思主义道德起源的三个条件&#x3D;&#x3D;"></a>&#x3D;&#x3D;马克思主义道德起源的三个条件&#x3D;&#x3D;</h4><blockquote>
<p>1）<strong>劳动</strong>是<strong>道德起源</strong>的<strong>首要前提</strong>。<br>道德是<strong>人类社会的特有现象</strong>，动物的本能行为中不存在真正的道德。<u>劳动创造了人和人类社会，是道德起源的第一个历史前提。</u><br>2）<strong>社会关系</strong>是<strong>道德</strong>赖以产生的<strong>客观条件</strong>。<br>在生产生活的实践活动中，人类必然要发生各种各样的人际交往和社会关系，各种利益关系更为凸显。<br>3）人的<strong>自我意识</strong>是道德产生的<strong>主观条件</strong>。<br>意识是道德产生的思想认识前提。</p>
</blockquote>
<p><strong>(三）道德的本质</strong><br>1.&#x3D;&#x3D;<strong>道德</strong>是反映<strong>社会经济关系</strong>的<strong>特殊意识形态</strong>&#x3D;&#x3D;。道德的产生、发展和变化，归根结底源于社会经济关系。</p>
<blockquote>
<p><u>其一，道德的<strong>性质</strong>和<strong>基本原则</strong>、<strong>规范</strong>反映了与之相应的社会经济关系的性质和内容。</u><br><u>其二，道德<strong>随着社会经济关系的变化而变化</strong>。</u><br><u>其三，道德<strong>作为一种社会意识</strong>，在阶级社会里总是反映着一定阶级的利益，因而不可避免地<strong>具有阶级性</strong>。</u><br><u>其四，作为社会意识的道德一经产生，便有<strong>相对独立性</strong>。</u></p>
</blockquote>
<p>2.道德是<strong>社会利益关系的特殊调节方式</strong>。<br>作为一种调整人与人、人与社会、人与自然以及人与自身之间关系的特殊的行为规范，道德与法律规范、政治规范的不同之处在于，它是用善恶标准去评价，依靠社会舆论、传统习俗、内心信念来维持的，因此是一种<strong>非强制性的规范</strong>。</p>
<p>3.道德是一种<strong>实践精神</strong>。<br>作为实践精神，道德是一种旨在<strong>通过把握世界的善恶现象而规范人们的行为</strong>，并通过人们的实践活动体现出来的<strong>社会意识</strong>。具体来说，道德是一种以指导人的行为为目的、以形成人的正确行为方式为内容的精神，在<strong>本质上</strong>是<strong>知行合一</strong>的</p>
<p><strong>(四)  道德的功能与作用</strong> [<del>道德万能论、道德无用论</del>]</p>
<h5 id="1-道德的功能"><a href="#1-道德的功能" class="headerlink" title="1.道德的功能"></a>1.道德的功能</h5><p>道德的功能，一般是指道德作为社会意识的特殊形式对于社会发展所具有的功效与作用。道德的功能是多元的，同时也是多层次的。在道德的功能系统中，&#x3D;&#x3D;<strong>认识功能、规范功能、调节功能</strong>是最基本的功能&#x3D;&#x3D;。<br>1）道德的<strong>认识功能</strong>是指道德反映社会关系特别是反映社会经济关系的功效与能力。<br>2）道德的<strong>规范功能</strong>是指在正确善恶观的指引下，规范社会成员在社会公共领域、职业领域、家庭领域的行为，并规范个人品德的养成，引导并促进人们崇德向善。<br>3）道德的<strong>调节功能</strong>是指道德通过评价等方式指导和纠正人们的行为和实践活动、协调社会关系和人际关系的功效与能力。<br>&#x3D;&#x3D;<u><strong>道德评价</strong>是道德<strong>调节</strong>是主要形式</u>&#x3D;&#x3D;，社会舆论、传统习俗和人们的内心信念是道德调节所依赖发挥作用的力量。<br>法律是成文的道德，道德是人们内心的法律。 </p>
<h5 id="2-道德的作用"><a href="#2-道德的作用" class="headerlink" title="2.道德的作用"></a>2.道德的作用</h5><blockquote>
<p>道德对其赖以产生的经济基础的形成、巩固和发展具有促进作用<br>道德对其他社会意识形态具有重要影响<br>道德是影响社会生产力发展的重要力量<br>道德是维护社会秩序的重要手段<br>道德是个体发展、完善的内在动力<br>在阶级社会中，道德是阶级斗争的重要工具</p>
</blockquote>
<p>道德的作用是<u>指道德的<strong>认识、规范、调节、激励、导向、教育</strong>等功能的发挥和实现所产生的<strong>社会影响及实际效果</strong>。**”国无德不兴，人无德不立”<strong>，就生动表达了道德的作用</u>。<br>道德发挥作用的性质</strong>与<strong>社会发展的不同</strong>历史阶段相联系<strong>，</strong>由<strong>道德所反映的</strong>经济基础、代表的阶级利益所决定。**<br>只有<strong>反映先进生产力发展要求</strong>和<strong>进步阶级利益的道德</strong>，才会对社会的发展和人的素质的提高产生积极的推动作用，否则，就不利于甚至阻碍社会的发展和人的素质的提高。</p>
<p><strong>(五) 社会主义道德是崭新类型的道德</strong><br>1.道德的发展过程<br>道德同其他社会意识形态一样，不是亘古不变的。迄今为止，人类社会先后经历了<strong>五种基本社会形态</strong>，与此相适应，出现了&#x3D;&#x3D;<strong>原始社会的道德、奴隶社会的道德、封建社会的道德、资本主义社会的道德、社会主义社会的道德</strong>&#x3D;&#x3D;。在社会主义社会，有一部分先进分子还身体力行共产主义道德。</p>
<p>2.道德发展的规律<br>人类道德的发展是<strong>一个曲折上升的历史过程</strong>。人类道德发展的历史过程与社会生产方式的发展进程大体一致，这是道德发展的基本规律。<br>虽然在一定时期可能有某种停滞或倒退现象，但道德发展的总趋势是向上的、前进的，是沿着曲折的道路向前发展的，或者叫作<strong>螺旋式上升、波浪式前进</strong>。</p>
<p>3.与以往社会的道德形态相比，<strong>社会主义道德</strong>具有<strong>显著的先进性特征</strong>。这种先进性主要体现在以下几个方面。<br>&#x3D;&#x3D;<u>首先，社会主义道德是<strong>社会主义经济基础</strong>的反映。</u><br><u>其次，社会主义道德是<strong>对人类优秀道德资源</strong>的<strong>批判继承</strong>和<strong>创新发展</strong>。</u><br><u>最后，社会主义道德克服了以往阶级社会道德的<strong>片面性</strong>和<strong>局限性</strong></u>，<span style = "color : red">坚持以<strong>为人民服务为核心</strong>，坚持<strong>以集体主义为原则</strong></span>，展现出真实而强大的道义力量。&#x3D;&#x3D;</p>
<h4 id="坚持以为人民服务为核心"><a href="#坚持以为人民服务为核心" class="headerlink" title="坚持以为人民服务为核心"></a>坚持以为人民服务为核心</h4><p><u><strong>为什么人服务</strong>是<strong>道德的&#x3D;&#x3D;核心问题&#x3D;&#x3D;<strong>，决定并体现着道德建设的</strong>根本性质</strong>和<strong>发展方向</strong>，规定并制约着道德领域中的所有道德现象。</u><br><strong>为人民服务</strong>是中国共产党人把马克思主义基本原理与中国革命、建设、改革的具体实践相结合的<strong>伟大创造</strong>。<strong>为人民服务<del>共产党的宗旨</del><strong>，不仅是坚持</strong>历史唯物主义</strong>的<strong>必然要求</strong>，是中国共产党践行的<strong>根本宗旨</strong>，也是<strong>社会主义道德观的集中体现</strong>，是<strong>全体中国人民</strong>共同遵循的<strong>道德要求</strong>。[&#x3D;&#x3D;<u>为人民服务</u>作为<strong>社会主义道德的核心</strong>，是社会主义道德区别和优越于其他社会形态道德的<strong>显著标志</strong>&#x3D;&#x3D;]</p>
<h5 id="（一）社会主义道德的本质要求"><a href="#（一）社会主义道德的本质要求" class="headerlink" title="（一）社会主义道德的本质要求"></a>（一）社会主义道德的本质要求</h5><p>1.&#x3D;&#x3D;<strong>为人民服务</strong>是<strong>社会主义经济基础</strong>和<strong>人际关系</strong>的<strong>客观要求</strong>。&#x3D;&#x3D;<br>在社会主义社会，每个劳动者和建设者都在为社会、为他人同时也是为自己而劳动和工作。<br>各行各业的劳动者和建设者，只是社会分工不同，<strong>没有高低贵贱之分</strong>。在我国【社会主义的根本经济制度】：<u>公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等<strong>社会主义基本经济制度</strong></u>，是为人民服务的<strong>根本制度保证；团结互助、平等友爱、共同进步</strong>的人际关系，是为人民服务的<strong>广泛社会基础</strong>。</p>
<p>2.&#x3D;&#x3D;<strong>为人民服务</strong>是<strong>社会主义市场经济健康发展</strong>的要求。&#x3D;&#x3D;<br>在社会主义市场经济条件下，市场主体必须通过向社会和他人提供一定数量和质量的产品，<strong>建立</strong>满足社会和他人需求的<strong>良好信誉</strong>。<br>换句话说，社会主义市场经济，不仅不排斥为社会和他人服务，而且需要通过服务甚至是优质服务，才能实现市场主体的利益。</p>
<p><strong>（二）先进性与广泛性的统一</strong><br>2.<u><strong>为人民服务</strong>作为社会主义道德的<strong>核心</strong>，是社会主义道德<strong>区别和优越于</strong>其他社会形态道德的<strong>显著标志</strong>。</u><br>大学生践行为人民服务，就是要弘扬为人民服务的精神，尊重人、理解人、关心人，为人民、为社会、为国家多做好事、多作贡献。</p>
<h4 id="坚持以-x3D-x3D-集体主义-x3D-x3D-为原则"><a href="#坚持以-x3D-x3D-集体主义-x3D-x3D-为原则" class="headerlink" title="坚持以&#x3D;&#x3D;集体主义&#x3D;&#x3D;为原则"></a>坚持以&#x3D;&#x3D;集体主义&#x3D;&#x3D;为原则</h4><p><strong>道德原则</strong>是道德规范<strong>体系的总纲</strong>，它最直接最集中地反映着一定社会经济关系和利益关系的<strong>根本要求</strong>，代表着一定阶级的<strong>根本利益和长远利益</strong>。<br><strong>社会主义道德</strong>的原则是<strong>集体主义</strong>。在我国，<strong>国家</strong>利益、<strong>社会整体</strong>利益和<strong>个人</strong>利益根本上的一致性，使得集体主义应当而且能够在全社会范围内贯彻实施。</p>
<p><strong>(一）调节社会利益关系的基本原则</strong><br>长期以来，<strong>集体主义</strong>已经成为调节国家利益、社会整体利益和个人利益关系的<strong>基本原则</strong>。<br>1.&#x3D;&#x3D;集体主义强调<strong>国家利益、社会整体利益</strong>和<strong>个人利益</strong>的<strong>辩证统一</strong>&#x3D;&#x3D;<br>2.&#x3D;&#x3D;集体主义强调**<span style = "color : red">国家利益、社会整体利益高于个人利益</span><strong>&#x3D;&#x3D;<br>集体主义强调，在个<u>人利益与国家利益、社会整体利益发生矛盾尤其是</strong>发生激烈冲突的时候<strong>，必须坚持</strong>国家利益、社会整体利益高于个人利益的原则<strong>，即个人应当</strong>以大局为重<strong>，使个人利益服从国家利益、社会整体利益，</strong>在必要时作出牺牲<strong>。</u><br>集体主义要求个人为国家、社会作出牺牲并</strong>不是随意的<strong>，只有在不牺牲个人利益就不能保全国家利益、社会整体利益的情况下，</strong>才要求个人作出牺牲**。<br>3&#x3D;&#x3D;.<strong>集体主义重视和保障个人的正当利益</strong>&#x3D;&#x3D;</p>
<p><strong>(二）集体主义的层次性</strong><br>1.社会主义市场经济之所以需要集体主义，是因为其有助于克服市场自身的弱点和消极方面，有助于形成追求高尚、激励先进的良好社会风气，保证社会主义市场经济的有序健康发展。</p>
<p>2.根据我国现阶段经济社会生活和人们思想道德的实际，<strong>集体主义分为三个层次</strong>的道德要求。<br>&#x3D;&#x3D;<u>一是<strong>无私奉献、一心为公</strong></u>&#x3D;&#x3D;。即时时处处为集体利益着想，并甘愿为集体牺牲一切。这是&#x3D;&#x3D;集体主义的<strong>最高层次</strong>&#x3D;&#x3D;，是优秀共产党员、先进分子应努力达到的道德目标。<br>&#x3D;&#x3D;<u>二是<strong>先公后私、先人后己</strong></u>&#x3D;&#x3D;。即自觉把集体利益放在个人利益之上，在维护集<br>体利益的前提下，实现个人的正当利益。这是已经具有较高社会主义道德觉悟的人能够达到的要求，具有广泛的社会基础。<br>&#x3D;&#x3D;<u>三是<strong>顾全大局、遵纪守法、热爱祖国、诚实劳动，以正当合法的手段保障个人利益</strong></u>&#x3D;&#x3D;。这是对<strong>公民最基本的道德要求。</strong></p>
<p>3.集体主义离我们并不遥远，<strong>体现于具体的学习工作生活</strong>之中。<br>人人都可以而且<strong>应当践行集体主义原</strong>则，沿着道德的阶梯循序渐进地向上攀登。当代大学生应正确认识和处理国家利益、社会整体利益和个人利益的关系，自觉坚持个人利益<strong>服从集体利益</strong>、局部利益服从整体利益、当前利益<strong>服从长远利益</strong>，反对<strong>小团体主</strong>义、本位主义和<strong>极端个人主</strong>义。</p>
<h2 id="吸收借鉴优秀道德成果"><a href="#吸收借鉴优秀道德成果" class="headerlink" title="吸收借鉴优秀道德成果"></a>吸收借鉴优秀道德成果</h2><h4 id="传承中华传统美德"><a href="#传承中华传统美德" class="headerlink" title="传承中华传统美德"></a>传承中华传统美德</h4><p><u><strong>传统道德</strong>是历史上不同时代人们的<strong>行为方式、风俗习惯、价值观念</strong>和<strong>文化心理</strong>的集中体现，是对<strong>道德实践经验</strong>的<strong>提炼总结</strong></u>。中华传统美德是人类文明发展的重要精神财富，是社会主义道德建设的源头活水。</p>
<p><strong>(一)  中华传统美德的基本精神</strong></p>
<p>1.&#x3D;&#x3D;重视<strong>整体利益</strong>，强调<strong>责任奉献</strong>&#x3D;&#x3D;</p>
<p>传统道德中的义利之辨、理欲之辨，其&#x3D;&#x3D;<strong>核心</strong>和<strong>本质</strong>是<strong>公私之辨</strong>&#x3D;&#x3D;。”<strong>公义胜私欲</strong>“是<strong>中华传统美德的根本要求</strong>。<br><strong>《诗经》“夙夜在公”</strong> [从早到晚，勤于公务]<br><strong>《尚书》“以公灭私，民其允怀”</strong> [用公正消除私情，人民将会信任归服。 君子不镜于水，而镜于人]<br>西汉<strong>贾谊</strong>提出“<strong>国而忘家，公而忘私</strong>“<br>清代<strong>林则徐</strong>提出”<strong>苟利国家生死以，岂因祸福避趋之</strong>“<br><u>从国家利益和整体利益的原则出发，中国古代思想家强调在**”义”和”利”**发生矛盾时，应当&#x3D;&#x3D;<strong>义以为上、先义后利、见利思义、见义勇为</strong>&#x3D;&#x3D;。</u></p>
<p>2.&#x3D;&#x3D;推崇<strong>仁爱原则</strong>，注重<strong>以和为贵</strong>&#x3D;&#x3D;</p>
<p>孔子强调”<strong>己欲立而立人，己欲达而达人</strong>“<br>孟子强调”<strong>亲亲而仁民，仁民而爱物</strong>“<br>荀子强调”<strong>仁者自爱</strong>“，墨子则提出”<strong>兼相爱，交相利</strong>“</p>
<p>3.&#x3D;&#x3D;注重<strong>人伦关系</strong>，重视<strong>道德义务</strong>&#x3D;&#x3D;</p>
<p>《<strong>尚书</strong>》中”<strong>五教</strong>“的思想，即**”父义”“母慈””兄友””弟恭””子孝”**<br>战国时期，孟子提出了影响深远的**”五伦”说<strong>，即”父子有亲<br>君臣有义、夫妇有别、长幼有序、朋友有信”。<br>汉代以后,如</strong>董仲舒**提出了”<strong>仁、义、礼、智、信</strong>”<br>宋代的思想家们又提出了”<strong>忠、孝、节、义</strong>“四大德目等</p>
<p>4.&#x3D;&#x3D;追求<strong>精神境界</strong>，向往<strong>理想人格</strong>&#x3D;&#x3D;</p>
<p>孟子说，人之所以异于禽兽的根本就在于人能够”<strong>明于庶物，察于人伦</strong>“，即能本着”仁义”行事。<br>荀子说，人之所以能够保持群体性特征，归根结底是由于人能够遵守礼仪，否则人就会由于争斗而发生祸乱，进而造成彼此分离而变得弱小。<br>从先秦儒家所强调的孔颜之乐、”大丈夫”人格，<br><strong>范仲淹</strong>所提出的”<strong>先天下之忧而忧，后天下之乐而乐</strong>“</p>
<p>5.&#x3D;&#x3D;强调<strong>道德修养</strong>，注重<strong>道德践履</strong>&#x3D;&#x3D;</p>
<p><strong>《礼记》:”修身”是”齐家、治国、平天下“的前提和基础</strong><br><strong>孔子</strong>提倡”修己””克己”和”慎独”，提倡”<strong>见贤思齐焉，见不贤而内自省也</strong>“<br><strong>孟子</strong>更主张”<strong>善养吾浩然之气</strong>“。<br>墨家也非常重视修身，强调”<strong>察色修身</strong>“和”<strong>以身戴行</strong>“</p>
<h5 id="x3D-x3D-中国传统美德的时代价值在哪里？-x3D-x3D-【多-x2F-简】"><a href="#x3D-x3D-中国传统美德的时代价值在哪里？-x3D-x3D-【多-x2F-简】" class="headerlink" title="&#x3D;&#x3D;中国传统美德的时代价值在哪里？&#x3D;&#x3D;【多&#x2F;简】"></a>&#x3D;&#x3D;中国传统美德的时代价值在哪里？&#x3D;&#x3D;【多&#x2F;简】</h5><p><u>弘扬中华传统美德是中华民族伟大复兴的需要，建设中华民族共有的精神家园的需要，也是大学生成长成才的需要</u></p>
<p>(二）<strong>中华传统美德</strong>的<strong>创造性转化</strong>和<strong>创新性发展</strong></p>
<p>1.&#x3D;&#x3D;<strong>传统道德</strong>是一个<strong>矛盾体</strong>，具有<strong>鲜明的两重性</strong>。&#x3D;&#x3D;<br>属于<strong>精华的部分</strong>，表现出<strong>积极、革新、进步</strong>的一面;<br>属于<strong>糟粕的部分</strong>，则表现出<strong>消极、保守、落后</strong>的一面<br><strong>中华传统美德</strong>作为中国传统道德的<strong>精华部分</strong>，为今天的道德建设提供了丰富的资源，要在去粗取精、去伪存真的基础上坚持&#x3D;&#x3D;<strong>古为今用、推陈出新，不忘本来，辩证取舍</strong>&#x3D;&#x3D;，传承和弘扬中华传统美德。</p>
<p>2.&#x3D;&#x3D;<strong>加强</strong>对中华传统美德的<strong>挖掘</strong>和<strong>阐发</strong>。&#x3D;&#x3D;<br>弘扬中华传统美德，必须通过<strong>科学的分析和鉴别</strong>，把其中带有<strong>阶级和时代局限性</strong>的成分<strong>剔除出去</strong>，把其中具有<strong>当代价值的道德精神挖掘出来</strong>，总结传统美德中丰富的思想道德资源，对中华传统美德的<strong>德目、观点进行新的诠释和激活</strong>，结合现代生活赋予其新的时代内涵，努力推动中华传统美德的<strong>创造性转化和创新性发展</strong>。</p>
<p>3.&#x3D;&#x3D;用中华传统美德滋养社会主义道德建设&#x3D;&#x3D;<br>结合时代要求，按照是否有利于推动中国特色社会主义事业、是否有利于建设社会主义道德体系、是否有利于培育和践行社会主义核心价值观的标准</p>
<p>在对待传统道德的问题上，要反对两种错误思潮。<br>&#x3D;&#x3D;一种是”<strong>复古论</strong>”&#x3D;&#x3D;，认为道德建设的最终目标就是要<strong>恢复中国”固有文化”<strong>，形成以中国传统文化为主体的道德体系;<br>&#x3D;&#x3D;另一种是</strong>“虚无论”</strong>&#x3D;&#x3D;，认为中国传统道德从整体上来说在今天已<strong>经失去了价值和意义</strong>，必须从整体上予以<strong>全盘否定</strong>。<br>这两种观点都是错误的，<strong>割断了道德的历史与发展的关系</strong>，都不利于社会的发展和道德的进步。</p>
<h4 id="发扬中国革命道德"><a href="#发扬中国革命道德" class="headerlink" title="发扬中国革命道德"></a>发扬<strong>中国革命道德</strong></h4><p>&#x3D;&#x3D;<u><strong>中国革命道德</strong>是对中华传统美德的<strong>延续和发展</strong>。传承和发扬中国革命道德，是弘扬中华传统美德的<strong>应有之义</strong>，是加强社会主义道德建设的<strong>客观需要</strong>，也是激励大学生锤炼优良道德品质的<strong>必然要求</strong></u>。&#x3D;&#x3D;</p>
<p><strong>(一)  中国革命道德的形成与发展</strong><br><u><strong>中国革命道德</strong>，是指中国共产党人、人民军队、一切先进分子和人民群众在中国革命、建设、改革中所形成的优秀道德，是马克思主义与中国革命、建设、改革的伟大实践相结合的产物，是<strong>中华民族极其宝贵的道德财富</strong></u><br>&#x3D;&#x3D;中国革命道德<strong>萌芽</strong>于**<u>五四运动前后</u><strong>，</strong>发端于**<u>中国共产党成立以后蓬勃发展的伟大工人运动和农民运动</u>，经过<strong>土地革命战争、抗日战争、解放战争和社会主义革命、建设、改革</strong>的长期发展，逐渐形成并不断发扬光大。&#x3D;&#x3D;</p>
<p>革命道德的发展</p>
<blockquote>
<p>萌芽阶段：五四运动前后<br>发端阶段：中国共产党成立以后蓬勃发展的伟大工人运动和农1民运动<br>形成并不断发展：土地革命战争、抗日战争、解放战争以及社会主义革命、建设、改革的长期发展</p>
</blockquote>
<p><strong>(二)  &#x3D;&#x3D;中国革命道德的主要内容&#x3D;&#x3D;</strong><br>&#x3D;&#x3D;<strong>1.为实现社会主义和共产主义的理想信念而奋斗。</strong><br><strong>2.全心全意为人民服务。</strong><br><strong>3.始终把革命利益放在首位。</strong><br><strong>4.树立社会新风，建立新型人际关系。</strong><br><strong>5.修身自律，保持节操。</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>1.<strong>为实现社会主义和共产主义的理想信念而奋斗</strong>。社会主义和共产主义理想信念的不屈不挠的精神，是革命道德的灵魂。<br>2.<strong>全心全意为人民服务</strong>。全心全意为人民服务作为贯穿中国革命道德始终的<strong>一根红线</strong>。<del>习思想的理论特职：人民至上是贯穿的一根红线</del>【以人民为中心】<br>3.<strong>始终把革命利益放在首位。</strong><br>4.<strong>树立社会新风，建立新型人际关系</strong>。<br>5.<strong>修身自律，保持节操</strong>。中国革命道德还体现在共产党人对自身道德修养的重视方面。</p>
</blockquote>
<p>&#x3D;&#x3D;<strong>(三）中国革命道德的当代价值</strong>[时代价值]<br><strong>1.有利于加强和巩固社会主义和共产主义的理想信念。</strong><br><strong>2.有利于培育和践行社会主义核心价值观。</strong><br><strong>3.有利于引导人们树立正确的道德观。</strong><br><strong>4.有利于培育良好的社会道德风尚。</strong>&#x3D;&#x3D;</p>
<h4 id="借鉴人类文明优秀道德成果"><a href="#借鉴人类文明优秀道德成果" class="headerlink" title="借鉴人类文明优秀道德成果"></a>借鉴人类文明优秀道德成果</h4><p>(一)  重要性<br>文明因<strong>交流</strong>而多彩，文明因<strong>互鉴</strong>而丰富。<br>人类文化和文明发展进步的过程表明，<u>一种文化能够通过与其他文化交流碰撞和冲突融合而保持其生命力，是实现<strong>自我更新</strong>和<strong>自我发展</strong>的重要条件。</u><strong>反应了具体民族或国家的生存方式和生活态度</strong></p>
<p>(二)  重要性借鉴和吸收人类文明优秀道德成果，必须<strong>秉承正确的态度</strong>和<strong>科学的方法</strong>。<br>① 要<strong>坚持马克思主义立场、观点、方法</strong>，在道德问题上把握好<strong>共性和个性、抽象和具体、一般和个别</strong>的关系。<br>② 要坚持<strong>以我为主、为我所用，批判吸收</strong>其他国家的道德成果。<br>③ 在吸取人类文明优秀道德成果的问题上，既要<strong>大胆吸收和借鉴</strong>人类道德文明的<strong>积极成果</strong>，又必须掌握好<strong>鉴别取舍的标准</strong>，善于在鉴别中吸收、吸收中消化,把人类文明优秀道德成果变成自己道德文明体系的组成部分。</p>
<h2 id="投身崇德向善的道德实践"><a href="#投身崇德向善的道德实践" class="headerlink" title="投身崇德向善的道德实践"></a>投身崇德向善的道德实践</h2><h5 id="遵守社会公德"><a href="#遵守社会公德" class="headerlink" title="遵守社会公德"></a>遵守社会公德</h5><p><strong>社会公德</strong>与<strong>公共生活</strong>密切相关，公共生活需要道德规范来约束和协调。<strong>社会公德</strong>作为社会公共生活中应当遵守的<strong>行为准则</strong>，在维护公共秩序方面具有重要的作用。大学生应当自觉培养公德意识，养成遵守社会公德的良好行为习惯。</p>
<p>当今公共生活的<strong>特征</strong>：**<u>活动范围的广泛性；活动内容的开放性；交往对象的复杂性；活动方式的多样性</u>**</p>
<p><strong>(一）公共生活与公共秩序</strong></p>
<p><u><strong>活动范围的广泛性、活动内容的开放性、交往对象的复杂性、活动方式的多样性</strong></u></p>
<p><strong>公共生活</strong>是相对于私人生活而言的。私人生活以家庭内部活动和个人活动为主要领域，私人空间里人们的行为是相对独立的，因而具有一定的封闭性和隐秘性。<br>在公共生活中，一个人的行为必定与他人发生直接或间接的联系，具有鲜明的<strong>开放性</strong>和<strong>透明性</strong>，对社会的影响更为直接和广泛。<br>公共生活<strong>需要公共秩序</strong>。秩序是由社会生活中的规范来制约和保障的，公共秩序是由一定规范维系的人们公共生活的一种有序化状态，如工作秩序、教学秩序、交通秩序、娱乐秩序、网络秩序等。公共生活领域越扩大，对公共秩序的要求就越高。<br><strong>有序的公共生活</strong>是社会生产活动的<strong>重要基础</strong>，是提高社会成员生活质量的<strong>基本保障</strong>，更是社会文明的<strong>重要标志</strong>。</p>
<p><strong>(二)  公共生活中的道德规范</strong><br>公共生活中的道德规范，即社会公德，是指人们在社会交往和公共生活中应该遵守的行为准则，是维护公共利益、公共秩序、社会和谐稳定的起码的道德要求，涵盖了<strong>人与人、人与社会、人与自然</strong>之间的关系。</p>
<p>&#x3D;&#x3D;社会公德内容: <strong>①文明礼貌 ②助人为乐 ③爱护公物<del>是社会文明水平的重要标志</del> ④保护环境 ⑤遵纪守法</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>(三)  网络生活中的道德要求</strong>&#x3D;&#x3D;<br>从本质上说，网络交往仍然是人与人的现实交往，网络生活也是人的真实生活。网络生活中的道德要求，是人们在网络生活中为了维护正常的网络公共秩序需要共同遵守的<strong>基本道德准则</strong>，是社会公德在网络空间的运用和扩展。<br>“网络空间天朗气清、生态良好，符合人民利益。”大学生应当遵守网络生活中的道德要求，成为营造清朗网络空间的正能量。</p>
<p>&#x3D;&#x3D;<strong>1.正确使用网络工具。</strong>&#x3D;&#x3D;<br>人们通过网络获取信息的方式更加方便、多样，大部分人特别是年轻人越来越主要依靠网络获取信息。大学生要提高信息、获取能力，加强信息辨识能力，增进信息应用能力，使网络成为开阔视野、提高能力的重要工具。</p>
<p>&#x3D;&#x3D;<strong>2.加强网络文明自律。</strong>&#x3D;&#x3D;<br>网络行为主体的文明自律是网络空间道德建设的基础。<br>首先，进行<strong>健康网络交往</strong>。其次，自觉避免沉迷网络。最后，加强网络道德自律。</p>
<p>&#x3D;&#x3D;<strong>3.营造良好网络道德环境</strong>。&#x3D;&#x3D;<br>良好的网络环境需要网民的共同努力，纷繁复杂的网络言论如果得不到正确引导，势必会引发各种社会问题。大学生一方面要加强网络道德自律，自觉抵制网络欺诈、造谣、诽谤、漫骂、歧视、色情、低俗等内容，反对网络暴力行为，维护网络道德秩序;另一方面应当带头引导网络舆论，对模糊认识要及时廓清，对怨气怨言要及时化解，对错误看法要及时纠正，促进网络空间日益清朗。</p>
<h4 id="恪守职业道德"><a href="#恪守职业道德" class="headerlink" title="恪守职业道德"></a>恪守职业道德</h4><p><strong>(一) 职业生活与劳动观念</strong><br><u><strong>职业</strong>是指人们由于社会分工所从事的具有<strong>专门业务</strong>和<strong>特定职责</strong>，并以此作为<strong>主要生活来源</strong>的社会活动。</u><br><strong>职业生活</strong>则是<strong>人们参与社会分工</strong>，用专业的技能和知识创造物质财富或精神财富，获取合理报酬，丰富社会物质生活或精神生活的<strong>生活方式</strong>。</p>
<p><strong>人类</strong>是<strong>劳动创造的</strong>，<strong>社会</strong>是劳动创造的。劳动没有高低贵贱之分，任何一份职业都很光荣。正确的劳动观念是维系人们职业活动和职业生活的思想观念保障。在职业生活中，必须牢固树立<strong>劳动最光荣、劳动最崇高、劳动最伟大、劳动最美丽</strong>“的观念，通过劳动创造更加美好的生活。无论从事什么劳动，都要干一行、爱一行、钻一行。只要踏实劳动、勒勉工作，在平凡岗位上也能干出不平凡的业绩。</p>
<p><u><strong>幸福源自奋斗，成功在于奉献，平凡孕育伟大</strong></u>。<br>事实上，只要有志气有闯劲，普通劳动者都可以在宽广舞台上实现自己的人生价值。许多劳动模范平凡而感人的事迹，就充分地说明了这一点。**”蓝领专家”孔祥瑞、”金牌工人”窦铁成、“新时代雷锋”徐虎、”知识工人”邓建军、”马班邮路上的信使”王顺友、”白衣圣人”吴登云、”中国航空发动机之父**”吴大观等一大批劳动模范和先进工作者，带动人们锐意进取、积极投身改革开放和社会主义现代化建设，为国家和人民建立了杰出功勋。</p>
<p><strong>(二) 职业生活中的道德规范</strong><br>职业生活中的道德规范即<strong>职业道德</strong>，是指从事一定职业的人在职业生活中应当遵循的具有职业特征的道德要求和行为准则，涵盖了从业人员与服务对象、职业与职工、职业与职业之间的关系。<br>&#x3D;&#x3D;<strong>爱岗敬业、诚实守信、办事公道、热情服务和奉献社会</strong>&#x3D;&#x3D;是职业生活中的基本道德规范。</p>
<blockquote>
<p><strong>爱岗敬业</strong>：就要干一行爱一行<br><strong>诚实守信</strong>：要求从业者在职业生活中诚实劳动、合法经营、信守承诺。&#x3D;&#x3D;<span style = "color : red"><strong>诚实守信</strong>是思想道德建设的重要作用，是中华民族传统美德，也是公民道德建设重点，社会主义核心价值观的一条重要准则</span>&#x3D;&#x3D;【选择】<br><strong>办事公道</strong>：要求从业人员做到公平公正、不损公肥私，不以谋权私，不假公济私<br><strong>热情服务</strong>：要求每个人无论从事什么工作、能力如何<br><strong>奉献社会</strong>：要求从业人员在工作岗位上兢兢业业地社会和他人作贡献，<u>是社会主义职业道德中<strong>最高层次的要求</strong>。体现了社会主义职业道德的<strong>最高目标指向</strong></u></p>
</blockquote>
<p><strong>(三)  树立正确的择业观和创业观</strong><br><strong>就业</strong>是<strong>最大的民生</strong>。就业牵涉大学生自身和千家万户的利益，也影响国家和社会的发展。每个大学生都要面临就业的现实。树立正确的<strong>择业观和创业观</strong>，对于大学生顺利走进职业生活具有重要的现实意义。</p>
<p><u><span style = "color:red"><strong>如何树立正确的择业观和创业观?</strong></span></u><br>&#x3D;&#x3D;<strong>1.树立崇高的职业理想。2.服从社会发展的需要。3.做好充分的择业准备。4.培养创业的勇气和能力。</strong>&#x3D;&#x3D;</p>
<p>1、树立<strong>崇高</strong>的<strong>职业理想</strong>。职业活动<strong>不仅是</strong>人们<strong>谋生的手段</strong>，也是人们<strong>奉献社会、完善自身的必要&#x3D;件</strong>。<br>2、<strong>服从社会发展的需要</strong>。择业和创业固然要<strong>考虑个人的兴趣和意愿</strong>，同时也要充分<strong>考虑现实的可能性和社会的需要</strong>，把自己对职业的期望与社会的需要、现实的可能结合起来。<br>3、做好<strong>充分的择业准备</strong>。<strong>素质</strong>是<strong>立身之基</strong>，<strong>技能</strong>是<strong>立业之本</strong>。<br>4、<strong>培养创业的勇气和能力</strong>。<u><strong>创业</strong>是通过发挥自己的<strong>主动性</strong>和<strong>创造性</strong>，开辟新的工作岗位、拓展职业活动范围、创造新业绩的实践过程。</u></p>
<h4 id="弘扬家庭美德"><a href="#弘扬家庭美德" class="headerlink" title="弘扬家庭美德"></a>弘扬家庭美德</h4><p><strong>(一) &#x3D;&#x3D;注重家庭、家教、家风&#x3D;&#x3D;</strong><br><strong>家庭</strong>是社会的<strong>基本细胞</strong>，是人生的第一所学校。不论时代发生多大变化，生活格局发生多大变化，都要重视家庭建设，注重<strong>家庭、家教、家风</strong>。</p>
<p>1.&#x3D;&#x3D;注重<strong>家庭</strong>&#x3D;&#x3D;。<br>家庭和睦则社会安定，家庭幸福则社会祥和，家庭文明则社会文明。<br>2.&#x3D;&#x3D;注重<strong>家教</strong>&#x3D;&#x3D;。<br><strong>家庭</strong>是<strong>人生的第一个</strong>课堂，父母是孩子的<strong>第一任老师</strong>。家庭教育涉及很多方面，&#x3D;&#x3D;但<strong>最重要</strong>的是<strong>品德教育</strong>&#x3D;&#x3D;<br>3.&#x3D;&#x3D;注重<strong>家风</strong>&#x3D;&#x3D;。<br><strong>家风</strong>是指一个家庭或家族世代相传的<strong>风尚、作风</strong>，即一个家庭当中的风气。家风是社会风气的<strong>重要组成部分</strong></p>
<p><strong>(二)  恋爱、婚姻家庭中的道德规范</strong><br>1.<u><strong>爱情</strong>是<strong>一对男女</strong>基于一定的<strong>社会基础</strong>和共同的<strong>生活理想</strong>，在各目内心形的相互倾慕并渴望对方成为自己终身伴侣的一种<strong>强烈、纯真、专一</strong>的<strong>感情</strong>。</u><br>男女双方培养爱情的过程或在爱情基础上进行的相互交往活动，就是人们日常所说的恋爱。恋爱作为一种人际交往，也必然要<strong>受到道德的约束</strong>。恋爱是建立幸福婚姻家庭的前奏，恪守恋爱中的道德规范关系到未来婚姻家庭生活的幸福。</p>
<p>1.恋爱中的道德规范主要有<strong>尊重人格平等、自觉承担责任</strong>和<strong>文明相亲相爱</strong>。<br>一是&#x3D;&#x3D;<strong>尊重人格平等</strong>&#x3D;&#x3D;。恋爱的双方在人格上都是独立的,恋爱双方在相互关系上是平等的。<br>二是&#x3D;&#x3D;<strong>自觉承担责任</strong>&#x3D;&#x3D;。自愿地为对方承担责任，是爱情本质的体现。<br>三是&#x3D;&#x3D;<strong>文明相亲相爱</strong>&#x3D;&#x3D;。文明的恋爱往往是恋爱双方既相互爱慕、亲近，又举止得体、相互尊重。</p>
<p>⒉<strong>婚姻</strong>是指由法律所确认的男女两性的结合以及由此而产生的<strong>夫妻关系</strong>。家庭是指在<u><strong>婚姻关系</strong>、<strong>血缘关系</strong>或<strong>收养关系</strong></u>基础上产生的亲属之间所构成的社会生活单位。婚姻是家庭产生的重要前提，家庭又是缔结婚姻的必然结果。婚姻的成功体现为家庭的幸福，家庭的美满又彰显出婚姻的意义。</p>
<p>3.&#x3D;&#x3D;家庭美德以<strong>尊老爱幼、男女平等、夫妻和睦，勤俭持家、邻里互助</strong>为主要内容&#x3D;&#x3D;，在维系和谐美满的婚姻家庭关系中具有重要而独特的功能。<br>其一，<strong>尊老爱幼</strong>。我国自古以来就倡导”<strong>幼有所养，老有所终</strong>“，形成了尊老爱幼的<strong>良好家庭道德传统</strong>。<br>其二，<strong>男女平等</strong><del>基本国策</del>。家庭生活中的男女平等既表现为<strong>夫妻权利和义务上的平等、人格地位上的平等</strong>，又表现为<strong>平等地对待自己的子女</strong>。<br>其三，<strong>夫妻和睦</strong>。夫妻关系是家庭关系的<strong>核心</strong>。夫妻和睦是仕另又平寺基叫上的<strong>互敬互爱、互助互让</strong>。<br>其四，<strong>勤俭持家</strong>。勤俭是家庭兴旺的保证，也是社会富足的保证。<br>其五，<strong>邻里互助</strong>。邻里互助重要的是相互尊重，尊重对方的人格、民族习惯、生活方式、兴趣爱好等，做到互谅互让、互帮互助、宽以待人、团结友爱。</p>
<p><strong>(三）树立正确的恋爱观与婚姻观</strong><br>1.大学生在恋爱中要避免以下误区。<br>第一，不能<strong>误把友谊当爱情</strong>。<br>第二，不能<strong>错置爱情的地位</strong>。<br>第三，不能<strong>片面</strong>或<strong>功利化</strong>地<strong>对待恋爱</strong>。<br>第四，不能<strong>只重过程不顾后果</strong>。<br>第五，不能因<strong>失恋</strong>而<strong>迷失人生方向</strong>。</p>
<p>2.树立正确的恋爱观，大学生还要处理好几种关系。<br>一是<strong>恋爱与学习</strong>的关系。<strong>学习</strong>是大学生的<strong>主要任务</strong>，大学生应把爱情作为奋发学习的动力，同时还应把<strong>是否有利于促进学习</strong>作为衡量爱情价值的一个<strong>重要而特殊的标准</strong>。<br>二是<strong>恋爱与关心集体</strong>的关系。恋爱中的双方不应把自己禁锢在两个人的世界中。如果脱离集体，疏远同学，就会妨碍自身的全面发展与进步。<br>三是<strong>恋爱与关爱他人和社会</strong>的关系。<strong>爱的情感丰富博大</strong>，不仅有<strong>恋人之爱</strong>，还有对<strong>父母之爱、对兄弟姐妹之爱、对社会和国家之爱</strong>。</p>
<h4 id="锤炼个人品德"><a href="#锤炼个人品德" class="headerlink" title="锤炼个人品德"></a>锤炼个人品德</h4><p><strong>(一) 涵养高尚道德品格</strong><br><strong>个人品德</strong>是通过社会道德教育和个人自觉的道德修养所形成的稳定的心理状态和行为习惯。&#x3D;&#x3D;<strong>个人品德</strong>在社会道德建设中具有<strong>基础性作用</strong>。&#x3D;&#x3D;在现实生活中，社会公德、职业道德和家庭美德的状况，最终都是&#x3D;&#x3D;以每个<strong>社会成员的道德品质为基础的</strong>&#x3D;&#x3D;<br>它是<u>个体对某种道德要求认同和践履的结果，集中体现了道德<strong>认知</strong>、道德<strong>情感</strong>、道德<strong>意志</strong>、道德<strong>信念</strong>和道德<strong>行为</strong>的<strong>内在统一</strong></u>。无论是社会的和谐有序，还是个人的人格健全，都有赖于个人品德的不断提升。&#x3D;&#x3D;大学生要自觉践行<u><strong>爱国奉献、明礼守法、厚德仁爱、正直善良、勤劳勇敢等个人品德要求</strong></u>&#x3D;&#x3D;，形成善良的道德意愿、道德情感，培育正确的道德判断和道德责任，提高道德实践能力尤其是自觉实践能力向往和追求自觉讲道德、尊道德、守道德的生活。</p>
<p>&#x3D;&#x3D;1.形成正确的<strong>道德认知</strong>和<strong>道德判断</strong>。&#x3D;&#x3D;<br>道德具有<strong>历史性、民族性</strong>和<strong>时代性</strong>的特征。要<strong>坚持以唯物史观</strong>的基本原理来<strong>看待道德</strong>。<br>一方面，要认识到<strong>道德的发展</strong>是一个<strong>曲折上升的历史过程</strong>，既要对历史上各种道德形态的进步性和局限性有客观准确的认知和判断，又要充分认识到<strong>社会主义道德</strong>作为崭新类型道德所具有的<strong>历史优越性</strong>和<strong>时代进步性</strong>;<br>另一方面，要认识到在国际国内形势深刻变化、我国经济社会深刻变革的大背景下，道德领域存在着各种错综复杂的现象和问题，需要我们<strong>保持清醒的认识，学会理性地辨析并形成正确的判断</strong>。</p>
<p>&#x3D;&#x3D;2.<strong>激发正向的道德认同和道德情感</strong>。&#x3D;&#x3D;<br><u>大学生在道德修养中激发正向的情感认同，总体而言就是<strong>要亲近真善美</strong>，抵制假恶丑，体验道德的愉悦，追求高尚的快乐。</u><br>通过对美德的尊崇，真正把<strong>外在的社会道德规范</strong>内化为心悦诚服的<strong>自律准则</strong>。具体而言就是要自觉涵育对家庭成员的亲亲之情，对他人集体的关心关爱，增强社会责任感、国家认同感、民族归属感、时代使命感，在与祖国同呼吸、与民族同步伐、与人民心连心的高尚情怀中，陶冶道德情操。</p>
<p>&#x3D;&#x3D;3.<strong>强化</strong>坚定的<strong>道德意志</strong>和<strong>道德信念</strong>。&#x3D;&#x3D;<br>道德修养重在践行，但有些大学生存在知而不行的现象，也就是尽管掌握了许多道德知识，却没有落实在自己的实际行动上，导致知行脱节。在道德认知向道德行为转化的过程中，道德意志和道德信念是关键环节。道德意志和道德信念是人们在践履道德原则、规范的过程中表现出的自觉克服一切困难和障碍的毅力，通过道德意志和信念的坚守，道德行为才能体现出稳定性。大学生需要明白”<strong>从善如登、从恶如崩</strong>“的深刻道理，磨炼道德意志，坚定道德信念，在砥砺中前行，在拼搏中进取，并做到持之以恒、久久为功，从而成就高尚的道德品格。</p>
<p><strong>(二)  道德修养重在践行</strong><br><strong>“纸上得来终觉浅，绝知此事要躬行</strong>。”高尚道德品格的形成重在实践，贵在坚持。大学生投身崇德向善的道德实践，就要自觉加强道德修养，向道德模范学习,培养志愿服务精神，大力弘扬时代新风。</p>
<p><strong>1.掌握道德修养的正确方法。</strong><br><u>道德修养作为人类道德实践活动的重要形式之一，是指个体自觉地将一定社会的道德规范、准则及要求内化为内在的道德品质，以促进人格的自我陶冶<strong>自我培育</strong>和<strong>自我完善</strong>的实践过程。</u><br>“<strong>不矜细行，终累大德</strong>。”加强个人品德修养不可能一蹴而就，更不可能一劳永逸。只有按照有效的品德修养方法去做，并长期坚持下去，才能使自己不断进步、不断完善，从而成为品德高尚的人。</p>
<p><strong>2.向道德模范学习。</strong><br><strong>道德模范</strong>主要是指<strong>思想和行为</strong>能够激励人们不断向善且为人们所崇敬、模仿的先进人物。<br><strong>道德模范</strong>是群众身边看得见、摸得着的榜样，是<strong>可以学、能够学的标杆</strong>。榜样的力量是无穷的。道德模范用自己的行动诠释着道德的内涵，展示着道德的力量。</p>
<p><strong>3.参与志愿服务活动。</strong><br><u><strong>志愿服务</strong>是指<strong>志愿贡献个人的时间及精力</strong>，在不求任何物质报酬的情况下，为改善社会、促进社会进步而提供的服务。</u><br><strong>志愿服务</strong>是<strong>培育和弘扬社会主义核心价值观</strong>的重要载体。<strong>志愿服务的精神</strong>是<strong>奉献、友爱、互助、进步</strong>。其中，奉献精神是<strong>精髓</strong>。</p>
<p><strong>(三）积极引领社会风尚</strong><br><strong>良好的社会风尚</strong>是人们在社会道德实践中<strong>逐渐形成的</strong>。<br>大学生投身崇德向善的道德实践，要弘扬真善美、贬斥假恶丑，做社会主义道德的示范者和引领者，促成<strong>知荣辱、讲正气、作奉献、促和谐</strong>的社会风尚。</p>
<p><strong>1.知荣辱</strong>。荣辱观对个人的思想行为具有鲜明的<strong>动力导向</strong>和<strong>调节作用</strong>。<strong>社会风尚</strong>同荣辱观紧密相连，两者<strong>相互影响、相互作用</strong>。<br><strong>2.讲正气</strong>。讲正气，就是<strong>坚持真理、坚持原则，坚持同一切歪风邪气作斗争</strong>。大学生须有一腔浩然正气，才能无所畏惧地前进，才能不屈不挠地为国家、为社会建功立业。<br><strong>3.作奉献</strong>。奉献精神是社会责任感的集中表现。<br><strong>4.促和谐</strong>。民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处的社会，是国家富强、民族复兴、人民幸福的重要保证。</p>
<h5 id="中国古代思想提出的五种代表性道德修养方法"><a href="#中国古代思想提出的五种代表性道德修养方法" class="headerlink" title="中国古代思想提出的五种代表性道德修养方法"></a>中国古代思想提出的五种代表性道德修养方法</h5><p>@@ 弘扬社会主义道德必须坚持的<strong>核心</strong>是<strong>为人民服务</strong><br>@@ 弘扬社会主义道德必须坚持的<strong>原则</strong>是<strong>集体主义</strong><br>@@ 道德起源的<strong>首要前提</strong>是<strong>劳动</strong><br>@@ 道德赖以产生的客观条件是<strong>社会关系</strong><br>@@ 道德产生的<strong>主观条件</strong>是<strong>人的自我意识</strong><br>@@ 在人类思想史上第一次科学而全面地论述了道德起源问题的理论是<strong>马克思主义</strong><br>@@ 道德在<strong>本质上</strong>是知行合一的<br>@@ 道德作为社会意识的特殊形式对于社会发展所具有的功效与作用指的是<strong>道德的功能</strong><br>@@ 为人民服务的根本政治保证是<strong>社会主义基本经济建设</strong><br>@@ 人民服务是<strong>先进性要求和广泛性要求的统一</strong><br>@@ <strong>集体主义</strong>可分为<strong>无私奉献、一心为公；先公后私、先人后己；顾全大局、遵纪守法</strong>三个层次的道德要求<br>@@ 道德规范体系的总纲是<strong>道德原则</strong><br>@@ 最直接最集中地反映着一定社会<strong>经济关系和利益关系</strong>的根本要求是<strong>道德原则</strong><br>@@ 道德与法律规范、整治规范的不同之处在于<strong>道德用善恶标准去评价，道德依靠社会舆论来维持，道德依靠传统习俗来维持，道德依靠人们的内心信念来维持</strong><br>@@ 为人民服务是<strong>坚持历史唯物主义的必然要求、中国共产党践行的根本宗旨、社会主义道德观的集中体现、全体中国人民共同遵循的道德要求</strong><br>@@ 传统道德中义利之辨、理欲之辨，其<strong>核心</strong>和<strong>本质</strong>是<strong>公私之辩</strong><br>@@ 中华传统美德的<strong>根本要求</strong>是<strong>公义胜私欲</strong><br>@@ 在社会公德的主要内容中，调整和规范人际关系的行为准则是<strong>文明礼貌</strong><br>@@ 通过虚心学习，积极思索，辨别善恶，学善戒恶，以涵养良好的德行，指的是道德修养方法是<strong>学思并重</strong><br>@@ 社会职业生活中的基本道德规范有<strong>爱岗敬业、诚实守信、办事公道、助人为乐、热情服务、奉献社会</strong><br>@@ 家庭应该注重<strong>家庭、家风、家教</strong><br>@@ </p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/政治" style=color:#00bcd4>
                政治
            </a>
        </span>
        
    </div>

    <a href="/2023/01/15/政治/(思修)第五章-道德核心原则、优秀道德成果、向善道德实践/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/01/15/政治/(思修)第四章-价值要求准则、核心价值观/">
        <h2>
            (思修)第四章-价值要求准则、核心价值观
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="确定价值要求-践行价值标准"><a href="#确定价值要求-践行价值标准" class="headerlink" title="确定价值要求 践行价值标准"></a>确定价值要求 践行价值标准</h1><h2 id="全体人民共同的价值追求"><a href="#全体人民共同的价值追求" class="headerlink" title="全体人民共同的价值追求"></a>全体人民共同的价值追求</h2><h4 id="价值观与社会主义核心价值观"><a href="#价值观与社会主义核心价值观" class="headerlink" title="价值观与社会主义核心价值观"></a>价值观与社会主义核心价值观</h4><p>(一) 价值观与核心价值观<br>1、价值、价值观的含义<br>&#x3D;&#x3D;<strong>价值</strong>是指在实践基础上形成的主体和客体之间的意义关系，主要反映的是<strong>现实的人的需要</strong>与<strong>事物属性之间</strong>的关系&#x3D;&#x3D;。在对价值的认识过程中，人们逐渐形成关于价值的不同观点。<br>&#x3D;&#x3D;<u><strong>核心价值观，承载着一个民族、一个国家的精神追求，体现着一个社会评判是非曲直的价值标准</strong></u><br><u>核心价值观是一个国家民族的<strong>精神纽带</strong></u><br><u>评价善恶的标准是<strong>道德</strong></u>&#x3D;&#x3D;<br>社会主义核心价值观是社会的<strong>本质属性</strong></p>
<p>⒉、<strong>价值观</strong><br>&#x3D;&#x3D;<strong>价值观</strong>就是<strong>主体对客体</strong>有无价值、价值大小的立场和态度，是对价值及其相关内容的<strong>基本观点和看法</strong>。&#x3D;&#x3D;<br>&#x3D;&#x3D;<strong>价值观</strong>对人的具体行为起着<strong>规范</strong>和<strong>保证</strong>的作用&#x3D;&#x3D;</p>
<p>3、<strong>价值观的特点</strong><br>&#x3D;&#x3D;① 价值观反映着特定的<strong>时代精神</strong>。&#x3D;&#x3D;<br>&#x3D;&#x3D;② 价值观体现着<strong>鲜明的民族特色</strong>。&#x3D;&#x3D;[成为该<strong>民族文化传统的核心和灵魂</strong>]<br>&#x3D;&#x3D;③ 价值观蕴含着<strong>特定的阶级立场</strong>。&#x3D;&#x3D;</p>
<p>4、核心价值观<br>&#x3D;&#x3D;<u><strong>核心价值观</strong>是一定<strong>社会形态、社会性质</strong>的集中体现，在一个社会的思想观念体系中处子<strong>全导地位</strong></u>&#x3D;&#x3D;<br><u>&#x3D;&#x3D;体现着社会制度的阶级属性、社会运行的<strong>基本原则</strong>和社会发展的<strong>基本方向</strong>&#x3D;&#x3D;</u>。历史和现实都表明，<strong>核心价值观</strong>是一个国家的<strong>重要稳定器</strong>，能否构建具有强大感召力的核心价值观，<strong>关系社会和谐稳定，关系国家长治久安</strong>。世界上各种文化之争，本质上是价值观念之争，也是人心之争、意识形态之争。<strong>社会主义核心价值观</strong>是一个民族就赖以为系的<strong>精神纽带</strong>，一个国家<strong>共同的</strong>思想道德基础</p>
<p>(二）社会主义核心价值观</p>
<p>1、社会主义核心价值观<br>党的<strong>十八大提出</strong>，要倡导&#x3D;&#x3D;<strong>富强、民主、文明、和谐，倡导自由、平等、公正、法治，倡导爱国、敬业、诚信、友善</strong>&#x3D;&#x3D;，积极培育和践行<strong>社会主义核心价值观</strong>。这是中国共产党凝聚全党全社会价值共识作出的重要论断。<br>2、社会主义核心价值体系<br><strong>社会主义核心价值观</strong>和<strong>社会主义核心价值体系</strong>是<strong>紧密联系、互为依存、相辅相成</strong>的。<br>&#x3D;&#x3D;<strong>社会主义核心价值体系</strong>【两想两神一观】主要包括<strong>马克思主义指导思想、中国特色社会主义共同理想、以爱国主义为核心的民族精神和以改革创新为核心的时代精神、社会主义荣辱观。</strong>&#x3D;&#x3D;</p>
<h4 id="3、相互关系"><a href="#3、相互关系" class="headerlink" title="3、相互关系"></a>3、相互关系</h4><p>① <strong>社会主义核心价值观</strong>和<strong>社会主义核心价值体系</strong>是<strong>紧密联系、互为依存、相辅相成</strong>的。<br>② 社会主义核心价值观是社会主义核心价值体系的<strong>精神内核</strong>，它体现了社会主义文核心价值体系的丰富内核心价值体系的<strong>根本性质和基本特征</strong>，反映了社会主义核心价值体系的<strong>丰富主涵和实践要求</strong>，是社会主义核心价值体系的<strong>高度凝练</strong>和集中表达。<br>③ 同时，社会主义核心价值观与社会主义核心价值体系具有<strong>内在一致性</strong>，都体现了社会主义意识形态的<strong>本质要求</strong>，体现了社会主义制度在思想和精神层面的<strong>质的规定性</strong>，是建成中国特色社会主义现代化强国、实现中华民族伟大复兴的中国梦的<strong>价值引领</strong>。</p>
<p>4.做法要求<br>推进社会主义核心价值观与社会主义核心价值体系建设，就是要<strong>弘扬共同理想、凝聚精神力量、引领道德风尚</strong>，形成全民族奋发向上、团结和睦的<strong>精神纽带</strong>，使我们的国家、民族、人民在思想上和精神上强起来，更好地坚持中国道路、弘扬中国精神、凝聚中国力量。</p>
<h4 id="社会主义核心价值观的基本内容"><a href="#社会主义核心价值观的基本内容" class="headerlink" title="社会主义核心价值观的基本内容"></a>社会主义核心价值观的基本内容</h4><p>富强、民主、文明、和谐，自由、平等、公正、法治、爱国、敬业、诚信、友善，是社会主义核心价值观的基本内容。<br>&#x3D;&#x3D;它把涉及国家、社会、公民的价值要求融为一体，<strong>体现了</strong>社会主义本质要求, <strong>继承了</strong>中华优秀传统文化，<strong>吸收了</strong>世界文明有益成果，<strong>体现了</strong>时代精神&#x3D;&#x3D;。&#x3D;&#x3D;是对我们要<strong>建设什么样的国家、建设什么样的社会、培育什么样的公</strong>民等重大问题的深刻解答&#x3D;&#x3D;。</p>
<p>&#x3D;&#x3D;<span style = "color : red">(一)  <strong>富强、民主、文明、和谐</strong></span>&#x3D;&#x3D;<br><u><strong>富强</strong>是促进社会进步、人的自由全面发展的<strong>物质基础</strong>，体现了马克思主义唯物史观生产力标准的<strong>根本要求</strong>。富强，就是<strong>人民的富裕</strong>和<strong>国家的强盛</strong>。</u></p>
<p><u><strong>民主</strong>指的是<strong>社会主义民主</strong>，是人民当家作主，不是由别人作主，也不是由少数人作主。人民<strong>民主</strong>是社会主义的<strong>生命</strong>，是人民群众创造历史的集中体现</u></p>
<p><u><strong>文明</strong>是社会进步的<strong>重要标志</strong>，也是社会主义现代化国家的<strong>重要特征</strong>。是全面建设社会主义现代化国家的<strong>题中应有之义</strong>，是实现中华民族伟大复兴的<strong>重要支撑</strong></u></p>
<p><u><strong>和谐</strong>是中华文明的<strong>核心价值理念</strong></u>。社会主义核心价值观倡导的和谐，是<u>人与人、人与社会、人与自然以及人的自我身心的<strong>有机统一</strong>。</u></p>
<p>&#x3D;&#x3D;<strong>揭示了当代中国在经济发展、政治文明、文化繁荣、社会进步等方面的价值目标</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<span style = "color : red"><strong>(二) 自由、平等、公正、法治</strong></span>&#x3D;&#x3D;<br><u><strong>自由</strong>是社会<strong>活力之源</strong>，是社会主义的<strong>价值理想</strong>。</u></p>
<p><u><strong>平等</strong>是人类追求的<strong>美好状态</strong>。是<strong>兼顾效率与公平</strong>的平等，不是”不患寡而患不均”的绝对平均主义; 是<strong>实实在在的平等</strong>，不是落在法律文本上的”形式上的平等”;</u></p>
<p><u><strong>公正</strong>是<strong>人类社会进步的标尺</strong>，是社会主义制度的<strong>本质要求</strong>。</u></p>
<p><u><strong>法治</strong>是人类政治文明的重要成果，是<strong>现代社会的主要特征</strong>。坚持<strong>党的领导、人民当家作主、依法治国的有机统一</strong>。</u></p>
<p>&#x3D;&#x3D;<strong>反应了人们对美好社会的期望和憧憬，是衡量现代社会是否充满活力又和谐有序的重要标志</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<span style = "color : red"><strong>(三）爱国、敬业、诚信、友善</strong></span>&#x3D;&#x3D;<br><u><strong>爱国</strong>是<strong>最深沉、最持久</strong>的情感，是每个公民应当遵循的最基本的<strong>价值观念和道德准则</strong>，也是中华民族的优良传统。</u></p>
<p><u><strong>敬业</strong>是对待<strong>生产劳动和人类生存</strong>的一种根本价值态度敬业的“业”，涵盖了人们所从事的一切促进人类生存与发展的生产劳动领域，本质上是由劳动的重要地位决定的。</u></p>
<p><u><strong>诚信</strong>是个人立身处世的<strong>基本价值规范</strong>，是<strong>社会存续发展</strong>的<strong>重要价值基石</strong>。</u></p>
<p><u><strong>友善</strong>是维系良好<strong>人际关系和社会关系</strong>的基本价值准则</u></p>
<p>文化自信是一个民族最持久，最深沉的力量</p>
<h4 id="当代中国发展进步的精神指引"><a href="#当代中国发展进步的精神指引" class="headerlink" title="当代中国发展进步的精神指引"></a>当代中国发展进步的精神指引</h4><p>&#x3D;&#x3D;<strong>2018年3月，十三届全国人大一次会议</strong>通过宪法修正案&#x3D;&#x3D;，把<strong>国家倡导社会主义核心价值观</strong>正式<strong>写入宪法</strong>，进一步凸显了社会主义核心价值观的重大意义。</p>
<blockquote>
<p>①共产党的重大会议 [几届几中]全会 秋天冬天10月&#x2F;11月<br>②人大国家召开的会议 春天3月 [几届几次]<br>党和人大代表是5年一届<br>人大会议是在党的会议之后<br>政治大年 逢2逢7<br><strong>几大几大 &#x3D; 党代会</strong> 改党章 <u>之后的一年通过宪法的修改</u><br><strong>全国人大几次会议 &#x3D; 人代会</strong> 改宪法</p>
</blockquote>
<p>一) &#x3D;&#x3D;坚持和发展中国特色社会主义的<strong>价值遵循</strong>&#x3D;&#x3D;<br><u>马克思主义提出在<strong>生产力高度发展</strong>和<strong>生产资料公有制</strong>的基础上，建立真正实现人人平等的公平正义的社会，是迄今为止人类<strong>最先进、最广泛</strong>的价值追求</u>。这也正是社会主义核心价值观<strong>先进性、感召力</strong>之所在。<br><span style = "color:red"><strong>社会主义核心价值观</strong>，集中体现了<strong>马克思主义所倡导的价值理念</strong>，是中国特色社会主义的<strong>根本价值导向</strong>，是中国特色社会主义的<strong>铸魂工程</strong></span>中国特色社会主义是全面发展、全面进步的社会主义。</p>
<p>(二) &#x3D;&#x3D;提高<strong>国家文化软实力</strong>的迫切要求&#x3D;&#x3D;<br>“<strong>核心价值观</strong>是<strong>文化软实力</strong><del>如何建设文化强国</del>的<strong>灵魂</strong>、文化软实力<strong>建设的重点</strong>。这是决定文化性质和方向的最深层次要素。”一个国家的文化软实力，从根本上说，<span style = "color:red">文化软实力主要<strong>取决于其核心价值观的生命力、凝聚力、感召力</strong></span>。<br><u>当今世界，<strong>文化</strong>越来越成为综合国力竞争的重要因素，成为经济社会发展的重要支撑，文化软实力越来越成为<strong>争夺发展制高点、道义制高点</strong>的<strong>关键所在</strong></u>。文化软实力的竞争，本质上是不同文化所代表的核心价值观的竞争。 </p>
<p>(三) &#x3D;&#x3D;推进社会团结奋进的”<strong>最大公约数</strong>“&#x3D;&#x3D; <u>中国梦是中华儿女的<strong>最大公约数</strong></u> <u>核心价值观是国内人民的<strong>最大公约数</strong></u><br>历史和现实一再表明、只有<strong>建立共同的价值目标</strong>，一个国家和民族才会有赖以维系的<strong>精神纽带</strong>，才会有<strong>统一的意志和行动</strong>，才会有强大的<strong>凝聚力、向心力</strong>。<br>当前，我国正处在经济转轨和社会转型的<strong>加速期</strong>，思想领域日趋多元、多样、多变，各种思潮此起彼伏，各种观念相互碰撞，不同价值取向并存，所有这些表现出来的是具体利益、观念观点之争，但折射出来的是价值观的分歧。</p>
<h2 id="社会主义核心价值观的显著特征"><a href="#社会主义核心价值观的显著特征" class="headerlink" title="社会主义核心价值观的显著特征"></a>社会主义核心价值观的显著特征</h2><h4 id="反应人类社会发展进步的价值理念-x3D-x3D-先进性-人民性-社会性-真实性-x3D-x3D"><a href="#反应人类社会发展进步的价值理念-x3D-x3D-先进性-人民性-社会性-真实性-x3D-x3D" class="headerlink" title="反应人类社会发展进步的价值理念&#x3D;&#x3D;[先进性] [人民性] [社会性] [真实性]&#x3D;&#x3D;"></a>反应人类社会发展进步的价值理念&#x3D;&#x3D;[先进性] [人民性] [社会性] [真实性]&#x3D;&#x3D;</h4><p>&#x3D;&#x3D;<strong>“社会主义”<strong>是社会主义核心价值观的</strong>底色</strong>&#x3D;&#x3D; </p>
<p>社会主义核心价值观<strong>遵循着人类历史发展的轨迹</strong>。<br>作为社会意识的价值观念是社会存在的反映。在阶级社会中，核心价值观体现的是这个社会占统治地位阶级的根本利益。<strong>奴隶社会</strong>的核心价值观体现<strong>奴隶主阶级的根本利益</strong>，<strong>封建社会</strong>的核心价值观体现<strong>封建地主阶级的根本利益，资本主义社会</strong>的核心价值观体现<strong>资产阶级的根本利益</strong>。<br><strong>社会主义</strong>作为人类社会<u>迄今为止</u><strong>最先进的社会制度</strong>,其价值观同社会主义经济基础和上层建筑相适应，充分彰显了社会主义社会的本质要求。</p>
<p>&#x3D;&#x3D;<strong>(二) 扎根中华优秀传统文化土壤</strong>&#x3D;&#x3D; [扎根在中国特色社会主义文化建设]<br>源远流长的<strong>中华优秀传统文化</strong>，是中华民族发展壮大的<strong>独特优势</strong>，也<u>是社会主义核心价值观<strong>历史底蕴的集中体现</strong>。</u><br><strong>中华优秀传统文化</strong>是涵养社会主义核心价值观的<strong>重要源泉</strong>。</p>
<p>&#x3D;&#x3D;<strong>(三) 吸纳世界文明有益成果</strong>&#x3D;&#x3D;<br>社会主义核心价值观吸纳了世界文明的有益成果。<strong>博采众长、兼容并蓄</strong>是中华文明的<strong>气质</strong>，社会主义核心价值观以海纳百川的气度广泛吸收借鉴了包括资本主义文明成果在内的<strong>人类一切文明成果，萃取精华、融会贯通</strong>、形成了具有世界视野、中国气派的价值观。<br>社会主义核心价值观在<strong>吸收人类优秀价值理念</strong>的<strong>基础上</strong>，以中国经验、中国实践为民主、自由、平等、公正、法治等价值理念<strong>赋予社会主义性质</strong>，代表了<strong>人类社会前进的方向和价值理念</strong>。</p>
<h4 id="彰显人民至上的价值立场"><a href="#彰显人民至上的价值立场" class="headerlink" title="彰显人民至上的价值立场"></a>彰显人民至上的价值立场</h4><p><strong>(一) 尊重人民群众历史主体地位</strong><br><strong>马克思主义唯物史观</strong>从<strong>社会存在决定社会意识</strong>的<strong>立场</strong>出发去考察人类社会发展历史，指出<strong>人民群众</strong>在社会历史发展中的<strong>主体作用</strong>，认为人民群众是历史的<strong>创造者</strong>。<strong>相信群众、依靠群众，从群众中来、到群众中去</strong>，站在<strong>广大劳动人民</strong>的<strong>立场</strong>上，<strong>以广大劳动人民的解放</strong>为<strong>宗旨</strong>，&#x3D;&#x3D;竭尽全力<strong>为人民求福利、谋利益</strong>，是马克思主义最根本的政治立场。&#x3D;&#x3D;<br>中国共产党为人民而生，因人民而兴。&#x3D;&#x3D;<strong>人民</strong>是我们党执政的<strong>最深厚基础</strong>和最大底气。人民性是社会主义核心价值观的<strong>根本特性</strong>，<strong>人民立场</strong>是社会主义核心价值观的<strong>根本立场</strong>。&#x3D;&#x3D;</p>
<p><strong>(二)  体现以人民为中心的价值导向</strong><br>&#x3D;&#x3D;<strong>为中国人民谋幸福、为中华民族谋复兴</strong>，是中国共产党人的<strong>初心和使命</strong>，也是我们党领导现代化建设的<strong>出发点和落脚点</strong>。&#x3D;&#x3D;<br>在领导中国特色社会主义建设的进程中，中国共产党始终坚持<strong>人民是历史创造者的观点</strong>，践行全心全意为人民服务的根本宗旨，坚持人民当家作主，坚持以人民为中心的发展思想，把<strong>人民对美好生活的向往作为奋斗目标</strong>。</p>
<p>在社会主义中国，“以人民为中心的发展思想，不是一个抽象的、玄奥的概念，不能只停留在口头上、止步于思想环节，而<strong>要体现在</strong>经济社会发展<strong>各个环节</strong>“。</p>
<p>在<strong>经济</strong>建设上，推进<strong>高质量发展</strong>，朝着全体人民共同富裕的方向稳步迈进;<br>在<strong>政治</strong>建设上，强调<strong>人民当家作主</strong>，体现人民意志，维护人民合法权益;<br>在<strong>文化</strong>建设上，坚持<strong>人民是文化事业的主体</strong>，满足人民的精神文化生活需要;<br>在<strong>社会</strong>发展上，不断<strong>保障和改善民生</strong>，促进社会公平正义;<br>在<strong>生态</strong>文明建设上，强调<strong>人与自然和谐相处</strong>，满足人民对优美生态环境的需要。</p>
<p><u>特别是在2020年中国抗击新冠肺炎疫情斗争中，<strong>人民至上、生命至上</strong>成为最醒目的<strong>价值导向</strong>，深刻彰显了我国社会主义核心价值观的人民性。</u></p>
<h4 id="因真实可信而具有强大的道义力量"><a href="#因真实可信而具有强大的道义力量" class="headerlink" title="因真实可信而具有强大的道义力量"></a>因真实可信而具有强大的道义力量</h4><p><strong>(一) 社会主义核心价值观是真实可信的</strong> [西方是假的]<br>社会主义核心价值观与以往价值观的一个重要区别在于其<strong>真实性</strong>。以<strong>民主选举制度为例</strong>，与西方民主制度”一人一票”注重形式不同，中国特色社会王义民王更注重内容和结果。我们不仅有<strong>选举民主</strong>，还有<strong>协商民主、基层民主</strong>，保证人民依法实行<strong>民主选举、民主决策、民主管理、民主监督</strong>。<br>中国特色社会主义的成功也验证了社会主义核心价值观的正确性、可信性，使得社会主义核心价值观可以而且能够成为<strong>真切、具体、广泛</strong>的现实。</p>
<p>(二)  认清西方”普世价值”的实质<br><u><strong>“普世价值”<strong>就是一种</strong>极具迷惑性、欺骗性</strong>并且带有<strong>鲜明政治倾向</strong>的价值观。</u><br>1.&#x3D;&#x3D;”普世价值”在<strong>理论</strong>上的<strong>虚伪性</strong>。&#x3D;&#x3D;是特指资本主义价值观;推行的并不是人类共同的价值观。而是特定的价值观及其背后的经济政治文化制度。是为资产阶级利益服务的。<br>2.&#x3D;&#x3D;”普世价值”在<strong>实践</strong>上的<strong>虚伪性</strong>。&#x3D;&#x3D;<br><strong>种族歧视、劳资对立、金钱政治、贫富分化、社会撕裂、人权无保障</strong>等。</p>
<p>[自由是活力之源]</p>
<h2 id="积极践行社会主义核心价值观"><a href="#积极践行社会主义核心价值观" class="headerlink" title="积极践行社会主义核心价值观"></a>积极践行社会主义核心价值观</h2><h4 id="扣好人生的扣子"><a href="#扣好人生的扣子" class="headerlink" title="扣好人生的扣子"></a>扣好人生的扣子</h4><p>1.<strong>大学时期</strong>是<strong>价值观养成</strong>的<strong>关键阶段</strong>。<br>青年的未来与国家的未来同频同向，青年一代的理想、本领和担当勾勒出国家的形象和力量。正因为未来掌握在青年手中，<strong>青年的价值观是什么样，决定着未来整个社会的价值观</strong>就是什么样。当代大学生要意识到自身肩负的历史使命，自觉加强价值观养成，树立正确的价值取向。</p>
<p>2.大学生的成长成才和全面发展，<strong>离不开正确价值观的引领</strong>。<br>正确的价值观能够引导大学生<strong>把人生价值追求融入国家和民族事业，始终站在人民大众立场</strong>，同人民一道拼搏、同祖国一道前进，服务人民、奉献社会，努力成为中国特色社会主义事业的合格建设者和可靠接班人。</p>
<p>3.核心价值观的养成<strong>绝非一日之功</strong>。<br><u>大学生要坚持由易到难、由近及远。从现在做起，从自己做起，<strong>努力把核心价值观的要求变成日常的行为准则，形成自觉奉行的信念理念，并身体力行大力将其推广到全社会</strong>去，为实现国家富强、民族振兴、人民幸福的中国梦凝聚强大的青春能量。</u></p>
<p><u>培育和践行社会主义核心价值观，既要<strong>目标高远、保持定力、不懈奋进</strong>，又要<strong>脚踏实地，严于律己、精益求精</strong></u>。新时代大学生要将社会主义核心价值观转化为<strong>人生的价值准则</strong>，勤学以增智、修德以立身、明辨以正心、笃实以为功，在激扬青春、开拓人生、奉献社会的进程中书写无愧于时代的壮丽篇章。</p>
<h4 id="把社会主义核心价值观落实细落小落实"><a href="#把社会主义核心价值观落实细落小落实" class="headerlink" title="把社会主义核心价值观落实细落小落实"></a>把社会主义核心价值观落实细落小落实</h4><p>笃实：扎扎实实干事，踏踏实实做人</p>
<p>@@ <strong>马克思主义</strong>提出在生产力高度发展和生产资料公有制的基础上，建立真正实现人人平等的公平正义的社会，是迄今为止人类最先进、最广泛的价值追求<br>@@ 社会主义核心价值观的民主是<strong>真是的民主、广泛的民主、高效的民主、丰富的民主</strong><br>@@ 社会主义核心价值观的<strong>本质特性</strong>是<strong>人民性</strong><br>@@ 社会主义核心价值观的<strong>根本立场</strong>是<strong>人民立场</strong><br>@@ 在社会主义中国，以人民为中心的发展思想，体现在经济社会发展各个换届。<br>在经济建设上，推进高质量发展，朝着全体人民共同富裕的方向稳步迈进；<br>在政治建设上，强调人民当家做主，体现人民意志，维护人民合法权益；<br>在文化建设上，坚持人民是文化事业的主体，满足人民的精神文化生活需要；<br>在社会发展上，不断保障和改善民生，促进社会公平正义；<br>在生态文明建设上，强调人与自然和谐相处，满足人民对优美生态环境的需要</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/政治" style=color:#ff7d73>
                政治
            </a>
        </span>
        
    </div>

    <a href="/2023/01/15/政治/(思修)第四章-价值要求准则、核心价值观/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/5/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <a href="/page/5/">
                <span class="page-num">
                    5
                </span>
            </a>
        </span>
        

        <span class="current">
            6
        </span>

        
        <span>
            <a href="/page/7/">
                <span class="page-num">
                    7
                </span>
            </a>
            
            <a href="/page/8">
                <span class="page-num">
                    8
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/7/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>