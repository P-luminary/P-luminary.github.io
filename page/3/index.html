
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/11/23/后端/MyBatisPlus/">
        <h2>
            MyBatisPlus
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><a target="_blank" rel="noopener" href="https://www.baomidou.com/">MyBatis-Plus</a><br><a target="_blank" rel="noopener" href="https://www.baomidou.com/introduce/">简介 | MyBatis-Plus</a></p>
<h5 id="引入MybatisPlus起步依赖写依赖-认爸爸"><a href="#引入MybatisPlus起步依赖写依赖-认爸爸" class="headerlink" title="引入MybatisPlus起步依赖写依赖+认爸爸"></a>引入MybatisPlus起步依赖<del>写依赖+认爸爸</del></h5><ul>
<li>MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter：</li>
</ul>
<pre><code class="xml">&lt;!--MybatisPlus--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; 
    &lt;version&gt;3.5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>自定义的Mapper继承MybatisPlus提供的<code>BaseMapper</code>接口</li>
</ul>
<pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">UserMapper.java

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
</code></pre>
<pre><code class="xml">UserMapper.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.itheima.mp.mapper.UserMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><code>@TableName</code>：用来指定表名</li>
<li><code>@Tableld</code>：用来指定表中的主键字段信息<ul>
<li><code>IdType枚举</code>：<ul>
<li><strong>AUTO</strong>：数据库自增长</li>
<li><strong>INPUT</strong>：通过set方法自行输入</li>
<li><em>ASSIGN_ID</em>：<u>分配ID 默认实现类是</u><code>雪花算法</code></li>
</ul>
</li>
</ul>
</li>
<li><code>@TableField</code>：用来指定表中的普通字段信息<del>默认驼峰转下划线，不一致需要改</del><ul>
<li>成员变量名与数据库字段名不一致</li>
<li><u>成员变量名是以<strong>is开头</strong>，且是<strong>布尔值</strong></u><del>isMarried</del></li>
<li>成员变量名与数据库关键字冲突<del>order</del></li>
<li>成员变量不是数据库字段<del>address</del>，要标记不存在不然会默认数据库字段</li>
</ul>
</li>
</ul>
<pre><code class="java">@Data
public class User &#123;
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;
    
    @TableField(&quot;username&quot;)
    private String name;

    @TableField(&quot;is_married&quot;)
    private Boolean isMarried;  // is经过反射会默认变成变量名Married
    
    @TableField(&quot;`order`&quot;)
    private Integer order;
    
    @TableField(exist = false)
    private String address;
......
&#125;
</code></pre>
<p>此时如果数据库的表名是：<code>tb_user</code> 就需要用到 <code>@TableName</code> 了</p>
<pre><code class="mysql">数据库名：tb_user (用户表)
#  名称
1  id
2  username
3  is_married
4  order
</code></pre>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><p><code>MyBatisPlus</code>的配置项继承了MyBatis原生配置和一些自己特有的配置<br>MP更擅长单表的增删改查，如果是多表还是推荐用xml</p>
<pre><code class="yaml">mybatis:
  mapper-locations: classpath*:mapper/*.xml # Mapper.xml文件地址，默认值
  type-aliases-package: com.itheima.po # 别名扫描包
  configuration:
    map-underscore-to-camel-case: true # 开启驼峰命名自动映射
    cache-enabled: false # 是否开启二级缓存
  global-config:
    db-config:
      id-type: assign_id # id为雪花算法生成
      update-strategy: not_null # 更新策略：只更新非空字段 类似于动态sql
</code></pre>
<p><span style="color:red"><strong>MyBatisPlus使用的基本流程</strong></span></p>
<ul>
<li>引入起步依赖</li>
<li>自定义Mapper基础BaseMapper</li>
<li>在实体类上添加注释声明 表信息</li>
<li>在application.yml中根据需要添加配置</li>
</ul>
<h3 id="核心功能—条件构造器"><a href="#核心功能—条件构造器" class="headerlink" title="核心功能—条件构造器"></a>核心功能—条件构造器</h3><h6 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3b9a3950642e32ab3182e3aae6cd2ba50c25f42f/MyBatisPlus%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8.jpg"></p>
<p><code>MyBatisPlus</code>支持各种复杂的<code>where</code>条件，满足日常开发的所有需求</p>
<ul>
<li>查询出名字中带o的，存款大于等于1000元的人的id、username、info、balance字段</li>
</ul>
<pre><code class="mysql"># 原始SQL：
SELECT id,username,info,balance
FROM user
WHERE username LIKE ? AND balance &gt;= ?
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testQueryWrapper()&#123;
        // 1.构建查询条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()
                .select(&quot;id&quot;, &quot;username&quot;, &quot;phone&quot;)
                .like(&quot;username&quot;, &quot;o&quot;)
                .ge(&quot;balance&quot;, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<pre><code class="java">// MyBatisPlus Lambda编码格式(解决硬编码)：
 @Test
    void testLambdaQueryWrapper()&#123;
        // 1.构建查询条件
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;User&gt;()
                // 利用反射 解决字符串硬编码
                .select(User::getId, User::getUsername, User::getPhone)
                .like(User::getUsername, &quot;o&quot;)
                .ge(User::getBalance, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;

-------------------------------------------------------------------------
@Test
void testLambdaQueryWrapperWithQueryWrapper()&#123;
    // 1. 构建查询条件
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();
    LambdaQueryWrapper&lt;User&gt; wrapper = queryWrapper.lambda()
            .select(User::getId, User::getUsername, User::getPhone)
            .like(User::getUsername, &quot;o&quot;)
            .ge(User::getBalance, 1000);

    // 2. 查询
    List&lt;User&gt; users = userMapper.selectList(wrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<ul>
<li>更新用户名为jack的用户的余额为2000</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = 2000
    WHERE (username = &quot;jack&quot;)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateByQueryWrapper()&#123;
        // 1.要更新的数据
        User user = new User();
        user.setBalance(2000);
        // 2.更新的条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;jack&quot;);
        // 3.执行更新
        userMapper.update(user, wrapper);
    &#125;
</code></pre>
<ul>
<li>更新id为1，2，4的用户的余额，扣200</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = balance - 200
    WHERE id in (1,2,4)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateWrapper()&#123;
        List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
        UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()
                .setSql(&quot;balance = balance - 100&quot;)
                .in(&quot;id&quot;, ids);
        userMapper.update(null, wrapper);
    &#125;
</code></pre>
<h5 id="条件构造器的用法："><a href="#条件构造器的用法：" class="headerlink" title="条件构造器的用法："></a>条件构造器的用法：</h5><ul>
<li><p>QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分</p>
</li>
<li><p>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用</p>
</li>
<li><p>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码</p>
</li>
</ul>
<h3 id="4-字段映射与表名映射"><a href="#4-字段映射与表名映射" class="headerlink" title="4. 字段映射与表名映射"></a>4. 字段映射与表名映射</h3><h4 id="4-1-问题一：表字段与编码属性设计不同步"><a href="#4-1-问题一：表字段与编码属性设计不同步" class="headerlink" title="4.1 问题一：表字段与编码属性设计不同步"></a>4.1 问题一：表字段与编码属性设计不同步</h4><ul>
<li>在模型类属性上方，使用**@TableField**属性注解，通过&#x3D;&#x3D;<strong>value</strong>&#x3D;&#x3D;属性，设置当前属性对应的数据库表中的字段关系。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\1683796001750.png" alt="1683796001750"></p>
<h4 id="4-2-问题二：编码中添加了数据库中未定义的属性"><a href="#4-2-问题二：编码中添加了数据库中未定义的属性" class="headerlink" title="4.2 问题二：编码中添加了数据库中未定义的属性"></a>4.2 问题二：编码中添加了数据库中未定义的属性</h4><ul>
<li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>&#x3D;&#x3D;exist&#x3D;&#x3D;**属性，设置属性在数据库表字段中是否存在，默认为true。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\exist.png" alt="1683796121907"></p>
<h4 id="4-3-问题三：表名与编码开发设计不同步"><a href="#4-3-问题三：表名与编码开发设计不同步" class="headerlink" title="4.3 问题三：表名与编码开发设计不同步"></a>4.3 问题三：表名与编码开发设计不同步</h4><ul>
<li>在<u><strong>模型类</strong></u>上方，使用**@TableName<strong>注解，通过</strong>&#x3D;&#x3D;value&#x3D;&#x3D;**属性，设置当前类对应的数据库表名称。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\table.png" alt="1683798660359"></p>
<h2 id="四、主键生成策略"><a href="#四、主键生成策略" class="headerlink" title="四、主键生成策略"></a>四、主键生成策略</h2><p>id主键生成的策略有哪几种方式？</p>
<p>不同的表应用不同的id生成策略</p>
<ul>
<li>日志：自增（1,2,3,4，……）</li>
<li>购物订单：特殊规则（FQ23948AK3843）</li>
<li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li>
<li>关系表：可省略id</li>
<li>……</li>
</ul>
<h3 id="1-id生成策略控制（-TableId注解）"><a href="#1-id生成策略控制（-TableId注解）" class="headerlink" title="1 id生成策略控制（@TableId注解）"></a>1 id生成策略控制（@TableId注解）</h3><p>雪花算法：<code>@TableId(type= IdType.ASSIGN_ID)</code><br><code>ASSIGN_UUID</code>是趋势递增<br>用了<code>分库分表</code>就不能用默认的id自增了 要用雪花算法</p>
<ul>
<li><p>名称：@TableId</p>
</li>
<li><p>类型：<strong>属性注解</strong></p>
</li>
<li><p>位置：模型类中用于表示主键的属性定义上方</p>
</li>
<li><p>作用：设置当前类中主键属性的生成策略</p>
</li>
<li><p>相关属性</p>
<p>​    <strong>type</strong>：设置主键属性的生成策略，值参照IdType枚举值</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801192449901.png" alt="image-20210801192449901"></p>
</li>
</ul>
<h3 id="2-全局策略配置"><a href="#2-全局策略配置" class="headerlink" title="2 全局策略配置"></a>2 全局策略配置</h3><pre><code class="yml">mybatis-plus:
  global-config:
    db-config:
      id-type: assign_id #全局设置主键id策略
      table-prefix: tbl_  #表名前缀设置
</code></pre>
<h5 id="id生成策略全局配置"><a href="#id生成策略全局配置" class="headerlink" title="id生成策略全局配置"></a>id生成策略全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183128266.png" alt="image-20210801183128266"></p>
<h5 id="表名前缀全局配置"><a href="#表名前缀全局配置" class="headerlink" title="表名前缀全局配置"></a>表名前缀全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183157694.png" alt="image-20210801183157694"></p>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用MyBatisPlus的Wrapper来**<u>构造复杂的where条件</u>**，然后自己定义SQL语句中剩下的部分。</p>
<h6 id="将id在指定范围的用户-1-2-4-的余额扣减指定值"><a href="#将id在指定范围的用户-1-2-4-的余额扣减指定值" class="headerlink" title="将id在指定范围的用户(1,2,4)的余额扣减指定值"></a>将id在指定范围的用户(1,2,4)的余额扣减指定值</h6><pre><code class="sql">&lt;update id = &quot;updateBalanceByIds&quot;&gt;
    UPDATE user
    SET balance = balance - #&#123;amount&#125;
    WHERE id IN
    &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
    #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/update&gt;
</code></pre>
<ul>
<li>基于Wrapper构建where条件</li>
</ul>
<pre><code class="java">// 1.更新条件
  List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
  int amount = 200;
// 2.定义条件
  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(User::getId, ids);
// 3.调用自定义SQL方法
  userMapper.updateBalanceByIds(wrapper, amount);
</code></pre>
<ul>
<li>在mapper方法参数中用Param注解声明wrapper变量名称，<strong>必须是ew</strong></li>
</ul>
<pre><code class="java">void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);
</code></pre>
<ul>
<li>自定义SQL，并使用Wrapper条件</li>
</ul>
<pre><code class="xml">&lt;update id=&quot;updateBalanceByIds&quot;&gt;
        update user
        set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="IService接口基本用法"><a href="#IService接口基本用法" class="headerlink" title="IService接口基本用法"></a>IService接口基本用法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d025a67eaeb98c3eb9725d71e36e36b6516b2b7d/IService%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.jpg" style="zoom:150%;" />

<ul>
<li>自定义Service接口继承IService接口</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

public interface IUserService extends IService&lt;User&gt; &#123;

&#125;
</code></pre>
<ul>
<li>自定义Service实现类，实现自定义接口并继承ServiceImpl类</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.impl.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;

&#125;
</code></pre>
<ul>
<li>搞了个测试类<code>@Test</code></li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.itheima.mp.domain.po.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@SpringBootTest
class IUserServiceTest &#123;
    @Autowired
    private IUserService userService;

    @Test
    void testSaveUser() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
    &#125;
    @Test
    void testQuery()&#123;
        List&lt;User&gt; users = userService.listByIds(Arrays.asList(1L, 2L, 3L));
        users.forEach(System.out::println);
    &#125;

&#125;
</code></pre>
<h3 id="IService开发基础业务接口"><a href="#IService开发基础业务接口" class="headerlink" title="IService开发基础业务接口"></a>IService开发基础业务接口</h3><ul>
<li>基于Restful风格实现下面的接口：<br>飞书文档说明：(<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc</a>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>接口</strong></th>
<th align="left"><strong>请求方式</strong></th>
<th align="left"><strong>请求路径</strong></th>
<th><strong>请求参数</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">新增用户</td>
<td align="left">POST</td>
<td align="left">&#x2F;users</td>
<td>用户表单实体</td>
<td>无</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">删除用户</td>
<td align="left">DELETE</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>无</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">根据id查询用户</td>
<td align="left">GET</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>用户VO</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">根据id批量查询</td>
<td align="left">GET</td>
<td align="left">&#x2F;users</td>
<td>用户id集合</td>
<td>用户VO集合</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">根据id扣减余额</td>
<td align="left">PUT</td>
<td align="left">&#x2F;users&#x2F;{id}&#x2F;deduction&#x2F;{money}</td>
<td>•用户id  •扣减金额</td>
<td>无</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thinkingandworkinghard/p/10482929.html">解决在IDEA 的Maven下 出现 Cannot access in offline mode 问题 - Doyourself! - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">管理接口文档</a></p>
<pre><code class="java">UserController.java
package com.itheima.mp.controller;

import cn.hutool.core.bean.BeanUtil;
import com.itheima.mp.domain.po.User;

import com.itheima.mp.domain.dto.UserFormDTO;

import com.itheima.mp.domain.vo.UserVO;
import com.itheima.mp.service.IUserService;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Api(tags = &quot;用户管理接口&quot;)
@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;users&quot;)
public class UserController &#123;

    private final IUserService userService;

    @PostMapping
    @ApiOperation(&quot;新增用户&quot;)
    public void saveUser(@RequestBody UserFormDTO userFormDTO) &#123;
        // 1.转换DTO为PO
        User user = BeanUtil.copyProperties(userFormDTO, User.class);
        // 2.新增
        userService.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;删除用户&quot;)
    public void removeUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        userService.removeById(userId);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        // 1.查询用户
        User user = userService.getById(userId);
        // 2.处理vo
        return BeanUtil.copyProperties(user, UserVO.class);
    &#125;

    @GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;

    @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserFormDTO.java
package com.itheima.mp.domain.dto;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户表单实体&quot;)
public class UserFormDTO &#123;

    @ApiModelProperty(&quot;id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

    @ApiModelProperty(&quot;注册手机号&quot;)
    private String phone;

    @ApiModelProperty(&quot;详细信息，JSON风格&quot;)
    private String info;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;
&#125;
</code></pre>
<pre><code class="java">UserQuery.java
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
    @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额
        baseMapper.deductMoneyById(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.mapper;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import com.itheima.mp.domain.po.User;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Update;

import java.util.List;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;

    List&lt;User&gt; queryUserByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);

    void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);

    @Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)
    void deductMoneyById(Long id, Integer money);
&#125;
</code></pre>
<h3 id="Iservice的Lambda方法"><a href="#Iservice的Lambda方法" class="headerlink" title="Iservice的Lambda方法"></a>Iservice的Lambda方法</h3><h6 id="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："><a href="#需求：实现一个根据复杂条件查询用户的接口，查询条件如下：" class="headerlink" title="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："></a>需求：实现一个根据复杂条件查询用户的接口，查询条件如下：</h6><p><strong>name</strong>：用户名关键字，可以为空<br><strong>status</strong>：用户状态，可以为空<br><strong>minBalance</strong>：最小余额，可以为空<br><strong>maxBalance</strong>：最大余额，可以为空</p>
<pre><code class="mysql">&lt;select id=&quot;queryUsers&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;
    SELECT *
    FROM tb_user
    &lt;where&gt;
        &lt;if test=&quot;name != null&quot;&gt;
            AND username LIKE CONCAT(&#39;%&#39;, #&#123;name&#125;, &#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            AND `status` = #&#123;status&#125;
        &lt;/if&gt;
        &lt;if test=&quot;minBalance != null and maxBalance != null&quot;&gt;
            AND balance BETWEEN #&#123;minBalance&#125; AND #&#123;maxBalance&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h6 id="UserQuery-java"><a href="#UserQuery-java" class="headerlink" title="UserQuery.java"></a>UserQuery.java</h6><pre><code class="java">package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<h6 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h6><pre><code class="java">    @ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        // 1.查询用户PO
        List&lt;User&gt; users = userService.queryUsers(query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance());
        // 2.把po拷贝到vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;
</code></pre>
<h6 id="IUserService-java"><a href="#IUserService-java" class="headerlink" title="IUserService.java"></a>IUserService.java</h6><pre><code class="java">package com.itheima.mp.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

import java.util.List;

public interface IUserService extends IService&lt;User&gt; &#123;
    void deductBalance(Long id, Integer money);

    List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance);
&#125;
</code></pre>
<h6 id="UserServiceImpl-java"><a href="#UserServiceImpl-java" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
   @Override
    public List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) &#123;
        return lambdaQuery()
                .like(name!=null, User::getUsername,name)
                .eq(status!=null, User::getStatus,status)
                .gt(minBalance!=null, User::getBalance,minBalance) // 大于
                .lt(maxBalance!=null, User::getBalance,maxBalance) // 小于
                .list();
    &#125;
&#125;
</code></pre>
<h3 id="IService的Lambda更新LambdaUpdate-、LambdaQuery"><a href="#IService的Lambda更新LambdaUpdate-、LambdaQuery" class="headerlink" title="IService的Lambda更新LambdaUpdate()、LambdaQuery()"></a>IService的Lambda更新<del>LambdaUpdate()、LambdaQuery()</del></h3><h6 id="改造根据id修改用户余额的接口，要求如下"><a href="#改造根据id修改用户余额的接口，要求如下" class="headerlink" title="改造根据id修改用户余额的接口，要求如下"></a>改造根据id修改用户余额的接口，要求如下</h6><ul>
<li><p>完成对用户状态校验</p>
</li>
<li><p>完成对用户余额校验</p>
</li>
<li><p>如果扣减后余额为0，则将用户status修改为冻结状态 (2)</p>
<h6 id="UserController-java-1"><a href="#UserController-java-1" class="headerlink" title="UserController.java"></a>UserController.java</h6></li>
</ul>
<pre><code class="java"> @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
</code></pre>
<h6 id="UserServiceImpl-java-1"><a href="#UserServiceImpl-java-1" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java"> @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额 update tb_user set balance = balance - ?
        int remainBalance = user.getBalance() - money;
        lambdaUpdate()
                .set(User::getBalance, remainBalance)
                .set(remainBalance == 0,User::getStatus, 2)
                .eq(User::getId, id)
                .eq(User::getBalance, user.getBalance()) // 乐观锁
                .update();
    &#125;
</code></pre>
<h3 id="IService的批量新增"><a href="#IService的批量新增" class="headerlink" title="IService的批量新增"></a>IService的批量新增</h3><h6 id="批量插入10万条用户数据，并作出对比："><a href="#批量插入10万条用户数据，并作出对比：" class="headerlink" title="批量插入10万条用户数据，并作出对比："></a>批量插入10万条用户数据，并作出对比：</h6><ul>
<li>普通for循环插入<del>4分钟</del></li>
<li><strong>IService的批量插入</strong><del>30秒</del></li>
<li>开启<strong>rewriteBatchedStatements&#x3D;true</strong>参数【6秒】<del>重写Statement语句，在application.yaml的sql中url拼接</del></li>
</ul>
<pre><code class="java">Test  com/itheima/mp/service/IUserServiceTest.java
@Test
    void testSaveOneByOne() &#123;
        long b = System.currentTimeMillis();
        for (int i = 1; i &lt;= 100000; i++) &#123;
            userService.save(buildUser(i));
        &#125;
        long e = System.currentTimeMillis();
        System.out.println(&quot;耗时：&quot; + (e - b));
    &#125;

    private User buildUser(int i) &#123;
        User user = new User();
        user.setUsername(&quot;user_&quot; + i);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;&quot; + (18688190000L + i));
        user.setBalance(2000);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(user.getCreateTime());
        return user;
    &#125;
</code></pre>
<h6 id="MyBatisPlus的批处理"><a href="#MyBatisPlus的批处理" class="headerlink" title="MyBatisPlus的批处理"></a>MyBatisPlus的批处理</h6><pre><code class="java">@Test
void testSaveBatch() &#123;
    // 准备10万条数据
    List&lt;User&gt; list = new ArrayList&lt;&gt;(1000);
    long b = System.currentTimeMillis();
    for (int i = 1; i &lt;= 100000; i++) &#123;
        list.add(buildUser(i));
        // 每1000条批量插入一次
        if (i % 1000 == 0) &#123;
            userService.saveBatch(list);
            list.clear();
        &#125;
    &#125;
    long e = System.currentTimeMillis();
    System.out.println(&quot;耗时：&quot; + (e - b));
&#125;
</code></pre>
<p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<pre><code class="SQL">Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )
Parameters: user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
</code></pre>
<p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p>
<pre><code class="SQL">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )
VALUES 
(user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023-07-01, 2023-07-01);
</code></pre>
<p>该怎么做呢？</p>
<p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p>
<p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p>
<pre><code class="YAML">spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: MySQL123
</code></pre>
<h3 id="扩展功能-——-代码生成器生成代码的代码"><a href="#扩展功能-——-代码生成器生成代码的代码" class="headerlink" title="扩展功能 —— 代码生成器生成代码的代码"></a>扩展功能 —— 代码生成器<del>生成代码的代码</del></h3><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1 代码生成"></a><strong>3.1 代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p>
<p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p>
<h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p>
<p>然后重启你的Idea即可使用。</p>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p>
<p>点击OK保存。</p>
<p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p>
<p>在弹出的表单中填写信息：</p>
<p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1ZmEzNjMxODM4NjkzMjUzZDkxMGY1NDdlZjUzNmRfMjQweXV3NE1lRmpkWGNzcU5pOGxyMW1yaGoxNmtJamZfVG9rZW46WlRqemI4SGVjb080VWp4Sko0ZWNZR2lTbnRoXzE3MzI0MTU0NDQ6MTczMjQxOTA0NF9WNA" alt="img"></p>
<p>最终，代码自动生成到指定的位置了：</p>
<h3 id="扩展功能-——-DB静态工具两个Service相互注入"><a href="#扩展功能-——-DB静态工具两个Service相互注入" class="headerlink" title="扩展功能 —— DB静态工具两个Service相互注入"></a>扩展功能 —— DB静态工具<del>两个Service相互注入</del></h3><ul>
<li>改造根据id查询用户的接口，查询用户的同时<del>user表</del>，查询出用户对应的所有地址<del>address表</del></li>
<li>改造根据id批量查询用户的接口，查询用户的同时，查询出用户对应的所有地址</li>
<li>实现根据用户id查询收货地址功能，需要验证用户状态，冻结用户抛出异常(练习)</li>
</ul>
<h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/76848ff08a98edaf6d5d07285cd76e50f42e7c5b/DB%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7.jpg"></p>
<p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p>
<pre><code class="java">UserController.java
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;
        // 1.查询用户
//        User user = userService.getById(userId);
        // 2.处理vo
        return userService.queryUserAndAddressById(id);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    UserVO queryUserAndAddressById(Long id);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h3 id="扩展功能—DB静态工具-练习"><a href="#扩展功能—DB静态工具-练习" class="headerlink" title="扩展功能—DB静态工具(练习)"></a>扩展功能—DB静态工具(练习)</h3><pre><code class="java">UserController.java
@GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
//        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return userService.queryUserAndAddressByIds(ids);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = listByIds(ids);
        if (CollUtil.isEmpty(users)) &#123;
            return Collections.emptyList();
        &#125;
        // 2.查询地址
        // 2.1 获取用户id集合
        List&lt;Long&gt; userIds = users.stream().map(User::getId).collect(Collectors.toList());
        // 2.2 根据用户id查询地址 这是全部地址
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
        // 2.3 转换地址VO
        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addresses, AddressVO.class);
        // 2.4 梳理地址集合分组处理，分类整理，相同用户放入一个集合(组)中
        Map&lt;Long, List&lt;AddressVO&gt;&gt; addressMap = new HashMap&lt;&gt;(0);
        if (CollUtil.isNotEmpty(addressVOList))&#123;
            addressMap = addressVOList.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
        &#125;
        // 3.转换VO返回
        List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(users.size());
        for (User user : users) &#123;
            // 3.1 转换User的Po为VO
            UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
            list.add(userVO);

            // 3.2 转换地址VO
            userVO.setAddresses(addressMap.get(user.getId()));
        &#125;
        return null;
    &#125;
</code></pre>
<h3 id="扩展功能—逻辑删除要在数据库里面创建一个deleted表"><a href="#扩展功能—逻辑删除要在数据库里面创建一个deleted表" class="headerlink" title="扩展功能—逻辑删除要在数据库里面创建一个deleted表"></a>扩展功能—逻辑删除<del>要在数据库里面创建一个deleted表</del></h3><h6 id="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"><a href="#订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息" class="headerlink" title="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"></a>订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息</h6><p><strong>逻辑删除</strong>就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p>
<ul>
<li>在表中添加一个字段标记数据是否被删除</li>
<li>当删除数据时把标记置为1</li>
<li>查询时只查询标记为0的数据</li>
</ul>
<p>例如逻辑删除字段为deleted：</p>
<p>• 删除操作：</p>
<pre><code class="mysql"># 是0才删除 是1就不用删除 所以用AND
UPDATE user SET deleted = 1 WHERE id = 1 AND deleted = 0
</code></pre>
<p>• 查询操作：</p>
<pre><code class="mysql"># 查询未删除的数据
SELECT * FROM user WHERE deleted = 0
</code></pre>
<h5 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h5><p><strong>MybatisPlus</strong>提供了逻辑删除功能，无需改变方法调用的方式，而是在底层帮我们自动修改CRUD的语句。我们要做的就是在application.yaml文件中配置逻辑删除的字段名称和值即可：</p>
<pre><code class="yaml">mybatis-plus: 
  global-config:    
   db-config:
    logic-delete-field: flag # 全局逻辑删除的实体字段名，字段类型可以是boolean、integer
    logic-delete-value: 1 # 逻辑已删除值(默认为 1)
    logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
</code></pre>
<h6 id="逻辑删除本身也有自己的问题，比如："><a href="#逻辑删除本身也有自己的问题，比如：" class="headerlink" title="逻辑删除本身也有自己的问题，比如："></a>逻辑删除本身也有自己的问题，比如：</h6><p>• 会导致数据库表垃圾数据越来越多，影响查询效率<br>• SQL中全都需要对逻辑删除字段做判断，影响查询效率</p>
<p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p>
<h3 id="扩展功能—枚举处理器"><a href="#扩展功能—枚举处理器" class="headerlink" title="扩展功能—枚举处理器"></a>扩展功能—枚举处理器</h3><p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p>
<p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p>
<h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p>
<pre><code class="java">User.java //使用枚举类型
// 使用状态(1正常 2冻结)
private UserStatus status;
</code></pre>
<p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p>
<pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="3-3-2-配置枚举处理器MP增加了Enum和JSON处理器"><a href="#3-3-2-配置枚举处理器MP增加了Enum和JSON处理器" class="headerlink" title="3.3.2.配置枚举处理器MP增加了Enum和JSON处理器"></a>3.3.2.配置枚举处理器<del>MP增加了Enum和JSON处理器</del></h3><p>在application.yaml文件中添加配置：</p>
<pre><code class="YAML">mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private String info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
 @Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == UserStatus.FREEZE) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h6 id="想要前端返回正常还是冻结-JsonValue"><a href="#想要前端返回正常还是冻结-JsonValue" class="headerlink" title="想要前端返回正常还是冻结  @JsonValue"></a>想要前端返回正常还是冻结 <code> @JsonValue</code></h6><pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    @JsonValue
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="扩展功能—JSON处理器AbstractJsonTypeHandler"><a href="#扩展功能—JSON处理器AbstractJsonTypeHandler" class="headerlink" title="扩展功能—JSON处理器AbstractJsonTypeHandler"></a>扩展功能—JSON处理器<del>AbstractJsonTypeHandler</del></h3><p>数据库中user表中有一个json类型的字段</p>
<blockquote>
<p><strong>名称   数据类型      注释</strong><br>info    JSON            详细信息<br>。。。。。。。。。。。。</p>
<p>JSON：<br>{ “age”:20,<br>“intro”: “”青年”,<br>“gender”:”male”}</p>
</blockquote>
<p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p>
<p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p>
<p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p>
<h6 id="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："><a href="#接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：" class="headerlink" title="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："></a>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</h6><p><code>@TableField(typeHandler = JacksonTypeHandler.class)</code> 定义类型处理器<br><code>@TableName(value = &quot;user&quot;, autoResultMap = true)</code></p>
<pre><code class="java">User.java
@Data
@TableName(value = &quot;user&quot;, autoResultMap = true)
public class User &#123;

    /**
     * 用户id
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 详细信息
     */
    @TableField(typeHandler = JacksonTypeHandler.class)
    private UserInfo info;
&#125;
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.domain.po.UserInfo;
import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private UserInfo info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.domain.po;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(staticName = &quot;of&quot;)
public class UserInfo &#123;
    private Integer age;
    private String intro;
    private String gender;
    // 添加静态方法 of
    public static UserInfo of(Integer age, String intro, String gender) &#123;
        return new UserInfo(age, intro, gender);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserMapperTest.java
@SpringBootTest
class UserMapperTest &#123;

    @Autowired
    private UserMapper userMapper;

    @Test
    void testInsert() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(UserInfo.of(14, &quot;英文老师&quot;, &quot;female&quot;));
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userMapper.insert(user);
    &#125;
</code></pre>
<h3 id="插件功能—分页插件基本用法"><a href="#插件功能—分页插件基本用法" class="headerlink" title="插件功能—分页插件基本用法"></a>插件功能—分页插件基本用法</h3><p>MyBatisPlus提供的内置拦截器有下面这些：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>拦截器</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TenantLineInnerInterceptor</td>
<td>多租户插件</td>
</tr>
<tr>
<td>2</td>
<td>DynamicTableNameInnerInterceptor</td>
<td>动态表名插件</td>
</tr>
<tr>
<td>3</td>
<td>PaginationInnerInterceptor</td>
<td>分页插件</td>
</tr>
<tr>
<td>4</td>
<td>OptimisticLockerInnerInterceptor</td>
<td>乐观锁插件</td>
</tr>
<tr>
<td>5</td>
<td>IllegalSQLInnerInterceptor</td>
<td>SQL性能规范插件，检测并拦截垃圾SQL</td>
</tr>
<tr>
<td>6</td>
<td>BlockAttackInnerInterceptor</td>
<td>防止全表更新和删除的插件</td>
</tr>
</tbody></table>
<h6 id="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"><a href="#首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】" class="headerlink" title="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"></a>首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】</h6><pre><code class="java">@Configuration
public class MybatisConfig &#123;

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;
        // 1. 初始化核心插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2. 添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        pageInterceptor.setMaxLimit(1000L); // 设置分页上限
        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    &#125;
&#125;
</code></pre>
<h6 id="接着，就可以使用分页的API了：-IService里面就有"><a href="#接着，就可以使用分页的API了：-IService里面就有" class="headerlink" title="接着，就可以使用分页的API了：[IService里面就有]"></a>接着，就可以使用分页的API了：[IService里面就有]</h6><pre><code class="java">@Test
    void testPageQuery() &#123;
        // 1. 查询
        int pageNo = 1, pageSize = 5;
        // 1.1. 分页参数
        Page&lt;User&gt; page = Page.of(pageNo, pageSize);
        // 1.2. 排序参数, 通过OrderItem来指定
        page.addOrder(new OrderItem(&quot;balance&quot;, true));
        // 先按balance排序 再按id排序
        page.addOrder(new OrderItem(&quot;id&quot;, true));
        // 1.3. 分页查询
        Page&lt;User&gt; p = userService.page(page);
        // 2. 总条数
        System.out.println(&quot;total = &quot; + p.getTotal());
        // 3. 总页数
        System.out.println(&quot;pages = &quot; + p.getPages());
        // 4. 分页数据
        List&lt;User&gt; records = p.getRecords();
        records.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="插件功能—通用分页实体"><a href="#插件功能—通用分页实体" class="headerlink" title="插件功能—通用分页实体"></a>插件功能—通用分页实体</h3><h6 id="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"><a href="#遵循下面的接口规范，编写一个UserController接口，实现User的分页查询" class="headerlink" title="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"></a>遵循下面的接口规范，编写一个UserController接口，实现User的分页查询</h6><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>&#x2F;users&#x2F;page</td>
</tr>
<tr>
<td>请求参数</td>
<td>“pageNo”: 1<br/>“pageSize”: 5<br/>“sortBy”: “balance”<br/>“isAsc”: false<br/>“name”: “jack”<br/>“status”: 1</td>
</tr>
<tr>
<td>返回值</td>
<td>“total”: 1005<br/>“pages”: 201<br/>“list”: 包含两个元素的数组，每个元素都是一个对象，包含以下键值对：<br/>“id”: 1 或 2<br/>“username”: “Jack” 或 “Rose”<br/>“info”: 包含以下键值对的对象：<br/>“age”: 21 或 20<br/>“gender”: “male” 或 “female”<br/>“intro”: “佛系青年” 或 “文艺青年”<br/>“status”: “正常” 或 “冻结”<br/>“balance”: 2000 或 1000</td>
</tr>
<tr>
<td>特殊说明</td>
<td>如果排序字段为空，默认按照更新时间排序  •排序字段不为空，则按照排序字段排序</td>
</tr>
</tbody></table>
<h6 id="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"><a href="#准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】" class="headerlink" title="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"></a>准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】</h6><p><code>写一个 【统一的分页条件】 和 【统一的分页结果】</code></p>
<pre><code class="java">com/itheima/mp/domain/query/UserQuery.java
// 要记得继承哦
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery extends PageQuery&#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">com/itheima/mp/controller/UserController.java
@ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        return (List&lt;UserVO&gt;) userService.queryUsersPage(query);
    &#125;
</code></pre>
<pre><code class="java">// 如果你想在字符串中表示一个大于号，
你可以直接输入 &gt;，或者使用HTML实体 &amp;gt; 
小于号可以使用 &lt; 或者 &amp;lt;，
等于号可以使用 = 或者 &amp;equals
</code></pre>
<h3 id="插件功能—通用分页实体与MP转换"><a href="#插件功能—通用分页实体与MP转换" class="headerlink" title="插件功能—通用分页实体与MP转换"></a>插件功能—通用分页实体与MP转换</h3><p>需求：</p>
<ul>
<li>在PageQuery中定义方法，将PageQuery对象转为MyBatisPlus中的Page对象</li>
<li>在PageDTO中定义方法，将MyBatisPlus中的Page结果转为PageDTO结果</li>
</ul>
<h6 id="最好直接封装通用部分"><a href="#最好直接封装通用部分" class="headerlink" title="最好直接封装通用部分"></a>最好直接封装通用部分</h6><h5 id="封装查询"><a href="#封装查询" class="headerlink" title="封装查询"></a>封装查询</h5><pre><code class="java"> @Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());
        // 1.2 排序条件
        if (StrUtil.isNotBlank(query.getSortBy())) &#123;
            // 不为空
            page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc()));
        &#125;else &#123;
            // 为空，默认按照更新时间排序
            page.addOrder(new OrderItem(&quot;update_time&quot;, false));
        &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<h5 id="封装结果"><a href="#封装结果" class="headerlink" title="封装结果"></a>封装结果</h5><pre><code class="java">// 3.封装VO结果
        PageDTO&lt;UserVO&gt; dto = new PageDTO&lt;&gt;();
        // 3.1 总条数
        dto.setTotal(p.getTotal());
        // 3.2 总页数
        dto.setPages(p.getPages());
        // 3.3 当前页数据
        List&lt;User&gt; records = p.getRecords();
        if (CollUtil.isEmpty(records)) &#123;
            dto.setList(Collections.emptyList());
            return dto;
        &#125;
        // 3.4 拷贝user的VO
        dto.setList(BeanUtil.copyToList(records, UserVO.class));
        // 4.返回
        return dto;
    &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = query.toMpPageDefaultSortByUpdateTimeDesc();
        // 2. 分页查询
        Page&lt;User&gt; p = lambdaQuery()
                .like(name != null, User::getUsername, name)
                .eq(status != null, User::getStatus, status)
                .page(page);
        // 3. 封装VO结果
//        return PageDTO.of(p, UserVO.class); 属性转换 ↓
        return PageDTO.of(p, user -&gt; &#123;
            // 1.拷贝基础属性
            UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
            // 2.处理特殊逻辑 密码加**
            vo.setUsername(vo.getUsername().substring(0, vo.getUsername().length()-2)+&quot;**&quot;);
            return vo;
        &#125;);
    &#125;
</code></pre>
<hr>
<hr>
<hr>
<h3 id="tilas-all-成功案例"><a href="#tilas-all-成功案例" class="headerlink" title="tilas-all 成功案例"></a>tilas-all 成功案例</h3><pre><code class="java">package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class GenderStatisticsDTO &#123;
    private String name;
    private Integer value;

&#125;
==================================================
package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName(&quot;emp&quot;)
public class JobStatisticsDTO &#123;
    private List&lt;String&gt; jobList;
    private List&lt;Long&gt; dataList;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Emp;

import java.util.List;

public interface ReportService extends IService&lt;Emp&gt; &#123;
    List&lt;GenderStatisticsDTO&gt; getGenderStatistics(); // 获取性别统计信息
    JobStatisticsDTO getJobStatistics(); // 获取职位统计信息
&#125;


//    CombinedStatisticsDTO getCombinedStatistics();
</code></pre>
<pre><code class="java">com/itheima/controller/ReportController.java
package com.itheima.controller;

import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Result;
import com.itheima.service.ReportService;
import io.swagger.annotations.Api;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Api(tags = &quot;报表统计接口&quot;)
@RestController
@RequestMapping(&quot;/report&quot;)
@RequiredArgsConstructor
public class ReportController &#123;

    private final ReportService reportService;

    // 获取合并后的统计信息
//    @GetMapping(&quot;/statistics&quot;)
//    public Result&lt;CombinedStatisticsDTO&gt; getStatistics() &#123;
//        CombinedStatisticsDTO combinedStatistics = reportService.getCombinedStatistics();
//        return Result.success(combinedStatistics);
//    &#125;

    // 获取员工性别统计信息
    @GetMapping(&quot;/empGenderData&quot;)
    public Result&lt;List&lt;GenderStatisticsDTO&gt;&gt; getEmployeeGenderStatistics() &#123;
        List&lt;GenderStatisticsDTO&gt; genderStatistics = reportService.getGenderStatistics();
        return Result.success(genderStatistics);
    &#125;

    // 获取员工职位统计信息
    @GetMapping(&quot;/empJobData&quot;)
    public Result&lt;JobStatisticsDTO&gt; getEmployeeJobStatistics() &#123;
        JobStatisticsDTO jobStatistics = reportService.getJobStatistics();
        return Result.success(jobStatistics);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/service/impl/ReportServiceImpl.java
package com.itheima.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.mapper.ReportMapper;
import com.itheima.pojo.Emp;
import com.itheima.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl extends ServiceImpl&lt;ReportMapper, Emp&gt; implements ReportService &#123;

    private final ReportMapper reportMapper;

    @Autowired
    public ReportServiceImpl(ReportMapper reportMapper) &#123;
        this.reportMapper = reportMapper;
    &#125;

    // 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();

        // 修改查询字段，注意这里你仍然需要写正确的字段名
        wrapper.select(&quot;CASE job WHEN 1 THEN &#39;班主任&#39; WHEN 2 THEN &#39;讲师&#39; WHEN 3 THEN &#39;学工主管&#39; WHEN 4 THEN &#39;校研主管&#39; WHEN 5 THEN &#39;咨询师&#39; ELSE &#39;其他&#39; END AS 职位&quot;,
                        &quot;COUNT(*) AS 数量&quot;)
                .groupBy(&quot;job&quot;);

        // 通过 selectMaps 执行查询
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 创建两个列表来存储职位和数量
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        // 遍历查询结果并填充列表
        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            jobTitles.add((String) stat.get(&quot;职位&quot;));
            counts.add((Long) stat.get(&quot;数量&quot;));
        &#125;

        // 返回JobStatisticsDTO对象，传入两个列表
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;

    // 获取员工性别统计信息
    @Override
    public List&lt;GenderStatisticsDTO&gt; getGenderStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;gender&quot;, &quot;COUNT(gender) AS value&quot;)
                .groupBy(&quot;gender&quot;);

        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 转换为 GenderStatisticsDTO
        return statistics.stream()
                .map(stat -&gt; &#123;
                    String genderName = &quot;1&quot;.equals(String.valueOf(stat.get(&quot;gender&quot;))) ? &quot;男性员工&quot; : &quot;女性员工&quot;;
                    int count = ((Number) stat.get(&quot;value&quot;)).intValue();
                    return new GenderStatisticsDTO(genderName, count);
                &#125;)
                .collect(Collectors.toList());
    &#125;
&#125;
</code></pre>
<h6 id="上面的获取员工职位属性已修改为高级版本"><a href="#上面的获取员工职位属性已修改为高级版本" class="headerlink" title="上面的获取员工职位属性已修改为高级版本"></a>上面的获取员工职位属性已修改为高级版本</h6><pre><code class="java">// 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        // 1. 构建查询条件
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;job&quot;, &quot;COUNT(*) AS count&quot;)
                .groupBy(&quot;job&quot;);

        // 2. 查询数据
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 如果返回结果为 null 或为空列表，返回默认对象
        if (statistics == null || statistics.isEmpty()) &#123;
            return new JobStatisticsDTO(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());
        &#125;

        // 3. 转换结果：处理 `null` 值和字段映射
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            if (stat == null) &#123;
                continue; // 跳过 null 数据
            &#125;

            // 使用 `getOrDefault` 方法，确保不会返回 null
            Integer jobCode = (Integer) stat.getOrDefault(&quot;job&quot;, -1);
            Long count = stat.get(&quot;count&quot;) == null ? 0L : ((Number) stat.get(&quot;count&quot;)).longValue();

            // 如果 jobCode 是 -1 或其他无效值，则视为“其他”
            String jobTitle = switch (jobCode) &#123;
                case 1 -&gt; &quot;班主任&quot;;
                case 2 -&gt; &quot;讲师&quot;;
                case 3 -&gt; &quot;学工主管&quot;;
                case 4 -&gt; &quot;校研主管&quot;;
                case 5 -&gt; &quot;咨询师&quot;;
                default -&gt; &quot;其他&quot;;
            &#125;;

            jobTitles.add(jobTitle);
            counts.add(count);
        &#125;

        // 返回封装好的 DTO 对象
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/23/后端/MyBatisPlus/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/">
        <h2>
            Stream模板+Lambda常用+@注释+常用方法模板集合
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Stream模板"><a href="#Stream模板" class="headerlink" title="Stream模板"></a>Stream模板</h1><h6 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h6><p>中间方法的特点惰性求值：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。可以链式调用：多个中间操作可以链接在一起，形成一个操作链。返回类型：所有的中间操作返回的都是一个 Stream 对象。</p>
<h6 id="Stream中间代码"><a href="#Stream中间代码" class="headerlink" title="Stream中间代码"></a>Stream中间代码</h6><pre><code class="java">功能：过滤流中的元素，仅保留满足给定条件的元素。
// 示例：
Stream.of(1, 2, 3, 4, 5)
      .filter(n -&gt; n % 2 == 0) // 只保留偶数
      .forEach(System.out::println);//打印功能：将流中的元素映射为其他形式（通常是不同类型）。
// 示例：
Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。示例：Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);功能：去除流中的重复元素。示例：Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4功能：对流中的元素进行排序。示例：Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);功能：截取流中的前 maxSize 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);功能：跳过流中的前 n 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5下面是一个示例，展示了多种中间方法的使用：import java.util.Arrays;
import java.util.List;
</code></pre>
<details class="lake-collapse"><summary id="u41427c34"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 16px">中间方法：</span></strong></summary><ol class="ne-ol"><li id="ue6d895fe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">中间方法的特点<br /></span></strong><a href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">惰性求值</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">可以</span></strong><a href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">链式调用</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：多个中间操作可以链接在一起，形成一个操作链。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">返回类型：所有的中间操作返回的都是一个 Stream 对象。</span></strong></li></ol></details>
<details class="lake-collapse"><summary id="ueec7bf3e"><strong><span class="ne-text" style="color: #DF2A3F">stream中间操作</span></strong></summary><p id="u9155c15c" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：过滤流中的元素，仅保留满足给定条件的元素。</span></strong></p><p id="ue9508648" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oyHwt" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
.filter(n -&gt; n % 2 == 0) // 只保留偶数
.forEach(System.out::println);//打印</code></pre><p id="u7087b579" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素映射为其他形式（通常是不同类型）。</span></strong></p><p id="uec5be4e7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="rVrS1" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写</code></pre><p id="ufc5f99d4" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。</span></strong></p><p id="ub40cb3ec" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="NUaVI" class="ne-codeblock language-java"><code>Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);</code></pre><p id="u9bb719ff" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F">功能：去除流中的重复元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="Q888J" class="ne-codeblock language-java"><code>Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4</code></pre><p id="u18f09612" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">功能：对流中的元素进行排序。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">示例：</span></strong></p><pre data-language="java" id="JLF00" class="ne-codeblock language-java"><code>Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);</code></pre><p id="ue50c0c95" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：截取流中的前 maxSize 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="OdjlP" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);</code></pre><p id="u5c024d35" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：跳过流中的前 n 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="fN4RR" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5</code></pre><p id="u05623b28" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种中间方法的使用：</span></strong></p><pre data-language="java" id="wLvBv" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
public class StreamIntermediateOperations &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;);

<pre><code>    // 使用中间方法
    names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;)) // 过滤以 &#39;A&#39; 开头的名字
        .map(String::toUpperCase) // 将名字转换为大写
        .sorted() // 排序
        .forEach(System.out::println); // 输出结果
&#125;
</code></pre>
<p>}</code></pre><p id="ud6df2a51" class="ne-p"><br></p></details></p>
<details class="lake-collapse"><summary id="u8303321d"><strong><span class="ne-text">终结方法</span></strong></summary><p id="u6620a2d6" class="ne-p"><strong><span class="ne-text">在 Java Stream API 中，终结方法（Terminal Operations）是指那些会触发流的计算并最终产生结果的方法。与中间操作不同，终结方法会结束流的操作链，并返回一个具体的结果或副作用。以下是对终结方法的详细介绍：</span></strong></p><p id="ued92678c" class="ne-p"><strong><span class="ne-text">1. 终结方法的特点</span></strong></p><p id="u4f276cc4" class="ne-p"><strong><span class="ne-text">触发计算：终结方法会对流中的数据进行处理并生成结果，通常会遍历流中的所有元素。</span></strong></p><p id="u06c9bbef" class="ne-p"><strong><span class="ne-text">返回类型：终结方法可以返回不同类型的结果，包括：</span></strong></p><p id="ucfcd69c3" class="ne-p"><strong><span class="ne-text">基本类型（如 int、double）</span></strong></p><p id="u477c4769" class="ne-p"><strong><span class="ne-text">对象（如 List、Set、Map）</span></strong></p><p id="u935ad81e" class="ne-p"><strong><span class="ne-text">特殊值（如 Optional、Void）</span></strong></p></details>
<details class="lake-collapse"><summary id="u2b491d90"><strong><span class="ne-text" style="color: #DF2A3F">终结方法</span></strong></summary><p id="u6772e1b1" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：对流中的每个元素执行指定的操作。</span></strong></p><p id="udd84ed9a" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oUmRF" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);</code></pre><p id="u8e4efc31" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素收集到集合或其他形式。</span></strong></p><p id="u5b5cf4d3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="zF3zf" class="ne-codeblock language-java"><code>List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());</code></pre><p id="u76f88dab" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F; font-size: 14px">功</span></strong><strong><span class="ne-text" style="color: #DF2A3F">能：对流中的元素进行归约，返回一个单一的结果。</span></strong></p><p id="ue96e0ab3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="H9hY0" class="ne-codeblock language-java"><code>int sum = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</code></pre><p id="uab6649eb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中元素的数量。</span></strong></p><p id="u88fba7fd" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="ATK6U" class="ne-codeblock language-java"><code>long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).count();</code></pre><p id="u2f406546" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中是否有任何元素满足给定的条件。</span></strong></p><p id="uc612e6ba" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="yGMii" class="ne-codeblock language-java"><code>boolean hasA = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).anyMatch(s -&gt; s.equals(&quot;a&quot;));</code></pre><p id="u371b5ce7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中所有元素是否满足给定的条件。</span></strong></p><p id="ufd1731bb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="O6I5A" class="ne-codeblock language-java"><code>boolean allMatch = Stream.of(1, 2, 3).allMatch(n -&gt; n &lt; 5);</code></pre><p id="u5928384b" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中的第一个元素（如果存在）。</span></strong></p><p id="ufe6ffdc2" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="qh5FK" class="ne-codeblock language-java"><code>Optional&lt;String&gt; first = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).findFirst();</code></pre><p id="ub4cf4986" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种终结方法的使用：</span></strong></p><pre data-language="java" id="dakWh" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


<p>public class StreamTerminalOperations &#123;<br>    public static void main(String[] args) &#123;<br>        List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);</p>
<pre><code>    // forEach
    names.stream().forEach(System.out::println);

    // collect
    List&amp;lt;String&amp;gt; filteredNames = names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;))
        .collect(Collectors.toList());
    System.out.println(filteredNames);

    // reduce
    String concatenated = names.stream()
        .reduce(&amp;quot;&amp;quot;, (a, b) -&amp;gt; a + b);
    System.out.println(concatenated);
    
    // count
    long count = names.stream().count();
    System.out.println(&amp;quot;Count: &amp;quot; + count);
    
    // findFirst
    String firstName = names.stream().findFirst().orElse(&amp;quot;No Name&amp;quot;);
    System.out.println(&amp;quot;First Name: &amp;quot; + firstName);
&#125;
</code></pre>
<p>}</code></pre></details></p>
<h3 id="stream流超强引用"><a href="#stream流超强引用" class="headerlink" title="stream流超强引用"></a>stream流超强引用</h3><pre><code class="java">package com.itheima.pojo.test;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Arrays.asList 是 Java 中 java.util.Arrays 类的一个静态方法，
 * 用于将指定的数组或可变数量的参数转换为一个固定大小的 List。
 * 这个 List 是 ArrayList 的一个内部实现类，
 * 但它不是 java.util.ArrayList，
 * 而是一个不可变的列表
 */
public class Test2 &#123;
    public static void main(String[] args) &#123;
        // List&lt;String&gt; list：将上述列表赋值给 list 变量
        List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
        // 定义一个映射，键为整数，值为字符串列表 = 创建一个新的空哈希映射
        // 键的类型是 Integer，值的类型是 List&lt;String&gt; 表示具有相同长度的字符串列表
        // 用HashMap  允许 null 值：键和值都可以为 null，但键只能有一个 null。
        Map&lt;Integer, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : list) &#123;
            int length = s.length();
            // 检查 groups 映射中是否已经存在键为 length 的条目
            if (!groups.containsKey(length)) &#123;
                // 将新创建的列表作为值，以 length 为键添加到 groups 映射中
                // 创建一个新的 ArrayList，并将当前字符串 s 添加到其中
                groups.put(length, new ArrayList&lt;&gt;(Arrays.asList(s)));
            &#125; else &#123;
                // 从 groups 映射中获取键为 length 的列表
                List&lt;String&gt; group = groups.get(length);
                group.add(s);
            &#125;
            System.out.println(groups);
        &#125;

        // 使用 Stream API 进行分组
        // 使用 Collectors.groupingBy 方法按字符串长度进行分组
        // 将分组结果收集到一个新的映射 group2 中。
        Map&lt;Integer, List&lt;String&gt;&gt; group2 = list.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(group2);
    &#125;
&#125;
</code></pre>
<h1 id="Lambda-Stream实用方法"><a href="#Lambda-Stream实用方法" class="headerlink" title="Lambda+Stream实用方法"></a>Lambda+Stream实用方法</h1><pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.for循环输出
for (String s : list)&#123;
System.out.println(s);&#125;

2.表达式输出   
list.forEach(s -&gt;
System.out.println(s);&#125;);

3.表达式最简洁输出
List.forEach(System.out::println);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.使用重写Collections 排序
Collections.sort(list,new Comparator&lt;String&gt;（） &#123;
@override
public int compare(String o1, String o2) &#123;
return o1.compareTo(o2);
&#125;
&#125;);

2.使用lambda表达式排序
Collections.sort(list,(o1,o2) -&gt;&#123;
    return o1.compareTo(o2)
&#125;);

3.使用最简洁的表达式
Collections.sort(list,(o1,o2) -&gt;&#123;o1.compareTo(o2)&#125;);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式过滤
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;String s : list2)&#123;
if(s.startsWith(&quot;a&quot;))&#123;
     list2.add(s);
&#125; &#125;

2.使用 Stream API 进行过滤和收集,过滤以 &#39;a&#39; 开头的字符串,收集结果到一个新的 List 中
List&lt;String&gt;list3 = list.stream().filter(s - &gt; s.startsWith(&quot;a&quot;)).collect(Collectrs.toList());
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式获取长度
List&lt;Integer&gt; List2 = new ArrayList&lt;&gt;();
for （String s:list)&#123;
    
list2.add(s.length());&#125;

2.Lambda表达式+stream流获取长度
(map)这个函数对我们管道中的每个元素做了处理，在此处为把string转换为Integer类型 主要进行转换作用
List&lt;Integer&gt; list3 = list.stream().map(s -&gt; s.length()).collect(Collectors.toList());
</code></pre>
<pre><code class="java">//新建一个List集合
List&lt;Integer&gt; list = Arrays.asList（1,2, 3, 4, 5);
1.普通方式相加操作
int sum =0;
for (Integer v : list) &#123;
SUm +=V  &#125;
System.out.println(sum);

2.Lambda+stream
(表达式含义)：【0】操作的起始值，【a = a+b】 循环下去
int sum2 = list.stream().reduce( identity: 0, (a, b) -&gt; a + b);
System.out.println(sum2)
</code></pre>
<pre><code class="java">//新建一个集合
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);

Map&lt;Integer,List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();

1.普通方式分组
for （String s:list)&#123;
int length = s.length();
if (!groups.containsKey(length))&#123;
groups.put(length,new ArrayList&lt;&gt;());
&#125;
groups.get(Length) .add(s);
&#125;
    System.out.println(groups);

2.Lambda+stream分组
Map&lt;Integer,List&lt;String&gt;&gt; groups2 = list.stream().collect(Collectors.groupingBy(String::length));
System.out.println（groups2）
</code></pre>
<pre><code class="java">1.普通方式创建线程

Thread thread = newThread(new Runnable()&#123;
@Override
public void run()&#123;
System.out.println(&quot;hello world&quot;);
&#125;
&#125;);
thread.start();

2.Lambda表达式

Thread thread1 = new Threal(() -&gt; System.out.println(hello world&quot;));
thread1.start();
</code></pre>
<pre><code class="java">1.创建接口
interface  MyInterface&#123;
public void doSomething(String s);&#125;

2.普通实现接口
MyInterface myInterface = new MyInterface&#123;
    @override
    public void doSomething(String s)&#123;
    System.out.println(s);
    &#125;
&#125;;
myInterface.doSomething( s:&quot;hello world&quot;);

3.Lambda表达式实现接口
MyInterface myInterface1 = (s) -&gt; System.out.println(s);
myInterface1.doSomething( s:&quot;hello worLd&quot;)
</code></pre>
<pre><code class="java">String str = &quot;hello world&quot;;

1.普通方式
if（str !=null）&#123;
System.out.println(str.toUpperCase());&#125;

2.Lambda表达式
Optional.ofNuLlable(str).map(String::toUpperCase).ifPresent(System.out::println);
</code></pre>
<pre><code class="java">List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.普通方式
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
for （String s:list2)&#123; //遍历循环
    if （s.startsWith(&quot;a&quot;))&#123; //取出 包含a的元素
        list2.add(s.toUpperCase());//添加到list2中然后转换为大写
    &#125;
&#125;       Collections.sort(list2); //排序

2.Lambda+stream方式

List&lt;String&gt; list3 = list.stream().filter(s -&gt; s.startsWith(&quot;a&quot;))
.map(String::toupperCase).sorted().collect(collectors.toList());
</code></pre>
<pre><code class="java">public class Dept &#123;
    private int id;

    public Dept(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dept&#123;id=&quot; + id + &quot;&#125;&quot;;
    &#125;
&#125;

public class TestCollectStopOptions &#123;

    public void testCollectStopOptions() &#123;
        // 创建一个包含 Dept 对象的列表
        List&lt;Dept&gt; ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 List 中
        List&lt;Dept&gt; collectList = ids.stream()
                                   .filter(dept -&gt; dept.getId() &gt; 20)
                                   .collect(Collectors.toList());
        System.out.println(&quot;collectList: &quot; + collectList);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Set 中
        Set&lt;Dept&gt; collectSet = ids.stream()
                                 .filter(dept -&gt; dept.getId() &gt; 20)
                                 .collect(Collectors.toSet());
        System.out.println(&quot;collectSet: &quot; + collectSet);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Map 中，key 为 id，value 为 Dept 对象
        Map&lt;Integer, Dept&gt; collectMap = ids.stream()
                                          .filter(dept -&gt; dept.getId() &gt; 20)
                                          .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));
        System.out.println(&quot;collectMap: &quot; + collectMap);
    &#125;

    public static void main(String[] args) &#123;
        new TestCollectStopOptions().testCollectStopOptions();
    &#125;
&#125;

结果

collectList:[Dept&#123;id=22&#125;, Dept&#123;id=23&#125;]
collectSet:[Dept&#123;id=23&#125;, Dept&#123;id=22&#125;]
collectMap:&#123;22=Dept&#123;id=22&#125;, 23=Dept&#123;id=23&#125;&#125;
</code></pre>
<pre><code class="java">import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class User &#123;
    private String id;

    public User() &#123;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;id=&#39;&quot; + id + &#39;\&#39;&#39; + &#39;&#125;&#39;;
    &#125;
&#125;

public class TestStringToIntMap &#123;

    /**
     * 演示map的用途：一对一转换
     */
    public void stringToIntMap() &#123;
        // 创建一个包含字符串 ID 的列表
        List&lt;String&gt; ids = Arrays.asList(&quot;205&quot;, &quot;105&quot;, &quot;308&quot;, &quot;469&quot;, &quot;627&quot;, &quot;193&quot;, &quot;111&quot;);

        // 使用流操作
        List&lt;User&gt; results = ids.stream()
                               .map(id -&gt; &#123;
                                   // 创建一个新的 User 对象
                                   User user = new User();
                                   // 设置 User 对象的 id 属性
                                   user.setId(id);
                                   // 返回 User 对象
                                   return user;
                               &#125;)
                               .collect(Collectors.toList()); // 收集结果到一个新的 List 中

        // 打印结果
        System.out.println(results);
    &#125;

    public static void main(String[] args) &#123;
        new TestStringToIntMap().stringToIntMap();
    &#125;
&#125;
</code></pre>
<h1 id="注释笔记"><a href="#注释笔记" class="headerlink" title="@注释笔记"></a>@注释笔记</h1><p>@RequestBody ：获取请全体json字符串数据 封装给java对象，封装的前提是 json字符串属性要与实体类属性名一致才可以封装。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>#{name} 占位符 会从方法参数 对象里面调用getname封装方法获取数据映射到占位符位置。</p>
<p>#{参数名} 是Mybatis的参数占位符，可以自动将参数映射到SQL语句去执行</p>
<p>参数名要与接口方法的参数名要一致，但是方法只有一个参数时，参数名可以是任意的。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>Spring MVC 的 <font style="color:#DF2A3F;">@RequestMapping </font>注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的请求默认都会是 HTTP GET 类型的。比如<font style="color:#DF2A3F;">@GetMapping </font></p>
<p><font style="color:#DF2A3F;">加入路径处理前端响应</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>注解<font style="color:#DF2A3F;">@RequiredArgsConstructor</font> 是 Lombok 提供的一个注解，其主要作用在于简化 @Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;"> ：</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">的作用与</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Controller&lt;/font&gt;</code><font style="color:#000000;">，</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Service&lt;/font&gt;</code><font style="color:#000000;">的作用都是把对象交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">是标注在</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Dao&lt;/font&gt;</code><font style="color:#000000;">层接口上，作用是将接口的一个实现类交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Mapper</font></p>
<p><font style="color:#000000;">@Mapper: 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。</font></p>
<p><font style="color:#000000;">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中</font></p>
<p><font style="color:#000000;">注意：</font></p>
<p><font style="color:#000000;">在Dao层不要存在相同名字的接口，也就是在Dao不要写重载。因为mapper文件是通过id与接口进行对应的，如果写了两个同名的接口，就会导致mapper文件映射出错。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Transactional </font></p>
<p><font style="color:#000000;">Spring事务管理-控制事务 注解:@Transactional</font></p>
<p><font style="color:#000000;">作用:将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务  放在类上 则是整个类都会启动事务  放在接口上 接口的实现类都会去启动事务。放在方法上此方法中的代码会启动事务。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>规则:JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>MultipartFile  接收文件接口</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@Service 表明这个是逻辑层 可以被调用</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ConfigurationPropertise（）</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#000000;">@Autowired 注入bean</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;background-color:#131314;">集合:@RequestParam[List<Integer> ids</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>是一个在Java项目中常用的注解，特别是在使用日志框架如SLF4J时，通过在你的类上使用<code>@Slf4j</code>注解，Lombok会自动为你的类生成一个静态的日志字段，这个字段通常是<code>org.slf4j.Logger</code>类型的，并且通常命名为<code>log</code>。这样，你就可以在类中直接使用<code>log.info()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.error()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.debug()</code>等方法来记录日志，而无需手动声明和初始化<code>Logger</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">对象。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">@PathVariable  是 Spring MVC 中用于将 URL 模板变量绑定到你控制器处理器方法参数上的注解。这个注解使得你可以从 URL 中提取出变量值，并将其作为参数传递给控制器的方法。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RequestParam(defaultValue &#x3D; “1”)  给参数设置默认值  如果前端没有参数传进来 默认值为1 可自己设置</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@RequestBody 注解  使用对象去接收 的时候使用的注解  </p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RestControllerAdvice</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@ExceptionHandler</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">限制请求的方式</font></p>
<p><font style="color:#DF2A3F;">@RequestMapping  可以放在类上，获取的路径可以当做所有方法的父路径</font></p>
<p>@PostMapping(value&#x3D;”&#x2F;depts”,method&#x3D;RequestMethod.GET)注解 可以放方法上，获取前端的路径。</p>
<p>@GetMapping（”&#x2F;depts”）</p>
<p>@PutMapping</p>
<p>@DeleteMapping</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">junnit5</font></p>
<p>@Test</p>
<p><font style="color:#DF2A3F;">@ParameterizedTest</font></p>
<p><font style="color:#DF2A3F;">@BeforeEach</font></p>
<p>@AfterEach</p>
<p>@BeforeAll  标识静态方法</p>
<p>@AfterAll  标识静态方法</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@RestController &#x3D;  @Controller+@ResponseBody</font></p>
<p>标识当前控制类所有方法都有了@ResponseBody</p>
<p>@ResponseBody 将控制器方法直接输出给前端，将java对象转换为json字符串输出给前端</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>lombok</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;@WebFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，并指定属性</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;urlPatterns&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，通过这个属性指定过滤器要拦截哪些请求。</font></p>
<p><font style="color:rgb(51, 51, 51);">当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</font></p>
<p><font style="color:rgb(51, 51, 51);">@Order注解 控制过滤器优先级数字越小 优先级越高</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">Spring Boot 中注解的作用</font></p>
<p><font style="color:#DF2A3F;"></font></p>
<p><font style="color:#000000;">Spring Boot 利用注解来简化配置和提高开发效率。主要注解包括但不限于：</font></p>
<p><font style="color:#000000;">@SpringBootApplication: 启动 Spring Boot 应用程序。</font></p>
<p><font style="color:#000000;">@Component, @Service, @Repository, @Controller: 标记组件，以便 Spring 容器可以自动检测和管理它们。</font></p>
<p><font style="color:#000000;">@Bean 该方法会在spring项目启动时自动调用，并将方法的返回值交给IOC容器管理 – bean对象</font></p>
<p><font style="color:#000000;">@Autowired: 用于自动装配 Bean。</font></p>
<p><font style="color:#000000;">@Bean: 在配置类中定义 Bean。</font></p>
<p><font style="color:#000000;">@Configuration: 定义配置类。</font></p>
<p><font style="color:#000000;">@EnableAutoConfiguration: 开启自动配置。</font></p>
<p><font style="color:#000000;">这些注解通常被组合使用，以提供一个高度可配置且易于扩展的应用程序结构。</font></p>
<p><font style="color:#000000;">12. @PathVariable, @RequestParam, @ModelAttribute, @RequestBody, @ResponseBody</font></p>
<p><font style="color:#000000;">参数绑定</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">这些注解用于从 HTTP 请求中提取参数，并将它们绑定到方法参数上。</font></p>
<p><font style="color:#000000;">@PathVariable: 用于从 URL 中提取路径变量。</font></p>
<p><font style="color:#000000;">@RequestParam: 用于从查询字符串中提取参数。</font></p>
<p><font style="color:#000000;">@ModelAttribute: 用于将多个请求参数绑定到一个对象上。</font></p>
<p><font style="color:#000000;">@RequestBody: 用于将请求体中的数据绑定到方法参数上。 获取请求体json字符串数据封装给java对象</font></p>
<p><font style="color:#000000;">@ResponseBody: 用于将方法的结果直接写入响应体。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">13. @RestController</font></p>
<p><font style="color:#000000;">控制器注解</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">@RestController 注解是一个组合注解，它等价于 @Controller 和 @ResponseBody 的组合。它表示这是一个 REST 控制器，所有返回值都将被序列化为 JSON 格式并直接写入 HTTP 响应体。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">全局异常处理</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@ControllerAdvice&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于定义全局异常处理类，它可以捕获控制器方法抛出的所有异常，并提供统一的错误响应。</font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class)</font></p>
<p><font style="color:rgb(77, 77, 77);">测试运行器</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class) 注解告诉 JUnit 使用 Spring 测试运行器 (SpringRunner) 来运行测试。Spring 测试运行器提供了一种方便的方式来加载 Spring 上下文并管理测试生命周期。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">整体测试</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@SpringBootTest&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于执行整体测试，它会加载整个 Spring 应用上下文，包括所有自动配置的 Bean。这对于集成测试非常有用，因为它可以模拟完整的 Spring Boot 应用程序。</font></p>
<p>@Configuration 用于定义配置类，<font style="color:rgb(77, 77, 77);">配置类中的bean可以自动装配到其他bean中</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类可以使用其他Spring注解，如@ComponentScan和@Import，来扫描组件或导入其他配置类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类在Spring容器启动时会通过CGLIB动态代理机制生成代理类，以确保@Bean方法只被调用一次，从而保证单例bean的行为</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">环境和属性配置：</font></strong><font style="color:rgb(77, 77, 77);"><br></font><font style="color:rgb(77, 77, 77);">使用@PropertySource和@Value注解可以将外部属性文件中的值注入到配置类中</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">作用:按照一定的条件进行判断，在满足给定条件才会注册对应的bean对象到Spring IOC容器中。</font></p>
<p><font style="color:rgb(77, 77, 77);">位置:方法、类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Conditional 本身是一个父注解，派生出大量子注解</font></p>
<p><font style="color:rgb(77, 77, 77);">@ConditionalonClass:判断环境中是否有对应节码文件才注册bean到IOC容器</font></p>
<p><font style="color:rgb(77, 77, 77);">对应的bean(类型或名称)，才注册bean到IOC容器@ConditionalOnMissingBean:判断环境中没@ConditionalonProperty:判断配置文件中有应属性和值，才注册bean到IOC容器。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">SpringBoot 底层原理</font></p>
<p><font style="color:rgb(77, 77, 77);">bean获取。</font></p>
<p><font style="color:rgb(77, 77, 77);">@singleton   默认容器内同名称的bean只有一个实例（单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@prototype  每次使用该bean时会创建新的实例（非单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@request 每个请求范围内会创建新的实例（web环境中，了解即可）</font></p>
<p><font style="color:rgb(77, 77, 77);">@session 每个会话范围内都会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:rgb(77, 77, 77);">@application 每个应用范围内会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:#DF2A3F;">@Scope 设置bean的作用域 </font><font style="color:rgb(77, 77, 77);"> </font></p>
<p><font style="color:rgb(77, 77, 77);">@Lazy 延迟加载 会延迟到第一次使用的时候才会去加载</font></p>
<p><font style="color:rgb(77, 77, 77);">默认singleton的bean，在容器启动时被创建，可以使用aLazy注解来延迟初始化(延迟到第一次使用时)</font></p>
<p><font style="color:rgb(77, 77, 77);">prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</font></p>
<p><font style="color:rgb(77, 77, 77);">– 非单例是每次使用时会创建一个全新的bean</font></p>
<p><font style="color:rgb(77, 77, 77);">@Import  </font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">是 Java 中 Spring 框架（特别是 Spring Framework 和 Spring Boot）中用于配置类的一个注解。它主要用于导入其他配置类，使得当前的配置类能够复用其他配置类中的配置信息，从而避免重复的配置代码。</font></p>
<p><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Conditional&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 是 Spring Framework 中的一个注解，它用于在自动配置类（@Configuration 类）中或者通过 </font><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Bean&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 方法定义 bean 时，根据特定的条件来决定是否创建某个 bean 或配置。这个注解使得 Spring 的自动配置更加灵活和强大，因为它允许开发者基于特定的条件（如类路径上的特定类、操作系统属性、环境变量等）来启用或禁用配置。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">@Transactional注解书写位置：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">方法</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前方法交给spring进行事务管理</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">类</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前类中所有的方法都交由spring进行事务管理 （推荐）</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">接口</font><ul>
<li><font style="color:rgb(51, 51, 51);">接口下所有的实现类当中所有的方法都交给spring 进行事务管理</font></li>
</ul>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<ul>
<li><p><font style="color:rgb(51, 51, 51);">@Data是lombok注解,可以生成getter&#x2F;setter方法,tostring&#x2F;hashcode&#x2F;equals等方法重写</font></p>
<pre><code>@NoArgsConstructor /添加无参构造

@AllArgsConstructor //添加全参构造
</code></pre>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ResponseBody: 将控制器方法返回值直接输出给前端，将java对象转换为json字符串输出给前端@RestController &#x3D; @controller + @ResponseBody</p>
<p>标识了当前控制器类所有方法就都有了@ResponseBody</p>
<p>@Controller : spring框架的ioc注解，用于给当前类创建实例对象，也就是加入ioc容器中。</p>
<p>@Autowired ：依赖注入注解:在运行时会从spring容器中找当前接口实现类对象并注入</p>
<p>@Qualifier(“Bean对象”)：指定Bean别名这与对象</p>
<p>@Qualifier常与@Autowired一起使用</p>
<p>@0ptions(useGeneratedKeys &#x3D; true，keyProperty &#x3D;”id”)&#x2F;&#x2F;需要获取数据库赋值的id属性 并赋值给对象的id</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<h1 id="常用方法模板集合"><a href="#常用方法模板集合" class="headerlink" title="常用方法模板集合"></a>常用方法模板集合</h1><pre><code class="java">@Test
1:JsONUtil.toJsonStr(paramMap)//将任意对象转换为json字符串形式
                     
//使用hutool工具类把BedDto类型转换成Bed实体类 类型
2:Bed bean = BeanUtil.toBean(bedDto, Bed.class);

//判断对象是否为null 如果为null 返回true
3:Objects.isNull(xx)

//判断对象是否不为null 如果不为null 返回true
4:Objects.nonNull(xx)
                  
//工具类Objects 专门用来解决空指针异常 意思 先判断s1！=null 在调用s1.equals(s2)
5:Objects.equals(s1,s2)

//强转方法
6:String.valueOf() 

//整个对象的转换方法
7:BeanUtils.copyProperties(user,userPojo) 

8:StringUtils.toStringArray(把括号中的内容转换为一个字符串类型数组)

//在java中，JSONOBject类中的get（String key）方法接收一个字符串参数作为键名，用于从JSON对象中获取对应的值，这种方法运行通过建模来检索特定的数据项
//当我们调用JSONOBject.get(&quot;acces_token&quot;)的时候，实际上是在告诉程序：请查找名为“access_token”的键，并返回其关键的值，
//如果找到匹配的键，则返回相应的值，如果没有找到，则返回null
9:JSONOBject.get(&quot;acces_token&quot;)
//建造者设计模式：利用各种组件（各种属性）随意组合生成对象，目的是创建对象更加灵活
//与直接调用构造函数对比
//类一般要提供很多构造函数才可以灵活构建对象，这种方式很麻烦
//建造者模式创建对象底层只需需要提供一个构造函数即可，在使用的时候想设置哪个属性就设置哪个属性，最终都调用同一个构造函数
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder给当前类添加建造者设计模式创建对象    这几个注解都要有
10：member = Member.builder()
.openId(openid)
.build();
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/19/攻略/Git详细操作/">
        <h2>
            git详细操作
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><code>@Author yuan</code></p>
<h2 id="Git作用"><a href="#Git作用" class="headerlink" title="Git作用"></a>Git作用</h2><p><font style="color:#DF2A3F;background-color:#FBDE28;">Git 作用</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">代码回溯  版本控制  多人协作  远程备份</font></p>
<p>Git 简介</p>
<p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种:</p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">本地仓库:开发人员自己电脑上的 Git 仓库</font></p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">远程仓库:远程服务器上的 Git 仓库</font></p>
<p>commit:提交,将本地文件和版本信息保存到本地仓库</p>
<p>push:推送,将本地仓库文件和版本信息上传到远程仓库</p>
<p>pull:拉取,将远程仓库文件和版本信息下载到本地仓库</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728304999728-8681df84-6516-4c9a-a9e7-69119132c404.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">常用的 Git 代码托管服务</font></p>
<p>Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢?</p>
<p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">获取Git 仓库-从远程仓库克隆</font></p>
<p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地命令形式:git clone【远程Git仓库地址】</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">工作区、暂存区、版本库 概念</font></p>
<p>版本库:前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等工作区:包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码暂存区:.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">Git工作区中文件的状态</font></p>
<p>Git工作区中的文件存在两种状态:untracked 未跟踪(未被纳入版本控制)</p>
<p>tracked 已跟踪(被纳入版本控制)</p>
<p>1.Unmodified 未修改状态</p>
<p>2.Modified 已修改状态</p>
<p>3.Staged 已暂存状态</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库操作</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库常用命令如下:</font></p>
<p><strong>git status          查看文件状态</strong></p>
<p><strong>git add             将文件的修改加入暂存区</strong></p>
<p><strong>git reset           将暂存区的文件取消暂存或者是切换到指定版本</strong></p>
<p>git commit       将暂存区的文件修改提交到版本库</p>
<p>git log              查看日志</p>
<h1 id="Git项目克隆"><a href="#Git项目克隆" class="headerlink" title="Git项目克隆"></a>Git项目克隆</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">在IDEA中克隆Git项目</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">首先配置Git  </font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347762923-5f8a0d24-f11c-4162-bd3f-b17b6fdfd7cc.png"></p>
<p><font style="color:rgb(51, 51, 51);">说明：如果Git安装在默认目录中（C:\Program Files\Git），则IDEA中无需再手动配置，直接就可以使用。</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第一步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347513186-e3f2fa07-4c0b-46fe-920f-3982080e4299.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第二步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348065880-ac6cf502-c456-4122-a6ab-e70075051bf5.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第三步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348271734-59eff3ed-f0c4-4d72-b3d1-0c6c16584db3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第四步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348416264-cd2e8e62-f156-45dd-82cd-9e9e6033170c.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第五步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348466727-6131437b-652f-4f1e-af23-ba44a5b06f34.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第六步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348514297-16fde195-3353-4143-b11f-1e2525409467.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>红色:未跟踪文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>绿色</strong>:<strong>已暂存文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>蓝色</strong>:<strong>已修改文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>黑色</strong>:<strong>未修改文件</strong></font></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.创建一个标签</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356563022-557a0fbc-3faf-4e88-97dd-ebecc3f671e3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">确认标签名：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356633874-991c5be6-115b-44dc-83f0-a14a3d8ae038.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">添加成功：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356669609-147814c4-3fc5-4905-8840-72f80f5051d2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送到远程仓库：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356774166-0d41891d-631a-4313-937f-85f09f5438ef.png"></p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">分支操作:</font></p>
<p>查看分支，本质就是执行 gitbranch 命令</p>
<p>创建分支，本质就是执行 git branch 分支名 </p>
<p>命令切换分支，本质就是执行 git checkout命令</p>
<p>将分支推送到远程仓库，本质就是执行 git push 命令</p>
<p>合并分支，本质就是执行 git merge 命令</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">IDEA中查看分支在右下角，如图</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355362895-b04cd00a-03e0-456c-b901-fc343da9be6d.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355451938-5e8ae2ff-5c6b-470a-8419-814bbc077498.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355509519-a24c495a-3bde-447e-8557-b8ef2bdc4405.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355654046-73a4dbc8-b73d-4b40-b5e9-659ea5d82945.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">切换分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355795984-ecf5519c-c5ee-46fb-b86a-9b6f5a6d5bf2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356060830-877aa5cd-7b37-41df-a7b3-3c90f34d623c.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356178679-0aa3a848-e212-4bee-909a-d0360ede2269.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支后需要推送到远程仓库同步</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356308073-89d5e135-2d4c-437e-823d-cc122b649b3f.png"></p>
<h1 id="切换版本开发"><a href="#切换版本开发" class="headerlink" title="切换版本开发"></a>切换版本开发</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">切换版本：</font></p>
<p>在开发过程中，有a1到a5这几个版本的项目，现在需要重新基于a3去开发后续项目。基于这种情况，我们可以右键这个版本的项目，新建分支进行开发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357068967-77c87275-510e-4067-a7cd-17b8448bdecd.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357294505-f9518280-5b27-4922-b4c6-0d3a68fc6399.png"></p>
<h1 id="提交-amp-amp-拉取-amp-amp-冲突"><a href="#提交-amp-amp-拉取-amp-amp-冲突" class="headerlink" title="提交 &amp;&amp; 拉取 &amp;&amp; 冲突"></a>提交 &amp;&amp; 拉取 &amp;&amp; 冲突</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.提交</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351542021-b166f619-90aa-438f-9679-bf82ac777e12.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">2.推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351606771-c5aa2b2a-b25d-4923-a1b1-5e57dc79a098.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">3.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351707487-a8cbd23f-0b89-4e76-9afd-9f9d4cf24fb1.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">4.提交推送2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351889553-2e93cea9-f5a9-49a1-b38e-ed889eebe51e.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">5.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351959955-8efb3bf0-1fbf-456a-b187-0c8e56939498.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font>多个人操作同一个文件，其中有人基于旧的版本修改，提交新版本会成功，但是推送到远程会失败，就是发送冲突。</p>
<p>冲突为什么发生：a和b同时修改c1文件，a先修改完成c1文件，提交推送到远程仓库，c1文件进行更新版本成为c2，提交推送后b也修改完成c1文件，提交的时候成功 推送则失败，因为远程仓库的文件已经进行了更新。<strong>b推送的时候没有拉取最新的文件进行修改，而是使用的过期版本，所以造成冲突。</strong></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突，拉取，合并，推送</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353222693-dfb36773-9de9-4e59-913e-76ab27d9c7af.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：1</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353384068-45d7181b-852b-4c20-876c-c54ac075c495.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353537745-00b91a2b-d5b8-4490-8925-df9fb5637584.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：3</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353826957-3282047c-26eb-4555-8b12-19f1c2f9a5dc.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：4</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353863162-0e943f20-1ae9-4747-9008-3e253c18b7eb.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送合并后的项目到远程仓库</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354076794-ee920b1a-dc3a-4524-ad43-753fb6e75526.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354258412-947fe27d-bcf5-4153-ac1b-cf8c38a7db53.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/攻略" style=color:#00bcd4>
                攻略
            </a>
        </span>
        
    </div>

    <a href="/2024/11/19/攻略/Git详细操作/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/03/后端/若依-AI & 帝可得/">
        <h2>
            若依-AI & 帝可得
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="RuoYi-Vue"><a href="#RuoYi-Vue" class="headerlink" title="RuoYi-Vue"></a>RuoYi-Vue</h3><ul>
<li>RuoYi-Vue版本，采用了前后端分离的单体架构设计<br><a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/RuoYi-Vue3">https://gitee.com/ys-gitee/RuoYi-Vue3</a><br><a target="_blank" rel="noopener" href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project/RuoYi-Vue</a></li>
</ul>
<table>
<thead>
<tr>
<th align="center">课程版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JDK 11</td>
</tr>
<tr>
<td align="center">MySQL 8</td>
</tr>
<tr>
<td align="center">Redis 5</td>
</tr>
<tr>
<td align="center">Maven 3.6</td>
</tr>
<tr>
<td align="center">Node 16 (Vue3)</td>
</tr>
</tbody></table>
<ul>
<li>技术选型：SpringBoot、SpringSecurity、MyBatis、Jwt、VUE3、Element-Plus</li>
</ul>
<ol>
<li><p><strong>从VCS导入项目</strong>：</p>
<ul>
<li><p>点击<code>VCS</code>菜单。</p>
</li>
<li><p>选择<code>Get from Version Control...</code>选项。</p>
</li>
<li><pre><code class="java">URL：https://gitee.com/y_project/RuoYi-Vue.git
Directory：C:\Users\Pluminary\Desktop\RuoYi-Vue
</code></pre>
</li>
</ul>
</li>
<li><p><strong>输入项目地址</strong>：</p>
<ul>
<li>在弹出的窗口中，您可以看到不同的版本控制系统（例如Git, SVN等）。</li>
<li>选择您要导入的项目所使用的版本控制系统。</li>
<li>在接下来的窗口中，您需要输入项目的URL地址。这通常是项目的仓库地址，例如Git仓库的HTTPS或SSH链接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>① 若模块没有导入进去没有亮 就<strong>Maven → clean → package</strong></p>
<p>C:\Users\Pluminary\Desktop\RuoYi-Vue\sql 导入Sql文件两个<br><strong>sql&#x2F;quartz.sql</strong><br><strong>sql&#x2F;ry_20240629.sql</strong></p>
</blockquote>
<p>先git<a target="_blank" rel="noopener" href="https://github.com/wzs28150/RuoYi-Vue3">wzs28150&#x2F;RuoYi-Vue3: :tada: (RuoYi)官方仓库 基于SpringBoot，Spring Security，JWT，Vue3 &amp; Vite、Element Plus 的前后端分离权限管理系统</a>下载这里面的资料，在里面<code>C:\Users\Pluminary\Desktop\itcast&gt;code ./RuoYi-Vue3</code>导入vscode里面，再安装依赖(要进入Vue3里面才能利用package.json去生成)<code>npm install</code> → 运行前端项目<code>npm run dev</code></p>
<pre><code class="java">// npm install慢的话 就用中国镜像去下载
npm install --registr=https://registry.npmmirror.com

C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3&gt;npm run dev

&gt; ruoyi@3.8.8 dev
&gt; vite


  VITE v5.3.2  ready in 2026 ms

  ➜  Local:   http://localhost:8080/
  ➜  Network: http://10.254.3.124:8080/
  ➜  Network: http://192.168.104.38:8080/
  ➜  Network: http://192.168.22.1:8080/
  ➜  Network: http://192.168.36.1:8080/
  ➜  press h + enter to show help
</code></pre>
<p>再导入<code>课程管理.sql</code>数据库 → 在若依的后台系统 → 系统工具 → 代码生成 → 配置好后下载代码 → 导入数据库</p>
<p> → 导入RuoYi生成的前端代码<code>C:\Users\Pluminary\Downloads\ruoyi\vue\api</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code> &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\vue\views</code> 的<strong>course</strong>导入vscode中 <code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\api\course</code></p>
<p>→ 导入RuoYi生成的后端代码<code>C:\Users\Pluminary\Desktop\itcast\RuoYi-Vue3\src\views\course</code>的<strong>com</strong> 并且导入配置文件 &amp;&amp; <code>C:\Users\Pluminary\Downloads\ruoyi\main\resources</code>的<strong>mapper</strong>导入到idea的resource中</p>
<h3 id="功能详解"><a href="#功能详解" class="headerlink" title="功能详解"></a>功能详解</h3><h5 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h5><ul>
<li>若依内置了强大的权限控制系统，为企业级项目提供了通用的解决方案<ul>
<li>**demo账号 (超级管理员)**，查看所有功能菜单</li>
<li>**zhangsan账号 (市场专员)**，查看线索菜单</li>
<li>**yueyue账号 (销售专员)**，查看商机、合同等菜单</li>
</ul>
</li>
<li><strong>RBAC (基于<span style = "color:red">角色的控制访问</span>)</strong> 是一种广泛使用的访问控制模型，通过<strong>角色</strong>来分配和管理<strong>用户</strong>的菜单<strong>权限</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">表名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sys_dept</td>
<td align="center">部门表</td>
</tr>
<tr>
<td align="center">sys_post</td>
<td align="center">岗(职)位信息表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>菜单权限表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_role_dept</td>
<td align="center">角色和部门关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_role_menu</strong></span></td>
<td align="center"><span style = "color:red"><strong>角色和菜单关联表</strong></span></td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户信息表</strong></span></td>
</tr>
<tr>
<td align="center">sys_user_post</td>
<td align="center">用户与岗位关联表</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>sys_user_role</strong></span></td>
<td align="center"><span style = "color:red"><strong>用户和角色关联表</strong></span></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e34a8982a14929c9b4d00cae2f337c3e043708da/%E8%8B%A5%E4%BE%9D-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.jpg"></p>
<h6 id="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"><a href="#创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。" class="headerlink" title="创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。"></a>创建新用户小智并关联课研人员角色，仅限课程管理和统计分析菜单访问。</h6><p>① <strong>创建菜单</strong><br>② <strong>创建角色，并分配权限</strong><del>课研人员</del><br>③ <strong>创建用户，并关联角色</strong><del>xiaozhi</del></p>
<pre><code class="java">若依通过简单的功能配置实现RBC的权限管理
</code></pre>
<h5 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h5><ul>
<li>若依内置的数据字典，用于维护系统中常见的静态数据。例如：性别、状态</li>
<li>功能包括：字典类型管理、字典数据管理</li>
<li>表关系说明【一对多】</li>
</ul>
<table>
<thead>
<tr>
<th>表名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sys_dict_type</td>
<td>字典类型表</td>
</tr>
<tr>
<td>sys_dict_data</td>
<td>字典数据表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_id</th>
<th>dict_name</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户性别</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>菜单状态</td>
<td>sys_show_hide</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>dict_code</th>
<th>dict_sort</th>
<th>dict_label</th>
<th>dict_value</th>
<th><span style = "color:red">dict_type</span></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>男</td>
<td>0</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>女</td>
<td>1</td>
<td>sys_user_sex</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>未知</td>
<td>2</td>
<td>sys_user_sex</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>将一些不经常修改的数据(课程管理的学科字段)改为数据字典维护，以免占用大量空间</strong></p>
<ul>
<li><p>添加字典类型和数据</p>
<blockquote>
<p>系统管理 → 字典管理 → 新增 → <strong>添加字典类型</strong><br>字典名称：学科<br>字典类型：course_subject<br>第二页点进去<strong>添加字典数据</strong><br>javaEE → 0 → 1 </p>
</blockquote>
</li>
<li><p>修改代码生成信息</p>
<blockquote>
<p>系统工具 → 代码生成 → 编辑课程管理 → subject课程学科 显示类型从<strong>文本框</strong>改成<strong>下拉框</strong> → 字典类型 是学科 → 下载最新的代码<br>只需要修改前端vue组件 因为只改了从前端文本框到下拉框 和一些数据字典</p>
</blockquote>
</li>
<li><p>下载代码，导入前端</p>
<blockquote>
<p>C:\Users\Pluminary\Downloads\ruoyi (1)\vue\views\course\course\index.vue去替换前端的index.vue  此时去若依前端查看课程管理→课程学科就会发现已经添加新的进去了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>此时去<code>课程管理</code>里面找<code>课程学科：JavaEE</code>进行筛选不会出 因为若依底层<br><a target="_blank" rel="noopener" href="http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0">http://10.254.2.179/dev-api/course/course/list?pageNum=1&amp;pageSize=10&amp;subject=0</a><br>要从数据库里把JavaEE的subject改成0<br>优点：<strong>降低数据库的存储压力 提高磁盘利用率</strong></p>
</blockquote>
<h5 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h5><ul>
<li><p><strong>参数设置</strong>：对系统中的参数进行动态维护</p>
<blockquote>
<p>系统管理 → 参数设置 → 验证码开关 → 修改 → 参数键值 → false<br>还可以开启是否 <u>用户注册功能</u> → 前端代码隐藏需要修改 → src&#x2F;views&#x2F;login.vue → 97行注册开关<br>const register &#x3D; ref(true) 此时登录界面就有立即注册 跳转注册</p>
</blockquote>
</li>
<li><p><strong>通知公告(半成品)：</strong>促进组织内部信息传递</p>
<blockquote>
<p>系统管理 → 通知公告 → 新增</p>
</blockquote>
</li>
<li><p><strong>日志管理：</strong>轻松追踪用户行为和系统运行状况</p>
<blockquote>
<p>系统管理 → 通知公告 → 日志管理 → 操作日志</p>
</blockquote>
</li>
</ul>
<h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><ul>
<li><p>若依提供了一些列强大的监控工具，能够帮助开发者和运维快速了解应用程序的性能状态</p>
<blockquote>
<p>系统监控 → 在线用户 &amp;&amp; 缓存列表<br>数据监控【Druid Monitor】 → ruoyi &amp;&amp; 123456</p>
</blockquote>
</li>
</ul>
<h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><ul>
<li><p>若依为定时任务功能提供方便友好的web界面，实现动态管理任务</p>
<pre><code class="java">@Component
public class MyTask&#123;
  @Scheduled(cron = &quot;0/5 *****?&quot;)
  public void showTime()&#123;
     sout(&quot;定时任务开始执行：&quot; + new Date());
  &#125;
&#125;
// 硬编码 改代码需要重新修改 重新编译 重新上传...
</code></pre>
</li>
<li><p><strong>每间隔5秒，控制台输出系统时间</strong></p>
<ul>
<li><p>创建任务类</p>
<blockquote>
<p>创建一个类 <code>C:\Users\Pluminary\Desktop\RuoYi-Vue\ruoyi-quartz\src\main\java\com\ruoyi\quartz\task\MyTask.java</code></p>
<pre><code class="java">package com.ruoyi.quartz.task;

import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class MyTask &#123;
    public void showTime()&#123;
        System.out.println(&quot;定时任务开始执行：&quot; + new Date());
    &#125;
&#125;
</code></pre>
</blockquote>
</li>
<li><p>添加任务规则</p>
<blockquote>
<p>系统监控 → 定时任务 → 新增 →<br>任务名称：输出时间        任务分组：默认<br>调用方式：myTask.showTime()<br>Cron表达式生成器：<u>从0秒开始，每5秒执行一次</u> → 0&#x2F;5 * * * * ?<br>开启输出时间 状态打开！</p>
<h2 id="然后每间隔5秒就会向控制台输出时间"><a href="#然后每间隔5秒就会向控制台输出时间" class="headerlink" title="然后每间隔5秒就会向控制台输出时间"></a>然后每间隔5秒就会向控制台输出时间</h2><p>定时任务开始执行：Wed Nov 06 18:12:30 CST 2024<br>18:12:30.001 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:30.002 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:30.009 [quartzScheduler_Worker-4] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1 定时任务开始执行：Wed Nov 06 18:12:35 CST 2024 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &gt; Preparing: insert into sys_job_log( job_name, job_group, invoke_target, job_message, status, create_time )values( ?, ?, ?, ?, ?, sysdate() ) 18:12:35.006 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - –&gt; Parameters: 输出时间(String), DEFAULT(String), myTask.showTime()(String), 输出时间 总共耗时：0毫秒(String), 0(String) 18:12:35.012 [quartzScheduler_Worker-5] DEBUG c.r.q.m.S.insertJobLog - [debug,135] - &lt; Updates: 1</p>
</blockquote>
</li>
<li><p><strong>启动任务</strong></p>
<p>官方有提供可以训练的模型</p>
<blockquote>
<p>在这里面：com&#x2F;ruoyi&#x2F;quartz&#x2F;task&#x2F;RyTask.java</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="表单构建"><a href="#表单构建" class="headerlink" title="表单构建"></a>表单构建</h5><ul>
<li><h6 id="通过表单构建工具，单独制作一个添加课程的表单页面"><a href="#通过表单构建工具，单独制作一个添加课程的表单页面" class="headerlink" title="通过表单构建工具，单独制作一个添加课程的表单页面"></a>通过表单构建工具，单独制作一个添加课程的表单页面</h6><ul>
<li><p>制作表单并导出</p>
<blockquote>
<p>系统工具 → 表单构建 → 左侧<strong>行容器</strong> → 拖入第一个单行文本 → 右侧可以改名字 如果想实现一行两个文本的化 就把<code>表单栅格调小一点</code> → 选择性组件的<strong>下拉选择</strong>托到右面 → 修改字段名、标题、表单栅格…<br>日期范围 → 课程有效期 → 选择型组件里的日期范围 命名为：课程有效期<br>文件上传组件 → 课程封面<br>评分 → 推荐指数<br>多行文本 → 课程介绍</p>
</blockquote>
</li>
<li><p>复制到前端工程</p>
<blockquote>
<p>搞完后打开前端工程把add.vue它放在 src&#x2F;views&#x2F;course&#x2F;course&#x2F;中</p>
</blockquote>
</li>
<li><p>创建动态菜单</p>
<blockquote>
<p>系统管理 → 菜单管理 → 添加菜单 →<br>菜单类型：菜单<br>菜单名称：添加课程<br>显示排序：1<br>路由地址：course&#x2F;add<br>组件路径：course&#x2F;course&#x2F;add<br>刷新界面 就会有菜单管理→添加课程了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><h5 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h5><ul>
<li>代码生成器，根据数据库表结构自动生成前后端CRUD代码</li>
<li>提供三种生成模板：单表、树表、主子表(一对多)</li>
<li>树表是一种展示层级数据的表格，能展开折叠，清晰呈现父子关系，便于管理</li>
</ul>
<blockquote>
<p>系统工具 → 代码生成 → 导入部门表 → 编辑 → 生成信息 → 生成模板：树表 →<br>树编码字段：dept_id：部门id<br>树父编码字段：parent_id：父部门id<br>树名称字段：dept_name：部门名称<br>提交后下载代码<br>导入后就是 系统管理&#x2F;部门管理 的树型结构界面了</p>
</blockquote>
<table>
<thead>
<tr>
<th>dept_id</th>
<th>parent_id</th>
<th>ancestors</th>
<th>dept_name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>0</td>
<td>0</td>
<td>若依科技</td>
</tr>
<tr>
<td>101</td>
<td>100</td>
<td>0,100</td>
<td>深圳总公司</td>
</tr>
<tr>
<td><span style = "color:red">102</span></td>
<td>100</td>
<td>0,100</td>
<td>长沙分公司</td>
</tr>
<tr>
<td>108</td>
<td><span style = "color:red">102</span></td>
<td>0,100,101</td>
<td>市场部门</td>
</tr>
<tr>
<td>109</td>
<td><span style = "color:red">102</span></td>
<td>0,100,102</td>
<td>财务部门</td>
</tr>
</tbody></table>
<h5 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h5><ul>
<li><p>Swagger，能够自动生成API的同步在线文档，并提供Web界面进行接口调用和测试</p>
<blockquote>
<p>系统工具 → 系统接口<br>若依的Token在应用程序里 需要搞token进去<br>测试：获取用户列表GET<br>得到Token(F12后找应用程序 → Cookie<del>若依</del> → 找到Admin-Token<del>一定是当前ip地址的Token</del> → 在Authorize中设置Token令牌 → 去后端改swagger的请求前缀pathMapping：&#x2F;<del>因为他的地址前面默认佩戴&#x2F;dev-api</del></p>
<pre><code class="yaml"># Swagger配置
swagger:
  # 是否开启swagger
  enabled: true
  # 请求前缀
  pathMapping: /
</code></pre>
<p>然后重启后台项目刷新浏览器打开接口再调用Token再去测试<br>此时就操作成功了</p>
<pre><code class="json">&#123;
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: [
    &#123;
      &quot;userId&quot;: 1,
      &quot;username&quot;: &quot;admin&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15888888888&quot;
    &#125;,
    &#123;
      &quot;userId&quot;: 2,
      &quot;username&quot;: &quot;ry&quot;,
      &quot;password&quot;: &quot;admin123&quot;,
      &quot;mobile&quot;: &quot;15666666666&quot;
    &#125;
  ]
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>若依常用功能？</strong></span></p>
<p>① <strong>权限控制</strong><br>② <strong>数据字典</strong><br>③ <strong>定时任务</strong><br>④ <strong>表单构建</strong><br>⑤ <strong>代码生成</strong></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"  />

<h5 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h5><img src="https://raw.githubusercontent.com/P-luminary/images/f157a27c9825e2305562a5f7a5917ad511ee7ac5/RuoYi%E8%A1%A8%E7%BB%93%E6%9E%84.jpg" style="zoom:150%;" />

<h5 id="前端代码分析"><a href="#前端代码分析" class="headerlink" title="前端代码分析"></a>前端代码分析</h5><ul>
<li><code>api/course/course.js</code>  用于向后端发送Ajax请求的接口代码</li>
<li><code>views/course/course/index.vue</code>用于在浏览器展示课程的视图组件</li>
</ul>
<pre><code class="vue">src\views\course\course\index.vue
&lt;template&gt;
  &lt;div class=&quot;app-container&quot;&gt;
    &lt;!-- :model做双向绑定 将前端录入条件封装给响应对象  v-show控制搜索栏显示隐藏--&gt;
    &lt;el-form :model=&quot;queryParams&quot; ref=&quot;queryRef&quot; :inline=&quot;true&quot; v-show=&quot;showSearch&quot; label-width=&quot;68px&quot;&gt;
      &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
        &lt;!-- v-model双向绑定code(前端课程编码) clearable清理用户输入信息 @keyup键盘回车事件完成搜索--&gt;
        &lt;el-input
          v-model=&quot;queryParams.code&quot;
          placeholder=&quot;请输入课程编码&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
        &lt;!-- v-for遍历课程学科的字典数据列表 :lable展示label :value提交value值--&gt;
        &lt;el-select v-model=&quot;queryParams.subject&quot; placeholder=&quot;请选择课程学科&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_subject&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
        &lt;el-input
          v-model=&quot;queryParams.name&quot;
          placeholder=&quot;请输入课程名称&quot;
          clearable
          @keyup.enter=&quot;handleQuery&quot;
        /&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;el-select v-model=&quot;queryParams.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot; clearable&gt;
          &lt;el-option
            v-for=&quot;dict in course_applicable_person&quot;
            :key=&quot;dict.value&quot;
            :label=&quot;dict.label&quot;
            :value=&quot;dict.value&quot;
          /&gt;
        &lt;/el-select&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item&gt;
        &lt;el-button type=&quot;primary&quot; icon=&quot;Search&quot; @click=&quot;handleQuery&quot;&gt;搜索&lt;/el-button&gt;
        &lt;el-button icon=&quot;Refresh&quot; @click=&quot;resetQuery&quot;&gt;重置&lt;/el-button&gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;

    &lt;el-row :gutter=&quot;10&quot; class=&quot;mb8&quot;&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;!-- @click点击新增按钮弹出新增 v-hasPermi自定义属性完成菜单显示/隐藏 --&gt;
        &lt;el-button
          type=&quot;primary&quot;
          plain
          icon=&quot;Plus&quot;
          @click=&quot;handleAdd&quot;
          v-hasPermi=&quot;[&#39;course:course:add&#39;]&quot;
        &gt;新增&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- :disabled表示这个框是否可用 --&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;success&quot;
          plain
          icon=&quot;Edit&quot;
          :disabled=&quot;single&quot;
          @click=&quot;handleUpdate&quot;
          v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;
        &gt;修改&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;danger&quot;
          plain
          icon=&quot;Delete&quot;
          :disabled=&quot;multiple&quot;
          @click=&quot;handleDelete&quot;
          v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;
        &gt;删除&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;1.5&quot;&gt;
        &lt;el-button
          type=&quot;warning&quot;
          plain
          icon=&quot;Download&quot;
          @click=&quot;handleExport&quot;
          v-hasPermi=&quot;[&#39;course:course:export&#39;]&quot;
        &gt;导出&lt;/el-button&gt;
      &lt;/el-col&gt;
      &lt;!-- 点击会控制&#39;搜索栏&#39;显示隐藏 @queryTable重新加载表格展示数据 --&gt;
      &lt;right-toolbar v-model:showSearch=&quot;showSearch&quot; @queryTable=&quot;getList&quot;&gt;&lt;/right-toolbar&gt;
    &lt;/el-row&gt;
    &lt;!-- v-loading展示表格的加载状态 遍历展示courseList 事件监听器监听选中行 --&gt;
    &lt;el-table v-loading=&quot;loading&quot; :data=&quot;courseList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
      &lt;!-- 当用户勾选复选框 触发@selection-change --&gt;
      &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;!-- 展示具体数据源数据 --&gt;
      &lt;el-table-column label=&quot;课程id&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;课程编码&quot; align=&quot;center&quot; prop=&quot;code&quot; /&gt;
      &lt;el-table-column label=&quot;课程学科&quot; align=&quot;center&quot; prop=&quot;subject&quot;&gt;
 &lt;!-- 通过scope拿到整个表格数据 通过:value=&quot;scope.row.subject&quot;拿到字典值去匹配字典数据列表 找到该值对应的标签显示给前端--&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_subject&quot; :value=&quot;scope.row.subject&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程名称&quot; align=&quot;center&quot; prop=&quot;name&quot; /&gt;
      &lt;el-table-column label=&quot;价格&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt;
      &lt;el-table-column label=&quot;适用人群&quot; align=&quot;center&quot; prop=&quot;applicablePerson&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;dict-tag :options=&quot;course_applicable_person&quot; :value=&quot;scope.row.applicablePerson&quot;/&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;课程介绍&quot; align=&quot;center&quot; prop=&quot;info&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
&lt;!-- 使用了模板插槽 --&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;!-- @click=&quot;handleUpdate(scope.row)把当前行的数据传给当前方法  v-hasPermi自定义权限属性--&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;course:course:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    
    &lt;!-- 分页区域 --&gt;
     &lt;!-- v-show如果大于0条就显示反之隐藏 :total展示总条数 展示分页页码 @pagination=&quot;getList&quot;换页后新数据的查询--&gt;
    &lt;pagination
      v-show=&quot;total&gt;0&quot;
      :total=&quot;total&quot;
      v-model:page=&quot;queryParams.pageNum&quot;
      v-model:limit=&quot;queryParams.pageSize&quot;
      @pagination=&quot;getList&quot;
    /&gt;

    &lt;!-- 添加或修改课程管理对话框 --&gt;
     &lt;!-- el-dialog默认隐藏的 点击会显示 append-to-body默认将对话框在body上追加显示 :title动态绑定标题(新增和修改不一样)--&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;!-- :model来双向绑定 :rules校验规则--&gt;
      &lt;el-form ref=&quot;courseRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;课程编码&quot; prop=&quot;code&quot;&gt;
          &lt;el-input v-model=&quot;form.code&quot; placeholder=&quot;请输入课程编码&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程学科&quot; prop=&quot;subject&quot;&gt;
          &lt;el-select v-model=&quot;form.subject&quot; placeholder=&quot;请选择课程学科&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_subject&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt;
          &lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;请输入课程名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;价格&quot; prop=&quot;price&quot;&gt;
          &lt;el-input v-model=&quot;form.price&quot; placeholder=&quot;请输入价格&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;applicablePerson&quot;&gt;
          &lt;el-select v-model=&quot;form.applicablePerson&quot; placeholder=&quot;请选择适用人群&quot;&gt;
            &lt;el-option
              v-for=&quot;dict in course_applicable_person&quot;
              :key=&quot;dict.value&quot;
              :label=&quot;dict.label&quot;
              :value=&quot;dict.value&quot;
            &gt;&lt;/el-option&gt;
          &lt;/el-select&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;info&quot;&gt;
          &lt;el-input v-model=&quot;form.info&quot; placeholder=&quot;请输入课程介绍&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;!-- 提交前先进行表单规则的校验:rules=&quot;rules&quot;  --&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup name=&quot;Course&quot;&gt;
// 引入后端api接口文件
import &#123; listCourse, getCourse, delCourse, addCourse, updateCourse &#125; from &quot;@/api/course/course&quot;;
// 获取当前实例代理对象，用于访问组件数据、方法
const &#123; proxy &#125; = getCurrentInstance();
// 获取课程学科的数据字典
const &#123; course_applicable_person, course_subject &#125; = proxy.useDict(&#39;course_applicable_person&#39;, &#39;course_subject&#39;);
// 列表数据
const courseList = ref([]);
// 是否显示弹框
const open = ref(false);
// 是否显示加载状态
const loading = ref(true);
// 是否显示搜索栏
const showSearch = ref(true);
// 复选框，被选中id的数组
const ids = ref([]);
// 复选框，是否单选，用于高亮修改、删除按钮
const single = ref(true);
// 复选框，是否多选，仅高亮删除按钮
const multiple = ref(true);
// 总(记录)条数
const total = ref(0);
// 用于区分新增、修改对话框标题
const title = ref(&quot;&quot;);
// 定义reactive响应式对象
const data = reactive(&#123;
  // 新增或修改表单数据
  form: &#123;&#125;,
  // 搜索条件参数
  queryParams: &#123;
    pageNum: 1,
    pageSize: 10,
    code: null,
    subject: null,
    name: null,
    applicablePerson: null,
  &#125;,
  // 表单校验规则
  rules: &#123;
    code: [
      &#123; required: true, message: &quot;课程编码不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    subject: [
      &#123; required: true, message: &quot;课程学科不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    name: [
      &#123; required: true, message: &quot;课程名称不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    price: [
      &#123; required: true, message: &quot;价格不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
    applicablePerson: [
      &#123; required: true, message: &quot;适用人群不能为空&quot;, trigger: &quot;change&quot; &#125;
    ],
    info: [
      &#123; required: true, message: &quot;课程介绍不能为空&quot;, trigger: &quot;blur&quot; &#125;
    ],
  &#125;
&#125;);
// 将data对象的三个属性，转换为ref响应式对象
const &#123; queryParams, form, rules &#125; = toRefs(data);

/** 查询课程管理列表 */
function getList() &#123;
  loading.value = true;
  listCourse(queryParams.value).then(response =&gt; &#123;
    courseList.value = response.rows;
    total.value = response.total;
    loading.value = false;
  &#125;);
&#125;

// 取消按钮
function cancel() &#123;
  open.value = false;
  reset();
&#125;

// 表单重置
function reset() &#123;
  form.value = &#123;
    id: null,
    code: null,
    subject: null,
    name: null,
    price: null,
    applicablePerson: null,
    info: null,
    createTime: null,
    updateTime: null
  &#125;;
  proxy.resetForm(&quot;courseRef&quot;);
&#125;

/** 搜索按钮操作 */
function handleQuery() &#123;
  // 最新的从第一页开始 再发送请求
  queryParams.value.pageNum = 1;
  getList();
&#125;

/** 重置按钮操作 */
function resetQuery() &#123;
  proxy.resetForm(&quot;queryRef&quot;);
  handleQuery();
&#125;

// 多选框选中数据
// 把选中的复选框对象传递过来
function handleSelectionChange(selection) &#123;
  // 拿到对象调用map方法进行遍历取每个复选框的id
  // 封装给ids的响应式数组对象
  ids.value = selection.map(item =&gt; item.id);
  // 控制修改和删除按钮是否高亮可用的 23默认为true
  single.value = selection.length != 1;
  // 修改按钮只要大于0 就是false 那么修改按钮可用使用
  multiple.value = !selection.length;
&#125;

/** 新增按钮操作 */
function handleAdd() &#123;
  reset();
  open.value = true;
  title.value = &quot;添加课程管理&quot;;
&#125;

/** 修改按钮操作 */
// 拿到行对象 重置 取出当前行id或一个id
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getCourse(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改课程管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  // &#39;修改课程&#39;对表单进行校验 正则规则...是否必填
  proxy.$refs[&quot;courseRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;// 区分新增还是修改的操作
      if (form.value.id != null) &#123;
        updateCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addCourse(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;

/** 删除按钮操作 */
function handleDelete(row) &#123;
  // 一行或数组
  const _ids = row.id || ids.value;
  // 防止误操作
  proxy.$modal.confirm(&#39;是否确认删除课程管理编号为&quot;&#39; + _ids + &#39;&quot;的数据项？&#39;).then(function() &#123;
    return delCourse(_ids);
  &#125;).then(() =&gt; &#123;
    getList();
    proxy.$modal.msgSuccess(&quot;删除成功&quot;);
  &#125;).catch(() =&gt; &#123;&#125;);
&#125;

/** 导出按钮操作 */
function handleExport() &#123;
  proxy.download(&#39;course/course/export&#39;, &#123;
    ...queryParams.value
  &#125;, `course_$&#123;new Date().getTime()&#125;.xlsx`)
&#125;

getList();
&lt;/script&gt;
</code></pre>
<pre><code class="js">src\api\course\course.js
// 封装了请求和响应拦截器 下面return每个都调用请求
import request from &#39;@/utils/request&#39;

// 查询课程管理列表
// 接收用户输入参数 调用工具类把参数传过去 向后端发送请求完成课程列表的查询
// 然后返回前端并展示数据
export function listCourse(query) &#123;
  return request(&#123;
    url: &#39;/course/course/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;

// 查询课程管理详细
// 点击修改按钮时候根据id去查询 返回给前端
export function getCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;get&#39;
  &#125;)
&#125;

// 新增课程管理
// 当点击确定按钮的时候 就把数据添加进来发送请求后返回前端
export function addCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;post&#39;,
    data: data
  &#125;)
&#125;

// 修改课程管理
// 修改完毕(根据id去查找数据库的)
export function updateCourse(data) &#123;
  return request(&#123;
    url: &#39;/course/course&#39;,
    method: &#39;put&#39;,
    data: data
  &#125;)
&#125;

// 删除课程管理
// 批量/单体删除
export function delCourse(id) &#123;
  return request(&#123;
    url: &#39;/course/course/&#39; + id,
    method: &#39;delete&#39;
  &#125;)
&#125;
</code></pre>
<h3 id="再次熟悉：前-后端结构"><a href="#再次熟悉：前-后端结构" class="headerlink" title="再次熟悉：前+后端结构"></a><span style = "color:red">再次熟悉：前+后端结构</span></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/2d1ced51ed4dfb918b78181cb385e58594e7bdaa/RuoYi%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"></p>
<h6 id="若i18n乱码的情况下"><a href="#若i18n乱码的情况下" class="headerlink" title="若i18n乱码的情况下"></a>若i18n乱码的情况下</h6><blockquote>
<p>file -&gt; settings -&gt; editor -&gt; file ecoding -&gt; <strong>default encoding for properties files</strong>：utf-8</p>
</blockquote>
<h3 id="后端代码分析"><a href="#后端代码分析" class="headerlink" title="后端代码分析"></a>后端代码分析</h3><ul>
<li><p><strong>CourseController</strong></p>
</li>
<li><p><strong>ICourseService及实现类</strong></p>
</li>
<li><p><strong>CourseMapper及映射方法</strong></p>
</li>
<li><p><strong>Course</strong></p>
</li>
<li><p><strong><u>BaseController：web层通用数据处理</u></strong></p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/afd799acd589023d8452649e6565150168bee83b/BaseController%E5%86%85%E5%AE%B9.jpg" style="zoom:200%;" />

<pre><code class="java">/**
     * 查询课程管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        //1.开启分页
        startPage();
        //2.查询课程列表
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
// 在分页查询那块会附带着两个封装好的sql语句
// select * from tb_course where xxx 【逐步细分成两个小sql】
  1. select count(*) from tb_course where xxx      //总记录数
  2. select * from tb_course where xxx limit ?,?   //获取当前的数据列表
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/644e3ab525e8c4aaf75d6f6f3e3879cb2a196303/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%86.jpg"></p>
<h5 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/14bbabe082a07e29da26ea9d5f0c648dcf91677a/%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%8E%9F%E7%90%862.jpg"></p>
<h5 id="AjaxResult：操作消息提醒"><a href="#AjaxResult：操作消息提醒" class="headerlink" title="AjaxResult：操作消息提醒"></a>AjaxResult：操作消息提醒</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/92f34019d9a098b23780c66e99a5bab18541ee9a/AjaxResult%E6%93%8D%E4%BD%9C%E4%BF%A1%E6%81%AF%E6%8F%90%E9%86%92.jpg"></p>
<h5 id="权限解读"><a href="#权限解读" class="headerlink" title="权限解读"></a>权限解读</h5><ul>
<li><code>@PreAuthorize</code>注解是Spring Security框架中用来做权限检查的。</li>
<li>它在运行方法前先验证权限，权限够就放行，不够就拦截</li>
</ul>
<pre><code class="java">@RestController
@RequestMapping(&quot;/course/course&quot;)
public class CourseController extends BaseController &#123;
    @Autowired
    private ICourseService courseService;

    /**
     * 查询课程管理列表
     */
// 问题：我怎么知道该用户有没有权限呢？基于RBC权限模型 
    @PreAuthorize(&quot;@ss.hasPermi(&#39;course:course:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Course course) &#123;
        startPage();
        List&lt;Course&gt; list = courseService.selectCourseList(course);
        return getDataTable(list);
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>菜单名称</th>
<th>排序</th>
<th>权限标识</th>
</tr>
</thead>
<tbody><tr>
<td>课程管理</td>
<td>1</td>
<td>course:course:list</td>
</tr>
<tr>
<td>课程管理查询</td>
<td>1</td>
<td>course:course:query</td>
</tr>
<tr>
<td>课程管理新增</td>
<td>2</td>
<td>course:course:add</td>
</tr>
<tr>
<td>课程管理修改</td>
<td>3</td>
<td>course:course:edit</td>
</tr>
<tr>
<td>课程管理删除</td>
<td>4</td>
<td>course:course:remove</td>
</tr>
<tr>
<td>课程管理导出</td>
<td>5</td>
<td>course:course:export</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/623caf468a6f636c5fe27e119368bfabc1e20aa2/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg"></p>
<pre><code class="java">PermissionService.java
源码解读在后期

/**
 * RuoYi首创 自定义权限实现，ss取自SpringSecurity首字母
 * 
 * @author ruoyi
 */
@Service(&quot;ss&quot;)
public class PermissionService
&#123;
    /**
     * 验证用户是否具备某权限
     * 
     * @param permission 权限字符串
     * @return 用户是否具备某权限
     */
    public boolean hasPermi(String permission)
    &#123;
        if (StringUtils.isEmpty(permission))
        &#123;
            return false;
        &#125;
        LoginUser loginUser = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions()))
        &#123;
            return false;
        &#125;
        PermissionContextHolder.setContext(permission);
        return hasPermissions(loginUser.getPermissions(), permission);
    &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7e976e8ec0b1bb90abd5f6fc94d23c9b8ba39a8b/%E5%89%8D%E5%90%8E%E8%81%94%E8%B0%83.jpg"></p>
<h3 id="二次开发-——-苍穹外卖"><a href="#二次开发-——-苍穹外卖" class="headerlink" title="二次开发 —— 苍穹外卖"></a>二次开发 —— 苍穹外卖</h3><h5 id="若依框架修改器"><a href="#若依框架修改器" class="headerlink" title="若依框架修改器"></a>若依框架修改器</h5><ul>
<li>若依框架修改器是一个可以一键修改RuoYi框架包名、项目名等的工具</li>
</ul>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\若依框架修改器.exe</p>
</blockquote>
<pre><code class="java">选择系列：RuoYi-Vue
目录名称: sky
项目名：sky
包名：com.sky
artifactId：sky
groupId：com.sky
站点名称：外卖管理系统


C:\Users\Pluminary\Desktop\20241108150415\sky
</code></pre>
<h5 id="新建业务模块"><a href="#新建业务模块" class="headerlink" title="新建业务模块"></a>新建业务模块</h5><ul>
<li><p>新建<code>sky-merchant</code>子模块<del>商家管理</del></p>
<ul>
<li><p>新建子模块<br><code>sky-merchant</code> → Advanced Settings → GroupId：com.sky</p>
</li>
<li><p>父工程版本锁定</p>
<pre><code class="xml">pom.xml(sky总)
&lt;!-- 商家管理--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.sky&lt;/groupId&gt;
                &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
                &lt;version&gt;$&#123;sky.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">pom.xml(sky-merchant)
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>sky-admin添加依赖</p>
<pre><code class="xml">pom.xml(sky-admin) 
&lt;dependency&gt;
            &lt;groupId&gt;com.sky&lt;/groupId&gt;
            &lt;artifactId&gt;sky-merchant&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h3><ul>
<li><strong>利用若依代码生成器(主子表模板)，生成菜品管理的前后端代码</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">tb_dish【菜品管理】</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span style = "color:red"><strong>id</strong></span></td>
</tr>
<tr>
<td align="left">name</td>
</tr>
<tr>
<td align="left">price</td>
</tr>
<tr>
<td align="left">image</td>
</tr>
<tr>
<td align="left">description</td>
</tr>
<tr>
<td align="left">status</td>
</tr>
<tr>
<td align="left">create_time</td>
</tr>
<tr>
<td align="left">update_time</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>tb_dish_flavor【菜品口味关系表】</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
</tr>
<tr>
<td><span style = "color:red"><strong>dish_id</strong></span></td>
</tr>
<tr>
<td>name</td>
</tr>
<tr>
<td>value</td>
</tr>
</tbody></table>
<ul>
<li><p>准备SQL并导入数据库</p>
<blockquote>
<p>E:\Java实例项目1-20套\2024-Java若依框架专题课\01-基础篇\资料\04-二次开发\菜品管理</p>
</blockquote>
</li>
<li><p>配置代码生成信息【主子表的生成】</p>
<blockquote>
<p>在若依代码生成 → 导入表<strong>tb_dish</strong> 和 <strong>tb_dish_flavor</strong></p>
</blockquote>
</li>
<li><p>下载代码并导入项目</p>
</li>
<li><p>修改代码 → 系统工具 → 代码生成 → 菜品管理(修改) → </p>
<blockquote>
<p>基本信息：实体类名称→Dish     作者→itheima</p>
</blockquote>
<p>字段信息<del>参考页面原型生成</del> → 系统管理 → 字典管理 →</p>
<blockquote>
<p>字典名称：售卖状态<br>字典类型：dish_status<br>第二页点进去售卖状态的字典类型 dish_status → 新增</p>
<blockquote>
<p>数据标签：停售  +  起售<br>数据键值：0  +  1<br>显示排序：1  +  2</p>
</blockquote>
</blockquote>
</li>
</ul>
<p>​      回到系统工具 → 代码生成 → 菜品管理修改 → 售卖状态 → 显示类型：下拉框 → 字典类型：售卖状态</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f50e3c057b0a8fae3fb16f4e3bcc1c9b507ed227/%E8%8F%9C%E5%8D%95%E8%8B%A5%E4%BE%9D%E4%BD%BF%E7%94%A8.jpg"></p>
<p>→ 代码生成 → 修改菜单配置信息 → 菜品</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/26b0d18887d1c565926b28e8d450fa2a773ccadb/%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%93%81.jpg"></p>
<p>→ 上面的生成信息</p>
<blockquote>
<p>生成模板：主子表<br>生成模块名：merchant<br>生成业务名：dish<br>关联子表的表名：tb_dish_flavor：菜品口味关系表<br>子表关联的外键名：dish_id：菜品</p>
</blockquote>
<p>→ 在代码生成 → tb_dish_flavor菜品口味关系表 → 点击编辑</p>
<blockquote>
<p>基本信息：<br>实体名：DishFalvor</p>
</blockquote>
<p>→ 生成代码(main后端 + vue前端 + dishMenu.sql数据库动态菜单) → 动态sql导入进去 → 前端vue将merchant导入到.&#x2F;src&#x2F;api中，将views导入到views中 → 在前端中将java和resources导入到merchant模块中</p>
<h4 id="对菜品管理进行升级改造"><a href="#对菜品管理进行升级改造" class="headerlink" title="对菜品管理进行升级改造"></a>对菜品管理进行升级改造</h4><h6 id="主键隐藏掉-售价前缀￥-修改时间时分秒"><a href="#主键隐藏掉-售价前缀￥-修改时间时分秒" class="headerlink" title="主键隐藏掉 售价前缀￥ 修改时间时分秒"></a>主键隐藏掉 售价前缀￥ 修改时间时分秒</h6><pre><code class="java">src\views\merchant\dish\index.vue 
把  &lt;el-table-column label=&quot;主键&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;  打注释符
////////////////////////////////////////////////////////////////////////////
插入￥流程：
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot; /&gt; 修改为 →
&lt;el-table-column label=&quot;售价&quot; align=&quot;center&quot; prop=&quot;price&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;div&gt;
            ￥&#123;&#123; scope.row.price &#125;&#125;
          &lt;/div&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
通义灵码操作：
先解析那行代码，然后输入使用vue3语法在售价前显示￥
////////////////////////////////////////////////////////////////////////////
生成年月日时分秒：
&lt;el-table-column label=&quot;更新时间&quot; align=&quot;center&quot; prop=&quot;updateTime&quot; width=&quot;180&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;span&gt;&#123;&#123; parseTime(scope.row.updateTime, '&#123;y&#125;-&#123;m&#125;-&#123;d&#125;') &#125;&#125;&lt;/span&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
修改为：

</code></pre>
<h6 id="修改图片回显bug"><a href="#修改图片回显bug" class="headerlink" title="修改图片回显bug"></a>修改图片回显bug</h6><blockquote>
<p>新增毛血旺的图片若依默认保存在了本地服务器而不是阿里云上<br><code>/profile/upload/2024/11/10/毛血旺_20241110093243A001.jpg</code></p>
<p>C:\Users\Pluminary\Desktop\20241108150415\sky\sky-admin\src\main\resources\application.yml</p>
<pre><code class="yaml"># 项目相关配置
ruoyi:
  # 名称
  name: RuoYi
  # 版本
  version: 3.8.8
  # 版权年份
  copyrightYear: 2024
  # 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）
  profile: D:/ruoyi/uploadPath
  # 获取ip地址开关
  addressEnabled: false
  # 验证码类型 math 数字计算 char 字符验证
  captchaType: math
</code></pre>
<p><code>D:\ruoyi\uploadPath\upload\2024\11\10</code><br>文件上传组件标签修改 增加<code>&amp;&amp; item.indexOf(&quot;http&quot;) === -1</code></p>
<pre><code class="js">watch(() =&gt; props.modelValue, val =&gt; &#123;
  if (val) &#123;
    // 首先将值转为数组
    const list = Array.isArray(val) ? val : props.modelValue.split(&quot;,&quot;);
    // 然后将数组转为对象数组
    fileList.value = list.map(item =&gt; &#123;
      if (typeof item === &quot;string&quot;) &#123;
        if (item.indexOf(baseUrl) === -1 &amp;&amp; item.indexOf(&quot;http&quot;) === -1) &#123;
          item = &#123; name: baseUrl + item, url: baseUrl + item &#125;;
        &#125; else &#123;
          item = &#123; name: item, url: item &#125;;
        &#125;
      &#125;
      return item;
    &#125;);
  &#125; else &#123;
    fileList.value = [];
    return [];
  &#125;
&#125;,&#123; deep: true, immediate: true &#125;);
</code></pre>
</blockquote>
<h6 id="修改口味列表数组格式-改为下拉框的口味搭配"><a href="#修改口味列表数组格式-改为下拉框的口味搭配" class="headerlink" title="修改口味列表数组格式 改为下拉框的口味搭配"></a>修改口味列表数组格式 改为下拉框的口味搭配</h6><pre><code class="js">src\views\merchant\dish\index.vue
//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);
//------------------------------------------------
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue
&lt;template #default=&quot;scope&quot;&gt;
      &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
           &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
            &lt;/el-select&gt;
           &lt;/template&gt;
       &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">src\views\merchant\dish\index.vue【修改当选中辣度时候 后面的规格】
// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 清空当前行的value
  row.value = [];
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">//增加了一个 @change   注意：如果是多选框一定要 → multiple

&lt;el-table-column label=&quot;口味名称&quot; prop=&quot;name&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.name&quot; placeholder=&quot;请输入口味名称&quot; /&gt; --&gt;
               &lt;!-- label是最终看到下拉框的内容 value是用户提交的内容 --&gt;
               &lt;el-select v-model=&quot;scope.row.name&quot;  placeholder=&quot;请选择口味名称&quot;
               @change=&quot;changeFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;dishFlavor in dishFlavorListSelect&quot;
                  :key=&quot;dishFlavor.name&quot;
                  :label=&quot;dishFlavor.name&quot; 
                  :value=&quot;dishFlavor.name&quot;
                &gt;
                &lt;/el-option&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
          &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
          &lt;/el-select&gt;
          &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<pre><code class="js">//------------------------------------------------
// 定义口味名称和口味列表静态数据
const dishFlavorListSelect = ref([
  &#123;name:&quot;辣度&quot;, value:[&quot;不辣&quot;,&quot;微辣&quot;,&quot;中辣&quot;,&quot;重辣&quot;]&#125;,
  &#123;name:&quot;忌口&quot;, value:[&quot;不要葱&quot;,&quot;不要蒜&quot;,&quot;不要香菜&quot;,&quot;不要辣&quot;]&#125;,
  &#123;name:&quot;甜味&quot;, value:[&quot;无糖&quot;,&quot;少糖&quot;,&quot;半糖&quot;]&#125;
]);


// 存储当前选中口味列表数组
const checkValueList = ref([]);
// 定义改变口味名称时更新当前选中的口味列表
function changeFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value =       dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
//------------------------------------------------
</code></pre>
<pre><code class="java">// 此时报错了 
11:59:00.441 [http-nio-8080-exec-64] ERROR c.s.f.w.e.GlobalExceptionHandler - [handleRuntimeException,100] - 请求地址&#39;/merchant/dish&#39;,发生未知异常.
org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`); nested exception is com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `java.lang.String` from Array value (token `JsonToken.START_ARRAY`)
 at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 1, column: 239] (through reference chain: com.sky.system.domain.Dish[&quot;dishFlavorList&quot;]-&gt;java.util.ArrayList[0]-&gt;com.sky.system.domain.DishFlavor[&quot;value&quot;])
    
/*
根据错误日志，问题出在请求地址 /merchant/dish 处理过程中，JSON 解析时出现了类型不匹配的问题。具体来说，Dish 对象中的 dishFlavorList 字段下的 DishFlavor 对象的 value 字段期望接收一个 String 类型的值，但实际接收到的是一个数组。
*/
</code></pre>
<h6 id="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"><a href="#解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串" class="headerlink" title="解决序列化问题bug将口味列表中value通过JSON工具类转换为字符串"></a>解决序列化问题bug<del>将口味列表中value通过JSON工具类转换为字符串</del></h6><p>提交数据后是字符串 而不是数组</p>
<pre><code class="js">在331行
/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
</code></pre>
<h6 id="解决后端添加成功后-修改后口味列表无法回显再增加个非空判断"><a href="#解决后端添加成功后-修改后口味列表无法回显再增加个非空判断" class="headerlink" title="解决后端添加成功后 修改后口味列表无法回显再增加个非空判断"></a>解决后端添加成功后 修改后口味列表无法回显<del>再增加个非空判断</del></h6><p>因为前端提交了字符串給后端，后端再回去修改的时候无法解析字符串 <code>拿到字符串后返回JSON数组即可</code></p>
<pre><code class="js">/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getDish(_id).then(response =&gt; &#123;
    form.value = response.data;
    dishFlavorList.value = response.data.dishFlavorList;
    // 将口味列表的value字符串转成json数组
    if(dishFlavorList.value!=null)&#123;
      form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.parse(item.value))
    &#125;
    open.value = true;
    title.value = &quot;修改菜品管理&quot;;
  &#125;);
&#125;

/** 提交按钮 */
function submitForm() &#123;
  proxy.$refs[&quot;dishRef&quot;].validate(valid =&gt; &#123;
    if (valid) &#123;
      form.value.dishFlavorList = dishFlavorList.value;
      // 将口味列表中value通过JSON工具类转换为字符串
      if(form.value.dishFlavorList!=null)&#123;
        form.value.dishFlavorList.forEach(item=&gt;item.value = JSON.stringify(item.value))
      &#125;
      if (form.value.id != null) &#123;
        updateDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;修改成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125; else &#123;
        addDish(form.value).then(response =&gt; &#123;
          proxy.$modal.msgSuccess(&quot;新增成功&quot;);
          open.value = false;
          getList();
        &#125;);
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<h6 id="解决修改时无法修改口味列表的下拉框"><a href="#解决修改时无法修改口味列表的下拉框" class="headerlink" title="解决修改时无法修改口味列表的下拉框"></a>解决修改时无法修改口味列表的下拉框</h6><blockquote>
<p>給口味下拉框绑定一个获取焦点事件 再该事件内调用方法根据当前行的口味名称去查询静态数据 再赋值給静态数组</p>
</blockquote>
<pre><code class="js">// 删除清除策略
// 定义口味列表获取焦点时更新当前选中的口味列表
function FocusFlavorName(row)&#123;
  // 根据选中的name去查找静态数据的value
  checkValueList.value = dishFlavorListSelect.value.find(item=&gt;item.name==row.name).value;
&#125;
</code></pre>
<pre><code class="js">// 加个 @focus
&lt;el-table-column label=&quot;口味列表&quot; prop=&quot;value&quot; width=&quot;150&quot;&gt;
            &lt;template #default=&quot;scope&quot;&gt;
              &lt;!-- &lt;el-input v-model=&quot;scope.row.value&quot; placeholder=&quot;请输入口味列表&quot; /&gt; --&gt;
              &lt;el-select v-model=&quot;scope.row.value&quot;  placeholder=&quot;请选择口味列表&quot; multiple
              @focus = &quot;FocusFlavorName(scope.row)&quot;&gt;
                &lt;el-option
                  v-for=&quot;value in checkValueList&quot;
                  :key=&quot;value&quot;
                  :label=&quot;value&quot; 
                  :value=&quot;value&quot;
                /&gt;
               &lt;/el-select&gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
</code></pre>
<h3 id="二次开发——页面调整"><a href="#二次开发——页面调整" class="headerlink" title="二次开发——页面调整"></a>二次开发——页面调整</h3><h6 id="将原有的页面，调整为外卖管理系统的项目标识"><a href="#将原有的页面，调整为外卖管理系统的项目标识" class="headerlink" title="将原有的页面，调整为外卖管理系统的项目标识"></a>将原有的页面，调整为外卖管理系统的项目标识</h6><ul>
<li>浏览器标签页icon、标题</li>
<li>系统页面中的logo、标题</li>
<li>去除源码 &amp; 文档 </li>
<li>主题和自定义图标</li>
<li>登录页面中标题、背景图</li>
</ul>
<blockquote>
<p><strong>icon</strong>：public中的favicon.ico 改为 favicon.ico.bak 就作废了<br>把新的图标复制进来改成favicon.ico</p>
<p><strong>标题</strong>：最外层index.html<br>&lt; title&gt; 外卖管理系统 &lt; &#x2F;title&gt;<br>但是改完没有效果 是因为运行环境給覆盖了<br><code>.env.development</code>修改一下</p>
<p><strong>logo</strong>放在了静态资源页面<br>src\assets\logo\logo.png</p>
<p><strong>修改顶部源码和文档图标内容</strong><br>src\layout\components\Navbar.vue</p>
<pre><code class="js">&lt;!-- &lt;el-tooltip content=&quot;源码地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-git id=&quot;ruoyi-git&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt;

        &lt;el-tooltip content=&quot;文档地址&quot; effect=&quot;dark&quot; placement=&quot;bottom&quot;&gt;
          &lt;ruo-yi-doc id=&quot;ruoyi-doc&quot; class=&quot;right-menu-item hover-effect&quot; /&gt;
        &lt;/el-tooltip&gt; --&gt;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a><br>下载一个<strong>菜品管理的小图标</strong><br>然后给它复制进去src\assets\icons\svg\菜品管理.svg<br>随后回到菜单管理修改图标就好</p>
<p><strong>登录界面图片修改：</strong><br>src\views\login.vue 修改一下标题<br>背景图 → src\assets\images\login-background1.jpg<br>通过css样式修改背景图<br>171行<br> <code>background-image: url(&quot;../assets/images/login-background.jpg&quot;);</code><br>修改为<br><code> background-image: url(&quot;../assets/images/login-background1.jpg&quot;);</code></p>
<pre><code class="css">.login &#123;
  display: flex;
  justify-content: right;
  align-items: center;
  height: 100%;
  background-image: url(&quot;../assets/images/login-background1.jpg&quot;);
  background-size: cover;
&#125;
</code></pre>
</blockquote>
<h6 id="給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能"><a href="#給外卖商家的员工创建角色和用户分配菜单的权限-登录后只能看到自己的功能" class="headerlink" title="給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能"></a>給外卖商家的员工创建角色和用户分配菜单的权限 登录后只能看到自己的功能</h6><blockquote>
<p>系统管理 → 角色管理 →  新增 →<br>角色名称：商家员工<br>权限字符串：merchant<br>角色顺序：4<br>菜单权限：父子联动<br>√ 菜品管理</p>
<p>再到用户管理 → 新增 → 添加用户 →<br>用户昵称：波妞<br>用户名称：boniu<br>用户密码：admin123<br>角色：商家员工</p>
</blockquote>
<h1 id="帝可得"><a href="#帝可得" class="headerlink" title="帝可得"></a>帝可得</h1><ul>
<li><p>帝可得是一个基于<strong>物联网</strong>概念下的<strong>智能售货机</strong>运营管理系统</p>
<ul>
<li><p><strong>物联网</strong>(IOT)</p>
<p>让各种物品通过互联网链接起来，实现信息的交换和通信</p>
<ul>
<li>智能家居</li>
<li>共享充电桩</li>
<li>智能售货机</li>
</ul>
</li>
<li><p><strong>智能售货机</strong></p>
<p>是物联网技术的一个典型应用</p>
<ul>
<li>物联网技术</li>
<li>智能分析与推荐</li>
<li>人员设备绑定管理</li>
<li>线上线下融合</li>
</ul>
</li>
</ul>
</li>
<li><h6 id="售货机术语"><a href="#售货机术语" class="headerlink" title="售货机术语"></a>售货机术语</h6><ul>
<li><p><strong>区域管理</strong></p>
<p>为了更高效地进行经营管理，公司将运营范围划分为若干个逻辑区域</p>
</li>
<li><p><strong>点位选择</strong></p>
<p>点位指的是智能售货机的具体放置位置</p>
</li>
<li><p><strong>售货机功能</strong></p>
<p>自动小店，摆满了各种零食</p>
</li>
<li><p><strong>货道设计</strong></p>
<p>售货机里的货道</p>
</li>
</ul>
</li>
</ul>
<h3 id="角色与功能"><a href="#角色与功能" class="headerlink" title="角色与功能"></a>角色与功能</h3><ul>
<li>一个完整的售货机系统由**<u>五端五角色</u>**组成:</li>
<li><strong>管理员</strong>：对基础数据(区域、点位、设备、货道、商品等)进行管理</li>
<li><strong>运维人员</strong>：投放设备、撤除设备、维修设备。</li>
<li><strong>运营人员</strong>：补货。</li>
<li><strong>合作商</strong>：仅提供点位，坐收渔翁之利。</li>
<li><strong>消费者</strong>：在小程序或屏幕端下单购买商品。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ksg50j5gph.feishu.cn/docx/NxIqdCZVzo2tRfxNL6Nc1BD1nnf">帝可得在线功能文档_Docs</a></p>
<p>帝可得项目点击链接立即查看 <a target="_blank" rel="noopener" href="https://codesign.qq.com/s/426304924036117">https://codesign.qq.com/s/426304924036117</a></p>
<h3 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h3><ul>
<li>系统后台基础数据表关系说明：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e677e01fa90ed813fd68cab1fabdde7b958ec9df/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%85%B3%E7%B3%BB%E8%AF%B4%E6%98%8E.png"></p>
<h3 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h3><ul>
<li><p><strong>AI</strong> (Artificial Intelligence)：即<strong>人工智能</strong>，是指通过计算机系统模拟人类<strong>思维</strong>和<strong>行为</strong>一种技术</p>
</li>
<li><p>它通过机器学习、深度学习等算法，使计算机具备对数据分析、理解、推理和决策的能力</p>
</li>
<li><p><strong>AIGC</strong> (AI Generated content)：是AI领域的一个应用分支，专注于利用AI技术自动生成内容</p>
</li>
<li><p>国内常见的通用大模型(AGI)产品：</p>
<ul>
<li>文心一言</li>
<li>讯飞星火</li>
<li>通义千问</li>
<li>KIMI</li>
</ul>
</li>
</ul>
<h3 id="Prompt的组成"><a href="#Prompt的组成" class="headerlink" title="Prompt的组成"></a>Prompt的组成</h3><ul>
<li><strong>角色</strong>：给 AI 定义一个最匹配任务的角色，比如：「你是一位软件工程师」「你是一位小学老师」</li>
<li><strong>指示</strong>：对任务进行描述</li>
<li><strong>上下文</strong>：给出与任务相关的其它背景信息（尤其在多轮交互中）</li>
<li><strong>例子</strong>：必要时给出举例，[实践证明其对输出正确性有帮助]</li>
<li><strong>输入</strong>：任务的输入信息；在提示词中明确的标识出输入</li>
<li><strong>输出</strong>：输出的格式描述，以便后继模块自动解析模型的输出结果，比如（JSON、Java）</li>
</ul>
<blockquote>
<p>先定义角色，其实就是在<strong>开头把问题域收窄</strong>，减少二义性。</p>
</blockquote>
<p><strong>案例：</strong></p>
<pre><code class="markdown">角色：你是一位专业的博客作者。

指示：撰写一篇关于最新AI技术发展的文章。

上下文：文章应该涵盖AI技术的当前状态和未来趋势。

例子：可以引用最近的AI技术突破和行业专家的见解。

输入：当前AI技术的相关信息和数据。

输出：一篇结构清晰、观点鲜明的文章草稿。
</code></pre>
<pre><code class="markdown">角色：你是一位资深的Java开发工程师。

指示：编写一个Java函数，该函数接收两个整数参数，并返回它们的和。

上下文：这个函数将被用于一个简单的数学应用程序，该程序帮助学生练习基本的算术运算。

例子：如果你调用函数 `addNumbers(3, 5)`，它应该返回 `8`。

输入：两个整数参数，分别为 `int a` 和 `int b`。

输出：返回这两个整数的和，类型为 `int`。
</code></pre>
<h3 id="常见的编程相关的Prompt"><a href="#常见的编程相关的Prompt" class="headerlink" title="常见的编程相关的Prompt"></a>常见的编程相关的Prompt</h3><h4 id="表结构-1"><a href="#表结构-1" class="headerlink" title="表结构"></a>表结构</h4><pre><code class="markdown">你是一个软件工程师，帮我生成MySQL的表结构
需求如下：
    1，课程管理表，表名tb_course，字段有主键id、课程编码、课程学科、课程名称、课程价格、适用人群、课程介绍
其他要求：
    1，每个表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
    2，每个表的主键都是自增的
    3，课程价格是整型、课程编码是字符串
    4，请为每个字段都添加上comment
    5，帮我给生成的表中插入一些IT课程示例数据
        课程学科：Java、人工智能、大数据
        适用人群：小白学员、中级程序员
</code></pre>
<h4 id="生成数据库说明文档"><a href="#生成数据库说明文档" class="headerlink" title="生成数据库说明文档"></a>生成数据库说明文档</h4><pre><code class="markdown">你是一个软件工程师，现在要根据数据库的sql脚本，编写数据库说明文档，sql脚本如下：
CREATE TABLE `tb_course` (
    `id` INT AUTO_INCREMENT COMMENT &#39;主键ID&#39;,
    `course_code` VARCHAR(255) NOT NULL COMMENT &#39;课程编码&#39;,
    `course_subject` VARCHAR(100) NOT NULL COMMENT &#39;课程学科&#39;,
    `course_name` VARCHAR(255) NOT NULL COMMENT &#39;课程名称&#39;,
    `course_price` INT COMMENT &#39;课程价格&#39;,
    `target_audience` VARCHAR(100) COMMENT &#39;适用人群&#39;,
    `course_introduction` TEXT COMMENT &#39;课程介绍&#39;,
    `create_time` DATETIME COMMENT &#39;创建时间&#39;,
    `update_time` DATETIME COMMENT &#39;修改时间&#39;,
    `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
    `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
    `remark` VARCHAR(255) COMMENT &#39;备注&#39;,
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;课程管理表&#39;;

输出要求是：
    1，每个表以及每个表的字段都要详细说明，包括，字段名称、类型、作用
    2，使用markdown的输出格式，字段的描述需要使用表格展示
    3，如果表之间有关系，需要描述清楚表之间的关系
</code></pre>
<h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p>代码生成算是比较常规的方案，用的也比较多，分为了几种情况</p>
<ul>
<li>给出表生成代码（项目中常见）<ul>
<li>给出表结构的ddl，可以输出这个表的增删改查的所有代码</li>
<li>给出表结构的dll，可以输出增删改查的接口文档</li>
</ul>
</li>
<li>补全代码<ul>
<li>例1-给出实体类，帮助编写getter、setter、toString、构造方法等等</li>
<li>例2-给出一个controller，帮助编写swagger注解等</li>
</ul>
</li>
<li>提取结构（无含金量，费时间的编程）<ul>
<li>例1-根据接口文档提取dto类或者vo类</li>
</ul>
</li>
</ul>
<h4 id="生成代码流程图"><a href="#生成代码流程图" class="headerlink" title="生成代码流程图"></a>生成代码流程图</h4><p>有一些比较复杂的业务流程，往往需要画出流程图，现在就可以使用ai协助我们画流程图</p>
<pre><code class="java">你是一个软件工程师，为了方便理解代码执行流程，需要给出代码执行的流程图，代码如下：
    // 创建工单
    @Transactional
    @Override
    public int insertTaskDto(TaskDto taskDto) &#123;
    //1. 查询售货机是否存在
    VendingMachine vm = vendingMachineService.selectVendingMachineByInnerCode(taskDto.getInnerCode());
    if (vm == null) &#123;
        throw new ServiceException(&quot;设备不存在&quot;);
    &#125;
    //2. 校验售货机状态与工单类型是否相符
    checkCreateTask(vm.getVmStatus(), taskDto.getProductTypeId());
    //3. 校验这台设备是否有未完成的同类型工单，如果存在则不能创建
    hasTask(taskDto.getInnerCode(), taskDto.getProductTypeId());
    //4. 校验员工是否存在
    Emp emp = empService.selectEmpById(taskDto.getUserId());
    if (emp == null) &#123;
        throw new ServiceException(&quot;员工不存在&quot;);
    &#125;
    // 5. 校验非同区域下的工作人员不能接受工单
    if (emp.getRegionId() != vm.getRegionId()) &#123;
        throw new ServiceException(&quot;非同区域下的工作人员不能接受工单&quot;);
    &#125;
    //6. 保存工单信息
    Task task = new Task();
    BeanUtil.copyProperties(taskDto, task);// 属性赋值
    task.setCreateTime(DateUtils.getNowDate());// 创建时间
    task.setTaskCode(generateTaskCode());// 工单编号 202405150001
    task.setTaskStatus(DkdContants.TASK_STATUS_CREATE);// 创建工单
    task.setAddr(vm.getAddr());
    task.setRegionId(vm.getRegionId());
    task.setUserName(emp.getUserName());
    int taskResult = taskMapper.insertTask(task);
    //7. 如果是补货工单，向工单明细表插入记录
    if (task.getProductTypeId() == DkdContants.TASK_TYPE_SUPPLY) &#123;
        if (CollUtil.isEmpty(taskDto.getDetails())) &#123;
            throw new ServiceException(&quot;补货工单明细不能为空&quot;);
        &#125;
        List&lt;TaskDetails&gt; taskDetailsList = taskDto.getDetails().stream().map(details -&gt; &#123;
            TaskDetails taskDetails = BeanUtil.copyProperties(details, TaskDetails.class);
            taskDetails.setTaskId(task.getTaskId());
            return taskDetails;
        &#125;).collect(Collectors.toList());
        taskDetailsService.insertBatch(taskDetailsList);
    &#125;

    return taskResult;
&#125;

输出：请使用mermaid语言来描述这个方法的流程
</code></pre>
<pre><code class="mermaid">graph TD;
    A[查询售货机] --&gt; B(售货机不存在?)
    B -- 是 --&gt; C[抛出异常: 设备不存在]
    B -- 否 --&gt; D[校验售货机状态与工单类型]
    D --&gt; E(校验失败?)
    E -- 是 --&gt; F[抛出异常]
    E -- 否 --&gt; G[检查未完成同类型工单]
    G --&gt; H(存在未完成同类型工单?)
    H -- 是 --&gt; I[抛出异常]
    H -- 否 --&gt; J[查询员工]
    J --&gt; K(员工不存在?)
    K -- 是 --&gt; L[抛出异常: 员工不存在]
    K -- 否 --&gt; M[校验员工区域与售货机区域是否一致]
    M --&gt; N(不一致?)
    N -- 是 --&gt; O[抛出异常: 非同区域工作人员不能接受工单]
    N -- 否 --&gt; P[保存工单信息]
    P --&gt; Q(保存成功?)
    Q -- 否 --&gt; R[处理保存失败]
    Q -- 是 --&gt; S(工单类型为补货?)
    S -- 是 --&gt; T[处理补货工单明细]
    T --&gt; U[补货明细处理结果?]
    U -- 失败 --&gt; V[抛出异常: 补货工单明细不能为空]
    U -- 成功 --&gt; END(结束)
    S -- 否 --&gt; END
</code></pre>
<h3 id="项目搭建-后端"><a href="#项目搭建-后端" class="headerlink" title="项目搭建(后端)"></a>项目搭建(后端)</h3><blockquote>
<p>复制gitee克隆的地址<code>https://gitee.com/Pluminary/dkd-parent.git</code>，在新的idea中找到<code>Get from Version Control</code>在URL中导入<code>xxx.git</code><br>若左列模块没有高亮 右侧找maven→clean→package<br>MySQL的配置和导入 → sql里的sql文件导入到Database<br>C:\Users\Pluminary\Desktop\dkd-parent\dkd-admin\src\main\resources\application-druid.yml<br>连接好数据库配置信息<br>Redis的配置(搞个密码)<br>为了方便学习我没有搞redis的password 项目里的是：root【application.yml的redis里面】<br>打开redis服务后就可以启动啦<code>dkd-parent\dkd-admin\src\main\java\com\dkd\DkdApplication.java</code></p>
</blockquote>
<h3 id="项目搭建-前端"><a href="#项目搭建-前端" class="headerlink" title="项目搭建(前端)"></a>项目搭建(前端)</h3><blockquote>
<p>通过vscode克隆源码，仓库地址：<a target="_blank" rel="noopener" href="https://gitee.com/ys-gitee/dkd-vue.git/">https://gitee.com/ys-gitee/dkd-vue.git\</a></p>
<ul>
<li>打开VS Code，并确保已经安装了Git。如果未安装Git，请先下载并安装。</li>
<li>在VS Code<strong>左侧的活动栏</strong>中点击”Source Control”图标，或者按下Ctrl+Shift+G，打开Git集成面板。</li>
<li>在Git集成面板上方的输入框中，选择并输入要克隆的Git仓库地址。可以是HTTP或SSH地址。</li>
<li>点击Enter键，VS Code将连接到Git仓库并拉取最新的代码</li>
</ul>
<p>在vscode中右上角第二个小框框 点击打开命令行 导入jar包 <code>npm install</code><br>然后<code>npm run dev</code>打开项目<br><a target="_blank" rel="noopener" href="http://10.254.1.228/index">帝可得管理系统 http://10.254.1.228/index</a></p>
<pre><code class="java">在VSCode项目中运行npm install命令主要是用于安装项目所需的Node.js包依赖。以下是具体的作用和步骤：

安装依赖包：当你创建一个Node.js项目或者从版本控制系统中克隆一个项目到本地时，项目中通常会包含一个package.json文件。这个文件里列出了项目所有依赖的包及其版本号。运行npm install命令会读取这个文件，然后从npm（Node Package Manager）仓库下载并安装所有列出的依赖包到项目的node_modules目录。

确保环境一致性：通过npm install，可以确保在不同的开发环境和生产环境中，项目使用的是相同版本的依赖包，这有助于避免因为环境差异导致的bug。

项目初始化：如果你是第一次在一个项目中运行npm install，它还会运行每个依赖包的install脚本，这些脚本可能会进行一些设置工作，比如编译代码、生成必要的文件等。

脚本命令：在package.json中，除了依赖项，还可以定义一些脚本命令（scripts）。npm install会使得这些命令变为可用状态，你可以在项目目录下通过npm run &lt;script-name&gt;来执行这些脚本。
</code></pre>
<p>[npm 加速，命令行修改国内镜像源【附带国内最新几个镜像】超简约版<del>_npm 修改国内镜像-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52172586/article/details/142930356#">https://blog.csdn.net/m0_52172586/article/details/142930356#</a>:</del>:text&#x3D;1.查看目前的镜像源 &gt;npm get registry 2.设置镜像源 &gt;npm,config set registry https%3A %2F%2Fregistry.npmmirror.com 3.验证)</p>
<pre><code class="java">1.查看目前的镜像源
&gt; npm get registry
2.设置镜像源
&gt; npm config set registry https://registry.npmmirror.com
3.验证
&gt; npm get registry
    
/////////////////////////////////////////
后端maven镜像就先设置好maven地址(非C盘)
然后再去配置maven里的文件设置镜像
</code></pre>
</blockquote>
<h1 id="点位管理"><a href="#点位管理" class="headerlink" title="点位管理"></a>点位管理</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p><strong>业务场景</strong>： 假设我们的公司现在有一个宏伟的计划——在北京发展业务。首先，我们需要确定几个有潜力的区域，这些区域可能是人流量大、消费能力高的商业区或居民区。然后，我们要与这些区域内的潜在合作商进行洽谈，比如商场、写字楼、学校等地方的管理者或所有者。</p>
<p>一旦我们与合作商达成协议，确定了合作的细节和点位，我们就可以安排工作人员去投放智能售货机了。这些点位将成为我们智能售货机的“家”，为消费者提供便捷的购买服务。</p>
<p>点位管理主要涉及到三个功能模块，业务流程如下：</p>
<ol>
<li><strong>登录系统</strong>：后台管理人员登录后台系统</li>
<li><strong>新增区域</strong>: 后台管理人员可以添加区域范围，区域范围与运维&#x2F;运维人员挂钩，区域下可关联点位。</li>
<li><strong>新增合作商</strong>: 管理人员可以添加合作商，合作商与点位进行关联。</li>
<li><strong>新增区域点位</strong>: 后台管理人员可以在特定区域内新增点位，这些点位是放置智能售货机的具体位置。</li>
</ol>
<pre><code class="mermaid">graph TD
    A[登录系统] 
    A --&gt; B[新增区域]
    B --&gt; C[新增合作商]
    C --&gt; D[新增区域点位]
</code></pre>
<h2 id="库表设计-1"><a href="#库表设计-1" class="headerlink" title="库表设计"></a>库表设计</h2><ul>
<li>参考页面原型和具体需求完成库表设计</li>
</ul>
<blockquote>
<p><strong>区域表</strong>: 主键id、区域名称、备注说明<br><strong>合作商表</strong>: 主键id、合作商名称、联系人、联系电话、分成比例、账号、密码<br><strong>点位表</strong>: 主键id、点位名称、详细地址、商圈类型、区域外键、合作商外键</p>
</blockquote>
<pre><code class="java">// 你是一位软件工程师，帮我生成MySQL的表结构
需求如下：
1，区域表，表名tb_region，字段有主键id、区域名称
2，合作商表，表名tb_partner，字段有主键id、合作商名称、联系人、联系电话、分成比例（int类型）、账号、密码
3，点位表，表名tb_node，字段有主键id、点位名称、详细地址、商圈类型（int类型）
    
其他要求：
1，每张表中都有创建时间(create_time)、修改时间(date_time)、创建人(create_by)、修改人(update_by)、备注(remark)这些字段
2，每张表的主键都是自增的
3，区域与点位是一对多的关系，合作商与点位是一对多的关系，请用字段表示出来，并建立外键约束
4，请为所有字段都添加上comment
5，帮我给生成的表中插入一些北京城市相关区域、点位、合作商的测试数据
</code></pre>
<pre><code class="sql">CREATE TABLE `tb_region` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `region_name` VARCHAR(255) NOT NULL COMMENT &#39;区域名称&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;区域表&#39;;

-- 插入测试数据
INSERT INTO `tb_region` (`region_name`,`remark`) VALUES (&#39;北京市朝阳区&#39;,&#39;北京市朝阳区&#39;), (&#39;北京市海淀区&#39;,&#39;北京市海淀区&#39;), (&#39;北京市东城区&#39;,&#39;北京市东城区&#39;);

CREATE TABLE `tb_partner` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `partner_name` VARCHAR(255) NOT NULL COMMENT &#39;合作商名称&#39;,
  `contact_person` VARCHAR(64) COMMENT &#39;联系人&#39;,
  `contact_phone` VARCHAR(15) COMMENT &#39;联系电话&#39;,
  `profit_ratio` INT COMMENT &#39;分成比例&#39;,
  `account` VARCHAR(64) COMMENT &#39;账号&#39;,
  `password` VARCHAR(64) COMMENT &#39;密码&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;合作商表&#39;;

-- 插入测试数据
INSERT INTO `tb_partner` (`partner_name`, `contact_person`, `contact_phone`, `profit_ratio`, `account`, `password`) VALUES
(&#39;合作商A&#39;, &#39;张三&#39;, &#39;13800138000&#39;, 30, &#39;a001&#39;, &#39;pwdA&#39;),
(&#39;合作商B&#39;, &#39;李四&#39;, &#39;13912345678&#39;, 25, &#39;b002&#39;, &#39;pwdB&#39;);

CREATE TABLE `tb_node` (
  `id` INT AUTO_INCREMENT COMMENT &#39;主键id&#39; PRIMARY KEY,
  `node_name` VARCHAR(255) NOT NULL COMMENT &#39;点位名称&#39;,
  `address` VARCHAR(255) NOT NULL COMMENT &#39;详细地址&#39;,
  `business_type` INT COMMENT &#39;商圈类型&#39;,
  `region_id` INT COMMENT &#39;区域ID&#39;,
  `partner_id` INT COMMENT &#39;合作商ID&#39;,
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,
  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,
  `create_by` VARCHAR(64) COMMENT &#39;创建人&#39;,
  `update_by` VARCHAR(64) COMMENT &#39;修改人&#39;,
  `remark` TEXT COMMENT &#39;备注&#39;,
  FOREIGN KEY (`region_id`) REFERENCES `tb_region`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  FOREIGN KEY (`partner_id`) REFERENCES `tb_partner`(`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#39;点位表&#39;;


-- 插入测试数据
-- 假设区域ID为1对应&#39;北京市朝阳区&#39;，合作商ID为1对应&#39;合作商A&#39;
INSERT INTO `tb_node` (`node_name`, `address`, `business_type`, `region_id`, `partner_id`) VALUES
(&#39;三里屯点位&#39;, &#39;北京市朝阳区三里屯路&#39;, 1, 1, 1),
(&#39;五道口点位&#39;, &#39;北京市海淀区五道口&#39;, 2, 2, 2);
</code></pre>
<p>对于点位管理数据模型，下面是示意图：</p>
<ul>
<li><p>关系字段：region_id、partner_id</p>
</li>
<li><p>数据字典：business_type</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2aea3c59b88952c77f32514636619e7de0202c16/dkd%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1.jpg"></p>
<h3 id="生成基础代码"><a href="#生成基础代码" class="headerlink" title="生成基础代码"></a>生成基础代码</h3><h6 id="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："><a href="#使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：" class="headerlink" title="使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中："></a>使用若依代码生成器，生成区域管理、合作商管理、点位管理前后端基础代码，导入项目中：</h6><ul>
<li>创建目录菜单</li>
<li>添加数据字典</li>
<li>配置代码生成信息</li>
<li>下载代码并导入项目</li>
</ul>
<blockquote>
<p>系统管理 → 菜单管理 → 新增菜单<br>→ <u>主类目、点位管理、2、node</u></p>
<p>→ 系统管理 → 字典管理<br>→ <u>字典名称：商圈类型</u><br>     <u>字典类型：business_type</u><br>→ 在第二页找到商圈类型点进去<br>→ <u>新增：旅游区</u><br>     &lt;u<u>&gt;数据标签：旅游区</u><br>     <u>数据键值：1</u><br>     <u>显示排序：1</u><br>→ 新增：商场写字楼、2、2；学校33、交通枢纽44</p>
<p>→ 系统工具 → 代码生成 → 导入表(<u>tb_node、tb_partner、tb_region</u>)<br>分别配置表的生成信息<br>→ 点击<u><strong>区域表</strong></u> → <u>字段信息</u><br>→ 根据新增区域弹出菜单显示 需要增加<u>区域名称全打勾 备注说明除了查询全打勾 其余全×</u></p>
<p>→ 点击**<u>合作商表</u>** → 生成信息<br>→ <u>包路径：com.dkd.manage、生成模块名：manage、生成业务名：region、生成功能名：区域管理、上级菜单：点位管理</u><br>→ 代码生成：Partner<br>→  基本信息：<br><u>实体类名称：Partner</u><br><u>作者：itheima</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：合作商管理</u><br><u>上级菜单：点位管理</u></p>
<p>→ 点击**<u>点位表</u>**<br>→ 生成信息：<br><u>生成包路径：com.dkd.manage</u><br><u>生成模块名：manage</u><br><u>生成功能名：点位管理</u><br><u>上级菜单：点位管理</u><br>→ 字段信息：见**<u>帝可得后台管理系统.md</u>**<br>→ 基本信息：<br><u>实体类名称：Node</u><br><u>表描述：点位表</u><br><u>作者：itheima</u></p>
<p>回到代码生成 选中三张表 生成！！<br>分别在前后端和数据库 导入java&#x2F;manage、vue&#x2F;manage、sql代码</p>
</blockquote>
<blockquote>
<p><strong>细节</strong>：如果当你创建一个模块以后 src.main.java里面没有任何代码 resources里面也没有 它提交仓库的时候是默认空的 所以可以手动添加一个占位符<code>.gitkeep</code>虽然什么都不是，但是可以提交空项目模块</p>
</blockquote>
<h3 id="区域管理改造"><a href="#区域管理改造" class="headerlink" title="区域管理改造"></a>区域管理改造</h3><h4 id="基础页面"><a href="#基础页面" class="headerlink" title="基础页面"></a>基础页面</h4><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ul>
<li>参考页面原型，完成基础布局展示改造</li>
</ul>
<pre><code class="html">// 让前端页面自动排序
src\views\manage\region\index.vue
&lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
</code></pre>
<h5 id="区域管理改造-1"><a href="#区域管理改造-1" class="headerlink" title="区域管理改造"></a>区域管理改造</h5><ul>
<li><p>查看详情，需要显示所有区域下所有点位列表(<strong>稍后完成</strong>)</p>
</li>
<li><p><strong>在查询区域列表时，同时显示每个区域的点位数，还要新增查看详情</strong></p>
<p><span style="color:red; font-family: 'KaiTi';"><strong>修改<u>后端</u>要参考<u>接口文档</u>，修改<u>前端</u>要参考<u>产品原型</u></strong></span></p>
</li>
<li><p>实现此功能方案：</p>
<p>(1) <strong>同步存储</strong>在区域表中有点位数的字段，当点位发生变化时候，同步区域表中的点位数(<u>在tb_region里面新增一个<code>node_count</code></u> 方案可行考虑缺点：每次点位数据变化时都要更新区域表[增加了工作量]，添加数据不一致也会)<br>(2) <span style="color:red"><strong>关联查询</strong></span>编写关联查询语句，在mapper层封装</p>
</li>
</ul>
<p>SQL查询：先聚合统计每个区域的点位数，然后与区域表进行关联查询<br>[提前在idea中下面的通义灵码状态勾选 <code>本地补全模型</code>、<code>云端模型自动触发</code>]<br><span style="color:red; font-family: 'KaiTi';"><strong>数据库返回的数据 要结合前端所需要的返回数据来写</strong> </span><br><span style="color:blue; font-family: 'KaiTi';"><strong>比如接口文档需要返回remark id name nodeCount</strong> &#x3D;&#x3D;&gt; select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count</span></p>
<pre><code class="sql">-- 传统模式
-- 1.先聚合统计每个区域下的点位数
-- 确定查询表 tb_node
-- 确定分组字段 region_id
select region_id,count(*) as node_count from tb_node group by region_id;
-- 2.然后与区域表进行关联查询   内连接是两个表的交集
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count 
   from tb_region r
left join (select region_id,count(*) as node_count 
   from tb_node group by region_id) n 
on r.id=n.region_id;

-- AI辅助编程模式
-- 查询区域表所有的信息,需要显示每个区域的点位数
SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/Region.java
package com.dkd.manage.domain;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import com.dkd.common.annotation.Excel;
import com.dkd.common.core.domain.BaseEntity;

/**
 * 区域管理对象 tb_region
 * 
 * @author itheima
 * @date 2024-11-12
 */
public class Region extends BaseEntity
&#123;
    private static final long serialVersionUID = 1L;

    /** 主键id */
    private Long id;

    /** 区域名称 */
    @Excel(name = &quot;区域名称&quot;)
    private String regionName;

    public void setId(Long id) 
    &#123;
        this.id = id;
    &#125;

    public Long getId() 
    &#123;
        return id;
    &#125;
    public void setRegionName(String regionName) 
    &#123;
        this.regionName = regionName;
    &#125;

    public String getRegionName() 
    &#123;
        return regionName;
    &#125;

    @Override
    public String toString() &#123;
        return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE)
            .append(&quot;id&quot;, getId())
            .append(&quot;regionName&quot;, getRegionName())
            .append(&quot;createTime&quot;, getCreateTime())
            .append(&quot;updateTime&quot;, getUpdateTime())
            .append(&quot;createBy&quot;, getCreateBy())
            .append(&quot;updateBy&quot;, getUpdateBy())
            .append(&quot;remark&quot;, getRemark())
            .toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/domain/vo/RegionVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class RegionVo extends Region &#123;
    // 点位数量
    private Integer nodeCount;

&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/RegionMapper.java
/**
     * 查询区域列表
     * @param regionVo
     * @return
     */
    public List&lt;RegionVo&gt; selectRegionVoList(RegionVo regionVo);
</code></pre>
<pre><code class="xml">mapper/manage/RegionMapper.xml    
&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
        SELECT r.*, COUNT(n.id) AS node_count FROM tb_region r LEFT JOIN tb_node n ON r.id = n.region_id GROUP BY r.id
    &lt;/select&gt;
</code></pre>
<h6 id="思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能"><a href="#思考：上面的xml中提取的字段是-node-count-而前端让返回的是驼峰式命名-nodeCount-若依默认关闭了此功能需要手动开启此功能" class="headerlink" title="思考：上面的xml中提取的字段是 node_count 而前端让返回的是驼峰式命名 nodeCount,  若依默认关闭了此功能需要手动开启此功能"></a>思考：上面的xml中提取的字段是 <u>node_count</u> 而前端让返回的是驼峰式命名 <u>nodeCount</u>,  若依默认关闭了此功能需要手动开启此功能</h6><pre><code class="xml">dkd-parent → resources → mybatis → mybatis-config.xml
&lt;!-- 使用驼峰命名法转换字段 --&gt;
&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
</code></pre>
<h6 id="Ctrl-F9是热部署-在不新增文件的时候可以直接部署"><a href="#Ctrl-F9是热部署-在不新增文件的时候可以直接部署" class="headerlink" title="Ctrl+F9是热部署 在不新增文件的时候可以直接部署"></a>Ctrl+F9是热部署 在不新增文件的时候可以直接部署</h6><h4 id="RegionMapper"><a href="#RegionMapper" class="headerlink" title="RegionMapper"></a>RegionMapper</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionMapper-xml"><a href="#RegionMapper-xml" class="headerlink" title="RegionMapper.xml"></a>RegionMapper.xml</h4><pre><code class="xml">&lt;select id=&quot;selectRegionVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.RegionVo&quot;&gt;
select r.id,r.region_name,r.remark,ifnull(n.node_count,0) as node_count from tb_region r
    left join (select region_id,count(*) as node_count from tb_node group by region_id) n on r.id=n.region_id
    &lt;where&gt;
       &lt;if test=&quot;regionName != null  and regionName != &#39;&#39;&quot;&gt; and r.region_name like concat(&#39;%&#39;, #&#123;regionName&#125;, &#39;%&#39;)&lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt; 
</code></pre>
<h4 id="IRegionService"><a href="#IRegionService" class="headerlink" title="IRegionService"></a>IRegionService</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
public List&lt;RegionVo&gt; selectRegionVoList(Region region);
</code></pre>
<h4 id="RegionServiceImpl"><a href="#RegionServiceImpl" class="headerlink" title="RegionServiceImpl"></a>RegionServiceImpl</h4><pre><code class="java">/**
 * 查询区域管理列表
 * @param region
 * @return RegionVo集合
 */
@Override
public List&lt;RegionVo&gt; selectRegionVoList(Region region) &#123;
    return regionMapper.selectRegionVoList(region);
&#125;
</code></pre>
<h4 id="RegionController"><a href="#RegionController" class="headerlink" title="RegionController"></a>RegionController</h4><pre><code class="java">/**
 * 查询区域管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:region:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Region region)
&#123;
    startPage();
    List&lt;RegionVo&gt; voList = regionService.selectRegionVoList(region);
    return getDataTable(voList);
&#125;
</code></pre>
<h4 id="region-x2F-index-vue"><a href="#region-x2F-index-vue" class="headerlink" title="region&#x2F;index.vue"></a>region&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 区域列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;regionList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;区域名称&quot; align=&quot;center&quot; prop=&quot;regionName&quot; /&gt;
  &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
  &lt;el-table-column label=&quot;备注说明&quot; align=&quot;center&quot; prop=&quot;remark&quot; /&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><strong>区域列表改造步骤</strong><ul>
<li>确定关联查询方案并编写sql</li>
<li>创建RegionVo</li>
<li>在RegionMapper和xml中添加查询Vo方法和sql</li>
<li>在RegionService接口和实现类中添加查询Vo方法</li>
<li>修改RegionController查询方法</li>
<li>修改前端视图组件</li>
</ul>
</li>
</ul>
<h3 id="合作商改造-查看详情"><a href="#合作商改造-查看详情" class="headerlink" title="合作商改造-查看详情"></a>合作商改造-查看详情</h3><h5 id="密码是明文-改成密文"><a href="#密码是明文-改成密文" class="headerlink" title="密码是明文 改成密文"></a>密码是明文 改成密文</h5><pre><code class="html">&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
   &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui"><a href="#隐藏修改时的账号密码id存在时隐藏不存在显示-因为修改和新增共用了一个对话框ui" class="headerlink" title="隐藏修改时的账号密码id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui"></a>隐藏修改时的账号密码<del>id存在时隐藏不存在显示,因为修改和新增共用了一个对话框ui</del></h5><pre><code class="html">&lt;el-form-item label=&quot;账号&quot; prop=&quot;account&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.account&quot; placeholder=&quot;请输入账号&quot; /&gt;
&lt;/el-form-item&gt;
&lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot; v-if=&quot;form.id==null&quot;&gt;
    &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;
&lt;/el-form-item&gt;
</code></pre>
<h5 id="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"><a href="#前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间" class="headerlink" title="前端需要返回创建时间因为数据返回时有，用v-if判断是否修改显示创建时间"></a>前端需要返回创建时间<del>因为数据返回时有，用v-if判断是否修改显示创建时间</del></h5><pre><code class="html"> &lt;el-form-item label=&quot;创建时间&quot; prop=&quot;contactPhone&quot; v-if=&quot;form.id!=null&quot;&gt;
          &#123;&#123;form.createTime&#125;&#125;
        &lt;/el-form-item&gt;
</code></pre>
<h5 id="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"><a href="#新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了" class="headerlink" title="新增时保存的数据是以明文保存到了数据库此时新增的合作商就是密文了"></a>新增时保存的数据是以明文保存到了数据库<del>此时新增的合作商就是密文了</del></h5><pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java  
/**
     * 新增合作商管理
     *
     * @param partner 合作商管理
     * @return 结果
     */
    @Override
    public int insertPartner(Partner partner) &#123;
        // 使用SpringSecurity工具类，对前端传入的密码进行加密
        partner.setPassword(SecurityUtils.encryptPassword(partner.getPassword()));
        partner.setCreateTime(DateUtils.getNowDate());
        return partnerMapper.insertPartner(partner);
    &#125;
</code></pre>
<h5 id="合作商管理改造—合作商详情"><a href="#合作商管理改造—合作商详情" class="headerlink" title="合作商管理改造—合作商详情"></a>合作商管理改造—合作商详情</h5><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<pre><code class="js">/** 借鉴修改流程
/** 修改按钮操作 */
function handleUpdate(row) &#123;
  reset();
  const _id = row.id || ids.value
  getPartner(_id).then(response =&gt; &#123;
    form.value = response.data;
    open.value = true;
    title.value = &quot;修改合作商管理&quot;;
  &#125;);
&#125;
</code></pre>
<pre><code class="html">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
  &lt;template #default=&quot;scope&quot;&gt;
    &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;getPartnerInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:query&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
  &lt;/template&gt;
&lt;/el-table-column&gt;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
    /**
     * 获取合作商管理详细信息
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:query&#39;)&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public AjaxResult getInfo(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return success(partnerService.selectPartnerById(id));
    &#125;
</code></pre>
<pre><code class="js">/** 查看合作商详情 **/
  const partnerInfoOpen = ref(false)
  function getPartnerInfo(row)&#123;
    reset();
    const _id = row.id
    getPartner(_id).then(response =&gt; &#123;
      form.value = response.data;
      partnerInfoOpen.value = true;
    &#125;);
  &#125;
</code></pre>
<pre><code class="html">    &lt;!-- 查看合作商详情对话框 --&gt;
&lt;el-dialog title=&quot;合作商详情&quot; v-model=&quot;partnerInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;!-- 使用el-descriptions组件以卡片形式展示信息，更加整洁 --&gt;
    &lt;el-descriptions :column=&quot;2&quot; border&gt;
        &lt;el-descriptions-item label=&quot;合作商名称&quot;&gt;&#123;&#123; form.partnerName &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系人&quot;&gt;&#123;&#123; form.contactPerson &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;联系电话&quot;&gt;&#123;&#123; form.contactPhone &#125;&#125;&lt;/el-descriptions-item&gt;
        &lt;el-descriptions-item label=&quot;分成比例&quot;&gt;&#123;&#123; form.profitRatio &#125;&#125;%&lt;/el-descriptions-item&gt;
    &lt;/el-descriptions&gt;
&lt;/el-dialog&gt;
</code></pre>
<h3 id="合作商改造—列表查询点位管理→合作商管理→增加点位数"><a href="#合作商改造—列表查询点位管理→合作商管理→增加点位数" class="headerlink" title="合作商改造—列表查询点位管理→合作商管理→增加点位数"></a>合作商改造—列表查询<del>点位管理→合作商管理→增加点位数</del></h3><ul>
<li>实现此功能方案：</li>
</ul>
<h4 id="后端改造"><a href="#后端改造" class="headerlink" title="后端改造"></a>后端改造</h4><p><strong>关联查询</strong>编写关联查询语句，在mapper层封装</p>
<blockquote>
<p><strong>tb_node</strong>(点位表)的partner_id(合作商ID)<br><u>关联</u><br><strong>tb_partner</strong>(合作商表)的id</p>
<pre><code class="sql">-- 查询合作商表的所有信息，同时显示每个合作商的点位数
select p.*, count(n.id) as node_count
from tb_partner p
    left join tb_node n on p.id = n.partner_id
group by p.id
</code></pre>
</blockquote>
<p><strong>首先先创建一个需要查询新东西的方法<del>增加</del></strong></p>
<pre><code class="java">com/dkd/manage/domain/vo/PartnerVo.java
package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Partner;
import lombok.Data;

@Data
public class PartnerVo extends Partner &#123;
    // 点位数量
    private Integer nodeCount;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/controller/PartnerController.java
 /**
     * 查询合作商管理列表
     */
    @PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:list&#39;)&quot;)
    @GetMapping(&quot;/list&quot;)
    public TableDataInfo list(Partner partner) &#123;
        startPage();
        List&lt;PartnerVo&gt; voList = partnerService.selectPartnerVoList(partner);
        return getDataTable(voList);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/service/IPartnerService.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">com/dkd/manage/service/impl/PartnerServiceImpl.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    @Override
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner) &#123;
        return partnerMapper.selectPartnerVoList(partner);
    &#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/PartnerMapper.java
/**
     * 查询合作商列表
     * @param partner
     * @return
     */
    public List&lt;PartnerVo&gt; selectPartnerVoList(Partner partner);
</code></pre>
<pre><code class="java">mapper/manage/PartnerMapper.xml
&lt;/select&gt;
        &lt;select id=&quot;selectPartnerVoList&quot; resultType=&quot;com.dkd.manage.domain.vo.PartnerVo&quot;&gt;
        select p.*, count(n.id) as node_count
        from tb_partner p
                 left join tb_node n on p.id = n.partner_id
        &lt;where&gt;
            &lt;if test=&quot;partnerName != null  and partnerName != &#39;&#39;&quot;&gt; and partner_name like concat(&#39;%&#39;, #&#123;partnerName&#125;, &#39;%&#39;)&lt;/if&gt;
        &lt;/where&gt;
        group by p.id
    &lt;/select&gt;
</code></pre>
<h4 id="前端改造"><a href="#前端改造" class="headerlink" title="前端改造"></a>前端改造</h4><pre><code class="html">&lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
      &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
      &lt;el-table-column label=&quot;合作商名称&quot; align=&quot;center&quot; prop=&quot;partnerName&quot; /&gt;
      &lt;el-table-column label=&quot;点位数&quot; align=&quot;center&quot; prop=&quot;nodeCount&quot; /&gt;
      &lt;el-table-column label=&quot;账号&quot; align=&quot;center&quot; prop=&quot;account&quot; /&gt;
      &lt;el-table-column label=&quot;分成比例&quot; align=&quot;center&quot; prop=&quot;profitRatio&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &#123;&#123; scope.row.profitRatio + '%' &#125;&#125;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column label=&quot;联系人&quot; align=&quot;center&quot; prop=&quot;contactPerson&quot; /&gt;
      &lt;el-table-column label=&quot;联系电话&quot; align=&quot;center&quot; prop=&quot;contactPhone&quot; /&gt;
      &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
</code></pre>
<h3 id="合作商改造——重置密码"><a href="#合作商改造——重置密码" class="headerlink" title="合作商改造——重置密码"></a>合作商改造——重置密码</h3><ul>
<li>查看详情，需要显示合作商名称、联系人、联系电话、分成比例</li>
<li>在查询合作商列表时，同时显示每个合作商的点位数</li>
<li>重置密码，初始密码为123456</li>
</ul>
<h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>在PartnerController中</p>
<pre><code class="java">/**
 * 重置合作商密码
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:partner:edit&#39;)&quot;)
@Log(title = &quot;重置合作商密码&quot;, businessType = BusinessType.UPDATE)
@PutMapping(&quot;/resetPwd/&#123;id&#125;&quot;)
public AjaxResult resetpwd(@PathVariable Long id) &#123;//1. 接收参数
    //2. 创建合作商对象
    Partner partner = new Partner();
    partner.setId(id);// 设置id
    partner.setPassword(SecurityUtils.encryptPassword(&quot;123456&quot;));// 设置加密后的初始密码
    //3. 调用service更新密码
    return toAjax(partnerService.updatePartner(partner));
&#125;
</code></pre>
<h4 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h4><p>在<code>manage/partner.js</code>请求api中</p>
<pre><code class="js">// 重置合作商密码
export function resetPartnerPwd(id)&#123;
  return request(&#123;
    url: &#39;/manage/partner/resetPwd/&#39; + id,
    method: &#39;put&#39;
  &#125;)
&#125;
</code></pre>
<p>在<code>partner/index.vue</code>视图组件中<del>参考@click&#x3D;”handleDelete”，此方法删除时弹出对话框</del></p>
<pre><code class="vue">&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot; width=&quot;300px&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
        &lt;el-button link type=&quot;primary&quot; @click=&quot;resetPwd(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:partner:edit&#39;]&quot;&gt;重置密码&lt;/el-button&gt;
    &lt;/template&gt;
&lt;/el-table-column&gt;

&lt;script&gt;
    import &#123; listPartner, getPartner, delPartner, addPartner, updatePartner,resetPartnerPwd &#125; from &quot;@/api/manage/partner&quot;;
    /* 重置合作商密码 */
    function resetPwd(row) &#123;
        proxy.$modal.confirm(&#39;你确定要重置该合作商密码吗？&#39;).then(function () &#123;
            return resetPartnerPwd(row.id);
        &#125;).then(() =&gt; &#123;
            proxy.$modal.msgSuccess(&quot;重置成功&quot;);
        &#125;).catch(() =&gt; &#123; &#125;);
    &#125;
&lt;/script&gt;
</code></pre>
<h3 id="点位管理改造——基础布局"><a href="#点位管理改造——基础布局" class="headerlink" title="点位管理改造——基础布局"></a>点位管理改造——基础布局</h3><p>修改前端更简单一些 可以把前端一次性请求1w条数据 后端接口就可以重复调用</p>
<p>在<code>src\views\manage\node\index.vue</code>视图组件中</p>
<pre><code class="js">import &#123;listRegion&#125; from &quot;@/api/manage/region&quot;;

/* 查询所有条件对象 */
const loadAllParams=reactive(&#123;
  pageNum:1,
  pageSize:10000
&#125;)
/** 查询区域列表 **/
const regionList=ref([]);
function getRegionList() &#123;
  listRegion(loadAllParams).then(response=&gt;&#123;
    regionList.value=response.rows;
  &#125;)
&#125;
getRegionList();
getList();
</code></pre>
<p>在<code>src\api\manage\region.js</code>中</p>
<pre><code class="js">// 查询区域管理列表
export function listRegion(query) &#123;
  return request(&#123;
    url: &#39;/manage/region/list&#39;,
    method: &#39;get&#39;,
    params: query
  &#125;)
&#125;
</code></pre>
<h6 id="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"><a href="#新增点位管理的时候想把合作商输入的改成自动获取的下拉框" class="headerlink" title="新增点位管理的时候想把合作商输入的改成自动获取的下拉框"></a>新增点位管理的时候想把合作商输入的改成自动获取的下拉框</h6><ul>
<li>定义js代码向后台发送请求，将请求后的结果封装给合作商parnterList集合</li>
<li>将文本框改成下拉框来遍历展示每个合作商的名称，提交时关联合作商的id</li>
</ul>
<pre><code class="js">      &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip/&gt; 详细地址多出的部分隐藏只有鼠标移动到才会显示


import &#123;listPartner&#125; from &quot;@/api/manage/partner&quot;

&lt;el-form-item label=&quot;合作商ID&quot; prop=&quot;partnerId&quot;&gt;
          &lt;!-- &lt;el-input v-model=&quot;form.partnerId&quot; placeholder=&quot;请输入合作商ID&quot; /&gt; --&gt;
           &lt;el-select v-model=&quot;form.partnerId&quot; placeholder=&quot;请选择合作商&quot;&gt;
            &lt;el-option
              v-for=&quot;item in partnerList&quot;
              :key=&quot;item.id&quot;
              :label=&quot;item.partnerName&quot;
              :value=&quot;item.id&quot;&gt;
            &lt;/el-option&gt;
           &lt;/el-select&gt;
&lt;/el-form-item&gt;

/* 查询合作商列表 */
const partnerList=ref([]);
function getPartnerList()&#123;
  listPartner(loadAllParams).then(response=&gt;&#123;
    partnerList.value = response.rows;
  &#125;)
&#125;
getPartnerList();
</code></pre>
<h6 id="避免每次都要写pageSize：10000-直接搞入js里面"><a href="#避免每次都要写pageSize：10000-直接搞入js里面" class="headerlink" title="避免每次都要写pageSize：10000 直接搞入js里面"></a>避免每次都要写pageSize：10000 直接搞入js里面</h6><pre><code class="java">src\api\page.js
/* 查询所有条件对象 */
// const loadAllParams=reactive(&#123;
//   pageNum:1,
//   pageSize:10000
// &#125;) →

export const loadAllParams = reactive(&#123;
  pageNum: 1,
  pageSize: 10000,
&#125;);
</code></pre>
<h3 id="点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯"><a href="#点位管理改造点位中增加个查看详情-将单表查询改为多表查询咯" class="headerlink" title="点位管理改造点位中增加个查看详情(将单表查询改为多表查询咯)"></a>点位管理改造<del>点位中增加个查看详情(将单表查询改为多表查询咯)</del></h3><ul>
<li>查看详情，需要显示当前点位下所有设备列表(稍后完成)</li>
<li>在区域详情中，需要显示每个点位的设备数</li>
<li>在点位列表查询中，关联显示区域、合作商等信息</li>
<li><strong>关联查询：</strong><u>对于设备数量的统计，我们需要执行关联查询，在mapper层封装</u></li>
<li><strong>关联实体</strong>：<u>对于区域和合作商的数据，我们会采用Mybatis提供的嵌套查询功能</u></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/601b425cc8b355cd33badf92ed988dbdabef1b9d/%E7%82%B9%E4%BD%8D%E7%AE%A1%E7%90%86%E6%94%B9%E9%80%A0%E8%A1%A8%E8%AE%BE%E8%AE%A1.png" alt="点位管理改造表设计.png"></p>
<pre><code class="mysql">&lt;resultMap&gt;......&lt;/resultMap&gt;   #完成手动映射

#解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

#解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 
</code></pre>
<pre><code class="mysql"># AI辅助编程模式
-- AI辅助编程模式
-- 你是一个软件开发工程师，现在要根据数据库的sql脚本，查询并显示点位表所有的字段信息,同时显示每个点位的设备数量，sql脚本如下：
create table tb_node
(
    id            int auto_increment comment &#39;主键id&#39;
        primary key,
    node_name     varchar(255)                        not null comment &#39;点位名称&#39;,
    address       varchar(255)                        not null comment &#39;详细地址&#39;,
    business_type int                                 null comment &#39;商圈类型&#39;,
    region_id     int                                 null comment &#39;区域ID&#39;,
    partner_id    int                                 null comment &#39;合作商ID&#39;,
    create_time   timestamp default CURRENT_TIMESTAMP null comment &#39;创建时间&#39;,
    update_time   timestamp default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment &#39;修改时间&#39;,
    create_by     varchar(64)                         null comment &#39;创建人&#39;,
    update_by     varchar(64)                         null comment &#39;修改人&#39;,
    remark        text                                null comment &#39;备注&#39;,
    constraint tb_node_ibfk_1
        foreign key (region_id) references tb_region (id)
            on update cascade on delete cascade,
    constraint tb_node_ibfk_2
        foreign key (partner_id) references tb_partner (id)
            on update cascade on delete cascade
)
    comment &#39;点位表&#39;;
    
create table tb_vending_machine
(
    id                   bigint auto_increment comment &#39;主键&#39;
        primary key,
    inner_code           varchar(15) default &#39;000&#39;                 null comment &#39;设备编号&#39;,
    channel_max_capacity int                                       null comment &#39;设备容量&#39;,
    node_id              int                                       not null comment &#39;点位Id&#39;,
    addr                 varchar(100)                              null comment &#39;详细地址&#39;,
    last_supply_time     datetime    default &#39;2000-01-01 00:00:00&#39; not null comment &#39;上次补货时间&#39;,
    business_type        int                                       not null comment &#39;商圈类型&#39;,
    region_id            int                                       not null comment &#39;区域Id&#39;,
    partner_id           int                                       not null comment &#39;合作商Id&#39;,
    vm_type_id           int         default 0                     not null comment &#39;设备型号&#39;,
    vm_status            int         default 0                     not null comment &#39;设备状态，0:未投放;1-运营;3-撤机&#39;,
    running_status       varchar(100)                              null comment &#39;运行状态&#39;,
    longitudes           double      default 0                     null comment &#39;经度&#39;,
    latitude             double      default 0                     null comment &#39;维度&#39;,
    client_id            varchar(50)                               null comment &#39;客户端连接Id,做emq认证用&#39;,
    policy_id            bigint                                    null comment &#39;策略id&#39;,
    create_time          timestamp   default CURRENT_TIMESTAMP     not null comment &#39;创建时间&#39;,
    update_time          timestamp   default CURRENT_TIMESTAMP     null comment &#39;修改时间&#39;,
    constraint vendingmachine_VmId_uindex
        unique (inner_code),
    constraint tb_vending_machine_ibfk_1
        foreign key (vm_type_id) references tb_vm_type (id),
    constraint tb_vending_machine_ibfk_2
        foreign key (node_id) references tb_node (id),
    constraint tb_vending_machine_ibfk_3
        foreign key (policy_id) references tb_policy (policy_id)
)
    comment &#39;设备表&#39;;
</code></pre>
<pre><code class="sql">-- 查询并显示点位表所有的字段信息,同时显示每个点位的设备数量
SELECT
    n.id,
    n.node_name,
    n.address,
    n.business_type,
    n.region_id,
    n.partner_id,
    n.create_time,
    n.update_time,
    n.create_by,
    n.update_by,
    n.remark,
    COUNT(v.id) AS vm_count
FROM
    tb_node n
LEFT JOIN
    tb_vending_machine v ON n.id = v.node_id
GROUP BY
    n.id;
</code></pre>
<pre><code class="java">package com.dkd.manage.domain.vo;

import com.dkd.manage.domain.Node;
import com.dkd.manage.domain.Partner;
import com.dkd.manage.domain.Region;
import lombok.Data;

@Data
public class NodeVo extends Node &#123;
    // 设备数量
    private Integer vmCount;
    // 区域信息
    private Region region;
    // 合作商信息
    private Partner partner;
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<pre><code class="xml">&lt;!--
resultType=&quot;com.dkd.manage.domin.vo.NodeVo&quot;&gt;...
这个是mybatis以前搞的自动映射封装直接把结果映射给了NodeVo的实体类了
嵌套查询就不能使用resultType自动映射 要改为resultMap做自动映射
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
多表查询一定要起别名噢 不然会报错没有指明where的子句是来自tb_node表的region_id  还是来自tb_vending_machine表的region_id
--&gt;

&lt;select id=&quot;selectNodeVoList&quot; parameterType=&quot;Node&quot; resultMap=&quot;NodeVoResult&quot;&gt;
        SELECT
        n.id,
        n.node_name,
        n.address,
        n.business_type,
        n.region_id,
        n.partner_id,
        n.create_time,
        n.update_time,
        n.create_by,
        n.update_by,
        n.remark,
        COUNT(v.id) AS vm_count
        FROM
        tb_node n
        LEFT JOIN
        tb_vending_machine v ON n.id = v.node_id
        &lt;where&gt;
            &lt;if test=&quot;nodeName != null  and nodeName != &#39;&#39;&quot;&gt; and n.node_name like concat(&#39;%&#39;, #&#123;nodeName&#125;, &#39;%&#39;)&lt;/if&gt;
            &lt;if test=&quot;regionId != null &quot;&gt; and n.region_id = #&#123;regionId&#125;&lt;/if&gt;
            &lt;if test=&quot;partnerId != null &quot;&gt; and n.partner_id = #&#123;partnerId&#125;&lt;/if&gt;
        &lt;/where&gt;
        GROUP BY
        n.id
    &lt;/select&gt;
</code></pre>
<pre><code class="xml">多对一标签用association
&lt;resultMap type=&quot;NodeVo&quot; id=&quot;NodeVoResult&quot;&gt;
        &lt;result property=&quot;id&quot;    column=&quot;id&quot;    /&gt;
        &lt;result property=&quot;nodeName&quot;    column=&quot;node_name&quot;    /&gt;
        &lt;result property=&quot;address&quot;    column=&quot;address&quot;    /&gt;
        &lt;result property=&quot;businessType&quot;    column=&quot;business_type&quot;    /&gt;
        &lt;result property=&quot;regionId&quot;    column=&quot;region_id&quot;    /&gt;
        &lt;result property=&quot;partnerId&quot;    column=&quot;partner_id&quot;    /&gt;
        &lt;result property=&quot;createTime&quot;    column=&quot;create_time&quot;    /&gt;
        &lt;result property=&quot;updateTime&quot;    column=&quot;update_time&quot;    /&gt;
        &lt;result property=&quot;createBy&quot;    column=&quot;create_by&quot;    /&gt;
        &lt;result property=&quot;updateBy&quot;    column=&quot;update_by&quot;    /&gt;
        &lt;result property=&quot;remark&quot;    column=&quot;remark&quot;    /&gt;
        &lt;result property=&quot;vmCount&quot;    column=&quot;vm_count&quot;    /&gt;
&lt;!--
sql语法拿到region_id去执行区域当中的selectRegionById 方法执行的时候需要传递区域的id
原理：RegionMapper.java中的 public Region selectRegionById(Long id)把条件拿到手并封装给区域的Region对象 返回的Region对象最终映射给NodeVo.java的 private Region region;
怎么执行的映射呢？需要指定java属性名和执行的类型：
property=&quot;region&quot; 
javaType=&quot;Region&quot;
至此完成了mybatis的嵌套查询
--&gt;
        &lt;association property=&quot;region&quot; javaType=&quot;Region&quot; column=&quot;region_id&quot; select=&quot;com.dkd.manage.mapper.RegionMapper.selectRegionById&quot;/&gt;
        &lt;association property=&quot;partner&quot; javaType=&quot;Partner&quot; column=&quot;partner_id&quot; select=&quot;com.dkd.manage.mapper.PartnerMapper.selectPartnerById&quot;/&gt;
    &lt;/resultMap&gt;
</code></pre>
<pre><code class="java">&lt;resultMap&gt;......&lt;/resultMap&gt;   // 完成手动映射 为了实现多表映射情况组合查询

// 解决一对一 或 多对一 映射结果集只有一个对象时完成的ORM的映射封装
&lt;association&gt;......&lt;/association&gt;  #点位和点位1对1  点位和合作商1对多

// 解决一对多场景下来映射多个结果的集合 单个区域表+区域点位列表 映射的是集合！！
&lt;collection&gt;......&lt;/collection&gt; 


/*
// &lt;association&gt; 标签允许你在查询结果中嵌套另一个对象。
 这样可以方便地在 NodeVo 对象中直接访问 Region 和 Partner 的属性，而不需要额外的查询
 
property：指定 NodeVo 类中的属性名称，该属性将引用关联的对象。
javaType：指定关联对象的 Java 类型。
column：指定用于关联查询的列名，通常是外键。
select：指定一个子查询的方法，用于根据外键查询关联对象
*/
</code></pre>
<h4 id="NodeService"><a href="#NodeService" class="headerlink" title="NodeService"></a>NodeService</h4><pre><code class="java">/**
 * 查询点位管理列表
 * @param node
 * @return NodeVo集合
 */
public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="NodeServiceImpl"><a href="#NodeServiceImpl" class="headerlink" title="NodeServiceImpl"></a>NodeServiceImpl</h4><pre><code class="java">/**
 * 查询点位管理列表
 *
 * @param node
 * @return NodeVo集合
 */
@Override
public List&lt;NodeVo&gt; selectNodeVoList(Node node) &#123;
    return nodeMapper.selectNodeVoList(node);
&#125;
</code></pre>
<h4 id="NodeController"><a href="#NodeController" class="headerlink" title="NodeController"></a>NodeController</h4><pre><code class="java">/**
 * 查询点位管理列表
 */
@PreAuthorize(&quot;@ss.hasPermi(&#39;manage:node:list&#39;)&quot;)
@GetMapping(&quot;/list&quot;)
public TableDataInfo list(Node node)
&#123;
    startPage();
    List&lt;NodeVo&gt; voList = nodeService.selectNodeVoList(node);
    return getDataTable(voList);
&#125;
</code></pre>
<pre><code class="java">com/dkd/manage/mapper/NodeMapper.java
/**
     *  查询点位管理列表
     * @param node
     * @return
     */
    public List&lt;NodeVo&gt; selectNodeVoList(Node node);
</code></pre>
<h4 id="node-x2F-index-vue"><a href="#node-x2F-index-vue" class="headerlink" title="node&#x2F;index.vue"></a>node&#x2F;index.vue</h4><pre><code class="vue">&lt;!-- 点位列表 --&gt;
&lt;el-table v-loading=&quot;loading&quot; :data=&quot;nodeList&quot; @selection-change=&quot;handleSelectionChange&quot;&gt;
  &lt;el-table-column type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot; /&gt;
  &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; prop=&quot;id&quot; /&gt;
  &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
  &lt;el-table-column label=&quot;所在区域&quot; align=&quot;center&quot; prop=&quot;region.regionName&quot; /&gt;
  &lt;el-table-column label=&quot;商圈类型&quot; align=&quot;center&quot; prop=&quot;businessType&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;dict-tag :options=&quot;business_type&quot; :value=&quot;scope.row.businessType&quot; /&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
  &lt;el-table-column label=&quot;合作商&quot; align=&quot;center&quot; prop=&quot;partner.partnerName&quot; /&gt;
  &lt;el-table-column label=&quot;详细地址&quot; align=&quot;center&quot; prop=&quot;address&quot; show-overflow-tooltip=&quot;true&quot;/&gt;
  &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
    &lt;template #default=&quot;scope&quot;&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Edit&quot; @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
      &lt;el-button link type=&quot;primary&quot; icon=&quot;Delete&quot; @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:node:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
    &lt;/template&gt;
  &lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<h3 id="区域管理改造-地区详情新增查看详情"><a href="#区域管理改造-地区详情新增查看详情" class="headerlink" title="区域管理改造-地区详情新增查看详情"></a>区域管理改造-地区详情<del>新增查看详情</del></h3><pre><code class="html">src\views\manage\region\index.vue
&lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; class-name=&quot;small-padding fixed-width&quot;&gt;
        &lt;template #default=&quot;scope&quot;&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;getRegionInfo(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:list&#39;]&quot;&gt;查看详情&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleUpdate(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:edit&#39;]&quot;&gt;修改&lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot;  @click=&quot;handleDelete(scope.row)&quot; v-hasPermi=&quot;[&#39;manage:region:remove&#39;]&quot;&gt;删除&lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;

&lt;!-- 
template 插槽：
#default=&quot;scope&quot;：定义默认插槽，scope 是当前行的数据对象。

@click=&quot;getRegionInfo(scope.row)&quot;：点击按钮时调用 getRegionInfo 函数，并传入当前行的数据。
--&gt;

...
...

/* 查看详情操作按钮 */
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
&#125;

&lt;!-- 
nodeList 变量：

const nodeList = ref([])：定义一个响应式数组 nodeList，用于存储点位列表。
getRegionInfo 函数：

reset()：调用 reset 函数，可能用于重置表单或其他状态。
const _id = row.id：获取当前行的 id。
getRegion(_id).then(response =&gt; &#123; form.value = response.data &#125;)：调用 getRegion 函数查询区域信息，并将返回的数据赋值给 form.value。
loadAllParams.regionId = row.id：设置 loadAllParams 对象的 regionId 属性为当前行的 id。
listNode(loadAllParams).then(response =&gt; &#123; nodeList.value = response.rows &#125;)：调用 listNode 函数查询点位列表，并将返回的行数据赋值给 nodeList.value。
--&gt;
</code></pre>
<h5 id="区域管理里引入点位的api文件"><a href="#区域管理里引入点位的api文件" class="headerlink" title="区域管理里引入点位的api文件"></a>区域管理里引入点位的api文件</h5><pre><code class="js">import &#123; listNode &#125; from &quot;@/api/manage/node&quot;;
import &#123; loadAllParams &#125; from &quot;@/api/page&quot;;
...
/* 查看详情操作按钮 */
const nodeList = ref([]);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
&#125;
</code></pre>
<h6 id="添加区域管理对话框"><a href="#添加区域管理对话框" class="headerlink" title="添加区域管理对话框"></a>添加区域管理对话框</h6><pre><code class="html"> &lt;!-- 添加或修改区域管理对话框 --&gt;
    &lt;el-dialog :title=&quot;title&quot; v-model=&quot;open&quot; width=&quot;500px&quot; append-to-body&gt;
      &lt;el-form ref=&quot;regionRef&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt;
        &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
          &lt;el-input v-model=&quot;form.regionName&quot; placeholder=&quot;请输入区域名称&quot; /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item label=&quot;备注说明&quot; prop=&quot;remark&quot;&gt;
          &lt;el-input v-model=&quot;form.remark&quot; type=&quot;textarea&quot; placeholder=&quot;请输入内容&quot; /&gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
      &lt;template #footer&gt;
        &lt;div class=&quot;dialog-footer&quot;&gt;
          &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm&quot;&gt;确 定&lt;/el-button&gt;
          &lt;el-button @click=&quot;cancel&quot;&gt;取 消&lt;/el-button&gt;
        &lt;/div&gt;
      &lt;/template&gt;
    &lt;/el-dialog&gt;
   &lt;!-- 查看详情对话框 --&gt;
&lt;el-dialog title=&quot;区域详情&quot; v-model=&quot;regionInfoOpen&quot; width=&quot;500px&quot; append-to-body&gt;
    &lt;el-form-item label=&quot;区域名称&quot; prop=&quot;regionName&quot;&gt;
        &lt;el-input v-model=&quot;form.regionName&quot; disabled /&gt;
    &lt;/el-form-item&gt;
    &lt;label&gt;包含点位：&lt;/label&gt;
    &lt;el-table :data=&quot;nodeList&quot;&gt;
        &lt;el-table-column label=&quot;序号&quot; type=&quot;index&quot; width=&quot;50&quot; align=&quot;center&quot; /&gt;
        &lt;el-table-column label=&quot;点位名称&quot; align=&quot;center&quot; prop=&quot;nodeName&quot; /&gt;
        &lt;el-table-column label=&quot;设备数量&quot; align=&quot;center&quot; prop=&quot;vmCount&quot; /&gt;
    &lt;/el-table&gt;
&lt;/el-dialog&gt;
</code></pre>
<pre><code class="js">/* 查看详情操作按钮 */
const nodeList = ref([]);
const regionInfoOpen=ref(false);
function getRegionInfo(row) &#123;
  // 查询区域信息
  reset();
  const _id = row.id
  getRegion(_id).then(response =&gt; &#123;
    form.value = response.data
  &#125;);
  // 查看点位列表
  loadAllParams.regionId=row_id
  listNode(loadAllParams).then(response =&gt; &#123;
    nodeList.value = response.rows;
  &#125;);
  regionInfoOpen.value=true;
&#125;
</code></pre>
<h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><ul>
<li>在删除区域或合作商数据时，关联的点位数据该如何处理？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/05e49c8d5a61f85f41c20ded647d7f32c03ae296/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7_%E5%AD%97%E6%AE%B5%E4%BE%9D%E8%B5%96.png"></p>
<blockquote>
<p>tb_region(区域表)                     tb_node(点位表)                       tb_partner(合作商表)<br>id           ←region_id:id ←        region_id                                                  id<br>                                                    partner_id             partner_id:id →→→↑     </p>
</blockquote>
<p>找到设置外键约束<del>(取消约束)</del><code>dkd → tb_node → Modify Table(old)</code> 找到<code>Foreign Keys</code>  双击打开后将<u>Update rule</u>和<u>Delete rule</u>修改为：<strong>no action</strong></p>
<blockquote>
<p>**CASCADE（级联操作）:**当父表中的某行记录被删除或更新时，与其关联的所有子表中的匹配行也会自动被删除或更新。这种方式适用于希望保持数据一致性的场景，即父记录不存在时，相关的子记录也应该被移除。</p>
<p>**SET NULL（设为空）:**若父表中的记录被删除或更新，子表中对应的外键字段会被设置为NULL。选择此选项的前提是子表的外键列允许为NULL值。这适用于那些子记录不再需要明确关联到任何父记录的情况。</p>
<p>**RESTRICT（限制）:**在尝试删除或更新父表中的记录之前，数据库首先检查是否有相关联的子记录存在。如果有，则拒绝执行删除或更新操作，以防止意外丢失数据或破坏数据关系的完整性。这是一种保守策略，确保数据间的引用完整性。</p>
<p>**NO ACTION（无操作）:**在标准SQL中，NO ACTION是一个关键字，它要求数据库在父表记录被删除或更新前，检查是否会影响子表中的相关记录。在MySQL中，NO ACTION的行为与RESTRICT相同，即如果子表中有匹配的行，则禁止执行父表的删除或更新操作。这意味着如果存在依赖关系，操作将被阻止，从而保护数据的参照完整性。</p>
</blockquote>
<p>修改完毕后，如果你尝试进行删除操作，会发现数据库的完整性约束生效了，它会阻止删除操作并给出错误提示。但是，这个错误提示信息可能对于用户来说不够友好，可能会让用户感到困惑。</p>
<p><code>SQLIntegrityConstraintViolationException</code>是Java中的一个异常类，这个类通常用于表示SQL数据库操作中的完整性约束违反异常</p>
<p>例如：外键约束、唯一约束等。当数据库操作违反了这些约束时，就会抛出这个异常。</p>
<p>这个错误是由于外键约束导致的。它表明在删除或更新父表的行时，存在外键约束，子表中的相关行会受到影响。</p>
<p>是因为在删除tb_region表中的行时，tb_node表中的region_id外键约束会阻止操作。</p>
<p>如果你在使用Spring框架进行数据库操作，可能会先遇到DataIntegrityViolationException，它是对SQLIntegrityConstraintViolationException的一个更高层次的抽象，旨在提供一种更加面向应用的错误表示。</p>
<p>而SQLIntegrityConstraintViolationException是更底层的异常，直接来源于数据库驱动，包含更多底层数据库相关的细节。</p>
<p>在实际开发中，推荐捕获并处理DataIntegrityViolationException，因为它更符合Spring应用的异常处理模式，同时也可以通过其内部的cause（原因）属性来获取具体的SQLIntegrityConstraintViolationException，进而获取详细的错误信息。</p>
<p>为了提升用户体验，我们可以使用Spring Boot框架的全局异常处理器来捕获这些错误信息，并返回更友好的提示信息给用户。这样，当用户遇到这种情况时，他们将收到一个清晰、易懂的提示，告知他们操作无法完成的原因。</p>
<pre><code class="java">com/dkd/framework/web/exception/GlobalExceptionHandler.java
/**
     * 数据完整性异常
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public AjaxResult handleDataIntegrityViolationException(DataIntegrityViolationException e) &#123;
        log.error(e.getMessage(), e);
        if (e.getMessage().contains(&quot;foreign&quot;)) &#123;
            return AjaxResult.error(&quot;无法删除该数据，有其他数据引用&quot;);
        &#125;
        return AjaxResult.error(&quot;数据完整性异常，请联系管理员&quot;);
    &#125;
</code></pre>
<p>16</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/03/后端/若依-AI & 帝可得/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/10/31/面试/Java八股文专项/">
        <h2>
            Java面试专项
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/31
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><h6 id="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"><a href="#我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？" class="headerlink" title="我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？"></a><span style = "color:red">我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？</span></h6><ul>
<li>验证你项目场景的真实性，二是为了深入发问的切入点</li>
<li><strong>缓存</strong> 缓存三兄弟(穿透、击穿、雪崩)、双写一致、持久化、数据过期策略、数据淘汰策略</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li><strong>消息队列、延迟队列</strong> 何种数据类型</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><p><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong><br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</p>
</li>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p><strong>bitmap（位图）</strong>：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大    </p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给<strong>某一个key设置了过期时间</strong>，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[不设置过期时间] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】<br>也可以搞个<u><strong>永不过期</strong></u> 具体是先在业务里写好某种情况下 某些时候不会过期 比如疫情卖口罩时期</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值</li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<pre><code class="java">《缓存三兄弟》
穿透无中生有key，布隆过滤null隔离。
缓存击穿过期key，锁与非期解难题。
雪崩大量过期key，过期时间要随机。
面试必考三兄弟，可用限流来保底。
</code></pre>
<h6 id="redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性"><a href="#redis作为缓存，mysql的数据如何与redis进行同步呢？-双写一致性" class="headerlink" title="redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)"></a><span style = "color:red">redis作为缓存，mysql的数据如何与redis进行同步呢？(双写一致性)</span></h6><blockquote>
<h3 id="✅-二、Redis-和-MySQL-不一致会发生什么？"><a href="#✅-二、Redis-和-MySQL-不一致会发生什么？" class="headerlink" title="✅ 二、Redis 和 MySQL 不一致会发生什么？"></a>✅ <strong>二、Redis 和 MySQL 不一致会发生什么？</strong></h3><h4 id="如果同步失败，会出现："><a href="#如果同步失败，会出现：" class="headerlink" title="如果同步失败，会出现："></a>如果同步失败，会出现：</h4><ul>
<li><strong>缓存中的数据是脏的</strong>（脏读）</li>
<li><strong>缓存中没有数据，但数据库中有</strong>（缓存穿透）</li>
<li><strong>数据库更新了，但 Redis 仍是旧值</strong>（一致性问题）</li>
<li><strong>并发写操作丢失最新值</strong>（写丢失）</li>
</ul>
</blockquote>
<p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行</p>
<p><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。<br>或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】</p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知</strong>&#x3D;&#x3D;： <u>异步通知保证数据的最终一致性</u>(需要保证<strong>MQ</strong>的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先<u>将数据写入Redis</u>，然后通过<u>异步通知机制触发数据库的更新</u>操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="✅-为什么会出现-Redis-和-MySQL-数据不一致？"><a href="#✅-为什么会出现-Redis-和-MySQL-数据不一致？" class="headerlink" title="✅ 为什么会出现 Redis 和 MySQL 数据不一致？"></a>✅ 为什么会出现 Redis 和 MySQL 数据不一致？</h2><p>Redis 是<strong>缓存</strong>，MySQL 是<strong>数据库</strong>，它们的数据生命周期不同，导致在更新时会出现以下几种情况：</p>
<hr>
<h3 id="💥-情况1：先更新数据库，再删除缓存（常见写法）"><a href="#💥-情况1：先更新数据库，再删除缓存（常见写法）" class="headerlink" title="💥 情况1：先更新数据库，再删除缓存（常见写法）"></a>💥 情况1：先更新数据库，再删除缓存（常见写法）</h3><pre><code>update DB
delete cache
</code></pre>
<ul>
<li>假设刚执行完 <code>update DB</code>，还没来得及 <code>delete cache</code>，此时某个<strong>高并发请求</strong>进来：<ul>
<li>它先查缓存，发现是旧数据；</li>
<li>然后返回了错误的数据；</li>
<li>后续即使删了缓存，已经晚了。</li>
</ul>
</li>
</ul>
<p>这就是：<strong>缓存未及时失效，读取到了脏数据</strong>。</p>
<hr>
<h3 id="💥-情况2：先删除缓存，再更新数据库"><a href="#💥-情况2：先删除缓存，再更新数据库" class="headerlink" title="💥 情况2：先删除缓存，再更新数据库"></a>💥 情况2：先删除缓存，再更新数据库</h3><pre><code>delete cache
update DB
</code></pre>
<ul>
<li>这个时候如果并发查询线程来得很快：<ul>
<li>缓存刚被删，查询请求就查不到；</li>
<li>就会穿透查数据库，查到旧数据；</li>
<li>然后<strong>又把旧数据写入了 Redis</strong>，覆盖了更新后的数据！</li>
</ul>
</li>
</ul>
<hr>
<h3 id="💥-情况3：缓存过期后查询数据库，正好遇到更新未完成"><a href="#💥-情况3：缓存过期后查询数据库，正好遇到更新未完成" class="headerlink" title="💥 情况3：缓存过期后查询数据库，正好遇到更新未完成"></a>💥 情况3：缓存过期后查询数据库，正好遇到更新未完成</h3><pre><code>Redis key 过期
查询数据库返回旧数据
写入 Redis（错的数据被缓存）
</code></pre>
<p>这就是<strong>缓存击穿 + 数据同步延迟</strong>的问题。</p>
<hr>
<h2 id="✅-数据为什么会“丢”？需要同步吗？"><a href="#✅-数据为什么会“丢”？需要同步吗？" class="headerlink" title="✅ 数据为什么会“丢”？需要同步吗？"></a>✅ 数据为什么会“丢”？需要同步吗？</h2><p>Redis 是内存数据库，<strong>不具备强一致性保障</strong>，以下情况会导致“看起来丢数据”：</p>
<ol>
<li><strong>更新了数据库，但缓存没更新&#x2F;没删除</strong></li>
<li><strong>缓存提前过期，重新加载了旧数据</strong></li>
<li><strong>Redis 重启，缓存丢失</strong></li>
<li><strong>并发穿透，旧数据反复写入缓存</strong></li>
<li><strong>程序异常，缓存更新&#x2F;删除逻辑没执行</strong></li>
</ol>
<h2 id="✅-怎么保证-Redis-和-MySQL-的一致性？"><a href="#✅-怎么保证-Redis-和-MySQL-的一致性？" class="headerlink" title="✅ 怎么保证 Redis 和 MySQL 的一致性？"></a>✅ 怎么保证 Redis 和 MySQL 的一致性？</h2><p>这就是我们说的：<strong>缓存与数据库双写一致性问题</strong>，常见策略如下：</p>
<h3 id="1️⃣-读写操作采用延迟双删策略（推荐）"><a href="#1️⃣-读写操作采用延迟双删策略（推荐）" class="headerlink" title="1️⃣ 读写操作采用延迟双删策略（推荐）"></a>1️⃣ 读写操作采用延迟双删策略（推荐）</h3><pre><code>update DB
delete Redis
sleep 500ms
delete Redis again
</code></pre>
<ul>
<li>延迟双删可以尽可能避免并发查询旧缓存的情况。</li>
</ul>
<h3 id="2️⃣-加分布式锁"><a href="#2️⃣-加分布式锁" class="headerlink" title="2️⃣ 加分布式锁"></a>2️⃣ 加分布式锁</h3><ul>
<li>给关键资源加锁，串行化更新操作，避免并发穿透。</li>
</ul>
<h3 id="3️⃣-异步更新缓存（利用消息队列）"><a href="#3️⃣-异步更新缓存（利用消息队列）" class="headerlink" title="3️⃣ 异步更新缓存（利用消息队列）"></a>3️⃣ 异步更新缓存（利用消息队列）</h3><ul>
<li>变更数据后，发送消息通知缓存异步刷新。</li>
</ul>
<h3 id="4️⃣-设置合理的缓存-TTL-定时刷新"><a href="#4️⃣-设置合理的缓存-TTL-定时刷新" class="headerlink" title="4️⃣ 设置合理的缓存 TTL + 定时刷新"></a>4️⃣ 设置合理的缓存 TTL + 定时刷新</h3><ul>
<li>防止长期过期数据驻留，降低不一致几率。</li>
</ul>
<h3 id="5️⃣-不缓存非热点数据"><a href="#5️⃣-不缓存非热点数据" class="headerlink" title="5️⃣ 不缓存非热点数据"></a>5️⃣ 不缓存非热点数据</h3><ul>
<li>某些冷门数据没必要缓存，避免无谓一致性维护。</li>
</ul>
</blockquote>
<h6 id="Redis作为缓存，数据的持久化是怎么做的？"><a href="#Redis作为缓存，数据的持久化是怎么做的？" class="headerlink" title="Redis作为缓存，数据的持久化是怎么做的？"></a><span style = "color:red">Redis作为缓存，数据的持久化是怎么做的？</span></h6><p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开 启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del><br><del>save就是直接让主线程去执行</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果<del>这是AOF文件越来越大的处理方式</del></p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h6 id="假如Redis的key过期之后，会立即删除吗"><a href="#假如Redis的key过期之后，会立即删除吗" class="headerlink" title="假如Redis的key过期之后，会立即删除吗"></a><span style = "color:red">假如Redis的key过期之后，会立即删除吗</span></h6><p>Redis对数据设置数据的有效时间，数据过期以后就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略(数据过期策略)</p>
<p>&#x3D;&#x3D;<strong>Redis数据删除策略-惰性删除</strong>&#x3D;&#x3D;</p>
<p>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p>
<pre><code class="mysql">set name zhangsan 10
get name # 发现name过期了，直接删除key
</code></pre>
<p><strong>优点：</strong>对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不会浪费时间进行过期检查<br><strong>缺点：</strong>对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p>
<p><strong>&#x3D;&#x3D;Redis数据删除策略-定期删除&#x3D;&#x3D;</strong></p>
<p>定期删除：每隔一段时间，我们就会对一些key进行检查，删除里面过期的key (从一定数量的数据库中取出一定数量的<strong>随机key</strong>进行检查，并删除其中的过期key)</p>
<p><strong>定期清理的两种模式：</strong></p>
<ul>
<li><strong>SLOW模式</strong>是定时模式，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件<code>redis.conf</code>的hz选项来调整这个次数</li>
<li><strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li>
</ul>
<p><strong>优点：</strong>可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存<br><strong>难点：</strong>难以确定删除操作执行的时长和频率</p>
<p><strong>Redis过期删除策略：</strong> <strong><u>惰性删除 + 定期删除</u></strong> 两种策略进行配合使用</p>
<h6 id="假如缓存过多，内存是有限的，内存被占满了怎么办？"><a href="#假如缓存过多，内存是有限的，内存被占满了怎么办？" class="headerlink" title="假如缓存过多，内存是有限的，内存被占满了怎么办？"></a><span style = "color:red">假如缓存过多，内存是有限的，内存被占满了怎么办？</span></h6><p>&#x3D;&#x3D;<strong>数据淘汰策略</strong>&#x3D;&#x3D;</p>
<p>当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据制除掉，这种数据的制除规则被称之为内存的淘汰策略</p>
<p><strong>Redis支持8种不同策略来选择要删除的key:</strong></p>
<ul>
<li><p><strong>noeviction：</strong>不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong></p>
<blockquote>
<h6 id="maxmemory-policy-noeviction"><a href="#maxmemory-policy-noeviction" class="headerlink" title="maxmemory-policy noeviction"></a>maxmemory-policy noeviction</h6></blockquote>
</li>
<li><p><strong>volatile-ttl</strong>：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰 (<u>TTL:过期时间的key</u>)</p>
</li>
<li><p><strong>allkeys-random</strong>：对全体key，随机进行淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：对设置了TTL的key，随机进行淘汰</p>
</li>
<li><p><strong>allkeys-lru</strong>：对全体key，基于LRU算法进行淘汰</p>
<blockquote>
<p><strong>LRU</strong>(Least <strong>Recently</strong> Used)：<strong>最近最少使用</strong>，用当前时间减去最后一次访问时间，这个值越大测淘汰优先级越高 [逐出访问时间最少的]<br><strong>LFU</strong>(Least <strong>Frequently</strong> Used)：<strong>最少频率使用</strong>。会统计每个key的访问频率，值越小淘汰优先级越高。[逐出频率最低的] 【电商会应用】</p>
</blockquote>
</li>
<li><p><strong>allkeys-lfu</strong>：对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p><strong>volatile-lfu</strong>：对设置了TTL的key，基于LFU算法进行淘汰</p>
</li>
</ul>
<p><strong>淘汰策略 - 使用建议</strong></p>
<p>1.优先使用 <code>allkeys-lru</code> 策略。充分利用LRU算法的优势，把最近最常访问的数据留在缓存中，如果业务有明显的冷热数据区分，建议使用。<br>2.如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用<code>allkeys-random</code>，随机选择淘汰<br>3.如果业务中有置顶的需求，可以使用<code>volatile-lru</code>策略，同时<strong>置顶数据不设置过期时间</strong>，这些数据就一直不会被删除，会淘汰其他设置过期时间的数据<br>4.如果业务中有<strong>短时高频</strong>访问的数据，可以使用<code>allkeys-lfu</code>或<code>volatile-lfu</code>策略</p>
<h6 id="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"><a href="#数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？" class="headerlink" title="数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？"></a>数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis中的数据都是热点数据？</h6><ul>
<li>使用<code>allkeys-lru</code>(挑选最近最少使用的数据淘汰) 淘汰策略，留下来的都是经常访问的热点数据</li>
</ul>
<h6 id="Redis的内存用完了会发生什么？"><a href="#Redis的内存用完了会发生什么？" class="headerlink" title="Redis的内存用完了会发生什么？"></a>Redis的内存用完了会发生什么？</h6><ul>
<li>主要看数据淘汰策略是什么？如果是默认的配置(noeviction)，会直接报错</li>
</ul>
<h6 id="redis分布式锁，是如何实现的？"><a href="#redis分布式锁，是如何实现的？" class="headerlink" title="redis分布式锁，是如何实现的？"></a><span style = "color:red">redis分布式锁，是如何实现的？</span></h6><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题<br><img src="https://raw.githubusercontent.com/P-luminary/images/0f81d6fe238b4774d88facda4329c5ebe4921aa0/Redis%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg"></p>
<p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写<br>在同一时刻，只有一个线程&#x2F;进程&#x2F;服务节点能拿到锁，执行关键代码。其他的只能等或者失败退出。</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、PX是设置超时时间<br><strong>SET lock value NX PX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h6 id="Redis实现分布式锁如何合理的控制锁的有效时长？"><a href="#Redis实现分布式锁如何合理的控制锁的有效时长？" class="headerlink" title="Redis实现分布式锁如何合理的控制锁的有效时长？"></a><span style = "color:red">Redis实现分布式锁如何合理的控制锁的有效时长？</span></h6><ul>
<li>根据业务执行时间预估</li>
<li><strong>给锁续期</strong></li>
</ul>
<h5 id="你“自己用-Redis-实现分布式锁”-vs-用-Redisson-实现锁-——-有哪些区别？"><a href="#你“自己用-Redis-实现分布式锁”-vs-用-Redisson-实现锁-——-有哪些区别？" class="headerlink" title="你“自己用 Redis 实现分布式锁” vs 用 Redisson 实现锁 —— 有哪些区别？"></a>你“自己用 Redis 实现分布式锁” vs 用 <strong>Redisson</strong> 实现锁 —— 有哪些区别？</h5><table>
<thead>
<tr>
<th>对比点</th>
<th>手动实现（自己用 Redis 命令）</th>
<th>✅ Redisson 实现</th>
</tr>
</thead>
<tbody><tr>
<td>🛠 实现方式</td>
<td>使用 <code>SET key value NX PX</code>、<code>GET</code> + <code>DEL</code></td>
<td>内部封装好，直接调用 <code>.lock()</code>、<code>.unlock()</code></td>
</tr>
<tr>
<td>🔐 安全性</td>
<td>容易写错，不易保证“<strong>只有加锁者能解锁</strong>”</td>
<td>Redisson 自动做到了“加锁者才能解锁”</td>
</tr>
<tr>
<td>💣 死锁处理</td>
<td>自己必须手动加过期时间（PX），否则会死锁</td>
<td>自动设置超时时间，支持 watchdog 自动续命</td>
</tr>
<tr>
<td>🧵 可重入锁</td>
<td>不支持，需要自己实现复杂逻辑</td>
<td>✅ 内建支持可重入锁（ReentrantLock）</td>
</tr>
<tr>
<td>⚠ 主从不一致</td>
<td>Redis 主从复制延迟下可能“锁丢失”</td>
<td>Redisson 有 RedLock 模式，可用多个实例容错</td>
</tr>
<tr>
<td>🚦 阻塞等待</td>
<td>需要自己写轮询逻辑（比如 while循环）</td>
<td>✅ Redisson 支持阻塞、等待、超时等参数</td>
</tr>
<tr>
<td>⏱ 自动续租</td>
<td>没有，需要自己定时续约</td>
<td>✅ 有“看门狗机制”自动续租防止业务太长释放锁</td>
</tr>
<tr>
<td>🔁 分布式支持</td>
<td>支持有限，自己写 RedLock 非常麻烦</td>
<td>✅ 内置 RedLock、联锁、多锁等高级功能</td>
</tr>
<tr>
<td>✅ 使用体验</td>
<td>复杂，代码易错</td>
<td>✅ 简单、线程安全、功能全面</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;<br>✅ 只有在 <strong>你没指定超时时间</strong> 时，Watchdog 才会自动开启</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="要加依赖"><a href="#要加依赖" class="headerlink" title="要加依赖"></a>要加依赖</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="❌-如果你这样写："><a href="#❌-如果你这样写：" class="headerlink" title="❌ 如果你这样写："></a>❌ 如果你这样写：</h3><pre><code class="java">lock.lock(10, TimeUnit.SECONDS);
</code></pre>
<p>就不会有自动续命，看门狗不会工作。这种锁就是严格 10 秒后自动释放，不管你业务是否完成。</p>
<h3 id="🔄-Watchdog-自动续命流程图"><a href="#🔄-Watchdog-自动续命流程图" class="headerlink" title="🔄 Watchdog 自动续命流程图"></a>🔄 Watchdog 自动续命流程图</h3><pre><code class="yaml">lock.lock() 被调用
     ↓
Redisson 设置锁为30秒过期
     ↓
启动看门狗线程，每10秒刷新一次锁 TTL
     ↓
如果线程还持有锁 → Redis.expire(lockKey, 30秒)
     ↓
直到 unlock() 调用 → 结束看门狗 + 删除锁
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责 <strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h6 id="Redis集群有哪些方案？"><a href="#Redis集群有哪些方案？" class="headerlink" title="Redis集群有哪些方案？"></a><span style = "color:red">Redis集群有哪些方案？</span></h6><ul>
<li><p>&#x3D;&#x3D;<strong>主从复制</strong>&#x3D;&#x3D; </p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离<br><u>主节点写操作→增删改</u>     <u>从节点读操作→查</u></p>
<h6 id="介绍一下redis的主从同步"><a href="#介绍一下redis的主从同步" class="headerlink" title="介绍一下redis的主从同步"></a><span style = "color:red">介绍一下redis的主从同步</span></h6><blockquote>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p>
</blockquote>
<p><strong>主从数据同步原理：</strong></p>
<ul>
<li><span style="color:blue"><u>主从<strong>全量同步</strong></u>：</span></li>
</ul>
<p>slave从节点执行<code>replicaof</code>命令建立链接 → 请求master主节点数据同步(<u>replid+offset</u>) → master判断是否是第一次同步(判断replid是否一致) → 是第一次, 返回master的数据版本信息(<u>replid+offset</u>)  → slave保存版本信息 → master执行<strong>bgsave</strong>, 生成RDB → 发送RDB文件给slave → slave清空本地数据加载RDB数据 → 此时master记录RDB期间所有命令<code>repl_balklog</code> → 发送repl_backlog中的命令 → slave执行接收到的命令</p>
<p><strong>Replication ld</strong>: 简称<u>replid</u>，是数据集的标记，id一致则说明是同一<strong>数据集</strong>。每一个master都有唯一的replid,slave则会继承master节点的replid<br><strong>offset</strong>: 偏移量，随着记录在repl baklog中的数据增多而逐渐增大。save完成同步时也会记录当前同步的offset，<strong>如果slave的offset小于master的offset，说明slave数据落后于master</strong>，需要更新。</p>
<blockquote>
<p>简述全量同步的流程？</p>
<p>• slave节点请求增量同步</p>
<p>• master节点判断replid，发现不一致，拒绝增量同步</p>
<p>• master将完整内存数据生成RDB，发送RDB到slave</p>
<p>• slave清空本地数据，加载master的RDB</p>
<p>• master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</p>
<p>• slave执行接收到的命令，保持与master之间的同步</p>
</blockquote>
<p><span style = "color:red"><strong>能说一下，主从同步数据的流程吗？</strong></span></p>
<p><span style="color:pink"><strong>全量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据(replication id、offset)<br>2.主节点判断是否为第一次请求，是第一次就与从节点同步版本信息(replication id和offset)<br>3.主节点执行bgsave, 生成RDB文件后, 发送给从节点去执行<br>4.在RDB生成执行期间, 主节点会从命令的方式记录到缓冲区(日志文件)</p>
</blockquote>
<ul>
<li><span style="color:blue"><u>主从<strong>增量同步</strong></u></span><br>主从增量同步(slave重启或后期数据变化)</li>
</ul>
<p>① slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 是第一次, 返回主节点replid和offset → 保存版本信息<br>② slave重启后 → 携带(replid+offset)找master → master判断请求replid是否一致 → 不是第一次, 回复continue向slave → master 去repl_baklog中<strong>获取offset后的数据</strong> → 发送offset后的命令给slave → 执行命令</p>
<p><span style="color:pink"><strong>增量同步</strong></span></p>
<blockquote>
<p>1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值<br>2.主节点从命令日志中获取offset值后的数据，发送给节点进行数据同步</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>简述全量同步和增量同步区别？</p>
<p>•全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</p>
<p>•增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</p>
<p>什么时候执行全量同步？</p>
<p>•slave节点第一次连接master节点时</p>
<p>•slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</p>
<p>什么时候执行增量同步？</p>
<p>•slave节点断开又恢复，并且在repl_baklog中能找到offset时</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>哨兵模式</strong>&#x3D;&#x3D;<del>搭过集群，具体多少个节点是组长那边，不太清楚</del>[并发量不是太多 搭哨兵可以节省一点资源]~<br>Redis提供了<strong>哨兵</strong>(Sentinel)机制来实现主从集群的自动故障恢复</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为一个master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知：</strong>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<p><span style="color:blue"><strong>服务状态监控</strong></span><br>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令 <code>期待回复pong</code></p>
<ul>
<li><strong>主观下线</strong>：如果某sentinel节点发现或某实例未在规定时间相应，则认为该实例<strong>主观下线</strong></li>
<li><strong>客观下线</strong>：若超过指定数量(quorum)的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>，quorum值最好超过Sentinel实例数量的一半</li>
</ul>
<p><span style="color:blue"><strong>哨兵选主规则</strong></span></p>
<ul>
<li>首先判断主与从节点断开时间长短，如超过指定值就排该从节点</li>
<li>然后判断从节点的slave-priority值，越小优先级越高</li>
<li><strong><u>如果slave-priority值一样，则判断slave节点的offset值，越大优先级越高</u></strong> (数据是最全的)</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<p><strong><span style="color:blue">redis集群(哨兵模式) 脑裂</span></strong><br>因网络问题 主节点和从节点分别在不同的网络分区 这样sentinel只会监控到一部分从节点网络分区 导致RedisClient继续写主节点的数据，这时网络恢复了，哨兵会将老的master强制降级到slave(携带着脑裂前的最新数据)，这个时候slave就会把自己数据清空去同步master数据，这时就存在真正的数据丢失了</p>
<p><strong>怎么解决</strong>？</p>
<blockquote>
<p>redis中有两个配置参数：【若不能达成就拒绝客户端请求 这样就会避免大量数据丢失】<br>min-replicas-to-write 1      <strong>表示最少的salve节点为1</strong><br>min-replicas-max-lag 5      <strong>表示数据复制和同步的延迟不能超过5秒</strong><br>达不到这两个条件就拒绝写入，从而避免数据丢失。</p>
</blockquote>
<p><span style = "color:red"><strong>怎么保证Redis的高并发高可用呢？</strong></span></p>
<blockquote>
<p>哨兵模式：实现主从集群的自动故障恢复(监控、自动故障恢复、通知)</p>
</blockquote>
<p><span style = "color:red"><strong>你们使用redis是单点还是集群，哪种集群？</strong></span></p>
<blockquote>
<p>主从(1主1从) + 哨兵就可以了。单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点</p>
</blockquote>
<p><span style = "color:red"><strong>redis集群脑裂，该怎么解决？</strong></span></p>
<blockquote>
<p><strong>集群脑裂</strong>是由于主节点和从节点和sentinel处于不同网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当为网络恢复后，sentinel会将老的主节点降为从节点，此时再从新master同步数据，就会导致数据丢失<br><strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，这样就会避免大量数据丢失。</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>分片集群</strong>&#x3D;&#x3D;</p>
<p>主从和哨兵可以解决高可用、高并发读的问题，但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可用解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可用有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<p><strong><span style="color:blue">分片集群结果 - 数据读写</span></strong></p>
<p>Redis分片集群引入了<strong>哈希槽</strong>的概念，Redis集群有16384个哈希值，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽</p>
<blockquote>
<p>存数据流程：<br>set name itheima → CRC16计算name的hash值(666666) → 666666%16384&#x3D;11306 → 根据11306找寻所对应哈希槽的范围 并且插入数据</p>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群有什么用？</strong></span></p>
<blockquote>
<ul>
<li>集群中有多个master，每个master保存不同数据。(解决高并发<strong>写</strong>的问题)</li>
<li>每个master都可以有多个slave节点。(解决高并发<strong>读</strong>的问题)</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可用访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>redis的分片集群中数据是怎么存储和读取的？</strong></span></p>
<blockquote>
<ul>
<li>Redis 分片集群引入了哈希槽的概念，Redis 集群有16384个哈槽</li>
<li>将16384个插槽分配到不同的实例</li>
<li>读写数据:根据key的**<u>有效部分</u>**计算哈希值，对16384取余(有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分)余数做为播槽，寻找插所在的实例</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="🚀-Redis-集群常见三种方式（解决不同问题）"><a href="#🚀-Redis-集群常见三种方式（解决不同问题）" class="headerlink" title="🚀 Redis 集群常见三种方式（解决不同问题）"></a>🚀 Redis 集群常见三种方式（解决不同问题）</h2><table>
<thead>
<tr>
<th>模式</th>
<th>主要解决问题</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>① 主从复制（+读写分离）</td>
<td><strong>读写压力分担</strong></td>
<td>一主多从，主写从读，不能自动故障转移</td>
</tr>
<tr>
<td>② 哨兵模式（Sentinel）</td>
<td><strong>高可用（自动故障转移）</strong></td>
<td>在主从基础上，Sentinel 实现监控、自动选主、通知客户端</td>
</tr>
<tr>
<td>③ 分片集群（Cluster）</td>
<td><strong>海量数据、高写吞吐</strong></td>
<td>数据分片+多主多从，每个主分管部分槽位（16384 slots）</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>Redis是单线程的，但是为什么还那么快</strong></span></p>
<blockquote>
<ul>
<li>Redis是<strong>纯内存操作</strong>，执行速度非常快</li>
<li>采用单线程，<strong>避免不必要的上下文切换</strong>可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用<strong>I&#x2F;O多路复用</strong>模型，非阻塞IO</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>解释一下I&#x2F;O多路复用模型？</strong></span></p>
<blockquote>
<p>Redis是纯内存操作，执行速度非常快，它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度，I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li><p>是指利用单个线程来同时监听多个Socket ，并在某个Socket<strong>可读、可写</strong>时得到通知，从而避免无效的等待，充分利用CPU资源，目前的I&#x2F;O多路复用都是采用的epol模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要换个Socket来判断是否就绪，提升了性能</p>
</li>
<li><p><strong>Redis网络模型</strong>:</p>
<p>就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<ul>
<li><p>连接应答处理器</p>
</li>
<li><p>命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件</p>
</li>
<li><p>命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>用户空间和内核空间</strong>&#x3D;&#x3D;</p>
<ul>
<li>Linux系统中一个进程使用的内存情况划分两部分：<strong>内核空间、用户空间</strong></li>
<li><strong>用户空间</strong>只能执行受限的命令Ring3，而且不能直接调用系统资源必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令Ring0，调用一切系统资源</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p>
<ul>
<li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
</li>
<li><p><strong>常见的IO模型</strong></p>
<ul>
<li><p><strong>&#x3D;&#x3D;阻塞IO&#x3D;&#x3D;</strong></p>
<p>阻塞IO就是两个阶段都必须阻塞等待：<br><strong>阶段一：</strong></p>
<ul>
<li>用户进程尝试读取数据(网卡数据等)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>此时用户进程也处于阻塞状态</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li>数据到达并拷贝到内核缓冲区，代表已就绪</li>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>非阻塞</strong>IO&#x3D;&#x3D;</p>
<p><strong>阶段一</strong>：</p>
<ul>
<li>用户进程尝试读取数据(比如网卡数据)</li>
<li>此时数据尚未到达，内核需要等待数据</li>
<li>返回异常给用户进程</li>
<li>用户进程拿到error后，再次尝试读取</li>
<li>循环往复，直到数据就绪</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>将内核数据拷贝到用户缓冲区</li>
<li>拷贝过程中，用户进程依然阻塞等待</li>
<li>拷贝完成，用户进程解除阻塞，处理数据</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;IO<strong>多路复用</strong>&#x3D;&#x3D;</p>
<p>是利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><strong>IO多路复用</strong>是利用单个线程来同步监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现</p>
<ul>
<li><strong>select</strong></li>
<li><strong>poll</strong></li>
<li><strong>epoll</strong></li>
</ul>
<p><strong>差异:</strong><br>★ select和polI只会通知用户进程有Socket就绪，但不确定具体是哪个Socket，需要用户进程逐个历Socket来确认<br>★ epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间,</p>
<p><strong>阶段一</strong>:</p>
<ul>
<li>用户进程调用select，指定要监听的Socket集合</li>
<li>内核监听对应的多个socket</li>
<li>任意一个或多个sacket数据就绪则返回readable</li>
<li>此过程中用户进程阻塞</li>
</ul>
<p><strong>阶段二</strong>:</p>
<ul>
<li>用户进程找别就格的socket</li>
<li>依次调用recvfrom读取数据</li>
<li>内核将数据拷贝到用户空间</li>
<li>用户进程处理数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis网络模型</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9490d2cd8e67cb8fae7520ad15c0849821dbfac0/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png"></p>
<h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span></p>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、Skywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>那这个SQL语句执行很慢，如何分析呢？</strong></span></p>
<blockquote>
<p>可以采用MySQL自带的分析工具 <code>explain</code></p>
<ul>
<li>通过<strong>key</strong>和<strong>key_len</strong>检查是否命中了索引(索引本身存在是否有失效的情况)</li>
<li>通过type字段查看sql是否有进一步的优化空间，是否存在<strong>全索引扫描</strong>或<strong>全盘扫描</strong></li>
<li>通过<strong>extra</strong>建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询 → <strong><u>新增临时表的数据</u></strong></li>
<li>多表查询 → <strong><u>优化SQL语句结构</u></strong></li>
<li>表数据量过大查询 → <strong><u>添加索引</u></strong></li>
<li>深度分页查询</li>
</ul>
</blockquote>
<h5 id="一个SQL语句执行很慢，如何分析？"><a href="#一个SQL语句执行很慢，如何分析？" class="headerlink" title="一个SQL语句执行很慢，如何分析？"></a>一个SQL语句执行很慢，如何分析？</h5><p>可以采用<code>EXPLAIN</code>或者<code>DESC</code>命令获取MySQL如何执行SELECT语句的信息</p>
<pre><code class="mysql"># 直接在select语句之前加上关键字 explain/desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
</code></pre>
<blockquote>
<p>mysql &gt; explain select * from t_user where id &#x3D; ‘1’</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>t_user</td>
<td>NULL</td>
<td>const</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>98</td>
<td>const</td>
<td>1</td>
<td>100.00</td>
<td>NULL</td>
</tr>
</tbody></table>
<ul>
<li><strong>possible_key</strong>：当前sql可能会使用到的索引</li>
<li><strong>key：</strong>当前sql实际命中的索引     <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>key_len</strong>：<strong>索引占用的大小</strong>          <u>通过它俩查看是否可能会命中索引</u></li>
<li><strong>Extra</strong>：额外的优化建议 看是否走过覆盖索引或回表查询</li>
</ul>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; <strong>Using Index</strong></td>
<td>查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据</td>
</tr>
<tr>
<td>Using <strong>index condition</strong></td>
<td>查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<ul>
<li><strong>type：</strong>这条sql的<strong>连接的类型</strong>，性能由好到差为 <ul>
<li>NULL</li>
<li>system：查询系统中的表</li>
<li>const：根据主键查询</li>
<li>eq_ref：主键索引查询或唯一索引查询</li>
<li>ref：索引查询</li>
<li>range：范围查询</li>
<li>index：索引树扫描</li>
<li>all：全盘扫描</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>了解过索引吗？（什么是索引）</strong></span></p>
<blockquote>
<p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)，在数据之外，数据库系统还维护着满足特定查找算法的数据结构**(B+树)**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<ul>
<li>索引(index)是帮助MySQL高效获取数据的数据结构(有序)</li>
<li>提高数据检索的效率，降低数据库的IO成本(不需要全表扫描)</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;  B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：<u><strong>数据</strong>与</strong>索引</strong></u>放到一块，B+树的叶子节点保存了整行数据，有且只有一个</li>
<li><strong>非聚簇索引(二级索引)<strong>：<u><strong>数据</strong>与</strong>索引</strong></u>分开存储，B+树的叶子节点保存对应的主键，可以有多个</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<h3 id="聚集索引和非聚集索引的具体区别"><a href="#聚集索引和非聚集索引的具体区别" class="headerlink" title="聚集索引和非聚集索引的具体区别"></a>聚集索引和非聚集索引的具体区别</h3><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">聚集索引</th>
<th align="left">非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储方式</strong></td>
<td align="left">数据与索引存储在一起，叶子节点存储整行数据。</td>
<td align="left">数据与索引分开存储，叶子节点存储指针或主键值。</td>
</tr>
<tr>
<td align="left"><strong>物理排序</strong></td>
<td align="left">数据按索引键的顺序物理排序。</td>
<td align="left">数据的物理顺序与索引无关。</td>
</tr>
<tr>
<td align="left"><strong>索引数量</strong></td>
<td align="left">一个表只能有一个聚集索引。</td>
<td align="left">一个表可以有多个非聚集索引。</td>
</tr>
<tr>
<td align="left"><strong>查询性能</strong></td>
<td align="left">查询效率高，尤其是范围查询和排序操作。</td>
<td align="left">查询效率相对较低，可能需要“回表”操作。</td>
</tr>
<tr>
<td align="left"><strong>更新操作影响</strong></td>
<td align="left">插入、删除或更新数据可能需要重新排序。</td>
<td align="left">更新操作影响较小，仅修改索引和指针。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">范围查询、排序、分组等操作频繁的列。</td>
<td align="left">查询条件筛选、快速定位数据的列。</td>
</tr>
</tbody></table>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<p><span style = "color:red"><strong>知道什么叫覆盖索引吗？</strong></span></p>
<blockquote>
<p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p>
<ul>
<li>使用id查询，直接走聚集索引查询，一次索引描述，直接返回数据，性能高</li>
<li>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用 **select *** <del>[除非用的聚簇索引(主键)]</del></li>
</ul>
</blockquote>
<p>&#x3D;&#x3D;<strong>覆盖索引</strong>&#x3D;&#x3D;是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p>
<table>
<thead>
<tr>
<th align="center"><span style = "color:red">id</span></th>
<th align="center"><span style = "color:red">name</span></th>
<th align="center">gender</th>
<th align="center">createdate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">Arm</td>
<td align="center">1</td>
<td align="center">2021-01-01</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Lily</td>
<td align="center">0</td>
<td align="center">2021-05-04</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Rose</td>
<td align="center">0</td>
<td align="center">2021-04-21</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Zoo</td>
<td align="center">1</td>
<td align="center">2021-07-31</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Doc</td>
<td align="center">1</td>
<td align="center">2021-02-26</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">Lee</td>
<td align="center">1</td>
<td align="center">2021-09-11</td>
</tr>
</tbody></table>
<ul>
<li><strong>id为主键，默认是主键索引</strong></li>
<li><strong>name字段为普通索引</strong></li>
</ul>
<pre><code class="mysql">select * from tb_user where id = 1;                     【覆盖索引】
select id, name from tb_user where name = &#39;Arm&#39;         【覆盖索引】
select id, name, gender from tb_user where name = &#39;Arm&#39; 【非覆盖索引】(需要回表查询)
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9b20975f94b299a861457b2214bd985ff4b2625d/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.jpg"></p>
<p><span style = "color:red"><strong>MySQL超大分页怎么处理？</strong></span></p>
<blockquote>
<p>问题：再数据量比较大时，limit分页查询，需要对数据进行排序，效率低<br><strong>解决方案：</strong>可以用<strong>覆盖索引</strong> + <strong>子查询</strong>处理<br>[我们先分页查询获取表中的id 并且对表的id进行排序 就能筛选出分页后的id集合(因为id是覆盖索引效率高)  最后再根据id集合到原来的表中做关联查询就可以得到提升了]</p>
</blockquote>
<p>在数据量比较大时，如果用limit分页查询，在查询时，越往后，分页查询效率越低</p>
<pre><code class="mysql">mysql &gt; select * from tb_sku limit 0,10;
10 rows in set (0.00 sec)

mysql &gt; select * from tb_sku limit 9000000,10;
10 rows in set (11.05 sec)
</code></pre>
<p>因为，当在进行分页查询时，如果执行 limit  9000000,10，此时需要MySQL排序前9000010记录，仅仅返回9000000 - 9000010 的记录，其他记录丢失，查询排序的代价非常大。</p>
<p>&#x3D;&#x3D;<strong>MySQL超大分页查询优化思路</strong>&#x3D;&#x3D;：一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化</p>
<pre><code class="mysql"># 超大分页处理：先通过覆盖索引找到符合条件的id，再通过这个id的覆盖索引查询到所有的列
select * 
from tb_sku t,
(select id from tb_sku order by id limit 9000000,10) a
where t.id = a.id

# 10 rows in set (7.15 sec)
</code></pre>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong><br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><br>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<h6 id="创建索引的方式1"><a href="#创建索引的方式1" class="headerlink" title="创建索引的方式1"></a>创建索引的方式1</h6><pre><code class="mysql">① SQL的方式
ALTER TABLE user_innodb ADD INDEX idx_name(name)

② 在建表的时候 去指定索引
...
PRIMARY KEY(&#39;id&#39;),
KEY &#39;idx_name&#39; (&#39;name&#39;) USING HASH

③ 通过界面化工具去指定索引
字段旁边有个`索引` 可以去添加

=============================================
单个字段的索引 → 单列索引
多个字段的索引 → 联合索引
</code></pre>
<h6 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h6><p><u>索引可以增加查询速度 同时也增加了更新&#x2F;修改速度</u><del>因为更新的第一步就是查询</del></p>
<blockquote>
<p>① <strong>普通索引</strong>   经过特殊设计的数据结构<br>② <strong>唯一索引</strong>   唯一约束<br>[索引必须是唯一的 比如name就不行 因为名字可以很多建立普通索引]<br>③ <strong>主键索引</strong>   在主键索引上添加了<strong>非空约束</strong><br>④ <strong>全文索引</strong>   一般使用搜索引擎，因为对中文的搜索不太友好<del>美国英文开发的</del><br>[特殊的sql：select * from 表名 where match(字段名) against(‘马士兵教育’ IN NATURAL LANGUAGE MODE);]</p>
<p>AVL树 右右型左旋 <strong><u>左子树与右子树的深度差绝对值不超过1</u></strong><br>树的节点里应该放：<strong>键值</strong>+<strong>Value值</strong>+<strong>左右子树的地址</strong><del>left+right</del><br>Innodb一次会加载16k(<u>16384字节&#x3D;Redis的槽位</u>) 内存到内存<br>不选红黑树是因为它是二叉的，我们需要多叉树<br>要用&#x3D;&#x3D;<strong>B+树</strong>&#x3D;&#x3D;全盘扫描能力更强 叶子节点是双向链表<br>因为稳定性比较好  B树非所见所得 B+树是稳定几层的查找数据<del>因为数据都在最后一层叶子节点上</del><br>Innodb的索引方法是BTREE 不能改成HASH</p>
</blockquote>
<p>**<u><span style = "color:red">数据结构可视化网</span></u>**：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a></p>
<ul>
<li>针对数据量较大，且查询比较频繁的表建立索引。<strong>单表超过10万数据(增加用户体验)</strong></li>
<li>针对常作为<strong>查询条件(where)、排序(order by)、分组(group by)</strong> 操作的字段建立索引</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 (比如address都在北京市)</li>
<li>如果是字符串类型的字段，字段的长度越长(描述信息…)，可以针对于字段的特点，建立前缀索引</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引(避免回表)，节省存储空间，提高查询效率</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ul>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加<strong>单引号</strong>，造成索引失效。(类型转换)</li>
<li>以**%开头的Like模糊查询**，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><strong>怎么哪块读判断索引是否失效了呢</strong>？</p>
<pre><code class="mysql"># 执行计划explain
</code></pre>
<p>【2024最新版MySQL索引讲解！一个视频带你彻底搞懂MySQL索引！！【马士兵】】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3">https://www.bilibili.com/video/BV17z421i7Kb?vd_source=5966d6c3cf3709c10b3c53b278b0f4d3</a></p>
<p><strong>什么情况下索引会失效？</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。匹配最左前缀法则，走索引：<br><img src="https://github.com/P-luminary/images/blob/master/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png?raw=true" style="zoom:80%;" /></p>
<p><span style = "color:red"><strong>谈谈你对sql的优化经验？</strong></span></p>
<blockquote>
<ul>
<li>表的设计优化，数据类型的选择</li>
<li>索引优化，索引创建原则</li>
<li>sql语句优化，避免索引失效，避免使用select</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ul>
</blockquote>
<ul>
<li><p>表的设计优化(<strong>参考阿里开发手册《嵩山版》</strong>)</p>
<ul>
<li>比如设置合适的数值(tinyint、int、bigint) ，要根据实际情况选择</li>
<li>比如设置合适的字符串类型(char和varchar) char定长效率高，varchar可变长度，效率低</li>
</ul>
<blockquote>
<p>候选人: 这个我们主要参考的阿里出的那个开发手册《嵩山版》，就比如，在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型</p>
</blockquote>
</li>
<li><p><strong>索引优化</strong>(参考优化创建原则和索引失效)</p>
</li>
<li><p><strong>SQL语句优化</strong></p>
<ul>
<li><p>SELECT语句务必<strong>指明字段名称</strong> (避免直使用select *)<del>回表</del></p>
</li>
<li><p>SQL语句要<strong>避免造成索引失效</strong>的写法</p>
</li>
<li><p>尽量使用<strong>union all</strong>代替union，union(不会重复)会多一次过滤, 效率低</p>
<pre><code class="mysql">select * from t_user where id &gt; 2
union all | union
select * from t_user where id &lt; 5
</code></pre>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
</li>
<li><p>join优化 能用<strong>inner join</strong> 就不用left join,  right 如必须使用 一定要以小表为驱动；内链接会对两个表进行优化，<strong>优先把小表放到外边，把大表放到里边</strong>。left join 或 right  join，不会重新调整顺序</p>
<pre><code class="java">for(int i = 0; i &lt; 3; i++)&#123; //只链接查询3次
 for(int j = 0; j &lt; 1000; j++)&#123;

 &#125;  
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>主从复制、读写分离</strong>(在生产环境下一般会搭建主库和从库 分开读操作和写操作)</p>
<p>如果数据库的使用场景读的操作比较多的时候，为了避免写的操作所造成的性能影响 可以采用读写分离的架构。读写分离解决的是，<strong>数据库的写入</strong>，影响了查询的效率。[Master(写) 和 Slave(读)]</p>
</li>
<li><p><strong>分库分表(后面有介绍)</strong></p>
</li>
</ul>
<p><span style = "color:red"><strong>事务的特性是什么？可以详细的说一下吗？</strong></span>【ACID】</p>
<blockquote>
<p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>候选人：嗯，这个比较清楚，ACID，分别指的是:原子性、一致性、隔离性、持久性;<br><strong>我举个例子</strong>：A向B转账500，转账成功，A扣除500元，B增加500元。<br><strong>原子性</strong>操作体现在<u>要么都成功，要么都失败</u>。<br>在转账的过程中，数据要<strong>一致性</strong>，A扣除了500，B必须增加500<br>在转账的过程中，<strong>隔离性</strong>体现在A像B转账，不能受其他事务干扰<br>在转账的过程中，<strong>持久性</strong>体现在事务提交后，要把数据持久化(可以说是落盘操作)</p>
</blockquote>
<ul>
<li>**原子性(**Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性</strong>(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性</strong>(lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境运行</li>
<li><strong>持久性</strong>(Durabiity)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><span style = "color:red"><strong>并发事务带来哪些问题？怎么解决这些问题？MySQL默认隔离级别是？</strong></span></p>
<blockquote>
<ul>
<li>&#x3D;&#x3D;<strong>并发事务问题</strong>&#x3D;&#x3D;：脏读、不可重复读、幻读</li>
<li>&#x3D;&#x3D;<strong>隔离级别</strong>&#x3D;&#x3D;：读未提交、读已提交、<strong>可重复读</strong>、串行化</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据</td>
</tr>
<tr>
<td align="center">不可重复读</td>
<td>一个事务先后读取同一条事务，但两次读取的数据不同，称之为不可重复读</td>
</tr>
<tr>
<td align="center">幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，这同时另一个事务B(insert且commit)了事务，此时事务A在插入数据时候，又发现这行数据已经存在了，好像出现了”幻影“</td>
</tr>
</tbody></table>
<h6 id="怎么解决并发事务的问题呢？？"><a href="#怎么解决并发事务的问题呢？？" class="headerlink" title="怎么解决并发事务的问题呢？？"></a>怎么解决并发事务的问题呢？？</h6><p><strong>对事务进行隔离</strong> (× 是代表可以解决此问题)</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Read uncommitted 未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Read committed 读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;<strong>Repeatable Read(默认) 可重复读</strong>&#x3D;&#x3D;</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Serializable 串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>注意：**<u>事务隔离级别越高，数据越安全，但是性能越低</u>**</p>
<p><span style = "color:red"><strong>数据库的undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是<strong>数据页的物理变化</strong>，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是<strong>逻辑日志</strong>，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undolog保证了事务的原子性和一致性</p>
</blockquote>
<p><code>redo log</code> 和 <code>undo log</code> 是 InnoDB 为了实现事务的 <strong>原子性</strong> 和 <strong>持久性</strong> 而设计的两种日志机制：</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>作用</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>redo log</strong></td>
<td>崩溃<strong>恢复</strong>，重做操作（实现<strong>持久性</strong>）【恢复】</td>
<td>保存键 Ctrl+S</td>
</tr>
<tr>
<td><strong>undo log</strong></td>
<td><strong>回滚</strong>事务，撤销操作（实现<strong>原子性</strong>）【撤销】</td>
<td>撤销键 Ctrl+Z</td>
</tr>
</tbody></table>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>假设你执行一条 SQL：</p>
<pre><code>UPDATE account SET balance = balance - 100 WHERE id = 1;
</code></pre>
<p>InnoDB 的执行顺序是：</p>
<ol>
<li>写入 <strong>undo log</strong>（记录原值，便于回滚） ✅</li>
<li>修改内存中的数据（Buffer Pool）✅</li>
<li>写入 <strong>redo log</strong>（记录新的值，崩溃后可重做）✅</li>
<li>提交事务时将 <strong>redo log 落盘（刷到磁盘）</strong></li>
</ol>
<h5 id="🔄-崩溃恢复时如何用它们？"><a href="#🔄-崩溃恢复时如何用它们？" class="headerlink" title="🔄 崩溃恢复时如何用它们？"></a>🔄 崩溃恢复时如何用它们？</h5><ul>
<li>💥 <strong>宕机恢复（crash recovery）时</strong>，MySQL 会用 <code>redo log</code> 把“<strong>已提交但还没写到磁盘的数据</strong>”重做一遍，确保数据不丢失（持久性）。</li>
<li>❌ <strong>事务失败或回滚时</strong>，MySQL 用 <code>undo log</code> 把数据恢复到修改之前的样子，确保事务“要么全做，要么全不做”（原子性）。</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p><strong>重做日志</strong>，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p><strong>回滚日志</strong>，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>**<u>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录</u>**，反之亦然</li>
<li><u>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</u></li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
<p><span style = "color:red"><strong>事务中的隔离性是如何保证的呢？</strong></span></p>
<p>事务的隔离性主要是通过<strong>锁机制</strong>和 <strong>MVCC（多版本并发控制）</strong> 来实现的。</p>
<p><strong>对于更新操作 (写)<strong>，MySQL 会使用加锁机制，比如行级锁中的</strong>排他锁（X锁）</strong>来避免并发写冲突；<br><strong>对于查询操作 (读)<strong>，MySQL 使用 <strong>MVCC</strong> 来避免加锁带来的性能开销，从而支持高并发读操作。<br><strong>MVCC</strong> 的核心思想是：</strong>为同一条数据维护多个版本</strong>，从而实现 “读写不冲突、并发更高效”。</p>
<blockquote>
<p>排他锁 (如果一个事务获取到了一个数据行的排他锁，其他事务就不能再获取该行的其他锁)<br>mvcc: 多版本并发控制  让MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突<br><strong>隐藏字段</strong>:<br>每一行数据都会有两个隐藏字段<br>① trx _id(事务id)，记录每一次操作的事务id，是自增的 [当前这条记录是由哪个事务创建的（事务ID）]<br>② roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址（形成一个版本链）</p>
<p><strong>undo log</strong>:<br>① 回滚日志，存储老版本数据<br>② 版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过rollpointer指针形成一个链表</p>
<p><strong>readView</strong>：解决的是一个事务查询选择版本的问题<br>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据》不同的隔离级别快照读是不一样的，最终的访问的结果不一样RC:每一次执行快照读时生成ReadView<br>RR:仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
</blockquote>
<blockquote>
<p><strong>面试官</strong>: 事务中的隔离性是如何保证的呢?(你解释一下MVCC)<br><strong>候选人</strong>: 事务的隔离性是由锁和mvcc实现的。<br>其中mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是<u>隐藏字段</u>，第二个是<u>undolog日志</u>，第三个是<u>readView读视图</u><br>隐藏字段是指:在mysq!中给每个表都设置了隐藏字段，有一个是x_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll-pointer(回滚指针)，指向上一个版本的事务版本记录地址<br>undolog主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行探作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表<br>readview解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是r隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p>
<blockquote>
<h2 id="MVCC底层的三个关键机制"><a href="#MVCC底层的三个关键机制" class="headerlink" title="MVCC底层的三个关键机制"></a>MVCC底层的三个关键机制</h2><h3 id="🔹-1-隐藏字段"><a href="#🔹-1-隐藏字段" class="headerlink" title="🔹 1. 隐藏字段"></a>🔹 1. <strong>隐藏字段</strong></h3><p>每一行数据都会有两个隐藏字段：</p>
<ul>
<li><code>trx_id</code>：当前这条记录是由哪个事务创建的（事务ID）</li>
<li><code>roll_pointer</code>：回滚指针，指向这条记录的上一个版本（形成一个版本链）</li>
</ul>
<hr>
<h3 id="🔹-2-undo-log（回滚日志）"><a href="#🔹-2-undo-log（回滚日志）" class="headerlink" title="🔹 2. undo log（回滚日志）"></a>🔹 2. <strong>undo log（回滚日志）</strong></h3><ul>
<li>当事务对数据进行修改时，会记录修改前的旧数据到 <code>undo log</code></li>
<li>所有旧版本数据通过 <code>roll_pointer</code> 串成一个“版本链”</li>
<li>查询时可以根据版本选择合适的数据版本，从而“读老数据”</li>
</ul>
<hr>
<h3 id="🔹-3-ReadView（读视图）"><a href="#🔹-3-ReadView（读视图）" class="headerlink" title="🔹 3. ReadView（读视图）"></a>🔹 3. <strong>ReadView（读视图）</strong></h3><ul>
<li>在执行快照读时，InnoDB 会生成一个 <strong>ReadView</strong></li>
<li>它记录了当前活跃的事务ID列表，以及当前事务的ID</li>
<li>查询时，会根据 ReadView 判断：这条记录版本是否“可见”</li>
</ul>
</blockquote>
<p>总的来说，<strong>写操作靠加锁，读操作靠 MVCC</strong>。MVCC 通过维护多个版本的数据 + ReadView 机制，让不同事务之间在查询时互不干扰，从而保证隔离性，同时提升并发性能。</p>
<p>🔐 写用锁、📚 读用 MVCC，🔁 多版本 + 🔍 读视图 + 🧾 回滚日志，性能高，隔离强！</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下MVCC？</strong></span></p>
<p>全程 <strong>Multi-Version Concurrency Control</strong>，<u>多版本并发控制</u>。指维护一个数据的多个版本，使得读写操作没有冲突</p>
<h6 id="问题的来源：-橙色的-查询的是哪个事务版本的记录？"><a href="#问题的来源：-橙色的-查询的是哪个事务版本的记录？" class="headerlink" title="问题的来源：(橙色的)查询的是哪个事务版本的记录？"></a>问题的来源：(橙色的)查询的是哪个事务版本的记录？</h6><table>
<thead>
<tr>
<th align="center">事务2</th>
<th align="center">事务3</th>
<th align="center">事务4</th>
<th align="center">事务5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
<td align="center">开始事务</td>
</tr>
<tr>
<td align="center">修改id为30记录, age改为3</td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">修改id为30记录, name改为A3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提交文件</td>
<td align="center">修改id为30的记录, age改为10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">查询id为30的记录</td>
<td align="center"><span style = "color:orange"><strong>查询id为30的记录</strong></span></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
</tbody></table>
<h6 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC-实现原理"></a>MVCC-实现原理</h6><ul>
<li><strong>记录中的隐藏字段</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">age</th>
<th align="center">name</th>
<th align="center">DB_TRX_ID</th>
<th align="center">DB_ROLL_PTR</th>
<th align="center">DB_ROW_ID</th>
</tr>
</thead>
</table>
<ul>
<li><strong>DB_TRX_ID</strong>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，指向这条记录的上一个版本，用于<strong>配合undo log</strong>, 指向上一个版本</li>
<li><strong>DB_ROW_ID</strong>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</li>
</ul>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><ul>
<li>回滚日志，在<strong>insert、update、delete</strong>的时候产生的便于数据回滚的日志<del>相反的语句</del>。</li>
<li>当insert的时候，产生的undolog日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，mvcc版本访问也需要，不会立即被删除。</li>
</ul>
<h6 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h6><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，<strong>链表的头部是最新的旧记录，链表尾部是最早的旧记录</strong></p>
<ul>
<li><strong>readview</strong></li>
</ul>
<p>ReadView(读视图) 是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id</p>
<p>ReadView中包含了四个核心字段</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_ids</td>
<td align="center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td align="center">min_trx_id</td>
<td align="center">最小活跃事务ID</td>
</tr>
<tr>
<td align="center">max_trx_id</td>
<td align="center">预分配事务ID, 当前最大事务ID+1 (事务ID是自增的)</td>
</tr>
<tr>
<td align="center">creator_trx_id</td>
<td align="center">ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<ul>
<li><strong>当前读</strong></li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select .. lock in share mode(共享锁)，select .. for update、update、insert、delete(排他锁)都是一种当前读。</p>
<ul>
<li><strong>快照读</strong></li>
</ul>
<p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。<br><strong>Read Committed</strong>：每次select，都生成一个快照读。<br><strong>Repeatable Read</strong>：开启事务后第一个select语句才是快照读的地方。</p>
<p><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></p>
<p><code>主从同步就是主库把所有数据修改写到日志文件（Binlog）里，从库再去“抄作业”——读日志，写自己，中继日志相当于中转站，最终把主库的修改同步过来。</code></p>
<blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 <strong>Binlog</strong> 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 <strong>Relay Log</strong>。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<hr>
<blockquote>
<p>MySQL 主从同步分三步：</p>
<ul>
<li>写日志：主库提交事务 → 写 Binlog</li>
<li>拉日志：从库 I&#x2F;O 线程拉取 Binlog → 写 Relay Log</li>
<li>执行日志：从库 SQL 线程执行 Relay Log → 同步数据</li>
</ul>
</blockquote>
<blockquote>
<p>整个过程就是：<strong>主库写 → 从库拉 → 从库执行</strong></p>
</blockquote>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<pre><code class="text">       +---------------------+
       |      Master 主库     |
       | 写 Binlog（记录变更） |
       +---------------------+
                  ↓
       [ I/O 线程拉取 Binlog ]
                  ↓
       +---------------------+
       |      Slave 从库      |
       | 写 Relay Log（中继） |
       | 执行日志 → 同步数据  |
       +---------------------+
</code></pre>
<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<p><span style = "color:red"><strong>你们项目用过分库分表吗？</strong></span></p>
<blockquote>
<p>是的，我们项目在业务数据达到一定规模后使用了分库分表策略。<br>具体来说，我们在做【举个真实业务：比如订单系统、日志存储系统、会员行为分析系统】时，由于单表数据量突破了 <strong>1000W+<strong>，单表容量超过 <strong>20GB</strong>，查询响应变慢，索引命中率降低，磁盘和网络 I&#x2F;O 成为瓶颈。<br>一开始我们尝试通过</strong>主从读写分离、加索引、缓存优化</strong>等方式缓解，但效果有限，最终采用了分库分表来从根本上解决性能问题。</p>
</blockquote>
<blockquote>
<ul>
<li><p>业务介绍<br>1，根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)<br>2，达到了什么样的量级(单表1000万或超过20G)</p>
</li>
<li><p>具体拆分策略<br>1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题<br>2，水平分表，解决单表存储和性能的问题<br>3，垂直分库，根据业务进行拆分，高并发下提高磁盘I0和网络连接数<br>4，垂直分表，冷热数据分离，多表互不影响</p>
</li>
</ul>
</blockquote>
<p><strong>分担了访问压力、解决存储压力</strong></p>
<p>分库分表的时机：</p>
<p>① <strong>前提</strong>：项目业务数据逐渐增多，业务发展比较迅速【单表数据量达1000W或20G以后】<br>② 优化解决不了性能问题(主从读写分离、查询索引)<br>③ <strong>IO瓶颈</strong>(磁盘IO、网络IO)、<strong>CPU瓶颈</strong>(聚合查询、连接数太多)</p>
<p><strong>拆分策略</strong>【垂直 ≈ 微服务、水平 ≈ 分配数值】</p>
<ul>
<li>&#x3D;&#x3D;<strong>垂直拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中<br>(特点：按业务对数据分级管理、维护、监控、扩展；在高并发下，提高磁盘IO和数据量连接数)<ul>
<li>tb_user → 用户微服务 </li>
<li>tb_order → 订单微服务</li>
<li>tb_sku → 商品微服务</li>
</ul>
</li>
<li><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中<br>(把不常用的字段单独放在一张表；把<strong>text, blob</strong>等大字段[描述]拆分出来放在附表中)<br>(特点：冷热数据分离、减少IO过渡争抢，两表互不影响)</li>
</ul>
</li>
<li>&#x3D;&#x3D;<strong>水平拆分</strong>&#x3D;&#x3D;<ul>
<li><strong>水平分库</strong>：将一个库的数据拆分到多个库中<br>(解决了单库大数量，高并发的性能瓶颈问题；提高了系统的稳定性和可用性)<br><u>路由规则</u><ul>
<li>根据id节点取模</li>
<li>按id也就是范围路由，节点1(1-100万)，节点2(100万-200万)</li>
</ul>
</li>
<li><strong>水平分表</strong>：将一个库的数据拆分到多个表中(可以在同一个库内)<br>(优化单一表数据量过大而产生的性能问题；避免IO争抢并减少锁表的几率)</li>
</ul>
</li>
</ul>
<h6 id="分库后的问题：↓↓"><a href="#分库后的问题：↓↓" class="headerlink" title="分库后的问题：↓↓"></a>分库后的问题：↓↓</h6><ul>
<li>分布式事务一致性问题</li>
<li>跨节点关联查询</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h6 id="使用分库分表中间件"><a href="#使用分库分表中间件" class="headerlink" title="使用分库分表中间件"></a>使用分库分表中间件</h6><ul>
<li><span style = "color:blue"><strong>sharding-sphere</strong></span></li>
<li><span style = "color:blue"><strong>mycat</strong></span></li>
</ul>
<p><span style = "color:red"><strong>Spring框架中的单例bean是线程安全的吗？</strong></span></p>
<blockquote>
<p>不是线程安全的，是这样的</p>
<p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑(成员方法)，如果该处理逻辑中有对该单列状态的修改(体现为该单例的成员属性)，则必须考虑线程同步问题。</p>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。<br>比如:我们通常在项目中使用的Springbean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p>
<p>如果你的bean有多种状态的话(比如 View Model对象)，就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“singleton”变更为“prototype”。</p>
</blockquote>
<blockquote>
<p>Spring框架中的bean是单例的</p>
<pre><code class="java">@Service
@Scope(&quot;singleton&quot;)
public class UserServiceImpl implements UserService&#123;

&#125;
</code></pre>
<ul>
<li><strong>singleton</strong>：bean在每个Spring IOC容器中只有一个实例</li>
<li><strong>prototype：</strong>一个bean的定义可以有多个实例</li>
</ul>
<p>Spring bean并没有可变的状态(比如Service类和DAO类), 所以在某种程度上说Spring的单例bean是线程安全的。但要尽可能的少创造可变参数比如count</p>
<pre><code class="java">@Controller
@RequeestMapping(&quot;/user&quot;)
public class UserController&#123;
    private int count; //成员方法需要考虑线程安全问题

    @Autowired
    private UserService userService;

    @GetMapping(&quot;/getById/&#123;id&#125;&quot;)
    public User getById(@PathVariable(&quot;id&quot;) Integer id)&#123;
        count++;
        sout(count);
        return userService.getById(id);
    &#125;
&#125;
</code></pre>
</blockquote>
<blockquote>
<ol>
<li><strong>单例Bean就像共享单车</strong>：<ul>
<li>整个小区（Spring容器）只有一辆共享单车（单例Bean），所有居民（线程）都要轮流骑这辆车。</li>
<li>如果只是骑车（调用无状态方法），不会出问题。</li>
<li>但如果有人在车筐里放东西（修改成员变量），下个人可能就会看到&#x2F;改动这些东西。</li>
</ul>
</li>
<li><strong>什么时候安全？</strong><ul>
<li>比如Service、DAO这类Bean，它们通常只干活不记账（没有成员变量），就像只提供骑行服务的单车，很安全。</li>
<li>这也是为什么我们平时用@Autowired注入的Service不会出问题。</li>
</ul>
</li>
<li><strong>什么时候危险？</strong><ul>
<li>如果Bean里有个计数器count（就像你代码里的例子），多个线程同时”+1”就会乱套。</li>
<li>就像多个人同时往单车筐里放苹果，最后苹果数量肯定对不上。</li>
</ul>
</li>
<li><strong>怎么解决？</strong><ul>
<li>方法一：不记账 → 永远不在Bean里放成员变量（推荐）</li>
<li>方法二：用锁 → 像公共厕所那样，一个人用的时候锁门（加synchronized）</li>
<li>方法三：每人发一辆车 → 改用@Scope(“prototype”)，每次请求都新建Bean（但浪费资源）</li>
</ul>
</li>
<li><strong>实际开发建议</strong>：<ul>
<li>大多数情况下，Service&#x2F;Dao写成单例完全没问题</li>
<li>遇到要记录状态的场景（比如计数器），要么改成prototype，要么把变量存在ThreadLocal里</li>
<li>绝对不要在Controller里定义成员变量！你代码里的count就是个典型反例</li>
</ul>
</li>
</ol>
<p>简单说：单例Bean本身不是线程安全的，但只要我们遵守”不用成员变量记事情”的原则，就能安全使用。就像共享单车，只要大家都不往车筐里放私人物品，就不会有问题。</p>
</blockquote>
<p><span style = "color:red"><strong>什么是AOP，你们项目中有没有用到AOP？</strong></span></p>
<p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”(Aspect)，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<h6 id="常见AOP使用场景："><a href="#常见AOP使用场景：" class="headerlink" title="常见AOP使用场景："></a>常见AOP使用场景：</h6><ul>
<li><p><strong>拒绝策略记录操作日志</strong></p>
<blockquote>
<p>nginx → 新增用户 → @Around(“pointcut()”) <u><strong>环绕通知</strong></u></p>
</blockquote>
</li>
<li><p><strong>缓存处理</strong></p>
</li>
<li><p><strong>Spring中内置的事务处理</strong></p>
</li>
</ul>
<p><strong>Spring中的事务是如何实现的</strong><br><span style = "color:blue"><u>Spring支持 <strong>编程式事务管理</strong> 和 <strong>声明式事务</strong> 管理两种方式</u></span>。</p>
<ul>
<li><strong>编程式事务控制</strong>：需使用TransactionTemplate来进行实现，对业务代码有侵入性，项目中很少使用</li>
<li><strong>声明式事务管理</strong>：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li>
</ul>
<blockquote>
<p>AOP（面向切面编程）可以理解为 <strong>“在不修改原有代码的情况下，给程序动态添加功能”</strong>。</p>
<h5 id="生活中的例子："><a href="#生活中的例子：" class="headerlink" title="生活中的例子："></a><strong>生活中的例子：</strong></h5><ul>
<li>假设你开了一家咖啡店，主要业务是 <strong>做咖啡</strong>（核心业务）。</li>
<li>但除了做咖啡，你还要 <strong>记录销售日志、检查权限、处理异常</strong>（如咖啡机坏了）等（<strong>横切关注点</strong>）。</li>
<li>如果用传统OOP（面向对象编程），你需要在每个做咖啡的方法里都写日志、权限检查代码，这样代码会变得臃肿且难以维护。</li>
<li>而AOP的做法是：<strong>把这些公共逻辑（如日志、权限）抽出来，做成一个“切面”</strong>，然后“织入”到需要的地方，<strong>不影响原有业务代码</strong>。</li>
</ul>
<hr>
<h5 id="AOP的核心概念"><a href="#AOP的核心概念" class="headerlink" title="AOP的核心概念"></a><strong>AOP的核心概念</strong></h5><ol>
<li><strong>切面（Aspect）</strong>：封装横切逻辑的模块（比如日志、事务）。</li>
<li><strong>连接点（Join Point）</strong>：程序执行的点（如方法调用、异常抛出）。</li>
<li><strong>通知（Advice）</strong>：切面在连接点执行的动作（如方法执行前、后、异常时做什么）。</li>
<li><strong>切点（Pointcut）</strong>：定义哪些连接点会被切面影响（如“所有Service层的方法”）。</li>
<li><strong>织入（Weaving）</strong>：把切面应用到目标对象的过程（编译期、类加载期、运行时）。</li>
</ol>
</blockquote>
<p><span style = "color:red"><strong>Spring中事务失效的场景有哪些？</strong></span></p>
<blockquote>
<p>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出<br>抛出检查异常，配置rollbackFor属性为Exception<br>非public方法导致的事务失效，改为public</p>
</blockquote>
<p>考察对spring框架的深入理解、复杂业务的编码经验</p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>异常捕获处理</strong>&#x3D;&#x3D;【异常被try-catch吃掉】</p>
<p><strong>原因</strong>：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉【Spring 的事务是基于 AOP 的，只有方法抛出异常，事务管理器才能感知并触发回滚；你在方法内部 <code>try-catch</code> 了异常，但没有再往外抛，就会导致事务<strong>不能回滚</strong>】</p>
<p><strong>解决</strong>：<u>在catch块添加throw new RuntimeException(“转账失败”)</u> 抛出</p>
</li>
<li><p>&#x3D;&#x3D;<strong>抛出检查异常</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring 默认只对 非检查异常（RuntimeException 及其子类）、 进行回滚</p>
<pre><code class="java">@Transactional
public void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>解决：</strong>配置<code>rollbackFor</code>属性</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
</code></pre>
</li>
<li><p>&#x3D;&#x3D;<strong>非public方法</strong>&#x3D;&#x3D;<br>Spring 的事务本质是基于 AOP 代理实现的，而 AOP 默认只对 <code>public</code> 方法生效。</p>
<pre><code class="java">@Transcational(rollbackFor=Exception.class)
void update(...) throw FileNotFoundException&#123;
    ...
    new FileInputStream(&quot;dddd&quot;)
    ...
&#125;
</code></pre>
<p><strong>原因：</strong>Spring为方法创建代理、添加事务通知、<u>前提条件都是该方法是<strong>public</strong>的</u><br><strong>解决：</strong>把方法改为<code>public</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>同类内部调用，导致代理失效</strong>&#x3D;&#x3D;</p>
<p><strong>原因</strong>：Spring AOP 基于代理机制。如果类内部方法调用类内的另一个 <code>@Transactional</code> 方法，实际上不会经过代理，事务不会生效。</p>
<pre><code class="java">// ❌ 会失效
public void methodA() &#123;
    methodB(); // 不经过代理
&#125;
  
@Transactional
public void methodB() &#123;
    // 无效
&#125;
</code></pre>
<ul>
<li><strong>解决</strong>：<ul>
<li>将方法调用抽出到另一个 bean 中；</li>
<li>或使用 <code>AopContext.currentProxy()</code> 获取当前代理对象执行调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>Spring的bean的生命周期？</strong></span></p>
<blockquote>
<p>Spring容器是如何管理和创建bean实例<br>方便调试和解决问题</p>
<p>① 通过BeanDefinition获取bean的定义信息 [Spring 会将 XML 或注解配置的 Bean 信息封装成 <code>BeanDefinition</code> 对象，用于描述 Bean 的元数据信息，如 class 类型、作用域、是否懒加载等]<br>② 调用构造函数实例化bean [通过构造函数或工厂方法创建 Bean 对象，还没进行依赖注入]<br>③ bean的依赖注入 [Spring 根据 BeanDefinition 中的配置信息，进行依赖注入，例如通过 <code>@Autowired</code>、<code>@Resource</code> 等注解注入其它 Bean]<br>④ 处理Aware接囗回调(BeanNameAware、BeanFactoryAware、ApplicationContextAware)<br>⑤ Bean的后置处理器BeanPostProcessor-前置<br>⑥ 初始化方法(InitializingBean、init-method)<br>⑦ Bean的后置处理器BeanPostProcessor-后置<br>⑧ 销毁bean</p>
</blockquote>
<p><strong>BeanDefinition</strong></p>
<p>Spring容器在进行实例化时，会将xml配置的&lt; bean &gt;的信息封装成一个<strong>BeanDefinition</strong>对象，<u>Spring根据BeanDefinition来创建Bean对象，里面有很多的属性来描述Bean</u></p>
<pre><code class="java">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaolmpl&quot; lazy-init=&quot;true&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.UserServicelmpl&quot; scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><img src="https://github.com/P-luminary/images/blob/master/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png?raw=true"></p>
<p><span style = "color:red"><strong>Spring中的循环引用？</strong></span></p>
<blockquote>
<p>★ <strong>循环依赖</strong>：循环依赖其实就是循环引用, 也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A<br>★ 循环依赖在spring中是允许存在，spring框架**<u>依据三级缓存已经解决了大部分的循环依赖</u>**<br>☆ <strong>一级缓存</strong>：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象<br>☆ <strong>二级缓存</strong>：缓存早期的<strong>bean</strong>对象(生命周期还没走完)<br>☆ <strong>三级缓存</strong>：缓存的是<strong>ObjectFactory</strong>，表示对象工厂，用来创建某个对象的</p>
<h4 id="✅-处理流程简要说明："><a href="#✅-处理流程简要说明：" class="headerlink" title="✅ 处理流程简要说明："></a>✅ 处理流程简要说明：</h4><ol>
<li>Spring 创建 A → A 依赖 B → 创建 B</li>
<li>B 依赖 A，发现 A 还没完成创建</li>
<li>Spring 把 A 的 <strong>半成品（early reference）</strong> 暴露到二级缓存，让 B 先注入用</li>
<li>最后 A 初始化完成，加入一级缓存</li>
</ol>
<blockquote>
<p>✅ 这样就解决了大多数基于 <strong>setter 注入 &#x2F; 字段注入</strong> 的循环依赖问题。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>构造方法出现了循环依赖怎么解决？</strong></span></p>
<blockquote>
<p>A依赖于B，B依赖于A，注入的方式是<strong>构造函数</strong><br><strong>原因</strong>：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入<br><strong>解决方案</strong>：使用**@Lazy<strong>进行</strong>懒加载**，什么时候需要对象再进行bean对象的创建</p>
<p>public A(@Lazy B b){<br> sout(“A的构造方法执行了”);<br> this.b&#x3D;b;<br>}</p>
</blockquote>
<blockquote>
<p>@Component                                     @Component<br>public class A{          →      ←             public class B{<br>    @Autowired         ↑          ↑                 @Autowired<br>    private B b;       →↑          ↑←                private A a;<br>}                                                             } </p>
<h4 id="🧠-三大缓存："><a href="#🧠-三大缓存：" class="headerlink" title="🧠 三大缓存："></a>🧠 三大缓存：</h4><table>
<thead>
<tr>
<th>缓存级别</th>
<th>对应源码字段名</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td><code>singletonObjects</code></td>
<td>已完全初始化的 Bean（生命周期完成），正式放入单例池</td>
</tr>
<tr>
<td>二级缓存</td>
<td><code>earlySingletonObjects</code></td>
<td>暂时暴露的半成品 Bean 实例（未执行初始化方法）</td>
</tr>
<tr>
<td>三级缓存</td>
<td><code>singletonFactories</code></td>
<td>存的是创建代理对象的 ObjectFactory，用于解决代理类循环依赖</td>
</tr>
</tbody></table>
<h6 id="Spring-把-A-的-半成品（early-reference）-暴露到二级缓存，让-B-先注入用为啥要放到二级缓存-而不是一级呢？"><a href="#Spring-把-A-的-半成品（early-reference）-暴露到二级缓存，让-B-先注入用为啥要放到二级缓存-而不是一级呢？" class="headerlink" title="Spring 把 A 的 半成品（early reference） 暴露到二级缓存，让 B 先注入用为啥要放到二级缓存 而不是一级呢？"></a><span style = "color:blue">Spring 把 A 的 半成品（early reference） 暴露到二级缓存，让 B 先注入用为啥要放到二级缓存 而不是一级呢？</span></h6><h2 id="✅-答案核心："><a href="#✅-答案核心：" class="headerlink" title="✅ 答案核心："></a>✅ 答案核心：</h2><p>因为此时 A 只是一个 <strong>尚未完成初始化的半成品对象</strong>，它还没有执行：</p>
<ul>
<li>属性填充（依赖注入）</li>
<li>Aware 接口回调</li>
<li>初始化方法（如 <code>@PostConstruct</code>、<code>afterPropertiesSet()</code>）</li>
</ul>
<p>➡️ <strong>这个 Bean 还不“完整”，不能放入正式的一级缓存！</strong>🔍 为什么不能直接放入一级缓存？</p>
<p>一级缓存是 <code>singletonObjects</code>，是 Spring 的“成品仓库”：</p>
<ul>
<li>放入这个缓存意味着：<ul>
<li>Bean 已经完成生命周期（包括依赖注入、初始化）</li>
<li>可以被别人安全引用</li>
</ul>
</li>
</ul>
<p>但在处理循环依赖时，我们是<strong>中途打断流程，把未初始化完成的 Bean 暴露出来</strong>给另一个 Bean 注入（比如 A 注入给 B）</p>
<h3 id="🔴-如果此时放入一级缓存，有两个风险："><a href="#🔴-如果此时放入一级缓存，有两个风险：" class="headerlink" title="🔴 如果此时放入一级缓存，有两个风险："></a>🔴 如果此时放入一级缓存，有两个风险：</h3><ol>
<li><strong>状态不一致风险</strong><br> 其他 Bean 拿到这个未初始化完成的 Bean，会误以为它是“成品”，使用后可能报错或引发不一致。</li>
<li><strong>生命周期混乱</strong><br> BeanPostProcessor、InitializingBean、@PostConstruct 等生命周期操作可能被跳过或错乱，严重破坏 Spring 的生命周期管理逻辑。</li>
</ol>
<h2 id="✅-二级缓存的作用正是：-”暴露早期引用”，但不当成成品！"><a href="#✅-二级缓存的作用正是：-”暴露早期引用”，但不当成成品！" class="headerlink" title="✅ 二级缓存的作用正是：**”暴露早期引用”，但不当成成品！**"></a>✅ 二级缓存的作用正是：**”暴露早期引用”，但不当成成品！**</h2><pre><code class="java">// 二级缓存 earlySingletonObjects：仅仅作为“抢先使用”的通道
this.earlySingletonObjects.put(beanName, earlyReference);
</code></pre>
<p>它是 Spring 对“对象未完成但又必须提前使用”这个两难问题的妥协方案。✅ 最终完整的 Bean 放入一级缓存：</p>
<p>当整个 Bean 初始化完成（属性注入 + 初始化方法 + 后置处理器都执行完），才会放入一级缓存：</p>
<pre><code class="java">addSingleton(beanName, exposedObject); // 放入 singletonObjects
</code></pre>
<hr>
<hr>
<p><span style = "color:blue"><strong>那按照你这样说 三级缓存又是干啥的?你问得非常到位！</strong></span><br>✅ 我们已经知道：</p>
<ul>
<li>一级缓存：<strong>成品 Bean 的正式仓库</strong>；</li>
<li>二级缓存：<strong>未初始化完成的“早期引用”</strong>，暴露给依赖它的 Bean 使用。</li>
</ul>
<h5 id="✅-简明结论（先记住）："><a href="#✅-简明结论（先记住）：" class="headerlink" title="✅ 简明结论（先记住）："></a>✅ 简明结论（先记住）：</h5><p><strong>三级缓存的本质作用是：为了解决“代理对象”在循环依赖中的提前暴露问题。</strong></p>
<h2 id="🎯-三级缓存的角色是什么？"><a href="#🎯-三级缓存的角色是什么？" class="headerlink" title="🎯 三级缓存的角色是什么？"></a>🎯 三级缓存的角色是什么？</h2><p>三级缓存存的是：</p>
<pre><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories
</code></pre>
<p>也就是说：它<strong>不是直接存 Bean 实例本身</strong>，而是存一个<strong>对象工厂 ObjectFactory</strong>，这个工厂可以在需要的时候返回一个 Bean（甚至是它的代理对象）。</p>
<h4 id="🧠-为什么需要三级缓存？——解决AOP-代理对象的提前暴露"><a href="#🧠-为什么需要三级缓存？——解决AOP-代理对象的提前暴露" class="headerlink" title="🧠 为什么需要三级缓存？——解决AOP 代理对象的提前暴露"></a>🧠 为什么需要三级缓存？——解决<strong>AOP 代理对象的提前暴露</strong></h4><p>Spring 在三级缓存里放一个 <code>ObjectFactory</code>，用于 <strong>延迟构建代理对象</strong></p>
<p>等到别的 Bean（比如 B）需要注入 A 时，先从二级缓存找不到，就用三级缓存的 <code>ObjectFactory.getObject()</code> 来构造这个 Bean，此时可以通过 <code>SmartInstantiationAwareBeanPostProcessor</code>（比如 AOP 后置处理器）提前生成代理。</p>
</blockquote>
<h6 id="什么是Spring的循环依赖？？"><a href="#什么是Spring的循环依赖？？" class="headerlink" title="什么是Spring的循环依赖？？"></a>什么是Spring的循环依赖？？</h6><p><u>&#x3D;&#x3D;<strong>一级缓存</strong>&#x3D;&#x3D;作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/14e03913c1c2b7ca24702d5d2226a886bcc373de/%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%961.jpg"></p>
<p><u>如果想打破循环依赖，就需要一个中间人的参与，这个中间人就是&#x3D;&#x3D;<strong>二级缓存</strong>&#x3D;&#x3D;</u><del>如果一个对象是代理对象(被增强了)就不行</del><br><img src="https://github.com/P-luminary/images/blob/master/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%962.jpg?raw=true"></p>
<p><u>针对如果是代理对象的话如何解决呢？</u> → &#x3D;&#x3D;<strong>三级缓存</strong>&#x3D;&#x3D;<br><img src="https://github.com/P-luminary/images/blob/master/%E4%B8%89%E6%AC%A1%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.jpg?raw=true"></p>
<h6 id="那如果构造方法出现了循环依赖怎么解决？"><a href="#那如果构造方法出现了循环依赖怎么解决？" class="headerlink" title="那如果构造方法出现了循环依赖怎么解决？"></a>那如果构造方法出现了循环依赖怎么解决？</h6><blockquote>
<p>@Component                                                                   @Component<br>public class A{                           →      ←                          public class B{<br>    private B b;                             ↑          ↑                             private A a;<br>    public A(B c){                       →↑          ↑←                        public B(A c){<br>       sout(“A的构造方法执行了”)                                          sout(“B的构造方法执行了”)<br>       this.b&#x3D;b;                                                                                 this.b&#x3D;b;<br> }                                                                                               }<br>}                                                                                            } </p>
<p>报错信息：Is there an unresolvable circular reference?<br>解决：<code>@Lazy </code> 延迟加载→什么时候需要对象的时候什么时候实例化对象</p>
<pre><code class="java">public A(@Lazy B b)&#123;
 sout(&quot;A的构造方法执行了&quot;);
 this.b=b;
&#125;
</code></pre>
</blockquote>
<p><strong>Spring解决循环依赖是通过三级缓存</strong></p>
<pre><code class="java">// 单实例对象注册器
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123;
private static final int SUPPRESSED EXCEPTIONS LIMIT= 100;  
private final Map&lt;String, Object&gt;singletonObjects = new ConcurrentHashMap(256); 一级缓存
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16); 三级缓存
private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16); 二级缓存 
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObject</td>
<td>单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象(生命周期还没走完)</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC的执行流程知道吗？</strong></span></p>
<blockquote>
<ul>
<li>视图阶段(老旧JSP等)</li>
<li>前后端分离阶段(接口开发，异步)</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/67d750afe8d0ece9e5cc289483dc164a9897e165/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<p>&#x3D;&#x3D;<strong>视图阶段(jsp)</strong>&#x3D;&#x3D; </p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器<strong>对象</strong>及处理器<strong>拦截器</strong>(如果有)</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)Controller执行完成返回</li>
<li>ModelAndView对象HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)</li>
<li>ViewReslover解析后返回具体View(视图)</li>
<li>DispatcherServlet根据View进行渲染视图(即将模型数据填充至视图中)</li>
<li>DispatcherServlet响应用户</li>
</ul>
<p>&#x3D;&#x3D;<strong>前后端分离阶段(接口开发，异步请求)</strong>&#x3D;&#x3D;</p>
<ul>
<li>用户发送出请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter(处理器适配器)</li>
<li>HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)</li>
</ul>
<blockquote>
<h3 id="✅-一、SpringMVC-是什么？"><a href="#✅-一、SpringMVC-是什么？" class="headerlink" title="✅ 一、SpringMVC 是什么？"></a>✅ 一、SpringMVC 是什么？</h3><blockquote>
<p>SpringMVC 是基于<strong>Servlet 的原生请求处理模型</strong>封装的一套 MVC Web 框架，它通过 DispatcherServlet 实现请求分发，解耦了控制器、视图解析器等组件之间的关系。</p>
</blockquote>
<h3 id="🚀-1-用户发起请求"><a href="#🚀-1-用户发起请求" class="headerlink" title="🚀 1. 用户发起请求"></a>🚀 1. 用户发起请求</h3><p>浏览器访问一个 URL，例如：<code>http://localhost:8080/user/list</code>，请求会先到达 <strong>前端控制器 DispatcherServlet</strong>。</p>
<hr>
<h3 id="🔄-2-DispatcherServlet-接收到请求"><a href="#🔄-2-DispatcherServlet-接收到请求" class="headerlink" title="🔄 2. DispatcherServlet 接收到请求"></a>🔄 2. DispatcherServlet 接收到请求</h3><p>DispatcherServlet 是 SpringMVC 的核心入口，用于请求分发和生命周期管理。</p>
<hr>
<h3 id="🔎-3-查找-HandlerMapping（处理器映射器）"><a href="#🔎-3-查找-HandlerMapping（处理器映射器）" class="headerlink" title="🔎 3. 查找 HandlerMapping（处理器映射器）"></a>🔎 3. 查找 HandlerMapping（处理器映射器）</h3><ul>
<li>DispatcherServlet 调用 HandlerMapping 来<strong>查找当前请求所匹配的 Handler（Controller 方法）</strong>；</li>
<li>会封装成 <code>HandlerExecutionChain</code>，里面包含目标处理器和拦截器链。</li>
</ul>
<hr>
<h3 id="⚙️-4-调用-HandlerAdapter（处理器适配器）"><a href="#⚙️-4-调用-HandlerAdapter（处理器适配器）" class="headerlink" title="⚙️ 4. 调用 HandlerAdapter（处理器适配器）"></a>⚙️ 4. 调用 HandlerAdapter（处理器适配器）</h3><p>SpringMVC 不直接调用 Handler，而是交给 HandlerAdapter 来统一调用逻辑（比如支持 @RequestMapping&#x2F;@RestController 方法）。</p>
<hr>
<h3 id="🧠-5-执行-Handler（也就是-Controller-方法）"><a href="#🧠-5-执行-Handler（也就是-Controller-方法）" class="headerlink" title="🧠 5. 执行 Handler（也就是 Controller 方法）"></a>🧠 5. 执行 Handler（也就是 Controller 方法）</h3><p>通过适配器调用具体的 Controller 中的业务处理方法，如：</p>
<pre><code>java复制代码@GetMapping(&quot;/user/list&quot;)
public List&lt;User&gt; list() &#123;
    return userService.findAll();
&#125;
</code></pre>
<hr>
<h3 id="📦-6-返回-ModelAndView（传统视图模式）或-ResponseBody-数据（前后端分离）"><a href="#📦-6-返回-ModelAndView（传统视图模式）或-ResponseBody-数据（前后端分离）" class="headerlink" title="📦 6. 返回 ModelAndView（传统视图模式）或 @ResponseBody 数据（前后端分离）"></a>📦 6. 返回 ModelAndView（传统视图模式）或 @ResponseBody 数据（前后端分离）</h3><ul>
<li>传统 MVC 场景下，Controller 返回一个 <code>ModelAndView</code>；</li>
<li>如果是前后端分离，通常会返回 JSON 数据，经过 <code>HttpMessageConverter</code> 处理后直接写入响应体。</li>
</ul>
<hr>
<h3 id="🪞-7-调用-ViewResolver（视图解析器）【视图模式专属】"><a href="#🪞-7-调用-ViewResolver（视图解析器）【视图模式专属】" class="headerlink" title="🪞 7. 调用 ViewResolver（视图解析器）【视图模式专属】"></a>🪞 7. 调用 ViewResolver（视图解析器）【视图模式专属】</h3><ul>
<li>如果返回的是视图名（如 “userList”），SpringMVC 会调用 ViewResolver 解析为具体的 JSP 或 Thymeleaf 模板。</li>
</ul>
<hr>
<h3 id="🎨-8-渲染视图-View（视图模式专属）"><a href="#🎨-8-渲染视图-View（视图模式专属）" class="headerlink" title="🎨 8. 渲染视图 View（视图模式专属）"></a>🎨 8. 渲染视图 View（视图模式专属）</h3><ul>
<li>将模型数据（Model）填充进视图模板，生成 HTML 页面。</li>
</ul>
<hr>
<h3 id="📤-9-DispatcherServlet-返回响应给浏览器"><a href="#📤-9-DispatcherServlet-返回响应给浏览器" class="headerlink" title="📤 9. DispatcherServlet 返回响应给浏览器"></a>📤 9. DispatcherServlet 返回响应给浏览器</h3><ul>
<li>前后端分离下是 JSON 响应；</li>
<li>传统模式下是完整渲染后的 HTML。</li>
</ul>
<pre><code class="text">  [用户请求]
       ↓
 DispatcherServlet
       ↓
 HandlerMapping → 找到 Handler + 拦截器链
       ↓
 HandlerAdapter  → 统一执行 Handler
       ↓
 Controller      → 执行业务逻辑
       ↓
 返回 ModelAndView / JSON
       ↓
（传统）ViewResolver → 找视图模板
       ↓
 渲染视图 / 写入 JSON 响应体
       ↓
 DispatcherServlet 响应浏览器
</code></pre>
<h2 id="✅-四、不同开发阶段下的区别"><a href="#✅-四、不同开发阶段下的区别" class="headerlink" title="✅ 四、不同开发阶段下的区别"></a>✅ 四、不同开发阶段下的区别</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>返回值</th>
<th>是否走视图解析器</th>
<th>常见注解</th>
</tr>
</thead>
<tbody><tr>
<td>JSP 阶段</td>
<td>ModelAndView</td>
<td>✅ 是</td>
<td><code>@Controller</code></td>
</tr>
<tr>
<td>前后端分离</td>
<td>JSON 数据</td>
<td>❌ 否</td>
<td><code>@RestController</code> + <code>@ResponseBody</code></td>
</tr>
</tbody></table>
<h2 id="🎯-五、总结金句（可背）："><a href="#🎯-五、总结金句（可背）：" class="headerlink" title="🎯 五、总结金句（可背）："></a>🎯 五、总结金句（可背）：</h2><blockquote>
<p>SpringMVC 核心就是一个请求经过 DispatcherServlet，根据 HandlerMapping 找到处理器，由 HandlerAdapter 调用 Controller 执行逻辑，最终通过视图解析或消息转换，返回结果给客户端。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>SpringBoot自动配置原理？</strong></span></p>
<pre><code class="java">@SpringBootApplication = 
    @SpringBootConfiguration +
    @EnableAutoConfiguration +
    @ComponentScan
</code></pre>
<blockquote>
<p>SpringBoot中最高频的一道面试题，也是框架最核心的思想<br>&#x3D;&#x3D;<code>@SpringBootConfiguration</code>&#x3D;&#x3D;：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类<br>&#x3D;&#x3D;<code>@EnableAutoConfiguration</code>&#x3D;&#x3D;：SpringBoot实现自动化配置的核心注解，通过配置选择器导入自动配置类<br>&#x3D;&#x3D;<code>@ComponentScan</code>&#x3D;&#x3D;：组件扫描，默认扫描当前引导类所在包及其子包</p>
<p>1，在Spring Boot项目中的引导类上有一个注解<code>@SpringBootApplication</code>，这个注解是对三个注解进行了封装，分别是:</p>
<ul>
<li><code>@SpringBootConfiquration</code></li>
<li><code>@EnableAutoConfiquration</code></li>
<li><code>@ComponentScan</code></li>
</ul>
<p>2，其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。<u>该注解通过<code>@Import</code>注解导入对应的<strong>配置选择器</strong>。内部就是读取了该项目和该项目引用的jar包的classpath路径下<code>META-INF/spring.factories</code>文件中的所配置的类的全类名。在这些配置类中所定义的Bean会根据条件注解<strong>所指定的条件来决定</strong>是否需要将其导入到Spring容器中</u>。</p>
<p>3，条件判断会有像<code>@ConditionalOnClass</code>这样的注解，<u>判断是否有对应的class文件</u>，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p>
</blockquote>
<pre><code class="java">package com.itheima;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// SpringBoot的启动类
// 注意: 我们写的代码要在启动类的包或者子包中
// @SpringBootApplication注解中包含了 @ComponentScan，没有指定扫描哪个包，默认扫描当前类所在的包和子包
@SpringBootApplication
public class Day15TliasManagement01IocDiApplication &#123;
    // 启动项目, 内嵌的Tomcat会启动, 把项目部署到这个内嵌Tomcat中
    public static void main(String[] args) &#123;
        SpringApplication.run(Day15TliasManagement01IocDiApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@SpringBootApplication</code>会弹到<code>SpringBootApplication.class</code>界面</p>
</blockquote>
<pre><code class="mysql">@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
</code></pre>
<blockquote>
<p>按住<code>ctrl+左键</code>点击<code>@EnableAutoConfiguration</code>会弹到<code>EnableAutoConfiguration.class</code>界面</p>
</blockquote>
<pre><code class="mysql"># @Import(&#123;AutoConfigurationImportSelector.class&#125;)
# AutoConfigurationImportSelector是自动配置的选择器 
# 会加载META-INF中的spring.factories文件的自动配置类...AutoConfiguration...
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Import;

@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(&#123;AutoConfigurationImportSelector.class&#125;)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<p><span style = "color:red"><strong>Spring框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围<del>默认单例的</del></td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定Spring在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程(AOP)</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringMVC框架常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>用于映射请求路径，可以定义在类上和方法上。用于类上，则标识类中的所有的方法都是以该地址作为父路径</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>注解实现接收http请求的json数据，将json转换为java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数的名称</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径中获取请求参数(<code>/user/&#123;id&#125;</code>)，传递给方法的形式参数</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>注解实现将Controller方法返回对象转换成json对象响应给客户端</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>获取指定的请求头数据</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @RequestBody</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>SpringBoot常见的注解有哪些？</strong></span></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootConfiguration</td>
<td>组合了 <code>-@Configuration注解</code>，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>打开自动配置的功能，也可以关闭某个自动配置的选项</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/aa2405d532d8e6606845f6a1a4da8456b797e115/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>MyBatis执行流程？</strong></span></p>
<blockquote>
<ul>
<li>读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ul>
<p>执行流程从读取配置文件、创建 SqlSession、查找 MappedStatement、参数映射、执行 SQL 到结果映射，每个环节都有对应的组件协作完成。</p>
</blockquote>
<ul>
<li>理解了各个组件的关系</li>
<li>Sql的执行过程(参数映射、sql解析、执行和结果处理)</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/7263f0a583711bca127933c0053e2b1fef476cb7/MyBatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" style="zoom:80%;" />



<p><span style = "color:red"><strong>MyBatis是否支持延迟加载？</strong></span></p>
<blockquote>
<ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</li>
<li>Mybatis支持<strong>一对一关联对象</strong>和<strong>一对多关联集合对象</strong>的延迟加载</li>
<li>在<code>Mybatis配置文件</code>中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true/false</code>，默认是关闭的</li>
</ul>
<pre><code class="yaml">&lt;settings&gt;
  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>延迟加载(懒加载)：<strong>查询主对象时不立即加载关联对象，而是在访问关联属性时再去执行查询语句加载数据</strong>。<br>查询 <code>User</code> 时不查 <code>Order</code>，只有调用 <code>user.getOrders()</code> 时，才执行 <code>select * from order where user_id = ?</code></p>
</blockquote>
<p><span style = "color:red"><strong>延迟加载的底层原理知道吗？</strong></span></p>
<p>MyBatis <strong>延迟加载的核心是代理模式 + 拦截器机制</strong>，底层主要通过 <strong>CGLIB 创建目标对象的代理对象</strong></p>
<blockquote>
<ul>
<li>使用<strong>CGLIB</strong>创建目标对象的代理对象</li>
<li>当调用目标方法时，进入拦截器<strong>invoke</strong>方法，发现目标方法是nul值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</li>
</ul>
</blockquote>
<blockquote>
<p>查询用户的时候，把用户所属的订单数据也查询出来，这个是&#x3D;&#x3D;<strong>立即加载</strong>&#x3D;&#x3D;<br>查询**<u>用户的(sql)</u><strong>时候，暂时不查询订单数据，当需要订单的时候，再查询</strong><u>订单(sql)</u>**，这个就是&#x3D;&#x3D;<strong>延迟加载</strong>&#x3D;&#x3D;</p>
<h3 id="执行流程-👇"><a href="#执行流程-👇" class="headerlink" title="执行流程 👇"></a>执行流程 👇</h3><ol>
<li><strong>查询主对象时</strong>，不会立即查关联对象，而是用 CGLIB 创建一个代理对象（继承目标类）</li>
<li><strong>当访问关联属性时</strong>，进入代理类的 <code>intercept</code> 方法（拦截器）</li>
<li><strong>拦截器判断属性是否已加载</strong>：<ul>
<li>没加载 → 执行对应的 SQL（如 <code>selectOrdersForUser</code>）</li>
<li>查出结果后 → 通过 <code>setXxx()</code> 方法注入属性值</li>
</ul>
</li>
<li><strong>属性值设置好之后</strong>，后续访问就是直接取值，不再触发数据库查询</li>
</ol>
</blockquote>
<blockquote>
<h3 id="延迟加载的实现步骤："><a href="#延迟加载的实现步骤：" class="headerlink" title="延迟加载的实现步骤："></a>延迟加载的实现步骤：</h3><ol>
<li><strong>配置开启延迟加载</strong>： 在MyBatis的配置文件中（通常是<code>mybatis-config.xml</code>），需要设置两个属性：<ul>
<li><code>lazyLoadingEnabled=true</code>：开启延迟加载。</li>
<li><code>aggressiveLazyLoading=false</code>：关闭积极的延迟加载，即访问对象的时候不会立即加载其所有属性。</li>
</ul>
</li>
<li><strong>映射文件配置</strong>： 在对应的Mapper映射文件中，对于需要延迟加载的关联查询，使用<code>select</code>标签定义延迟加载的SQL语句，并通过<code>fetchType=&quot;lazy&quot;</code>属性明确指定使用延迟加载。</li>
<li><strong>创建代理对象</strong>： 当执行查询操作时，MyBatis不会立即执行关联查询的SQL，而是返回一个代理对象。这个代理对象是使用CGLIB库创建的，它继承自目标对象。</li>
<li><strong>拦截器方法调用</strong>： 当我们首次访问这个代理对象的某个方法（比如访问订单详情）时，实际上会调用CGLIB生成的代理对象的拦截器方法（<code>intercept</code>方法）。在拦截器方法中，会判断当前要访问的属性是否已经被加载：<ul>
<li>如果属性已经被加载，则直接返回属性值。</li>
<li>如果属性未被加载，则会执行之前定义好的延迟加载SQL语句，从数据库中查询数据。</li>
</ul>
</li>
<li><strong>设置属性值</strong>： 查询得到数据后，MyBatis会将这些数据设置到目标对象的相应属性上，这样下次访问该属性时，就不需要再次查询数据库了。</li>
</ol>
<h3 id="底层原理："><a href="#底层原理：" class="headerlink" title="底层原理："></a>底层原理：</h3><ul>
<li><strong>CGLIB代理</strong>：MyBatis使用CGLIB库创建目标对象的代理，当调用目标方法时，实际上会进入拦截器（Interceptor）的<code>intercept</code>方法。</li>
<li><strong>拦截器逻辑</strong>：在拦截器中，会判断当前调用的方法是否需要触发延迟加载。如果需要，则执行延迟加载的SQL查询。</li>
<li><strong>结果处理</strong>：查询结果会被处理并设置到目标对象的属性上，这样目标对象的相关属性就持有了数据，后续访问将直接返回这些数据，而无需再次查询。<code>MyBatis在执行完延迟加载的SQL查询后，会获取查询结果，并将这些结果映射到目标对象的相应属性中</code></li>
</ul>
<h3 id="示例说明："><a href="#示例说明：" class="headerlink" title="示例说明："></a>示例说明：</h3><p>假设有一个用户<code>User</code>和订单<code>Order</code>的关系，在查询用户时，通常不会立即加载其订单信息，而是当需要时再加载。以下是简化的代码示例：</p>
<pre><code class="xml">&lt;!-- UserMapper.xml --&gt;
&lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
  &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
  &lt;!-- 延迟加载订单信息 --&gt;
  &lt;collection property=&quot;orders&quot; column=&quot;id&quot; ofType=&quot;Order&quot; select=&quot;selectOrdersForUser&quot; fetchType=&quot;lazy&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectUser&quot; resultMap=&quot;userMap&quot;&gt;
  SELECT * FROM user WHERE id = #&#123;id&#125;
&lt;/select&gt;

&lt;select id=&quot;selectOrdersForUser&quot; resultType=&quot;Order&quot;&gt;
  SELECT * FROM order WHERE user_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p>在上述配置中，当调用<code>selectUser</code>查询用户信息时，不会立即查询订单信息。只有当程序中访问<code>User</code>对象的<code>orders</code>属性时，才会执行<code>selectOrdersForUser</code>查询，这就是延迟加载的具体实现。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/1fdf519599da660621e27393d18b48f4b2bdb802/MyBatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86.png"  />

<p><span style = "color:red"><strong>MyBatis的一级、二级缓存用过吗？</strong></span></p>
<blockquote>
<ul>
<li>一级缓存:基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>MyBatis的二级缓存什么时候会清理缓存中的数据？</strong></span></p>
<blockquote>
<ul>
<li>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ul>
</blockquote>
<ul>
<li>本地缓存，基于PerpetualCache，本质是一个HashMap</li>
<li><strong>一级缓存</strong>：作用域是session级别<ul>
<li>基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，<strong>默认打开一级缓存</strong></li>
</ul>
</li>
<li><strong>二级缓存</strong>：作用域是namespace和mapper的作用域，不依赖于session<ul>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQLsession，默认也是采用 PerpetualCache<br>HashMap 存储</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5f133abb10da579732fe734073e28b0713a3b63/Mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.jpg"></p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li>
<li>二级缓存需要缓存的数据实现Serializable接口</li>
<li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li>
</ul>
<h2 id="SpringCloud篇"><a href="#SpringCloud篇" class="headerlink" title="SpringCloud篇"></a><span style = "color:blue">SpringCloud篇</span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/a556069d277599cc45e30c8e2e719fba7ff392cb/SpringCloud%E9%9D%A2%E8%AF%95%E9%A2%98.jpg"></p>
<p><span style = "color:red"><strong>SpringCloud 5大组件有哪些？</strong></span></p>
<p>回答原则：简单的问题不能答错</p>
<table>
<thead>
<tr>
<th>通常情况</th>
<th>SpringCloudAlibba</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka：注册中心</td>
<td>Nacos：注册中心&#x2F;配置中心</td>
</tr>
<tr>
<td><strong>Ribbon：负载均衡</strong></td>
<td><strong>Ribbon：负载均衡</strong></td>
</tr>
<tr>
<td><strong>Feign：远程调用</strong></td>
<td><strong>Feign：远程调用</strong></td>
</tr>
<tr>
<td>Hystrix：服务熔断</td>
<td>sentinel：服务保护</td>
</tr>
<tr>
<td>Zuul&#x2F;<strong>Gateway：网关</strong></td>
<td><strong>Gateway：服务网关</strong></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/39f10dd62358b96346cdf42dd3f893f0d0920bcc/SpringCloud5%E5%A4%A7%E7%BB%84%E4%BB%B6.jpg"></p>
<p><span style = "color:red"><strong>服务注册和发现是什么意思？ SpringCloud 如何实现服务注册发现？</strong></span></p>
<blockquote>
<ul>
<li>我们当时项目采用的<code>eureka</code>作为注册中心，这个也是SpringCloud体系的一个核心组件</li>
<li><strong>服务注册</strong>：服务提供者需要把自己的信息注册到eureka来保存这些信息，比如**<u>服务名称、ip、端口</u>**等等</li>
<li><strong>服务发现</strong>：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者利用<strong>负载均衡</strong>算法，选择一个发起调用</li>
<li><strong>服务监控</strong>：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没有收到心跳，从eureka中剔除</li>
</ul>
</blockquote>
<ul>
<li>微服务中必须要使用的组件，考虑我们使用微服务的程度</li>
<li>注册中心的核心作用是：服务注册和发现</li>
<li>常见的注册中心：<strong>eureka、nocas</strong>、zookeeper</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4f4fe573949c4168cd4114f6cc6a28679f84181/Eureka%E4%BD%9C%E7%94%A8.jpg"></p>
<p><span style = "color:red"><strong>请你说一下nacos与eureka的区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>Nacos与Eureka的共同点</strong> (<u>注册中心</u>)<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务者心跳方式做健康检测</li>
</ul>
</li>
<li><strong>Nacos与Eureka的区别</strong> (<u>注册中心</u>)<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>
<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被提出</strong></li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式<del>高可用模式</del>，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，Eureka只有注册中心，也是选择选用nacos的一个重要原因</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3c304f59104d2917c35ecb658f95f7073365ed9c/Eureka%E5%92%8CNacos%E5%8C%BA%E5%88%AB.jpg"></p>
<p><span style = "color:red"><strong>把RestTemplate替换成OpenFeign后它们的底层还是一样的吗？</strong></span><del>OpenFeign是远程调用</del></p>
<p>OpenFeign的底层原理也是根据服务名称，首先去远程注册中心拉取服务列表，底层也会在本地缓存一份，也会根据负载均衡选出一个实例，又运用了jdk的动态代理生成代理类，也会涉及到反射机制，最终拼出完整的url，发起http远程调用</p>
<pre><code class="java">@FeignClient(name = &quot;service-provider&quot;)
public interface ServiceProviderClient &#123;
    // 定义接口方法，映射到服务提供者的具体API
    @GetMapping(&quot;/api/resource&quot;)
    String getResource();
&#125;
</code></pre>
<blockquote>
<h3 id="✅-一、使用方式不同"><a href="#✅-一、使用方式不同" class="headerlink" title="✅ 一、使用方式不同"></a>✅ 一、使用方式不同</h3><ul>
<li><p><strong>RestTemplate</strong> 是显式调用（自己写 URL，拼参数）</p>
<pre><code>restTemplate.getForObject(&quot;http://user-service/user/1&quot;, String.class);
</code></pre>
</li>
<li><p><strong>OpenFeign</strong> 是声明式调用（只写接口 + 注解，SpringBoot自动帮你拼URL发请求）</p>
<pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient &#123;
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    String getUser(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
</li>
</ul>
<hr>
<h3 id="✅-二、底层原理差不多，但实现机制不同"><a href="#✅-二、底层原理差不多，但实现机制不同" class="headerlink" title="✅ 二、底层原理差不多，但实现机制不同"></a>✅ 二、底层原理差不多，但实现机制不同</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>RestTemplate</th>
<th>OpenFeign</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发起方式</strong></td>
<td>手动构造 URL + 参数</td>
<td>注解接口 + 动态代理自动拼 URL</td>
</tr>
<tr>
<td><strong>底层通信方式</strong></td>
<td>HttpClient &#x2F; OKHttp &#x2F; JDK Http</td>
<td>同样也是基于 HttpClient 或 OKHttp</td>
</tr>
<tr>
<td><strong>注册中心拉取服务</strong></td>
<td>可搭配 Ribbon 手动实现服务发现</td>
<td>默认集成 Spring Cloud <strong>LoadBalancer</strong> 自动发现服务</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>手动配置 Ribbon 或 LoadBalancer</td>
<td>自动内置 <strong>LoadBalancer</strong>，基于服务名均衡选择</td>
</tr>
<tr>
<td><strong>动态代理</strong></td>
<td>无</td>
<td>有，基于 <strong>JDK 动态代理</strong>生成接口实现类</td>
</tr>
<tr>
<td><strong>扩展能力</strong></td>
<td>灵活性高，配置复杂</td>
<td>扩展性强，统一规范，支持熔断&#x2F;重试&#x2F;拦截器等</td>
</tr>
</tbody></table>
<h3 id="✅-三、OpenFeign-更高级，集成更好"><a href="#✅-三、OpenFeign-更高级，集成更好" class="headerlink" title="✅ 三、OpenFeign 更高级，集成更好"></a>✅ 三、OpenFeign 更高级，集成更好</h3><p>OpenFeign 是对 RestTemplate 的一层封装 + 声明式远程调用：</p>
<ul>
<li>内置了服务注册发现（Eureka&#x2F;Nacos）</li>
<li>内置了负载均衡（Ribbon &#x2F; Spring Cloud LoadBalancer）</li>
<li>可配合 Hystrix &#x2F; Sentinel 实现熔断降级</li>
<li>支持拦截器、日志、重试、压缩等功能</li>
<li>统一异常处理、超时配置更方便</li>
</ul>
<h3 id="✅-四、结论一句话总结："><a href="#✅-四、结论一句话总结：" class="headerlink" title="✅ 四、结论一句话总结："></a>✅ 四、结论一句话总结：</h3><blockquote>
<p><strong>虽然最终底层都是通过 HTTP 客户端发起请求（如 OkHttp &#x2F; HttpClient），但 <span style = "color:red">OpenFeign 是基于动态代理+注解的声明式封装，实现了更强大的远程调用能力和集成能力，远比 RestTemplate 更高级、更易维护。</span></strong></p>
</blockquote>
<h5 id="如果面试官继续追问：“你们项目是怎么替换的？”，你可以说："><a href="#如果面试官继续追问：“你们项目是怎么替换的？”，你可以说：" class="headerlink" title="如果面试官继续追问：“你们项目是怎么替换的？”，你可以说："></a>如果面试官继续追问：“你们项目是怎么替换的？”，你可以说：</h5><blockquote>
<p>我们之前用 RestTemplate 是在业务代码里拼 URL，很冗余。后来统一封装为 OpenFeign，只保留接口定义，调用方更清晰，服务注册与发现、负载均衡也变成自动处理，配合 Sentinel 做了服务熔断与限流，提升了整体的系统健壮性。</p>
<h6 id="怎么个自动处理法？"><a href="#怎么个自动处理法？" class="headerlink" title="怎么个自动处理法？"></a>怎么个自动处理法？</h6><h2 id="默认情况下-——-OpenFeign-自动处理"><a href="#默认情况下-——-OpenFeign-自动处理" class="headerlink" title="默认情况下 —— OpenFeign 自动处理"></a>默认情况下 —— OpenFeign 自动处理</h2><h3 id="✅-默认配置时："><a href="#✅-默认配置时：" class="headerlink" title="✅ 默认配置时："></a>✅ 默认配置时：</h3><ul>
<li><strong>服务注册与发现</strong>：依赖 Nacos &#x2F; Eureka 等注册中心，OpenFeign 会根据服务名自动从注册中心拉取可用实例。</li>
<li><strong>负载均衡</strong>：默认通过 Spring Cloud LoadBalancer（以前是 Ribbon）对服务列表进行轮询或权重等策略选择一个实例。</li>
<li><strong>HTTP请求</strong>：通过 <code>HttpClient</code> &#x2F; <code>OkHttp</code> 等客户端执行。</li>
</ul>
<p><strong>你只写：</strong></p>
<pre><code>@FeignClient(&quot;user-service&quot;)
public interface UserClient &#123;
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    User getUser(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<p><strong>OpenFeign 会自动做：</strong></p>
<ul>
<li>拉取 <code>user-service</code> 的服务列表</li>
<li>选出一个实例（负载均衡）</li>
<li>拼接 URL 发起 HTTP 请求</li>
</ul>
<blockquote>
<h2 id="🧠-一、什么叫“选出一个实例”？"><a href="#🧠-一、什么叫“选出一个实例”？" class="headerlink" title="🧠 一、什么叫“选出一个实例”？"></a>🧠 一、什么叫“选出一个实例”？</h2><p>在 <strong>微服务架构</strong> 中，一个服务往往会 <strong>部署多个实例</strong> 来应对高并发或容灾，例如：</p>
<table>
<thead>
<tr>
<th>服务名</th>
<th>实例地址</th>
</tr>
</thead>
<tbody><tr>
<td>user-service</td>
<td>10.0.0.1:8080</td>
</tr>
<tr>
<td>user-service</td>
<td>10.0.0.2:8080</td>
</tr>
<tr>
<td>user-service</td>
<td>10.0.0.3:8080</td>
</tr>
</tbody></table>
<p>当你通过 OpenFeign 发送请求：</p>
<pre><code>@FeignClient(&quot;user-service&quot;)
User getUser(...);
</code></pre>
<p>你只写了一个服务名 <code>user-service</code>，但后台其实有多个实例，<strong>必须从这些实例中选出一个具体地址来发请求</strong>，比如选中 <code>10.0.0.2:8080</code>。</p>
<hr>
<h2 id="⚖️-二、这就是负载均衡要干的事！"><a href="#⚖️-二、这就是负载均衡要干的事！" class="headerlink" title="⚖️ 二、这就是负载均衡要干的事！"></a>⚖️ 二、这就是负载均衡要干的事！</h2><h3 id="✅-负载均衡做的事："><a href="#✅-负载均衡做的事：" class="headerlink" title="✅ 负载均衡做的事："></a>✅ 负载均衡做的事：</h3><p>就是 <strong>从多个可用实例中选择一个</strong>。</p>
<h3 id="✅-为什么要选？不选行不行？"><a href="#✅-为什么要选？不选行不行？" class="headerlink" title="✅ 为什么要选？不选行不行？"></a>✅ 为什么要选？不选行不行？</h3><p>如果不做选择，就不知道到底该请求哪个服务器，容易：</p>
<ul>
<li>总是访问同一个实例 → 某一个实例过载</li>
<li>有的实例空闲，有的压力大 → 资源利用不均衡</li>
<li>某些实例宕机，没人检测 → 请求失败</li>
</ul>
<h3 id="✅-所以负载均衡的作用是："><a href="#✅-所以负载均衡的作用是：" class="headerlink" title="✅ 所以负载均衡的作用是："></a>✅ 所以负载均衡的作用是：</h3><ul>
<li><strong>分摊压力</strong>：让不同请求打到不同实例，防止某一个服务器崩掉</li>
<li><strong>提高可用性</strong>：某个实例挂了，下一次选择其他实例，系统还能继续用</li>
<li><strong>自动切换</strong>：负载均衡组件还能感知服务状态变化，动态更新可用实例列表</li>
</ul>
<hr>
<h2 id="🧮-三、OpenFeign-背后使用了什么做负载均衡？"><a href="#🧮-三、OpenFeign-背后使用了什么做负载均衡？" class="headerlink" title="🧮 三、OpenFeign 背后使用了什么做负载均衡？"></a>🧮 三、OpenFeign 背后使用了什么做负载均衡？</h2><p>在 Spring Cloud 中，OpenFeign 默认集成了：</p>
<h3 id="✅-Spring-Cloud-LoadBalancer（或老版-Ribbon）"><a href="#✅-Spring-Cloud-LoadBalancer（或老版-Ribbon）" class="headerlink" title="✅ Spring Cloud LoadBalancer（或老版 Ribbon）"></a>✅ Spring Cloud LoadBalancer（或老版 Ribbon）</h3><p>它的核心就是在每次请求前调用：</p>
<pre><code>choose(&quot;user-service&quot;)
</code></pre>
<p>然后根据你配置的策略，比如：</p>
<ul>
<li>轮询（RoundRobin）👉 按顺序一个一个来</li>
<li>随机（Random）👉 随机挑一个</li>
<li>最少连接数（LeastConnections）</li>
<li>权重（Weighted）</li>
</ul>
<p>最终得到一个实例，例如 <code>10.0.0.2:8080</code>，然后拼接成最终 URL：</p>
<pre><code>http://10.0.0.2:8080/api/user/1
</code></pre>
<p>再发起 HTTP 请求。</p>
<hr>
<h2 id="🎯-总结一句话："><a href="#🎯-总结一句话：" class="headerlink" title="🎯 总结一句话："></a>🎯 总结一句话：</h2><blockquote>
<p>OpenFeign 中的“选出一个实例”就是 <strong>从多个服务实例中选择一个合适的来发送请求的过程</strong>，这个选择过程就是“负载均衡”负责的。它的目标是为了 <strong>提升性能、避免单点压力、实现高可用</strong>。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>你们项目负载均衡如何实现的？</strong></span><del>图1.1</del></p>
<blockquote>
<p>微服务的负载均衡主要使用了一个组件Ribbon，比如，我们再使用feign远程调用的过程中，底层的负载均衡就是使用了Ribbon 【<u>与RestTemplate不同，OpenFeign默认是LoadBalancer</u>】</p>
</blockquote>
<ul>
<li>负载均衡Ribbon，发起远程调用feign就会使用Ribbon</li>
<li>Ribbon负载均衡策略有哪些？</li>
<li>如果想自定义负载均衡策略如何实现？</li>
</ul>
<h6 id="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"><a href="#Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring-Cloud-LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进" class="headerlink" title="Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进"></a>Ribbon已经进入维护模式，Netflix不再积极开发新功能。而Spring Cloud LoadBalancer作为替代，不仅提供了Ribbon的核心功能，还引入了一些新特性和改进</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/2a6397006f0e74e16de4222ac7ab2758e98aa96c/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0.png"></p>
<p><span style = "color:red"><strong>Ribbon负载均衡策略有哪些？</strong></span><del>简单、权重、随机、区域</del></p>
<ul>
<li><span style="color:blue"><strong>RoundRobinRule</strong>：<strong>简单</strong><u>轮询服务列表</u>来选择服务器</span></li>
<li><span style="color:blue"><strong>WeightedResponseTimeRule</strong>：按照<u><strong>权重</strong></u>来选择服务器，响应时间越长，权重越小</span></li>
<li><span style="color:blue"><strong>RandomRule</strong>：<u><strong>随机</strong>选择</u>一个可用的服务器</span></li>
<li>BestAvaliableRule：忽略那些短路的服务器，并选择并发数较低的服务器</li>
<li>RetryRule：重试机制的选择逻辑</li>
<li>AvaliabilityFilteringRule：可用性敏感策略，先过滤非健康的，再选择连接数较小的实例</li>
<li><span style="color:blue"><strong>ZoneAvoidanceRule</strong>：以<u><strong>区域</strong>可用</u>的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可用理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询</span></li>
</ul>
<blockquote>
<h5 id="✅-Ribbon-常见负载均衡策略一览"><a href="#✅-Ribbon-常见负载均衡策略一览" class="headerlink" title="✅ Ribbon 常见负载均衡策略一览"></a>✅ Ribbon 常见负载均衡策略一览</h5><table>
<thead>
<tr>
<th>策略名</th>
<th>简介</th>
<th>核心逻辑</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RoundRobinRule</strong></td>
<td>轮询策略</td>
<td>依次选择服务列表中的每个实例，循环使用</td>
<td>简单、适用于服务性能相当、请求量均匀的场景</td>
</tr>
<tr>
<td><strong>RandomRule</strong></td>
<td>随机策略</td>
<td>随机选一个可用实例</td>
<td>测试环境、低并发系统或对分布无要求的场景</td>
</tr>
<tr>
<td><strong>WeightedResponseTimeRule</strong></td>
<td>权重 + 响应时间</td>
<td>根据服务实例响应时间动态调整权重，响应快的被选中几率高</td>
<td>适用于实例性能差异明显，希望高性能实例被优先选中</td>
</tr>
<tr>
<td><strong>RetryRule</strong></td>
<td>带重试机制的轮询</td>
<td>每次选择失败后会在一段时间内重试其他实例（默认使用 RoundRobinRule）</td>
<td>适用于请求容错性强、临时性网络波动频繁的情况</td>
</tr>
<tr>
<td><strong>BestAvailableRule</strong></td>
<td>最少并发策略</td>
<td>忽略短路（熔断）的实例，选择并发数最少的可用实例</td>
<td>适用于高并发下控制服务压力</td>
</tr>
<tr>
<td><strong>AvailabilityFilteringRule</strong></td>
<td>可用性过滤策略</td>
<td>过滤掉连接失败次数多的和并发高的实例，避免访问不健康服务</td>
<td>适用于系统对可用性要求高、网络波动大的场景</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong>（默认）</td>
<td>区域感知策略</td>
<td>综合评估 zone（区域）内实例的可用性和负载（Zone可以理解为机房或机架），选出最优 zone 再轮询选择服务</td>
<td>适用于跨机房、跨地域部署，希望优先选择本地&#x2F;低延迟实例的系统</td>
</tr>
</tbody></table>
<h2 id="📌-补充小Tips"><a href="#📌-补充小Tips" class="headerlink" title="📌 补充小Tips"></a>📌 补充小Tips</h2><ul>
<li>Spring Cloud 2020 后 Ribbon 官方不再维护，<strong>推荐用 Spring Cloud LoadBalancer</strong> 替代，但思想类似。</li>
<li>如果你项目还用 Ribbon，<strong>推荐配合 Hystrix 或 Sentinel 做服务熔断和限流</strong>。</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>如果想自定义负载均衡策略如何实现？</strong></span><del>图1.2</del></p>
<blockquote>
<ul>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在客户端的配置文件中，可以配置某一个服务调用的负载均衡（局部）</li>
</ul>
</blockquote>
<blockquote>
<p>首先，你需要创建一个类来实现 <code>IRule</code> 接口，这样就能自定义负载均衡的策略。<br><strong>实现 IRule 接口</strong>：</p>
<pre><code class="java">import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.Server;
import com.netflix.loadbalancer.ZoneAwareLoadBalancer;
import com.netflix.loadbalancer.RandomRule;

import java.util.List;

public class CustomLoadBalancerRule implements IRule &#123;

private IRule delegate = new RandomRule();  // 默认策略

@Override
public Server choose(Object key) &#123;
  // 在这里实现自己的负载均衡算法
  // 比如，你可以使用 RoundRobin、Random 或者基于健康检查的策略
  return delegate.choose(key);
&#125;

@Override
public void setLoadBalancer(ZoneAwareLoadBalancer&lt;?&gt; lb) &#123;
  delegate.setLoadBalancer(lb);
&#125;

@Override
public ZoneAwareLoadBalancer&lt;?&gt; getLoadBalancer() &#123;
  return delegate.getLoadBalancer();
&#125;
&#125;
</code></pre>
<p>然后，你需要在 Spring 配置类或者启动类上注入该自定义的负载均衡策略。<br><strong>配置 Bean 注册到容器（全局策略）</strong>：</p>
<pre><code class="java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RibbonConfig &#123;

@Bean
public IRule customLoadBalancerRule() &#123;
  return new CustomLoadBalancerRule();
&#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>SpringCloud中什么是服务雪崩，怎么解决这个问题？</strong></span></p>
<ul>
<li>什么是&#x3D;&#x3D;<strong>服务雪崩</strong>&#x3D;&#x3D;？<del>一个服务失败，导致整条链路的服务都失败的情形</del></li>
</ul>
<blockquote>
<ul>
<li>服务雪崩：当某个服务因为故障不可用，导致依赖它的上游服务纷纷失败，进而整个系统连锁崩溃的现象<ul>
<li>常发生在<strong>服务调用链路较长</strong>时</li>
<li>一个服务挂了，所有调用它的服务都会超时挂起，<strong>线程资源被耗尽，最终整个系统瘫痪</strong></li>
</ul>
</li>
</ul>
<p>📌 <strong>通俗比喻</strong>：你访问淘宝商品详情页面 → 商品服务依赖库存服务 → 库存服务挂了 → 商品服务一直卡着等 → 网页加载失败 → 淘宝崩了</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9900715f7f6943c509f9312dc31f4cf581e0af49/%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9.jpg"></p>
<ul>
<li>&#x3D;&#x3D;<u><strong>熔断降级</strong></u>&#x3D;&#x3D; &amp;&amp; &#x3D;&#x3D;<strong>服务熔断</strong>&#x3D;&#x3D;（解决）<strong>Hystix 服务熔断降级</strong></li>
</ul>
<blockquote>
<p><strong><u>服务降级</u></strong><del>部分服务不可用</del>：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<span style = "color:orange"><strong>一般在实际开发中与Feign接口整合，编写降级逻辑 <strong></span>(<strong>某个服务挂了或响应慢</strong>，不让请求卡住，而是返回</strong>预设的“备胎数据”</strong>，用户体验不会很差)</p>
</blockquote>
<blockquote>
<p><strong><u>服务熔断</u></strong><del>整个服务不可用</del>：默认关闭，需要手动打开，如果监测到<span style = "color:orange"><strong>10秒内请求的失败率超过50%</strong></span>，就触发熔断机制。之后<span style = "color:orange"><strong>每隔5秒重新尝试请求</strong></span>微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3195c4ca2d1f63815e09a802354a9c28209893b/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%AD%96%E7%95%A5.jpg"></p>
<ul>
<li><p><strong>限流（预防）</strong><del>微服务限流(漏桶算法、令牌桶算法)</del></p>
<blockquote>
<p>限制单位时间的请求数，避免流量洪峰打垮服务</p>
<ul>
<li>漏桶算法：匀速出水，适合平滑限流</li>
<li>令牌桶算法：按需取令牌，适合突发流量控制</li>
</ul>
<p>📍 实现工具：Sentinel、Gateway限流、Bucket4j、RateLimiter</p>
</blockquote>
</li>
</ul>
<p><span style = "color:red"><strong>你们项目中有没有做到限流？怎么做的？&amp;&amp; 限流常见的算法有哪些？？</strong></span></p>
<blockquote>
<p>① 先来介绍一下业务，什么情况下去做限流，需要说明<strong>QPS</strong>具体是多少</p>
<ul>
<li>我们有一个活动，到了假期就会抢购优惠券，QPS最高可以达到2000，平时10-50之间，为了应对突发流量，需要做限流</li>
<li>常规限流，为了防止恶意攻击，保护系统正常运行，我们当时系统能够承受最大的QPS是多少(压测结果)</li>
</ul>
<p>② <strong>nginx限流</strong></p>
<ul>
<li>控制速率(突发流量)，使用的<strong>漏桶算法</strong>来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的连接数和并发链接的总数</li>
</ul>
<p>③ <strong>网关限流</strong></p>
<ul>
<li>在SpringCloudGateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</blockquote>
<blockquote>
<h4 id="解释原理："><a href="#解释原理：" class="headerlink" title="解释原理："></a>解释原理：</h4><p>QPS（Queries Per Second，每秒查询率）是衡量一个系统处理请求能力的指标，它表示服务器在一秒钟内能够处理的查询数量。这个指标常用于数据库和web服务器等应用，以评估系统在高并发情况下的性能。<br>以下是对您提到的两句话的分析：</p>
<ol>
<li><strong>活动期间的高并发处理：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> 在电子商务等应用中，促销活动往往会引起用户的大量点击和购买行为，导致短时间内流量剧增。</li>
<li><strong>限流原理：</strong> 为了应对这种突发的高流量，系统需要实施限流措施。限流是为了保护系统资源不被过度消耗，确保系统的稳定性和可靠性。常见的限流算法有固定窗口、滑动窗口、令牌桶和漏桶等。</li>
</ul>
<p><code>固定窗口： 假设每 1 分钟允许 100 次请求，10:00:00 到 10:01:00 期间的 100 次请求被允许，超出 100 次则会被限流，10:01:00 到 10:02:00 则重新开始计算。</code></p>
<p><code>滑动窗口： 每 60 秒内最多允许 100 次请求，滑动窗口的时间长度为 60 秒，窗口内的请求数会随着时间滑动更新，防止请求在时间边界上积压</code></p>
<p><code>令牌桶：假设每秒生成 10 个令牌，令牌桶的容量为 100 个令牌。如果 1 秒内有 15 个请求到达，则前 10 个请求能获得令牌并继续执行，剩余的 5 个请求需要等到下一个时间窗口令牌生成后再执行。</code></p>
<p><code>漏桶：假设每秒钟流出 10 个请求，漏桶的容量为 100 个请求。如果 1 秒钟内接收了 30 个请求，系统只会处理 10 个请求，剩余的 20 个请求被丢弃，直到下一个时间点。</code></p>
<ul>
<li><strong>实施方式：</strong> 在您提到的情况下，可以采用以下策略：<ul>
<li><strong>预判性扩容：</strong> 根据历史数据和活动规模预测流量，提前进行服务器资源的扩容。</li>
<li><strong>动态限流：</strong> 在活动期间，根据实时监控的QPS数据动态调整限流阈值，保证系统平稳运行。</li>
<li><strong>排队处理：</strong> 对于超出系统处理能力的请求，可以采用队列进行缓冲，分批次处理。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>常规限流与系统最大承受QPS：</strong></li>
</ol>
<ul>
<li><strong>背景知识：</strong> <strong>常规限流</strong>是为了在日常运行中防止恶意攻击（如<strong>DDoS攻击</strong>）和保护系统资源不被滥用。</li>
<li><strong>压测结果：</strong> 系统的最大承受QPS是通过压力测试得出的。压力测试（也称为负载测试）是通过模拟高并发访问来测试系统的极限性能，以确定系统在保证稳定运行的前提下能够承受的最大QPS。</li>
<li><strong>原理分析：</strong> <ul>
<li><strong>保护系统：</strong> 通过设定一个QPS上限，可以防止系统过载，保障系统的正常运行。</li>
<li><strong>资源分配：</strong> 了解系统的最大承受QPS有助于合理分配资源，如数据库连接、内存和CPU等。</li>
<li><strong>用户体验：</strong> 适当的限流可以保证用户的体验，避免因系统过载导致的响应缓慢或服务不可用。<br>在实施限流策略时，还需要考虑以下因素：</li>
</ul>
</li>
<li><strong>业务优先级：</strong> 对于不同的业务请求，可能需要有不同的限流策略，优先保证核心功能的可用性。</li>
<li><strong>用户体验：</strong> 限流策略应尽量减少对用户体验的影响，例如通过友好的错误提示或降级方案。</li>
<li><strong>数据监控：</strong> 实时监控系统的QPS和其他关键指标，以便快速响应并调整限流策略。<br> 综上所述，限流是确保系统在高并发情况下稳定运行的重要措施，而了解系统的最大承受QPS是制定合理限流策略的基础。</li>
</ul>
</blockquote>
<p>为什么要限流？</p>
<ul>
<li><strong>并发业务量大</strong>(突发流量)</li>
<li>防止用户<strong>恶意刷接口</strong></li>
</ul>
<h6 id="限流的实现方式："><a href="#限流的实现方式：" class="headerlink" title="限流的实现方式："></a>限流的实现方式：</h6><ul>
<li><p>&#x3D;&#x3D;<strong>Tomcat</strong>&#x3D;&#x3D;<del>单体项目可以,分布式不行</del>：可以设置最大连接数 <code>&lt;Connector port=&quot;8080&quot;...maxThreads=&quot;150&quot;...&gt;</code></p>
</li>
<li><p>&#x3D;&#x3D;<strong>Nginx</strong>&#x3D;&#x3D;：<strong>漏桶算法</strong><del>固定速率露出(平滑)</del></p>
<p>控制速率(突发流量)</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/8090ab914e03e67198de3dd121167624b5c3a541/Nginx%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E9%99%90%E6%B5%81.png" style="zoom: 200%;" />
</li>
<li><p>&#x3D;&#x3D;<strong>网关</strong>&#x3D;&#x3D;：<strong>令牌桶算法</strong></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/e32511e92db5c1c27f7fad58f5078039014016a6/%E7%BD%91%E5%85%B3%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" style="zoom: 200%;" />
</li>
<li><p>自定义拦截器</p>
</li>
</ul>
<blockquote>
<h5 id="echos-gateway真实案例"><a href="#echos-gateway真实案例" class="headerlink" title="echos-gateway真实案例"></a>echos-gateway真实案例</h5><h3 id="🔷-1-网关服务名称-动态发现配置"><a href="#🔷-1-网关服务名称-动态发现配置" class="headerlink" title="🔷 1. 网关服务名称 + 动态发现配置"></a>🔷 1. 网关服务名称 + 动态发现配置</h3><pre><code>spring:
  application:
    name: ech-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.188.120:8848
</code></pre>
<ul>
<li><strong>知识点</strong>：Gateway 是 Spring Cloud 架构中的 API 网关，用于请求路由、统一鉴权、日志跟踪、限流、熔断等功能。</li>
<li><strong>动态路由注册中心配置</strong>：接入 Nacos 注册中心，自动发现服务实例。</li>
</ul>
<hr>
<h3 id="🔷-2-Gateway-路由规则（重点）"><a href="#🔷-2-Gateway-路由规则（重点）" class="headerlink" title="🔷 2. Gateway 路由规则（重点）"></a>🔷 2. Gateway 路由规则（重点）</h3><pre><code>spring:
  cloud:
    gateway:
      routes:
        - id: zk-sam-service
          uri: lb://ech-sam-cs
          predicates:
            - Path=/iclock/**
</code></pre>
<h4 id="🧠-面试要点："><a href="#🧠-面试要点：" class="headerlink" title="🧠 面试要点："></a>🧠 面试要点：</h4><ul>
<li><code>id</code>: 路由唯一标识</li>
<li><code>uri: lb://xxx</code>: 表示使用 <strong>负载均衡方式</strong> 路由到注册中心中 <code>xxx</code> 的实例（通过 Ribbon&#x2F;LoadBalancer 实现）</li>
<li><code>Path</code>: 路径断言，匹配路径开头为 <code>/iclock/**</code> 的请求</li>
<li><code>filters: StripPrefix=1</code>: 去除路径中的第一级前缀（如 <code>/ech-service/a/b</code> → <code>/a/b</code>）</li>
</ul>
<hr>
<h3 id="🔷-3-自动路由发现开启"><a href="#🔷-3-自动路由发现开启" class="headerlink" title="🔷 3. 自动路由发现开启"></a>🔷 3. 自动路由发现开启</h3><pre><code>discovery:
  locator:
    enabled: true
    lower-case-service-id: true
</code></pre>
<h4 id="🧠-面试延申："><a href="#🧠-面试延申：" class="headerlink" title="🧠 面试延申："></a>🧠 面试延申：</h4><ul>
<li><strong>enabled&#x3D;true</strong>：允许网关根据注册中心中注册的服务自动创建路由（简化配置）</li>
<li><strong>lower-case-service-id&#x3D;true</strong>：将服务名小写化，避免大小写不一致导致路由失败</li>
</ul>
<blockquote>
<p>面试官可能问：<br> “你们项目中是手动配置路由还是用 locator 自动发现？哪种方式更推荐？”</p>
</blockquote>
<p>✅ <strong>回答思路：</strong></p>
<ul>
<li>自动发现适合内部测试环境，快速接入新服务</li>
<li>生产建议手动配置，便于管理、加权限、加限流、避免误暴露</li>
</ul>
<hr>
<h2 id="✅-三、Feign配置部分（Gateway下游调用）"><a href="#✅-三、Feign配置部分（Gateway下游调用）" class="headerlink" title="✅ 三、Feign配置部分（Gateway下游调用）"></a>✅ 三、Feign配置部分（Gateway下游调用）</h2><pre><code>feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: full
  httpclient:
    enabled: false
  okhttp:
    enabled: false
</code></pre>
<h3 id="✅-面试可延申："><a href="#✅-面试可延申：" class="headerlink" title="✅ 面试可延申："></a>✅ 面试可延申：</h3><ul>
<li>Feign 的连接&#x2F;读取超时时间如何设置？</li>
<li>loggerLevel 有哪些级别（NONE&#x2F;BASIC&#x2F;HEADERS&#x2F;FULL）？</li>
<li>Feign 支持哪几种底层 HTTP 客户端？为什么要关掉 HttpClient&#x2F;OkHttp？</li>
</ul>
<hr>
<h2 id="✅-四、Redis连接池配置（网关限流、缓存常用）"><a href="#✅-四、Redis连接池配置（网关限流、缓存常用）" class="headerlink" title="✅ 四、Redis连接池配置（网关限流、缓存常用）"></a>✅ 四、Redis连接池配置（网关限流、缓存常用）</h2><pre><code>spring:
  redis:
    database: 12
    host: 192.168.188.120
    port: 6379
    lettuce:
      pool:
        max-active: 1000
        max-idle: 10
        min-idle: 5
</code></pre>
<h3 id="✅-面试展开："><a href="#✅-面试展开：" class="headerlink" title="✅ 面试展开："></a>✅ 面试展开：</h3><ul>
<li><p>为什么使用 Redis？</p>
<blockquote>
<p>作为 <strong>限流、缓存、黑名单过滤、Token 存储</strong> 后端，具备高性能分布式能力</p>
</blockquote>
</li>
<li><p>你们用 Lettuce 还是 Jedis？区别在哪？</p>
</li>
</ul>
<hr>
<h2 id="✅-五、Actuator配置（服务监控）"><a href="#✅-五、Actuator配置（服务监控）" class="headerlink" title="✅ 五、Actuator配置（服务监控）"></a>✅ 五、Actuator配置（服务监控）</h2><pre><code>management:
  server:
    port: 9090
</code></pre>
<ul>
<li>暴露 Spring Boot Actuator 指标信息，常用于结合 Prometheus&#x2F;Grafana 做监控</li>
<li>可暴露如 <code>/actuator/health</code>、<code>/metrics</code>、<code>/gateway/routes</code> 等</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>你们的微服务是怎么监控的？</strong></span></p>
<blockquote>
<p><strong>我们项目中采用的skywalking进行监控的</strong></p>
<ul>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，我们可以针对性的分析和优化。</li>
<li>我们还在skywalking设置了告警规则，特别是在项目上线以后，如果报错，我们分别设置了可以给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</li>
</ul>
</blockquote>
<h6 id="skywalking"><a href="#skywalking" class="headerlink" title="skywalking"></a>skywalking</h6><p>一个分布式系统的应用程序性能监控工具(Application Performance Management), 提供了完善的链路追踪能力，apache的顶级项目(前华为产品经理吴晟主导开源)</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/889f98186e8bf25ea018e80457f9333fef009d07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A71.jpg"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/33749d5ca478f04bee93c83339a877330485f51a/skywalking%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1.png"></p>
<blockquote>
<h4 id="✅-面试追问题-amp-答法建议"><a href="#✅-面试追问题-amp-答法建议" class="headerlink" title="✅ 面试追问题 &amp; 答法建议"></a>✅ 面试追问题 &amp; 答法建议</h4><table>
<thead>
<tr>
<th>面试官可能追问的问题</th>
<th>答题建议</th>
</tr>
</thead>
<tbody><tr>
<td>🔸SkyWalking 是怎么接入项目的？</td>
<td>我们使用 Java Agent 的方式，启动时通过 <code>-javaagent:/path/to/skywalking-agent.jar</code> 加载探针，同时在 <code>agent.config</code> 中配置服务名、采集后端等</td>
</tr>
<tr>
<td>🔸和 Zipkin、Prometheus 相比有什么优劣？</td>
<td>SkyWalking 支持 UI 更强，适合链路分析；Prometheus 更适合指标监控配合 Grafana；Zipkin 更轻量但功能少。SkyWalking 是综合性最强的一款</td>
</tr>
<tr>
<td>🔸SkyWalking 的数据存储用的什么？</td>
<td>默认是 ElasticSearch，也支持 H2（测试环境），生产建议搭配 ES 做查询与聚合</td>
</tr>
<tr>
<td>🔸你怎么通过 SkyWalking 优化过接口？</td>
<td>我们发现某个接口 RT 超过 1 秒，通过 Trace 发现是 MySQL 多表 Join 查询导致，优化了 SQL 才解决的</td>
</tr>
<tr>
<td>🔸SkyWalking 能采集哪些组件的数据？</td>
<td>HTTP请求、Dubbo、MySQL、Redis、Kafka、RocketMQ、Elasticsearch 等主流中间件都有探针支持</td>
</tr>
</tbody></table>
<h4 id="✅-加分拓展：如何实现全链路追踪？"><a href="#✅-加分拓展：如何实现全链路追踪？" class="headerlink" title="✅ 加分拓展：如何实现全链路追踪？"></a>✅ 加分拓展：如何实现全链路追踪？</h4><p>SkyWalking 通过在每个服务部署时<strong>挂载探针（agent）</strong>，实现对请求头中 traceId 的自动传递，采集：</p>
<ul>
<li>入参出参（拦截 Controller 层、Feign、RestTemplate）</li>
<li>RPC调用（如Dubbo&#x2F;Feign）</li>
<li>数据库执行耗时</li>
<li>Redis访问</li>
<li>MQ消息链路</li>
</ul>
<p>最终统一聚合在 SkyWalking OAP 端，再通过 Web UI 展示，形成完整的 <strong>“调用链 + 指标 + 日志”</strong> 三位一体监控体系。</p>
<h2 id="✅-项目答题串联建议"><a href="#✅-项目答题串联建议" class="headerlink" title="✅ 项目答题串联建议"></a>✅ 项目答题串联建议</h2><p>你可以在项目介绍环节自然引入这段内容，例如👇：</p>
<blockquote>
<p>为了保障我们微服务系统的稳定性，我们在项目中接入了 SkyWalking 作为 APM 工具。通过它我们做到了链路追踪、性能分析、异常预警等。特别在压测和上线之后，能第一时间通过短信和邮件告警通知我们，提升了系统稳定性和定位效率。</p>
</blockquote>
<p>探针（<strong>Agent</strong>）本质上是一个<strong>Java 程序运行时的字节码增强器</strong>，可以在<strong>不修改源码的前提下</strong>，对目标应用的类和方法进行增强，从而实现请求数据的“埋点采集”。</p>
<hr>
<h3 id="✅-简单理解：探针干了啥？"><a href="#✅-简单理解：探针干了啥？" class="headerlink" title="✅ 简单理解：探针干了啥？"></a>✅ 简单理解：探针干了啥？</h3><p>可以这样比喻👇</p>
<blockquote>
<p>你写的业务代码是演员<br> 探针就是藏在台下的摄像机<br> 它在你表演的时候偷偷把你的一举一动都记录下来（记录你调了哪个接口，用了多久，是不是出错了）</p>
</blockquote>
<hr>
<h3 id="✅-具体工作原理："><a href="#✅-具体工作原理：" class="headerlink" title="✅ 具体工作原理："></a>✅ 具体工作原理：</h3><ol>
<li><strong>运行时注入字节码</strong><ul>
<li>探针是以 <code>-javaagent</code> 参数的形式加载到 JVM 中</li>
<li>JVM 启动时，探针会监听所有类的加载过程，选择特定的类（如 <code>Controller</code>、<code>RestTemplate</code>、<code>JdbcTemplate</code>、<code>RedisTemplate</code>）进行增强</li>
</ul>
</li>
<li><strong>插入监控逻辑</strong><ul>
<li>在方法的前后插入监控逻辑：<ul>
<li>方法开始时记录时间</li>
<li>方法执行完记录耗时、返回值</li>
<li>如果抛出异常，也能捕获异常堆栈</li>
</ul>
</li>
</ul>
</li>
<li><strong>traceId 传递</strong><ul>
<li>每个请求入口（比如 SpringMVC Controller）会生成一个全局 <code>traceId</code></li>
<li>这个 ID 会自动透传到下游服务，比如 Feign 调用、MQ 发送、数据库访问等</li>
<li>最终串成一条完整的调用链路</li>
</ul>
</li>
</ol>
<h3 id="✅-示例："><a href="#✅-示例：" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><p>比如你访问这个接口：</p>
<pre><code class="java">@GetMapping(&quot;/user/&#123;id&#125;&quot;)
public User getUser(@PathVariable Long id) &#123;
    return userService.getById(id);
&#125;
</code></pre>
<blockquote>
<p>探针实际会在你这个方法前后<strong>偷偷插入逻辑</strong>（伪代码）：</p>
</blockquote>
<pre><code class="java">// 前置逻辑：记录 traceId、时间戳
recordTrace(&quot;traceId-xxx&quot;);
startTime = System.currentTimeMillis();

User result = userService.getById(id);

// 后置逻辑：记录耗时
long cost = System.currentTimeMillis() - startTime;
sendToSkywalking(traceId, methodName, cost);
</code></pre>
<p>探针就是自动化“打点采集 + 数据上传”的代码增强器，开箱即用，不入侵业务代码。</p>
</blockquote>
<p><span style = "color:red"><strong>解释一下CAP和BASE<del>分布式系统理论</del></strong></span></p>
<blockquote>
<ul>
<li>CAP 定理(一致性、可用性、分区容错性)</li>
</ul>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题(P)</li>
<li>当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足</li>
</ol>
<ul>
<li>BASE理论</li>
</ul>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<ul>
<li>解决分布式事务的思想和模型</li>
</ul>
<ol>
<li><u>最终一致思想</u>：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)</li>
<li><u>强一致思想</u>：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</li>
</ol>
</blockquote>
<ul>
<li>分布式事务方案的指导</li>
<li>分布式系统设计方向</li>
<li>根据业务指导使用正确的技术选择</li>
</ul>
<h5 id="x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标"><a href="#x3D-x3D-CAP定理-x3D-x3D-分布式系统无法同时满足三个指标" class="headerlink" title="&#x3D;&#x3D;CAP定理&#x3D;&#x3D;分布式系统无法同时满足三个指标"></a>&#x3D;&#x3D;CAP定理&#x3D;&#x3D;<del>分布式系统无法同时满足三个指标</del></h5><p>CAP 定理是 <strong>数学证明出来的分布式理论限制</strong>，<strong>不是人为规定的规则，而是无法回避的“物理规律”</strong></p>
<ul>
<li>&#x3D;&#x3D;<strong>Consistency</strong>&#x3D;&#x3D;（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。<del>主从一致</del></li>
<li>&#x3D;&#x3D;<strong>Availability</strong>&#x3D;&#x3D;（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li>
<li>&#x3D;&#x3D;<strong>Partition</strong> tolerance&#x3D;&#x3D;（分区容错性）：当出现网络分区现象后，系统能够继续运行<ul>
<li>Partition（分区）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点失去链接，形成独立分区</li>
<li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>分布式系统节点之间肯定是需要网络链接的，<strong>分区 (P) 必然存在</strong></li>
<li><u>如果保证访问的高可用性（<strong>A</strong>）可以持续对外提供服务</u>，但不能保证数据的强一致性 <strong>AP</strong></li>
<li><u>如果保证访问的数据强一致性（C）就要放弃高可用性</u> <strong>CP</strong></li>
</ul>
<blockquote>
<h3 id="🎯-CAP-的结论："><a href="#🎯-CAP-的结论：" class="headerlink" title="🎯 CAP 的结论："></a>🎯 CAP 的结论：</h3><blockquote>
<p><strong>在分布式系统中，</strong>由于网络问题不可避免（P必选），所以只能在 C 和 A 之间选其一：</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP 系统</strong></td>
<td>放弃可用性，保证一致性</td>
<td>银行&#x2F;支付系统（宁可服务不可用，也不能出错）</td>
</tr>
<tr>
<td><strong>AP 系统</strong></td>
<td>放弃一致性，保证可用性</td>
<td>电商商品浏览、社交系统（稍微不一致无所谓）</td>
</tr>
</tbody></table>
<h2 id="为什么-CAP-无法同时满足？"><a href="#为什么-CAP-无法同时满足？" class="headerlink" title="为什么 CAP 无法同时满足？"></a>为什么 CAP 无法同时满足？</h2><p>我们来看一个例子理解「<strong>一致性（C） vs 可用性（A）</strong> 在分区故障（P）下的矛盾」：</p>
<hr>
<h3 id="❗-场景设定："><a href="#❗-场景设定：" class="headerlink" title="❗ 场景设定："></a>❗ 场景设定：</h3><ul>
<li>系统有两个节点：<strong>节点A 和 节点B</strong></li>
<li>正常时，A 和 B 通过网络通信同步数据</li>
<li>现在发生了网络分区（<strong>P</strong>）：A 和 B 之间<strong>断网了！</strong></li>
</ul>
<hr>
<h3 id="🧩-你怎么选？C-和-A-只能二选一："><a href="#🧩-你怎么选？C-和-A-只能二选一：" class="headerlink" title="🧩 你怎么选？C 和 A 只能二选一："></a>🧩 你怎么选？C 和 A 只能二选一：</h3><h4 id="✅-如果你要保证【一致性-C】："><a href="#✅-如果你要保证【一致性-C】：" class="headerlink" title="✅ 如果你要保证【一致性 C】："></a>✅ 如果你要保证【<strong>一致性 C</strong>】：</h4><ul>
<li>当客户端向 A 节点写数据时，为了保证一致性，A <strong>必须等待 B 同步成功</strong></li>
<li>但现在 A 和 B 网络断了，同步不了</li>
<li>所以 A 只能拒绝请求：<strong>不响应</strong> —— ❌ 违反了<strong>可用性 A</strong></li>
</ul>
<h4 id="✅-如果你要保证【可用性-A】："><a href="#✅-如果你要保证【可用性-A】：" class="headerlink" title="✅ 如果你要保证【可用性 A】："></a>✅ 如果你要保证【<strong>可用性 A</strong>】：</h4><ul>
<li>A 收到写请求就立刻接受并返回成功</li>
<li>但 B 此时拿到的还是老数据</li>
<li>数据就不一致了 —— ❌ 违反了<strong>一致性 C</strong></li>
</ul>
<hr>
<h3 id="🎯-所以：在【网络分区-P】已发生的前提下-——"><a href="#🎯-所以：在【网络分区-P】已发生的前提下-——" class="headerlink" title="🎯 所以：在【网络分区 P】已发生的前提下 ——"></a>🎯 所以：在【网络分区 P】已发生的前提下 ——</h3><p><strong>你只能选：C+A ❌，C+P ✅，A+P ✅</strong></p>
<p>这就是 CAP 定理的本质逻辑。<br>所以我们在设计系统时必须做<strong>权衡</strong> —— 这正是分布式架构的难点和美感所在。</p>
</blockquote>
<h5 id="x3D-x3D-BASE理论-x3D-x3D"><a href="#x3D-x3D-BASE理论-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;BASE理论&#x3D;&#x3D;"></a>&#x3D;&#x3D;BASE理论&#x3D;&#x3D;</h5><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p>
<ul>
<li>&#x3D;&#x3D;<strong>Basically Avaliable</strong>&#x3D;&#x3D;（基本可用）：分布式系统在出现故时，允许损失部分可用性，即保证核心可用</li>
<li>&#x3D;&#x3D;<strong>Soft State</strong>&#x3D;&#x3D;（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态</li>
<li>&#x3D;&#x3D;<strong>Eventually Consistent</strong>&#x3D;&#x3D;（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3f0f7a676a51ce6dded96d7c6a910a7c6b763d99/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%92%88%E5%AF%B9CAP%E7%9A%84BASE%E7%90%86%E8%AE%BA.jpg"></p>
<blockquote>
<h4 id="🎯-举个通俗易懂的例子："><a href="#🎯-举个通俗易懂的例子：" class="headerlink" title="🎯 举个通俗易懂的例子："></a>🎯 举个通俗易懂的例子：</h4><p>你去银行转账，系统提示：“<strong>资金将在2小时内到账</strong>”。这就是：</p>
<ul>
<li>✅ 系统可用（你能转账）</li>
<li>✅ 软状态（中间状态是“处理中”）</li>
<li>✅ 最终一致（2小时内一定到账）</li>
</ul>
<p>这就符合 BASE 理论。</p>
<hr>
<h4 id="✅-BASE-与-CAP-的关系？"><a href="#✅-BASE-与-CAP-的关系？" class="headerlink" title="✅ BASE 与 CAP 的关系？"></a>✅ BASE 与 CAP 的关系？</h4><table>
<thead>
<tr>
<th>理论</th>
<th>类型</th>
<th>强调</th>
</tr>
</thead>
<tbody><tr>
<td>CAP</td>
<td>理论限制</td>
<td>三选二原则，强调不可能同时满足一致性、可用性、分区容错</td>
</tr>
<tr>
<td>BASE</td>
<td>实践理念</td>
<td>放弃强一致性，追求最终一致，以换取系统可用性与性能</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/data/CAP%E5%AE%9A%E7%90%86.jpg?raw=true"></p>
<p><span style = "color:red"><strong>你们采用哪种分布式事务解决方案？</strong></span></p>
<blockquote>
<p>● 简历上写的微服务，只要是发生了多个服务之间的<strong>写操作</strong>，都需要进行分布式事务控制</p>
<p>● 描述项目中采用的哪种方案(seataMQ)<br>⚪ seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ seata的AT模式，AP，底层使用undolog 实现，性能好 (<span style = "color:red"><strong>互联网业务</strong></span> )<br>⚪ seata的TCC模式，AP，性能较好，不过需要人工编码实现 (<span style = "color:red"><strong>银行业务</strong></span> )<br>⚪ MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务异步，性能最好 (<span style = "color:red"><strong>互联网业务</strong></span> )</p>
<h3 id="✅-你的理解：Seata-的-XA-≈-CP，AT-≈-AP？"><a href="#✅-你的理解：Seata-的-XA-≈-CP，AT-≈-AP？" class="headerlink" title="✅ 你的理解：Seata 的 XA ≈ CP，AT ≈ AP？"></a>✅ 你的理解：<strong>Seata 的 XA ≈ CP，AT ≈ AP？</strong></h3><h4 id="Seata-是实现，CAP-是原则"><a href="#Seata-是实现，CAP-是原则" class="headerlink" title="Seata 是实现，CAP 是原则"></a>Seata 是实现，CAP 是原则</h4><p>你这样理解<strong>有一定道理</strong>，但这两者并不是等价关系。<br>Seata 是一种“<strong>解决分布式事务问题的技术方案</strong>”，目的是确保多个数据库操作的一致性，属于 <strong>CAP 中的一致性实现策略之一</strong>，但不能反过来说它就是 CAP 的实现。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th><strong>Seata XA &#x2F; AT 模式</strong></th>
<th><strong>CAP 理论中的 CP &#x2F; AP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>一种<strong>分布式事务协议实现</strong></td>
<td>一种<strong>分布式系统权衡模型</strong></td>
</tr>
<tr>
<td>关注点</td>
<td>一致性、事务原子性</td>
<td>可用性 vs 一致性 vs 分区容忍性</td>
</tr>
<tr>
<td>使用背景</td>
<td>数据库操作级别的事务控制</td>
<td>整个分布式系统的架构设计选择</td>
</tr>
</tbody></table>
<h2 id="🟢-Seata-为什么要设计成-XA、AT-两种模式？"><a href="#🟢-Seata-为什么要设计成-XA、AT-两种模式？" class="headerlink" title="🟢 Seata 为什么要设计成 XA、AT 两种模式？"></a>🟢 Seata 为什么要设计成 XA、AT 两种模式？</h2><p>因为不同的业务场景对性能 vs 一致性 的需求不同，Seata 提供了“可插拔”式的事务解决方案：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>一致性</th>
<th>性能</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>XA模式（两阶段提交）</strong></td>
<td>强一致性</td>
<td>性能差、资源占用多</td>
<td>接近传统分布式事务，事务期间资源锁定</td>
</tr>
<tr>
<td><strong>AT模式（自动补偿）</strong></td>
<td>最终一致性</td>
<td>性能好</td>
<td>非侵入，靠 Undo Log 回滚操作，适用于大部分业务场景</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>Seata框架(XA、AT、TCC)</li>
<li>MQ</li>
</ul>
<h4 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h4><ul>
<li><strong>TC</strong>(Transaction Coordinator) - <strong>事务协调者</strong>：<u>维护全局和分支事务的状态，协调全局事务提交或回滚</u></li>
<li><strong>TM</strong>(Transaction Manager) - <strong>事务管理器</strong>：定义全局事务的范围、开启全局事务、提交或回滚全局事务</li>
<li><strong>RM</strong>(Resource Manager) - <strong>资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li>
</ul>
<blockquote>
<p>Seata 的 XA 和 AT 确实在一致性与可用性方面体现了 CAP 的设计权衡，但它并不是 CAP 的实现，而是面向分布式事务的一种<strong>可插拔事务解决方案</strong>。Seata 架构之所以独立，是因为它提供了统一的事务协调服务，支持多种协议（XA&#x2F;AT&#x2F;TCC&#x2F;SAGA），以满足不同业务场景对一致性和性能的需求，这在真实的微服务架构中非常关键。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/30dd6983ec4340d3f3f4118f3d5ccf89e4199555/XA%2CAT%2CTCC.png"></p>
<p><span style = "color:red"><strong>分布式服务的<u>接口幂等性</u>如何设计？</strong></span></p>
<blockquote>
<ul>
<li>幕等：多次调用方法或者接口不务状态，可以<strong>保证重复调用的结果和单次调用的结果一致</strong>；常用于支付、下单等关键业务防止<strong>重复提交</strong>。</li>
<li>如果是**<u>新增数据</u>**，可以使用数据库的唯一索引</li>
<li>如果是**<u>新增或修改数据</u>**<ul>
<li>分布式锁，性能较低</li>
<li>使用token+redis来实现，性能较好<br>●  第一次请求，生成一个唯一token存入redis，返回给前端<br>●  第二次请求，业务处理，携带之前的token，到redis进行验证，如果存在，可以执行业务，删除token; 如果不存在，则直接返回，不处理业务</li>
</ul>
</li>
</ul>
<h4 id="🧠-一、什么是幂等性？"><a href="#🧠-一、什么是幂等性？" class="headerlink" title="🧠 一、什么是幂等性？"></a>🧠 一、什么是幂等性？</h4><ul>
<li>幂等性是指：<strong>一次和多次请求同一个接口，对资源的影响是相同的</strong></li>
<li>幂等操作的特性是：<strong>无副作用（No Side Effect）</strong></li>
</ul>
<h4 id="📌-二、幂等性为什么重要？"><a href="#📌-二、幂等性为什么重要？" class="headerlink" title="📌 二、幂等性为什么重要？"></a>📌 二、幂等性为什么重要？</h4><h5 id="会出现重复调用的原因："><a href="#会出现重复调用的原因：" class="headerlink" title="会出现重复调用的原因："></a>会出现重复调用的原因：</h5><ul>
<li>网络抖动、页面重复点击</li>
<li>分布式事务重试机制</li>
<li>网关重试、MQ重复投递</li>
<li>前端误操作（如双击支付按钮）</li>
</ul>
<h4 id="🎯-三、幂等性保障方案（重点）"><a href="#🎯-三、幂等性保障方案（重点）" class="headerlink" title="🎯 三、幂等性保障方案（重点）"></a>🎯 三、幂等性保障方案（重点）</h4><table>
<thead>
<tr>
<th>场景</th>
<th>适用范围</th>
<th>实现方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 数据库唯一约束</td>
<td>新增接口</td>
<td>通过唯一索引防止重复插入</td>
<td>简单高效</td>
</tr>
<tr>
<td>✅ Token机制 + Redis</td>
<td>提交类（订单、支付）</td>
<td>一次性Token防止重复提交</td>
<td>推荐，效率高</td>
</tr>
<tr>
<td>✅ 分布式锁</td>
<td>修改、转账等接口</td>
<td>基于Redisson、ZK等实现同步控制</td>
<td>精准，但性能稍差</td>
</tr>
<tr>
<td>✅ 接口幂等表</td>
<td>所有需幂等接口</td>
<td>记录请求唯一标识 + 状态</td>
<td>控制最强，适合高并发</td>
</tr>
<tr>
<td>✅ 乐观锁（版本号机制）</td>
<td>更新操作</td>
<td>防止并发更新，CAS思想</td>
<td>要求带版本号字段</td>
</tr>
<tr>
<td>✅ 幂等组件中间件</td>
<td>通用接口平台</td>
<td>拦截层统一幂等处理</td>
<td>企业封装，灵活可控</td>
</tr>
</tbody></table>
<h4 id="🔨-Token-Redis-实现幂等（推荐）"><a href="#🔨-Token-Redis-实现幂等（推荐）" class="headerlink" title="🔨 Token+Redis 实现幂等（推荐）"></a>🔨 Token+Redis 实现幂等（推荐）</h4><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol>
<li>客户端请求创建订单，先调用接口获取 <code>幂等Token</code></li>
<li>后续提交时在请求头中携带该 Token</li>
<li>服务端收到请求：<ul>
<li>判断 Redis 中是否存在该 Token</li>
<li>若存在，则处理业务并删除 Token</li>
<li>若不存在，说明已处理或重复请求，直接返回</li>
</ul>
</li>
</ol>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>轻量级，无锁高并发</li>
<li>可扩展性强，适用于 POST&#x2F;PUT 等需要控制的接口</li>
</ul>
</blockquote>
<p><strong>幂等</strong>：<u>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</u></p>
<h6 id="需要幂等场景"><a href="#需要幂等场景" class="headerlink" title="需要幂等场景"></a>需要幂等场景</h6><ul>
<li>用户重复点击(网络波动)</li>
<li>MQ消息重复</li>
<li>应用使用失败或超时</li>
</ul>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>说明</th>
<th>是否天然幂等</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>查询操作，天然幂等</td>
<td>✅ 是</td>
</tr>
<tr>
<td>POST</td>
<td>新增操作，请求一次与请求多次造成的结果不同，<strong>不是幂等的</strong></td>
<td>❌ 否</td>
</tr>
<tr>
<td>PUT</td>
<td>更新操作，如果是以绝对值更新，则是幂等的。如果是通过增量的方式更新，则<strong>不是幂等的</strong></td>
<td>✅ 是（全量）或❌ 否（增量）</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除操作，根据唯一值删除，是幂等的</td>
<td>✅ 是（按主键）</td>
</tr>
</tbody></table>
<pre><code class="mysql">-- 幂等更新：将余额设置为固定值
UPDATE account SET money = 500 WHERE id = 1;

-- 非幂等更新：余额加上500
UPDATE account SET money = money + 500 WHERE id = 1;
</code></pre>
<ul>
<li><p><strong>数据库唯一索引</strong>【新增】</p>
</li>
<li><p><strong>&#x3D;&#x3D;token + redis&#x3D;&#x3D;</strong> 【新增+修改】**<u>AND</u>**  <strong>&#x3D;&#x3D;分布式锁&#x3D;&#x3D;</strong> 【新增+修改】</p>
<blockquote>
<h2 id="🧠-面试答题思路模板"><a href="#🧠-面试答题思路模板" class="headerlink" title="🧠 面试答题思路模板"></a>🧠 面试答题思路模板</h2><p>我们项目中对于需要幂等性的接口（如支付、下单等），主要采用了<strong>Token + Redis机制</strong>：</p>
<ul>
<li>请求前由前端向后端申请一次性 Token</li>
<li>后续接口请求中携带该 Token</li>
<li>后端通过 Redis 判断 Token 是否存在，从而保证接口只被处理一次</li>
</ul>
<p>此外，对于批量创建类操作，还会结合<strong>数据库唯一索引</strong>控制幂等，对于状态更新类操作会使用<strong>乐观锁</strong>或<strong>分布式锁</strong>。</p>
</blockquote>
<h6 id="创建商品、提交订单、转账、支付等操作"><a href="#创建商品、提交订单、转账、支付等操作" class="headerlink" title="创建商品、提交订单、转账、支付等操作"></a>创建商品、提交订单、转账、支付等操作</h6></li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/58b8b5385bf3e40c1661e824f613b15f57686549/token+redis%20AND%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" style="zoom:200%;" />



<p><span style = "color:red"><strong>你们项目中使用了什么分布式任务调度</strong></span></p>
<p><code>xxl-job</code> 是一个分布式任务调度平台，它致力于解决分布式场景下的任务调度问题，主要由调度中心和执行器两部分组成。调度中心负责统一管理任务调度，而执行器则是负责接收调度并执行任务逻辑的客户端。</p>
<blockquote>
<h2 id="🎯-一句话总结"><a href="#🎯-一句话总结" class="headerlink" title="🎯 一句话总结"></a>🎯 一句话总结</h2><blockquote>
<p>我们项目使用的是 <strong>XXL-Job</strong> 分布式任务调度平台，用来实现定时任务管理，比如取消订单、同步库存、发送通知等，解决了分布式环境下定时任务重复、不可控的问题。</p>
</blockquote>
</blockquote>
<ul>
<li><p><span style = "color:red"><strong>xxl-job路由策略有哪些？</strong></span></p>
<blockquote>
<p>xxl-job提供了很多的路由策略，我们平时用的较多的就是：<strong>轮询、故障转移、分片广播</strong></p>
<h2 id="🚦-路由策略有哪些？（面试重点）"><a href="#🚦-路由策略有哪些？（面试重点）" class="headerlink" title="🚦 路由策略有哪些？（面试重点）"></a>🚦 路由策略有哪些？（面试重点）</h2><blockquote>
<p>路由策略就是调度中心选 <strong>哪个执行器节点去执行任务</strong> 的方式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>路由策略</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>轮询（Round）</strong> ✅</td>
<td>多个节点轮流执行任务，负载均衡常用</td>
</tr>
<tr>
<td><strong>故障转移（Failover）</strong> ✅</td>
<td>优先使用健康节点，失败时自动切换执行</td>
</tr>
<tr>
<td><strong>分片广播（Broadcast）</strong> ✅</td>
<td>每个节点都执行一次任务，适合大数据并行处理</td>
</tr>
<tr>
<td><strong>随机（Random）</strong></td>
<td>随机选取一个可用节点</td>
</tr>
<tr>
<td><strong>一致性哈希</strong></td>
<td>根据任务参数哈希选节点，适合状态保持</td>
</tr>
<tr>
<td><strong>最少运行节点</strong></td>
<td>选当前执行任务最少的机器</td>
</tr>
<tr>
<td><strong>指定机器</strong></td>
<td>手动指定执行器</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>xxl-job任务执行失败怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>路由策略选择<strong>故障转移</strong>，使用健康的实例来执行任务</li>
<li>设置重试次数</li>
<li>查看<strong>日志+邮件</strong>警告来通知相关负责人解决</li>
<li>配置 <strong>任务超时时间 + 告警通知（邮件、短信）</strong></li>
<li>失败日志可在调度中心查看，有堆栈信息</li>
</ul>
</blockquote>
</li>
<li><p><span style = "color:red"><strong>如果有大数据量的任务同时都现需要执行，怎么解决？</strong></span></p>
<blockquote>
<ul>
<li>让多个实例一块去执行(部署集群)，路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行；通过 <code>ShardingContext</code> 拿到当前分片信息</li>
</ul>
<pre><code class="java">@JobHandler(&quot;xxxHandler&quot;)
public ReturnT&lt;String&gt; execute(ShardingContext context) &#123;
    int totalShards = context.getTotalShardCount();
    int shardIndex = context.getShardIndex();

    List&lt;Data&gt; allData = getData();
    for (int i = 0; i &lt; allData.size(); i++) &#123;
        if (i % totalShards == shardIndex) &#123;
            process(allData.get(i));
        &#125;
    &#125;
    return SUCCESS;
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<h2 id="💡-面试高频问法总结"><a href="#💡-面试高频问法总结" class="headerlink" title="💡 面试高频问法总结"></a>💡 面试高频问法总结</h2><table>
<thead>
<tr>
<th>面试问题</th>
<th>回答提示</th>
</tr>
</thead>
<tbody><tr>
<td>你们怎么做定时任务调度？</td>
<td>我们使用 XXL-Job 做分布式定时调度，支持失败重试、分片执行、失败告警</td>
</tr>
<tr>
<td>XXL-Job 怎么实现任务分片？</td>
<td>配置为广播策略，任务中使用 ShardingContext 获取分片信息</td>
</tr>
<tr>
<td>路由策略都有哪些？你们用哪个？</td>
<td>常用<strong>轮询、故障转移、分片广播</strong>；我们大任务用广播，小任务轮询</td>
</tr>
<tr>
<td>如果一个任务执行失败怎么办？</td>
<td>设置了最大重试次数、使用了 Failover 策略、并配置了邮件告警通知</td>
</tr>
<tr>
<td>为什么不用 @Scheduled？</td>
<td>@Scheduled 适用于单体项目，不能解决多实例下重复执行问题；XXL-Job 支持分布式调度、管理界面、执行日志等</td>
</tr>
</tbody></table>
<h2 id="✅-详细对比分析：SpringTask-vs-XXL-Job"><a href="#✅-详细对比分析：SpringTask-vs-XXL-Job" class="headerlink" title="✅ 详细对比分析：SpringTask vs XXL-Job"></a>✅ 详细对比分析：SpringTask vs XXL-Job</h2><table>
<thead>
<tr>
<th>对比维度</th>
<th><strong>SpringTask</strong></th>
<th><strong>XXL-Job</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定位</strong></td>
<td>本地轻量级定时调度工具</td>
<td>分布式定时任务调度平台</td>
</tr>
<tr>
<td><strong>部署方式</strong></td>
<td>内嵌在应用中（@Scheduled）</td>
<td>独立部署调度中心 + 执行器</td>
</tr>
<tr>
<td><strong>集群支持</strong></td>
<td>不支持，单实例任务</td>
<td>支持分布式执行和 failover</td>
</tr>
<tr>
<td><strong>任务失效恢复</strong></td>
<td>无（如服务挂了任务丢）</td>
<td>支持失败重试 + 调度日志记录</td>
</tr>
<tr>
<td><strong>任务管理</strong></td>
<td>无可视化界面</td>
<td>Web 界面管理、动态配置任务</td>
</tr>
<tr>
<td><strong>任务执行方式</strong></td>
<td>方法注解 + 固定周期</td>
<td>支持 Bean 调用、Shell、HTTP、RPC 等</td>
</tr>
<tr>
<td><strong>执行结果监控</strong></td>
<td>无</td>
<td>有日志管理、失败报警、状态追踪</td>
</tr>
<tr>
<td><strong>调度策略</strong></td>
<td>固定时间（cron）</td>
<td>cron、分片广播、失败重试、手动触发等</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单、稳定的定时逻辑，如定期清理缓存</td>
<td>多任务调度、跨服务控制、任务分发、分片执行、手动补偿等复杂场景</td>
</tr>
</tbody></table>
</blockquote>
<h6 id="xxl-job解决的问题"><a href="#xxl-job解决的问题" class="headerlink" title="xxl-job解决的问题"></a>xxl-job解决的问题</h6><ul>
<li>解决集群任务的重复执行问题                   xxl-job路由策略有哪些？</li>
<li>cron表达式定义灵活<del>在页面上</del>                      xxl-job任务执行失败怎么解决？</li>
<li>定时任务失败了，重试和统计                   如果有大数据量的任务同时都需要执行，怎么解决？</li>
<li>任务量大，分片执行</li>
</ul>
<blockquote>
<h4 id="场景-1-定时处理过期订单"><a href="#场景-1-定时处理过期订单" class="headerlink" title="场景 1: 定时处理过期订单"></a>场景 1: <strong>定时处理过期订单</strong></h4><p>假设用户下单后如果订单超过了某个时间没有支付，平台需要自动取消该订单并释放库存。这个任务需要在每天的某个固定时间（比如凌晨 2 点）运行。</p>
<h5 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务调度</strong>：XXL-Job 可以轻松管理该任务的执行时间和周期，确保每天准时执行，不需要开发者手动触发。</li>
<li><strong>任务失败重试</strong>：如果该任务因为某些原因执行失败，XXL-Job 可以自动进行重试，并设置重试次数，确保任务最终被执行。</li>
<li><strong>分布式执行</strong>：假设电商平台是一个分布式系统，订单数据存储在多个数据库中，XXL-Job 可以通过分布式执行确保每个数据库的订单都被正确处理</li>
</ol>
<p><u>假设每晚 2 点有一个任务需要取消未支付的订单</u>：</p>
<pre><code class="java">public class OrderJob &#123;
    @JobHandler(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 查询所有未支付的订单
        List&lt;Order&gt; unpaidOrders = orderService.findUnpaidOrders();
        for (Order order : unpaidOrders) &#123;
            if (order.isExpired()) &#123;
                orderService.cancelOrder(order);
                inventoryService.releaseStock(order.getProductId(), order.getQuantity());
                // 发送订单取消通知给用户
                notificationService.sendOrderCancelledNotification(order.getUserId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-2-定时更新商品库存"><a href="#场景-2-定时更新商品库存" class="headerlink" title="场景 2: 定时更新商品库存"></a>场景 2: <strong>定时更新商品库存</strong></h4><p>假设电商平台上销售的是一些有时效性的商品，商家需要定期更新商品的库存状态（例如，库存数量达到一定阈值时，自动下架商品，或者增加库存数量）。这个任务同样需要定时执行。</p>
<h5 id="解决的问题：-1"><a href="#解决的问题：-1" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>任务分片</strong>：在商品很多的情况下，XXL-Job 可以通过任务分片的方式并行处理不同商品的库存更新，提升任务的执行效率。</li>
<li><strong>任务优先级</strong>：根据不同商品的重要程度，XXL-Job 可以设置任务的优先级，确保关键商品的库存更新优先执行。</li>
</ol>
<pre><code class="java">public class InventoryJob &#123;
    @JobHandler(&quot;inventoryUpdateJobHandler&quot;)
    public void updateProductInventory() &#123;
        // 获取需要更新库存的商品
        List&lt;Product&gt; productsToUpdate = productService.findProductsForInventoryUpdate();
        for (Product product : productsToUpdate) &#123;
            inventoryService.updateInventory(product);
            if (product.getStockQuantity() &lt;= product.getLowStockThreshold()) &#123;
                productService.deactivateProduct(product);
                // 发送商品下架通知
                notificationService.sendOutOfStockNotification(product.getId());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="场景-3-定时发送促销活动通知"><a href="#场景-3-定时发送促销活动通知" class="headerlink" title="场景 3: 定时发送促销活动通知"></a>场景 3: <strong>定时发送促销活动通知</strong></h4><p>假设电商平台有一个促销活动，每个活动的开始和结束时间都由后台系统控制。需要在活动开始前 1 小时、活动结束时发送通知给用户。这些通知可以是短信、邮件或 APP 推送通知。</p>
<h5 id="解决的问题：-2"><a href="#解决的问题：-2" class="headerlink" title="解决的问题："></a>解决的问题：</h5><ol>
<li><strong>定时任务管理</strong>：XXL-Job 可以定时触发通知任务，确保用户在活动前后及时收到通知。</li>
<li><strong>高并发支持</strong>：在促销活动开始或结束时，平台可能会有大量的通知需要发送，XXL-Job 支持任务的并行处理，可以帮助我们高效地分发通知，避免性能瓶颈。</li>
<li><strong>任务状态监控</strong>：XXL-Job 提供任务的实时监控功能，平台可以随时查看任务的执行情况，确保通知任务按时执行。</li>
</ol>
<pre><code class="java">public class PromotionJob &#123;
    @JobHandler(&quot;promotionNotifyJobHandler&quot;)
    public void sendPromotionNotifications() &#123;
        // 获取当前正在进行的促销活动
        List&lt;Promotion&gt; activePromotions = promotionService.findActivePromotions();
        for (Promotion promotion : activePromotions) &#123;
            if (promotion.isStartingSoon()) &#123;
                notificationService.sendStartNotification(promotion);
            &#125; else if (promotion.isEndingSoon()) &#123;
                notificationService.sendEndNotification(promotion);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="✅-这段代码做了什么？"><a href="#✅-这段代码做了什么？" class="headerlink" title="✅ 这段代码做了什么？"></a>✅ 这段代码做了什么？</h2><pre><code>java复制编辑@JobHandler(&quot;orderCancelJobHandler&quot;)
public void cancelUnpaidOrders() &#123; ... &#125;
</code></pre>
<p>这是一个 XXL-Job 的定时任务处理方法，任务名叫 <code>orderCancelJobHandler</code>，作用是：</p>
<blockquote>
<p><strong>定时扫描所有未支付订单，判断是否过期，过期则取消订单、释放库存并通知用户</strong></p>
</blockquote>
<hr>
<h2 id="🔧-XXL-Job-是怎么运行这个方法的？"><a href="#🔧-XXL-Job-是怎么运行这个方法的？" class="headerlink" title="🔧 XXL-Job 是怎么运行这个方法的？"></a>🔧 XXL-Job 是怎么运行这个方法的？</h2><h3 id="🧩-步骤-1：添加依赖"><a href="#🧩-步骤-1：添加依赖" class="headerlink" title="🧩 步骤 1：添加依赖"></a>🧩 步骤 1：添加依赖</h3><p>在你的 <code>pom.xml</code> 中，需要加入 XXL-Job 的执行器依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
    &lt;version&gt;2.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h3 id="🧩-步骤-2：执行器配置（application-yml）"><a href="#🧩-步骤-2：执行器配置（application-yml）" class="headerlink" title="🧩 步骤 2：执行器配置（application.yml）"></a>🧩 步骤 2：执行器配置（application.yml）</h3><pre><code class="java">xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin
    executor:
      appname: order-job-executor
      address:
      ip:
      port: 9999
      logpath: /data/applogs/xxl-job/jobhandler
      logretentiondays: 30
    accessToken:
</code></pre>
<p>说明：</p>
<ul>
<li><code>admin.addresses</code>: 调度中心地址</li>
<li><code>executor.*</code>: 当前服务是执行器，配置端口、日志路径等</li>
</ul>
<hr>
<h3 id="🧩-步骤-3：启动类开启执行器功能"><a href="#🧩-步骤-3：启动类开启执行器功能" class="headerlink" title="🧩 步骤 3：启动类开启执行器功能"></a>🧩 步骤 3：启动类开启执行器功能</h3><pre><code class="java">@EnableXxlJob
@SpringBootApplication
public class OrderJobExecutorApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderJobExecutorApplication.class, args);
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="🧩-步骤-4：创建-JobHandler-并注册到容器"><a href="#🧩-步骤-4：创建-JobHandler-并注册到容器" class="headerlink" title="🧩 步骤 4：创建 JobHandler 并注册到容器"></a>🧩 步骤 4：创建 JobHandler 并注册到容器</h3><pre><code class="java">@Component
public class OrderJob &#123;

    @XxlJob(&quot;orderCancelJobHandler&quot;)
    public void cancelUnpaidOrders() &#123;
        // 执行任务逻辑
    &#125;
&#125;
</code></pre>
<blockquote>
<p><strong>注意</strong>：你用的是 <code>@JobHandler</code>，它是旧版本用法，新版本统一改为 <code>@XxlJob</code>（推荐）</p>
</blockquote>
<hr>
<h3 id="🧩-步骤-5：在调度中心页面注册该任务"><a href="#🧩-步骤-5：在调度中心页面注册该任务" class="headerlink" title="🧩 步骤 5：在调度中心页面注册该任务"></a>🧩 步骤 5：在调度中心页面注册该任务</h3><p>登录调度中心（xxl-job-admin）</p>
<ul>
<li>新建任务<ul>
<li>执行器：选择 <code>order-job-executor</code></li>
<li>JobHandler名称：<code>orderCancelJobHandler</code></li>
<li>调度类型：如“CRON”</li>
<li>执行方式：BEAN 模式</li>
<li>CRON 表达式：比如每天凌晨 2 点 <code>0 0 2 * * ?</code></li>
</ul>
</li>
<li>保存并启动任务</li>
</ul>
</blockquote>
<h6 id="xxl-job路由策略有哪些？"><a href="#xxl-job路由策略有哪些？" class="headerlink" title="xxl-job路由策略有哪些？"></a>xxl-job路由策略有哪些？</h6><p>实例找任务项执行任务 这种<strong>找机器的方式</strong>就是路由策略</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ee1e805b34b443e5fed49434ec33e59c264894b/xxl-job%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5.png"></p>
<h3 id="消息中间件RabbitMQ-Kafka"><a href="#消息中间件RabbitMQ-Kafka" class="headerlink" title="消息中间件RabbitMQ+Kafka"></a><span style = "color:blue">消息中间件<del>RabbitMQ+Kafka</del></span></h3><h6 id="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"><a href="#消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦" class="headerlink" title="消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦"></a>消息中间件提供了服务与服务之间的异步调用，还可以服务与服务之间解耦</h6><p><strong>RabbitMQ</strong>：**<u>消息不丢失、消息重复消费、消息堆积、延迟队列、死信队列、高可用机制</u>**<br><strong>Kafka</strong>：**<u>消息不丢失、消息重复消费、高可用机制、高性能设计</u><del>吞吐量达到百万级</del>、<u>数据存储和清理</u>**</p>
<p><span style = "color:red"><strong>RabbitMQ-如何保证消息不丢失？</strong></span></p>
<blockquote>
<ul>
<li><p><u>开启<strong>生产者确认机制</strong>，确保生产者的消息能到达队列</u><br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
<blockquote>
<p>达到队列成功返回<code>ack</code>，失败返回<code>nack</code>【<u><strong>n</strong>egative <strong>ack</strong>nowledgment</u>】</p>
<ol>
<li>生产者发送消息到交换机。</li>
<li>交换机收到消息后，根据绑定规则（是否有匹配的队列）决定消息是否被正确路由。</li>
<li>如果消息成功路由到队列，交换机会向生产者返回 <code>ack</code> 确认。</li>
<li>如果消息没有成功路由到任何队列，交换机会通过 <code>return</code> 将消息退回给生产者。</li>
<li>生产者收到 <code>ack</code> 或 <code>nack</code>，可以处理消息确认或重试逻辑。</li>
</ol>
</blockquote>
</li>
<li><p><u>开启<strong>持久化功能</strong>，确保消息未消费前在队列中不会丢失</u>   <code>durable = True</code><br>万一broker挂掉就惨了 保证至少成功一次消费<br>MQ是默认内存存储信息，开启持久化功能可以确保缓存在MQ中的消息不丢失[把数据存在磁盘上]</p>
<pre><code class="python"># 声明持久化交换器
channel.exchange_declare(exchange=&#39;exchange_name&#39;, durable=True)
      
# 声明持久化队列
channel.queue_declare(queue=&#39;queue_name&#39;, durable=True)
      
# 发送持久化消息
channel.basic_publish(exchange=&#39;exchange_name&#39;,
                      routing_key=&#39;routing_key&#39;,
                      body=&#39;Hello World!&#39;,
                      properties=pika.BasicProperties(
                         delivery_mode=2,  # 使消息持久化
                      ))
</code></pre>
</li>
<li><p><u>开启<strong>消费者确认机制</strong>为auto，由spring确认消息处理成功后完成ack</u><br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：**<u>消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息</u>**，而Spring AMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h5 id="x3D-x3D-生产者确认机制-x3D-x3D"><a href="#x3D-x3D-生产者确认机制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;生产者确认机制&#x3D;&#x3D;</h5><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ad3b4f558db898d6e3a53744beb5512a958f9f57/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>RabbitMQ消息的重复消费问题如何解决的？</strong></span></p>
<blockquote>
<p>我们当时消费者是设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息，这样就重复消费了<br><u>因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。<strong>如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</strong></u>。</p>
</blockquote>
<h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><ul>
<li>网络抖动</li>
<li>消费者挂了</li>
</ul>
<p>解决方案：<del>适用于任何MQ(Kafka，RabbitMQ，RocketMQ)</del></p>
<ul>
<li><strong>每条消息设置一个唯一的标识id</strong></li>
<li>幂等方案：【<strong>分布式锁</strong>、数据库锁(悲观锁、乐观锁)】</li>
</ul>
<p><span style = "color:red"><strong>RabbitMQ中死信交换机？(RabbitMQ延迟队列有了解过吗)</strong></span></p>
<p>如果用原来的定时任务 也可以但是 可能会有订单空窗期 如果没人消费的时候 它内部还是回去sql查询<strong>已下单</strong> +(now()-下单时间)?15min : true, false</p>
<blockquote>
<ul>
<li>我们当时一个什么业务使用到了延迟队列（超时订单、限时优惠、定时发布）</li>
<li>其中<strong>延迟队列</strong>就用到了<strong>死信交换机</strong>和<strong>TTL</strong>（消息存活时间）实现的</li>
<li>消息超时未消费就会变成死信（死信的其他情况：<strong>拒绝被消费，队列满了</strong>）</li>
</ul>
<blockquote>
<p><strong>我们用延迟队列处理未支付订单</strong>：用户下单后 15 分钟未付款，自动取消订单+释放库存；其他场景也用到延迟队列，比如限时促销、定时发布文章、定时发通知等。</p>
</blockquote>
<p>延迟队列插件实现延迟队列<code>DelayExchange</code><br><strong>延迟队列</strong>的底层实现就是通过 TTL（消息存活时间）+ 死信交换机（DLX）组合完成的。</p>
<ul>
<li>声明一个交换机，添加delayed属性为true</li>
<li>发送消息时，添加<code>x-delay</code>头，值为超过时间</li>
</ul>
<pre><code class="java">什么样的消息会成为死信？
★ 消费者返回reject或者nack，且requeue参数设置为false【消息被拒绝并且不重入队列】
★ 消息超时未消费
★ 队列满了

如何给队列绑定死信交换机？
★ 给队列设置dead-letter-exchange属性，指定一个交换机
★ 给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey

------------------------------------------------------------------------
★ ★ ★ 使用 Spring AMQP 配置 ★ ★ ★ 
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.Exchange;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig &#123;

    // 定义普通队列
    @Bean
    public Queue normalQueue() &#123;
        return new Queue(&quot;normalQueue&quot;, true, false, false, 
                Map.of(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;, 
                       &quot;x-dead-letter-routing-key&quot;, &quot;dlx_routing_key&quot;));
    &#125;

    // 定义死信队列
    @Bean
    public Queue dlxQueue() &#123;
        return new Queue(&quot;dlxQueue&quot;, true);
    &#125;

    // 定义普通交换机
    @Bean
    public Exchange normalExchange() &#123;
        return new TopicExchange(&quot;normal_exchange&quot;);
    &#125;

    // 定义死信交换机
    @Bean
    public Exchange dlxExchange() &#123;
        return new TopicExchange(&quot;dlx_exchange&quot;);
    &#125;

    // 将普通队列与交换机绑定
    @Bean
    public Binding bindNormalQueue() &#123;
        return BindingBuilder.bind(normalQueue()).to(normalExchange()).with(&quot;normal.routing.key&quot;).noargs();
    &#125;

    // 将死信队列与死信交换机绑定
    @Bean
    public Binding bindDLXQueue() &#123;
        return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(&quot;dlx_routing_key&quot;).noargs();
    &#125;
&#125;
------------------------------------------------------------------------
如果你希望将死信队列配置成带有过期时间或其他特殊属性的队列，可以在定义 dlxQueue 时增加更多的设置，例如 TTL（过期时间）。
例如，设置死信队列的 TTL：

@Bean
public Queue dlxQueue() &#123;
    return QueueBuilder.durable(&quot;dlxQueue&quot;)
            .withArgument(&quot;x-message-ttl&quot;, 60000) // 设置TTL为60秒
            .build();
&#125;
</code></pre>
<pre><code class="java">✅ Spring AMQP 中配置延迟队列 + 死信队列（简洁版）

@Bean
public Queue orderQueue() &#123;
    return QueueBuilder.durable(&quot;order.queue&quot;)
            .ttl(15 * 60 * 1000) // 15分钟TTL
            .deadLetterExchange(&quot;dlx.exchange&quot;) // 超时后投递到死信交换机
            .deadLetterRoutingKey(&quot;order.dlx&quot;)  // 指定死信路由key
            .build();
&#125;

@Bean
public Queue orderDLXQueue() &#123;
    return new Queue(&quot;order.dlx.queue&quot;);
&#125;
</code></pre>
</blockquote>
<h6 id="延迟队列-x3D-死信交换机-TTL-生存时间"><a href="#延迟队列-x3D-死信交换机-TTL-生存时间" class="headerlink" title="延迟队列 &#x3D; 死信交换机 + TTL (生存时间)"></a><span style = "color:blue">延迟队列 &#x3D; 死信交换机 + TTL (生存时间)</span></h6><ul>
<li><strong>延迟队列</strong>：进入队列的消息会被延迟消费的队列</li>
<li><strong>场景</strong>：超时订单、限时优惠，定时发布</li>
</ul>
<h6 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h6><p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>(dead letter)：</p>
<ul>
<li>消费者使用basic.reject 或 basic.nack声明消费失败，并且信息的requeue参数设置为false</li>
<li>消息是一个过期消息，超时无人消费</li>
<li>要投递的队列消息堆积满了，最早的消息可能成为死信</li>
</ul>
<p>如果该队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>(Dead Letter Exchange，简称DLX)</p>
<pre><code class="java">@Bean
public QUeue ttlQueue()&#123;
    return QueueBuilder.durable(&quot;simple.queue&quot;) // 指定队列名称，并持久化
        .ttl(10000) // 设置队列的超时时间 10秒
        .deadLetterExchange(&quot;dl.direct&quot;) // 指定死信交换机
        .build();
&#125;
</code></pre>
<pre><code class="yaml">✅ 死信交换机配置核心属性（面试考点）

x-dead-letter-exchange: 死信交换机名称
x-dead-letter-routing-key: 投递死信用的路由key
x-message-ttl: 消息过期时间（单位：毫秒）
</code></pre>
<h6 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h6><p>TTL(Time-To-Live)。如果一个队列中的消息TTL结束仍未消费，则会变成死信，ttl超时分为两种情况：</p>
<ul>
<li><strong>消息所在的队列设置了存活时间</strong></li>
<li><strong>消息本身设置了存活时间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/50eb7d1338c4fdae6ee9c65274b3116ac361514d/%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" alt="死信图片"></p>
<p><span style = "color:red"><strong>RabbitMQ如果有100万消息堆积在MQ，如何解决(消息堆积怎么解决)？</strong><br></span></p>
<p>消息堆积的本质是消费能力不足，解决重点是提升消费者处理能力 + 降低系统压力。</p>
<blockquote>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li><strong>增加更多消费者</strong>，提高消费速度</li>
<li>在消费者内<strong>开启线程池</strong>加快消息处理速度</li>
<li><strong>扩大队列容积</strong>，提高堆积上限<ul>
<li>在声明队列的时候可以设置<code>x-queue-model</code>为lazy，即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘IO，时效性会降低</li>
</ul>
</li>
</ul>
</blockquote>
<p>当<strong>生产者发送消息的速度超过了消费者处理消息的速度</strong>，就会导致队列中的<strong>消息堆积</strong>，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h6 id="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？"><a href="#达到上限发送的消息会变成死信，那我为什么不搞个死信交换机-而是用了上面的三种思路？？" class="headerlink" title="达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？"></a>达到上限发送的消息会变成死信，那我为什么不搞个死信交换机 而是用了上面的三种思路？？</h6><blockquote>
<p>使用死信交换机（DLX, Dead Letter Exchange）是另一种处理消息堆积的方式，但它的作用更偏向于“消息过期”或“处理失败”的情况下将消息转发到另一个队列。并不直接解决生产者发送消息过快或消费者处理速度过慢的问题。通过死信交换机，你可以将无法处理的消息转发到其他队列，方便你后续进行分析或处理，但它并不能提高消费者处理消息的速度。</p>
<p>针对消息堆积的本质问题，解决方式更多的是优化消费者处理能力，而不是仅依赖死信交换机。具体而言，死信交换机和你的三种思路的关系如下：</p>
<ol>
<li><strong>死信交换机（DLX）</strong>：当消息达到队列上限或无法消费时，消息被转发到死信队列。你可以分析死信队列中的消息，了解原因，并决定是重试、丢弃还是进行其他处理。它的作用是<strong>不丢失消息</strong>，但并不能帮助消除堆积。</li>
<li><strong>增加消费者</strong>：这是直接针对堆积的根本解决方案，通过增加消费者数量来加速消息的处理。死信交换机无法直接解决消费者处理能力不足的问题。</li>
<li><strong>开启消费者线程池</strong>：在单个消费者上开启线程池，可以提高消费者的处理能力，减少堆积。死信交换机并不能增加消息处理速度，它只是用来应对消费失败的情况。</li>
<li><strong>扩大队列容量并使用惰性队列</strong>：惰性队列可以将消息存储在磁盘上，而非内存中，减轻内存压力，但这也会降低时效性，并不能解决生产者生产过快或消费者消费过慢的问题。死信交换机同样无法直接解决这一点。</li>
</ol>
<p>总结来说，死信交换机是处理消息丢失或无法消费的方式，它和通过增加消费者、线程池、队列优化这些手段并不冲突，但也无法替代这些更直接的解决方案。你可以结合这两者，使用死信交换机来保障消息不丢失，同时采取上述方法来提高消息消费速度。</p>
<p>死信交换机主要作用是<strong>保底机制</strong>，用于<strong>处理失败的消息</strong>，比如超时、拒绝、队列满。它不能真正解决堆积问题，只能<strong>帮我们兜底不丢消息</strong>。<br>所以，我们会<strong>搭配使用</strong>：前面是用多线程和惰性队列来<strong>压堆积</strong>，后面用死信队列来<strong>兜住异常消息</strong>，保障系统稳定。</p>
</blockquote>
<h6 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h6><p>惰性队列特征如下：</p>
<ul>
<li>接收到消息后直接存入磁盘而非内存</li>
<li>消费者要消费消息时才会从磁盘中读取并加载到内存</li>
<li>支持数百万条的消息存储</li>
</ul>
<pre><code class="java">@Bean
public Queue lazyQueue()&#123;
    return QueueBuilder
            .durable(&quot;lazy.queue&quot;)
            .lazy() // 设置为惰性队列，落盘存储
            .build();
&#125;

// 惰性队列是 RabbitMQ 提供的一种机制，消息直接写入磁盘，内存消耗小，堆积能力强，适合处理海量不紧急消息。但缺点是消费速度会稍慢，因为要从磁盘读。
</code></pre>
<pre><code class="java">@RabbitListener(queuesToDeclare = @Queue)&#123;
    name = &quot;lazy.queue&quot;,
    durable = &quot;true&quot;,
    arguments = @Argument(name = &quot;x-queue-mode&quot;), value=&quot;lazy&quot;
&#125;
public void listenLazyQUeue(String msg)&#123;
    log.info(&quot;接收到lazy.queue的消息：&#123;&#125;&quot;,msg);
&#125;
</code></pre>
<p>提高消费能力是解决堆积的根本；惰性队列能缓解内存压力，死信机制是辅助保障不丢消息。三者应配合使用。</p>
<p><strong><span style = "color:red">RabbitMQ高可用机制有了解过吗？ &amp;&amp;  请描述 RabbitMQ 镜像队列的工作原理及其在高可用性场景下的优缺点<br></span></strong></p>
<blockquote>
<p>在我们项目中，为了保障消息队列的高可用性，我们采用了 RabbitMQ 的镜像队列集群部署方案，后来也了解并测试了仲裁队列来提升一致性保障。</p>
<p>我们当时的项目在生产环境下，采用的是镜像模式搭建的集群，共有3个节点<br>镜像队列结构是一主多从(从就是镜像)，所有(写)操作都是主节点完成，然后同步给镜像节点<br>主宕机后，镜像节点会代替成为新的主(如果在主从同步完成前，主就已经宕机，可能出现数据丢失)</p>
<h5 id="🔹-RabbitMQ-高可用机制对比三种："><a href="#🔹-RabbitMQ-高可用机制对比三种：" class="headerlink" title="🔹 RabbitMQ 高可用机制对比三种："></a>🔹 RabbitMQ 高可用机制对比三种：</h5><table>
<thead>
<tr>
<th>模式</th>
<th>原理</th>
<th>是否同步消息</th>
<th>容灾能力</th>
<th>是否强一致</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>普通集群</td>
<td>共享元数据，不同步消息内容</td>
<td>❌</td>
<td>弱</td>
<td>❌</td>
<td>测试、非关键业务</td>
</tr>
<tr>
<td>镜像队列</td>
<td>主节点写入，同步到镜像节点</td>
<td>✅</td>
<td>中</td>
<td>弱~中</td>
<td>读多写少</td>
</tr>
<tr>
<td>仲裁队列</td>
<td>Raft 协议选主，多节点确认写入</td>
<td>✅</td>
<td>强</td>
<td>✅（强一致）</td>
<td>关键数据、支付</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>那出现丢数据怎么解决呢？</strong><br></span></p>
<blockquote>
<p>我们可以采用<strong>仲裁队列</strong>，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于<span style = "color:blue"><u><strong>wwwwwwwwwwwwwwwwwwwww</strong></u></span>，强一致性，并且使用起来也非常简单，不需要格外的配置，<strong>在声明队列的时候只需要指定这个是仲裁队列即可</strong></p>
<blockquote>
<p>Raft 协议 是一种 <strong>共识算法（Consensus Algorithm）</strong>；<br>🔴 <strong>在分布式系统中，让多个节点就某个值达成一致（即使有部分节点故障）</strong><br>Raft 就是“几个节点如何选出一个 Leader，让它来统筹所有更新，然后让大多数节点<strong>都确认成功后</strong>再算真正提交成功”。<br>为了避免这些 <strong>“脑裂、数据冲突”</strong> 问题，就需要一种 <strong>“大家达成共识”</strong> 的机制，<strong>Raft 协议就是这种机制</strong>🏗️ Raft 核心角色和流程</p>
<h3 id="✅-Raft-有三种角色："><a href="#✅-Raft-有三种角色：" class="headerlink" title="✅ Raft 有三种角色："></a>✅ Raft 有三种角色：</h3><table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Leader</td>
<td>主节点，唯一能接收客户端写请求</td>
</tr>
<tr>
<td>Follower</td>
<td>跟随者，接受 Leader 同步数据</td>
</tr>
<tr>
<td>Candidate</td>
<td>候选人，用于选举新 Leader</td>
</tr>
</tbody></table>
<h3 id="✅-正常流程："><a href="#✅-正常流程：" class="headerlink" title="✅ 正常流程："></a>✅ 正常流程：</h3><ol>
<li>所有节点刚启动时，都是 Follower。</li>
<li>一段时间内没收到 Leader 的心跳，会变成 Candidate，发起投票选举。</li>
<li>多数投票成功后，变成新的 Leader。</li>
<li><strong>所有写请求只能由 Leader 处理</strong>，然后同步给其他节点（Follower）。</li>
<li>如果 <strong>大多数节点都确认写入成功</strong>，则这条数据才算真正提交成功。</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>在生产环境下，使用集群来保证高可用性</li>
<li>普通集群、<strong>镜像集群</strong>、仲裁队列(Raft协议)</li>
</ul>
<h5 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h5><p>普通集群，或者叫标准集群(classic cluster)</p>
<ul>
<li>会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的信息</li>
<li>当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>队列所在节点宕机，队列中的消息就会丢失</li>
</ul>
<h5 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h5><p>镜像集群：本质是<strong>主从模式</strong>，具备下面的特征：</p>
<ul>
<li>交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其他节点叫做该队列的<strong>镜像</strong>节点</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
<blockquote>
<h2 id="🔹-镜像队列原理（项目中实际使用）"><a href="#🔹-镜像队列原理（项目中实际使用）" class="headerlink" title="🔹 镜像队列原理（项目中实际使用）"></a>🔹 镜像队列原理（项目中实际使用）</h2><blockquote>
<p>在我们的生产环境中，RabbitMQ 集群采用的是 <strong>镜像队列（Classic Mirrored Queue）</strong> 模式，有以下特点：</p>
</blockquote>
<ul>
<li><strong>主从同步：</strong> 队列存在一个主节点，多个镜像节点。</li>
<li><strong>所有写操作都落在主节点，随后同步给镜像节点</strong>。</li>
<li>如果主节点宕机，镜像节点会被选举为新主。</li>
<li>同步存在延迟，一旦主节点宕机且尚未同步完，就可能<strong>出现数据丢失</strong>。</li>
</ul>
<h3 id="💡-镜像队列优点："><a href="#💡-镜像队列优点：" class="headerlink" title="💡 镜像队列优点："></a>💡 镜像队列优点：</h3><ul>
<li>数据有副本，具备一定容灾能力</li>
<li>节点可切换，保证服务不中断</li>
</ul>
<h3 id="⚠-镜像队列缺点："><a href="#⚠-镜像队列缺点：" class="headerlink" title="⚠ 镜像队列缺点："></a>⚠ 镜像队列缺点：</h3><ul>
<li>主从同步可能延迟 → <strong>存在数据丢失风险</strong></li>
<li>配置复杂、资源开销大，<strong>大集群下性能差</strong></li>
</ul>
<hr>
<h2 id="🔹-那出现丢数据怎么办？"><a href="#🔹-那出现丢数据怎么办？" class="headerlink" title="🔹 那出现丢数据怎么办？"></a>🔹 那出现丢数据怎么办？</h2><blockquote>
<p>我们后来开始测试和使用了 <strong>仲裁队列（Quorum Queue）</strong>，它在 3.8+ 中推出，作为镜像队列的替代方案，<strong>支持强一致性</strong>。</p>
</blockquote>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/59b655f55c1f3031f72c5790425b8ae8e76e9d1f/%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4.png" style="zoom:150%;" />

<h5 id="仲裁队列：-quorum"><a href="#仲裁队列：-quorum" class="headerlink" title="仲裁队列：.quorum()"></a>仲裁队列：<del>.quorum()</del></h5><p>仲裁队列是<strong>3.8版本</strong>以后才有的新功能，用来替代镜像队列</p>
<ul>
<li>与镜像队列一样，都是主从模式，支持主从数据同步</li>
<li>使用非常简单，没有复杂的配置</li>
<li>主从同步基于<strong>Raft</strong>协议，强一致性</li>
</ul>
<p>仲裁队列的工作原理如下：</p>
<ol>
<li><strong>主从模式</strong>：仲裁队列也是主从模式，支持主从数据同步。</li>
<li><strong>Raft 协议</strong>：主从同步基于 Raft 协议，确保数据的一致性和可靠性。</li>
<li><strong>强一致性</strong>：所有写操作必须得到大多数节点的确认后才能完成，避免了数据丢失。</li>
</ol>
<p>仲裁队列通过以下机制保证数据不丢失：</p>
<ul>
<li><strong>多数派确认</strong>：<u>每次写操作需要得到大多数节点的确认，确保数据已经成功复制到多个节点</u>。</li>
<li><strong>自动故障转移</strong>：如果主节点宕机，<strong>Raft 协议</strong>会自动选举新的主节点，确保服务的连续性。</li>
<li><strong>数据一致性</strong>：<u>Raft 协议保证了数据的<strong>强一致性</strong></u>，即使在网络分区或节点宕机的情况下，也不会出现数据不一致的问题。</li>
</ul>
<p>仲裁队列的优点是配置简单、数据强一致，但需要至少 3 个节点，并且在写操作上的延迟和资源消耗可能会比镜像队列高。</p>
<pre><code class="java">@Bean
public Queue quorumQueue()&#123;
    return QueueBuilder
            .durable(&quot;quorum.queue&quot;) // 持久化
            .quorum() // 仲裁队列
            .build();
&#125;
</code></pre>
<p><span style = "color:red"><strong>Kafka是如何保证消息不丢失？</strong><br></span></p>
<blockquote>
<p>需要从三个层面去解决这个问题</p>
<ul>
<li><p>生产者发送消息到Brocker丢失</p>
<ul>
<li>设置异步发送，发送失败使用回调进行记录或重发</li>
<li>失败重试，参数配置，可以设置重试次数消息</li>
</ul>
</li>
<li><p>在Brocker中存储丢失</p>
<p>发送确认acks，选择all，让所有的副本都参与保存数据后确认</p>
</li>
<li><p>消费者从Brocker接收消息丢失</p>
<ul>
<li>关闭自动提交偏移量，开启手动提交偏移量</li>
<li>提交方式：最好是<strong>同步+异步提交</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>使用Kafka在消息的收发过程中都会出现消息丢失，Kafka分别给出了解决方案</p>
<ul>
<li>生产者发送消息到Brocker丢失</li>
<li>消息在Brocker中存储丢失</li>
<li>消费者从Brocker接收消息丢失</li>
</ul>
</blockquote>
<p>kafka-高产出的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/ckafka?from_column=20065&from=20065">分布式消息系统</a>(A high-throughput distributed messaging system)。</p>
<p>Kafka是一个高吞吐、分布式、基于发布订阅的消息系统，利用Kafka技术可以在廉价的PC Server上搭建起大规模消息系统。</p>
<h5 id="Kafka的特性："><a href="#Kafka的特性：" class="headerlink" title="Kafka的特性："></a><strong>Kafka的特性：</strong></h5><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作；</li>
<li>可扩展性：kafka集群支持热扩展；</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/backup?from_column=20065&from=20065">数据备份</a>防止数据丢失；</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）；</li>
<li>高并发：支持数千个客户端同时读写；</li>
<li>支持实时在线处理和离线处理：可以使用Storm这种实时流处理系统对消息进行实时进行处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</li>
</ul>
<p>Kafka和其他组件比较，具有消息持久化、高吞吐、分布式、多客户端支持、实时等特性，适用于离线和在线的消息消费，如常规的消息收集、网站活性跟踪、聚合统计系统运营数据（监控数据）、日志收集等大量数据的互联网服务的数据收集场景。</p>
<ol>
<li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如Hadoop、Hbase、Solr等；</li>
<li>消息系统：解耦和生产者和消费者、缓存消息等；</li>
<li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到Hadoop、数据仓库中做离线分析和挖掘；</li>
<li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告；</li>
<li>流式处理：比如spark streaming和storm；</li>
<li>事件源；</li>
<li>kafka在FusionInsight中的位置：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fcebf13cb4e2d12dc10727d9d5942720bbd114e6/Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.png"></p>
<p><span style = "color:red"><strong>Kafka是如何保证消费的顺序性？</strong><br></span></p>
<blockquote>
<p>Kafka 保证消息不丢失需要从 <strong>生产者、Broker、消费者</strong> 三个维度考虑：</p>
<ol>
<li><strong>生产者侧</strong>：通过设置 <code>acks=all</code>、启用 <code>幂等性（enable.idempotence=true）</code>、配置 <code>重试机制</code> 等，确保消息可靠送达 Kafka。</li>
<li><strong>Broker 侧</strong>：通过消息持久化、<code>副本同步机制（ISR）</code>、故障转移机制等，确保存储端可靠。</li>
<li><strong>消费者侧</strong>：通过 <code>关闭自动提交 offset</code>，使用手动同步&#x2F;异步提交，并搭配幂等消费逻辑，避免消息处理丢失。</li>
</ol>
<p>多项机制结合，共同保障 Kafka 在高吞吐、高并发下仍具备良好的可靠性与稳定性。</p>
</blockquote>
<blockquote>
<p><strong>问题原因：</strong><br>一个topic的数据可能存储在不同的分区中 ，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p>
<p>&#x3D;&#x3D;<strong>解决方案：</strong>&#x3D;&#x3D;</p>
<ul>
<li>发送消息时指定分区号</li>
<li>发送消息时按照相同的业务设置相同的key</li>
</ul>
</blockquote>
<blockquote>
<p>应用场景：</p>
<ul>
<li>即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致</li>
<li>充值转账两个渠道在同一个时间进行金额变更，短信通知必须要有顺序</li>
</ul>
</blockquote>
<p>承接上图<code>消费者从Brocker接收消息丢失</code>：<br><strong>如何做</strong>？→ topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<pre><code class="java">// 指定分区
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,0,&quot;key-001&quot;,&quot;value-001&quot;);
// 相同的业务key
kafkaTemplate.sent(&quot;springboot-kafka-topic&quot;,&quot;key-001&quot;,&quot;value-001&quot;);
</code></pre>
<p>会计算key的hashcode值推断出它在哪个分区，如果要求有顺序性 就可以设置同一个key，此时hash值都是一样的 就可以在同一个分区存储</p>
<p><span style = "color:red"><strong>Kafka的高可用机制有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;<strong>集群模式</strong>&#x3D;&#x3D;</p>
<p>一个kafka集群由多个broker实例组成，即使某一台宕机，也不会耽误其他broker继续对外提供服务</p>
</li>
<li><p>&#x3D;&#x3D;<strong>分区备份机制</strong>&#x3D;&#x3D;</p>
<ul>
<li>一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中</li>
<li>所有的分区副本的内容都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="✅-真实业务场景案例：订单创建消息流的高可用设计（基于-Kafka）"><a href="#✅-真实业务场景案例：订单创建消息流的高可用设计（基于-Kafka）" class="headerlink" title="✅ 真实业务场景案例：订单创建消息流的高可用设计（基于 Kafka）"></a>✅ 真实业务场景案例：订单创建消息流的高可用设计（基于 Kafka）</h5><blockquote>
<h6 id="🟡-业务背景"><a href="#🟡-业务背景" class="headerlink" title="🟡 业务背景"></a>🟡 业务背景</h6><p>你在做一个电商平台系统，其中<strong>订单创建之后</strong>，需要进行如下异步操作：</p>
<ol>
<li>通知库存中心扣减库存</li>
<li>通知积分服务赠送用户积分</li>
<li>通知数据中心写入大数据平台（如 HDFS）</li>
</ol>
<p>为了解耦服务、削峰填谷，并保障消息不丢失，我们决定使用 Kafka 进行消息中转。</p>
<hr>
<h6 id="🟧-Kafka-高可用设计"><a href="#🟧-Kafka-高可用设计" class="headerlink" title="🟧 Kafka 高可用设计"></a>🟧 Kafka 高可用设计</h6><h6 id="▶-架构图概览（文字版）"><a href="#▶-架构图概览（文字版）" class="headerlink" title="▶ 架构图概览（文字版）"></a>▶ 架构图概览（文字版）</h6><pre><code class="java">[订单服务 OrderService] 
    |
    | 生产消息 send(order_id=1001)
    ▼
[Kafka集群 topic=order-create partition=0,1,2]        
    |  partition-0：leader 在 broker1，follower 在 broker2,3
    |  partition-1：leader 在 broker2，follower 在 broker1,3
    |  partition-2：leader 在 broker3，follower 在 broker1,2
    ▼
[消费者集群]
  ├── 库存服务（group=stock）
  ├── 积分服务（group=points）
  └── 数据服务（group=bigdata）
</code></pre>
<h6 id="🔵-Kafka-高可用机制在这里怎么体现？"><a href="#🔵-Kafka-高可用机制在这里怎么体现？" class="headerlink" title="🔵 Kafka 高可用机制在这里怎么体现？"></a>🔵 Kafka 高可用机制在这里怎么体现？</h6><h5 id="✅-1-Kafka-集群部署（Broker-多节点）"><a href="#✅-1-Kafka-集群部署（Broker-多节点）" class="headerlink" title="✅ 1. Kafka 集群部署（Broker 多节点）"></a>✅ 1. Kafka <strong>集群部署</strong>（Broker 多节点）</h5><p>部署 3 个 Kafka Broker：</p>
<pre><code>broker.id=1,2,3 分别配置在三台服务器上
</code></pre>
<blockquote>
<p>即便其中任意一台 Broker 宕机，剩下两台仍然可以继续服务。</p>
</blockquote>
<h5 id="✅-2-Topic-分区-副本机制"><a href="#✅-2-Topic-分区-副本机制" class="headerlink" title="✅ 2. Topic 分区 + 副本机制"></a>✅ 2. <strong>Topic 分区 + 副本机制</strong></h5><p>创建 topic 时设定副本数：</p>
<pre><code class="java">bin/kafka-topics.sh --create \
  --topic order-create \
  --partitions 3 \
  --replication-factor 3 \
  --zookeeper zk1:2181
</code></pre>
<ul>
<li><p>每个分区会有 <strong>1 个 leader + 2 个 follower</strong></p>
</li>
<li><p>Leader 负责读写，follower 同步数据</p>
</li>
<li><p>当 Leader 所在 Broker 宕机时，Kafka 会<strong>自动从 ISR 列表中选一个 follower 升级为 leader</strong><br>🔁 例如：</p>
</li>
<li><p>原来 partition-0 的 leader 是 broker1</p>
</li>
<li><p>broker1 崩了 → Kafka Controller 会选 broker2 或 broker3 提升为新 leader</p>
</li>
</ul>
<h5 id="✅-3-生产者配置-acks-x3D-all-幂等性"><a href="#✅-3-生产者配置-acks-x3D-all-幂等性" class="headerlink" title="✅ 3. 生产者配置 acks&#x3D;all + 幂等性"></a>✅ 3. <strong>生产者配置 acks&#x3D;all + 幂等性</strong></h5><p>为了保障消息可靠写入 Kafka：</p>
<pre><code class="java">props.put(&quot;acks&quot;, &quot;all&quot;); // 所有副本都确认才算成功
props.put(&quot;enable.idempotence&quot;, &quot;true&quot;); // 避免重复投递
</code></pre>
<p>📝 所以生产者即便 retry 了，也不会生成重复消息。</p>
<h5 id="✅-4-消费者使用手动提交-offset"><a href="#✅-4-消费者使用手动提交-offset" class="headerlink" title="✅ 4. 消费者使用手动提交 offset"></a>✅ 4. <strong>消费者使用手动提交 offset</strong></h5><p>为了保证消费者处理完消息再提交 offset，避免消息处理失败却误提交偏移量：</p>
<pre><code class="java">props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);

while (true) &#123;
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord&lt;String, String&gt; record : records) &#123;
        // 处理消息
        process(record);
    &#125;
    consumer.commitSync(); // 处理完手动提交
&#125;
</code></pre>
<h6 id="🔻-模拟突发事件：Kafka-Broker-宕机，系统是否正常？"><a href="#🔻-模拟突发事件：Kafka-Broker-宕机，系统是否正常？" class="headerlink" title="🔻 模拟突发事件：Kafka Broker 宕机，系统是否正常？"></a>🔻 模拟突发事件：Kafka Broker 宕机，系统是否正常？</h6><h6 id="❓-假设-Broker1-宕机，会发生什么？"><a href="#❓-假设-Broker1-宕机，会发生什么？" class="headerlink" title="❓ 假设 Broker1 宕机，会发生什么？"></a>❓ 假设 Broker1 宕机，会发生什么？</h6><ul>
<li>partition-0 的 leader 在 broker1 → Kafka Controller 自动将 broker2 提升为新的 leader</li>
<li>生产者发送消息依然正常（因为 follower 已同步数据）</li>
<li>消费者照常消费 partition-0 的数据</li>
</ul>
<h2 id="✅-总结一波这个真实案例带来的知识点"><a href="#✅-总结一波这个真实案例带来的知识点" class="headerlink" title="✅ 总结一波这个真实案例带来的知识点"></a>✅ 总结一波这个真实案例带来的知识点</h2><table>
<thead>
<tr>
<th>组件</th>
<th>高可用机制</th>
<th>关键作用</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka 集群</td>
<td>多 Broker + Controller</td>
<td>任一节点挂掉不影响整体服务</td>
</tr>
<tr>
<td>Topic 分区副本</td>
<td>leader + follower</td>
<td>保证消息副本安全、自动故障转移</td>
</tr>
<tr>
<td>Producer</td>
<td>acks&#x3D;all + 幂等性</td>
<td>防止生产过程中消息丢失或重复</td>
</tr>
<tr>
<td>Consumer</td>
<td>手动提交 offset</td>
<td>避免处理失败误提交偏移量</td>
</tr>
</tbody></table>
<h2 id="❓面试模拟追问"><a href="#❓面试模拟追问" class="headerlink" title="❓面试模拟追问"></a>❓面试模拟追问</h2><blockquote>
<p>面试官：你们 Kafka 的 leader 挂了会不会影响消费者？</p>
</blockquote>
<p>你可以回答：</p>
<blockquote>
<p>Kafka 的消费者是从分区的 <strong>leader</strong> 拉取消息的，如果 leader 节点挂了，Kafka 会自动从 <span style = "color:blue"><strong>ISR 列表</strong></span>中挑选新的 follower 作为 leader，整个过程对消费者来说是无感知的，消费过程会自动恢复。</p>
</blockquote>
</blockquote>
<p><span style = "color:red"><strong>解释一下复制机制中的ISR？</strong><br></span></p>
<blockquote>
<p>ISR (in-sync replica) 需要同步复制保存的follower；<strong>跟 Leader 保持同步</strong> 的副本集合<br>分区副本分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉后，会优先从ISR副本列表中选取一个作为leader</p>
<p>Kafka 每个分区（Partition）都会有多个副本（Replicas）：</p>
<ul>
<li>一个 Leader</li>
<li>若干个 Follower</li>
</ul>
<p>这些副本被分成两类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ISR 副本</strong></td>
<td>与 Leader 保持数据同步的副本（<strong>最健康的副本集</strong>）</td>
</tr>
<tr>
<td><strong>OSR（Out-of-Sync Replicas）</strong></td>
<td>落后太多，未能及时同步 Leader 数据的副本</td>
</tr>
</tbody></table>
<h2 id="🧠-工作机制详解"><a href="#🧠-工作机制详解" class="headerlink" title="🧠 工作机制详解"></a>🧠 工作机制详解</h2><h3 id="1️⃣-消息写入"><a href="#1️⃣-消息写入" class="headerlink" title="1️⃣ 消息写入"></a>1️⃣ 消息写入</h3><ul>
<li><strong>Producer 只写 Leader</strong></li>
<li>Leader 负责将数据同步到 ISR 中的所有 Follower</li>
<li>所有 ISR 成员都成功写入后，才向 Producer 发送 <code>ack</code></li>
</ul>
<p>如果 Leader 挂了：</p>
<ul>
<li>Kafka <strong>只会从 ISR 列表</strong>中挑选一个副本晋升为新的 Leader</li>
<li>这样可以确保<strong>新 Leader 中的数据是完整的</strong></li>
</ul>
<h2 id="🟩-举个例子助记"><a href="#🟩-举个例子助记" class="headerlink" title="🟩 举个例子助记"></a>🟩 举个例子助记</h2><p>假设 topic 有 3 个副本：</p>
<pre><code>Partition-0:
  - broker1 (Leader)
  - broker2 (Follower)
  - broker3 (Follower)
</code></pre>
<p>此时，**ISR &#x3D; [broker1, broker2]**（broker3 落后太多，暂不在 ISR 中）</p>
<p>如果 broker1 挂掉了 → Kafka 会从 broker2 中选一个当 Leader（因为它是同步副本）</p>
<p>📌 broker3 不在 ISR 中，就算数据多，也不会被选为 leader（因为可能数据不一致）</p>
<hr>
<blockquote>
<p>Kafka 中每个分区都会有多个副本，其中 ISR（In-Sync Replicas）表示与 Leader 保持同步的副本集合。</p>
<p>ISR 是 Kafka 高可用的重要保障，Kafka 只会从 ISR 中选 leader，避免使用落后副本导致数据丢失。</p>
<p>可以通过配置 <code>min.insync.replicas</code> 来控制 ISR 最小数量，从而配合 <code>acks=all</code> 确保数据写入可靠性。</p>
</blockquote>
</blockquote>
<pre><code class="java">// 一个topic默认分区的replication个数，不能大于集群中broker的个数。默认为1
default.replication.factor=3
// 最小的ISR副本个数
min.insync.replicas=2
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b273ced4f6ca9b43b9fb5279e651199e7ad52e9f/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6(%E9%9B%86%E7%BE%A4+%E5%88%86%E5%8C%BA%E5%A4%87%E4%BB%BD%E6%9C%BA%E5%88%B6).png"></p>
<p><span style = "color:red"><strong>Kafka数据清理机制了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li>kafka文件存储机制<ul>
<li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li>
<li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxx.log)的形式存储</li>
<li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理</li>
</ul>
</li>
<li>数据清理机制<ul>
<li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认168小时(7天)</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息(默认关闭)</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dbab52581ab3ed1350e8310825216f279c66d7f7/Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86.png"></p>
<h2 id="✅-Kafka-和-RabbitMQ-对比"><a href="#✅-Kafka-和-RabbitMQ-对比" class="headerlink" title="✅ Kafka 和 RabbitMQ 对比"></a>✅ <span style ="color:orange">Kafka 和 RabbitMQ 对比</span></h2><table>
<thead>
<tr>
<th>对比维度</th>
<th>Kafka</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心模型</strong></td>
<td>发布-订阅模型（Pub-Sub）</td>
<td>基于消息队列（Queue）</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>分布式、高吞吐、日志存储</td>
<td>面向消息、消息中间人</td>
</tr>
<tr>
<td><strong>消息存储</strong></td>
<td>持久化日志，磁盘为主，保留时间可配</td>
<td>内存为主，结合磁盘，可配置 TTL</td>
</tr>
<tr>
<td><strong>性能吞吐量</strong></td>
<td>非常高（百万级）</td>
<td>相对较低（万级）</td>
</tr>
<tr>
<td><strong>消息顺序性</strong></td>
<td>同一个分区内有序</td>
<td>默认无序（队列先进先出 FIFO）</td>
</tr>
<tr>
<td><strong>消息重复消费</strong></td>
<td>可能（需要幂等性）</td>
<td>通过消息确认机制避免</td>
</tr>
<tr>
<td><strong>消息确认机制</strong></td>
<td>Offset 手动提交或自动提交（可恢复）</td>
<td>Ack 机制、可配置手动&#x2F;自动确认</td>
</tr>
<tr>
<td><strong>可靠性机制</strong></td>
<td>副本机制 + ISR 保证</td>
<td>持久化、确认机制、死信队列、重试机制</td>
</tr>
<tr>
<td><strong>高可用性</strong></td>
<td>分区副本机制 + Leader选举（Raft）</td>
<td>镜像队列或仲裁队列</td>
</tr>
<tr>
<td><strong>消息丢失保护</strong></td>
<td><code>acks=all</code> + <code>min.insync.replicas</code></td>
<td>confirm机制 + durable队列 + ack</td>
</tr>
<tr>
<td><strong>延迟队列支持</strong></td>
<td>原生不支持（需要定时调度或借助外部插件）</td>
<td>原生支持延迟队列（TTL + 死信队列）</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>日志采集、行为跟踪、数据管道、实时流处理</td>
<td>任务异步处理、延迟任务、订单超时处理等</td>
</tr>
<tr>
<td><strong>管理界面</strong></td>
<td>UI界面较弱，需要依赖第三方</td>
<td>自带 Web 管理后台，功能强大</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>略陡峭，需要理解 partition、offset、consumer group 等</td>
<td>简单易上手，文档丰富</td>
</tr>
<tr>
<td><strong>协议支持</strong></td>
<td>Kafka 自有协议</td>
<td>支持 AMQP、MQTT、STOMP 等多种协议</td>
</tr>
<tr>
<td><strong>成熟度</strong></td>
<td>大数据生态首选，社区活跃，企业常用</td>
<td>轻量级场景常用，灵活扩展，适合中小型应用</td>
</tr>
</tbody></table>
<h2 id="🧠-总结一句话对比"><a href="#🧠-总结一句话对比" class="headerlink" title="🧠 总结一句话对比"></a>🧠 总结一句话对比</h2><ul>
<li>🔥 <strong>Kafka 更适合</strong>：<strong>高吞吐、日志&#x2F;流式处理、大数据实时系统</strong></li>
<li>🔧 <strong>RabbitMQ 更适合</strong>：<strong>业务系统间的解耦、任务异步处理、延迟消息机制</strong></li>
</ul>
<p>Kafka 和 RabbitMQ 都是消息中间件，但定位不同：</p>
<ul>
<li>Kafka 是<strong>高吞吐、分布式日志系统</strong>，更适合大数据场景和实时流式处理，使用 Partition 和 Offset 保证扩展性。</li>
<li>RabbitMQ 是<strong>传统的消息队列中间件</strong>，支持 AMQP 协议，适合轻量级业务异步解耦，原生支持延迟队列和消息确认机制。</li>
</ul>
<p>我们项目中如果要处理高并发日志或用户行为采集就选 Kafka，如果是下单通知、订单超时等场景就更适合 RabbitMQ。</p>
<p><span style = "color:red"><strong>Kafka中实现高性能的设计有了解过吗？</strong><br></span></p>
<blockquote>
<ul>
<li><span style = "color:blue">消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</span></li>
<li><span style = "color:blue">顺序读写：磁盘顺序读写，提升读写效率</span></li>
<li><span style = "color:blue">页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</span></li>
<li><span style = "color:blue">零拷贝：减少上下文切换及数据拷贝</span></li>
<li>消息压缩：减少磁盘IO和网络IO</li>
<li>分批发送：将消息打包批量发送，减少网络开销</li>
</ul>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/86a930ef22442fc6b9460ee88b64b21983cc9847/kafka%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"></p>
<h2 id="集合面试篇"><a href="#集合面试篇" class="headerlink" title="集合面试篇"></a><span style = "color:red"><strong>集合面试篇</strong></span></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/9f0a0968283f4255bf0047d1761499c7b493ed97/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BBpng.png"></p>
<p><span style = "color:orange"><strong>算法复杂度分析</strong><br></span></p>
<blockquote>
<p>什么是算法时间复杂度？</p>
<ul>
<li>时间复杂度表示了算法的<strong>执行时间</strong>与<strong>数据规模</strong>之间的增长关系</li>
</ul>
<p>常见的时间复杂度有哪些？<del>口诀：常对幂指阶</del></p>
<ul>
<li>O(1)、O(n)、O(n^2)、O(logn)</li>
</ul>
<p>什么是算法的空间复杂度？</p>
<ul>
<li>表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系<br>常见的空间复杂度：O(1)、O(n)、O(n^2)</li>
</ul>
</blockquote>
<h6 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h6><ul>
<li>指导你编写出性能更优的代码</li>
<li>评判别人写的代码的好坏</li>
</ul>
<h6 id="时间复杂度分析：来评估代码的执行耗时的"><a href="#时间复杂度分析：来评估代码的执行耗时的" class="headerlink" title="时间复杂度分析：来评估代码的执行耗时的"></a>时间复杂度分析：来评估代码的执行耗时的</h6><ul>
<li><p>大O表示法：不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong></p>
</li>
<li><p>只要代码的执行时间**<u>不随着n的增大而增大</u><strong>，这样的代码复杂度都是</strong>O(1)**</p>
</li>
<li><p>复杂度分析就是要弄清楚代码的<strong>执行次数</strong>和<strong>数据规模n</strong>之间的关系</p>
</li>
</ul>
<h6 id="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"><a href="#时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系" class="headerlink" title="时间复杂度：全称是渐进空间复杂度，表示算法占用的额外存储空间和数据规模之间的增长关系"></a>时间复杂度：全称是<code>渐进空间复杂度</code>，表示算法占用的额外<code>存储空间</code>和<code>数据规模之间</code>的增长关系</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0d4930dbc47574f03c8f4db7b995944fb4418e3/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png"></p>
<h3 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a><span style = "color:red"><strong>List相关面试题</strong></span></h3><blockquote>
<ul>
<li><p>数组是一种用<strong>连续的内存空间</strong>存储<strong>相同数据类型</strong>数组的线性数据结构</p>
</li>
<li><p>数组下标为什么从0开始</p>
<p>寻址公式是：<code>baseAddress + i * data TypeSize</code> 计算下标的内存地址效率较高</p>
</li>
<li><p>查找的时间复杂度</p>
<ul>
<li>随机(<strong>通过下标</strong>)查询的时间复杂度是O(1)</li>
<li>查找元素(<strong>未知下标</strong>)的时间复杂度是O(n)</li>
<li>查找元素(<strong>未知下标但排序</strong>)通过二分查找的时间复杂度是O(logn)</li>
</ul>
</li>
<li><p>插入和删除时间复杂度</p>
<p>插入和删除的时候，为了保证数组的内存连续性，需要挪动数组元素，平均复杂度为O(n)</p>
</li>
</ul>
</blockquote>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><ul>
<li>数据结构—数组</li>
<li>ArrayList源码分析</li>
</ul>
<h6 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h6><ul>
<li>ArrayList底层的实现原理是什么</li>
<li>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</li>
<li>如何实现数组和List之间的转换</li>
<li>ArrayList和LinkedList的区别是什么</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9c400fc7d26d51223654eb4c997ae331fed38ac8/%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%B8%BA%E4%BB%80%E4%B9%880%E5%BC%80%E5%A7%8B.png"></p>
<p><span style = "color:red"><strong>ArrayList源码分析</strong></span></p>
<blockquote>
<p>List&lt; Integer &gt; list &#x3D; new ArrayList&lt; Integer &gt;();<br>list.add(1)</p>
</blockquote>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;

    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 用于空实例的共享空数组实例
     */
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

    /**
     * 用于默认大小的空实例的共享空数组实例
     * 与上面的区分开，以了解添加第一个元素时要膨胀多少
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
  
    /* 存储ArrayList元素的数组缓冲区，ArrayList的容量就是这个数组缓冲区的长度 */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList的大小(包含的元素数量)
     * @serial
     */
    private int size;
...
&#125;

--------------------------------------------------------------------------------

public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
       // 创建一个真正存储集合位置的数组
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
    // 如果容量是0则创建一个新的数组给elementData
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        &#125;
    &#125;
    public ArrayList() &#123; 
         // 无参构造函数，默认创建空集合
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

-------------------------------------------------------------------------------
// Collection是所有单列集合的父接口
// 将 Collection 对象转换成数组，然后将数组的地址赋给 elementData
 public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        elementData = c.toArray();
        if ((size = elementData.length) != 0) &#123;
            // 判断集合类型是否为不为object[] 
            // 在其他jdk此处是 ?? == ArrayList.class
            if (elementData.getClass() != Object[].class)
                // 不是的话就拷贝到数组elementData中
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;
</code></pre>
<h6 id="ArrayList源码分析-添加和扩容操作-第1次添加数据"><a href="#ArrayList源码分析-添加和扩容操作-第1次添加数据" class="headerlink" title="ArrayList源码分析-添加和扩容操作(第1次添加数据)"></a>ArrayList源码分析-添加和扩容操作(第1次添加数据)</h6><img src="https://raw.githubusercontent.com/P-luminary/images/94991acfd36ad12ca17dfd7578011cfeffe34022/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>ArrayList底层的实现原理是什么</strong></span></p>
<ul>
<li>ArrayList底层是用<strong>动态数组</strong>实现的</li>
<li>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</li>
<li>ArrayList在添加数据的时候<ul>
<li>确保数组已使用长度(size)加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用<code>grow</code>方法扩容<del>(原来的1.5倍)</del></li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>ArrayList list &#x3D; new ArrayList(10)中的list扩容几次</strong></span></p>
<ul>
<li>该语句只是声明和实例了一个<code>ArrayList</code>，指定了容量为10，未扩容</li>
</ul>
<p><span style = "color:red"><strong>如何实现数组和List之间的转换</strong></span></p>
<ul>
<li>数组转List，使用JDK中<code>java.util.Arrays</code>工具类的<code>asList</code>方法</li>
<li>List转数组，使用List的<code>toArray</code>方法，无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组</li>
</ul>
<blockquote>
<p>使用 Hutool 工具库可以非常方便地实现数组和 <code>List</code> 之间的转换。Hutool 提供了 <code>ArrayUtil</code> 和 <code>CollUtil</code> 工具类来处理数组和集合之间的转换。</p>
<p>问：我不能用BeanUtil吗？<br>答：<code>BeanUtil</code> 是 Hutool 工具库中用于 <strong>Java Bean 操作</strong>的工具类，主要用于 <strong>对象属性拷贝</strong>、<strong>Bean 转 Map</strong>、<strong>Map 转 Bean</strong> 等操作。它并不适用于 <strong>数组和 List 之间的转换</strong>。</p>
<p>如果你误以为 <code>BeanUtil</code> 可以用于数组和 List 的转换，可能是因为它的名字容易让人误解。实际上，数组和 List 的转换应该使用 <code>ArrayUtil</code> 或 <code>CollUtil</code>。</p>
<h3 id="正确的工具类选择"><a href="#正确的工具类选择" class="headerlink" title="正确的工具类选择"></a>正确的工具类选择</h3><ol>
<li><strong>数组转 List</strong>：使用 <code>ArrayUtil.toList</code>。</li>
<li><strong>List 转数组</strong>：使用 <code>CollUtil.toArray</code>。</li>
<li><strong>Bean 属性拷贝</strong>：使用 <code>BeanUtil.copyProperties</code>。</li>
<li><strong>Bean 转 Map</strong>：使用 <code>BeanUtil.beanToMap</code>。</li>
<li><strong>Map 转 Bean</strong>：使用 <code>BeanUtil.fillBeanWithMap</code>。</li>
</ol>
<h6 id="更多的Hutool工具使用高能预警"><a href="#更多的Hutool工具使用高能预警" class="headerlink" title="更多的Hutool工具使用高能预警"></a>更多的Hutool工具使用<del>高能预警</del></h6><h5 id="1-字符串工具类：StrUtil"><a href="#1-字符串工具类：StrUtil" class="headerlink" title="1. 字符串工具类：StrUtil"></a>1. <strong>字符串工具类：<code>StrUtil</code></strong></h5><ul>
<li><strong>功能</strong>：字符串操作，如判空、格式化、截取、替换等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>StrUtil.isEmpty()</code>：判断字符串是否为空。</li>
<li><code>StrUtil.format()</code>：格式化字符串。</li>
<li><code>StrUtil.split()</code>：拆分字符串。</li>
<li><code>StrUtil.join()</code>：连接字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-日期时间工具类：DateUtil"><a href="#2-日期时间工具类：DateUtil" class="headerlink" title="2. 日期时间工具类：DateUtil"></a>2. <strong>日期时间工具类：<code>DateUtil</code></strong></h5><ul>
<li><strong>功能</strong>：日期和时间的格式化、解析、计算等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>DateUtil.now()</code>：获取当前时间。</li>
<li><code>DateUtil.format()</code>：格式化日期。</li>
<li><code>DateUtil.parse()</code>：解析字符串为日期。</li>
<li><code>DateUtil.offsetDay()</code>：日期加减。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-文件工具类：FileUtil"><a href="#3-文件工具类：FileUtil" class="headerlink" title="3. 文件工具类：FileUtil"></a>3. <strong>文件工具类：<code>FileUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件和目录的操作，如读写、复制、删除等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>FileUtil.readUtf8String()</code>：读取文件内容为字符串。</li>
<li><code>FileUtil.writeUtf8String()</code>：将字符串写入文件。</li>
<li><code>FileUtil.copy()</code>：复制文件或目录。</li>
<li><code>FileUtil.del()</code>：删除文件或目录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-JSON-工具类：JSONUtil"><a href="#4-JSON-工具类：JSONUtil" class="headerlink" title="4. JSON 工具类：JSONUtil"></a>4. <strong>JSON 工具类：<code>JSONUtil</code></strong></h5><ul>
<li><strong>功能</strong>：JSON 的解析和生成。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>JSONUtil.parseObj()</code>：将 JSON 字符串解析为 JSON 对象。</li>
<li><code>JSONUtil.parseArray()</code>：将 JSON 字符串解析为 JSON 数组。</li>
<li><code>JSONUtil.toJsonStr()</code>：将对象转换为 JSON 字符串。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-集合工具类：CollUtil"><a href="#5-集合工具类：CollUtil" class="headerlink" title="5. 集合工具类：CollUtil"></a>5. <strong>集合工具类：<code>CollUtil</code></strong></h5><ul>
<li><strong>功能</strong>：集合操作，如创建集合、判空、过滤、分组等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CollUtil.newArrayList()</code>：快速创建 ArrayList。</li>
<li><code>CollUtil.isEmpty()</code>：判断集合是否为空。</li>
<li><code>CollUtil.filter()</code>：过滤集合。</li>
<li><code>CollUtil.group()</code>：对集合进行分组。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-反射工具类：ReflectUtil"><a href="#6-反射工具类：ReflectUtil" class="headerlink" title="6. 反射工具类：ReflectUtil"></a>6. <strong>反射工具类：<code>ReflectUtil</code></strong></h5><ul>
<li><strong>功能</strong>：反射操作，如调用方法、获取字段、创建对象等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ReflectUtil.invoke()</code>：调用方法。</li>
<li><code>ReflectUtil.getFieldValue()</code>：获取字段值。</li>
<li><code>ReflectUtil.newInstance()</code>：创建对象实例。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-HTTP-工具类：HttpUtil"><a href="#7-HTTP-工具类：HttpUtil" class="headerlink" title="7. HTTP 工具类：HttpUtil"></a>7. <strong>HTTP 工具类：<code>HttpUtil</code></strong></h5><ul>
<li><strong>功能</strong>：HTTP 请求的发送和响应处理。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>HttpUtil.get()</code>：发送 GET 请求。</li>
<li><code>HttpUtil.post()</code>：发送 POST 请求。</li>
<li><code>HttpUtil.downloadFile()</code>：下载文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-加密解密工具类：SecureUtil"><a href="#8-加密解密工具类：SecureUtil" class="headerlink" title="8. 加密解密工具类：SecureUtil"></a>8. <strong>加密解密工具类：<code>SecureUtil</code></strong></h5><ul>
<li><strong>功能</strong>：常见的加密解密操作，如 MD5、SHA、AES 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>SecureUtil.md5()</code>：计算 MD5 值。</li>
<li><code>SecureUtil.sha256()</code>：计算 SHA-256 值。</li>
<li><code>SecureUtil.aes()</code>：AES 加密解密。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-IO-工具类：IoUtil"><a href="#9-IO-工具类：IoUtil" class="headerlink" title="9. IO 工具类：IoUtil"></a>9. <strong>IO 工具类：<code>IoUtil</code></strong></h5><ul>
<li><strong>功能</strong>：IO 流操作，如读写、关闭流等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>IoUtil.read()</code>：读取流内容。</li>
<li><code>IoUtil.write()</code>：写入流内容。</li>
<li><code>IoUtil.close()</code>：关闭流。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="10-随机工具类：RandomUtil"><a href="#10-随机工具类：RandomUtil" class="headerlink" title="10. 随机工具类：RandomUtil"></a>10. <strong>随机工具类：<code>RandomUtil</code></strong></h5><ul>
<li><strong>功能</strong>：生成随机数、随机字符串等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>RandomUtil.randomInt()</code>：生成随机整数。</li>
<li><code>RandomUtil.randomString()</code>：生成随机字符串。</li>
<li><code>RandomUtil.randomEle()</code>：从集合中随机选择一个元素。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="11-验证工具类：Validator"><a href="#11-验证工具类：Validator" class="headerlink" title="11. 验证工具类：Validator"></a>11. <strong>验证工具类：<code>Validator</code></strong></h5><ul>
<li><strong>功能</strong>：数据验证，如邮箱、手机号、身份证等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Validator.isEmail()</code>：验证是否为邮箱。</li>
<li><code>Validator.isMobile()</code>：验证是否为手机号。</li>
<li><code>Validator.isCitizenId()</code>：验证是否为身份证号。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="12-缓存工具类：CacheUtil"><a href="#12-缓存工具类：CacheUtil" class="headerlink" title="12. 缓存工具类：CacheUtil"></a>12. <strong>缓存工具类：<code>CacheUtil</code></strong></h5><ul>
<li><strong>功能</strong>：简单的缓存操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>CacheUtil.newTimedCache()</code>：创建定时缓存。</li>
<li><code>CacheUtil.put()</code>：添加缓存。</li>
<li><code>CacheUtil.get()</code>：获取缓存。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="13-线程工具类：ThreadUtil"><a href="#13-线程工具类：ThreadUtil" class="headerlink" title="13. 线程工具类：ThreadUtil"></a>13. <strong>线程工具类：<code>ThreadUtil</code></strong></h5><ul>
<li><strong>功能</strong>：线程操作，如睡眠、创建线程池等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ThreadUtil.sleep()</code>：线程睡眠。</li>
<li><code>ThreadUtil.newExecutor()</code>：创建线程池。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="14-Excel-工具类：ExcelUtil"><a href="#14-Excel-工具类：ExcelUtil" class="headerlink" title="14. Excel 工具类：ExcelUtil"></a>14. <strong>Excel 工具类：<code>ExcelUtil</code></strong></h5><ul>
<li><strong>功能</strong>：Excel 文件的读写操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ExcelUtil.getReader()</code>：读取 Excel 文件。</li>
<li><code>ExcelUtil.getWriter()</code>：写入 Excel 文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="15-压缩工具类：ZipUtil"><a href="#15-压缩工具类：ZipUtil" class="headerlink" title="15. 压缩工具类：ZipUtil"></a>15. <strong>压缩工具类：<code>ZipUtil</code></strong></h5><ul>
<li><strong>功能</strong>：文件或目录的压缩和解压缩。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>ZipUtil.zip()</code>：压缩文件或目录。</li>
<li><code>ZipUtil.unzip()</code>：解压缩文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="16-日志工具类：Log"><a href="#16-日志工具类：Log" class="headerlink" title="16. 日志工具类：Log"></a>16. <strong>日志工具类：<code>Log</code></strong></h5><ul>
<li><strong>功能</strong>：简化日志操作。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>Log.get()</code>：获取日志对象。</li>
<li><code>Log.info()</code>：输出日志信息。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="17-数学工具类：MathUtil"><a href="#17-数学工具类：MathUtil" class="headerlink" title="17. 数学工具类：MathUtil"></a>17. <strong>数学工具类：<code>MathUtil</code></strong></h5><ul>
<li><strong>功能</strong>：数学计算，如四舍五入、最大值、最小值等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>MathUtil.round()</code>：四舍五入。</li>
<li><code>MathUtil.max()</code>：获取最大值。</li>
<li><code>MathUtil.min()</code>：获取最小值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="18-网络工具类：NetUtil"><a href="#18-网络工具类：NetUtil" class="headerlink" title="18. 网络工具类：NetUtil"></a>18. <strong>网络工具类：<code>NetUtil</code></strong></h5><ul>
<li><strong>功能</strong>：网络相关操作，如获取本机 IP、Ping 等。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>NetUtil.getLocalhost()</code>：获取本机 IP。</li>
<li><code>NetUtil.ping()</code>：Ping 测试。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>用<code>Arrays.asList</code>转List后，如果修改了数组内容，list受影响吗</li>
<li>List用<code>toArray</code>转数组后，如果修改了List内容，数组受影响吗</li>
</ul>
<h6 id="再答："><a href="#再答：" class="headerlink" title="再答："></a>再答：</h6><ul>
<li>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</li>
<li>list用了toArray转数组后，如果修改了list内容，数组不会受影响，当调用了toArray以后，在底层是它进行了数组拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2a0e6fcd9e82104de79aeb269b64bee2fe250a37/%E6%95%B0%E7%BB%84%E5%92%8Clist%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>LinkedList的数据结构—链表</strong></span></p>
<p><strong>单向链表</strong></p>
<ul>
<li>链表中的每一个元素称之为结点(Node)</li>
<li>物理存储单元上，非连续、非顺序的存储结构</li>
<li>单向链表：每个结点包括两个部分:一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。记录下个结点地址的指针叫作后继指针 next</li>
</ul>
<h6 id="1-单向链表和双向链表的区别是什么"><a href="#1-单向链表和双向链表的区别是什么" class="headerlink" title="1.单向链表和双向链表的区别是什么"></a>1.单向链表和双向链表的区别是什么</h6><ul>
<li>单向链表只有一个方向，结点只有一个后继指针 next。</li>
<li>双向链表它支持两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点</li>
</ul>
<h6 id="2-链表操作数据的时间复杂度是多少"><a href="#2-链表操作数据的时间复杂度是多少" class="headerlink" title="2.链表操作数据的时间复杂度是多少"></a>2.链表操作数据的时间复杂度是多少</h6><table>
<thead>
<tr>
<th></th>
<th>查询</th>
<th>新增删除</th>
</tr>
</thead>
<tbody><tr>
<td>单向链表</td>
<td>头O(1), 其他O(n)</td>
<td>头O(1), 其他O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
<td>头尾O(1), 其他O(n), 给定节点O(1)</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/89cd60c5af783394daee166cbfce512c0b796d0f/LinkedList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E9%93%BE%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>ArrayList和LinkedList的区别</strong></span></p>
<ul>
<li><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a><span style = "color:blue">底层数据结构</span></h5><ul>
<li>ArrayList 是<strong>动态数组</strong>的数据结构实现</li>
<li>LinkedList 是<strong>双向链表</strong>的数据结构实现</li>
</ul>
</li>
<li><p><strong>操作数组效率</strong></p>
<ul>
<li><p>ArrayList  按照下标查询的时间复杂度O(1);【内存是连续的，根据寻址公式】，LinkedList不支持下标查询</p>
</li>
<li><p>查找(未知索引)：ArrayList需要遍历，链表也需要遍历，时间复杂度都是O(n)</p>
</li>
<li><p><strong>新增</strong>和<strong>删除</strong>【查询多用<code>ArrayList</code>；插入&#x2F;删除多用<code>Linked</code>】</p>
<ul>
<li>ArrayList 尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li>
<li>LinkedList 头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存空间占用</strong></p>
<ul>
<li>ArrayList 底层是数组，内存连续，节省内存</li>
<li>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li><p><span style = "color:blue"><strong><u>ArrayList和LinkedList都不是线程安全的</u></strong></span></p>
</li>
<li><p>如果要保证线程安全，有两种方法</p>
<ul>
<li><p>在<strong>方法内使用</strong>，局部变量则是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<pre><code class="java">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());
List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(new LinkedList&lt;&gt;());
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a><span style = "color:red"><strong>HashMap相关面试题</strong></span></h3><ul>
<li><p><strong>二叉树</strong></p>
<ul>
<li><p>满二叉树</p>
</li>
<li><p>完全二叉树</p>
</li>
<li><p><strong>二叉搜索树</strong></p>
<p>二叉搜索树又名二叉查找树，有序二叉树或者排序二叉树，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</p>
</li>
<li><p><strong>红黑树</strong></p>
</li>
</ul>
</li>
<li><p><strong>红黑树</strong></p>
</li>
<li><p><strong>散列表</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/678118180d1bda0ac019f934c04c3db01eff5cf8/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p>
<blockquote>
<h3 id="✅-1-二叉树（Binary-Tree）"><a href="#✅-1-二叉树（Binary-Tree）" class="headerlink" title="✅ 1. 二叉树（Binary Tree）"></a>✅ 1. 二叉树（Binary Tree）</h3><p>每个节点最多有两个子节点，称为左子节点和右子节点。</p>
<hr>
<h3 id="✅-2-满二叉树（Full-Binary-Tree）"><a href="#✅-2-满二叉树（Full-Binary-Tree）" class="headerlink" title="✅ 2. 满二叉树（Full Binary Tree）"></a>✅ 2. 满二叉树（Full Binary Tree）</h3><p>每个节点要么是叶子节点，要么恰好有两个子节点，且<strong>所有叶子都在同一层</strong>。</p>
<hr>
<h3 id="✅-3-完全二叉树（Complete-Binary-Tree）"><a href="#✅-3-完全二叉树（Complete-Binary-Tree）" class="headerlink" title="✅ 3. 完全二叉树（Complete Binary Tree）"></a>✅ 3. 完全二叉树（Complete Binary Tree）</h3><p>除了最后一层，其他每一层的节点数都达到最大值，且<strong>最后一层节点集中在左侧</strong>。</p>
<hr>
<h3 id="✅-4-二叉搜索树（Binary-Search-Tree，BST）"><a href="#✅-4-二叉搜索树（Binary-Search-Tree，BST）" class="headerlink" title="✅ 4. 二叉搜索树（Binary Search Tree，BST）"></a>✅ 4. 二叉搜索树（Binary Search Tree，BST）</h3><blockquote>
<p>又叫：<strong>二叉查找树、有序二叉树</strong></p>
</blockquote>
<p>特点：</p>
<ul>
<li>对于任意一个节点 <code>node</code>：<ul>
<li>左子树中所有节点值 &lt; <code>node</code> 值</li>
<li>右子树中所有节点值 &gt; <code>node</code> 值</li>
</ul>
</li>
<li>中序遍历是<strong>升序排列</strong></li>
</ul>
<p>用途：</p>
<ul>
<li>用于快速查找、插入、删除（时间复杂度平均为 O(log n)，最坏为 O(n)）</li>
</ul>
<hr>
<h3 id="✅-5-红黑树（Red-Black-Tree）"><a href="#✅-5-红黑树（Red-Black-Tree）" class="headerlink" title="✅ 5. 红黑树（Red-Black Tree）"></a>✅ 5. 红黑树（Red-Black Tree）</h3><p>红黑树是<strong>自平衡的二叉搜索树</strong>，在多种语言的底层集合结构（如 Java 的 <code>TreeMap</code>、<code>TreeSet</code>，C++ 的 <code>map</code>、<code>set</code>）都有使用。</p>
<p>特点：</p>
<ul>
<li>每个节点是红或黑</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL）是黑色</li>
<li>红色节点不能有红色子节点（即不能连续两个红）</li>
<li>任意一节点到其所有后代叶子节点的路径上，<strong>黑色节点数量相同</strong></li>
</ul>
<p>目的：</p>
<ul>
<li>保证在最坏情况下，查找、插入、删除的时间复杂度是 O(log n)</li>
</ul>
<hr>
<h3 id="✅-6-散列表（Hash-Table）"><a href="#✅-6-散列表（Hash-Table）" class="headerlink" title="✅ 6. 散列表（Hash Table）"></a>✅ 6. 散列表（Hash Table）</h3><p>与树不同，散列表是通过<strong>哈希函数（Hash Function）</strong>将键映射到数组下标进行查找。</p>
<p>特点：</p>
<ul>
<li>查找时间接近 O(1)</li>
<li>冲突处理方式如链地址法、开放定址法等</li>
<li>用于实现如 Java 的 <code>HashMap</code>、<code>HashSet</code>、Python 的 <code>dict</code>、<code>set</code> 等结构</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>数据结构—红黑树 什么是红黑树？</strong></span></p>
<ul>
<li>红黑树：也是一种自平衡的二叉搜索树(BST)</li>
<li>所有的红黑规则都是希望红黑树能够保证平衡</li>
<li>红黑树的时间复杂度：查找、添加、删除都是O(logn)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d52e3005e6dbb2c546a407bdb237c51cbdab9694/%E7%BA%A2%E9%BB%91%E6%A0%91.png"></p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><span style = "color:red"><strong>散列表</strong></span></h4><p><span style = "color:red"><strong>什么是散列表？</strong></span></p>
<blockquote>
<ul>
<li>散列表(Hash Table)又叫哈希表&#x2F;Hash表</li>
<li>根据键(Key)直接访问再内存存储位置值(Value)的数据结构</li>
<li>由数组演化而来的，利用了数组支持按照下标进行随机访问数据</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突</strong></span></p>
<blockquote>
<ul>
<li>散列冲突又成为<strong>哈希冲突</strong>，哈希碰撞</li>
<li>指多个key映射到同一个数组下标位置</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>散列冲突—链表法(拉链)</strong></span></p>
<blockquote>
<ul>
<li>数组的每个下标位置称之为<strong>桶</strong>(bucket) 或者 <strong>槽</strong>(slot)</li>
<li>每个桶(槽)会对应一条链表</li>
<li>hash冲突后的元素都放到相同槽位对应的链表中或红黑树中</li>
</ul>
</blockquote>
<p>在<strong>HashMap</strong>中的最重要的一个数据结构就是散列表，在散列表中又用到了<strong>红黑树</strong>和<strong>链表</strong><br>散列表(Hash Table)又名为<strong>哈希表</strong>&#x2F;Hash表，是<strong>根据键(Key)直接访问</strong>在内存存储位置<strong>值(value)<strong>的数据结构，它是</strong>由数组演化而来的</strong>，利用了数组支持按照下标进行随机访问数据的特性<del>[根据寻址公式,时间复杂度O(1)]</del></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6dd0e10d2aaa9a064fde0c973b9d942ae149d17c/%E6%95%A3%E5%88%97%E8%A1%A8.png"></p>
<h4 id="说一下HashMap的实现原理"><a href="#说一下HashMap的实现原理" class="headerlink" title="说一下HashMap的实现原理"></a><span style = "color:red"><strong>说一下HashMap的实现原理</strong></span></h4><blockquote>
<p>1.说一下HashMap的实现原理</p>
<ul>
<li><p>HashMap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树</p>
</li>
<li><p>添加数据时，计算key的值确定元素在数组中的下标</p>
<ul>
<li>key相同则替换</li>
<li>不同则存入链表或红黑树中</li>
</ul>
<p>获取数据通过key的hash计算数组下标获取元素</p>
</li>
</ul>
<p>2.<span style = "color:blue"><strong>HashMap的jdk1.7和jdk1.8有什么区别</strong></span></p>
<ul>
<li>JDK1.8之前采用的拉链法，数组+链表</li>
<li>JDK1.8之后采用数组+链表+红黑树<br>链表长度大于8且数组长度大于64则会从链表转化为红黑树</li>
</ul>
</blockquote>
<p>当我们往HashMap中put元素时(扰动函数)，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/27826dde4b711105a212f30f6381f8097eca69ba/HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<h4 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a><span style = "color:red"><strong>HashMap的put方法的具体流程</strong></span></h4><blockquote>
<p>1.判断键值对数组table是否为空或为null，否则执行resize()进行扩容 [初始化]<br>2.根据键值key计算hash值得到数组索引<br>3.判断table[i] &#x3D;&#x3D; null，条件成立，直接新建节点添加<br>4.如果table[i] &#x3D;&#x3D; null，不成立<br>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value<br>4.2 判断table[i]是否为<strong>treeNode</strong>，即table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对<br>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d2fa5788e2f2f5c7e75e724c8bef242b6661c10c/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>讲一下HashMap的扩容机制</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c4e2b5bca4f89ece679358c70cdb042f8028aa81/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6.png"></p>
<p><span style = "color:red"><strong>HashMap源码分析</strong></span></p>
<p>桶下标是hash值取模数组(长度)下标 capacity</p>
<p><span style = "color:red"><strong>HashMap的寻址算法</strong></span></p>
<p>Hash值右移16位后与原来的hash值进行异或运算【扰动算法<del>hash值更加均匀,减少hash冲突</del>】<br>数组长度必须是2的n次幂 按位<strong>与运算</strong>的效果才能代替取模</p>
<blockquote>
<p>int hash &#x3D; h ^ (h &gt;&gt;&gt; 16);                 &#x2F;&#x2F; hashCode 的扰动处理<br>index &#x3D; hash &amp; (table.length - 1);   &#x2F;&#x2F; 更快的取模运算</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/85bdc4d076df91ec3d29294926d65f55713b2d26/HashMap%E5%AF%BB%E5%9D%80%E7%AE%97w%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>HashMap在1.7情况下的多线程死循环问题</strong></span></p>
<p>jdk7的数据结构是：数组+链表<br>在数组进行扩容的时候，因为链表是<strong>头插法</strong>(在并发情况下可能出现<strong>链表反转成环形结构</strong>)，在进行数据迁移的过程中，有可能导致死循环</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1be6d73360d8cdf5baa6b2fea0b1fc8fa8b7fadc/HashMap%E5%9C%A81.7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98.png"></p>
<h4 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a><span style = "color:red">进程和线程的区别？</span></h4><blockquote>
<h6 id="两者对比："><a href="#两者对比：" class="headerlink" title="两者对比："></a>两者对比：</h6><ul>
<li><u><strong>进程</strong>是整个在运行程序的实例</u>，<u>进程中包含了<strong>线程</strong></u>，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>简要定义</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>程序的执行实例，<strong>资源分配的最小单位</strong></td>
</tr>
<tr>
<td>线程</td>
<td>进程内的执行单元，<strong>cpu调度的最小单位</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>项目</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>概念</td>
<td>正在运行的程序实例</td>
<td>进程中的执行单元</td>
</tr>
<tr>
<td>所属关系</td>
<td>进程可包含多个线程</td>
<td>线程依附于进程存在</td>
</tr>
<tr>
<td>内存空间</td>
<td>拥有独立地址空间</td>
<td>共享所属进程的内存空间</td>
</tr>
<tr>
<td>创建开销</td>
<td>创建&#x2F;销毁成本高（需要资源分配）</td>
<td>创建&#x2F;销毁成本低（共享资源）</td>
</tr>
<tr>
<td>通信方式</td>
<td>进程间通信较复杂（如管道&#x2F;套接字）</td>
<td>线程通信简单（共享变量）</td>
</tr>
<tr>
<td>崩溃影响</td>
<td>一个进程崩溃不会影响其他进程</td>
<td>一个线程崩溃可能影响整个进程</td>
</tr>
<tr>
<td>切换开销</td>
<td>上下文切换开销大</td>
<td>上下文切换开销小</td>
</tr>
<tr>
<td>资源隔离</td>
<td>资源独立，安全性高</td>
<td>资源共享，效率高但易出错</td>
</tr>
</tbody></table>
<pre><code class="css">[ 进程A ]
 ├── 线程1：负责计算
 ├── 线程2：负责文件IO
 └── 线程3：负责网络通信

[ 进程B ]
 └── 线程1：完全独立
</code></pre>
</blockquote>
<p>程序由<strong>指令</strong>和<strong>数据</strong>组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备，<strong>进程</strong>就是用来加载指令、管理内存、管理IO的。<br>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个**<u>进程</u>**</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。一个进程之内可以分为一到多个线程</p>
<blockquote>
<p>core → 线程1[指令1，指令2，指令3…]   线程2[指令1，指令2，指令3…] </p>
</blockquote>
<h4 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a><span style = "color:red">并行和并发的区别？</span></h4><blockquote>
<p>现在都是多核CPU，在多核CPU下</p>
<ul>
<li>并发是<strong>同一时间</strong>应对多件事情的能力，多个线程<strong>轮流使用</strong>一个或多个CPU</li>
<li>并行是<strong>同一时间</strong>动手做多件事的能力，4核CPU<strong>同时执行</strong>4个线程</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>并发</td>
<td>同一时间段<strong>处理多个任务的能力</strong>（任务<strong>轮流切片</strong>执行）</td>
</tr>
<tr>
<td>并行</td>
<td>同一时刻<strong>真正同时执行多个任务</strong>（多个核同时执行）</td>
</tr>
</tbody></table>
</blockquote>
<p>&#x3D;&#x3D;<strong>单核CPU</strong>&#x3D;&#x3D; → 单核CPU下线程实际还是串行执行的</p>
<ul>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15ms)分给不同的程序使用，只是由于cpu在线程间(时间片很短)的切换非常快，人类感觉是同时运行的</li>
<li>每个时间片只能用有一个线程被执行</li>
<li>总结一句话：**<u>微观串行，宏观并行</u>**</li>
<li>一般会将这种线程轮流使用CPU的做法称为并发(concurrent)</li>
</ul>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
</tr>
</thead>
<tbody><tr>
<td>core</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
</tr>
</tbody></table>
<p><strong>&#x3D;&#x3D;多核CPU&#x3D;&#x3D;</strong> → 每个核(core)都可以调度运行线程，这个时候线程是可以并行的</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>时间片1</th>
<th>时间片2</th>
<th>时间片3</th>
<th>时间片4</th>
</tr>
</thead>
<tbody><tr>
<td>core1</td>
<td>线程1</td>
<td>线程2</td>
<td>线程3</td>
<td>线程3</td>
</tr>
<tr>
<td>core2</td>
<td>线程2</td>
<td>线程4</td>
<td>线程2</td>
<td>线程4</td>
</tr>
</tbody></table>
<blockquote>
<p>并发 (concurrent) 是同一时间<strong>应对</strong> (dealing with) 多件事情的能力<br>并行 (parallel) 是同一时间<strong>动手做</strong> (doing) 多件事情的能力</p>
<ul>
<li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这么多件事，这就是<strong>并发</strong>【单核CPU】</li>
<li>家庭主妇雇了个保姆，她们一起做这些事，这时既有并发，也有并行【会产生竞争，例如锅只有一个，一个人用锅时，另一个人就要等待】</li>
<li>雇了3个保姆，一个专门做饭，一个专门打扫卫生，一个专门喂奶，互不干扰，这就是<strong>并行</strong></li>
</ul>
</blockquote>
<h4 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a><span style = "color:red">创建线程的方式有哪些？</span></h4><ul>
<li><h5 id="继承Thread类，重写run方法"><a href="#继承Thread类，重写run方法" class="headerlink" title="继承Thread类，重写run方法"></a>继承Thread类，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyThread extends Thread&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyThread...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建MyThread对象
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Runnable接口，重写run方法"><a href="#实现Runnable接口，重写run方法" class="headerlink" title="实现Runnable接口，重写run方法"></a>实现Runnable接口，重写run方法</h5></li>
</ul>
<pre><code class="java">public class MyRunnable implements Runnable &#123;

    @Override
    public void run() &#123;
        // 在这里编写要执行的任务
        System.out.println(&quot;线程正在执行任务...&quot;);
    &#125;
    public static void main(String[] args) &#123;
        // 创建MyRunnable实例
        MyRunnable myRunnable = new MyRunnable();
        
        // 创建线程并启动
        Thread t1 = new Thread(myRunnable);
        Thread t2 = new Thread(myRunnable);
        // 调用start方法启动线程
        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致"><a href="#实现Callable-lt-T-gt-接口，重写call方法泛型和重写方法一致" class="headerlink" title="实现Callable&lt; T &gt;接口，重写call方法泛型和重写方法一致"></a>实现Callable&lt; T &gt;接口，重写call方法<del>泛型和重写方法一致</del></h5></li>
</ul>
<pre><code class="java">public class MyCallable implements Callable&lt;String&gt; &#123;
 @Override
    public String call() throws Exception &#123;
        sout(Thread.currentThread().getName());
        return &quot;ok&quot;;
    &#125;
     public static void main(String[] args) &#123;
        // 创建MyCallable实例
        MyCallable myCallable = new MyCallable();
        
        // 使用FutureTask来包装Callable对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;String&gt;(myCallable);
        
        // 创建并启动线程
        Thread t1 = new Thread(ft);
        t1.start();
        // 调用ft的get方法获取执行结果
        String result = ft.get();
        sout(result)
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="线程池创建线程-项目中使用的方式"><a href="#线程池创建线程-项目中使用的方式" class="headerlink" title="线程池创建线程 (项目中使用的方式)"></a><span style = "color:blue">线程池创建线程 (项目中使用的方式)</span></h5></li>
</ul>
<pre><code class="java">public class MyExecutors implements Runnable&#123;
    @Override
    public void run()&#123;
        sout(&quot;MyRunnable...run...&quot;);
    &#125;
    public static void main(String[] args)&#123;
        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()); 
        //submit用来提交线程
        
        // 关闭线程池
        threadPool.shutdown();
    &#125;
&#125;
</code></pre>
<h6 id="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"><a href="#刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？" class="headerlink" title="刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？"></a><span style = "color:red">刚刚你说过，使用runnable和callable都可以创建线程，它们有什么区别呢？</span></h6><blockquote>
<ul>
<li>Runnable接口run方法<strong>没有返回值</strong></li>
<li><strong>Callable</strong>接口call方法<strong>有返回值</strong>，要结合FutureTask配合可以用来获取异步执行的结果</li>
</ul>
<blockquote>
<p><strong><code>FutureTask</code></strong> 是 <strong><code>Future</code></strong> 的实现类，它可以包装一个 <code>Callable</code> 或 <code>Runnable</code> 对象，并允许我们在任务执行完毕后获取执行结果或取消任务。</p>
<p><strong><code>FutureTask</code></strong> 可以在子线程中异步执行任务，而主线程可以通过调用 <code>FutureTask.get()</code> 方法获取任务执行的结果。</p>
</blockquote>
<ul>
<li>Callable接口的call()方法<strong>允许抛出异常</strong>；而Runnabble接口的run()方法的异常只能在<strong>内部消化</strong>，不能继续上抛</li>
</ul>
<pre><code class="java">import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableExample &#123;

    public static void main(String[] args) throws Exception &#123;
        // 创建一个Callable任务
        Callable&lt;Integer&gt; task = new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                System.out.println(&quot;Task is running in the background...&quot;);
                // 模拟耗时操作
                Thread.sleep(2000);
                return 42; // 返回计算结果
            &#125;
        &#125;;

        // 创建FutureTask对象，包装Callable任务
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);

        // 启动线程执行FutureTask
        Thread thread = new Thread(futureTask);
        thread.start();

        // 主线程可以做一些其他工作
        System.out.println(&quot;Main thread is doing something else...&quot;);

        // 获取异步执行结果，阻塞直到任务完成
        Integer result = futureTask.get(); // 这会阻塞主线程直到获取到结果
        System.out.println(&quot;Task result: &quot; + result); // 打印任务执行结果
    &#125;
&#125;
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>在启动线程的时候，可以使用run方法吗？run()和start()有什么区别？</strong></span></p>
<p>start()是开启一个线程   run()跟开启普通方法一样</p>
<blockquote>
<p><strong>start()：</strong>用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。<strong>start方法只能被调用一次</strong><br><strong>run()：</strong>封装了要被线程执行的代码，<strong>可以被调用多次</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/807ae461bb166b0aa6a755a66e43d57c0166323c/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9.png"></p>
<h4 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a><span style = "color:red"><strong>线程包括哪些状态，状态之间是如何变化的？</strong></span></h4><blockquote>
<p>状态：<br><strong>新建</strong>New、<strong>可运行</strong>Runnable、<strong>阻塞</strong>Blocked、<strong>等待</strong>Waiting、<strong>时间等待</strong>Timed_waiting、<strong>终止</strong>Terminated</p>
<p>线程状态之间如何变化：</p>
<ul>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了<strong>start()<strong>方法转变为</strong>可执行状态</strong></li>
<li>线程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁(<strong>synchronized</strong>或lock) 进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了<strong>wait()<strong>方法进入</strong>等待状态</strong>，其他线程调用notify()唤醒后可转换为可执行状态</li>
<li>如果线程调用了<strong>sleep(50)<strong>方法，进入</strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="java">Thread.java
public enum State &#123;
    /**
     * 新建状态。线程已经被创建，但尚未启动。
     */
    NEW,

    /**
     * 可运行状态。线程在JVM中是可运行的，这并不意味着它一定在运行，它可能在等待其他线程或操作系统的资源。
     */
    RUNNABLE,

    /**
     * 阻塞状态。线程正在等待监视器锁，以进入一个同步块/方法，或者在调用Object.wait后等待重新进入同步块/方法。
     */
    BLOCKED,

    /**
     * 等待状态。线程在等待另一个线程执行特定操作。例如，一个线程调用了Thread.join，它在等待指定的线程终止。
     */
    WAITING,

    /**
     * 超时等待状态。线程在等待另一个线程执行特定操作，但它设置了超时时间。如果线程在指定时间内没有等待到所需条件，它将自动返回。
     */
    TIMED_WAITING,

    /**
     * 终止状态。线程已经完成了执行。
     */
    TERMINATED;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/981d7e954005439be7e8261b142100e3e87f800b/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"></p>
<p><span style = "color:red"><strong>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</strong></span></p>
<p>可以使用线程中的<strong>join</strong>方法解决<br><code>join() 等待线程运行结束</code></p>
<pre><code class="java">t.join() 阻塞调用此方法的线程进入timed_waiting 直到线程t执行完毕后，此线程再继续执行
</code></pre>
<pre><code class="java">Thread t1 = new Thread(()-&gt;&#123;
    sout(&quot;t1&quot;);
&#125;);
Thread t2 = new Thread(()-&gt;&#123;
    try&#123;
        t1.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t2&quot;);
&#125;)
Thread t3 = new Thread(()-&gt;&#123;
    try&#123;
        t2.join();
    &#125;catch(InterruptedException e)&#123;
        e.printStackTrance();
    &#125;
    sout(&quot;t3&quot;);
&#125;);
// 启动线程
t1.start();
t2.start();
t3.start();
</code></pre>
<p><span style = "color:red"><strong>notify() 和 notifyAll() 有什么区别？</strong></span></p>
<blockquote>
<ul>
<li><strong>notifyAll</strong>：唤醒所有wait的线程</li>
<li><strong>notify</strong>：只随机唤醒一个wait线程</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>java中wait和sleep方法有什么区别？</strong></span><del>wait要和synchronized一起使用</del></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>归属类</th>
<th>是否释放锁</th>
<th>唤醒方式</th>
<th>使用前提</th>
</tr>
</thead>
<tbody><tr>
<td><code>sleep()</code></td>
<td><code>Thread</code></td>
<td>❌ 不释放锁</td>
<td>时间到、被打断</td>
<td>直接调用即可</td>
</tr>
<tr>
<td><code>wait()</code></td>
<td><code>Object</code></td>
<td>✅ 释放锁</td>
<td><code>notify()</code>&#x2F;时间到&#x2F;被打断</td>
<td>必须配合 <code>synchronized</code> 使用</td>
</tr>
</tbody></table>
<h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>wait()，wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul>
<li>方法归属不同<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait()，wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li><strong>wait(long)和wait()还可以被notify唤醒</strong>，wait()如果不唤醒就一直等下去<del>wait要和synchronized一起使用</del></li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><strong>锁特性不同</strong>【重点】<ul>
<li><strong>wait方法的调用必须先获取wait对象的锁</strong>，而sleep则无此限制</li>
<li>wait方法执行后会释放锁对象，允许其他线程获得该锁对象 (我放弃cpu，但你们还可以用)</li>
<li>而sleep如果在synchronized代码块中执行，并不会释放锁对象 (我放弃cpu，你们也用不了)</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="✅-核心区别（面试高频）"><a href="#✅-核心区别（面试高频）" class="headerlink" title="✅ 核心区别（面试高频）"></a>✅ 核心区别（面试高频）</h2><table>
<thead>
<tr>
<th>维度</th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属类</td>
<td><code>Thread</code> 静态方法</td>
<td><code>Object</code> 实例方法</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>❌ 不释放锁</td>
<td>✅ 释放当前对象锁</td>
</tr>
<tr>
<td>是否需要锁</td>
<td>❌ 不需要任何锁</td>
<td>✅ 必须持有该对象的锁（<code>synchronized</code>）</td>
</tr>
<tr>
<td>唤醒方式</td>
<td>到时间&#x2F;中断</td>
<td>到时间&#x2F;中断&#x2F;<code>notify</code> &#x2F; <code>notifyAll</code></td>
</tr>
<tr>
<td>使用目的</td>
<td><strong>让线程暂停执行</strong>，但持有锁不让别人进</td>
<td><strong>让线程等待并释放锁，协调多线程通信</strong></td>
</tr>
</tbody></table>
<h2 id="✅-场景对比"><a href="#✅-场景对比" class="headerlink" title="✅ 场景对比"></a>✅ 场景对比</h2><table>
<thead>
<tr>
<th>场景</th>
<th>使用方法</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>想暂停线程几秒钟（不释放锁）</td>
<td><code>Thread.sleep(ms)</code></td>
<td>常用于模拟网络延迟&#x2F;定时任务</td>
</tr>
<tr>
<td>多线程协作（生产者-消费者模型）</td>
<td><code>wait()</code> &#x2F; <code>notify()</code></td>
<td>用于线程间通信，让出锁资源</td>
</tr>
</tbody></table>
<h2 id="✅-通俗类比-🌰"><a href="#✅-通俗类比-🌰" class="headerlink" title="✅ 通俗类比 🌰"></a>✅ 通俗类比 🌰</h2><ul>
<li><code>sleep()</code>：你在<strong>厕所里睡觉</strong>，门上锁了（别人不能进），你虽然休息了，但别人也进不来。</li>
<li><code>wait()</code>：你说“我出去抽根烟（释放锁）”，别人可以进去用厕所（释放资源），抽完烟再回来（被唤醒）继续工作。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5541d691652184639a4936426271a2f6ea03d2fb/wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.png"></p>
<p><span style = "color:red"><strong>如何停止一个正在运行的线程？</strong></span></p>
<h6 id="有三种方式可以停止线程"><a href="#有三种方式可以停止线程" class="headerlink" title="有三种方式可以停止线程"></a>有三种方式可以停止线程</h6><ul>
<li>使用<strong>退出标志位</strong>，使线程<strong>正常退出</strong>，也就是当run方法完成后线程终止</li>
<li>使用<strong>stop方法</strong>强行终止(不推荐，方法已作废)</li>
<li>使用<strong>interrupt</strong>方法中断线程<ul>
<li>打断阻塞的线程(sleep, wait, join)的线程，线程会抛出InterruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/64f320ea60791a6cc20d9e238d50be95345d1485/%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理？</strong></span><del>底层：Monitor</del></p>
<blockquote>
<ul>
<li>synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li>
<li>它的底层由monitor实现的，monitor**是jvm级别的现象(C++实现)**，线程获得锁需要使用对象(锁)关联monitor</li>
<li>在monitor内部有三个属性，分别是<code>owner、entrylist、waitset</code><ul>
<li>owner是关联的获得锁的线程，并且只能关联一个线程；</li>
<li>entrylist关联的是处于阻塞状态的线程；</li>
<li>waitset关联的是处于Waiting状态的线程；</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized关键字的底层原理—进阶</strong></span></p>
<p><span style = "color:red"><strong><u>Monitor实现的锁属于重量级锁，你了解过锁升级吗？</u></strong></span></p>
<blockquote>
<h4 id="一旦锁发生了竞争，都会升级为重量级锁"><a href="#一旦锁发生了竞争，都会升级为重量级锁" class="headerlink" title="一旦锁发生了竞争，都会升级为重量级锁"></a>一旦锁发生了竞争，都会升级为重量级锁</h4><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 【有多个线程来抢】</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争)可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
</blockquote>
<ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<blockquote>
<p>每一个 Java 对象在 JVM 中都有一个对象头，其中包含 <strong>MarkWord</strong>，用于存储锁信息。<br>当线程访问 <code>synchronized</code> 方法或代码块时，会尝试获取对象关联的 <strong>Monitor</strong>，进入临界区：Monitor 中包含：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td>owner</td>
<td>当前持有锁的线程</td>
</tr>
<tr>
<td>entryList</td>
<td>等待获取锁（阻塞）的线程队列</td>
</tr>
<tr>
<td>waitSet</td>
<td>调用 <code>wait()</code> 被挂起的线程队列</td>
</tr>
</tbody></table>
<h3 id="获取锁流程（简化）："><a href="#获取锁流程（简化）：" class="headerlink" title="获取锁流程（简化）："></a>获取锁流程（简化）：</h3><ol>
<li>检查对象头中的 MarkWord；</li>
<li>如果未被锁，尝试通过 CAS 设置为当前线程（偏向或轻量级）；</li>
<li>如果竞争失败 → 升级为重量级锁（Monitor）；</li>
<li>等待唤醒或抢占锁。</li>
</ol>
<h5 id="锁升级过程（从偏向锁-→-轻量级锁-→-重量级锁）"><a href="#锁升级过程（从偏向锁-→-轻量级锁-→-重量级锁）" class="headerlink" title="锁升级过程（从偏向锁 → 轻量级锁 → 重量级锁）"></a>锁升级过程（从偏向锁 → 轻量级锁 → 重量级锁）</h5><table>
<thead>
<tr>
<th>锁类型</th>
<th>触发条件</th>
<th>优点</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>只有一个线程访问（无竞争）</td>
<td>几乎无开销，不用 CAS</td>
<td>单线程长时间持有的锁</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>多线程访问，但加锁时间错开</td>
<td>使用 CAS，无阻塞，性能较高</td>
<td>少量线程短时间交替访问</td>
</tr>
<tr>
<td>重量级锁</td>
<td>多线程同时竞争同一把锁</td>
<td>线程阻塞 + 唤醒，开销大</td>
<td>并发激烈，必须互斥的场景</td>
</tr>
</tbody></table>
<h5 id="偏向锁-x2F-轻量级锁-x2F-重量级锁细节图解（简述）"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁细节图解（简述）" class="headerlink" title="偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁细节图解（简述）"></a>偏向锁 &#x2F; 轻量级锁 &#x2F; 重量级锁细节图解（简述）</h5><h3 id="🚀-偏向锁原理："><a href="#🚀-偏向锁原理：" class="headerlink" title="🚀 偏向锁原理："></a>🚀 偏向锁原理：</h3><ul>
<li>第一次访问：CAS 记录当前线程 ID 到对象头</li>
<li>再次访问时：只判断对象头的线程 ID 是否是自己</li>
<li>如果有竞争，偏向锁就会被撤销，升级为轻量级锁</li>
</ul>
<h3 id="🚀-轻量级锁原理："><a href="#🚀-轻量级锁原理：" class="headerlink" title="🚀 轻量级锁原理："></a>🚀 轻量级锁原理：</h3><ul>
<li>在 <strong>线程栈中创建 LockRecord</strong>；</li>
<li>尝试 CAS 将 LockRecord 指针复制到对象头；</li>
<li>成功 → 获取锁；失败 → 说明竞争，升级为重量级锁</li>
</ul>
<h3 id="🚀-重量级锁原理（Monitor）："><a href="#🚀-重量级锁原理（Monitor）：" class="headerlink" title="🚀 重量级锁原理（Monitor）："></a>🚀 重量级锁原理（Monitor）：</h3><ul>
<li>Monitor 的实现是基于 <strong>操作系统的互斥量（mutex）</strong></li>
<li>涉及线程的挂起、唤醒（用户态 → 内核态切换，开销大）</li>
</ul>
</blockquote>
<h6 id="Monitor重量级锁"><a href="#Monitor重量级锁" class="headerlink" title="Monitor重量级锁"></a>Monitor重量级锁</h6><p>每个Java对象都可以关联一个Monitor对象，如果使用 synchronized 给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><ul>
<li>在线程栈中创建一个Lock Record，将其obj字段指向锁对象。</li>
<li>通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为nul，起到了一个重入计数器的作用。</li>
<li>如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。</li>
</ul>
<h6 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h6><ul>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record.</li>
<li>如果Lock Record的Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的 Mark Word不为nul，则利用CAS指令将对象头的mark word恢复成为无锁状态。如果失败则膨胀为重量级锁。</li>
</ul>
<h6 id="偏向锁性能比轻量级锁好"><a href="#偏向锁性能比轻量级锁好" class="headerlink" title="偏向锁性能比轻量级锁好"></a>偏向锁<del>性能比轻量级锁好</del></h6><ul>
<li>轻量级锁在没有竞争时(就自己这个线程)每次重入仍然需要执行 CAS 操作。</li>
<li>Java6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d930bb7ad0d897e72b69faa5bb15fa1f387b728a/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%5B%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%5D%E2%80%94%E8%BF%9B%E9%98%B6%E7%AF%87.png"></p>
<h4 id="你谈谈JMM-Java内存模型"><a href="#你谈谈JMM-Java内存模型" class="headerlink" title="你谈谈JMM (Java内存模型)"></a><span style = "color:red"><strong>你谈谈JMM (Java内存模型)</strong></span></h4><h6 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h6><ul>
<li>JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块，一块是私有线程的工作区域(工作内存)，一块是所有线程的共享区域(主内存)</li>
<li>线程跟线程之间是相互隔离，线程跟线程相互需要通过主内存</li>
</ul>
<p><span style = "color:red"><strong>CAS你知道吗？</strong></span><del>乐观锁</del></p>
<blockquote>
<ul>
<li>CAS全称是：Compare And Swap(比较再交换)，它体现的一种无锁（<strong>乐观锁</strong>）的思想，在无锁情况下保证线程操作共享数据的原子性。</li>
<li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li>
<li>在操作共享变量的时候使用自旋锁，效率上更高一些</li>
<li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li>
</ul>
<p>比较内存值是否与预期值相等，如果相等则更新为新值；否则不做操作，重新尝试（一般配合自旋）</p>
<pre><code class="java">// 伪代码
if (value == expectedValue) &#123;
  value = newValue;
&#125;
</code></pre>
<h3 id="💡-应用场景："><a href="#💡-应用场景：" class="headerlink" title="💡 应用场景："></a>💡 应用场景：</h3><ul>
<li><code>java.util.concurrent.atomic</code> 包下的 <code>AtomicInteger</code> 等</li>
<li><code>ReentrantLock</code> 的底层 AQS</li>
<li><code>ConcurrentHashMap</code> 局部并发控制</li>
</ul>
</blockquote>
<p>在JUC(java.util.concurrent)包下实现的很多类都用到了CAS操作</p>
<ul>
<li>AbstractQueuedSynchronizer (AQS框架)</li>
<li>AtomicXXX类</li>
</ul>
<p><span style = "color:red"><strong>乐观锁和悲观锁的区别？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ed89cde4cab6a88d6f2a86f3430be2b28a5e3626/JMM%20(Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)+CAS.png"></p>
<h4 id="乐观锁-vs-悲观锁（对比表）"><a href="#乐观锁-vs-悲观锁（对比表）" class="headerlink" title="乐观锁 vs 悲观锁（对比表）"></a>乐观锁 vs 悲观锁（对比表）</h4><table>
<thead>
<tr>
<th>特性</th>
<th>乐观锁（CAS）</th>
<th>悲观锁（synchronized&#x2F;Lock）</th>
</tr>
</thead>
<tbody><tr>
<td>思想</td>
<td>默认不会冲突，失败后重试</td>
<td>默认可能冲突，先加锁</td>
</tr>
<tr>
<td>开销</td>
<td>CPU 开销高（自旋）</td>
<td>上下文切换成本高</td>
</tr>
<tr>
<td>性能</td>
<td>高并发下优于悲观锁</td>
<td>并发低时更稳定</td>
</tr>
<tr>
<td>实现方式</td>
<td>CAS，自旋锁，版本号控制</td>
<td>synchronized, ReentrantLock等</td>
</tr>
</tbody></table>
<p><span style = "color:red"><strong>谈一谈你对volatile的理解？</strong></span><del>轻量级的同步机制</del></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li><h5 id="保证线程间的可见性"><a href="#保证线程间的可见性" class="headerlink" title="保证线程间的可见性"></a>保证线程间的可见性</h5><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
<blockquote>
<p>当一个线程修改了被 <code>volatile</code> 修饰的变量，<strong>新值会立即同步到主内存中</strong>，其他线程读取这个变量时也会<strong>立即从主内存中刷新</strong>，而不是使用线程工作内存中的旧副本。</p>
<ul>
<li>✅ <strong>保证多个线程看到的是同一个值</strong></li>
<li>❌ 但是 <strong>不能保证原子性</strong></li>
</ul>
</blockquote>
</li>
<li><h5 id="禁止进行指令重排序"><a href="#禁止进行指令重排序" class="headerlink" title="禁止进行指令重排序"></a>禁止进行指令重排序</h5><p>用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
<blockquote>
<ul>
<li><p>Java 编译器 &amp; CPU <u>为了提高性能可能会对指令进行优化</u>，造成<strong>代码执行顺序</strong>与<strong>书写顺序</strong>不一致。</p>
</li>
<li><p><code>volatile</code> 能在变量读写操作前插入内存屏障（Memory Barrier）：</p>
<ul>
<li><p>写屏障：防止写操作后面的指令重排到前面</p>
</li>
<li><p>读屏障：防止读操作前面的指令被排到后面</p>
</li>
</ul>
</li>
</ul>
<h5 id="JMM-是理论模型，volatile-是其具体体现。"><a href="#JMM-是理论模型，volatile-是其具体体现。" class="headerlink" title="JMM 是理论模型，volatile 是其具体体现。"></a>JMM 是理论模型，<code>volatile</code> 是其具体体现。</h5><blockquote>
<p>🔄 <code>volatile</code> 是 JMM（Java内存模型）在语义上的一个重要实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th>JMM 内容</th>
<th><code>volatile</code> 实现作用</th>
</tr>
</thead>
<tbody><tr>
<td>主内存 &amp; 工作内存</td>
<td>强制将值立即刷新到主内存</td>
</tr>
<tr>
<td>可见性保证</td>
<td>✅ volatile 提供</td>
</tr>
<tr>
<td>原子性保证</td>
<td>❌ volatile 不提供</td>
</tr>
<tr>
<td>禁止指令重排</td>
<td>✅ volatile 提供（内存屏障）</td>
</tr>
</tbody></table>
<h5 id="这几个进行一下比较"><a href="#这几个进行一下比较" class="headerlink" title="这几个进行一下比较"></a>这几个进行一下比较</h5><table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code> &#x2F; <code>Lock</code></th>
<th>CAS (<code>AtomicXXX</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>原子性</td>
<td>❌</td>
<td>✅</td>
<td>✅（通过硬件指令）</td>
</tr>
<tr>
<td>重排序控制</td>
<td>✅（内存屏障）</td>
<td>✅（通过锁的语义）</td>
<td>✅（内存屏障）</td>
</tr>
<tr>
<td>是否加锁</td>
<td>否，轻量，性能高</td>
<td>是，重量级，性能相对低</td>
<td>否，自旋CAS</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标志、单例双检锁等</td>
<td>临界区互斥、大块同步场景</td>
<td>高并发下原子计数&#x2F;计量等操作</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ce52eb544e19cacdc7c7d22cb6fa3135b27e6a3/volatile%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%90%86%E8%A7%A3[%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81+%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F].png"></p>
<p><span style = "color:red"><strong>什么是AQS？</strong></span></p>
<blockquote>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个**<u>先进先出的双向队列</u>**，队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无所状态)，如果队列中有一个线程修改成功了state为1，则当前线程就相当于获取了资源。</li>
<li>在对state修改的时候使用<strong>CAS</strong>(compare and swap)操作，保证多个线程修改的情况下<strong>原子性</strong></li>
</ul>
</blockquote>
<p>AQS(<strong>A</strong>bstract<strong>Q</strong>ueued<strong>S</strong>ynchronizer)，即抽象队列同步器。它是构建锁或者其他同步组件的<strong>基础框架</strong></p>
<h6 id="AQS与Synchronized的区别"><a href="#AQS与Synchronized的区别" class="headerlink" title="AQS与Synchronized的区别"></a>AQS与Synchronized的区别</h6><table>
<thead>
<tr>
<th align="center">AQS</th>
<th align="center">synchronized</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java语言实现</td>
<td align="center">关键字，C++语言实现</td>
</tr>
<tr>
<td align="center">悲观锁，手动开启和关闭</td>
<td align="center">悲观锁，自动释放锁</td>
</tr>
<tr>
<td align="center">锁竞争激烈的情况下，提供了多种解决方案</td>
<td align="center">锁竞争激励都会升级为<strong>重量级锁</strong>，性能差</td>
</tr>
</tbody></table>
<blockquote>
<h4 id="CAS和AQS的区别"><a href="#CAS和AQS的区别" class="headerlink" title="CAS和AQS的区别"></a>CAS和AQS的区别</h4><p><strong>CAS(Compare And Swap)</strong><del>乐观锁</del>：一种<strong>无锁的原子操作机制</strong>，用于实现<strong>数据层面的原子性</strong>，是底层原语。</p>
<p><strong>AQS(AbstractQueuedSynchronizer)</strong><del>悲观锁</del>：一种<strong>同步器框架</strong>，用于构建<strong>锁和同步器</strong>（如 ReentrantLock、Semaphore 等），是结构设计。</p>
<h4 id="表格对比：CAS-vs-AQS"><a href="#表格对比：CAS-vs-AQS" class="headerlink" title="表格对比：CAS vs AQS"></a>表格对比：CAS vs AQS</h4><table>
<thead>
<tr>
<th>对比点</th>
<th>CAS</th>
<th>AQS</th>
</tr>
</thead>
<tbody><tr>
<td>全称</td>
<td>Compare And Swap</td>
<td>AbstractQueuedSynchronizer</td>
</tr>
<tr>
<td>概念类型</td>
<td>原子操作机制（CPU指令级别）</td>
<td>同步器框架（Java并发包核心）</td>
</tr>
<tr>
<td>功能目的</td>
<td>保证<strong>共享变量原子性更新</strong></td>
<td>实现<strong>线程同步控制</strong>（排队、阻塞、唤醒等）</td>
</tr>
<tr>
<td>属于哪一层</td>
<td>底层原子操作</td>
<td>高层并发框架</td>
</tr>
<tr>
<td>是否加锁</td>
<td>否（无锁）</td>
<td>是（加锁或排队等待）</td>
</tr>
<tr>
<td>底层依赖</td>
<td>CPU的 CAS 指令（如 <code>cmpxchg</code>）</td>
<td>CAS、LockSupport、队列、模板方法</td>
</tr>
<tr>
<td>应用场景</td>
<td>AtomicXXX、线程安全计数器、乐观锁等</td>
<td>ReentrantLock、Semaphore、CountDownLatch、FutureTask 等</td>
</tr>
<tr>
<td>是否自带阻塞&#x2F;唤醒</td>
<td>❌ 不具备阻塞机制</td>
<td>✅ 自带阻塞&#x2F;唤醒机制（如 condition.await&#x2F;signal）</td>
</tr>
<tr>
<td>实现原理</td>
<td>通过比较内存值 + 原子更新</td>
<td>模板方法 + 状态位 state + FIFO 等待队列</td>
</tr>
<tr>
<td>失败机制</td>
<td>自旋重试（乐观锁）</td>
<td>阻塞挂起，进入等待队列</td>
</tr>
</tbody></table>
<h4 id="各自常见应用场景"><a href="#各自常见应用场景" class="headerlink" title="各自常见应用场景"></a>各自常见应用场景</h4><table>
<thead>
<tr>
<th>场景</th>
<th>用的是谁？</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>实现原子操作</td>
<td>CAS</td>
<td><code>AtomicInteger.incrementAndGet()</code></td>
</tr>
<tr>
<td>实现线程排队获取锁</td>
<td>AQS</td>
<td><code>ReentrantLock.lock()</code></td>
</tr>
<tr>
<td>信号量控制</td>
<td>AQS</td>
<td><code>Semaphore.acquire()</code></td>
</tr>
<tr>
<td>倒计时器</td>
<td>AQS</td>
<td><code>CountDownLatch.await()</code></td>
</tr>
<tr>
<td>实现 Future 机制</td>
<td>AQS</td>
<td><code>FutureTask.run()</code></td>
</tr>
<tr>
<td>高并发无锁计数器</td>
<td>CAS</td>
<td><code>LongAdder.add()</code>（改进版</td>
</tr>
</tbody></table>
<p><strong>CAS 是 AQS 的底层基础</strong>之一：AQS 内部更新同步状态（<code>state</code>）时就用的是 CAS。<br><strong>AQS 是基于 CAS + FIFO 队列实现的线程同步框架</strong>，比 CAS 更复杂、能力更强。</p>
<pre><code class="java">// AQS 内部设置状态的关键方法
protected final boolean compareAndSetState(int expect, int update) &#123;
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update); // 使用CAS
&#125;
</code></pre>
<h4 id="举个例子：ReentrantLock"><a href="#举个例子：ReentrantLock" class="headerlink" title="举个例子：ReentrantLock"></a>举个例子：ReentrantLock</h4><pre><code class="java">lock.lock();
</code></pre>
<ul>
<li><strong>内部结构：</strong><ul>
<li>使用 <strong>AQS 实现公平&#x2F;非公平锁的排队机制</strong></li>
<li>使用 <strong>CAS 来设置 state &#x3D; 1（加锁）</strong></li>
</ul>
</li>
</ul>
<p>CAS 是一种基于硬件的原子操作指令，用于在无锁环境下保证共享变量的线程安全，常用于 <code>AtomicInteger</code> 等类。而 AQS 是 Java 并发包中用于构建同步器（如锁、信号量等）的框架，它通过 CAS 操作来维护内部状态 <code>state</code>，并通过一个基于 FIFO 的等待队列来实现线程的阻塞与唤醒。因此，<strong>CAS 是底层原语，而 AQS 是上层的并发框架，AQS 内部正是基于 CAS 实现的</strong>。</p>
</blockquote>
<h6 id="AQS常见的实现类"><a href="#AQS常见的实现类" class="headerlink" title="AQS常见的实现类"></a>AQS常见的实现类</h6><ul>
<li><strong>ReentrantLock 阻塞式锁</strong></li>
<li>Semaphore 信号量</li>
<li>CountDownLatch 倒计时锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dd56a7110e36eebc67c093ce454bd7052a1ad30/%E4%BB%80%E4%B9%88%E6%98%AFAQS.png"></p>
<p><span style = "color:red"><strong>ReentrantLock [rɪ’entrənt]lock 的实现原理？</strong></span><del>[关联HashMap线程不安全需加锁(synchronized或ReentrantLock)]</del></p>
<blockquote>
<p>ReentrantLock主要利用<strong>CAS+AQS队列</strong><del>CompareAndSwap+AbstractQueuedSynchronized</del>来实现。**<u>它支持公平锁和非公平锁</u><strong>，两者的实现类似构造方法接受一个可选的公平参数(<strong>默认非公平锁</strong>)，</strong><u>当设置为true时，表示公平锁，否则为非公平锁</u>**。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p>
</blockquote>
<p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p>
<ul>
<li>可中断<del>synchronized不可中断</del></li>
<li>可设置超时时间<del>没有获得锁时只能进入等待</del>[<u>没有获取锁可以放弃锁</u>]</li>
<li>可以设置公平锁<del>synchronized只有非公平锁</del>[也支持非公平锁]</li>
<li>支持多个条件变量</li>
<li>与synchronized一样，都支持重入</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9279a890a6163298e551a9f594f3c0b921a438ad/ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>synchronized和Lock有什么区别？</strong></span></p>
<ul>
<li><strong>语法层面</strong></li>
</ul>
<p><strong>synchronized是关键字</strong>，源码在jvm中，用<strong>c++<strong>语言实现<br><strong>Lock是接口</strong>，源码由jdk提供，用</strong>java</strong>语言实现<br>使用synchronized时，退出同步代码块锁会<strong>自动释放</strong>，而使用Lock时，需要<strong>手动</strong>调用unlock方法<strong>释放锁</strong></p>
<ul>
<li><strong>功能层面</strong></li>
</ul>
<p><strong>二者均属于悲观锁</strong>、都具备基本的互斥、同步、锁重入功能<br>Lock提供了许多synchronized不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong><br>Lock有适合不同场景的实现，如ReentrantLock、ReentrantReadWeiteLock(读写锁)</p>
<p><span style = "color:red"><strong>死锁产生的条件是什么</strong></span></p>
<p><strong>死锁</strong>：一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<h6 id="如何进行死锁诊断-？"><a href="#如何进行死锁诊断-？" class="headerlink" title="如何进行死锁诊断 ？"></a>如何进行死锁诊断 ？</h6><p>当程序出现了死锁现象，我们可以使用jdk自带的工具：<strong>jps</strong>和<strong>jstack</strong></p>
<ul>
<li><strong>jps</strong>：输出JVM中运行的<strong>进程状态</strong>信息</li>
<li><strong>jstack</strong>：查看java进程内<strong>线程的堆栈</strong>信息</li>
</ul>
<p>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack -l &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h6 id="其他解决工具，可视化工具"><a href="#其他解决工具，可视化工具" class="headerlink" title="其他解决工具，可视化工具"></a>其他解决工具，可视化工具</h6><ul>
<li><strong>jconsole</strong></li>
</ul>
<p>用于对jvm的 <u>内存，线程，类</u>  的监控，是一个基于jmx的GUI性能监控工具<br>打开方式：java安装目录 bin目录下 直接启动 <code>jconsole.exe</code>就行</p>
<ul>
<li><strong>VisualVM</strong>：故障处理工具</li>
</ul>
<p>能够监控线程，内存情况，查看方法的cpu时间和内存中的对象，已被GC的对象，反向查看分配的堆栈<br>打开方式：java安装目录 bin目录下 直接启动 <code>jvisualvm.exe</code>就行</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e76fa529b0f5ed6e555f615f22b4ad646e02f0d6/%E6%AD%BB%E9%94%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"><a href="#在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法：银行家算法可以避免死锁"></a>在实际操作中，以下是一些打破死锁的具体方法：<del>银行家算法可以避免死锁</del></h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<p><span style = "color:red"><strong>聊一下ConcurrentHashMap</strong></span></p>
<p><code>ConcurrentHashMap</code>是一种线程安全的高效Map集合<br><strong>底层数据结构</strong>：</p>
<ul>
<li><p>JDK1.7底层采用分段的数组+链表实现</p>
</li>
<li><p>JDK1.8采用的数数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</p>
<p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：<code>数组+红黑树+链表</code>，采用CAS + Synchronized来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升</li>
</ul>
</li>
</ul>
<p><strong>加锁的方式</strong>：</p>
<ul>
<li>JDK1.7采用<code>Segment</code>分段锁，底层使用的是<code>ReentrantLock</code></li>
<li>JDK1.8采用<code>CAS</code><del>自旋锁</del>添加新节点，采用<code>synchronized</code>锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</li>
</ul>
<blockquote>
<p>在 <strong>JDK1.7</strong> 的 <code>ConcurrentHashMap</code> 实现中：</p>
<ul>
<li><code>ConcurrentHashMap</code> 底层被分成了多个 <strong>Segment</strong>（段）。</li>
<li>每个 Segment 本质上就是一个小型的 HashMap + 一把锁（<code>ReentrantLock</code>）。</li>
<li>整个 Map 是由多个 Segment 组成的数组：<code>Segment&lt;K, V&gt;[] segments;</code></li>
<li>每个 Segment 管理自己那部分的数据，<strong>互不干扰</strong>，从而实现高并发。</li>
</ul>
<p><strong>提高并发性，减小锁竞争：</strong></p>
<ul>
<li>将一个大的 <strong>HashMap</strong> 拆成多个 Segment（默认16个），每个 Segment 单独加锁。</li>
<li>这样多个线程并发访问不同 Segment 的数据时，就不会互相阻塞，从而提升性能。</li>
<li>线程只会锁定自己需要访问的那个 Segment，不会锁全表。</li>
</ul>
<h5 id="【下列图中针对于整体和put的解释】"><a href="#【下列图中针对于整体和put的解释】" class="headerlink" title="【下列图中针对于整体和put的解释】"></a>【下列图中针对于整体和put的解释】</h5><h3 id="📌-1-整体结构"><a href="#📌-1-整体结构" class="headerlink" title="📌 1. 整体结构"></a>📌 1. 整体结构</h3><ul>
<li>外部是一个 <strong>Segment 数组</strong>：每个 Segment 是独立加锁的。</li>
<li>每个 Segment 内部又是一个 HashEntry 数组（就像 HashMap 的结构）。</li>
</ul>
<h3 id="📌-2-put-操作流程（以-JDK1-7-为例）："><a href="#📌-2-put-操作流程（以-JDK1-7-为例）：" class="headerlink" title="📌 2. put 操作流程（以 JDK1.7 为例）："></a>📌 2. put 操作流程（以 JDK1.7 为例）：</h3><ol>
<li>根据 key 的 hash 计算出 Segment 的<strong>下标</strong>（如 Segment[5]）。</li>
<li>进入对应的 Segment，获<strong>取其锁</strong>（<code>ReentrantLock.lock()</code>）。</li>
<li>再在该 Segment 中，查找对应的<strong>桶位</strong>（HashEntry 数组）。</li>
<li>找到位置后：<ul>
<li>如果该位置已有数据，做链表遍历、替换或追加。</li>
<li>如果链表过长，在 JDK1.7 仍然是链表（没有红黑树）。</li>
</ul>
</li>
<li>插入完成后释放锁。</li>
</ol>
<h5 id="✅-JDK1-8-为什么放弃-Segment？"><a href="#✅-JDK1-8-为什么放弃-Segment？" class="headerlink" title="✅ JDK1.8 为什么放弃 Segment？"></a>✅ JDK1.8 为什么放弃 Segment？</h5><p>JDK1.8 里，<strong>取消了 Segment 分段锁结构，改为节点粒度的同步控制</strong>：</p>
<ul>
<li>使用 <strong>CAS + synchronized</strong> 替代了 Segment + ReentrantLock。</li>
<li>好处：<ul>
<li>不再有 Segment 的内存占用与操作复杂度。</li>
<li>粒度更细，性能更好。</li>
<li>数据结构与 HashMap 接轨，统一维护。</li>
</ul>
</li>
</ul>
<p>在 JDK1.7 中，<code>ConcurrentHashMap</code> 使用 <strong>Segment 分段锁机制</strong> 提高并发性能，将 Map 拆成多个小的 Segment，每个 Segment 内部结构类似 HashMap，通过加锁控制并发。而在 JDK1.8 中，放弃 Segment，采用 <strong>CAS + synchronized 锁节点的方式</strong>，结构变为数组 + 链表 + 红黑树，性能与简洁性双双提升。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/fc8e6e126e8fff5692b8c53102ac3237b913310d/%E8%81%8A%E4%B8%80%E8%81%8AConcurrentHashMap.png"></p>
<h4 id="导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全"><a href="#导致并发程序出现问题的根本原因是什么-Java程序中怎么保证多线程的执行安全" class="headerlink" title="导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)"></a><span style = "color:red"><strong>导致并发程序出现问题的根本原因是什么 (Java程序中怎么保证多线程的执行安全)</strong></span></h4><h6 id="Java并发编程三大特性"><a href="#Java并发编程三大特性" class="headerlink" title="Java并发编程三大特性"></a>Java并发编程三大特性</h6><ul>
<li><span style = "color:blue"><strong>原子性<del>synchronized、lock</del></strong></span>：一个线程在CPU中操作不可暂停，也不可中断，要么执行完成，要么不执行</li>
</ul>
<pre><code class="java">int ticketNum = 10;
public void getTicket()&#123;
    if(ticketNum &lt;= 0)&#123;
        return;
    &#125;
    sout(Thread.currentThread().getName() + &quot;抢到一张票，剩余：&quot; + ticketNum);
    // 非原子性操作
    ticketNum--;
&#125;
main&#123;
    TicketDemo demo = new TicketDemo();
    for(int i = 0; i &lt; 20; i++)&#123;
        new Thread(demo::getTicket).start();
    &#125;
&#125;
</code></pre>
<h6 id="不是原子操作，怎么保证原子操作呢？"><a href="#不是原子操作，怎么保证原子操作呢？" class="headerlink" title="不是原子操作，怎么保证原子操作呢？"></a>不是原子操作，怎么保证原子操作呢？</h6><ol>
<li>synchronized：同步加锁</li>
<li>JUC里面的lock：加锁</li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4fd1c205a0d2d906c28c4a924b883b4082605a78/Synchronized%E4%B8%8ELock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png"></p>
<ul>
<li><strong><span style = "color:blue">可见性<del>volatile、synchronized、lock</del></span></strong></li>
</ul>
<h6 id="内存可见性：让一个线程对共享变量的修改对另一个线程可见"><a href="#内存可见性：让一个线程对共享变量的修改对另一个线程可见" class="headerlink" title="内存可见性：让一个线程对共享变量的修改对另一个线程可见"></a>内存可见性：让一个线程对共享变量的修改对另一个线程可见</h6><pre><code class="java">public class VolatileDemo&#123;
    private static boolean flag = false;
    public static void main(String[] args) throws InterruptedException&#123;
        new Thread(()-&gt;&#123;
            while(!flag)&#123;
                sout(&quot;第一个线程执行完毕...&quot;);
            &#125;
        &#125;).start();
        Thread.sleep(100);
        new Thread(()-&gt;&#123;
            flag = true;
            sout(&quot;第二个线程执行完毕...&quot;);
        &#125;).start();
    &#125;
&#125;
</code></pre>
<p><strong>解决方案：synchronized、<u>volatile</u>、LOCK</strong> </p>
<p>volatile：加在共享变量上面即可 →  private static <strong>volatile</strong> boolean flag &#x3D; false;</p>
<ul>
<li><strong><span style = "color:blue">有序性<del>volatile</del></span></strong></li>
</ul>
<p><strong>指令重排</strong>：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p>
<pre><code class="java">int x;
int y;
@Actor
public void actor1()&#123;
    x = 1;
    y = 1;
&#125;
@Actor
public void actor2(II_Result r)&#123;
    r.r1 = y;
    r.r2 = x;
&#125;
</code></pre>
<p><strong>解决办法</strong>：在前面加上<code>volatile</code></p>
<p><span style = "color:red"><strong>说一下线程池的核心参数</strong></span></p>
<p>为什么要创建线程池 因为每次创建线程的时候就要占用一定的内存空间 无限创建线程会浪费内存<del>严重会导致内存溢出</del><br>CPU有限的同一时刻只能同时处理一个线程 大量线程来的话就没有线程权 会造成线程等待 造成大量线程在之间切换也会导致性能变慢</p>
<pre><code class="java">在这个例子中，我们创建了一个线程池，核心线程数为5，最大线程数为10，如果线程池中的线程数大于核心线程数，则空闲线程在60秒后会被终止。工作队列使用ArrayBlockingQueue，其容量为100。

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExample &#123;
    public static void main(String[] args) &#123;
        // 核心线程数
        int corePoolSize = 5;
        // 最大线程数 = （核心线程 + 救急线程的最大数目）
        int maximumPoolSize = 10;
        // 线程池中超过 corePoolSize 数量的空闲线程最大存活时间
        long keepAliveTime = 60L;
        // 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
        TimeUnit unit = TimeUnit.SECONDS;
        // 工作队列，用于存放提交的任务 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
        ArrayBlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;&gt;(100);
        // 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
        ThreadFactory threadFactory = new ThreadFactory;
        // 拒绝策略 - 当所有线程都繁忙，workQueue也繁忙时，会触发拒绝策略
        RejectedExecutionHandler handler = new RejectedExecutionHandler;
        
        // 创建线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSize,
                maximumPoolSize,
                keepAliveTime,
                unit,
                workQueue
        );

        // 示例：向线程池提交任务  threadPoolExecutor.submit()/.execute()
        for (int i = 0; i &lt; 20; i++) &#123;
            int taskNumber = i;
            threadPoolExecutor.execute(() -&gt; &#123;
                System.out.println(&quot;Executing task &quot; + taskNumber);
                // 模拟任务执行时间
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;

        // 关闭线程池
        threadPoolExecutor.shutdown();
    &#125;
&#125;
</code></pre>
<p>一开始new的时候没有是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<h6 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h6><ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><span style = "color:red"><strong>线程池中有哪些常见的阻塞队列</strong></span></p>
<p><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>workQueue - 阻塞队列常用的队列</u>：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
<li>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中时间最靠前的</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ArrayBlockingQueue</th>
<th align="center"><span style = "color:red">LinkedBlockingQueue<del>不给值默认最大值</del></span></th>
</tr>
</thead>
<tbody><tr>
<td align="center">强制有界</td>
<td align="center">默认无界，支持有界</td>
</tr>
<tr>
<td align="center">底层是数组</td>
<td align="center">底层是链表</td>
</tr>
<tr>
<td align="center">提前初始化Node数组</td>
<td align="center">是懒惰的，创建节点的时候添加数据</td>
</tr>
<tr>
<td align="center">Node需要是提前创建好的</td>
<td align="center">入队会生成新Node</td>
</tr>
<tr>
<td align="center">一把锁</td>
<td align="center">两把锁(头尾)<del>可以一边入队,一边出队</del></td>
</tr>
</tbody></table>
<blockquote>
<h4 id="ArrayBlockingQueue（数组有界队列）"><a href="#ArrayBlockingQueue（数组有界队列）" class="headerlink" title="ArrayBlockingQueue（数组有界队列）"></a><strong>ArrayBlockingQueue（数组有界队列）</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>有界队列（必须指定容量）</td>
</tr>
<tr>
<td>底层结构</td>
<td>数组（先进先出 FIFO）</td>
</tr>
<tr>
<td>线程安全</td>
<td>内部使用一把锁（ReentrantLock）实现</td>
</tr>
<tr>
<td>性能</td>
<td>读写快，结构稳定</td>
</tr>
<tr>
<td>应用场景</td>
<td>可以<strong>准确预估任务数量</strong>的场景，推荐用于<strong>生产环境</strong>保障系统稳定</td>
</tr>
<tr>
<td>特点</td>
<td>不支持扩容，满了会阻塞或抛异常</td>
</tr>
</tbody></table>
<p>✅ <strong>适用于：生产环境中任务量可控，保证内存稳定，不希望触发OOM。</strong></p>
<h4 id="LinkedBlockingQueue（链表无界队列）"><a href="#LinkedBlockingQueue（链表无界队列）" class="headerlink" title="LinkedBlockingQueue（链表无界队列）"></a><strong>LinkedBlockingQueue（链表无界队列）</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>默认无界队列（最大为 Integer.MAX_VALUE，可设置为有界）</td>
</tr>
<tr>
<td>底层结构</td>
<td>链表（FIFO）</td>
</tr>
<tr>
<td>线程安全</td>
<td>使用两把锁（put锁 + take锁），可以同时入队出队</td>
</tr>
<tr>
<td>性能</td>
<td>插入删除性能好，随机访问性能差（O(n)）</td>
</tr>
<tr>
<td>应用场景</td>
<td>任务流量大、不可预估任务量的场景</td>
</tr>
<tr>
<td>特点</td>
<td>不容易触发拒绝策略，但容易造成内存溢出（OOM）</td>
</tr>
</tbody></table>
<p>✅ <strong>适用于：高并发日志、事件处理等消费速度快但生产不确定的情况。</strong></p>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>有界性</th>
<th>底层结构</th>
<th>锁机制</th>
<th>特点描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>有界</td>
<td>数组</td>
<td>一把锁</td>
<td>性能稳定，适合任务量可控场景</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>默认无界</td>
<td>链表</td>
<td>两把锁（头尾）</td>
<td>插入删除效率高，容易堆积任务造成内存压力</td>
</tr>
</tbody></table>
<h4 id="线程池中选择哪个阻塞队列？"><a href="#线程池中选择哪个阻塞队列？" class="headerlink" title="线程池中选择哪个阻塞队列？"></a>线程池中选择哪个阻塞队列？</h4><table>
<thead>
<tr>
<th>使用场景</th>
<th>推荐队列类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>普通后台异步任务</td>
<td><code>ArrayBlockingQueue</code></td>
<td>稳定、安全，可预估任务量</td>
</tr>
<tr>
<td>高并发任务，消费快但产量不可控</td>
<td><code>LinkedBlockingQueue</code></td>
<td>适合吞吐量大场景，注意内存风险</td>
</tr>
</tbody></table>
<h4 id="守护线程补充"><a href="#守护线程补充" class="headerlink" title="守护线程补充"></a>守护线程补充</h4><p>你提到的这段也非常好，总结如下：</p>
<ul>
<li><strong>守护线程（daemon）</strong>：依附主线程存在，主线程结束，守护线程也自动终止。如：GC线程。</li>
<li><strong>非守护线程（user thread）</strong>：默认类型，主线程结束后仍会继续运行。</li>
</ul>
<p>可通过：</p>
<pre><code class="java">Thread thread = new Thread(...);
thread.setDaemon(true); // 设置为守护线程
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>如何确定核心线程数</strong></span></p>
<blockquote>
<p>① 高并发、任务执行时间短 → (CPU核数 + 1)，减少线程上下文的切换<br>② 并发不高、任务执行时间长</p>
<ul>
<li><strong>IO密集型任务 → (CPU核数 * 2 + 1)</strong></li>
<li>计算密集型任务 → (CPU核数 + 1)</li>
</ul>
<p>③ <strong>并发高、业务执行时间长</strong>，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置参考②</p>
</blockquote>
<ul>
<li>IO密集型任务：文件读写、DB读写、网络请求等                            <span style = "color:blue"><strong>核心线程数大小设置为2N+1</strong></span></li>
<li>CPU密集型任务：计算型代码、Bitmap转换、Gson转换等            <span style = "color:blue"><strong>核心线程数大小设置为N+1</strong></span></li>
</ul>
<pre><code class="java">// 查看机器的CPU核数
public static void main(String[] args)&#123;
    // 查看机器的CPU核数
    System.out.println(Runtime.getRuntime().avaliableProcessors());
&#125;
</code></pre>
<p><span style = "color:red"><strong>线程池的种类有哪些</strong></span></p>
<p>在<code>java.util.concurrent.Executors</code>类中提供了大量创建线程池的静态方法，常见的有四种</p>
<h6 id="①-创建使用固定线程数的线程池"><a href="#①-创建使用固定线程数的线程池" class="headerlink" title="① 创建使用固定线程数的线程池"></a>① 创建使用固定线程数的线程池</h6><p><span style = "color:blue">适用于任务已知，相对耗时的任务</span></p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads)&#123;
    return new ThreadPoolExecutor(nThreads, nThreads,0L,TimeUnit.MILLISECONDS.new LinkedBlockingQueue&lt;Runnable&gt;)
&#125;
</code></pre>
<ul>
<li>核心线程数与最大线程数一样，没有<code>救急线程 = 最大线程数 - 核心线程数</code></li>
<li>阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE</li>
</ul>
<h6 id="②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出"><a href="#②-单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序-FIFO-执行→-先进先出" class="headerlink" title="② 单线程化的线程池它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]"></a>② 单线程化的线程池<del>它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO)执行→[先进先出]</del></h6><p><span style = "color:blue">适用于按照顺序执行的任务</span></p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor()&#123;
    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
</code></pre>
<ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>，最大容量为<code>Integer.MAX_VALUE</code></li>
</ul>
<h6 id="③-可缓存线程池"><a href="#③-可缓存线程池" class="headerlink" title="③ 可缓存线程池"></a>③ 可缓存线程池</h6><pre><code class="java">public static ExecutorService newCachedThreadPool()&#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<ul>
<li>核心线程数为0</li>
<li>最大线程数是<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列是<code>SynchronousQueue</code>: 不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作</li>
</ul>
<h6 id="④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor"><a href="#④-提供了-延迟-和-周期执行-功能的ThreadPoolExecutor" class="headerlink" title="④ 提供了 延迟 和 周期执行 功能的ThreadPoolExecutor"></a>④ 提供了 <code>延迟</code> 和 <code>周期执行</code> 功能的ThreadPoolExecutor</h6><pre><code class="java">public ScheduledThreadPoolExecutor(int corePoolSize)&#123;
    super(corePoolSize, Integer.MAX_VALUE,0,NANOSECONDS,new DelayedWorkQueue());
&#125;
</code></pre>
<p><span style = "color:red"><strong>为什么不建议使用Executors创建线程池？</strong></span></p>
<p>参考阿里开发手册</p>
<pre><code class="java">【强制】 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
说明：Executors返回的线程池对象的弊端如下：
1. FixedThreadPool 和 SingleThreadPool：
允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求，从而导致OOM
2. CachedThreadPool：
允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM
    
    
在实际开发中，不建议使用 Executors 创建线程池，因为其底层默认参数具有潜在的 OOM 风险。例如 FixedThreadPool 使用无界队列、CachedThreadPool 最大线程数为 Integer.MAX_VALUE，容易在高并发场景下造成内存溢出。因此建议通过 ThreadPoolExecutor 显式指定核心参数，做到资源可控，避免系统风险。
</code></pre>
<p><span style = "color:red"><strong>线程池的使用场景①：ES数据批量导入</strong></span></p>
<h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><p>CountDownLatch(闭锁&#x2F;倒计时锁)用来进行线程同步协作，等待所有线程完成倒计时时(一个或多个线程，等待其他多个线程完成某件事情之后才能执行)</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li><code>await()</code>用来等待计数归零</li>
<li><code>countDown()</code>用来让计数减一</li>
</ul>
<h6 id="多线程使用场景一-es数据批量导入"><a href="#多线程使用场景一-es数据批量导入" class="headerlink" title="多线程使用场景一 (es数据批量导入)"></a>多线程使用场景一 (es数据批量导入)</h6><p>在我们项目上线之前，我们需要把数据库中的数据一次性的同步到es索引库中，但是当时的数据好像是1000万左右一次性读取数据肯定不行(oom异常)，当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制就能避免一次性加载过多，防止内存溢出</p>
<blockquote>
<p>在我们项目中，曾有一次需要把MySQL中的一千万条历史文章同步到ES。为了避免一次性加载引发OOM，我将数据分页为每页2000条，使用线程池批量提交导入任务，同时使用 <code>CountDownLatch</code> 控制主线程阻塞等待所有子任务完成，再统一执行收尾逻辑。这样做极大优化了内存占用和同步效率。</p>
</blockquote>
<p>DB(一千万) → 线程池(CountDownLatch) → Elasticearch</p>
<pre><code class="java">       批量导入  →  查询总条数   →       DB
                      ↓               ↑          批量导入到ES中     →   ES
(固定每页2000条)        计算总页数            ↑  (countDownLatch.countDown())
                        ↓               ↑                ↑
(总页数)         CountDownLatch        ↑                ↑
                        ↓               ↑                ↑
                分页查询文章数据 → [查询当前页的文章 → 创建任务批量导入ES → 提交到线程池执行]循环
                                             (文章列表, countDownLatch)
                                                          ↓
                                                countDownLatch.await()
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a8e33cd1bf93eca7f789f20cee1a67770b426f68/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-CountDownLatch%E7%94%A8ES%E6%89%B9%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景②：数据汇总</strong></span></p>
<ul>
<li>在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息;这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢?<ul>
<li>在实际开发的过程中，难免需要调用多个接口来汇总数据，如果所有接口(或部分接口)的没有依赖关系，就可以使用线程池+future来提升性能<br>[<u>统计的图文发布量、点赞数量、收藏数量、评论数量若不在同一台微服务下 或者 部分没有依赖关系</u>]</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="并发数据汇总（如订单数据聚合）"><a href="#并发数据汇总（如订单数据聚合）" class="headerlink" title="并发数据汇总（如订单数据聚合）"></a><strong>并发数据汇总（如订单数据聚合）</strong></h4><blockquote>
<p>关键词：<strong>接口无依赖、加速响应、Future并发调用</strong></p>
</blockquote>
<h4 id="📌-适用场景"><a href="#📌-适用场景" class="headerlink" title="📌 适用场景"></a>📌 适用场景</h4><ul>
<li>一个接口需要聚合多个来源服务（如订单服务、商品服务、物流服务）</li>
<li>服务之间<strong>无强依赖</strong>，可并发发起请求提升响应速度</li>
</ul>
<h4 id="✅-技术点"><a href="#✅-技术点" class="headerlink" title="✅ 技术点"></a>✅ 技术点</h4><ul>
<li><code>线程池 + Future + Callable</code></li>
<li>三个子任务并发发起 → <code>.get()</code>阻塞获取返回值</li>
<li>总响应时间 ≈ 最慢的那个接口，而不是三个之和</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b9ec7c6d685bab18893fbfa3b6637c48f3384ecf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB.png"></p>
<p><span style = "color:red"><strong>线程池的使用场景③：异步调用</strong></span></p>
<p>为了避免下一级方法影响上一级方法(性能考虑)，可使用<strong>异步线程调用</strong>下一个方法(不需要下一级方法返回值)，可以提升方法相应时间</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8b9788570956b65f8073f31b82bada34a8ddb799/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png"></p>
<p><span style = "color:red"><strong>如何控制某个方法允许并发访问线程的数量</strong></span></p>
<p>Semaphore信号量，是JUC包下的一个工具类，底层是AQS，我们可以通过其限制执行的线程数量<br><strong>适用场景</strong>：<br>通常用于那些资源有明确访问数量限制的场景，常用于限流</p>
<h6 id="Semaphore使用步骤"><a href="#Semaphore使用步骤" class="headerlink" title="Semaphore使用步骤"></a>Semaphore使用步骤</h6><ul>
<li>创建Semaphore对象，可以给一个容器</li>
<li>semaphore.acquire()：请求一个信号量，这时候的信号量个数 -1 (<u>一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量</u>)</li>
<li>semaphore.release()：释放一个信号量，此时信号量个数 +1</li>
</ul>
<blockquote>
<h3 id="使用-Semaphore-信号量"><a href="#使用-Semaphore-信号量" class="headerlink" title="使用 Semaphore 信号量"></a>使用 <code>Semaphore</code> 信号量</h3><ul>
<li><code>Semaphore</code> 是 JUC 包下的并发工具类，用于<strong>控制同时访问某个资源的线程数量</strong></li>
<li>底层基于 AQS（AbstractQueuedSynchronizer）实现</li>
<li>常用于<strong>限流、并发资源控制、连接池管理、接口控制等场景</strong></li>
</ul>
<pre><code class="yaml">Semaphore 就像操作系统中的“通行证/信号灯”，只有拿到令牌（acquire）才能进入方法执行，执行完后必须释放令牌（release），否则其他线程会一直阻塞在那等令牌释放。
</code></pre>
<ul>
<li><code>new Semaphore(n)</code>：设置可同时访问的线程数量为 n</li>
<li><code>semaphore.acquire()</code>：申请令牌，获取不到则阻塞</li>
<li><code>semaphore.release()</code>：释放令牌，通知其他线程</li>
</ul>
<blockquote>
<p>Semaphore 可以限制方法的并发访问线程数，常用于限流或控制资源并发度。通过 <code>acquire()</code> 获取访问许可、<code>release()</code> 释放许可，从而确保同时最多只有固定数量的线程能访问目标方法或资源。</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76cde79a53b36086d940f2874f8aa7ffd93ce6ef/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F.png"></p>
<p><span style = "color:red"><strong>谈一谈你对ThreadLocal的理解</strong></span></p>
<p><code>ThreadLocal</code> 是 Java 提供的<strong>线程本地变量工具类</strong>，用于实现<strong>线程间的数据隔离</strong>，也可理解为线程级别的“共享变量”。</p>
<blockquote>
<h3 id="🌟-一句话总结（记住这个）"><a href="#🌟-一句话总结（记住这个）" class="headerlink" title="🌟 一句话总结（记住这个）"></a>🌟 一句话总结（记住这个）</h3><blockquote>
<p><strong>ThreadLocal 实现线程间变量隔离，让每个线程拥有一份自己的变量副本，常用于解决共享变量的线程安全问题。</strong></p>
</blockquote>
<h3 id="📌-附加：ThreadLocal-≠-线程安全"><a href="#📌-附加：ThreadLocal-≠-线程安全" class="headerlink" title="📌 附加：ThreadLocal ≠ 线程安全"></a>📌 附加：ThreadLocal ≠ 线程安全</h3><blockquote>
<p>ThreadLocal 并不是让对象变“线程安全”，只是让每个线程用自己那份数据，<strong>避免共享</strong>导致的问题。</p>
</blockquote>
<h3 id="🚀-作用与优势"><a href="#🚀-作用与优势" class="headerlink" title="🚀 作用与优势"></a>🚀 作用与优势</h3><ul>
<li><strong>线程隔离</strong>：每个线程持有一份独立变量，互不干扰，解决并发线程对共享资源读写冲突的问题。</li>
<li><strong>线程内共享</strong>：同一线程中可以在不同方法、组件间共享数据（如事务控制、用户上下文等）。</li>
</ul>
<h3 id="🧠-原理说明（核心）"><a href="#🧠-原理说明（核心）" class="headerlink" title="🧠 原理说明（核心）"></a>🧠 原理说明（核心）</h3><p>每个线程内部都维护一个 <code>ThreadLocalMap</code>（它是 Thread 类的成员变量）：</p>
<ul>
<li>当调用 <code>threadLocal.set(value)</code> 时：<ul>
<li>当前线程的 <code>ThreadLocalMap</code> 中以 <code>threadLocal</code> 实例作为 key，<code>value</code> 作为值进行存储。</li>
</ul>
</li>
<li>当调用 <code>threadLocal.get()</code> 时：<ul>
<li>会从当前线程中以 <code>threadLocal</code> 为 key 查找对应的值。</li>
</ul>
</li>
<li><code>remove()</code> 用于手动移除，防止内存泄漏。</li>
</ul>
<p>✅ 本质上：ThreadLocal 并不是把值保存在自己内部，而是保存在当前线程的 <code>ThreadLocalMap</code> 中。</p>
<h3 id="☢️-内存泄漏问题"><a href="#☢️-内存泄漏问题" class="headerlink" title="☢️ 内存泄漏问题"></a>☢️ 内存泄漏问题</h3><ul>
<li><code>ThreadLocalMap</code> 中的 key 是 <code>ThreadLocal</code> 的<strong>弱引用</strong>，但 value 是<strong>强引用</strong></li>
<li>当 ThreadLocal 实例被 GC 回收后，key 变成 null，**<u>value 仍存在，若不手动 remove，就会造成内存泄漏</u>**</li>
<li><strong>最佳实践：用完一定要调用 <code>remove()</code> 方法清除数据</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
<li>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线<br>程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中査找关联的资源值</li>
<li>调用remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li>ThreadLocal内存泄漏问题ThreadLocalMap 中的key是弱引用，值为强引用; key会被Gc释放内存，关联 value的内存并不会释放。建议主动remove 释放 key，value</li>
</ul>
</blockquote>
<h6 id="ThreadLocal概述"><a href="#ThreadLocal概述" class="headerlink" title="ThreadLocal概述"></a>ThreadLocal概述</h6><p>ThreadLocal是多线程中对于解决线程安全的一个操作类，它会<strong>为每个线程都分配一个独立的线程副本</strong>从而解决了变量并发访问冲突的问题。ThreadLocal同时实现了线程内的资源共享</p>
<p>案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。</p>
<p><strong>ThreadLocal基本使用</strong></p>
<ul>
<li>set(value) 设置值</li>
<li>get() 获取值</li>
<li>remove() 清除值</li>
</ul>
<h6 id="ThreadLocal的实现原理-amp-源码解析"><a href="#ThreadLocal的实现原理-amp-源码解析" class="headerlink" title="ThreadLocal的实现原理 &amp; 源码解析"></a>ThreadLocal的实现原理 &amp; 源码解析</h6><p>ThreadLocal本质来说就是一个<strong>线程内部存储类</strong>，从而让多个线程只操作自己内部的值，从而实现线程数据隔离<br><img src="https://raw.githubusercontent.com/P-luminary/images/4471cf0ff69616926ff6fab93392d3d9fa5aba32/%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3.png"></p>
<h2 id="JVM相关面试题"><a href="#JVM相关面试题" class="headerlink" title="JVM相关面试题"></a>JVM相关面试题</h2><p><span style = "color:red"><strong>什么是JVM？</strong></span></p>
<p>JVM &#x3D; <code>Java Virtual Machine</code>  是java程序的运行环境<br>JVM是运行在操作系统中的 屏蔽了操作系统的差异</p>
<p><strong>好处</strong>：</p>
<ul>
<li>一次编码，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a325bf161b1cdb5a49058d007d4e21a05f2a1fc5/JVM%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90.png"></p>
<p><span style = "color:red"><strong>什么是程序计数器？</strong></span></p>
<p><strong>程序计数器</strong>：线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址</p>
<p><code>javap -v xx.class</code>：打印堆栈大小，局部变量的数量和方法的参数</p>
<blockquote>
<p>找到Application的class文件后 → Build → Rebuild Project<del>编译一下</del> → 找到该Application的class文件<del>黄色的</del> → Open in → Terminal → javap -v Application.class</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f1c8f0c34bb891c12d945dd852ab575a787a2112/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>你能给我详细介绍Java堆吗？</strong></span></p>
<p><strong>线程共享的区域：</strong>主要用来保存<strong>对象实例、数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展，则抛出<code>OutOfMemoryError</code>异常</p>
<ul>
<li>组成：<strong>年轻代 + 老年代</strong><ul>
<li><strong>年轻代</strong>被划分为三部分，Eden区和两个大小严格相同的Survivor区<del>幸存者区</del></li>
<li><strong>老年代</strong>主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
</li>
<li>jdk1.7和1.8的区别<ul>
<li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5e6f155423b028b82378d40f63a3713073b75410/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86.png"></p>
<p><span style = "color:red"><strong>什么是虚拟机栈？</strong></span></p>
<p><code>Java Virtual machine Stacks</code>(Java虚拟机栈)</p>
<ul>
<li>每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong>，先进后出</li>
<li>每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p><span style = "color:blue">垃圾回收是否涉及栈内存？</span></p>
<p>不涉及，因为垃圾回收主要指的是<strong>堆内存</strong>。<br>这里当栈帧弹栈后，内存就会释放</p>
<p><span style = "color:blue">栈内存分配越大越好吗？</span></p>
<p>未必，默认的栈内存通常为1024k<br>栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半</p>
<p><span style = "color:blue">方法内的局部变量是否线程安全？</span></p>
<p>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的<br>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</p>
<p><span style = "color:blue">什么情况下会导致栈内存溢出？</span></p>
<p>栈帧过多导致栈内存溢出，经典问题：递归调用<br>栈帧过大导致栈内存溢出</p>
<p><span style = "color:blue">堆栈的区别是什么？</span></p>
<p>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会<br>栈内存是线程私有的，而堆内存是线程共有的。<br>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常<br>  栈空间不足:java.lang.StackOverFlowError。<br>  堆空间不足:java.ang.OutOfMemoryError。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/420de72ff7c225960e7aff5d59f20c14e93ecb0a/%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p>
<p><span style = "color:red"><strong>能不能解释一下方法区</strong></span></p>
<ul>
<li><span style = "color:blue">方法区(Method Area)是<u>各个线程</u> <strong>共享的内存区域</strong></span></li>
<li><span style = "color:blue">主要存储类的信息、运行时常量池</span></li>
<li>虚拟机启动的时候创建，关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出<code>OutOfMemoryError: Metaspace</code></li>
</ul>
<h6 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h6><p>可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息<br>在<strong>Terminal</strong>中执行：<code>javap -v Application.class</code><br>可以查看字节码结构 (<strong><u>类的基本信息、常量池、方法定义</u></strong>)<br>当类被加载，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/dea620655b2b4c7234ba3b2f4fcedbf76a0bb9a8/%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><span style = "color:red"><strong>你听过直接内存吗？</strong></span></p>
<p><strong>直接内存</strong>：并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作时，用于数据缓冲区，它分配回收成本较高，但读写能力高。[平时的是BIO]</p>
<p>直接内存并不属于JVM中的内存结构，不由VM进行管理。<strong>是虚拟机的系统内存常见于 NIO 操作时，用于数据缓冲区</strong>，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5823b0e711a3e4029e411438f0a85468af5dfa3f/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.png"></p>
<p><span style = "color:red"><strong>什么是类加载器，类加载器有哪些？</strong></span></p>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来</p>
<ol>
<li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库</del><ul>
<li>这是最顶层的类加载器，它用于加载Java的核心库，这些库位于<code>&lt;JAVA_HOME&gt;/jre/lib</code>目录（比如<code>rt.jar</code>、<code>resources.jar</code>等），或者被<code>-Xbootclasspath</code>参数指定的路径中。</li>
<li><u><strong>引导类加载器是用原生代码（如C&#x2F;C++）实现的</strong></u>，它属于JVM的一部分。</li>
<li>它并不继承自<code>java.lang.ClassLoader</code>，而是由JVM自身实现。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：<del>加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类</del><ul>
<li>它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录中，或者由系统属性<code>java.ext.dirs</code>指定的路径中的类库。</li>
<li>它是<code>sun.misc.Launcher$ExtClassLoader</code>类的实例。</li>
</ul>
</li>
<li><strong>系统类加载器（System ClassLoader）</strong>：<del>用于加载classPath下的类</del><ul>
<li>也称为应用类加载器（Application ClassLoader），它负责加载用户类路径（Classpath）上的所有类库。</li>
<li>系统类加载器是<code>sun.misc.Launcher$AppClassLoader</code>类的实例。</li>
<li>它是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取。</li>
</ul>
</li>
<li><strong>自定义加载器（CustomizeClassLoader）</strong><del>自定义继承ClassLoader，实现自定义类加载规则</del><ul>
<li>用户还可以自定义类加载器。自定义类加载器通过继承<code>java.lang.ClassLoader</code>类并重写相应的方法来实现。自定义类加载器可以用于特定的需求，例如在Web容器中加载类，或者在运行时从网络或其他地方动态加载类。</li>
</ul>
</li>
</ol>
<p><span style = "color:red"><strong>什么是双亲委派模型？</strong></span></p>
<p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类</p>
<h6 id="JVM为什么采用双亲委派机制？"><a href="#JVM为什么采用双亲委派机制？" class="headerlink" title="JVM为什么采用双亲委派机制？"></a>JVM为什么采用双亲委派机制？</h6><ul>
<li>通过双亲委派机制可以<strong>避免某一个类被重复加载</strong>，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/994e5705a6bdb7a164308d3496942d154c877b36/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p>
<p><span style = "color:red"><strong>说一下类装载的执行过程？</strong></span></p>
<blockquote>
<p><strong>加载</strong>：查找和导入class文件<br><strong>验证</strong>：保证加载类的准确性<br><strong>准备</strong>：为类变量分配内存并设置类变量初始值<br><strong>解析</strong>：把类中的符号引用转换为直接引用<br><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作<br><strong>使用</strong>：JVM 开始从入口方法开始执行用户的程序代码<br><strong>卸载</strong>：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用</strong>和<strong>卸载</strong>这7个阶段。其中，验证、准备和解析这三个部分统称为连接(linking)</p>
<ul>
<li>通过类的全名，获得类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模型)</li>
<li>创建<code>java.lang.Class</code>类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6e58e968ea6bb8bb002556d37d5cc31b73f820e3/%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B1.png"></p>
<p><span style = "color:red"><strong>对象什么时候可以被垃圾器回收</strong></span></p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong></p>
<p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e29795c3537bdedf4f596d20c78cda8b7f8abc8c/%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6.png"></p>
<p><span style = "color:red"><strong>JVM垃圾回收算法有哪些？</strong></span></p>
<ul>
<li><p><strong>标记清除算法</strong></p>
<p>是将垃圾回收分为2个阶段，分别为<strong>标记</strong>和<strong>清除</strong></p>
<ul>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
</ul>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收；无碎片，内存使用率低</p>
</li>
<li><p><strong>标记清理算法</strong><del>一般用于老年代</del></p>
<p>标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，无碎片，对象需要移动，效率低</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/da45a9b399c0614bb286b0dfef59d0d737ee7b38/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png"></p>
<p><span style = "color:red"><strong>JVM的分代回收是什么？</strong></span></p>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>在java8时，堆被分为了两份：<strong>新生代和老年代</strong>[1:2]<br>对于新生代，内部又分为了三个区域，Eden区，幸存者区survivor(分成from和to)【8:1:1】</p>
<h6 id="MinorGC、MixedGC、FullGC的区别是什么"><a href="#MinorGC、MixedGC、FullGC的区别是什么" class="headerlink" title="MinorGC、MixedGC、FullGC的区别是什么"></a>MinorGC、MixedGC、FullGC的区别是什么</h6><ul>
<li>MinorGC<del>(youngGC)</del>发生在新生代的垃圾回收，暂停时间短(STW)</li>
<li>MixedGC：新生代 + 老年代 <strong>部分</strong>区域的垃圾回收，G1收集器特有</li>
<li>FullGC：新生代 + 老年代 <strong>完整</strong>垃圾回收，暂停时间长(STW)，应尽力避免</li>
</ul>
<p><code>STW(Stop-The-World)</code>：<u>暂停所有应用程序线程，等待垃圾回收的完成</u></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3cf5dfdf35165c472440a0b24f3561c6bef9b81a/JVM%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88.png"></p>
<p><span style = "color:red"><strong>JVM有哪些垃圾回收器？</strong></span></p>
<p>在jvm中，实现了多种垃圾收集器，包括：</p>
<ul>
<li><p><strong>串行垃圾收集器</strong></p>
<p><strong>Serial</strong>和<strong>Serial Old</strong>串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑</p>
<ul>
<li>Serial 作用于新生代，采用复制算法</li>
<li>Serial Old 作用于老年代，采用标记-整理算法垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成</li>
</ul>
</li>
<li><p><strong>并行垃圾收集器</strong></p>
<p>Parallel New和Parallel Old是一个<strong>并行</strong>垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p>
<ul>
<li><p>Parallel New作用于新生代，采用复制算法</p>
</li>
<li><p>Parallel Old作用于老年代，采用标记-整理算法</p>
<p>垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成。</p>
</li>
</ul>
</li>
<li><p><strong>CMS(并发)垃圾收集器</strong></p>
<p>CMS全称 Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记-清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
</li>
<li><p><strong>G1垃圾收集器</strong></p>
<p>作用在新生代和老年代</p>
</li>
</ul>
<p><span style = "color:red"><strong>详细聊一下G1垃圾回收器</strong></span></p>
<ul>
<li>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></li>
<li>划分成多个区域，每个区域都可以充当<strong>eden，survivor，old，humongous</strong>，其中<code>humongous</code>专为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集</li>
<li>如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1a968a17f25b1bbd6bdde1c89b08cb064802b868/%E8%AF%A6%E7%BB%86%E8%81%8A%E4%B8%80%E4%B8%8BG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<p><span style = "color:red"><strong>强引用、软引用、弱引用、虚引用的区别</strong></span></p>
<blockquote>
<p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，内存依然不够时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，只要进行了垃圾回收，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
</blockquote>
<ul>
<li><strong>强引用</strong>：只有所有 <code>GCRoots</code> 对象都不通过【强引用】 引用该对象，该对象才能被垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
</code></pre>
<p>  <u>GC Root → User对象</u></p>
<ul>
<li><strong>软引用</strong>：仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足</strong>时会再次触发垃圾回收</li>
</ul>
<pre><code class="java">User user = new User();
SoftReference softReference = new SoftReference(user);
</code></pre>
<p>  <u>GC Root → SoftReference对象 →→<del>虚线</del> User对象</u><br>  一开始并不会对User对象进行回收 此时User对象就是软引用 如果内存还是不够 马上又再次进行了垃    圾回收 此时软引用的User就会被回收</p>
<ul>
<li><strong>弱引用</strong>：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
</ul>
<pre><code class="java">User user = new User();
WeakReference weakReference = new WeakReference(user)
</code></pre>
<p>  <u>GC Root → WeakReference对象 →→<del>虚线</del> User对象</u></p>
<blockquote>
<p>延申话题：ThreadLocal内存泄露问题</p>
<pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;&#123;
    Object value;
 Entry(ThreadLocal&lt;?&gt;k, Object v)&#123;
     super(k); // k是弱引用
     value = v; // 强引用，不会被回收
 &#125;
&#125;
</code></pre>
</blockquote>
<ul>
<li><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</li>
</ul>
<pre><code class="java">User user = new User();
ReferenceQueue referenceQueue = new ReferenceQueue();
PhantomReference phantomReference = new PhantomReference(user, queue);
</code></pre>
<p><span style = "color:red"><strong>JVM调优的参数可以在哪里设置？</strong></span></p>
<ul>
<li><p><code>war包</code>部署在<code>tomcat</code>中设置</p>
<p>修改 <code>TOMCAT_HOME/bin/catalina.sh</code> 文件<br><code>D:\apache-tomcat-8.5.93\bin\catalina.sh</code>【卡特琳娜】</p>
<pre><code class="mysql"># OS specific support.  $var _must_ be set to either true or false.
JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot;
cygwin=false
darwin=false
os400=false
hpux=false
</code></pre>
</li>
<li><p><code>jar包</code>部署在<code>启动参数</code>设置</p>
<p>通常在linux系统下直接加参数启动SpringBoot项目<del>—VM</del></p>
<p><code>nohup java -Xms512m -Xmx1024n -jar xxxx.jar --spring.profiles.active=prod &amp;</code></p>
</li>
</ul>
<p><strong>nohup</strong>：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行<br>**参数<code>&amp;</code>**：让命令在后台执行，终端退出后命令仍然执行</p>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<p>对于JVM调优，主要就是调整 <code>年轻代、老年代、元空间</code> 的内存大小及使用的垃圾回收器类型</p>
<ul>
<li><p><strong>设置堆空间大小</strong></p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<pre><code class="java">-Xms: 设置堆的初始化大小
-Xmx: 设置堆的最大大小
// 不指定单位默认为字节
-Xms：1024
-Xms：1024k
</code></pre>
<p>堆内存设置多少合适？</p>
<ul>
<li>最大大小的默认值是物理内存的1&#x2F;4，<strong>初始大小是物理内存的1&#x2F;64</strong><del>【不设置的情况下】</del></li>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生STW，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc，它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p><strong>虚拟机栈的设置</strong></p>
<p>虚拟机栈的设置：<strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<p><code>-Xss 对每个线程stack大小的调整，-Xss128k</code></p>
</li>
<li><p><strong>年轻代中Eden区和两个Survivor区的大小比例</strong></p>
<p>设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。通过增大Eden区的大小来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<p><code>-XXSurvivorRatio=8，表示年轻代中的分配比率：survivor:eden = 2:8</code></p>
</li>
<li><p><strong>年前代晋升老年代阈值</strong>【默认值为15，取值范围0-15】</p>
<p><code>-XX:MaxTenuringThreshold=threshold</code></p>
</li>
<li><p><strong>设置垃圾回收收集器</strong></p>
<p>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器</p>
<p><code>-XX:+UseParallelGC</code><br><code>-XX:+UseParallelOldGC</code></p>
<p><code>-XX:+UserG1GC</code></p>
</li>
</ul>
<p><span style = "color:red"><strong>JVM调优的参数都有哪些？</strong></span></p>
<ul>
<li><p><strong>命令工具</strong></p>
<ul>
<li><p><strong>jps</strong> 进程状态信息</p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
</li>
<li><p><strong>jmap</strong> 查看堆栈信息[生成堆转内存快照,内存使用信息]</p>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid
</code></pre>
<ul>
<li><p>format&#x3D;b 表示以hprof二进制格式存储Java堆的内存</p>
</li>
<li><p>file&#x3D;&lt; filename  &gt; 用于指定快照dump文件的文件名</p>
<p><code>dump</code>：它是我们都可以通过工个进程或系统在某一给定的时间的快照。比如在进程崩溃时，甚至是任何时候，具将系统或某进程的内存备份出来供调试分析用，dump文件中包含了程序运行的模块信息、线程信息、堆调用信息、异常信息等数据，方便系统技术人品进行错误排查</p>
</li>
</ul>
</li>
<li><p><strong>jhat</strong> 堆转储快照分析工具</p>
</li>
<li><p><strong>jstat</strong> JVM统计监测工具[可以用来显示垃圾回收信息、类加载信息、新生代统计信息等]</p>
<ul>
<li>总结垃圾回收统计：<code>jstat -gcutil pid</code></li>
<li>垃圾回收统计：<code>jstat -gc pid</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可视化工具</strong></p>
<ul>
<li><strong>jconsole</strong> 用于对jvm的内存，线程，类的监控, 是一个可视化工具<br><code>D:\java\jdk-11.0.20\bin\jconsole.exe</code></li>
<li><strong>VisualVM</strong> 能够监控线程，内存情况<del>只有jdk1.8有</del><br><code>D:\java\jdk1.8.0_181\bin\jvisualvm.exe</code></li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>Java内存泄露的排查思路？</strong></span></p>
<blockquote>
<p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
</blockquote>
<p>JVM  Stacks <strong>虚拟机栈</strong> → <code>StackOverFlowError</code><br>Heap <strong>堆</strong> → <code>OutOfMemoryError：java heap space</code><br>Method Are&#x2F; MateSpace <strong>方法区&#x2F;元空间</strong> → <code>OutOfMemoryError: Metaspace</code></p>
<p>模拟堆空间溢出场景：-VM设置参数 → <code>-Xmx10m</code></p>
<pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
while(true)&#123;
    list.add(&quot;北京&quot;);
&#125;
-------------------------------------------
// OutOfMemoryError：java heap space
</code></pre>
<h6 id="如何排查启动闪退、运行一段时间宕机"><a href="#如何排查启动闪退、运行一段时间宕机" class="headerlink" title="如何排查启动闪退、运行一段时间宕机"></a>如何排查启动闪退、运行一段时间宕机</h6><ul>
<li><p>获取堆内存快照dump</p>
<ul>
<li>使用jmap命令获取运行中程序的dump文件<del>【只有在项目运行时候才可以用】</del></li>
</ul>
<pre><code class="java">jmap -head pid 显示Java堆的信息
jmap -dump:format=b,file=heap.hprof pid 【只有在项目运行时候才可以用】
</code></pre>
<ul>
<li><p><strong>使用vm参数获取dump文件</strong></p>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式生成dump文件</p>
</li>
</ul>
<pre><code class="java">-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/home/app/dumps/
</code></pre>
</li>
<li><p>VisualVM区分析dump文件</p>
</li>
<li><p>通过查看堆内存的信息，定位内存溢出问题</p>
</li>
</ul>
<p><span style = "color:red"><strong>CPU飙高排查方案与思路？</strong></span></p>
<blockquote>
<p>1.使用top命令查看占用cpu的情况<br>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>3.使用ps命令查看进程中的线程信息<br>4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
</blockquote>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程转换十六进程<br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><span style = "color:red">设计模式</span></h2><h5 id="框架中的设计模式-项目中的设计模式"><a href="#框架中的设计模式-项目中的设计模式" class="headerlink" title="框架中的设计模式 + 项目中的设计模式"></a>框架中的设计模式 + 项目中的设计模式</h5><p><span style = "color:red"><strong>简单工厂模式</strong></span></p>
<p>简单工厂包含如下角色</p>
<ul>
<li><strong>抽象产品</strong>：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li><strong>具体产品</strong> ：实现或者继承抽象产品的子类</li>
<li><strong>具体工厂</strong>：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<p>需求：设计一个咖啡店点餐系统。<br>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCofee】和拿铁咖啡【LatteCoffee】); 再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d91b96f4466457e253dd9a8b298f99c098e4501c/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>工厂方法模式</strong></span><del>完全遵循开闭原则</del></p>
<p>方法模式的主要角色:<br><strong>抽象工厂</strong>(Abstract Factory)：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。<br><strong>具体工厂</strong>(ConcreteFactory)：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br><strong>抽象产品</strong>(Product)：定义了产品的规范，描述了产品的主要特性和功能。<br><strong>具体产品</strong>(ConcreteProduct)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一 一对应。</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/55e41a4a745af324a0d0a18d0af0694fb0d319e9/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" style="zoom: 67%;" />



<p><span style = "color:red"><strong>抽象工厂模式</strong></span></p>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理等级产品的生产<br>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产–个等级的产品，而抽象工厂模式可生产多个等级的产品<strong>。一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2dc778be8350e592f74d23beeee7c256826204f4/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"></p>
<p><span style = "color:red"><strong>策略模式</strong></span></p>
<ul>
<li>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</li>
<li>它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</li>
</ul>
<p>策略模式的主要角色如下:<br><strong>抽象策略(Strategy)类</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口<br><strong>具体策略(Concrete Strategy)类</strong>：实现了抽象策略定义的接口，提供具体的算法实现或行为。<br><strong>环境(Context)类</strong>：持有一个策略类的引用，最终给客户端调用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b29eac1685bcdf60e7adde25286c276ddbeb43a7/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA.png"></p>
<h4 id="策略模式—登录案例-工厂模式-策略模式"><a href="#策略模式—登录案例-工厂模式-策略模式" class="headerlink" title="策略模式—登录案例 (工厂模式 + 策略模式)"></a><span style = "color:red"><strong>策略模式—登录案例 (工厂模式 + 策略模式)</strong></span></h4><blockquote>
<ul>
<li><p>什么是策略模式</p>
<ul>
<li><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户</p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</p>
</li>
</ul>
</li>
<li><p>案例(工厂方法+策略)</p>
<ul>
<li>介绍业务(登录、支付、解析excel、优惠等级…)</li>
<li>提供了很多种策略，都让spring容器管理</li>
<li>提供一个工厂：准备策略对象，根据参数提供对象</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>一句话总结</strong>：只要代码中有冗长的if-else 或switch 分支判断都可以采用策略模式优化</p>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>订单的支付策略(支付宝、微信、银行卡..)</li>
<li>解析不同类型excel(xls格式、xlsx格式)</li>
<li>打折促销(满300元9折、满500元8折、满1000元7折..)</li>
<li>物流运费阶梯计算(5kg以下、5-10kg、10-20kg、20kg以上)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/69c802f411142a1bdabf991a27b8a48662cc8ca9/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E6%8B%9F.png" alt="策略模式和工厂方法模拟.png"></p>
<p><span style = "color:red"><strong>责任链模式—概述及案例</strong></span></p>
<p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<ul>
<li><strong>抽象处理者(Handler)角色</strong>：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li><strong>具体处理者(Concreate Handler)角色</strong>：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li><strong>客户类(Cient)角色</strong>：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<p><span style = "color:blue"><strong>举一反三</strong></span></p>
<ul>
<li>内容审核(视频、文章、课程)</li>
<li>订单创建</li>
<li>简易流程审批</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c73c212f673d69975c55ad134b045e433a6f1e23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F2.png"></p>
<blockquote>
<h3 id="区分责任链模式和策略模式-在if的情况下"><a href="#区分责任链模式和策略模式-在if的情况下" class="headerlink" title="区分责任链模式和策略模式 在if的情况下"></a>区分<strong>责任链模式</strong>和<strong>策略模式</strong> 在if的情况下</h3><h2 id="✅-一句话区分"><a href="#✅-一句话区分" class="headerlink" title="✅ 一句话区分"></a>✅ 一句话区分</h2><table>
<thead>
<tr>
<th>模式</th>
<th>一句话理解</th>
</tr>
</thead>
<tbody><tr>
<td><strong>策略模式</strong></td>
<td><strong>多种方案中选一个</strong>执行（if 就是“选择谁”）</td>
</tr>
<tr>
<td><strong>责任链模式</strong></td>
<td><strong>多个处理器</strong>依次尝试处理（if 是“要不要接着传下去”）</td>
</tr>
</tbody></table>
<hr>
<h2 id="👀-从-if-角度看"><a href="#👀-从-if-角度看" class="headerlink" title="👀 从 if 角度看"></a>👀 从 if 角度看</h2><table>
<thead>
<tr>
<th>模式</th>
<th>if 的含义</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>策略模式</td>
<td>选择哪个处理逻辑（<strong>只执行一个</strong>）</td>
<td>一旦匹配执行完毕，不再走其他</td>
</tr>
<tr>
<td>责任链模式</td>
<td>是否要处理或继续传递（<strong>可能多个都执行</strong>）</td>
<td>可以处理多个，也可以提前终止</td>
</tr>
</tbody></table>
<h2 id="🎯-场景类比（超级形象）"><a href="#🎯-场景类比（超级形象）" class="headerlink" title="🎯 场景类比（超级形象）"></a>🎯 场景类比（超级形象）</h2><h3 id="📦-策略模式："><a href="#📦-策略模式：" class="headerlink" title="📦 策略模式："></a>📦 策略模式：</h3><blockquote>
<p>像点菜：你从多个菜中选择一个最合适的吃<br> 🔁 选择一个策略就完事</p>
</blockquote>
<pre><code class="java">if (type == &quot;微信&quot;) &#123;
   payWithWeChat();
&#125; else if (type == &quot;支付宝&quot;) &#123;
   payWithAliPay();
&#125;
</code></pre>
<ul>
<li><strong>策略模式核心</strong>：同一个接口，不同实现类，运行时选择哪个</li>
</ul>
<hr>
<h3 id="🛠️-责任链模式："><a href="#🛠️-责任链模式：" class="headerlink" title="🛠️ 责任链模式："></a>🛠️ 责任链模式：</h3><blockquote>
<p>像审批流程：你写了个请假单，先经理签字 → 主管签字 → HR签字<br> 🔁 每个人看一下自己要不要处理，处理完能不能往下传</p>
</blockquote>
<pre><code class="java">if (金额 &lt;= 1000) &#123;
   主管处理
   return
&#125;
if (金额 &lt;= 5000) &#123;
   经理处理
   return
&#125;
HR处理
</code></pre>
<ul>
<li><strong>责任链核心</strong>：链式传递，一个接一个处理（可中断）</li>
</ul>
<h2 id="✅-示例代码对比"><a href="#✅-示例代码对比" class="headerlink" title="✅ 示例代码对比"></a>✅ 示例代码对比</h2><h3 id="🧪-策略模式（支付选择）"><a href="#🧪-策略模式（支付选择）" class="headerlink" title="🧪 策略模式（支付选择）"></a>🧪 策略模式（支付选择）</h3><pre><code class="java">public interface PayStrategy &#123;
    void pay();
&#125;

public class WeChatPay implements PayStrategy &#123;
    public void pay() &#123; System.out.println(&quot;微信支付&quot;); &#125;
&#125;

public class AliPay implements PayStrategy &#123;
    public void pay() &#123; System.out.println(&quot;支付宝支付&quot;); &#125;
&#125;

// 使用
PayStrategy strategy;
if (&quot;wechat&quot;.equals(type)) &#123;
    strategy = new WeChatPay();
&#125; else &#123;
    strategy = new AliPay();
&#125;
strategy.pay();
</code></pre>
<p>✔️ 选择一个策略类并执行，<code>if</code> 只是为了<strong>选哪一个</strong></p>
<hr>
<h3 id="🧪-责任链模式（审批流程）"><a href="#🧪-责任链模式（审批流程）" class="headerlink" title="🧪 责任链模式（审批流程）"></a>🧪 责任链模式（审批流程）</h3><pre><code class="java">public abstract class Approver &#123;
    protected Approver next;

    public void setNext(Approver next) &#123;
        this.next = next;
    &#125;

    public abstract void process(int amount);
&#125;

public class Manager extends Approver &#123;
    public void process(int amount) &#123;
        if (amount &lt;= 1000) &#123;
            System.out.println(&quot;Manager approved&quot;);
        &#125; else if (next != null) &#123;
            next.process(amount);
        &#125;
    &#125;
&#125;

public class Director extends Approver &#123;
    public void process(int amount) &#123;
        if (amount &lt;= 5000) &#123;
            System.out.println(&quot;Director approved&quot;);
        &#125; else if (next != null) &#123;
            next.process(amount);
        &#125;
    &#125;
&#125;

// 链式构建
Manager m = new Manager();
Director d = new Director();
m.setNext(d);

// 发起请求
m.process(3000);
</code></pre>
<p>✔️ 多个处理器按顺序尝试，<code>if</code> 是为了<strong>决定自己是否处理</strong>，并可能<strong>往下传递</strong></p>
<p> <strong>if 语句长得一样</strong>，但目的不同：</p>
<ul>
<li>策略 if 是“选哪一个”</li>
<li>责任链 if 是“要不要传下去”</li>
</ul>
</blockquote>
<h3 id="常见技术场景题"><a href="#常见技术场景题" class="headerlink" title="常见技术场景题"></a><span style = "color:red">常见技术场景题</span></h3><h6 id="单点登录这块怎么实现的？"><a href="#单点登录这块怎么实现的？" class="headerlink" title="单点登录这块怎么实现的？"></a><span style = "color:red">单点登录这块怎么实现的？</span></h6><p>单点登录的英文名：Single Sign On (<strong>SSO</strong>)，只需要登录一次，就可以访问所有信任的应用系统</p>
<p>① 先解释什么是单点登录：单点登录的英文名叫做:Single SignOn(简称SSO)<br>② 介绍自己项目中涉及到的单点登录(即使没涉及过，也可以说实现的思路)<br>③ 介绍单点登录的解决方案，以JWT为例<br>    用户访问其他系统，会在网关判断token是否有效<br>    如果token无效则会返回401(认证失败)前端跳转到登录页面<br>    用户发送登录请求，返回浏览器一个token，浏览器把token保存到cookie<br>    再去访问其他服务的时候，都需要携带token，由网关统一验证后路由到目标服务</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3389992651a50673831641a3ae5dd61aa8e344a/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%BF%99%E5%9D%97%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.png"></p>
<h6 id="权限认证是如何实现的？"><a href="#权限认证是如何实现的？" class="headerlink" title="权限认证是如何实现的？"></a><span style = "color:red">权限认证是如何实现的？</span></h6><p>后台的管理系统，更注重权限控制，最常见的就是<strong>RBAC</strong>模型来指导实现权限<br>RBAC(Role-Based Access Control)基于角色的访问控制</p>
<ul>
<li>3个基础部分组成：<strong>用户、角色、权限</strong></li>
<li>具体实现：<ul>
<li>5张表：<strong>用户表、角色表、权限表、用户角色中间表、角色权限中间表</strong></li>
<li>7张表：<strong>用户表、角色表、权限表、菜单表、用户角色中间表、角色权限中间表、权限菜单中间表</strong></li>
</ul>
</li>
</ul>
<p>张三具有什么权限呢？<br>流程：张三登录系统 → 查询张三拥有的角色列表 → 再根据角色查询拥有的权限</p>
<p>权限框架：<code>Apache shiro</code>、<code>Spring Security（推荐）</code><br><img src="https://raw.githubusercontent.com/P-luminary/images/ed40dce8c09b42689021c6ee66a4565a314acc69/RBAC%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<h6 id="上传数据的安全性你们怎么控制？"><a href="#上传数据的安全性你们怎么控制？" class="headerlink" title="上传数据的安全性你们怎么控制？"></a><span style = "color:red">上传数据的安全性你们怎么控制？</span></h6><p>主要说的是数据在网络上传输如何保证安全</p>
<p>使用**非对称加密(或对称加密)**，给前端一个公钥让他把数据加密后传到后台，后台负责解密后处理数据</p>
<h6 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h6><p>文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9886840e455bef1ee39b93c8c75495b6e80fe6fb/%E5%AF%B9%E7%A7%B0+%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png"></p>
<h6 id="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3"><a href="#你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1-3" class="headerlink" title="你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？1+3"></a><span style = "color:red">你负责项目的时候遇到了哪些比较棘手的问题？怎么解决的？</span><del>1+3</del></h6><blockquote>
<p>其次你也可以说说aop的实现，比如你们操作日志记录等，利用aop切面思想，通过环绕通知等但需封装出出个切面工具类。建议你们说说sql调优，比如商品列表页需要分页查询，但是几百万商品导致查询慢，如何优化的，这是一个</p>
</blockquote>
<h6 id="①-设计模式在项目中的应用"><a href="#①-设计模式在项目中的应用" class="headerlink" title="① 设计模式在项目中的应用"></a><span style = "color:blue">① 设计模式在项目中的应用</span></h6><p>是为了遵循一系列的开发原则【工厂、策略、责任链】</p>
<ul>
<li>什么背景[技术问题] → 登录的例子</li>
<li>过程[解决问题的过程]</li>
<li>最终落地方案</li>
</ul>
<h6 id="②-线上BUGJVM-多线程"><a href="#②-线上BUGJVM-多线程" class="headerlink" title="② 线上BUGJVM+多线程"></a><span style = "color:blue">② 线上BUG<del>JVM+多线程</del></span></h6><ul>
<li>CPU飙高</li>
<li>内存泄露</li>
<li>线程死锁</li>
</ul>
<h6 id="③-调优"><a href="#③-调优" class="headerlink" title="③ 调优"></a><span style = "color:blue">③ 调优</span></h6><ul>
<li>慢接口</li>
<li>慢SQL</li>
<li>缓存方案</li>
</ul>
<p><span style = "color:blue"><strong>④ 组件封装</strong></span></p>
<ul>
<li>分布式锁</li>
<li>接口幂等</li>
<li>分布式事务</li>
<li>支付通用</li>
</ul>
<h6 id="你们项目中日志怎么采集的？"><a href="#你们项目中日志怎么采集的？" class="headerlink" title="你们项目中日志怎么采集的？"></a><span style = "color:red">你们项目中日志怎么采集的？</span></h6><blockquote>
<p>我们搭建了ELK日志采集系统<br>介绍**<u>ELK</u>**的三个组件:<br><strong>Elasticsearch</strong>是全文搜索分析引擎，可以对数据存储、搜索、分析<br><strong>Logstash</strong>是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置<br><strong>Kibana</strong>是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</p>
</blockquote>
<ul>
<li><strong>为什么要采集日志</strong>？</li>
</ul>
<p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题</p>
<ul>
<li><strong>采集日志的方式有哪些</strong><ul>
<li><span style = "color:orange"><strong>ELK</strong>：即<code>ElasticSearch、LogStash、Kibanna</code>三个软件的首字母</span></li>
<li><strong>常规采集</strong>：按天保存到一个日志文件</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b737bd7a31bb44363954ebefe0f32095096a3793/%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E6%80%8E%E4%B9%88%E9%87%87%E9%9B%86%E7%9A%84.png"></p>
<h6 id="查看日志的命令？查看是否在线查看过日志"><a href="#查看日志的命令？查看是否在线查看过日志" class="headerlink" title="查看日志的命令？查看是否在线查看过日志"></a><span style = "color:red">查看日志的命令？</span><del>查看是否在线查看过日志</del></h6><ul>
<li><p><strong>实时监控日志的变化</strong><br>实时监控某一个日志文件的变化：<code>tail -f xx.log</code><br>实时监控日志文件最后100行的变化：<code>tail -n 100 -f xx.log</code></p>
</li>
<li><p><strong>按照行号查询</strong><br>查询日志尾部最后100行日志：<code>tail -n 100 xx.log</code><br>查询日志头部开始100行日志：<code>head -n 100 xx.log</code><br>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code>(查询100行至200行的日志)</p>
</li>
<li><p><strong>按照关键字找日志的信息</strong><br>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p><strong>按照日期查询</strong><del>日期必须在日志中出现过</del></p>
<p><code>sed -n &#39;/2025-01-14 14:22:31.070/,/ 2025-01-14 14:27:18.158/p&#39; xx.log</code></p>
</li>
<li><p><strong>日志太多，处理方式</strong></p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log | grep &quot;debug&quot; | more</code></li>
<li>筛选过滤后，输出到一个文件：<code>cat -n xx.log | grep &quot;debug&quot; &gt; debug.txt</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9ee9064d3f9fa8ae290a4ccfe1da9af84b88e584/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4.png"></p>
<h6 id="上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码"><a href="#上线的项目远程Debug-——-生产问题怎么排查？本地调试远程代码" class="headerlink" title="上线的项目远程Debug —— 生产问题怎么排查？本地调试远程代码"></a><span style = "color:red">上线的项目远程Debug —— 生产问题怎么排查？</span><del>本地调试远程代码</del></h6><p>已经上线的bug排查的思路:</p>
<ul>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(通常公司的正式环境(生产环境)是<strong>不允许远程debug的</strong>。一般远程debug都是公司的测试环<br>境，方便调试代码)</li>
</ul>
<p><strong>远程debug</strong></p>
<p>前提条件：<strong>远程的代码和本地的代码要保持一致</strong></p>
<p><strong>①</strong> 远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数：</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 project-1.0-SNAPSHOT.jar</code></p>
<p><strong>②</strong> idea中设置远程debug，找到idea中的<code>Edit Configurations...</code> → 添加一个<code>Remote JVM debug</code> → 右侧要配置<code>Configuration</code>的Host → 添加上面的代码…</p>
<p><strong>③</strong> 在项目中点debug(绿色小虫子)</p>
<p><strong>④</strong> 访问远程服务器，在本地代码中打断点即可调试远程</p>
<p><span style = "color:red"><strong>怎么快速定位系统的瓶颈？</strong></span></p>
<ul>
<li><p>压测(性能测试)，<strong>项目上线之前测评系统的压力</strong></p>
<ul>
<li>压测目的：给出系统当前的性能状况;定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、QPS、并发数、吞吐量、CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端工程师：根据压测的结果进行解决或调优(接口、代码报错、并发达不到要求.)</li>
</ul>
</li>
<li><p>监控工具、链路追踪工具，<strong>项目上线之后监控</strong></p>
<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li><p>线上诊断工具Arthas(阿尔萨斯)，<strong>项目上线之后监控、排查</strong></p>
<ul>
<li><p>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p>
</li>
<li><p>核心功能:Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。<br>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决:</p>
<ul>
<li><p>这个类从哪个jar 包加载的?为什么会报各种类相关的 Exception?</p>
</li>
<li><p>我改的代码为什么没有执行到?难道是我没 commit?分支搞错了?</p>
</li>
<li><p>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗?</p>
</li>
<li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现!</p>
</li>
<li><p>是否有一个全局视角来查看系统的运行状况?</p>
</li>
<li><p>有什么办法可以监控到 JVM 的实时运行状态?</p>
</li>
<li><p>怎么快速定位应用的热点，生成火焰图?</p>
</li>
<li><p>怎样直接从 JVM 内查找某个类的实例?</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><span style = "color:red"><strong>怎么解决cpu飙高?</strong></span></p>
<p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息    使用<code>top -H -p 进程Id</code> [找线程哪个使用多]<br>记住要打印<code>%X十六进制</code>的<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题<br><code>jstack 进程PID | grep 16进制线程PID -A 20</code></p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h3 id="2025-x2F-1-x2F-14-20-35-地点广州-完结撒花"><a href="#2025-x2F-1-x2F-14-20-35-地点广州-完结撒花" class="headerlink" title="2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花"></a><span style = "color:red">2025&#x2F;1&#x2F;14 20:35 地点广州 完结撒花</span></h3><p><span style = "color:red"><strong>项目难点？</strong></span><del>四方保险——day11-数据中心：时序数据库、看板展示【实战】</del></p>
<p>技术上的难点：<strong>时序数据库</strong>、<strong>看板展示</strong></p>
<p><span style = "color:red"><strong>秒杀系统如何优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96a974e196f2d93a561775732ddf415ee4b401cd/%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF.png"></p>
<h6 id="痛点描述："><a href="#痛点描述：" class="headerlink" title="痛点描述："></a>痛点描述：</h6><ul>
<li><strong>瞬时并发量大</strong><ul>
<li>大量用户会在同一时间进行抢购</li>
<li>网站瞬时访问流量激增</li>
</ul>
</li>
<li><strong>库存少</strong><ul>
<li>访问请求数量远远大于库存数量</li>
<li>只有少部分用户能够秒杀成功</li>
</ul>
</li>
</ul>
<p><strong>Ⅰ. 访问层 — 商品页</strong></p>
<ul>
<li>可以将<strong>静态秒杀页面</strong>放在cdn上[用户访问速度↑   减轻服务器压力++]</li>
</ul>
<p><strong>Ⅱ. 访问层 — 秒杀按钮</strong></p>
<ul>
<li>活动前禁用按钮、点击后禁用按钮、滑动验证码[防羊毛党]、排队体验[提升用户体验]</li>
</ul>
<p><strong>Ⅲ. 中间转换层 — 多级负载均衡 &amp; 限流 &amp; 自动伸缩</strong></p>
<ul>
<li>通常会通过Nginx来进行负载均衡【单台Ng处理的并发量是两三万左右】</li>
<li>在它上层要做到硬件级别的隔离器 【F5&#x2F;LVS】</li>
<li>通过Ng负载均衡到网关之后 通过客户端的负载均衡器Ribbon</li>
<li>4级的负载均衡 可以处理每秒上10W以上的QPS并发量</li>
<li>通过<strong>Docker</strong>或<strong>K8S</strong>来进行云服务器的<strong>动态伸缩</strong>的部署[秒杀开始自动扩容 秒杀结束自动缩减]</li>
<li>注意要在Ng上做好限流 防止一些绕过了我们前端的DDOS攻击 还需要在网关层通过<code>Sentinel</code>对不同的服务节点去设置限流以及熔断的机制</li>
<li>可以在秒杀中通过MQ做削锋填股 通过MQ可以减轻下游的压力 防止激增流量打垮下游数据库</li>
</ul>
<p><strong>Ⅳ. 服务端 — 用Redis做缓存减轻数据库压力</strong></p>
<ul>
<li>秒杀商品信息预热到Redis中 防止Redis被击穿我们的数据库</li>
<li>通过Redis的<strong>Lua脚本</strong>[保证多个操作的原子性]操作库存</li>
<li>防重 可以通过 redis的SETNX → 用 <strong><u>Token + 商品URL</u></strong> &#x2F;&#x2F; <strong><u>IP + 商品URL</u></strong> 只能有一个有效</li>
<li>分布式锁保证请求的原子性 → Redisson的分布式锁</li>
</ul>
<p>**Ⅴ. 数据库 — 读写分离 **</p>
<ul>
<li>数据量很大就分库分表</li>
</ul>
<blockquote>
<h4 id="✅-一张图理清：秒杀系统全链路优化流程"><a href="#✅-一张图理清：秒杀系统全链路优化流程" class="headerlink" title="✅ 一张图理清：秒杀系统全链路优化流程"></a>✅ 一张图理清：秒杀系统全链路优化流程</h4><pre><code class="java"> [用户点击秒杀按钮]
        ↓
   【前端防刷】
      - 限制频繁点击
      - 滑动验证码
      - 倒计时、按钮控制
        ↓
   【网关 &amp; Nginx】
      - 黑名单拦截（IP、UA）
      - Sentinel 限流 + 降级 + 熔断
        ↓
   【秒杀服务】
      - 判断秒杀状态、时间、库存是否存在
      - 生成秒杀Token（防重）
      - Redis 原子性扣减库存（Lua脚本）
      - 发送下单消息至 MQ 异步处理
        ↓
   【MQ异步削峰】
      - 持久化队列（RocketMQ / Kafka）
      - 消费者异步落库
        ↓
   【数据库层】
      - MySQL最终扣减库存 + 创建订单（事务）
      - 数据库读写分离 / 分库分表
</code></pre>
<h2 id="🧩-各模块详细优化方案"><a href="#🧩-各模块详细优化方案" class="headerlink" title="🧩 各模块详细优化方案"></a>🧩 <strong>各模块详细优化方案</strong></h2><h3 id="①-前端层（第一道防线）"><a href="#①-前端层（第一道防线）" class="headerlink" title="① 前端层（第一道防线）"></a>① 前端层（第一道防线）</h3><ul>
<li><p>✅ <strong>活动页静态化</strong>：部署在 CDN，秒开页面，减少服务器并发压力。</p>
<blockquote>
<p><strong>CDN域名</strong>是指通过内容分发网络（CDN）技术加速访问的域名。CDN的全称是<strong>Content Delivery Network</strong>，即内容分发网络。它通过将源站内容分发到分布在全球各地的加速节点，使用户可以从离自己最近的节点获取内容，从而提升访问速度和体验。</p>
<p>CDN域名的工作原理是将用户的访问请求通过DNS解析，指向最优的CDN节点。如果节点上已有缓存内容，则直接返回给用户；如果没有缓存，则从源站拉取内容并缓存到节点，供后续用户访问。</p>
</blockquote>
</li>
<li><p>✅ <strong>JS 控制按钮状态</strong>：倒计时期间按钮禁用；点击后立即禁用防止重复提交。</p>
</li>
<li><p>✅ <strong>防刷机制</strong>：</p>
<ul>
<li>滑动验证码（极验、腾讯滑动等）</li>
<li>限制频繁请求（客户端节流 + 后端拦截）</li>
<li>秒杀路径动态化（通过接口获取临时随机URL）</li>
</ul>
</li>
</ul>
<h3 id="②-网关层（第二道防线）"><a href="#②-网关层（第二道防线）" class="headerlink" title="② 网关层（第二道防线）"></a>② 网关层（第二道防线）</h3><ul>
<li>✅ <strong>Nginx限流</strong> + F5&#x2F;LVS 硬件负载均衡</li>
<li>✅ <strong>Sentinel限流</strong>：<ul>
<li>QPS限流、线程数限制</li>
<li>降级策略（服务不稳定时快速失败）</li>
</ul>
</li>
<li>✅ <strong>灰度发布</strong> + 金丝雀策略防雪崩</li>
</ul>
<h3 id="③-服务层（核心逻辑）"><a href="#③-服务层（核心逻辑）" class="headerlink" title="③ 服务层（核心逻辑）"></a>③ 服务层（核心逻辑）</h3><ul>
<li>✅ <strong>Redis预热商品库存</strong>：<ul>
<li><code>key: seckill:stock:123 =&gt; 10</code></li>
</ul>
</li>
<li>✅ <strong>Lua脚本保证扣减原子性</strong></li>
</ul>
<pre><code class="java">if redis.call(&quot;get&quot;, KEYS[1]) &gt;= tonumber(ARGV[1]) then
   return redis.call(&quot;decrby&quot;, KEYS[1], ARGV[1])
else
   return -1
end
</code></pre>
<ul>
<li>✅ <strong>Token校验防重</strong>（防止同一用户多次提交）<ul>
<li>用户下发秒杀Token</li>
<li>下单时校验 token 是否存在</li>
</ul>
</li>
<li>✅ <strong>幂等性处理</strong>：幂等令牌、Redis标记等手段防止重复下单</li>
<li>✅ <strong>Redisson分布式锁</strong>（用于控制某些全局状态，如每秒限量）</li>
</ul>
<h3 id="④-MQ-消息队列层（削峰填谷）"><a href="#④-MQ-消息队列层（削峰填谷）" class="headerlink" title="④ MQ 消息队列层（削峰填谷）"></a>④ MQ 消息队列层（削峰填谷）</h3><ul>
<li>✅ 典型架构：RocketMQ &#x2F; RabbitMQ &#x2F; Kafka</li>
<li>✅ 一进一出，异步下单逻辑<ul>
<li>消息格式：包含<code>userId</code>, <code>productId</code>, <code>token</code></li>
</ul>
</li>
<li>✅ 消息失败怎么办？<ul>
<li><strong>死信队列</strong> + 重试机制 + 日志报警</li>
</ul>
</li>
</ul>
<h3 id="⑤-数据库层（最终一致性）"><a href="#⑤-数据库层（最终一致性）" class="headerlink" title="⑤ 数据库层（最终一致性）"></a>⑤ 数据库层（最终一致性）</h3><ul>
<li>✅ <strong>分库分表</strong>：<ul>
<li>订单表按用户ID或时间范围分表</li>
<li>库存表按商品类型分表</li>
</ul>
</li>
<li>✅ <strong>读写分离</strong>：<ul>
<li>MySQL主从复制</li>
<li>下单写入主库，查询走从库</li>
</ul>
</li>
<li>✅ <strong>事务处理</strong>：<ul>
<li>扣库存 + 创建订单需要事务包裹</li>
</ul>
</li>
<li>✅ <strong>补偿机制</strong>：<ul>
<li>MQ失败回滚机制 + 自动重试 or 人工介入</li>
</ul>
</li>
</ul>
<h2 id="🎯-秒杀系统关键点总结（重点记忆）"><a href="#🎯-秒杀系统关键点总结（重点记忆）" class="headerlink" title="🎯 秒杀系统关键点总结（重点记忆）"></a>🎯 秒杀系统关键点总结（重点记忆）</h2><table>
<thead>
<tr>
<th>优化维度</th>
<th>关键点</th>
</tr>
</thead>
<tbody><tr>
<td>防刷防作弊</td>
<td>滑动验证码、动态路径、限流、IP黑名单</td>
</tr>
<tr>
<td>限流削峰</td>
<td>Sentinel、MQ异步下单、排队</td>
</tr>
<tr>
<td>高性能扣减</td>
<td>Redis + Lua 脚本，原子扣减库存</td>
</tr>
<tr>
<td>数据一致性</td>
<td>MQ消息可靠投递、事务补偿机制</td>
</tr>
<tr>
<td>分布式扩展</td>
<td>分库分表、读写分离、动态扩容</td>
</tr>
<tr>
<td>安全性</td>
<td>Token校验、防重、防止超卖</td>
</tr>
</tbody></table>
<p>我将为你详细讲解和设计一个真实的<strong>秒杀系统完整优化方案</strong>，从 Redis 预热、限流、库存扣减、异步下单、订单状态回写等关键步骤一一展开说明，并配上示意代码。</p>
<hr>
<h2 id="🔧-一、整体秒杀流程概览图"><a href="#🔧-一、整体秒杀流程概览图" class="headerlink" title="🔧 一、整体秒杀流程概览图"></a>🔧 一、整体秒杀流程概览图</h2><pre><code class="java">用户请求 → 接入层限流 → Redis预扣库存（Lua脚本） → 发送MQ消息 → 异步下单 → 数据库落库 → 回写订单状态
</code></pre>
<hr>
<h2 id="🧱-二、Redis缓存预热（秒杀前的准备工作）"><a href="#🧱-二、Redis缓存预热（秒杀前的准备工作）" class="headerlink" title="🧱 二、Redis缓存预热（秒杀前的准备工作）"></a>🧱 二、Redis缓存预热（秒杀前的准备工作）</h2><blockquote>
<p>提前将商品库存加载到 Redis，避免高并发时频繁访问数据库。</p>
</blockquote>
<pre><code class="java">// Redis结构设计
// key: seckill:stock:&lt;skuId&gt;
// val: 商品库存数量

public void preloadSeckillStock(Long skuId, Integer stock) &#123;
    String key = &quot;seckill:stock:&quot; + skuId;
    redisTemplate.opsForValue().set(key, stock);
&#125;
</code></pre>
<hr>
<h2 id="🛡-三、限流-防刷-验签（接入层）"><a href="#🛡-三、限流-防刷-验签（接入层）" class="headerlink" title="🛡 三、限流 + 防刷 + 验签（接入层）"></a>🛡 三、限流 + 防刷 + 验签（接入层）</h2><blockquote>
<p>使用网关 Sentinel 限流，前端限制点击频率，后端防刷接口做风控。</p>
</blockquote>
<pre><code class="java">@GetMapping(&quot;/doSeckill&quot;)
public ResponseEntity&lt;?&gt; doSeckill(@RequestParam Long skuId) &#123;
    // 判断是否登录
    Long userId = getLoginUserId();
    
    // 判断是否重复请求（防重）
    String repeatKey = &quot;seckill:user:&quot; + userId + &quot;:sku:&quot; + skuId;
    Boolean hasBought = redisTemplate.opsForValue().setIfAbsent(repeatKey, &quot;1&quot;, 5, TimeUnit.MINUTES);
    if (!hasBought) return ResponseEntity.status(429).body(&quot;请勿重复抢购&quot;);

    // 执行扣库存的 Lua 脚本
    Long result = redisTemplate.execute(luaScript, Collections.singletonList(&quot;seckill:stock:&quot; + skuId), &quot;1&quot;);
    if (result == 0L) return ResponseEntity.status(410).body(&quot;库存不足&quot;);

    // 发送消息至 MQ 进行异步处理
    SeckillMessage msg = new SeckillMessage(userId, skuId);
    mqTemplate.convertAndSend(&quot;seckill.queue&quot;, msg);

    return ResponseEntity.ok(&quot;下单请求已提交&quot;);
&#125;
</code></pre>
<hr>
<h2 id="📜-四、Lua脚本操作-Redis（保证原子性）"><a href="#📜-四、Lua脚本操作-Redis（保证原子性）" class="headerlink" title="📜 四、Lua脚本操作 Redis（保证原子性）"></a>📜 四、Lua脚本操作 Redis（保证原子性）</h2><pre><code class="java">-- KEYS[1]: 库存key
-- ARGV[1]: 扣减数量
local stock = redis.call(&quot;get&quot;, KEYS[1])
if tonumber(stock) &gt;= tonumber(ARGV[1]) then
    return redis.call(&quot;decrby&quot;, KEYS[1], ARGV[1])
end
return 0
</code></pre>
<hr>
<h2 id="📦-五、MQ异步消费-创建订单（核心业务）"><a href="#📦-五、MQ异步消费-创建订单（核心业务）" class="headerlink" title="📦 五、MQ异步消费 + 创建订单（核心业务）"></a>📦 五、MQ异步消费 + 创建订单（核心业务）</h2><blockquote>
<p>用 RabbitMQ、RocketMQ、Kafka 等异步落库下单，减轻主线程压力。</p>
</blockquote>
<pre><code class="java">@RabbitListener(queues = &quot;seckill.queue&quot;)
public void handleSeckill(SeckillMessage msg) &#123;
    Long userId = msg.getUserId();
    Long skuId = msg.getSkuId();

    // 检查数据库是否已下单（防止重复下单）
    boolean exists = orderMapper.existsByUserAndSku(userId, skuId);
    if (exists) return;

    // 创建订单
    Order order = new Order();
    order.setUserId(userId);
    order.setSkuId(skuId);
    order.setStatus(&quot;WAIT_PAY&quot;);
    orderMapper.insert(order);
&#125;
</code></pre>
<hr>
<h2 id="🧨-六、下单后定时关闭未支付订单（延迟消息）"><a href="#🧨-六、下单后定时关闭未支付订单（延迟消息）" class="headerlink" title="🧨 六、下单后定时关闭未支付订单（延迟消息）"></a>🧨 六、下单后定时关闭未支付订单（延迟消息）</h2><blockquote>
<p>利用 RabbitMQ 的延迟队列（或用 Redis 的 ZSet+定时任务轮询）。</p>
</blockquote>
<pre><code class="java">// 下单后发送延迟消息
rabbitTemplate.convertAndSend(&quot;order.ttl.exchange&quot;, &quot;order.ttl&quot;, orderId);

// 死信队列处理超时未支付订单
@RabbitListener(queues = &quot;order.dlx.queue&quot;)
public void closeOrder(String orderId) &#123;
    Order order = orderMapper.selectById(orderId);
    if (&quot;WAIT_PAY&quot;.equals(order.getStatus())) &#123;
        order.setStatus(&quot;CLOSED&quot;);
        orderMapper.updateById(order);

        // 回滚库存
        redisTemplate.opsForValue().increment(&quot;seckill:stock:&quot; + order.getSkuId());
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="📊-七、数据一致性考虑"><a href="#📊-七、数据一致性考虑" class="headerlink" title="📊 七、数据一致性考虑"></a>📊 七、数据一致性考虑</h2><table>
<thead>
<tr>
<th>场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>Redis库存扣减成功但消息发送失败</td>
<td>使用本地事务 + MQ事务消息机制</td>
</tr>
<tr>
<td>订单超时未支付但库存没回滚</td>
<td>MQ死信队列 + 回滚库存</td>
</tr>
<tr>
<td>秒杀重复下单</td>
<td>Redis防重 + DB唯一约束</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-八、技术选型建议"><a href="#✅-八、技术选型建议" class="headerlink" title="✅ 八、技术选型建议"></a>✅ 八、技术选型建议</h2><table>
<thead>
<tr>
<th>模块</th>
<th>技术</th>
</tr>
</thead>
<tbody><tr>
<td>缓存</td>
<td>Redis</td>
</tr>
<tr>
<td>消息队列</td>
<td>RabbitMQ&#x2F;RocketMQ</td>
</tr>
<tr>
<td>限流防刷</td>
<td>Sentinel、滑动窗口</td>
</tr>
<tr>
<td>延迟任务</td>
<td>MQ延迟队列、定时任务轮询</td>
</tr>
<tr>
<td>锁</td>
<td>Redisson 分布式锁</td>
</tr>
<tr>
<td>脚本原子性</td>
<td>Lua脚本</td>
</tr>
</tbody></table>
<hr>
<hr>
<h4 id="你说的很好-我想更进一步了解一下-你说的-Nginx限流-F5-x2F-LVS硬件负载均衡；网关-amp-nginx黑名单拦截-IP、UA-；生成秒杀Token；灰度发布-金丝雀策略"><a href="#你说的很好-我想更进一步了解一下-你说的-Nginx限流-F5-x2F-LVS硬件负载均衡；网关-amp-nginx黑名单拦截-IP、UA-；生成秒杀Token；灰度发布-金丝雀策略" class="headerlink" title="你说的很好 我想更进一步了解一下 你说的 Nginx限流+F5&#x2F;LVS硬件负载均衡；网关&amp;nginx黑名单拦截(IP、UA)；生成秒杀Token；灰度发布+金丝雀策略"></a>你说的很好 我想更进一步了解一下 你说的 Nginx限流+F5&#x2F;LVS硬件负载均衡；网关&amp;nginx黑名单拦截(IP、UA)；生成秒杀Token；灰度发布+金丝雀策略</h4><h2 id="✅-一、Nginx-限流-F5-x2F-LVS-硬件负载均衡"><a href="#✅-一、Nginx-限流-F5-x2F-LVS-硬件负载均衡" class="headerlink" title="✅ 一、Nginx 限流 + F5&#x2F;LVS 硬件负载均衡"></a>✅ 一、Nginx 限流 + F5&#x2F;LVS 硬件负载均衡</h2><h3 id="1-Nginx-限流"><a href="#1-Nginx-限流" class="headerlink" title="1. Nginx 限流"></a>1. Nginx 限流</h3><h4 id="✨目的："><a href="#✨目的：" class="headerlink" title="✨目的："></a>✨目的：</h4><ul>
<li>限制单位时间的请求数，防止恶意刷接口、瞬间高并发导致服务崩溃。</li>
</ul>
<h4 id="✨配置方式："><a href="#✨配置方式：" class="headerlink" title="✨配置方式："></a>✨配置方式：</h4><pre><code>http &#123;
    limit_req_zone $binary_remote_addr zone=req_limit_per_ip:10m rate=1r/s;
    ...
    server &#123;
        location /seckill &#123;
            limit_req zone=req_limit_per_ip burst=5 nodelay;
            proxy_pass http://seckill-server;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul>
<li><code>rate=1r/s</code>：每秒允许一个请求。</li>
<li><code>burst=5</code>：允许瞬间突发5个请求。</li>
<li><code>nodelay</code>：立即处理突发请求，不排队。</li>
</ul>
<h4 id="✅应用场景："><a href="#✅应用场景：" class="headerlink" title="✅应用场景："></a>✅应用场景：</h4><ul>
<li>秒杀接口、登录接口、验证码接口等敏感接口的访问频控。</li>
</ul>
<hr>
<h3 id="2-F5-x2F-LVS-硬件负载均衡"><a href="#2-F5-x2F-LVS-硬件负载均衡" class="headerlink" title="2. F5 &#x2F; LVS 硬件负载均衡"></a>2. F5 &#x2F; LVS 硬件负载均衡</h3><h4 id="✨作用："><a href="#✨作用：" class="headerlink" title="✨作用："></a>✨作用：</h4><ul>
<li>F5&#x2F;LVS 作为物理网络设备层面的高性能负载均衡系统，位于企业最外层（防火墙之后，Nginx之前），进行<strong>四层(TCP&#x2F;UDP)转发</strong>，性能远高于 Nginx。</li>
</ul>
<h4 id="✅典型架构："><a href="#✅典型架构：" class="headerlink" title="✅典型架构："></a>✅典型架构：</h4><pre><code>markdown复制编辑             用户请求
                 ↓
       ┌────────────────┐
       │  F5 / LVS  (L4)│
       └────────────────┘
                 ↓
       ┌────────────────┐
       │   Nginx (L7)    │
       └────────────────┘
                 ↓
            应用服务层
</code></pre>
<h4 id="✅优势："><a href="#✅优势：" class="headerlink" title="✅优势："></a>✅优势：</h4><ul>
<li>性能高、吞吐量大（每秒几十万 QPS）。</li>
<li>更稳定，更适合企业级大并发业务。</li>
<li>通常和 Nginx 搭配使用，分别处理 L4 &#x2F; L7 流量调度。</li>
</ul>
<hr>
<h2 id="✅-二、网关-amp-Nginx-黑名单拦截（IP-x2F-UA）"><a href="#✅-二、网关-amp-Nginx-黑名单拦截（IP-x2F-UA）" class="headerlink" title="✅ 二、网关 &amp; Nginx 黑名单拦截（IP&#x2F;UA）"></a>✅ 二、网关 &amp; Nginx 黑名单拦截（IP&#x2F;UA）</h2><h3 id="✅-目标："><a href="#✅-目标：" class="headerlink" title="✅ 目标："></a>✅ 目标：</h3><p>防止恶意攻击、秒杀脚本、爬虫工具参与秒杀。</p>
<h3 id="1-拦截策略"><a href="#1-拦截策略" class="headerlink" title="1. 拦截策略"></a>1. 拦截策略</h3><ul>
<li><strong>IP 黑白名单</strong>：将恶意访问源加入黑名单。</li>
<li><strong>UA 校验</strong>：不允许 curl、httpclient、python 等工具模拟请求。</li>
<li><strong>访问频率统计</strong>：单位时间内访问频率超过阈值即封禁。</li>
</ul>
<h3 id="2-网关层实现（如-SpringCloud-Gateway）"><a href="#2-网关层实现（如-SpringCloud-Gateway）" class="headerlink" title="2. 网关层实现（如 SpringCloud Gateway）"></a>2. 网关层实现（如 SpringCloud Gateway）</h3><pre><code class="java">// 伪代码：过滤器中处理
if (blackList.contains(ip) || suspiciousUA(ua)) &#123;
    return 403 Forbidden;
&#125;
</code></pre>
<hr>
<h2 id="✅-三、生成秒杀Token（防黄牛、刷请求）"><a href="#✅-三、生成秒杀Token（防黄牛、刷请求）" class="headerlink" title="✅ 三、生成秒杀Token（防黄牛、刷请求）"></a>✅ 三、生成秒杀Token（防黄牛、刷请求）</h2><h3 id="✅-核心思想："><a href="#✅-核心思想：" class="headerlink" title="✅ 核心思想："></a>✅ 核心思想：</h3><p><strong>用户先请求一个随机 Token，再带着这个 Token 才能参与秒杀，且只能用一次</strong>。</p>
<h3 id="✅-实现流程："><a href="#✅-实现流程：" class="headerlink" title="✅ 实现流程："></a>✅ 实现流程：</h3><h4 id="🔁-第一步：获取秒杀Token"><a href="#🔁-第一步：获取秒杀Token" class="headerlink" title="🔁 第一步：获取秒杀Token"></a>🔁 第一步：获取秒杀Token</h4><pre><code class="javascript">GET /seckill/token?productId=123
Header: Authorization: Bearer 用户登录Token
</code></pre>
<p>返回：</p>
<pre><code class="java">&#123; &quot;token&quot;: &quot;a8729f03-6a22-4cdb-8ad4-e19932cf&quot; &#125;
</code></pre>
<blockquote>
<p>Redis 存储 token → <code>seckill:token:uid:productId -&gt; token</code></p>
</blockquote>
<h4 id="🏃-第二步：用户秒杀请求带上Token"><a href="#🏃-第二步：用户秒杀请求带上Token" class="headerlink" title="🏃 第二步：用户秒杀请求带上Token"></a>🏃 第二步：用户秒杀请求带上Token</h4><pre><code class="java">POST /seckill/submit
Body: &#123; productId: 123, token: &quot;a8729f03-6a22-4cdb-8ad4-e19932cf&quot; &#125;
</code></pre>
<h4 id="✅-服务端校验："><a href="#✅-服务端校验：" class="headerlink" title="✅ 服务端校验："></a>✅ 服务端校验：</h4><ul>
<li>token是否存在；</li>
<li>token是否属于当前用户；</li>
<li>校验通过后删除 token（一次性）；</li>
<li>进入库存扣减逻辑。</li>
</ul>
<hr>
<h2 id="✅-四、灰度发布-金丝雀策略（保障系统稳定性）"><a href="#✅-四、灰度发布-金丝雀策略（保障系统稳定性）" class="headerlink" title="✅ 四、灰度发布 + 金丝雀策略（保障系统稳定性）"></a>✅ 四、灰度发布 + 金丝雀策略（保障系统稳定性）</h2><h3 id="✅-区别："><a href="#✅-区别：" class="headerlink" title="✅ 区别："></a>✅ 区别：</h3><table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>灰度发布</td>
<td>指在小范围（如某些用户&#x2F;机器）上逐步发布新功能</td>
</tr>
<tr>
<td>金丝雀发布</td>
<td>类似灰度，但更强调监控与回滚能力</td>
</tr>
</tbody></table>
<hr>
<h3 id="✅-示例：-1"><a href="#✅-示例：-1" class="headerlink" title="✅ 示例："></a>✅ 示例：</h3><h4 id="1-灰度规则："><a href="#1-灰度规则：" class="headerlink" title="1. 灰度规则："></a>1. 灰度规则：</h4><ul>
<li>仅对北京地区、特定用户ID段、Android设备开放新功能；</li>
<li>灰度用户看到的是新接口，其他人访问旧接口。</li>
</ul>
<h4 id="2-实现方式："><a href="#2-实现方式：" class="headerlink" title="2. 实现方式："></a>2. 实现方式：</h4><ul>
<li>在网关中增加灰度判断逻辑，如基于用户ID、设备类型、地理位置等维度；</li>
<li>配合 Nacos &#x2F; Apollo 实现灰度配置动态下发。</li>
</ul>
<pre><code class="java">if (grayUser(userId)) &#123;
    routeTo(newServiceV2);
&#125; else &#123;
    routeTo(oldServiceV1);
&#125;
</code></pre>
<h4 id="3-金丝雀监控："><a href="#3-金丝雀监控：" class="headerlink" title="3. 金丝雀监控："></a>3. 金丝雀监控：</h4><ul>
<li>接入 Prometheus + Grafana；</li>
<li>实时监控新版本的接口成功率、响应时间、异常率；</li>
<li>若指标异常，立即自动或手动回滚。</li>
</ul>
<hr>
<h2 id="🧠-总结：秒杀防护层层递进"><a href="#🧠-总结：秒杀防护层层递进" class="headerlink" title="🧠 总结：秒杀防护层层递进"></a>🧠 总结：秒杀防护层层递进</h2><table>
<thead>
<tr>
<th>层级</th>
<th>技术 &#x2F; 策略</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>网络层</td>
<td>F5&#x2F;LVS、Nginx限流</td>
<td>硬抗高并发</td>
</tr>
<tr>
<td>网关层</td>
<td>黑名单拦截、UA过滤、灰度&#x2F;金丝雀</td>
<td>防刷 + 风控</td>
</tr>
<tr>
<td>应用层</td>
<td>秒杀Token、验证码、人机校验</td>
<td>精准控制用户行为</td>
</tr>
<tr>
<td>缓存层</td>
<td>Redis库存控制、Lua原子操作、布隆过滤器</td>
<td>高性能、数据一致</td>
</tr>
<tr>
<td>后端层</td>
<td>MQ异步削峰、数据库分库分表</td>
<td>解耦 + 弹性架构</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>订单超时自动取消是怎么实现的？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/743d8b7cd78b5a1fe4023554fee8d62726435cb2/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88.png"></p>
<h5 id="①-JDK自带的延时队列"><a href="#①-JDK自带的延时队列" class="headerlink" title="① JDK自带的延时队列"></a>① JDK自带的延时队列</h5><p><strong>优点</strong>：简单，不需要借助其他第三方组件，成本低。<br><strong>缺点</strong>：所有超时处理订单都要加入到<code>DelayQueue</code>中，占用内存大，没办法做到分布式处理，之恶能在集群中挑选一台leader专门处理，效率低<br>不适合订单量比较大的</p>
<h5 id="②-基于RocketMQ的定时消息-—-延时消息"><a href="#②-基于RocketMQ的定时消息-—-延时消息" class="headerlink" title="② 基于RocketMQ的定时消息 — 延时消息"></a>② 基于RocketMQ的定时消息 — 延时消息</h5><p><strong>优点</strong>：使用简单，和使用普通消息一样，支持分布式。精度高，支持任意时刻</p>
<p><strong>缺点</strong>：<strong>使用限制</strong>：定时时长最大值24小时。<br><strong>成本高</strong>：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。<br>同一个时刻大量消息会导致<u>消息延迟:</u>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p>
<h5 id="③-基于Redis的过期监听"><a href="#③-基于Redis的过期监听" class="headerlink" title="③ 基于Redis的过期监听"></a>③ 基于Redis的过期监听</h5><p>设置过期时间：24小时内没有支付就会自动取消<br><strong>缺点</strong>：(也是所有中间件的缺点)</p>
<ul>
<li>不可靠 Redis在过期通知的时候，如果应用<strong>正好重启了</strong>，那么就有可能<strong>通知事件就丢了，会导致订单一直无法关闭</strong>，有稳定性问题。如果一定要使用Redis过期监听方案，建议再通过定时任务做补偿机制。</li>
<li>如果订单量大需要占用中间件大量的存储空间，需要额外维护成本。</li>
</ul>
<h5 id="④-定时任务分布式处理【要按照成本思维的思考方式】"><a href="#④-定时任务分布式处理【要按照成本思维的思考方式】" class="headerlink" title="④ 定时任务分布式处理【要按照成本思维的思考方式】"></a>④ 定时任务分布式处理【要按照成本思维的思考方式】</h5><p>通过定时任务(任务调度)的批量处理 → 一次性把所有超时的订单全部捞出来 处理完再全部执行更新<br>如果使用中间件都要单独存储那些数据，如果存储压力大就要涉及到集群</p>
<blockquote>
<p>如果对于超时精度比较高，超时时间在24小时内，且不会有峰值压力的场景下，推荐使用RocketMQ的定时消息解决方案<br>在电商业务下，许多订单超时场景都在24小时以上，对于超时精度没那么敏感，并且有海量订单需要批处理，推荐使用基于定时任务的<strong>跑批</strong>解决方案。</p>
</blockquote>
<blockquote>
<h2 id="✅-最佳实践对比表"><a href="#✅-最佳实践对比表" class="headerlink" title="✅ 最佳实践对比表"></a>✅ 最佳实践对比表</h2><table>
<thead>
<tr>
<th>方案</th>
<th>分布式支持</th>
<th>精度</th>
<th>可靠性</th>
<th>适用场景</th>
<th>优缺点总结</th>
</tr>
</thead>
<tbody><tr>
<td>DelayQueue</td>
<td>❌ 否</td>
<td>秒级</td>
<td>❌ 低</td>
<td>单体项目&#x2F;小订单量</td>
<td>简单、无需中间件，但不支持分布式和高可用</td>
</tr>
<tr>
<td>RocketMQ延时消息</td>
<td>✅ 是</td>
<td>秒级</td>
<td>✅ 高</td>
<td>秒杀、限时抢购、延迟关闭等</td>
<td>精度高、支持分布式，但时长限制 &amp; 消息堆积</td>
</tr>
<tr>
<td>Redis过期监听</td>
<td>✅ 是</td>
<td>秒级</td>
<td>❌ 较低</td>
<td>轻量业务、有兜底机制的场景</td>
<td>实时、方便，但事件容易丢失，不适合重要任务</td>
</tr>
<tr>
<td>定时任务跑批</td>
<td>✅ 是</td>
<td>分钟级</td>
<td>✅ 高</td>
<td>电商订单系统、大量订单处理</td>
<td>稳定、灵活、适合大业务，容忍分钟级延迟</td>
</tr>
</tbody></table>
<h2 id="🔄-常见混合策略推荐"><a href="#🔄-常见混合策略推荐" class="headerlink" title="🔄 常见混合策略推荐"></a>🔄 常见混合策略推荐</h2><ul>
<li><strong>秒杀业务 &#x2F; 限时订单</strong>：RocketMQ 延时消息为主 + 补偿机制（定时任务兜底）</li>
<li><strong>电商平台</strong>：定时任务跑批为主 + MQ 异步通知用户（取消成功推送）</li>
<li><strong>轻量小应用</strong>：Redis 过期监听 + 手动补偿兜底</li>
<li><strong>单体项目或demo</strong>：DelayQueue 简单可用</li>
</ul>
<h2 id="🧠-思考：为什么不用-cron-来做？"><a href="#🧠-思考：为什么不用-cron-来做？" class="headerlink" title="🧠 思考：为什么不用 cron 来做？"></a>🧠 思考：为什么不用 cron 来做？</h2><blockquote>
<p>cron 固定执行时间点，而订单创建是动态的，<strong>无法精确知道每个订单的30分钟是哪一刻。</strong></p>
</blockquote>
<p>举例：</p>
<ul>
<li>cron表达式只能写 <code>每隔5分钟扫描</code> 或 <code>每天0点执行</code></li>
<li>订单创建时间是不确定的 → <strong>用cron不能实时取消30分钟后的每个订单</strong></li>
</ul>
<p>所以，动态调度任务（MQ&#x2F;DelayQueue）或带参数处理（定时扫描数据库）更合适。</p>
</blockquote>
<p><span style = "color:red"><strong>如何防止重复下单？</strong></span></p>
<h5 id="方案一：提交订单按钮置灰-防止用户无意点击多次"><a href="#方案一：提交订单按钮置灰-防止用户无意点击多次" class="headerlink" title="方案一：提交订单按钮置灰 [防止用户无意点击多次]"></a>方案一：提交订单按钮置灰 [防止用户无意点击多次]</h5><h5 id="方案二：后端采用redis的setnx-来保证它的唯一幂等性"><a href="#方案二：后端采用redis的setnx-来保证它的唯一幂等性" class="headerlink" title="方案二：后端采用redis的setnx 来保证它的唯一幂等性"></a>方案二：后端采用redis的<span style = "color:red">setnx</span> 来保证它的唯一幂等性</h5><p>setnx：当我们调用setnx来去保存一个key和value的时候，如果这个value没有值的话，那么就会返回<strong>true</strong>保存成功；如果有值就会返回<strong>false</strong> → 保证多次存储只能存储一个值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be8debbe9711d790569ea62e3954dca9e6f2937b/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95.png"></p>
<blockquote>
<h4 id="业务幂等号（如唯一Token机制）"><a href="#业务幂等号（如唯一Token机制）" class="headerlink" title="业务幂等号（如唯一Token机制）"></a>业务幂等号（如唯一Token机制）</h4><ul>
<li>用户点击下单前，后端下发一个<code>token</code>（存 Redis），用户下单时带上这个 token。</li>
<li>后端验证 token 是否存在，使用后即删除。</li>
</ul>
<pre><code class="java">// 伪代码
if (redisToken == null || !redisToken.equals(requestToken)) &#123;
    throw new RuntimeException(&quot;重复请求或非法请求&quot;);
&#125;
redisTemplate.delete(redisToken);
</code></pre>
<blockquote>
<p>✅ 优点：</p>
<ul>
<li>通用幂等机制，不局限订单；</li>
<li>可防止表单重复提交、支付回调重复通知等场景；</li>
</ul>
<p>✅ 使用场景：</p>
<ul>
<li>秒杀下单、提交表单、支付回调。</li>
</ul>
</blockquote>
<hr>
<h4 id="🔐-方案四：消息队列去重（异步场景）"><a href="#🔐-方案四：消息队列去重（异步场景）" class="headerlink" title="🔐 方案四：消息队列去重（异步场景）"></a>🔐 方案四：消息队列去重（异步场景）</h4><ul>
<li>使用 RocketMQ 的幂等机制，确保同一消息只消费一次（消费端做去重处理），适用于下单流程是异步的情况。</li>
</ul>
<hr>
<h3 id="✅-三、多手段组合更安全"><a href="#✅-三、多手段组合更安全" class="headerlink" title="✅ 三、多手段组合更安全"></a>✅ <strong>三、多手段组合更安全</strong></h3><table>
<thead>
<tr>
<th>层级</th>
<th>技术手段</th>
<th>是否强制</th>
</tr>
</thead>
<tbody><tr>
<td>前端</td>
<td>按钮置灰&#x2F;节流</td>
<td>否</td>
</tr>
<tr>
<td>应用层</td>
<td>Redis + setnx 或 Token</td>
<td>是</td>
</tr>
<tr>
<td>数据层</td>
<td>唯一约束字段</td>
<td>是</td>
</tr>
<tr>
<td>异步处理</td>
<td>MQ消费幂等处理</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="📌-典型实践示意图："><a href="#📌-典型实践示意图：" class="headerlink" title="📌 典型实践示意图："></a>📌 典型实践示意图：</h3><ul>
<li><strong>用户点击下单</strong> ➜ <strong>获取唯一Token&#x2F;Redis锁</strong> ➜ <strong>请求成功后释放</strong> ➜ <strong>写入订单表时校验唯一性</strong>。</li>
</ul>
<hr>
<h3 id="💡-小贴士："><a href="#💡-小贴士：" class="headerlink" title="💡 小贴士："></a>💡 小贴士：</h3><ul>
<li>并发高推荐：<strong>Redis方案（+Redisson分布式锁）</strong></li>
<li>最后兜底：<strong>数据库唯一索引</strong></li>
<li>支付类、接口幂等推荐：<strong>Token机制</strong></li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>怎么防止刷单？【人肉机刷单！！】</strong></span></p>
<h5 id="业务风控"><a href="#业务风控" class="headerlink" title="业务风控"></a>业务风控</h5><p>提高羊毛门槛：实名认证、消费门槛、随机优惠<br>限制用户参与、中奖、奖励次数<br>根据用户的历史行为和忠诚度，提供不同层次的优惠，优待忠实用户<br>奖池(优惠券数量)限制上限</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3850683ae318970983834aa03ac35168bbf52a8/%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E4%BA%BA%E8%82%89%E5%88%B7%E5%8D%95%EF%BC%9F.png"></p>
<p><span style="color:red"><strong>分布式集群架构下怎么保证并发安全？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/48788978d525bf16e52bb10180e63022de6a5ea3/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E4%B8%8B%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8.png"></p>
<blockquote>
<h3 id="✅-一、为什么分布式架构下更容易出现并发问题？"><a href="#✅-一、为什么分布式架构下更容易出现并发问题？" class="headerlink" title="✅ 一、为什么分布式架构下更容易出现并发问题？"></a>✅ 一、为什么分布式架构下更容易出现并发问题？</h3><p>在单体应用中，所有请求在同一个进程内处理，天然可以用<code>synchronized</code>等方式控制并发。</p>
<p>而在<strong>分布式集群架构</strong>中：</p>
<ul>
<li>请求会打到多个节点 → 本地锁失效</li>
<li>数据可能分库分表 → 数据不在一个数据库</li>
<li>多线程 + 多机器 + 多服务 → 并发成倍放大</li>
</ul>
<p>所以需要一整套<strong>分布式并发安全</strong>解决方案。</p>
<h3 id="✅-二、并发安全常见场景"><a href="#✅-二、并发安全常见场景" class="headerlink" title="✅ 二、并发安全常见场景"></a>✅ 二、并发安全常见场景</h3><ul>
<li>秒杀&#x2F;抢购：多个用户同时抢一件商品</li>
<li>下单：防止重复下单、超卖</li>
<li>支付：防止重复支付</li>
<li>分布式调度：防止定时任务重复执行</li>
<li>分布式ID生成：避免重复ID</li>
</ul>
<h3 id="✅-三、总结：解决并发的“组合拳”"><a href="#✅-三、总结：解决并发的“组合拳”" class="headerlink" title="✅ 三、总结：解决并发的“组合拳”"></a>✅ 三、总结：解决并发的“组合拳”</h3><table>
<thead>
<tr>
<th>组件&#x2F;策略</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>Redis分布式锁</td>
<td>跨节点并发控制，控制共享资源</td>
</tr>
<tr>
<td>乐观锁（version）</td>
<td>控制数据库并发更新冲突</td>
</tr>
<tr>
<td>消息队列MQ</td>
<td>异步削峰，提高系统吞吐</td>
</tr>
<tr>
<td>唯一Token机制</td>
<td>防止重复提交</td>
</tr>
<tr>
<td>限流 &amp; 黑名单机制</td>
<td>拦截恶意请求，保护系统</td>
</tr>
<tr>
<td>本地+分布式缓存</td>
<td>缓解数据库压力，提高响应速度</td>
</tr>
<tr>
<td>灰度发布</td>
<td>降低风险，平稳上线</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>让你设计一个扫码登录怎么实现？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b3bbc19e0da554166000933c31bf749e2f6d3313/%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.png"></p>
<h6 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h6><p>请求登录页生成二维码，PC端请求后端生成一个二维码，此时在后端就会生成一个全局唯一的二维码ID，主要保存二维码的状态[二维码ID, NEW]，状态设置到Redis设置过期时间，然后把当前的二维码ID返回给前端，然后生成二维码 【前后端都可以生成 → 返回Base64的编码给前端】此时的二维码就绑定了用户的ID让用户扫描。</p>
<h6 id="扫码"><a href="#扫码" class="headerlink" title="扫码"></a>扫码</h6><p>PC端和后端会建立一个轮询的请求，不断的根据二维码ID去查询二维码状态，一旦状态改变页面也会改变。也可以通过长连接<strong>WebSocket</strong>获取状态 <code>淘宝用的轮询、抖音用的长连接</code>，此时就可以扫码。<br>扫码前保证手机是登录状态 没有登录肯定是不能扫码的，登录后进行扫码就会携带手机端的用户token以及二维码的ID在后端去校验请求Token，如果校验成功就代表手机可以登录，此时可以变更二维码状态为扫描。前端就可以根据这个把页面变为<code>待确认</code>状态</p>
<blockquote>
<h2 id="✅-一、整体流程概述"><a href="#✅-一、整体流程概述" class="headerlink" title="✅ 一、整体流程概述"></a>✅ 一、整体流程概述</h2><p><strong>目标：</strong> 用户在 PC 端扫码并登录系统，安全、高效、用户体验好。</p>
<p><strong>参与者：</strong></p>
<ul>
<li>PC 浏览器（Web）</li>
<li>手机 App（用户已登录）</li>
<li>后端服务（Web + API）</li>
<li>Redis（状态存储）</li>
<li>前端轮询&#x2F;长连接</li>
</ul>
<hr>
<h2 id="🧩-二、关键技术点拆解"><a href="#🧩-二、关键技术点拆解" class="headerlink" title="🧩 二、关键技术点拆解"></a>🧩 二、关键技术点拆解</h2><h3 id="1️⃣-二维码生成（PC端发起）"><a href="#1️⃣-二维码生成（PC端发起）" class="headerlink" title="1️⃣ 二维码生成（PC端发起）"></a>1️⃣ 二维码生成（PC端发起）</h3><ul>
<li>用户打开 PC 登录页面，请求后端接口 <code>/api/qr/generate</code></li>
<li>后端逻辑：<ul>
<li>生成唯一的二维码ID（一般用 UUID、Snowflake 或 Redis Incr）</li>
<li>创建二维码状态：<code>[qrCodeId: &#123;status: NEW, userId: null&#125;]</code> 存入 Redis，设置过期时间（如：3分钟）</li>
<li>把 <code>qrCodeId</code> 返回给前端（前端将其转成二维码图像）</li>
</ul>
</li>
</ul>
<p><strong>二维码状态定义：</strong></p>
<table>
<thead>
<tr>
<th>状态值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>二维码已生成，待扫码</td>
</tr>
<tr>
<td>SCANNED</td>
<td>手机已扫码，待确认</td>
</tr>
<tr>
<td>CONFIRMED</td>
<td>用户已确认登录</td>
</tr>
<tr>
<td>EXPIRED</td>
<td>二维码过期</td>
</tr>
</tbody></table>
<hr>
<h3 id="2️⃣-轮询-or-WebSocket-监听状态（PC端）"><a href="#2️⃣-轮询-or-WebSocket-监听状态（PC端）" class="headerlink" title="2️⃣ 轮询 or WebSocket 监听状态（PC端）"></a>2️⃣ 轮询 or WebSocket 监听状态（PC端）</h3><ul>
<li>前端定时调用 <code>/api/qr/status?qrCodeId=xxx</code> 或使用 WebSocket 长连接订阅状态变更。</li>
<li>后端通过 Redis 获取二维码状态，响应当前状态值给前端；</li>
<li>前端根据状态更新 UI：<ul>
<li><code>NEW</code>：显示二维码提示扫码</li>
<li><code>SCANNED</code>：显示“请确认登录”</li>
<li><code>CONFIRMED</code>：跳转系统首页</li>
<li><code>EXPIRED</code>：提示“二维码已失效”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣-手机扫码（App-端发起）"><a href="#3️⃣-手机扫码（App-端发起）" class="headerlink" title="3️⃣ 手机扫码（App 端发起）"></a>3️⃣ 手机扫码（App 端发起）</h3><ul>
<li>用户打开手机 App，扫码得到 <code>qrCodeId</code></li>
<li>App 发起请求 <code>/api/qr/scan</code>，携带：<ul>
<li><code>qrCodeId</code></li>
<li>当前用户登录 Token（说明谁在扫码）</li>
</ul>
</li>
<li>后端校验 Token 合法性 + 校验二维码状态是否是 <code>NEW</code></li>
<li>如果校验通过：<ul>
<li>更新 Redis 状态为 <code>SCANNED</code></li>
<li>保存扫码用户ID（用于确认登录）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4️⃣-手机端确认登录（App-端）"><a href="#4️⃣-手机端确认登录（App-端）" class="headerlink" title="4️⃣ 手机端确认登录（App 端）"></a>4️⃣ 手机端确认登录（App 端）</h3><ul>
<li>用户点击“确认登录”按钮，App 发起请求 <code>/api/qr/confirm</code></li>
<li>后端再次校验 Token、状态、qrCodeId</li>
<li>如果合法：<ul>
<li>更新 Redis 状态为 <code>CONFIRMED</code></li>
<li>后端为 PC 端生成登录凭证（JWT 或 Session ID）</li>
<li>可以将 token 写入 Redis，让 PC 端后续使用</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5️⃣-PC端轮询到-CONFIRMED-状态后"><a href="#5️⃣-PC端轮询到-CONFIRMED-状态后" class="headerlink" title="5️⃣ PC端轮询到 CONFIRMED 状态后"></a>5️⃣ PC端轮询到 CONFIRMED 状态后</h3><ul>
<li>前端收到 CONFIRMED 状态</li>
<li>发起请求 <code>/api/qr/login?qrCodeId=xxx</code></li>
<li>后端从 Redis 中取出对应用户信息</li>
<li>为 PC 创建 Session 或返回 JWT Token</li>
<li>登录成功，跳转首页</li>
</ul>
<h2 id="🔐-三、安全要点"><a href="#🔐-三、安全要点" class="headerlink" title="🔐 三、安全要点"></a>🔐 三、安全要点</h2><ul>
<li>二维码应设置过期时间，防止被反复使用</li>
<li>Token 校验要严谨，确保扫码者是本人</li>
<li>Redis 里状态更新使用 Lua 脚本或事务 CAS 保证一致性</li>
<li>后端二维码状态需加密传输或限制频繁请求（防刷）</li>
</ul>
<h2 id="🚀-四、技术选型小结"><a href="#🚀-四、技术选型小结" class="headerlink" title="🚀 四、技术选型小结"></a>🚀 四、技术选型小结</h2><table>
<thead>
<tr>
<th>功能</th>
<th>技术</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>二维码生成</td>
<td>UUID + Redis</td>
<td>可快速唯一生成并记录状态</td>
</tr>
<tr>
<td>状态存储</td>
<td>Redis（带 TTL）</td>
<td>快速响应，高并发，易过期处理</td>
</tr>
<tr>
<td>实时通知</td>
<td>轮询 &#x2F; WebSocket</td>
<td>淘宝用轮询、抖音用 WS</td>
</tr>
<tr>
<td>登录授权</td>
<td>JWT &#x2F; Session</td>
<td>生成 PC 端登录凭证</td>
</tr>
<tr>
<td>防刷限流</td>
<td>接口限流 + 签名校验</td>
<td>避免恶意轮询&#x2F;伪造请求</td>
</tr>
</tbody></table>
<h2 id="✅-五、流程图（配合讲解）"><a href="#✅-五、流程图（配合讲解）" class="headerlink" title="✅ 五、流程图（配合讲解）"></a>✅ 五、流程图（配合讲解）</h2><pre><code>text复制编辑[PC端]        [后端]                   [App端]
  |                      |                         |
  |--&gt; 请求生成二维码 --&gt;|                         |
  |                      |-- 生成qrCodeId + Redis存储
  |&lt;-- 返回二维码Base64--|                         |
  |                      |                         |
  |==轮询/WS监听状态====&gt;|                         |
  |                      |                         |
  |                      |&lt;--扫码携带Token + qrCodeId
  |                      |--校验后标记为SCANNED     |
  |&lt;==收到SCANNED状态== |                         |
  |                      |&lt;--确认登录               |
  |                      |--更新为CONFIRMED +登录信息
  |&lt;==收到CONFIRMED==   |                         |
  |-- 请求登录状态凭证 --&gt;|                         |
  |&lt;-- 返回JWT/Session--|                         |
</code></pre>
<hr>
</blockquote>
<p><span style = "color:red"><strong>如何设计分布式日志存储架构？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/38bcadd4a99fd1093a4d7ab6e39c60340bfc73a8/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png"></p>
<p><span style = "color:red"><strong>使用redis出现缓存三兄弟如何解决？</strong></span><del>减轻数据库的压力</del></p>
<p><span style = "color:blue"><strong>你在项目中用到了Redis对吧 介绍一下有没有遇到关于redis的什么问题？</strong></span></p>
<p>暂时还没看！<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV176KpeiEXF?spm_id_from=333.788.videopod.episodes&vd_source=a4d980c3208d51858f08b3025a6ab2d9&p=12">12.使用redis出现缓存击穿雪崩穿透怎么解决_哔哩哔哩_bilibili</a></p>
<p><span style = "color:red"><strong>如何使用Redis记录用户连续登录了多少天？</strong></span><del>放在数据库里不合适</del></p>
<p>放在数据库不合适因为你要创建一个表 记录用户哪一天进行了签到 如果用户量很多就会很大的量</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9db550cabe345faff24a1fccba0d9d0f5e59faf9/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E7%99%BB%E5%BD%95%E4%BA%86%E5%A4%9A%E5%B0%91%E5%A4%A9.png"></p>
<blockquote>
<p>这个问题其实就是一个<strong>连续签到&#x2F;登录统计</strong>问题，数据库不适合是因为：</p>
<ul>
<li>每签到一天就插一行 → 数据量巨大，I&#x2F;O压力大。</li>
<li>查询连续签到天数复杂，SQL不好写，效率低。</li>
</ul>
<p>所以使用 Redis 的 <strong>位图（bitmap）</strong> 来解决，是一种<strong>低存储+高性能</strong>的方案。</p>
<hr>
<h3 id="🎯-场景目标"><a href="#🎯-场景目标" class="headerlink" title="🎯 场景目标"></a>🎯 场景目标</h3><p>统计用户<strong>连续登录天数</strong>、<strong>本月第几天登录过</strong>，实现类似：</p>
<pre><code>复制编辑用户A 7月签到状态 = 01111100010001000（1表示登录，0表示没登录）
查询当前用户是否今天登录过？
查询用户本月连续登录天数？
</code></pre>
<hr>
<h3 id="🧠-技术选型：使用-Redis-Bitmap"><a href="#🧠-技术选型：使用-Redis-Bitmap" class="headerlink" title="🧠 技术选型：使用 Redis Bitmap"></a>🧠 技术选型：使用 Redis Bitmap</h3><h4 id="什么是-Bitmap？"><a href="#什么是-Bitmap？" class="headerlink" title="什么是 Bitmap？"></a>什么是 Bitmap？</h4><p>Redis 的 Bitmap 本质上是字符串（<code>String</code> 类型），但你可以对它的每一位 bit 操作：</p>
<pre><code class="java"># 设置偏移量为 5 的位置为 1（签到）
SETBIT user:sign:1001:202507 5 1

# 查询偏移量为 5 的位置是否为 1（是否登录）
GETBIT user:sign:1001:202507 5
</code></pre>
<hr>
<h3 id="✅-实现思路"><a href="#✅-实现思路" class="headerlink" title="✅ 实现思路"></a>✅ 实现思路</h3><h4 id="1-登录-x2F-签到时"><a href="#1-登录-x2F-签到时" class="headerlink" title="1. 登录&#x2F;签到时"></a>1. 登录&#x2F;签到时</h4><pre><code class="java">int offset = today - 1; // 7月19日 → offset = 18，从0开始
String key = &quot;user:sign:&quot; + userId + &quot;:&quot; + yyyyMM;
redisTemplate.opsForValue().setBit(key, offset, true);
</code></pre>
<h4 id="2-查询某天是否登录"><a href="#2-查询某天是否登录" class="headerlink" title="2. 查询某天是否登录"></a>2. 查询某天是否登录</h4><pre><code class="javascript">Boolean isLogin = redisTemplate.opsForValue().getBit(key, offset);
</code></pre>
<h4 id="3-查询本月累计登录多少天"><a href="#3-查询本月累计登录多少天" class="headerlink" title="3. 查询本月累计登录多少天"></a>3. 查询本月累计登录多少天</h4><pre><code class="java">BitCountOptions options = BitCountOptions.defaults();
Long total = redisTemplate.execute((RedisCallback&lt;Long&gt;) conn -&gt; 
    conn.bitCount(key.getBytes(), options)
);
</code></pre>
<h4 id="4-查询连续登录天数（重点）"><a href="#4-查询连续登录天数（重点）" class="headerlink" title="4. 查询连续登录天数（重点）"></a>4. 查询连续登录天数（重点）</h4><p>假设今天是第19天，从 offset &#x3D; 18 开始向前看：</p>
<pre><code class="java">int count = 0;
for (int i = offset; i &gt;= 0; i--) &#123;
    if (redisTemplate.opsForValue().getBit(key, i)) &#123;
        count++;
    &#125; else &#123;
        break; // 一旦中断，退出循环
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="🚀-优势"><a href="#🚀-优势" class="headerlink" title="🚀 优势"></a>🚀 优势</h3><ul>
<li>Redis Bitmap 单月只占用 31 bit，超省空间（一个用户一年只用 372 bit ≈ 47 字节）</li>
<li>查询效率高，O(1)</li>
<li>写入也快，支持并发</li>
</ul>
<hr>
<h3 id="🔐-注意点"><a href="#🔐-注意点" class="headerlink" title="🔐 注意点"></a>🔐 注意点</h3><ul>
<li><p><strong>设置过期时间</strong>：避免内存占用过大</p>
<pre><code class="java">redisTemplate.expire(key, Duration.ofDays(60));
</code></pre>
</li>
<li><p>如果需要“补签”功能，操作相应的 bit 位即可</p>
</li>
</ul>
<h3 id="📌-示例-Redis-数据结构（7月）"><a href="#📌-示例-Redis-数据结构（7月）" class="headerlink" title="📌 示例 Redis 数据结构（7月）"></a>📌 示例 Redis 数据结构（7月）</h3><pre><code class="java">Key: user:sign:1001:202507

Value (bit位)：0111110000000000000000000000000
日期：1 2 3 4 5 6 7 ... 31
含义：从左往右，第i位是第i+1天
</code></pre>
</blockquote>
<p><span style = "color:red"><strong>给你一亿个Redis keys统计双方的共同好友？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a917027faf313dfaee955c52361c8f711309fb43/%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BA%BF%E4%B8%AARedis%20keys%E7%BB%9F%E8%AE%A1%E5%8F%8C%E6%96%B9%E7%9A%84%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B.png"></p>
<blockquote>
<h2 id="🧩-题目解析"><a href="#🧩-题目解析" class="headerlink" title="🧩 题目解析"></a>🧩 题目解析</h2><p>假设：</p>
<ul>
<li>每个用户的好友列表存储在 Redis 的 Set 结构中，例如：<br> <code>SADD friends:user1 A B C D</code><br> <code>SADD friends:user2 B C E F</code></li>
</ul>
<p>目标：</p>
<ul>
<li>快速统计两个人共同的好友，即集合交集数量。</li>
</ul>
<hr>
<h2 id="✅-常规解法：Redis-SINTER-命令"><a href="#✅-常规解法：Redis-SINTER-命令" class="headerlink" title="✅ 常规解法：Redis SINTER 命令"></a>✅ 常规解法：Redis <code>SINTER</code> 命令</h2><p>Redis 支持对多个集合求交集：</p>
<pre><code class="java">SINTER friends:user1 friends:user2
</code></pre>
<p>返回结果即为双方的共同好友。</p>
<p>如果只要交集数量，可以使用：</p>
<pre><code class="java">SINTERCARD 2 friends:user1 friends:user2
</code></pre>
<p>这是 Redis 7.0 新增的命令，<strong>效率更高</strong>。</p>
<h2 id="🧠-问题难点：一亿个-keys-怎么办？"><a href="#🧠-问题难点：一亿个-keys-怎么办？" class="headerlink" title="🧠 问题难点：一亿个 keys 怎么办？"></a>🧠 问题难点：一亿个 keys 怎么办？</h2><p>一亿个 keys 说明用户量巨大或好友数量极多，可能涉及以下挑战：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Redis 内存压力</td>
<td>如果所有好友关系都存在 Redis Set 中，消耗大量内存</td>
</tr>
<tr>
<td>网络 IO 开销</td>
<td>获取或计算时大量命令交互</td>
</tr>
<tr>
<td>集合元素巨大</td>
<td>每个 Set 元素多（例如几千好友），单次 <code>SINTER</code> 代价大</td>
</tr>
<tr>
<td>频繁交集操作</td>
<td>如果这是一个高频功能（如社交推荐），需要高效方案</td>
</tr>
</tbody></table>
<h2 id="🧠-实战建议"><a href="#🧠-实战建议" class="headerlink" title="🧠 实战建议"></a>🧠 实战建议</h2><table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody><tr>
<td>精确共同好友、数量不大</td>
<td><code>SINTER</code> &#x2F; <code>SINTERCARD</code></td>
</tr>
<tr>
<td>只需估算交集数量</td>
<td><code>PFCOUNT</code>（HyperLogLog）</td>
</tr>
<tr>
<td>只需交集数量 + 数据量很大</td>
<td>Bitmap + <code>BITOP</code> + <code>BITCOUNT</code></td>
</tr>
<tr>
<td>数据量超大，追求压缩极致</td>
<td>Roaring Bitmap、Redis Module</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>如何做一亿用户实时积分排行榜？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2be2ea44cfd98cb3669dcc098f4790f2ad0780d1/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%BA%BF%E7%94%A8%E6%88%B7%E5%AE%9E%E6%97%B6%E7%A7%AF%E5%88%86%E6%8E%92%E8%A1%8C%E6%A6%9C.png"></p>
<blockquote>
<p>做“一亿用户实时积分排行榜”时，面临的挑战是：<strong>高并发写入、高频读、排序性能、排行榜分页、内存管理等</strong>。使用传统数据库难以胜任，我们通常结合 <strong>Redis 的 ZSet（有序集合）结构 + 分布式架构</strong> 来高效实现。</p>
<h4 id="💡-核心思路"><a href="#💡-核心思路" class="headerlink" title="💡 核心思路"></a>💡 核心思路</h4><ul>
<li>使用 Redis 的 <code>ZSet</code> 存储用户积分（ZSet天然支持有序集合）。</li>
<li>使用 <strong>用户ID为 member，积分为 score</strong>，自动排序。</li>
<li>按业务场景设置多个排行榜（<strong>总榜、日榜、周榜</strong>等）。</li>
<li>使用分片&#x2F;分区 + 多 Redis 实例缓解内存压力。</li>
</ul>
<h3 id="🚀-性能优化方案"><a href="#🚀-性能优化方案" class="headerlink" title="🚀 性能优化方案"></a>🚀 性能优化方案</h3><table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>高并发写入</td>
<td>异步批处理写入积分变化（Kafka &#x2F; MQ）</td>
</tr>
<tr>
<td>高并发读榜</td>
<td>热榜分页结果缓存（Redis 二级缓存）</td>
</tr>
<tr>
<td>大数据量</td>
<td>分片存储排行榜（按地域&#x2F;业务线）</td>
</tr>
<tr>
<td>数据持久化</td>
<td>后台定期将 ZSet 持久化至 MySQL（定时备份）</td>
</tr>
<tr>
<td>用户查自己排名</td>
<td>排名反查缓存 + 异步修正（定时刷新）</td>
</tr>
</tbody></table>
<h3 id="⚙️-分布式架构下的挑战与解决"><a href="#⚙️-分布式架构下的挑战与解决" class="headerlink" title="⚙️ 分布式架构下的挑战与解决"></a>⚙️ 分布式架构下的挑战与解决</h3><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>单机内存不足</td>
<td>Redis 分布式集群 + 按 key 做水平分区</td>
</tr>
<tr>
<td>网络波动</td>
<td>Redis 哨兵或主从架构容灾</td>
</tr>
<tr>
<td>跨机房</td>
<td>使用 Kafka MQ 异步同步数据</td>
</tr>
<tr>
<td>并发冲突</td>
<td>ZINCRBY 原子操作，确保并发安全</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>内存200M读取1G文件并统计内容重复次数？<del>内存受限时</del></strong></span></p>
<p>一次性读取肯定会OOM<br>可以根据缓冲区分块读取<br><img src="https://raw.githubusercontent.com/P-luminary/images/f791667943446b731b86a4123b2fc03c812dabf1/%E5%86%85%E5%AD%98200M%E8%AF%BB%E5%8F%961G%E6%96%87%E4%BB%B6%E5%B9%B6%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AE%B9%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0.png"></p>
<blockquote>
<h3 id="📌-方案核心：“分治-磁盘中间结果-再归并统计”"><a href="#📌-方案核心：“分治-磁盘中间结果-再归并统计”" class="headerlink" title="📌 方案核心：“分治 + 磁盘中间结果 + 再归并统计”"></a>📌 方案核心：<strong>“分治 + 磁盘中间结果 + 再归并统计”</strong></h3><hr>
<h3 id="📍第一步：分片预处理（Hash-分桶）"><a href="#📍第一步：分片预处理（Hash-分桶）" class="headerlink" title="📍第一步：分片预处理（Hash 分桶）"></a>📍第一步：分片预处理（Hash 分桶）</h3><ul>
<li><p>遍历文件，<strong>每条记录用 hash 函数映射到 N 个临时小文件中</strong>（如 100 个文件）。</p>
</li>
<li><p>例如：</p>
<pre><code>hash(line) % 100 -&gt; 选择第 i 个 bucket_i.txt 写入
</code></pre>
</li>
<li><p>每个桶的数据量 &lt;&lt; 1GB，<strong>避免某一个桶数据过大</strong>（可以动态调节桶数）。</p>
</li>
</ul>
<p>📝 <strong>实现要点</strong>：</p>
<ul>
<li>不能直接把 key 存在内存中，而是用 <code>BufferedWriter</code> 把行写入不同的中间文件。</li>
<li>临时文件名如 <code>bucket_0.txt</code>, <code>bucket_1.txt</code>, …, <code>bucket_99.txt</code>。</li>
</ul>
<hr>
<h3 id="📍第二步：小文件内统计（Map-阶段）"><a href="#📍第二步：小文件内统计（Map-阶段）" class="headerlink" title="📍第二步：小文件内统计（Map 阶段）"></a>📍第二步：小文件内统计（Map 阶段）</h3><ul>
<li><p>每个小文件都可以用内存加载（一般几十 MB），然后用 <code>Map&lt;String, Integer&gt;</code> 来做频次统计。</p>
</li>
<li><p>统计完毕后，<strong>结果写入新的临时文件</strong>，如：</p>
<pre><code>result_bucket_0.txt:
word1 -&gt; 5
word2 -&gt; 3
...
</code></pre>
</li>
</ul>
<hr>
<h3 id="📍第三步：归并所有桶（Reduce-阶段）"><a href="#📍第三步：归并所有桶（Reduce-阶段）" class="headerlink" title="📍第三步：归并所有桶（Reduce 阶段）"></a>📍第三步：归并所有桶（Reduce 阶段）</h3><ul>
<li>如果需要所有数据的总频率（跨桶汇总），则可以：<ul>
<li>对所有结果文件做归并统计（Map 合并）。</li>
<li>比如 <code>word1</code> 在 <code>result_bucket_0.txt</code> 是 5，<code>result_bucket_1.txt</code> 是 2，总共就是 7。</li>
<li>这一步可再次用 hashmap 缓存 + 写磁盘防止内存爆掉。</li>
</ul>
</li>
</ul>
<h2 id="📘-总结一句话"><a href="#📘-总结一句话" class="headerlink" title="📘 总结一句话"></a>📘 总结一句话</h2><p><strong>“把大象装进冰箱，需要分步来——分桶写临时文件 → 每桶局部统计 → 全局归并或提取 Top-N。”</strong></p>
</blockquote>
<p><span style = "color:red"><strong>查询200条数据耗时200ms，怎么在500ms内查询1000条数据？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/af425172c9777d99374c270ea1bb12daf6c9a886/%E6%9F%A5%E8%AF%A2200%E6%9D%A1%E6%95%B0%E6%8D%AE%E8%80%97%E6%97%B6200ms%EF%BC%8C%E6%80%8E%E4%B9%88%E5%9C%A8500ms%E5%86%85%E6%9F%A5%E8%AF%A21000%E6%9D%A1%E6%95%B0%E6%8D%AE.png"></p>
<p><span style = "color:red"><strong>SpringBoot如果有百万数据插入怎么优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/819db0a99867d7dea55c079cd88561676d73d2cd/SpringBoot%E5%A6%82%E6%9E%9C%E6%9C%89%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96.png"></p>
<p><span style = "color:red"><strong>SpringBoot可以同时处理多少请求？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a3872a89aa8e4de272a70a38c33d71e854708610/SpringBoot%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E5%A4%9A%E5%B0%91%E8%AF%B7%E6%B1%82.png"></p>
<p><span style = "color:red"><strong>volatile的应用场景？</strong></span></p>
<p>为了保证我们并发编程的<strong>可见性</strong>和<strong>有序性</strong></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7a43484ced62d5727e9d6636d98a72d5bc8e4306/volatile%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png"></p>
<p><span style = "color:red"><strong>SQL的执行流程</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d1cb7430ecba8b881cca73c71d320e672975fae1/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><span style = "color:red"><strong>单表最多数据量需要多大才涉及到分表？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c6f0c5d08eac3f278743c748ff2ce3fe0849bcf9/%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%9A%E6%95%B0%E6%8D%AE%E9%87%8F%E9%9C%80%E8%A6%81%E5%A4%9A%E5%A4%A7%E6%89%8D%E6%B6%89%E5%8F%8A%E5%88%B0%E5%88%86%E8%A1%A8.png"></p>
<p><span style = "color:red"><strong>Mysql引擎层BufferPool工作过程原理？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a2eabbfa570efb5cce42f6fa8a3ea77cab621618/Mysql%E5%BC%95%E6%93%8E%E5%B1%82BufferPool%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86.png"></p>
<p><span style = "color:red"><strong>什么是聚集索引和非聚集索引？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0aece273ba1eea943a48d6ed472c7bab462058fe/%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png"></p>
<p><span style = "color:red"><strong>count(*)、count(1)、count(字段) 谁更快？有什么区别？</strong></span></p>
<h6 id="tb-user"><a href="#tb-user" class="headerlink" title="tb_user"></a>tb_user</h6><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>潘春尧</td>
</tr>
<tr>
<td>2</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>张三</td>
</tr>
</tbody></table>
<pre><code class="mysql">Ⅰ. SELECT count(*) FROM tb_user;                → 3
Ⅱ. SELECT count(1) FROM tb_user;                → 3
Ⅲ. SELECT count(name) FROM tb_user;             → 2
</code></pre>
<p><strong>在功能上没有区别</strong>       Ⅲ.<u>如果你统计的数据需要排除NULL 就可以用count(指定字段)</u><br><strong>在性能上没有任何区别</strong> 非要比较就是<code>count(1)</code>更胜一筹 因为不需要mysql在底层做任何的sql优化</p>
<p><span style = "color:red"><strong>SQL语句中使用了前模糊会导致索引失效？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c0b61b722ea0ee0990611ae568ee2ca082677ee/SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%89%8D%E6%A8%A1%E7%B3%8A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"></p>
<p><span style = "color:red"><strong>分库分表id冲突解决方案？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/379b852cebfc3bf8b34e24670994a54443885b21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8id%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"></p>
<blockquote>
<h2 id="✅-解决方案详解"><a href="#✅-解决方案详解" class="headerlink" title="✅ 解决方案详解"></a>✅ 解决方案详解</h2><h3 id="1-数据库主键自增（不推荐）"><a href="#1-数据库主键自增（不推荐）" class="headerlink" title="1. 数据库主键自增（不推荐）"></a>1. <strong>数据库主键自增（不推荐）</strong></h3><ul>
<li>每个分库或分表自己用数据库的自增主键生成 ID。</li>
<li>缺点：跨库表合并数据时会重复，<strong>不具备全局唯一性</strong>。</li>
</ul>
<hr>
<h3 id="2-UUID-作为主键"><a href="#2-UUID-作为主键" class="headerlink" title="2. UUID 作为主键"></a>2. <strong>UUID 作为主键</strong></h3><ul>
<li>使用 Java 的 <code>UUID.randomUUID().toString()</code> 等方式。</li>
<li>优点：<strong>天然全局唯一</strong>。</li>
<li>缺点：<ul>
<li>不适合做主键（无序、冗长，影响数据库索引性能）。</li>
<li>可读性差，调试困难。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-数据库主键段（Segment）模式（推荐）"><a href="#3-数据库主键段（Segment）模式（推荐）" class="headerlink" title="3. 数据库主键段（Segment）模式（推荐）"></a>3. <strong>数据库主键段（Segment）模式（推荐）</strong></h3><ul>
<li>思路：中心服务维护一张 ID 号段表，为每个业务系统分配一个号段。</li>
<li>实现：<ul>
<li>表中记录：<code>biz_tag, max_id, step, version</code></li>
<li>应用请求号段：<code>SELECT max_id, step FROM id_segment WHERE biz_tag = &#39;order&#39;</code></li>
<li>然后更新 max_id 为 <code>max_id + step</code></li>
</ul>
</li>
<li>优点：<ul>
<li>性能高（本地生成，无需每次访问数据库）</li>
<li>避免重复（由号段控制）</li>
</ul>
</li>
<li>缺点：需要一个中心服务（如美团 Leaf）</li>
</ul>
<hr>
<h3 id="4-雪花算法（Snowflake）"><a href="#4-雪花算法（Snowflake）" class="headerlink" title="4. 雪花算法（Snowflake）"></a>4. <strong>雪花算法（Snowflake）</strong></h3><ul>
<li><p>Twitter 出品，用于生成 64 位整数 ID。</p>
</li>
<li><p>格式如下：</p>
<pre><code class="java">0 - 41位时间戳 - 10位机器ID - 12位自增序列
</code></pre>
</li>
<li><p>优点：</p>
<ul>
<li>单机高性能、趋势递增、可分布式部署</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>依赖机器时钟，<strong>系统时间回拨可能导致重复 ID 或服务挂掉</strong></li>
<li>需要保证机器 ID 唯一（通常通过配置或 ZooKeeper 分配）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-Redis-生成自增-ID"><a href="#5-Redis-生成自增-ID" class="headerlink" title="5. Redis 生成自增 ID"></a>5. <strong>Redis 生成自增 ID</strong></h3><ul>
<li><p>利用 Redis 的 <code>INCR</code> 命令，生成全局递增 ID：</p>
<pre><code class="java">INCR order:id
</code></pre>
</li>
<li><p>可配合时间戳、业务前缀等拼接成全局唯一 ID。</p>
</li>
<li><p>优点：</p>
<ul>
<li>简单、轻量、分布式支持</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>Redis 挂掉或主从切换期间可能丢失或重复</li>
</ul>
</li>
</ul>
<hr>
<h2 id="🏁-总结推荐"><a href="#🏁-总结推荐" class="headerlink" title="🏁 总结推荐"></a>🏁 总结推荐</h2><table>
<thead>
<tr>
<th>方案</th>
<th>唯一性</th>
<th>性能</th>
<th>实现复杂度</th>
<th>推荐使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>UUID</td>
<td>✅</td>
<td>高</td>
<td>简单</td>
<td>临时标识、测试用途</td>
</tr>
<tr>
<td>自增主键</td>
<td>❌</td>
<td>高</td>
<td>简单</td>
<td>单库表内可用</td>
</tr>
<tr>
<td>Segment</td>
<td>✅</td>
<td>✅</td>
<td>中等</td>
<td>企业级 ID 服务（如 Leaf）</td>
</tr>
<tr>
<td>雪花算法</td>
<td>✅</td>
<td>✅</td>
<td>中等</td>
<td>分布式高并发业务</td>
</tr>
<tr>
<td>Redis INCR</td>
<td>✅</td>
<td>高</td>
<td>简单</td>
<td>轻量级全局 ID 需求</td>
</tr>
</tbody></table>
<p>如果你是在<strong>高并发、微服务、分布式环境下</strong>，强烈推荐使用：</p>
<ul>
<li>雪花算法 + Redis 搭配</li>
<li>或引入一个中心 ID 生成服务（如 Leaf、TinyId、美团 UID Generator）</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>深分页为什么慢，怎么优化？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c3a969f374bebb04ca5858c2ab7ef750ac4296af/%E6%B7%B1%E5%88%86%E9%A1%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2%2C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96.png"></p>
<blockquote>
<h3 id="❓-问题背景：什么是深分页？"><a href="#❓-问题背景：什么是深分页？" class="headerlink" title="❓ 问题背景：什么是深分页？"></a>❓ 问题背景：什么是深分页？</h3><blockquote>
<p>深分页 &#x3D; 当前页数很大，比如 <code>page=100000 &amp; size=10</code><br> 对应 SQL：</p>
</blockquote>
<pre><code>SELECT * FROM table LIMIT 1000000, 10;
</code></pre>
<ul>
<li><code>LIMIT offset, size</code> 这种分页方式，在 <strong>offset 特别大时非常慢</strong>。</li>
<li>根因：数据库在处理时，<strong>仍然会扫描前面 offset 条记录，然后丢弃它们，仅返回后面的 size 条</strong>。</li>
</ul>
<hr>
<h3 id="🐌-为什么慢？"><a href="#🐌-为什么慢？" class="headerlink" title="🐌 为什么慢？"></a>🐌 为什么慢？</h3><p>数据库执行过程（如MySQL）：</p>
<pre><code>LIMIT 1000000, 10
</code></pre>
<p>数据库内部会：</p>
<ol>
<li>先从磁盘&#x2F;缓冲中 <strong>取出前 1000000 条记录</strong>；</li>
<li>然后只返回第 1000001 ~ 1000010 条；</li>
<li><strong>前面的全丢了</strong>，但依然耗费 CPU、IO 和内存资源。</li>
</ol>
<p>当数据量大时：</p>
<ul>
<li>IO开销大（全表扫描）</li>
<li>CPU开销大（排序、过滤）</li>
<li>数据库响应延迟高</li>
</ul>
<hr>
<h3 id="🚀-如何优化深分页？"><a href="#🚀-如何优化深分页？" class="headerlink" title="🚀 如何优化深分页？"></a>🚀 如何优化深分页？</h3><h4 id="✅-方案一：使用-覆盖索引"><a href="#✅-方案一：使用-覆盖索引" class="headerlink" title="✅ 方案一：使用 覆盖索引"></a>✅ 方案一：使用 <strong>覆盖索引</strong></h4><pre><code>SELECT id FROM table ORDER BY id LIMIT 1000000, 10;
</code></pre>
<p>如果 <code>id</code> 是索引字段，数据库可以直接从索引树上读取，无需回表。</p>
<p>但这个优化能力有限，适合某些查询字段很少、又刚好有索引的情况。</p>
<hr>
<h4 id="✅-方案二：记录上次的游标（Keyset-Pagination）"><a href="#✅-方案二：记录上次的游标（Keyset-Pagination）" class="headerlink" title="✅ 方案二：记录上次的游标（Keyset Pagination）"></a>✅ 方案二：记录上次的游标（<strong>Keyset Pagination</strong>）</h4><blockquote>
<p>又叫 <strong>基于条件的分页</strong>，避免使用 offset。</p>
</blockquote>
<p>例如：</p>
<pre><code>SELECT * FROM table 
WHERE id &gt; 上一页最后一条记录id 
ORDER BY id 
LIMIT 10;
</code></pre>
<p>优点：</p>
<ul>
<li>快！数据库利用索引跳过前面的数据</li>
<li>没有 offset，性能非常稳定</li>
</ul>
<p>适用场景：</p>
<ul>
<li>id 或时间戳等字段是自增或顺序的</li>
<li>不要求用户可以跳到任意页，只支持“向前&#x2F;向后翻页”</li>
</ul>
<hr>
<h4 id="✅-方案三：缓存-异步预处理"><a href="#✅-方案三：缓存-异步预处理" class="headerlink" title="✅ 方案三：缓存 + 异步预处理"></a>✅ 方案三：缓存 + 异步预处理</h4><p>对于排行榜、热点数据等：</p>
<ul>
<li>查询结果提前生成并缓存（Redis 等）</li>
<li>用户点页数 → 直接读缓存，避免实时查询</li>
</ul>
<hr>
<h4 id="✅-方案四：使用临时表或中间结果表"><a href="#✅-方案四：使用临时表或中间结果表" class="headerlink" title="✅ 方案四：使用临时表或中间结果表"></a>✅ 方案四：使用临时表或中间结果表</h4><ul>
<li>查询结果太大 → 先异步存入临时表</li>
<li>分页从临时表中读取数据（配合游标分页）</li>
</ul>
<p>适用于复杂 SQL 查询 + 多表连接</p>
<hr>
<h3 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h3><table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>offset 分页</td>
<td>简单</td>
<td>深分页慢</td>
<td>小数据量</td>
</tr>
<tr>
<td>覆盖索引</td>
<td>快</td>
<td>限制大</td>
<td>查询字段少</td>
</tr>
<tr>
<td>游标分页</td>
<td>性能高</td>
<td>不支持跳页</td>
<td>流式阅读&#x2F;时间线</td>
</tr>
<tr>
<td>缓存分页</td>
<td>快</td>
<td>一致性差</td>
<td>热点排行榜等</td>
</tr>
<tr>
<td>临时表分页</td>
<td>灵活</td>
<td>复杂</td>
<td>大查询分页导出</td>
</tr>
</tbody></table>
</blockquote>
<p><span style = "color:red"><strong>MySQL的隔离级别实现原理MVCC ？</strong></span></p>
<p>核心：<strong>隐藏字段 + Undo Log + ReadView</strong></p>
<blockquote>
<h3 id="🔸-1-每行记录都有两个隐藏字段："><a href="#🔸-1-每行记录都有两个隐藏字段：" class="headerlink" title="🔸 1. 每行记录都有两个隐藏字段："></a>🔸 1. 每行记录都有两个隐藏字段：</h3><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>trx_id</code>（创建事务ID）</td>
<td>表示创建该版本的事务 ID</td>
</tr>
<tr>
<td><code>roll_pointer</code>（回滚指针）</td>
<td>指向 Undo Log（历史版本）的位置</td>
</tr>
</tbody></table>
<hr>
<h3 id="🔸-2-Undo-Log（回滚日志）"><a href="#🔸-2-Undo-Log（回滚日志）" class="headerlink" title="🔸 2. Undo Log（回滚日志）"></a>🔸 2. Undo Log（回滚日志）</h3><ul>
<li>用于记录数据修改前的<strong>旧版本数据</strong></li>
<li>当有读请求（快照读）时，就通过 <code>roll_pointer</code> 访问历史版本</li>
<li>写操作失败或回滚，也依赖 Undo Log 恢复数据</li>
</ul>
<hr>
<h3 id="🔸-3-ReadView（读视图）"><a href="#🔸-3-ReadView（读视图）" class="headerlink" title="🔸 3. ReadView（读视图）"></a>🔸 3. ReadView（读视图）</h3><ul>
<li>当事务开启时，会创建一个 ReadView（可见性判断工具）</li>
<li>包含当前活跃事务 ID 列表、最小事务ID、最大事务ID</li>
<li>判断规则：<ul>
<li>如果行的创建事务ID &lt; ReadView 中最小事务ID → 可见</li>
<li>如果在活跃事务列表中 → 不可见</li>
<li>如果创建事务ID &gt; 当前事务ID → 不可见（未来数据）</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>**MVCC ** (Multiversion Concurrency Control) <u>多版本并发控制器</u> </p>
<p>它是事务隔离级别的无锁的实现方式，用于提高事务的并发性能</p>
</li>
</ul>
<h5 id="事务隔离级别-isolation"><a href="#事务隔离级别-isolation" class="headerlink" title="事务隔离级别 (isolation)"></a>事务隔离级别 (isolation)</h5><p>用来解决并发事务所产生一些问题：<br><strong>并发</strong>：同一个时间，多个线程同时进行请求。<br>什么时候会发生并发问题：在并发情况下，对同一个数据(变量、对象)进行读写操作才会产生并发问题<br>并发会产生什么问题?<br>1.脏读一读已提交(行锁，读不会加锁)<br>2.不可重复度–重复读(行锁，读和写都会上锁)<br>3.幻影读–串行化(表锁)概念: 通过设置隔离级别可解决在并发过程中产生的那些问题</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/eba483783b9cb58dca90497f85013b9f66e86dc0/MySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86MVCC.png"></p>
<p><span style="color:red"><strong>用户忘记密码，系统为什么不直接提供原密码，而让改密码</strong></span></p>
<h5 id="因为系统它也不知道我们的原密码是什么"><a href="#因为系统它也不知道我们的原密码是什么" class="headerlink" title="因为系统它也不知道我们的原密码是什么"></a>因为系统它也不知道我们的原密码是什么</h5><p>服务端在保存密码的时候绝不会<strong>明文</strong>存到数据库，怕有数据库权限的人或者黑客恶意利用<br>必须用不可逆的加密算法</p>
<h5 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h5><ul>
<li>只能加密不可解密 但是它是hash算法 可能会有哈希冲突 至少加密2^128次方才有可能发生<strong>哈希碰撞</strong></li>
<li>每次生成的密文都一样，不管加密多少次生成的密文都是一样的 可以通过<strong>暴力破解</strong><ul>
<li><u>解决暴力破解 就要在里面加<strong>盐</strong> 每次加密 解密 都要加入<strong>盐</strong></u></li>
</ul>
</li>
</ul>
<h5 id="HS256"><a href="#HS256" class="headerlink" title="HS256"></a>HS256</h5><ul>
<li>增加加密字符长度 目前没有碰撞性</li>
<li>最好加入随机盐</li>
</ul>
<h5 id="BCrypt-→-加入spring-security-core依赖"><a href="#BCrypt-→-加入spring-security-core依赖" class="headerlink" title="BCrypt → 加入spring-security-core依赖"></a>BCrypt → 加入<code>spring-security-core</code>依赖</h5><ul>
<li>盐是随机的 </li>
<li>无法通过暴力破解</li>
</ul>
<p><span style="color:red"><strong>Git怎么修复线上的突发BUG</strong></span><del>线上突发Bug要修复,本地正在开发新需求</del></p>
<p>在git里我们通常会用一个单独的分支来进行管理<br>本地开发也会有一个单独的分支<br>可以将线上代码的分支签出来单独进行修复</p>
<ul>
<li>正在开发的代码 → 暂存dev分支</li>
<li><strong>严重故障</strong>：回滚上一个版本<br><strong>非严重故障</strong>：在fix分支修复紧急Bug</li>
<li><strong>非常紧急</strong>：直接合并master分支上线</li>
<li><strong>一般急</strong>：合并release分支，走测试、上线流程</li>
<li><strong>非紧急</strong>：合并dev分支，走测试、线上流程</li>
</ul>
<p><span style = "color:red"><strong>RestTemplate如何优化连接池</strong></span></p>
<p>默认是没有连接池的<br>要用框架<code>HTTPClient</code>、<code>OKHTTP</code></p>
<blockquote>
<p><strong>RestTemplate</strong> 是Spring框架中用于简化HTTP请求的一个类，它提供了多种方法来处理HTTP请求和响应。RestTemplate可以用于发送GET、POST、PUT、DELETE等HTTP请求，并且可以处理请求头、请求体、URL参数等。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/6fd3855adcf37a9b9b26fd5173c0b8b9c549724d/RestTemplate%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%BF%9E%E6%8E%A5%E6%B1%A0.png"  />

<p><span style = "color:red"><strong>Synchronized怎么提升性能</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a85c2658ee0266db182e0570b1f861ee2933bfa9/Synchronized%E6%80%8E%E4%B9%88%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD.png"></p>
<blockquote>
<h2 id="🧠-实际开发中如何用好-synchronized？"><a href="#🧠-实际开发中如何用好-synchronized？" class="headerlink" title="🧠 实际开发中如何用好 synchronized？"></a>🧠 实际开发中如何用好 synchronized？</h2><h3 id="✅-尽量减少锁的粒度"><a href="#✅-尽量减少锁的粒度" class="headerlink" title="✅ 尽量减少锁的粒度"></a>✅ 尽量减少锁的粒度</h3><pre><code class="java">// ❌ 锁了整个方法
public synchronized void update() &#123; ... &#125;

// ✅ 只锁关键代码段
public void update() &#123;
    // 非关键代码
    synchronized (this) &#123;
        // 只锁关键部分
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="✅-使用局部锁对象代替类锁"><a href="#✅-使用局部锁对象代替类锁" class="headerlink" title="✅ 使用局部锁对象代替类锁"></a>✅ 使用局部锁对象代替类锁</h3><pre><code class="java">private final Object lock = new Object();

public void doTask() &#123;
    synchronized (lock) &#123;
        // 更细粒度的锁，避免不必要的争用
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="✅-使用并发类替代锁（性能更高）"><a href="#✅-使用并发类替代锁（性能更高）" class="headerlink" title="✅ 使用并发类替代锁（性能更高）"></a>✅ 使用并发类替代锁（性能更高）</h3><ul>
<li><code>ConcurrentHashMap</code></li>
<li><code>ReadWriteLock</code></li>
<li><code>ReentrantLock</code></li>
<li><code>AtomicInteger</code> 等</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>开发中有没有用到设计模式？怎么用的</strong></span></p>
<h5 id="策略模式-简单工厂-模板方法"><a href="#策略模式-简单工厂-模板方法" class="headerlink" title="策略模式 + 简单工厂 + 模板方法"></a>策略模式 + 简单工厂 + 模板方法</h5><img src="https://raw.githubusercontent.com/P-luminary/images/16704bb551d4c6a51ba6023f3d9370cbb7d02cc8/%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84.png" style="zoom:150%;" />



<p><span style = "color:red"><strong>SpringBoot如何防止反编译</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0e89c453cdc642a63ce8455ad04f9ff07f6010b0/SpringBoot%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91.png"></p>
<p><span style = "color:red"><strong>有没有出现过Spring正常SpringBoot报错的情况？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b4fd9547c5d460bcf571303b13c67ef3958a5972/%E6%9C%89%E6%B2%A1%E6%9C%89%E5%87%BA%E7%8E%B0%E8%BF%87Spring%E6%AD%A3%E5%B8%B8SpringBoot%E6%8A%A5%E9%94%99%E7%9A%84%E6%83%85%E5%86%B5.png"></p>
<p><span style = "color:red"><strong>SpringBoot配置文件敏感信息如何加密？</strong></span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/3d0323ce17742f53366f8c69b6675ddb5bc14ac4/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%EF%BC%9F.png"></p>
<p><span style = "color:red"><strong>一个需求来了怎么办</strong></span>！<br>首先看这个需求 进行一个分析 分析这个需求跟哪些功能有关联 比如说在我做过的xxx里面 和什么关联 要思考怎么去做这个关联 数据库 代码层面 思考好之后 再去ER画图 写接口文档 再去开始写代码</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#ffa2c4>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2024/10/31/面试/Java八股文专项/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/">
        <h2>
            SpringBoot趣味实战课
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/10/21
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="Swagger-Mariadb-Hibernate-实现极简CRUD"><a href="#Swagger-Mariadb-Hibernate-实现极简CRUD" class="headerlink" title="Swagger + Mariadb + Hibernate 实现极简CRUD"></a>Swagger + Mariadb + Hibernate 实现极简CRUD</h3><pre><code class="yaml">application.yaml
spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MariaDB103Dialect
  springdoc:
    api-docs:
      path: /v3/api-docs
    swagger-ui:
      path: /swagger-ui.html

  server:
    port: 8080
    servlet:
      context-path: /springboot
      session:
        timeout: 60
  debug: true
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;) //这里是扫描包
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java //【这个是持久化接口 实现CRUD】
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
package com.pcy.controller;

import com.pcy.dao.User;
import com.pcy.service.UserRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功获取用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功创建用户&quot;),
            @ApiResponse(responseCode = &quot;400&quot;, description = &quot;无效的输入&quot;)
    &#125;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功更新用户信息&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @ApiResponses(value = &#123;
            @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功删除用户&quot;),
            @ApiResponse(responseCode = &quot;404&quot;, description = &quot;未找到用户&quot;)
    &#125;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="增加分页、排序"><a href="#增加分页、排序" class="headerlink" title="增加分页、排序"></a>增加分页、排序</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping
    public Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
 @RequestParam(defaultValue = &quot;ASC&quot;)Sort.Direction direction,
 @RequestParam(defaultValue = &quot;0&quot;) Integer page,
 @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
    Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;
</code></pre>
<h3 id="根据姓名查用户"><a href="#根据姓名查用户" class="headerlink" title="根据姓名查用户"></a>根据姓名查用户</h3><pre><code class="java">com/pcy/controller/UserController.java    
    @Operation(summary = &quot;根据姓名查用户&quot;,description = &quot;根据姓名查用户&quot;)
    @GetMapping(&quot;/name&quot;)
    public List&lt;User&gt; getByName(String name)&#123;
        return userRepository.findByNameContaining(name);
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
package com.pcy.service;

import com.pcy.dao.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
    List&lt;User&gt; findByNameContaining(String name);
&#125;
</code></pre>
<h3 id="根据生日查用户、删除User表"><a href="#根据生日查用户、删除User表" class="headerlink" title="根据生日查用户、删除User表"></a>根据生日查用户、删除User表</h3><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;根据生日获取用户信息①&quot;,description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(LocalDate birthDay)&#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;,description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(LocalDate birthDay)&#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除User&quot;,description = &quot;删除User&quot;)
    @GetMapping(&quot;/delete&quot;)
    public void delete()&#123;
        userRepository.delete();
    &#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserRepository.java
@Query(&quot;SELECT u FROM User u WHERE u.birthday=?1&quot;)
    List&lt;User&gt; findByBirthDay(LocalDate birthDay);

    @Query(value = &quot;SELECT * FROM user WHERE birth_day =:birthDay&quot;,nativeQuery = true)
    List&lt;User&gt; findByBirthDayNative(LocalDate birthDay);

    @Modifying
    @Transactional
    @Query(value = &quot;DELETE FROM User&quot;)
    int delete();
</code></pre>
<h3 id="增加审计"><a href="#增加审计" class="headerlink" title="增加审计"></a>增加审计</h3><pre><code class="java">com/pcy/MallApplication.java //【增加@EnableJpaAuditing】
package com.pcy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@EnableJpaAuditing
@SpringBootApplication
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/BaseEntity.java //【没有必要为每个实体类都编写 直接封装导一个类 User去继承】
package com.pcy.dao;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Data;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Data
@MappedSuperclass
//该注解用于监听实体类，在save、update之后的状态
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity &#123;
    @CreatedBy
    @Column(updatable = false)
    private String creator;

    @LastModifiedBy
    private String modifier;

    @CreatedDate
    @Column(updatable = false) //不可修改的
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
&#125;
</code></pre>
<pre><code class="java">com/pcy/dao/User.java //【增加@EqualsAndHashCode 与 extends BaseEntity】
@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    ...
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/AuditorAwareImpl.java
package com.pcy.service.impl;

import org.springframework.data.domain.AuditorAware;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class AuditorAwareImpl implements AuditorAware&lt;String&gt; &#123;

    @Override
    public Optional&lt;String&gt; getCurrentAuditor() &#123;
        // 添加一个随机数
        return Optional.of(&quot;管理员&quot;+(int)(Math.random()));
    &#125;
&#125;
</code></pre>
<h3 id="引入Mybatis-Plus-FreeMarker"><a href="#引入Mybatis-Plus-FreeMarker" class="headerlink" title="引入Mybatis-Plus + FreeMarker"></a>引入Mybatis-Plus + FreeMarker</h3><pre><code class="xml">pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="java">//根据你提供的实体类BaseEntity和User，我为你设计了一个基于MyBatis-Plus 3.5.x版本的代码生成器MysqlGenerator，它将自动生成与这些实体类相关的代码，如Mapper、Service、Controller等。以下是生成器的代码示例
【仅供查看学习 实际代码爆红无法导入】
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.toolkit.StringPool;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.builder.*;
import com.baomidou.mybatisplus.generator.config.po.TableInfo;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
import com.baomidou.mybatisplus.generator.fill.Property;
import com.baomidou.mybatisplus.generator.keywords.MySqlKeyWordsHandler;

import java.util.Collections;

public class MysqlGenerator &#123;

    // 项目路径
    private static final String PROJECT_PATH = System.getProperty(&quot;user.dir&quot;);
    // 输出路径
    private static final String OUTPUT_DIR = PROJECT_PATH + &quot;/src/main/java&quot;;
    // 作者
    private static final String AUTHOR = &quot;YourName&quot;;
    // 包名
    private static final String BASE_PACKAGE = &quot;com.pcy&quot;;
    // 数据源配置
    private static final String DATABASE_URL = &quot;jdbc:mysql://localhost:3306/your_database&quot;;
    private static final String DATABASE_USERNAME = &quot;root&quot;;
    private static final String DATABASE_PASSWORD = &quot;password&quot;;
    private static final String DATABASE_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;

    public static void main(String[] args) &#123;
        // 1. 全局配置
        GlobalConfig.Builder globalConfig = new GlobalConfig.Builder()
            .outputDir(OUTPUT_DIR)
            .author(AUTHOR)
            .enableSwagger()
            .fileOverride()
            .disableOpenDir(); // 不自动打开输出目录

        // 2. 数据源配置
        DataSourceConfig.Builder dataSourceConfig = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
            .dbQuery(new MySqlQuery())
            .schema(&quot;public&quot;)
            .dbType(DbType.MYSQL)
            .keyWordsHandler(new MySqlKeyWordsHandler())
            .driverName(DATABASE_DRIVER);

        // 3. 包配置
        PackageConfig.Builder packageConfig = new PackageConfig.Builder()
            .parent(BASE_PACKAGE)
            .entity(&quot;dao&quot;)
            .mapper(&quot;mapper&quot;)
            .service(&quot;service&quot;)
            .controller(&quot;controller&quot;);

        // 4. 策略配置
        StrategyConfig.Builder strategyConfig = new StrategyConfig.Builder()
            .addInclude(&quot;user&quot;) // 生成指定表
            .addTablePrefix(&quot;t_&quot;) // 去掉表前缀
            .entityBuilder()
                .superClass(BaseEntity.class)
                .enableLombok()
                .addSuperEntityColumns(&quot;id&quot;, &quot;creator&quot;, &quot;modifier&quot;, &quot;create_time&quot;, &quot;update_time&quot;)
                .logicDeleteColumnName(&quot;deleted&quot;)
                .addTableFills(new Property(&quot;create_time&quot;, FieldFill.INSERT))
                .addTableFills(new Property(&quot;update_time&quot;, FieldFill.INSERT_UPDATE))
                .enableActiveRecord()
                .naming(NamingStrategy.underline_to_camel)
                .columnNaming(NamingStrategy.underline_to_camel)
            .controllerBuilder()
                .enableRestStyle()
                .enableHyphenStyle()
            .serviceBuilder()
                .formatServiceFileName(&quot;%sService&quot;)
                .formatServiceImplFileName(&quot;%sServiceImpl&quot;)
            .mapperBuilder()
                .enableBaseResultMap()
                .enableBaseColumnList();

        // 5. 模板配置
        TemplateConfig.Builder templateConfig = new TemplateConfig.Builder();

        // 6. 自定义配置
        InjectionConfig.Builder injectionConfig = new InjectionConfig.Builder()
            .beforeOutputFile((tableInfo, objectMap) -&gt; objectMap.put(&quot;parent&quot;, BASE_PACKAGE));

        // 7. 整合配置
        AutoGenerator autoGenerator = new AutoGenerator(dataSourceConfig.build())
            .global(globalConfig.build())
            .packageInfo(packageConfig.build())
            .strategy(strategyConfig.build())
            .template(templateConfig.build())
            .injection(injectionConfig.build())
            .templateEngine(new FreemarkerTemplateEngine()); // 选择模板引擎

        // 8. 执行
        autoGenerator.execute();
    &#125;
&#125;
/*
关键配置说明：
GlobalConfig：设置代码生成的全局配置，包括作者、输出目录、是否覆盖已有文件等。
DataSourceConfig：配置数据库连接信息，使用MySQL数据库。
PackageConfig：指定生成的代码所在的包路径。
StrategyConfig：配置生成策略，包括实体类的继承关系、使用Lombok、Rest风格的控制器等。
TemplateConfig：模板配置，可定制生成的模板。
InjectionConfig：自定义配置，用于在生成文件前注入自定义的变量或逻辑。
AutoGenerator：整合所有配置并执行代码生成。

生成的文件包括：
实体类：根据数据库表生成实体类，并继承BaseEntity。
Mapper接口：生成Mapper接口用于数据库操作。
Service接口和实现类：生成Service接口及其实现类。
Controller类：生成Rest风格的控制器类。

使用方法：
修改数据库连接信息（DATABASE_URL、DATABASE_USERNAME、DATABASE_PASSWORD）。
配置需要生成代码的表名（addInclude(&quot;user&quot;)）。
运行MysqlGenerator.java的main方法，代码将会生成在指定的输出目录中。
*
</code></pre>
<pre><code class="java">//【以下都是自动生成的代码】
com/pcy/mapper/UserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.User;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/UserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.User;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务类
 * &lt;/p&gt;
 */
public interface UserService extends IService&lt;User&gt; &#123;
// 在Spring中使用事务
    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequired(User user);

    @Transactional(propagation = Propagation.REQUIRED)
    void addWithRequiredAndException(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNew(User user);

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void addWithRequiredNewAndException(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNested(User user);

    @Transactional(propagation = Propagation.NESTED)
    void addWithNestedAndException(User user);
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
package com.pcy.service.impl;


import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import com.pcy.mapper.UserMapper;
import com.pcy.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * &lt;p&gt;
 * 用户表 服务实现类
 * &lt;/p&gt;
 */
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;

    @Autowired
    private UserMapper mapper;
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequired(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void addWithRequiredAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNew(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addWithRequiredNewAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNested(User user) &#123;
        mapper.insert(user);
    &#125;

    @Override
    @Transactional(propagation = Propagation.NESTED)
    public void addWithNestedAndException(User user) &#123;
        mapper.insert(user);
        throw new RuntimeException();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.pcy.mapper.UserMapper&quot;&gt;

    &lt;!-- 通用查询映射结果 --&gt;
    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.pcy.entity.User&quot;&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;creator&quot; property=&quot;creator&quot; /&gt;
    &lt;result column=&quot;modifier&quot; property=&quot;modifier&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; /&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;
        &lt;result column=&quot;email&quot; property=&quot;email&quot; /&gt;
        &lt;result column=&quot;birth_day&quot; property=&quot;birthDay&quot; /&gt;
    &lt;/resultMap&gt;

    &lt;!-- 通用查询结果列 --&gt;
    &lt;sql id=&quot;Base_Column_List&quot;&gt;
        id,
        creator,
        modifier,
        create_time,
        update_time,
        name, email, birth_day
    &lt;/sql&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">//【提问：爆bug  &quot;Could not autowire. No beans of &#39;UserMapper&#39; type found&quot;】 深度解析
1. @MapperScan 注解的原理 //启动类里面的 @MapperScan(&quot;com.pcy.mapper&quot;)
@MapperScan 是 MyBatis-Spring 提供的一个注解，用于指定要扫描的 Mapper 接口所在的包路径。它的作用是告诉 Spring 框架应该在哪些包路径下寻找 Mapper 接口，并将它们注册为 Spring 的 Bean。
扫描 Mapper 接口：Spring Boot 在启动时，会扫描你指定的包路径下的所有接口，并检测这些接口是否包含 MyBatis 的 Mapper 注解或者继承了 BaseMapper 等相关接口。
注册为 Bean：一旦找到这些接口，Spring 会自动为这些接口生成一个实现类，并将它们注册为 Spring 容器中的 Bean，这样你就可以通过 @Autowired 注入这些 Mapper。

2. @Mapper 注解的原理
@Mapper 是 MyBatis 提供的一个注解，用于标记一个接口为 MyBatis 的 Mapper 接口。被标记为 @Mapper 的接口会被 MyBatis-Spring 扫描到，并且 MyBatis 会为该接口生成一个实现类，负责执行 SQL 语句。
当你在 UserMapper 接口上添加 @Mapper 注解时，即使没有使用 @MapperScan，MyBatis 也会知道这个接口是一个 Mapper 接口，并将其注册为一个 Bean。这使得你可以在 UserServiceImpl 中通过 @Autowired 注入它。

3. 为什么使用 @MapperScan 和 @Mapper 不会报错
自动注册 Bean：@MapperScan 会自动扫描指定包路径下的所有 Mapper 接口，并将它们注册为 Spring 容器中的 Bean。这意味着在 UserServiceImpl 中，当你使用 @Autowired 注入 UserMapper 时，Spring 可以找到对应的 Bean，从而避免 Could not autowire 错误。
手动注册 Bean：当你在 Mapper 接口上直接使用 @Mapper 注解时，Spring 也会将该接口注册为一个 Bean，这样你同样可以通过 @Autowired 进行注入，而不会出现 Bean 找不到的问题。
</code></pre>
<pre><code class="java">//【提问：MysqlGenerator 逆向生成那些包的原理】
MyBatis-Plus 提供的 MyBatis-Plus Generator 是一个非常强大的代码生成工具，可以通过数据库表结构生成对应的 Java 代码，包括实体类、Mapper 接口、Mapper XML 文件、Service 类、Controller 类等。这个过程通常被称为“逆向工程”或“代码生成”。
1. MyBatis-Plus Generator 的工作原理
 1.1 读取数据库表结构
数据源配置：首先，MyBatis-Plus Generator 通过配置的数据源连接到指定的数据库。它会读取数据库中的表结构信息，包括表名、字段名、数据类型、主键、外键、索引等信息。
&gt; DataSourceConfig dsc = new DataSourceConfig.Builder(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD)
    .driverName(DATABASE_DRIVER)
    .build();

元数据解析：MyBatis-Plus Generator 通过 JDBC 获取数据库的元数据 (Metadata)，并解析每个表的结构，将其转换为可以用于代码生成的数据结构。

 1.2 生成代码
代码生成器：AutoGenerator 是核心的代码生成器类。它根据从数据库中获取的表结构信息，生成相应的 Java 类文件。
&gt; AutoGenerator generator = new AutoGenerator(dsc);

模板引擎：MyBatis-Plus Generator 使用模板引擎（例如 Freemarker）来渲染代码模板。通过模板和解析后的元数据，生成代码文件。每个生成的 Java 类文件都对应着一个模板文件，模板文件中包含了如何生成特定类型文件的逻辑。
&gt; generator.templateEngine(new FreemarkerTemplateEngine());

 1.3 生成的包和文件
实体类 (entity)：根据表结构生成对应的 Java 实体类。每个实体类与数据库表一一对应，包含表中字段的定义。
&gt; strategyConfig.entityBuilder().enableLombok().naming(NamingStrategy.underline_to_camel);

Mapper 接口 (mapper)：生成的 Mapper 接口用于与数据库交互，执行基本的增删改查操作。Mapper 接口通常继承自 BaseMapper，提供基本的 CRUD 操作。
&gt; strategyConfig.mapperBuilder().enableBaseResultMap().enableBaseColumnList();
Mapper XML 文件 (mapper.xml)：生成的 Mapper XML 文件包含了 Mapper 接口中对应的方法的 SQL 语句。这些 XML 文件用于定义复杂的查询、更新语句等。

Service 接口和实现类 (service, service.impl)：Service 层是业务逻辑层。生成的 Service 接口提供了业务操作的定义，Service 实现类则实现这些业务操作。
&gt; strategyConfig.serviceBuilder().formatServiceFileName(&quot;%sService&quot;);

Controller 类 (controller)：生成的 Controller 类用于处理 HTTP 请求，调用 Service 层的方法进行业务处理，然后返回结果。Controller 通常与前端交互，处理用户请求。
&gt; strategyConfig.controllerBuilder().enableRestStyle().enableHyphenStyle();


2. MyBatis-Plus Generator 如何生成这些包和文件
 2.1 代码生成策略 (StrategyConfig)
StrategyConfig 类用于配置代码生成的策略，如生成哪些表，生成哪些类，类的命名规则，是否使用 Lombok 等。
StrategyConfig strategyConfig = new StrategyConfig.Builder()
    .addInclude(&quot;user&quot;) // 生成指定表
    .entityBuilder().enableLombok() // 实体类配置
    .mapperBuilder().enableBaseResultMap() // Mapper 配置
    .serviceBuilder().formatServiceFileName(&quot;%sService&quot;) // Service 配置
    .controllerBuilder().enableRestStyle() // Controller 配置
    .build();

 2.2 模板文件
MyBatis-Plus Generator 使用的模板文件可以自定义，通常位于 resources/templates 目录下。每个模板文件对应一个需要生成的 Java 文件类型，例如 entity.java.ftl 对应实体类，mapper.java.ftl 对应 Mapper 接口。
     
模板文件中可以使用变量和逻辑来决定生成的代码内容。例如，$&#123;className&#125; 会被替换为实际的类名，&lt;#if useLombok&gt; @Data &lt;/#if&gt; 会根据条件生成代码。
     
 2.3 文件输出配置 (InjectionConfig 和 FileOutConfig)
通过 InjectionConfig 和 FileOutConfig，可以控制生成文件的路径、名称、以及自定义生成的文件内容。例如，可以指定某个表的实体类生成到特定的包下，或者将 XML 文件输出到特定的路径。
InjectionConfig cfg = new InjectionConfig.Builder()
    .beforeOutputFile((tableInfo, objectMap) -&gt; &#123;
        // 自定义处理逻辑
    &#125;)
    .build();
</code></pre>
<h3 id="用MyBatis-Plus的分页"><a href="#用MyBatis-Plus的分页" class="headerlink" title="用MyBatis Plus的分页"></a>用MyBatis Plus的分页</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.pcy&lt;/groupId&gt;
    &lt;artifactId&gt;Pluminary&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;Pluminary&lt;/name&gt;
    &lt;description&gt;Pluminary&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.2.15&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;!--        &lt;dependency&gt;--&gt;
&lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
&lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
&lt;!--            &lt;version&gt;8.0.33&lt;/version&gt;--&gt;
&lt;!--        &lt;/dependency&gt;--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;6.1.7.Final&lt;/version&gt; &lt;!-- 选择与 Spring Boot 3.3.2 兼容的版本 --&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
                    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;3.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
            &lt;version&gt;3.5.5&lt;/version&gt; &lt;!-- 版本对齐 --&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">//【添加MyBatis-Plus的分页插件】
com/pcy/utils/MyBatisPlusConfig.java
package com.pcy.utils;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
//@Configuration 用于定义配置类，被注解的类内部包含有一个或多个被@Bean注解的方法
// 用于构建bean定义，初始化Spring容器
@Configuration
public class MyBatisPlusConfig &#123;
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MARIADB));
        return interceptor;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java //【增加listPage】
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserRepository;
import com.pcy.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping(&quot;/users&quot;)
@Tag(name = &quot;User Controller&quot;, description = &quot;用户相关操作&quot;)
public class UserController &#123;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;

    @Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)
    @PostMapping
    public User create(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;更新用户&quot;, description = &quot;更新用户信息&quot;)
    @PutMapping
    public User update(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;

    @Operation(summary = &quot;删除用户&quot;, description = &quot;根据ID删除用户&quot;)
    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void delete(@PathVariable int id) &#123;
        userRepository.deleteById(id);
    &#125;

    @Operation(summary = &quot;获取用户列表&quot;, description = &quot;获取用户列表&quot;)
    @GetMapping(&quot;/list&quot;)
    public org.springframework.data.domain.Page&lt;User&gt; list(@RequestParam(defaultValue = &quot;id&quot;) String property,
                                                           @RequestParam(defaultValue = &quot;ASC&quot;) Sort.Direction direction,
                                                           @RequestParam(defaultValue = &quot;0&quot;) Integer page,
                                                           @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        Pageable pageable = PageRequest.of(page, pageSize, direction, property);
        return userRepository.findAll(pageable);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息①&quot;, description = &quot;根据生日获取用户信息①&quot;)
    @GetMapping(&quot;/birthdayOne&quot;)
    public List&lt;User&gt; getBirthDayOne(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDay(birthDay);
    &#125;

    @Operation(summary = &quot;根据生日获取用户信息②&quot;, description = &quot;根据生日获取用户信息②&quot;)
    @GetMapping(&quot;/birthdayTwo&quot;)
    public List&lt;User&gt; getBirthDayTwo(@RequestParam LocalDate birthDay) &#123;
        return userRepository.findByBirthDayNative(birthDay);
    &#125;

    @Operation(summary = &quot;删除所有用户&quot;, description = &quot;删除所有用户&quot;)
    @DeleteMapping(&quot;/deleteAll&quot;)
    public void deleteAll() &#123;
        userRepository.deleteAll();
    &#125;

    @Operation(summary = &quot;分页查询用户列表&quot;, description = &quot;分页查询用户列表&quot;)
    @GetMapping(&quot;/page&quot;)
    public Page&lt;User&gt; listPage(@RequestParam(defaultValue = &quot;1&quot;) Integer page,
                               @RequestParam(defaultValue = &quot;10&quot;) Integer pageSize) &#123;
        return userService.page(new Page&lt;&gt;(page, pageSize));
    &#125;
&#125;
</code></pre>
<h3 id="高级SQL语句-Lambda"><a href="#高级SQL语句-Lambda" class="headerlink" title="高级SQL语句(Lambda)"></a>高级SQL语句(Lambda)</h3><pre><code class="java">wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
/*
Lambda 表达式:

user -&gt; user.getName() 是一个 Lambda 表达式。
user 是 User 类的一个实例，作为 Lambda 表达式的输入参数。
user.getName() 是对 user 对象的 getName() 方法的调用，返回 name 字段的值。
作用:

这行代码告诉 MyBatis-Plus：在生成的 SQL 查询中，查找 name 字段值中包含 &quot;p&quot; 的所有记录。
wrapper.lambda() 返回一个 LambdaQueryWrapper&lt;User&gt; 对象，支持使用 Lambda 表达式进行条件构建。
.like() 方法添加了一个 LIKE 条件，表示在 SQL 查询中进行模糊匹配。
*/


wrapper.lambda().like(User::getName, &quot;p&quot;);
/*
方法引用:

User::getName 是一种方法引用，它引用了 User 类的 getName() 方法。
方法引用是对 Lambda 表达式的一种简写。它表示将某个方法作为函数式接口的实现。
作用:

这行代码与第一行代码的作用相同，都是在生成的 SQL 查询中查找 name 字段值中包含 &quot;p&quot; 的所有记录。
User::getName 告诉 MyBatis-Plus：使用 User 类中的 getName() 方法来获取要参与条件判断的字段。
*/
</code></pre>
<pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;自定义查询&quot;, description = &quot;自定义查询&quot;)
    @GetMapping(&quot;/Dingyi&quot;)
    public List&lt;User&gt; getWrapper() &#123; //类型List&lt;User&gt; 可以返回数据库列表
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();
//        wrapper.eq(&quot;name&quot;, &quot;潘春尧&quot;);
//        wrapper.lambda().ge(User::getBirthDay, LocalDate.parse(&quot;2011-01-01&quot;));
//        wrapper.between(User::getBirthDay, &quot;2011-01-01&quot;, &quot;2011-12-31&quot;);
        wrapper.lambda().like(User::getName, &quot;string&quot;);

//      wrapper.lambda().like(user -&gt; user.getName(), &quot;p&quot;);
//        wrapper.select(&quot;name,count(*)&quot;).groupBy(&quot;name&quot;);
//        return (QueryWrapper&lt;User&gt;) userMapper.selectList(wrapper);
//        wrapper.in(CollectionUtils.isNotEmpty(nameList), User::getName, nameList);
        return userMapper.selectList(wrapper);
    &#125;
</code></pre>
<h3 id="自动填充、填充实现策略"><a href="#自动填充、填充实现策略" class="headerlink" title="自动填充、填充实现策略"></a>自动填充、填充实现策略</h3><pre><code class="java">com/pcy/utils/MyMetaObjectHandler.java
package com.pcy.utils;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;

import java.time.LocalDateTime;

public class MyMetaObjectHandler implements MetaObjectHandler &#123;
    @Override
    public void insertFill(MetaObject metaObject) &#123;
        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictInsertFill(metaObject, &quot;creator&quot;, this::getCurrentUser, String.class);
        this.strictInsertFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;

    @Override
    public void updateFill(MetaObject metaObject) &#123;
        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime::now, LocalDateTime.class);
        this.strictUpdateFill(metaObject, &quot;modifier&quot;, this::getCurrentUser, String.class);
    &#125;
    
    // 模拟获取当前用户
    private String getCurrentUser()&#123;
        return &quot;管理员&quot; + (int) (Math.random() * 10);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 这是自动填充的原理
default MetaObjectHandler strictFillStrategy(MetaObject metaObject, String fieldName, Supplier&lt;?&gt; fieldVal) &#123;
        if (metaObject.getValue(fieldName) == null) &#123;
            Object obj = fieldVal.get();
            if (Objects.nonNull(obj)) &#123;
                metaObject.setValue(fieldName, obj);
            &#125;
        &#125;
        return this;
    &#125;
</code></pre>
<h3 id="强大的Druid"><a href="#强大的Druid" class="headerlink" title="强大的Druid"></a>强大的Druid</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">// Druid和MariaDB是两种不同类型的数据库系统
1、类型和用途：
Druid：Druid是一种分布式的实时分析数据库，主要用于处理高吞吐量的时间序列数据或事件数据。它专为快速查询和分析大规模数据而设计，常用于数据仓库、在线分析处理（OLAP）以及实时数据分析等场景。
MariaDB：MariaDB是一种关系型数据库管理系统（RDBMS），它是MySQL的一个分支，广泛用于常规的事务处理、数据存储和管理。MariaDB通常用于传统的OLTP（在线事务处理）场景，如web应用、内容管理系统等。

2、适用场景：
Druid：适合用于实时数据分析、日志分析、时间序列分析、用户行为分析等需要快速响应的场景。
MariaDB：适合传统的数据库应用，如电子商务系统、内容管理系统、ERP、CRM等需要强事务处理能力的场景。
    
总结来说，Druid和MariaDB各自适用于不同的数据处理需求，Druid更侧重于实时分析和大规模数据处理，而MariaDB更侧重于事务处理和关系型数据管理
</code></pre>
<h3 id="Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明"><a href="#Spring-Data-JPA与MyBatis-Plus的区别并且简单举例说明" class="headerlink" title="Spring Data JPA与MyBatis-Plus的区别并且简单举例说明"></a>Spring Data JPA与MyBatis-Plus的区别并且简单举例说明</h3><pre><code class="java">Spring Data JPA: //【实现接口】

@Entity
public class User &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;
    List&lt;User&gt; findByName(String name);
&#125;
</code></pre>
<pre><code class="java">Spring Data JPA: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/jpa/users&quot;)
public class UserJpaController &#123;

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userRepository.findAll();
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userRepository.findById(id)
                             .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));
    &#125;

    @PostMapping
    public User createUser(@RequestBody User user) &#123;
        return userRepository.save(user);
    &#125;
    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public User updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        user.setName(userDetails.getName());
        // Update other fields here
        return userRepository.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userRepository.findById(id)
                                  .orElseThrow(() -&gt; new ResourceNotFoundException(&quot;User not found with id: &quot; + id));

        userRepository.delete(user);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userRepository.findByName(name);
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<pre><code class="java">MyBatis Plus: //【实现接口】

@TableName(&quot;user&quot;)
public class User &#123;
    private Long id;
    private String name;
    // Other fields, getters, and setters
&#125;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
    // Custom SQL
    @Select(&quot;SELECT * FROM user WHERE name = #&#123;name&#125;&quot;)
    List&lt;User&gt; selectByName(@Param(&quot;name&quot;) String name);
&#125;
</code></pre>
<pre><code class="java">MyBatis-Plus: //【实现控制类】
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping
    public List&lt;User&gt; getAllUsers() &#123;
        return userMapper.selectList(null);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    public User getUserById(@PathVariable Long id) &#123;
        return userMapper.selectById(id);
    &#125;

    @PostMapping
    public void createUser(@RequestBody User user) &#123;
        userMapper.insert(user);
    &#125;

    @PutMapping(&quot;/&#123;id&#125;&quot;)
    public void updateUser(@PathVariable Long id, @RequestBody User userDetails) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        user.setName(userDetails.getName());
        // Update other fields here
        userMapper.updateById(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    public void deleteUser(@PathVariable Long id) &#123;
        User user = userMapper.selectById(id);
        if (user == null) &#123;
            throw new ResourceNotFoundException(&quot;User not found with id: &quot; + id);
        &#125;

        userMapper.deleteById(id);
    &#125;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        return userMapper.selectByName(name);
    &#125;
&#125;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 构建查询条件的包装类，它使用 Lambda 表达式避免了手写字符串可能导致的字段错误。
// 这种方式非常适合需要根据多个条件动态生成SQL查询的场景，使用LambdaQueryWrapper不仅能提高代码的可读性，还能减少由于硬编码字符串导致的错误。
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/mybatis/users&quot;)
public class UserMyBatisController &#123;

    @Autowired
    private UserMapper userMapper;

    @GetMapping(&quot;/search&quot;)
    public List&lt;User&gt; searchUsersByName(@RequestParam String name) &#123;
        // 使用 LambdaQueryWrapper 构建模糊查询条件
        LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();
        queryWrapper.like(User::getName, name); // 类似于 SQL 中的 &quot;WHERE name LIKE &#39;%name%&#39;&quot;

        // 执行查询并返回结果
        return userMapper.selectList(queryWrapper);
    &#125;
    // 其他CRUD方法与前面的示例相同
&#125;
</code></pre>
<h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h6 id="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"><a href="#经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。" class="headerlink" title="经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。"></a>经过单元测试，观察日志输出，就会发现没有进行数据库查询，对数据库的交互逻辑不是Service层的单元测试需要关心的事情，而是Dao层的单元测试需要考虑的。Service层的单元测试是假定Dao层全部正确的基础上写的，我们只需要关注Service层是正确即可。</h6><pre><code class="xml">pom.xml
          &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserServiceImpl.java
@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;
    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);
    @Autowired
    private UserMapper mapper;

    public User getById(int id) &#123;
        logger.info(&quot;id为：&quot;,id);
        return mapper.selectById(id);
    &#125;
......
&#125;
</code></pre>
<h6 id="这是测试Service"><a href="#这是测试Service" class="headerlink" title="这是测试Service"></a>这是测试Service</h6><pre><code class="java">test/java  com/pcy/service/impl/UserServiceImplTest.java //【用Mock改造 + log4j】
// 检查 UserServiceImpl 是否在测试中被 @MockBean 或其他方式替换为Mock对象。如果使用了Mock对象，测试时不会真正访问数据库，而是使用模拟数据。
package com.pcy.service.impl;

import com.pcy.entity.User;
import com.pcy.mapper.UserMapper;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class UserServiceImplTest &#123;
    @InjectMocks
    UserServiceImpl userService;

    @Mock
    UserMapper userMapper;

    @Test
    @DisplayName(&quot;Test Service getById&quot;)
    void getById() &#123;
        // 模拟userMapper的selectById方法返回一个User对象
        User mockUser = new User().setId(1).setName(&quot;qwe&quot;).setEmail(&quot;1234@qq.com&quot;);
        Mockito.when(userMapper.selectById(1)).thenReturn(mockUser);

        // 调用userService的getById方法，并验证返回结果
        User user = userService.getById(1);

        System.out.println(user);
        Assertions.assertEquals(&quot;qwe&quot;, user.getName());
    &#125;
&#125;
=====================================================================
Java HotSpot(TM) 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
2024-08-12T21:18:07.805+08:00  INFO 31512 --- [Pluminary] [           main] com.pcy.service.impl.UserServiceImpl     : id为：
User(id=1, name=qwe, age=0, email=1234@qq.com, birthDay=null)
</code></pre>
<pre><code class="java">com/pcy/entity/User.java
//你的 User 类同时使用了 Lombok 注解 (@Data, @Accessors(chain = true)) 和手动定义的 getter/setter 方法。由于 Lombok 已经生成了这些方法，手动定义的 getter/setter 方法会覆盖 Lombok 自动生成的方法，这可能导致链式调用的 setEmail 和其他类似方法无法正确解析。
package com.pcy.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.time.LocalDate;

@Data
@Entity
@EqualsAndHashCode(callSuper = true)
//@Schema(name=&quot;用户信息&quot;)
@Table(indexes = &#123;@Index(name = &quot;uk_email&quot;,columnList = &quot;email&quot;,unique = true)&#125;)
@Accessors(chain = true) // 允许链式调用
public class User extends BaseEntity&#123;
    @Id
//    @Schema(description = &quot;用户ID&quot;)
//    @NotBlank(message = &quot;Id不能为空&quot;)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

//    @Schema(description = &quot;用字&quot;)
//    @NotBlank(message = &quot;名字不能为空&quot;)
    @Column(nullable = false, columnDefinition = &quot;varchar(20) comment &#39;姓名&#39;&quot;)
    private String name;

//    @Transient //注解修饰
//    @Schema(description = &quot;年龄&quot;)
//    @Min(value = 1, message = &quot;年龄不能小于1&quot;)
    private int age;

//    @Schema(description = &quot;邮箱&quot;)
//    @Email(message = &quot;E-mail格式不正确&quot;)
    @Column(nullable = false, length = 50)
    private String email;

//    @Schema(description = &quot;生日&quot;)
//    @Past(message = &quot;生日必须为过去的时间&quot;)
    private LocalDate birthDay;
&#125;
</code></pre>
<h6 id="这是测试Controller"><a href="#这是测试Controller" class="headerlink" title="这是测试Controller"></a>这是测试Controller</h6><pre><code class="java">test/java  com/pcy/controller/UserControllerTest.java
// Controller层的单元测试需要用到一个特定的类——MockMvc 专门为SpringMVC提供支持的
package com.pcy.controller;

import com.pcy.entity.User;
import com.pcy.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.annotation.Before;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.BDDMockito;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.junit.jupiter.api.Assertions.*;
@Slf4j
@SpringBootTest
class UserControllerTest &#123;
    MockMvc mockMvc;

    @Mock
    UserService userService;

    @InjectMocks
    UserController userController;

    @BeforeEach
    void setUp()&#123;
        mockMvc = MockMvcBuilders.standaloneSetup(userController).build();
    &#125;

    @Test
    @DisplayName(&quot;Test Controller get&quot;)
    void get() throws Exception &#123;
        Mockito.when(userService.getById(1)).thenReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        BDDMockito.given(userService.getById(1)).willReturn(new User().setName(&quot;刘水镜&quot;).setEmail(&quot;liushuijing@mail.com&quot;));
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/&#123;id&#125;&quot;, 1)
                        .accept(&quot;application/json;charset=UTF-8&quot;)
                        .contentType(&quot;application/json;charset=UTF-8&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;).value(&quot;刘水镜&quot;))
                .andDo(MockMvcResultHandlers.print())
                .andReturn();
        log.info(&quot;Test Controller get&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><pre><code class="java">/*
一、@RestControllerAdvice 注解的作用
@RestControllerAdvice 是 Spring Framework 为我们提供的一个复合注解，它是 @ControllerAdvice 和 @ResponseBody 的结合体。

@ControllerAdvice：该注解标志着一个类可以为所有的 @RequestMapping 处理方法提供通用的异常处理和数据绑定等增强功能。当应用到一个类上时，该类中定义的方法将在所有控制器类的请求处理链中生效。

@ResponseBody：表示方法的返回值将被直接写入 HTTP 响应体中，通常配合 Jackson 或 Gson 等 JSON 库将对象转换为 JSON 格式的响应。

因此，@RestControllerAdvice 就是专门为 RESTful 控制器设计的全局异常处理器，它的方法返回值将自动转换为响应体。
*/
</code></pre>
<h6 id="“全球”异常"><a href="#“全球”异常" class="headerlink" title="“全球”异常"></a>“全球”异常</h6><pre><code class="java">com/pcy/controller/UserController.java
@Operation(summary = &quot;异常查询&quot;, description = &quot;异常查询&quot;)
    @GetMapping(value = &quot;/&#123;id&#125;&quot;)
    public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
        User user = userService.getById(id);
        if (user == null)&#123;
            throw new RuntimeException(&quot;找不到id信息&quot; + id);
        &#125;
        return Result.success(userService.getById(id));
    &#125;
/*
当输入id信息错误的时候
&#123;
  &quot;code&quot;: 200,
  &quot;message&quot;: &quot;操作成功&quot;,
  &quot;data&quot;: &#123;
    &quot;creator&quot;: null,
    &quot;modifier&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;潘春尧&quot;,
    &quot;age&quot;: 1,
    &quot;email&quot;: &quot;390@qq.com&quot;,
    &quot;birthDay&quot;: &quot;2024-08-10&quot;
  &#125;
&#125;


当输入id信息错误的时候
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;找不到id信息3323&quot;,
  &quot;data&quot;: null
&#125;
*/
</code></pre>
<pre><code class="java">com/pcy/utils/GlobalExceptionHandler.java
package com.pcy.utils;

import com.pcy.entity.MessageEnum;
import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler &#123;
//@ExceptionHandler注解用于在Spring MVC控制器中处理特定类型的异常。它可以应用于方法上
//当控制器方法抛出指定类型的异常时，@ExceptionHandler注解的方法将被调用来处理该异常
    @ExceptionHandler(Exception.class)
    public Result&lt;Boolean&gt; globalException(Exception e)&#123;
        Result&lt;Boolean&gt; result = new Result&lt;&gt;();
        result.setCode(MessageEnum.ERROR.getCode());
        result.setMessage(e.getMessage() == null ? MessageEnum.ERROR.getMessage() : e.getMessage());
        log.error(e.getMessage(), e);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/MessageEnum.java
package com.pcy.entity;

import lombok.Getter;

@Getter
public enum MessageEnum &#123;
    SUCCESS(200, &quot;操作成功&quot;),
    ERROR(500, &quot;操作失败&quot;);

    private final Integer code;
    private final String message;
    MessageEnum(Integer code, String message)&#123;
        this.code = code;
        this.message = message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/Result.java
package com.pcy.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result&lt;T&gt; &#123;
   private Integer code;
   private String message;
   private T data;
   // 用于生成一个没有具体数据内容的成功响应
   public static &lt;T&gt; Result&lt;T&gt; success()&#123;
       return success(null);
   &#125;
   // 用于生成包含数据的成功响应
    public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123;
        return new Result&lt;&gt;(MessageEnum.SUCCESS.getCode(), MessageEnum.SUCCESS.getMessage(), data);
    &#125;
    // 用于生成一个没有具体错误信息的默认错误响应
    public static&lt;T&gt; Result&lt;T&gt; error()&#123;
        return error(MessageEnum.ERROR);
    &#125;
    // 用于生成带有特定错误信息的错误响应，MessageEnum 是一个枚举类型，包含了不同的错误信息和代码。
    public static&lt;T&gt; Result&lt;T&gt; error(MessageEnum messageEnum)&#123;
        return new Result&lt;&gt;(messageEnum.ERROR.getCode(), messageEnum.getMessage(), null);
    &#125;
    // 用于生成包含自定义错误信息的错误响应
    public static &lt;T&gt; Result&lt;T&gt; error(String message) &#123;
        return error(message, MessageEnum.ERROR.getCode());
    &#125;
    // 用于生成包含自定义错误信息和自定义状态码的错误响应
    protected static &lt;T&gt; Result&lt;T&gt; error(String message, Integer code) &#123;
        return new Result&lt;&gt;(code, message, null);
    &#125;
&#125;
</code></pre>
<h6 id="写个小异常"><a href="#写个小异常" class="headerlink" title="写个小异常"></a>写个小异常</h6><pre><code class="java">com/pcy/controller/ExceptionController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/exception&quot;)
@Tag(name = &quot;Exception&quot;, description = &quot;异常操作&quot;)
public class ExceptionController &#123;
    @GetMapping(&quot;/runtimeexception&quot;)
    public Result&lt;Boolean&gt; runtimeException()&#123;
        throw new RuntimeException();
    &#125;
&#125;
/*
开启全局异常处理的返回值
&#123;
  &quot;code&quot;: 500,
  &quot;message&quot;: &quot;操作失败&quot;,
  &quot;data&quot;: null
&#125;

没有全局异常处理的错误返回值
&#123;
  &quot;timestamp&quot;: &quot;2024-08-13T08:21:43.192+00:00&quot;,
  &quot;status&quot;: 500,
  &quot;error&quot;: &quot;Internal Server Error&quot;,
  &quot;path&quot;: &quot;/exception/runtimeexception&quot;
&#125;
*/
</code></pre>
<pre><code class="java">//在SwaggerConfig中添加扫描路径 &quot;/exception/**&quot;  不然接口无法获取
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">你提到的 GlobalExceptionHandler 和 ExceptionController 是用于统一处理 Spring MVC 控制器中的异常。让我逐步分析它们的作用，以及为什么在某些情况下它返回错误值。

//1. GlobalExceptionHandler 的作用
@RestControllerAdvice：这个注解用来全局处理控制器层的异常。它会拦截所有抛出的异常，并根据异常类型调用相应的 @ExceptionHandler 方法。

@ExceptionHandler(Exception.class)：这个注解标注的方法会在控制器抛出 Exception 或其子类时执行。它用来捕获并处理全局的异常，比如你代码中的 RuntimeException。

globalException(Exception e)：这是一个全局异常处理方法。当控制器中出现 Exception 时，这个方法会被调用。它将返回一个带有错误状态码的 Result&lt;Boolean&gt; 对象，并且会将错误信息记录到日志中。

//2. ExceptionController 的作用
@RestController：声明这个类是一个 Spring MVC 控制器，处理 Web 请求并返回数据。

runtimeException() 方法：在这个方法中，你手动抛出了一个 RuntimeException，这会触发 GlobalExceptionHandler 中的 globalException 方法，并返回一个包含错误信息的 Result&lt;Boolean&gt; 对象。

//3. 为什么只有引用 runtimeException() 才返回错误值
runtimeException() 方法直接抛出了一个 RuntimeException，因此会被 GlobalExceptionHandler 捕获并处理。这就是为什么在访问 /exception/runtimeexception 时，你会看到返回的是错误信息。

//4. 在 get() 方法中返回 200 状态码的原因
在 get() 方法中，如果你传入的 id 是无效的，返回的 Result&lt;User&gt; 仍然会是 Result.success(userService.getById(id))，即使 userService.getById(id) 返回的是 null。这种情况下，你的 Result.success(null) 仍然会返回状态码 200，因为 Result.success() 的设计是用于表示成功状态的，且你没有抛出任何异常。

//5. 如何让 get() 方法在出错时返回错误信息
你可以通过以下方法来确保在 get() 方法中传入无效的 id 时，抛出异常并触发全局异常处理器：

手动抛出异常：

java
复制代码
@GetMapping(value = &quot;/&#123;id&#125;&quot;)
public Result&lt;User&gt; get(@PathVariable Integer id) &#123;
    User user = userService.getById(id);
    if (user == null) &#123;
        throw new RuntimeException(&quot;User not found with id: &quot; + id);
    &#125;
    return Result.success(user);
&#125;
在 userService.getById(id) 方法中抛出异常：如果你的业务逻辑要求在找不到用户时抛出异常，那么可以在 userService.getById(id) 方法中实现这个逻辑。

//6. 总结
GlobalExceptionHandler 用于捕获和处理全局异常。
当你手动抛出 RuntimeException 或其他异常时，它会捕获并返回带有错误信息的 Result。
在 get() 方法中，如果你想要在找不到用户时返回错误信息，需要手动抛出异常，这样才能触发 GlobalExceptionHandler。
</code></pre>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><h6 id="方法一：直接编写使用"><a href="#方法一：直接编写使用" class="headerlink" title="方法一：直接编写使用"></a>方法一：直接编写使用</h6><pre><code class="java">// [配置方法：一种是直接在application.yml文件中配置、另一种是在外置logback-spring.xml文件中配置]
logging:
  pattern:
    console: &quot;%d - %m%n&quot;
</code></pre>
<h6 id="方法二：引用外置xml文件"><a href="#方法二：引用外置xml文件" class="headerlink" title="方法二：引用外置xml文件"></a>方法二：引用外置xml文件</h6><pre><code class="xml">resources/pom.xml               &lt;引用外部的配置&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
&lt;/dependency&gt;

resources/application.yaml
logging:
  config: classpath:logback-spring.xml
</code></pre>
<pre><code class="xml">               &lt;如果你有更多样的配置需求，就需要使用外置XML文件的配置方式&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;configuration&gt;

    &lt;!--    日志文件存放路径--&gt;
    &lt;property name=&quot;PATH&quot; value=&quot;C:/Users/Pluminary/Desktop/log&quot;/&gt;

    &lt;!-- 彩色日志依赖的渲染类 --&gt;
    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wex&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;conversionRule conversionWord=&quot;wEx&quot;
                    converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;/&gt;
    &lt;!-- 彩色日志格式 --&gt;
    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;
              value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;
    &lt;!-- 文件日志格式 --&gt;
    &lt;property name=&quot;FILE_LOG_PATTERN&quot;
              value=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&quot;/&gt;

    &lt;!-- 控制台输出配置--&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;pattern&gt;
                $&#123;CONSOLE_LOG_PATTERN&#125;
            &lt;/pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- INFO 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;info&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 INFO 级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
            &lt;level&gt;INFO&lt;/level&gt;
            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;
            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/info.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/info.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!-- ERROR 级别日志文件输出配置--&gt;
    &lt;appender name=&quot;error&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;!--按级别过滤日志，只输出 ERROR 及以上级别--&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
        &lt;/filter&gt;
        &lt;!--当天日志文件名--&gt;
        &lt;File&gt;$&#123;PATH&#125;/error.log&lt;/File&gt;
        &lt;!--按天分割日志文件--&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!--历史日志文件名规则--&gt;
            &lt;fileNamePattern&gt;$&#123;PATH&#125;/error.log.%d&#123;yyyy-MM-dd&#125;.%i&lt;/fileNamePattern&gt;
            &lt;!--按大小分割同一天的日志--&gt;
            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;!--日志输出格式--&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;!--日志级别--&gt;
    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
        &lt;appender-ref ref=&quot;info&quot;/&gt;
        &lt;appender-ref ref=&quot;error&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
                   
                   
&lt;
Logback 能够精确区分并输出特定日志级别的错误，是通过 Appender 配置中的 Filter 机制实现的。在你的 Logback 配置文件中，RollingFileAppender 使用了不同的 Filter 来确保只有指定级别的日志信息会被记录到特定的日志文件中。

工作原理
LevelFilter 和 ThresholdFilter:

LevelFilter: 这个过滤器允许你指定只接受特定日志级别的日志。例如，LevelFilter 被配置为只接受 INFO 级别的日志，而拒绝其他级别的日志。&lt;level&gt;INFO&lt;/level&gt; 表示只记录 INFO 级别的日志。
ThresholdFilter: 这个过滤器允许你指定一个日志级别的下限，只有高于或等于这个级别的日志才会被记录。例如，ThresholdFilter 被配置为只接受 ERROR 级别及以上的日志（例如 ERROR 和 FATAL）。
日志级别的传递:

日志框架从最底层（比如 TRACE）开始逐级向上检查日志的级别，直到它与 Appender 中配置的 Filter 级别匹配。例如，如果一个 ERROR 级别的日志被触发，RollingFileAppender 的 ThresholdFilter 将检测到这个日志并允许它通过，然后将日志写入指定的 error.log 文件。
日志级别匹配:

当应用程序运行时，它会生成不同级别的日志信息（如 DEBUG、INFO、WARN、ERROR 等）。每个 Appender 都会根据它的 Filter 规则检查这些日志条目。只有符合条件的日志条目才会被记录到相应的日志文件中。
&gt;
</code></pre>
<h3 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h3><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/AspectController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/Swagger/SwaggerConfig.java //【增加&quot;/aspect/**&quot;】
package com.pcy.Swagger;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
// http://localhost:8080/swagger-ui/index.html
@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;

    @Bean
    public OpenAPI customOpenAPI() &#123;
        return new OpenAPI()
                .info(new Info()
                        .title(&quot;Spring Boot 实战&quot;)
                        .version(&quot;1.0&quot;)
                        .description(&quot;Spring Boot 实战的 RESTFul 接口文档说明&quot;)
                        .contact(new Contact()
                                .name(&quot;Pluminary&quot;)
                                .url(&quot;https://github.com/P-luminary&quot;)
                                .email(&quot;390415030@qq.com&quot;)));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
package com.pcy.utils;

import com.pcy.entity.Result;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Aspect
@Component
public class WebAspect &#123;
// ★★★★★★★★★★★ 一定要注意这个AOP切面扫描的包 ★★★★★★★★★★★
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut() &#123;
    &#125;

    @Before(value = &quot;pointCut()&quot;)
    public void before(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@Before ========================================&quot;);
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getName();
        Object[] args = joinPoint.getArgs();
        String[] parameterNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames();

        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();

        Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; parameterNames.length; i++) &#123;
            paramMap.put(parameterNames[i], args[i]);
        &#125;

        log.info(&quot;before path：&#123;&#125;&quot;,request.getServletPath());
        log.info(&quot;before class name：&#123;&#125;&quot;,className);
        log.info(&quot;before method name：&#123;&#125;&quot;,methodName);
        log.info(&quot;before args：&#123;&#125;&quot;,paramMap.toString());
    &#125;

    @After(value = &quot;pointCut()&quot;)
    public void after(JoinPoint joinPoint) &#123;
        System.out.println(&quot;======================================== 这是@After =========================================&quot;);
        log.info(&quot;&#123;&#125; after&quot;, joinPoint.getSignature().getName());
    &#125;

    @AfterReturning(value = &quot;pointCut()&quot;, returning = &quot;returnVal&quot;)
    public void afterReturning(JoinPoint  joinPoint, Object returnVal) &#123;
        System.out.println(&quot;==================================== 这是@AfterReturning ====================================&quot;);
        log.info(&quot;&#123;&#125; after return, returnVal: &#123;&#125;&quot;, joinPoint.getSignature().getName(), returnVal);
    &#125;
&#125;

/*
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.249  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-14 18:28:20.250  INFO 3296 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2024-08-14 18:28:20.261  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:28:20:261 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before path：/aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before method name：aspect
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : before args：&#123;message=www&#125;
2024-08-14 18:28:20.278  INFO 3296 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
==================================== 这是@AfterReturning ====================================
2024-08-14 18:28:20.279  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after return, returnVal: Result(code=200, message=操作成功, data=www)
======================================== 这是@After =========================================
2024-08-14 18:28:20.280  INFO 3296 --- [nio-8080-exec-1] com.pcy.utils.WebAspect                  : aspect after
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:28:20:308 毫秒
2024-08-14 18:28:20.308  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:28:20.309  INFO 3296 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：47 毫秒

*/
</code></pre>
<h6 id="若是调用UserController的get接口"><a href="#若是调用UserController的get接口" class="headerlink" title="若是调用UserController的get接口"></a>若是调用UserController的get接口</h6><pre><code class="java">com/pcy/controller/UserController.java
...
    @Operation(summary = &quot;根据ID获取用户信息&quot;, description = &quot;通过用户ID获取用户详细信息&quot;)
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public User get(@PathVariable int id) &#123;
        return userRepository.findById(id).orElse(null);
    &#125;
...

Console控制台的报错信息：
/*
2024-08-14 18:33:22.383  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：18:33:22:383 毫秒
======================================== 这是@Before ========================================
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/users/user/2
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.UserController
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：get
2024-08-14 18:33:22.385  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;id=2&#125;
==================================== 这是@AfterReturning ====================================
2024-08-14 18:33:22.425  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after return, returnVal: User(id=2, name=we2, age=2, email=2, birthDay=2024-08-10)
======================================== 这是@After =========================================
2024-08-14 18:33:22.426  INFO 3296 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : get after
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：18:33:22:428 毫秒
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-14 18:33:22.428  INFO 3296 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：45 毫秒
*/
</code></pre>
<h6 id="异常善后处理"><a href="#异常善后处理" class="headerlink" title="异常善后处理"></a>异常善后处理</h6><pre><code class="java">com/pcy/controller/AspectController.java //【浏览exception接口的时候会报错】
package com.pcy.controller;

import com.pcy.entity.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
    @GetMapping
    public Result aspect(String message)&#123;
        log.info(&quot;aspect controller&quot;);
        return Result.success(message);
    &#125;
    @GetMapping(&quot;/exception&quot;)
    public Result exception()&#123;//抛出异常
        throw new RuntimeException(&quot;runtime exception&quot;);
    &#125;
&#125;


/*
======================================== 这是@Before ========================================
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before path：/aspect/exception
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:09:20.586  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before method name：exception
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : before args：&#123;&#125;
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:09:20.587  INFO 4200 --- [nio-8080-exec-4] com.pcy.utils.WebAspect                  : exception after
2024-08-15 15:09:20.588 ERROR 4200 --- [nio-8080-exec-4] com.pcy.utils.GlobalExceptionHandler     : runtime exception
*/
</code></pre>
<pre><code class="java">com/pcy/utils/WebAspect.java
@AfterThrowing(value = &quot;pointCut()&quot;, throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint  joinPoint, Exception e) &#123;
        log.info(&quot;&#123;&#125; after throwing, message: &#123;&#125;&quot;, joinPoint.getSignature().getName(), e.getMessage());
    &#125;
</code></pre>
<h6 id="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"><a href="#综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行" class="headerlink" title="综上所述：after方法不关心方法是否成功，当方法执行完成之后就会被执行；afterReturning方法必须在目标方法成果return之后才会被执行；afterThrowing方法则会在目标方法抛出异常后被执行"></a><span style = "color:red">综上所述：<span style = "color:blue">after</span>方法不关心方法是否成功，当方法执行完成之后就会被执行；<span style = "color:blue">afterReturning</span>方法必须在目标方法成果return之后才会被执行；<span style = "color:blue">afterThrowing</span>方法则会在目标方法抛出异常后被执行</span></h6><h5 id="性能统计"><a href="#性能统计" class="headerlink" title="性能统计"></a>性能统计</h5><blockquote>
<p>Around可以囊括以上所有能力</p>
</blockquote>
<pre><code class="java">com/pcy/controller/AspectController.java
@Slf4j
@RestController
@RequestMapping(&quot;/aspect&quot;)
public class AspectController &#123;
  @GetMapping(&quot;/sleep/&#123;time&#125;&quot;)
    public Result sleep(@PathVariable(&quot;time&quot;) long time) &#123;
        log.info(&quot;sleep&quot;);
        try &#123;
            Thread.sleep(time);
        &#125; catch (InterruptedException e) &#123;
           log.error(&quot;error&quot;, e);
        &#125;
        if (time == 1000) &#123;
            throw new RuntimeException(&quot;runtime exception&quot;);
        &#125;
        log.info(&quot;wake up&quot;);
        return Result.success(&quot;wake up&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Around(&quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around start&quot;);
        long startTime = System.currentTimeMillis();
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;,e);
        &#125;
        long endTime = System.currentTimeMillis();
        log.info(&quot;execute time：&#123;&#125; ms&quot;,endTime - startTime);
        return result;
    &#125;
</code></pre>
<pre><code class="java">//【当输入time值为2004时】
2024-08-15 15:27:21.987  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:27:21:987 毫秒
2024-08-15 15:27:21.990  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/2004
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : before args：&#123;time=2004&#125;
2024-08-15 15:27:21.991  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : sleep
2024-08-15 15:27:23.996  INFO 10844 --- [nio-8080-exec-6] com.pcy.controller.AspectController      : wake up
==================================== 这是@AfterReturning ====================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after return, returnVal: Result(code=200, message=操作成功, data=wake up)
======================================== 这是@After =========================================
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:27:23.997  INFO 10844 --- [nio-8080-exec-6] com.pcy.utils.WebAspect                  : execute time：2007 ms
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：15:27:23:999 毫秒
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 15:27:23.999  INFO 10844 --- [nio-8080-exec-6] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：12 毫秒


//【当输入time值为1000时】
2024-08-15 15:28:19.596  INFO 10844 --- [nio-8080-exec-9] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：15:28:19:596 毫秒
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around start
======================================== 这是@Before ========================================
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before path：/aspect/sleep/1000
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before class name：com.pcy.controller.AspectController
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before method name：sleep
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : before args：&#123;time=1000&#125;
2024-08-15 15:28:19.597  INFO 10844 --- [nio-8080-exec-9] com.pcy.controller.AspectController      : sleep
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after throwing, message: runtime exception
======================================== 这是@After =========================================
2024-08-15 15:28:20.607  INFO 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : sleep after
2024-08-15 15:28:20.607 ERROR 10844 --- [nio-8080-exec-9] com.pcy.utils.WebAspect                  : around error

java.lang.RuntimeException: runtime exception
    at com.pcy.controller.AspectController.sleep(AspectController.java:32)
    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
    at java.base/java.lang.reflect.Method.invoke(Method.java:578)
......
</code></pre>
<h6 id="同一切面内的执行顺序"><a href="#同一切面内的执行顺序" class="headerlink" title="同一切面内的执行顺序"></a>同一切面内的执行顺序</h6><blockquote>
<p>先执行before方法，再执行afterReturning &#x2F; afterThrowing方法，最后执行after方法<br>要验证的关键点是around方法和它们之间的先后关系</p>
<p>around方法早于before方法开始执行，并且晚于after方法结束执行，刚好将其他同志完全包裹了起来</p>
</blockquote>
<pre><code class="java">//【注释掉WebAspect.java里面的代码不然会叠叠乐累加】
com/pcy/utils/AspectOne.java
package com.pcy.utils;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component
public class AspectOne &#123;
    @Pointcut(&quot;execution(public * com.pcy.controller.*.*(..))&quot;)
    public void pointCut()&#123;&#125;
    @Before(value = &quot;pointCut()&quot;)
    public void before()&#123;
        log.info(&quot;before one&quot;);
    &#125;
    @After(value = &quot;pointCut()&quot;)
    public void after()&#123;
        log.info(&quot;after one&quot;);
    &#125;
    @AfterReturning(value = &quot;pointCut()&quot;)
    public void afterReturning()&#123;
        log.info(&quot;afterReturning one&quot;);
    &#125;

    @Around(value = &quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) &#123;
        log.info(&quot;around one start&quot;);
        Object result = null;
        try &#123;
            result = joinPoint.proceed();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;around error&quot;, e);
        &#125;
        log.info(&quot;around one end&quot;);
        return result;
    &#125;
&#125;

/*
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.819  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;
2024-08-15 16:12:12.820  INFO 28788 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 0 ms
2024-08-15 16:12:12.839  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : preHandle开始时间：16:12:12:839 毫秒
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one start
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : before one
2024-08-15 16:12:12.864  INFO 28788 --- [nio-8080-exec-1] com.pcy.controller.AspectController      : aspect controller
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : afterReturning one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : after one
2024-08-15 16:12:12.865  INFO 28788 --- [nio-8080-exec-1] com.pcy.utils.AspectOne                  : around one end
2024-08-15 16:12:12.908  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : postHandle结束时间：16:12:12:908 毫秒
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : afterCompletion
2024-08-15 16:12:12.909  INFO 28788 --- [nio-8080-exec-1] c.pcy.HandlerInterceptor.LogInterceptor  : 接口运行时间：69 毫秒
*/
</code></pre>
<h6 id="不同切面间的执行顺序"><a href="#不同切面间的执行顺序" class="headerlink" title="不同切面间的执行顺序"></a>不同切面间的执行顺序</h6><blockquote>
<p>将AspectOne复制两份命名AspectTwo和AspectThree [<strong>执行后是One→Three→Two</strong>]<br>在Spring中的加载顺序是根据类名升序排列的，Three字母排序排在Two前面<br>那如何指定执行顺序按照One Two Three？<br>分别为AspectOne&#x2F;Two&#x2F;Three加上@Order(1)，@Order(2)，@Order(3)</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h6 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h6><pre><code class="xml">pom.xml
       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">spring:
  application:
    name: Pluminary
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/pcy?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;nullCatalogMeansCurrent=true
    username: root
    password: root

    redis:
      host: localhost port:6379
      connect-timeout: 1000
      jedis:
        pool:
          min-idle: 5
          max-active: 10
          max-idle: 10
          max-wait: 2000
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
 @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

//先访问hello接口 再去redis-cli中尝试访问自己定义的内容
http://localhost:8080/swagger-ui/index.html#/hello-controller/hello

/*
127.0.0.1:6379&gt; get hello
&quot;world&quot;
*/
</code></pre>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/HelloController.java
package com.pcy.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class HelloController &#123;
    @GetMapping(&quot;/hi&quot;)
//  http://localhost:8080/hi
    public String hi()&#123;
        log.info(&quot;hi&quot;);
        return &quot;ok!&quot;;
    &#125;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello()&#123;
        stringRedisTemplate.opsForValue().set(&quot;hello&quot;,&quot;world&quot;);
        return stringRedisTemplate.opsForValue().get(&quot;hello&quot;);
    &#125;
&#125;

/* Console:
Using generated security password: 4147707e-58d6-46d9-b5cc-19865a2c523f
*/

账号：user
密码：4147707e-58d6-46d9-b5cc-19865a2c523f
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;

    // 配置HTTP安全性
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeRequests(authorizeRequests -&gt;
                        authorizeRequests
//          .antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll() // 允许访问Swagger UI和API文档
                                .anyRequest().authenticated() // 所有请求都需要认证
                )
                .httpBasic(withDefaults()); // 使用HTTP Basic认证

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .inMemoryAuthentication()
                .withUser(&quot;pcy&quot;)
                .password(passwordEncoder().encode(&quot;123456&quot;))
                .roles(&quot;admin&quot;);

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;

/*
你可能无法访问 http://localhost:8080/swagger-ui/index.html 的原因可能与 Spring Security 配置有关。由于你启用了 Spring Security，默认情况下，所有请求都需要经过身份认证，这可能会阻止你访问 Swagger UI。

为了确保你能够访问 Swagger UI，你需要在 Spring Security 的配置中添加一个例外规则，允许对 /swagger-ui/** 和相关的 Swagger 资源进行无认证访问。

添加代码：.antMatchers(&quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;).permitAll()


账号：pcy
密码：123456
*/
</code></pre>
<h3 id="从数据库中获取用户信息"><a href="#从数据库中获取用户信息" class="headerlink" title="从数据库中获取用户信息"></a>从数据库中获取用户信息</h3><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt;
                        authorizeRequests
                                .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults())
                .csrf(csrf -&gt; csrf.disable());

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/UserDetailsServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.pcy.entity.SysUser;
import com.pcy.service.SysUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
//确保你的 UserDetailsServiceImpl 类被 Spring 管理，且实现了 Spring Security 的 UserDetailsService 接口
@Service
public class UserDetailsServiceImpl implements UserDetailsService  &#123;

    @Autowired
    private SysUserService sysUserService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
        SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
        if (sysUser == null) &#123;
            throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
        &#125;
        return User.builder()
                .username(sysUser.getUsername())
                .password(sysUser.getPassword())
                .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getRole()))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/entity/SysUser.java
package com.pcy.entity;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.extension.activerecord.Model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.Accessors;

import java.io.Serializable;

@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@Schema(name = &quot;SysUser对象&quot;, description = &quot;系统用户表&quot;)
public class SysUser extends Model&lt;SysUser&gt; &#123;

    private static final long serialVersionUID = 1L;

    @Schema(description = &quot;主键 id&quot;)
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Integer id;

    @Schema(description = &quot;用户名&quot;)
    private String username;

    @Schema(description = &quot;密码&quot;)
    private String password;

    @Schema(description = &quot;角色&quot;)
    private String role;


    @Override
    public Serializable pkVal() &#123;
        return this.id;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/SysUserService.java
package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;

public interface SysUserService extends IService&lt;SysUser&gt; &#123;
    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">com/pcy/service/impl/SysUserServiceImpl.java
package com.pcy.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.pcy.common.ApiException;
import com.pcy.entity.SysUser;
import com.pcy.mapper.SysUserMapper;
import com.pcy.service.SysUserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;
    @Override
    public String getCurrentUser() &#123;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // 非匿名用户访问才能获得用户信息
        if (!(authentication instanceof AnonymousAuthenticationToken)) &#123;
            String userName = authentication.getName();
            log.info(&quot;userName by SecurityContextHolder: &#123;&#125;&quot;, userName);
            return userName;
        &#125;
        throw new ApiException(&quot;用户不存在！&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<pre><code class="java">com/pcy/common/ApiException.java
package com.pcy.common;

import com.pcy.entity.MessageEnum;
import lombok.Data;

@Data
public class ApiException extends RuntimeException &#123;

    private Integer code;

    public ApiException(MessageEnum messageEnum) &#123;
        super(messageEnum.getMessage());
        this.code = messageEnum.getCode();
    &#125;

    public ApiException(String message) &#123;
        super(message);
        this.code = 500;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//【由于数据库的密码要被加密后的形式保存到数据中】
com/pcy/common/test.java
package com.pcy.common;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class test &#123;
    public static void main(String[] args) &#123;
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String encodedPassword = encoder.encode(&quot;123456&quot;);
        System.out.println(encodedPassword);
    &#125;
&#125;

//$2a$10$GzDPdLyrzC9NudmE937AAetR2bef2VQzuSbP6KM6Y.I3045OuT/xC
</code></pre>
<h6 id="修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了"><a href="#修改创建SysUser用户的时候用Spring-Security-登录的时候就可以用自己创建的了" class="headerlink" title="修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]"></a>修改创建SysUser用户的时候用Spring Security [登录的时候就可以用自己创建的了]</h6><pre><code class="java">com/pcy/controller/UserController.java
/* 对比User数据
    @Operation(summary = &quot;创建User用户&quot;, description = &quot;创建一个新的User用户&quot;)
    @PostMapping(&quot;/create/&quot;)
    public User create(@RequestBody User User) &#123;
        return userRepository.save(User);
    &#125;
*/
    @Autowired
    private SysUserService sysUserService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Operation(summary = &quot;创建SysUser用户&quot;, description = &quot;创建一个新的SysUser用户&quot;)
    @PostMapping(&quot;/create/test&quot;)
    public SysUser create(@RequestBody SysUser sysUser) &#123;
        sysUser.setPassword(passwordEncoder.encode(sysUser.getPassword()));
        sysUserService.save(sysUser);
        return sysUser;
    &#125;
</code></pre>
<pre><code class="java">package com.pcy.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.pcy.entity.SysUser;
public interface SysUserService extends IService&lt;SysUser&gt;&#123;

    String getCurrentUser();
&#125;
</code></pre>
<pre><code class="java">@Slf4j
@Service
public class SysUserServiceImpl extends ServiceImpl&lt;SysUserMapper, SysUser&gt; implements SysUserService &#123;

 @Override
    public boolean save(SysUser sysUser) &#123;
        return SqlHelper.retBool(this.baseMapper.insert(sysUser));
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/mapper/SysUserMapper.java
package com.pcy.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.pcy.entity.SysUser;

/**
 * &lt;p&gt;
 * 系统用户表 Mapper 接口
 * &lt;/p&gt;
 */
public interface SysUserMapper extends BaseMapper&lt;SysUser&gt; &#123;

&#125;
</code></pre>
<h6 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h6><pre><code class="java">com/pcy/config/SecurityConfig.java
package com.pcy.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;

    // 配置认证管理器
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception &#123;
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(userDetailsService)  // 使用数据库中的用户信息
                .passwordEncoder(passwordEncoder());

        return authenticationManagerBuilder.build();
    &#125;

    // 配置密码编码器
    @Bean
    public PasswordEncoder passwordEncoder() &#123;
        return new BCryptPasswordEncoder();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/pcy/controller/SecurityController.java
package com.pcy.controller;

import com.pcy.entity.Result;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/security&quot;)
@Tag(name = &quot;权限控制&quot;, description = &quot;权限控制&quot;)
public class SecurityController &#123;
    // Anyone
    @Operation(summary = &quot;permitAll 权限&quot;)
    @GetMapping(value = &quot;/permitall&quot;)
    public Result&lt;String&gt; permitAll()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // 未登录时可以访问
    @Operation(summary = &quot;anonymous 权限&quot;)
    @GetMapping(value = &quot;/anonymous&quot;)
    public Result&lt;String&gt; anonymous()&#123;
        return Result.success(&quot;anonymous&quot;);
    &#125;
    // xiaopan可以访问
    @Operation(summary = &quot;config 权限&quot;)
    @GetMapping(value = &quot;/config&quot;)
    public Result&lt;String&gt; config()&#123;
        return Result.success(&quot;permitAll&quot;);
    &#125;
    // xiaochun可以访问
    @Operation(summary = &quot;Secured 权限&quot;)
    @GetMapping(value = &quot;/Secured&quot;)
    @Secured(&#123;&quot;ROLE_Secured&quot;&#125;)
    public Result&lt;String&gt; Secured()&#123;
        return Result.success(&quot;Secured&quot;);
    &#125;
    // panchunyao可以访问
    @Operation(summary = &quot;PreAuthorize 权限&quot;)
    @GetMapping(value = &quot;/preAuthorize&quot;)
    @PreAuthorize(&quot;hasAnyAuthority(&#39;PreAuthorize&#39;)&quot;)
    public Result&lt;String&gt; PreAuthorize()&#123;
        return Result.success(&quot;PreAuthorize&quot;);
    &#125;
&#125;

/*
首先，确保在数据库中创建几个测试用户，并为每个用户分配不同的角色或权限。假设你有以下几个用户：
User 1: Username: xiaopan, Password: 123456, Role: ROLE_config
User 2: Username: xiaochun, Password: 123456, Role: ROLE_Secured
User 3: Username: panchun, Password: 123456, Authority: PreAuthorize

尝试使用不同用户登录:
使用 xiaopan 登录后，尝试访问 /security/config。
使用 xiaochun 登录后，尝试访问 /security/Secured。
使用 panchunyao 登录后，尝试访问 /security/preAuthorize。

检查响应:
/security/config: 只有 xiaopan 能访问，其他用户会被拒绝访问。
/security/Secured: 只有 xiaochun 能访问，其他用户会被拒绝访问。
/security/preAuthorize: 只有 panchunyao 能访问，其他用户会被拒绝访问。
/security/permitall: 所有用户都可以访问。
/security/anonymous: 只有未登录的用户可以访问，登录的用户会被拒绝。

验证权限控制
每个请求的响应应该反映你在 SecurityConfig 中配置的权限。
如果用户没有适当的角色或权限，应该会返回 403 Forbidden 或其他错误响应。
*/
</code></pre>
<pre><code class="java">@Configuration
public class SwaggerConfig &#123;

    @Bean
    public GroupedOpenApi createRestApi() &#123;
        return GroupedOpenApi.builder()
                .group(&quot;Spring Boot 实战&quot;)
                .pathsToMatch(&quot;/users/**&quot;, &quot;/exception/**&quot;,&quot;/aspect/**&quot;,&quot;/test/**&quot;,&quot;/security/**&quot;)
                // .addPathsToMatch(&quot;/exception/**&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 【问答环节】
我的数据库创建的是Role字段但是为什么 下面这些有.hasAuthority 有.hasRole 还有其他的 这是怎么匹配到我数据库 按照你的方式设置的数据的

/*
1. hasRole() 和 hasAuthority() 的区别

hasRole(String role):
hasRole 方法通常用于检查用户是否拥有特定的角色。
Spring Security 会在你传递的角色名称前自动加上 &quot;ROLE_&quot; 前缀。因此，当你使用 hasRole(&quot;Secured&quot;) 时，实际上它会检查用户是否有 &quot;ROLE_Secured&quot; 这个权限。

hasAuthority(String authority):
hasAuthority 方法用于检查用户是否拥有特定的权限（或授权）。
hasAuthority 不会自动添加任何前缀。所以当你使用 hasAuthority(&quot;ROLE_config&quot;) 时，它会直接匹配 &quot;ROLE_config&quot;，而不会添加任何前缀。


2. 匹配数据库中的角色和权限
hasRole(&quot;Secured&quot;):
代码中的 hasRole(&quot;Secured&quot;) 实际上会匹配数据库中的 ROLE_Secured，因为 hasRole 方法会自动加上 &quot;ROLE_&quot; 前缀。

hasAuthority(&quot;ROLE_config&quot;):
代码中的 hasAuthority(&quot;ROLE_config&quot;) 会直接匹配数据库中的 &quot;ROLE_config&quot;，没有任何前缀变化。

hasAuthority(&quot;PreAuthorize&quot;):
代码中的 hasAuthority(&quot;PreAuthorize&quot;) 会直接匹配数据库中的 &quot;PreAuthorize&quot;，因为没有添加任何前缀。
*/
    
它为什么能查到我数据库的role字段里面的数据 如果我把这个字段换成test这个名字 它又是怎么去匹配到的呢
/*
Spring Security 默认会使用 UserDetails 接口中的 getAuthorities() 方法来获取用户的权限或角色信息。这些权限或角色信息通常是通过你在 UserDetailsService 实现类中定义的逻辑从数据库中获取的。
而在SecurityConfig中有代码：
@Autowired // 使用 Spring Security 的UserDetailsService
private UserDetailsService userDetailsService; 
回顾securityFilterChain代码
下面会有 .userDetailsService(userDetailsService) // 设置 UserDetailsService

Spring Security 本身并不直接访问你的数据库表或字段。它依赖于你在 UserDetailsService 中提供的 UserDetails 对象的 getAuthorities() 方法的返回值。因此，当你在 SecurityConfig 中使用 hasRole() 或 hasAuthority() 方法时，它实际上是在检查用户的权限信息，即 UserDetails 对象中的 authorities。
===========================================================================
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;
    SysUser sysUser = sysUserService.getOne(Wrappers.&lt;SysUser&gt;lambdaQuery().eq(SysUser::getUsername, username));
    if (sysUser == null) &#123;
        throw new UsernameNotFoundException(&quot;User not found with username: &quot; + username);
    &#125;
    return User.builder()
            .username(sysUser.getUsername())
            .password(sysUser.getPassword())
            .authorities(AuthorityUtils.commaSeparatedStringToAuthorityList(sysUser.getTest()))  // 修改为使用 &#39;test&#39; 字段
            .build();
&#125;

*/
</code></pre>
<h3 id="记住我-√-Remember-Me"><a href="#记住我-√-Remember-Me" class="headerlink" title="记住我               √ Remember Me"></a>记住我               √ Remember Me</h3><h6 id="基于SpringSession的方式"><a href="#基于SpringSession的方式" class="headerlink" title="基于SpringSession的方式"></a>基于SpringSession的方式</h6><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">//【要新搞个登录界面 .ftl】
application.yaml

spring:
  freemarker:
    template-loader-path: /templates/
    suffix: .ftl
</code></pre>
<pre><code class="html">resources/templates/loginPage.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;
    &lt;div&gt;
        &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
        &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type=&quot;checkbox&quot; id=&quot;remember-me&quot; name=&quot;remember-me&quot;&gt;
        &lt;label for=&quot;remember-me&quot;&gt;Remember me&lt;/label&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/pcy/controller/LoginController.java
package com.pcy.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;) // 修改为 &quot;/custom-login&quot;
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名仍然是 &quot;loginPage&quot;
    &#125;
&#125;

/*
http://localhost:8080/login

Please sign in
Username
    panchunyao
Password
    •••••••••••••
√ Remember me on this computer.


127.0.0.1:6379&gt; keys spring*
1) &quot;spring:session:sessions:96c83240-f939-4fd1-ac2c-93542f883aef&quot;
2) &quot;spring:session:sessions:56baf3c6-7a5c-483b-b04a-422b8a2be1b7&quot;
*/
</code></pre>
<pre><code class="java">com/pcy/config/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig &#123;
    @Autowired
    private UserDetailsService userDetailsService; // 使用 Spring Security 的 UserDetailsService

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;
        http
                .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
                        .requestMatchers(&quot;/security/permitall&quot;).permitAll() // 允许所有人访问
                        .requestMatchers(&quot;/security/anonymous&quot;).anonymous() // 仅允许匿名用户访问
                        .requestMatchers(&quot;/security/config&quot;).hasAuthority(&quot;ROLE_config&quot;) // 仅拥有 ROLE_config 权限的用户可以访问
                        .requestMatchers(&quot;/security/Secured&quot;).hasRole(&quot;Secured&quot;) // 仅拥有 ROLE_Secured 的用户可以访问
                        .requestMatchers(&quot;/security/preAuthorize&quot;).hasAuthority(&quot;PreAuthorize&quot;) // 仅拥有 PreAuthorize 权限的用户可以访问
                        .anyRequest().authenticated() // 其他所有请求需要认证
                )
                .formLogin(form -&gt; form
//                        .loginPage(&quot;/custom-login&quot;) // 将登录页面的路径改为 &quot;/custom-login&quot; 打开会循环重定向
                        .defaultSuccessUrl(&quot;http://localhost:8080/swagger-ui/index.html&quot;, true) // 登录成功后的跳转路径
                        .permitAll()
                )
                .rememberMe(rememberMe -&gt; rememberMe
                        .rememberMeServices(rememberMeServices()) // 配置 Remember Me 服务
                )
                .userDetailsService(userDetailsService) // 设置 UserDetailsService
                .httpBasic(withDefaults()) // 使用 HTTP Basic 认证
                .csrf(csrf -&gt; csrf.disable()); // 禁用 CSRF

        return http.build();
    &#125;
&#125;
......
</code></pre>
<pre><code class="java">//【问答环节】
分析一下freemarker这个配置的含义
    freemarker:
      template-loader-path: /templates/
      suffix: .ftl
/*
这些配置项的含义如下：
template-loader-path: /templates/: 这个配置指定了 Freemarker 模板文件的加载路径，也就是 /templates/ 目录。Spring Boot 会在这个目录下寻找所有的 .ftl 模板文件。

suffix: .ftl: 这个配置指定了 Freemarker 模板文件的文件后缀，也就是 .ftl。在控制器中返回视图名称时，Spring 会自动添加这个后缀来查找相应的模板文件。


配置的工作原理
@Controller
public class LoginController &#123;
    @GetMapping(&quot;/login&quot;)
    public String login() &#123;
        return &quot;loginPage&quot;; // 返回的视图名
    &#125;
&#125;
在 LoginController 中的 login() 方法中，你返回的是 &quot;loginPage&quot;：
因为在 application.yaml 中已经配置了 template-loader-path 和 suffix，Spring Boot 会根据这些配置来查找模板文件：
它会在 template-loader-path 配置的 /templates/ 目录下寻找文件。
它会在视图名称 &quot;loginPage&quot; 后面自动添加 .ftl 后缀。
因此，最终 Spring Boot 会查找路径 /templates/loginPage.ftl，并使用这个模板文件来渲染登录页面。这就是为什么当你在控制器中返回 &quot;loginPage&quot; 时，Freemarker 能正确地找到并渲染 loginPage.ftl 模板。

如果你想修改 Freemarker 模板文件的目录或后缀，可以调整 application.yaml 中的相应配置。
视图名称在 return 中不需要包含目录或后缀，Spring 会根据配置自动处理。
*/
</code></pre>
<h1 id="SpringBoot-Vue企业级狐狸"><a href="#SpringBoot-Vue企业级狐狸" class="headerlink" title="SpringBoot + Vue企业级狐狸"></a>SpringBoot + Vue企业级狐狸</h1><pre><code class="mysql">@RequestMapping 注解指定控制器类中的方法可以处理哪些格式的URL请求
@RequestMapping(&quot;/hello&quot;) 说明该方法将接收并处理格式为/hello的HTTP请求
@RestController 注解指定本类承担着SpringBoot项目的&#39;控制器&#39;效果
</code></pre>
<table>
<thead>
<tr>
<th>包名</th>
<th>所放置的业务代码类型</th>
</tr>
</thead>
<tbody><tr>
<td>common</td>
<td>放置了通用的参数和业务方法</td>
</tr>
<tr>
<td>controller</td>
<td>放置了针对各业务请求的控制类</td>
</tr>
<tr>
<td>domain</td>
<td>放置了各种业务实体类</td>
</tr>
<tr>
<td>mapper</td>
<td>放置了针对MyBatis框架的映射关系类</td>
</tr>
<tr>
<td>service</td>
<td>放置了诸多实现业务逻辑的类</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/10/21/后端/SpringBoot趣味实战课/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/09/28/后端/苍穹外卖/">
        <h2>
            苍穹外卖
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/9/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="苍穹外卖"><a href="#苍穹外卖" class="headerlink" title="苍穹外卖"></a>苍穹外卖</h1><h3 id="软件开发整体介绍"><a href="#软件开发整体介绍" class="headerlink" title="软件开发整体介绍"></a>软件开发整体介绍</h3><h4 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h4><h6 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h6><ul>
<li>需求规格说明书(word)、产品原型</li>
</ul>
<h6 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h6><ul>
<li>UI设计、数据库设计、接口设计</li>
</ul>
<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><ul>
<li>项目代码、单元测试</li>
</ul>
<h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><ul>
<li>测试用例、测试报告</li>
</ul>
<h6 id="上线运维"><a href="#上线运维" class="headerlink" title="上线运维"></a>上线运维</h6><ul>
<li>软件环境安装、配置</li>
</ul>
<h5 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h5><ul>
<li><strong>项目经理</strong>：对整个项目负责，任务分配、把控进度</li>
<li><strong>产品经理</strong>：进行需求调研，输出需求调研文档、产品原型等</li>
<li><strong>UI设计师</strong>：根据产品原型输出界面效果图</li>
<li><strong>架构师</strong>：项目整体架构设计、技术选型等</li>
<li><span style = "color:red"><strong>开发工程师</strong></span>：代码实现</li>
<li><strong>测试工程师</strong>：编写测试用例，输出测试报告</li>
<li><strong>运维工程师</strong>：软件环境搭建、项目上线</li>
</ul>
<h5 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h5><ul>
<li><p>开发环境：开发人员在开发阶段使用的环境</p>
</li>
<li><p>测试环境：专门给测试人员使用的环境，用于项目测试</p>
</li>
<li><p>生产环境：线上环境</p>
</li>
</ul>
<h2 id="第二轮补充知识点复习-会以橙色标注"><a href="#第二轮补充知识点复习-会以橙色标注" class="headerlink" title="第二轮补充知识点复习 会以橙色标注"></a><span style = "color:orange"><strong>第二轮补充知识点复习 会以橙色标注</strong></span></h2><h3 id="苍穹外卖项目介绍"><a href="#苍穹外卖项目介绍" class="headerlink" title="苍穹外卖项目介绍"></a>苍穹外卖项目介绍</h3><h5 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h5><ul>
<li>定位：专门为餐饮制定的一款软件产品[<strong>管理端</strong> 与 <strong>用户端</strong>]</li>
</ul>
<h5 id="功能架构-体现项目中的业务功能模块"><a href="#功能架构-体现项目中的业务功能模块" class="headerlink" title="功能架构 (体现项目中的业务功能模块)"></a>功能架构 (体现项目中的业务功能模块)</h5><ul>
<li><strong>管理端</strong>：员工、分类、菜品、套餐、订单管理、工作台、数据统计、来单提醒</li>
<li><strong>用户端</strong>：微信登录、商品浏览、购物车、用户下单、微信支付、历史订单、地址管理、用户催单</li>
</ul>
<h5 id="产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计"><a href="#产品原型“在文件里有用户端和管理端”-用于展示项目的业务功能-一般由产品经理进行设计" class="headerlink" title="产品原型“在文件里有用户端和管理端” (用于展示项目的业务功能 一般由产品经理进行设计)"></a><span style = "color:red">产品原型<del>“在文件里有用户端和管理端”</del></span> (用于展示项目的业务功能 一般由产品经理进行设计)</h5><h5 id="技术选型-展示项目中使用到的技术框架和中间件"><a href="#技术选型-展示项目中使用到的技术框架和中间件" class="headerlink" title="技术选型 (展示项目中使用到的技术框架和中间件)"></a>技术选型 (展示项目中使用到的技术框架和中间件)</h5><ul>
<li><p><strong>用户层</strong>：node.js、VUE.js、ElementUI、微信小程序、apache echarts</p>
</li>
<li><p><strong>网关层</strong>：Nginx</p>
</li>
<li><p><strong>应用层</strong>：SpringBoot、SpringMVC、SpringTask、httpclient、SpringCache、JWT、阿里云OSS、Swagger、POI(操作excel表格)、WebSocket(网络协议&lt;催单…&gt;)</p>
</li>
<li><p><strong>数据层</strong>：MySQL、Redis、MyBatis、PageHelper、Spring Data Redis</p>
</li>
<li><p><strong>工具</strong>：Git、Maven、Junit、PostMan</p>
</li>
</ul>
<h3 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h3><p><strong>前端</strong>：管理端(Web<del>基于Nginx</del>)、用户端(小程序)</p>
<blockquote>
<p>前端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\前端运行环境\nginx-1.20.2\html\sky</p>
<p>D:\nginx-1.20.2 [放在英文目录下 双击 nginx.exe] 默认端口号80</p>
<p><strong>[苍穹外卖]</strong> (<a target="_blank" rel="noopener" href="http://localhost/#/login">http://localhost/#/login</a>) 如果被其他占用(比如RAGFlow)就把 <code>localhost</code> 换成 <strong>127.0.0.1</strong></p>
</blockquote>
<p><strong>后端</strong>：后端服务(Java)</p>
<blockquote>
<p>后端环境位置：<br>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day01\后端初始工程\sky-take-out</p>
<p>把sky-take-out导入到idea</p>
</blockquote>
<ul>
<li><strong>sky-take-out</strong> [maven父工程，<strong>统一管理依赖版本</strong>，<strong>聚合其他子模块</strong>]<ul>
<li>sky-common [子模块，存放公共类(工具类、常量类、异常类)]</li>
<li>sky-pojo [子模块，存放实体类、VO、DTO等]</li>
<li>sky-server [子模块，后端服务，存放配置文件、Controller、Service、Mapper等]</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Entity</td>
<td>实体，通常和数据库中的表对应</td>
</tr>
<tr>
<td>DTO</td>
<td>数据传输对象，通常用程序中各层之间传递数据</td>
</tr>
<tr>
<td>VO</td>
<td>视图对象，为前端展示数据提供的对象</td>
</tr>
<tr>
<td>POJO</td>
<td>普通Java对象，只有属性和对应的Getter和Setter</td>
</tr>
</tbody></table>
<p><span style = "color:orange"><strong>深刻理解POJO</strong></span></p>
<blockquote>
<p><strong>POJO</strong>的内在含义是指：那些没有继承任何类、也没有实现任何接口[可以实现]，更没有被其它框架侵入的java对象。<br><strong>POJO是一个简单的、普通Java对象，它包含业务逻辑处理或持久化逻辑等，但不是JavaBean、EntityBean等</strong>不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。 <strong><u>可以包含类似与JavaBean属性和对属性访问的setter和getter方法的</u></strong><br>一般在web应用程序中建立一个<strong>数据库</strong>的映射对象时，我们只能称它为POJO。</p>
<ul>
<li><strong>POJO持久化之后</strong>&#x3D;&#x3D;〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）</li>
<li><strong>POJO传输过程中</strong>&#x3D;&#x3D;&gt; DTO</li>
<li><strong>POJO用作表示层</strong>&#x3D;&#x3D;&gt; VO</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解PO、DTO、VO</strong></span></p>
<blockquote>
<p><strong>PO</strong>(persistent object)：就是将对象与关系数据库绑定，用对象来表示关系数据，<br>最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。</p>
<ul>
<li>有时也被称为Data对象，对应数据库的entity，简单认为一个PO对应数据库中的一条记录</li>
<li>PO中不应该包含任何对数据库的操作</li>
<li><strong>PO的属性是跟数据表的字段一一对应的</strong></li>
<li>PO对象需要实现序列化接口</li>
</ul>
<hr>
<p><strong>DTO</strong>(<u>Data Transfer Object</u>)： → 数据传输对象<br>主要用于远程调用需要大量传输对象的地方<br>我们可以将PO中的部分属性抽取出来，就形成了DTO<br><strong>举例说明</strong>：<br>比如我们有一张表有100个字段，那么对应的PO就有100个属性<br>但是我们界面上需要显示10个字段，客户端用WEB service来获取数据，没必要把整个PO对象传递到客户端，这时<u>我们就可以用只有这10个属性的DTO来传递结果到客户端</u>，这样就<u><strong>不会暴露服务端表结构</strong></u>，到达客户端后，<u>如果用这个对象来对应界面显示，那么此时它的身份就转为了<strong>VO</strong>(View Object)</u></p>
<hr>
<p><strong>VO</strong><br>VO(value object) 是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。<br><strong>重点</strong>：<br>一个VO可以只是PO的一部分，也可以是多个PO构成，同样也等同于一个PO(指的是属性)。正因为这样，PO独立出来，<u>数据持久层</u>也就独立出来了，它不会受到任何业务的影响和干涉。又因为这样，<u>业务逻辑层</u>也独立开来，它不会受到数据持久层的影响，业务层只关心业务逻辑的处理，怎么存和读都交给别人。</p>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解什么是DAO</strong></span></p>
<blockquote>
<p><strong>DAO</strong>(Data Access Object)：数据访问对象<br>主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO。<br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD操作…</p>
<ul>
<li><p>主要用来封装对DB（数据库）的访问（CRUD操作）。</p>
</li>
<li><p>通过接收业务层的数据，把POJO持久化为PO。</p>
</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>深刻理解JavaBean</strong></span></p>
<blockquote>
<p><strong>JavaBean是一个遵循特定写法的Java类，是一种Java语言编写的可重用组件，它的方法命名，构造及行为必须符合特定的约定：</strong></p>
<p><strong>1、这个类必须具有一个公共的(public)无参构造函数；</strong><br><strong>2、所有属性私有化（private）；</strong><br><strong>3、私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。</strong><br><strong>4、这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</strong><br>JavaBean在JavaEE开发中，通常用于<strong>封装数据</strong><br>许多开发者会把<strong>JavaBean</strong>看作村从特定命名约定的<strong>POJO</strong><del>POJO按照JavaBean的规则来就可以变成JavaBean</del><br><strong>当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean</strong><br>JavaBean是一种组件技术，就好像你做了一个扳手，而这个扳手会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</p>
</blockquote>
<p><span style = "color:orange"><strong>common里的constant、context、properties代表什么意思</strong></span></p>
<pre><code class="java">constant:
用于存放常量类。这些常量可能是项目中频繁使用的固定值，如状态码、错误码、系统配置项等。
常量类中的变量一般使用public static final修饰，确保其不可变性。
    
context:
用于存放上下文类。上下文类通常用来保存和传递运行时环境信息或状态。
在Spring框架中，ApplicationContext就是一个典型的上下文对象，它提供了对Bean的访问以及配置信息的管理。
    
properties:
用于存放属性文件。这些文件通常以.properties为扩展名，用于存储配置信息，如数据库连接字符串、系统参数等。
属性文件可以通过Properties类来读取和写入，方便在运行时动态调整系统行为。
</code></pre>
<p><span style = "color:orange"><strong>Final的巩固</strong></span></p>
<pre><code class="java">问：对于引用类型（如String、Object等），final变量的引用不能被改变，但引用的对象内部状态可以改变。 这句话是什么意思？

答：当一个引用类型的变量被声明为final时，这个变量的引用（即指向的对象）不能被改变，但该对象的内部状态是可以改变的。我们可以通过具体的例子来理解这一点。
public class Example &#123;
    public static final String EMP_ID = &quot;empId&quot;;
    public static void main(String[] args)&#123;
        // 下面这行代码会编译失败，因为EMP_ID是final的
        // EMP_ID = &quot;newEmpId&quot;; // 编译错误
        
// 但是可以创建一个新的String对象并使用EMP_ID内容
    String anotherId = EMP_ID + &quot;123&quot;;
    sout(anotherId) =&gt; empId123;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>解析context (实现上下类的逻辑原理) 内的代码</strong></span></p>
<pre><code class="java">package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
//ThreadLocal 是一个线程局部变量，每个线程都有自己的独立副本。这意味着不同线程之间不会共享同一个 ThreadLocal实例的数据，从而避免了多线程环境下的数据竞争问题。
    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
/*
这个类通常用于需要在多线程环境中传递和管理线程上下文信息的场景。例如：

Web应用：在处理HTTP请求时，可能需要将用户ID或其他上下文信息绑定到当前线程，以便在整个请求处理过程中都能访问到这些信息。

日志记录：在日志记录中，可能需要记录每个操作的执行者ID，通过 ThreadLocal 可以方便地在日志记录器中获取当前操作者的ID。

事务管理：在分布式事务中，可能需要将事务ID绑定到当前线程，以便在事务的各个阶段都能访问到这个ID。

内存泄漏：如果 ThreadLocal 中存储的对象没有及时释放，可能会导致内存泄漏。因此，建议在不再需要 ThreadLocal 中的数据时，调用 remove 方法将其移除。

线程池：在使用线程池时，特别需要注意 ThreadLocal 的管理。线程池中的线程是复用的，如果不及时清理 ThreadLocal 中的数据，可能会导致数据混淆或内存泄漏。
*/
</code></pre>
<p><span style = "color:orange"><strong>静态变量解析</strong></span></p>
<pre><code class="java">//静态变量 (static)
静态变量：在 Java 中，静态变量属于类而不是类的实例。这意味着无论创建多少个类的实例，静态变量都只有一份拷贝，并且所有实例共享这份拷贝。
作用域：静态变量在类加载时初始化，并且在类卸载时销毁。它们存在于类的生命周期内，而不是实例的生命周期内。

//结合 static 和 ThreadLocal
在 BaseContext 类中，threadLocal 被声明为 static，这意味着所有 BaseContext 实例共享同一个 ThreadLocal 实例。但这并不意味着所有线程共享同一个 ThreadLocal 实例的数据。相反，每个线程都有自己独立的 ThreadLocal 数据副本。
    
静态变量：
public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();
这行代码声明了一个静态的 ThreadLocal 变量 threadLocal，所有 BaseContext 实例共享这个 ThreadLocal 实例。
</code></pre>
<h3 id="使用Git进行版本控制"><a href="#使用Git进行版本控制" class="headerlink" title="使用Git进行版本控制"></a>使用Git进行版本控制</h3><ul>
<li>创建Git本地仓库</li>
<li>创建Git远程仓库[GitHub、Gitee]</li>
<li>将本地文件推送到Git远程仓库</li>
</ul>
<pre><code class="java">.gitignore[文件设置]
    
//忽略git管理的文件
**/target/
.idea
*.iml
*.class
*Test.java
**/test/
</code></pre>
<blockquote>
<p><strong>创建远程仓库流程</strong>：【提交到本地】<br>VCS → Create Git Repository → sky-take-out → √ → Unversinoed Files(All)  → Commit</p>
<p><strong>去创建一个仓库</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
<p><strong>推送代码到Gitee远程仓库</strong>：Idea右上角的↗ → 定义一下本地和远程仓库关联 点击Define remote → Name: origin<br>URL: <a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out.git">https://gitee.com/Pluminary/sky-take-out.git</a> (这个是在Gitee上创建仓库后复制的代码)</p>
<p><strong>推送成功</strong>：[Pluminary&#x2F;sky-take-out (gitee.com)] (<a target="_blank" rel="noopener" href="https://gitee.com/Pluminary/sky-take-out">https://gitee.com/Pluminary/sky-take-out</a>)</p>
</blockquote>
<h3 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h3><h6 id="数据库环境搭建"><a href="#数据库环境搭建" class="headerlink" title="数据库环境搭建"></a>数据库环境搭建</h6><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42914989/article/details/113155204">Unknown collation: ‘utf8mb4_0900_ai_ci‘的解决方法_unknown collation utf8mb4-CSDN博客</a></p>
<h6 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h6><pre><code class="java">浏览器

↓
Controller:
1.接收并封装参数
2.调用service方法查询数据库
3.封装结果并相应

↓
Service：
1.调用mapper查询数据库
2.密码对比
3.返回结果

↓
Mapper：
1.select * from employee where username = ? 

↓
数据库
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tlk20071/article/details/103629336">IDEA中导入多module的Maven项目无法识别module的解决办法_idea modules太多 mvn clean 对某个module不起作用-CSDN博客</a></p>
<blockquote>
<p>Maven → <strong>compile</strong>(编译聚合模块 )</p>
<p>[INFO] ————————————————————————<br>[INFO] Reactor Summary for sky-take-out 1.0-SNAPSHOT:<br>[INFO]<br>[INFO] sky-take-out ………………………………… SUCCESS [  0.003 s]<br>[INFO] sky-common ………………………………….. SUCCESS [  2.761 s]<br>[INFO] sky-pojo ……………………………………. SUCCESS [  2.227 s]<br>[INFO] sky-server ………………………………….. SUCCESS [  1.294 s]<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS</p>
</blockquote>
<p><span style="color:red">在数据库中 <u>新建查询</u> <strong>→</strong> <u>SELECT VERSION()</u>; <strong>→</strong> 引擎是8.0.33的是正规操作mysql此时对应的任务管理器<strong>服务</strong>里搜索mysql(名称:MySQL80)开启这个 <strong>→</strong> 如果开启了服务里的MySQL那<u>SELECT VERSION()</u>查询就是11.0.5-MariaDB</span></p>
<blockquote>
<p>handler：全局异常处理器</p>
</blockquote>
<p><span style = "color:orange"><strong>右侧Maven的具体用途</strong></span></p>
<blockquote>
<ol>
<li><p><strong>clean</strong><br> 功能：<strong>清除项目构建过程中生成的所有文件，通常包括 target 目录下的内容</strong>。<br> 命令：mvn clean<br> 使用场景：<br> 在每次构建之前，确保没有旧的构建产物干扰新构建。<br> 清理项目目录，准备进行新的构建。</p>
</li>
<li><p><strong>validate</strong><br> 功能：<strong>验证项目的正确性，确保所有必要的信息都已就绪</strong>。<br> 命令：mvn validate<br> 使用场景：<br> 在构建过程的早期阶段，检查项目配置是否正确。<br> **<u>确保所有依赖项和资源都可用</u>**。</p>
</li>
<li><p><span style = "color:red"><strong>compile</strong></span><br> 功能：<strong>编译项目的源代码</strong>。<br> 命令：mvn compile<br> 使用场景：<br> <u>编译项目源代码，生成 .class 文件。</u><br> <u><strong>通常在开发过程中频繁使用</strong>，<strong>确保代码可以成功编译</strong>。</u></p>
</li>
<li><p><strong>test</strong><br> 功能：运行项目的单元测试。<br> 命令：mvn test<br> 使用场景：<br> 在代码提交前，确保所有单元测试通过。<br> 持续集成（CI）过程中，自动运行测试以确保代码质量。</p>
</li>
<li><p><span style = "color:red"><strong>package</strong></span><br> 功能：<strong>将编译后的代码打包成可分发的格式，如 JAR、WAR 等</strong>。<br> 命令：mvn package<br> 使用场景：<br> 构建项目并生成可部署的包。<br> <strong>通常在开发和部署过程中使用，生成最终的可发布版本。</strong></p>
</li>
<li><p><strong>verify</strong><br> 功能：<strong>运行任何检查以验证包的完整性和有效性。</strong><br> 命令：mvn verify<br> 使用场景：<br> 在发布前，进行更严格的验证，确保包的质量。<br> <strong>运行集成测试、性能测试</strong>等。</p>
</li>
<li><p><span style = "color:red"><strong>install</strong></span><br> <strong>功能：将包安装到本地 Maven 仓库，供其他项目使用</strong>。<br> 命令：mvn install<br> 使用场景：<br> 将项目依赖安装到本地仓库，以便其他项目可以引用。<br> 通常在开发和测试环境中使用，确保依赖项可用。</p>
</li>
<li><p><strong>site</strong><br> 功能：生成项目的站点文档，包括项目报告、测试覆盖率等。<br> 命令：mvn site<br> 使用场景：<br> 生成项目文档，供团队成员和外部用户查阅。<br> 文档生成和发布，提高项目的透明度和可维护性。</p>
</li>
<li><p><strong>deploy</strong><br> 功能：将最终的包部署到远程仓库，如 Nexus、Artifactory 等。<br> 命令：mvn deploy<br> 使用场景：<br> 将项目发布到远程仓库，供其他团队或项目使用。<br> 通常在持续集成和持续部署（CI&#x2F;CD）流程中使用，确保发布的版本可用。</p>
</li>
</ol>
<p>  <strong>总结</strong><br>  clean：清理构建产物。<br>  validate：验证项目配置。<br>  compile：编译源代码。<br>  test：运行单元测试。<br>  package：打包项目。<br>  verify：验证包的完整性和有效性。<br>  install：安装到本地仓库。<br>  site：生成项目文档。<br>  deploy：部署到远程仓库。</p>
</blockquote>
<h6 id="思考：前端发送的请求，是如何请求到后端服务的？"><a href="#思考：前端发送的请求，是如何请求到后端服务的？" class="headerlink" title="思考：前端发送的请求，是如何请求到后端服务的？"></a>思考：前端发送的请求，是如何请求到后端服务的？</h6><pre><code class="java">前端请求地址：http://localhost/api/employee/login
后端接口地址：http://localhost:8080/admin/employee/login
</code></pre>
<ul>
<li><p><strong>nginx</strong>反向代理，就是将前端发送的动态请求由nginx转发到后端服务器</p>
</li>
<li><p><strong>浏览器</strong> → <a target="_blank" rel="noopener" href="http://localhost/api/employee/login">http://localhost/api/employee/login</a> → <strong>Nginx</strong> → <a target="_blank" rel="noopener" href="http://localhost:8080/admin/employee/login">http://localhost:8080/admin/employee/login</a> → <strong>Tomcat</strong></p>
</li>
<li><p>nginx反向代理的好处：提高访问速度、进行负载均衡<del>(否则前端就只能访问一台服务器)</del>、保证后端服务安全<del>(不对外开放)</del></p>
</li>
</ul>
<h6 id="nginx-反向代理的配置方式"><a href="#nginx-反向代理的配置方式" class="headerlink" title="nginx 反向代理的配置方式"></a>nginx 反向代理的配置方式</h6><pre><code class="java">nginx.conf

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://localhost:8080/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡的配置方法-平均转发到多台后端服务器"><a href="#nginx-负载均衡的配置方法-平均转发到多台后端服务器" class="headerlink" title="nginx 负载均衡的配置方法(平均转发到多台后端服务器)"></a>nginx 负载均衡的配置方法(平均转发到多台后端服务器)</h6><pre><code class="java">nginx.conf

upstream webservers&#123;
    server 192.168.100.128:8080;
    server 192.168.100.129:8080;
&#125;

server&#123;
    listen 80;
    server_name localhost;
    location /api/&#123;
        proxy_pass http://webservers/admin/;  #反向代理
    &#125;
&#125;
</code></pre>
<h6 id="nginx-负载均衡策略："><a href="#nginx-负载均衡策略：" class="headerlink" title="nginx 负载均衡策略："></a>nginx 负载均衡策略：</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式，默认为1，权重越高，被分配的客户端请求就越多</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式，这样每个访客可以固定访问一个后端服务</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式，把请求优先分配给连接数少的后端服务</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据url分配方式，这样相同的url会被分配到同一个后端服务</td>
</tr>
<tr>
<td>fair</td>
<td>依据相应时间方式，响应时间短的服务将会被优先分配</td>
</tr>
</tbody></table>
<h3 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h3><h6 id="问题：员工表中的密码是明文存储，安全性太低"><a href="#问题：员工表中的密码是明文存储，安全性太低" class="headerlink" title="问题：员工表中的密码是明文存储，安全性太低"></a>问题：员工表中的密码是明文存储，安全性太低</h6><ul>
<li><p>将密码加密后存储，提高安全性</p>
</li>
<li><p>使用<strong>MD5</strong>加密方式对明文密码加密 <strong>[不可逆]</strong></p>
</li>
<li><p>修改数据库中的明文代码，改为MD5加密后的密文</p>
</li>
<li><p>修改Java代码，前端提交的代码进行MD5加密后再跟数据库中密码比对</p>
</li>
</ul>
<p><span style = "color:yellow"><strong>在Idea中有 “&#x2F;&#x2F;TODO” 这代表着标记处 此处还未完成一些操作 标记后可以在idea的下面快速定位到TODO</strong></span></p>
<blockquote>
<p>MD5密码加密后 也区分大小写 如果相同的密文但是大小写不同 结果还是不同的</p>
</blockquote>
<h6 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a><span style ="color:orange">修改密码</span></h6><pre><code class="java">com/sky/controller/admin/EmployeeController.java
 @PutMapping(&quot;/editPassword&quot;)
    @ApiOperation(&quot;修改密码&quot;)
    public Result editPassword(@RequestBody PasswordEditDTO passwordEditDTO) &#123;
        log.info(&quot;修改密码：&#123;&#125;&quot;, passwordEditDTO);
        employeeService.updatePassword(passwordEditDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/EmployeeService.java
/**
     * 更改密码
     * @param passwordEditDTO
     */
    void updatePassword(PasswordEditDTO passwordEditDTO);
</code></pre>
<pre><code class="java">com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 更改密码
     * @param passwordEditDTO
     */
    @Override
    public void updatePassword(PasswordEditDTO passwordEditDTO) &#123;
    //getCurrentId 方法：public static Long getCurrentId() 方法用于获取当前线程的用户ID。

        Long empId = BaseContext.getCurrentId();
    //select * from employee where id = #&#123;id&#125;   根据id查员工的所有
        Employee employee = employeeMapper.getById(empId);
    //用md根据从前端传来的oldpassword 去判断employee的原始代码是否相同
        if (!employee.getPassword().equals(DigestUtils.md5DigestAsHex(passwordEditDTO.getOldPassword().getBytes()))) &#123; 
            throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
        &#125;
        String newPassword = DigestUtils.md5DigestAsHex(passwordEditDTO.getNewPassword().getBytes());
        employee.setPassword(newPassword);
        employeeMapper.update(employee);
    &#125;
</code></pre>
<h3 id="导入接口文档"><a href="#导入接口文档" class="headerlink" title="导入接口文档"></a>导入接口文档</h3><h6 id="前后端分离开发流程"><a href="#前后端分离开发流程" class="headerlink" title="前后端分离开发流程"></a>前后端分离开发流程</h6><ul>
<li><strong>定制接口</strong>(定义规范) → <strong>前端开发</strong>(mock数据) + <strong>后端开发</strong>(后端自测) → <strong>连调</strong>(校验格式) → <strong>提测</strong>(自动化测试)</li>
</ul>
<h6 id="操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台"><a href="#操作步骤-YApi-Pro-高效、易用、功能强大的可视化接口管理平台" class="headerlink" title="操作步骤 YApi Pro-高效、易用、功能强大的可视化接口管理平台"></a>操作步骤 <a target="_blank" rel="noopener" href="https://yapi.pro/">YApi Pro-高效、易用、功能强大的可视化接口管理平台</a></h6><blockquote>
<p>将课程资料中提供的项目接口导入YApi<br>苍穹外卖-管理端接口.json<br>苍穹外卖-用户端接口.json<br>苍穹外卖-管理端+用户端接口 → 数据管理 → 数据导入(json 随后把json文件拖入) → 点击接口可查看</p>
</blockquote>
<h3 id="Swagger介绍和使用方式"><a href="#Swagger介绍和使用方式" class="headerlink" title="Swagger介绍和使用方式"></a>Swagger介绍和使用方式</h3><p><strong>Knife4j</strong>是为Java MVC框架集成Swagger生成Api文档的增强解决方案</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h6><ul>
<li>导入knife4j的maven坐标</li>
<li>在配置类中加入knife4j相关配置</li>
</ul>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
/**
 * 通过knife4j生成接口文档
 * @return
*/ 
@Bean
    public Docket docket() &#123;
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                    //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller&quot;))
                .paths(PathSelectors.any())
                .build();
        return docket;
    &#125;
</code></pre>
<ul>
<li>设置静态资源映射，否则接口文档页面无法访问</li>
</ul>
<pre><code class="java">/**
 * 设置静态资源映射
 * @param registry
*/
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
</code></pre>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a>) 这个文档是解析<code>EmployeeController</code>来的</p>
<h6 id="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"><a href="#通过Swagger就可以生成接口文档，那么我们不需要Yapi了？" class="headerlink" title="通过Swagger就可以生成接口文档，那么我们不需要Yapi了？"></a>通过Swagger就可以生成接口文档，那么我们不需要Yapi了？</h6><ul>
<li>Yapi是设计阶段使用的工具，管理和维护接口</li>
<li>Swagger在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</li>
</ul>
<p><strong>编写接口文档 在企业中需要注意：</strong></p>
<pre><code class="java">测试：
为每个API编写单元测试和集成测试，确保API的正确性和稳定性。
使用自动化测试工具（如Postman, JUnit等）来定期验证API的行为。
</code></pre>
<h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Api</strong></td>
<td>用在类上，例如<strong>Controller</strong>，表明对类的说明</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>用在类上，例如entity、DTO、VO</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>用在属性上，描述属性信息</td>
</tr>
<tr>
<td><strong>@ApiOperation</strong></td>
<td>用在方法上，例如Controller的方法，说明方法的用途、作用</td>
</tr>
</tbody></table>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
package com.sky.controller.admin;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.EmployeeService;
import com.sky.utils.JwtUtil;
import com.sky.vo.EmployeeLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

/**
 * 员工管理
 */
@RestController
@RequestMapping(&quot;/admin/employee&quot;)
@Slf4j
@Api(tags = &quot;员工相关接口&quot;)
public class EmployeeController &#123;

    @Autowired
    private EmployeeService employeeService;
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 登录
     *
     * @param employeeLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(value = &quot;员工登录&quot;)
    public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123;
        log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO);

        Employee employee = employeeService.login(employeeLoginDTO);

        //登录成功后，生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
        String token = JwtUtil.createJWT(
                jwtProperties.getAdminSecretKey(),
                jwtProperties.getAdminTtl(),
                claims);

        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();

        return Result.success(employeeLoginVO);
    &#125;

    /**
     * 退出
     *
     * @return
     */
    @PostMapping(&quot;/logout&quot;)
    @ApiOperation(value = &quot;员工退出&quot;)
    public Result&lt;String&gt; logout() &#123;
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/EmployeeLoginVO.java
// 这里是最后返回的数据vo [已经经历过由po→DTO→vo的过程] 这里的po应该就是Employee
package com.sky.vo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel(description = &quot;员工登录返回的数据格式&quot;)
public class EmployeeLoginVO implements Serializable &#123;

    @ApiModelProperty(&quot;主键值&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String userName;

    @ApiModelProperty(&quot;姓名&quot;)
    private String name;

    @ApiModelProperty(&quot;jwt令牌&quot;)
    private String token;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeLoginDTO.java
// 这里的DTO是传输中的数据
package com.sky.dto;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
@ApiModel(description = &quot;员工登录时传递的数据模型&quot;)
public class EmployeeLoginDTO implements Serializable &#123;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

&#125;
</code></pre>
<p><span style = "color:orange"><strong>Getter与Setter无中生有？？    以及快速创建对象builder</strong>  </span></p>
<blockquote>
<p>在上述VO和DTO代码中很显然没有看到常见的Getter和Setter<br>这是因为代码使用了 Lombok 注解，Lombok 是一个 Java 库，可以通过注解自动生成常见的样板代码，如 getter、setter、toString、equals 和 hashCode 等方法。</p>
<p><u>Lombok 注解解释</u>：<br>@<strong>Data</strong>：<br>作用：这是一个组合注解，包含了 @ToString、@EqualsAndHashCode、<u>@Getter、@Setter</u> 和 @RequiredArgsConstructor。<br><span style = "color:pink"><strong>效果：自动生成所有字段的 getter 和 setter 方法，toString 方法，equals 和 hashCode 方法，以及一个包含所有 final 字段和 @NonNull 字段的构造函数。</strong></span></p>
<p>@<strong>Builder</strong>：<br>作用：生成一个构建器模式的类，使得对象的创建更加灵活和可读。<br>效果：自动生成一个静态内部类 EmployeeLoginVO.EmployeeLoginVOBuilder，并提供构建方法。</p>
<ul>
<li><p>生成的构建器类包含所有字段的设置方法，并提供一个 build 方法来最终构建对象</p>
</li>
<li><p>使用构建器模式可以让你在创建对象时更清晰地指定各个字段的值，特别是在对象有很多字段时。<br>构建器模式允许你按需设置字段，而不需要为每个字段组合创建多个构造函数。</p>
</li>
<li><p>生成的构建器类：<br>Lombok 会自动生成一个静态内部类 EmployeeLoginVOBuilder，包含所有字段的设置方法和一个 build 方法。</p>
<ul>
<li>设置字段：<br>你可以按需调用构建器的设置方法来设置字段值，例如 id(1L)、userName(“john_doe”) 等。</li>
<li>构建对象：<br>最后调用 build 方法来创建 EmployeeLoginVO 对象。</li>
</ul>
</li>
</ul>
<pre><code class="java"> // 使用构建器创建 EmployeeLoginVO 对象
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(1L)
                .userName(&quot;john_doe&quot;)
                .name(&quot;John Doe&quot;)
                .token(&quot;eyJhbGciOiJIUzI1NiJ9...&quot;)
                .build();

        System.out.println(employeeLoginVO);
</code></pre>
<p>@<strong>NoArgsConstructor</strong>：<br>作用：生成一个无参构造函数。<br>效果：自动生成一个不带任何参数的构造函数。</p>
<p>@<strong>AllArgsConstructor</strong>：<br>作用：生成一个全参构造函数。<br>效果：自动生成一个包含所有字段的构造函数。</p>
</blockquote>
<p><span style = "color:orange"><strong>详细解析@GetMapping 与 @PostMapping</strong></span></p>
<blockquote>
<p>选择使用 @GetMapping 还是 @PostMapping 主要取决于Http请求的性质和用途<br><strong>@GetMapping</strong></p>
<p>作用：</p>
<ul>
<li><p>@GetMapping专门用于处理HTTP GET请求</p>
</li>
<li><p>GET请求通常用于从服务器获取资源，不会对服务器上的数据进行修改</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数通常附加在URL中 <code>@GetMapping(&quot;/xxx/&#123;id&#125;&quot;)</code> 底下会跟 <code>@PathVariable</code></li>
<li>请求是安全的不会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>查询数据：获取<strong>用户列表、搜索结果</strong></li>
<li>获取静态资源：图片、css文件</li>
<li>获取单个资源：获取某个用户的详细信息</li>
</ul>
<p>@<strong>PostMapping</strong></p>
<p>作用：</p>
<ul>
<li>@PostMapping专门用于处理HTTP POST请求</li>
<li>POST请求通常用于向服务器发送数据，可能会对服务器上的数据进行修改</li>
</ul>
<p>特点：</p>
<ul>
<li>请求参数放在请求体中，不会显示在URL这种 <code>@PostMapping(&quot;/users&quot;)</code>底下会跟<code>@RequestBody</code></li>
<li>请求体的大小没有固定限制，可以发送大量数据</li>
<li>多次相同的POST请求可能会产生不同的结果，可能会修改服务器状态</li>
<li>请求是不安全的，可能会修改服务器状态</li>
</ul>
<p><span style = "color:orange"><strong>适用场景：</strong></span></p>
<ul>
<li>创建新资源：注册新用户、添加新订单</li>
<li>更新现有资源：修改用户信息、更新订单状态</li>
<li>发送表单数据：登录、提交评论</li>
<li>上传文件：图片、文档</li>
</ul>
</blockquote>
<blockquote>
<p>以下是一些可能的原因，解释了为什么您看到的前端项目代码不是“正经的网页代码”：</p>
<ul>
<li><strong>构建过程</strong>：现代前端项目通常有一个构建过程，使用工具如Webpack、Rollup或Parcel等将源代码转换和打包。原始的代码可能在<code>src</code>目录中，而您看到的是构建后的<code>dist</code>目录，其中包含了转换和压缩后的文件。</li>
<li><strong>模块化和组件化</strong>：前端框架和库鼓励开发者将UI拆分成可复用的模块和组件。这意味着不再有传统的HTML、CSS和JavaScript混合在一起的代码，而是分别在不同的文件中定义。</li>
<li><strong>框架和库的使用</strong>：现代前端开发往往依赖于各种框架和库，这些框架和库有自己的文件结构和编写方式，可能和您熟悉的传统网页代码写法有很大不同。</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>根据@PutMapping(“&#x2F;{Id}”)提问</strong></span></p>
<h6 id="我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢"><a href="#我为什么-PutMapping-“-x2F-id-”-是id呢-是不是因为我后面需要数据库where-id-x3D-id-查询才这样传输-如果-我想以name去查询呢" class="headerlink" title="我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢"></a>我为什么@PutMapping(“&#x2F;{id}”)是id呢 是不是因为我后面需要数据库where id &#x3D; #{id} 查询才这样传输 如果 我想以name去查询呢</h6><blockquote>
<p>在RESTful API设计中，资源通常通过其唯一标识符（如ID）来访问和操作。<code>@PutMapping(&quot;/&#123;id&#125;&quot;)</code>使用<code>&#123;id&#125;</code>作为路径变量是因为ID是数据库中记录的唯一标识，这使得通过ID查找和更新特定的记录变得直接和高效。</p>
<p>如果你想要通过<code>name</code>来查询和更新记录，这在理论上是可行的，但需要注意以下几点：</p>
<ol>
<li><code>name</code>字段可能不是唯一的，这意味着可能有多条记录具有相同的名称。</li>
<li>使用非唯一字段作为更新依据可能会导致数据不一致或错误更新。</li>
</ol>
</blockquote>
<p><span style = "color:orange"><strong>更新员工 前后端联调原理</strong></span></p>
<pre><code class="javascript">★ 在前端使用Ajax与后端URL对应时，你需要确保Ajax请求的URL与后端控制器中定义的映射相匹配。在你提供的例子中，后端使用@PutMapping(&quot;/&#123;id&#125;&quot;)来定义更新员工信息的端点，因此前端的Ajax URL应该包含员工的ID

// 绑定更新按钮的点击事件
$(&#39;#updateBtn&#39;).click(function() &#123;
    var employee = &#123;
        id: $(&#39;#id&#39;).val(), // 假设这是员工的唯一标识符
        name: $(&#39;#name&#39;).val(),
        email: $(&#39;#email&#39;).val(),
        department: $(&#39;#department&#39;).val()
    &#125;;

    // 发起Ajax PUT请求，URL中包含员工的ID
    $.ajax(&#123;
        url: `/api/employees/$&#123;employee.id&#125;`, // 注意这里的URL与后端的@PutMapping(&quot;/&#123;id&#125;&quot;)对应
        type: &#39;PUT&#39;,
        contentType: &#39;application/json&#39;, // 指定发送给服务器的数据类型
        data: JSON.stringify(employee), // 将JavaScript对象转换为JSON字符串
        success: function(response) &#123;
            // 请求成功，可以在这里处理响应数据
            alert(&#39;Employee information updated successfully!&#39;);
            // 如果需要，可以在这里更新页面上的表单数据
        &#125;,
        error: function(xhr, status, error) &#123;
            // 请求失败，可以在这里处理错误信息
            alert(&#39;Error updating employee information: &#39; + xhr.responseText);
        &#125;
    &#125;);
&#125;);

//在这个例子中，employee.id是从表单中获取的员工ID，它被拼接到URL字符串中，以形成完整的请求URL。这个URL应该与后端控制器中定义的@PutMapping(&quot;/&#123;id&#125;&quot;)相对应。当点击更新按钮时，Ajax请求会被发送到后端，后端会根据提供的ID找到对应的员工记录并进行更新。
</code></pre>
<pre><code class="java"> @PutMapping(&quot;/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Employee&gt; updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) &#123;
        Employee employee = employeeService.getEmployeeById(id);
        if (employee != null) &#123;
            employee.setName(employeeDetails.getName());
            employee.setEmail(employeeDetails.getEmail());
            employee.setDepartment(employeeDetails.getDepartment());
            Employee updatedEmployee = employeeService.updateEmployee(employee);
            return ResponseEntity.ok(updatedEmployee);
        &#125; else &#123;
            return ResponseEntity.notFound().build();
        &#125;
    &#125;
&#125;
//这里&#123;id&#125;是路径变量，它会匹配Ajax请求URL中的employee.id。这样，前后端的URL就正确对应起来了。
</code></pre>
<h3 id="新增员工-Post-Json提交格式"><a href="#新增员工-Post-Json提交格式" class="headerlink" title="新增员工(Post+Json提交格式)"></a>新增员工(Post+Json提交格式)</h3><h4 id="需求分析和设计"><a href="#需求分析和设计" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h4><h6 id="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"><a href="#账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456" class="headerlink" title="账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456"></a>账号必须是唯一的、手机号校验合法11位、性别单选男女、身份证合法18位号码、新增密码默认为123456</h6><p><strong>本项目约定</strong>：</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用 <strong>&#x2F;admin</strong> 作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用 <strong>&#x2F;user</strong> 作为前缀</li>
</ul>
<h4 id="代码开发"><a href="#代码开发" class="headerlink" title="代码开发"></a>代码开发</h4><p>根据新增员工接口设计对应的DTO<br>注意：当前提交的数据和实体类中对应的属性差别比较大时，建议使用DTO(数据传输)来封装数据</p>
<pre><code class="java">sky-pojo  com/sky/dto/EmployeeDTO.java
package com.sky.dto;

import lombok.Data;

import java.io.Serializable;

@Data
public class EmployeeDTO implements Serializable &#123;

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 新增员工
     * @param employeeDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增员工&quot;)
    public Result save(@RequestBody  EmployeeDTO employeeDTO)&#123;
    // 因为是JSON格式 要加@RequestBody
        log.info(&quot;新增员工：&#123;&#125;&quot;,employeeDTO);
        employeeService.save(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
package com.sky.service;

import com.sky.dto.EmployeeDTO;
import com.sky.dto.EmployeeLoginDTO;
import com.sky.entity.Employee;

public interface EmployeeService &#123;

    /**
     * 员工登录
     * @param employeeLoginDTO
     * @return
     */
    Employee login(EmployeeLoginDTO employeeLoginDTO);

    /**
     * 新增员工
     * @param employeeDTO
     */
    void save(EmployeeDTO employeeDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
 /**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        //employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setUpdateUser(10L);

        employeeMapper.insert(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/Employee.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;

    private Integer status;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;

    private Long createUser;

    private Long updateUser;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
 * 插入员工数据
*/
    @Insert(&quot;insert into employee (name,username,password,phone,sex,id_number,create_time,update_time,create_user,update_user))&quot; +
            &quot;values&quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    void insert(Employee employee);
</code></pre>
<p><span style = "color:orange"><strong>@Builder 和 @JsonFormat</strong></span></p>
<blockquote>
<p>@Builder 是 Lombok 提供的一个注解，用于自动生成构建器模式的代码。<br>它会在编译时生成一个静态的 Builder 类和相关的方法，使得对象的创建更加灵活和可读。<br>需要<strong>创建不可变对象</strong>时，可以使用 @Builder 结合 @Value 注解。<br>需要<strong>创建复杂的对象</strong>时，可以通过构建器模式逐步设置属性，提高代码的可读性和可维护性</p>
<p>@JsonFormat 是 Jackson 库提供的注解，用于指定日期时间字段在 JSON 序列化和反序列化时的格式。<br>通过设置 pattern 属性，可以控制日期时间字段的格式化方式。<br>当需要将 LocalDateTime、Date 等日期时间类型的字段转换为特定格式的字符串时。<br>在 RESTful API 中，返回的 JSON 数据需要符合特定的日期时间格式要求。</p>
<h6 id="使用-Builder-的场景"><a href="#使用-Builder-的场景" class="headerlink" title="使用 @Builder 的场景"></a>使用 @Builder 的场景</h6><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        // 使用 @Builder 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(employee);
    &#125;
&#125;
</code></pre>
<h6 id="使用-JsonFormat-的场景"><a href="#使用-JsonFormat-的场景" class="headerlink" title="使用 @JsonFormat 的场景"></a>使用 @JsonFormat 的场景</h6><pre><code class="java">//创建 RESTful API
Employee里面的pojo就不详细写了
    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime createTime;

    //@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime updateTime;
==========================================================================

@RestController
public class EmployeeController &#123;

    @GetMapping(&quot;/employee&quot;)
    public ResponseEntity&lt;String&gt; getEmployee() throws Exception &#123;
        // 创建 Employee 对象
        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .createUser(1L)
                .updateUser(1L)
                .build();

        // 使用 ObjectMapper 将 Employee 对象转换为 JSON 字符串
        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(employee);

        return ResponseEntity.ok(json);
    &#125;
&#125;
===========================================================================
// 除了 @JsonFormat 注解，还有其他方式可以指定日期时间格式，具体取决于你的需求和使用的库。
 public static void main(String[] args) &#123;
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String formattedDateTime = now.format(formatter);

        Employee employee = Employee.builder()
                .id(1L)
                .username(&quot;user123&quot;)
                .name(&quot;张三&quot;)
                .password(&quot;password123&quot;)
                .phone(&quot;12345678901&quot;)
                .sex(&quot;男&quot;)
                .idNumber(&quot;123456789012345678&quot;)
                .status(1)
                .createTime(now)
                .updateTime(now)
                .createUser(1L)
                .updateUser(1L)
                .build();

        System.out.println(&quot;Formatted Create Time: &quot; + formattedDateTime);
        System.out.println(&quot;Formatted Update Time: &quot; + formattedDateTime);
    &#125;
</code></pre>
<p>@<strong>Builder</strong>：<br>通过 Employee.builder() 创建了一个构建器对象。<br>使用链式调用设置各个属性，最后调用 build() 方法生成 Employee 实例。<br>这种方式使得创建对象的代码更加简洁和易读，特别是当对象属性较多时。</p>
<p>@<strong>JsonFormat</strong>：<br>在 createTime 和 updateTime 字段上使用了 @JsonFormat 注解，指定了日期时间的格式为 “yyyy-MM-dd HH:mm:ss”。<br><u><strong>当 Employee 对象被转换为 JSON 字符串</strong></u>时，这两个字段会被格式化为指定的日期时间格式。<br>这样可以确保返回的 JSON 数据符合预期的格式要求。</p>
</blockquote>
<p><span style = "color:orange"><strong>RESTful风</strong></span></p>
<blockquote>
<p><strong>可缓存性：</strong><br>RESTful API 可以利用 HTTP 缓存机制，减少网络请求，提高性能。<br>客户端可以缓存响应，减少服务器的负载。</p>
<p>易于集成：<br>RESTful API 使用标准的 HTTP 协议，几乎所有的编程语言和框架都支持 HTTP 请求。<br>这使得不同系统之间的集成变得更加容易。</p>
<p>可读性强：<br>RESTful API 的 URL 设计通常非常直观，易于理解和记忆。<br>例如，&#x2F;users&#x2F;123 表示用户 ID 为 123 的资源，&#x2F;users&#x2F;123&#x2F;orders 表示该用户的订单资源。</p>
<p>灵活性：<br>RESTful API 支持多种数据格式（如 JSON、XML 等），可以根据需要选择合适的格式。<br>客户端和服务器可以通过协商确定数据格式，提高了灵活性。</p>
<p>  GET &#x2F;users<br>  GET &#x2F;users&#x2F;{id}<br>  POST &#x2F;users<br>  PUT &#x2F;users&#x2F;{id}</p>
</blockquote>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><h6 id="功能测试方式："><a href="#功能测试方式：" class="headerlink" title="功能测试方式："></a>功能测试方式：</h6><ul>
<li>通过接口文档测试</li>
<li>通过前后端联调测试</li>
</ul>
<p>注意：由于开发阶段前后端是并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主</p>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/documentManager/GlobalParameters-default">http://localhost:8080/doc.html#/documentManager/GlobalParameters-default</a>)</p>
<p><span style = "color:red">首先要拿到<strong>JWT令牌</strong>(去接口进行一次登录测试后会有) → 全局参数设置 → 添加参数</span><br><strong>注意</strong>：这个jwt→json是有有效期的(2小时&#x3D;7200000秒)</p>
<pre><code class="xml">sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
</code></pre>
<blockquote>
<p>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: {<br>    “id”: 1,<br>    “userName”: “admin”,<br>    “name”: “管理员”,<br>    “token”: “eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc”<br>  }<br>}</p>
<hr>
<p>新增参数：<br>  参数名称：token<br>  参数值：eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI3NjAxMTAxfQ.rnxaRc7fjPzMYwGHk3VzKA4EOxRFrYkKzesxEQsCQUc<br>  参数类型：header</p>
<p>新增员工接口<br>{<br>  “idNumber”: “1321321312”,<br>  “name”: “张三”,<br>  “phone”: “11111111111”,<br>  “sex”: “1”,<br>  “username”: “zhangsan”<br>}</p>
<p>响应内容：<br>{<br>  “code”: 1,<br>  “msg”: null,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component  //将该类注册为 Spring 管理的 Bean。
@Slf4j //使用 Lombok 自动生成日志记录器
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;
// 包含 JWT 相关的配置属性，如令牌名称和密钥
    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
//检查当前拦截到的是否是 Controller 的方法。如果不是，直接放行
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/properties/JwtProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.jwt&quot;)
@Data
public class JwtProperties &#123;

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;
&#125;
</code></pre>
<h4 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h4><h6 id="程序存在的问题："><a href="#程序存在的问题：" class="headerlink" title="程序存在的问题："></a>程序存在的问题：</h6><ul>
<li>录入的用户名已存在，抛出异常后没有处理</li>
<li>新增员工时，创建人id和修改人id设置了固定值</li>
</ul>
<blockquote>
<p>当你在 Maven 中执行 compile 命令时，它会强制 Maven 重新编译整个项目，包括所有的类和资源。这一过程会清除任何旧的编译结果，确保所有的依赖和代码都是最新的。这可能导致以下几种情况，从而解决了你的问题：</p>
<p>**<u>重新编译：</u>**Maven 会重新编译所有的源代码，包括你修改或新增的类，这样就能解决因为旧的编译缓存而引起的引用问题。<br>**<u>更新依赖：</u>**如果你在项目中添加或修改了依赖，执行 compile 可以确保这些依赖被正确加载和引用。<br><u><strong>清理旧缓存</strong>：</u>在编译过程中，Maven 会清理旧的缓存和临时文件，避免由于这些文件造成的潜在冲突。<br>**<u>IDE 同步：</u>**有时候，IDE 的状态可能与 Maven 项目状态不一致，执行 Maven 命令可以帮助 IDE 重新同步项目的状态。</p>
</blockquote>
<h6 id="问题①"><a href="#问题①" class="headerlink" title="问题①"></a>问题①</h6><pre><code class="java">sky-server  com/sky/handler/GlobalExceptionHandler.java
package com.sky.handler;

import com.sky.constant.MessageConstant;
import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器，处理项目中抛出的业务异常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler &#123;

    /**
     * 捕获业务异常
     * @param ex
     * @return
     */
    @ExceptionHandler
    public Result exceptionHandler(BaseException ex)&#123;
        log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage());
        return Result.error(ex.getMessage());
    &#125;

    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) &#123;
        String message = ex.getMessage();
        if (message.contains(&quot;Duplicate entry&quot;)) &#123;
            // Duplicate entry &#39;zhangsan&#39; for key &#39;employee.idx_username&#39;
// 在这里，我们使用 split(&quot;&#39;&quot;) 将字符串分割为多个部分。这样，parts[1] 将得到 zhangsan，因为它位于单引号之间。这种方式可以正确提取用户名。
            String[] split = message.split(&quot;&#39;&quot;);
            String username = split[1];
//            String msg = username + &quot;已存在&quot;;
            String msg = username + MessageConstant.ALREADY_EXISTS;
            return Result.error(msg);
        &#125;else &#123;
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>Split的深入学习</strong></span></p>
<blockquote>
<ul>
<li><strong>正则表达式</strong></li>
</ul>
<p>split 方法接受一个<strong>正则表达式</strong>作为参数，因此分隔符可以是复杂的模式，而不仅仅是单个字符。<br>例如，<strong>split(“\s+”)</strong> 可以用来按一个或多个空白字符（包括空格、制表符、换行符等）进行分割。</p>
<ul>
<li><strong>限制分割次数</strong></li>
</ul>
<p>split 方法还有一个重载版本 split(String regex, int limit)，可以限制分割的次数。<br>例如，split(“‘“, 3) 只会进行两次分割，结果数组最多包含三个元素。</p>
</blockquote>
<h3 id="问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal"><a href="#问题②-解析出员工登录id后，如何转递给Service的save方法？→-ThreadLocal" class="headerlink" title="问题②  解析出员工登录id后，如何转递给Service的save方法？→ ThreadLocal"></a>问题②  <span style = "color:orange"><strong>解析出员工登录id后，如何转递给Service的save方法？</strong></span>→ <span style = "color:red">ThreadLocal</span></h3><img src="https://raw.githubusercontent.com/P-luminary/images/2dd9f9e12ba173719123c685949c277632af5ce4/data/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E7%99%BB%E5%BD%95%E5%8F%8A%E6%A0%A1%E9%AA%8C.jpg" style="zoom:150%;" />

<h6 id="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："><a href="#前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：" class="headerlink" title="前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id："></a>前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：</h6><pre><code class="java">        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
</code></pre>
<h6 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h6><p>ThreadLocal并不是一个Thread，Thread的局部变量<br><strong>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获得到对应的值，线程外则不能访问</strong></p>
<pre><code class="java">sky-common  com/sky/context/BaseContext.java
package com.sky.context;

public class BaseContext &#123;

    public static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();

    public static void setCurrentId(Long id) &#123;
        threadLocal.set(id);
    &#125;

    public static Long getCurrentId() &#123;
        return threadLocal.get();
    &#125;

    public static void removeCurrentId() &#123;
        threadLocal.remove();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/interceptor/JwtTokenAdminInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info(&quot;当前员工id：&quot;, empId);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            BaseContext.setCurrentId(empId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 新增员工
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
//        employee.setName(employeeDTO.getName()); 太多了 用对象属性拷贝
        BeanUtils.copyProperties(employeeDTO,employee); //其余的要手动设置
        //设置账号状态，默认正常状态 1正常 0锁定  规范封装
        employee.setStatus(StatusConstant.ENABLE);
        //设置密码，默认密码123456
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));
        //设置当前记录的创建时间和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        //设置当前记录创建人id和修改人id
        //TODO 后期需要改为当前登录用户的id
//        employee.setCreateUser(10L);
// ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
        employee.setCreateUser(BaseContext.getCurrentId());
        employee.setUpdateUser(BaseContext.getCurrentId());
    
        employeeMapper.insert(employee);
    &#125;

// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 如果想单独针对22行代码 测试部分的值是多少 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
// 左键选中&#39;BaseContext.getCurrentId()&#39; 右键Evaluate Expression单独计算即可
</code></pre>
<p><span style = "color:orange"><strong>将员工登录ID放在 ThreadLocal 中的原因</strong></span></p>
<blockquote>
<p>在多线程环境中，使用 ThreadLocal 来存储和传递员工的完整信息是一个常见的做法。这样可以确保每个线程都有独立的变量副本，避免并发问题。以下是一些步骤和最佳实践，帮助你在 ThreadLocal 中安全地传递和存储员工的完整信息。<br>ThreadLocal 主要用于在同一个线程内传递和存储数据，确保每个线程都有独立的变量副本。在你的例子中，ThreadLocal 用于存储员工ID，确保在多线程环境下员工ID的安全传递。</p>
<ul>
<li><strong>线程隔离</strong>：ThreadLocal 确保每个线程都有独立的员工ID副本，避免了多线程环境下的并发问题。<br>防止篡改：<u><strong>只有当前线程可以访问和修改 ThreadLocal 中的员工ID</strong></u>，其他线程无法访问，确保了ID的安全性。</li>
<li><strong>员工其他信息的安全性</strong><br><u>数据库查询</u>：员工的其他信息是从数据库中查询的，而不是从 ThreadLocal 中获取的。数据库查询本身是安全的，只要数据库连接和查询操作是安全的。<br><u>权限控制</u>：确保只有经过认证的用户才能执行查询操作，防止未授权访问。<br><u>数据加密</u>：敏感信息（如密码）在存储和传输过程中应进行加密，确保数据的安全性。</li>
</ul>
<p><strong>线程安全</strong>：<br>ThreadLocal 为每个线程提供独立的变量副本，避免了多线程环境下的并发问题。每个线程都可以安全地读取和修改自己的 ThreadLocal 变量，而不会影响其他线程。</p>
<p><strong>简化代码</strong>：<br>在 Web 应用中，通常需要在多个方法或组件之间传递用户身份信息（如员工登录ID）。使用 ThreadLocal 可以避免在每个方法调用中显式传递这些信息，从而简化代码。</p>
<p><strong>全局访问</strong>：<br>在同一个线程内，任何地方都可以访问 ThreadLocal 中存储的值，这使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
<p><strong>避免传递参数</strong>：<br>在多层调用中，如果需要传递员工登录ID，通常需要在每个方法签名中添加相应的参数。使用 ThreadLocal 可以避免这种繁琐的参数传递，提高代码的可读性和可维护性。</p>
<pre><code class="java">// 设置员工登录ID：
在用户登录成功后，将员工登录ID设置到 ThreadLocal 中。
@PostMapping(&quot;/login&quot;)
public ResponseEntity&lt;?&gt; login(@RequestBody LoginRequest loginRequest) &#123;
    // 验证用户名和密码
    User user = userService.validateUser(loginRequest.getUsername(), loginRequest.getPassword());
    if (user != null) &#123;
        // 设置当前线程的员工登录ID
        BaseContext.setCurrentId(user.getId());
        // 返回登录成功信息
        return ResponseEntity.ok(&quot;Login successful&quot;);
    &#125; else &#123;
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(&quot;Invalid username or password&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">// 获取员工登录ID
在需要使用员工登录ID的地方，直接从 ThreadLocal 中获取
@Service
public class OrderService &#123;

    public void createOrder(Order order) &#123;
        Long currentUserId = BaseContext.getCurrentId();
        if (currentUserId != null) &#123;
            order.setCreatedBy(currentUserId);
            orderRepository.save(order);
        &#125; else &#123;
            throw new RuntimeException(&quot;User ID not found in context&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>将员工登录ID放在 ThreadLocal 中，可以确保每个线程都有独立的变量副本，避免多线程环境下的并发问题。同时，这种方式简化了代码，提供了全局访问的能力，避免了繁琐的参数传递，使得在复杂的业务逻辑中传递和使用员工登录ID变得非常方便。</p>
</blockquote>
<h3 id="员工分页查询"><a href="#员工分页查询" class="headerlink" title="员工分页查询"></a>员工分页查询</h3><h5 id="需求分析和设计-1"><a href="#需求分析和设计-1" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则：-查询-→-get"><a href="#业务规则：-查询-→-get" class="headerlink" title="业务规则：(查询 → get)"></a>业务规则：(查询 → get)</h6><ul>
<li>根据页码展示员工信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要，输入员工姓名进行查询</li>
</ul>
<h5 id="代码开发-1"><a href="#代码开发-1" class="headerlink" title="代码开发"></a>代码开发</h5><h6 id="根据分页查询接口设计对应的DTO"><a href="#根据分页查询接口设计对应的DTO" class="headerlink" title="根据分页查询接口设计对应的DTO:"></a>根据分页查询接口设计对应的DTO:</h6><p><strong>Query</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>是否必须</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>否</td>
<td>张三</td>
<td>员工姓名</td>
</tr>
<tr>
<td>page</td>
<td>是</td>
<td>1</td>
<td>页码</td>
</tr>
<tr>
<td>pageSize</td>
<td>是</td>
<td>10</td>
<td>每页记录数</td>
</tr>
</tbody></table>
<pre><code class="java">@Data
public class EmployeePageQueryDTO implements Serializable&#123;
    private String name;
    private int page;
    private int pageSize;
&#125;
</code></pre>
<h6 id="后面所有的分页查询，统一都封装成PageResult对象"><a href="#后面所有的分页查询，统一都封装成PageResult对象" class="headerlink" title="后面所有的分页查询，统一都封装成PageResult对象"></a>后面所有的分页查询，统一都封装成PageResult对象</h6><pre><code class="java">/*封装分页查询结果*/
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable&#123;
    private long total; 
    private List records;
&#125;
</code></pre>
<h6 id="员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt"><a href="#员工信息分页查询后端返回的对象类型为：Result-lt-PageResult-gt" class="headerlink" title="员工信息分页查询后端返回的对象类型为：Result &lt; PageResult &gt;"></a>员工信息分页查询后端返回的对象类型为：<strong>Result &lt; PageResult &gt;</strong></h6><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
/**
     * 员工分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    public Result&lt;PageResult&gt; page(EmployeePageQueryDTO employeePageQueryDTO)&#123;
        //格式不是JSON不用加 @RequestBody
        log.info(&quot;员工分页查询，参数为：&#123;&#125;&quot;, employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 分页查询
     * @param employeePageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) &#123;
        // select * from employee limit 0,10
        // 开始分页查询 动态拼接
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        Page&lt;Employee&gt; page =  employeeMapper.pageQuery(employeePageQueryDTO);

        long total = page.getTotal();
        List&lt;Employee&gt; records = page.getResult();

        return new PageResult(total, records);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>逐行研究分页查询</strong></span></p>
<blockquote>
<ul>
<li><p>PageHelper.startPage 是 MyBatis 分页插件提供的方法，用于开启分页功能</p>
<ul>
<li><p>employeePageQueryDTO.getPage() 获取当前页码。</p>
</li>
<li><p>employeePageQueryDTO.getPageSize() 获取每页显示的记录数</p>
<p>这一行代码的作用是告诉 MyBatis 在接下来的查询中启用分页，并设置分页参数</p>
</li>
</ul>
</li>
<li><p>employeeMapper.pageQuery(employeePageQueryDTO) 是调用 MyBatis 的 Mapper 接口方法，执行分页查询。</p>
<ul>
<li>employeePageQueryDTO 包含了查询条件，如关键字、排序字段等。</li>
<li>查询结果会被封装成 Page<Employee> 对象，其中包含了分页数据和分页元数据。</li>
</ul>
</li>
<li><p>page.getTotal() 获取分页查询的总记录数。</p>
<ul>
<li>总记录数用于计算总页数和其他分页相关的计算</li>
</ul>
</li>
<li><p>List<Employee> records &#x3D; page.getResult();</p>
<ul>
<li>page.getResult() 获取分页查询的实际数据列表。</li>
<li>这个列表包含了当前页的员工记录</li>
</ul>
</li>
<li><p>return new PageResult(total, records);</p>
</li>
<li><p>new PageResult(total, records) 创建一个新的 PageResult 对象，将总记录数和分页数据列表封装起来</p>
</li>
<li><p>PageResult 类通常包含 total 和 records 属性，用于返回给客户端</p>
</li>
<li><p>假设 employeePageQueryDTO.getPage() 返回 2，employeePageQueryDTO.getPageSize() 返回 10，那么 MyBatis 生成的 SQL 可能类似于：</p>
</li>
</ul>
<pre><code class="mysql">SELECT * FROM employee
WHERE ... -- 根据 employeePageQueryDTO 中的查询条件
LIMIT 10 OFFSET 10;
</code></pre>
<p>LIMIT 10：表示每页显示 10 条记录。<br>OFFSET 10：表示从第 11 条记录开始（因为页码从 1 开始，所以第 2 页的偏移量是 10）。</p>
<ul>
<li><p><strong>PageResult 类</strong>：用于封装分页查询的结果，包括总记录数和当前页的数据集合。<br>使用场景：在分页查询服务中，将查询结果封装为 PageResult 对象，通过控制器返回给客户端。</p>
</li>
<li><p><strong>Serializable 接口</strong>：是 Java 中的一个标记接口，没有定义任何方法。实现 Serializable 接口的类的对象可以被序列化，即将对象的状态转换为字节流，以便在网络上传输或持久化存储。反序列化则是将字节流恢复为对象的过程。 </p>
<ul>
<li><strong>序列化</strong></li>
</ul>
<p><u>对象状态转换</u>：将对象的状态（即对象的字段值）转换为字节流。<br>默认序列化机制：Java 提供了默认的序列化机制，通过 ObjectOutputStream 类的 writeObject 方法实现。<br><u>自定义序列化</u>：可以通过实现 writeObject 和 readObject 方法来自定义序列化和反序列化过程。</p>
<ul>
<li><strong>持久化</strong></li>
</ul>
<p>持久化：序列化的主要目的是将对象的状态保存到存储介质中，或者通过网络传输对象。</p>
</li>
</ul>
<p>查询结果会被封装到 PageResult 对象中，其中 total 表示总记录数，records 表示当前页的数据集合。</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
</code></pre>
<pre><code class="xml">sky-server  mapper/EmployeeMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.EmployeeMapper&quot;&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Employee&quot;&gt;
        select * from employee
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
        &lt;/where&gt;
        order by create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
&lt;!--
and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)：
如果条件成立，生成的 SQL 条件为 AND name LIKE &#39;%$&#123;name&#125;%&#39;，实现名称的模糊匹配
--&gt;
</code></pre>
<p>[员工管理] (<a target="_blank" rel="noopener" href="http://localhost/#/employee">http://localhost/#/employee</a>)</p>
<h5 id="代码完善-1"><a href="#代码完善-1" class="headerlink" title="代码完善"></a>代码完善</h5><h6 id="问题：创建-x2F-更新时间那边传入的数据不是想要的"><a href="#问题：创建-x2F-更新时间那边传入的数据不是想要的" class="headerlink" title="问题：创建&#x2F;更新时间那边传入的数据不是想要的"></a>问题：创建&#x2F;更新时间那边传入的数据不是想要的</h6><pre><code class="java">// 2024929214237
&quot;createTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
        &quot;updateTime&quot;: [
          2024,
          9,
          29,
          22,
          10,
          37
        ],
</code></pre>
<h6 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h6><ul>
<li><p><strong>方法一</strong>：在属性上加注解，对日期进行格式化<del>(只能处理单独一个属性)</del></p>
<pre><code class="java">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
private LocalDateTime updateTime;
------------------------------------------------------------------------
 &quot;createTime&quot;: &quot;2024-09-29 22:10:37&quot;,
</code></pre>
</li>
<li><p><strong>方法二</strong>：在<code>WebMvcConfiguration</code>中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理</p>
</li>
</ul>
<blockquote>
<p>重写父类方法 去扩展 消息转换器</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
 /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
</code></pre>
<pre><code class="java">package com.sky.json;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper &#123;

    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;;
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    public JacksonObjectMapper() &#123;
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    &#125;
&#125;
</code></pre>
<h3 id="启用禁用员工账号"><a href="#启用禁用员工账号" class="headerlink" title="启用禁用员工账号"></a>启用禁用员工账号</h3><h5 id="需求分析和设计-2"><a href="#需求分析和设计-2" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h5><h6 id="业务规则："><a href="#业务规则：" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以对状态为 “启用” 的员工账号进行 “禁用” 操作</li>
<li>可以对状态为 “禁用” 的员工账号进行 “启用” 操作</li>
<li>状态为 “禁用” 的员工账号不能登录系统</li>
</ul>
<pre><code class="java">sky-server
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用员工账号&quot;)
    //因为上面的和下面的参数都是一致 不然需要@PathVariable(&quot;status&quot;)解释一下
    public Result startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id) &#123;
        log.info(&quot;启用禁用员工账号: &#123;&#125;,&#123;&#125;&quot;,status,id);
        employeeService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
 /**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 启用禁用员工账号
     * @param status
     * @param id
     * @return
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        // update employee set status = ? where id = ?
        Employee employee = new Employee();
        employee.setStatus(status);
        employee.setId(id);

/** 要在Employee.java中添加@Builder 才能使用这种风格
 *      Employee employee = Employee.builder()
 *              .status(status)
 *              .id(id)
 *              .build();
 */
        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
/**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);
</code></pre>
<pre><code class="java">sky-server  mapper/EmployeeMapper.xml
&lt;update id=&quot;update&quot; parameterType=&quot;Employee&quot;&gt;
        update employee
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;name = #&#123;name&#125;,&lt;/if&gt;
            &lt;if test=&quot;username != null&quot;&gt;username = #&#123;username&#125;,&lt;/if&gt;
            &lt;if test=&quot;password != null&quot;&gt;password = #&#123;password&#125;,&lt;/if&gt;
            &lt;if test=&quot;phone != null&quot;&gt;phone = #&#123;phone&#125;,&lt;/if&gt;
            &lt;if test=&quot;sex != null&quot;&gt;sex = #&#123;sex&#125;,&lt;/if&gt;
            &lt;if test=&quot;idNumber != null&quot;&gt;id_Number = #&#123;idNumber&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;update_Time = #&#123;updateTime&#125;,&lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;update_User = #&#123;updateUser&#125;,&lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125;,&lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h3><h4 id="需求分析和设计-回写数据"><a href="#需求分析和设计-回写数据" class="headerlink" title="需求分析和设计[回写数据]"></a>需求分析和设计[回写数据]</h4><h6 id="编辑员工功能涉及到两个接口："><a href="#编辑员工功能涉及到两个接口：" class="headerlink" title="编辑员工功能涉及到两个接口："></a>编辑员工功能涉及到两个接口：</h6><ul>
<li>根据id查询员工信息</li>
<li>编辑员工信息</li>
</ul>
<h4 id="代码开发-2"><a href="#代码开发-2" class="headerlink" title="代码开发"></a>代码开发</h4><pre><code class="java">sky-server  com/sky/controller/admin/EmployeeController.java
    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id)&#123;
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;编辑员工信息&quot;)
    public Result update(@RequestBody EmployeeDTO employeeDTO)&#123;
        log.info(&quot;编辑员工信息：&#123;&#125;&quot;, employeeDTO);
        employeeService.update(employeeDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/EmployeeService.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    Employee getById(Long id);

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    void update(EmployeeDTO employeeDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/EmployeeServiceImpl.java
/**
     * 根据id查询员工
     * @param id
     * @return
     */
    public Employee getById(Long id) &#123;
        Employee employee = employeeMapper.getById(id);
        employee.setPassword(&quot;****&quot;);
        return employee;
    &#125;

    /**
     * 编辑员工信息
     * @param employeeDTO
     */
    public void update(EmployeeDTO employeeDTO) &#123;
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO, employee);

        //employee.setUpdateTime(LocalDateTime.now());
        //employee.setUpdateUser(BaseContext.getCurrentId());

        employeeMapper.update(employee);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
 /**
     * 根据主键动态修改属性
     * @param employee
     */
    void update(Employee employee);

    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)
    Employee getById(Long id);
</code></pre>
<blockquote>
<ul>
<li>前端提交表单：<br>用户在前端页面编辑员工信息并提交表单。<br>表单数据被序列化为 JSON 格式，通过 HTTP PUT 请求发送到后端。</li>
<li>后端接收数据：<br>控制器方法 update 接收到 EmployeeDTO 对象。<br>记录日志，输出接收到的员工信息。<br>调用服务层的 update 方法，处理员工信息的更新。</li>
<li>服务层处理：<br>创建一个新的 Employee 对象。<br>使用 BeanUtils.copyProperties 将 EmployeeDTO 的属性复制到 Employee 对象中。<br>调用 MyBatis 的 employeeMapper，执行更新操作。</li>
<li>MyBatis 更新操作：<br>生成动态 SQL 语句，只更新传入的非 null 属性。<br>例如，如果 name 和 phone 不为 null，生成的 SQL 语句如下：</li>
</ul>
</blockquote>
<p><span style = "color:orange"><strong>数据回写的具体过程</strong></span></p>
<blockquote>
<ul>
<li>前端请求获取员工信息   &#x2F;&#x2F; 根据id查询员工信息<br>当你点击编辑按钮时，前端会发起一个 HTTP GET 请求，从后端获取员工的详细信息。这些信息将被用来填充表单字段。</li>
<li>后端处理 GET 请求<br>后端需要提供一个接口来处理这个 GET 请求，并返回员工的详细信息。</li>
<li>前端处理响应并填充表单<br>前端接收到后端返回的员工信息后，将其填充到表单字段中</li>
</ul>
<pre><code class="java">/**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping(&quot;&#123;/id&#125;&quot;)
    @ApiOperation(&quot;根据id查询员工信息&quot;)
    public Result&lt;Employee&gt; getById(@PathVariable Long id) &#123;
        log.info(&quot;根据id查询员工信息：&#123;&#125;&quot;, id);
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    &#125;
</code></pre>
<pre><code class="vue">&lt;script&gt;export default &#123;
  data() &#123;
    return &#123;
      employee: &#123;
        id: null,
        name: &#39;&#39;,
        username: &#39;&#39;,
        password: &#39;&#39;,
        phone: &#39;&#39;,
        sex: &#39;&#39;,
        idNumber: &#39;&#39;
      &#125;
    &#125;;
  &#125;,
  methods: &#123;
    async fetchEmployee(id) &#123;
      try &#123;
        const response = await this.$axios.get(`/employees/$&#123;id&#125;`);
        this.employee = response.data.data;
      &#125; catch (error) &#123;
        console.error(&#39;获取员工信息失败&#39;, error);
      &#125;
    &#125;,
    async updateEmployee() &#123;
      try &#123;
        await this.$axios.put(&#39;/employees&#39;, this.employee);
        alert(&#39;员工信息更新成功&#39;);
      &#125; catch (error) &#123;
        console.error(&#39;更新员工信息失败&#39;, error);
      &#125;
    &#125;
  &#125;,
  mounted() &#123;
    const id = this.$route.params.id; // 假设通过路由参数传递员工ID
    this.fetchEmployee(id);
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>提交表单<br>当用户编辑完表单并点击保存按钮时，前端会发起一个 HTTP PUT 请求，将更新后的员工信息发送到后端进行处理</li>
</ul>
<p><strong>总结</strong><br>前端请求获取员工信息：点击编辑按钮时，前端发起 GET 请求获取员工的详细信息。<br>后端处理 GET 请求：后端提供一个接口处理 GET 请求，返回员工的详细信息。<br>前端处理响应并填充表单：前端接收到员工信息后，将其填充到表单字段中。<br>提交表单：用户编辑完表单并点击保存按钮，前端发起 PUT 请求，将更新后的员工信息发送到后端进行处理。</p>
</blockquote>
<p>[苍穹外卖项目接口文档] (<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/%E5%91%98%E5%B7%A5%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/updateUsingPUT">http://localhost:8080/doc.html#/default/员工相关接口/updateUsingPUT</a>)</p>
<h4 id="导入分类管理功能代码"><a href="#导入分类管理功能代码" class="headerlink" title="导入分类管理功能代码"></a>导入分类管理功能代码</h4><h6 id="业务规则：-1"><a href="#业务规则：-1" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>分类名称必须是<strong>唯一</strong>的</li>
<li>分类按章类型可分为<strong>菜品分类</strong>和<strong>套餐分类</strong></li>
<li>新添加的分类状态默认认为 “<strong>禁用</strong>“</li>
</ul>
<h6 id="接口设计："><a href="#接口设计：" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>新增分类</li>
<li>分类分页查询</li>
<li>根据id删除分类</li>
<li>修改分类</li>
<li>启用禁止分类</li>
<li>根据类型调查分类</li>
</ul>
<p><strong>数据库设计(category表)</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/CategoryController.java
package com.sky.controller.admin;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.List;

/**
 * 分类管理
 */
@RestController
@RequestMapping(&quot;/admin/category&quot;)
@Api(tags = &quot;分类相关接口&quot;)
@Slf4j
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     * @param categoryDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增分类&quot;)
    public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123;
        log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO);
        categoryService.save(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 分类分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分类分页查询&quot;)
    public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123;
        log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO);
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 删除分类
     * @param id
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;删除分类&quot;)
    public Result&lt;String&gt; deleteById(Long id)&#123;
        log.info(&quot;删除分类：&#123;&#125;&quot;, id);
        categoryService.deleteById(id);
        return Result.success();
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改分类&quot;)
    public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123;
        categoryService.update(categoryDTO);
        return Result.success();
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;启用禁用分类&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123;
        categoryService.startOrStop(status,id);
        return Result.success();
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据类型查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type)&#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);

        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人
        category.setUpdateTime(LocalDateTime.now());
        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status)
                .updateTime(LocalDateTime.now())
                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    Page&lt;Category&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    @Delete(&quot;delete from category where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.CategoryMapper&quot;&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.entity.Category&quot;&gt;
        select * from category
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                and type = #&#123;type&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by sort asc , create_time desc
    &lt;/select&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot;&gt;
        update category
        &lt;set&gt;
            &lt;if test=&quot;type != null&quot;&gt;
                type = #&#123;type&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;sort != null&quot;&gt;
                sort = #&#123;sort&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt;
        select * from category
        where status = 1
        &lt;if test=&quot;type != null&quot;&gt;
            and type = #&#123;type&#125;
        &lt;/if&gt;
        order by sort asc,create_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

&#125;
</code></pre>
<h2 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h2><h4 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h4><p>业务表中的公共字段：(后期会很多[菜品&#x2F;套餐管理])</p>
<h6 id="问题：代码冗余不利于后期维护"><a href="#问题：代码冗余不利于后期维护" class="headerlink" title="问题：代码冗余不利于后期维护"></a>问题：代码冗余不利于后期维护</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
</tr>
</tbody></table>
<h6 id="解决：技术点-→-枚举、注解、AOP、反射"><a href="#解决：技术点-→-枚举、注解、AOP、反射" class="headerlink" title="解决：技术点 → 枚举、注解、AOP、反射"></a>解决：技术点 → 枚举、注解、AOP、反射</h6><table>
<thead>
<tr>
<th>序号</th>
<th>字段名</th>
<th>含义</th>
<th>数据类型</th>
<th>操作类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>create_time</td>
<td>创建时间</td>
<td>datetime</td>
<td>insert</td>
</tr>
<tr>
<td>2</td>
<td>create_user</td>
<td>创建人id</td>
<td>bigint</td>
<td>insert</td>
</tr>
<tr>
<td>3</td>
<td>update_time</td>
<td>修改时间</td>
<td>datetime</td>
<td>insert、update</td>
</tr>
<tr>
<td>4</td>
<td>update_user</td>
<td>修改人id</td>
<td>bigint</td>
<td>insert、update</td>
</tr>
</tbody></table>
<ul>
<li>自定义注解 <strong>AutoFill</strong>，用于标识需要进行公共字段自动填充的方法</li>
<li>自定义切面 <strong>AutoFillAspect</strong>，统一拦截加入了 <strong>AutoFill</strong> 注解的方法，通过反射为公共字段赋值</li>
<li>在 <strong>Mapper</strong> 的方法上加入 <strong>AutoFill</strong> 注解</li>
</ul>
<h4 id="代码开发1"><a href="#代码开发1" class="headerlink" title="代码开发1"></a>代码开发1</h4><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java
package com.sky.annotation;

import com.sky.enumeration.OperationType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill &#123;
// 枚举数据库操作类型：UPDATE INSERT [只要在这情况才有必要设置]
    OperationType value();
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/EmployeeMapper.java
//只在update和insert里加
@Mapper
public interface EmployeeMapper &#123;
 /**
     * 插入员工数据
     * @param employee
     */
    @Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +
            &quot;values &quot; +
            &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)
    @AutoFill(value = OperationType.INSERT)
    void insert(Employee employee);
/**
     * 分页查询 [动态sql 不用注解了 写道 EmployeeMapper.xml]
     * @param employeePageQueryDTO
     * @return
     */
    Page&lt;Employee&gt; pageQuery(EmployeePageQueryDTO employeePageQueryDTO);
    @AutoFill(value = OperationType.UPDATE)
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/CategoryMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.enumeration.OperationType;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;
@Mapper
public interface CategoryMapper &#123;

    /**
     * 插入数据
     * @param category
     */
    @Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +
            &quot; VALUES&quot; +
            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)
    void insert(Category category);

    /**
     * 根据id修改分类
     * @param category
     */
    void update(Category category);
&#125;
</code></pre>
<p><span style = "color:orange"><strong>详细讲解@AutoFill</strong></span></p>
<blockquote>
<p><strong><u>@Target(ElementType.<em>METHOD</em>)</u></strong><br>使用<code>@Target</code>注解指定自定义注解@AutoFill可以应用的目标元素类，这里指定了<code>ElementType.METHOD</code>，表示@AutoFill**<u>只能应用于方法上</u>**</p>
<p><strong><u>@Retention(RetentionPolicy.RUNTIME)</u></strong><br>使用 <code>@Retention</code> 注解指定自定义注解 @AutoFill 的保留策略。这里指定了 <code>RetentionPolicy.RUNTIME</code>，表示 @AutoFill 注解会在运行时保留，可以通过反射获取到。</p>
<p><strong><u>public @interface AutoFill {…}</u></strong><br>@interface：关键字，用于定义一个新的注解类型。<br>AutoFill：注解的名称，表示这个注解就叫做AutoFill</p>
<p>区分普通接口：<code>@interface</code> 与普通的 <code>interface</code> 不同，普通的interface用于定义接口，而@interface用于定义注解，@符号帮助编译器区分这两者</p>
<pre><code class="java">package com.sky.enumeration;

/**
 * 数据库操作类型
 */
public enum OperationType &#123;
    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT
&#125;
</code></pre>
<hr>
<p>@<strong><u>Aspect</u></strong><br>使用<code>@Aspect</code>注解将这个类标记为一个切面，切面是AOP(面向切面编程)，用于定义切面关注点(日志记录、事务管理)</p>
<p>@<strong><u>Component</u></strong><br>使用<code>@Component</code>注解将这个类标记为Spring管理的Bean，这样Spring容器会自动扫描并管理这个类的实例</p>
<p>@<strong><u>Slf4j</u></strong><br>使用 <code>@Slf4j</code> 注解生成一个日志记录器（Logger）实例。这个注解来自 Lombok 库，可以简化日志记录器的创建</p>
<pre><code class="java">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;
</code></pre>
<p>使用<code>@Pointcut</code>注解定义一个切入点<code>autoFillPointCut</code></p>
<ul>
<li><code>execution(* com.sky.mapper.*.*(..))</code>：匹配<code>com.sky.mapper</code>包下所有类的所有方法</li>
<li><code>&amp;&amp; @annotation(com.sky.annotation.AutoFill)</code>：并且这些方法必须带有<code>@AutoFill</code>注解</li>
<li>public void autoFillPointCut()：定义一个空的方法，用于标识这个切入点</li>
</ul>
<pre><code class="java">/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);
    &#125;
&#125;
</code></pre>
<p>使用<code>@Before</code>注解定义一个前置通知<code>autoFill</code>，这个通知会在切入点方法执行前被调用</p>
<ul>
<li><code>@Before(&quot;autoFillPointCut()&quot;)</code>：指定这个通知应用于<code>autoFillPointCut</code>切入点</li>
<li><code>public void autoFill(JoinPoint joinPoint)</code>：定义通知方法，接收一个<code>JoinPoint</code>参数，<code>JoinPoint</code>包含了连接点的信息，如被拦截的方法、参数等</li>
</ul>
</blockquote>
<h4 id="代码开发2"><a href="#代码开发2" class="headerlink" title="代码开发2"></a>代码开发2</h4><blockquote>
<p>公共属性赋值后 Service里的 save(Employee employee) → employee.setCreateUser(BaseContext.getCurrentId())就不用再去赋值了</p>
</blockquote>
<h6 id="这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill"><a href="#这个写完后-就可以把Service里的一些employee-setXXX的删除了-因为公共属性只需要加-AutoFill" class="headerlink" title="这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill"></a>这个写完后 就可以把Service里的一些employee.setXXX的删除了 因为公共属性只需要加@AutoFill</h6><pre><code class="java">sky-server  com/sky/annotation/AutoFill.java 不变
sky-server  com/sky/aspect/AutoFillAspect.java
package com.sky.aspect;

import com.sky.annotation.AutoFill;
import com.sky.constant.AutoFillConstant;
import com.sky.context.BaseContext;
import com.sky.enumeration.OperationType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

/**
 * 自定义切面，实现公共字段自动填充处理逻辑
 */
@Aspect
@Component
@Slf4j
public class AutoFillAspect &#123;
    /**
     * 切入点
     */
    // 拦截类 + 注解的东西
    @Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)
    public void autoFillPointCut()&#123;&#125;

    // 前置通知，在通知中进行公共字段的赋值
    @Before(&quot;autoFillPointCut()&quot;)
    public void autoFill(JoinPoint joinPoint) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;
        log.info(&quot;开始公共字段自动填充...&quot;);

        // 获取当前被拦截的方法上的数据库操作类型(Update/Insert)
        MethodSignature signature = (MethodSignature)joinPoint.getSignature(); //方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); //获得方法上的注解对象
        OperationType operationType = autoFill.value();//获得数据库操作类型

        // 获取当当前被拦截的方法的参数--实体对象 (Employee employee)
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) &#123; //没有参数不执行
            return;
        &#125;
        Object entity = args[0]; //获得第一个

        // 准备赋值数据
        LocalDateTime now = LocalDateTime.now();
        Long currentId = BaseContext.getCurrentId();

        // 根据当前不同的操作类型，对对应的属性通过反射来赋值
        if (operationType == OperationType.INSERT) &#123;
            // 为4个公共字段赋值
            Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
            Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);


            //通过反射对对象赋值属性
            setCreateTime.invoke(entity,now);
            setCreateUser.invoke(entity,currentId);
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125; else if (operationType == OperationType.UPDATE) &#123;
            // 为2个公共字段赋值
            Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
            Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);

            //通过反射对对象赋值属性
            setUpdateTime.invoke(entity,now);
            setUpdateUser.invoke(entity,currentId);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h3><h6 id="业务规则：-2"><a href="#业务规则：-2" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>菜品名称必须是唯一的</li>
<li>菜品必须属于某个分类下，不能单独存在</li>
<li>新增菜品时可以根据选择情况菜品的口味</li>
<li>每个菜品必须对应一张图片</li>
</ul>
<h6 id="接口设计：-1"><a href="#接口设计：-1" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>根据类型查询分类(已完成) <code>/admin/category/list    GET</code></p>
<p><u>这里要注意数据返回 因为它里面的口味算一个集合</u></p>
</li>
<li><p>文件上传 <code>/admin/common/upload    POST</code>   </p>
</li>
<li><p>新增菜品 <code>/admin/dish    POST</code></p>
</li>
</ul>
<h6 id="数据库设计："><a href="#数据库设计：" class="headerlink" title="数据库设计："></a>数据库设计：</h6><ul>
<li>dish菜品表 [一个菜品对应着多种口味]</li>
<li>dish_flavour口味表</li>
</ul>
<h6 id="开发文件上传接口："><a href="#开发文件上传接口：" class="headerlink" title="开发文件上传接口："></a>开发文件上传接口：</h6><p>浏览器 → 后端服务 → 阿里云OSS</p>
<pre><code class="java">sky-common  com/sky/utils/AliOssUtil.java
package com.sky.utils;

import com.aliyun.oss.ClientException;
import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.aliyun.oss.OSSException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;


import java.io.ByteArrayInputStream;

@Data
@AllArgsConstructor
@Slf4j
public class AliOssUtil &#123;
// 通过配置类初始化这些数据
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;
    private String bucketName;

    /**
     * 文件上传
     *
     * @param bytes
     * @param objectName
     * @return
     */
    public String upload(byte[] bytes, String objectName) &#123;

 // 创建OSSClient实例。 将字节数组转换为输入流，并将其上传到指定的bucket和objectName
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);

        try &#123;
            // 创建PutObject请求。
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(bytes));
        &#125; catch (OSSException oe) &#123;
            System.out.println(&quot;Caught an OSSException, which means your request made it to OSS, &quot;
                    + &quot;but was rejected with an error response for some reason.&quot;);
            System.out.println(&quot;Error Message:&quot; + oe.getErrorMessage());
            System.out.println(&quot;Error Code:&quot; + oe.getErrorCode());
            System.out.println(&quot;Request ID:&quot; + oe.getRequestId());
            System.out.println(&quot;Host ID:&quot; + oe.getHostId());
        &#125; catch (ClientException ce) &#123;
            System.out.println(&quot;Caught an ClientException, which means the client encountered &quot;
                    + &quot;a serious internal problem while trying to communicate with OSS, &quot;
                    + &quot;such as not being able to access the network.&quot;);
            System.out.println(&quot;Error Message:&quot; + ce.getMessage());
        &#125; finally &#123;
            if (ossClient != null) &#123;
                ossClient.shutdown();
            &#125;
        &#125;

        //文件访问路径规则 https://BucketName.Endpoint/ObjectName
        StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;);
        stringBuilder
                .append(bucketName)
                .append(&quot;.&quot;)
                .append(endpoint)
                .append(&quot;/&quot;)
                .append(objectName);
        log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, stringBuilder);

        return stringBuilder.toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-common  com/sky/constant/AutoFillConstant.java
package com.sky.constant;

/**
 * 公共字段自动填充相关常量
 */
public class AutoFillConstant &#123;
    /**
     * 实体类中的方法名称
     */
    public static final String SET_CREATE_TIME = &quot;setCreateTime&quot;;
    public static final String SET_UPDATE_TIME = &quot;setUpdateTime&quot;;
    public static final String SET_CREATE_USER = &quot;setCreateUser&quot;;
    public static final String SET_UPDATE_USER = &quot;setUpdateUser&quot;;
&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
sky:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    host: localhost
    port: 3306
    database: sky_take_out
    username: root
    password: root
  alioss:
    endpoint: XXXXXXXXX
    access-key-id: XXXXXXXXXXXX
    access-key-secret: XXXXXXXXXXX
    bucketName: XXXXXXXXX
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/CommonController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.utils.AliOssUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.UUID;

/**
 * 通用接口
 */
@RestController
@RequestMapping(&quot;/admin/common&quot;)
@Api(tags = &quot;通用接口&quot;)
@Slf4j
public class CommonController &#123;
    @Autowired
    private AliOssUtil aliOssUtil;
    @PostMapping(&quot;/upload&quot;)
    @ApiOperation(&quot;文件上传&quot;)
    // 如果要测试文件上传 只能用postman或者前后端联调
    public Result&lt;String&gt; upload(MultipartFile file) &#123;
        log.info(&quot;文件上传：&#123;&#125;&quot;, file);
        // 防止重名覆盖
        try &#123;
            // 原始文件名
            String filename = file.getOriginalFilename();
            // 截取原始文件名的后缀
            String extension = filename.substring(filename.lastIndexOf(&quot;.&quot;));
            // 构造新文件名UUID
            String objectName = UUID.randomUUID().toString() + extension;

            // 文件的请求路径
            String filepath = aliOssUtil.upload(file.getBytes(), objectName);
            log.info(&quot;文件上传成功，访问路径：&#123;&#125;&quot;, filepath);
            return Result.success(filepath);
        &#125; catch (IOException e) &#123;
            log.error(&quot;文件上传失败：&#123;&#125;&quot;, e);
        &#125;
        return Result.error(MessageConstant.UPLOAD_FAILED);
    &#125;
&#125;
</code></pre>
<p><span style = "color:orange"><strong>如何让application.yml识别到我在application-dev.yml里设置的值呢？</strong></span></p>
<pre><code class="yaml">server:
  port: 8080

spring:
  profiles:
    active: dev

你已经在 application.yml 中指定了 spring.profiles.active: dev，这样在启动应用程序时，Spring Boot 会自动加载 application-dev.yml 中的配置

如果你使用的是 IDE（如 IntelliJ IDEA 或 Eclipse），你可以在运行配置中指定激活的环境配置文件。例如，在 IntelliJ IDEA 中：
打开 Run -&gt; Edit Configurations。
选择你的应用程序配置。
在 VM options 中添加 -Dspring.profiles.active=dev。

# 在 VM options 中配置的原理：
在 VM options 中添加 -Dspring.profiles.active=dev 的原理是通过 Java 虚拟机（JVM）的系统属性来设置 Spring Boot 应用程序的活动配置文件。以下是详细的解释：
原理
JVM 系统属性：
JVM 提供了一种机制，允许你在启动时通过命令行参数传递系统属性。这些系统属性可以在应用程序中通过 System.getProperty 方法访问。
-D 前缀用于设置系统属性。例如，-Dkey=value 会将 key 设置为 value。
Spring Boot 配置：
Spring Boot 会读取 spring.profiles.active 系统属性来确定当前激活的配置文件。
当你通过 -Dspring.profiles.active=dev 设置系统属性时，Spring Boot 会在启动时读取这个属性，并根据其值加载相应的配置文件（如 application-dev.yml）。
</code></pre>
<h6 id="新增菜品重要代码"><a href="#新增菜品重要代码" class="headerlink" title="新增菜品重要代码"></a>新增菜品重要代码</h6><pre><code class="java">sky-pojo  com/sky/dto/DishDTO.java
package com.sky.dto;

import com.sky.entity.DishFlavor;
import lombok.Data;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDTO implements Serializable &#123;
    //dish属性封装成dto

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //口味[因为有多种口味要区分]
    private List&lt;DishFlavor&gt; flavors = new ArrayList&lt;&gt;();

&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/entity/DishFlavor.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 菜品口味
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DishFlavor implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;
    //菜品id
    private Long dishId;

    //口味名称
    private String name;

    //口味数据list
    private String value;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
package com.sky.controller.admin;

import com.sky.dto.DishDTO;
import com.sky.result.Result;
import com.sky.service.DishService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);
&#125;
</code></pre>
<pre><code class="java">com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.sky.dto.DishDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.service.DishService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
package com.sky.mapper;

import com.sky.annotation.AutoFill;
import com.sky.entity.Dish;
import com.sky.enumeration.OperationType;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface DishMapper &#123;

    /**
     * 根据分类id查询菜品数量
     * @param categoryId
     * @return
     */
    @Select(&quot;select count(id) from dish where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long categoryId);

    /**
     * 插入菜品数据
     */
    @AutoFill(value = OperationType.INSERT)
    void insert(Dish dish);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
package com.sky.mapper;

import com.sky.entity.DishFlavor;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface DishFlavorMapper &#123;
    /**
     * 批量插入口味数据
     */
    void insertBatch(List&lt;DishFlavor&gt; flavors);
&#125;
</code></pre>
<pre><code class="java">sky-server  mapper/DishFlavorMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishFlavorMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish_flavor (dish_id, name, value) values
        &lt;foreach collection=&quot;flavors&quot; item=&quot;df&quot; separator=&quot;,&quot;&gt;
            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="菜品分页查询"><a href="#菜品分页查询" class="headerlink" title="菜品分页查询"></a>菜品分页查询</h3><blockquote>
<p>菜品名称[         ]     菜品分类[         ]     售卖状态[         ]         [搜索]<br>菜品名称、图片、菜品分类、售价、售卖状态、最后操作事件、操作[修改 删除 启售,停售]<br>                                                                                                                            右下角 分页操作</p>
</blockquote>
<h6 id="业务规则：-3"><a href="#业务规则：-3" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>根据页码展示菜品信息</li>
<li>每页展示10条数据</li>
<li>分页查询时可以根据需要输入<strong>菜品名称、菜品分类、菜品状态</strong>进行查询</li>
</ul>
<h6 id="接口设计：-2"><a href="#接口设计：-2" class="headerlink" title="接口设计："></a>接口设计：</h6><p><strong>Path</strong>：&#x2F;admin&#x2F;dish&#x2F;page<br><strong>Method</strong>：GET</p>
<h6 id="代码开发："><a href="#代码开发：" class="headerlink" title="代码开发："></a>代码开发：</h6><p>根据菜品分页查询接口定义设计对应的<strong>DTO</strong><br>根据菜品分页查询接口定义设计对应的<strong>VO</strong>[转成Json数据给前端]</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
@GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;菜品分页查询&quot;)
    public Result&lt;PageResult&gt; page(DishPageQueryDTO dishPageQueryDTO)&#123;
        log.info(&quot;菜品分页查询：&#123;&#125;&quot;, dishPageQueryDTO);
        PageResult pageResult = dishService.pageQuery(dishPageQueryDTO);
        return Result.success(pageResult);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.result.PageResult;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
@Service
@Slf4j
public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
 @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
  // 1. 开启分页功能，设置当前页和每页显示的数量
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
 // 2. 调用 dishMapper 的 pageQuery 方法进行分页查询，返回一个 Page&lt;DishVO&gt; 对象
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
     // 3. 创建并返回 PageResult 对象，包含总记录数和查询结果列表
        return new PageResult(page.getTotal(), page.getResult());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    Page&lt;DishVO&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO);
</code></pre>
<pre><code class="mysql">sky-server  mapper/DishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.DishMapper&quot;&gt;
    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,
                          update_user, status)
        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;,
                #&#123;updateUser&#125;, #&#123;status&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><span style="color:orange"><strong>分页查询SQL语句分析</strong></span></p>
<blockquote>
<pre><code class="mysql">&lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.DishVO&quot;&gt;
        select d.*, c.name as categoryName
        from dish d
            left join category c
                on d.category_id=c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                and d.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and d.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and d.status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by d.update_time desc
    &lt;/select&gt;
</code></pre>
<p>从 dish 表中选择所有列，并从 category 表中选择 name 列，别名为 categoryName。<br>使用左连接 (left join) 将 dish 表和 category 表连接起来，连接条件是 d.category_id &#x3D; c.id。</p>
<p>动态生成WHERE子句，&lt; where &gt;标签会自动处理AND和OR关键字的添加，并且会忽略第一个条件前的ADN和OR</p>
</blockquote>
<h3 id="删除菜品"><a href="#删除菜品" class="headerlink" title="删除菜品"></a>删除菜品</h3><blockquote>
<p>单个删除、批量删除、先停售后删除</p>
</blockquote>
<h6 id="业务规则：-4"><a href="#业务规则：-4" class="headerlink" title="业务规则："></a>业务规则：</h6><ul>
<li>可以一次删除一个菜品，也可以批量删除菜品</li>
</ul>
<blockquote>
<p><strong>Path</strong>: &#x2F;admin&#x2F;dish<br><strong>Method</strong>: DELETE<br><strong>数据库设计</strong>：<br>dish表 → id 【菜品】<br>dish_flavor表 → dish_id 【口味】<br>setmeal_dish表 → dish_id</p>
</blockquote>
<ul>
<li>起售中的菜品不能删除</li>
<li>被套餐关联的菜品不能删除</li>
<li>删除菜品后，关联的口味数据也需要删除</li>
</ul>
<h6 id="代码开发：-1"><a href="#代码开发：-1" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Override
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishId(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据主键删除菜品数据
     */

    @Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id删除对应的 口味数据
     * @param id
     */
    @Delete(&quot;delete from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    void deleteByDishId(Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealDishMapper.java
package com.sky.mapper;

import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishId(List&lt;Long&gt; dishIds);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealDishMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealDishMapper&quot;&gt;

    &lt;select id=&quot;getSetmealIdsByDishId&quot; resultType=&quot;java.lang.Long&quot;&gt;
        SELECT setmeal_id
        FROM setmeal_dish
        WHERE dish_id IN
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
           #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
&lt;/mapper&gt;

&lt;!--
★ foreach 标签用于遍历集合，并生成相应的 SQL 语句。
★ collection=&quot;dishIds&quot;：指定要遍历的集合名称，即传入的参数 dishIds。
★ item=&quot;dishId&quot;：指定集合中的每个元素的别名，即每次迭代时的变量名。
★ separator=&quot;,&quot;：指定每个元素之间的分隔符，这里是逗号 ,。
★ open=&quot;(&quot; 和 close=&quot;)&quot;：指定生成的 SQL 语句的开始和结束符号，这里是括号 ( 和 )。
--&gt;
</code></pre>
<p><span style="color:orange">@<strong>RequestParm详细分析</strong></span></p>
<blockquote>
<p><code>public Result delete(@RequestParam List&lt;Long&gt; ids)</code></p>
<p><code>@RequestParam</code>：注解用于将请求参数绑定到方法参数上。具体来说，它可以从请求的查询参数中提取出指定的参数值，并将其转换为方法参数的类型；在这个例子中，@RequestParam List<Long> ids 表示从请求的查询参数中提取 ids 参数，并将其转换为 List<Long> 类型。</p>
</blockquote>
<h3 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h3><h6 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h6><p><strong>接口设计：</strong></p>
<ul>
<li>根据id查询菜品</li>
</ul>
<blockquote>
<p>口味也要回显<br><strong>Path:</strong>  &#x2F;admin&#x2F;dish&#x2F;{id}<br><strong>Method：</strong>GET</p>
</blockquote>
<ul>
<li>根据类型查询分类(已实现)</li>
<li>文件上传(已实现)</li>
<li>修改菜品</li>
</ul>
<blockquote>
<p>根据ID修改<br><strong>Path：</strong>&#x2F;admin&#x2F;dish<br><strong>Method：</strong>PUT</p>
</blockquote>
<h6 id="代码开发：-2"><a href="#代码开发：-2" class="headerlink" title="代码开发："></a>代码开发：</h6><p><strong>根据id查询菜品进行信息回显</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询菜品&quot;)
//  @PathVariable 注解用于从 URL 路径中的占位符参数中提取值，并将其绑定到方法参数上
    public Result&lt;DishVO&gt; getById(@PathVariable long id) &#123;
        log.info(&quot;根据id查询菜品：&#123;&#125;&quot;, id);
        DishVO dishVO = dishService.getByIdWithFlavor(id);
        return Result.success(dishVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishFlavorMapper.java
/**
     * 根据菜品id查询对应的口味数据
     * @param id
     * @return
     */
    @Select(&quot;select * from dish_flavor where dish_id = #&#123;id&#125;&quot;)
    List&lt;DishFlavor&gt; getByDishId(long id);
</code></pre>
<p><strong>修改菜品接口</strong></p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 根据id修改菜品和对应的口味数据
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;
/*
这段代码中，将 dishDTO 的属性复制到 dish 对象的主要原因有以下几点：
数据模型分离：
dishDTO 通常用于数据传输，包含前端传来的所有数据。
dish 是数据库实体类，只包含数据库表中的字段。
安全性：
使用 BeanUtils.copyProperties 可以避免将不必要的字段（如前端传来的额外属性）写入数据库。
确保只有预期的字段被更新。
数据校验：
dishDTO 可以包含更多的验证逻辑或额外的属性，而 dish 对象则严格遵循数据库模型。
通过这种方式，可以在更新前对数据进行进一步校验。
事务管理：
添加 @Transactional 注解确保整个更新过程在一个事务中完成。
如果任何一步出错，整个事务都会回滚，保证数据一致性。
*/
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
 /**
     * 根据id修改菜品和对应的口味数据
     * @param dish
     */
    //有时间和修改人 不要忘记自动填充
    @AutoFill(value = OperationType.UPDATE)
    void update(Dish dish);
</code></pre>
<pre><code class="xml">sky-server  mapper/DishMapper.xml
&lt;update id=&quot;update&quot;&gt;
        update dish
        &lt;set&gt;
            &lt;if
                test=&quot;name != null and name != &#39;&#39;&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
</code></pre>
<h5 id="菜品起售停售"><a href="#菜品起售停售" class="headerlink" title="菜品起售停售"></a>菜品起售停售</h5><pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
/**
     * 菜品起售停售
     * @param status
     * @param id
     */
@Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java

    /**
     * 根据套餐id查询菜品
     * @param setmealId
     * @return
     */
    @Select(&quot;select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;Dish&gt; getBySetmealId(Long setmealId);
/*
在 SQL 查询中添加筛选条件。
确保返回的结果集中，setmeal_dish 表中的 setmeal_id 字段值与传入的 setmealId 参数值相匹配，从而获取与指定套餐 ID 相关的菜品列表。
*/
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">@Mapper
public interface SetmealDishMapper &#123;
    /**
     * 根据菜品id查询对应的套餐id
     * @param dishIds
     * @return
     */
    // select setmeal_id from setmeal_dish where dish_id in (1,2,3)
    // 在mapper.xml中dishIds是形参  &lt;foreach collection=&quot;dishIds&quot;&gt;
    List&lt;Long&gt; getSetmealIdsByDishIds(List&lt;Long&gt; dishIds);
</code></pre>
<pre><code class="xml">SetmealDishMapper.xml
&lt;select id=&quot;getSetmealIdsByDishIds&quot; resultType=&quot;java.lang.Long&quot;&gt;
        select setmeal_id from setmeal_dish where dish_id in
        &lt;foreach collection=&quot;dishIds&quot; item=&quot;dishId&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
            #&#123;dishId&#125;
        &lt;/foreach&gt;
    &lt;/select&gt;
</code></pre>
<h4 id="修改套餐那些事"><a href="#修改套餐那些事" class="headerlink" title="修改套餐那些事"></a>修改套餐<del>那些事</del></h4><pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java
package com.sky.controller.admin;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.result.PageResult;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.SetmealVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/page&quot;)
    @ApiOperation(&quot;分页查询&quot;)
    public Result&lt;PageResult&gt; page(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        PageResult pageResult = setmealService.pageQuery(setmealPageQueryDTO);
        return Result.success(pageResult);
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;

    /**
     * 根据id查询套餐，用于修改页面回显数据
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询套餐&quot;)
    public Result&lt;SetmealVO&gt; getById(@PathVariable Long id) &#123;
        SetmealVO setmealVO = setmealService.getByIdWithDish(id);
        return Result.success(setmealVO);
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;
/**
ids.forEach(id -&gt; &#123; ... &#125;)：对ids集合中的每个元素id执行大括号内的操作。
id -&gt; &#123; ... &#125;：定义了一个接受单个参数id的函数，并执行大括号内的逻辑。
在大括号内，根据id查询数据库获取套餐信息，并检查其状态，若状态符合启用条件，则抛出异常。
**/
    
    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.annotation.AutoFill;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.enumeration.OperationType;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;
import java.util.Map;

@Mapper
public interface SetmealMapper &#123;

    /**
     * 根据分类id查询套餐的数量
     *
     * @param id
     * @return
     */
    @Select(&quot;select count(id) from setmeal where category_id = #&#123;categoryId&#125;&quot;)
    Integer countByCategoryId(Long id);

    /**
     * 根据id修改套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.UPDATE)
    void update(Setmeal setmeal);

    /**
     * 新增套餐
     *
     * @param setmeal
     */
    @AutoFill(OperationType.INSERT)
    void insert(Setmeal setmeal);

    /**
     * 分页查询
     * @param setmealPageQueryDTO
     * @return
     */
    Page&lt;SetmealVO&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 根据id查询套餐
     * @param id
     * @return
     */
    @Select(&quot;select * from setmeal where id = #&#123;id&#125;&quot;)
    Setmeal getById(Long id);

    /**
     * 根据id删除套餐
     * @param setmealId
     */
    @Delete(&quot;delete from setmeal where id = #&#123;id&#125;&quot;)
    void deleteById(Long setmealId);

    /**
     * 根据id查询套餐和套餐菜品关系
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 动态条件查询套餐
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据套餐id查询菜品选项
     * @param setmealId
     * @return
     */
    @Select(&quot;select sd.name, sd.copies, d.image, d.description &quot; +
            &quot;from setmeal_dish sd left join dish d on sd.dish_id = d.id &quot; +
            &quot;where sd.setmeal_id = #&#123;setmealId&#125;&quot;)
    List&lt;DishItemVO&gt; getDishItemBySetmealId(Long setmealId);

    /**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/SetmealMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.SetmealMapper&quot;&gt;
    &lt;resultMap id=&quot;setmealAndDishMap&quot; type=&quot;com.sky.vo.SetmealVO&quot; autoMapping=&quot;true&quot;&gt;
        &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;collection property=&quot;setmealDishes&quot; ofType=&quot;SetmealDish&quot;&gt;
            &lt;result column=&quot;sd_id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;setmeal_id&quot; property=&quot;setmealId&quot;/&gt;
            &lt;result column=&quot;dish_id&quot; property=&quot;dishId&quot;/&gt;
            &lt;result column=&quot;sd_name&quot; property=&quot;name&quot;/&gt;
            &lt;result column=&quot;sd_price&quot; property=&quot;price&quot;/&gt;
            &lt;result column=&quot;copies&quot; property=&quot;copies&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;Setmeal&quot;&gt;
        update setmeal
        &lt;set&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                name = #&#123;name&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                category_id = #&#123;categoryId&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;price != null&quot;&gt;
                price = #&#123;price&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;description != null&quot;&gt;
                description = #&#123;description&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;image != null&quot;&gt;
                image = #&#123;image&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateTime != null&quot;&gt;
                update_time = #&#123;updateTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;updateUser != null&quot;&gt;
                update_user = #&#123;updateUser&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

&lt;!--
    &lt;insert&gt;：表示这是一个插入操作。
    id=&quot;insert&quot;：指定这个 SQL 语句的唯一标识符，通常用于在 MyBatis 映射文件中引用此 SQL 语句。
    parameterType=&quot;Setmeal&quot;：指定插入操作的参数类型为 Setmeal 类型。
    useGeneratedKeys=&quot;true&quot;：指示 MyBatis 在执行插入操作后自动获取自动生成的主键。
    keyProperty=&quot;id&quot;：指定将自动生成的主键值设置到对象的 id 属性上。
--&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;Setmeal&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into setmeal
        (category_id, name, price, status, description, image, create_time, update_time, create_user, update_user)
        values (#&#123;categoryId&#125;, #&#123;name&#125;, #&#123;price&#125;, #&#123;status&#125;, #&#123;description&#125;, #&#123;image&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;,
                #&#123;createUser&#125;, #&#123;updateUser&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;com.sky.vo.SetmealVO&quot;&gt;
        select
        s.*,c.name categoryName
        from
        setmeal s
        left join
        category c
        on
        s.category_id = c.id
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and s.name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and s.status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and s.category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by s.create_time desc
    &lt;/select&gt;

    &lt;select id=&quot;getByIdWithDish&quot; parameterType=&quot;long&quot; resultMap=&quot;setmealAndDishMap&quot;&gt;
        select a.*,
               b.id    sd_id,
               b.setmeal_id,
               b.dish_id,
               b.name  sd_name,
               b.price sd_price,
               b.copies
        from setmeal a
                 left join
             setmeal_dish b
             on
                 a.id = b.setmeal_id
        where a.id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;list&quot; parameterType=&quot;Setmeal&quot; resultType=&quot;Setmeal&quot;&gt;
        select * from setmeal
        &lt;where&gt;
            &lt;if test=&quot;name != null&quot;&gt;
                and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;

    &lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="Redis入门-调整营业状态"><a href="#Redis入门-调整营业状态" class="headerlink" title="Redis入门 [调整营业状态]"></a>Redis入门 [调整营业状态]</h3><p>Redis是一个基于<strong>内存</strong>的 key-value 结构数据库</p>
<ul>
<li>基于内存存储，读写性能高</li>
<li>适合存储热点数据 (热点商品、资讯、新闻) 访问量较大</li>
<li>企业应用广泛</li>
</ul>
<h3 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h3><h5 id="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："><a href="#Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：" class="headerlink" title="Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型："></a>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</h5><ul>
<li>字符串 string：普通字符串</li>
<li>哈希 hash：散列，类似于java中的HashMap结构</li>
<li>列表 list：按照插入顺序排序，可以有重复元素，类似于java中的LinkedList</li>
<li>集合 set：无序集合，没有重复元素，类似于java中的HashSet</li>
<li>有序集合 sorted set &#x2F; zset：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li>
</ul>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><ul>
<li><p><strong>字符串操作命令</strong></p>
<blockquote>
<p>ValueOperations valueOperations &#x3D; redisTemplate.opsForValue();</p>
</blockquote>
<ul>
<li>SET key value                      设置指定key的值</li>
<li>GET key                                获取指定key的值</li>
<li>SETEX key seconds value  设置指定key的值，并将key的过期时间设为 seconds秒</li>
<li>SETNX key value                 只有在key不存在时设置key的值</li>
</ul>
</li>
<li><p><strong>哈希操作命令</strong> [<strong>key → value(field1 value1,  field2 value2)</strong>]</p>
<blockquote>
<p>HashOperations hashOperations &#x3D; redisTemplate.opsForHash();</p>
</blockquote>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<ul>
<li>HSET key field value   将哈希表key中的字段field的值设为value</li>
<li>HGET key field             获取存储在哈希表中指定字段的值</li>
<li>HDEL key field             删除存储在哈希表中的指定字段</li>
<li>HKEYS key                    获取哈希表中所有字段</li>
<li>HVALS key                    获取哈希表中所有值</li>
</ul>
</li>
<li><p><strong>列表操作命令</strong></p>
<blockquote>
<p>ListOperations listOperations &#x3D; redisTemplate.opsForList();</p>
</blockquote>
<ul>
<li>LPUSH key value1 [value2]      将一个或多个值插入到列表头部</li>
<li>LRANGE key start stop             获取列表指定范围内的元素</li>
<li>RPOP key                                    移除并获取列表最后一个元素</li>
<li>LLEN key                                     获取列表长度</li>
</ul>
</li>
<li><p><strong>集合操作命令</strong></p>
<blockquote>
<p>SetOperations setOperations &#x3D; redisTemplate.opsForSet();</p>
</blockquote>
<p>Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据</p>
<ul>
<li>SADD key member1 [member2]           向集合添加一个或多个成员 [无序插入]</li>
<li>SMEMBERS key                                         返回集合中的所有成员</li>
<li>SCARD key                                                  获取集合的成员数</li>
<li>SINTER key1 [key2]                                   返回给定所有集合的交集</li>
<li>SUNION key1 [key2]                                 返回所有给定集合的并集</li>
<li>SREM key member1 [member2]            删除集合中一个或多个成员</li>
</ul>
</li>
<li><p><strong>有序列表操作命令</strong></p>
<blockquote>
<p>ZSetOperations zSetOperations &#x3D; redisTemplate.opsForZSet();</p>
</blockquote>
<p>Redis有序集合是string类型元素的集合，且不允许重复成员。每个元素都会关联一个double类型的分数</p>
<ul>
<li>ZADD key score1 member1 [score2 member2]  向有序集合添加一个或多个成员</li>
<li>ZRANGE key start stop [WITHSCORES]                 通过索引区间返回有序集合中指定区间内的成员</li>
<li>ZINCRBY key increment member                          有序集合中对指定成员的分数加上增量increment</li>
<li>ZREM key member [member …]                            移除有序集合中的一个或多个成员</li>
</ul>
</li>
<li><p><strong>通用命令</strong></p>
<p>Redis的通用命令是不分数据类型的，都可以使用的命令</p>
<ul>
<li>KEYS pattern            查找所有符合给定模式(pattern)的key</li>
<li>EXISTS key                检查给定key是否存在</li>
<li>TYPE key                   返回key所存储的值的类型</li>
<li>DEL key                     该命令用于在key存在是删除key</li>
</ul>
</li>
</ul>
<h3 id="在java中操作Redis-SpringDataRedis"><a href="#在java中操作Redis-SpringDataRedis" class="headerlink" title="在java中操作Redis_SpringDataRedis"></a>在java中操作Redis_SpringDataRedis</h3><p><span style = "color:red">序列化器：<strong>redisTemplate.setKeySerializer(new StringRedisSerializer());</strong></span></p>
<h6 id="Redis的Java客户端很多"><a href="#Redis的Java客户端很多" class="headerlink" title="Redis的Java客户端很多"></a>Redis的Java客户端很多</h6><ul>
<li>Jedis</li>
<li>Lettuce</li>
<li>Spring Data Redis</li>
</ul>
<p>Spring Data Redis 是 Spring 的一部分，对Redis底层开发包进行了高度封装<br>在Spring项目中，可以使用Spring Data Redis来简化操作</p>
<h5 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h5><ul>
<li><p>导入Spring Data Redis的maven坐标</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置Redis数据源</p>
<pre><code class="yaml">spring:
 redis:
  host: localhost
  port: 6379
  password:
</code></pre>
</li>
<li><p>编写配置类，创建RedisTemplate对象</p>
<pre><code class="java">package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
</li>
<li><p>通过RedisTemplate对象操作Redis</p>
</li>
</ul>
<h6 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h6><pre><code class="yaml">application.yml
  redis:
    host: $&#123;sky.redis.host&#125;
    port: $&#123;sky.redis.port&#125;
    database: $&#123;sky.redis.database&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  redis:
    host: localhost
    port: 6379
    database: 1
</code></pre>
<pre><code class="java">sky-server  com/sky/config/RedisConfiguration.java
package com.sky.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@Slf4j
public class RedisConfiguration &#123;
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
        log.info(&quot;开始创建redis模板对象...&quot;);
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器 在图形化界面不出现乱码
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server【测试类】 com/sky/test/SpringDataRedisTest.java
package com.sky.test;

import com.mysql.cj.util.TimeUtil;
import net.sf.jsqlparser.statement.select.KSQLWindow;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.*;

import java.util.concurrent.TimeUnit;

@SpringBootTest //测试完记得注释 不然每次启动类就会运行这个测试类
public class SpringDataRedisTest &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void testRedisTemplate()&#123;
        System.out.println(redisTemplate);
        //创建根据字符串、哈希、列表、集合、有序列表、通用命令的代码
        ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        SetOperations setOperations = redisTemplate.opsForSet();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
    &#125;

    /**
     * 操作字符串类型的数据
     */
    @Test
    public void testString()&#123;
        // set get setex setnx
        redisTemplate.opsForValue().set(&quot;city&quot;,&quot;北京&quot;);
        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);
        System.out.println(city); // 北京

        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);
        // 第一次调用可以设置成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);
        // 第二次不可以成功
        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);
        Object lock = redisTemplate.opsForValue().get(&quot;lock&quot;);
        System.out.println(lock); // 1

        Object lock2 = redisTemplate.opsForValue().get(&quot;locwwk&quot;);
        System.out.println(lock2);// null
    &#125;
    
    /**
     * 操作哈希类型的数据
     */
    @Test
    public void testHash()&#123;
        //hset hget hdel hkeys havls
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.put(&quot;100&quot;,&quot;name&quot;,&quot;tom&quot;);
        hashOperations.put(&quot;100&quot;,&quot;age&quot;,&quot;20&quot;);

        String name = (String) hashOperations.get(&quot;100&quot;,&quot;name&quot;);
        System.out.println(name);

        Set keys = hashOperations.keys(&quot;100&quot;);
        System.out.println(keys);

        List values = hashOperations.values(&quot;100&quot;);
        System.out.println(values);

        hashOperations.delete(&quot;100&quot;,&quot;age&quot;);
/**
     * 操作列表类型的数据
     */
    @Test
    public void testList()&#123;
        //lpush lrange rpop llen
        ListOperations listOperations = redisTemplate.opsForList();

        listOperations.leftPushAll(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
        listOperations.leftPush(&quot;mylist&quot;,&quot;d&quot;);

        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);
        System.out.println(mylist);

        listOperations.rightPop(&quot;mylist&quot;);

        Long size = listOperations.size(&quot;mylist&quot;);
        System.out.println(size);
    &#125;

    /**
     * 操作集合类型的数据
     */
    @Test
    public void testSet()&#123;
        //sadd smembers scard sinter sunion srem
        SetOperations setOperations = redisTemplate.opsForSet();

        setOperations.add(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);
        setOperations.add(&quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);

        Set members = setOperations.members(&quot;set1&quot;);
        System.out.println(members);

        Long size = setOperations.size(&quot;set1&quot;);
        System.out.println(size);

        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(intersect);

        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);
        System.out.println(union);

        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 操作有序集合类型的数据
     */
    @Test
    public void testZset()&#123;
        //zadd zrange zincrby zrem
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();

        zSetOperations.add(&quot;zset1&quot;,&quot;a&quot;,10);
        zSetOperations.add(&quot;zset1&quot;,&quot;b&quot;,12);
        zSetOperations.add(&quot;zset1&quot;,&quot;c&quot;,9);

        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);
        System.out.println(zset1);

        zSetOperations.incrementScore(&quot;zset1&quot;,&quot;c&quot;,10);

        zSetOperations.remove(&quot;zset1&quot;,&quot;a&quot;,&quot;b&quot;);
    &#125;

    /**
     * 通用命令操作
     */
    @Test
    public void testCommon()&#123;
        //keys exists type del
        Set keys = redisTemplate.keys(&quot;*&quot;);
        System.out.println(keys);

        Boolean name = redisTemplate.hasKey(&quot;name&quot;);
        Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;);

        for (Object key : keys) &#123;
            DataType type = redisTemplate.type(key);
            System.out.println(type.name());
        &#125;

        redisTemplate.delete(&quot;mylist&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="店铺营业状态设置-【存入Redis】"><a href="#店铺营业状态设置-【存入Redis】" class="headerlink" title="店铺营业状态设置 【存入Redis】"></a>店铺营业状态设置 【存入Redis】</h3><h6 id="接口设计：-3"><a href="#接口设计：-3" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>设置营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;admin&#x2F;shop&#x2F;{status}<br><strong>Method</strong>：PUT<br>status   1    店铺营业状态：1为营业，0为打样</p>
</blockquote>
</li>
<li><p>管理端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>admin</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
<li><p>用户端查询营业状态</p>
<blockquote>
<p><strong>Path</strong>：&#x2F;<strong>user</strong>&#x2F;shop&#x2F;status<br><strong>Method</strong>：GET</p>
</blockquote>
</li>
</ul>
<p>★ ★ <strong>本项目约定</strong> ★ ★</p>
<ul>
<li><strong>管理端</strong>发出的请求，统一使用**&#x2F;admin**作为前缀</li>
<li><strong>用户端</strong>发出的请求，统一使用**&#x2F;user**作为前缀</li>
</ul>
<p>营业状态数据存储方式：基于Redis的字符串来进行存储<br>key: SHOP_STATUS     value: 1                1为营业，0为打样</p>
<h6 id="代码开发：-3"><a href="#代码开发：-3" class="headerlink" title="代码开发："></a>代码开发：</h6><pre><code class="java">sky-server  com/sky/controller/admin/ShopController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;

@RestController(&quot;adminShopController&quot;)
@RequestMapping(&quot;/admin/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;
    /**
     * 设置店铺营业状态
     * @param status
     * @return
     */
    @PutMapping(&quot;/&#123;status&#125;&quot;) //动态取到status
    @ApiOperation(&quot;设置店铺营业状态&quot;)
    public Result setStatus(@PathVariable Integer status) &#123;
        log.info(&quot;设置店铺的营业状态为：&#123;&#125;&quot;, status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    &#125;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShopController.java
package com.sky.controller.user;

import com.sky.result.Result;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.*;
//@RestController(&quot;userShopController&quot;) 指定了这个控制器的名称为 userShopController
//这有助于在应用中唯一标识这个控制器，便于管理和调用
@RestController(&quot;userShopController&quot;)
@RequestMapping(&quot;/user/shop&quot;)
@Api(tags = &quot;店铺相关接口&quot;)
@Slf4j
public class ShopController &#123;
    public static final String KEY = &quot;SHOP_STATUS&quot;;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping(&quot;/status&quot;)
    @ApiOperation(&quot;获取店铺的营业状态&quot;)
    public Result&lt;Integer&gt; getStatus()&#123;
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info(&quot;获取到的店铺营业状态为：&#123;&#125;&quot;,status == 1 ? &quot;营业中&quot; : &quot;打样中&quot;);
        return Result.success(status);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java
// 设置两个接口文档方便在前端文档处调试【管理端+用户端】
package com.sky.config;

import com.sky.interceptor.JwtTokenAdminInterceptor;
import com.sky.interceptor.JwtTokenUserInterceptor;
import com.sky.json.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

import java.util.List;

/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;

    @Bean
    public Docket docket1()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;管理端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.admin&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    @Bean
    public Docket docket2()&#123;
        log.info(&quot;准备生成接口文档...&quot;);
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;苍穹外卖项目接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;苍穹外卖项目接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;用户端接口&quot;)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.sky.controller.user&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射，主要是访问接口文档（html、js、css）
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;

    /**
     * 扩展Spring MVC框架的消息转化器
     * @param converters
     */
    protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        log.info(&quot;扩展消息转换器...&quot;);
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将自己的消息转化器加入容器中
        converters.add(0,converter);
    &#125;
&#125;
</code></pre>
<p><span style="color:orange"><strong>回顾拦截器原理</strong></span></p>
<h3 id="HttpClient-amp-微信小程序开发"><a href="#HttpClient-amp-微信小程序开发" class="headerlink" title="HttpClient &amp; 微信小程序开发"></a>HttpClient &amp; 微信小程序开发</h3><h5 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h5><p>HttpClient 是 Apache Jakarta Common下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.5.13&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>核心API：</p>
<ul>
<li>HttpClient</li>
<li><strong>HttpClients</strong></li>
<li>CloseableHttpClient</li>
<li>HttpGet</li>
<li>HttpPost</li>
</ul>
<p>发送请求步骤：</p>
<ul>
<li>创建HttpClient对象</li>
<li>创建Http请求对象</li>
<li>调用HttpClient的execute方法发送请求</li>
</ul>
<h5 id="发送GET方式请求-要先把项目跑起来"><a href="#发送GET方式请求-要先把项目跑起来" class="headerlink" title="发送GET方式请求 [要先把项目跑起来]"></a>发送GET方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server  com/sky/test/HttpClientTest.java
package com.sky.test;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.IOException;

@SpringBootTest
public class HttpClientTest &#123;
    /**
     * 测试通过httpclient发送GET方式的请求
     */

    @Test
    public void testGET() throws IOException &#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象接口 (GET请求方式+请求地址)
        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);

        // 发送请求，接受响应结果
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 获取服务端返回的状态码
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;服务端返回的状态码为：&quot; + statusCode);


        HttpEntity entity = response.getEntity();// 获得请求体
        String body = EntityUtils.toString(entity);
        System.out.println(&quot;服务端返回的数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;

    /**
     * 测试通过httpclient发送POST方式的请求
     */
&#125;
--------------------------------------------------------------------------------
服务端返回的状态码为：200
服务端返回的数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:0&#125;
</code></pre>
<h5 id="发送POST方式请求-要先把项目跑起来"><a href="#发送POST方式请求-要先把项目跑起来" class="headerlink" title="发送POST方式请求 [要先把项目跑起来]"></a>发送POST方式请求 [要先把项目跑起来]</h5><pre><code class="java">sky-server   com/sky/test/HttpClientTest.java
/**
     * 测试通过httpclient发送POST方式的请求
     */
    @Test
    public void testPOST() throws Exception&#123;
        // 创建httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        // 创建请求对象
        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);
        // 以json方式请求提交参数
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);
        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);

        StringEntity entity = new StringEntity(jsonObject.toString());
        // 指定请求编码方式
        entity.setContentEncoding(&quot;utf-8&quot;);
        // 数据格式
        entity.setContentType(&quot;application/json&quot;);
        httpPost.setEntity(entity);

        // 发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);

        // 解析返回结果
        int statusCode = response.getStatusLine().getStatusCode();
        System.out.println(&quot;响应码为：&quot; + statusCode);

        HttpEntity entity1 = response.getEntity();
        String body = EntityUtils.toString(entity1);
        System.out.println(&quot;响应数据为：&quot; + body);

        // 关闭资源
        response.close();
        httpClient.close();
    &#125;
--------------------------------------------------------------------------------
响应码为：200
响应数据为：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:&#123;&quot;id&quot;:1,&quot;userName&quot;:&quot;admin&quot;,&quot;name&quot;:&quot;管理员&quot;,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI4MTMyMzczfQ.8M2nIkgtHx8wpORNfhKEWjbprBV6OwC82wgYjAMxe2I&quot;&#125;&#125;
</code></pre>
<h6 id="封装后的HttpClientUtil"><a href="#封装后的HttpClientUtil" class="headerlink" title="封装后的HttpClientUtil"></a>封装后的HttpClientUtil</h6><pre><code class="java">package com.sky.utils;

import com.alibaba.fastjson.JSONObject;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Http工具类
 */
public class HttpClientUtil &#123;

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map&lt;String,String&gt; paramMap)&#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = &quot;&quot;;
        CloseableHttpResponse response = null;

        try&#123;
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null)&#123;
                for (String key : paramMap.keySet()) &#123;
                    builder.addParameter(key,paramMap.get(key));
                &#125;
            &#125;
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200)&#123;
                result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;finally &#123;
            try &#123;
                response.close();
                httpClient.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return result;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) &#123;
                List&lt;NameValuePair&gt; paramList = new ArrayList();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                &#125;
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map&lt;String, String&gt; paramMap) throws IOException &#123;
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = &quot;&quot;;

        try &#123;
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) &#123;
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry&lt;String, String&gt; param : paramMap.entrySet()) &#123;
                    jsonObject.put(param.getKey(),param.getValue());
                &#125;
                StringEntity entity = new StringEntity(jsonObject.toString(),&quot;utf-8&quot;);
                //设置请求编码
                entity.setContentEncoding(&quot;utf-8&quot;);
                //设置数据类型
                entity.setContentType(&quot;application/json&quot;);
                httpPost.setEntity(entity);
            &#125;

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);
        &#125; catch (Exception e) &#123;
            throw e;
        &#125; finally &#123;
            try &#123;
                response.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        return resultString;
    &#125;
    private static RequestConfig builderRequestConfig() &#123;
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    &#125;
&#125;
</code></pre>
<h3 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/wxamp/home/guide?lang=zh_CN&token=244469372">小程序 (qq.com)</a></p>
<blockquote>
<p>详情 → 本地设置 → [取消勾选]不校验合法域名…</p>
</blockquote>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ul>
<li><p>了解小程序目录结构</p>
<p>小程序包含一个<strong>描述整体程序</strong>的<u>app</u>和多个和<strong>描述各自页面</strong>的<u>page</u>，一个小程序主体部分由三个文件组村，必须放在项目的根目录</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>app.js</td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td>app.wxss</td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody></table>
<h6 id="一个小程序页面由四个文件组成-pages-→-index-→-…"><a href="#一个小程序页面由四个文件组成-pages-→-index-→-…" class="headerlink" title="一个小程序页面由四个文件组成 [pages → index → …]"></a>一个小程序页面由四个文件组成 [pages → index → …]</h6><table>
<thead>
<tr>
<th>文件类型</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>wxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody></table>
</li>
<li><p>编写测试小程序代码</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_23385943/article/details/142336381?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-142336381-blog-119914069.235%5Ev43%5Epc_blog_bottom_relevance_base6&spm=1001.2101.3001.4242.1&utm_relevant_index=3">微信getUserProfile不弹出授权框_wx.getuserprofile没有弹窗-CSDN博客</a></p>
<pre><code class="json">app.json 【外面一层】
&#123;
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/logs&quot;
  ],
  &quot;window&quot;: &#123;
    &quot;navigationBarTextStyle&quot;: &quot;black&quot;,
    &quot;navigationBarTitleText&quot;: &quot;Sky-Delivery&quot;,
    &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;
  &#125;,
  &quot;style&quot;: &quot;v2&quot;,
  &quot;componentFramework&quot;: &quot;glass-easel&quot;,
  &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;,
  &quot;lazyCodeLoading&quot;: &quot;requiredComponents&quot;
&#125;
</code></pre>
<pre><code class="xml">pages/index/index.wxml
&lt;view class=&quot;container&quot;&gt;
  &lt;view&gt;
    &#123;&#123;msg&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;getUserInfo&quot; type=&quot;primary&quot;&gt;获取用户信息&lt;/button&gt;
    昵称：&#123;&#123;nickName&#125;&#125;
    &lt;image src=&quot;&#123;&#123;url&#125;&#125;&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/image&gt;
    &lt;button bindtap=&quot;wxLogin&quot; type=&quot;warn&quot;&gt;微信登录&lt;/button&gt;
    授权码：&#123;&#123;code&#125;&#125;
  &lt;/view&gt;

  &lt;view&gt;
    &lt;button bindtap=&quot;sendRequest&quot; type=&quot;default&quot;&gt;发送请求&lt;/button&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="js">pages/index/index.js
Page(&#123;
  data: &#123;
    msg: &#39;hello world&#39;,
    nickName: &#39;&#39;,
    url:&#39;&#39;,
    code:&#39;&#39;,
  &#125;,

  // 获取微信用户的头像和昵称
  getUserInfo(e)&#123;
    wx.getUserProfile(&#123;
      desc: &#39;获取用户信息&#39;,
      success: (res) =&gt; &#123;
        console.log(res.userInfo);
        // 为数据赋值
        this.setData(&#123;
          nickName: res.userInfo.nickName,
          url: res.userInfo.avatarUrl
        &#125;)
      &#125;,
      fail:(err) =&gt; &#123;
        console.error(&#39;获取用户信息失败&#39;, err);
      &#125;
    &#125;);
  &#125;,
  
  //微信登录，获取微信用户的授权码 
  //拿到后可以去请求微信服务器获得openId
  //授权码提交到后端去调用服务器
  wxLogin()&#123;
    wx.login(&#123;
      success: (res) =&gt; &#123;
        console.log(res.code)
        this.setData(&#123;
          code: res.code
        &#125;)
      &#125;
    &#125;)
  &#125;,

  //发送请求
  sendRequest()&#123;
    wx.request(&#123;
      url: &#39;http://localhost:8080/user/shop/status&#39;,
      method: &#39;GET&#39;,
      success: (res)=&gt;&#123;
        // data是后端响应回来的整个数据
        console.log(res.data)
      &#125;
    &#125;)
  &#125;
&#125;);
</code></pre>
</li>
<li><p>编译小程序</p>
</li>
</ul>
<h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><h5 id="导入小程序代码"><a href="#导入小程序代码" class="headerlink" title="导入小程序代码"></a>导入小程序代码</h5><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day06\微信小程序代码\mp-weixin<br>【注意：导入后有很多包名错误common、components】</p>
</blockquote>
<h5 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">开放能力 &#x2F; 用户信息 &#x2F; 小程序登录 (qq.com)</a><br><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg"></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>appid</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appId</td>
</tr>
<tr>
<td>secret</td>
<td>string</td>
<td></td>
<td>是</td>
<td>小程序 appSecret</td>
</tr>
<tr>
<td>js_code</td>
<td>string</td>
<td></td>
<td>是</td>
<td>登录时获取的 code</td>
</tr>
<tr>
<td>grant_type</td>
<td>string</td>
<td></td>
<td>是</td>
<td>授权类型，此处只需填写 authorization_code</td>
</tr>
</tbody></table>
<blockquote>
<p>PostMan测试 →<br>GET：<a target="_blank" rel="noopener" href="https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2session?appid=wxa33b4bae9165c5a5&amp;secret=c2d6fc237953d711146c4ad5db3ef947&amp;js_code=0f1hdA200TsYYS1ghD100c3GZJ1hdA2w&amp;grant_type=authorization_code</a></p>
<p>返回：<br>{“session_key”:”HsYD32ryqarcnrCXbEyWhg&#x3D;&#x3D;”,”openid”:”obaex5N3w1_oAP6a4h-c-CkQBsZQ”}</p>
</blockquote>
<h6 id="需求分析和设计-3"><a href="#需求分析和设计-3" class="headerlink" title="需求分析和设计"></a>需求分析和设计</h6><p>数据库设计(user表)</p>
<h6 id="代码开发-3"><a href="#代码开发-3" class="headerlink" title="代码开发"></a>代码开发</h6><pre><code class="yaml">sky-server  application.yml
sky:
  jwt:
    # 设置jwt签名加密时使用的秘钥
    admin-secret-key: itcast
    # 设置jwt过期时间
    admin-ttl: 7200000
    # 设置前端传递过来的令牌名称
    admin-token-name: token
    user-secret-key: itheima
    user-ttl: 7200000
    user-token-name: authentication
  alioss:
    endpoint: $&#123;sky.alioss.endpoint&#125;
    access-key-id: $&#123;sky.alioss.access-key-id&#125;
    access-key-secret: $&#123;sky.alioss.access-key-secret&#125;
    bucket: $&#123;sky.alioss.bucket&#125;
  wechat:
    appid: $&#123;sky.wechat.appid&#125;
    secret: $&#123;sky.wechat.secret&#125;
</code></pre>
<pre><code class="java">sky-server  application-dev.yml
  wechat:
    appid: xxxxxxx
    secret: xxxxxxx
</code></pre>
<pre><code class="java">sky-common  com/sky/properties/WeChatProperties.java
package com.sky.properties;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = &quot;sky.wechat&quot;)
@Data
public class WeChatProperties &#123;

    private String appid; //小程序的appid
    private String secret; //小程序的秘钥
    private String mchid; //商户号
    private String mchSerialNo; //商户API证书的证书序列号
    private String privateKeyFilePath; //商户私钥文件
    private String apiV3Key; //证书解密的密钥
    private String weChatPayCertFilePath; //平台证书
    private String notifyUrl; //支付成功的回调地址
    private String refundNotifyUrl; //退款成功的回调地址
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/UserController.java
package com.sky.controller.user;

import com.sky.constant.JwtClaimsConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.properties.JwtProperties;
import com.sky.result.Result;
import com.sky.service.UserService;
import com.sky.utils.JwtUtil;
import com.sky.vo.UserLoginVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping(&quot;/user/user&quot;)
@Api(tags = &quot;C端用户相关接口&quot;)
@Slf4j
public class UserController &#123;
    @Autowired
    private UserService userService;
    @Autowired
    private JwtProperties jwtProperties;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @PostMapping(&quot;/login&quot;)
    @ApiOperation(&quot;微信登录&quot;)
    public Result&lt;UserLoginVO&gt; login(@RequestBody UserLoginDTO userLoginDTO) &#123;
        log.info(&quot;微信登录：&#123;&#125;&quot;, userLoginDTO.getCode());
        //微信登录
        User user = userService.wxLogin(userLoginDTO);

        //为微信用户生成jwt令牌
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(JwtClaimsConstant.USER_ID, user.getId());
        String token = JwtUtil.createJWT(jwtProperties.getUserSecretKey(),jwtProperties.getUserTtl(),claims);
        UserLoginVO userLoginVO = UserLoginVO.builder()
                .id(user.getId())
                .openid(user.getOpenid())
                .token(token)
                .build();
        return Result.success(userLoginVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/UserService.java
package com.sky.service;

import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;

public interface UserService &#123;
    /**
     * 微信登录
     * @return
     */
    User wxLogin(UserLoginDTO userLoginDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/UserServiceImpl.java
package com.sky.service.impl;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.sky.constant.MessageConstant;
import com.sky.dto.UserLoginDTO;
import com.sky.entity.User;
import com.sky.exception.LoginFailedException;
import com.sky.mapper.UserMapper;
import com.sky.properties.WeChatProperties;
import com.sky.service.UserService;
import com.sky.utils.HttpClientUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class UserServiceImpl implements UserService &#123;
    // 微信服务接口地址
    public static final String WX_LOGIN = &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;

    @Autowired
    private WeChatProperties weChatProperties;
    @Autowired
    private UserMapper userMapper;
    /**
     * 微信登录
     * @param userLoginDTO
     * @return
     */
    @Override
    public User wxLogin(UserLoginDTO userLoginDTO) &#123;
        String openid = getOpenid(userLoginDTO.getCode());
        // 判断openId是否真的获取到 如果为空代表失败 业务异常
        if (openid == null)&#123;
            throw new LoginFailedException(MessageConstant.LOGIN_FAILED);
        &#125;
        // openId是否在表里 可判断是否为新用户
        User user = userMapper.getByOpenid(openid);
        // 如果是新用户，自动完成注册
        if (user == null) &#123;
            user = User.builder()
                    .openid(openid)
                    .createTime(LocalDateTime.now())
                    .build();
            userMapper.insert(user);
        &#125;
        // 返回这个用户对象
        return user;
    &#125;

    /**
     * 调用微信接口服务，获取微信用户的openid
     * @param code
     * @return
     */
    //只有当前类用到
    private String getOpenid(String code) &#123;
        // 调用微信服务器接口 获得当前用户的openid
        // 四个请求参数
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;appid&quot;, weChatProperties.getAppid());
        map.put(&quot;secret&quot;, weChatProperties.getSecret());
        map.put(&quot;js_code&quot;, code);
        map.put(&quot;grant_type&quot;, &quot;authorization_code&quot;);
        String json = HttpClientUtil.doGet(WX_LOGIN, map);

        // 获得json对象
        JSONObject jsonObject = JSON.parseObject(json);
        String openid = jsonObject.getString(&quot;openid&quot;);
        return openid;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
package com.sky.mapper;

import com.sky.entity.User;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface UserMapper &#123;
    /**
     * 根据openid查询用户
     * @param openid
     * @return
     */
    @Select(&quot;select * from user where openid = #&#123;openid&#125;&quot;)
    User getByOpenid(String openid);

    /**
     * 新增用户
     * @param user
     */
    void insert(User user);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.UserMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into user (openid, name, phone, sex, id_number, avatar, create_time)
        values (#&#123;openid&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;avatar&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">【检测小程序用户是否登陆性】
sky-server  com/sky/interceptor/JwtTokenUserInterceptor.java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenUserInterceptor implements HandlerInterceptor &#123;

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) &#123;
            //当前拦截到的不是动态方法，直接放行
            return true;
        &#125;

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getUserTokenName());

        //2、校验令牌
        try &#123;
            log.info(&quot;jwt校验:&#123;&#125;&quot;, token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);
            Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());
            log.info(&quot;当前用户的id：&quot;, userId);
            BaseContext.setCurrentId(userId);
            //3、通过，放行
            return true;
        &#125; catch (Exception ex) &#123;
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/config/WebMvcConfiguration.java 【增加jwtTokenUserInterceptor】
/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;
    @Autowired
    private JwtTokenUserInterceptor jwtTokenUserInterceptor;

    /**
     * 注册自定义拦截器
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) &#123;
        log.info(&quot;开始注册自定义拦截器...&quot;);
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns(&quot;/admin/**&quot;)
                .excludePathPatterns(&quot;/admin/employee/login&quot;);

        registry.addInterceptor(jwtTokenUserInterceptor)
                .addPathPatterns(&quot;/user/**&quot;)
                .excludePathPatterns(&quot;/user/user/login&quot;)
                .excludePathPatterns(&quot;/user/shop/status&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="导入商品浏览功能代码"><a href="#导入商品浏览功能代码" class="headerlink" title="导入商品浏览功能代码"></a>导入商品浏览功能代码</h4><h6 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h6><ul>
<li><p>查询分类</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;category&#x2F;list<br>Method：GET<br>请求参数<br>Type： 分类类型→1.菜品分类  2.套餐分类</p>
</blockquote>
</li>
<li><p>根据分类id查询菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;dish&#x2F;list<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据分类id查询套餐</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;list?category&#x3D;111<br>Method：GET<br>请求参数<br>categoryId 分类id</p>
</blockquote>
</li>
<li><p>根据套餐id查询包含的菜品</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;setmeal&#x2F;dish&#x2F;10<br>Method：GET<br>请求参数<br>id 套餐id<br>返回数据：<br>copies 份数<br>description 菜品描述<br>image 菜品图片<br>name 菜品名称</p>
</blockquote>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;
        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        List&lt;DishVO&gt; list = dishService.listWithFlavor(dish);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/DishService.java
package com.sky.service;

import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.result.PageResult;
import com.sky.vo.DishVO;

import java.util.List;

public interface DishService &#123;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    public void saveWithFlavour(DishDTO dishDTO);

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO);

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    DishVO getByIdWithFlavor(long id);

    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    void updateWithFlavor(DishDTO dishDTO);

    /**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    List&lt;Dish&gt; list(Long categoryId);

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    List&lt;DishVO&gt; listWithFlavor(Dish dish);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/DishServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.DishDTO;
import com.sky.dto.DishPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.DishFlavor;
import com.sky.entity.Setmeal;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.DishFlavorMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j

public class DishServiceImpl implements DishService &#123;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private DishFlavorMapper dishFlavorMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    /**
     * 新增菜品和对应的口味
     * @param dishDTO
     */
    @Override
    @Transactional //保证事务一致性
    public void saveWithFlavour(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        //直接new出来是空的需要先赋值 属性拷贝[属性命名要一致]
        BeanUtils.copyProperties(dishDTO,dish);

        // 向菜品表插入1条数据
        dishMapper.insert(dish);
        // 前端无法传 要获取dishId
// &lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; 获取主键值
        Long dishId = dish.getId();

        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishId);
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品分页查询
     * @param dishPageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123;
        PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());
        Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        // 判断当前菜品是否能够删除--是否存在起售中的菜品？？ 取出id
        for (Long id : ids) &#123;
            Dish dish = dishMapper.getById(id);
            if (dish.getStatus() == StatusConstant.ENABLE) &#123;
                //当前菜品处于起售中，不能删除
                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);
            &#125;
        &#125;

        // 判断当前菜品是否能够删除--是否被套餐关联了
        List&lt;Long&gt; setMealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);
        if (setMealIds != null &amp;&amp; setMealIds.size() &gt; 0) &#123; //存在不允许删除
            // 当前菜品被套餐关联了，不能删除
            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);
        &#125;
        // 删除菜品表中的菜品数据
        for (Long id : ids) &#123;
            dishMapper.deleteById(id);
            // 删除菜品关联的口味数据
            dishFlavorMapper.deleteByDishId(id);
        &#125;
    &#125;

    /**
     * 根据id查询菜品和对应的口味数据
     * @param id
     * @return
     */
    @Override
    public DishVO getByIdWithFlavor(long id) &#123;
        // 根据id查询菜品数据
        Dish dish = dishMapper.getById(id);
        // 根据菜品id查询口味数据
        List&lt;DishFlavor&gt; dishFlavors = dishFlavorMapper.getByDishId(id);

        // 将查询到的数据封装到VO
        DishVO dishVO = new DishVO();
            // 属性拷贝
        BeanUtils.copyProperties(dish,dishVO);
        dishVO.setFlavors(dishFlavors);

        return dishVO;
    &#125;



    /**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @Override
    public void updateWithFlavor(DishDTO dishDTO) &#123;
        Dish dish = new Dish();
        BeanUtils.copyProperties(dishDTO,dish);

        // 修改菜品表基本信息 只是基础信息噢
        dishMapper.update(dish);
        // 先删掉原先的
        dishFlavorMapper.deleteByDishId(dishDTO.getId());
        // 再重新插入新的
        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();
        if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123;
            flavors.forEach(dishFlavor -&gt; &#123;
                dishFlavor.setDishId(dishDTO.getId());
            &#125;);
            // 向口味表插入n条数据 集合对象批量传入不用集合
            dishFlavorMapper.insertBatch(flavors);
        &#125;
    &#125;

    /**
     * 菜品起售停售
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) &#123;
        Dish dish = Dish.builder()
                .id(id)
                .status(status)
                .build();
        dishMapper.update(dish);

        if (status == StatusConstant.DISABLE) &#123;
            // 如果是停售操作，还需要将包含当前菜品的套餐也停售
            List&lt;Long&gt; dishIds = new ArrayList&lt;&gt;();
            dishIds.add(id);
            // select setmeal_id from setmeal_dish where dish_id in (?,?,?)
            List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);
            if (setmealIds != null &amp;&amp; setmealIds.size() &gt; 0) &#123;
                for (Long setmealId : setmealIds) &#123;
                    Setmeal setmeal = Setmeal.builder()
                            .id(setmealId)
                            .status(StatusConstant.DISABLE)
                            .build();
                    setmealMapper.update(setmeal);
                &#125;
            &#125;

        &#125;
    &#125;

    /**
     * 根据分类id查询菜品
     * @param categoryId
     * @return
     */
    public List&lt;Dish&gt; list(Long categoryId) &#123;
        Dish dish = Dish.builder()
                .categoryId(categoryId)
                .status(StatusConstant.ENABLE)
                .build();
        return dishMapper.list(dish);
    &#125;

    /**
     * 条件查询菜品和口味
     * @param dish
     * @return
     */
    public List&lt;DishVO&gt; listWithFlavor(Dish dish) &#123;
        List&lt;Dish&gt; dishList = dishMapper.list(dish);

        List&lt;DishVO&gt; dishVOList = new ArrayList&lt;&gt;();

        for (Dish d : dishList) &#123;
            DishVO dishVO = new DishVO();
            BeanUtils.copyProperties(d,dishVO);

            //根据菜品id查询对应的口味
            List&lt;DishFlavor&gt; flavors = dishFlavorMapper.getByDishId(d.getId());

            dishVO.setFlavors(flavors);
            dishVOList.add(dishVO);
        &#125;

        return dishVOList;
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Setmeal;
import com.sky.result.Result;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;

    /**
     * 根据套餐id查询包含的菜品列表
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/dish/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)
    public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(@PathVariable(&quot;id&quot;) Long id) &#123;
        List&lt;DishItemVO&gt; list = setmealService.getDishItemById(id);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/SetmealService.java
package com.sky.service;

import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Setmeal;
import com.sky.result.PageResult;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;

import java.util.List;

public interface SetmealService &#123;

    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    void saveWithDish(SetmealDTO setmealDTO);

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO);

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    void deleteBatch(List&lt;Long&gt; ids);

    /**
     * 根据id查询套餐和关联的菜品数据
     *
     * @param id
     * @return
     */
    SetmealVO getByIdWithDish(Long id);

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    void update(SetmealDTO setmealDTO);

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    List&lt;Setmeal&gt; list(Setmeal setmeal);

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    List&lt;DishItemVO&gt; getDishItemById(Long id);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/SetmealServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.dto.SetmealDTO;
import com.sky.dto.SetmealPageQueryDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.SetmealDish;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.exception.SetmealEnableFailedException;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealDishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.SetmealService;
import com.sky.vo.DishItemVO;
import com.sky.vo.SetmealVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * 套餐业务实现
 */
@Service
@Slf4j
public class SetmealServiceImpl implements SetmealService &#123;

    @Autowired
    private SetmealMapper setmealMapper;
    @Autowired
    private SetmealDishMapper setmealDishMapper;
    @Autowired
    private DishMapper dishMapper;


    /**
     * 新增套餐，同时需要保存套餐和菜品的关联关系
     *
     * @param setmealDTO
     */
    @Transactional
    public void saveWithDish(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //向套餐表插入数据
        setmealMapper.insert(setmeal);

        //获取生成的套餐id
        Long setmealId = setmeal.getId();

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);

        //保存套餐和菜品的关联关系
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 分页查询
     *
     * @param setmealPageQueryDTO
     * @return
     */
    public PageResult pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123;
        int pageNum = setmealPageQueryDTO.getPage();
        int pageSize = setmealPageQueryDTO.getPageSize();

        PageHelper.startPage(pageNum, pageSize);
        Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 批量删除套餐
     *
     * @param ids
     */
    @Transactional
    public void deleteBatch(List&lt;Long&gt; ids) &#123;
        ids.forEach(id -&gt; &#123;
            Setmeal setmeal = setmealMapper.getById(id);
            if (StatusConstant.ENABLE == setmeal.getStatus()) &#123;
                //起售中的套餐不能删除
                throw new DeletionNotAllowedException(MessageConstant.SETMEAL_ON_SALE);
            &#125;
        &#125;);

        ids.forEach(setmealId -&gt; &#123;
            //删除套餐表中的数据
            setmealMapper.deleteById(setmealId);
            //删除套餐菜品关系表中的数据
            setmealDishMapper.deleteBySetmealId(setmealId);
        &#125;);
    &#125;

    /**
     * 根据id查询套餐和套餐菜品关系
     *
     * @param id
     * @return
     */
    public SetmealVO getByIdWithDish(Long id) &#123;
        SetmealVO setmealVO = setmealMapper.getByIdWithDish(id);
        return setmealVO;
    &#125;

    /**
     * 修改套餐
     *
     * @param setmealDTO
     */
    @Transactional
    public void update(SetmealDTO setmealDTO) &#123;
        Setmeal setmeal = new Setmeal();
        BeanUtils.copyProperties(setmealDTO, setmeal);

        //1、修改套餐表，执行update
        setmealMapper.update(setmeal);

        //套餐id
        Long setmealId = setmealDTO.getId();

        //2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete
        setmealDishMapper.deleteBySetmealId(setmealId);

        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();
        setmealDishes.forEach(setmealDish -&gt; &#123;
            setmealDish.setSetmealId(setmealId);
        &#125;);
        //3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert
        setmealDishMapper.insertBatch(setmealDishes);
    &#125;

    /**
     * 套餐起售、停售
     *
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        //起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;
        if (status == StatusConstant.ENABLE) &#123;
            //select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?
            List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);
            if (dishList != null &amp;&amp; dishList.size() &gt; 0) &#123;
                dishList.forEach(dish -&gt; &#123;
                    if (StatusConstant.DISABLE == dish.getStatus()) &#123;
                        throw new SetmealEnableFailedException(MessageConstant.SETMEAL_ENABLE_FAILED);
                    &#125;
                &#125;);
            &#125;
        &#125;

        Setmeal setmeal = Setmeal.builder()
                .id(id)
                .status(status)
                .build();
        setmealMapper.update(setmeal);
    &#125;

    /**
     * 条件查询
     * @param setmeal
     * @return
     */
    public List&lt;Setmeal&gt; list(Setmeal setmeal) &#123;
        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);
        return list;
    &#125;

    /**
     * 根据id查询菜品选项
     * @param id
     * @return
     */
    public List&lt;DishItemVO&gt; getDishItemById(Long id) &#123;
        return setmealMapper.getDishItemBySetmealId(id);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">sky-server  com/sky/controller/user/CategoryController.java
package com.sky.controller.user;

import com.sky.entity.Category;
import com.sky.result.Result;
import com.sky.service.CategoryService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userCategoryController&quot;)
@RequestMapping(&quot;/user/category&quot;)
@Api(tags = &quot;C端-分类接口&quot;)
public class CategoryController &#123;

    @Autowired
    private CategoryService categoryService;

    /**
     * 查询分类
     * @param type
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查询分类&quot;)
    public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123;
        List&lt;Category&gt; list = categoryService.list(type);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/CategoryService.java
package com.sky.service;

import com.sky.annotation.AutoFill;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.result.PageResult;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增分类
     * @param categoryDTO
     */
    void save(CategoryDTO categoryDTO);
    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO);

    /**
     * 根据id删除分类
     * @param id
     */
    void deleteById(Long id);

    /**
     * 修改分类
     * @param categoryDTO
     */
    void update(CategoryDTO categoryDTO);

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    void startOrStop(Integer status, Long id);

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    List&lt;Category&gt; list(Integer type);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/CategoryServiceImpl.java
package com.sky.service.impl;

import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.sky.constant.MessageConstant;
import com.sky.constant.StatusConstant;
import com.sky.context.BaseContext;
import com.sky.dto.CategoryDTO;
import com.sky.dto.CategoryPageQueryDTO;
import com.sky.entity.Category;
import com.sky.exception.DeletionNotAllowedException;
import com.sky.mapper.CategoryMapper;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.result.PageResult;
import com.sky.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 分类业务层
 */
@Service
@Slf4j
public class CategoryServiceImpl implements CategoryService &#123;

    @Autowired
    private CategoryMapper categoryMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 新增分类
     * @param categoryDTO
     */
    public void save(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        //属性拷贝
        BeanUtils.copyProperties(categoryDTO, category);

        //分类状态默认为禁用状态0
        category.setStatus(StatusConstant.DISABLE);
/**  公共属性
        //设置创建时间、修改时间、创建人、修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContext.getCurrentId());
        category.setUpdateUser(BaseContext.getCurrentId());
 **/

        categoryMapper.insert(category);
    &#125;

    /**
     * 分页查询
     * @param categoryPageQueryDTO
     * @return
     */
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123;
        PageHelper.startPage(categoryPageQueryDTO.getPage(),categoryPageQueryDTO.getPageSize());
        //下一条sql进行分页，自动加入limit关键字分页
        Page&lt;Category&gt; page = categoryMapper.pageQuery(categoryPageQueryDTO);
        return new PageResult(page.getTotal(), page.getResult());
    &#125;

    /**
     * 根据id删除分类
     * @param id
     */
    public void deleteById(Long id) &#123;
        //查询当前分类是否关联了菜品，如果关联了就抛出业务异常
        Integer count = dishMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        &#125;

        //查询当前分类是否关联了套餐，如果关联了就抛出业务异常
        count = setmealMapper.countByCategoryId(id);
        if(count &gt; 0)&#123;
            //当前分类下有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        &#125;

        //删除分类数据
        categoryMapper.deleteById(id);
    &#125;

    /**
     * 修改分类
     * @param categoryDTO
     */
    public void update(CategoryDTO categoryDTO) &#123;
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO,category);

        //设置修改时间、修改人 (公共属性)
//        category.setUpdateTime(LocalDateTime.now());
//        category.setUpdateUser(BaseContext.getCurrentId());

        categoryMapper.update(category);
    &#125;

    /**
     * 启用、禁用分类
     * @param status
     * @param id
     */
    public void startOrStop(Integer status, Long id) &#123;
        Category category = Category.builder()
                .id(id)
                .status(status) // 下面注释是公共属性AOP有写
//                .updateTime(LocalDateTime.now())
//                .updateUser(BaseContext.getCurrentId())
                .build();
        categoryMapper.update(category);
    &#125;

    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    public List&lt;Category&gt; list(Integer type) &#123;
        return categoryMapper.list(type);
    &#125;
&#125;
</code></pre>
<h3 id="缓存菜品-【redis】"><a href="#缓存菜品-【redis】" class="headerlink" title="缓存菜品 【redis】"></a>缓存菜品 【redis】</h3><h5 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h5><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大</p>
<h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>通过Redis来缓存菜品数据，减少数据库查询操作</p>
<p>开始→(查询菜品)→后端服务→缓存是否存在→(是)→读取缓存<br>                                                                               (否)→查询数据库→载入缓存</p>
<h5 id="缓存逻辑分析："><a href="#缓存逻辑分析：" class="headerlink" title="缓存逻辑分析："></a>缓存逻辑分析：</h5><ul>
<li><p>每个分类下的菜品保存一份缓存数据</p>
<p><strong>key</strong>：dish_1<br><strong>value</strong>：string(…) [List集合]</p>
</li>
</ul>
<pre><code class="java">sky-server com/sky/controller/user/DishController.java
package com.sky.controller.user;

import com.sky.constant.StatusConstant;
import com.sky.entity.Dish;
import com.sky.result.Result;
import com.sky.service.DishService;
import com.sky.vo.DishVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

@RestController(&quot;userDishController&quot;)
@RequestMapping(&quot;/user/dish&quot;)
@Slf4j
@Api(tags = &quot;C端-菜品浏览接口&quot;)
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 根据分类id查询菜品
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询菜品&quot;)
    public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123;

        //构造redis中的key，规则：dish_分类id
        String key = &quot;dish_&quot; + categoryId;

        //查询redis中是否存在菜品数据
        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);
        if(list != null &amp;&amp; list.size() &gt; 0)&#123;
            //如果存在，直接返回，无须查询数据库
            return Result.success(list);
        &#125;

        Dish dish = new Dish();
        dish.setCategoryId(categoryId);
        dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品

        //如果不存在，查询数据库，将查询到的数据放入redis中
        list = dishService.listWithFlavor(dish);
        redisTemplate.opsForValue().set(key, list);

        return Result.success(list);
    &#125;
&#125;
</code></pre>
<h5 id="清理缓存数据"><a href="#清理缓存数据" class="headerlink" title="清理缓存数据"></a>清理缓存数据</h5><h6 id="防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收"><a href="#防止-新增-x2F-更改-x2F-删除-x2F-起售停售-后无法及时在用户手机端接收" class="headerlink" title="防止 新增&#x2F;更改&#x2F;删除&#x2F;起售停售 后无法及时在用户手机端接收"></a>防止 <u>新增&#x2F;更改&#x2F;删除&#x2F;起售停售</u> 后无法及时在用户手机端接收</h6><p>修改管理端接口 <code>DishController</code> 加入清理缓存的逻辑 (新增菜品、修改菜品、批量删除菜品、起售停售菜品)</p>
<pre><code class="java">sky-server  com/sky/controller/admin/DishController.java
/**
 * 菜品管理
 */
@RestController
@RequestMapping(&quot;/admin/dish&quot;)
@Api(tags = &quot;菜品相关接口&quot;)
@Slf4j
public class DishController &#123;
    @Autowired
    private DishService dishService;
    @Autowired
    private RedisTemplate redisTemplate;
    @PostMapping
    @ApiOperation(&quot;新增菜品&quot;)
    //@RequestBody 封装JSON格式的数据
    public Result save(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;新增菜品：&#123;&#125;&quot;, dishDTO);
        dishService.saveWithFlavour(dishDTO);

        //清理缓存数据(精确查询)
        String key = &quot;dish_&quot; + dishDTO.getCategoryId();
        cleanCache(key);
        return Result.success();
    &#125;
 /**
     * 菜品的批量删除
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除菜品&quot;)
    //@RequestParam MVC动态解析字符串 ids提取出来
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123; //ids
        log.info(&quot;批量删除菜品：&#123;&#125;&quot;, ids);
        dishService.deleteBatch(ids);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);
        return Result.success();
    &#125;
/**
     * 修改菜品
     * @param dishDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改菜品&quot;)
    public Result update(@RequestBody DishDTO dishDTO) &#123;
        log.info(&quot;修改菜品：&#123;&#125;&quot;, dishDTO);
        dishService.updateWithFlavor(dishDTO);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);;
        return Result.success();
    &#125;
/**
     * 菜品起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;菜品起售停售&quot;)
    public Result&lt;String&gt; startOrStop(@PathVariable Integer status, Long id) &#123;
        dishService.startOrStop(status, id);

        // 将所有的菜品缓存数据清理掉，所有的以dish_开头的key
        cleanCache(&quot;dish_*&quot;);

        return Result.success();
    &#125;
private void cleanCache(String pattern)&#123;
        /** 因为单独清理每个菜品可能会有关联套餐 就直接清理全部
         * 1. 先获取到所有的key
         * 2. 遍历key，判断是否以pattern开头
         * 3. 删除所有的key
         */
        Set keys = redisTemplate.keys(pattern);
        redisTemplate.delete(keys);
    &#125;
&#125;
</code></pre>
<h2 id="缓存套餐-【SpringCache】"><a href="#缓存套餐-【SpringCache】" class="headerlink" title="缓存套餐 【SpringCache】"></a>缓存套餐 【SpringCache】</h2><p>Spring Cache 是一个框架，实现了基于<strong>注解</strong>的缓存功能，只需要简单地加一个<strong>注解</strong>，就能实现缓存功能<br>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现</p>
<ul>
<li>EHCache</li>
<li>Caffeine</li>
<li>Redis</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style="color:red">@<strong>EnableCaching</strong></span></td>
<td>开启缓存注解功能，通常加在<strong>启动类</strong>上</td>
</tr>
<tr>
<td><span style="color:red">@<strong>Cacheable</strong></span></td>
<td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CachePut</strong></span></td>
<td>将方法的返回值放到缓存中</td>
</tr>
<tr>
<td><span style="color:red">@<strong>CacheEvict</strong></span></td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<pre><code class="java">@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

     @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
</code></pre>
<h5 id="SpringCache入门案例"><a href="#SpringCache入门案例" class="headerlink" title="SpringCache入门案例"></a>SpringCache入门案例</h5><h6 id="初始资源："><a href="#初始资源：" class="headerlink" title="初始资源："></a>初始资源：</h6><pre><code class="java">package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;

    @Autowired
    private UserMapper userMapper;

    @PostMapping
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;

    @GetMapping
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.mapper;

import com.itheima.entity.User;
import org.apache.ibatis.annotations.*;

@Mapper
public interface UserMapper&#123;

    @Insert(&quot;insert into user(name,age) values (#&#123;name&#125;,#&#123;age&#125;)&quot;)
    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    void insert(User user);

    @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);

    @Delete(&quot;delete from user&quot;)
    void deleteAll();

    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
    User getById(Long id);
&#125;
</code></pre>
<pre><code class="java">package com.itheima.entity;

import lombok.Data;
import java.io.Serializable;

@Data
public class User implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    private String name;

    private int age;

&#125;
</code></pre>
<pre><code class="java">package com.itheima.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    /**
     * 生成接口文档配置
     * @return
     */
    @Bean
    public Docket docket()&#123;
        log.info(&quot;准备生成接口文档...&quot;);

        ApiInfo apiInfo = new ApiInfoBuilder()
                .title(&quot;接口文档&quot;)
                .version(&quot;2.0&quot;)
                .description(&quot;接口文档&quot;)
                .build();

        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                //指定生成接口需要扫描的包
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itheima.controller&quot;))
                .paths(PathSelectors.any())
                .build();

        return docket;
    &#125;

    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        log.info(&quot;开始设置静态资源映射...&quot;);
        registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.yml
server:
  port: 8888
spring:
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/spring_cache_demo?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true
      username: root
      password: root
  redis:
    host: localhost
    port: 6379
    database: 1
logging:
  level:
    com:
      itheima:
        mapper: debug
        service: info
        controller: info
</code></pre>
<pre><code class="sql">springcachedemo.sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(45) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`)
);
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcache-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.20&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.76&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-lang&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.7.3&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<hr>
<hr>
<h5 id="开始调试咯"><a href="#开始调试咯" class="headerlink" title="开始调试咯"></a>开始调试咯</h5><pre><code class="java">com/itheima/CacheDemoApplication.java
package com.itheima;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
//@EnableCaching 放在 Application 类上，这样整个应用就启用了缓存支持
@Slf4j
@SpringBootApplication
@EnableCaching
public class CacheDemoApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(CacheDemoApplication.class,args);
        log.info(&quot;项目启动成功...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/controller/UserController.java
package com.itheima.controller;

import com.itheima.entity.User;
import com.itheima.mapper.UserMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/user&quot;)
@Slf4j
public class UserController &#123;
    /*
    set a:b:c:d: itheima 这个就是树形结构在Redis里面 文件夹包着文件夹
    */
    @Autowired
    private UserMapper userMapper;

    @PostMapping
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#result.id&quot;) 对象导航
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#p0.id&quot;)
//  @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;)
    @CachePut(cacheNames = &quot;userCache&quot;,key = &quot;#user.id&quot;)
// 将方法的返回值放到缓存中
    // 如果使用Spring Cache缓存数据，key的生成&quot;#user.id&quot;
    public User save(@RequestBody User user)&#123;
        userMapper.insert(user);
        return user;
    &#125;

    @DeleteMapping
    @CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
    public void deleteById(Long id)&#123;
        userMapper.deleteById(id);
    &#125;

    @DeleteMapping(&quot;/delAll&quot;)
    @CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)
    public void deleteAll()&#123;
        userMapper.deleteAll();
    &#125;


    @GetMapping
    @Cacheable(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)
// 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中
    public User getById(Long id)&#123;
        User user = userMapper.getById(id);
        return user;
    &#125;
&#125;
</code></pre>
<h4 id="缓存套餐-代码开发"><a href="#缓存套餐-代码开发" class="headerlink" title="缓存套餐_代码开发"></a>缓存套餐_代码开发</h4><h6 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h6><ul>
<li>导入 <strong>Spring Cache</strong> 和 <strong>Redis</strong> 相关maven坐标</li>
<li>在<u><strong>启动类</strong></u>上加入 <strong>@EnableCaching</strong> 注解，开启缓存注解功能</li>
<li>在<u><strong>用户端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>list</strong> 方法上加入 <strong>@Cacheable</strong> 注解</li>
<li>在<u><strong>管理端</strong></u>接口 <strong>SetmealController</strong> 的 <strong>save、delete、update、startOrStop</strong> 等方法上<br>加入**@CacheEvict** 注解<del>保证数据一致性</del></li>
</ul>
<pre><code class="java">com/sky/SkyApplication.java
package com.sky;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
@EnableTransactionManagement //开启注解方式的事务管理
@Slf4j
@EnableCaching //开启缓存注解
public class SkyApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SkyApplication.class, args);
        log.info(&quot;server started&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/SetmealController.java
@RestController(&quot;userSetmealController&quot;)
@RequestMapping(&quot;/user/setmeal&quot;)
@Api(tags = &quot;C端-套餐浏览接口&quot;)
public class SetmealController &#123;
    @Autowired
    private SetmealService setmealService;

    /**
     * 条件查询
     *
     * @param categoryId
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;根据分类id查询套餐&quot;)
    @Cacheable(cacheNames = &quot;setmealCache&quot;,key = &quot;#categoryId&quot;) //key: setmealCache::100
    public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123;
        Setmeal setmeal = new Setmeal();
        setmeal.setCategoryId(categoryId);
        setmeal.setStatus(StatusConstant.ENABLE);

        List&lt;Setmeal&gt; list = setmealService.list(setmeal);
        return Result.success(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/SetmealController.java

/**
 * 套餐管理
 */
@RestController
@RequestMapping(&quot;/admin/setmeal&quot;)
@Api(tags = &quot;套餐相关接口&quot;)
@Slf4j
public class SetmealController &#123;

    @Autowired
    private SetmealService setmealService;

    /**
     * 新增套餐
     *
     * @param setmealDTO
     * @return
     */
    @PostMapping
    @ApiOperation(&quot;新增套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)//key: setmealCache::100
    public Result save(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.saveWithDish(setmealDTO);
        return Result.success();
    &#125;
 /**
     * 批量删除套餐
     *
     * @param ids
     * @return
     */
    @DeleteMapping
    @ApiOperation(&quot;批量删除套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result delete(@RequestParam List&lt;Long&gt; ids) &#123;
        setmealService.deleteBatch(ids);
        return Result.success();
    &#125;
/**
     * 修改套餐
     *
     * @param setmealDTO
     * @return
     */
    @PutMapping
    @ApiOperation(&quot;修改套餐&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result update(@RequestBody SetmealDTO setmealDTO) &#123;
        setmealService.update(setmealDTO);
        return Result.success();
    &#125;

    /**
     * 套餐起售停售
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping(&quot;/status/&#123;status&#125;&quot;)
    @ApiOperation(&quot;套餐起售停售&quot;)
    @CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)
    public Result startOrStop(@PathVariable Integer status, Long id) &#123;
        setmealService.startOrStop(status, id);
        return Result.success();
    &#125;
&#125;
</code></pre>
<h3 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a>添加购物车</h3><blockquote>
<p>套餐直接点击加号<br>菜品＋ 或者有口味数据的选择后才可以加入购物车</p>
</blockquote>
<h6 id="接口设计：-4"><a href="#接口设计：-4" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li>请求方式：<strong>POST</strong></li>
<li>请求路径：&#x2F;user&#x2F;shoppingCart&#x2F;add</li>
<li>请求参数：<strong>菜品id</strong>(dish_id)、<strong>口味</strong>(dish_flavor) 或 <strong>套餐id</strong>(setmeal_id) (JSON请求体)</li>
<li>返回结果：code、data、msg</li>
</ul>
<h6 id="数据库设计-shopping-cart表-设置冗余字段可提高数据库效率"><a href="#数据库设计-shopping-cart表-设置冗余字段可提高数据库效率" class="headerlink" title="数据库设计(shopping_cart表):设置冗余字段可提高数据库效率"></a>数据库设计(shopping_cart表):<del>设置冗余字段可提高数据库效率</del></h6><ul>
<li>作用：暂时存放所选商品的地方</li>
<li>选的什么商品</li>
<li>每个商品都买了几个</li>
<li>不同用户的购物车需要区分开</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/dto/ShoppingCartDTO.java
package com.sky.dto;

import lombok.Data;
import java.io.Serializable;

@Data
public class ShoppingCartDTO implements Serializable &#123;

    private Long dishId;
    private Long setmealId;
    private String dishFlavor;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
package com.sky.controller.user;

import com.sky.dto.ShoppingCartDTO;
import com.sky.result.Result;
import com.sky.service.ShoppingCartService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/user/shoppingCart&quot;)
@Slf4j
@Api(tags = &quot;C端添加购物车接口&quot;)
public class ShoppingCartController &#123;
    @Autowired
    private ShoppingCartService shoppingCartService;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加购物车&quot;)
    public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;添加购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.addShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
package com.sky.service;

import com.sky.dto.ShoppingCartDTO;
import org.springframework.stereotype.Service;

public interface ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    void addShoppingCart(ShoppingCartDTO shoppingCartDTO);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
package com.sky.service.impl;

import com.sky.context.BaseContext;
import com.sky.dto.ShoppingCartDTO;
import com.sky.entity.Dish;
import com.sky.entity.Setmeal;
import com.sky.entity.ShoppingCart;
import com.sky.mapper.DishMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.ShoppingCartService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
@Service
@Slf4j
public class ShoppingCartServiceImpl implements ShoppingCartService &#123;
    /**
     * 添加购物车
     * @param shoppingCartDTO
     */
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;
    @Override
    public void addShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        // 判断当前加入购物车中的商品是否已经存在了 (user_id + setmeal_id)
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        Long userId = BaseContext.getCurrentId();
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);

        // 如果已经存在了，只需要将数量+1
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            cart.setNumber(cart.getNumber() + 1);
            // update shopping_cart set number = ? where id = ?
            shoppingCartMapper.updateNumberById(cart);
        &#125; else &#123;
            // 如果不存在，需要插入一条购物车数据
            // [先确定套餐or菜品]
            // 判断本次添加到购物车的是菜品还是套餐
            Long dishId = shoppingCartDTO.getDishId();
            if (dishId != null) &#123;
                //本次添加到购物车的是菜品
                Dish dish = dishMapper.getById(dishId);
                shoppingCart.setName(dish.getName());
                shoppingCart.setImage(dish.getImage());
                shoppingCart.setAmount(dish.getPrice());
            &#125; else &#123;
                //本次添加到购物车的是套餐 查菜品表
                Long setmealId = shoppingCartDTO.getSetmealId();
                Setmeal setmeal = setmealMapper.getById(setmealId);
                shoppingCart.setName(setmeal.getName());
                shoppingCart.setImage(setmeal.getImage());
                shoppingCart.setAmount(setmeal.getPrice());

            &#125;
            shoppingCart.setNumber(1);
            shoppingCart.setCreateTime(LocalDateTime.now());
            shoppingCartMapper.insert(shoppingCart);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
package com.sky.mapper;

import com.sky.entity.ShoppingCart;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Update;

import java.util.List;

@Mapper
public interface ShoppingCartMapper &#123;
    List&lt;ShoppingCart&gt; list(ShoppingCart shoppingCart);

    /**
     * 根据id修改商品数量
     * @param shoppingCart
     */
    @Update(&quot;update shopping_cart set number = #&#123;number&#125; where id = #&#123;id&#125;&quot;)
    void updateNumberById(ShoppingCart shoppingCart);

    /**
     * 插入购物车数据
     * @param shoppingCart
     */
    @Insert(&quot;insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) &quot; +
            &quot; values (#&#123;name&#125;,#&#123;userId&#125;,#&#123;dishId&#125;,#&#123;setmealId&#125;,#&#123;dishFlavor&#125;,#&#123;number&#125;,#&#123;amount&#125;,#&#123;image&#125;,#&#123;createTime&#125;)&quot;)
    void insert(ShoppingCart shoppingCart);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/ShoppingCartMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.ShoppingCartMapper&quot;&gt;

    &lt;select id=&quot;list&quot; resultType=&quot;com.sky.entity.ShoppingCart&quot;&gt;
        select * from shopping_cart
        &lt;where&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishId != null&quot;&gt;
                and dish_id = #&#123;dishId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;setmealId != null&quot;&gt;
                and setmeal_id = #&#123;setmealId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;dishFlavor != null&quot;&gt;
                and dish_flavor = #&#123;dishFlavor&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="删除购物车"><a href="#删除购物车" class="headerlink" title="删除购物车"></a>删除购物车</h3><pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 删除购物车
     * @param shoppingCartDTO
     * @return
     */
    @PostMapping(&quot;/sub&quot;)
    @ApiOperation(&quot;删除购物车&quot;)
    public Result sub(@RequestBody ShoppingCartDTO shoppingCartDTO)&#123;
        log.info(&quot;删除购物车，商品信息为：&#123;&#125;&quot;,shoppingCartDTO);
        shoppingCartService.subShoppingCart(shoppingCartDTO);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 删除购物车
     * @param shoppingCartDTO
     */
    void subShoppingCart(ShoppingCartDTO shoppingCartDTO);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 删除购物车中的商品
     * @param shoppingCartDTO
     */
    @Override
    public void subShoppingCart(ShoppingCartDTO shoppingCartDTO) &#123;
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);
        shoppingCart.setUserId(userId);

        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        if (list != null &amp;&amp; list.size() &gt; 0) &#123;
            ShoppingCart cart = list.get(0);
            if (cart.getNumber() &gt; 1) &#123;
                // 如果 number &gt;1， 则需要将 number - 1
                cart.setNumber(cart.getNumber() - 1);
                shoppingCartMapper.updateNumberById(cart);
            &#125; else &#123;
                // 如果 number &lt;=1，则直接删除该购物车数据
                shoppingCartMapper.deleteById(cart.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据id删除购物车数据
     * @param id
     */
    @Delete(&quot;delete from shopping_cart where id = #&#123;id&#125;&quot;)
    void deleteById(Long id);
</code></pre>
<h3 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h3><blockquote>
<p>名称、价格、商品、数量<br>Path：&#x2F;user&#x2F;shoppingCart&#x2F;list<br>            PUT</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 查看购物车
     * @return
     */
    @GetMapping(&quot;/list&quot;)
    @ApiOperation(&quot;查看购物车&quot;)
    public Result&lt;List&lt;ShoppingCart&gt;&gt; list()&#123;
       List&lt;ShoppingCart&gt; list = shoppingCartService.showShoppingCart();
       return Result.success(list);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
    /**
     * 查看购物车
     * @return
     */
    List&lt;ShoppingCart&gt; showShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 查看购物车
     * @return
     */
    @Override
    public List&lt;ShoppingCart&gt; showShoppingCart() &#123;
        // 获取到当前微信用户的id
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = ShoppingCart.builder()
                .userId(userId)
                .build();
        List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);
        return list;
    &#125;
</code></pre>
<h3 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h3><blockquote>
<p>Path：user&#x2F;shoppingCart&#x2F;clean<br>Method：DELETE<br>返回：code <strong>date</strong> msg</p>
</blockquote>
<pre><code class="java">sky-server  com/sky/controller/user/ShoppingCartController.java
/**
     * 清空购物车
     * @return
     */
    @DeleteMapping(&quot;/clean&quot;)
    @ApiOperation(&quot;清空购物车&quot;)
    public Result clean() &#123;
        shoppingCartService.cleanShoppingCart();
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ShoppingCartService.java
/**
     * 清空购物车 删除自己的购物车
     */
    void cleanShoppingCart();
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ShoppingCartServiceImpl.java
/**
     * 清空购物车
     */
    @Override
    public void cleanShoppingCart() &#123;
        //获取到当前用户的id
        Long userId = BaseContext.getCurrentId();
        shoppingCartMapper.deleteByUserId(userId);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/ShoppingCartMapper.java
/**
     * 根据用户id清空购物车
     * @param userId
     */
    @Delete(&quot;delete from shopping_cart where user_id = #&#123;userId&#125;&quot;)
    void deleteByUserId(Long userId);
</code></pre>
<h3 id="支付接口"><a href="#支付接口" class="headerlink" title="支付接口"></a>支付接口</h3><h5 id="导入地址簿功能代码"><a href="#导入地址簿功能代码" class="headerlink" title="导入地址簿功能代码"></a>导入地址簿功能代码</h5><p><strong>业务功能：</strong></p>
<ul>
<li><p>查询地址列表</p>
</li>
<li><p>新增地址</p>
</li>
<li><p>修改地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：PUT</p>
</blockquote>
</li>
<li><p>删除地址</p>
</li>
<li><p>设置默认地址</p>
</li>
<li><p>查询默认地址</p>
</li>
</ul>
<p><strong>接口设计：</strong></p>
<ul>
<li><p>新增地址</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook<br>Method: POST</p>
</blockquote>
</li>
<li><p>查询当前登录用户的所有地址信息</p>
<blockquote>
<p>Path: &#x2F;user&#x2F;addressBook&#x2F;list<br>Method: GET</p>
</blockquote>
</li>
<li><p>查询默认地址</p>
</li>
<li><p>根据id修改地址</p>
</li>
<li><p>根据id删除地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook<br>Method：DELETE</p>
</blockquote>
</li>
<li><p>根据id查询地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;{id}<br>Method：GET</p>
</blockquote>
</li>
<li><p>设置默认地址</p>
<blockquote>
<p>Path：&#x2F;user&#x2F;addressBook&#x2F;default<br>Method：PUT</p>
</blockquote>
</li>
</ul>
<h6 id="数据库设计-address-book表"><a href="#数据库设计-address-book表" class="headerlink" title="数据库设计(address_book表)"></a>数据库设计(address_book表)</h6><h4 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h4><h6 id="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"><a href="#在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货" class="headerlink" title="在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货"></a>在电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货</h6><p>用户下单后会产生订单相关数据，订单数据需要体现信息：</p>
<ul>
<li><strong>订单总金额是多少</strong>？</li>
<li><strong>哪个用户下的单</strong>？</li>
<li><strong>买的哪些商品</strong>？</li>
<li><strong>每个商品数量是多少</strong>？</li>
<li><strong>收货地址是哪</strong>？</li>
<li><strong>用户手机号是多少</strong>？</li>
</ul>
<p>餐盒费：用数量算</p>
<h5 id="用户下单接口设计"><a href="#用户下单接口设计" class="headerlink" title="用户下单接口设计"></a>用户下单接口设计</h5><blockquote>
<p><strong>请求方式</strong>：POST<br><strong>请求路径：</strong>&#x2F;user&#x2F;order&#x2F;submit</p>
<p><strong>参数：</strong></p>
<ul>
<li>地址簿id<del>addressBookId</del></li>
<li>配送状态(立即送出、选择送出时间)<del>deliveryStatus</del></li>
<li>打包费<del>packAmount</del></li>
<li>总金额<del>amount</del></li>
<li>备注<del>remark</del></li>
<li>餐具数量<del>tablewareNumber</del></li>
</ul>
</blockquote>
<h5 id="支付订单接口设计"><a href="#支付订单接口设计" class="headerlink" title="支付订单接口设计"></a>支付订单接口设计</h5><blockquote>
<p><strong>返回数据：</strong></p>
<ul>
<li>下单时间</li>
<li>订单总金额</li>
<li>订单号</li>
<li>订单id</li>
</ul>
</blockquote>
<h5 id="数据库设计订单表orders、订单明细表order-detail"><a href="#数据库设计订单表orders、订单明细表order-detail" class="headerlink" title="数据库设计订单表orders、订单明细表order_detail"></a>数据库设计<del>订单表orders、订单明细表order_detail</del></h5><ul>
<li>订单表 <strong>orders</strong><ul>
<li>谁的订单？</li>
<li>送哪去？</li>
<li>打哪个电话联系？</li>
<li>多少钱？</li>
<li>什么时间下的单？</li>
<li>什么时间支付的？</li>
<li>订单的状态？</li>
<li>订单号是多少？</li>
</ul>
</li>
<li>订单明细表 <strong>order_detail</strong><ul>
<li>当前明细属于哪个订单？</li>
<li>具体点的是什么商品？</li>
<li>这个商品点了几份？</li>
</ul>
</li>
</ul>
<h4 id="代码开发-4"><a href="#代码开发-4" class="headerlink" title="代码开发"></a>代码开发</h4><h6 id="用户下单1"><a href="#用户下单1" class="headerlink" title="用户下单1"></a>用户下单1</h6><h5 id="根据用户下单接口的参数设计DTO："><a href="#根据用户下单接口的参数设计DTO：" class="headerlink" title="根据用户下单接口的参数设计DTO："></a>根据用户下单接口的参数设计DTO：</h5><pre><code class="java">sky-pojo  com/sky/dto/OrdersSubmitDTO.java
package com.sky.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
public class OrdersSubmitDTO implements Serializable &#123;
    //地址簿id
    private Long addressBookId;
    //付款方式
    private int payMethod;
    //备注
    private String remark;
    //预计送达时间
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime estimatedDeliveryTime;
    //配送状态  1立即送出  0选择具体时间
    private Integer deliveryStatus;
    //餐具数量
    private Integer tablewareNumber;
    //餐具数量状态  1按餐量提供  0选择具体数量
    private Integer tablewareStatus;
    //打包费
    private Integer packAmount;
    //总金额
    private BigDecimal amount;
&#125;
</code></pre>
<pre><code class="java">sky-pojo  com/sky/vo/OrdersSubmitVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
package com.sky.controller.user;

import com.sky.dto.OrdersSubmitDTO;
import com.sky.result.Result;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController(&quot;userOrderController&quot;)
@RequestMapping(&quot;/user/order&quot;)
@Api(tags = &quot;用户订单相关接口&quot;)
@Slf4j
public class OrderController &#123;
    @Autowired
    private OrderService orderService;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @PostMapping(&quot;/submit&quot;)
    @ApiOperation(&quot;用户下单&quot;)
    public Result&lt;OrderSubmitVO&gt; submit(@RequestBody OrdersSubmitDTO ordersSubmitDTO) &#123;
        log.info(&quot;用户下单,参数为：&#123;&#125;&quot;, ordersSubmitDTO);
        OrderSubmitVO orderSubmitVO = orderService.submitOrder(ordersSubmitDTO);
        return Result.success(orderSubmitVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderSubmitVO implements Serializable &#123;
    //订单id
    private Long id;
    //订单号
    private String orderNumber;
    //订单金额
    private BigDecimal orderAmount;
    //下单时间
    private LocalDateTime orderTime;
&#125;
</code></pre>
<h6 id="用户下单2"><a href="#用户下单2" class="headerlink" title="用户下单2"></a>用户下单2</h6><pre><code class="java">sky-pojo  com/sky/entity/AddressBook.java
package com.sky.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 地址簿
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AddressBook implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    private Long id;

    //用户id
    private Long userId;

    //收货人
    private String consignee;

    //手机号
    private String phone;

    //性别 0 女 1 男
    private String sex;

    //省级区划编号
    private String provinceCode;

    //省级名称
    private String provinceName;

    //市级区划编号
    private String cityCode;

    //市级名称
    private String cityName;

    //区级区划编号
    private String districtCode;

    //区级名称
    private String districtName;

    //详细地址
    private String detail;

    //标签
    private String label;

    //是否默认 0否 1是
    private Integer isDefault;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Override
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        // 3.向订单明细表插入n条数据

        // 4,清空当前用户的购物车数据

        // 5.封装VO返回结果
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface OrderMapper &#123;
    /**
     * 用户下单
     * @param orders
     */
    void insert(Orders orders);
&#125;
</code></pre>
<h5 id="代码开发3"><a href="#代码开发3" class="headerlink" title="代码开发3"></a>代码开发3</h5><pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.MessageConstant;
import com.sky.context.BaseContext;
import com.sky.dto.OrdersSubmitDTO;
import com.sky.entity.AddressBook;
import com.sky.entity.OrderDetail;
import com.sky.entity.Orders;
import com.sky.entity.ShoppingCart;
import com.sky.exception.AddressBookBusinessException;
import com.sky.exception.ShoppingCartBusinessException;
import com.sky.mapper.AddressBookMapper;
import com.sky.mapper.OrderDetailMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.ShoppingCartMapper;
import com.sky.service.OrderService;
import com.sky.vo.OrderSubmitVO;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private OrderDetailMapper orderDetailMapper;
    @Autowired
    private AddressBookMapper addressBookMapper;
    @Autowired
    private ShoppingCartMapper shoppingCartMapper;
    /**
     * 用户下单
     * @param ordersSubmitDTO
     * @return
     */
    @Transactional
    public OrderSubmitVO submitOrder(OrdersSubmitDTO ordersSubmitDTO) &#123;

        // 1.处理各种业务异常(地址簿为空，购物车数据为空)
        AddressBook addressBook = addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());
        if (addressBook == null) &#123;
            // 抛出业务异常
            throw new AddressBookBusinessException(MessageConstant.ADDRESS_BOOK_IS_NULL);
        &#125;
        // 查询当前用户购物车信息
        Long userId = BaseContext.getCurrentId();
        ShoppingCart shoppingCart = new ShoppingCart();
        shoppingCart.setUserId(userId);
        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);
        if (shoppingCartList == null || shoppingCartList.size() == 0) &#123;
            // 抛出业务异常
            throw new ShoppingCartBusinessException(MessageConstant.SHOPPING_CART_IS_NULL);
        &#125;

        // 2.向订单表插入1条数据
        Orders orders = new Orders();
        BeanUtils.copyProperties(ordersSubmitDTO, orders);
        orders.setOrderTime(LocalDateTime.now());
        orders.setPayStatus(Orders.UN_PAID);
        orders.setStatus(Orders.PENDING_PAYMENT);
        orders.setNumber(String.valueOf(System.currentTimeMillis()));//订单号
        orders.setPhone(addressBook.getPhone());
        orders.setConsignee(addressBook.getConsignee());
        orders.setUserId(userId);
        orderMapper.insert(orders);

        //批量插入订单明细数据
        List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();
        // 3.向订单明细表插入n条数据
        for (ShoppingCart cart : shoppingCartList) &#123;
            OrderDetail orderDetail = new OrderDetail(); //订单明细
            BeanUtils.copyProperties(cart, orderDetail);
            orderDetail.setOrderId(orders.getId()); //设置当前订单明细关联的订单id
            orderDetailList.add(orderDetail);
        &#125;
        orderDetailMapper.insertBatch(orderDetailList);
        // 4.清空当前用户的购物车数据
        shoppingCartMapper.deleteByUserId(userId);
        // 5.封装VO返回结果
        OrderSubmitVO ordersubmitVO = OrderSubmitVO.builder()
                .id(orders.getId())
                .orderNumber(orders.getNumber())
                .orderAmount(orders.getAmount())
                .orderTime(orders.getOrderTime())
                .build();
        return ordersubmitVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderDetailMapper.java
package com.sky.mapper;

import com.sky.entity.OrderDetail;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

@Mapper
public interface OrderDetailMapper &#123;
    /**
     * 批量插入订单明细数据
     */
    void insertBatch(List&lt;OrderDetail&gt; orderDetailList);
&#125;
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderDetailMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderDetailMapper&quot;&gt;

    &lt;insert id=&quot;insertBatch&quot;&gt;
        insert into order_detail (name, image, order_id, dish_id, setmeal_id, dish_flavor, number, amount)
        values
        &lt;foreach collection=&quot;orderDetailList&quot; item=&quot;od&quot; separator=&quot;,&quot;&gt;
            (#&#123;od.name&#125;,#&#123;od.image&#125;,#&#123;od.orderId&#125;,#&#123;od.dishId&#125;,#&#123;od.setmealId&#125;,#&#123;od.dishFlavor&#125;,#&#123;od.number&#125;,#&#123;od.amount&#125;)
        &lt;/foreach&gt;
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h3><h5 id="微信支付产品-微信支付"><a href="#微信支付产品-微信支付" class="headerlink" title="微信支付产品 + 微信支付"></a>微信支付产品 + 微信支付</h5><p>参考：<a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p>
<h5 id="微信支付接入流程："><a href="#微信支付接入流程：" class="headerlink" title="微信支付接入流程："></a>微信支付接入流程：</h5><p>提交资料 → 签署协议 → 绑定场景</p>
<h6 id="微信小程序支付时序图："><a href="#微信小程序支付时序图：" class="headerlink" title="微信小程序支付时序图："></a>微信小程序支付时序图：</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/a0ad040fbbc2a25f299e2b9b93c5386ced4068ea/data/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg"></p>
<p><strong>JSAPI下单：</strong>商户系统调用该接口在微信支付服务后台生成预支付交易单</p>
<blockquote>
<p><strong>请求URL</strong>：<a target="_blank" rel="noopener" href="https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi">https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi</a></p>
</blockquote>
<h5 id="获取微信支付平台证书、商户私钥文件："><a href="#获取微信支付平台证书、商户私钥文件：" class="headerlink" title="获取微信支付平台证书、商户私钥文件："></a>获取微信支付平台证书、商户私钥文件：</h5><h4 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h4><blockquote>
<p>E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day08\安装包<code>cpolar_amd64.msi</code></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dashboard.cpolar.com/auth">cpolar - secure introspectable tunnels to localhost</a><br>验证<br>你的隧道<br>[复制token] → 在cpolar文件里&#x2F;cmd[C:\Program Files\cpolar] → cpolar.exe authtoken xxxx[Authtoken：这个是在网站验证里复制的] → cpolar.exe http 8080</p>
<p>cpolar by @bestexpresser                                                                                (Ctrl+C to quit)</p>
<p>Tunnel Status       online<br>Account             Pluminary (Plan: Free)<br>Version             2.86.16&#x2F;3.18<br>Web Interface       127.0.0.1:4042<br>Forwarding          <a target="_blank" rel="noopener" href="http://22d34b67.r9.cpolar.top/">http://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a><br>Forwarding          <a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/">https://22d34b67.r9.cpolar.top</a> -&gt; <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Conn              0</p>
<p>Avg Conn Time       0.00ms</p>
<p>启动穿透地址：[22d34b67.r9.cpolar.top&#x2F;doc.html] (<a target="_blank" rel="noopener" href="https://22d34b67.r9.cpolar.top/doc.html">https://22d34b67.r9.cpolar.top/doc.html</a>)</p>
<p>此时正在下载资源<br>HTTP Requests</p>
<hr>
<p>GET &#x2F;v2&#x2F;api-docs              200<br>GET &#x2F;swagger-resources        200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-3b888a6 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-589faee 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-2d0bd79 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0fd6771 200<br>GET &#x2F;webjars&#x2F;js&#x2F;chunk-0c58d94 200<br>GET &#x2F;webjars&#x2F;css&#x2F;chunk-62d2fe 200<br>GET &#x2F;webjars&#x2F;js&#x2F;app.0f2f48b5. 200</p>
<p>随后就可以访问到接口文档了！！<br><strong>原理：使用内网穿透工具临时获得一个域名</strong></p>
</blockquote>
<blockquote>
<p><strong>CPolar</strong> 和 <strong>SwitchHosts</strong> 是两种不同类型的软件，它们的功能和用途有所区别。</p>
<p>CPolar 是一款内网穿透软件，主要用于将本地运行的服务暴露到公网上，使得外网可以访问。它通过在本地和公网服务器之间建立一个安全的隧道，使得用户可以在任何地方通过互联网访问到本地的服务，比如网站、SSH、数据库等。</p>
<p>SwitchHosts 则是一款用于管理和切换本地hosts文件的软件。Hosts文件是操作系统用于将一些域名解析到特定的IP地址的一个文本文件。SwitchHosts 允许用户方便地添加、切换、备份不同的hosts规则，对于开发者来说，这在开发过程中进行域名映射和测试非常有用。</p>
<p>总结来说，CPolar主要用于内网穿透，而SwitchHosts用于hosts文件管理。两者解决的问题和适用场景不同，不是同一种软件。</p>
<hr>
<p>内网、公网、外网和CPolar这几个概念在网络通信中扮演着不同的角色，以下是它们的定义和它们之间的联系：</p>
<ol>
<li>内网（Local Network 或 Intranet）： 内网是指一个私有网络，通常是在家庭、办公室或企业内部使用。内网中的设备通常通过路由器连接，并使用私有IP地址（如192.168.x.x或10.x.x.x）。内网中的设备一般不能直接从外部互联网访问，它们之间的通信受到防火墙和NAT（网络地址转换）的保护。</li>
<li>公网（Public Network 或 Internet）： 公网是指全球范围内的开放网络，即互联网。公网上的设备使用公网IP地址，这些地址是全球唯一的，可以通过互联网被其他设备访问。网站、电子邮件服务器和其他在线服务都部署在公网上。</li>
<li>外网（External Network）： 外网通常是指相对于内网而言的任何外部网络，特别是指互联网。当说“外网”时，通常是指从内网之外访问的资源或服务。</li>
<li>CPolar： CPolar是一款内网穿透工具，它的主要作用是帮助内网中的设备暴露服务到公网上，使得这些服务可以被外网访问。以下是CPolar与内网、公网、外网之间的联系：</li>
</ol>
<ul>
<li>内网到公网：CPolar在本地设备上运行一个客户端，该客户端与CPolar的服务器建立连接。当外部网络（公网）尝试访问CPolar服务器上配置的特定端口时，CPolar服务器会将这些请求转发到运行CPolar客户端的内网设备上。</li>
<li>公网访问：通过CPolar，内网中的服务可以被赋予一个公网可访问的地址（通常是CPolar服务器的一个子域名或自定义域名），这样外网的任何用户都可以通过这个地址访问到内网的服务。</li>
</ul>
<p>简而言之，CPolar是实现内网服务与公网之间通信的桥梁，它使得原本只能在局域网内部访问的服务能够被外网的用户访问。这对于远程工作、调试、以及需要在公网上提供服务的内网应用来说非常有用</p>
</blockquote>
<h5 id="导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】"><a href="#导入功能代码【由于没有微信凭证-此接口未能正常开发-但代码均可学习】" class="headerlink" title="导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】"></a>导入功能代码【由于没有微信凭证 此接口未能正常开发 但代码均可学习】</h5><pre><code class="yaml">sky-server  application-dev.yml
 wechat:
    appid: wxffb3637a228223b8
    secret: 84311df9199ecacdf4f12d27b6b9522d
    mchid : 1561414331
    mchSerialNo: 4B3B3DC35414AD50B1B755BAF8DE9CC7CF407606
    privateKeyFilePath: D:\pay\apiclient_key.pem
    apiV3Key: CZBK51236435wxpay435434323FFDuv3
    weChatPayCertFilePath: D:\pay\wechatpay_166D96F876F45C7D07CE98952A96EC980368ACFC.pem
    notifyUrl: https://58869fb.r2.cpolar.top/notify/paySuccess
    refundNotifyUrl: https://58869fb.r2.cpolar.top/notify/refundSuccess
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/user/OrderController.java
/**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    @PutMapping(&quot;/payment&quot;)
    @ApiOperation(&quot;订单支付&quot;)
    public Result&lt;OrderPaymentVO&gt; payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        log.info(&quot;订单支付：&#123;&#125;&quot;, ordersPaymentDTO);
        OrderPaymentVO orderPaymentVO = orderService.payment(ordersPaymentDTO);
        log.info(&quot;生成预支付交易单：&#123;&#125;&quot;, orderPaymentVO);
        return Result.success(orderPaymentVO);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/OrderService.java
/**
     * 订单支付
     * @param ordersPaymentDTO
     * @return
     */
    OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception;

    /**
     * 支付成功，修改订单状态
     * @param outTradeNo
     */
    void paySuccess(String outTradeNo);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 @Autowired
    private UserMapper userMapper;
 @Autowired
    private WeChatPayUtil weChatPayUtil;

    
    /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.CONFIRMED);

        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;
    &#125;
    /**
     * 支付成功，修改订单状态
     *
     * @param outTradeNo
     */
    public void paySuccess(String outTradeNo) &#123;
        // 当前登录用户id
        Long userId = BaseContext.getCurrentId();

        // 根据订单号查询当前用户的订单
        Orders ordersDB = orderMapper.getByNumberAndUserId(outTradeNo, userId);

        // 根据订单id更新订单的状态、支付方式、支付状态、结账时间
        Orders orders = Orders.builder()
                .id(ordersDB.getId())
                .status(Orders.TO_BE_CONFIRMED)
                .payStatus(Orders.PAID)
                .checkoutTime(LocalDateTime.now())
                .build();

        orderMapper.update(orders);
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
package com.sky.mapper;

import com.github.pagehelper.Page;
import com.sky.dto.GoodsSalesDTO;
import com.sky.dto.OrdersPageQueryDTO;
import com.sky.entity.Orders;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Mapper
public interface OrderMapper &#123;
    /**
     * 插入订单数据
     * @param order
     */
    void insert(Orders order);

    /**
     * 根据订单号和用户id查询订单
     * @param orderNumber
     * @param userId
     */
    @Select(&quot;select * from orders where number = #&#123;orderNumber&#125; and user_id= #&#123;userId&#125;&quot;)
    Orders getByNumberAndUserId(String orderNumber, Long userId);

    /**
     * 修改订单信息
     * @param orders
     */
    void update(Orders orders);
    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id = #&#123;id&#125;&#125;&quot;)
    Orders getById(Long id);
&#125;
</code></pre>
<pre><code class="xml">resources/mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;
        
        &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
  @Select(&quot;select * from user where id = #&#123;id&#125;&#125;&quot;)
    User getById(Long userId);
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/notify/PayNotifyController.java
package com.sky.controller.notify;

import com.alibaba.druid.support.json.JSONUtils;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
//import com.sky.annotation.IgnoreToken;
import com.sky.properties.WeChatProperties;
import com.sky.service.OrderService;
import com.wechat.pay.contrib.apache.httpclient.util.AesUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.entity.ContentType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.BufferedReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * 支付回调相关接口
 */
@RestController
@RequestMapping(&quot;/notify&quot;)
@Slf4j
public class PayNotifyController &#123;
    @Autowired
    private OrderService orderService;
    @Autowired
    private WeChatProperties weChatProperties;

    /**
     * 支付成功回调
     *
     * @param request
     */
//  @IgnoreToken
    @RequestMapping(&quot;/paySuccess&quot;)
    public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        //读取数据
        String body = readData(request);
        log.info(&quot;支付成功回调：&#123;&#125;&quot;, body);

        //数据解密
        String plainText = decryptData(body);
        log.info(&quot;解密后的文本：&#123;&#125;&quot;, plainText);

        JSONObject jsonObject = JSON.parseObject(plainText);
        String outTradeNo = jsonObject.getString(&quot;out_trade_no&quot;);//商户平台订单号
        String transactionId = jsonObject.getString(&quot;transaction_id&quot;);//微信支付交易号

        log.info(&quot;商户平台订单号：&#123;&#125;&quot;, outTradeNo);
        log.info(&quot;微信支付交易号：&#123;&#125;&quot;, transactionId);

        //业务处理，修改订单状态、来单提醒
        orderService.paySuccess(outTradeNo);

        //给微信响应
        responseToWeixin(response);
    &#125;

    /**
     * 读取数据
     *
     * @param request
     * @return
     * @throws Exception
     */
    private String readData(HttpServletRequest request) throws Exception &#123;
        BufferedReader reader = request.getReader();
        StringBuilder result = new StringBuilder();
        String line = null;
        while ((line = reader.readLine()) != null) &#123;
            if (result.length() &gt; 0) &#123;
                result.append(&quot;\n&quot;);
            &#125;
            result.append(line);
        &#125;
        return result.toString();
    &#125;

    /**
     * 数据解密
     *
     * @param body
     * @return
     * @throws Exception
     */
    private String decryptData(String body) throws Exception &#123;
        JSONObject resultObject = JSON.parseObject(body);
        JSONObject resource = resultObject.getJSONObject(&quot;resource&quot;);
        String ciphertext = resource.getString(&quot;ciphertext&quot;);
        String nonce = resource.getString(&quot;nonce&quot;);
        String associatedData = resource.getString(&quot;associated_data&quot;);

        AesUtil aesUtil = new AesUtil(weChatProperties.getApiV3Key().getBytes(StandardCharsets.UTF_8));
        //密文解密
        String plainText = aesUtil.decryptToString(associatedData.getBytes(StandardCharsets.UTF_8),
                nonce.getBytes(StandardCharsets.UTF_8),
                ciphertext);

        return plainText;
    &#125;

    /**
     * 给微信响应
     * @param response
     */
    private void responseToWeixin(HttpServletResponse response) throws Exception&#123;
        response.setStatus(200);
        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;, &quot;SUCCESS&quot;);
        map.put(&quot;message&quot;, &quot;SUCCESS&quot;);
        response.setHeader(&quot;Content-type&quot;, ContentType.APPLICATION_JSON.toString());
        response.getOutputStream().write(JSONUtils.toJSONString(map).getBytes(StandardCharsets.UTF_8));
        response.flushBuffer();
    &#125;
&#125;
</code></pre>
<h3 id="查询历史订单"><a href="#查询历史订单" class="headerlink" title="查询历史订单"></a>查询历史订单</h3><p>业务规则</p>
<ul>
<li>分页查询历史订单</li>
<li>可以根据订单状态查询</li>
<li>展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）</li>
</ul>
<p>接口设计：参见接口文档</p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><h4 id="1-2-1-user-x2F-OrderController"><a href="#1-2-1-user-x2F-OrderController" class="headerlink" title="1.2.1 user&#x2F;OrderController"></a>1.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 历史订单查询
     *
     * @param page
     * @param pageSize
     * @param status   订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
     * @return
     */
    @GetMapping(&quot;/historyOrders&quot;)
    @ApiOperation(&quot;历史订单查询&quot;)
    public Result&lt;PageResult&gt; page(int page, int pageSize, Integer status) &#123;
        PageResult pageResult = orderService.pageQuery4User(page, pageSize, status);
        return Result.success(pageResult);
    &#125;
</code></pre>
<h4 id="1-2-2-OrderService"><a href="#1-2-2-OrderService" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户端订单分页查询
     * @param page
     * @param pageSize
     * @param status
     * @return
     */
    PageResult pageQuery4User(int page, int pageSize, Integer status);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl"><a href="#1-2-3-OrderServiceImpl" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">/**
     * 用户端订单分页查询
     *
     * @param pageNum
     * @param pageSize
     * @param status
     * @return
     */
    public PageResult pageQuery4User(int pageNum, int pageSize, Integer status) &#123;
        // 设置分页
        PageHelper.startPage(pageNum, pageSize);

        OrdersPageQueryDTO ordersPageQueryDTO = new OrdersPageQueryDTO();
        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());
        ordersPageQueryDTO.setStatus(status);

        // 分页条件查询
        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        List&lt;OrderVO&gt; list = new ArrayList();

        // 查询出订单明细，并封装入OrderVO进行响应
        if (page != null &amp;&amp; page.getTotal() &gt; 0) &#123;
            for (Orders orders : page) &#123;
                Long orderId = orders.getId();// 订单id

                // 查询订单明细
                List&lt;OrderDetail&gt; orderDetails = orderDetailMapper.getByOrderId(orderId);

                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                orderVO.setOrderDetailList(orderDetails);

                list.add(orderVO);
            &#125;
        &#125;
        return new PageResult(page.getTotal(), list);
    &#125;
</code></pre>
<h4 id="1-2-4-OrderMapper"><a href="#1-2-4-OrderMapper" class="headerlink" title="1.2.4 OrderMapper"></a>1.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 分页条件查询并按下单时间排序
     * @param ordersPageQueryDTO
     */
    Page&lt;Orders&gt; pageQuery(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-5-OrderMapper-xml"><a href="#1-2-5-OrderMapper-xml" class="headerlink" title="1.2.5 OrderMapper.xml"></a>1.2.5 OrderMapper.xml</h4><pre><code class="xml">    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
</code></pre>
<h4 id="1-2-6-OrderDetailMapper"><a href="#1-2-6-OrderDetailMapper" class="headerlink" title="1.2.6 OrderDetailMapper"></a>1.2.6 OrderDetailMapper</h4><pre><code class="java">    /**
     * 根据订单id查询订单明细
     * @param orderId
     * @return
     */
    @Select(&quot;select * from order_detail where order_id = #&#123;orderId&#125;&quot;)
    List&lt;OrderDetail&gt; getByOrderId(Long orderId);
</code></pre>
<h3 id="查询订单详情"><a href="#查询订单详情" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><h4 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h4><h6 id="2-2-1-user-x2F-OrderController"><a href="#2-2-1-user-x2F-OrderController" class="headerlink" title="2.2.1 user&#x2F;OrderController"></a>2.2.1 user&#x2F;OrderController</h6><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/orderDetail/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService"><a href="#2-2-2-OrderService" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 查询订单详情
     * @param id
     * @return
     */
    OrderVO details(Long id);
</code></pre>
<h4 id="2-2-3-OrderServiceImpl"><a href="#2-2-3-OrderServiceImpl" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 查询订单详情
     *
     * @param id
     * @return
     */
    public OrderVO details(Long id) &#123;
        // 根据id查询订单
        Orders orders = orderMapper.getById(id);

        // 查询该订单对应的菜品/套餐明细
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将该订单及其详情封装到OrderVO并返回
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(orders, orderVO);
        orderVO.setOrderDetailList(orderDetailList);

        return orderVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper"><a href="#2-2-4-OrderMapper" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据id查询订单
     * @param id
     */
    @Select(&quot;select * from orders where id=#&#123;id&#125;&quot;)
    Orders getById(Long id);
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><p>业务规则：</p>
<ul>
<li>待支付和待接单状态下，用户可直接取消订单</li>
<li>商家已接单状态下，用户取消订单需电话沟通商家</li>
<li>派送中状态下，用户取消订单需电话沟通商家</li>
<li>如果在待接单状态下取消订单，需要给用户退款</li>
<li>取消订单后需要将订单状态修改为“已取消”</li>
</ul>
<h4 id="3-2-1-user-x2F-OrderController"><a href="#3-2-1-user-x2F-OrderController" class="headerlink" title="3.2.1 user&#x2F;OrderController"></a>3.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel/&#123;id&#125;&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@PathVariable(&quot;id&quot;) Long id) throws Exception &#123;
        orderService.userCancelById(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="3-2-2-OrderService"><a href="#3-2-2-OrderService" class="headerlink" title="3.2.2 OrderService"></a>3.2.2 OrderService</h4><pre><code class="java">    /**
     * 用户取消订单
     * @param id
     */
    void userCancelById(Long id) throws Exception;
</code></pre>
<h4 id="3-2-3-OrderServiceImpl"><a href="#3-2-3-OrderServiceImpl" class="headerlink" title="3.2.3 OrderServiceImpl"></a>3.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 用户取消订单
     *
     * @param id
     */
    public void userCancelById(Long id) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_NOT_FOUND);
        &#125;

        //订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消
        if (ordersDB.getStatus() &gt; 2) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());

        // 订单处于待接单状态下取消，需要进行退款
        if (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            //调用微信支付退款接口
            weChatPayUtil.refund(
                    ordersDB.getNumber(), //商户订单号
                    ordersDB.getNumber(), //商户退款单号
                    new BigDecimal(0.01),//退款金额，单位 元
                    new BigDecimal(0.01));//原订单金额

            //支付状态修改为 退款
            orders.setPayStatus(Orders.REFUND);
        &#125;

        // 更新订单状态、取消原因、取消时间
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(&quot;用户取消&quot;);
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="再来一单"><a href="#再来一单" class="headerlink" title="再来一单"></a>再来一单</h3><h4 id="4-2-1-user-x2F-OrderController"><a href="#4-2-1-user-x2F-OrderController" class="headerlink" title="4.2.1 user&#x2F;OrderController"></a>4.2.1 user&#x2F;OrderController</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     * @return
     */
    @PostMapping(&quot;/repetition/&#123;id&#125;&quot;)
    @ApiOperation(&quot;再来一单&quot;)
    public Result repetition(@PathVariable Long id) &#123;
        orderService.repetition(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService"><a href="#4-2-2-OrderService" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
    void repetition(Long id);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl"><a href="#4-2-3-OrderServiceImpl" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 再来一单
     *
     * @param id
     */
   @Override
    public void repetition(Long id) &#123;
        //查询当前用户id
        Long userId = BaseContext.getCurrentId();
        //根据订单id查询当前订单详情
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(id);

        // 将订单详情对象转换为购物车对象
        // 这一行使用 map 方法对每个 OrderDetail 对象进行转换操作，x 是当前遍历的 OrderDetail 对象
        List&lt;ShoppingCart&gt; shoppingCartList = orderDetailList.stream().map(x -&gt; &#123;
            //表示一个函数，该函数接受一个参数 x 并返回一个新对象
            ShoppingCart shoppingCart = new ShoppingCart();

            // 将原订单详情里面的菜品信息重新复制到购物车对象中
            BeanUtils.copyProperties(x, shoppingCart, &quot;id&quot;);
            shoppingCart.setUserId(userId);
            shoppingCart.setCreateTime(LocalDateTime.now());

            return shoppingCart;
        &#125;).collect(Collectors.toList());
// 使用 collect 方法将转换后的 ShoppingCart 对象收集到一个新的 List&lt;ShoppingCart&gt; 列表中
        // 将购物车对象批量添加到数据库
        shoppingCartMapper.insertBatch(shoppingCartList);
    &#125;
</code></pre>
<h4 id="4-2-4-ShoppingCartMapper"><a href="#4-2-4-ShoppingCartMapper" class="headerlink" title="4.2.4 ShoppingCartMapper"></a>4.2.4 ShoppingCartMapper</h4><pre><code class="java">    /**
     * 批量插入购物车数据
     *
     * @param shoppingCartList
     */
    void insertBatch(List&lt;ShoppingCart&gt; shoppingCartList);
</code></pre>
<h4 id="4-2-5-ShoppingCartMapper-xml"><a href="#4-2-5-ShoppingCartMapper-xml" class="headerlink" title="4.2.5 ShoppingCartMapper.xml"></a>4.2.5 ShoppingCartMapper.xml</h4><pre><code class="xml">&lt;insert id=&quot;insertBatch&quot; parameterType=&quot;list&quot;&gt;
        insert into shopping_cart
        (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)
        values
        &lt;foreach collection=&quot;shoppingCartList&quot; item=&quot;sc&quot; separator=&quot;,&quot;&gt;
            
        &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>
<h3 id="订单搜索"><a href="#订单搜索" class="headerlink" title="订单搜索"></a>订单搜索</h3><h4 id="1-2-1-admin-x2F-OrderController"><a href="#1-2-1-admin-x2F-OrderController" class="headerlink" title="1.2.1 admin&#x2F;OrderController"></a>1.2.1 admin&#x2F;OrderController</h4><p>在admin包下创建OrderController</p>
<pre><code class="java">/**
 * 订单管理
 */
@RestController(&quot;adminOrderController&quot;)
@RequestMapping(&quot;/admin/order&quot;)
@Slf4j
@Api(tags = &quot;订单管理接口&quot;)
public class OrderController &#123;

    @Autowired
    private OrderService orderService;

    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    @GetMapping(&quot;/conditionSearch&quot;)
    @ApiOperation(&quot;订单搜索&quot;)
    public Result&lt;PageResult&gt; conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageResult pageResult = orderService.conditionSearch(ordersPageQueryDTO);
        return Result.success(pageResult);
    &#125;
&#125;
</code></pre>
<h4 id="1-2-2-OrderService-1"><a href="#1-2-2-OrderService-1" class="headerlink" title="1.2.2 OrderService"></a>1.2.2 OrderService</h4><pre><code class="java">    /**
     * 条件搜索订单
     * @param ordersPageQueryDTO
     * @return
     */
    PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO);
</code></pre>
<h4 id="1-2-3-OrderServiceImpl-1"><a href="#1-2-3-OrderServiceImpl-1" class="headerlink" title="1.2.3 OrderServiceImpl"></a>1.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 订单搜索
     *
     * @param ordersPageQueryDTO
     * @return
     */
    public PageResult conditionSearch(OrdersPageQueryDTO ordersPageQueryDTO) &#123;
        PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());

        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);

        // 部分订单状态，需要额外返回订单菜品信息，将Orders转化为OrderVO
        List&lt;OrderVO&gt; orderVOList = getOrderVOList(page);

        return new PageResult(page.getTotal(), orderVOList);
    &#125;

    private List&lt;OrderVO&gt; getOrderVOList(Page&lt;Orders&gt; page) &#123;
        // 需要返回订单菜品信息，自定义OrderVO响应结果
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();

        List&lt;Orders&gt; ordersList = page.getResult();
        if (!CollectionUtils.isEmpty(ordersList)) &#123;
            for (Orders orders : ordersList) &#123;
                // 将共同字段复制到OrderVO
                OrderVO orderVO = new OrderVO();
                BeanUtils.copyProperties(orders, orderVO);
                String orderDishes = getOrderDishesStr(orders);

                // 将订单菜品信息封装到orderVO中，并添加到orderVOList
                orderVO.setOrderDishes(orderDishes);
                orderVOList.add(orderVO);
            &#125;
        &#125;
        return orderVOList;
    &#125;

    /**
     * 根据订单id获取菜品信息字符串
     *
     * @param orders
     * @return
     */
    private String getOrderDishesStr(Orders orders) &#123;
        // 查询订单菜品详情信息（订单中的菜品和数量）
        List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());

        // 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）
        List&lt;String&gt; orderDishList = orderDetailList.stream().map(x -&gt; &#123;
            String orderDish = x.getName() + &quot;*&quot; + x.getNumber() + &quot;;&quot;;
            return orderDish;
        &#125;).collect(Collectors.toList());

        // 将该订单对应的所有菜品信息拼接在一起
        return String.join(&quot;&quot;, orderDishList);
    &#125;
</code></pre>
<h3 id="各个状态的订单数量统计"><a href="#各个状态的订单数量统计" class="headerlink" title="各个状态的订单数量统计"></a>各个状态的订单数量统计</h3><h4 id="2-2-1-admin-x2F-OrderController"><a href="#2-2-1-admin-x2F-OrderController" class="headerlink" title="2.2.1 admin&#x2F;OrderController"></a>2.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    @GetMapping(&quot;/statistics&quot;)
    @ApiOperation(&quot;各个状态的订单数量统计&quot;)
    public Result&lt;OrderStatisticsVO&gt; statistics() &#123;
        OrderStatisticsVO orderStatisticsVO = orderService.statistics();
        return Result.success(orderStatisticsVO);
    &#125;
</code></pre>
<h4 id="2-2-2-OrderService-1"><a href="#2-2-2-OrderService-1" class="headerlink" title="2.2.2 OrderService"></a>2.2.2 OrderService</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     * @return
     */
    OrderStatisticsVO statistics();
</code></pre>
<h4 id="2-2-3-OrderServiceImpl-1"><a href="#2-2-3-OrderServiceImpl-1" class="headerlink" title="2.2.3 OrderServiceImpl"></a>2.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 各个状态的订单数量统计
     *
     * @return
     */
    public OrderStatisticsVO statistics() &#123;
        // 根据状态，分别查询出待接单、待派送、派送中的订单数量
        Integer toBeConfirmed = orderMapper.countStatus(Orders.TO_BE_CONFIRMED);
        Integer confirmed = orderMapper.countStatus(Orders.CONFIRMED);
        Integer deliveryInProgress = orderMapper.countStatus(Orders.DELIVERY_IN_PROGRESS);

        // 将查询出的数据封装到orderStatisticsVO中响应
        OrderStatisticsVO orderStatisticsVO = new OrderStatisticsVO();
        orderStatisticsVO.setToBeConfirmed(toBeConfirmed);
        orderStatisticsVO.setConfirmed(confirmed);
        orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);
        return orderStatisticsVO;
    &#125;
</code></pre>
<h4 id="2-2-4-OrderMapper-1"><a href="#2-2-4-OrderMapper-1" class="headerlink" title="2.2.4 OrderMapper"></a>2.2.4 OrderMapper</h4><pre><code class="java">    /**
     * 根据状态统计订单数量
     * @param status
     */
    @Select(&quot;select count(id) from orders where status = #&#123;status&#125;&quot;)
    Integer countStatus(Integer status);
</code></pre>
<h3 id="查询订单详情-1"><a href="#查询订单详情-1" class="headerlink" title="查询订单详情"></a>查询订单详情</h3><p>业务规则：</p>
<ul>
<li>订单详情页面需要展示订单基本信息（状态、订单号、下单时间、收货人、电话、收货地址、金额等）</li>
<li>订单详情页面需要展示订单明细数据（商品名称、数量、单价）</li>
</ul>
<h4 id="3-2-1-admin-x2F-OrderController"><a href="#3-2-1-admin-x2F-OrderController" class="headerlink" title="3.2.1 admin&#x2F;OrderController"></a>3.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 订单详情
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/details/&#123;id&#125;&quot;)
    @ApiOperation(&quot;查询订单详情&quot;)
    public Result&lt;OrderVO&gt; details(@PathVariable(&quot;id&quot;) Long id) &#123;
        OrderVO orderVO = orderService.details(id);
        return Result.success(orderVO);
    &#125;
</code></pre>
<h3 id="接单"><a href="#接单" class="headerlink" title="接单"></a>接单</h3><p>业务规则：</p>
<ul>
<li>商家接单其实就是将订单的状态修改为“已接单”</li>
</ul>
<h4 id="4-2-1-admin-x2F-OrderController"><a href="#4-2-1-admin-x2F-OrderController" class="headerlink" title="4.2.1 admin&#x2F;OrderController"></a>4.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 接单
     *
     * @return
     */
    @PutMapping(&quot;/confirm&quot;)
    @ApiOperation(&quot;接单&quot;)
    public Result confirm(@RequestBody OrdersConfirmDTO ordersConfirmDTO) &#123;
        orderService.confirm(ordersConfirmDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="4-2-2-OrderService-1"><a href="#4-2-2-OrderService-1" class="headerlink" title="4.2.2 OrderService"></a>4.2.2 OrderService</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    void confirm(OrdersConfirmDTO ordersConfirmDTO);
</code></pre>
<h4 id="4-2-3-OrderServiceImpl-1"><a href="#4-2-3-OrderServiceImpl-1" class="headerlink" title="4.2.3 OrderServiceImpl"></a>4.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 接单
     *
     * @param ordersConfirmDTO
     */
    public void confirm(OrdersConfirmDTO ordersConfirmDTO) &#123;
        Orders orders = Orders.builder()
                .id(ordersConfirmDTO.getId())
                .status(Orders.CONFIRMED)
                .build();

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="拒单"><a href="#拒单" class="headerlink" title="拒单"></a>拒单</h3><p>业务规则：</p>
<ul>
<li>商家拒单其实就是将订单状态修改为“已取消”</li>
<li>只有订单处于“待接单”状态时可以执行拒单操作</li>
<li>商家拒单时需要指定拒单原因</li>
<li>商家拒单时，如果用户已经完成了支付，需要为用户退款</li>
</ul>
<h4 id="5-2-1-admin-x2F-OrderController"><a href="#5-2-1-admin-x2F-OrderController" class="headerlink" title="5.2.1 admin&#x2F;OrderController"></a>5.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 拒单
     *
     * @return
     */
    @PutMapping(&quot;/rejection&quot;)
    @ApiOperation(&quot;拒单&quot;)
    public Result rejection(@RequestBody OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        orderService.rejection(ordersRejectionDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="5-2-2-OrderService"><a href="#5-2-2-OrderService" class="headerlink" title="5.2.2 OrderService"></a>5.2.2 OrderService</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception;
</code></pre>
<h4 id="5-2-3-OrderServiceImpl"><a href="#5-2-3-OrderServiceImpl" class="headerlink" title="5.2.3 OrderServiceImpl"></a>5.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 拒单
     *
     * @param ordersRejectionDTO
     */
    public void rejection(OrdersRejectionDTO ordersRejectionDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersRejectionDTO.getId());

        // 订单只有存在且状态为2（待接单）才可以拒单
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == Orders.PAID) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());
        orders.setCancelTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="取消订单-1"><a href="#取消订单-1" class="headerlink" title="取消订单"></a>取消订单</h3><h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><h4 id="6-2-1-admin-x2F-OrderController"><a href="#6-2-1-admin-x2F-OrderController" class="headerlink" title="6.2.1 admin&#x2F;OrderController"></a>6.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @return
     */
    @PutMapping(&quot;/cancel&quot;)
    @ApiOperation(&quot;取消订单&quot;)
    public Result cancel(@RequestBody OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        orderService.cancel(ordersCancelDTO);
        return Result.success();
    &#125;
</code></pre>
<h4 id="6-2-2-OrderService"><a href="#6-2-2-OrderService" class="headerlink" title="6.2.2 OrderService"></a>6.2.2 OrderService</h4><pre><code class="java">    /**
     * 商家取消订单
     *
     * @param ordersCancelDTO
     */
    void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception;
</code></pre>
<h4 id="6-2-3-OrderServiceImpl"><a href="#6-2-3-OrderServiceImpl" class="headerlink" title="6.2.3 OrderServiceImpl"></a>6.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 取消订单
     *
     * @param ordersCancelDTO
     */
    public void cancel(OrdersCancelDTO ordersCancelDTO) throws Exception &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(ordersCancelDTO.getId());

        //支付状态
        Integer payStatus = ordersDB.getPayStatus();
        if (payStatus == 1) &#123;
            //用户已支付，需要退款
            String refund = weChatPayUtil.refund(
                    ordersDB.getNumber(),
                    ordersDB.getNumber(),
                    new BigDecimal(0.01),
                    new BigDecimal(0.01));
            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);
        &#125;

        // 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间
        Orders orders = new Orders();
        orders.setId(ordersCancelDTO.getId());
        orders.setStatus(Orders.CANCELLED);
        orders.setCancelReason(ordersCancelDTO.getCancelReason());
        orders.setCancelTime(LocalDateTime.now());
        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="派送订单"><a href="#派送订单" class="headerlink" title="派送订单"></a>派送订单</h3><p>业务规则：</p>
<ul>
<li>派送订单其实就是将订单状态修改为“派送中”</li>
<li>只有状态为“待派送”的订单可以执行派送订单操作</li>
</ul>
<h4 id="7-2-1-admin-x2F-OrderController"><a href="#7-2-1-admin-x2F-OrderController" class="headerlink" title="7.2.1 admin&#x2F;OrderController"></a>7.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @return
     */
    @PutMapping(&quot;/delivery/&#123;id&#125;&quot;)
    @ApiOperation(&quot;派送订单&quot;)
    public Result delivery(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.delivery(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="7-2-2-OrderService"><a href="#7-2-2-OrderService" class="headerlink" title="7.2.2 OrderService"></a>7.2.2 OrderService</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    void delivery(Long id);
</code></pre>
<h4 id="7-2-3-OrderServiceImpl"><a href="#7-2-3-OrderServiceImpl" class="headerlink" title="7.2.3 OrderServiceImpl"></a>7.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 派送订单
     *
     * @param id
     */
    public void delivery(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为3
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.CONFIRMED)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为派送中
        orders.setStatus(Orders.DELIVERY_IN_PROGRESS);

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="完成订单"><a href="#完成订单" class="headerlink" title="完成订单"></a>完成订单</h3><p>业务规则：</p>
<ul>
<li>完成订单其实就是将订单状态修改为“已完成”</li>
<li>只有状态为“派送中”的订单可以执行订单完成操作</li>
</ul>
<h4 id="8-2-1-admin-x2F-OrderController"><a href="#8-2-1-admin-x2F-OrderController" class="headerlink" title="8.2.1 admin&#x2F;OrderController"></a>8.2.1 admin&#x2F;OrderController</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @return
     */
    @PutMapping(&quot;/complete/&#123;id&#125;&quot;)
    @ApiOperation(&quot;完成订单&quot;)
    public Result complete(@PathVariable(&quot;id&quot;) Long id) &#123;
        orderService.complete(id);
        return Result.success();
    &#125;
</code></pre>
<h4 id="8-2-2-OrderService"><a href="#8-2-2-OrderService" class="headerlink" title="8.2.2 OrderService"></a>8.2.2 OrderService</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    void complete(Long id);
</code></pre>
<h4 id="8-2-3-OrderServiceImpl"><a href="#8-2-3-OrderServiceImpl" class="headerlink" title="8.2.3 OrderServiceImpl"></a>8.2.3 OrderServiceImpl</h4><pre><code class="java">    /**
     * 完成订单
     *
     * @param id
     */
    public void complete(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在，并且状态为4
        if (ordersDB == null || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Orders orders = new Orders();
        orders.setId(ordersDB.getId());
        // 更新订单状态,状态转为完成
        orders.setStatus(Orders.COMPLETED);
        orders.setDeliveryTime(LocalDateTime.now());

        orderMapper.update(orders);
    &#125;
</code></pre>
<h3 id="校验收货地址是否超出配送范围"><a href="#校验收货地址是否超出配送范围" class="headerlink" title="校验收货地址是否超出配送范围"></a>校验收货地址是否超出配送范围</h3><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>注册账号：<a target="_blank" rel="noopener" href="https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://passport.baidu.com/v2/?reg&amp;tt=1671699340600&amp;overseas=&amp;gid=CF954C2-A3D2-417F-9FE6-B0F249ED7E33&amp;tpl=pp&amp;u=https%3A%2F%2Flbsyun.baidu.com%2Findex.php%3Ftitle%3D%E9%A6%96%E9%A1%B5</a></p>
<p>登录百度地图开放平台：<a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/">https://lbsyun.baidu.com/</a></p>
<p>进入控制台，创建应用，获取AK：</p>
<p>![image-20221222170049729](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170049729.png)</p>
<p>![image-20221222170256927](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170256927.png)</p>
<p>相关接口:</p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding">https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding</a></p>
<p><a target="_blank" rel="noopener" href="https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1">https://lbsyun.baidu.com/index.php?title=webapi/directionlite-v1</a></p>
<h2 id="2-代码开发"><a href="#2-代码开发" class="headerlink" title="2. 代码开发"></a>2. 代码开发</h2><h3 id="2-1-application-yml"><a href="#2-1-application-yml" class="headerlink" title="2.1 application.yml"></a>2.1 application.yml</h3><p>配置外卖商家店铺地址和百度地图的AK：</p>
<p>![image-20221222170819582](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222170819582.png)</p>
<h3 id="2-2-OrderServiceImpl"><a href="#2-2-OrderServiceImpl" class="headerlink" title="2.2 OrderServiceImpl"></a>2.2 OrderServiceImpl</h3><p>改造OrderServiceImpl，注入上面的配置项：</p>
<pre><code class="java">com/sky/properties/BaiDuProperties.java
package com.sky.properties;

import lombok.Data;
import lombok.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
// 多个prefix
@ConfigurationProperties(prefix = &quot;sky.baidu&quot;)
@Data
public class BaiDuProperties &#123;
    private String shopAddress;
    private String ak;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
  baidu:
    ak: $&#123;sky.baidu.ak&#125;
    shopAddress: $&#123;sky.baidu.shopAddress&#125;
</code></pre>
<pre><code class="yaml">application-dev.yml
  baidu:
    ak: xxxxxxxxx
    shopAddress: 河北省唐山市丰润区燕山路街道美景花园
</code></pre>
<p>在OrderServiceImpl中提供校验方法：</p>
<pre><code class="java">/**
     * 检查客户的收货地址是否超出配送范围
     * @param address
     */
    private void checkOutOfRange(String address) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;address&quot;, baiDuProperties.getShopAddress());
        map.put(&quot;output&quot;, &quot;json&quot;);
        map.put(&quot;ak&quot;, baiDuProperties.getAk());

        //获取店铺的经纬度坐标
        String shopCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        JSONObject jsonObject = JSON.parseObject(shopCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;店铺地址解析失败&quot;);
        &#125;

        //数据解析
        JSONObject location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        String lat = location.getString(&quot;lat&quot;);
        String lng = location.getString(&quot;lng&quot;);
        //店铺经纬度坐标
        String shopLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;address&quot;,address);
        //获取用户收货地址的经纬度坐标
        String userCoordinate = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/geocoding/v3&quot;, map);

        jsonObject = JSON.parseObject(userCoordinate);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;收货地址解析失败&quot;);
        &#125;

        //数据解析
        location = jsonObject.getJSONObject(&quot;result&quot;).getJSONObject(&quot;location&quot;);
        lat = location.getString(&quot;lat&quot;);
        lng = location.getString(&quot;lng&quot;);
        //用户收货地址经纬度坐标
        String userLngLat = lat + &quot;,&quot; + lng;

        map.put(&quot;origin&quot;,shopLngLat);
        map.put(&quot;destination&quot;,userLngLat);
        map.put(&quot;steps_info&quot;,&quot;0&quot;);

        //路线规划
        String json = HttpClientUtil.doGet(&quot;https://api.map.baidu.com/directionlite/v1/driving&quot;, map);

        jsonObject = JSON.parseObject(json);
        if(!jsonObject.getString(&quot;status&quot;).equals(&quot;0&quot;))&#123;
            throw new OrderBusinessException(&quot;配送路线规划失败&quot;);
        &#125;

        //数据解析
        JSONObject result = jsonObject.getJSONObject(&quot;result&quot;);
        JSONArray jsonArray = (JSONArray) result.get(&quot;routes&quot;);
        Integer distance = (Integer) ((JSONObject) jsonArray.get(0)).get(&quot;distance&quot;);

        if(distance &gt; 5000)&#123;
            //配送距离超过5000米
            throw new OrderBusinessException(&quot;超出配送范围&quot;);
        &#125;
    &#125;
</code></pre>
<p>在OrderServiceImpl的submitOrder方法中调用上面的校验方法：</p>
<pre><code class="java">   // 检查用户的收获地址是否超出配送范围
        checkOutOfRange(addressBook.getCityName() + addressBook.getDistrictName() + addressBook.getDetail());
</code></pre>
<p>![image-20221222171444981](E:\Java实例项目1-20套\第24套【项目实战】Java外卖项目实战《苍穹外卖》SpringBoot+SpringMVC+Vue+Swagger+Lombok+Mybatis+SpringSession+Redis+Nginx+小程序\0-0 源码资料\资料\day09\项目实战参考答案\assets\image-20221222171444981.png)</p>
<h3 id="SpringTask-定时任务-定时自动执行某段Java代码"><a href="#SpringTask-定时任务-定时自动执行某段Java代码" class="headerlink" title="SpringTask[定时任务]定时自动执行某段Java代码"></a>SpringTask[定时任务]<del>定时自动执行某段Java代码</del></h3><p>SpringTask是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ul>
<li>信用卡每月还款提醒</li>
<li>银行贷款每月还款提醒</li>
<li>火车票售票系统处理未支付订单</li>
<li>入职纪念日为用户发送通知</li>
</ul>
<h5 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h5><p>cron表达式其实就是一个字符串，通过cron表达式可以<strong>定义任务触发时间</strong><br>构成规则：分为6或7个域，由空格分隔开，每个域代表一个含义<br>每个域的含义分别为：<u>秒、分钟、小时、日、月、周、年</u>(可选)</p>
<h6 id="2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）"><a href="#2022年10月12日上午9点整-对应的cron表达式（日-和-周-不能同时定义）" class="headerlink" title="2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）"></a>2022年10月12日上午9点整 对应的cron表达式（日 和 周 不能同时定义）</h6><p>0 0 9 12 10 ？ 2022<br><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">https://cron.qqe2.com</a></p>
<table>
<thead>
<tr>
<th>秒</th>
<th>分钟</th>
<th>小时</th>
<th>日</th>
<th>月</th>
<th>周</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>？</td>
</tr>
</tbody></table>
<h6 id="SpringTask使用步骤："><a href="#SpringTask使用步骤：" class="headerlink" title="SpringTask使用步骤："></a>SpringTask使用步骤：</h6><ul>
<li>导入maven坐标 spring-context（已存在）</li>
<li>启动类添加注解 <code>@EnableScheduling</code> 开启任务调度</li>
<li><strong>自定义定时任务类</strong></li>
</ul>
<pre><code class="java">sky-server  com/sky/task/MyTask.java
package com.sky.task;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.util.Date;

/**
 * 自定义定时任务类
 */
@Component
@Slf4j
public class MyTask &#123;

    /**
     * 定时任务 每隔5秒触发一次
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void executeTask()&#123;
        log.info(&quot;定时任务开始执行：&#123;&#125;&quot;, new Date());
    &#125;
&#125;
</code></pre>
<h3 id="订单状态定时处理"><a href="#订单状态定时处理" class="headerlink" title="订单状态定时处理"></a>订单状态定时处理</h3><h6 id="用户下单后可能存在的情况："><a href="#用户下单后可能存在的情况：" class="headerlink" title="用户下单后可能存在的情况："></a>用户下单后可能存在的情况：</h6><ul>
<li>下单后未支付，订单一直处于”<strong>待支付</strong>“状态</li>
<li>用户收获后管理端未点击完成按钮，订单一直处于<strong>“派送中”</strong>状态<ul>
<li>通过定时任务<strong>每分钟检查一次</strong>是否存在支付超时订单(超过15min)，如果存在则修改订单状态为”已取消”</li>
<li>通过定时任务<strong>每天凌晨1点检查一次</strong>是否存在”派送中”的订单，如果存在则修改订单状态为”已完成”</li>
</ul>
</li>
</ul>
<h5 id="代码开发：-4"><a href="#代码开发：-4" class="headerlink" title="代码开发："></a>代码开发：</h5><pre><code class="java">sky-server  com/sky/task/OrderTask.java
package com.sky.task;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

@Component
@Slf4j
public class OrderTask &#123;
    @Autowired
    private OrderMapper orderMapper;

    /**
     * 处理超时订单的方法
     */
    @Scheduled(cron = &quot;0 * * * * ?&quot;)//每分钟触发一次
    public void processTimeoutOrder()&#123;
        log.info(&quot;定时处理超时订单&quot;);
        // select * from orders where status = ? and order_time = (当前时间 - 15分钟)
        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.PENDING_PAYMENT, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.CANCELLED);
                orders.setCancelReason(&quot;订单超时，自动取消&quot;);
                orders.setCancelTime(LocalDateTime.now());
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;

    /**
     * 处理一直处于派送中状态的订单
     */
    @Scheduled(cron = &quot;0 0 1 * * ?&quot;)//每天凌晨一点
    public void processDeliveryOrder() &#123;
        log.info(&quot;定时处理处于派送中的订单&quot;);
        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);
        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrderTimeLT(Orders.DELIVERY_IN_PROGRESS, time);
        if (ordersList != null &amp;&amp; ordersList.size() &gt; 0) &#123;
            for (Orders orders : ordersList) &#123;
                orders.setStatus(Orders.COMPLETED);
                orderMapper.update(orders);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
    /**
     *
     * 根据订单状态和下单时间查询订单
     * @param status
     * @param orderTime
     * @return
     */
    @Select(&quot;select * from orders where status = #&#123;status&#125; and order_time &lt; #&#123;orderTime&#125;&quot;)
    List&lt;Orders&gt; getByStatusAndOrderTimeLT(Integer status, LocalDateTime orderTime);
</code></pre>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是基于TCP的一种新的<strong>网络协议</strong>，它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持续性</strong>连接，并进行<strong>双向</strong>数据传输</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/edb75e96dfbeebfac80f0c08ad92001201b8754c/data/WebSocket.png"></p>
<h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><ul>
<li>视频弹幕</li>
<li>网页聊天</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
<h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p><strong>实现步骤：</strong></p>
<ul>
<li>直接使用<strong>websocket.html</strong>页面坐位WebSocket客户端</li>
<li>导入<strong>WebSocket</strong>的maven坐标</li>
<li>导入<strong>WebSocket</strong>服务端组件<strong>WebSocketServer</strong>，用于和客户端通信</li>
<li>导入配置类<strong>WebSocketConfiguration</strong>，注册WebSocket的服务端组件</li>
<li>导入定时人物类<strong>WebSocketTask</strong>，定时向客户端推送数据</li>
</ul>
<pre><code class="html">websocket.html
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;WebSocket Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;
    &lt;button onclick=&quot;send()&quot;&gt;发送消息&lt;/button&gt;
    &lt;button onclick=&quot;closeWebSocket()&quot;&gt;关闭连接&lt;/button&gt;
    &lt;div id=&quot;message&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var websocket = null;
    var clientId = Math.random().toString(36).substr(2);

    //判断当前浏览器是否支持WebSocket
    if(&#39;WebSocket&#39; in window)&#123;
        //连接WebSocket节点
        websocket = new WebSocket(&quot;ws://localhost:8080/ws/&quot;+clientId);
    &#125;
    else&#123;
        alert(&#39;Not support websocket&#39;)
    &#125;

    //连接发生错误的回调方法
    websocket.onerror = function()&#123;
        setMessageInnerHTML(&quot;error&quot;);
    &#125;;

    //连接成功建立的回调方法
    websocket.onopen = function()&#123;
        setMessageInnerHTML(&quot;连接成功&quot;);
    &#125;

    //接收到消息的回调方法
    websocket.onmessage = function(event)&#123;
        setMessageInnerHTML(event.data);
    &#125;

    //连接关闭的回调方法
    websocket.onclose = function()&#123;
        setMessageInnerHTML(&quot;close&quot;);
    &#125;

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function()&#123;
        websocket.close();
    &#125;

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML)&#123;
        document.getElementById(&#39;message&#39;).innerHTML += innerHTML + &#39;&lt;br/&gt;&#39;;
    &#125;

    //发送消息
    function send()&#123;
        var message = document.getElementById(&#39;text&#39;).value;
        websocket.send(message);
    &#125;
    
    //关闭连接
    function closeWebSocket() &#123;
        websocket.close();
    &#125;
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/sky/websocket/WebSocketServer.java
package com.sky.websocket;

import org.springframework.stereotype.Component;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.PathParam;
import javax.websocket.server.ServerEndpoint;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * WebSocket服务
 */
@Component //交给spring容器管理
@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)
public class WebSocketServer &#123;

    //存放会话对象
    private static Map&lt;String, Session&gt; sessionMap = new HashMap();

    /**
     * 连接建立成功调用的方法
     */
    @OnOpen
    public void onOpen(Session session, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;客户端：&quot; + sid + &quot;建立连接&quot;);
        sessionMap.put(sid, session);
    &#125;

    /**
     * 收到客户端消息后调用的方法
     *
     * @param message 客户端发送过来的消息
     */
    @OnMessage
    public void onMessage(String message, @PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;收到来自客户端：&quot; + sid + &quot;的信息:&quot; + message);
    &#125;

    /**
     * 连接关闭调用的方法
     *
     * @param sid
     */
    @OnClose
    public void onClose(@PathParam(&quot;sid&quot;) String sid) &#123;
        System.out.println(&quot;连接断开:&quot; + sid);
        sessionMap.remove(sid);
    &#125;

    /**
     * 群发
     *
     * @param message
     */
    public void sendToAllClient(String message) &#123;
        Collection&lt;Session&gt; sessions = sessionMap.values();
        for (Session session : sessions) &#123;
            try &#123;
                //服务器向客户端发送消息
                session.getBasicRemote().sendText(message);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/config/WebSocketConfiguration.java
package com.sky.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

/**
 * WebSocket配置类，用于注册WebSocket的Bean
 */
@Configuration
public class WebSocketConfiguration &#123;

    @Bean
    public ServerEndpointExporter serverEndpointExporter() &#123;
        return new ServerEndpointExporter();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/sky/task/WebSocketTask.java
package com.sky.task;

import com.sky.websocket.WebSocketServer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class WebSocketTask &#123;
    @Autowired
    private WebSocketServer webSocketServer;

    /**
     * 通过WebSocket每隔5秒向客户端发送消息
     */
    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)
    public void sendMessageToClient() &#123;
        webSocketServer.sendToAllClient(&quot;这是来自服务端的消息：&quot; + DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;).format(LocalDateTime.now()));
    &#125;
&#125;
</code></pre>
<h3 id="来单提醒"><a href="#来单提醒" class="headerlink" title="来单提醒"></a>来单提醒</h3><p>用户下单并且支付成功后，需要第一时间通知外卖商家</p>
<ul>
<li><strong>语音播报</strong></li>
<li><strong>弹出提示框</strong></li>
</ul>
<h6 id="设计："><a href="#设计：" class="headerlink" title="设计："></a>设计：</h6><ul>
<li>通过WebSocket实现管理端页面和服务端保持长连接状态</li>
<li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li>
<li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li>
<li>约定服务器发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul>
<li>type 为消息类型，1为来单提醒  2为客户催单</li>
<li>orderId 为订单id</li>
<li>content 为消息内容</li>
</ul>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/service/impl/OrderServiceImpl.java
 /**
     * 订单支付
     *
     * @param ordersPaymentDTO
     * @return
     */
    public OrderPaymentVO payment(OrdersPaymentDTO ordersPaymentDTO) throws Exception &#123;
        // 查询订单
        Orders order = orderMapper.getByOrderNumber(ordersPaymentDTO.getOrderNumber());
        if (order == null) &#123;
            throw new OrderBusinessException(&quot;订单不存在&quot;);
        &#125;

        // 检查订单支付状态
        if (order.getPayStatus() == 1) &#123; // 1 表示已支付
            throw new OrderBusinessException(&quot;该订单已支付&quot;);
        &#125;
        order.setPayStatus(1);

        // 更新订单支付状态为已支付
        order.setPayStatus(Orders.PAID);
        order.setCheckoutTime(LocalDateTime.now());
        order.setPayMethod(ordersPaymentDTO.getPayMethod());
        order.setStatus(Orders.TO_BE_CONFIRMED);

        // 支付成功后通过 WebSocket 向客户端推送消息
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;type&quot;, 1); // 1 表示来单提醒
        map.put(&quot;orderId&quot;, order.getId());
        map.put(&quot;content&quot;, &quot;订单号：&quot; + ordersPaymentDTO.getOrderNumber());

        webSocketServer.sendToAllClient(JSON.toJSONString(map));


        orderMapper.update(order);

        // 构造并返回支付结果对象
        OrderPaymentVO orderPaymentVO = new OrderPaymentVO();
        orderPaymentVO.setOrderNumber(order.getNumber()); // 订单号
        orderPaymentVO.setPaymentTime(new Date());
        orderPaymentVO.setPaymentStatus(&quot;SUCCESS&quot;);

        return orderPaymentVO;

    &#125;
</code></pre>
<h3 id="用户催单"><a href="#用户催单" class="headerlink" title="用户催单"></a>用户催单</h3><pre><code class="java">com/sky/controller/user/OrderController.java 
/**
     * 客户催单
     * @param id
     * @return
     */
    @GetMapping(&quot;/reminder/&#123;id&#125;&quot;)
    @ApiOperation(&quot;客户催单&quot;)
    public Result reminder(@PathVariable(&quot;id&quot;) Long id)&#123;
        orderService.reminder(id);
        return Result.success();
    &#125;
</code></pre>
<pre><code class="java">com/sky/service/OrderService.java
 /**
     * 用户催单
     * @param id
     */
    void reminder(Long id);
</code></pre>
<pre><code class="java">com/sky/service/impl/OrderServiceImpl.java
/**
     * 客户催单
     * @param id
     */
    public void reminder(Long id) &#123;
        // 根据id查询订单
        Orders ordersDB = orderMapper.getById(id);

        // 校验订单是否存在
        if (ordersDB == null) &#123;
            throw new OrderBusinessException(MessageConstant.ORDER_STATUS_ERROR);
        &#125;

        Map map = new HashMap();
        map.put(&quot;type&quot;,2); //1表示来单提醒 2表示客户催单
        map.put(&quot;orderId&quot;,id);
        map.put(&quot;content&quot;,&quot;订单号：&quot; + ordersDB.getNumber());

        //通过websocket向客户端浏览器推送消息
        webSocketServer.sendToAllClient(JSON.toJSONString(map));
    &#125;
</code></pre>
<h3 id="ApacheECharts"><a href="#ApacheECharts" class="headerlink" title="ApacheECharts"></a>ApacheECharts</h3><p><a target="_blank" rel="noopener" href="http://echarts.apache.org/zh/index.html">http://echarts.apache.org/zh/index.html</a></p>
<ul>
<li><strong>柱形图</strong> bar</li>
<li><strong>饼形图</strong></li>
<li><strong>折线图</strong></li>
</ul>
<p>使用Echarts，重点在于研究当前图标所需<strong>数据格式</strong>，通常是需要后端提供符合格式要求的动态数据，然后相应给前端来展示图表</p>
<h3 id="营业额统计"><a href="#营业额统计" class="headerlink" title="营业额统计"></a>营业额统计</h3><h6 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>营业额指订单状态为已完成的订单金额合计</li>
<li>基于可视化报表的折线图展示营业额数据，x轴为日期，y轴为营业额</li>
<li>根据时间选择区间，展示每天的营业额数据</li>
</ul>
<h5 id="根据接口定义设计对应的vo："><a href="#根据接口定义设计对应的vo：" class="headerlink" title="根据接口定义设计对应的vo："></a>根据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/TurnoverReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TurnoverReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03 [开始到结束的每一天]
    private String dateList;

    //营业额，以逗号分隔，例如：406.0,1520.0,75.0 [营业额一一对应]
    private String turnoverList;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
 * 数据统计相关接口
 */
@RestController
@RequestMapping(&quot;/admin/report&quot;)
@Api(tags = &quot;数据统计接口&quot;)
@Slf4j
public class ReportController &#123;
    @Autowired
    private ReportService reportService;

    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/turnoverStatistics&quot;)
    public Result&lt;TurnoverReportVO&gt; turnoverStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end) &#123;
        log.info(&quot;营业额统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getTurnoverStatistics(begin,end));
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    @Autowired
    private OrderMapper orderMapper;
    /**
     * 统计指定时间区间内的营业额数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public TurnoverReportVO getTurnoverStatistics(LocalDate begin, LocalDate end) &#123;
        // 当前集合用于存放从begin到end范围内的每天的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天对应的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天的营业额
        List&lt;Double&gt; turnoverList = new ArrayList&lt;&gt;();
        for (LocalDate date : dateList) &#123; //LocalDate只是年月日 而下单的Order有时分秒
            // 查询Date日期对应的营业额数据，数据额是指：订单状态为“已完成”的订单金额合计
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
        // select sum(count) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Map map = new HashMap&lt;&gt;();
            map.put(&quot;begin&quot;, beginTime);
            map.put(&quot;end&quot;, endTime);
            map.put(&quot;status&quot;, Orders.COMPLETED);
            Double turnover = orderMapper.sumByMap(map);
            turnover = turnover == null ? 0.0 : turnover;//没有营业额则默认为0
            turnoverList.add(turnover);
        &#125;

        return TurnoverReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .turnoverList(StringUtils.join(turnoverList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计营业额数据
     * @param map
     * @return
     */
    Double sumByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;Orders&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into orders
        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,
         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,
         tableware_status)
        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,
                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,
                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.sky.entity.Orders&quot;&gt;
        update orders
        &lt;set&gt;
            &lt;if test=&quot;cancelReason != null and cancelReason!=&#39;&#39; &quot;&gt;
                cancel_reason=#&#123;cancelReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;rejectionReason != null and rejectionReason!=&#39;&#39; &quot;&gt;
                rejection_reason=#&#123;rejectionReason&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;cancelTime != null&quot;&gt;
                cancel_time=#&#123;cancelTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payStatus != null&quot;&gt;
                pay_status=#&#123;payStatus&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;payMethod != null&quot;&gt;
                pay_method=#&#123;payMethod&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;checkoutTime != null&quot;&gt;
                checkout_time=#&#123;checkoutTime&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                status = #&#123;status&#125;,
            &lt;/if&gt;
            &lt;if test=&quot;deliveryTime != null&quot;&gt;
                delivery_time = #&#123;deliveryTime&#125;
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #&#123;id&#125;
    &lt;/update&gt;

    &lt;select id=&quot;pageQuery&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders
        &lt;where&gt;
            &lt;if test=&quot;number != null and number!=&#39;&#39;&quot;&gt;
                and number like concat(&#39;%&#39;,#&#123;number&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;phone != null and phone!=&#39;&#39;&quot;&gt;
                and phone like concat(&#39;%&#39;,#&#123;phone&#125;,&#39;%&#39;)
            &lt;/if&gt;
            &lt;if test=&quot;userId != null&quot;&gt;
                and user_id = #&#123;userId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;beginTime != null&quot;&gt;
                and order_time &amp;gt;= #&#123;beginTime&#125;
            &lt;/if&gt;
            &lt;if test=&quot;endTime != null&quot;&gt;
                and order_time &amp;lt;= #&#123;endTime&#125;
            &lt;/if&gt;
        &lt;/where&gt;
        order by order_time desc
    &lt;/select&gt;
    &lt;!-- 根据订单号查询订单 --&gt;
    &lt;select id=&quot;getByOrderNumber&quot; parameterType=&quot;String&quot; resultType=&quot;Orders&quot;&gt;
        select * from orders where number = #&#123;orderNumber&#125;
    &lt;/select&gt;
    &lt;select id=&quot;sumByMap&quot; resultType=&quot;java.lang.Double&quot;&gt;
        select sum(amount) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>业务规则：</p>
<ul>
<li>根据时间选择区间，展示每天的用户总量和新增用户量数据</li>
</ul>
<h5 id="据接口定义设计对应的vo："><a href="#据接口定义设计对应的vo：" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/UserReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //用户总量，以逗号分隔，例如：200,210,220
    private String totalUserList;

    //新增用户，以逗号分隔，例如：20,21,10
    private String newUserList;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/userStatistics&quot;)
    @ApiOperation(&quot;用户统计&quot;)
    public Result&lt;UserReportVO&gt; userStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)LocalDate end)&#123;
        log.info(&quot;用户数据统计:&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getUserStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
   /**
     * 用户统计
     * @param begin
     * @param end
     * @return
     */
    UserReportVO getUserStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Slf4j
public class ReportServiceImpl implements ReportService &#123;
    /**
     * 统计指定时间区间内的用户数据
     * @param begin
     * @param end
     * @return
     */
    @Override
    public UserReportVO getUserStatistics(LocalDate begin, LocalDate end) &#123;
        // 存放从begin 到 end之间的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();
        dateList.add(begin);
        while (!begin.equals(end)) &#123;
            //日期计算，计算指定日期的后一天的日期
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        // 存放每天新增用户数量 select count(id) from user where create_time &gt; ? and create_time &lt; ?
        List&lt;Integer&gt; newUserList = new ArrayList&lt;&gt;();
        // 存放每天的总用户数量 select count(id) from user where create_time &lt;= ?
        List&lt;Integer&gt; totalUserList = new ArrayList&lt;&gt;();

        for (LocalDate date : dateList) &#123;
        // 遍历每一天的用户总量和数量
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);

            Map map = new HashMap&lt;&gt;();
            map.put(&quot;end&quot;, endTime);

            // 总用户数量
            Integer integer = userMapper.countByMap(map);

            map.put(&quot;begin&quot;, beginTime);
            //新增用户数量
            Integer newUser = userMapper.countByMap(map);
            totalUserList.add(integer);
            newUserList.add(newUser);
        &#125;
        return UserReportVO.builder()
                .dateList(StringUtils.join(dateList, &quot;,&quot;))
                .totalUserList(StringUtils.join(totalUserList, &quot;,&quot;))
                .newUserList(StringUtils.join(newUserList, &quot;,&quot;))
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/UserMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="订单统计"><a href="#订单统计" class="headerlink" title="订单统计"></a>订单统计</h3><h6 id="业务规则-1"><a href="#业务规则-1" class="headerlink" title="业务规则"></a>业务规则</h6><ul>
<li>根据时间选择区间，展示每天的订单总数和有效订单数</li>
<li>展示所选时间区间内的有效订单数、总订单数、订单完成率</li>
<li>订单完成率 &#x3D; 有效订单数 &#x2F; 总订单数 * 100%</li>
</ul>
<h6 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h6><ul>
<li>dataList 日期列表以逗号分隔</li>
<li>orderCompletionRate 订单完成率</li>
<li>orderCountList 订单数列表以逗号分隔</li>
<li>totalOrderCount 订单总数</li>
<li>validOrderCount 有效订单数</li>
<li>validOrderCountList 有效订单数列表以逗号分隔</li>
</ul>
<h5 id="据接口定义设计对应的vo：-1"><a href="#据接口定义设计对应的vo：-1" class="headerlink" title="据接口定义设计对应的vo："></a>据接口定义设计对应的vo：</h5><pre><code class="java">sky-pojo  com/sky/vo/OrderReportVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OrderReportVO implements Serializable &#123;

    //日期，以逗号分隔，例如：2022-10-01,2022-10-02,2022-10-03
    private String dateList;

    //每日订单数，以逗号分隔，例如：260,210,215
    private String orderCountList;

    //每日有效订单数，以逗号分隔，例如：20,21,10
    private String validOrderCountList;

    //订单总数
    private Integer totalOrderCount;

    //有效订单数
    private Integer validOrderCount;

    //订单完成率
    private Double orderCompletionRate;

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;

/**
     * 订单统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/ordersStatistics&quot;)
    @ApiOperation(&quot;订单统计&quot;)
    public Result&lt;OrderReportVO&gt; ordersStatistics(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)  LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;订单数据统计：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getOrderStatistics(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
package com.sky.service;

import com.sky.vo.TurnoverReportVO;

import java.time.LocalDate;

public interface ReportService &#123;
 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end);
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
package com.sky.service.impl;

import com.sky.entity.Orders;
import com.sky.mapper.OrderMapper;
import com.sky.service.ReportService;
import com.sky.vo.TurnoverReportVO;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

 /**
     * 统计指定时间区间内的订单数据
     * @param begin
     * @param end
     * @return
     */
    public OrderReportVO getOrderStatistics(LocalDate begin, LocalDate end) &#123;
        //存放从begin到end之间的每天对应的日期
        List&lt;LocalDate&gt; dateList = new ArrayList&lt;&gt;();

        dateList.add(begin);

        while (!begin.equals(end)) &#123;
            begin = begin.plusDays(1);
            dateList.add(begin);
        &#125;

        //存放每天的订单总数
        List&lt;Integer&gt; orderCountList = new ArrayList&lt;&gt;();
        //存放每天的有效订单数
        List&lt;Integer&gt; validOrderCountList = new ArrayList&lt;&gt;();

        //遍历dateList集合，查询每天的有效订单数和订单总数
        for (LocalDate date : dateList) &#123;
            //查询每天的订单总数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?
            LocalDateTime beginTime = LocalDateTime.of(date, LocalTime.MIN);
            LocalDateTime endTime = LocalDateTime.of(date, LocalTime.MAX);
            Integer orderCount = getOrderCount(beginTime, endTime, null);

            //查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = 5
            Integer validOrderCount = getOrderCount(beginTime, endTime, Orders.COMPLETED);

            orderCountList.add(orderCount);
            validOrderCountList.add(validOrderCount);
        &#125;

        //计算时间区间内的订单总数量
        Integer totalOrderCount = orderCountList.stream().reduce(Integer::sum).get();

        //计算时间区间内的有效订单数量
        Integer validOrderCount = validOrderCountList.stream().reduce(Integer::sum).get();

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0)&#123;
            //计算订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
        &#125;

        return  OrderReportVO.builder()
                .dateList(StringUtils.join(dateList,&quot;,&quot;))
                .orderCountList(StringUtils.join(orderCountList,&quot;,&quot;))
                .validOrderCountList(StringUtils.join(validOrderCountList,&quot;,&quot;))
                .totalOrderCount(totalOrderCount)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .build();
    &#125;
    /**
     * 根据条件统计订单数量
     * @param begin
     * @param end
     * @param status
     * @return
     */
    private Integer getOrderCount(LocalDateTime begin, LocalDateTime end, Integer status)&#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);
        map.put(&quot;status&quot;,status);

        return orderMapper.countByMap(map);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
/**
     * 根据动态条件统计用户数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.sky.mapper.OrderMapper&quot;&gt;

&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from orders
        &lt;where&gt;
            &lt;if test=&quot;begin != null&quot;&gt;
                and order_time &amp;gt; #&#123;begin&#125;
            &lt;/if&gt;
            &lt;if test=&quot;end != null&quot;&gt;
                and order_time &amp;lt; #&#123;end&#125;
            &lt;/if&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="销量排名Top10"><a href="#销量排名Top10" class="headerlink" title="销量排名Top10"></a>销量排名Top10</h3><h6 id="产品原型-查已完成的数据"><a href="#产品原型-查已完成的数据" class="headerlink" title="产品原型 (查已完成的数据)"></a>产品原型 (查已完成的数据)</h6><ul>
<li>此处的销量为商品销售的份数</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    @GetMapping(&quot;/top10&quot;)
    @ApiOperation(&quot;销量排名top10&quot;)
    public Result&lt;SalesTop10ReportVO&gt; top10(
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate begin,
            @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate end)&#123;
        log.info(&quot;销量排名top10：&#123;&#125;,&#123;&#125;&quot;,begin,end);
        return Result.success(reportService.getSalesTop10(begin,end));
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
/**
     * 销量排名统计
     * @param begin
     * @param end
     * @return
     */
    SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
    /**
     * 统计指定时间区间内的销量排名前10
     * @param begin
     * @param end
     * @return
     */
    @Override
    public SalesTop10ReportVO getSalesTop10(LocalDate begin, LocalDate end) &#123;
        LocalDateTime beginTime = LocalDateTime.of(begin, LocalTime.MIN);
        LocalDateTime endTime = LocalDateTime.of(end, LocalTime.MAX);

        List&lt;GoodsSalesDTO&gt; salesTop10 = orderMapper.getSalesTop10(beginTime, endTime);
        List&lt;String&gt; names = salesTop10.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList());
        String nameList = StringUtils.join(names, &quot;,&quot;);

        List&lt;Integer&gt; numbers = salesTop10.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList());
        String numberList = StringUtils.join(numbers, &quot;,&quot;);

        //封装返回结果数据
        return SalesTop10ReportVO
                .builder()
                .nameList(nameList)
                .numberList(numberList)
                .build();
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/OrderMapper.java
  /**
     * 统计指定时间内的销量排名
     * @return
     */
    List&lt;GoodsSalesDTO&gt; getSalesTop10(LocalDateTime begin,LocalDateTime end);
</code></pre>
<pre><code class="xml">sky-server  mapper/OrderMapper.xml
&lt;select id=&quot;getSalesTop10&quot; resultType=&quot;com.sky.dto.GoodsSalesDTO&quot;&gt;
        select od.name, sum(od.number) number
        from order_detail od,orders o
        where od.order_id = o.id and o.status = 5
        &lt;if test=&quot;begin != null&quot;&gt;
            and o.order_time &amp;gt; #&#123;begin&#125;
        &lt;/if&gt;
        &lt;if test=&quot;end != null&quot;&gt;
            and o.order_time &amp;lt; #&#123;end&#125;
        &lt;/if&gt;
        group by od.name
        order by number desc
        limit 0,10
    &lt;/select&gt;
</code></pre>
<h6 id="重装数据库"><a href="#重装数据库" class="headerlink" title="重装数据库"></a>重装数据库</h6><pre><code class="mysql">C:\Windows\System32&gt;cd D:\MySQL\MySQL Server 8.0\bin

C:\Windows\System32&gt;mysqld --install MySQL80
Service successfully installed.

C:\Windows\System32&gt;sc query | findstr MySQL

C:\Windows\System32&gt;net start MySQL80
MySQL80 服务正在启动 .
MySQL80 服务已经启动成功。
服务里的MySQL80是Mysql服务
-----------------------------------------------------------------------------------------

C:\Windows\System32&gt;cd D:\MariaDB 11.0\bin

C:\Windows\System32&gt;mysqld --install MariaDB
Service successfully installed.

C:\Windows\System32&gt;net start MariaDB
MariaDB 服务正在启动 .
MariaDB 服务无法启动。
服务里的MariaDB是MariaDB服务
</code></pre>
<h3 id="工作台"><a href="#工作台" class="headerlink" title="工作台"></a>工作台</h3><h5 id="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"><a href="#工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率" class="headerlink" title="工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率"></a>工作台是系统运营的数据看板，并提供快捷操作入口，可以有效提高商家的工作效率</h5><p>功能工作台展示的数据：</p>
<ul>
<li>今日数据</li>
<li>订单管理</li>
<li>菜品总览</li>
<li>套餐总览</li>
<li>订单信息</li>
</ul>
<h6 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h6><ul>
<li>营业额：已完成订单的总金额</li>
<li>有效订单：已完成订单的数量</li>
<li>订单完成率：有效订单数 &#x2F; 总订单数 * 100%</li>
<li>平均客单价：营业额 &#x2F; 有效订单数</li>
<li>新增用户：新增用户的数量</li>
</ul>
<h6 id="接口设计：-5"><a href="#接口设计：-5" class="headerlink" title="接口设计："></a>接口设计：</h6><ul>
<li><p>今日数据接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;businessData<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单管理接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewOrders<br>Method: Get</p>
</blockquote>
</li>
<li><p>菜品总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewDishes<br>Method: Get</p>
</blockquote>
</li>
<li><p>套餐总览接口</p>
<blockquote>
<p>Path: &#x2F;admin&#x2F;workspace&#x2F;overviewSetmeals<br>Method: Get</p>
</blockquote>
</li>
<li><p>订单搜索(已完成)</p>
</li>
</ul>
<pre><code class="java">sky-server  com/sky/controller/admin/WorkSpaceController.java
package com.sky.controller.admin;

import com.sky.result.Result;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.time.LocalDateTime;
import java.time.LocalTime;

/**
 * 工作台
 */
@RestController
@RequestMapping(&quot;/admin/workspace&quot;)
@Slf4j
@Api(tags = &quot;工作台相关接口&quot;)
public class WorkSpaceController &#123;

    @Autowired
    private WorkspaceService workspaceService;

    /**
     * 工作台今日数据查询
     * @return
     */
    @GetMapping(&quot;/businessData&quot;)
    @ApiOperation(&quot;工作台今日数据查询&quot;)
    public Result&lt;BusinessDataVO&gt; businessData()&#123;
        //获得当天的开始时间
        LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN);
        //获得当天的结束时间
        LocalDateTime end = LocalDateTime.now().with(LocalTime.MAX);

        BusinessDataVO businessDataVO = workspaceService.getBusinessData(begin, end);
        return Result.success(businessDataVO);
    &#125;

    /**
     * 查询订单管理数据
     * @return
     */
    @GetMapping(&quot;/overviewOrders&quot;)
    @ApiOperation(&quot;查询订单管理数据&quot;)
    public Result&lt;OrderOverViewVO&gt; orderOverView()&#123;
        return Result.success(workspaceService.getOrderOverView());
    &#125;

    /**
     * 查询菜品总览
     * @return
     */
    @GetMapping(&quot;/overviewDishes&quot;)
    @ApiOperation(&quot;查询菜品总览&quot;)
    public Result&lt;DishOverViewVO&gt; dishOverView()&#123;
        return Result.success(workspaceService.getDishOverView());
    &#125;

    /**
     * 查询套餐总览
     * @return
     */
    @GetMapping(&quot;/overviewSetmeals&quot;)
    @ApiOperation(&quot;查询套餐总览&quot;)
    public Result&lt;SetmealOverViewVO&gt; setmealOverView()&#123;
        return Result.success(workspaceService.getSetmealOverView());
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/WorkspaceService.java
package com.sky.service;

import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import java.time.LocalDateTime;

public interface WorkspaceService &#123;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end);

    /**
     * 查询订单管理数据
     * @return
     */
    OrderOverViewVO getOrderOverView();

    /**
     * 查询菜品总览
     * @return
     */
    DishOverViewVO getDishOverView();

    /**
     * 查询套餐总览
     * @return
     */
    SetmealOverViewVO getSetmealOverView();

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/WorkspaceServiceImpl.java
package com.sky.service.impl;

import com.sky.constant.StatusConstant;
import com.sky.entity.Orders;
import com.sky.mapper.DishMapper;
import com.sky.mapper.OrderMapper;
import com.sky.mapper.SetmealMapper;
import com.sky.mapper.UserMapper;
import com.sky.service.WorkspaceService;
import com.sky.vo.BusinessDataVO;
import com.sky.vo.DishOverViewVO;
import com.sky.vo.OrderOverViewVO;
import com.sky.vo.SetmealOverViewVO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.Map;

@Service
@Slf4j
public class WorkspaceServiceImpl implements WorkspaceService &#123;

    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private DishMapper dishMapper;
    @Autowired
    private SetmealMapper setmealMapper;

    /**
     * 根据时间段统计营业数据
     * @param begin
     * @param end
     * @return
     */
    public BusinessDataVO getBusinessData(LocalDateTime begin, LocalDateTime end) &#123;
        /**
         * 营业额：当日已完成订单的总金额
         * 有效订单：当日已完成订单的数量
         * 订单完成率：有效订单数 / 总订单数
         * 平均客单价：营业额 / 有效订单数
         * 新增用户：当日新增用户的数量
         */

        Map map = new HashMap();
        map.put(&quot;begin&quot;,begin);
        map.put(&quot;end&quot;,end);

        //查询总订单数
        Integer totalOrderCount = orderMapper.countByMap(map);

        map.put(&quot;status&quot;, Orders.COMPLETED);
        //营业额
        Double turnover = orderMapper.sumByMap(map);
        turnover = turnover == null? 0.0 : turnover;

        //有效订单数
        Integer validOrderCount = orderMapper.countByMap(map);

        Double unitPrice = 0.0;

        Double orderCompletionRate = 0.0;
        if(totalOrderCount != 0 &amp;&amp; validOrderCount != 0)&#123;
            //订单完成率
            orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;
            //平均客单价
            unitPrice = turnover / validOrderCount;
        &#125;

        //新增用户数
        Integer newUsers = userMapper.countByMap(map);

        return BusinessDataVO.builder()
                .turnover(turnover)
                .validOrderCount(validOrderCount)
                .orderCompletionRate(orderCompletionRate)
                .unitPrice(unitPrice)
                .newUsers(newUsers)
                .build();
    &#125;


    /**
     * 查询订单管理数据
     *
     * @return
     */
    public OrderOverViewVO getOrderOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;begin&quot;, LocalDateTime.now().with(LocalTime.MIN));
        map.put(&quot;status&quot;, Orders.TO_BE_CONFIRMED);

        //待接单
        Integer waitingOrders = orderMapper.countByMap(map);

        //待派送
        map.put(&quot;status&quot;, Orders.CONFIRMED);
        Integer deliveredOrders = orderMapper.countByMap(map);

        //已完成
        map.put(&quot;status&quot;, Orders.COMPLETED);
        Integer completedOrders = orderMapper.countByMap(map);

        //已取消
        map.put(&quot;status&quot;, Orders.CANCELLED);
        Integer cancelledOrders = orderMapper.countByMap(map);

        //全部订单
        map.put(&quot;status&quot;, null);
        Integer allOrders = orderMapper.countByMap(map);

        return OrderOverViewVO.builder()
                .waitingOrders(waitingOrders)
                .deliveredOrders(deliveredOrders)
                .completedOrders(completedOrders)
                .cancelledOrders(cancelledOrders)
                .allOrders(allOrders)
                .build();
    &#125;

    /**
     * 查询菜品总览
     *
     * @return
     */
    public DishOverViewVO getDishOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = dishMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = dishMapper.countByMap(map);

        return DishOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;

    /**
     * 查询套餐总览
     *
     * @return
     */
    public SetmealOverViewVO getSetmealOverView() &#123;
        Map map = new HashMap();
        map.put(&quot;status&quot;, StatusConstant.ENABLE);
        Integer sold = setmealMapper.countByMap(map);

        map.put(&quot;status&quot;, StatusConstant.DISABLE);
        Integer discontinued = setmealMapper.countByMap(map);

        return SetmealOverViewVO.builder()
                .sold(sold)
                .discontinued(discontinued)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/DishMapper.java
/**
     * 根据条件统计菜品数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/DishMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from dish
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<pre><code class="java">sky-server  com/sky/mapper/SetmealMapper.java
/**
     * 根据条件统计套餐数量
     * @param map
     * @return
     */
    Integer countByMap(Map map);
</code></pre>
<pre><code class="java">sky-server  mapper/SetmealMapper.xml
&lt;select id=&quot;countByMap&quot; resultType=&quot;java.lang.Integer&quot;&gt;
        select count(id) from setmeal
        &lt;where&gt;
            &lt;if test=&quot;status != null&quot;&gt;
                and status = #&#123;status&#125;
            &lt;/if&gt;
            &lt;if test=&quot;categoryId != null&quot;&gt;
                and category_id = #&#123;categoryId&#125;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><h6 id="在Java中操控Excel文件-读写操作"><a href="#在Java中操控Excel文件-读写操作" class="headerlink" title="在Java中操控Excel文件 [读写操作]"></a>在Java中操控Excel文件 [读写操作]</h6><p>Apache POI 是一个处理Miscrosoft Office各种文件格式的开源项目，POI都是用于操作Excel文件</p>
<h6 id="Apache-POI应用场景："><a href="#Apache-POI应用场景：" class="headerlink" title="Apache POI应用场景："></a>Apache POI应用场景：</h6><ul>
<li><strong>银行网银系统</strong>导出交易明细</li>
<li>各种业务系统到出Excel报表</li>
<li>批量导入业务数据</li>
</ul>
<pre><code class="java">sky-server  com/sky/test/POITest.java
package com.sky.test;

import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

public class POITest &#123;
    /**
     * 通过POI创建Excel文件并且写入文件内容
     */
    public static void write() throws Exception &#123;
        // 在内存中创建一个Excel文件
        XSSFWorkbook excel = new XSSFWorkbook();
        // 在Excel文件中创建一个sheet页
        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);
        // 在Sheet中创建行对象, rownum编号从0开始
        XSSFRow row = sheet.createRow(1);
        // 创建单元格并写入文件内容
        row.createCell(1).setCellValue(&quot;姓名&quot;);
        row.createCell(2).setCellValue(&quot;城市&quot;);

        // 创建一个新行
        row = sheet.createRow(2);
        row.createCell(1).setCellValue(&quot;张三&quot;);
        row.createCell(2).setCellValue(&quot;北京&quot;);

        row = sheet.createRow(3);
        row.createCell(1).setCellValue(&quot;李四&quot;);
        row.createCell(2).setCellValue(&quot;南京&quot;);

        // 通过输出流将内存中的Excel文件写入到磁盘
        FileOutputStream out = new FileOutputStream(new File(&quot;C:\\Users\\Pluminary\\Desktop\\itcast.xlsx&quot;));
        excel.write(out);

        // 关闭资源
        out.close();
        excel.close();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        write();
    &#125;
&#125;
</code></pre>
<h3 id="导出运营数据Excel报表"><a href="#导出运营数据Excel报表" class="headerlink" title="导出运营数据Excel报表"></a>导出运营数据Excel报表</h3><h6 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h6><ul>
<li>设计Excel模板文件</li>
<li>查询近30天的运营数据</li>
<li>将查询到的运营数据写入模板文件</li>
<li>通过输出流将Excel文件下载到客户端浏览器</li>
</ul>
<pre><code class="java">sky-pojo  com/sky/vo/BusinessDataVO.java
package com.sky.vo;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 数据概览
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BusinessDataVO implements Serializable &#123;

    private Double turnover;//营业额

    private Integer validOrderCount;//有效订单数

    private Double orderCompletionRate;//订单完成率

    private Double unitPrice;//平均客单价

    private Integer newUsers;//新增用户数

&#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/controller/admin/ReportController.java
/**
     * 导出运营数据报表
     * @param response
     */
    @GetMapping(&quot;/export&quot;)
    @ApiOperation(&quot;导出运营数据报表&quot;)
    public void export(HttpServletResponse response) &#123;
        reportService.exportBusinessData(response);
    &#125;
</code></pre>
<pre><code class="java">sky-server  com/sky/service/ReportService.java
 /**
     * 导出运营数据报表
     * @param response
     */
    void exportBusinessData(HttpServletResponse response);
</code></pre>
<pre><code class="java">sky-server  com/sky/service/impl/ReportServiceImpl.java
/**
     * 导出运营数据报表
     * @param response
     */
    @Override
    public void exportBusinessData(HttpServletResponse response) &#123;
        // 查询数据库 获取营业数据 -- 查询最近30天的营业数据
        LocalDate dateBegin = LocalDate.now().minusDays(30);
        LocalDate dateEnd = LocalDate.now().minusDays(1);
        // 查询概览数据
        BusinessDataVO businessDataVO = workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN),LocalDateTime.of(dateEnd, LocalTime.MAX));

        // 查询的数据通过POI写入Excel文件中 (获得对象 获得类加载器 类加载器读取资源)
        InputStream in = this.getClass().getClassLoader().getResourceAsStream(&quot;template/运营数据报表模板.xlsx&quot;);
        try &#123;
            // 基于模板文件创建一个新的Excel文件
            XSSFWorkbook excel = new XSSFWorkbook();

            // 填充数据 [获取标签页]

            XSSFSheet sheet = excel.getSheet(&quot;Sheet1&quot;);
            // 获取第二行[索引是从0开始]
            sheet.getRow(1).createCell(1).setCellValue(&quot;时间：&quot; + dateBegin + &quot;至&quot; + dateEnd);

            // 获得第四行
            XSSFRow row = sheet.getRow(3);
            row.getCell(2).setCellValue(businessDataVO.getTurnover());//营业额
            row.getCell(4).setCellValue(businessDataVO.getOrderCompletionRate());//订单完成率
            row.getCell(6).setCellValue(businessDataVO.getNewUsers());//新增用户数

            // 获得第五行
            row = sheet.getRow(4);
            row.getCell(2).setCellValue(businessDataVO.getValidOrderCount());//有效订单数
            row.getCell(4).setCellValue(businessDataVO.getUnitPrice());//平均单品价格

            // 填充明细数据
            for (int i = 0; i &lt; 30; i++) &#123;
                LocalDate date = dateBegin.plusDays(i);
                // 查询某一天的营业数据
                workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));
                // 获得某一行
                row = sheet.getRow(7 + i);// 利用循环 超越循环
                row.getCell(1).setCellValue(date.toString());
                row.getCell(2).setCellValue(businessDataVO.getTurnover());
                row.getCell(3).setCellValue(businessDataVO.getValidOrderCount());
                row.getCell(6).setCellValue(businessDataVO.getOrderCompletionRate());
                row.getCell(4).setCellValue(businessDataVO.getUnitPrice());
                row.getCell(5).setCellValue(businessDataVO.getNewUsers());
            &#125;

            // 通过输出流将Excel文件下载到客户端浏览器
            ServletOutputStream out = response.getOutputStream();
            excel.write(out);

            // 关闭资源
            out.close();
            excel.close();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/09/28/后端/苍穹外卖/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/07/03/前端/Vue/">
        <h2>
            Vue
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/7/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Vue快速入门"><a href="#Vue快速入门" class="headerlink" title="Vue快速入门"></a>Vue快速入门</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>MVVM</strong>响应式编程模型，避免直接操作<strong>DOM</strong>，降低<strong>DOM</strong>操作的复杂性</p>
<p>安装Vscode 安装nodejs<br>检测是否安装成功 <code>cmd →  node -v  →  npm -v</code></p>
<h6 id="npm设置镜像-cmd"><a href="#npm设置镜像-cmd" class="headerlink" title="npm设置镜像[cmd]"></a>npm设置镜像[cmd]</h6><pre><code class="java">C:\Users\Pluminary&gt;npm config set registry https://registry.npmmirror.com
C:\Users\Pluminary&gt;npm config ls
C:\Users\Pluminary&gt;npm config get registry
</code></pre>
<pre><code class="java">在Vscode里的终端输入 
PS C:\Users\Pluminary\Desktop\vue2&gt; npm init -y
PS C:\Users\Pluminary\Desktop\vue2&gt; npm install vue
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c327127960/article/details/108853046">Vue Chrome调试工具 Vue.js devtools 5.3.3 安装包及教程_vuedevtool.crx百度网盘-CSDN博客</a></p>
<h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 这个就没有被挂载--&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;!--在对话框里输入的时候改变下面的次数--&gt;
        &lt;button v-on:click=&quot;num++&quot;&gt;登录&lt;/button&gt; &lt;!--实现当点击按钮的时候num数值++--&gt;
        &lt;button v-on:click=&quot;loginout()&quot;&gt;登出&lt;/button&gt;
        &lt;h1&gt;&#123;&#123;name&#125;&#125;, 欢迎您,当前登录第&#123;&#123;num&#125;&#125;次,当前登录时间：&#123;&#123;nowDate()&#125;&#125;&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        // 1. new vue实例 每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的
        new Vue(&#123;
            el:&quot;#app&quot;, // 挂载的模板
            data()&#123; // 绑定的数据 把data对象中的所有属性 加到相应视图里
                return&#123;
                    name : &quot;图灵学院&quot;,
                    num:1
                &#125;
            &#125;,
            methods: &#123;
                nowDate()&#123;
                    return new Date().toLocaleDateString()
                &#125;,
                loginout()&#123;
                    this.num--; //当调用实例时要加this
                &#125;
            &#125;,
        &#125;);
        // 双向绑定：数据发生改变 视图也要随之改变；在谷歌浏览器的Vue调试中
        // 指令：简化对Dom的频繁操作
        // 方法：声明方法可以实现更复杂的操作，声明methods属性中
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-text、v-html"><a href="#指令-v-text、v-html" class="headerlink" title="指令 v-text、v-html"></a>指令 v-text、v-html</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-text=&quot;message&quot;&gt;&lt;/div&gt;&#123;&#123;message&#125;&#125;
        &lt;!-- &#123;&#123;&#125;&#125;在网络延迟情况下会出现暂时显示的情况 --&gt;
        &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    // 1.实例Vue
    var vm = new Vue(&#123;
        el:&#39;#app&#39;,
        data:&#123;
            message: &quot;&lt;a href = &#39;#&#39;&gt;Hello&lt;/a&gt;&quot;
        &#125;,
    &#125;)
// v-text 用于绑定数据，语法v-text=&quot;属性&quot;，会直接将值作为文本显示
// v-html 会将值进行编译再显示
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-bind"><a href="#指令-v-bind" class="headerlink" title="指令 v-bind"></a>指令 v-bind</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .red&#123;
            background-color: red;
        &#125; 
        .yellow&#123;
            background-color: yellow;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;    &lt;!--:style=&quot;font-size: &#123;&#123;bigFont&#125;&#125;; 错误写法--&gt;
        &lt;div v-bind:title=&quot;title&quot; :class=&quot;red&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;
            鼠标悬停查看信息！
        &lt;/div&gt;
        &lt;div :class=&quot;&#123;yellow:isyellow&#125;&quot;&gt;
            &lt;a :href=&quot;href&quot; :style=&quot;&#123;fontSize:bigFont&#125;&quot;&gt;图灵学院&lt;/a&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;img :src=&quot;src&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;button v-bind:disabled=&quot;disabled&quot;&gt;禁用按钮&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            red:&quot;red&quot;,
            isyellow:true,
            bigFont:&quot;50px&quot;,
            title: &quot;您好，本网站可以学到更多的知识&quot;,
            href: &quot;https://www.pronhub.com/&quot;,
            scr: &#39;../Imooc_Cat.jpg&#39;,
            disabled: true
        &#125;
    &#125;)

    // 绑定元素属性 -- v-bind
    // 语法：v-bind:元素属性=&quot;vue的属性&quot;
    // 简写：v-bind:title 简写成 :title
    /*
       针对样式的特殊用法：
         动态控制class是否添加 :class=&quot;&#123;red:isred&#125;&quot;
           语法 &#123;red:isred&#125; : &#123;需要动态控制的class样式:vue的属性(需要是boolean类型)&#125;

         动态设置style的样式   :style=&quot;&#123;fontSize:bigFont&#125;&quot;
           语法 &#123;fontSize: bigFont&#125; : &#123;css样式的驼峰命名方法:&#125; font-size=fontSize
    */
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-model"><a href="#指令-v-model" class="headerlink" title="指令 v-model"></a>指令 v-model</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;
            &lt;label&gt;年龄：&lt;/label&gt;
            &lt;input v-model=&quot;age&quot;/&gt;
        &lt;/div&gt;
        &lt;div&gt;当前输入的年龄是：&#123;&#123;age&#125;&#125;&lt;/div&gt;
        &lt;button @click=&quot;add&quot;&gt;加一岁&lt;/button&gt; &lt;!--  @click = v-on:click  --&gt;
        &lt;button @click=&quot;alertYear&quot;&gt;弹出年龄&lt;/button&gt;

    &lt;hr&gt;
        &lt;label&gt;课程：&lt;/label&gt;
        &lt;select v-model=&quot;course&quot;&gt;
            &lt;option value=&quot;javascript&quot;&gt;javascript&lt;/option&gt;
            &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt;
            &lt;option value=&quot;c++&quot;&gt;c++&lt;/option&gt;
        &lt;/select&gt;

        &lt;div&gt;
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;javascript&quot;&gt;javascript
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;java&quot;&gt;java
            &lt;input v-model=&quot;course&quot; type=&quot;radio&quot; name=&quot;course&quot; value=&quot;c++&quot;&gt;c++
        &lt;/div&gt;

        &lt;div&gt;当前课程是：&#123;&#123;course&#125;&#125;&lt;/div&gt;
    &lt;/div&gt;
    
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        age:10,
        course:&#39;java&#39;
    &#125;,
    methods: &#123;
        add()&#123;
            this.age++;
        &#125;,
        alertYear()&#123;
            alert(this.age)
        &#125;
    &#125;
&#125;)

//v-model 用于实现双向绑定 一般用在表单元素
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-on"><a href="#指令-v-on" class="headerlink" title="指令 v-on"></a>指令 v-on</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button v-on:click=&quot;hello(&#39;hello&#39;)&quot;&gt;hello&lt;/button&gt;
        &lt;button @click=&quot;hello(&#39;world&#39;)&quot;&gt;world&lt;/button&gt;
        &lt;button @click=&quot;num++&quot;&gt;数据：&lt;/button&gt;&#123;&#123;num&#125;&#125;
&lt;!-- 不让事件传播 禁止默认a标签事件 
 @click.stop 不让事件传播
 @click.self 需要自己点击[不会参与传播]
 @click.prevent 组织默认事件
 @click.once 事件只会触发一次
 --&gt;
        &lt;div @click=&quot;hello(1)&quot; style=&quot;background-color: red; width: 800px; height: 500px;padding: 50px;&quot;&gt;
            1
            &lt;div @click.stop=&quot;hello(2)&quot; style=&quot;background-color: blue; width: 400px; height: 200px;padding: 50px;&quot;&gt;
                2
                &lt;a @click.stop.prevent=&quot;hello(3)&quot; style=&quot;background-color: yellow; width: 200px; height: 100px; display: block;padding: 50px;&quot; href=&quot;www.baidu.com&quot;&gt;3&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;input v-on:keyup.enter=&quot;hello(&#39;enter&#39;)&quot;&gt; &lt;!--键盘按回车触发--&gt;&lt;br&gt;
        &lt;input v-on:keyup.space=&quot;hello(&#39;enter&#39;)&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            num: 0
        &#125;,
        methods: &#123;
            hello(str)&#123;
                alert(str)
            &#125;
        &#125;
    &#125;)

/*
 v-on用于绑定事件
 语法  v-on:事件名
 简写方式 v-on:click =&gt; @click
 只能调用vue中的函数和数据
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-for"><a href="#指令-v-for" class="headerlink" title="指令 v-for"></a>指令 v-for</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        循环数组
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in music&quot;&gt;&#123;&#123;item.name&#125;&#125;---&#123;&#123;index+1&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
        循环对象
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data:&#123;
        // 要循环的数组
        music:[
            &#123;name: &#39;青花瓷&#39;&#125;,
            &#123;name: &#39;阳光总在风雨后&#39;&#125;,
            &#123;name: &#39;十年&#39;&#125;
        ],
        // 要循环的对象
        obj:&#123;
            name: &#39;句号&#39;,
            age: 18,
            sex: &#39;男&#39;
        &#125;
    &#125;
&#125;)
/*
v-for循环，可以循环数组和对象
v-for=&quot;(item, index) in intems
语法：v-for=&quot;(每次循环接收的变量, 当前循环的索引) in 需要循环的变量&quot;
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-if-与-v-show"><a href="#指令-v-if-与-v-show" class="headerlink" title="指令 v-if 与 v-show"></a>指令 v-if 与 v-show</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;button @click=&quot;vif=!vif&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-if=&quot;vif&quot; style=&quot;background-color: red; width: 200px; height: 200px;&quot;&gt;
            v-if
        &lt;/div&gt;
        &lt;hr&gt;
        &lt;button @click=&quot;vshow=!vshow&quot;&gt;切换显示隐藏&lt;/button&gt;
        &lt;div v-show=&quot;vshow&quot; style=&quot;background-color: yellow; width: 200px; height: 200px;&quot;&gt;
            v-show
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &quot;#app&quot;,
    data:&#123;
        vif: true,
        vshow: true
    &#125;
&#125;)
/*
    v-if 和 v-show 用于控制元素显示隐藏
    语法 v-if = &quot;指定Boolean值&quot; v-show一样
    
    v-if 控制元素是否生成
    v-show 控制元素是否显示隐藏
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令-v-else-与-v-else-if"><a href="#指令-v-else-与-v-else-if" class="headerlink" title="指令 v-else 与 v-else-if"></a>指令 v-else 与 v-else-if</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div v-if=&quot;number == 1&quot;&gt;
            A
        &lt;/div&gt;
        &lt;div v-else-if=&quot;number == 2&quot;&gt;
            B
        &lt;/div&gt;
        &lt;div v-else&gt;
            C
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data() &#123;
        return &#123;
            number: 1
        &#125;
    &#125;,
&#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;计算属性和侦听器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- 实现一个购物车功能 
            1. 数据初始化处理
            2. 选择商品数量：当商品数量超过库存做提示
            3. 计算商品总价
        --&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;(item, index) in car&quot;&gt;
                &#123;&#123;item.pname&#125;&#125; --- 商品价格：&#123;&#123;item.price&#125;&#125; --- 库存：&#123;&#123;item.stock&#125;&#125;
                数量：&lt;input type=&quot;number&quot; v-model=&quot;item.num&quot; style=&quot;width: 30px;&quot;/&gt;
            &lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
            &lt;!-- &lt;li v-html=&quot;warn()&quot;&gt;&lt;/li&gt; --&gt;
            &lt;li v-html=&quot;message&quot;&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
 new Vue(&#123;
    el:&quot;#app&quot;,
    data:&#123;
        car:[
            &#123;pname:&#39;IPhone 12&#39;,price:10000,stock:10,num:1&#125;,
            &#123;pname:&#39;Mate40 pro&#39;,price:7000,stock:3,num:1&#125;,
        ],
        message:&quot;&quot;,
    &#125;,
    // methods：当方法中的数据发生改变，方法会自动调用 所以当数量增加时会自动计算总价
    methods: &#123;
        // calcSum()&#123;
        //     let sum=0;
        //     this.car.forEach(item =&gt; &#123;
        //         sum+=item.price*item.num;
        //     &#125;);
        //     return sum;
        // &#125;

        // warn()&#123;
        //     let message=&quot;&quot;;
        //     this.car.forEach(item =&gt; &#123;
        //         if(item.num&gt;item.stock)&#123;
        //             message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
        //         &#125;
        //     &#125;);
        //     return message;
        // &#125;
    &#125;,
    // 计算属性 上面就不加大括号  &lt;li&gt;&lt;strong&gt;总价：&lt;/strong&gt;&#123;&#123;calcSum&#125;&#125;&lt;/li&gt;
    computed:&#123;
        calcSum()&#123;
            let sum=0;
            this.car.forEach(item =&gt; &#123;
                sum+=item.price*item.num;
            &#125;);
            return sum;
        &#125;
    &#125;,
    // 侦听器 专门用于侦听某些数据的变化，当数据发生变化会自动调节方法 不能像方法那样调用
    watch:&#123;
        // 要侦听的数据 
        car:&#123;
            handler(newvalue,oldvalue)&#123;
                this.message=&quot;&quot;;
                this.car.forEach(item =&gt; &#123;
                    if(item.num&gt;item.stock)&#123;
                        this.message+=`$&#123;item.pname&#125;的库存超出限制&lt;br/&gt;`
                    &#125;
                &#125;);
            &#125;,
            deep:true
        &#125;,
        //侦听message 基础类型的侦听 将侦听数据作为函数就可以了
        message(newvalue,oldvalue)&#123;
            console.info(newvalue,oldvalue)
        &#125;
    &#125;
 &#125;);
 /*
    方法和计算属性的区别：
    声明方式不一样，调用不一样方法要用&quot;()&quot;, 计算属性调用不要加&quot;()&quot;
 */
/*
    方法和侦听器的区别：
        方法：方法中任意数据发生改变了就会自动调用方法 
            可以调用，进行返回值

        侦听器：需要指定具体的侦听数据，只有被具体指定的侦听数据发生了改变才会触发
            不能像方法那样去调用，而是靠vue自动触发 如果初始情况就数量就大于库存是不改变的
*/
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;过滤器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    

    &lt;div id=&quot;app&quot;&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;user in userList&quot;&gt;
                姓名：&#123;&#123;user.name&#125;&#125;; 性别：&#123;&#123;user.gender==1?"男":"女"&#125;&#125;
                &#123;&#123;user.gender | filterGender&#125;&#125;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    let vm = new Vue(&#123;
        el: &quot;#app&quot;,
        data:&#123;
            userList:[
                &#123;id:1, name:&#39;xushu&#39;, gender:1&#125;,
                &#123;id:2, name:&#39;zhuge&#39;, gender:0&#125;
            ]
        &#125;,
        //针对数据过滤的
        methods:&#123;
            formateGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;~男&quot;
                &#125;else&#123;
                    return &quot;~女&quot;
                &#125;
            &#125;
        &#125;,
        filters:&#123;
            filterGender(gender)&#123;
                if(gender==1)&#123;
                    return &quot;!男&quot;
                &#125;else&#123;
                    return &quot;!女&quot;
                &#125;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Vue-组件化"><a href="#Vue-组件化" class="headerlink" title="Vue-组件化"></a>Vue-组件化</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;组件化&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt;  &lt;!--输出50--&gt;
        &lt;app-xushu&gt;&lt;/app-xushu&gt; &lt;!--输出66--&gt;
    &lt;/div&gt;

    &lt;div id=&quot;app2&quot;&gt;
        &lt;!-- &lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt; --&gt;
        &lt;!-- &lt;xushu&gt;&lt;/xushu&gt; --&gt;
        &lt;xushu :num=&quot;numxx&quot;&gt;&lt;/xushu&gt; &lt;!--传递属性--&gt; &lt;!--输出100--&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 1.全局组件 在所有的Vue实例中使用
        /*
            1.1 命名：不要使用驼峰命名法 可以用中划线命名
            1.2 模板：必须的
            1.3 数据：一定要函数的方式声明
        */
        Vue.component(&quot;xushu&quot;, &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            //1.在自己的字方法中声明  
            // data() &#123;
            //     return &#123;
            //         num:10
            //     &#125;
            // &#125;,

            //2.在下方父方法中声明并传递过来
            props: [&quot;num&quot;]
        &#125;);

        // 2.局部组件 //自己定义下面引用
        const appXushu = &#123;
            template: `&lt;div @click=&#39;num++&#39;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;`,
            data() &#123;
                return &#123;
                    num: 66
                &#125;
            &#125;
        &#125;;

        new Vue(&#123;
            el: &quot;#app&quot;,
            data: &#123;
                numxx: 50
            &#125;,
            components: &#123;
                &quot;app-xushu&quot;: appXushu
            &#125;
        &#125;);

        new Vue(&#123;
            el: &quot;#app2&quot;,
            data: &#123;
                numxx: 100
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="生命周期和钩子函数"><a href="#生命周期和钩子函数" class="headerlink" title="生命周期和钩子函数"></a>生命周期和钩子函数</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;span id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;
        &lt;button @click=&quot;updateName&quot;&gt;更新&lt;/button&gt;
        &lt;button @click=&quot;destroyInstance&quot;&gt;销毁&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue(&#123;
        el: &#39;#app&#39;,
        data:&#123;
            name: &#39;hello !&#39;
        &#125;,
        methods: &#123;
            updateName()&#123;
                console.log(&#39;准备改名字啦！&#39;)
                this.name = &#39;hello 图灵！&#39;
            &#125;,
            destroyInstance()&#123;
                console.log(&#39;销毁实例&#39;)
                vm.$destroy()
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><pre><code class="vue">npm install vue-router@3
npm install vue-router@3 --legacy-peer-deps

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;!-- 1.安装vue-router路由
     2.引入vue-router文件
     3.根据不同url连接到不同的页面，需要使用模板实现，将模板绑定对应的路由地址
--&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;nav&gt;
            &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;
            &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
        &lt;/nav&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-router@3.5.1/dist/vue-router.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
                // 定义组件：原本应该是在外面定义HomeComponent.vue [创建一些组件]
        const HomeComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;Home&lt;/h1&gt;&lt;p&gt;Welcome to the Home page!&lt;/p&gt;&lt;/div&gt;`
        &#125;;
              // 定义组件：原本应该是在外面定义AboutComponent.vue [创建一些组件]
        const AboutComponent = &#123;
            template: `&lt;div&gt;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;Learn more about us on this page.&lt;/p&gt;&lt;/div&gt;`
        &#125;;

        // 定义路由：原本应该是外面定义router.js文件来定义路由。
        const routes = [
            &#123; path: &#39;/&#39;, component: HomeComponent &#125;,
            &#123; path: &#39;/about&#39;, component: AboutComponent &#125;
        ];

        // 创建路由实例
        const router = new VueRouter(&#123;
            routes
        &#125;);

        // 创建并挂载根实例
        const app = new Vue(&#123;
            router// 挂载路由
        &#125;).$mount(&#39;#app&#39;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><pre><code class="vue">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Vue with Axios Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h1&gt;Data from API&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;
        &lt;!-- 使用 Vue 的 v-for 指令遍历 posts 数组，并生成列表项，每个列表项显示 post.title。 --&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;!-- 引入 Vue.js --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 引入 Axios --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // 创建 Vue 实例
        let vm = new Vue(&#123;
            el: &quot;#app&quot;, // Vue 实例绑定到 HTML 中的 id=&quot;app&quot; 的元素
            data: &#123;
                posts: [] // 初始化一个空数组用于存储从 API 获取的数据
            &#125;,
            created() &#123;
                // Vue 实例创建时调用的生命周期钩子
                axios.get(&#39;https://jsonplaceholder.typicode.com/posts&#39;) // 使用 Axios 发送 GET 请求
                    .then(response =&gt; &#123; // 请求成功后的处理
                        this.posts = response.data; // 将响应数据赋值给 posts 数组
                    &#125;)
                    .catch(error =&gt; &#123; // 请求失败后的处理
                        console.error(&#39;Error fetching data:&#39;, error); // 输出错误信息到控制台
                    &#125;);
            &#125;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h3><h5 id="CLI文档，开箱即用！"><a href="#CLI文档，开箱即用！" class="headerlink" title="CLI文档，开箱即用！"></a>CLI文档，开箱即用！</h5><pre><code class="vue">cmd全局安装：
npm install -g @vue/cli         或者
npm install -g @vue/cli-init

去想要的文件夹里面：C:\Users\Pluminary\Desktop\vue_cli&gt;vue init webpack tuling
vue init webpack 项目名

? Project name tuling
? Project description A Vue.js project
? Author pcy
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? No //严格检验Javascript语法的
? Set up unit tests No
? Setup e2e tests with Nightwatch? No
? Should we run `npm install` for you after the project has been created? (recommended) npm

完成后需要开启：
cd tuling
npm run dev

DONE  Compiled successfully in 1780ms 18:41:21
I  Your application is running here: http://localhost:8080
</code></pre>
<h3 id="运用element-ui创建一个简易的登录界面"><a href="#运用element-ui创建一个简易的登录界面" class="headerlink" title="运用element-ui创建一个简易的登录界面"></a>运用element-ui创建一个简易的登录界面</h3><pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;hello-world&quot;&gt;
    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;
    &lt;el-button type=&quot;primary&quot; @click=&quot;showAlert&quot;&gt;Click Me&lt;/el-button&gt;
  &lt;/div&gt;

  &lt;div class=&quot;app&quot;&gt;
    &lt;h3&gt;&#123;&#123;passage&#125;&#125;&lt;/h3&gt;
    &lt;h4&gt;&#123;&#123;getVal()&#125;&#125;&lt;/h4&gt;
  &lt;/div&gt;

   &lt;!-- 使用Element UI的Table组件展示empList --&gt;
  &lt;el-table :data=&quot;empList&quot; style=&quot;width: 100%&quot;&gt;
    &lt;el-table-column prop=&quot;name&quot; label=&quot;Name&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
    &lt;el-table-column prop=&quot;salary&quot; label=&quot;Salary&quot; width=&quot;180&quot;&gt;&lt;/el-table-column&gt;
  &lt;/el-table&gt;

   &lt;!-- 登录表单 --&gt;
  &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; class=&quot;loginForm&quot; label-width=&quot;80px&quot;&gt;
    &lt;h2 class=&quot;loginTitle&quot;&gt;人事后台管理系统&lt;/h2&gt;
    &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item label=&quot;验证码&quot; prop=&quot;code&quot;&gt;
      &lt;el-input v-model=&quot;loginForm.code&quot; placeholder=&quot;请输入验证码&quot;&gt;&lt;/el-input&gt;
    &lt;/el-form-item&gt;
    &lt;el-form-item style=&quot;width:100%;&quot;&gt;
      &lt;el-button type=&quot;primary&quot; @click=&quot;handleLogin&quot;&gt;登录&lt;/el-button&gt;
    &lt;/el-form-item&gt;
  &lt;/el-form&gt;
   

&lt;/template&gt;

&lt;script&gt;
  export default &#123;
    name: &#39;app&#39;,
    data()&#123;
      return&#123;
        passage: &#39;Oh?&#39;,
        message: &#39;Hello World!&#39;,
        empList:[
          &#123; name: &#39;Peter&#39;, salary: &#39;20000&#39; &#125;,
          &#123; name: &#39;Mike&#39;, salary: &#39;16000&#39; &#125;,
          &#123; name: &#39;Tom&#39;, salary: &#39;17000&#39; &#125;
        ],
        loginForm:&#123;
          username:&#39;&#39;,
          password:&#39;&#39;,
          code:&#39;&#39;
        &#125;
      &#125;
    &#125;,
    methods: &#123;
      showAlert() &#123;
        this.$message(&#123;
          message: &#39;Hello from Element UI!&#39;,
          type: &#39;success&#39;
        &#125;);
      &#125;,
      getVal:function()&#123;
        return &quot;getVal的方法&quot;;
      &#125;,
      handleLogin() &#123;
      this.$message(&#123;
        message: `登录成功，用户名: $&#123;this.loginForm.username&#125;`,
        type: &#39;success&#39;
      &#125;);
     &#125;
    &#125;
  &#125;

&lt;/script&gt;

&lt;style scoped&gt;
    .hello-world &#123;
      text-align: center;
      margin-top: 20px;
    &#125;

    h1 &#123;
      font-size: 24px;
      margin-bottom: 20px;
    &#125;
    .app &#123;
      margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<pre><code class="java">在Vue项目中，Element UI需要正确引入CSS样式和JavaScript文件才能正常工作。如果你没有一个HTML模板文件（例如index.html），而是在Vue组件中直接编写代码，你需要通过一些方式来确保Element UI的样式和脚本被正确加载。

// 1. 创建index.html文件：
这个index.html文件通常放在public文件夹下，是你Vue应用的入口文件。Vue CLI自动生成的项目通常会有这个文件。

// 2. 为什么需要这个HTML文件？
这个index.html文件是Vue CLI或手动设置的Vue项目的入口页面。当你运行npm run serve时，Vue CLI会将所有内容注入到&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;中，这个HTML文件是项目的基本框架。

Element UI的CSS和JS资源：需要在HTML文件的&lt;head&gt;中引入Element UI的样式文件（CSS）和在&lt;body&gt;中引入JS库，这样才能确保Element UI组件在你的Vue组件中正确渲染和运行。
    
// 3. 直接在Vue组件中引入：
如果你不想使用外部HTML文件，Vue项目中可以直接在main.js中引入Element UI的样式和组件：
/*
    // main.js
    import Vue from &#39;vue&#39;;
    import App from &#39;./App.vue&#39;;
    import ElementUI from &#39;element-ui&#39;;
    import &#39;element-ui/lib/theme-chalk/index.css&#39;;

    Vue.config.productionTip = false;

    Vue.use(ElementUI);

    new Vue(&#123;
      render: h =&gt; h(App),
    &#125;).$mount(&#39;#app&#39;);
*/
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#00bcd4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/2024/07/03/前端/Vue/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/">
        <h2>
            Cloud分布式微服务打造大型自媒体3大业务平台
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="自媒体项目"><a href="#自媒体项目" class="headerlink" title="自媒体项目"></a>自媒体项目</h1><h6 id="VM-CentOS7：数据库密码→Panchunyao123"><a href="#VM-CentOS7：数据库密码→Panchunyao123" class="headerlink" title="VM CentOS7：数据库密码→Panchunyao123!"></a>VM CentOS7：数据库密码→Panchunyao123!</h6><h5 id="开发思维与企业一致"><a href="#开发思维与企业一致" class="headerlink" title="开发思维与企业一致"></a>开发思维与企业一致</h5><ul>
<li>三端融合：门户+媒体+运营</li>
<li>4g自媒体辉煌时代</li>
<li>5g科技互联网风口</li>
<li>前后端分离式开发、代码动静分离、保证职</li>
<li>能解耦、功能模块互相协调</li>
</ul>
<h5 id="如何整合分布式中间件到项目中"><a href="#如何整合分布式中间件到项目中" class="headerlink" title="如何整合分布式中间件到项目中"></a>如何整合分布式中间件到项目中</h5><ul>
<li>整个流程会做到细致入微</li>
<li>帮助<span style = "color:red"><strong>迅速提升至少2年</strong></span>以上的项目经验</li>
</ul>
<h5 id="重点功能技术分析"><a href="#重点功能技术分析" class="headerlink" title="重点功能技术分析"></a>重点功能技术分析</h5><ul>
<li><strong>Redis</strong>：分布式会话、session共享、单点登录、防刷、计数</li>
<li><strong>Fastdfs+Nginx&#x2F;OSS&#x2F;GridFS</strong>：搭建分布式文件系统、单文件&#x2F;批量上传、人脸隐私保护拦截</li>
<li><strong>Maven</strong>：项目构建、聚合、分层、架构设计、面向对象</li>
<li><strong>阿里AI</strong>：人脸对比、文本&#x2F;图片自动审核、短信</li>
<li><strong>SpringCloud</strong>：业务分而治之、可伸缩、可扩展、接口服务化</li>
<li><strong>Freemarker</strong>：构建模块页，实现页面静态化</li>
</ul>
<h5 id="前置技能必备"><a href="#前置技能必备" class="headerlink" title="前置技能必备"></a>前置技能必备</h5><ul>
<li>Java基础</li>
<li>熟悉MySQL&#x2F;MariaDB</li>
<li>掌握Linux的基本命令</li>
</ul>
<h5 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h5><ul>
<li>前端构建与运行</li>
<li>后端手把手从0到1</li>
<li>中间件手把手部署</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/42c012bc7c8346dbe4070f43c67bfed16904e4a8/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E6%9E%B6%E5%9B%BE.jpg" style="zoom: 80%;" />



<h3 id="前后端分离开发模式"><a href="#前后端分离开发模式" class="headerlink" title="前后端分离开发模式"></a>前后端分离开发模式</h3><h5 id="传统JavaWeb开发-与-前后端页面交互"><a href="#传统JavaWeb开发-与-前后端页面交互" class="headerlink" title="传统JavaWeb开发 与 前后端页面交互"></a>传统JavaWeb开发 与 前后端页面交互</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1e5f4e27bd9ca7bf4ab7d4afebe373a9f06dc735/data/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="运行前端项目"><a href="#运行前端项目" class="headerlink" title="运行前端项目"></a>运行前端项目</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bugu_hhh/article/details/130625482?ops_request_misc=%7B%22request_id%22:%22171930111016800178595350%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171930111016800178595350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-130625482-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql&spm=1018.2226.3001.4187">Linux 安装 MySQL【CentOS】_linux 安装mysql-CSDN博客</a></p>
<pre><code class="java">前端代码在压缩包中 启动D:\apache-tomcat-8.5.93\bin\startup.bat
将里面的imooc-news放到D:\apache-tomcat-8.5.93\webapps中
去浏览器中启动 http://localhost:9090/imooc-news/portal/index.html
</code></pre>
<h5 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h5><blockquote>
<p><a target="_blank" rel="noopener" href="https://oldj.github.io/SwitchHosts/">https://oldj.github.io/SwitchHosts/</a><br>在本地把域名和对应的IP給联系绑定起来 [相当于在云服务买了域名后绑定]</p>
<p> #imooc-news 127.0.0.1<br>[这东西需要关闭代理才可以用]</p>
<p>127.0.0.1 <a target="_blank" rel="noopener" href="http://www.imoocnews.com/">www.imoocnews.com</a><br>127.0.0.1 writer.imoocnews.com<br>127.0.0.1 admin.imoocnews.com</p>
<p>127.0.0.1 article.imoocnews.com<br>127.0.0.1 user.imoocnews.com<br>127.0.0.1 files.imoocnews.com</p>
</blockquote>
<h6 id="D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js"><a href="#D-apache-tomcat-8-5-93-webapps-imooc-news-portal-js-app-js" class="headerlink" title="D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js"></a>D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\js\app.js</h6><pre><code class="java">window.app = &#123;
    /* 
    portalIndexUrl: &quot;http://localhost:8080/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerIndexUrl: &quot;http://localhost:8080/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://localhost:8080/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    userServerUrl: &quot;http://192.168.1.5:8003&quot;,   // 用户服务后端接口地址
    */

    portalIndexUrl: &quot;http://www.imoocnews.com:9090/imooc-news/portal/index.html&quot;,           // 门户首页地址
    writerLoginUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/passport.html&quot;,      // 登录页面
    writerIndexUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html&quot;,      // 作家中心首页
    writerInfoUrl: &quot;http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html&quot;,     // 用户信息完善页面
    adminCenterUrl: &quot;http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html&quot;,     // 运营管理平台主页

    userServerUrl: &quot;http://user.imoocnews.com:8003&quot;,        // 用户服务后端接口地址
    fsServerUrl: &quot;http://files.imoocnews.com:8004&quot;,         // 文件服务后端接口地址
    adminServerUrl: &quot;http://admin.imoocnews.com:8005&quot;,      // 运营管理服务后端接口地址
    articleServerUrl: &quot;http://article.imoocnews.com:8001&quot;,      // 文章服务后端接口地址

    /**
     * 如果本地使用localhost测试可以不使用，如果是ip或者域名测试，cookieDomain改为对应的ip或者域名
     * 例：
     *    ip：  192.168.1.111
     *    域名：   .imooc.com
     */
    cookieDomain: &quot;.imoocnews.com&quot;,  
    ......
&#125;
</code></pre>
<h3 id="数据库选型与数据导入"><a href="#数据库选型与数据导入" class="headerlink" title="数据库选型与数据导入"></a>数据库选型与数据导入</h3><ul>
<li>MySql 5.6&#x2F;5.7</li>
<li><strong>MariaDB</strong></li>
<li>Mysql 8.0</li>
</ul>
<pre><code class="java">表名                             注释
admin_user                      运营管理平台的admin级别用户    
app_user                      网站用户
article                          文章资讯表
category                      新闻资讯文章的分类(或称之为领域)
comments                      评论表
fans                          粉丝表，用户与粉丝的关联关系，粉丝本质也是用户
</code></pre>
<h3 id="构建Maven聚合工程"><a href="#构建Maven聚合工程" class="headerlink" title="构建Maven聚合工程"></a>构建Maven聚合工程</h3><blockquote>
<p>创建一个 imooc-news-dev 的Maven项目作为一个顶级工程项目</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fa77f452f8588a132ccd5a461663d1f8cc8b353/data/%E6%9E%84%E5%BB%BAmaven%E8%81%9A%E5%90%88%E5%B7%A5%E7%A8%8B.png"></p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
&lt;!--
    1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
      这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
      模块与模块之间是平级的,是可以相互依赖的
    2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
      必须构建依赖(构建关系)
    3.一个顶级工程是可以由多个不同的子工程共同组合而成
--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,父工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-common"><a href="#imooc-news-dev-common" class="headerlink" title="imooc-news-dev-common"></a>imooc-news-dev-common</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-model"><a href="#imooc-news-dev-model" class="headerlink" title="imooc-news-dev-model"></a>imooc-news-dev-model</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-model
    模型工程, 所有的子工程以及微服务中所涉及到的模型实体类都在此管理
    可以包含一些 *pojo,*Bean,*Entity,vo,bo,dto等
--&gt;

    &lt;artifactId&gt;imooc-news-dev-model&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
&lt;!--  子工程依赖common --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-api"><a href="#imooc-news-dev-service-api" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;!--    imooc-news-dev-service-api
            接口工程,集中管理所有的controller中的接口,为了更好的统一管理微服务
    --&gt;
    &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-service-user"><a href="#imooc-news-dev-service-user" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-user&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h6 id="imooc-news-dev-父"><a href="#imooc-news-dev-父" class="headerlink" title="imooc-news-dev [父]"></a>imooc-news-dev [父]</h6><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
    &lt;!-- 这里是子模块[自动创建] 如果物理删除了子工程 这个不会自动删除的要手动删除--&gt;
        &lt;module&gt;imooc-news-dev-common&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-model&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-api&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
        &lt;module&gt;imooc-news-dev-service-user&lt;/module&gt;
    &lt;/modules&gt;
    &lt;!--
        1.聚合工程可以分为顶级项目(顶级工程,父工程) 与子工程(子modele模块)
          这两者的关系其实就是父子继承关系, 子工程在maven中可以称为module,
          模块与模块之间是平级的,是可以相互依赖的
        2.子模块可以使用顶级工程中所有的资源(依赖), 子模块之间如果有要使用资源的话
          必须构建依赖(构建关系)
        3.一个顶级工程是可以由多个不同的子工程共同组合而成
    --&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!--SpringBoot是和后续的SpringCLoud版本联系的--&gt;
    &lt;/parent&gt;

    &lt;properties&gt; &lt;!--属性文件参数 如果mysql是8以上 需要修改mysql的版本号--&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;

        &lt;mysql-connector-java.version&gt;8.0.33&lt;/mysql-connector-java.version&gt;
        &lt;mybatis-spring-boot-starter.version&gt;2.1.0&lt;/mybatis-spring-boot-starter.version&gt;
        &lt;mapper-spring-boot-starter.version&gt;2.1.5&lt;/mapper-spring-boot-starter.version&gt;
        &lt;pagehelper-spring-boot-starter.version&gt;1.2.12&lt;/pagehelper-spring-boot-starter.version&gt;

        &lt;okhttp.version&gt;4.2.2&lt;/okhttp.version&gt;
        &lt;jackson.version&gt;2.10.2&lt;/jackson.version&gt;

        &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt;
        &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt;
        &lt;commons-fileupload.version&gt;1.4&lt;/commons-fileupload.version&gt;
        &lt;google-guava.version&gt;28.2-jre&lt;/google-guava.version&gt;

        &lt;springfox-swagger2.version&gt;2.4.0&lt;/springfox-swagger2.version&gt;
        &lt;swagger-bootstrap-ui.version&gt;1.6&lt;/swagger-bootstrap-ui.version&gt;
        &lt;fastdfs.version&gt;1.27.2&lt;/fastdfs.version&gt;

        &lt;slf4j.version&gt;1.7.21&lt;/slf4j.version&gt;
        &lt;joda-time.version&gt;2.10.6&lt;/joda-time.version&gt;
    &lt;/properties&gt;

    &lt;!--
        使用dependencyManagement的目的是为了保证父工程的干净，
        也就是说父工程他只负责管理依赖，以及依赖的版本，而不会导入额外的jar依赖。
        如此一来父工程的职责就很单一了，而且也符合了面向对象开发的父子继承关系，
        依赖的导入只有在各自的子工程中才会进行导入。
    --&gt;
&lt;!--  ↓ 管理依赖 不会从外网下载具体jar包 只有在后续子模块配置的时候才会去配置
      为了保证父工程的干净,夫工程中只负责管理依赖,以及依赖的版本,而不会导入额外的jar依赖
      如此一来父工程的职责就很单一了,而且也符合了面向对象开发的父子继承关系
      依赖的导入只有在各自的子工程中才会导入
 --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- SpringCloud 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- 引入 mongodb 依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
                &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
                &lt;!--mongodb-driver.version--&gt;
                &lt;version&gt;3.11.1&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- mysql 驱动  这样引用方便以后jar包依赖的升级--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql-connector-java.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- mybatis --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- 通用mapper逆向工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mapper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--pagehelper --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
                &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;pagehelper-spring-boot-starter.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--服务和服务之间的请求--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
                &lt;version&gt;$&#123;okhttp.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- jackson --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- apache 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-codec&lt;/groupId&gt;
                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-codec.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
                &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- google 工具类 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
                &lt;artifactId&gt;guava&lt;/artifactId&gt;
                &lt;version&gt;$&#123;google-guava.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- swagger2 配置 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.springfox&lt;/groupId&gt;
                &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
                &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
                &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- 文件上传fdfs工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
                &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
                &lt;version&gt;$&#123;fastdfs.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- joda-time 时间工具 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;joda-time&lt;/groupId&gt;
                &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
                &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;

        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- Java 编译 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;
    @GetMapping(&quot;/hello&quot;)
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
  port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">SwitchHosts【一定要先关闭代理 因为它会固定静态ip】
127.0.0.1 user.imoocnews.com

http://user.imoocnews.com:8003/hello
</code></pre>
<h3 id="api接口暴露"><a href="#api接口暴露" class="headerlink" title="api接口暴露"></a>api接口暴露</h3><h6 id="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"><a href="#所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内" class="headerlink" title="所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内"></a>所有业务下不同的controller都要交给api统一接口去处理，把实现所对应的接口写进API内</h6><pre><code class="xml">把imooc-news-dev-service-user中的pom.xml中的关于SpringBoot的依赖
全部放入imooc-news-dev-service-api中
并且在imooc-news-dev-service-user中写入引用依赖
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">【服务层依赖api层】
更改把user项目的HelloController 复制到dev-service-api 创建一个接口

...api
com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;
import org.springframework.web.bind.annotation.GetMapping;

public interface HelloControllerApi &#123;
    /**
     * api的作用：
     * api就相当于企业的领导,老板,部门经理
     * 其他的服务层都是实现,他们就相当于员工,只做事情
     * 老板(开发人员)来看一下每个人(服务)的进度,做什么事
     * 老板不会去问员工,他只会对接部门经理
     * 这里所有的api接口就是统一在这里管理和调度的,微服务也如此
     */

    /**
     * 运作：
     * 现在的所有接口都在此暴露,实现都是在各自的微服务中
     * 本项目只写项目,不写实现,实现在各自的微服务工程中,因为以业务来划分的微服务有很多
     * Controller也会分散在各个微服务工程中,一旦多了就很难统一管理和查看
     *
     * 其次,微服务之间的调用都是基于接口的
     * 如果不这样做,微服务之间的调用就需要互相依赖了
     * 耦合对也就很高,接口的目的是为了能够提供解耦
     *
     * 此外,本项目的接口其实就是一套规范.实现都是由各自的工程去做的处理
     * 目前我们使用springboot作为接口的实现的
     * 如果未来以后出现新的java web框架,那么我们不需要修改接口
     * 只需要去修改对应的实现就可以了,这其实也是解耦的一个体现
     *
     * Swagger2, 基于接口的自动文档生成
     * 所有的配置文件只需要一份,就能再当前项目中去构建了
     * 管理起来很方便
     * 
     * 综上所述,这样做法可以提高多服务的项目可扩展性
     */
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;


...user
com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    public Object hello()&#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="配置logback日志与多环境profile"><a href="#配置logback日志与多环境profile" class="headerlink" title="配置logback日志与多环境profile"></a>配置logback日志与多环境profile</h3><h6 id="imooc-news-dev-service-user-1"><a href="#imooc-news-dev-service-user-1" class="headerlink" title="imooc-news-dev-service-user"></a>imooc-news-dev-service-user</h6><blockquote>
<p>先添加一个logback-spring.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-user.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

        return &quot;hello&quot;;
    &#125;
&#125;
//重新启动后去页面刷新一下
......
29:22.373 [main] INFO  com.imooc.user.Application - Started Application in 1.061 seconds (JVM running for 1.543)
29:40.693 [http-nio-8003-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
29:40.694 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
29:40.696 [http-nio-8003-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 2 ms
29:40.707 [http-nio-8003-exec-1] INFO  c.i.user.controller.HelloController - info: hello~
29:40.707 [http-nio-8003-exec-1] WARN  c.i.user.controller.HelloController - warn: hello~
29:40.707 [http-nio-8003-exec-1] ERROR c.i.user.controller.HelloController - error: hello~
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<pre><code class="java">application-dev.yml
server:
  port: 8003


application-prod.yml
server:
  port: 8130
</code></pre>
<h3 id="优雅的返回封装结果"><a href="#优雅的返回封装结果" class="headerlink" title="优雅的返回封装结果"></a>优雅的返回封装结果</h3><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.IMOOCJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/IMOOCJSONResult.java
package com.imooc.grace.result;

/**
 * 
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 * 
 *                 200：表示成功
 *                 500：表示错误，错误信息在msg字段中
 *                 501：bean验证错误，不管多少个错误都以map形式返回
 *                 502：拦截器拦截到用户token出错
 *                 555：异常抛出信息
 *                 556: 用户qq校验异常
 *                 557: 校验用户是否在CAS登录，用户门票的校验
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V1.0
 * 这样太麻烦了 直接用枚举类
 */
public class IMOOCJSONResult &#123;

    // 响应业务状态
    private Integer status;

    // 响应消息
    private String msg;

    // 响应中的数据
    private Object data;
    
    private String ok;    // 不使用

    public static IMOOCJSONResult build(Integer status, String msg, Object data) &#123;
        return new IMOOCJSONResult(status, msg, data);
    &#125;

    public static IMOOCJSONResult build(Integer status, String msg, Object data, String ok) &#123;
        return new IMOOCJSONResult(status, msg, data, ok);
    &#125;
    
    public static IMOOCJSONResult ok(Object data) &#123;
        return new IMOOCJSONResult(data);
    &#125;

    public static IMOOCJSONResult ok() &#123;
        return new IMOOCJSONResult(null);
    &#125;
    
    public static IMOOCJSONResult errorMsg(String msg) &#123;
        return new IMOOCJSONResult(500, msg, null);
    &#125;

    public static IMOOCJSONResult errorUserTicket(String msg) &#123;
        return new IMOOCJSONResult(557, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorMap(Object data) &#123;
        return new IMOOCJSONResult(501, &quot;error&quot;, data);
    &#125;
    
    public static IMOOCJSONResult errorTokenMsg(String msg) &#123;
        return new IMOOCJSONResult(502, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorException(String msg) &#123;
        return new IMOOCJSONResult(555, msg, null);
    &#125;
    
    public static IMOOCJSONResult errorUserQQ(String msg) &#123;
        return new IMOOCJSONResult(556, msg, null);
    &#125;

    public IMOOCJSONResult() &#123;

    &#125;

    public IMOOCJSONResult(Integer status, String msg, Object data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;
    
    public IMOOCJSONResult(Integer status, String msg, Object data, String ok) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
        this.ok = ok;
    &#125;

    public IMOOCJSONResult(Object data) &#123;
        this.status = 200;
        this.msg = &quot;OK&quot;;
        this.data = data;
    &#125; Getter+Setter
</code></pre>
<h6 id="这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！"><a href="#这样太麻烦而且观察起来不方便-升级一下变成枚举类-更加优雅！" class="headerlink" title="这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！"></a>这样太麻烦而且观察起来不方便 升级一下变成枚举类 更加优雅！</h6><pre><code class="java">com/imooc/user/controller/HelloController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.IMOOCJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        logger.debug(&quot;debug: hello~&quot;);
        logger.info(&quot;info: hello~&quot;);
        logger.warn(&quot;warn: hello~&quot;);
        logger.error(&quot;error: hello~&quot;);

//        return &quot;hello&quot;;
//        return IMOOCJSONResult.ok();
//        return IMOOCJSONResult.ok(&quot;hello!&quot;);
//        return IMOOCJSONResult.errorMsg(&quot;您的信息有误&quot;);
        return GraceJSONResult.errorCustom(ResponseStatusEnum.NO_AUTH);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<h3 id="配置数据库逆向生成实体类"><a href="#配置数据库逆向生成实体类" class="headerlink" title="配置数据库逆向生成实体类"></a>配置数据库逆向生成实体类</h3><h6 id="引入mybatis-generator-database-新建工程项目"><a href="#引入mybatis-generator-database-新建工程项目" class="headerlink" title="引入mybatis-generator-database[新建工程项目]"></a>引入mybatis-generator-database[新建工程项目]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-database&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


    &lt;dependencies&gt;

        &lt;!-- 引入log4j日志依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;
            &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 阿里开源数据源 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.41&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mapper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--pagehelper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis 逆向生成工具  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoheihai666/article/details/125936493">dependencymanagement 无法引入包依赖-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stKAnic/article/details/121380871?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-121380871-blog-121295199.235%5Ev43%5Epc_blog_bottom_relevance_base6">关于Maven依赖dependency无法引入的问题_<dependencymanagement> 无法引入包-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46411355/article/details/131312807">Maven配置仓库、阿里云镜像、环境变量（史上最全最详细）_maven配置阿里云镜像-CSDN博客</a></p>
<pre><code class="java">将mybatis-generator-database中的pojo[AppUser+Fans]复制转移到imooc-news-dev-model com/imooc/pojo中
将mybatis-generator-database中的com/imooc/user/mapper[AppUserMapper、FansMapper]复制转移到imooc-news-service-user com/imooc/user/mapper中
所有的服务都是要实现API的
将mybatis-generator-database中的com/imooc/my/mapper[MyMapper]复制转移到imooc-news-dev-service-api com/imooc/my/mapper中
将..database中的resources的mapper[AppUserMapper.xml、FansMapper.xml]转移到...service-user的resources的mapper中
</code></pre>
<pre><code class="yaml">imooc-news-dev-service-user中的resources的application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-user
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: com.mysql.jdbc.Driver          # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hkdhkdhkd/article/details/113869035">【解决】SLF4J: Class path contains multiple SLF4J bindings._启动metastore时slf4j: class path contains multiple sl-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huifeidezhuzai/p/16352608.html">整合MongoDB踩坑记录及解决方法 - 会飞的猪仔 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(&quot;com.imooc&quot;)
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="Swagger2接口文檔工具的使用"><a href="#Swagger2接口文檔工具的使用" class="headerlink" title="Swagger2接口文檔工具的使用"></a>Swagger2接口文檔工具的使用</h3><h6 id="imooc-news-dev-service-api-1"><a href="#imooc-news-dev-service-api-1" class="headerlink" title="imooc-news-dev-service-api"></a>imooc-news-dev-service-api</h6><pre><code class="xml">&lt;!-- swagger2 配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;springfox-swagger2.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
            &lt;version&gt;$&#123;swagger-bootstrap-ui.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
//http://user.imoocnews.com:8003/swagger-ui.htm
    //    http://localhost:8088/doc.html            新路径
//http://user.imoocnews.com:8003/doc.html

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/HelloControllerApi.java
package com.imooc.api.controller.user;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;controller的標題&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
public interface HelloControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/hello&quot;)
    public Object hello();
&#125;
</code></pre>
<p>[maven-之Lifecycle详解_maven lifecycle-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39505065/article/details/102915403#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86">https://blog.csdn.net/qq_39505065/article/details/102915403#第三部分</a> PS)</p>
<blockquote>
<p>Maven中的Lifecycle的install是什麽 ？<br>将包安装到本地存储库中，作为本地其他项目的依赖项</p>
</blockquote>
<h3 id="梳理短信登錄注冊流程"><a href="#梳理短信登錄注冊流程" class="headerlink" title="梳理短信登錄注冊流程"></a>梳理短信登錄注冊流程</h3><ul>
<li>短信登录注册</li>
<li>短信验证码发送与限制</li>
<li>分布式会话</li>
<li>用户信息完善，OSS&#x2F;FastDFS文件上传</li>
<li>AOP日志监控</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/87e42b65e3e64f84efebcf347d7bd0180b448627/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e4dcd13c468e5883cfd3187c6c2800cf2bc4168f/data/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C2.png"></p>
<pre><code class="xml">aliyun.properties
#这里需要去阿里云上购买短信验证 [电脑aliyun_Key.txt有]
aliyun.accessKeyID=
aliyun.accessKeySecret=
</code></pre>
<p><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api/Dysmsapi/2017-05-25/SendSms?params=%7B%22SignName%22:%22%E5%B0%8F%E6%BD%98%E7%A7%91%E6%8A%80%22,%22TemplateCode%22:%22SMS_467115116%22,%22PhoneNumbers%22:%2215027597319%22,%22TemplateParam%22:%22%7B%22code%22:%221234%22%7D%22%7D">SendSms_短信服务_API调试-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://next.api.aliyun.com/api-tools/demo/Dysmsapi/db7e1211-14e0-4b7b-9011-037dfb85d42e">短信发送并查询示例_短信服务_示例中心-阿里云OpenAPI开发者门户 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/manage/ak">RAM 访问控制 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://dysms.console.aliyun.com/overview">短信服务 (aliyun.com)</a><br><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<pre><code class="xml">【imooc-news-dev-common】
pom.xml
加入springboot依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/extend/AliyunResource.java
package com.imooc.utils.extend;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:aliyun.properties&quot;)
@ConfigurationProperties(prefix = &quot;aliyun&quot;) //这里是前缀
public class AliyunResource &#123;
    private String accessKeyID;
    private String accessKeySecret;

    public String getAccessKeyID() &#123;
        return accessKeyID;
    &#125;

    public void setAccessKeyID(String accessKeyID) &#123;
        this.accessKeyID = accessKeyID;
    &#125;

    public String getAccessKeySecret() &#123;
        return accessKeySecret;
    &#125;

    public void setAccessKeySecret(String accessKeySecret) &#123;
        this.accessKeySecret = accessKeySecret;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/SMSUtils.java
package com.imooc.utils;

import com.aliyuncs.CommonRequest;
import com.aliyuncs.CommonResponse;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.exceptions.ServerException;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.profile.DefaultProfile;
import com.imooc.utils.extend.AliyunResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //工具类 可以作为组件
public class SMSUtils &#123;
    @Autowired
    public AliyunResource aliyunResource;
    final static Logger logger = LoggerFactory.getLogger(SMSUtils.class);
    public void sendSMS(String mobile, String code) &#123;
        DefaultProfile profile = DefaultProfile.getProfile(&quot;cn-hangzhou&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);

        CommonRequest request = new CommonRequest();
        request.setSysMethod(MethodType.POST);
        request.setSysDomain(&quot;dysmsapi.aliyuncs.com&quot;);
        request.setSysVersion(&quot;2017-05-25&quot;);
        request.setSysAction(&quot;SendSms&quot;);
        request.putQueryParameter(&quot;RegionId&quot;, &quot;cn-hangzhou&quot;);
        //给对方发送的手机号
        request.putQueryParameter(&quot;PhoneNumbers&quot;, mobile);
        request.putQueryParameter(&quot;SignName&quot;, &quot;小潘科技&quot;);//控制台可以添加签名
        request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_467115116&quot;);
        request.putQueryParameter(&quot;TemplateParam&quot;, &quot;&#123;\&quot;code\&quot;:\&quot;&quot; + code + &quot;\&quot;&#125;&quot;);//JSON对象字符串
        try &#123;
            CommonResponse response = client.getCommonResponse(request);
            System.out.println(response.getData());
            // 打印阿里云API的响应结果
            logger.info(&quot;Aliyun SMS API response: &quot; + response.getData());
        &#125; catch (ServerException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ServerException: &quot; + e.getMessage());
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
            logger.error(&quot;ClientException: &quot; + e.getMessage());
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java[接口]
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode();
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode()&#123;
        // 生成6位随机验证码
        String random = String.valueOf((int)((Math.random() * 9 + 1) * 100000));
        // 打印生成的验证码以便调试
        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
        logger.info(&quot;SMS sent to 15027597000 with code: &quot; + random);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/grace/result/GraceJSONResult.java
package com.imooc.grace.result;

import java.util.Map;

/**
 * 自定义响应数据类型枚举升级版本
 *
 * @Title: IMOOCJSONResult.java
 * @Package com.imooc.utils
 * @Description: 自定义响应数据结构
 *                 本类可提供给 H5/ios/安卓/公众号/小程序 使用
 *                 前端接受此类数据（json object)后，可自行根据业务去实现相关功能
 *
 * @Copyright: Copyright (c) 2020
 * @Company: www.imooc.com
 * @author 慕课网 - 风间影月
 * @version V2.0
 */
public class GraceJSONResult &#123;

    // 响应业务状态码
    private Integer status;

    // 响应消息
    private String msg;

    // 是否成功
    private Boolean success;

    // 响应数据，可以是Object，也可以是List或Map等
    private Object data;

    /**
     * 成功返回，带有数据的，直接往OK方法丢data数据即可
     * @param data
     * @return
     */
    public static GraceJSONResult ok(Object data) &#123;
        return new GraceJSONResult(data);
    &#125;
    /**
     * 成功返回，不带有数据的，直接调用ok方法，data无须传入（其实就是null）
     * @return
     */
    public static GraceJSONResult ok() &#123;
        return new GraceJSONResult(ResponseStatusEnum.SUCCESS);
    &#125;
    public GraceJSONResult(Object data) &#123;
        this.status = ResponseStatusEnum.SUCCESS.status();
        this.msg = ResponseStatusEnum.SUCCESS.msg();
        this.success = ResponseStatusEnum.SUCCESS.success();
        this.data = data;
    &#125;


    /**
     * 错误返回，直接调用error方法即可，当然也可以在ResponseStatusEnum中自定义错误后再返回也都可以
     * @return
     */
    public static GraceJSONResult error() &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED);
    &#125;

    /**
     * 错误返回，map中包含了多条错误信息，可以用于表单验证，把错误统一的全部返回出去
     * @param map
     * @return
     */
    public static GraceJSONResult errorMap(Map map) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, map);
    &#125;

    /**
     * 错误返回，直接返回错误的消息
     * @param msg
     * @return
     */
    public static GraceJSONResult errorMsg(String msg) &#123;
        return new GraceJSONResult(ResponseStatusEnum.FAILED, msg);
    &#125;

    /**
     * 错误返回，token异常，一些通用的可以在这里统一定义
     * @return
     */
    public static GraceJSONResult errorTicket() &#123;
        return new GraceJSONResult(ResponseStatusEnum.TICKET_INVALID);
    &#125;

    /**
     * 自定义错误范围，需要传入一个自定义的枚举，可以到[ResponseStatusEnum.java[中自定义后再传入
     * @param responseStatus
     * @return
     */
    public static GraceJSONResult errorCustom(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;
    public static GraceJSONResult exception(ResponseStatusEnum responseStatus) &#123;
        return new GraceJSONResult(responseStatus);
    &#125;

    public GraceJSONResult(ResponseStatusEnum responseStatus) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, Object data) &#123;
        this.status = responseStatus.status();
        this.msg = responseStatus.msg();
        this.success = responseStatus.success();
        this.data = data;
    &#125;
    public GraceJSONResult(ResponseStatusEnum responseStatus, String msg) &#123;
        this.status = responseStatus.status();
        this.msg = msg;
        this.success = responseStatus.success();
    &#125;

    public GraceJSONResult() &#123;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

    public Boolean getSuccess() &#123;
        return success;
    &#125;

    public void setSuccess(Boolean success) &#123;
        this.success = success;
    &#125;
&#125;
</code></pre>
<h3 id="安装配置整合Redis"><a href="#安装配置整合Redis" class="headerlink" title="安装配置整合Redis"></a>安装配置整合Redis</h3><pre><code class="mysql">通过Xftp7把redis-5.0.7.tar.gz传入到服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# tar -zxvf redis-5.0.7.tar.gz 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
apache-zookeeper-3.6.0-bin         rabbitmq-server-3.8.2-1.el7.noarch.rpm
apache-zookeeper-3.6.0-bin.tar.gz  redis-5.0.7
erlang-22.3-1.el7.x86_64.rpm       redis-5.0.7.tar.gz
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ll
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# yum install gcc-c++
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# make
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/ ★
[root@iZbp1dssknxftmjczbtpndZ local]# ll
[root@iZbp1dssknxftmjczbtpndZ local]# pwd
/usr/local
[root@iZbp1dssknxftmjczbtpndZ local]# cd redis/ ★
[root@iZbp1dssknxftmjczbtpndZ redis]# ll
total 4
drwxr-xr-x 2 root root 4096 May 15 11:19 bin
[root@iZbp1dssknxftmjczbtpndZ redis]# cd bin ★
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32772
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root       0 May 15 11:19 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ redis]# cd
[root@iZbp1dssknxftmjczbtpndZ ~]# cd redis-5.0.7
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# ls
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cp redis.conf /usr/local/redis/bin/
cp: overwrite ‘/usr/local/redis/bin/redis.conf’? y
[root@iZbp1dssknxftmjczbtpndZ redis-5.0.7]# cd /usr/local/redis/bin/
[root@iZbp1dssknxftmjczbtpndZ bin]# ll
total 32836
-rwxr-xr-x 1 root root 4366880 May 15 11:04 redis-benchmark
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-aof
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-check-rdb
-rwxr-xr-x 1 root root 4807952 May 15 11:04 redis-cli
-rw-r--r-- 1 root root   61797 May 15 11:28 redis.conf
lrwxrwxrwx 1 root root      12 May 15 11:04 redis-sentinel -&gt; redis-server
-rwxr-xr-x 1 root root 8125288 May 15 11:04 redis-server
[root@iZbp1dssknxftmjczbtpndZ bin]# vim redis.conf
在里面 /bind 直接搜索
把bind 127.0.0.1修改成 0.0.0.0在任何地方都可以进行操作修改
在里面 /dae
把daemonize no 改成 daemonize yes[后台启动]
在里面 /require
把requirepass foobared 这里是设置密码 requirepass XXXX
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf ★
32421:C 15 May 2024 11:35:36.687 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
32421:C 15 May 2024 11:35:36.687 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=32421, just started
32421:C 15 May 2024 11:35:36.687 # Configuration loaded
[root@iZbp1dssknxftmjczbtpndZ bin]# ps -ef|grep redis
root     32422     1  0 11:35 ?        00:00:00 ./redis-server 0.0.0.0:6379
root     32456 25226  0 11:35 pts/0    00:00:00 grep --color=auto redis
【此时说明已经成功启动Redis】
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli ★
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt; set name imooc
OK
127.0.0.1:6379&gt; get name
&quot;imooc&quot;
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli -p 6379 shutdown

★直接进入redis文件内★
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/local/redis/bin       //进入文件内
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-server redis.conf   //启动
[root@iZbp1dssknxftmjczbtpndZ bin]# ./redis-cli                 //测试
★★
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hu4545/article/details/126174419">Linux下Redis服务启动与关闭_linux 关闭redis-CSDN博客</a></p>
<h3 id="安装配置整合Redis-2"><a href="#安装配置整合Redis-2" class="headerlink" title="安装配置整合Redis-2"></a>安装配置整合Redis-2</h3><blockquote>
<p>下载并安装好 Redis Desktop Manager<br>新连接设置<br>名字：redis-imooc-news 47.98.225.105<br>地址：47.98.225.105：6379</p>
</blockquote>
<pre><code class="xml">加一下redis的依赖
imooc-news-dev-common
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
&lt;!--
    imooc-news-dev-common:
    通用工程
    包含了一些工具类,枚举类,封装的一些公共方法以及一些第三方组件等
--&gt;
    &lt;artifactId&gt;imooc-news-dev-common&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--    引入SpringBoot依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 引入 redis 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
            &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- jackson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- apache 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- google 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
            &lt;artifactId&gt;guava&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- joda-time 时间工具 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;joda-time&lt;/groupId&gt;
            &lt;artifactId&gt;joda-time&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--  第三方云厂商相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/utils/RedisOperator.java
package com.imooc.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.StringRedisConnection;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @Title: Redis 工具类
 * @author 风间影月
 */
@Component
public class RedisOperator &#123;
    
    @Resource
    private StringRedisTemplate redisTemplate;

    // Key（键），简单的key-value操作

    /**
     * 判断key是否存在
     * @param key
     * @return
     */
    public boolean keyIsExist(String key) &#123;
        return redisTemplate.hasKey(key);
    &#125;

    /**
     * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。
     * 
     * @param key
     * @return
     */
    public long ttl(String key) &#123;
        return redisTemplate.getExpire(key);
    &#125;
    
    /**
     * 实现命令：expire 设置过期时间，单位秒
     * 
     * @param key
     * @return
     */
    public void expire(String key, long timeout) &#123;
        redisTemplate.expire(key, timeout, TimeUnit.SECONDS);
    &#125;
    
    /**
     * 实现命令：increment key，增加key一次
     * 
     * @param key
     * @return
     */
    public long increment(String key, long delta) &#123;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;

    /**
     * 实现命令：decrement key，减少key一次
     *
     * @param key
     * @return
     */
    public long decrement(String key, long delta) &#123;
        return redisTemplate.opsForValue().decrement(key, delta);
    &#125;

    /**
     * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key
     */
    public Set&lt;String&gt; keys(String pattern) &#123;
        return redisTemplate.keys(pattern);
    &#125;

    /**
     * 实现命令：DEL key，删除一个key
     * 
     * @param key
     */
    public void del(String key) &#123;
        redisTemplate.delete(key);
    &#125;

    // String（字符串）

    /**
     * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key）
     * 
     * @param key
     * @param value
     */
    public void set(String key, String value) &#123;
        redisTemplate.opsForValue().set(key, value);
    &#125;

    /**
     * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒）
     * 
     * @param key
     * @param value
     * @param timeout
     *            （以秒为单位）
     */
    public void set(String key, String value, long timeout) &#123;
        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx60s(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value, 60, TimeUnit.SECONDS);
    &#125;

    /**
     * 如果key不存在，则设置，如果存在，则报错
     * @param key
     * @param value
     */
    public void setnx(String key, String value) &#123;
        redisTemplate.opsForValue().setIfAbsent(key, value);
    &#125;

    /**
     * 实现命令：GET key，返回 key所关联的字符串值。
     * 
     * @param key
     * @return value
     */
    public String get(String key) &#123;
        return (String)redisTemplate.opsForValue().get(key);
    &#125;

    /**
     * 批量查询，对应mget
     * @param keys
     * @return
     */
    public List&lt;String&gt; mget(List&lt;String&gt; keys) &#123;
        return redisTemplate.opsForValue().multiGet(keys);
    &#125;

    /**
     * 批量查询，管道pipeline
     * @param keys
     * @return
     */
    public List&lt;Object&gt; batchGet(List&lt;String&gt; keys) &#123;

//        nginx -&gt; keepalive
//        redis -&gt; pipeline

        List&lt;Object&gt; result = redisTemplate.executePipelined(new RedisCallback&lt;String&gt;() &#123;
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException &#123;
                StringRedisConnection src = (StringRedisConnection)connection;

                for (String k : keys) &#123;
                    src.get(k);
                &#125;
                return null;
            &#125;
        &#125;);

        return result;
    &#125;


    // Hash（哈希表）

    /**
     * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value
     * 
     * @param key
     * @param field
     * @param value
     */
    public void hset(String key, String field, Object value) &#123;
        redisTemplate.opsForHash().put(key, field, value);
    &#125;

    /**
     * 实现命令：HGET key field，返回哈希表 key中给定域 field的值
     * 
     * @param key
     * @param field
     * @return
     */
    public String hget(String key, String field) &#123;
        return (String) redisTemplate.opsForHash().get(key, field);
    &#125;

    /**
     * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
     * 
     * @param key
     * @param fields
     */
    public void hdel(String key, Object... fields) &#123;
        redisTemplate.opsForHash().delete(key, fields);
    &#125;

    /**
     * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。
     * 
     * @param key
     * @return
     */
    public Map&lt;Object, Object&gt; hgetall(String key) &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    // List（列表）

    /**
     * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long lpush(String key, String value) &#123;
        return redisTemplate.opsForList().leftPush(key, value);
    &#125;

    /**
     * 实现命令：LPOP key，移除并返回列表 key的头元素。
     * 
     * @param key
     * @return 列表key的头元素。
     */
    public String lpop(String key) &#123;
        return (String)redisTemplate.opsForList().leftPop(key);
    &#125;

    /**
     * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。
     * 
     * @param key
     * @param value
     * @return 执行 LPUSH命令后，列表的长度。
     */
    public long rpush(String key, String value) &#123;
        return redisTemplate.opsForList().rightPush(key, value);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337066868">Spring Boot集成Redis的坑，踩了！ - 知乎 (zhihu.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45590494/article/details/114444371">@Autowired和@Resource注解的区别和联系（十分详细，不看后悔）_为什么@resource和@autowired 注入的对象不一样-CSDN博客</a></p>
<blockquote>
<p>妈的有个超级大bug 整我一下午，<br>@Component public class RedisOperator {<br>@Autowired private StringRedisTemplate redisTemplate;}<br> 报错信息 Could not autowire. No beans of ‘StringRedisTemplate’ type found.</p>
<p>在这里不要本末倒置 回归最原始的报错 那就是pom.xml中的导包依赖问题<br>有的时候直接复制的项目中的成熟依赖 根据时代的不同可能会导致丢失无法下载依赖<br>这时要去百度Maven库手动下载 并且手动添加 然后手动导入Project Structure → Libraries 手动导入自己需要的包[记住包的版本 也要在依赖里面体现 &lt; version &gt;]，而且如果有红色波浪线的包可以删除 再重新导入即可</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h3 id="完善发送短信接口"><a href="#完善发送短信接口" class="headerlink" title="完善发送短信接口"></a>完善发送短信接口</h3><pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request);
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.controller.user.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.imooc.utils.IPUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
// 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
//    @Autowired
//    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        String userIp = IPUtil.getRequestIp(request);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
//        redis.setnx60s(&quot;smscode&quot;+ip);
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot;+userIp,userIp);

        //生成随机验证码并且发送短信
        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替

        //把验证码存入redis,用于后续进行验证
        redis.set(MOBILE_SMSCODE+&quot;:&quot;+mobile, random, 30*60);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/BaseController.java
package com.imooc.api.controller.user;

import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

&#125;
</code></pre>
<pre><code class="java">com/imooc/utils/IPUtil.java
package com.imooc.utils;

import javax.servlet.http.HttpServletRequest;

/**
 * 用户获得用户ip的工具类
 */
public class IPUtil &#123;

    /**
     * 获取请求IP:
     * 用户的真实IP不能使用request.getRemoteAddr()
     * 这是因为可能会使用一些代理软件，这样ip获取就不准确了
     * 此外我们如果使用了多级（LVS/Nginx）反向代理的话，ip需要从X-Forwarded-For中获得第一个非unknown的IP才是用户的有效ip。
     * @param request
     * @return
     */
    public static String getRequestIp(HttpServletRequest request) &#123;
        String ip = request.getHeader(&quot;x-forwarded-for&quot;);
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);
        &#125;
        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;
            ip = request.getRemoteAddr();
        &#125;
        return ip;
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/sms/getting-started/use-sms-console-1?spm=a2c4g.11186623.0.0.70707f5cATZOcJ">快速使用 在控制台发送短信_短信服务(SMS)-阿里云帮助中心 (aliyun.com)</a></p>
</blockquote>
<h3 id="联调前端发送短信-解决跨域问题"><a href="#联调前端发送短信-解决跨域问题" class="headerlink" title="联调前端发送短信, 解决跨域问题"></a>联调前端发送短信, 解决跨域问题</h3><pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/passport.html
因为后台写死了手机号 所以在输入手机号可以随便 点击发送验证码后 会在浏览器控制台输出跨域问题 在后端要設置允許跨域請求
-----------------------------------------------------------------------------------
passport.html:1  Access to XMLHttpRequest at &#39;http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323&#39; from origin &#39;http://writer.imoocnews.com:9090&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.

GET http://user.imoocnews.com:8003/passport/getSMSCode?mobile=123334323 net::ERR_FAILED 200 (OK)
axios.min.js:2  Uncaught (in promise) Error: Network Error
    at e.exports (axios.min.js:2:9633)
    at l.onerror (axios.min.js:2:8398)
</code></pre>
<pre><code class="java">...service-api  com/imooc/api/config/CorsConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration //SpringBoot可以加载该信息
public class CorsConfig &#123;

    public CorsConfig() &#123;
    &#125;

    @Bean
    public CorsFilter corsFilter() &#123;
        // 1. 添加cors配置信息
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin(&quot;*&quot;);
        // 设置是否发送cookie信息
        config.setAllowCredentials(true);
        // 设置允许请求的方式
        config.addAllowedMethod(&quot;*&quot;);
        // 设置允许的header
        config.addAllowedHeader(&quot;*&quot;);
        // 2. 为url添加映射路径
        UrlBasedCorsConfigurationSource corsSource = new UrlBasedCorsConfigurationSource();
        corsSource.registerCorsConfiguration(&quot;/**&quot;, config);
        // 3. 返回重新定义好的corsSource
        return new CorsFilter(corsSource);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
   //记得如果要发送到redis中 则需要先用application-dev.yml导入RedisDesktopManager正确的网络地址127.0.0.1 
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);
&#125;
</code></pre>
<h3 id="拦截并限制60秒用户短信发送"><a href="#拦截并限制60秒用户短信发送" class="headerlink" title="拦截并限制60秒用户短信发送"></a>拦截并限制60秒用户短信发送</h3><pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/password/getSMSCode&quot;); //拦截PassportControllerApi里的信息
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/api/interceptors/PassportInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

    public class PassportInterceptor implements HandlerInterceptor &#123;

        @Autowired
        public RedisOperator redis;

        public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

        /**
         * 拦截请求，访问controller之前
         * @param request
         * @param response
         * @param handler
         * @return
         * @throws Exception
         */
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

            // 获得用户ip
            String userIp = IPUtil.getRequestIp(request);

            boolean keyIsExist = redis.keyIsExist(MOBILE_SMSCODE + &quot;:&quot; + userIp);

            if (keyIsExist) &#123;
                GraceException.display(ResponseStatusEnum.SMS_NEED_WAIT_ERROR);
//            System.out.println(&quot;短信发送频率太大！&quot;);
                return false;
            &#125;

            /**
             * false：请求被拦截
             * true：请求通过验证，放行
             */
            return true;
        &#125;


        /**
         * 请求访问到controller之后，渲染视图之前
         * @param request
         * @param response
         * @param handler
         * @param modelAndView
         * @throws Exception
         */
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

        &#125;

        /**
         * 请求访问到controller之后，渲染视图之后
         * @param request
         * @param response
         * @param handler
         * @param ex
         * @throws Exception
         */
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

        &#125;
    &#125;
</code></pre>
<pre><code class="java">dev-common com/imooc/exception/GraceException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 优雅的处理异常，统一封装
 */
public class GraceException &#123;

    public static void display(ResponseStatusEnum responseStatusEnum) &#123;
        throw new MyCustomException(responseStatusEnum);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/exception/MyCustomException.java
package com.imooc.exception;

import com.imooc.grace.result.ResponseStatusEnum;

/**
 * 自定义异常
 * 目的：统一处理异常信息
 *      便于解耦，service与controller错误的解耦，不会被service返回的类型而限制
 */
public class MyCustomException extends RuntimeException &#123;

    private ResponseStatusEnum responseStatusEnum;

    public MyCustomException(ResponseStatusEnum responseStatusEnum) &#123;
        super(&quot;异常状态码为：&quot; + responseStatusEnum.status()
                + &quot;；具体异常信息为：&quot; + responseStatusEnum.msg());
        this.responseStatusEnum = responseStatusEnum;
    &#125;

    public ResponseStatusEnum getResponseStatusEnum() &#123;
        return responseStatusEnum;
    &#125;

    public void setResponseStatusEnum(ResponseStatusEnum responseStatusEnum) &#123;
        this.responseStatusEnum = responseStatusEnum;
    &#125;
&#125;
</code></pre>
<h3 id="自定义异常-返回错误信息"><a href="#自定义异常-返回错误信息" class="headerlink" title="自定义异常, 返回错误信息"></a>自定义异常, 返回错误信息</h3><h6 id="接上方GraceException、MyCustomException、PassportInterceptor"><a href="#接上方GraceException、MyCustomException、PassportInterceptor" class="headerlink" title="[接上方GraceException、MyCustomException、PassportInterceptor]"></a>[接上方GraceException、MyCustomException、PassportInterceptor]</h6><pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
package com.imooc.grace.result;

/**
 * 响应结果枚举，用于提供给GraceJSONResult返回给前端的
 * 本枚举类中包含了很多的不同的状态码供使用，可以自定义
 * 便于更优雅的对状态码进行管理，一目了然
 */
public enum ResponseStatusEnum &#123;

    SUCCESS(200, true, &quot;操作成功！&quot;),
    FAILED(500, false, &quot;操作失败！&quot;),

    // 50x
    UN_LOGIN(501,false,&quot;请登录后再继续操作！&quot;),
    TICKET_INVALID(502,false,&quot;会话失效，请重新登录！&quot;),
    NO_AUTH(503,false,&quot;您的权限不足，无法继续操作！&quot;),
    MOBILE_ERROR(504,false,&quot;短信发送失败，请稍后重试！&quot;),
    SMS_NEED_WAIT_ERROR(505,false,&quot;短信发送太快啦~请稍后再试！&quot;),
    SMS_CODE_ERROR(506,false,&quot;验证码过期或不匹配，请稍后再试！&quot;),
    USER_FROZEN(507,false,&quot;用户已被冻结，请联系管理员！&quot;),
    USER_UPDATE_ERROR(508,false,&quot;用户信息更新失败，请联系管理员！&quot;),
    USER_INACTIVE_ERROR(509,false,&quot;请前往[账号设置]修改信息激活后再进行后续操作！&quot;),
    FILE_UPLOAD_NULL_ERROR(510,false,&quot;文件不能为空，请选择一个文件再上传！&quot;),
    FILE_UPLOAD_FAILD(511,false,&quot;文件上传失败！&quot;),
    FILE_FORMATTER_FAILD(512,false,&quot;文件图片格式不支持！&quot;),
    FILE_MAX_SIZE_ERROR(513,false,&quot;仅支持500kb大小以下的图片上传！&quot;),
    FILE_NOT_EXIST_ERROR(514,false,&quot;你所查看的文件不存在！&quot;),
    USER_STATUS_ERROR(515,false,&quot;用户状态参数出错！&quot;),
    USER_NOT_EXIST_ERROR(516,false,&quot;用户不存在！&quot;),

    // 自定义系统级别异常 54x
    SYSTEM_INDEX_OUT_OF_BOUNDS(541, false, &quot;系统错误，数组越界！&quot;),
    SYSTEM_ARITHMETIC_BY_ZERO(542, false, &quot;系统错误，无法除零！&quot;),
    SYSTEM_NULL_POINTER(543, false, &quot;系统错误，空指针！&quot;),
    SYSTEM_NUMBER_FORMAT(544, false, &quot;系统错误，数字转换异常！&quot;),
    SYSTEM_PARSE(545, false, &quot;系统错误，解析异常！&quot;),
    SYSTEM_IO(546, false, &quot;系统错误，IO输入输出异常！&quot;),
    SYSTEM_FILE_NOT_FOUND(547, false, &quot;系统错误，文件未找到！&quot;),
    SYSTEM_CLASS_CAST(548, false, &quot;系统错误，类型强制转换错误！&quot;),
    SYSTEM_PARSER_ERROR(549, false, &quot;系统错误，解析出错！&quot;),
    SYSTEM_DATE_PARSER_ERROR(550, false, &quot;系统错误，日期解析出错！&quot;),

    // admin 管理系统 56x
    ADMIN_USERNAME_NULL_ERROR(561, false, &quot;管理员登录名不能为空！&quot;),
    ADMIN_USERNAME_EXIST_ERROR(562, false, &quot;管理员登录名已存在！&quot;),
    ADMIN_NAME_NULL_ERROR(563, false, &quot;管理员负责人不能为空！&quot;),
    ADMIN_PASSWORD_ERROR(564, false, &quot;密码不能为空后者两次输入不一致！&quot;),
    ADMIN_CREATE_ERROR(565, false, &quot;添加管理员失败！&quot;),
    ADMIN_PASSWORD_NULL_ERROR(566, false, &quot;密码不能为空！&quot;),
    ADMIN_NOT_EXIT_ERROR(567, false, &quot;管理员不存在或密码错误！&quot;),
    ADMIN_FACE_NULL_ERROR(568, false, &quot;人脸信息不能为空！&quot;),
    ADMIN_FACE_LOGIN_ERROR(569, false, &quot;人脸识别失败，请重试！&quot;),
    CATEGORY_EXIST_ERROR(570, false, &quot;文章分类已存在，请换一个分类名！&quot;),

    // 媒体中心 相关错误 58x
    ARTICLE_COVER_NOT_EXIST_ERROR(580, false, &quot;文章封面不存在，请选择一个！&quot;),
    ARTICLE_CATEGORY_NOT_EXIST_ERROR(581, false, &quot;请选择正确的文章领域！&quot;),
    ARTICLE_CREATE_ERROR(582, false, &quot;创建文章失败，请重试或联系管理员！&quot;),
    ARTICLE_QUERY_PARAMS_ERROR(583, false, &quot;文章列表查询参数错误！&quot;),
    ARTICLE_DELETE_ERROR(584, false, &quot;文章删除失败！&quot;),
    ARTICLE_WITHDRAW_ERROR(585, false, &quot;文章撤回失败！&quot;),
    ARTICLE_REVIEW_ERROR(585, false, &quot;文章审核出错！&quot;),
    ARTICLE_ALREADY_READ_ERROR(586, false, &quot;文章重复阅读！&quot;),

    // 人脸识别错误代码
    FACE_VERIFY_TYPE_ERROR(600, false, &quot;人脸比对验证类型不正确！&quot;),
    FACE_VERIFY_LOGIN_ERROR(601, false, &quot;人脸登录失败！&quot;),

    // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;);


    // 响应业务状态
    private Integer status;
    // 调用是否成功
    private Boolean success;
    // 响应消息，可以为成功或者失败的消息
    private String msg;

    ResponseStatusEnum(Integer status, Boolean success, String msg) &#123;
        this.status = status;
        this.success = success;
        this.msg = msg;
    &#125;

    public Integer status() &#123;
        return status;
    &#125;
    public Boolean success() &#123;
        return success;
    &#125;
    public String msg() &#123;
        return msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice //本质上是实现AOP的管理
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;
&#125;
</code></pre>
<h3 id="验证BO信息-注册登录接口"><a href="#验证BO信息-注册登录接口" class="headerlink" title="验证BO信息(注册登录接口)"></a>验证BO信息(注册登录接口)</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/RegistLoginBO.java
package com.imooc.pojo.bo;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

//加上@data 会自动生成getter+setter
public class RegistLoginBO &#123;
    //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;

    @Override
    public String toString() &#123;
        return &quot;RegistLoginBO&#123;&quot; +
                &quot;mobile=&#39;&quot; + mobile + &#39;\&#39;&#39; +
                &quot;, smsCode=&#39;&quot; + smsCode + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;

    public String getMobile() &#123;
        return mobile;
    &#125;

    public void setMobile(String mobile) &#123;
        this.mobile = mobile;
    &#125;

    public String getSmsCode() &#123;
        return smsCode;
    &#125;

    public void setSmsCode(String smsCode) &#123;
        this.smsCode = smsCode;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html   打开校验
POST：/passport/doLogin

&#123;
    &quot;mobile&quot;:&quot;&quot;,
    &quot;smsCode&quot;:&quot;&quot;
&#125;

&#123;
&quot;status&quot;: 500,
&quot;msg&quot;: &quot;操作失败！&quot;,
&quot;success&quot;: false,
-&quot;data&quot;: &#123;
&quot;smsCode&quot;: &quot;短信验证码不能为空&quot;,
&quot;mobile&quot;: &quot;手机号不能为空&quot;
&#125;
&#125;
--------------------------------------------------------
 //不为空 空的话可以返回 不用NOTNULL因为无法校验空字符串 用NotBlank
    @NotBlank(message = &quot;手机号不能为空&quot;) 
    private String mobile;
    @NotBlank(message = &quot;短信验证码不能为空&quot;)
    private String smsCode;
// 要注意上面的为NotBlank 不然它验证的结果会跳过手机号判断 直接说验证码错误 
// 因为NotNull在处理&quot;mobile&quot;:&quot;&quot;, &quot;smsCode&quot;:&quot;&quot;的时候空字符串也算入不为空
//NotBlank兼顾NotNull
</code></pre>
<h3 id="通过数据库-查询老用户-老用户添加"><a href="#通过数据库-查询老用户-老用户添加" class="headerlink" title="通过数据库 查询老用户_老用户添加"></a>通过数据库 查询老用户_老用户添加</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
package com.imooc.user.controller;


import com.imooc.api.BaseController;
import com.imooc.api.controller.user.PassportControllerApi;
import com.imooc.enums.UserStatus;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.IPUtil;
import com.imooc.utils.SMSUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;passport&quot;)
public class PassportController extends BaseController implements PassportControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(PassportController.class);

    @Autowired
    private SMSUtils smsUtils;

    @Autowired
    private UserService userService;
    // 这里去除的原因是因为新建了一个BaseController 在里面有信息 且在这加个extends
    //    @Autowired
    //    private RedisOperator redis;

    @Override
    public GraceJSONResult getSMSCode(String mobile, HttpServletRequest request)&#123;
        //获取用户ip
        String userIp = IPUtil.getRequestIp(request);
        logger.info(&quot;User ip:&quot;, userIp);
        //根据用户的ip进行限制,限制用户在60秒内只能获得一次验证码
        redis.setnx60s(MOBILE_SMSCODE + &quot;:&quot; + userIp, userIp);

        // 生成6位随机验证码
        String random = (int)((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
        // 打印生成的验证码以便调试
//        logger.info(&quot;Generated SMS code: &quot; + random);
//        String random = ((Math.random() * 9 + 1) * 100000) + &quot;&quot;;
//        smsUtils.sendSMS(&quot;15027597319&quot;,random);//可以用MyInfo.getMobile代替
        // 记录发送短信的结果（添加日志）
//        logger.info(&quot;SMS sent to 15027597319 with code: &quot; + random);
        redis.set(MOBILE_SMSCODE + &quot;:&quot; + mobile, random, 30 * 60);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;
        return GraceJSONResult.ok(user);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java[接口]
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return null;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/AppUser.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Date;

@Table(name = &quot;app_user&quot;)
public class AppUser &#123;
    @Id
    private String id;

    /**
     * 手机号
     */
    private String mobile;

    /**
     * 昵称，媒体号
     */
    private String nickname;

    /**
     * 头像
     */
    private String face;

    /**
     * 真实姓名
     */
    private String realname;

    /**
     * 邮箱地址
     */
    private String email;

    /**
     * 性别 1:男  0:女  2:保密
     */
    private Integer sex;

    /**
     * 生日
     */
    private Date birthday;

    /**
     * 省份
     */
    private String province;

    /**
     * 城市
     */
    private String city;

    /**
     * 区县
     */
    private String district;

    /**
     * 用户状态：0：未激活。 1：已激活：基本信息是否完善，真实姓名，邮箱地址，性别，生日，住址等，如果没有完善，则用户不能发表评论，不能点赞，不能关注。2：已冻结。
     */
    @Column(name = &quot;active_status&quot;)
    private Integer activeStatus;

    /**
     * 累计已结算的收入金额，也就是已经打款的金额，每次打款后再此累加
     */
    @Column(name = &quot;total_income&quot;)
    private Integer totalIncome;

    /**
     * 创建时间 创建时间
     */
    @Column(name = &quot;created_time&quot;)
    private Date createdTime;

    /**
     * 更新时间 更新时间
     */
    @Column(name = &quot;updated_time&quot;)
    private Date updatedTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;com.imooc.utils&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">【来自Chatgpt】
java.sql.SQLException: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;READ&#39; at line 1
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readErrorPacket(AbstractQueryProtocol.java:1594)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.readPacket(AbstractQueryProtocol.java:1453)
    at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.getResult(AbstractQueryProtocol.java:1415)

这个新的错误信息表明在设置 tx_isolation 时，语法存在问题。我们需要确保设置事务隔离级别的语法是正确的。以下是一些更具体的步骤来解决这个问题：

1. 确认MariaDB版本支持的语法
在MariaDB中，设置事务隔离级别的正确语法可能与MySQL略有不同。确保使用MariaDB支持的正确语法。

2. 确认正确的事务隔离级别语法
根据MariaDB的官方文档，设置事务隔离级别的正确方法是使用以下语法：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
3. 修改连接URL
在连接URL中正确设置事务隔离级别：

yaml
复制代码
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
4. 确认数据源属性配置
确保数据源属性配置正确：

yaml
复制代码
spring:
  datasource:
    hikari:
      connection-timeout: 30000
      minimum-idle: 5
      maximum-pool-size: 20
      auto-commit: true
      idle-timeout: 600000
      pool-name: DateSourceHikariCP
      max-lifetime: 1800000
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
5. 确认使用MariaDB JDBC驱动
确保使用MariaDB的JDBC驱动：

Maven
xml
复制代码
&lt;dependency&gt;
    &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
    &lt;version&gt;2.7.2&lt;/version&gt;
&lt;/dependency&gt;
Gradle
groovy
复制代码
implementation &#39;org.mariadb.jdbc:mariadb-java-client:2.7.2&#39;
6. 测试事务隔离设置
在MariaDB中手动测试设置事务隔离级别，确保语法正确：

sql
复制代码
SET SESSION tx_isolation = &#39;READ-COMMITTED&#39;;
如果这条命令可以成功执行，那么它也应该能在你的连接URL中正确设置。

7. 确认Spring配置
确保Spring Boot配置正确，可以通过显式设置数据源属性来避免问题：

yaml
复制代码
spring:
  datasource:
    hikari:
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
总结
通过上述步骤，你应该能够解决 tx_isolation 变量设置的问题，并确保连接到MariaDB数据库时没有语法错误。如果问题依然存在，请提供更多的错误日志和配置文件信息，以便进一步诊断。
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:8003/doc.html 先接收验证码 通过redis获得 再测试登录接口
&#123;
    &quot;mobile&quot;:&quot;15027597319&quot;,
    &quot;smsCode&quot;:&quot;815850&quot;
&#125;

相应内容：
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    -&quot;data&quot;: &#123;
    &quot;id&quot;: &quot;240629F0PD4PZANC&quot;,
    &quot;mobile&quot;: &quot;15027597319&quot;,
    &quot;nickname&quot;: &quot;用户：15******319&quot;,
    &quot;face&quot;: &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,
    &quot;realname&quot;: null,
    &quot;email&quot;: null,
    &quot;sex&quot;: 2,
    &quot;birthday&quot;: &quot;2024-06-29 00:00:00&quot;,
    &quot;province&quot;: null,
    &quot;city&quot;: null,
    &quot;district&quot;: null,
    &quot;activeStatus&quot;: 0,
    &quot;totalIncome&quot;: 0,
    &quot;createdTime&quot;: &quot;2024-06-29 19:39:10&quot;,
    &quot;updatedTime&quot;: &quot;2024-06-29 19:39:10&quot;
    &#125;
&#125;

此时去数据库imooc-news-dev的app_user中发现并未有数据新增进入
再UserServiceimpl.java中
appUserMapper.insert(user);

当如果把app_user数据库离的active_status 的0变成2 就会被冻结【UserStatus】
&#123;
&quot;status&quot;: 507,
&quot;msg&quot;: &quot;用户已被冻结，请联系管理员！&quot;,
&quot;success&quot;: false,
&quot;data&quot;: null
&#125;
</code></pre>
<h3 id="设置会话与cookie信息【注册登录】"><a href="#设置会话与cookie信息【注册登录】" class="headerlink" title="设置会话与cookie信息【注册登录】"></a>设置会话与cookie信息【注册登录】</h3><pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
...
 // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi

        &#125;
        return GraceJSONResult.ok(user);
    &#125;
...
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java [增加一个setCookie]
package com.imooc.api;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class BaseController &#123;
   @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;

    /**可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result)&#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList)&#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

/*    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125; */

   public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge)&#123;
            Cookie cookie = new Cookie(cookieName,cookieValue);
            cookie.setMaxAge(maxAge);
            cookie.setDomain(&quot;imoocnews.com&quot;);
            cookie.setPath(&quot;/&quot;);//都用cookie
            response.addCookie(cookie);//把cookie传入
        &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
    @Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;uToken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<h3 id="资源属性与常量绑定-优雅"><a href="#资源属性与常量绑定-优雅" class="headerlink" title="资源属性与常量绑定 [优雅]"></a>资源属性与常量绑定 [优雅]</h3><pre><code class="java">把这种属性放到常量文件里进行绑定  cookie.setDomain(&quot;imoocnews.com&quot;);
service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
 ★ @Value(&quot;$&#123;website.domain-name&#125;&quot;) ★★
 ★ public String DOMAIN_NAME; ★★
...
 public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
...
================================================================================
application-dev.yml
server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<h3 id="查询用户账户信息"><a href="#查询用户账户信息" class="headerlink" title="查询用户账户信息"></a>查询用户账户信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@RestController
public class UserController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;
    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);
&#125;
====================================================================
service-user  com/imooc/user/service/UserServiceimpl.java
     @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/UserAccountInfoVO.java
public class UserAccountInfoVO &#123;
    private String id;
    private String mobile;
    private String nickname;
    private String face;
    private String realname;
    private String email;
    private Integer sex;
    private Date birthday;
    private String province;
    private String city;
    private String district;
&#125;Getter + Setter
</code></pre>
<h3 id="信息校验"><a href="#信息校验" class="headerlink" title="信息校验"></a>信息校验</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.UserAccountInfoVO;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Map;

@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getAccountInfo(String userId) &#123;
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;

        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        UserAccountInfoVO accountInfoVO = new UserAccountInfoVO();
        BeanUtils.copyProperties(user, accountInfoVO); //拷贝信息
        return GraceJSONResult.ok(accountInfoVO);
    &#125;

    private AppUser getUser(String userId)&#123;
        // TODO 本方法后续公用，并且扩展
        AppUser user = userService.getUser(userId);
        return user;
    &#125;

    @Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/UpdateUserInfoBO.java
public class UpdateUserInfoBO &#123;

    @NotBlank(message = &quot;用户ID不能为空&quot;)
    private String id;

    @NotBlank(message = &quot;用户昵称不能为空&quot;)
    @Length(max = 12, message = &quot;用户昵称不能超过12位&quot;)
    private String nickname;

    @NotBlank(message = &quot;用户头像不能为空&quot;)
    private String face;

    @NotBlank(message = &quot;真实姓名不能为空&quot;)
    private String realname;

    @Email
    @NotBlank(message = &quot;邮件不能为空&quot;)
    private String email;

    @NotNull(message = &quot;请选择一个性别&quot;)
    @Min(value = 0, message = &quot;性别选择不正确&quot;)
    @Max(value = 1, message = &quot;性别选择不正确&quot;)
    private Integer sex;

    @NotNull(message = &quot;请选择生日日期&quot;)
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd&quot;) // 解决前端日期字符串传到后端后，转换为Date类型
    private Date birthday;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String province;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String city;

    @NotBlank(message = &quot;请选择所在城市&quot;)
    private String district;
&#125;
</code></pre>
<h3 id="激活用户信息入库"><a href="#激活用户信息入库" class="headerlink" title="激活用户信息入库"></a>激活用户信息入库</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Override
    public GraceJSONResult updateUserInfo(UpdateUserInfoBO updateUserInfoBO, BindingResult result) &#123;
        // 0.校验BO
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/UserService.java
package com.imooc.user.service.impl;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;

public interface UserService &#123;
    /**
     * 判断用户是否存在，如果存在返回user信息
     */
    public AppUser queryMobileIsExist(String mobile);

    /**
     * 创建用户，新增用户记录到数据库
     */
    public AppUser createUser(String mobile);

    /**
     * 根据用户主键id查询用户信息
     * @param userId
     * @return
     */
    public AppUser getUser(String userId);

    /**
     * 用户修改信息，完善资料，并且激活
     * @param updateUserInfoBO
     */
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
@Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);
        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="查询并展示用户基本信息"><a href="#查询并展示用户基本信息" class="headerlink" title="查询并展示用户基本信息"></a>查询并展示用户基本信息</h3><pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,BindingResult result);
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //重写接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<h3 id="浏览器存储介质"><a href="#浏览器存储介质" class="headerlink" title="浏览器存储介质"></a>浏览器存储介质</h3><ul>
<li><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6></li>
<li><h6 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a><span style = "color:red">SessionStorage</span></h6></li>
<li><h6 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h6></li>
</ul>
<h3 id="缓存用户信息-用Redis减轻数据库压力"><a href="#缓存用户信息-用Redis减轻数据库压力" class="headerlink" title="缓存用户信息 [用Redis减轻数据库压力]"></a>缓存用户信息 [用Redis减轻数据库压力]</h3><pre><code class="java">service-api  com/imooc/api/BaseController.java
//REDIS_USER_INFO添加进来
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;

    /**
     * 可以公用 就放到BaseController里面
     * 在任何controller中都可以调用和使用
     * 获取BO中的错误信息
     *
     * @param result
     * @return
     */
    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        //对应着RegistLoginBO的信息
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            //发生验证错误所对应的某个属性
            String field = error.getField();
            //验证的错误信息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;

    public void setCookie(HttpServletRequest request,
                          HttpServletResponse response,
                          String cookieName,
                          String cookieValue,
                          Integer maxAge) &#123;
        try &#123;
            cookieValue = URLEncoder.encode(cookieValue, &quot;utf-8&quot;);
//            Cookie cookie = new Cookie(cookieName,cookieValue);
//            cookie.setMaxAge(maxAge);
//            cookie.setDomain(&quot;imoocnews.com&quot;);
//            cookie.setPath(&quot;/&quot;);//都用cookie
            setCookieValue(request, response, cookieName, cookieValue, maxAge);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;

    public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
 private AppUser getUser(String userId)&#123;
        //查询判断redis中是否包含用户信息 若有则直接返回就不去查询数据库了
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            //字符串转换成json对象  要提取user 所以要一开始赋值null
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            // TODO 本方法后续公用，并且扩展
            user = userService.getUser(userId);
            // 由于用户信息不怎么会变动,对于一些千万级别网站来说,这类信息不会直接去查询数据库
            // 可以完全依靠Redis,直接把查询后的数据存入到Redis中
            // set里面设置一个key去BaseController里设置  ↓user变成jason转换类
            redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));
        &#125;

        return user;
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java
package com.imooc.user.service;

import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.impl.UserService;
import com.imooc.utils.DesensitizationUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;
import com.imooc.utils.DateUtil;

import java.util.Date;

@Service
public class UserServiceimpl implements UserService &#123;
    @Autowired
    public AppUserMapper appUserMapper; //基本的CRUD都可以

    @Autowired
    public Sid sid;
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写


    @Autowired
    public RedisOperator redis;

    private static final String USER_FACE0 = &quot;https://raw.githubusercontent.com/P-luminary/images/10d94134b65e13cc8ec9b8a9aeae4f958921cab7/data/Imooc_Cat.jpg&quot;;
    private static final String USER_FACE1 = &quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;;
    @Override
    public AppUser queryMobileIsExist(String mobile) &#123;
        Example userExample = new Example(AppUser.class);
        Example.Criteria userCriteria = userExample.createCriteria();
        userCriteria.andEqualTo(&quot;mobile&quot;, mobile);
        AppUser user = appUserMapper.selectOneByExample(userExample);
        return user;
    &#125;

    @Transactional //对整个类的方法，事务起作用。无异常时正常提交，有异常时数据回滚
    @Override
    public AppUser createUser(String mobile) &#123;
        /**
         * 互联网项目都要考虑可扩展性
         * 如果未来的业务激增，那么就需要分表分库
         * 那么数据库表主键id必须保证全局(全库)唯一,不得重复
         */
        String userId = sid.nextShort();
        AppUser user = new AppUser();
        user.setId(userId);
        user.setMobile(mobile);
        user.setNickname(&quot;用户：&quot; + DesensitizationUtil.commonDisplay(mobile)); //給手机号加** 是脱敏操作
        user.setFace(USER_FACE1);
        user.setBirthday(DateUtil.stringToDate(&quot;2024-06-29&quot;)); //字符串转换Date类型
        user.setSex(Sex.secret.type);
        user.setActiveStatus(UserStatus.INACTIVE.type);//是否激活
        user.setTotalIncome(0);//收入
        user.setCreatedTime(new Date());
        user.setUpdatedTime(new Date());
        appUserMapper.insert(user);
        return user;
    &#125;

    @Override
    public AppUser getUser(String userId) &#123;
        return appUserMapper.selectByPrimaryKey(userId);
    &#125;

    @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

    &#125;
&#125;
</code></pre>
<pre><code class="java">Redis里面 redis_user_info
&#123;&quot;id&quot;:&quot;240629F21AK1BHX4&quot;,&quot;mobile&quot;:&quot;15027597319&quot;,&quot;nickname&quot;:&quot;15027597319&quot;,&quot;face&quot;:&quot;https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg&quot;,&quot;realname&quot;:&quot;小宝宝的小潘潘2&quot;,&quot;email&quot;:&quot;390415030@qq.com&quot;,&quot;sex&quot;:1,&quot;birthday&quot;:1720195200000,&quot;province&quot;:&quot;河北&quot;,&quot;city&quot;:&quot;唐山市&quot;,&quot;district&quot;:&quot;丰润区&quot;,&quot;activeStatus&quot;:1,&quot;totalIncome&quot;:0,&quot;createdTime&quot;:1719661387000,&quot;updatedTime&quot;:1720281759000&#125;
</code></pre>
<h3 id="双写数据不一致的情况-redis故障没有写入新数据"><a href="#双写数据不一致的情况-redis故障没有写入新数据" class="headerlink" title="双写数据不一致的情况 [redis故障没有写入新数据]"></a>双写数据不一致的情况 [redis故障没有写入新数据]</h3><h6 id="如何双写一致-缓存双删"><a href="#如何双写一致-缓存双删" class="headerlink" title="如何双写一致 缓存双删"></a>如何双写一致 缓存双删</h6><blockquote>
<p>用户先把老Redis中的数据删除 然后再把修改值放入数据库 然后数据库再导入redis 就可以保证双写一致<br>但是要保证数据库放入Redis之前 后期用户请求要再其之后 [进行休眠] &#x3D;&gt;缓存双删</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/service/UserServiceimpl.java  @Override
    public void updateUserInfo(UpdateUserInfoBO updateUserInfoBO)&#123;
        String userId = updateUserInfoBO.getId();
        // 保证双写一致,先删除redis中的数据,后更新数据库
//        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);

        AppUser userInfo = new AppUser();
        BeanUtils.copyProperties(updateUserInfoBO, userInfo);

        userInfo.setUpdatedTime(new Date());
        userInfo.setActiveStatus(UserStatus.ACTIVE.type);
        //appUserMapper.updateByPrimaryKey()//数据中现有的数据覆盖为空的
        int result = appUserMapper.updateByPrimaryKeySelective(userInfo);
        if (result != 1)&#123;
            //更新操作有问题
            GraceException.display(ResponseStatusEnum.USER_UPDATE_ERROR);
        &#125;
        // 再次查询用户的最新信息,放入redis中
        AppUser user = getUser(userId);
        redis.set(REDIS_USER_INFO + &quot;:&quot; + userId, JsonUtils.objectToJson(user));

        // 缓存双删策略 [不处理可能会缓存击穿]
        try &#123;
            Thread.sleep(100);
            redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
</code></pre>
<h3 id="CAP理论-只能满足其中一、二"><a href="#CAP理论-只能满足其中一、二" class="headerlink" title="CAP理论 [只能满足其中一、二]"></a>CAP理论 [只能满足其中一、二]</h3><h5 id="分布式系统都存在CAP情况"><a href="#分布式系统都存在CAP情况" class="headerlink" title="分布式系统都存在CAP情况"></a>分布式系统都存在CAP情况</h5><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件 【先满足P再去考虑A或C】</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果 [某节点获得的数据都是一样的] 在本项目中一致性位于Session Storage</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。 [某个挂掉了 其他还可以用]</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行。分区容错性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
<li><strong>CP</strong>：Redis【保证数据一致性 一定要满足C】</li>
<li><strong>AP</strong>：会采用弱一致性 淘宝下单只需要知道下单就好 数量一致性商家可以慢慢调整</li>
<li><strong>CA</strong>：单体存在架构、关系型架构</li>
</ul>
<p>在本项目中如果采用弱一致性：可以不把用户存到session Storage 直接显示</p>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h3 id="用户会话拦截器-必须用户登陆后才可以用其他界面"><a href="#用户会话拦截器-必须用户登陆后才可以用其他界面" class="headerlink" title="用户会话拦截器 [必须用户登陆后才可以用其他界面]"></a>用户会话拦截器 [必须用户登陆后才可以用其他界面]</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UserTokenInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class UserTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userToken = request.getHeader(&quot;headerUserToken&quot;);

        // 判断是否放行
        boolean run = verifyUserIdToken(userId, userToken, REDIS_USER_TOKEN);

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;


    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.api.interceptors;

import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;

public class BaseInterceptor &#123;
    @Autowired
    private RedisOperator redis;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写

    public boolean verifyUserIdToken(String id,
                                     String token,
                                     String redisKeyPrefix)&#123; //redis..前缀
        if (StringUtils.isNotBlank(id) &amp;&amp; StringUtils.isNotBlank(token))&#123;
            String redisToken = redis.get(redisKeyPrefix + &quot;:&quot; + id);
            if (StringUtils.isBlank(id))&#123;
                GraceException.display(ResponseStatusEnum.UN_LOGIN);
                return false;
            &#125; else &#123;
                if (!redisToken.equalsIgnoreCase(token))&#123;//是否和传入token一致
                    GraceException.display(ResponseStatusEnum.TICKET_INVALID);
                    return false;
                &#125;
            &#125;
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
            return false;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
    &#125;
&#125;
/*
在你的 Spring 应用程序中，InterceptorConfig 类中的 @Bean 注解用于定义 PassportInterceptor 和 UserTokenInterceptor 的 bean。这使这些拦截器对象在 Spring 上下文中可用，以便进行依赖注入。

删除 @Bean 注解后会出现错误 Autowired members must be defined in valid Spring bean (@Component|@Service|...)，这是因为 BaseInterceptor 类中有一个需要由 Spring 注入的依赖 (RedisOperator redis)。要让 Spring 执行依赖注入，包含 @Autowired 注解的类必须是一个由 Spring 管理的 bean，可以通过 @Component、@Service、@Controller 等注解或在配置类中通过 @Bean 来定义。

这里是对 @Bean 的作用以及为什么删除它会导致错误的详细解释：

使用 @Bean 定义 Bean：
在 InterceptorConfig 类中，@Bean 注解定义了 PassportInterceptor 和 UserTokenInterceptor 作为 Spring 的 bean。这使得它们在整个应用程序中可用于依赖注入。

依赖注入的要求：
BaseInterceptor 类中使用了 @Autowired 注解来注入 RedisOperator。要使这个注入有效，BaseInterceptor 必须是一个 Spring 管理的 bean。而 @Bean 注解在配置类中定义了这些拦截器，使得 Spring 可以管理它们，并在需要时进行依赖注入。

如果删除了 @Bean 注解，PassportInterceptor 和 UserTokenInterceptor 将不再是 Spring 管理的 bean，从而导致在它们内部或相关联的类（如 BaseInterceptor）中的依赖无法被注入。这就是为什么删除 @Bean 注解后会出现 Autowired members must be defined in valid Spring bean (@Component|@Service|...) 错误的原因。
*/
</code></pre>
<h3 id="用户状态激活拦截器"><a href="#用户状态激活拦截器" class="headerlink" title="用户状态激活拦截器"></a>用户状态激活拦截器</h3><pre><code class="java">service-api  com/imooc/api/interceptors/UseActiveInterceptor.java
package com.imooc.api.interceptors;

import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 用户激活状态检测拦截器
 * 发文章，修改文章，删除文章，发表评论，查看评论等
 * 这些接口都是要在用户激活后才能进行操作
 * 否则需要提示用户前往[账号设置]去修改信息
 */
    public class UseActiveInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，访问controller之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        // 有些接口同时会給安卓 H5等 所以不去cookie拿
        String userId = request.getHeader(&quot;headerUserId&quot;);
        String userJson = redis.get(REDIS_USER_INFO + &quot;:&quot; + userId);
        AppUser user = null;
        if (StringUtils.isNotBlank(userJson))&#123;
            user = JsonUtils.jsonToPojo(userJson, AppUser.class);
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.UN_LOGIN);
        &#125;
        if (user.getActiveStatus() == null || user.getActiveStatus() != UserStatus.ACTIVE.type)&#123;
            GraceException.display(ResponseStatusEnum.USER_INACTIVE_ERROR);
            return false;
            //随后去拦截器里进行@Bean注册 [下下个代码就是]
        &#125;

        /**
         * false：请求被拦截
         * true：请求通过验证，放行
         */
        return true;
    &#125;

    /**
     * 请求访问到controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
    &#125;
    /**
     * 请求访问到controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
//[加一行redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));]
@Override
    public GraceJSONResult doLogin(RegistLoginBO registLoginBO, BindingResult result, HttpServletRequest request, HttpServletResponse response) &#123;
        //0.判断BindingResult中是否保存了错误的验证信息 如果有则需要返回
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;
        String mobile = registLoginBO.getMobile();
        String smsCode = registLoginBO.getSmsCode();

        //1.校验验证码是否匹配[在redis中去获取]
        String redisSMSCode = redis.get(MOBILE_SMSCODE + &quot;:&quot; + mobile); //为空||不同值
        if (StringUtils.isBlank(redisSMSCode) || !redisSMSCode.equalsIgnoreCase(smsCode)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SMS_CODE_ERROR);
        &#125;

        //2.查询数据库,判断该用户注册
        AppUser user = userService.queryMobileIsExist(mobile);
        if (user != null &amp;&amp; user.getActiveStatus() == UserStatus.FROZEN.type)&#123;
            //如果用户不为空，并且状态为冻结，则直接抛出异常，禁止登录
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_FROZEN);
        &#125;else if (user == null)&#123;
            //如果用户没有注册过，则为null，需要注册信息入库
            user = userService.createUser(mobile);
        &#125;

        // 3.保存用户分布式会话的相关操作
        int userActiveStatus = user.getActiveStatus();
        if (userActiveStatus != UserStatus.FROZEN.type)&#123;
            String uToken = UUID.randomUUID().toString();
            redis.set(REDIS_USER_TOKEN+&quot;:&quot;+user.getId(),uToken);//BaseController里面 保存token到redis
            redis.set(REDIS_USER_INFO+&quot;:&quot;+user.getId(), JsonUtils.objectToJson(user));

            //保存用户id和token到cookie中 设计一个request response 回到PassportControllerApi
            setCookie(request, response,&quot;utoken&quot;,uToken,COOKIE_MONTH);
            setCookie(request, response,&quot;uid&quot;,user.getId(),COOKIE_MONTH);
        &#125;
        // 4.用户登录或注册成功以后，需要删除redis中的短信验证码，验证码只能使用一次，用过则作废
//        redis.del(MOBILE_SMSCODE + &quot;:&quot; + mobile);
        // 5.返回用户状态 返回前端看
        return GraceJSONResult.ok(userActiveStatus);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="AOP警告日志监控与sql打印-切面AOP通知编程"><a href="#AOP警告日志监控与sql打印-切面AOP通知编程" class="headerlink" title="AOP警告日志监控与sql打印 [切面AOP通知编程]"></a>AOP警告日志监控与sql打印 [切面AOP通知编程]</h3><pre><code class="xml">dev-common 引入aop依赖
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/aspect/ServiceLogAspect.java
package com.imooc.api.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class ServiceLogAspect &#123;
    final static Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);
    /**
     * AOP通知：
     * 1.前置通知
     * 2.后置通知
     * 3.环绕通知 ★★
     * 4.异常通知
     * 5.最终通知
     */
    //*是返回所有类型 匹配包的位置 *.* = 任意文件.任意后缀  (..)是任意类和任意方法
    @Around(&quot;execution(* com.imooc.*.service.impl..*.*(..))&quot;)
    public Object recordTimeOfService(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        logger.info(&quot;==== 开始执行 &#123;&#125;.&#123;&#125; ====&quot;,
                joinPoint.getTarget().getClass(),
                joinPoint.getSignature().getName());
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long end = System.currentTimeMillis();
        long takeTime = end - start;
        if (takeTime &gt; 3000)&#123;
            logger.error(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else if (takeTime &gt; 2000)&#123;
            logger.warn(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;else &#123;
            logger.info(&quot;当前执行耗时：&#123;&#125;&quot;,takeTime);
        &#125;
        return result;
    &#125;
&#125;
====================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交信息 看后台Terminal
</code></pre>
<pre><code class="yml">service-user  application-dev.yml #增加一个open mybatis log in dev
  server:
  port: 8003

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com

===================================================================
如果在未来发生sql错误可以通过sql输出来找到sql语句从而放入运行检查错误 (21 28行)
JDBC Connection [HikariProxyConnection@2054571226 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: UPDATE app_user SET nickname = ?,face = ?,realname = ?,email = ?,sex = ?,birthday = ?,province = ?,city = ?,district = ?,active_status = ?,updated_time = ? WHERE id = ? 
==&gt; Parameters: 15027597319(String), https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg(String), 小宝宝的小潘潘(String), 390415030@qq.com(String), 1(Integer), 2024-07-06 00:00:00.0(Timestamp), 河北(String), 唐山市(String), 丰润区(String), 1(Integer), 2024-07-07 22:41:09.862(Timestamp), 240629F21AK1BHX4(String)
&lt;==    Updates: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@9176eb0]
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477] was not registered for synchronization because synchronization is not active
JDBC Connection [HikariProxyConnection@1798162927 wrapping org.mariadb.jdbc.MariaDbConnection@4b4b68f8] will not be managed by Spring
==&gt;  Preparing: SELECT id,mobile,nickname,face,realname,email,sex,birthday,province,city,district,active_status,total_income,created_time,updated_time FROM app_user WHERE id = ? 
==&gt; Parameters: 240629F21AK1BHX4(String)
&lt;==    Columns: id, mobile, nickname, face, realname, email, sex, birthday, province, city, district, active_status, total_income, created_time, updated_time
&lt;==        Row: 240629F21AK1BHX4, 15027597319, 15027597319, https://raw.githubusercontent.com/P-luminary/images/875ad52658686e6cc3a8e0cd75d2a324a3d742a9/data/Imooc_Girl.jpg, 小宝宝的小潘潘, 390415030@qq.com, 1, 2024-07-06, 河北, 唐山市, 丰润区, 1, 0, 2024-06-29 19:43:07.0, 2024-07-07 22:41:09.0
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@65bd9477]
41:10.009 [http-nio-8003-exec-3] INFO  io.lettuce.core.EpollProvider - Starting without optional epoll library
41:10.010 [http-nio-8003-exec-3] INFO  io.lettuce.core.KqueueProvider - Starting without optional kqueue library
41:10.460 [http-nio-8003-exec-3] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：601
</code></pre>
<h3 id="退出登录、注销会话"><a href="#退出登录、注销会话" class="headerlink" title="退出登录、注销会话"></a>退出登录、注销会话</h3><pre><code class="java">service-api  com/imooc/api/controller/user/PassportControllerApi.java
//用户登录信息的redis和cookies清除
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid; //用户需求验证

@Api(value = &quot;用户注册登录&quot;,tags = &#123;&quot;用户注册登录的Controller&quot;&#125;)
@RequestMapping(&quot;passport&quot;)
public interface PassportControllerApi &#123;
    @ApiOperation(value = &quot;获得短信验证码&quot;,notes = &quot;获得短信验证码&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/getSMSCode&quot;)
    public GraceJSONResult getSMSCode(@RequestParam String mobile, HttpServletRequest request);

    @ApiOperation(value = &quot;一键注册登录接口&quot;,notes = &quot;一键注册登录接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/doLogin&quot;) //表单里面用post  RequestBody后面传过来的东西和json对象对应
    public GraceJSONResult doLogin(@RequestBody @Valid RegistLoginBO registLoginBO
            , BindingResult result, HttpServletRequest request, HttpServletResponse response);
    //完成之后 去BaseController里面写一个setCookie()方便都可以用

    @ApiOperation(value = &quot;用户退出登录&quot;,notes = &quot;用户退出登录&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/logout&quot;)
    public GraceJSONResult logout(@RequestParam String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/PassportController.java
@Override
    public GraceJSONResult logout(String userId,
                                  HttpServletRequest request,
                                  HttpServletResponse response)&#123;
        redis.del(REDIS_USER_TOKEN + &quot;:&quot; + userId);
        //USER_INFO可以不用删 可能后面会查询 没有清除cookie只有重新设置时间为0
        setCookie(request, response, &quot;utoken&quot;,&quot;&quot;,COOKIE_DELETE);
        setCookie(request, response, &quot;uid&quot;,&quot;&quot;,COOKIE_DELETE);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="FastDFS架构原理与上传下载流程解析"><a href="#FastDFS架构原理与上传下载流程解析" class="headerlink" title="FastDFS架构原理与上传下载流程解析"></a>FastDFS架构原理与上传下载流程解析</h3><h5 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h5><ul>
<li><p>传统服务器存储</p>
</li>
<li><h5 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h5></li>
<li><p>OSS</p>
</li>
<li><p>GridFS</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/584d8cb5b41ffa10cb9b5303c13b5782e1130889/data/FastDFS%E6%9E%B6%E6%9E%84.png"></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f4d7477aa2b6843ddfb11af2cbbe2424a25e4b39/data/FastDFS%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="配置FastDFS环境准备工作"><a href="#配置FastDFS环境准备工作" class="headerlink" title="配置FastDFS环境准备工作"></a>配置FastDFS环境准备工作</h3><h6 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h6><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Centos</td>
<td>7.x</td>
</tr>
<tr>
<td>libfastcommon-1.0.42.tar.gz</td>
<td>FastDFS分离出的一些公用函数包</td>
</tr>
<tr>
<td>FastDFS</td>
<td>FastDFS本体</td>
</tr>
<tr>
<td>fastdfs-nginx-module-1.22.tar.gz</td>
<td>FastDFS和nginx的关联模块</td>
</tr>
<tr>
<td>nginx</td>
<td>nginx1.15.4</td>
</tr>
</tbody></table>
<h6 id="它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x"><a href="#它跟我说要准备两个虚拟机-tracker-和-storage-版本都是CentOS-7-x" class="headerlink" title="它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]"></a>它跟我说要准备两个虚拟机[tracker 和 storage 版本都是CentOS 7.x]</h6><pre><code class="java">//创建一个FastDFS文件夹
[imooc@imooc FastDFS]$ ll
总用量 1980
-rw-rw-r--. 1 imooc imooc  800157 7月   9 15:53 fastdfs-6.04.tar.gz
-rw-rw-r--. 1 imooc imooc   19952 7月   9 15:53 fastdfs-nginx-module-1.22.tar.gz
-rw-rw-r--. 1 imooc imooc  164704 7月   9 15:53 libfastcommon-1.0.42.tar.gz
-rw-rw-r--. 1 imooc imooc 1032630 7月   9 15:53 nginx-1.16.1.tar.gz
[imooc@imooc FastDFS]$ tar -zxvf libfastcommon-1.0.42.tar.gz 
[imooc@imooc FastDFS]$ cd libfastcommon-1.0.42/
[imooc@imooc libfastcommon-1.0.42]$ ll
总用量 32
drwxrwxr-x. 2 imooc imooc   114 12月  5 2019 doc
-rw-rw-r--. 1 imooc imooc 10054 12月  5 2019 HISTORY
-rw-rw-r--. 1 imooc imooc   674 12月  5 2019 INSTALL
-rw-rw-r--. 1 imooc imooc  1607 12月  5 2019 libfastcommon.spec
-rwxrwxr-x. 1 imooc imooc  3253 12月  5 2019 make.sh
drwxrwxr-x. 2 imooc imooc   191 12月  5 2019 php-fastcommon
-rw-rw-r--. 1 imooc imooc  2776 12月  5 2019 README
drwxrwxr-x. 3 imooc imooc  4096 12月  5 2019 src
[imooc@imooc libfastcommon-1.0.42]$ ./make.sh
[imooc@imooc libfastcommon-1.0.42]$ sudo ./make.sh install
//安装解压包的本体
[imooc@imooc FastDFS]$ tar -zxvf fastdfs-6.04.tar.gz 
[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ ./make.sh
[imooc@imooc fastdfs-6.04]$ sudo ./make.sh install
[imooc@imooc fastdfs-6.04]$ cd /usr/bin
[imooc@imooc bin]$ ls fdfs_*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[imooc@imooc bin]$ cd /etc/fdfs/
[imooc@imooc fdfs]$ ll
总用量 28 //这些都是配置文件 如果要修改则需要拷贝一份新鲜的
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample

[imooc@imooc FastDFS]$ cd fastdfs-6.04/
[imooc@imooc fastdfs-6.04]$ cd conf/
[imooc@imooc conf]$ ll
总用量 88
-rw-rw-r--. 1 imooc imooc 23981 12月  5 2019 anti-steal.jpg
-rw-rw-r--. 1 imooc imooc  1834 12月  5 2019 client.conf
-rw-rw-r--. 1 imooc imooc   955 12月  5 2019 http.conf
-rw-rw-r--. 1 imooc imooc 31172 12月  5 2019 mime.types
-rw-rw-r--. 1 imooc imooc 10085 12月  5 2019 storage.conf
-rw-rw-r--. 1 imooc imooc   527 12月  5 2019 storage_ids.conf
-rw-rw-r--. 1 imooc imooc  8038 12月  5 2019 tracker.conf
//拷贝到etc下  安装前的准备工作
[imooc@imooc conf]$ sudo cp * /etc/fdfs/
[imooc@imooc conf]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
</code></pre>
<h3 id="配置tracker服务-一个虚拟机"><a href="#配置tracker服务-一个虚拟机" class="headerlink" title="配置tracker服务 [一个虚拟机]"></a>配置tracker服务 [一个虚拟机]</h3><pre><code class="java">//根据配置文件去区分是哪个服务
[imooc@imooc fdfs]$ cd /etc/fdfs
[imooc@imooc fdfs]$ ll
总用量 116
-rw-r--r--. 1 root root 23981 7月   9 16:06 anti-steal.jpg
-rw-r--r--. 1 root root  1834 7月   9 16:06 client.conf
-rw-r--r--. 1 root root  1834 7月   9 16:02 client.conf.sample
-rw-r--r--. 1 root root   955 7月   9 16:06 http.conf
-rw-r--r--. 1 root root 31172 7月   9 16:06 mime.types
-rw-r--r--. 1 root root 10085 7月   9 16:06 storage.conf
-rw-r--r--. 1 root root 10085 7月   9 16:02 storage.conf.sample
-rw-r--r--. 1 root root   527 7月   9 16:06 storage_ids.conf
-rw-r--r--. 1 root root   527 7月   9 16:02 storage_ids.conf.sample
-rw-r--r--. 1 root root  8038 7月   9 16:06 tracker.conf
-rw-r--r--. 1 root root  8038 7月   9 16:02 tracker.conf.sample
[imooc@imooc fdfs]$ sudo vim tracker.conf  
//里面的port=22122 bind_addr= 计算机节点 这些不动
//修改里面的base_path=/home/yuqing/fastdfs 
    //修改为→ /usr/local/fastdfs/tracker
[imooc@imooc fdfs]$ mkdir /usr/local/fastdfs/tracker -p //-p后面文件夹做递归创建
[imooc@imooc fdfs]$ sudo /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf //当成配置文件加进去 ★★★★★★★★★★★★★★★★★★
[imooc@imooc fdfs]$ ps -ef|grep tracker
root       6254      1  0 18:31 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf
imooc      6268   3011  0 18:31 pts/0    00:00:00 grep --color=auto tracker
</code></pre>
<h3 id="配置storage服务-另一个虚拟机"><a href="#配置storage服务-另一个虚拟机" class="headerlink" title="配置storage服务 [另一个虚拟机]"></a>配置storage服务 [另一个虚拟机]</h3><pre><code class="java">[storage@imooc fdfs]$ cd /etc/fdfs/
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] group_name=imooc 
//[修改后] bath_path=/usr/local/fastdfs/storage
[storage@imooc fdfs]$ sudo mkdir /usr/local/fastdfs/storage -p
[storage@imooc fdfs]$ cd /usr/local/
[storage@imooc local]$ ll
[storage@imooc local]$ cd fastdfs/
[storage@imooc fastdfs]$ ll
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root 6 7月   9 18:38 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/  //接着修改storage
[storage@imooc fdfs]$ sudo vim storage.conf
//[修改后] store_path0=/usr/local/fastdfs/storage
//配置到tracker的ip地址[修改后] tracker_server=192.168.170.135:22122
/ ‘/8888’  http.server_port=8888 是web的相关端口号
[storage@localhost fdfs]$ sudo /usr/bin/fdfs_storaged /etc/fdfs/storage.conf //★★★★
★一定要先启动tracker 再去启动storage 不然service发不过去★
</code></pre>
<pre><code class="java">//配置客户端做上传动作
[imooc@imooc ~]$ cd /etc/fdfs
[storage@localhost fdfs]$ pwd
/etc/fdfs
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]base_path=/usr/local/fastdfs/client
[storage@localhost fdfs]$ sudo mkdir /usr/local/fastdfs/client
[storage@localhost fdfs]$ cd /usr/local/fastdfs
[storage@localhost fastdfs]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 7月   9 19:26 client
drwxr-xr-x. 4 root root 30 7月   9 19:04 storage
[storage@localhost fastdfs]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim client.conf
//[修改后]tracker_server=192.168.170.135:22122
[storage@localhost fdfs]$ cd /usr/bin
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file        fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
//fdfs_test在命令行去测试
[storage@localhost bin]$ cd /home/
[storage@localhost home]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00
[storage@localhost data]$ ll   【里面很多十六进制数据】
[storage@localhost data]$ cd 00 
[storage@localhost data]$ ll   //【里面没有数据 上传图片到这里查看是否成功】
///home/storage 这里有一张测试图片log.png [自行添加]
[storage@localhost 00]$ pwd
/usr/local/fastdfs/storage/data/00/00
[storage@localhost 00]$ cd /etc/fdfs
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ cd /usr/bin/
[storage@localhost bin]$ ls fdfs*
fdfs_appender_test   fdfs_download_file      //fdfs_test
fdfs_appender_test1  fdfs_file_info            fdfs_test1
fdfs_append_file     fdfs_monitor              fdfs_trackerd
fdfs_crc32           fdfs_regenerate_filename  fdfs_upload_appender
fdfs_delete_file     fdfs_storaged             fdfs_upload_file
[storage@localhost bin]$ ./fdfs_test /etc/fdfs/client.conf upload /home/storage/log.png 
/*
This is FastDFS client test program v6.04

Copyright (C) 2008, Happy Fish / YuQing

FastDFS may be copied only under the terms of the GNU General
Public License V3, which may be found in the FastDFS source kit.
Please visit the FastDFS Home Page http://www.fastken.com/ 
for more detail.

[2024-07-09 19:39:25] DEBUG - base_path=/usr/local/fastdfs/client, connect_timeout=10, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0

tracker_query_storage_store_list_without_group: 
    server 1. group_name=, ip_addr=192.168.170.136, port=23000

group_name=imooc【企业简写】, ip_addr=192.168.170.136, port=23000
storage_upload_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png 
【remote_filename：重组路径】【因为还没有发布文件服务 所以无法直接查看文件】
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
storage_upload_slave_by_filename
group_name=imooc, remote_filename=M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
source ip address: 192.168.170.136
file timestamp=2024-07-09 19:39:25
file size=12618
file crc32=630904148
example file url: http://192.168.170.136/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
 */
[storage@localhost bin]$ cd /usr/local/fastdfs/storage/data/
[storage@localhost data]$ cd 00
[storage@localhost 00]$ cd 00
[storage@localhost 00]$ ll
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
</code></pre>
<h3 id="安装Nginx提供Web服务-通过浏览器访问到文件"><a href="#安装Nginx提供Web服务-通过浏览器访问到文件" class="headerlink" title="安装Nginx提供Web服务 [通过浏览器访问到文件]"></a>安装Nginx提供Web服务 [通过浏览器访问到文件]</h3><h6 id="Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机"><a href="#Nginx是反向代理服务器可以做集群-也可以控制多个虚拟主机" class="headerlink" title="Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机"></a>Nginx是反向代理服务器可以做集群 也可以控制多个虚拟主机</h6><pre><code class="java">-rw-rw-r--. 1 storage storage 142245547 7月  10 15:32 jdk-7u75-linux-x64.tar.gz
-rw-rw-r--. 1 storage storage   1032630 7月  10 15:33 nginx-1.16.1.tar.gz
//[storage@localhost ~]$ sudo yum install gcc-c++
已加载插件：fastestmirror, langpacks
Determining fastest mirrors
//[storage@localhost ~]$ sudo yum install -y pcre pcre-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y zlib zlib-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ sudo yum install -y openssl openssl-devel
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
//[storage@localhost ~]$ tar -zxvf nginx-1.16.1.tar.gz
nginx-1.16.1.tar.gz
//[storage@localhost ~]$ cd nginx-1.16.1.tar.gz
[storage@localhost nginx-1.16.1]$ sudo mkdir /var/temp/nginx -p
//创建所需的临时目录：
sudo mkdir -p /var/temp/nginx/client
sudo mkdir -p /var/temp/nginx/proxy
sudo mkdir -p /var/temp/nginx/fastcgi
sudo mkdir -p /var/temp/nginx/uwsgi
sudo mkdir -p /var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ ./configure \  //【预配置】
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi
[storage@localhost nginx-1.16.1]$ make  //【编译】
/* linux中的网络不可达
如果镜像出了问题 一定要换一下镜像配置
1. 编辑 CentOS 的 YUM 配置文件：
编辑 /etc/yum.repos.d/CentOS-Base.repo 文件：

复制代码
sudo vi /etc/yum.repos.d/CentOS-Base.repo

2. 使用以下内容更新 CentOS-Base.repo 文件：
复制代码
[base]
name=CentOS-$releasever - Base
baseurl=http://vault.centos.org/7.9.2009/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[updates]
name=CentOS-$releasever - Updates
baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7

[extras]
name=CentOS-$releasever - Extras
baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
*/
[storage@localhost nginx-1.16.1]$ sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local
[storage@localhost local]$ ll
总用量 0
drwxr-xr-x. 2 root root  6 4月  11 2018 bin
drwxr-xr-x. 2 root root  6 4月  11 2018 etc
drwxr-xr-x. 4 root root 35 7月   9 19:26 fastdfs
drwxr-xr-x. 2 root root  6 4月  11 2018 games
drwxr-xr-x. 2 root root  6 4月  11 2018 include
drwxr-xr-x. 2 root root  6 4月  11 2018 lib
drwxr-xr-x. 2 root root  6 4月  11 2018 lib64
drwxr-xr-x. 2 root root  6 4月  11 2018 libexec
drwxr-xr-x. 5 root root 42 7月  10 16:55 nginx
drwxr-xr-x. 2 root root  6 4月  11 2018 sbin
drwxr-xr-x. 5 root root 49 7月   9 17:16 share
drwxr-xr-x. 2 root root  6 4月  11 2018 src
[storage@localhost local]$ cd nginx/
[storage@localhost nginx]$ ll
总用量 4
drwxr-xr-x. 2 root root 4096 7月  10 16:55 conf
drwxr-xr-x. 2 root root   40 7月  10 16:55 html
drwxr-xr-x. 2 root root   19 7月  10 16:55 sbin
[storage@localhost nginx]$ cd sbin/
[storage@localhost sbin]$ ll
总用量 3768
-rwxr-xr-x. 1 root root 3857144 7月  10 16:55 nginx
[storage@localhost sbin]$ sudo ./nginx
[storage@localhost sbin]$ ps -ef|grep nginx
root       6642      1  0 16:58 ?        00:00:00 nginx: master process ./nginx
nobody     6643   6642  0 16:58 ?        00:00:00 nginx: worker process
storage    6651   2975  0 16:58 pts/0    00:00:00 grep --color=auto nginx

// 在浏览器输入：http://192.168.170.136/ 【如果没显示应该是虚拟机的防火墙拦截 可以禁止防火墙】
Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.

[storage@localhost nginx]$ cd html
[storage@localhost html]$ ll
总用量 8
-rw-r--r--. 1 root root 494 7月  10 16:55 50x.html
-rw-r--r--. 1 root root 612 7月  10 16:55 index.html

[storage@localhost html]$ sudo ../sbin/nginx -t //【测试刚刚的步骤是否正确】
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
</code></pre>
<h3 id="整合Nginx实现文件服务器"><a href="#整合Nginx实现文件服务器" class="headerlink" title="整合Nginx实现文件服务器"></a>整合Nginx实现文件服务器</h3><pre><code class="java">[storage@localhost FastDFS]$ tar -zxvf fastdfs-nginx-module-1.22.tar.gz 
fastdfs-nginx-module-1.22/
fastdfs-nginx-module-1.22/HISTORY
fastdfs-nginx-module-1.22/INSTALL
fastdfs-nginx-module-1.22/src/
fastdfs-nginx-module-1.22/src/common.c
fastdfs-nginx-module-1.22/src/common.h
fastdfs-nginx-module-1.22/src/config
fastdfs-nginx-module-1.22/src/mod_fastdfs.conf
fastdfs-nginx-module-1.22/src/ngx_http_fastdfs_module.c
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ ll
总用量 8
-rw-rw-r--. 1 storage storage 3036 11月 19 2019 HISTORY
-rw-rw-r--. 1 storage storage 2001 11月 19 2019 INSTALL
drwxrwxr-x. 2 storage storage  109 11月 19 2019 src
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ sudo cp mod_fastdfs.conf /etc/fdfs/
[storage@localhost ~]$ cd /etc/fdfs/
[storage@localhost fdfs]$ sudo vim mod_fastdfs.conf 
//【布置存储路径】
/*
store_path0=/usr/local/fastdfs/storage
tracker_server=192.168.170.135:22122
group_name=imooc
url_have_group_name = true
base_path=/usr/local/fastdfs/tmp
*/
[storage@localhost FastDFS]$ cd fastdfs-nginx-module-1.22/
[storage@localhost fastdfs-nginx-module-1.22]$ cd src/
[storage@localhost src]$ vim config
/local 把带有local的都删掉
[storage@localhost ~]$ cd nginx-1.16.1/
 [storage@localhost nginx-1.16.1]$ 
./configure \
&gt; --prefix=/usr/local/nginx \
&gt; --pid-path=/var/run/nginx/nginx.pid \
&gt; --lock-path=/var/lock/nginx.lock \
&gt; --error-log-path=/var/log/nginx/error.log \
&gt; --http-log-path=/var/log/nginx/access.log \
&gt; --with-http_gzip_static_module \
&gt; --http-client-body-temp-path=/var/temp/nginx/client \
&gt; --http-proxy-temp-path=/var/temp/nginx/proxy \
&gt; --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \
&gt; --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \
&gt; --http-scgi-temp-path=/var/temp/nginx/scgi \
&gt; --add-module=/home/storage/FastDFS/fastdfs-nginx-module-1.22/src
[storage@localhost nginx-1.16.1]$ sudo make &amp;&amp; sudo make install
[storage@localhost nginx-1.16.1]$ cd /usr/local/nginx/
[storage@localhost nginx]$ cd conf/
[storage@localhost conf]$ sudo vim nginx.conf
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location ~/group[0-9]/ &#123;
        ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;

*/
[storage@localhost conf]$ vim /etc/fdfs/tracker.conf
/http.service_port:8080
[storage@localhost conf]$ sudo vim nginx.conf //★★★★★★
/*
server &#123;
        listen       8888;
        server_name  localhost;
        location /imooc/M00 &#123;
            ngx_fastdfs_module;
        &#125;
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;
&#125;
*/
[storage@localhost conf]$ sudo ../sbin/nginx -t //测试一下有无问题
ngx_http_fastdfs_set pid=6143
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
[storage@localhost conf]$ sudo ../sbin/nginx -s reload //重新加载
ngx_http_fastdfs_set pid=6436

[storage@localhost conf]$ cd /usr/local/fastdfs/storage/
[storage@localhost storage]$ cd data
[storage@localhost data]$ cd 00/00
总用量 40
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457_big.png-m
-rw-r--r--. 1 root root 12618 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
-rw-r--r--. 1 root root    49 7月   9 19:39 wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png-m
http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png


//查看错误日志 ★★★【sudo tail -n 50 /var/log/nginx/error.log】★★★
/*
2. 重新加载 systemd 并启动 Nginx
重新加载 systemd：
复制代码
sudo systemctl daemon-reload
启动 Nginx：

sh
复制代码
sudo systemctl start nginx
设置开机自启动：

sh
复制代码
sudo systemctl enable nginx
检查 Nginx 服务状态：

sh
复制代码
sudo systemctl status nginx
*/
[storage@localhost conf]$ sudo vim /etc/fdfs/tracker.conf
[storage@localhost conf]$ sudo vim /etc/fdfs/storage.conf

[storage@localhost conf]$ cd /usr/local/nginx/conf/
[storage@localhost conf]$ sudo ../sbin/nginx -s stop
ngx_http_fastdfs_set pid=12586
[storage@localhost conf]$ sudo ../sbin/nginx
ngx_http_fastdfs_set pid=12605
[storage@localhost conf]$ sudo ../sbin/nginx -s reload

/*
FastDFS输出报告位置：
sudo tail -n 50 /usr/local/fastdfs/storage/logs/storaged.log


启动 Tracker 服务器：
sudo systemctl start fdfs_trackerd
检查 Tracker 服务器状态：
sudo systemctl status fdfs_trackerd
确认 Tracker 服务器监听端口：
sudo netstat -tuln | grep :22122
*/
//草！好几个小时的含泪史 一定要先开tracker端！！！
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★
★★★★★一定要先启动tracker 再去启动storage 不然service发不过去★★★★★

/*
首先，重新启动 FastDFS 的 tracker 和 storage 服务：

bash
复制代码
# 重启 tracker 服务
sudo systemctl restart fdfs_trackerd

# 重启 storage 服务
sudo systemctl restart fdfs_storaged
2. 重启 Nginx 服务
接下来，重新启动 Nginx 服务，确保它能够加载新的配置并生效：

bash
复制代码
sudo systemctl restart nginx
3. 验证服务状态
重新启动服务后，可以通过以下方式验证它们的运行状态：

检查 FastDFS 服务状态：

bash
复制代码
sudo systemctl status fdfs_trackerd
sudo systemctl status fdfs_storaged
检查 Nginx 服务状态：

bash
复制代码
sudo systemctl status nginx
*/

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaNIW2AMDeaAAAxSiWa1VQ457.png
</code></pre>
<h3 id="创建文件服务module-文件上传"><a href="#创建文件服务module-文件上传" class="headerlink" title="创建文件服务module [文件上传]"></a>创建文件服务module [文件上传]</h3><pre><code class="xml">【新建一个module imooc-news-dev-service-files】
pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-files&lt;/artifactId&gt;
&lt;!--
    imooc-news-dev-service-files
    文件服务，文件相关的操作都在此文件中进行
    文件上传   文件下载
    fastdfs  oss  gridfs
--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 文件上传fdfs工具包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.tobato&lt;/groupId&gt;
            &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;
            &lt;version&gt;1.27.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;



    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">application.yuml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="yaml">application-dev.yuml
server:
  port: 8004

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/HelloController.java
package com.imooc.files.controller;


import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello()&#123;
        return GraceJSONResult.ok(&quot;Hello World!&quot;);
    &#125;
&#125;




service-files  com/imooc/files/Application.java
package com.imooc.files;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //排除数据源
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
-----------------------------------------------------------------------
http://localhost:8004/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: &quot;Hello World!&quot;
&#125;
</code></pre>
<h3 id="整合fdfs与service实现-文件上传"><a href="#整合fdfs与service实现-文件上传" class="headerlink" title="整合fdfs与service实现 [文件上传]"></a>整合fdfs与service实现 [文件上传]</h3><pre><code class="java">service-api  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.service.UploaderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# 用户微服务
# web访问端口号  约定：8003
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000

############################################################
#
# fdfs配置信息
#
############################################################
fdfs:
  connect-timeout: 30
  so-timeout: 30
  tracker-list: 192.168.170.135:22122
</code></pre>
<h3 id="实现fastdfs图片存储-文件上传"><a href="#实现fastdfs图片存储-文件上传" class="headerlink" title="实现fastdfs图片存储 [文件上传]"></a>实现fastdfs图片存储 [文件上传]</h3><pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);
        return GraceJSONResult.ok(path);
    &#125;
&#125;
//此时去上传图片会报错 报跨域异常错误
//需要在用户service-user里的Application 
//@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
//贴到com/imooc/files/Application.java

此时再次 http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
提交头像
Console：
06:09.827 [http-nio-8004-exec-1] INFO  o.a.c.c.C.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;
06:09.827 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Initializing Servlet &#39;dispatcherServlet&#39;
06:09.832 [http-nio-8004-exec-1] INFO  o.s.web.servlet.DispatcherServlet - Completed initialization in 5 ms
06:09.882 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - ==== 开始执行 class com.imooc.files.service.impl.UploaderServiceImpl.uploadFdfs ====
06:09.937 [http-nio-8004-exec-2] INFO  c.imooc.api.aspect.ServiceLogAspect - 当前执行耗时：55
06:09.937 [http-nio-8004-exec-2] INFO  c.i.f.c.FileUploadController - path = imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png

http://192.168.170.136:8888/imooc/M00/00/00/wKiqiGaPrpKAEt22AAAeb3kUsrg507.png
此时就可以看到Cat的图片了！
</code></pre>
<h3 id="完善用户头像上传"><a href="#完善用户头像上传" class="headerlink" title="完善用户头像上传"></a>完善用户头像上传</h3><pre><code class="java">【在用户返回的时候写死路径+path】
return GraceJSONResult.ok(&quot;http://192.168.170.136:8888/&quot;path);

给它包装一下 FileResource写一下
service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.files.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // 执行上传
                path = uploaderService.uploadFdfs(file, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/FileResource.java
package com.imooc.files;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;

    public String getHost() &#123;
        return host;
    &#125;

    public void setHost(String host) &#123;
        this.host = host;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage 节点地址(nginx整合的web服务)
file.host=http://192.168.170.136:8888/


application.yml
############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-file
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  servlet:
    multipart:
      max-file-size: 512000 #请求文件大小限制为500kb
      max-request-size: 512000
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
此时拦截器也要加一层
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
//        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="图片大小控制的统一异常处理"><a href="#图片大小控制的统一异常处理" class="headerlink" title="图片大小控制的统一异常处理"></a>图片大小控制的统一异常处理</h3><pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
    @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;
&#125;
</code></pre>
<h3 id="第三方云存储解决方案-【阿里OSS】"><a href="#第三方云存储解决方案-【阿里OSS】" class="headerlink" title="第三方云存储解决方案 【阿里OSS】"></a>第三方云存储解决方案 【阿里OSS】</h3><h5 id="FastDFS-中小型公司使用"><a href="#FastDFS-中小型公司使用" class="headerlink" title="FastDFS [中小型公司使用]"></a>FastDFS [中小型公司使用]</h5><ul>
<li>水平扩容</li>
<li>运维复杂</li>
<li>开发复杂【增加图片效果 &amp; 人脸识别等】</li>
</ul>
<h5 id="云存储阿里OSS"><a href="#云存储阿里OSS" class="headerlink" title="云存储阿里OSS"></a><span style = "color:red">云存储阿里OSS</span></h5><ul>
<li>SDK使用简单 [Java对接]</li>
<li>提供强大的文件处理功能</li>
<li>零运维成本</li>
<li>图形化管理控制台</li>
<li>CDN加速</li>
<li>降低风险管理成本</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://common-buy.aliyun.com/?commodityCode=ossbag&spm=5176.28061389.commonbuy2container.oss_rc_dp_cn_ZjqTabLinks_2.3949778b3uJsQM&regionId=cn-inland-common&accounttraceid=f8f4fe13a682404d8cab9b0254ae864ddivk">对象存储 OSS 资源包 (aliyun.com)</a>[购买 <strong><u>标准-本地冗余存储</u></strong> ＋ <u><strong>下行流量</strong></u> ]</p>
<h3 id="控制台的基本配置使用-【阿里OSS】"><a href="#控制台的基本配置使用-【阿里OSS】" class="headerlink" title="控制台的基本配置使用 【阿里OSS】"></a>控制台的基本配置使用 【阿里OSS】</h3><p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/overview">OSS管理控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://billing-cost.console.aliyun.com/home/myfreetier?spm=5176.29188366.free-tier.4.47553e4dvJ4jbs">费用与成本 (aliyun.com)我的试用</a></p>
<ul>
<li>对象存储OSS → Bucket列表 → 创建Bucket → 存储冗余类型:<u>本地冗余存储</u> → 读写权限:<u>公共读</u></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://oss.console.aliyun.com/bucket/oss-cn-shanghai/iimooc-news-dev/object">OSS管理控制台 (aliyun.com)</a></p>
<ul>
<li>创建成功后进入<u>iimooc-news-dev&#x2F;object</u> → 文件管理 → 文件列表 →<br><a target="_blank" rel="noopener" href="https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png">https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/log.png</a></li>
</ul>
<pre><code class="xml">dev-common  pom.xml
&lt;dependency&gt;
  &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
  &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
  &lt;version&gt;3.10.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>对象存储OSS → SDK文档 → <strong>上传网络流</strong></li>
<li>对象存储OSS → iimooc-news-dev → 概览 → 访问端口: 外网访问 <u>oss-cn-shanghai.aliyuncs.com</u></li>
</ul>
<h3 id="SDK的使用与项目整合"><a href="#SDK的使用与项目整合" class="headerlink" title="SDK的使用与项目整合"></a>SDK的使用与项目整合</h3><pre><code class="java">service-file  com/imooc/files/service/UploaderService.java
package com.imooc.files.service;

import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;

public interface UploaderService &#123;
    /**
     * 使用fastdfs 上传文件
     */
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException;

    /**
     * 使用OSS 上传文件
     */
    public String uploadOSS(MultipartFile file,String userId, String fileExtName) throws IOException;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/service/impl/UploaderServiceImpl.java
package com.imooc.files.service.impl;

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import com.github.tobato.fastdfs.domain.fdfs.StorePath;
import com.github.tobato.fastdfs.service.FastFileStorageClient;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.utils.extend.AliyunResource;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;

@Service
public class UploaderServiceImpl implements UploaderService &#123;
    //注入客户端
    @Autowired
    public FastFileStorageClient fastFileStorageClient;
    @Autowired
    public FileResource fileResource;
    @Autowired
    public AliyunResource aliyunResource;
    @Autowired
    public Sid sid;

    @Override
    public String uploadFdfs(MultipartFile file, String fileExtName) throws IOException &#123;
        StorePath storePath = fastFileStorageClient.uploadFile(file.getInputStream(), file.getSize(), fileExtName, null);
        return storePath.getFullPath();
    &#125;

    @Override
    public String uploadOSS(MultipartFile file, String userId, String fileExtName) throws IOException &#123;
        // Endpoint以杭州为例，其它Region请按实际情况填写。
        // 外网访问：oss-cn-shanghai.aliyuncs.com
        String endpoint = fileResource.getEndpoint();
        // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。
        String accessKeyId = aliyunResource.getAccessKeyID();
        String accessKeySecret = aliyunResource.getAccessKeySecret();

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint,
                accessKeyId,
                accessKeySecret);
        //  images/abc/10010/cat.png  路径不全 所以需要myObjectName拼接
        String fileName = sid.nextShort();
        String myObjectName = fileResource.getObjectName()
                + &quot;/&quot; + userId + &quot;/&quot; + fileName + &quot;.&quot; + fileExtName;

        // 上传网络流。
        InputStream inputStream = file.getInputStream();
        ossClient.putObject(fileResource.getBucketName(),
                myObjectName,
                inputStream);

        // 关闭OSSClient。
        ossClient.shutdown();
        return myObjectName;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
package com.imooc.files.resource;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
&#125;Getter + Setter
</code></pre>
<pre><code class="mysql">file-dev.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc
</code></pre>
<h3 id="OSS整合实现文件上传"><a href="#OSS整合实现文件上传" class="headerlink" title="OSS整合实现文件上传"></a>OSS整合实现文件上传</h3><pre><code class="java"> // OSS执行上传
//  path = uploaderService.uploadOSS(file, userId, suffix);

service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
            finalPath = fileResource.getHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;

=================================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/accountInfo.html
此时更改头像上传后 头像会在OSS服务器的文件里面显示
</code></pre>
<pre><code class="mysql">file-dev.properties / file-prod.properties
# fastdfs storage ????(nginx???web??)
file.host=http://192.168.170.136:8888/

# aliyun OSS
file.endpoint=oss-cn-shanghai.aliyuncs.com

file.BucketName=iimooc-news-dev

# url name
file.objectName=images/abc

file.ossHost=https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/
</code></pre>
<pre><code class="java">service-files  com/imooc/files/resource/FileResource.java
@Component
@PropertySource(&quot;classpath:file-$&#123;spring.profiles.active&#125;.properties &quot;) //这个是在application.yml里面的 自动匹配
@ConfigurationProperties(prefix = &quot;file&quot;)
public class FileResource &#123;
    private String host;
    private String endpoint;
    private String BucketName;
    private String objectName;
    private String OssHost;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
    //用OSS执行上传 而不是 fdfs执行上传
package com.imooc.files.controller;


import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
        return GraceJSONResult.ok(finalPath);
    &#125;
&#125;
</code></pre>
<h3 id="图片自动审核-【阿里内容安全】"><a href="#图片自动审核-【阿里内容安全】" class="headerlink" title="图片自动审核 【阿里内容安全】"></a>图片自动审核 【阿里内容安全】</h3><h6 id="多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢"><a href="#多媒体内容风险智能识别服务，降低色情、暴力、恐怖-由于太贵了就不买了-1000多呢" class="headerlink" title="多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (由于太贵了就不买了 1000多呢)"></a>多媒体内容风险智能识别服务，降低色情、暴力、恐怖 (<u>由于太贵了就不买了 1000多呢</u>)</h6><pre><code class="xml">dev-common  pom.xml
 &lt;!-- 第三方云厂商相关的依赖 --&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-codec&lt;/groupId&gt;
            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
            &lt;version&gt;1.10&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliImageReviewUtils.java
package com.imooc.utils.extend;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.green.model.v20180509.ImageSyncScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.http.MethodType;
import com.aliyuncs.http.ProtocolType;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import com.imooc.enums.ArticleReviewLevel;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Date;
import java.util.UUID;

@Component
public class AliImageReviewUtils &#123;

//    文档地址：https://help.aliyun.com/document_detail/70292.html?spm=a2c4g.11186623.2.49.6f9c75fdjaW30p#reference-fzy-ztm-v2b

    @Autowired
    private AliyunResource aliyunResource;

    public boolean reviewImage(String imgUrl) throws Exception &#123;
        IClientProfile profile = DefaultProfile
                .getProfile(&quot;cn-shanghai&quot;, &quot;&quot;, &quot;&quot;);
        DefaultProfile
                .addEndpoint(&quot;cn-shanghai&quot;, &quot;cn-shanghai&quot;, &quot;Green&quot;, &quot;green.cn-shanghai.aliyuncs.com&quot;);
        IAcsClient client = new DefaultAcsClient(profile);

        ImageSyncScanRequest imageSyncScanRequest = new ImageSyncScanRequest();
        // 指定api返回格式
        imageSyncScanRequest.setAcceptFormat(FormatType.JSON);
        // 指定请求方法
        imageSyncScanRequest.setMethod(MethodType.POST);
        imageSyncScanRequest.setEncoding(&quot;utf-8&quot;);
        //支持http和https
        imageSyncScanRequest.setProtocol(ProtocolType.HTTP);


        JSONObject httpBody = new JSONObject();
        /**
         * 设置要检测的场景, 计费是按照该处传递的场景进行
         * 一次请求中可以同时检测多张图片，每张图片可以同时检测多个风险场景，计费按照场景计算
         * 例如：检测2张图片，场景传递porn、terrorism，计费会按照2张图片鉴黄，2张图片暴恐检测计算
         * porn: porn表示色情场景检测
         * logo: 商标
         * 其他详见官方文档
         */
        httpBody.put(&quot;scenes&quot;, Arrays.asList(&quot;terrorism&quot;));

        /**
         * 设置待检测图片， 一张图片一个task
         * 多张图片同时检测时，处理的时间由最后一个处理完的图片决定
         * 通常情况下批量检测的平均rt比单张检测的要长, 一次批量提交的图片数越多，rt被拉长的概率越高
         * 这里以单张图片检测作为示例, 如果是批量图片检测，请自行构建多个task
         */
        JSONObject task = new JSONObject();
        task.put(&quot;dataId&quot;, UUID.randomUUID().toString());

        //设置图片链接
        task.put(&quot;url&quot;, imgUrl);
        task.put(&quot;time&quot;, new Date());
        httpBody.put(&quot;tasks&quot;, Arrays.asList(task));

        imageSyncScanRequest.setHttpContent(org.apache.commons.codec.binary.StringUtils.getBytesUtf8(httpBody.toJSONString()),
                &quot;UTF-8&quot;, FormatType.JSON);

        /**
         * 请设置超时时间, 服务端全链路处理超时时间为10秒，请做相应设置
         * 如果您设置的ReadTimeout小于服务端处理的时间，程序中会获得一个read timeout异常
         */
        imageSyncScanRequest.setConnectTimeout(3000);
        imageSyncScanRequest.setReadTimeout(10000);
        HttpResponse httpResponse = null;
        try &#123;
            httpResponse = client.doAction(imageSyncScanRequest);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        //服务端接收到请求，并完成处理返回的结果
        if (httpResponse != null &amp;&amp; httpResponse.isSuccess()) &#123;
            JSONObject scrResponse = JSON.parseObject(org.apache.commons.codec.binary.StringUtils.newStringUtf8(httpResponse.getHttpContent()));
            System.out.println(JSON.toJSONString(scrResponse, true));
            int requestCode = scrResponse.getIntValue(&quot;code&quot;);
            //每一张图片的检测结果
            JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
            if (200 == requestCode) &#123;
                for (Object taskResult : taskResults) &#123;
                    //单张图片的处理结果
                    int taskCode = ((JSONObject) taskResult).getIntValue(&quot;code&quot;);
                    //图片要检测的场景的处理结果, 如果是多个场景，则会有每个场景的结果
                    JSONArray sceneResults = ((JSONObject) taskResult).getJSONArray(&quot;results&quot;);
                    if (200 == taskCode) &#123;
                        Object sceneResult = sceneResults.get(0);
//                        for (Object sceneResult : sceneResults) &#123;
                        String scene = ((JSONObject) sceneResult).getString(&quot;scene&quot;);
                        String suggestion = ((JSONObject) sceneResult).getString(&quot;suggestion&quot;);
                        //根据scene和suggetion做相关处理
                        //do something
                        System.out.println(&quot;scene = [&quot; + scene + &quot;]&quot;);
                        System.out.println(&quot;suggestion = [&quot; + suggestion + &quot;]&quot;);

                        return suggestion.equalsIgnoreCase(ArticleReviewLevel.PASS.type) ? true : false;
//                        &#125;
                    &#125; else &#123;
                        //单张图片处理失败, 原因视具体的情况详细分析
                        System.out.println(&quot;task process fail. task response:&quot; + JSON.toJSONString(taskResult));
                        return false;
                    &#125;
                &#125;
            &#125; else &#123;
                /**
                 * 表明请求整体处理失败，原因视具体的情况详细分析
                 */
                System.out.println(&quot;the whole image scan request failed. response:&quot; + JSON.toJSONString(scrResponse));
                return false;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/crisschan/article/details/136866137">解决github Push rejected报错 remote: error: GH013: Repository rule violations found for refs&#x2F;heads&#x2F;maste_github push declined due to repository rule violat-CSDN博客</a></p>
<pre><code class="java">dev-common  com/imooc/enums/ArticleReviewLevel.java
package com.imooc.enums;

/**
 * @Desc: 文章自动审核结果 枚举
 */
public enum ArticleReviewLevel &#123;
    PASS(&quot;pass&quot;, &quot;自动审核通过&quot;),
    BLOCK(&quot;block&quot;, &quot;自动审核不通过&quot;),
    REVIEW(&quot;review&quot;, &quot;建议人工复审&quot;);

    public final String type;
    public final String value;

    ArticleReviewLevel(String type, String value) &#123;
        this.type = type;
        this.value = value;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
package com.imooc.files.controller;

import com.imooc.api.controller.files.FileUploadControllerApi;
import com.imooc.files.resource.FileResource;
import com.imooc.files.service.UploaderService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliImageReviewUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

@RestController
public class FileUploadController implements FileUploadControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FileUploadController.class);

    @Autowired
    private UploaderService uploaderService;

    @Autowired
    private FileResource fileResource;

    @Autowired
    private AliImageReviewUtils aliImageReviewUtils;

    @Override
    public GraceJSONResult uploadFace(String userId,
                                      MultipartFile file) throws Exception &#123;
        String path = &quot;&quot;;
        if (file != null)&#123;
        // 获得文件上传的名称
            String fileName = file.getOriginalFilename();
            //判断文件名不能为空
            if (StringUtils.isNotBlank(fileName))&#123;
                String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                //获得后缀名
                String suffix = fileNameArr[fileNameArr.length - 1];
                //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                        !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                )&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_FORMATTER_FAILD);
                &#125;
                // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
//                path = uploaderService.uploadFdfs(file, suffix);
                // OSS执行上传
                path = uploaderService.uploadOSS(file, userId, suffix);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
            &#125;
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_NULL_ERROR);
        &#125;
        logger.info(&quot;path = &quot; + path);

        String finalPath = &quot;&quot;;
        if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
            finalPath = fileResource.getOssHost() + path;
        &#125;  else&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_UPLOAD_FAILD);
        &#125;
           return GraceJSONResult.ok(finalPath);
       // return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
    &#125;

    /**
     * fastdfs 默认存在于内网，无法被阿里云内容管理服务检查到
     * 需要配置到公网才行：
     * 1. 内网穿透，natppp/花生壳/ngrok
     * 2. 路由配置端口映射
     * 3. fdfs 发布到云服务器
     */

   /* 功能实现不了图片识别 因为没有开通内容安全需要企业认证
     public static final String FAILED_IMAGE_URL = &quot;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/Review_Failed.png&quot;; //这里保存审核失败的照片 提前上传到Oss里直接用
    private String doAliImageReview(String pendingImageUrl)&#123;
        boolean result = false;
        try &#123;
            result = aliImageReviewUtils.reviewImage(pendingImageUrl);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        if (!result)&#123;
            return FAILED_IMAGE_URL;
        &#125;
        return pendingImageUrl;
    &#125;
&#125;
*/
</code></pre>
<h3 id="创建阿里云子账号-【阿里内容安全】"><a href="#创建阿里云子账号-【阿里内容安全】" class="headerlink" title="创建阿里云子账号 【阿里内容安全】"></a>创建阿里云子账号 【阿里内容安全】</h3><p><a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/users">RAM访问控制 → 用户</a><br>[实在不行了 凑合着搞一下吧 功能实现不了图片识别 因为没有开通内容安全需要企业认证]</p>
<blockquote>
<p>登录名称：imooc-news-dev<br>显示名称：用于内容审核<br>√  OpenAPI访问调用<br>AccessKey ID：<br>AccessKeySeret：</p>
<p>点击左侧列表下方 授权 → 新增授权 【授权主体：用于内容审核      权限策略：搜：green   … 管理内容安全的权限】</p>
</blockquote>
<h3 id="构建admin服务"><a href="#构建admin服务" class="headerlink" title="构建admin服务"></a>构建admin服务</h3><ul>
<li>构建admin管理服务</li>
<li>文章分类管理</li>
<li>友情连接管理</li>
<li>用户账号管理</li>
<li>文章内容人工审核 [放在文章上传后的自动审核]</li>
<li>admin管理人员账号分配 [用户人脸]</li>
</ul>
<pre><code class="xml">service-admin  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-admin&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;


&lt;/project&gt;
</code></pre>
<pre><code class="xml">service-admin  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-admin&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-admin.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-admin:8005
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/HelloController.java
package com.imooc.admin.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
----------------------------------------------------------------------------
http://admin.imoocnews.com:8005/hello

application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
</code></pre>
<h3 id="表设计与账号预分配-【admin账号】"><a href="#表设计与账号预分配-【admin账号】" class="headerlink" title="表设计与账号预分配 【admin账号】"></a>表设计与账号预分配 【admin账号】</h3><pre><code class="xml">service-admin  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/PWDTest.java
package com.imooc.admin.controller;

import org.springframework.security.crypto.bcrypt.BCrypt;

public class PWDTest &#123;
    public static void main(String[] args) &#123;
        String pwd = BCrypt.hashpw(&quot;admin&quot;, BCrypt.gensalt());//加盐
        System.out.println(pwd);
    &#125;
&#125;
</code></pre>
<h3 id="持久层查询管理员-【admin账号】"><a href="#持久层查询管理员-【admin账号】" class="headerlink" title="持久层查询管理员 【admin账号】"></a>持久层查询管理员 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/login.html">http://admin.imoocnews.com:9090/imooc-news/admin/login.html</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">Windows下如何查看某个端口被谁占用 | 菜鸟教程 (runoob.com)</a></p>
<pre><code class="java">//更改一下mybatis-generator-database里面的generatorConfig-admin.xml
数据库表为：admin_user
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.admin&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.admin.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;admin_user&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database的把AdminUser拷贝到dev-model的com/imooc/pojo下
mybatis-generator-database的把AdminUserMapper拷贝到service-admin的resources mapper/AdminUserMapper.xml
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;



service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import tk.mybatis.mapper.entity.Example;

public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-admin  mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="用户名密码登录-【admin账号】"><a href="#用户名密码登录-【admin账号】" class="headerlink" title="用户名密码登录 【admin账号】"></a>用户名密码登录 【admin账号】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/arjelarxfc/article/details/78806384">Spring里遇到的一个问题，autowired时报找不到bean定义_autowired找不到bean-CSDN博客</a></p>
<h6 id="其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”"><a href="#其次上述问题一定要去找Controller-Service-ServiceImpl-和-启动类里面的有没有正确扫描包-MapperScan-basePackages-x3D-“com-imooc-admin-mapper”" class="headerlink" title="其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)"></a>其次上述问题一定要去找Controller Service ServiceImpl 和 启动类里面的有没有正确扫描包@MapperScan(basePackages &#x3D; “com.imooc.admin.mapper”)</h6><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public Object adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;

    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;
&#125;
---------------------------------------------------------------------------------
http://admin.imoocnews.com:9090/imooc-news/admin/login.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.pojo.AdminUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/AdminUserMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.AdminUser;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminUserMapper extends MyMapper&lt;AdminUser&gt; &#123;
&#125;


service-admin  resources/mapper/AdminUserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.AdminUserMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.AdminUser&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;face_id&quot; property=&quot;faceId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;admin_name&quot; property=&quot;adminName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;created_time&quot; property=&quot;createdTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;updated_time&quot; property=&quot;updatedTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/Application.java
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">service-admin  application-dev.yml
server:
  port: 8005

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
#mybatis:
#  configuration:
#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
#
</code></pre>
<h3 id="校验admin账号唯一-【admin账号】"><a href="#校验admin账号唯一-【admin账号】" class="headerlink" title="校验admin账号唯一 【admin账号】"></a>校验admin账号唯一 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java

  @Override
    public Object adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;
    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.pojo.bo.AdminLoginBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public Object adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                             HttpServletRequest request,
                             HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public Object adminLogin(@RequestParam String username); //传回来
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UseActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UseActiveInterceptor useActiveInterceptor()&#123;
        return new UseActiveInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);

        //        registry.addInterceptor(userTokenInterceptor())
//                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
    &#125;
&#125;
</code></pre>
<h3 id="创建admin账号-【admin账号】"><a href="#创建admin账号-【admin账号】" class="headerlink" title="创建admin账号 【admin账号】"></a>创建admin账号 【admin账号】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/userList.html">用户管理 | 运营管理平台 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a></p>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private RedisOperator redis;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1.查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2.判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
        // 3.判断密码是否匹配
        boolean isPwdMath = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMath)&#123;
            doLoginSettings(admin,request,response);
            return GraceJSONResult.ok();
        &#125;else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     */
    private void doLoginSettings(AdminUser admin, HttpServletRequest request, HttpServletResponse response)&#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(),token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;


    @Override
    public GraceJSONResult adminLogin(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username)&#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);
        if (admin != null)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;

    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64()))&#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) || StringUtils.isBlank(newAdminBO.getConfirmPassword()))&#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;
        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword().equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;
        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4.调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response); //传回来
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.service.AdminUserService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;

@Service
public class AdminUserServiceImpl implements AdminUserService &#123;
    @Autowired
    public AdminUserMapper adminUserMapper;
    @Autowired
    public Sid sid;
    @Override
    public AdminUser queryAdminByUsername(String username) &#123;
        Example adminExample = new Example(AdminUser.class);
        Example.Criteria Criteria = adminExample.createCriteria();
        Criteria.andEqualTo(&quot;username&quot;,username);
        AdminUser admin = adminUserMapper.selectOneByExample(adminExample);
        return admin;
    &#125;

    @Override
    public void createAdminUser(NewAdminBO newAdminBO) &#123;
        String adminId = sid.nextShort(); //获得主键
        AdminUser adminUser = new AdminUser();
        adminUser.setId(adminId);
        adminUser.setUsername(newAdminBO.getUsername());
        adminUser.setAdminName(newAdminBO.getAdminName());
        // 如果密码不为空 则密码需要加密 存入数据库
        if (StringUtils.isNotBlank(newAdminBO.getPassword()))&#123;
            String pwd = BCrypt.hashpw(newAdminBO.getPassword(), BCrypt.gensalt());
            adminUser.setPassword(pwd);
        &#125;

        // 如果人脸上传以后，则有faceId，需要和admin信息关联存储入库
        if (StringUtils.isNotBlank(newAdminBO.getFaceId()))&#123;
            adminUser.setFaceId(newAdminBO.getFaceId());
        &#125;
        adminUser.setCreatedTime(new Date());
        adminUser.setUpdatedTime(new Date());

        int insert = adminUserMapper.insert(adminUser);
        if (insert != 1)&#123;
            GraceException.display(ResponseStatusEnum.ADMIN_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);
&#125;
</code></pre>
<h3 id="查看admin列表-【admin账号】-分页查询"><a href="#查看admin列表-【admin账号】-分页查询" class="headerlink" title="查看admin列表 【admin账号】(分页查询)"></a>查看admin列表 【admin账号】(分页查询)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;//由于是固定数值 可以去basecontroller加一下
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public void queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
@Override
    public void queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        System.out.println(adminUserList);
    &#125; //下面一节会有改动
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/Swagger2.java
package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
//        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
//                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;,tags = &#123;&quot;管理员admin维护的Controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;
    @ApiOperation(value = &quot;hello方法的接口&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;,notes = &quot;查询admin用户名是否存在&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminLogin(@RequestParam String username); //传回来

    @ApiOperation(value = &quot;创建admin&quot;,notes = &quot;创建admin&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,HttpServletRequest request,HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;,notes = &quot;查询admin列表&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(@ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;,  required = false) @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false) @RequestParam Integer pageSize);
&#125;

-----------------------------------------------------------------
http://admin.imoocnews.com:8005/doc.html
</code></pre>
<h3 id="封装PagedGridResult分页数据-调试分页接口-【admin账号】"><a href="#封装PagedGridResult分页数据-调试分页接口-【admin账号】" class="headerlink" title="封装PagedGridResult分页数据_调试分页接口 【admin账号】"></a><span style = "color:red">封装<del>PagedGridResult</del></span>分页数据_调试分页接口 【admin账号】</h3><pre><code class="java">service-admin  com/imooc/admin/service/impl/AdminUserServiceImpl.java
    @Override
    public PagedGridResult queryAdminList(Integer page, Integer pageSize) &#123;
        Example adminExample = new Example(AdminUser.class);
        adminExample.orderBy(&quot;createdTime&quot;).asc();
        PageHelper.startPage(page, pageSize);
        List&lt;AdminUser&gt; adminUserList = adminUserMapper.selectByExample(adminExample);
        return setterPagedGrid(adminUserList, page);
    &#125;

    private PagedGridResult setterPagedGrid( List&lt;?&gt; adminUserList, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(adminUserList);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(adminUserList);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getPages());
        gridResult.setTotal(pageList.getTotal());
        return gridResult;

    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.PagedGridResult;

public interface AdminUserService &#123;
    /**
     * 获得管理员的用户信息
     * @param username
     * @return
     */
    public AdminUser queryAdminByUsername(String username);

    /**
     * 新增管理员
     *
     * @param newAdminBO
     */
    public void createAdminUser(NewAdminBO newAdminBO);


    /**
     * 分页查询admin列表
     * @param page
     * @param pageSize
     */
    public PagedGridResult queryAdminList(Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/PagedGridResult.java
package com.imooc.utils;

import java.util.List;

/**
 * 
 * @Title: PagedGridResult.java
 * @Package com.imooc.utils
 * @Description: 用来返回分页Grid的数据格式
 * Copyright: Copyright (c) 2019
 */
public class PagedGridResult &#123;
    
    private int page;            // 当前页数
    private long total;            // 总页数
    private long records;        // 总记录数
    private List&lt;?&gt; rows;        // 每行显示的内容
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
//拦截器新增地址
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;);

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/AdminTokenInterceptor.java
package com.imooc.api.interceptors;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import static com.imooc.api.BaseController.REDIS_ADMIN_TOKEN;

public class AdminTokenInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    /**
     * 拦截请求，在访问controller调用之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String adminUserId = request.getHeader(&quot;adminUserId&quot;);
        String adminUserToken = request.getHeader(&quot;adminUserToken&quot;);

        System.out.println(&quot;=====================================================================&quot;);
        System.out.println(&quot;AdminTokenInterceptor - adminUserId = &quot; + adminUserId);
        System.out.println(&quot;AdminTokenInterceptor - adminUserToken = &quot; + adminUserToken);
        System.out.println(&quot;=====================================================================&quot;);

        boolean run = verifyUserIdToken(adminUserId, adminUserToken, REDIS_ADMIN_TOKEN);
        return run;
    &#125;

    /**
     * 请求访问controller之后，渲染视图之前
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    /**
     * 请求访问controller之后，渲染视图之后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<h3 id="账号注销-【admin账号】-删掉redis和cookie数据"><a href="#账号注销-【admin账号】-删掉redis和cookie数据" class="headerlink" title="账号注销 【admin账号】(删掉redis和cookie数据)"></a>账号注销 【admin账号】(删掉redis和cookie数据)</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.AdminUserService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.AdminMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.utils.FaceVerifyUtils;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.UUID;

@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(AdminMngController.class);

    @Autowired
    private RedisOperator redis;

    @Autowired
    private AdminUserService adminUserService;

    @Autowired
    private FaceVerifyUtils faceVerifyUtils;

    @Override
    public GraceJSONResult adminLogin(AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response) &#123;
        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. 查询admin用户的信息
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        // 2. 判断admin不为空，如果为空则登录失败
        if (admin == null) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;

        // 3. 判断密码是否匹配
        boolean isPwdMatch = BCrypt.checkpw(adminLoginBO.getPassword(), admin.getPassword());
        if (isPwdMatch) &#123;
            doLoginSettings(admin, request, response);
            return GraceJSONResult.ok();
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_NOT_EXIT_ERROR);
        &#125;
    &#125;


    /**
     * 用于admin用户登录过后的基本信息设置
     * @param admin
     * @param request
     * @param response
     */
    private void doLoginSettings(AdminUser admin,
                                 HttpServletRequest request,
                                 HttpServletResponse response) &#123;
        // 保存token放入到redis中
        String token = UUID.randomUUID().toString();
        redis.set(REDIS_ADMIN_TOKEN + &quot;:&quot; + admin.getId(), token);

        // 保存admin登录基本token信息到cookie中
        setCookie(request, response, &quot;atoken&quot;, token, COOKIE_MONTH);
        setCookie(request, response, &quot;aid&quot;, admin.getId(), COOKIE_MONTH);
        setCookie(request, response, &quot;aname&quot;, admin.getAdminName(), COOKIE_MONTH);
    &#125;

    @Override
    public GraceJSONResult adminIsExist(String username) &#123;
        checkAdminExist(username);
        return GraceJSONResult.ok();
    &#125;

    private void checkAdminExist(String username) &#123;
        AdminUser admin = adminUserService.queryAdminByUsername(username);

        if (admin != null) &#123;
            GraceException.display(ResponseStatusEnum.ADMIN_USERNAME_EXIST_ERROR);
        &#125;
    &#125;

    @Override
    public GraceJSONResult addNewAdmin(NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 0. TODO 验证BO中的用户名和密码不为空

        // 1. base64不为空，则代表人脸入库，否则需要用户输入密码和确认密码
        if (StringUtils.isBlank(newAdminBO.getImg64())) &#123;
            if (StringUtils.isBlank(newAdminBO.getPassword()) ||
                    StringUtils.isBlank(newAdminBO.getConfirmPassword())
            ) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_NULL_ERROR);
            &#125;
        &#125;

        // 2. 密码不为空，则必须判断两次输入一致
        if (StringUtils.isNotBlank(newAdminBO.getPassword())) &#123;
            if (!newAdminBO.getPassword()
                    .equalsIgnoreCase(newAdminBO.getConfirmPassword())) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_PASSWORD_ERROR);
            &#125;
        &#125;

        // 3. 校验用户名唯一
        checkAdminExist(newAdminBO.getUsername());

        // 4. 调用service存入admin信息
        adminUserService.createAdminUser(newAdminBO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getAdminList(Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult result = adminUserService.queryAdminList(page, pageSize);
        return GraceJSONResult.ok(result);
    &#125;

    @Override
    public GraceJSONResult adminLogout(String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response) &#123;

        // 从redis中删除admin的会话token
        redis.del(REDIS_ADMIN_TOKEN + &quot;:&quot; + adminId);

        // 从cookie中清理adming登录的相关信息
        deleteCookie(request, response, &quot;atoken&quot;);
        deleteCookie(request, response, &quot;aid&quot;);
        deleteCookie(request, response, &quot;aname&quot;);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;管理员admin维护&quot;, tags = &#123;&quot;管理员admin维护的controller&quot;&#125;)
@RequestMapping(&quot;adminMng&quot;)
public interface AdminMngControllerApi &#123;

    @ApiOperation(value = &quot;hello方法的接口&quot;, notes = &quot;hello方法的接口&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogin&quot;)
    public GraceJSONResult adminLogin(@RequestBody AdminLoginBO adminLoginBO,
                                      HttpServletRequest request,
                                      HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin用户名是否存在&quot;, notes = &quot;查询admin用户名是否存在&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminIsExist&quot;)
    public GraceJSONResult adminIsExist(@RequestParam String username);

    @ApiOperation(value = &quot;创建admin&quot;, notes = &quot;创建admin&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/addNewAdmin&quot;)
    public GraceJSONResult addNewAdmin(@RequestBody NewAdminBO newAdminBO,
                                       HttpServletRequest request,
                                       HttpServletResponse response);

    @ApiOperation(value = &quot;查询admin列表&quot;, notes = &quot;查询admin列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAdminList&quot;)
    public GraceJSONResult getAdminList(
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;admin退出登录&quot;, notes = &quot;admin退出登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminLogout&quot;)
    public GraceJSONResult adminLogout(@RequestParam String adminId,
                                       HttpServletRequest request,
                                       HttpServletResponse response);
                                        HttpServletResponse response);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public void setCookieValue(HttpServletRequest request,
                               HttpServletResponse response,
                               String cookieName,
                               String cookieValue,
                               Integer maxAge) &#123;
        Cookie cookie = new Cookie(cookieName, cookieValue);
        cookie.setMaxAge(maxAge);
//        cookie.setDomain(&quot;imoocnews.com&quot;);
        cookie.setDomain(DOMAIN_NAME);
        cookie.setPath(&quot;/&quot;);//都用cookie
        response.addCookie(cookie);//把cookie传入
    &#125;

    public void deleteCookie(HttpServletRequest request,HttpServletResponse response,String cookieName)&#123;
        try &#123;
            String deleteValue = URLEncoder.encode(&quot;&quot;, &quot;utf-8&quot;);
            setCookieValue(request, response, cookieName, deleteValue, COOKIE_DELETE);
        &#125; catch (UnsupportedEncodingException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
</code></pre>
<h3 id="人脸业务流程图梳理"><a href="#人脸业务流程图梳理" class="headerlink" title="人脸业务流程图梳理"></a>人脸业务流程图梳理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/fa7fae40efa428b638a2589c3203204ff0479b04/data/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h3 id="Chrome开启视频调试模式"><a href="#Chrome开启视频调试模式" class="headerlink" title="Chrome开启视频调试模式"></a>Chrome开启视频调试模式</h3><blockquote>
<p>在谷歌浏览器中打开【每一次重启电脑都要操作】<br>chrome:&#x2F;&#x2F;flags&#x2F;#unsafely-treat-insecure-origin-as-secure<br>|————————————————————————————————|<br>|  <a href="http://admin.imoocnews.com:9090,http://admin.imoocnews.com">http://admin.imoocnews.com:9090,http://admin.imoocnews.com</a> |<br>|—— ——————————————————————————————|<br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html</a><br>可以获取人脸</p>
</blockquote>
<h3 id="MongoDB概念-人脸数据存储-可以存储JSON数据"><a href="#MongoDB概念-人脸数据存储-可以存储JSON数据" class="headerlink" title="MongoDB概念 [人脸数据存储]可以存储JSON数据"></a>MongoDB概念 [人脸数据存储]<del>可以存储JSON数据</del></h3><ul>
<li>NoSql 数据库</li>
<li>内存级别查询</li>
<li>不支持事务</li>
<li>非并发读写 请求并发数据量大</li>
<li>GridFS 小文件存储</li>
</ul>
<h4 id="MongoDB术语"><a href="#MongoDB术语" class="headerlink" title="MongoDB术语"></a>MongoDB术语</h4><table>
<thead>
<tr>
<th align="center">数据库</th>
<th align="center">ElasticSearch</th>
<th align="center">MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">database</td>
<td align="center">es库</td>
<td align="center">database</td>
</tr>
<tr>
<td align="center">table表</td>
<td align="center">index索引</td>
<td align="center">collection数据集合</td>
</tr>
<tr>
<td align="center">row行 (记录)</td>
<td align="center">document文档 (json)</td>
<td align="center">document文档 (json)</td>
</tr>
<tr>
<td align="center">column 字段列</td>
<td align="center">field域</td>
<td align="center">field域</td>
</tr>
<tr>
<td align="center">index索引</td>
<td align="center">-</td>
<td align="center">index索引</td>
</tr>
<tr>
<td align="center">join表关联查询</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">pk主键</td>
<td align="center">_id</td>
<td align="center">_id</td>
</tr>
</tbody></table>
<h5 id="MongoDB数据结构"><a href="#MongoDB数据结构" class="headerlink" title="MongoDB数据结构"></a>MongoDB数据结构</h5><pre><code class="vue">UserList:[
    &#123;
        userId: &quot;1001&quot;,
        username: &quot;lee&quot;,
        age: 18
    &#125;,
    &#123;
        userId: &quot;1002&quot;,
        username: &quot;jay&quot;,
        age: 20,
        sex: &quot;boy&quot;
    &#125;
]

----------------------------------------------------------

UserList --&gt;   collection
&#123;&#125;       --&gt;   document
属性        --&gt;   column
</code></pre>
<h3 id="MogoDB安装与配置使用"><a href="#MogoDB安装与配置使用" class="headerlink" title="MogoDB安装与配置使用"></a>MogoDB安装与配置使用</h3><p><a target="_blank" rel="noopener" href="https://www.mongodb.com/try/download/enterprise">https://www.mongodb.com/try/download/enterprise</a></p>
<pre><code class="mysql">将mongodb-linux-x86_64-rhel70-4.2.8传入虚拟机
[imooc@imooc ~]$ tar -zxvf mongodb-linux-x86_64-rhel70-4.2.8.tgz 
[imooc@imooc ~]$ sudo mv mongodb-linux-x86_64-rhel70-4.2.8 /usr/local/mongodb
[imooc@imooc ~]$ cd /usr/local/
[imooc@imooc local]$ ll
drwxrwxr-x. 3 imooc imooc      135 7月  16 19:46 mongodb
[imooc@imooc local]$ cd mongodb/
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
-rw-r--r--. 1 imooc imooc  30608 6月  12 2020 LICENSE-Community.txt
-rw-r--r--. 1 imooc imooc  16726 6月  12 2020 MPL-2
-rw-r--r--. 1 imooc imooc   2617 6月  12 2020 README
-rw-r--r--. 1 imooc imooc  75405 6月  12 2020 THIRD-PARTY-NOTICES
-rw-r--r--. 1 imooc imooc 183512 6月  12 2020 THIRD-PARTY-NOTICES.gotools
[imooc@imooc mongodb]$ cd bin/
[imooc@imooc bin]$ pwd
/usr/local/mongodb/bin

[imooc@imooc bin]$ sudo vim /etc/profile
最下面添加：
export JAVA_HOME=/usr/java/jdk1.8.0_222-ea
export CLASSPATH=.:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin
#set mogodb config
export PATH=/usr/local/mongodb/bin:$PATH

#修改 /etc/profile 文件后，需要重新加载这个文件才能使新配置生效。你可以执行以下命令：
[imooc@imooc bin]$ source /etc/profile

[imooc@imooc bin]$ mongo --version
MongoDB shell version v4.2.8
git version: 43d25964249164d76d5e04dd6cf38f6111e21f5f
OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013
allocator: tcmalloc
modules: none
build environment:
    distmod: rhel70
    distarch: x86_64
    target_arch: x86_64

[imooc@imooc bin]$ cd /usr/local/mongodb/
[imooc@imooc mongodb]$ pwd
/usr/local/mongodb

#创建数据存储目录
[imooc@imooc mongodb]$ mkdir data/db -p #出来一个data
[imooc@imooc mongodb]$ ll
总用量 312
drwxrwxr-x. 2 imooc imooc    231 7月  16 19:46 bin
drwxrwxr-x. 3 imooc imooc     16 7月  16 20:00 data
[imooc@imooc mongodb]$ cd data
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
[imooc@imooc data]$ mkdir logs
[imooc@imooc data]$ ll
总用量 0
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 db
drwxrwxr-x. 2 imooc imooc 6 7月  16 20:00 logs
[imooc@imooc data]$ cd logs/
[imooc@imooc logs]$ pwd
/usr/local/mongodb/data/logs
[imooc@imooc logs]$ touch mongodb.log
[imooc@imooc logs]$ ll
总用量 0
-rw-rw-r--. 1 imooc imooc 0 7月  16 20:01 mongodb.log
[imooc@imooc logs]$ cd ..
[imooc@imooc logs]$ cd ..

[imooc@imooc mongodb]$ vim mongodb.conf
port=27017
# datasource path
dbpath=/user/local/mongodb/data/db
# log path
logpath=/usr/local/mongodb/data/logs/mongodb.log
# append log
logappend=true
# cut useless log
quiet=true
# back desktop auto run
fork=true
# Maxcontect
maxConns=100
# Not open Verify permissions
noauth=true
# open Verify permissions
# auth=true
# open log =&gt; true
journal=true
# clash
bind_ip=0.0.0.0

[imooc@imooc mongodb]$ sudo yum install net-snmp
 
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18(libmysqlclient_18)(64bit)
#错误：软件包：1:net-snmp-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
#错误：软件包：1:net-snmp-agent-libs-5.7.2-49.el7_9.4.x86_64 (updates)
          需要：libmysqlclient.so.18()(64bit)
# cd /usr/local/mongodb/
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 4989
child process started successfully, parent exiting

[imooc@imooc mongodb]$ ps aux | grep mongod
imooc      4989  1.8  4.2 1550916 78280 ?       Sl   20:39   0:00 mongod -f mongodb.conf
imooc      5105  0.0  0.0 112824   988 pts/0    S+   20:40   0:00 grep --color=auto mongod

[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:02 mongod -f mongodb.conf
imooc      5201   2948  0 20:44 pts/0    00:00:00 grep --color=auto mongodb


尝试连接到 MongoDB 实例： 
[imooc@imooc mongodb]$ mongo --port 27017
</code></pre>
<h3 id="可视化管理工具【MongoDB】"><a href="#可视化管理工具【MongoDB】" class="headerlink" title="可视化管理工具【MongoDB】"></a>可视化管理工具【MongoDB】</h3><pre><code class="mysql">在Navicat里新建链接MongoDB
主机：192.168.170.135
右键新建数据库school → 集合 → 右键新建 左上角保存student
[imooc@imooc mongodb]$ vim mongodb.conf
##### 启用用户账号权限
# Not open Verify permissions
# noauth=true
# open Verify permissions
  auth=true
#重启服务
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      4989      1  0 20:39 ?        00:00:05 mongod -f mongodb.conf
imooc      5380   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ kill -2 4989
[imooc@imooc mongodb]$ ps -ef|grep mongodb
imooc      5395   2948  0 20:54 pts/0    00:00:00 grep --color=auto mongodb
[imooc@imooc mongodb]$ mongod -f mongodb.conf
about to fork child process, waiting until server is ready for connections.
forked process: 5419
child process started successfully, parent exiting

[imooc@imooc mongodb]$ mongo
MongoDB shell version v4.2.8
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session &#123; &quot;id&quot; : UUID(&quot;c87ffbd9-69cd-4e29-badd-5b86a314f428&quot;) &#125;
MongoDB server version: 4.2.8
&gt; use admin
switched to db admin
&gt; db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;root&quot;]&#125;)
Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] &#125;
&gt; db.auth(&quot;root&quot;,&quot;root&quot;)
1
&gt; show users
&#123;
    &quot;_id&quot; : &quot;admin.root&quot;,
    &quot;userId&quot; : UUID(&quot;2ced1f0a-8de4-4fab-9cb8-8e420fe9dcba&quot;),
    &quot;user&quot; : &quot;root&quot;,
    &quot;db&quot; : &quot;admin&quot;,
    &quot;roles&quot; : [
        &#123;
            &quot;role&quot; : &quot;root&quot;,
            &quot;db&quot; : &quot;admin&quot;
        &#125;
    ],
    &quot;mechanisms&quot; : [
        &quot;SCRAM-SHA-1&quot;,
        &quot;SCRAM-SHA-256&quot;
    ]
&#125;
&gt; 
#后面关闭连接 编辑数据库 新增密码登录 root root
</code></pre>
<h3 id="整合SpringBoot-【GridFS】"><a href="#整合SpringBoot-【GridFS】" class="headerlink" title="整合SpringBoot 【GridFS】"></a>整合SpringBoot 【GridFS】</h3><pre><code class="xml">&lt;!-- 引入 mongodb 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的
    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="yaml">service-files  application.yml
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<h3 id="实现人脸入库-【GridFS】"><a href="#实现人脸入库-【GridFS】" class="headerlink" title="实现人脸入库 【GridFS】"></a>实现人脸入库 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java

...
 @Autowired
    private GridFSBucket gridFSBucket;
...

 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;

http://admin.imoocnews.com:9090/imooc-news/admin/adminMng.html
注册并且提交人脸信息
去Navicat → MongoDB → imooc-news → GridFS存储桶 → fs → admin456.png
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploadController.java
...
    @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO) throws Exception &#123;
        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();
        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());
        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);
        //上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);
        // 获取文件在gridfs中的主键id
        String fileIdStr = fileId.toString();
        // 下次提交的时候会提交到后端
        return GraceJSONResult.ok(fileIdStr);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploadControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploadControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/GridFSConfig.java
package com.imooc.files;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="查看admin人脸信息-【GridFS】"><a href="#查看admin人脸信息-【GridFS】" class="headerlink" title="查看admin人脸信息 【GridFS】"></a>查看admin人脸信息 【GridFS】</h3><pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
 @Override
    public GraceJSONResult uploadToGridFS(NewAdminBO newAdminBO)
            throws Exception &#123;

        // 获得图片的base64字符串
        String file64 = newAdminBO.getImg64();

        // 将base64字符串转换为byte数组
        byte[] bytes = new BASE64Decoder().decodeBuffer(file64.trim());

        // 转换为输入流
        ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);

        // 上传到gridfs中
        ObjectId fileId = gridFSBucket.uploadFromStream(newAdminBO.getUsername() + &quot;.png&quot;, inputStream);

        // 获得文件在gridfs中的主键id
        String fileIdStr = fileId.toString();

        return GraceJSONResult.ok(fileIdStr);
    &#125;

    @Override
    public void readInGridFS(String faceId,
                             HttpServletRequest request,
                             HttpServletResponse response) throws Exception &#123;

        // 0. 判断参数
        if (StringUtils.isBlank(faceId) || faceId.equalsIgnoreCase(&quot;null&quot;)) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        // 1. 从gridfs中读取
        File adminFace = readGridFSByFaceId(faceId);

        // 2. 把人脸图片输出到浏览器
        FileUtils.downloadFileByStream(response, adminFace);
    &#125;

    private File readGridFSByFaceId(String faceId) throws Exception &#123;

        GridFSFindIterable gridFSFiles
                = gridFSBucket.find(Filters.eq(&quot;_id&quot;, new ObjectId(faceId)));

        GridFSFile gridFS = gridFSFiles.first();

        if (gridFS == null) &#123;
            GraceException.display(ResponseStatusEnum.FILE_NOT_EXIST_ERROR);
        &#125;

        String fileName = gridFS.getFilename();
        System.out.println(fileName);

        // 获取文件流，保存文件到本地或者服务器的临时目录
        File fileTemp = new File(&quot;/workspace/temp_face&quot;);
        if (!fileTemp.exists()) &#123;
            fileTemp.mkdirs();
        &#125;

        File myFile = new File(&quot;/workspace/temp_face/&quot; + fileName);

        // 创建文件输出流
        OutputStream os = new FileOutputStream(myFile);
        // 下载到服务器或者本地
        gridFSBucket.downloadToStream(new ObjectId(faceId), os);

        return myFile;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;

//AdminCookieToken也可以获得faceId
</code></pre>
<h3 id="阿里AI人脸识别介绍"><a href="#阿里AI人脸识别介绍" class="headerlink" title="阿里AI人脸识别介绍"></a>阿里AI人脸识别介绍</h3><p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/facebody?spm=5176.21213303.J_qCOwPWspKEuWcmp8qiZNQ.20.f1892f3dvI78tU&scm=20140722.S_card@@%E5%95%86%E5%93%81@@143873.S_card0.ID_card@@%E5%95%86%E5%93%81@@143873-RL_%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-LOC_search~UND~card~UND~item-OR_ser-V_3-RE_cardOld-P0_0">人脸人体-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.console.aliyun.com/cn-shanghai/detail/facebody?spm=5176.6660585.viapi_facebody_public_cn-top.i0.7bbf7992dXgogs">视觉智能开放平台-控制台 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://vision.aliyun.com/experience/detail?tagName=facebody&children=CompareFace">能力展示-阿里云视觉智能开放平台 (aliyun.com)</a></p>
<h3 id="获得人脸faceId【人脸登录】"><a href="#获得人脸faceId【人脸登录】" class="headerlink" title="获得人脸faceId【人脸登录】"></a>获得人脸faceId【人脸登录】</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/AdminMngControllerApi.java
@ApiOperation(value = &quot;admin管理员的人脸登录&quot;, notes = &quot;admin管理员的人脸登录&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/adminFaceLogin&quot;)
    public GraceJSONResult adminFaceLogin(@RequestBody AdminLoginBO adminLoginBO,
                                          HttpServletRequest request,
                                          HttpServletResponse response);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
 @Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据

        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;


import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewAdminBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;hello方法的接口&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    //不可以通过swagger2调用的

    /**
     * 文件上传到mongodb的gridfs中
     * @param newAdminBO
     * @return
     * @throws Exception
     */
    @PostMapping(&quot;/uploadToGridFS&quot;)
    public GraceJSONResult uploadToGridFS(@RequestBody NewAdminBO newAdminBO) throws Exception;

    @GetMapping(&quot;/readInGridFS&quot;)
    public void readInGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;

    /**
     * 从gridfs中读取图片内容 返回base64数据
     * @param faceId
     * @param request
     * @param response
     * @return
     * @throws Exception
     */
    @GetMapping(&quot;/readFace64InGridFS&quot;)
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception;
&#125;
</code></pre>
<pre><code class="java">service-files  com/imooc/files/controller/FileUploaderController.java
@Override
    public GraceJSONResult readFace64InGridFS(String faceId, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        // 0. 获得gridfs中人脸文件
        File myface = readGridFSByFaceId(faceId);

        // 1. 转换人脸为base64
        String base64Face = FileUtils.fileToBase64(myface);
        return GraceJSONResult.ok(base64Face);
    &#125;
</code></pre>
<h3 id="整合RestTemplate服务通信-【人脸登录】"><a href="#整合RestTemplate服务通信-【人脸登录】" class="headerlink" title="整合RestTemplate服务通信 【人脸登录】"></a>整合RestTemplate服务通信 【人脸登录】</h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@RestController
public class AdminMngController extends BaseController implements AdminMngControllerApi &#123;

@Autowired
    private RestTemplate restTemplate;

@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录

        // 4. admin登录后的数据设置，redis与cookie

        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下"><a href="#实现人脸对比进行登录【人脸对比】没买人脸识别服务-简单写了一下" class="headerlink" title="实现人脸对比进行登录【人脸对比】没买人脸识别服务,简单写了一下"></a>实现人脸对比进行登录【人脸对比】<del>没买人脸识别服务,简单写了一下</del></h3><pre><code class="java">service-admin  com/imooc/admin/controller/AdminMngController.java
@Override
    public GraceJSONResult adminFaceLogin(AdminLoginBO adminLoginBO, HttpServletRequest request, HttpServletResponse response) &#123;
        // 0. 判断用户名和人脸信息不能为空
        if(StringUtils.isBlank(adminLoginBO.getUsername()))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_USERNAME_NULL_ERROR);
        &#125;
        String tempFace64 = adminLoginBO.getImg64();
        if (StringUtils.isBlank(tempFace64))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 1. 从数据库中查询出faceId
        AdminUser admin = adminUserService.queryAdminByUsername(adminLoginBO.getUsername());
        String adminFaceId = admin.getFaceId();
        if (StringUtils.isBlank(adminFaceId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_NULL_ERROR);
        &#125;
        // 2. 请求文件服务，获得人懒数据的base64数据
        String fileServerUrlExecute = &quot;http://files.imoocnews.com:8004/fs/readFace64InGridFS?faceId=&quot; + adminFaceId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity = restTemplate.getForEntity(fileServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        String base64DB = (String)bodyResult.getData();
        // 3. 调用阿里ai进行人脸对比识别，判断可信度，从而实现人脸登录
        boolean result = faceVerifyUtils.faceVerify(FaceVerifyType.BASE64.type,
                tempFace64,
                base64DB,
                60);
        if (!result)&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ADMIN_FACE_LOGIN_ERROR);
        &#125;
        // 4. admin登录后的数据设置，redis与cookie
        doLoginSettings(admin,request,response);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/FaceVerifyUtils.java
package com.imooc.utils;

import com.aliyuncs.utils.Base64Helper;
import com.imooc.enums.FaceVerifyType;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.extend.AliyunResource;
import org.apache.tomcat.util.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;

@Component
public class FaceVerifyUtils &#123;

    final static Logger logger = LoggerFactory.getLogger(FaceVerifyUtils.class);

    @Autowired
    private AliyunResource aliyunResource;

    //网关地址
    private static final String gateway = &quot;https://dtplus-cn-shanghai.data.aliyuncs.com/face/verify&quot;;

    /*
     * 计算MD5+BASE64
     */
    public static String MD5Base64(String s) &#123;
        if (s == null)
            return null;
        String encodeStr = &quot;&quot;;
        byte[] utfBytes = s.getBytes();
        MessageDigest mdTemp;
        try &#123;
            mdTemp = MessageDigest.getInstance(&quot;MD5&quot;);
            mdTemp.update(utfBytes);
            byte[] md5Bytes = mdTemp.digest();
            Base64Helper b64Encoder = new Base64Helper();
            encodeStr = b64Encoder.encode(md5Bytes);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate MD5 : &quot; + e.getMessage());
        &#125;
        return encodeStr;
    &#125;

    /*
     * 计算 HMAC-SHA1
     */
    public static String HMACSha1(String data, String key) &#123;
        String result;
        try &#123;
            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), &quot;HmacSHA1&quot;);
            Mac mac = Mac.getInstance(&quot;HmacSHA1&quot;);
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(data.getBytes());
            result = (new Base64Helper()).encode(rawHmac);
        &#125; catch (Exception e) &#123;
            throw new Error(&quot;Failed to generate HMAC : &quot; + e.getMessage());
        &#125;
        return result;
    &#125;

    /*
     * 等同于javaScript中的 new Date().toUTCString();
     */
    public static String toGMTString(Date date) &#123;
        SimpleDateFormat df = new SimpleDateFormat(&quot;E, dd MMM yyyy HH:mm:ss z&quot;, Locale.UK);
        df.setTimeZone(new SimpleTimeZone(0, &quot;GMT&quot;));
        return df.format(date);
    &#125;

    /**
     * 发送POST请求 进行两张图的人脸对比
     * @param type
     *          0: 通过url识别，参数image_url不为空；1: 通过图片content识别，参数content不为空
     * @param face1
     *          type为0，则传入图片url，为1则传入base64
     * @param face2
     *          type为0，则传入图片url，为1则传入base64
     * @return
     */
    //如果发送的是转换为base64编码后后面加请求参数type为1，如果请求的是图片的url则不用加type参数。
    public String sendPostVerifyFace(int type, String face1, String face2) throws Exception &#123;
        String body = &quot;&quot;;
        if (type == FaceVerifyType.BASE64.type) &#123;
            body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else if (type == FaceVerifyType.IMAGE_URL.type) &#123;
            body = &quot;&#123;\&quot;image_url_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;image_url_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + type + &quot;\&quot;&#125;&quot;;
        &#125; else &#123;
            GraceException.display(ResponseStatusEnum.FACE_VERIFY_TYPE_ERROR);
        &#125;
//        String body = &quot;&#123;\&quot;content_1\&quot;: \&quot;&quot; + face1 + &quot;\&quot;, \&quot;content_2\&quot;:\&quot;&quot; + face2 + &quot;\&quot;, \&quot;type\&quot;:\&quot;&quot; + &quot;1&quot; + &quot;\&quot;&#125;&quot;;
        PrintWriter out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        int statusCode = 200;
        try &#123;
            URL realUrl = new URL(gateway);
            /*
             * http header 参数
             */
            String method = &quot;POST&quot;;
            // 返回值类型
            String accept = &quot;application/json&quot;;
            // 请求内容类型
            String content_type = &quot;application/json&quot;;
            String path = realUrl.getFile();
            // GMT时间
            String date = toGMTString(new Date());
            // 1.对body做MD5+BASE64加密
            String bodyMd5 = MD5Base64(body);
            String stringToSign = method + &quot;\n&quot; + accept + &quot;\n&quot; + bodyMd5 + &quot;\n&quot; + content_type + &quot;\n&quot; + date + &quot;\n&quot;
                    + path;
            // 2.计算 HMAC-SHA1
            String signature = HMACSha1(stringToSign, aliyunResource.getAccessKeySecret());
            // 3.得到 authorization header
            String authHeader = &quot;Dataplus &quot; + aliyunResource.getAccessKeyID() + &quot;:&quot; + signature;
            // 打开和URL之间的连接
            URLConnection conn = realUrl.openConnection();
            // 设置通用的请求属性
            conn.setRequestProperty(&quot;Accept&quot;, accept);
            conn.setRequestProperty(&quot;Content-type&quot;, content_type);
            conn.setRequestProperty(&quot;Date&quot;, date);
            // 认证信息
            conn.setRequestProperty(&quot;Authorization&quot;, authHeader);
            // 发送POST请求必须设置如下两行
            conn.setDoOutput(true);
            conn.setDoInput(true);
            // 获取URLConnection对象对应的输出流
            out = new PrintWriter(conn.getOutputStream());
            // 发送请求参数
            out.print(body);
            // flush输出流的缓冲
            out.flush();
            // 定义BufferedReader输入流来读取URL的响应
            statusCode = ((HttpURLConnection) conn).getResponseCode();
            if (statusCode != 200) &#123;
                in = new BufferedReader(new InputStreamReader(((HttpURLConnection) conn).getErrorStream()));
            &#125; else &#123;
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            &#125;
            String line;
            while ((line = in.readLine()) != null) &#123;
                result += line;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (out != null) &#123;
                    out.close();
                &#125;
                if (in != null) &#123;
                    in.close();
                &#125;
            &#125; catch (IOException ex) &#123;
                ex.printStackTrace();
            &#125;
        &#125;
        if (statusCode != 200) &#123;
            throw new IOException(&quot;\nHttp StatusCode: &quot; + statusCode + &quot;\nErrorMessage: &quot; + result);
        &#125;
        return result;
    &#125;

    /**
     *
     * @param type
     * @param face1
     * @param face2
     * @param targetConfidence
     *          目标可信度，自定义阈值
     * @return
     */
    public boolean faceVerify(int type, String face1, String face2, double targetConfidence) &#123;

        String response = null;
        try &#123;
            response = sendPostVerifyFace(type, face1, face2);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        Map&lt;String, String&gt; map = JsonUtils.jsonToPojo(response, Map.class);
        Object confidenceStr = map.get(&quot;confidence&quot;);
        Double responseConfidence = (Double)confidenceStr;

        logger.info(&quot;人脸对比结果：&#123;&#125;&quot;, responseConfidence);

//        System.out.println(response.toString());
//        System.out.println(map.toString());

        if (responseConfidence &gt; targetConfidence) &#123;
            return true;
        &#125; else &#123;
            return false;
        &#125;
    &#125;

    /**
     *
     * 将图片转换为Base64
     * 将base64编码字符串解码成img图片
     * @param imgUrl
     * @return
     */
    public String getImgBase64(String imgUrl)&#123;
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        try &#123;
            // 创建URL
            URL url = new URL(imgUrl);
            byte[] by = new byte[1024];
            // 创建链接
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(&quot;GET&quot;);
            conn.setConnectTimeout(5000);
            InputStream is = conn.getInputStream();
            // 将内容放到内存中
            int len = -1;
            while ((len = is.read(by)) != -1) &#123;
                data.write(by, 0, len);
            &#125;
            is.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        // 对字节数组Base64编码
        return Base64.encodeBase64String(data.toByteArray());
    &#125;

//    public static void main(String[] args) &#123;
//        String face3 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5MvvGAfnLXAAIHiv37wNk363.jpg&quot;;
//        String face4 = &quot;http://122.152.205.72:88/group1/M00/00/05/CpoxxF5Mv3yAH74mAACOiTd9pO4462.jpg&quot;;
//
//        boolean result = new FaceVerifyUtils().faceVerify(FaceVerifyType.IMAGE_URL.type, face3, face4, 60);
//
//        logger.info(&quot;人脸对比是否成功：&#123;&#125;&quot;, result);
//    &#125;
&#125;
</code></pre>
<h3 id="MongoDB使用场景-【分担数据库的大数据量】"><a href="#MongoDB使用场景-【分担数据库的大数据量】" class="headerlink" title="MongoDB使用场景 【分担数据库的大数据量】"></a>MongoDB使用场景 【分担数据库的大数据量】</h3><ul>
<li><strong>GridFS小文件存储</strong></li>
<li><strong>历史数据快照</strong> [买的东西涨价后 还是原来的价格] 【数据量大存入MongoDB】</li>
<li><strong>用户浏览记录</strong></li>
<li><strong>客服聊天记录</strong> [不是核心数据 可以剥离]</li>
</ul>
<h6 id="这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大"><a href="#这些不建议放在Redis里-因为Redis是存储在内存里的-内存很贵-成本很大" class="headerlink" title="这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]"></a>这些不建议放在Redis里 因为Redis是存储在内存里的 [内存很贵 成本很大]</h6><h3 id="友情连接保存与更新-【MongoDB】"><a href="#友情连接保存与更新-【MongoDB】" class="headerlink" title="友情连接保存与更新 【MongoDB】"></a>友情连接保存与更新 【MongoDB】</h3><h6 id="对连接的一些逻辑校验"><a href="#对连接的一些逻辑校验" class="headerlink" title="对连接的一些逻辑校验"></a>对连接的一些逻辑校验</h6><pre><code class="yaml">service-admin  application.yml 【加上mongodb配置】
  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
</code></pre>
<pre><code class="java">service-admin  Application 【注释exclude 把mongodb配置进来】
package com.imooc.admin;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication  //(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.admin.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p>dev-model  com&#x2F;imooc&#x2F;pojo&#x2F;bo&#x2F;SaveFriendLinkBO.java<br>package com.imooc.pojo.bo;</p>
<p>import com.imooc.validate.CheckUrl;</p>
<p>import javax.validation.constraints.NotBlank;<br>import javax.validation.constraints.NotNull;</p>
<p>public class SaveFriendLinkBO {<br>    private String id;<br>    @NotBlank(message &#x3D; “友情链接名不能为空”)<br>    private String linkName;<br>    @NotBlank(message &#x3D; “友情链接地址不能为空”)<br>    @CheckUrl 【ctrl+左键 显示↓ CheckUrl接口】<br>    @CheckName 【 &#x2F;&#x2F;不能有空格 不能为空 字符串长度要在6-12位】<br>    private String linkUrl;<br>    @NotNull(message &#x3D; “请选择保留或删除”)<br>    private Integer isDelete;<br>}Getter+Setter</p>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrl.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckUrl &#123;

    String message() default &quot;Url不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckName.java
package com.imooc.validate;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CheckUrlValidate.class)
public @interface CheckName &#123;

    String message() default &quot;Name不正确&quot;;
    Class&lt;?&gt;[] groups() default &#123;&#125;;
    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckUrlValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckUrlValidate implements ConstraintValidator&lt;CheckUrl, String&gt; &#123;

    @Override
    public boolean isValid(String url, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyUrl(url.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/validate/CheckNameValidate.java
package com.imooc.validate;

import com.imooc.utils.UrlUtil;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckNameValidate implements ConstraintValidator&lt;CheckName, String&gt; &#123;

    @Override
    public boolean isValid(String name, ConstraintValidatorContext context) &#123;
        return UrlUtil.verifyName(name.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/UrlUtil.java 【Url+Name校验标准】
package com.imooc.utils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class UrlUtil &#123;

    /**
     * 验证是否是URL
     * @param url
     * @return
     */
    public static boolean verifyUrl(String url)&#123;

        // URL验证规则
//        String regEx =&quot;[A-Za-z]+://[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_%&amp;\\?\\/.=]+&quot;;
        String regEx = &quot;^([hH][tT]&#123;2&#125;[pP]:/*|[hH][tT]&#123;2&#125;[pP][sS]:/*|[fF][tT][pP]:/*)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~\\/])+(\\?&#123;0,1&#125;(([A-Za-z0-9-~]+\\=&#123;0,1&#125;)([A-Za-z0-9-~]*)\\&amp;&#123;0,1&#125;)*)$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(regEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(url);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;

    &#125;
    //不能有空格 不能为空 字符串长度要在6-12位
    public static boolean verifyName(String name)&#123;
        // Name验证规则
        String nameEx = &quot;^[^\\s]&#123;6,12&#125;$&quot;;
        // 编译正则表达式
        Pattern pattern = Pattern.compile(nameEx);
        // 忽略大小写的写法
        // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(name);
        // 字符串是否与正则表达式相匹配
        boolean rs = matcher.matches();
        return rs;
    &#125;

    public static void main(String[] args) &#123;
        boolean res = verifyUrl(&quot;http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html&quot;);
        boolean nres = verifyName(&quot;Jerry&quot;);
        System.out.println(nres);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">dev-model  pom.xml
 &lt;!-- 引入 mongodb 依赖 --&gt; 【springboot整合mongodb】
        &lt;dependency&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt;
            &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h6 id="真正的友链保存接口"><a href="#真正的友链保存接口" class="headerlink" title="真正的友链保存接口"></a>真正的友链保存接口</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);


    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/mo/FriendLinkMO.java
//这些都是设置到MongoDB数据库的名字
//@Document(&quot;FriendLink&quot;) //MongoDB文件起别名
public class FriendLinkMO &#123;
    @Id //作为MongDB的主键了
    private String id;
    @Field(&quot;link_name&quot;)
    private String linkName;
    @Field(&quot;link_url&quot;)
    private String linkUrl;
    @Field(&quot;is_delete&quot;)
    private Integer isDelete;
    @Field(&quot;create_time&quot;)
    private Date createTime;
    @Field(&quot;update_time&quot;)
    private Date updateTime;
&#125;Getter + Setter
</code></pre>
<h3 id="Repository持久层操作保存记录"><a href="#Repository持久层操作保存记录" class="headerlink" title="Repository持久层操作保存记录"></a>Repository持久层操作保存记录</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
/* 友情连接 → 
链接名称：慕课网
链接地址：www.imooc.com
[新增/添加]

打开检查→Console
&#123;&quot;status&quot;:200,&quot;msg&quot;:&quot;操作成功！&quot;,&quot;success&quot;:true,&quot;data&quot;:null&#125;

打开数据库查看MongoDB→friendLinkMO有存入的数据即操作成功
*/
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
package com.imooc.admin.repository;

import com.imooc.pojo.mo.FriendLinkMO;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
&#125;
</code></pre>
<h3 id="友情链接查询列表-【MongoDB】"><a href="#友情链接查询列表-【MongoDB】" class="headerlink" title="友情链接查询列表 【MongoDB】"></a>友情链接查询列表 【MongoDB】</h3><h6 id="Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面"><a href="#Document-“FriendLink”-x2F-x2F-文件起别名-记得要在MongoDB里面找这个-下面搜索的都在这个文件里面" class="headerlink" title="@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面"></a>@Document(“FriendLink”) &#x2F;&#x2F;文件起别名 记得要在MongoDB里面找这个 下面搜索的都在这个文件里面</h6><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.AdminLoginBO;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
package com.imooc.admin.controller;

import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.FriendLinkControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveFriendLinkBO;
import com.imooc.pojo.mo.FriendLinkMO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.Map;

@RestController
public class FriendLinkController extends BaseController implements FriendLinkControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(FriendLinkController.class);
    @Autowired
    private FriendLinkService friendLinkService;

    @Override
    public GraceJSONResult saveOrUpdateFriendLink(SaveFriendLinkBO saveFriendLinkBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
            Map&lt;String, String&gt; map = getErrors(result);
            return GraceJSONResult.errorMap(map);
        &#125;

//      saveFriendLinkBO -&gt; ***Mo  MongoDB校验的对象
        FriendLinkMO friendLinkMO = new FriendLinkMO();
        BeanUtils.copyProperties(saveFriendLinkBO,friendLinkMO);
        friendLinkMO.setCreateTime(new Date());
        friendLinkMO.setUpdateTime(new Date());

        friendLinkService.saveOrUpdateFriendLink(friendLinkMO);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getFriendLinkList() &#123; 
//【用了FriendLinkRepository里面的】extends MongoRepository 中的简单增删改查 
// 里面的删除是逻辑删除
        return GraceJSONResult.ok(friendLinkService.queryAllFriendLinkList());
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/friendLinks.html
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
package com.imooc.admin.service;

import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public interface FriendLinkService &#123;
    /**
     * 新增或者更新友情链接
     */
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO);

    /**
     * 查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList();

&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/FriendLinkServiceImpl.java
package com.imooc.admin.service.impl;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.imooc.admin.mapper.AdminUserMapper;
import com.imooc.admin.repository.FriendLinkRepository;
import com.imooc.admin.service.AdminUserService;
import com.imooc.admin.service.FriendLinkService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AdminUser;
import com.imooc.pojo.bo.NewAdminBO;
import com.imooc.pojo.mo.FriendLinkMO;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Service;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class FriendLinkServiceImpl implements FriendLinkService &#123;

    @Autowired
    private FriendLinkRepository friendLinkRepository;
    @Override
    public void saveOrUpdateFriendLink(FriendLinkMO friendLinkMO) &#123;
        friendLinkRepository.save(friendLinkMO); //有id更新 无id直接保存
    &#125;

    @Override
    public List&lt;FriendLinkMO&gt; queryAllFriendLinkList() &#123;
//        Pageable pageable = PageRequest.of(1,10);
//        friendLinkRepository.findAll(pageable);
        return friendLinkRepository.findAll();
    &#125;
&#125;
</code></pre>
<h3 id="友情链接删除-【MongoDB】-增加真实删除"><a href="#友情链接删除-【MongoDB】-增加真实删除" class="headerlink" title="友情链接删除 【MongoDB】[增加真实删除]"></a>友情链接删除 【MongoDB】[增加真实删除]</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
...
/*
@Api(value = &quot;首页友情连接维护&quot;, tags = &#123;&quot;首页友情连接维护&quot;&#125;)
@RequestMapping(&quot;friendLinkMng&quot;)
public interface FriendLinkControllerApi &#123;

    @ApiOperation(value = &quot;新增或者修改友情连接&quot;, notes = &quot;新增或者修改友情连接&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/saveOrUpdateFriendLink&quot;)
    public GraceJSONResult saveOrUpdateFriendLink(@RequestBody SaveFriendLinkBO saveFriendLinkBO,
                                      BindingResult result);
    @ApiOperation(value = &quot;查询改友情连接列表&quot;, notes = &quot;查询改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getFriendLinkList&quot;)
    public GraceJSONResult getFriendLinkList();
*/
    @ApiOperation(value = &quot;删除改友情连接列表&quot;, notes = &quot;删除改友情连接列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/delete&quot;)
    public GraceJSONResult delete(@RequestParam String linkId);
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
@Override
    public GraceJSONResult delete(String linkId) &#123;
        friendLinkService.delete(linkId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 删除友情链接
     */
    public void delete(String linkId);
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/AdminUserService.java
@Override
    public void delete(String linkId) &#123;
        friendLinkRepository.deleteById(linkId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 【增加友链拦截器】
/*
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;);
        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
*/
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表"><a href="#【作业】文章分类管理-新增或修改分类、查询分类列表、用户端查询分类列表" class="headerlink" title="【作业】文章分类管理 [新增或修改分类、查询分类列表、用户端查询分类列表]"></a>【作业】文章分类管理 <del>[新增或修改分类、查询分类列表、用户端查询分类列表]</del></h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/80972817">@RequestBody的使用-CSDN博客</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
package com.imooc.admin.controller;

import com.imooc.admin.service.CategoryService;
import com.imooc.api.BaseController;
import com.imooc.api.controller.admin.CategoryMngControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import com.imooc.utils.JsonUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
public class CategoryMngController extends BaseController implements CategoryMngControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(CategoryMngController.class);

    @Autowired
    private CategoryService categoryService;

    @Override
    public GraceJSONResult saveOrUpdateCategory(SaveCatrgoryBO saveCatrgoryBO, BindingResult result) &#123;
        if (result.hasErrors())&#123;
        // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;
        Category newCat = new Category();
        BeanUtils.copyProperties(saveCatrgoryBO,newCat);
        // id为空新增，不为空修改
        if (saveCatrgoryBO.getId() == null)&#123;
            //查询新增的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), null);
            if (!isExist)&#123;
                //新增到数据库
                categoryService.createCategory(newCat);
            &#125;else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;else &#123;
            //查询修改的分类名称不能重复存在
            boolean isExist = categoryService.queryCatIsExist(newCat.getName(), saveCatrgoryBO.getOldName());
            if (!isExist)&#123;
                //修改到数据库
                categoryService.modifyCategory(newCat);
            &#125; else &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.CATEGORY_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult getCatList() &#123;
        List&lt;Category&gt; categoryList = categoryService.queryCategoryList();
        return GraceJSONResult.ok(categoryList);
    &#125;

    @Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/CategoryService.java
package com.imooc.admin.service;

import com.imooc.pojo.Category;
import java.util.List;

public interface CategoryService &#123;

    /**
     * 新增文章分类
     */
    public void createCategory(Category category);

    /**
     * 修改文章分类列表
     */
    public void modifyCategory(Category category);

    /**
     * 查询分类名是否已经存在
     */
    public boolean queryCatIsExist(String catName, String oldCatName);

    /**
     * 获得文章分类列表
     */
    public List&lt;Category&gt; queryCategoryList();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
package com.imooc.admin.service.impl;

import com.imooc.admin.mapper.CategoryMapper;
import com.imooc.admin.service.CategoryService;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Category;
import com.imooc.utils.RedisOperator;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;
    @Autowired
    public RedisOperator redis;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;

    @Override
    public boolean queryCatIsExist(String catName, String oldCatName) &#123;
        Example example = new Example(Category.class);
        Example.Criteria catCriteria = example.createCriteria();
        catCriteria.andEqualTo(&quot;name&quot;, catName);
        if (StringUtils.isNotBlank(oldCatName)) &#123;
            catCriteria.andNotEqualTo(&quot;name&quot;, oldCatName);
        &#125;

        List&lt;Category&gt; catList = categoryMapper.selectByExample(example);

        boolean isExist = false;
        if (catList != null &amp;&amp; !catList.isEmpty() &amp;&amp; catList.size() &gt; 0) &#123;
            isExist = true;
        &#125;

        return isExist;
    &#125;

    @Override
    public List&lt;Category&gt; queryCategoryList() &#123;
        return categoryMapper.selectAll();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/mapper/CategoryMapper.java
package com.imooc.admin.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Category;
import org.springframework.stereotype.Repository;

@Repository
public interface CategoryMapper extends MyMapper&lt;Category&gt; &#123;
&#125;
</code></pre>
<pre><code class="xml">service-admin  resources/mapper/CategoryMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.admin.mapper.CategoryMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Category&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;tag_color&quot; property=&quot;tagColor&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
    @Autowired
    public RedisOperator redis;
    public static final String MOBILE_SMSCODE = &quot;mobile:smscode&quot;;
    public static final String REDIS_USER_TOKEN = &quot;redis_user_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_USER_INFO = &quot;redis_user_info&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ADMIN_TOKEN = &quot;redis_admin_token&quot;;//ctrl+shift+u直接大写
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_READ_COUNTS = &quot;redis_article_read_counts&quot;;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Value(&quot;$&#123;website.domain-name&#125;&quot;)
    public String DOMAIN_NAME;
    public static final Integer COOKIE_MONTH = 30 * 24 * 60 * 60;
    public static final Integer COOKIE_DELETE = 0;

    public static final Integer COMMON_START_PAGE = 1;
    public static final Integer COMMON_PAGE_SIZE = 10;
&#125;...
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Category.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;

public class Category &#123;
    @Id
    private Integer id;

    /**
     * 分类名，比如：科技，人文，历史，汽车等等
     */
    private String name;

    /**
     * 标签颜色
     */
    @Column(name = &quot;tag_color&quot;)
    private String tagColor;
&#125;Getter + Setter
</code></pre>
<h3 id="查询用户列表-设置时间日期转换配置-【用户管理】"><a href="#查询用户列表-设置时间日期转换配置-【用户管理】" class="headerlink" title="查询用户列表_设置时间日期转换配置 【用户管理】"></a>查询用户列表_设置时间日期转换配置 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.AppUserMngControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
// 字符串无法直接转换成Date类型 需要工具类转换 DateConverterConfig com/imooc/api/config/DateConverterConfig.java

    @Override
    public GraceJSONResult queryAll(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        System.out.println(startDate);
        System.out.println(endDate);
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok();
    &#125;
&#125;
// http://admin.imoocnews.com:9090/imooc-news/admin/userList.html
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/DateConverterConfig.java
package com.imooc.api.config;


import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * 请求路径url中的参数进行时间日期类型的转换，字符串-&gt;日期Date
 */
@Configuration
public class DateConverterConfig implements Converter&lt;String, Date&gt; &#123;

    private static final List&lt;String&gt; formatterList = new ArrayList&lt;&gt;(4);
    static&#123;
        formatterList.add(&quot;yyyy-MM&quot;);
        formatterList.add(&quot;yyyy-MM-dd&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm&quot;);
        formatterList.add(&quot;yyyy-MM-dd hh:mm:ss&quot;);
    &#125;

    @Override
    public Date convert(String source) &#123;
        String value = source.trim();
        if (&quot;&quot;.equals(value)) &#123;
            return null;
        &#125;
        if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(0));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(1));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(2));
        &#125;else if(source.matches(&quot;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$&quot;))&#123;
            return parseDate(source, formatterList.get(3));
        &#125;else &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_DATE_PARSER_ERROR);
        &#125;
        return null;
    &#125;

    /**
     * 日期转换方法
     * @param dateStr
     * @param formatter
     * @return
     */
    public Date parseDate(String dateStr, String formatter) &#123;
        Date date=null;
        try &#123;
            DateFormat dateFormat = new SimpleDateFormat(formatter);
            date = dateFormat.parse(dateStr);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return date;
    &#125;
&#125;
</code></pre>
<h3 id="查询用户列表-实现service与联调-【用户管理】"><a href="#查询用户列表-实现service与联调-【用户管理】" class="headerlink" title="查询用户列表_实现service与联调 【用户管理】"></a>查询用户列表_实现service与联调 【用户管理】</h3><pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     * @param nickname
     * @param status
     * @param startDate
     * @param endDate
     * @param page
     * @param pageSize
     * @return
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;

import java.util.List;

public class BaseService &#123;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.Sex;
import com.imooc.enums.UserStatus;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.UserService;
import com.imooc.utils.*;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class AppUserMngServiceImpl extends BaseService implements AppUserMngService &#123;
    @Autowired
    public AppUserMapper appUserMapper;

    @Override
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(AppUser.class);
        example.orderBy(&quot;createdTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        if (StringUtils.isNotBlank(nickname)) &#123;
            criteria.andLike(&quot;nickname&quot;, &quot;%&quot; + nickname + &quot;%&quot;);
        &#125;
        if (UserStatus.isUserStatusValid(status))&#123;
            criteria.andEqualTo(&quot;activeStatus&quot;, status); //对比状态
        &#125;
        if (startDate != null)&#123;
            criteria.andGreaterThanOrEqualTo(&quot;createdTime&quot;, startDate);//数据库和传入参数对比
        &#125;
        if (endDate != null)&#123;
            criteria.andLessThanOrEqualTo(&quot;endTime&quot;, endDate);//数据库和传入参数对比
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;AppUser&gt; list = appUserMapper.selectByExample(example);

        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="查询用户账户-冻结与解封-【用户管理】"><a href="#查询用户账户-冻结与解封-【用户管理】" class="headerlink" title="查询用户账户_冻结与解封 【用户管理】"></a>查询用户账户_冻结与解封 【用户管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/AppUserMngControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Date;

@Api(value = &quot;用户管理相关的接口定义&quot;,tags = &#123;&quot;用户管理相关功能的controller&quot;&#125;)
@RequestMapping(&quot;appUser&quot;)
public interface AppUserMngControllerApi &#123;
    @ApiOperation(value = &quot;查询所有网站用户&quot;,notes = &quot;查询所有网站用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;queryAll&quot;)
    public GraceJSONResult queryAll(@RequestParam String nickname,
                                    @RequestParam Integer status,
                                    @RequestParam Date startDate,
                                    @RequestParam Date endDate,
                                    @RequestParam Integer page,
                                    @RequestParam Integer pageSize);

    @ApiOperation(value = &quot;查看用户详情&quot;,notes = &quot;查看用户详情&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;userDetail&quot;)
    public GraceJSONResult userDetail(@RequestParam String userId);

    @ApiOperation(value = &quot;冻结用户或者解冻用户&quot;,notes = &quot;冻结用户或者解冻用户&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;freezeUserOrNot&quot;)
    public GraceJSONResult freezeUserOrNot(@RequestParam String userId,@RequestParam Integer doStatus);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/AppUserMngController.java
@RestController
public class AppUserMngController extends BaseController implements AppUserMngControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(AppUserMngController.class);
    
    @Autowired
    private AppUserMngService appUserMngService;
    @Autowired
    private UserService userService;
......
    
     @Override
    public GraceJSONResult freezeUserOrNot(String userId, Integer doStatus) &#123;
        if (!UserStatus.isUserStatusValid(doStatus))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_STATUS_ERROR);
        &#125;
        appUserMngService.freezeUserOrNot(userId, doStatus);
        //若冻结后 用户处于登录状态 还可以进行操作 所以要刷新用户状态
        //方法①：删除用户会话，从而保证用户需要重新登陆以后再来刷新她的会话状态
        redis.del(REDIS_USER_INFO + &quot;:&quot; + userId);
        //方法②：查询最新用户的信息，重新放入redis中，做一次更新
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/AppUserMngService.java
package com.imooc.user.service;

import com.imooc.pojo.AppUser;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface AppUserMngService &#123;
    /**
     * 查询管理员列表
     */
    public PagedGridResult queryAllUserList(String nickname, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 冻结用户账号或者解除冻结
     */
    public void freezeUserOrNot(String userId, Integer doStatus);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/AppUserMngServiceImpl.java
    @Transactional
    @Override
    public void freezeUserOrNot(String userId, Integer doStatus) &#123;
        AppUser user = new AppUser();
        user.setId(userId);
        user.setActiveStatus(doStatus);
        appUserMapper.updateByPrimaryKeySelective(user);
    &#125;
</code></pre>
<h3 id="梳理文章article表结构-【文章服务】"><a href="#梳理文章article表结构-【文章服务】" class="headerlink" title="梳理文章article表结构 【文章服务】"></a>梳理文章article表结构 【文章服务】</h3><ul>
<li><strong>构建文章服务</strong></li>
<li><strong>作者中心发表文章</strong></li>
<li><strong>作者中心内容管理</strong></li>
<li><strong>自动审核<del>[阿里客户端]</del>，手动审核</strong></li>
</ul>
<h3 id="构建文章服务工程-【文章服务】"><a href="#构建文章服务工程-【文章服务】" class="headerlink" title="构建文章服务工程 【文章服务】"></a>构建文章服务工程 【文章服务】</h3><blockquote>
<p>新创建一个Module<br>GroupId：com.imooc<br>ArtifactId：imooc-news-dev-service-article<br>pom参考service-admin移植  resources里的所有文件(除mapper)也要移植</p>
</blockquote>
<pre><code class="xml">service-article  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;imooc-news-dev-service-article&lt;/artifactId&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">resources logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-article&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-article&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/service-article.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;

========================================================================
http://localhost:8001/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">service-article  application-dev
server:
  port: 8001

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
## setup CN from java, This is resource
website:
  domain-name: imoocnews.com

## open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<pre><code class="yaml">############################################################
#
# admin用户微服务
# web访问端口号  约定：8001
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article
  datasource: # 数据源的相关配置
    type: com.zaxxer.hikari.HikariDataSource          # 数据源类型：HikariCP
    driver-class-name: org.mariadb.jdbc.Driver       # mysql驱动
    url: jdbc:mysql://localhost:3306/imooc-news-dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;sessionVariables=tx_isolation=&#39;READ-COMMITTED&#39;
    username: root
    password: root
    hikari:
      connection-timeout: 30000       # 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 默认:30秒
      minimum-idle: 5                 # 最小连接数
      maximum-pool-size: 20           # 最大连接数
      auto-commit: true               # 自动提交
      idle-timeout: 600000            # 连接超时的最大时长（毫秒），超时则被释放（retired），默认:10分钟
      pool-name: DateSourceHikariCP     # 连接池名字
      max-lifetime: 1800000           # 连接的生命时长（毫秒），超时而且没被使用则被释放（retired），默认:30分钟 1800000ms
      connection-test-query: SELECT 1
      data-source-properties:
        tx_isolation: &#39;READ-COMMITTED&#39;
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
############################################################
#
# mybatis 配置
#
############################################################
mybatis:
  type-aliases-package: com.imooc.pojo          # 所有POJO类所在包路径
  mapper-locations: classpath:mapper/*.xml      # mapper映射文件

############################################################
#
# mybatis mapper 配置
#
############################################################
# 通用 Mapper 配置
mapper:
  mappers: com.imooc.my.mapper.MyMapper
  not-empty: false    # 在进行数据库操作的的时候，判断表达式 username != null, 是否追加 username != &#39;&#39;
  identity: MYSQL
# 分页插件配置
pagehelper:
  helperDialect: mysql
  supportMethodsArguments: true
</code></pre>
<h3 id="summernote与多文件上传需求-【发头条】"><a href="#summernote与多文件上传需求-【发头条】" class="headerlink" title="summernote与多文件上传需求 【发头条】"></a>summernote与多文件上传需求 【发头条】</h3><p><a target="_blank" rel="noopener" href="https://summernote.org/">https://summernote.org/</a></p>
<pre><code class="html">【前端工程里面的】createArticle.html
...
&lt;script src=&quot;libs/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/axios.min.js&quot;&gt;&lt;/script&gt;

&lt;link href=&quot;./libs/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;libs/layDate-v5.0.9/laydate/laydate.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./libs/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;./libs/summernote/dist/summernote.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;script src=&quot;./libs/summernote/dist/summernote.js&quot;&gt;&lt;/script&gt;
&lt;!-- 中文汉化 --&gt;
&lt;script src=&quot;libs/summernote/lang/summernote-zh-CN.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

......
&lt;!-- 富文本编辑器 --&gt;
        &lt;div id=&quot;editor2&quot; class=&quot;editor-container&quot;&gt;

            &lt;div class=&quot;article-title-wrapper&quot;&gt;
                &lt;input id=&quot;title&quot; class=&quot;article-title&quot; placeholder=&quot;请输入文字标题（6-30长度）&quot; v-model=&quot;articleTitle&quot; maxlength=&quot;30&quot;/&gt;
            &lt;/div&gt;

            &lt;div class=&quot;article-content-wrapper&quot;&gt;
                &lt;div id=&quot;summernote&quot; class=&quot;summernote&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;other-info&quot;&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章领域&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;!-- &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option value=&quot;0&quot;&gt;请选择&lt;/option&gt;
                            &lt;option value=&quot;1&quot;&gt;汽车&lt;/option&gt;
                            &lt;option value=&quot;2&quot;&gt;科技&lt;/option&gt;
                            &lt;option value=&quot;3&quot;&gt;历史&lt;/option&gt;
                        &lt;/select&gt; --&gt;

                        &lt;select v-model=&quot;articleCategory&quot;&gt;
                            &lt;option :value=&quot;cat.id&quot; v-for=&quot;(cat, index) in catList&quot; v-key=&quot;index&quot;&gt;&#123;&#123;cat.name&#125;&#125;&lt;/option&gt;
                        &lt;/select&gt;
                        
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;文章封面&lt;/div&gt;
                    &lt;div class=&quot;choose-type&quot;&gt;
                        &lt;div&gt;&lt;input type=&quot;radio&quot; name=&quot;articleType&quot; v-model=&quot;articleType&quot; value=&quot;1&quot; checked/&gt;&lt;span class=&quot;choose-words&quot;&gt;单封面&lt;/span&gt;&lt;/div&gt;
                        &lt;div style=&quot;margin-left: 30px;&quot;&gt;&lt;input type=&quot;radio&quot; v-model=&quot;articleType&quot; value=&quot;2&quot; name=&quot;articleType&quot;/&gt;&lt;span class=&quot;choose-words&quot;&gt;无封面&lt;/span&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;cover-wrapper&quot; v-show=&quot;articleType==1&quot;&gt;
                    &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;choose-cover&quot;&gt;
                        &lt;div class=&quot;uploader-comp&quot;&gt;
                            &lt;div id=&quot;block-choose&quot; class=&quot;block-choose&quot; :style=&quot;coverStyle&quot;&gt;
                                &lt;img src=&quot;./img/icon-go-upload.png&quot; style=&quot;width: 20px; height: 20px; align-self: center;&quot; v-show=&quot;articleCover == &#39;&#39; || articleCover == null&quot;/&gt;
                            &lt;/div&gt;
                            &lt;input type=&quot;file&quot; @change=&quot;uploadCover&quot; @mouseover=&quot;mouseOver&quot; @mouseout=&quot;mouseOut&quot; id=&quot;inputPic&quot; class=&quot;inputPic&quot; accept=&quot;image/jpeg,image/jpg,image/png&quot;&gt;
                        &lt;/div&gt;
                        &lt;div style=&quot;margin-top: 10px; color: #9b9d9e;&quot;&gt;请上传JPG、JPEG、PNG格式的封面图噢~&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;publish-bottom&quot;&gt;
                &lt;div class=&quot;buttons&quot;&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;preview&quot;&gt;预览&lt;/button&gt;
                    &lt;!-- &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;save&quot;&gt;保存草稿&lt;/button&gt; --&gt;
                    &lt;!-- FIXME: 计算剩余时间，使用RMQ延时队列，或分布式定时任务 --&gt;
                    &lt;button class=&quot;white-btn&quot; type=&quot;button&quot; @click=&quot;doTiming&quot;&gt;&#123;&#123;appointWords&#125;&#125;&lt;/button&gt;
                    
                    &lt;input type=&quot;text&quot; class=&quot;timing-date-picker&quot; placeholder=&quot;定时日期&quot; id=&quot;choose-date&quot; v-show=&quot;isAppoint==1&quot; readonly&gt;

                    &lt;button class=&quot;red-btn&quot; type=&quot;button&quot; @click=&quot;publish&quot;&gt;发布文章&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

......
// 初始化编辑器
            $(&#39;#summernote&#39;).summernote(&#123;
                placeholder: &#39;请输入正文...&#39;,
                lang: &#39;zh-CN&#39;,
                height: 600,
                width: 800,
                border: 0,
                // disableDragAndDrop: true, // 禁止文件拖放
                toolbar: [
                    [&#39;style&#39;, [&#39;style&#39;]],
                    [&#39;font&#39;, [&#39;bold&#39;, &#39;underline&#39;, &#39;clear&#39;]],
                    [&#39;color&#39;, [&#39;color&#39;]],
                    [&#39;para&#39;, [&#39;ul&#39;, &#39;ol&#39;, &#39;paragraph&#39;]],
                    [&#39;table&#39;, [&#39;table&#39;]],
                    [&#39;insert&#39;, [&#39;link&#39;, &#39;picture&#39;]],
                    [&#39;view&#39;, [&#39;fullscreen&#39;, &#39;codeview&#39;, &#39;help&#39;]]
                ],
</code></pre>
<h3 id="实现多文件上传uploadSomeFiles-【发头条】"><a href="#实现多文件上传uploadSomeFiles-【发头条】" class="headerlink" title="实现多文件上传uploadSomeFiles 【发头条】"></a>实现多文件上传<del>uploadSomeFiles</del> 【发头条】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/files/FileUploaderControllerApi.java
package com.imooc.api.controller.files;

@Api(value = &quot;文件上传的controller&quot;,tags = &#123;&quot;xx功能的Controller&quot;&#125;)
@RequestMapping(&quot;fs&quot;)
public interface FileUploaderControllerApi &#123;
    /**
     * 上传单文件
     * @param userId
     * @param file
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadFace&quot;)
    public GraceJSONResult uploadFace(@RequestParam String userId, MultipartFile file) throws Exception;

    /**
     * 上传多文件
     * @param userId
     * @param files
     * @return
     * @throws Exception
     */
    @ApiOperation(value = &quot;上传用户头像&quot;,notes = &quot;上传用户头像&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/uploadSomeFiles&quot;)  //因为前端createArticle.html 178行 multiForm.append(&#39;files&#39;,f,f.name);
    public GraceJSONResult uploadSomeFiles(@RequestParam String userId, MultipartFile[] files) throws Exception;
......
&#125;
</code></pre>
<pre><code class="java">service-file  com/imooc/files/controller/FileUploaderController.java
......
@Override
    public GraceJSONResult uploadSomeFiles(String userId, MultipartFile[] files) throws Exception &#123;
        // 声明一个list，用于存放多个图片的地址路径，返回到前端
        List&lt;String&gt; imageUrlList = new ArrayList&lt;&gt;();
        if (files != null &amp;&amp; files.length &gt; 0)&#123;
            for (MultipartFile file: files)&#123;
                String path = &quot;&quot;;
                if (file != null)&#123;
                    // 获得文件上传的名称
                    String fileName = file.getOriginalFilename();
                    //判断文件名不能为空
                    if (StringUtils.isNotBlank(fileName))&#123;
                        String fileNameArr[] = fileName.split(&quot;\\.&quot;);
                        //获得后缀名
                        String suffix = fileNameArr[fileNameArr.length - 1];
                        //防止黑客上传文件攻击服务器 判断后缀符合我们的预定义规范
                        if (!suffix.equalsIgnoreCase(&quot;png&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpg&quot;) &amp;&amp;
                                !suffix.equalsIgnoreCase(&quot;jpeg&quot;)
                        )&#123;
                           continue;
                        &#125;
                        // fdfs执行上传     要让外面得以访问 ①需要把内网的环境发布到公网 [内网穿透]  ②路由器端口映射到外网  ③fastdfs安装到公网里
                        // path = uploaderService.uploadFdfs(file, suffix);
                        // OSS执行上传
                        path = uploaderService.uploadOSS(file, userId, suffix);
                    &#125;else &#123;
                        continue;
                    &#125;
                &#125;else &#123;
                    continue;
                &#125;
                String finalPath = &quot;&quot;;
                if (StringUtils.isNotBlank(path))&#123;
//            finalPath = fileResource.getHost() + path;
                    finalPath = fileResource.getOssHost() + path;
                    // FIXME: 放入到imageUrlList之前，需要对图片做一次审核 [doAliImageReview]
                    imageUrlList.add(finalPath);
                &#125;  else&#123;
                    continue;
                &#125;
//                return GraceJSONResult.ok(finalPath);
//        return GraceJSONResult.ok(doAliImageReview(finalPath)); //这里加了图片审核咯
            &#125;
        &#125;
        return GraceJSONResult.ok(imageUrlList);
    &#125;
......
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java 
package com.imooc.api.config;
//【增加拦截uploadSomeFiles】
@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="获得列表-业务接口解耦与Redis缓存应用-【文章领域】"><a href="#获得列表-业务接口解耦与Redis缓存应用-【文章领域】" class="headerlink" title="获得列表_业务接口解耦与Redis缓存应用 【文章领域】"></a>获得列表_业务接口解耦与Redis缓存应用 【文章领域】</h3><blockquote>
<p>getCatList 和 getCats 一个是用户端一个是admin 业务体系不一样 所以同样是查询分类列表<br>但是还是应该拆开 使耦合减少 得到高效解耦<br>查询放在Redis里面 效率变高</p>
<p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>刷新一下 文章领域就可以找到那些分类<br>Redis里面会有信息 redis_all_category<br>[{“id”:2,”name”:”汽车”,”tagColor”:”#8939bd”},{“id”:3,”name”:”娱乐”,”tagColor”:”#c939aa”},{“id”:5,”name”:”地理”,”tagColor”:”#57394a”},{“id”:6,”name”:”历史”,”tagColor”:”#29ab4a”},{“id”:7,”name”:”科技”,”tagColor”:”#2467bc”},{“id”:9,”name”:”体育”,”tagColor”:”#c98f4a”},{“id”:10,”name”:”搞笑”,”tagColor”:”#68b84a”},{“id”:11,”name”:”技术”,”tagColor”:”#c9394a”},{“id”:12,”name”:”慕课”,”tagColor”:”#682aa8”},{“id”:13,”name”:”技能”,”tagColor”:”#c9394a”},{“id”:14,”name”:”课网”,”tagColor”:”#c9a24a”}]</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/admin/CategoryMngControllerApi.java
// 【getCasts】
package com.imooc.api.controller.admin;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.SaveCatrgoryBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

@Api(value = &quot;文章分类维护&quot;, tags = &#123;&quot;文章分类维护controller&quot;&#125;)
@RequestMapping(&quot;categoryMng&quot;)
public interface CategoryMngControllerApi &#123;
    @PostMapping(&quot;saveOrUpdateCategory&quot;)
    @ApiOperation(value = &quot;新增或修改分类&quot;, notes = &quot;新增或修改分类&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult saveOrUpdateCategory(@RequestBody @Valid SaveCatrgoryBO saveCatrgoryBO,
                                                BindingResult result);
    @PostMapping(&quot;getCatList&quot;)
    @ApiOperation(value = &quot;查询分类列表&quot;, notes = &quot;查询分类列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult getCatList();

    @GetMapping(&quot;getCats&quot;)
    @ApiOperation(value = &quot;用户端查询分类列表&quot;, notes = &quot;用户端查询分类列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult getCats();
&#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/CategoryMngController.java
@Override
    public GraceJSONResult getCats() &#123;
        // 先从redis中查询，如果有，则返回，如果没有，则查询数据库库后先放缓存，放返回
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);

        List&lt;Category&gt; categoryList = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            categoryList = categoryService.queryCategoryList();
            redis.set(REDIS_ALL_CATEGORY, JsonUtils.objectToJson(categoryList));
        &#125; else &#123;
            categoryList = JsonUtils.jsonToList(allCatJson, Category.class);
        &#125;

        return GraceJSONResult.ok(categoryList);
    &#125;
</code></pre>
<h3 id="admin端维护数据缓存-【文章领域】"><a href="#admin端维护数据缓存-【文章领域】" class="headerlink" title="admin端维护数据缓存 【文章领域】"></a>admin端维护数据缓存 【文章领域】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/categoryMng.html">文章分类 | 运营管理平台 (imoocnews.com)</a><br>在管理员修改文章类型后 【课网 → 课课】<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html">媒体号作家中心 | 发文章 (imoocnews.com)</a><br>回到用户发文章的文章领域类型也会一起修改<br><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/index.html">慕课新闻 | 风间影月 (imoocnews.com)</a><br>同时首页上方的栏目框也会修改</p>
</blockquote>
<pre><code class="java">service-admin  com/imooc/admin/service/impl/CategoryServiceImpl.java
@Service
public class CategoryServiceImpl extends BaseService implements CategoryService &#123;
    @Autowired
    public CategoryMapper categoryMapper;

    @Transactional
    @Override
    public void createCategory(Category category) &#123;
// 分类不会很多，所以id不需要自增，这个表的数据也不会多到几万甚至分表，数据都会集中在一起
        int result = categoryMapper.insert(category);
        if (result != 1)&#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
            /**
             * 不建议如下做法：
             * 1. 查询redis中的categoryList
             * 2. 转化categoryList为list类型
             * 3. 在categoryList中add一个当前的category
             * 4. 再次转换categoryList为json，并存入redis中
             */
            // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
            redis.del(REDIS_ALL_CATEGORY);
        &#125;
    &#125;

    @Transactional
    @Override
    public void modifyCategory(Category category) &#123;
        int result = categoryMapper.updateByPrimaryKey(category);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
        // 直接使用redis删除缓存即可，用户端在查询的时候会直接查库，再把最新的数据放入到缓存中
        redis.del(REDIS_ALL_CATEGORY);
    &#125;
......
</code></pre>
<h3 id="发布文章入库Controller及验证【发头条】"><a href="#发布文章入库Controller及验证【发头条】" class="headerlink" title="发布文章入库Controller及验证【发头条】"></a>发布文章入库Controller及验证【发头条】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
package com.imooc.api.controller.article;

@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;
    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
package com.imooc.article.controller;

@RestController
public class ArticleController extends BaseController implements ArticleControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(ArticleController.class);

    @Override
    public GraceJSONResult createArticle(NewArticleBO newArticleBO, BindingResult result) &#123;
            if (result.hasErrors())&#123;
                // 判断BindingResult是否保存错误的验证信息，如果有，则直接return
                Map&lt;String, String&gt; errorMap = getErrors(result);
                return GraceJSONResult.errorMap(errorMap);
            &#125;
            // 判断文章封面类型，单图必填，纯文字则设置为空
            if (newArticleBO.getArticleType() == ArticleCoverType.ONE_IMAGE.type)&#123;
                if (StringUtils.isBlank(newArticleBO.getArticleCover()))&#123;
                    return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
                &#125;
            &#125; else if (newArticleBO.getArticleType() == ArticleCoverType.WORDS.type) &#123;
                newArticleBO.setArticleCover(&quot;&quot;);
            &#125;

        // 判断分类id是否存在
        String allCatJson = redis.get(REDIS_ALL_CATEGORY);
        Category temp = null;
        if (StringUtils.isBlank(allCatJson)) &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125; else &#123;
            List&lt;Category&gt; catList =
                    JsonUtils.jsonToList(allCatJson, Category.class);
            for (Category c : catList) &#123;
                if(c.getId() == newArticleBO.getCategoryId()) &#123;
                    temp = c;
                    break;
                &#125;
            &#125;
            if (temp == null) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_CATEGORY_NOT_EXIST_ERROR);
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
&#125;
http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/NewArticleBO.java
package com.imooc.pojo.bo;

import com.fasterxml.jackson.annotation.JsonFormat;
import org.hibernate.validator.constraints.Length;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.util.Date;
/**
 * 用户发文的BO
 */
public class NewArticleBO &#123;

    @NotBlank(message = &quot;文章标题不能为空&quot;)
    @Length(max = 30, message = &quot;文章标题长度不能超过30&quot;)
    private String title;

    @NotBlank(message = &quot;文章内容不能为空&quot;)
    @Length(max = 9999, message = &quot;文章内容长度不能超过10000&quot;)
    private String content;

    @NotNull(message = &quot;请选择文章领域&quot;)
    private Integer categoryId;

    @NotNull(message = &quot;请选择正确的文章封面类型&quot;)
    @Min(value = 1, message = &quot;请选择正确的文章封面类型&quot;)
    @Max(value = 2, message = &quot;请选择正确的文章封面类型&quot;)
    private Integer articleType;
    private String articleCover;

    @NotNull(message = &quot;文章发布类型不正确&quot;)
    @Min(value = 0, message = &quot;文章发布类型不正确&quot;)
    @Max(value = 1, message = &quot;文章发布类型不正确&quot;)
    private Integer isAppoint;

    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) // 前端日期字符串传到后端后，转换为Date类型
    private Date publishTime;

    @NotBlank(message = &quot;用户未登录&quot;)
    private String publishUserId;
&#125;Getter + Setter
</code></pre>
<h3 id="发布文章入库Service及联调【也可以定时发布】"><a href="#发布文章入库Service及联调【也可以定时发布】" class="headerlink" title="发布文章入库Service及联调【也可以定时发布】"></a>发布文章入库Service及联调【也可以定时发布】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html</a><br>发布完成后去数据库article中就会存在数据了</p>
<pre><code class="xml">generator-datebase  generatorConfig-article.xml [逆向生成]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">generator-datebase  com/imooc/mybatis/utils/ArticleGenerator.java
//[运行时候就会自动生成对应文件 目录是上面的generatorConfig-article.xml]
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  mapper/ArticleMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Article&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;title&quot; property=&quot;title&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;category_id&quot; property=&quot;categoryId&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_type&quot; property=&quot;articleType&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_appoint&quot; property=&quot;isAppoint&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;article_status&quot; property=&quot;articleStatus&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;publish_user_id&quot; property=&quot;publishUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;publish_time&quot; property=&quot;publishTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;read_counts&quot; property=&quot;readCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;comment_counts&quot; property=&quot;commentCounts&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;mongo_file_id&quot; property=&quot;mongoFileId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;is_delete&quot; property=&quot;isDelete&quot; jdbcType=&quot;INTEGER&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;LONGVARCHAR&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;
    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.ArticleMapper;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleAppointType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.exception.GraceException;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.DateUtil;
import org.apache.commons.lang3.StringUtils;
import org.n3r.idworker.Sid;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

import static com.imooc.api.BaseController.REDIS_ALL_CATEGORY;


@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Article.java
package com.imooc.pojo;

import javax.persistence.Column;
import javax.persistence.Id;
import java.util.Date;

public class Article &#123;
    @Id
    private String id;

    /**
     * 文章标题
     */
    private String title;

    /**
     * 文章所属分类id
     */
    @Column(name = &quot;category_id&quot;)
    private Integer categoryId;

    /**
     * 文章类型，1：图文（1张封面），2：纯文字
     */
    @Column(name = &quot;article_type&quot;)
    private Integer articleType;

    /**
     * 文章封面图，article_type=1 的时候展示
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 是否是预约定时发布的文章，1：预约（定时）发布，0：即时发布    在预约时间到点的时候，把1改为0，则发布
     */
    @Column(name = &quot;is_appoint&quot;)
    private Integer isAppoint;

    /**
     * 文章状态，1：审核中（用户已提交），2：机审结束，等待人工审核，3：审核通过（已发布），4：审核未通过；5：文章撤回（已发布的情况下才能撤回和删除）
     */
    @Column(name = &quot;article_status&quot;)
    private Integer articleStatus;

    /**
     * 发布者用户id
     */
    @Column(name = &quot;publish_user_id&quot;)
    private String publishUserId;

    /**
     * 文章发布时间（也是预约发布的时间）
     */
    @Column(name = &quot;publish_time&quot;)
    private Date publishTime;

    /**
     * 用户累计点击阅读数（喜欢数）（点赞） - 放redis
     */
    @Column(name = &quot;read_counts&quot;)
    private Integer readCounts;

    /**
     * 文章评论总数。评论防刷，距离上次评论需要间隔时间控制几秒
     */
    @Column(name = &quot;comment_counts&quot;)
    private Integer commentCounts;

    @Column(name = &quot;mongo_file_id&quot;)
    private String mongoFileId;

    /**
     * 逻辑删除状态，非物理删除，1：删除，0：未删除
     */
    @Column(name = &quot;is_delete&quot;)
    private Integer isDelete;

    /**
     * 文章的创建时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;

    /**
     * 文章的修改时间
     */
    @Column(name = &quot;update_time&quot;)
    private Date updateTime;

    /**
     * 文章内容，长度不超过9999，需要在前后端判断
     */
    private String content;
</code></pre>
<h3 id="构建定时任务-定时发布文章【定时任务】"><a href="#构建定时任务-定时发布文章【定时任务】" class="headerlink" title="构建定时任务 定时发布文章【定时任务】"></a>构建定时任务 定时发布文章【定时任务】</h3><p><a target="_blank" rel="noopener" href="https://cron.qqe2.com/">在线Cron表达式生成器 (qqe2.com)</a></p>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
    &#125;
&#125;

=================================================================
执行定时任务：2024-07-22T14:34:54.009
执行定时任务：2024-07-22T14:34:57.013
执行定时任务：2024-07-22T14:35:00.012
执行定时任务：2024-07-22T14:35:03.002
执行定时任务：2024-07-22T14:35:06.001
执行定时任务：2024-07-22T14:35:09.006
</code></pre>
<pre><code class="java">service-article  com/imooc/article/task/TaskPublishArticles.java
package com.imooc.article.task;

import com.imooc.article.service.ArticleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;

@Configuration  // 1.标记配置类，使得springboot容器扫描到
@EnableScheduling // 2.开启定时任务
public class TaskPublishArticles &#123;
    @Autowired
    private ArticleService articleService;
    // 添加定时任务，注明定时任务的表达式
    // 【若文章数量庞大 需要RabbitMQ去做优化 后面会讲！】
    @Scheduled(cron = &quot;0/3 * * * * ? &quot;)
    private void publishArticles()&#123;
        System.out.println(&quot;执行定时任务：&quot; + LocalDateTime.now());
        // 4. 调用文章service，把当前时间应该发布的定时文章，状态改为即时
        articleService.updateAppointToPublish();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapperCustom extends MyMapper&lt;Article&gt; &#123;
    public void updateAppointToPublish();
&#125;
</code></pre>
<pre><code class="java">service-article resources/mapper/ArticleMapperCustom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.ArticleMapperCustom&quot; &gt;
    &lt;update id=&quot;updateAppointToPublish&quot;&gt;
        update
            article
        set
            is_appoint = 0
        where
            publish_time &amp;lt;= NOW()
        and
            is_appoint = 1
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;

import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

&#125;
</code></pre>
<pre><code class="java">service-article   com/imooc/article/service/impl/ArticleServiceImpl.java

@Transactional //添加事务[更新操作]
    @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125;
</code></pre>
<h3 id="文章列表展示-【内容管理】"><a href="#文章列表展示-【内容管理】" class="headerlink" title="文章列表展示 【内容管理】"></a>文章列表展示 【内容管理】</h3><p>[mybatis中关于example类详解mybatis的Example</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suizhikuo/p/13191209.html">Criteria]的使用 - 万事俱备就差个程序员 - 博客园 (cnblogs.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@Api(value = &quot;文章业务的controller&quot;, tags = &#123;&quot;文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article&quot;)
public interface ArticleControllerApi &#123;

    @PostMapping(&quot;createArticle&quot;)
    @ApiOperation(value = &quot;用户发文&quot;, notes = &quot;用户发文&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult createArticle(@RequestBody @Valid NewArticleBO newArticleBO, BindingResult result);

    @PostMapping(&quot;queryMyList&quot;) //对应着前端contentMng.html 340行
    @ApiOperation(value = &quot;查询用户的所有文章列表&quot;, notes = &quot;查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryMyList(@RequestParam String userId,
                                       @RequestParam String keyword,
                                       @RequestParam Integer status,
                                       @RequestParam Date startDate,
                                       @RequestParam Date endDate,
                                       @RequestParam Integer page,
                                       @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryMyList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_QUERY_PARAMS_ERROR);
        &#125;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        // 查询我的列表，调用service
        PagedGridResult grid =  articleService.queryMyArticleList(userId, keyword, status, startDate, endDate, page, pageSize);
        return GraceJSONResult.ok(grid);
    &#125;
=========================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private Sid sid;
     //匹配到前端的一种显示方法
    @Override
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize) &#123;
        Example example = new Example(Article.class);
        example.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        if (StringUtils.isNotBlank(keyword))&#123;
            //模糊查询
            criteria.andLike(&quot;title&quot;, &quot;%&quot;+keyword+&quot;%&quot;);
        &#125;
        if (ArticleReviewStatus.isArticleStatusValid(status))&#123;
            // 有效就匹配 无效就查询所有
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;
        // 12是在前端显示审核中
        if (status != null &amp;&amp; status == 12)&#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        // 逻辑删除
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        if (startDate != null)&#123; //大于等于
            criteria.andGreaterThanOrEqualTo(&quot;publishTime&quot;, startDate);
        &#125;
        if (startDate != null)&#123; //小于等于
            criteria.andLessThanOrEqualTo(&quot;publishTime&quot;,endDate);
        &#125;
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(example);
        return setterPagedGrid(list,page);
    &#125;
/*
ArticleMapper 可以实现 selectByExample 是因为它继承了 MyMapper 接口，而 MyMapper 提供了一些通用的 CRUD 操作，这些操作包括 selectByExample。

selectByExample 是 MyBatis 提供的一种动态查询方法。它允许你根据条件动态地生成 SQL 查询，而不需要手动编写复杂的 SQL 语句。这在实际开发中非常方便，因为你可以通过构建 Example 对象来动态设置查询条件。

ArticleMapper 继承了 MyMapper&lt;Article&gt;，这意味着它自动获得了 MyMapper 中定义的所有方法，包括 selectByExample。MyMapper 是一个通用的 Mapper 接口，封装了常用的数据库操作方法。

Example 和 Criteria
Example: 用于构建查询条件的对象。在这里，我们创建了一个 Example 对象，用于设置查询的表（Article.class）和排序规则（按 createTime 降序）。

Criteria: 用于添加具体的查询条件。在 Example 对象中创建 Criteria 对象，并使用它来添加各种条件（例如 publishUserId、title、articleStatus、isDelete 等）。

selectByExample
selectByExample 方法使用 Example 对象中的条件动态生成 SQL 查询，并从数据库中获取符合条件的记录。在这个例子中，我们使用了 articleMapper.selectByExample(example) 来根据构建的 Example 对象进行查询。

Example 详细用法
Example 和 Criteria 的使用使得我们可以非常灵活地构建查询条件，而不需要直接拼接 SQL 语句。这不仅提高了代码的可读性，还减少了 SQL 注入的风险。
*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/ArticleMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Article;
import org.springframework.stereotype.Repository;

@Repository
public interface ArticleMapper extends MyMapper&lt;Article&gt; &#123;
&#125;
</code></pre>
<h3 id="阿里AI文本检测【内容审核】-机器审核"><a href="#阿里AI文本检测【内容审核】-机器审核" class="headerlink" title="阿里AI文本检测【内容审核】[机器审核]"></a>阿里AI文本检测【内容审核】<del>[机器审核]</del></h3><pre><code class="xml">dev-common pom.xml 
       &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;
            &lt;version&gt;4.5.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;
            &lt;version&gt;3.10.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;
            &lt;artifactId&gt;aliyun-java-sdk-green&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.51&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">dev-common  com/imooc/utils/extend/AliTextReviewUtils.java
package com.imooc.utils.extend;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.green.model.v20180509.TextScanRequest;
import com.aliyuncs.http.FormatType;
import com.aliyuncs.http.HttpResponse;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.profile.IClientProfile;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.*;

@Component
public class AliTextReviewUtils &#123;

    @Autowired
    private AliyunResource aliyunResource;

    public String reviewTextContent(String content) &#123;
        IClientProfile profile = DefaultProfile.getProfile(&quot;cn-shanghai&quot;,
                aliyunResource.getAccessKeyID(),
                aliyunResource.getAccessKeySecret());
        IAcsClient client = new DefaultAcsClient(profile);
        TextScanRequest textScanRequest = new TextScanRequest();
        textScanRequest.setAcceptFormat(FormatType.JSON); // 指定api返回格式
        textScanRequest.setHttpContentType(FormatType.JSON);
        textScanRequest.setMethod(com.aliyuncs.http.MethodType.POST); // 指定请求方法
        textScanRequest.setEncoding(&quot;UTF-8&quot;);
        textScanRequest.setRegionId(&quot;cn-shanghai&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; tasks = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();
        Map&lt;String, Object&gt; task1 = new LinkedHashMap&lt;String, Object&gt;();
        task1.put(&quot;dataId&quot;, UUID.randomUUID().toString());
        /**
         * 待检测的文本，长度不超过10000个字符
         */
//        抵制毒品交易
//          尼玛
        task1.put(&quot;content&quot;, content);
        tasks.add(task1);
        JSONObject data = new JSONObject();

        /**
         * 检测场景，文本垃圾检测传递：antispam
         **/
        data.put(&quot;scenes&quot;, Arrays.asList(&quot;antispam&quot;));
        data.put(&quot;tasks&quot;, tasks);
        System.out.println(JSON.toJSONString(data, true));

        try &#123;
            textScanRequest.setHttpContent(data.toJSONString().getBytes(&quot;UTF-8&quot;), &quot;UTF-8&quot;, FormatType.JSON);
            // 请务必设置超时时间
            textScanRequest.setConnectTimeout(3000);
            textScanRequest.setReadTimeout(6000);

            HttpResponse httpResponse = client.doAction(textScanRequest);
            if(httpResponse.isSuccess())&#123;
                JSONObject scrResponse = JSON.parseObject(new String(httpResponse.getHttpContent(), &quot;UTF-8&quot;));
                System.out.println(JSON.toJSONString(scrResponse, true));
                if (200 == scrResponse.getInteger(&quot;code&quot;)) &#123;
                    JSONArray taskResults = scrResponse.getJSONArray(&quot;data&quot;);
                    for (Object taskResult : taskResults) &#123;
                        if(200 == ((JSONObject)taskResult).getInteger(&quot;code&quot;))&#123;
                            JSONArray sceneResults = ((JSONObject)taskResult).getJSONArray(&quot;results&quot;);
                            JSONObject sceneResult = (JSONObject)sceneResults.get(0);
        //                            for (Object sceneResult : sceneResults) &#123;
                                String scene = sceneResult.getString(&quot;scene&quot;);
                                String suggestion = sceneResult.getString(&quot;suggestion&quot;);
                                //根据scene和suggetion做相关处理
                                //suggestion == pass 未命中垃圾  suggestion == block 命中了垃圾，可以通过label字段查看命中的垃圾分类
                                System.out.println(&quot;args = [&quot; + scene + &quot;]&quot;);
                                System.out.println(&quot;args = [&quot; + suggestion + &quot;]&quot;);

        //                            suggestion=pass：文本正常，文章状态改为发布通过
        //                            review：需要人工审核，需要在后台管理系统中进行人工审核（很多自媒体平台都会采用机审+人工审的方式）
        //                            block：文本违规，可以直接删除或者做限制处理，审核不通过
        //                            &#125;
                                return suggestion;
                        &#125;else&#123;
                            System.out.println(&quot;task process fail:&quot; + ((JSONObject)taskResult).getInteger(&quot;code&quot;));
                            return null;
                        &#125;
                    &#125;
                &#125; else &#123;
                    System.out.println(&quot;detect not success. code:&quot; + scrResponse.getInteger(&quot;code&quot;));
                    return null;
                &#125;
            &#125;else&#123;
                System.out.println(&quot;response not success. status:&quot; + httpResponse.getStatus());
                return null;
            &#125;
        &#125; catch (UnsupportedEncodingException e) &#123;
            e.printStackTrace();
        &#125; catch (ClientException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="实现阿里AI自动审核文章【内容审核】"><a href="#实现阿里AI自动审核文章【内容审核】" class="headerlink" title="实现阿里AI自动审核文章【内容审核】"></a>实现阿里AI自动审核文章【内容审核】</h3><pre><code class="java">【沿用上面的AliTextReviewUtils】
@Service
public class ArticleServiceImpl extends BaseService implements ArticleService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository
    @Autowired
    private ArticleMapperCustom articleMapperCustom;
    @Autowired
    private AliTextReviewUtils aliTextReviewUtils;
    @Autowired
    private Sid sid;

    @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;
......
......
    @Transactional
    @Override
    public void updateArticleStatus(String articleId, Integer pendingStatus) &#123;
        Example example = new Example(Article.class);
        Example.Criteria criteria = example.createCriteria();
        criteria.andEqualTo(&quot;id&quot;,articleId);

        Article pendingArticle = new Article();
        pendingArticle.setArticleStatus(pendingStatus);
        int res = articleMapper.updateByExampleSelective(pendingArticle, example);
        if (res != 1)&#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

    /**
     * 发布文章
     */
    public void createArticle(NewArticleBO newArticleBO, Category category);

    /**
     * 更新定时发布为即使发布
     */
    public void updateAppointToPublish();

    /**
     * 用户中心-查询我的文章列表
     */
    public PagedGridResult queryMyArticleList(String userId, String keyword, Integer status, Date startDate, Date endDate, Integer page, Integer pageSize);

    /**
     * 更改文章的状态
     * @param articleId
     * @param pendingStatus
     */
    public void updateArticleStatus(String articleId, Integer pendingStatus);
&#125;
</code></pre>
<h3 id="admin文章管理列表【内容审核】【作业】"><a href="#admin文章管理列表【内容审核】【作业】" class="headerlink" title="admin文章管理列表【内容审核】【作业】"></a>admin文章管理列表【内容审核】<del>【作业】</del></h3><h5 id="管理员查询用户的所有文章列表"><a href="#管理员查询用户的所有文章列表" class="headerlink" title="管理员查询用户的所有文章列表"></a>管理员查询用户的所有文章列表</h5><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
@PostMapping(&quot;queryAllList&quot;)
    @ApiOperation(value = &quot;管理员查询用户的所有文章列表&quot;, notes = &quot;管理员查询用户的所有文章列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult queryAllList(@RequestParam Integer status,
                                        @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                        @RequestParam Integer page,
                                        @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                        @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult queryAllList(Integer status, Integer page, Integer pageSize) &#123;
        if (page == null)&#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null)&#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = articleService.queryAllArticleListAdmin(status,page,pageSize);

        return GraceJSONResult.ok(gridResult);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
    /**
     * 管理员查询文章列表
     */
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Override
    public PagedGridResult queryAllArticleListAdmin(Integer status, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;createTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();
        //这里是检测文章状态 与前端做匹配
        if (ArticleReviewStatus.isArticleStatusValid(status)) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, status);
        &#125;

        // 审核中是机审和人审核的两个状态，所以需要单独判断
        if (status != null &amp;&amp; status == 12) &#123;
            criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.REVIEWING.type)
                    .orEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125;
        //isDelete必须是0
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;
</code></pre>
<h3 id="人工审核-【内容审核】"><a href="#人工审核-【内容审核】" class="headerlink" title="人工审核 【内容审核】"></a>人工审核 【内容审核】</h3><p><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">内容审核 | 运营管理平台 (imoocnews.com)</a> 【[待审核]手动审核通过】</p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;doReview&quot;)
    @ApiOperation(value = &quot;管理员对文章进行审核通过或者失败&quot;, notes = &quot;管理员对文章进行审核通过或者失败&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult doReview(@RequestParam String articleId,
                                    @RequestParam Integer passOrNot);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<h3 id="撤回-删除文章作业-【内容管理】"><a href="#撤回-删除文章作业-【内容管理】" class="headerlink" title="撤回_删除文章作业 【内容管理】"></a>撤回_删除文章作业 【内容管理】</h3><p><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">媒体号作家中心 | 内容管理 (imoocnews.com)</a><br>[这个是用户撤回和删除噢 而不是管理员的撤回与删除]<br><a target="_blank" rel="noopener" href="http://writer.imoocnews.com:9090/imooc-news/writer/contentMng.html">用户：媒体号作家中心 | 内容管理 (imoocnews.com)</a><br><a target="_blank" rel="noopener" href="http://admin.imoocnews.com:9090/imooc-news/admin/contentReview.html">管理员：内容审核 | 运营管理平台 (imoocnews.com)</a></p>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleControllerApi.java
    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;用户删除文章&quot;, notes = &quot;用户删除文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String userId,
                                  @RequestParam String articleId);

    @PostMapping(&quot;/withdraw&quot;)
    @ApiOperation(value = &quot;用户撤回文章&quot;, notes = &quot;用户撤回文章&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult withdraw(@RequestParam String userId,
                                    @RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
package com.imooc.article.service;

import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.PagedGridResult;

import java.util.Date;
import java.util.List;

public interface ArticleService &#123;

   /**
     * 删除文章
     */
    public void deleteArticle(String userId, String articleId);

    /**
     * 撤回文章
     */
    public void withdrawArticle(String userId, String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
//        deleteHTML(articleId);
    &#125;

    private Example makeExampleCriteria(String userId, String articleId) &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = articleExample.createCriteria();
        criteria.andEqualTo(&quot;publishUserId&quot;, userId);
        criteria.andEqualTo(&quot;id&quot;, articleId);
        return articleExample;
    &#125;
</code></pre>
<h2 id="首页-作者页面介绍【章节描述】"><a href="#首页-作者页面介绍【章节描述】" class="headerlink" title="首页_作者页面介绍【章节描述】"></a>首页_作者页面介绍【章节描述】</h2><ul>
<li><strong>开发首页与作家个人展示页</strong></li>
<li><strong>文章列表、友情链接查询</strong></li>
<li><strong>粉丝关注与取关</strong></li>
<li><strong>我的粉丝与粉丝画像</strong></li>
</ul>
<h3 id="根据MongoDB字段查询友情链接"><a href="#根据MongoDB字段查询友情链接" class="headerlink" title="根据MongoDB字段查询友情链接"></a>根据MongoDB字段查询友情链接</h3><pre><code class="java">service-api  com/imooc/api/controller/admin/FriendLinkControllerApi.java
    @ApiOperation(value = &quot;门户端查询友情链接列表&quot;, notes = &quot;门户端查询友情链接列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;portal/list&quot;)
    public GraceJSONResult queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/controller/FriendLinkController.java
    @Override
    public GraceJSONResult queryPortalAllFriendLinkList() &#123;
        List&lt;FriendLinkMO&gt; list = friendLinkService.queryPortalAllFriendLinkList();
        return GraceJSONResult.ok(list);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/service/FriendLinkService.java
    /**
     * 首页查询友情链接
     */
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList();
</code></pre>
<pre><code class="java">service-admin com/imooc/admin/service/impl/FriendLinkServiceImpl.java 
@Override
    public List&lt;FriendLinkMO&gt; queryPortalAllFriendLinkList() &#123;
        return friendLinkRepository.getAllByIsDelete(YesOrNo.NO.type);
    &#125;
</code></pre>
<pre><code class="java">service-admin  com/imooc/admin/repository/FriendLinkRepository.java
@Repository
public interface FriendLinkRepository extends MongoRepository&lt;FriendLinkMO, String&gt; &#123; //持久层
    // 内置提供了很多方法 find.. delete...
    public List&lt;FriendLinkMO&gt; getAllByIsDelete(Integer isDelete); //后面可以加ANDID
&#125;
</code></pre>
<h3 id="搜索并展示文章列表【首页】"><a href="#搜索并展示文章列表【首页】" class="headerlink" title="搜索并展示文章列表【首页】"></a>搜索并展示文章列表【首页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;list&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Service
public class ArticlePortalServiceImpl extends BaseService implements ArticlePortalService &#123;
    @Autowired
    private ArticleMapper articleMapper; //红色波浪线就去ArticleMapper上面加@Repository


    @Override
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize) &#123;

        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();//使用时间进行排序
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        if (StringUtils.isNotBlank(keyword)) &#123;
            criteria.andLike(&quot;title&quot;, &quot;%&quot; + keyword + &quot;%&quot;);
        &#125;
        if (category != null) &#123;
            criteria.andEqualTo(&quot;categoryId&quot;, category);
        &#125;

        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        System.out.println(keyword);
        System.out.println(category);
        return setterPagedGrid(list, page);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 &#125;
</code></pre>
<pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
                                &lt;!-- TODO: 这里需要显示用户的昵称以及用户头像 --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                
                                
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                &lt;!--
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;
                                    --&gt;

                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<h3 id="文章列表展示发布者需求【首页】"><a href="#文章列表展示发布者需求【首页】" class="headerlink" title="文章列表展示发布者需求【首页】"></a>文章列表展示发布者需求【首页】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
[其他不变加上点代码]
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticleControllerApi;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.enums.ArticleCoverType;
import com.imooc.enums.ArticleReviewStatus;
import com.imooc.enums.YesOrNo;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.Article;
import com.imooc.pojo.Category;
import com.imooc.pojo.bo.NewArticleBO;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表

        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<h3 id="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"><a href="#发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户" class="headerlink" title="发起restTemplate请求查询用户服务获得发布者列表【首页】二级用户"></a>发起restTemplate请求查询用户服务获得发布者列表【首页】<del>二级用户</del></h3><pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        for (AppUserVO u : publisherList)&#123;
            System.out.println(u.toString());
        &#125;
        // 3. 拼接两个list，重组文章列表
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
===================成功输出二级用户基本信息===============================
AppUserVO&#123;id=&#39;240629F21AK1BHX4&#39;, nickname=&#39;15027597319&#39;, face=&#39;https://iimooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/240629F21AK1BHX4/240712FM0G1WMZHH.png&#39;, activeStatus=1&#125;
AppUserVO&#123;id=&#39;200628AFYM7AGWPH&#39;, nickname=&#39;我是慕课网&#39;, face=&#39;https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&#39;, activeStatus=1&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
@Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;

    private AppUserVO getBasicUserInfo(String userId)&#123;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        return userVO;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
package com.imooc.api.controller.user;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          BindingResult result);

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByids&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="重组文章列表并且渲染【首页】"><a href="#重组文章列表并且渲染【首页】" class="headerlink" title="重组文章列表并且渲染【首页】"></a>重组文章列表并且渲染【首页】</h3><pre><code class="html">index.html
&lt;!-- 中间容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;!-- 文章列表 --&gt;
            &lt;div id=&quot;articleList&quot; class=&quot;article-list&quot;&gt;
                &lt;ul&gt;
                    &lt;li class=&quot;single-article-wrapper&quot; v-for=&quot;(article, index) in articleList&quot; :key=&quot;index&quot;&gt;
                        &lt;img :src=&quot;article.articleCover&quot; class=&quot;article-cover&quot; v-show=&quot;article.articleType == 1&quot;&gt;

                        &lt;div class=&quot;single-article&quot;&gt;
                            &lt;div class=&quot;article-title&quot;&gt;
                                &lt;!-- TODO: 后期改为静态页面跳转 --&gt;
                                &lt;a :href=&quot;&#39;detail.html?articleId=&#39;+article.id&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;publisher&quot;&gt;
                                &lt;div class=&quot;category-tag&quot; :style=&quot;&#123;color: getCatTagColor(article.categoryId), borderColor: getCatTagColor(article.categoryId) &#125;&quot;&gt;&#123;&#123;getCatName(article.categoryId)&#125;&#125;&lt;/div&gt;
          &lt;!-- ★★★★★ TODO: 这里需要显示用户的昵称以及用户头像 ★★★★★ --&gt;
                                    &lt;img src=&quot;img/face1.png&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO == null || article.publisherVO == undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publishUserId&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                    &lt;img :src=&quot;article.publisherVO.face&quot; class=&quot;publisher-face&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;
                                
                                    &lt;a :href=&quot;&#39;writer.html?writerId=&#39;+article.publisherVO.id&quot; target=&quot;_blank&quot;&gt;
                                    &lt;div class=&quot;publisher-name&quot; v-if=&quot;article.publisherVO != null &amp;&amp; article.publisherVO != undefined&quot;&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;article.publisherVO.nickname&#125;&#125;&amp;nbsp;⋅&lt;/div&gt;
                                &lt;/a&gt;            
                                &lt;div class=&quot;article-name&quot;&gt;&amp;nbsp;&#123;&#123;article.readCounts&#125;&#125;阅读&amp;nbsp;⋅&lt;/div&gt;
                                &lt;!-- &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;formatData(article.publishTime)&#125;&#125;&lt;/div&gt; --&gt;
                                &lt;div class=&quot;publish-time&quot;&gt;&amp;nbsp;&#123;&#123;getDateBeforeNow(article.publishTime)&#125;&#125;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/IndexArticleVO.java
public class IndexArticleVO &#123;

    private String id;
    private String title;
    private Integer categoryId;
    private Integer articleType;
    private String articleCover;
    private Integer isAppoint;
    private Integer articleStatus;
    private String publishUserId;
    private Date publishTime;
    private Integer readCounts;
    private Integer commentCounts;
    private String mongoFileId;
    private Integer isDelete;
    private Date createTime;
    private Date updateTime;
    private String content;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
package com.imooc.article.controller;
......
import java.util.*;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
   //START 用户量大就双表关联查询      单表双查询 → 【首页不会显示发布者的用户id 和 头像】
        List&lt;Article&gt; list = (List&lt;Article&gt;) gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idset = new HashSet&lt;&gt;();
        for (Article a : list)&#123;
//            System.out.println(a.getPublishUserId());
            idset.add(a.getPublishUserId());
        &#125;
        System.out.println(idset.toString());
        // 2. 发起远程调用(restTemplate)，请求用户服务获得用户(idSet 发布者)列表
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idset);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity =
        restTemplate.getForEntity(userServerUrlExecute,GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200)&#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
//        for (AppUserVO u : publisherList)&#123;
//            System.out.println(u.toString());
//        &#125;
        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (Article a : list)&#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);
            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
   //END
        return GraceJSONResult.ok(gridResult);
    &#125;
    // 用于获得publish
    private AppUserVO getUserIfPublisher(String publisherId, List&lt;AppUserVO&gt; publisherList)&#123;
        for (AppUserVO user : publisherList)&#123;
            if (user.getId().equalsIgnoreCase(publisherId))&#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="查询热闻【首页】阅读数从最新新闻进行排名"><a href="#查询热闻【首页】阅读数从最新新闻进行排名" class="headerlink" title="查询热闻【首页】阅读数从最新新闻进行排名"></a>查询热闻【首页】<del>阅读数从最新新闻进行排名</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;
 @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
@Override
    public List&lt;Article&gt; queryHotList() &#123;
        Example articleExample = new Example(Article.class);
        Example.Criteria criteria = setDefualArticleExample(articleExample);

        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list  = articleMapper.selectByExample(articleExample);
        return list;
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;
</code></pre>
<h3 id="基本信息展示-历史文章列表【作者主页】"><a href="#基本信息展示-历史文章列表【作者主页】" class="headerlink" title="基本信息展示_历史文章列表【作者主页】"></a>基本信息展示_历史文章列表【作者主页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;门户端文章业务的controller&quot;, tags = &#123;&quot;门户端文章业务的controller&quot;&#125;)
@RequestMapping(&quot;portal/article&quot;)
public interface ArticlePortalControllerApi &#123;

    @GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;首页查询文章列表&quot;, notes = &quot;首页查询文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String keyword,
                                @RequestParam Integer category,
                                @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                @RequestParam Integer page,
                                @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                @RequestParam Integer pageSize);

    @GetMapping(&quot;hotList&quot;)
    @ApiOperation(value = &quot;首页查询新闻列表&quot;, notes = &quot;首页查询新闻列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult hotList();

    /**
     * 查询作家发布的所有文章列表
     */
    @GetMapping(&quot;queryArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;查询作家发布的所有文章列表&quot;, notes = &quot;查询作家发布的所有文章列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryArticleListOfWriter(@RequestParam String writerId,
                                                    @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                                                        @RequestParam Integer page,
                                                    @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                                                        @RequestParam Integer pageSize);

    @GetMapping(&quot;queryGoodArticleListOfWriter&quot;)
    @ApiOperation(value = &quot;作家页面查询近期佳文&quot;, notes = &quot;作家页面查询近期佳文&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult queryGoodArticleListOfWriter(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;
</code></pre>
<pre><code class="java">/* 完全版ArticlePortalController
package com.imooc.article.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.article.ArticlePortalControllerApi;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.ArticleService;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.vo.AppUserVO;
import com.imooc.pojo.vo.IndexArticleVO;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@RestController
public class ArticlePortalController extends BaseController implements ArticlePortalControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticlePortalController.class);

    @Autowired
    private ArticlePortalService articlePortalService;

    @Autowired
    private RestTemplate restTemplate;

    @Override
    public GraceJSONResult list(String keyword,
                                Integer category,
                                Integer page,
                                Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult
                = articlePortalService.queryIndexArticleList(keyword,
                category,
                page,
                pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START

        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();

        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i);
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;


        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;

    private AppUserVO getUserIfPublisher(String publisherId,
                                         List&lt;AppUserVO&gt; publisherList) &#123;
        for (AppUserVO user : publisherList) &#123;
            if (user.getId().equalsIgnoreCase(publisherId)) &#123;
                return user;
            &#125;
        &#125;
        return null;
    &#125;

    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;

    @Override
    public GraceJSONResult hotList() &#123;
        return GraceJSONResult.ok(articlePortalService.queryHotList());
    &#125;

    @Override
    public GraceJSONResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;

        System.out.println(&quot;writerId=&quot; + writerId);

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = articlePortalService.queryArticleListOfWriter(writerId, page, pageSize);
        gridResult = rebuildArticleGrid(gridResult);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult queryGoodArticleListOfWriter(String writerId) &#123;
        PagedGridResult gridResult = articlePortalService.queryGoodArticleListOfWriter(writerId);
        return GraceJSONResult.ok(gridResult);
    &#125;
&#125;

*/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
public interface ArticlePortalService &#123;

    /**
     * 首页查询文章列表
     */
    public PagedGridResult queryIndexArticleList(String keyword,
                                                 Integer category,
                                                 Integer page,
                                                 Integer pageSize);
    /**
     * 首页查询热闻列表
     */
    public List&lt;Article&gt; queryHotList();

    /**
     * 查询作家发布的所有文章列表
     */
    public PagedGridResult queryArticleListOfWriter(String writerId,
                                                    Integer page,
                                                    Integer pageSize);

    /**
     * 作家页面查询近期佳文
     */
    public PagedGridResult queryGoodArticleListOfWriter(String writerId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java

@Override
    public PagedGridResult queryArticleListOfWriter(String writerId, Integer page, Integer pageSize) &#123;
        Example articleExample = new Example(Article.class);

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(page, pageSize);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, page);
    &#125;

    @Override
    public PagedGridResult queryGoodArticleListOfWriter(String writerId) &#123;
        Example articleExample = new Example(Article.class);
        articleExample.orderBy(&quot;publishTime&quot;).desc();

        Example.Criteria criteria = setDefualArticleExample(articleExample);
        criteria.andEqualTo(&quot;publishUserId&quot;, writerId);

        /**
         * page: 第几页
         * pageSize: 每页显示条数
         */
        PageHelper.startPage(1, 5);
        List&lt;Article&gt; list = articleMapper.selectByExample(articleExample);
        return setterPagedGrid(list, 1);
    &#125;

    private Example.Criteria setDefualArticleExample(Example articleExample) &#123;
        articleExample.orderBy(&quot;publishTime&quot;).desc();
        Example.Criteria criteria = articleExample.createCriteria();

        /**
         * 查询首页文章的自带隐性查询条件：
         * isAppoint=即使发布，表示文章已经直接发布的，或者定时任务到点发布的
         * isDelete=未删除，表示文章只能够显示未删除
         * articleStatus=审核通过，表示只有文章经过机审/人工审核之后才能展示
         */
        criteria.andEqualTo(&quot;isAppoint&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;isDelete&quot;, YesOrNo.NO.type);
        criteria.andEqualTo(&quot;articleStatus&quot;, ArticleReviewStatus.SUCCESS.type);

        return criteria;
    &#125;
</code></pre>
<h4 id="关注与取关-redis单线程计数统计-【粉丝关注】"><a href="#关注与取关-redis单线程计数统计-【粉丝关注】" class="headerlink" title="关注与取关_redis单线程计数统计 【粉丝关注】"></a>关注与取关_redis单线程计数统计 【粉丝关注】</h4><blockquote>
<p>阅读数可以用数据库COUNT* 但是压力会很大 若很多人一起刷新会音响很大<br>用redis 数量累加累减 单线程安全<br>减少数据库压力</p>
</blockquote>
<pre><code class="mysql">【注意 redis我安装到了本地计算机里面 D:\Redis-x64-3.0.504】
打开redis-cli.exe
127.0.0.1:6379&gt; keys *
1) &quot;redis_all_category&quot;
2) &quot;redis_admin_token:1001&quot;
3) &quot;redis_user_info:1001&quot;
4) &quot;redis_user_info:200628AFYM7AGWPH&quot;
5) &quot;redis_user_token:240629F21AK1BHX4&quot;
6) &quot;redis_user_info:240629F21AK1BHX4&quot;
7) &quot;redis_user_token:200628AFYM7AGWPH&quot;
127.0.0.1:6379&gt; INCR 1001:fans #【增加】
(integer) 1
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 2
127.0.0.1:6379&gt; INCR 1001:fans
(integer) 3
127.0.0.1:6379&gt; get 1001:fans #【获取】
&quot;3&quot;
127.0.0.1:6379&gt; DECR 1001:fans #【减少】
(integer) 2
127.0.0.1:6379&gt; DECR 1001:fans
(integer) 1
127.0.0.1:6379&gt; incr 1001:follows #【关注的粉丝】
(integer) 1
127.0.0.1:6379&gt; get 1001:follows
&quot;1&quot;
</code></pre>
<h3 id="查询用户关注状态【粉丝关注】"><a href="#查询用户关注状态【粉丝关注】" class="headerlink" title="查询用户关注状态【粉丝关注】"></a>查询用户关注状态【粉丝关注】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;查询当前用户是否关注作家&quot;,notes = &quot;查询当前用户是否关注作家&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/isMeFollowThisWriter&quot;)
    public GraceJSONResult isMeFollowThisWriter(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

import java.util.Date;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;


    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/mapper/FansMapper.java
package com.imooc.user.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Fans;
import org.springframework.stereotype.Repository;

@Repository
public interface FansMapper extends MyMapper&lt;Fans&gt; &#123;
&#125;
</code></pre>
<h3 id="用户关注-粉丝累加-amp-amp-粉丝累减"><a href="#用户关注-粉丝累加-amp-amp-粉丝累减" class="headerlink" title="用户关注_粉丝累加 &amp;&amp; 粉丝累减"></a>用户关注_粉丝累加 &amp;&amp; 粉丝累减</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
package com.imooc.api.controller.user;


import com.imooc.grace.result.GraceJSONResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
    @ApiOperation(value = &quot;用户关注作家，成为粉丝&quot;,notes = &quot;用户关注作家，成为粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/follow&quot;)
    public GraceJSONResult follow(@RequestParam String writerId, @RequestParam String fanId);
    
    @ApiOperation(value = &quot;取消关注，作家损失粉丝&quot;,notes = &quot;取消关注，作家损失粉丝&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/unfollow&quot;)
    public GraceJSONResult unfollow(@RequestParam String writerId, @RequestParam String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
package com.imooc.user.controller;

import com.imooc.api.BaseController;
import com.imooc.api.controller.user.MyFansControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.user.service.MyFansService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(MyFansController.class);

    @Autowired
    private MyFansService myFansService;

    @Override
    public GraceJSONResult isMeFollowThisWriter(String writerId, String fanId) &#123;
        boolean res = myFansService.isMeFollowThisWriter(writerId,fanId);
        return GraceJSONResult.ok(res);
    &#125;

    @Override
    public GraceJSONResult follow(String writerId, String fanId) &#123;
        myFansService.follow(writerId,fanId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult unfollow(String writerId, String fanId) &#123;
        myFansService.unfollow(writerId, fanId);
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);
    
    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
package com.imooc.user.service.impl;

import com.github.pagehelper.PageHelper;
import com.imooc.api.service.BaseService;
import com.imooc.enums.UserStatus;
import com.imooc.pojo.AppUser;
import com.imooc.pojo.Fans;
import com.imooc.user.mapper.AppUserMapper;
import com.imooc.user.mapper.FansMapper;
import com.imooc.user.service.AppUserMngService;
import com.imooc.user.service.MyFansService;
import com.imooc.utils.PagedGridResult;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import tk.mybatis.mapper.entity.Example;

import java.util.Date;
import java.util.List;

@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
    @Autowired
    public FansMapper fansMapper;
    @Override
    public boolean isMeFollowThisWriter(String writerId, String fanId) &#123;
        Fans fan = new Fans();
        fan.setFanId(fanId);
        fan.setWriterId(writerId);
        int count = fansMapper.selectCount(fan); //前期先放在数据库里
        return count &gt; 0 ? true : false;
    &#125;
    
    @Transactional
    @Override
    public void follow(String writerId, String fanId) &#123;
        // 获得粉丝用户的信息
        AppUser fanInfo = userService.getUser(fanId);

        String fanPkId = sid.nextShort();

        Fans fans = new Fans();
        fans.setId(fanPkId);
        fans.setFanId(fanId);
        fans.setWriterId(writerId);

        fans.setFace(fanInfo.getFace());
        fans.setFanNickname(fanInfo.getNickname());
        fans.setSex(fanInfo.getSex());
        fans.setProvince(fanInfo.getProvince());

        fansMapper.insert(fans);

        // redis 作家粉丝数累加
        redis.increment(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累加
        redis.increment(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
    
    @Transactional
    @Override
    public void unfollow(String writerId, String fanId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setFanId(fanId);

        fansMapper.delete(fans);

        // redis 作家粉丝数累减
        redis.decrement(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + writerId, 1);  //增加key一次
        // redis 当前用户的(我的)关注数累减
        redis.decrement(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + fanId, 1);  //增加key一次
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/service/BaseService.java
package com.imooc.api.service;

import com.github.pagehelper.PageInfo;
import com.imooc.utils.PagedGridResult;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;

public class BaseService &#123;
    public static final String REDIS_ALL_CATEGORY = &quot;redis_all_category&quot;;

    public static final String REDIS_WRITER_FANS_COUNTS = &quot;redis_writer_fans_counts&quot;;
    public static final String REDIS_MY_FOLLOW_COUNTS = &quot;redis_my_follow_counts&quot;;

    public static final String REDIS_ARTICLE_COMMENT_COUNTS = &quot;redis_article_comment_counts&quot;;

    @Autowired
    public RedisOperator redis;
    public PagedGridResult setterPagedGrid(List&lt;?&gt; list, Integer page)&#123; //类型是? 后期不确定是什么泛型
        PageInfo&lt;?&gt; pageList = new PageInfo&lt;&gt;(list);
        PagedGridResult gridResult = new PagedGridResult();
        gridResult.setRows(list);
        gridResult.setPage(page);
        gridResult.setRecords(pageList.getTotal());
        gridResult.setTotal(pageList.getPages());
        return gridResult;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java //增加粉丝接口的拦截
package com.imooc.api.config;

import com.imooc.api.interceptors.AdminTokenInterceptor;
import com.imooc.api.interceptors.PassportInterceptor;
import com.imooc.api.interceptors.UserActiveInterceptor;
import com.imooc.api.interceptors.UserTokenInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
    @Bean
    public PassportInterceptor passportInterceptor()&#123;
        return new PassportInterceptor();
    &#125;
    @Bean
    public UserTokenInterceptor userTokenInterceptor()&#123;
        return new UserTokenInterceptor();
    &#125;
    @Bean
    public UserActiveInterceptor userActiveInterceptor() &#123;
        return new UserActiveInterceptor();
    &#125;

    @Bean
    public AdminTokenInterceptor adminTokenInterceptor() &#123;
        return new AdminTokenInterceptor();
    &#125;


    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
        registry.addInterceptor(passportInterceptor())
                .addPathPatterns(&quot;/passport/getSMSCode&quot;); //拦截PassportControllerApi里的信息
        registry.addInterceptor(userTokenInterceptor())
                .addPathPatterns(&quot;/user/getAccountInfo&quot;)
                .addPathPatterns(&quot;/user/updateUserId&quot;)
                .addPathPatterns(&quot;/fs/uploadFace&quot;)
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);

        registry.addInterceptor(adminTokenInterceptor())//继续添加拦截器：查询admin列表 创建新admin用户
                .addPathPatterns(&quot;/adminMng/adminIsExist&quot;)
                .addPathPatterns(&quot;/adminMng/addNewAdmin&quot;)
                .addPathPatterns(&quot;/adminMng/getAdminList&quot;)
                .addPathPatterns(&quot;/fs/uploadToGridFS&quot;)
                .addPathPatterns(&quot;/friendLinkMng/saveOrUpdateFriendLink&quot;)
                .addPathPatterns(&quot;/friendLinkMng/getFriendLinkList&quot;)
                .addPathPatterns(&quot;/friendLinkMng/delete&quot;)
                .addPathPatterns(&quot;/categoryMng/saveOrUpdateCategory&quot;)
                .addPathPatterns(&quot;/categoryMng/getCatList&quot;);

        registry.addInterceptor(userActiveInterceptor())
                .addPathPatterns(&quot;/fs/uploadSomeFiles&quot;)
                .addPathPatterns(&quot;/fans/follow&quot;)
                .addPathPatterns(&quot;/fans/unfollow&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="粉丝数与关注数页面显示【粉丝关注】"><a href="#粉丝数与关注数页面显示【粉丝关注】" class="headerlink" title="粉丝数与关注数页面显示【粉丝关注】"></a>粉丝数与关注数页面显示【粉丝关注】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
public class UserController extends BaseController implements UserControllerApi &#123;
 @Override
    public GraceJSONResult getUserInfo(String userId) &#123;
        //接口进行解耦!!
        // 0. 判断参数不为空
        if (StringUtils.isBlank(userId))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.UN_LOGIN);
        &#125;
        // 1. 根据userId查询用户的信息 UserService+impl
        AppUser user = getUser(userId);
        // 2. 返回用户信息
        AppUserVO userVO = new AppUserVO();
        BeanUtils.copyProperties(user, userVO); //拷贝信息
        // 3. 查询redis中用户的关注数和粉丝数，放入userVO放入前端渲染
        userVO.setMyFansCounts(getCountsFromRedis(REDIS_WRITER_FANS_COUNTS + &quot;:&quot; + userId));
        userVO.setMyFollowCounts(getCountsFromRedis(REDIS_MY_FOLLOW_COUNTS + &quot;:&quot; + userId));
        return GraceJSONResult.ok(userVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public abstract class BaseController &#123;
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/AppUserVO.java
public class AppUserVO &#123;
    private String id;
    private String nickname;
    private String face;
    private Integer activeStatus;

    private Integer myFollowCounts;
    private Integer myFansCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="我的粉丝列表-后端分页查询【粉丝管理】"><a href="#我的粉丝列表-后端分页查询【粉丝管理】" class="headerlink" title="我的粉丝列表_后端分页查询【粉丝管理】"></a>我的粉丝列表_后端分页查询【粉丝管理】</h3><pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询我的所有粉丝列表&quot;, notes = &quot;查询我的所有粉丝列表&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryAll&quot;)
    public GraceJSONResult queryAll(
            @RequestParam String writerId,
            @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
            @RequestParam Integer page,
            @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页查询每一页显示的条数&quot;, required = false)
            @RequestParam Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryAll(String writerId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        return GraceJSONResult.ok(myFansService.queryMyFansList(writerId, page, pageSize));
    &#125;
&#125;
===================================================================
http://writer.imoocnews.com:9090/imooc-news/writer/myFans.html
数据库中fans表
weiter_id
可以改成登录的cookie里面的 uid：240629F21AK1BHX4
就可以测试用户粉丝数量
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
    /**
     * 查询当前用户是否关注作家
     */
    public boolean isMeFollowThisWriter(String writerId, String fanId);

    /**
     * 关注成为粉丝
     */
    public void follow(String writerId, String fanId);

    /**
     * 粉丝取消关注
     */
    public void unfollow(String writerId, String fanId);

    /**
     * 查询我的粉丝
     */
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public PagedGridResult queryMyFansList(String writerId, Integer page, Integer pageSize) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        PageHelper.startPage(page,pageSize); //进行分页
        List&lt;Fans&gt; list = fansMapper.select(fans);
        return setterPagedGrid(list,page);
    &#125;
&#125;
</code></pre>
<h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@Api(value = &quot;粉丝管理&quot;,tags = &#123;&quot;粉丝管理功能的controller&quot;&#125;)
@RequestMapping(&quot;fans&quot;)
public interface MyFansControllerApi &#123;
@ApiOperation(value = &quot;查询男女粉丝数量&quot;, notes = &quot;查询男女粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatio&quot;)
    public GraceJSONResult queryRatio(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
 @Override
    public GraceJSONResult queryRatio(String writerId) &#123;
        int manCount = myFansService.queryFansCounts(writerId, Sex.man);
        int womanCount = myFansService.queryFansCounts(writerId, Sex.woman);

        FansCountsVO fansCountsVO = new FansCountsVO();
        fansCountsVO.setManCounts(manCount);
        fansCountsVO.setWomanCounts(womanCount);
        return GraceJSONResult.ok(fansCountsVO);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public Integer queryFansCounts(String writerId, Sex sex);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public Integer queryFansCounts(String writerId, Sex sex) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);
        fans.setSex(sex.type);

        int count = fansMapper.selectCount(fans);
        return count;
    &#125;
&#125;
</code></pre>
<h3 id="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"><a href="#中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】" class="headerlink" title="中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】"></a>中国地图粉丝地域分布数量展示【数据可视化-粉丝画像】</h3><h3 id="男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1"><a href="#男女比例柱状图-饼状图显示【数据可视化-粉丝画像】Echarts-1" class="headerlink" title="男女比例柱状图_饼状图显示【数据可视化-粉丝画像】Echarts"></a>男女比例柱状图_饼状图显示【数据可视化-粉丝画像】<del>Echarts</del></h3><p><a target="_blank" rel="noopener" href="https://echarts.apache.org/zh/index.html">Apache ECharts</a> + 前端 [myFansCharts-static.html + myFansCharts.html]</p>
<pre><code class="java">service-api  com/imooc/api/controller/user/MyFansControllerApi.java
@ApiOperation(value = &quot;根据地域查询粉丝数量&quot;, notes = &quot;根据地域查询粉丝数量&quot;, httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/queryRatioByRegion&quot;)
    public GraceJSONResult queryRatioByRegion(@RequestParam String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/MyFansController.java
@RestController
public class MyFansController extends BaseController implements MyFansControllerApi &#123;
  @Override
    public GraceJSONResult queryRatioByRegion(String writerId) &#123;
        return GraceJSONResult.ok(myFansService.queryRegionRatioCounts(writerId));
    &#125;
&#125;
=====================================================================
将fans里的writer_id【自己的cookie里的uid 属于自己的属性 对应着右面的province省份】
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/MyFansService.java
package com.imooc.user.service;

import com.imooc.utils.PagedGridResult;

public interface MyFansService &#123;
     /**
     * 查询粉丝数
     */
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId);
&#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/service/impl/MyFansServiceImpl.java
@Service
public class MyFansServiceImpl extends BaseService implements MyFansService &#123;
@Override
    public List&lt;RegionRatioVO&gt; queryRegionRatioCounts(String writerId) &#123;
        Fans fans = new Fans();
        fans.setWriterId(writerId);

        List&lt;RegionRatioVO&gt; list = new ArrayList&lt;&gt;();
        for (String r : regions) &#123;
            fans.setProvince(r);
            Integer count = fansMapper.selectCount(fans);

            RegionRatioVO regionRatioVO = new RegionRatioVO();
            regionRatioVO.setName(r);
            regionRatioVO.setValue(count);

            list.add(regionRatioVO);
        &#125;
        return list;
    &#125;

    public static final String[] regions = &#123;&quot;北京&quot;, &quot;天津&quot;, &quot;上海&quot;, &quot;重庆&quot;,
            &quot;河北&quot;, &quot;山西&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;, &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;,
            &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;, &quot;广东&quot;, &quot;海南&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;, &quot;台湾&quot;,
            &quot;内蒙古&quot;, &quot;广西&quot;, &quot;西藏&quot;, &quot;宁夏&quot;, &quot;新疆&quot;,
            &quot;香港&quot;, &quot;澳门&quot;&#125;;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/RegionRatioVO.java
package com.imooc.pojo.vo;

public class RegionRatioVO &#123;

    private String name;
    private Integer value;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Integer getValue() &#123;
        return value;
    &#125;

    public void setValue(Integer value) &#123;
        this.value = value;
    &#125;
&#125;
</code></pre>
<h2 id="开发文章详情接口-【章节概述】detail-html"><a href="#开发文章详情接口-【章节概述】detail-html" class="headerlink" title="开发文章详情接口 【章节概述】detail.html"></a>开发文章详情接口 【章节概述】<del>detail.html</del></h2><ul>
<li><strong>文章详情页</strong></li>
<li><strong>文章评论模块</strong></li>
<li><strong>评论管理</strong></li>
</ul>
<h3 id="文章详情页"><a href="#文章详情页" class="headerlink" title="文章详情页"></a>文章详情页</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
 @GetMapping(&quot;detail&quot;)
    @ApiOperation(value = &quot;文章详情查询&quot;, notes = &quot;文章详情查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult detail(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts(
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
    /**
     * 查询文章详情
     */
    public ArticleDetailVO queryDetail(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticlePortalServiceImpl.java
    @Override
    public ArticleDetailVO queryDetail(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(YesOrNo.NO.type);
        article.setIsDelete(YesOrNo.NO.type);
        article.setArticleStatus(ArticleReviewStatus.SUCCESS.type);

        Article result = articleMapper.selectOne(article);
        ArticleDetailVO detailVO = new ArticleDetailVO();
        BeanUtils.copyProperties(result, detailVO);
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
package com.imooc.pojo.vo;

import com.fasterxml.jackson.annotation.JsonFormat;

import java.util.Date;

public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="阅读文章-阅读量redis累加【详情页】"><a href="#阅读文章-阅读量redis累加【详情页】" class="headerlink" title="阅读文章_阅读量redis累加【详情页】"></a>阅读文章_阅读量redis累加【详情页】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
  @Override
    public GraceJSONResult detail(String articleId) &#123;
        ArticleDetailVO detailVO = articlePortalService.queryDetail(articleId);

        Set&lt;String&gt; idSet = new HashSet();
        idSet.add(detailVO.getPublishUserId());
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        if (!publisherList.isEmpty()) &#123;
            detailVO.setPublishUserName(publisherList.get(0).getNickname());
        &#125;

        detailVO.setReadCounts( //去redis获取值 关联到前端阅读量增加 关联！！！
                getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId));

        return GraceJSONResult.ok(detailVO);
    &#125;

    @Override
    public GraceJSONResult readArticle(String articleId) &#123;
        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
==================================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240721DDAHBPWG0H
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticlePortalService.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<h3 id="文章阅读数防刷策略【详情页】"><a href="#文章阅读数防刷策略【详情页】" class="headerlink" title="文章阅读数防刷策略【详情页】"></a>文章阅读数防刷策略【详情页】</h3><blockquote>
<p>限定id去做增加 readArticle中增加拦截器<br>在ArticlePortalControllerApi.java中的readArticle接口 增加 HttpServletRequest request</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@PostMapping(&quot;readArticle&quot;)
    @ApiOperation(value = &quot;阅读文章，文章阅读量累加&quot;, notes = &quot;阅读文章，文章阅读量累加&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult readArticle(@RequestParam String articleId, HttpServletRequest request);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public GraceJSONResult readArticle(String articleId, HttpServletRequest request) &#123;
        String userIp = IPUtil.getRequestIp(request);
        // 设置针对当前用户ip的永久存在的key，存入redis，表示该ip的用户已经阅读过了 防刷策略
        redis.setnx(REDIS_ALREADY_READ + &quot;:&quot; + articleId + &quot;:&quot; + userIp, userIp);

        redis.increment(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId, 1);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/interceptors/ArticleReadInterceptor.java //【增加拦截器】
package com.imooc.api.interceptors;

import com.imooc.utils.IPUtil;
import com.imooc.utils.RedisOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ArticleReadInterceptor extends BaseInterceptor implements HandlerInterceptor &#123;

    @Autowired
    public RedisOperator redis;
    public static final String REDIS_ALREADY_READ = &quot;redis_already_read&quot;;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String articleId = request.getParameter(&quot;articleId&quot;);

        String userIp = IPUtil.getRequestIp(request);
        boolean isExist = redis.keyIsExist(REDIS_ALREADY_READ + &quot;:&quot; +  articleId + &quot;:&quot; + userIp);

        if (isExist) &#123;
            return false;
        &#125;
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/InterceptorConfig.java
package com.imooc.api.config;

import com.imooc.api.interceptors.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class InterceptorConfig implements WebMvcConfigurer &#123;
...
    @Bean
    public ArticleReadInterceptor articleReadInterceptor()&#123;
        return new ArticleReadInterceptor();
    &#125;

    @Override
    public void addInterceptors(InterceptorRegistry registry)&#123;//注册拦截器
...
        registry.addInterceptor(articleReadInterceptor())
                .addPathPatterns(&quot;/portal/article/readArticle&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="Redis-mget-批量查询组装阅读量并展示【文章列表】"><a href="#Redis-mget-批量查询组装阅读量并展示【文章列表】" class="headerlink" title="Redis mget 批量查询组装阅读量并展示【文章列表】"></a>Redis mget 批量查询组装阅读量并展示【文章列表】</h3><h5 id="Redis-get单个读取-amp-amp-Redis-mget批量读取"><a href="#Redis-get单个读取-amp-amp-Redis-mget批量读取" class="headerlink" title="Redis get单个读取 &amp;&amp; Redis mget批量读取"></a>Redis get单个读取 &amp;&amp; Redis mget批量读取</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/9d581a6e864d203ffb7157e6edd621ef947c4775/data/Redis_mget%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2.png"></p>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
 private PagedGridResult rebuildArticleGrid(PagedGridResult gridResult) &#123;
        // START
        List&lt;Article&gt; list = (List&lt;Article&gt;)gridResult.getRows();
        // 1. 构建发布者id列表
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        List&lt;String&gt; idList = new ArrayList&lt;&gt;();
        for (Article a : list) &#123;
//            System.out.println(a.getPublishUserId());
            // 1.1 构建发布者的set
            idSet.add(a.getPublishUserId());
            // 1.2 构建文章id的list 包含所有key的值
            idList.add(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + a.getId());
        &#125;
        System.out.println(idSet.toString());
        // 发起redis的mget批量查询api，获得对应的值
        List&lt;String&gt; readCountsRedisList = redis.mget(idList);
        List&lt;AppUserVO&gt; publisherList = getPublisherList(idSet);

        // 3. 拼接两个list，重组文章列表
        List&lt;IndexArticleVO&gt; indexArticleList = new ArrayList&lt;&gt;();
        for (int i = 0 ; i &lt; list.size() ; i ++) &#123;
            IndexArticleVO indexArticleVO = new IndexArticleVO();
            Article a = list.get(i); //属性值拷贝
            BeanUtils.copyProperties(a, indexArticleVO);

            // 3.1 从publisherList中获得发布者的基本信息
            AppUserVO publisher  = getUserIfPublisher(a.getPublishUserId(), publisherList);
            indexArticleVO.setPublisherVO(publisher);

            // 3.2 重新组装设置文章列表中的阅读量
            String redisCountsStr = readCountsRedisList.get(i);
            int readCounts = 0;
            if (StringUtils.isNotBlank(redisCountsStr)) &#123;
                readCounts = Integer.valueOf(redisCountsStr);
            &#125;
            indexArticleVO.setReadCounts(readCounts);

            indexArticleList.add(indexArticleVO);
        &#125;
        gridResult.setRows(indexArticleList);
// END
        return gridResult;
    &#125;
</code></pre>
<h3 id="用户发表评论【文章评论】"><a href="#用户发表评论【文章评论】" class="headerlink" title="用户发表评论【文章评论】"></a>用户发表评论【文章评论】</h3><pre><code class="xml">mybatis-generator-database generatorConfig-article.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;!-- 通用mapper所在目录 --&gt;
        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;com.imooc.my.mapper.MyMapper&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;
                        connectionURL=&quot;jdbc:mysql://localhost:3306/imooc-news-dev&quot;
                        userId=&quot;root&quot;
                        password=&quot;root&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 对应生成的pojo所在包 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.imooc.pojo&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot;/&gt;

        &lt;!-- 对应生成的mapper所在目录 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;mapper.article&quot; targetProject=&quot;mybatis-generator-database/src/main/resources&quot;/&gt;

        &lt;!-- 配置mapper对应的java映射 --&gt;
        &lt;javaClientGenerator targetPackage=&quot;com.imooc.article.mapper&quot; targetProject=&quot;mybatis-generator-database/src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt;

        &lt;!-- 数据库表 --&gt;
        &lt;table tableName=&quot;comments&quot;&gt;&lt;/table&gt;

    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="java">mybatis-generator-database  com/imooc/mybatis/utils/ArticleGenerator.java //【运行】
package com.imooc.mybatis.utils;

import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;


public class ArticleGenerator &#123;

    public void generator() throws Exception &#123;

        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();
        boolean overwrite = true;
        //指定 逆向工程配置文件
        File configFile = new File(&quot;mybatis-generator-database&quot;
                                            + File.separator
                                            + &quot;generatorConfig-article.xml&quot;);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,
                callback, warnings);
        myBatisGenerator.generate(null);

    &#125; 
    
    public static void main(String[] args) throws Exception &#123;
        try &#123;
            ArticleGenerator generatorSqlmap = new ArticleGenerator();
            generatorSqlmap.generator();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;

public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;

================================================================

</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserFace&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot;&gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;writerId&quot; /&gt;
    &lt;result column=&quot;father_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;fatherId&quot; /&gt;
    &lt;result column=&quot;article_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleId&quot; /&gt;
    &lt;result column=&quot;article_title&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleTitle&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;articleCover&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserId&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;commentUserNickname&quot; /&gt;
    &lt;result column=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
...[未完待续]
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/bo/CommentReplyBO.java
/**
 * 文章留言的BO
 */
public class CommentReplyBO &#123;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String articleId;

    @NotBlank(message = &quot;留言信息不完整&quot;)
    private String fatherId;

    @NotBlank(message = &quot;当前用户信息不正确，请尝试重新登录&quot;)
    private String commentUserId;

    @NotBlank(message = &quot;留言内容不能为空&quot;)
    @Length(max = 50, message = &quot;文章内容长度不能超过50&quot;)
    private String content;
&#125;Getter + Setter + ToString
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

    /**
     * 冗余的用户头像
     */
    @Column(name = &quot;comment_user_face&quot;)
    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
</code></pre>
<h3 id="用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了"><a href="#用户评论入库保存【文章评论】这里暂时把数据库的comment-user-face删除了" class="headerlink" title="用户评论入库保存【文章评论】这里暂时把数据库的comment_user_face删除了"></a>用户评论入库保存【文章评论】<del>这里暂时把数据库的comment_user_face删除了</del></h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;

    @PostMapping(&quot;createComment&quot;)
    @ApiOperation(value = &quot;用户评论&quot;, notes = &quot;用户评论&quot;, httpMethod = &quot;POST&quot;) //@Valid是做验证的
    public GraceJSONResult createArticle(@RequestBody @Valid CommentReplyBO commentReplyBO, BindingResult result);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@RestController
public class CommentController extends BaseController implements CommentControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(CommentController.class);
    @Autowired
    private CommentPortalService commentPortalService;

    @Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname);

        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
public interface CommentPortalService &#123;
    /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
package com.imooc.article.service.impl;

import com.imooc.api.service.BaseService;
import com.imooc.article.mapper.CommentsMapper;
import com.imooc.article.service.ArticlePortalService;
import com.imooc.article.service.CommentPortalService;
import com.imooc.pojo.Comments;
import com.imooc.pojo.vo.ArticleDetailVO;
import com.imooc.utils.PagedGridResult;
import org.n3r.idworker.Sid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;


@Service
public class CommentPortalServiceImpl extends BaseService implements CommentPortalService &#123;
    @Autowired
    private ArticlePortalService articlePortalService;
    @Autowired
    private Sid sid;
    @Autowired
    private CommentsMapper commentsMapper;

    @Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Comments.java
public class Comments &#123;
    @Id
    private String id;

    /**
     * 评论的文章是哪个作者的关联id
     */
    @Column(name = &quot;writer_id&quot;)
    private String writerId;

    /**
     * 如果是回复留言，则本条为子留言，需要关联查询
     */
    @Column(name = &quot;father_id&quot;)
    private String fatherId;

    /**
     * 回复的那个文章id
     */
    @Column(name = &quot;article_id&quot;)
    private String articleId;

    /**
     * 冗余文章标题，宽表处理，非规范化的sql思维，对于几百万文章和几百万评论的关联查询来讲，性能肯定不行，所以做宽表处理，从业务角度来说，文章发布以后不能随便修改标题和封面的
     */
    @Column(name = &quot;article_title&quot;)
    private String articleTitle;

    /**
     * 文章封面
     */
    @Column(name = &quot;article_cover&quot;)
    private String articleCover;

    /**
     * 发布留言的用户id
     */
    @Column(name = &quot;comment_user_id&quot;)
    private String commentUserId;

    /**
     * 冗余用户昵称，非一致性字段，用户修改昵称后可以不用同步
     */
    @Column(name = &quot;comment_user_nickname&quot;)
    private String commentUserNickname;

//    /**
//     * 冗余的用户头像
//     */
//    @Column(name = &quot;comment_user_face&quot;)
//    private String commentUserFace;

    /**
     * 留言内容
     */
    private String content;

    /**
     * 留言时间
     */
    @Column(name = &quot;create_time&quot;)
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/BaseController.java
public List&lt;AppUserVO&gt; getBasicUserList(Set idSet) &#123;
        String userServerUrlExecute
                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; userVOList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            userVOList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return userVOList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapper.java
package com.imooc.article.mapper;

import com.imooc.my.mapper.MyMapper;
import com.imooc.pojo.Comments;
import org.springframework.stereotype.Repository;

@Repository
public interface CommentsMapper extends MyMapper&lt;Comments&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">service-article  resources/mapper/CommentsMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="评论数累计与显示【文章评论】"><a href="#评论数累计与显示【文章评论】" class="headerlink" title="评论数累计与显示【文章评论】"></a>评论数累计与显示【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
@Api(value = &quot;评论相关业务的controller&quot;, tags = &#123;&quot;评论相关业务的controller&quot;&#125;)
@RequestMapping(&quot;comment&quot;)
public interface CommentControllerApi &#123;
@GetMapping(&quot;counts&quot;)
    @ApiOperation(value = &quot;用户评论数查询&quot;, notes = &quot;用户评论数查询&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult commentCounts(@RequestParam String articleId);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult commentCounts(String articleId) &#123;
        Integer counts = getCountsFromRedis(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId);
        return GraceJSONResult.ok(counts);
    &#125;

--------------------------------------------------------------------------
service-api  com/imooc/api/BaseController.java
public Integer getCountsFromRedis(String key)&#123;
        String countsStr = redis.get(key);
        if (StringUtils.isBlank(countsStr)) &#123;
            countsStr = &quot;0&quot;;
        &#125;
        return Integer.valueOf(countsStr);
    &#125;
</code></pre>
<h3 id="文章评论sql关联查询father-id…"><a href="#文章评论sql关联查询father-id…" class="headerlink" title="文章评论sql关联查询father_id…"></a>文章评论sql关联查询<del>father_id…</del></h3><pre><code class="mysql">【多表关联查询】
SELECT
    c.id as commentId,
    c.father_id as fatherId,
    c.comment_user_id as commentUserId,
    c.comment_user_nickname as commentUserNickname,
    c.article_id as articleId,
    c.content as content,
    c.create_time as createTime,
    f.comment_user_nickname as quoteUserNickname,
    f.content as quoteContent
FROM
    comments c
LEFT JOIN
    comments f
ON
    c.father_id = f.id
WHERE
    c.article_id = &#39;2006117B57WRZGHH&#39;
ORDER BY
    c.create_time
DESC
</code></pre>
<h3 id="显示评论列表【文章评论】"><a href="#显示评论列表【文章评论】" class="headerlink" title="显示评论列表【文章评论】"></a>显示评论列表【文章评论】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
com/imooc/api/controller/article/CommentControllerApi.java 
@GetMapping(&quot;list&quot;)
    @ApiOperation(value = &quot;查询文章的所有评论列表&quot;, notes = &quot;查询文章的所有评论列表&quot;, httpMethod = &quot;GET&quot;)
    public GraceJSONResult list(@RequestParam String articleId,
                                @RequestParam Integer page,
                                @RequestParam Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
@Override
    public GraceJSONResult list(String articleId, Integer page, Integer pageSize) &#123;
        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;

        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;
        PagedGridResult gridResult = commentPortalService.queryArticleComments(articleId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;
==============================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=200816961ZYBXFRP
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
/**
     * 查询文章评论列表
     */
    public PagedGridResult queryArticleComments(String articleId,
                                                Integer page,
                                                Integer pageSize);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/mapper/CommentsMapperCustom.java
package com.imooc.article.mapper;

import com.imooc.pojo.vo.CommentsVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public interface CommentsMapperCustom &#123;

    /**
     * 查询文章评论
     */
    public List&lt;CommentsVO&gt; queryArticleCommentList(@Param(&quot;paramMap&quot;) Map&lt;String, Object&gt; map);

&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryArticleComments(String articleId, Integer page, Integer pageSize) &#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleId&quot;, articleId);

        PageHelper.startPage(page, pageSize);
        List&lt;CommentsVO&gt; list = commentsMapperCustom.queryArticleCommentList(map);
        return setterPagedGrid(list,page);
    &#125;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【把关于face的字段都删掉】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="作业-管理评论列表以及删除评论【评论管理】"><a href="#作业-管理评论列表以及删除评论【评论管理】" class="headerlink" title="(作业) 管理评论列表以及删除评论【评论管理】"></a>(作业) 管理评论列表以及删除评论【评论管理】</h3><blockquote>
<p>前端的commentMng.html的VUE有问题<br>需要增加定义userInfo<br>var mainPage &#x3D; new Vue({<br>        el: “#mainPage”,<br>data: {<br>            userInfo: {<br>                activeStatus: 0<br>            },<br>}…</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/CommentControllerApi.java
    @PostMapping(&quot;mng&quot;)
    @ApiOperation(value = &quot;查询我的评论管理列表&quot;, notes = &quot;查询我的评论管理列表&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult mng(@RequestParam String writerId,
                               @ApiParam(name = &quot;page&quot;, value = &quot;查询下一页的第几页&quot;, required = false)
                               @RequestParam Integer page,
                               @ApiParam(name = &quot;pageSize&quot;, value = &quot;分页的每一页显示的条数&quot;, required = false)
                               @RequestParam Integer pageSize);


    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(value = &quot;作者删除评论&quot;, notes = &quot;作者删除评论&quot;, httpMethod = &quot;POST&quot;)
    public GraceJSONResult delete(@RequestParam String writerId,
                                  @RequestParam String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java
 @Override
    public GraceJSONResult mng(String writerId, Integer page, Integer pageSize) &#123;

        if (page == null) &#123;
            page = COMMON_START_PAGE;
        &#125;
        if (pageSize == null) &#123;
            pageSize = COMMON_PAGE_SIZE;
        &#125;

        PagedGridResult gridResult = commentPortalService.queryWriterCommentsMng(writerId, page, pageSize);
        return GraceJSONResult.ok(gridResult);
    &#125;

    @Override
    public GraceJSONResult delete(String writerId, String commentId) &#123;
        commentPortalService.deleteComment(writerId, commentId);
        return GraceJSONResult.ok();
    &#125;
==============================================================
http://writer.imoocnews.com:9090/imooc-news/writer/commentMng.html
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java
     /**
     * 查询我的评论管理列表
     */
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize);

    /**
     * 删除评论
     */
    public void deleteComment(String writerId, String commentId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
@Override
    public PagedGridResult queryWriterCommentsMng(String writerId, Integer page, Integer pageSize) &#123;
        Comments comment = new Comments();
        comment.setWriterId(writerId);
        PageHelper.startPage(page, pageSize);
        List&lt;Comments&gt; list = commentsMapper.select(comment);
        return setterPagedGrid(list,page);
    &#125;

    @Override
    public void deleteComment(String writerId, String commentId) &#123;
        Comments comment = new Comments();
        comment.setId(commentId);
        comment.setWriterId(writerId);
        commentsMapper.delete(comment);
    &#125;
</code></pre>
<h3 id="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face"><a href="#增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment-user-face" class="headerlink" title="增加评论者头像展示功能需求扩展【文章评论】增加需求字段comment_user_face"></a>增加评论者头像展示功能需求扩展【文章评论】<del>增加需求字段comment_user_face</del></h3><blockquote>
<p>[数据库添加一个新的字段comment_user_face 重新在mybatis-generator-database进行逆向生成覆盖]<br>涉及范围广</p>
<p>在数据库里也要加个字段  在前端需求也要改一下头像</p>
</blockquote>
<pre><code class="html">detail.html
&lt;div class=&quot;all-comments-list&quot; v-for=&quot;(comment,index) in commentList&quot; :key=&quot;index&quot;&gt;
        &lt;div class=&quot;single-comment-wrapper&quot;&gt;
        &lt;!--&lt;img src=&quot;./img/face1.png&quot; class=&quot;user-face&quot;/&gt;--&gt;
        &lt;img :src=&quot;comment.commentUserFace&quot; class=&quot;user-face&quot;/&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapper.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapper&quot; &gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.pojo.Comments&quot; &gt;
    &lt;!--
      WARNING - @mbg.generated
    --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;writer_id&quot; property=&quot;writerId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;father_id&quot; property=&quot;fatherId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_id&quot; property=&quot;articleId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_title&quot; property=&quot;articleTitle&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;article_cover&quot; property=&quot;articleCover&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_id&quot; property=&quot;commentUserId&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_nickname&quot; property=&quot;commentUserNickname&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;comment_user_face&quot; property=&quot;commentUserFace&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;content&quot; property=&quot;content&quot; jdbcType=&quot;VARCHAR&quot; /&gt;
    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="mysql">service-article  resources/mapper/CommentsMapperCustom.xml #【增加字段】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;
&lt;mapper namespace=&quot;com.imooc.article.mapper.CommentsMapperCustom&quot; &gt;

  &lt;select id=&quot;queryArticleCommentList&quot;
          resultType=&quot;com.imooc.pojo.vo.CommentsVO&quot;
          parameterType=&quot;Map&quot;&gt;

    SELECT
      c.id as commentId,
      c.father_id as fatherId,
      c.comment_user_id as commentUserId,
      c.comment_user_nickname as commentUserNickname,
      c.comment_user_face as commentUserFace,
      c.article_id as articleId,
      c.content as content,
      c.create_time as createTime,
      f.comment_user_nickname as quoteUserNickname,
      f.content as quoteContent
    FROM
      comments c
        LEFT JOIN
      comments f
      ON
        c.father_id = f.id
    WHERE
      c.article_id = #&#123;paramMap.articleId&#125;
    ORDER BY
      c.create_time
            DESC

  &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/CommentPortalService.java //【增加字段】
 /**
     * 发表评论
     */
    public void createComment(String articleId,
                              String fatherCommentId,
                              String content,
                              String userId,
                              String nickname,
                              String face);
</code></pre>
<pre><code class="java">------------------------------------------------------------
dev-model  com/imooc/pojo/vo/CommentsVO.java //【增加字段属性】
private String commentUserFace;
    【Getter + Setter】

------------------------------------------------------------
dev-model  com/imooc/pojo/Comments.java
/**
     * 冗余的用户头像
     */
@Column(name = &quot;comment_user_face&quot;)
private String commentUserFace;
    【Getter + Setter】
------------------------------------------------------------
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/CommentController.java 
    //【增加 String face = getBasicUserList(idSet).get(0).getFace();】
@Override
    public GraceJSONResult createArticle(@Valid CommentReplyBO commentReplyBO,
                                         BindingResult result) &#123;
        // 0. 判断BindingResult是否保存错误的验证信息，如果有，则直接return
        if (result.hasErrors()) &#123;
            Map&lt;String, String&gt; errorMap = getErrors(result);
            return GraceJSONResult.errorMap(errorMap);
        &#125;

        // 1. 根据留言用户的id查询他的昵称，用于存入到数据表进行字段的冗余处理，从而避免多表关联查询的性能影响
        String userId = commentReplyBO.getCommentUserId();

        // 2. 发起restTemplate调用用户服务，获得用户侧昵称
        Set&lt;String&gt; idSet = new HashSet&lt;&gt;();
        idSet.add(userId);
        String nickname = getBasicUserList(idSet).get(0).getNickname();
        String face = getBasicUserList(idSet).get(0).getFace();

        // 3. 保存用户评论的信息到数据库
        commentPortalService.createComment(commentReplyBO.getArticleId(), commentReplyBO.getFatherId(), commentReplyBO.getContent(), userId, nickname,face);

        return GraceJSONResult.ok();
    &#125;
====================================================
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=2006116Z3MAP8SW0
//下面有个评论：牛逼  带着自己上传的头像
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/CommentPortalServiceImpl.java
    //【增加 comments.setCommentUserFace(face);】
@Transactional
    @Override
    public void createComment(String articleId, String fatherCommentId, String content, String userId, String nickname,String face) &#123;
        String commentId = sid.nextShort();
        ArticleDetailVO article = articlePortalService.queryDetail(articleId);
        Comments comments = new Comments();
        comments.setId(commentId);

        comments.setWriterId(article.getPublishUserId());
        comments.setArticleTitle(article.getTitle());
        comments.setArticleCover(article.getCover());
        comments.setArticleId(articleId);

        comments.setFatherId(fatherCommentId);
        comments.setCommentUserId(userId);
        comments.setCommentUserNickname(nickname);
        comments.setCommentUserFace(face);

        comments.setContent(content);
        comments.setCreateTime(new Date());

        commentsMapper.insert(comments);

        // 评论数累加
        redis.increment(REDIS_ARTICLE_COMMENT_COUNTS + &quot;:&quot; + articleId, 1);
    &#125;
</code></pre>
<h3 id="文章静态化技术与Freemarker【文章概述】"><a href="#文章静态化技术与Freemarker【文章概述】" class="headerlink" title="文章静态化技术与Freemarker【文章概述】"></a>文章静态化技术与Freemarker【文章概述】</h3><ul>
<li><strong>页面静态化</strong></li>
<li><strong>Freemarker静态化技术</strong></li>
<li><strong>渲染模板数据</strong></li>
<li><strong>生成并展示静态页面</strong></li>
</ul>
<h5 id="静态化趋势"><a href="#静态化趋势" class="headerlink" title="静态化趋势"></a>静态化趋势</h5><ul>
<li><strong>便于SEO</strong></li>
<li><strong>加速用户访问</strong></li>
<li><strong>降低数据库压力</strong></li>
</ul>
<h5 id="模板引擎技术"><a href="#模板引擎技术" class="headerlink" title="模板引擎技术"></a>模板引擎技术</h5><ul>
<li><strong>JSP</strong></li>
<li><strong>Freemarker</strong></li>
<li><strong>Thymeleaf</strong></li>
<li><strong>Velocity</strong></li>
</ul>
<h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/1f57d8e494be53fe2ee4745f819db41fe1e7173a/data/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96.png"></p>
<h3 id="创建并且显示模板ftl"><a href="#创建并且显示模板ftl" class="headerlink" title="创建并且显示模板ftl"></a>创建并且显示模板ftl</h3><pre><code class="xml">service-article  pom.xml
 &lt;!-- freemarker 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml 【suffix是模板后缀】
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hello Freemarker&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;#-- 
        写完以后去模板页面配置 application.yml
        Freemarker 页面的语法构成：
        1. 注释
        2. 表达式 $&#123;...&#125;
        3. 普通文本，基本的html标签
        4. 指令
    --&gt;
        &lt;div&gt;
            hello $&#123;there&#125;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出对象【Freemarker语法】"><a href="#输出对象【Freemarker语法】" class="headerlink" title="输出对象【Freemarker语法】"></a>输出对象【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;
    private Spouse spouse;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);
        stu.setSpouse(spouse);
        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

Hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:13:05
用户余额：88.86
已育：yes
伴侣：Lucy,25岁
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="输出list与map【Freemarker语法】"><a href="#输出list与map【Freemarker语法】" class="headerlink" title="输出list与map【Freemarker语法】"></a>输出list与map【Freemarker语法】</h3><pre><code class="java">dev-model  com/imooc/pojo/Stu.java
public class Stu &#123;
    private String uid;
    private String username;
    private Integer age;
    private Date birthday;
    private Float amount;
    private boolean haveChild;

    private Spouse spouse;

    private List&lt;Article&gt; articleList;
    private Map&lt;String, String&gt; parents;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/Spouse.java
public class Spouse &#123;
    private String username;
    private Integer age;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        // 定义输出到模板的内容
        // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);

        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
==================================================================
http://localhost:8001/free/hello

hello 慕课网 imooc.com

用户名uid: 10010
用户姓名: imooc
年龄：18
生日：2024-07-29 15:39:07
用户余额：88.86
已育：yes
伴侣：Lucy,25岁

1001 今天天气不错
1002 今天下雨了
1003 昨天下雨了

LiLi
XiaoMing
</code></pre>
<pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        伴侣：$&#123;stu.spouse.username&#125;,$&#123;stu.spouse.age&#125;岁
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="指令if【Freemarker语法】"><a href="#指令if【Freemarker语法】" class="headerlink" title="指令if【Freemarker语法】"></a>指令if【Freemarker语法】</h3><pre><code class="html">service-article  resources/templates/stu.ftl
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello Freemarker&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;#-- 
    写完以后去模板页面配置 application.yml
    Freemarker 页面的语法构成：
    1. 注释
    2. 表达式 $&#123;...&#125;
    3. 普通文本，基本的html标签
    4. 指令
--&gt;
    &lt;div&gt;
        hello $&#123;there&#125;
    &lt;/div&gt;
&lt;br&gt;

    &lt;div&gt;
        用户名uid: $&#123;stu.uid&#125;&lt;br&gt;
        用户姓名: $&#123;stu.username&#125;&lt;br&gt;
        年龄：$&#123;stu.age&#125;&lt;br&gt;
        生日：$&#123;stu.birthday?string(&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&lt;br&gt; &lt;#-- 日期转换 --&gt;
        用户余额：$&#123;stu.amount&#125;&lt;br&gt;
        已育：$&#123;stu.haveChild?string(&#39;yes&#39;, &#39;no&#39;)&#125;&lt;br&gt;
        &lt;#if stu.spouse??&gt;
            伴侣：$&#123;stu.spouse.username&#125;, $&#123;stu.spouse.age&#125;岁
        &lt;/#if&gt;
        &lt;#if !stu.spouse??&gt;
            单身狗
        &lt;/#if&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.articleList as article&gt;
            &lt;div&gt;
                &lt;span&gt;$&#123;article.id&#125;&lt;/span&gt;
                &lt;span&gt;$&#123;article.title&#125;&lt;/span&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#list stu.parents?keys as key&gt;
            &lt;div&gt;
                $&#123;stu.parents[key]&#125;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;

&lt;br&gt;

    &lt;div&gt;
        &lt;#if stu.uid == &#39;10010&#39;&gt;
            用户id是10010
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.username != &#39;imooc&#39;&gt;
            用户名不是imooc
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &gt;= 18) &gt;
            用户已成年
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if (stu.age &gt; 18 || stu.age = 18) &gt;
            成年人
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if (stu.age &lt; 18) &gt;
            未成年
            &lt;br&gt;
        &lt;/#if&gt;
        &lt;#if stu.haveChild &gt;
            已育
        &lt;/#if&gt;
        &lt;br&gt;
        &lt;#if !stu.haveChild &gt;
             未育
        &lt;/#if&gt;
     &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span style = "color:red">在这里特别注意一下 已经开始第二阶段的代码 进阶篇 所以前端的代码也是需要更新换代的 包括..&#x2F;js&#x2F;app.js里面多了 app.getPageName();</span><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/224939.html">生成的html调用app.js中getPageName()函数出错的问题-慕课网 (imooc.com)</a></p>
<h3 id="结合动态数据生成静态化HTML【Freemarker】"><a href="#结合动态数据生成静态化HTML【Freemarker】" class="headerlink" title="结合动态数据生成静态化HTML【Freemarker】"></a>结合动态数据生成静态化HTML【Freemarker】</h3><pre><code class="java">service-article  com/imooc/article/controller/FreemarkerController.java
【stu.ftl如上图不变增加java的整合代码】 俗称Java+ftl=HTML
package com.imooc.article.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.Article;
import com.imooc.pojo.Spouse;
import com.imooc.pojo.Stu;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

@Controller
@RequestMapping(&quot;free&quot;)
public class FreemarkerController&#123;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String htmlTarget;

    @GetMapping(&quot;/createHTML&quot;)
    @ResponseBody
    public String createHTML(Model model) throws IOException, TemplateException &#123;
        // 0. 配置freemarker基本环境
        Configuration cfg = new Configuration(Configuration.getVersion());
        // 声明freemarker模板所需要加载的目录的位置
            //resources/templates/stu.ftl
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File((classpath + &quot;templates&quot;)));

            // 测试打印
        System.out.println(htmlTarget);
        System.out.println(classpath + &quot;templates&quot;);
        /**
         * /workspace/freemarker_html
         * /C:/Users/Pluminary/Desktop/backup/imooc-news-dev/imooc-news-dev-service-article/target/classes/templates
         */
        // 1. 获得现有的模板ftl文件
        Template template = cfg.getTemplate(&quot;stu.ftl&quot;, &quot;utf-8&quot;);

        // 2. 获得动态数据
            // 定义输出到模板的内容
            // 输入字符串
        String stranger = &quot;慕课网 imooc.com&quot;;
        model.addAttribute(&quot;there&quot;, stranger);
        model = makeModel(model);

        // 3. 融合动态数据和ftl，生成html
        File tempDic = new File(htmlTarget);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;
        Writer out = new FileWriter(htmlTarget + File.separator + &quot;10010&quot; + &quot;.html&quot;);
        template.process(model, out);
        out.close();
        return &quot;ok&quot;;
        // C:\workspace\freemarker_html\10010.html 里面的数据都是静态数据
    &#125;

    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        makeModel(model);
        // 返回的stu是freemarker模板所在的目录 classpath:/templates/
        // 匹配 *.ftl
        return &quot;stu&quot;;
    &#125;

    private Model makeModel(Model model) &#123;
        Stu stu = new Stu();
        stu.setUid(&quot;10010&quot;);
        stu.setUsername(&quot;imooc&quot;);
        stu.setAmount(88.86f);
        stu.setAge(18);
        stu.setHaveChild(true);
        stu.setBirthday(new Date());

        Spouse spouse = new Spouse();
        spouse.setUsername(&quot;Lucy&quot;);
        spouse.setAge(25);

        stu.setSpouse(spouse);
        stu.setArticleList(getArticles());
        stu.setParents(getParents());

        model.addAttribute(&quot;stu&quot;,stu);
        return model;
    &#125;

    private List&lt;Article&gt; getArticles()&#123;
        Article article1 = new Article();
        article1.setId(&quot;1001&quot;);
        article1.setTitle(&quot;今天天气不错&quot;);

        Article article2 = new Article();
        article2.setId(&quot;1002&quot;);
        article2.setTitle(&quot;今天下雨了&quot;);

        Article article3 = new Article();
        article3.setId(&quot;1003&quot;);
        article3.setTitle(&quot;昨天下雨了&quot;);

        List&lt;Article&gt; list = new ArrayList&lt;&gt;();
        list.add(article1);
        list.add(article2);
        list.add(article3);
        return list;
    &#125;

    private Map&lt;String, String&gt; getParents()&#123;
        Map&lt;String, String&gt; parents = new HashMap&lt;&gt;();
        parents.put(&quot;father&quot;, &quot;XiaoMing&quot;);
        parents.put(&quot;mother&quot;, &quot;LiLi&quot;);
        return parents;
    &#125;
&#125;
</code></pre>
<h3 id="改写详情页为模板页ftl【页面静态化】"><a href="#改写详情页为模板页ftl【页面静态化】" class="headerlink" title="改写详情页为模板页ftl【页面静态化】"></a>改写详情页为模板页ftl【页面静态化】</h3><blockquote>
<p>地址页不是拼接   将detail.html 的路径都变成绝对路径</p>
<!--<link rel="shortcut icon" href="img/mu-toutiao.ico" />-->
<pre><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;../img/mu-toutiao.ico&quot; /&gt;
</code></pre>
<p>把其拷贝到 resources&#x2F;templates&#x2F;detail.ftl</p>
</blockquote>
<pre><code class="html">【放在d盘 tomcat/webapps中的】detail.ftl
&lt;div class=&quot;big-title&quot;&gt;
     $&#123;articleDetail.title&#125;
&lt;/div&gt;
    &lt;div class=&quot;read-counts&quot; v-show=&quot;articleDetail.readCounts != &#39;&#39; &amp;&amp; articleDetail.readCounts != null&quot;&gt;
     阅读量：$&#123;articleDetail.readCounts&#125;
    &lt;/div&gt;
......
&lt;div class=&quot;date-title&quot;&gt;
       &lt;span class=&quot;year&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;yyyy&#39;)&#125;&lt;/span&gt;
 &lt;/div&gt;
      &lt;div class=&quot;back-year-line&quot;&gt;&lt;/div&gt;

      &lt;div class=&quot;date-md&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;MM/dd&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;date-times&quot;&gt;$&#123;articleDetail.publishTime?string(&#39;HH:mm:ss&#39;)&#125;&lt;/div&gt;

      &lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;$&#123;articleDetail.publishUserId&#125;&#39;)&quot;&gt;
                        $&#123;articleDetail.publishUserName&#125;
                    &lt;/div&gt;
.....
&lt;div class=&quot;article-wrapper&quot;&gt;
   &lt;div class=&quot;content&quot;&gt;
        $&#123;articleDetail.content&#125;
   &lt;/div&gt;
&lt;div class=&quot;declare&quot;&gt;
      免责声明：本平台所有内容仅供测试，且文章来自互联网，不代表慕课网的观点和立场，如有不妥，请联系后删除。
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="文章详情ftl生成静态化页面【页面静态化】"><a href="#文章详情ftl生成静态化页面【页面静态化】" class="headerlink" title="文章详情ftl生成静态化页面【页面静态化】"></a>文章详情ftl生成静态化页面【页面静态化】</h3><pre><code class="yaml">freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="java">dev-model  com/imooc/pojo/vo/ArticleDetailVO.java
public class ArticleDetailVO &#123;

    private String id;
    private String title;
    private String cover;
    private Integer categoryId;
    private String categoryName;
    private String publishUserId;
    @JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date publishTime;
    private String content;

    private String publishUserName;
    private Integer readCounts;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);
        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
                 createArticleHTML(articleId);
//                String articleMongoId = createArticleHTMLToGridF(articleId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;

    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;
    // 发起远程调用rest，获得文章详情数据
    public ArticleDetailVO getArticleDetail(String articleId) &#123;
        String url
                = &quot;http://www.imoocnews.com:8001/portal/article/detail?articleId=&quot; + articleId;
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(url, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        ArticleDetailVO detailVO = null;
        if (bodyResult.getStatus() == 200) &#123;
            String detailJson = JsonUtils.objectToJson(bodyResult.getData());
            detailVO = JsonUtils.jsonToPojo(detailJson, ArticleDetailVO.class);
        &#125;
        return detailVO;
    &#125;
</code></pre>
<pre><code class="java">先去发表头条http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html
再去审核通过http://www.imoocnews.com:9090/imooc-news/admin/contentReview.html
此时运行后 就会有java+ftl=html静态页面在指定位置生成了
指定位置：D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a
生成了一个文件：240729D9S8683XP0.html  这里面就是刚刚发表头条的内容
此时下面的两个网站都可以打开同样的头条内容
http://www.imoocnews.com:9090/imooc-news/portal/a/240729D9S8683XP0.html
http://www.imoocnews.com:9090/imooc-news/portal/detail.html?articleId=240729D9S8683XP0

240729D9S8683XP0.html
&lt;div class=&quot;writer-name&quot; @click=&quot;showWriter(&#39;240629F21AK1BHX4&#39;)&quot;&gt;
      P_luminary
&lt;/div&gt;

// 跳转作家页面
showWriter(writerId) &#123;
    window.open(&quot;../writer.html?writerId=&quot; + writerId);
&#125;,
</code></pre>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/questiondetail/4daeRX4JGBRPnWEp.html">没有getPageName这个函数-慕课网 (imooc.com)</a></p>
<h3 id="文章阅读量detail单独获取并展示-【页面静态化】"><a href="#文章阅读量detail单独获取并展示-【页面静态化】" class="headerlink" title="文章阅读量detail单独获取并展示 【页面静态化】"></a>文章阅读量<del>detail</del>单独获取并展示 【页面静态化】</h3><p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FGXGSCRZ54.html">a5 (imoocnews.com)</a></p>
<pre><code class="java">【去前面代入阅读量】
 &lt;div class=&quot;read-counts&quot;&gt;
            阅读量：&#123;&#123;readCounts&#125;&#125;
        &lt;/div&gt;
【先定义readCounts初始量为0】
var articleList = new Vue(&#123;
        el: &quot;#detailContainer&quot;,
        data: &#123;
            nowReplyingFatherCommentId: 0,  // 根据当前用户正在回复的父commentId进行页面的留言看展示或隐藏
            userInfo: null,
            
            articleId: &quot;&quot;,
            articleDetail: &#123;&#125;,
            readCounts: 0,
        &#125;

// 获得文章阅读数
         this.getArticleReadCounts(articleId);

 // 获得文章阅读数
        getArticleReadCounts(articleId) &#123;
               var me = this;

               var articleServerUrl = app.articleServerUrl;
               axios.defaults.withCredentials = true;
               axios.get(articleServerUrl + &quot;/portal/article/readCounts?articleId=&quot; + articleId)
                .then(res =&gt; &#123;
                  // console.log(JSON.stringify(res.data));
                  this.readCounts = res.data;
                &#125;);
            &#125;,
//★★★★★★★★★★★★★★★★★★★★     ★★★★★★★★★★★★★★★★★★★★★★★\\
然后把这个临时页面修改的地方 移动到后端service-article  resources/templates/detail.ftl中
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
@Override
    public Integer readCounts(String articleId) &#123;
       return getCountsFromRedis(REDIS_ARTICLE_READ_COUNTS + &quot;:&quot; + articleId);
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticlePortalControllerApi.java
@GetMapping(&quot;readCounts&quot;)
    @ApiOperation(value = &quot;获得文章阅读数&quot;, notes = &quot;获得文章阅读数&quot;, httpMethod = &quot;GET&quot;)
    public Integer readCounts(@RequestParam String articleId);
</code></pre>
<p><a target="_blank" rel="noopener" href="http://www.imoocnews.com:9090/imooc-news/portal/a/240730FP00HHCF14.html">在这里折腾一天终于好了 文章:a6 (imoocnews.com)</a></p>
<p>9-10</p>
<h3 id="梳理生产端消费端与中间gridfs关系"><a href="#梳理生产端消费端与中间gridfs关系" class="headerlink" title="梳理生产端消费端与中间gridfs关系"></a>梳理生产端消费端与中间gridfs关系</h3><h5 id="静态化高度耦合"><a href="#静态化高度耦合" class="headerlink" title="静态化高度耦合"></a>静态化高度耦合</h5><blockquote>
<p>在本地电脑&#x2F;同一台服务器     &#x3D;&gt;     生成静态页面HTML →<del>(发布)</del> 前端</p>
</blockquote>
<h5 id="解耦静态化"><a href="#解耦静态化" class="headerlink" title="解耦静态化"></a>解耦静态化</h5><blockquote>
<p>后端服务器(生成静态页面HTML)  &#x3D;&gt;  GridFS  &lt;&#x3D;  前端服务器(前端HTML)<br>同时  后端服务器(生成静态页面HTML)  →  前端服务器(前端HTML)</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e63aeac9b0694f2fced26f0349e630e42e51ae54/data/%E9%9D%99%E6%80%81%E5%8C%96%E9%AB%98%E5%BA%A6%E8%80%A6%E5%90%88%E4%B8%8E%E8%A7%A3%E8%80%A6.png"></p>
<pre><code class="java">创建一个新的module =&gt; imooc-news-dev-service-article-html
把service-article中resources的application.yml /dev+prod.yml logback-spring.xml拷贝到article-html模块的resources中

############################################################
http://localhost:8002/hello
&#123;
    &quot;status&quot;: 200,
    &quot;msg&quot;: &quot;操作成功！&quot;,
    &quot;success&quot;: true,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="yaml">application.yml
############################################################
#
# article文章静态化服务
# web访问端口号  约定：8002
#
############################################################
server:
# port: 8003
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  profiles:
    active: dev # yml中配置文件的环境配置, dev:开发环境, test:测试环境, prod:生产环境
  application:
    name: service-article-html
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

  data:
    mongodb:
      uri: mongodb://root:root@192.168.170.135:27017
      database: imooc-news
  freemarker:
    charset: UTF-8
    content-type: text/html
    suffix: .ftl
    template-loader-path: classpath:/templates/

# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
</code></pre>
<pre><code class="yaml">application-dev.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379

## setup CN from java, This is resource
website:
  domain-name: imoocnews.com




application-prod.yml
server:
  port: 8002

spring:
  redis:
    database: 0
    host: 47.98.225.105
    port: 6379
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/Application.java
package com.imooc.article.html;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/HelloController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);

    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="生产端存储html道gridfs并关联文章表【静态化解耦】"><a href="#生产端存储html道gridfs并关联文章表【静态化解耦】" class="headerlink" title="生产端存储html道gridfs并关联文章表【静态化解耦】"></a>生产端存储html道gridfs并关联文章表【静态化解耦】</h3><h5 id="静态化解耦步骤"><a href="#静态化解耦步骤" class="headerlink" title="静态化解耦步骤"></a>静态化解耦步骤</h5><ul>
<li><strong>生成html，并上传到gridfs中</strong></li>
<li><strong>获得mongoFileId，关联保存到文章表中</strong></li>
<li><strong>调用消费端，下载gridfs的html进行发布</strong></li>
</ul>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
 /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
 @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
......
...
    @Value(&quot;$&#123;freemarker.html.target&#125;&quot;)
    private String articlePath;
    @Autowired
    private RestTemplate restTemplate;
    // 文章生成HTML
    public void createArticleHTML(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        File tempDic = new File(articlePath);
        if (!tempDic.exists()) &#123;
            tempDic.mkdirs();
        &#125;

        String path = articlePath + File.separator + detailVO.getId() + &quot;.html&quot;;

        Writer out = new FileWriter(path);
        template.process(map, out);
        out.close();
    &#125;

    @Autowired
    private GridFSBucket gridFSBucket;
    public String createArticleHTMLToGridFS(String articleId) throws IOException, TemplateException &#123;
        Configuration cfg = new Configuration(Configuration.getVersion());
        String classpath = this.getClass().getResource(&quot;/&quot;).getPath();
        cfg.setDirectoryForTemplateLoading(new File(classpath + &quot;templates&quot;));

        Template template = cfg.getTemplate(&quot;detail.ftl&quot;, &quot;utf-8&quot;);

        // 获得文章的详情数据
        ArticleDetailVO detailVO = getArticleDetail(articleId);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;articleDetail&quot;, detailVO);

        String htmlContent = FreeMarkerTemplateUtils.processTemplateIntoString(template, map);
//        System.out.println(htmlContent);

        InputStream inputStream = IOUtils.toInputStream(htmlContent);
        ObjectId fileId = gridFSBucket.uploadFromStream(detailVO.getId() + &quot;.html&quot;,inputStream);
        return fileId.toString();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/GridFSConfig.java
package com.imooc.article;

import com.mongodb.MongoClient;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.client.gridfs.GridFSBuckets;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

@Component //可以被容器访问到
public class GridFSConfig &#123;
    @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;)
    private String mongodb;

    @Bean
    public GridFSBucket gridFSBucket(MongoClient mongoClient)&#123;
        MongoDatabase mongoDatabase = mongoClient.getDatabase(mongodb);
        GridFSBucket bucket = GridFSBuckets.create(mongoDatabase);//存入mongodatabase
        return bucket;
    &#125;
&#125;
</code></pre>
<h3 id="消费端从gridfs下载HTML到tomcat【静态化解耦】"><a href="#消费端从gridfs下载HTML到tomcat【静态化解耦】" class="headerlink" title="消费端从gridfs下载HTML到tomcat【静态化解耦】"></a>消费端从gridfs下载HTML到tomcat【静态化解耦】</h3><pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
package com.imooc.api.controller.article;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.NewArticleBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.Date;

@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;

    @GetMapping(&quot;download&quot;)
    @ApiOperation(value = &quot;下载html&quot;, notes = &quot;下载html&quot;, httpMethod = &quot;GET&quot;)
    public Integer download(String articleId, String articleMongoId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
package com.imooc.article.html.controller;

import com.imooc.api.controller.article.ArticleHTMLControllerApi;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.mongodb.client.gridfs.GridFSBucket;
import com.mongodb.gridfs.GridFS;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.RestController;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@RestController
public class ArticleHTMLController implements ArticleHTMLControllerApi &#123;

    final static Logger logger = LoggerFactory.getLogger(ArticleHTMLController.class);

    @Autowired //相应的下载
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    @Override
    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
@Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
                doDownloadArticleHTML(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
    private void doDownloadArticleHTML(String articleId, String articleMongoId) &#123;
        String url = //去SwitchHost弄个新的端口映射
                &quot;http://html.imoocnews.com:8002/article/html/download?articleId=&quot;
                        + articleId +
                        &quot;&amp;articleMongoId=&quot;
                        + articleMongoId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
      /**
     * 关联文章和gridfs的html文件id
     */
    public void updateArticleToGridFS(String articleId, String articleMongoId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
    @Transactional
    @Override
    public void updateArticleToGridFS(String articleId, String articleMongoId) &#123;
        Article pendingArticle = new Article();
        pendingArticle.setId(articleId);
        pendingArticle.setMongoFileId(articleMongoId);
        articleMapper.updateByPrimaryKeySelective(pendingArticle);
    &#125;
</code></pre>
<pre><code class="mysql">【SwitchHosts】
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

发布文章后审核文章
此时会发现数据库MongoDB里面的GridFS存储桶有新建的html 包括在 前端也存在此文件
D:\apache-tomcat-8.5.93\webapps\imooc-news\portal\a\240731CN3X1M56Y8.html
</code></pre>
<h3 id="撤回删除文章，删除gridfs文件以及html【静态化解耦】"><a href="#撤回删除文章，删除gridfs文件以及html【静态化解耦】" class="headerlink" title="撤回删除文章，删除gridfs文件以及html【静态化解耦】"></a>撤回删除文章，删除gridfs文件以及html【静态化解耦】</h3><blockquote>
<p>拿到mongodb_id  去删除 在service-html 写个删除接口 拼接删除方法</p>
</blockquote>
<pre><code class="java">service-api  com/imooc/api/controller/article/ArticleHTMLControllerApi.java
@Api(value = &quot;静态化文章业务的controller&quot;, tags = &#123;&quot;静态化文章业务的controller&quot;&#125;)
@RequestMapping(&quot;article/html&quot;)
public interface ArticleHTMLControllerApi &#123;
@GetMapping(&quot;delete&quot;)
    @ApiOperation(value = &quot;删除html&quot;, notes = &quot;删除html&quot;, httpMethod = &quot;GET&quot;)
    public Integer delete(String articleId) throws Exception;
&#125;
</code></pre>
<pre><code class="java">article-html  com/imooc/article/html/controller/ArticleHTMLController.java
@Override
    public Integer delete(String articleId) throws Exception &#123;
        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;
        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 删除文件
        file.delete();
        return HttpStatus.OK.value();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult delete(String userId, String articleId) &#123;
        articleService.deleteArticle(userId,articleId);
        return GraceJSONResult.ok();
    &#125;

    @Override
    public GraceJSONResult withdraw(String userId, String articleId) &#123;
        articleService.withdrawArticle(userId, articleId);
        return GraceJSONResult.ok();
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
@Transactional
    @Override
    public void deleteArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setIsDelete(YesOrNo.YES.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_DELETE_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;

    @Transactional
    @Override
    public void withdrawArticle(String userId, String articleId) &#123;
        Example articleExample = makeExampleCriteria(userId, articleId);

        Article pending = new Article();
        pending.setArticleStatus(ArticleReviewStatus.WITHDRAW.type);

        int result = articleMapper.updateByExampleSelective(pending, articleExample);
        if (result != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_WITHDRAW_ERROR);
        &#125;
        deleteHTML(articleId);
    &#125;
...
...

    @Autowired
    private GridFSBucket gridFSBucket;
    /**
     * 文章撤回删除后，删除静态化的html
     */

    public void deleteHTML(String articleId) &#123;
        // 1. 查询文章的mongoFileId
        Article pending = articleMapper.selectByPrimaryKey(articleId);
        String articleMongoId = pending.getMongoFileId();

        // 2. 删除GridFS上的文件
        gridFSBucket.delete(new ObjectId(articleMongoId));

        // 3. 删除消费端的HTML文件
        doDeleteArticleHTML(articleId);
//        doDeleteArticleHTMLByMQ(articleId);
    &#125;

    @Autowired
    public RestTemplate restTemplate;
    private void doDeleteArticleHTML(String articleId) &#123;
        String url = &quot;http://html.imoocnews.com:8002/article/html/delete?articleId=&quot; + articleId;
        ResponseEntity&lt;Integer&gt; responseEntity = restTemplate.getForEntity(url, Integer.class);
        int status = responseEntity.getBody();
        if (status != HttpStatus.OK.value()) &#123;
            GraceException.display(ResponseStatusEnum.SYSTEM_OPERATION_ERROR);
        &#125;
    &#125;
</code></pre>
<h3 id="接口解耦需求【章节概述】"><a href="#接口解耦需求【章节概述】" class="headerlink" title="接口解耦需求【章节概述】"></a>接口解耦需求【章节概述】</h3><ul>
<li><strong>介绍RabbitMQ</strong></li>
<li><strong>RabbitMQ术语</strong></li>
<li><strong>安装与配置消息队列</strong></li>
<li><strong>实现接口调用解耦</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/d5205be20fc0bac1de7cadbc9b34f6ff949df3d1/data/Rabbitmq.png"></p>
<h3 id="RabbitMQ概述-MQ模型"><a href="#RabbitMQ概述-MQ模型" class="headerlink" title="RabbitMQ概述_MQ模型"></a>RabbitMQ概述_MQ模型</h3><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul>
<li><strong>RabbitMQ</strong></li>
<li><strong>ActiveMQ</strong></li>
<li><strong>RocketMQ</strong></li>
<li><strong>Kafka</strong></li>
</ul>
<h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h5><ul>
<li><strong>erlang语言开发</strong></li>
<li><strong>AMQP</strong></li>
<li><strong>应用之间通信</strong></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><strong>异步任务</strong></li>
<li><strong>提速</strong></li>
<li><strong>接口解耦</strong></li>
<li><strong>削峰</strong></li>
</ul>
<h5 id="RabbitMQ模型"><a href="#RabbitMQ模型" class="headerlink" title="RabbitMQ模型"></a>RabbitMQ模型</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/d83d056479d71444c598865698d340e2ba01da96/data/RabbitMQ%E6%A8%A1%E5%9E%8B.png"></p>
<h3 id="RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有"><a href="#RabbitMQ-3-8-5-安装与配置详细在”多线程与分布式-md“中有" class="headerlink" title="RabbitMQ-3.8.5 安装与配置详细在”多线程与分布式.md“中有"></a>RabbitMQ-3.8.5 安装与配置<del>详细在”多线程与分布式.md“中有</del></h3><blockquote>
<p>E:\Java实例项目1-20套\第04套【项目实战】Spring Cloud分布式微服务实战，打造大型自媒体3大业务平台 分布式前后端分离项目分层聚合 养成应对复杂业务的综合技术能力\imooc-news\rabbitmq-server-3.8.5</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://packagecloud.io/rabbitmq/erlang/install#bash-rpm">rabbitmq&#x2F;erlang - Installation · packagecloud- Bash Scripts</a></p>
<pre><code class="mysql">[imooc@imooc ~]$ curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
[imooc@imooc ~]$ sudo yum install erlang
[imooc@imooc ~]$ erl
Erlang/OTP 23 [erts-11.2.2.10] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] [hipe]

Eshell V11.2.2.10  (abort with ^G)
1&gt; 
[imooc@imooc ~]$ yum list | grep erlang
erlang.x86_64                               23.3.4.11-1.el7            @rabbitmq_erlang
erlang-debuginfo.x86_64                     23.3.4.11-1.el7            rabbitmq_erlang
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey
[imooc@imooc ~]$ sudo rpm --import https://packagecloud.io/gpg.key

将资源包里的文件拷贝过来 rabbitmq.conf 和 rabbitmq-server.rpm
#[先把两个依赖搞好 =&gt; 一个是key 一个是依赖]
[imooc@imooc ~]$ sudo rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc
[imooc@imooc ~]$ sudo yum install socat
[imooc@imooc ~]$ sudo rpm -ivh rabbitmq-server-3.8.5-1.el7.noarch.rpm
[imooc@imooc ~]$ sudo vim rabbitmq.conf
#&#123;loopback_users, []&#125; 加上注释#
[imooc@imooc ~]$ cd /etc/rabbitmq/
#把conf移动到etc中
[imooc@imooc rabbitmq]$ sudo cp /home/imooc/rabbitmq.conf .
#重新启动rabbitmq
[imooc@imooc rabbitmq]$ sudo systemctl restart rabbitmq-server
#查看状态
[imooc@imooc rabbitmq]$ sudo systemctl status rabbitmq-server

● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since 四 2024-08-01 15:45:54 CST; 13s ago
 Main PID: 5843 (beam.smp)
   Status: &quot;Initialized&quot;
    Tasks: 86
   CGroup: /system.slice/rabbitmq-server.service
           ├─5843 /usr/lib64/erlang/erts-11.2.2.10/bin/beam.smp -W w -K true -A 64 -M...
           ├─5952 erl_child_setup 32768
           ├─6008 inet_gethost 4
           └─6009 inet_gethost 4
           
[imooc@imooc rabbitmq]$ sudo rabbitmq-plugins enable rabbitmq_management
[imooc@imooc rabbitmq]$ ll
总用量 40
-rw-r--r--. 1 root rabbitmq    23 8月   1 15:46 enabled_plugins
-rw-r--r--. 1 root rabbitmq 33325 8月   1 15:35 rabbitmq.conf

http://192.168.170.135:15672/
username: guest
password: guest
[imooc@imooc ~]$ sudo vim rabbitmq.conf #把这个取消注释
loopback_users.guest = false

http://192.168.170.135:15672/#/  #创建虚拟host节点
→ admin → Add a user
</code></pre>
<h3 id="引入依赖和配置【集成Rabbitmq】"><a href="#引入依赖和配置【集成Rabbitmq】" class="headerlink" title="引入依赖和配置【集成Rabbitmq】"></a>引入依赖和配置【集成Rabbitmq】</h3><pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<blockquote>
<p>模块 Module<br>imooc-news-dev-service-article 是生产者[发送消息]<br>→<br>imooc-news-dev-service-article-html 是消费者[处理消息]</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/vhosts">RabbitMQ Management</a> 在Virtual Hosts → Add a new virtual host → Name: imooc-news-dev<br>退出再重新登陆一下rabbitmq → 账号密码：admin</p>
<pre><code class="yaml">service-article  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<pre><code class="yaml">service-article-html  application.yml
  rabbitmq:
    host: 192.168.170.135
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<h3 id="创建交换机和队列【集成Rabbitmq】"><a href="#创建交换机和队列【集成Rabbitmq】" class="headerlink" title="创建交换机和队列【集成Rabbitmq】"></a>创建交换机和队列【集成Rabbitmq】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_ARTICLE = &quot;exchange_article&quot;;

    // 定义队列的名字
    public static final String QUEUE_DOWNLOAD_HTML = &quot;queue_download_html&quot;;

    // 创建交换机
    @Bean(EXCHANGE_ARTICLE)
    public Exchange exchange()&#123;
        return ExchangeBuilder
                .topicExchange(EXCHANGE_ARTICLE)
                .durable(true)
                .build();
    &#125;

    // 创建队列
    @Bean(QUEUE_DOWNLOAD_HTML)
    public Queue queue()&#123;
        return new Queue(QUEUE_DOWNLOAD_HTML);
    &#125;

    // 队列绑定交换机
    @Bean
    public Binding binding(
            @Qualifier(QUEUE_DOWNLOAD_HTML) Queue queue,
            @Qualifier(EXCHANGE_ARTICLE) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                //.with(&quot;article.*&quot;) &quot;article.hello&quot;,  //类似于API的规则
                .with(&quot;article.#.do&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<h3 id="创建生产者-配置路由规则【集成RabbitMQ】"><a href="#创建生产者-配置路由规则【集成RabbitMQ】" class="headerlink" title="创建生产者_配置路由规则【集成RabbitMQ】"></a>创建生产者_配置路由规则【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://localhost:8001/producer/hello">localhost:8001&#x2F;producer&#x2F;hello</a></p>
<blockquote>
<p>{<br>“status”: 200,<br>“msg”: “操作成功！”,<br>“success”: true,<br>“data”: null<br>}</p>
</blockquote>
<pre><code class="java">//如果队列规则改变 就需要把Exchanges里的RoutingKey解绑[Unbind] 否则还是会有以前的规则收到消息
//http://192.168.170.135:15672/#/exchanges/imooc-news-dev/exchange_article 
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;
&#125;
http://localhost:8001/producer/hello
</code></pre>
<h3 id="消费者接受消息处理业务【集成RabbitMQ】"><a href="#消费者接受消息处理业务【集成RabbitMQ】" class="headerlink" title="消费者接受消息处理业务【集成RabbitMQ】"></a>消费者接受消息处理业务【集成RabbitMQ】</h3><p><a target="_blank" rel="noopener" href="http://192.168.170.135:15672/#/queues/imooc-news-dev/queue_download_html">RabbitMQ Management</a></p>
<blockquote>
<p>如果消息被消费掉后那么就 需要重新请求消息队列生成</p>
</blockquote>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
==================================================================
// 如果消息被消费掉后那么就 需要重新请求消息队列生成
// 此时需要刷新 http://localhost:8001/producer/hello 重新提交一下消息就可以了
Console：
1001~
article.publish.download.do
1002~
article.success.do
1003~
不符合的规则：article.play
</code></pre>
<h3 id="文章静态化HTML与删除【异步解耦】"><a href="#文章静态化HTML与删除【异步解耦】" class="headerlink" title="文章静态化HTML与删除【异步解耦】"></a>文章静态化HTML与删除【异步解耦】</h3><pre><code class="java">service-article  com/imooc/article/controller/ArticleController.java
 @Override
    public GraceJSONResult doReview(String articleId, Integer passOrNot) &#123;
        Integer pendingStatus;
        if (passOrNot == YesOrNo.YES.type) &#123;
            // 审核成功
            pendingStatus = ArticleReviewStatus.SUCCESS.type;
        &#125; else if (passOrNot == YesOrNo.NO.type) &#123;
            // 审核失败
            pendingStatus = ArticleReviewStatus.FAILED.type;
        &#125; else &#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.ARTICLE_REVIEW_ERROR);
        &#125;
        // 保存到数据库，更改文章状态为审核成功或者失败
        articleService.updateArticleStatus(articleId, pendingStatus);

        if (pendingStatus == ArticleReviewStatus.SUCCESS.type)&#123;
            //审核成功，生成文章详情页静态html
            try&#123;
//                 createArticleHTML(articleId);
                String articleMongoId = createArticleHTMLToGridFS(articleId);
                // 存储到对应的文章 进行关联保存
                articleService.updateArticleToGridFS(articleId, articleMongoId);
                // 调用消费端，执行下载html
//                doDownloadArticleHTML(articleId,articleMongoId);
            ★★  // 发送消息到mq队列，让消费者监听并且下载html  ★★
                doDownloadArticleHTMLByMQ(articleId,articleMongoId);
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
        return GraceJSONResult.ok();
    &#125;
@Autowired
    private RabbitTemplate rabbitTemplate;
    private void doDownloadArticleHTMLByMQ(String articleId, String articleMongoId) &#123;

        rabbitTemplate.convertAndSend(
                RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.download.do&quot;,
                articleId + &quot;,&quot; + articleMongoId);
    &#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/controller/ArticleHTMLComponent.java
package com.imooc.article.html.controller;

import com.mongodb.client.gridfs.GridFSBucket;
import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

@Component
public class ArticleHTMLComponent &#123;

    @Autowired
    private GridFSBucket gridFSBucket;

    @Value(&quot;$&#123;freemarker.html.article&#125;&quot;)
    private String articlePath;

    public Integer download(String articleId, String articleMongoId)
            throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);
        // 创建输出流
        OutputStream outputStream = new FileOutputStream(file);
        // 执行下载
        gridFSBucket.downloadToStream(new ObjectId(articleMongoId), outputStream);

        return HttpStatus.OK.value();
    &#125;

    public Integer delete(String articleId) throws Exception &#123;

        // 拼接最终文件的保存的地址
        String path = articlePath + File.separator + articleId + &quot;.html&quot;;

        // 获取文件流，定义存放的位置和名称
        File file = new File(path);

        // 删除文件
        file.delete();

        return HttpStatus.OK.value();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article-html  com/imooc/article/html/RabbitMQConsumer.java
package com.imooc.article.html;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.article.html.controller.ArticleHTMLComponent;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
//打断点后 只要队列有消息 消费者监听到就会被消费
@Component
public class RabbitMQConsumer &#123;
    @Autowired
    private ArticleHTMLComponent articleHTMLComponent;

    @RabbitListener(queues = &#123;RabbitMQConfig.QUEUE_DOWNLOAD_HTML&#125;)//监听哪个队列
    public void watchQueue(String payload, Message message)&#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        if (routingKey.equalsIgnoreCase(&quot;article.publish.download.do&quot;)) &#123;
            System.out.println(&quot;article.publish.download.do&quot;);
        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.success.do&quot;)) &#123;
            System.out.println(&quot;article.success.do&quot;);
        &#125;else if (routingKey.equalsIgnoreCase(&quot;article.download.do&quot;)) &#123;
            String articleId = payload.split(&quot;,&quot;)[0];
            String articleMongoId = payload.split(&quot;,&quot;)[1];
            try &#123;
                articleHTMLComponent.download(articleId, articleMongoId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;

        &#125; else if (routingKey.equalsIgnoreCase(&quot;article.html.download.do&quot;)) &#123;
            String articleId = payload;
            try &#123;
                articleHTMLComponent.delete(articleId);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else &#123;
            System.out.println(&quot;不符合的规则：&quot; + routingKey);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">前端的index.html页面也需要修改成静态页面跳转
&lt;a :href=&quot;&#39;./a/&#39;+article.id+&#39;.html&#39;&quot; target=&quot;_blank&quot; class=&quot;link-article-title&quot;&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;
这样再次刷新 就可以让页面不是articleId=?...
http://www.imoocnews.com:9090/imooc-news/portal/a/240801D7S7PM63R4.html
</code></pre>
<h3 id="延迟队列的需求与安装配置【延迟队列】"><a href="#延迟队列的需求与安装配置【延迟队列】" class="headerlink" title="延迟队列的需求与安装配置【延迟队列】"></a>延迟队列的需求与安装配置【延迟队列】</h3><p>把这个<del>rabbitmq_delayed_message_exchange-3.8.0.ez</del>上传到Linux虚拟机</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/be9aa25974ee850399731a79b57f5cd8c4375356/data/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.jpg"></p>
<pre><code class="mysql">[imooc@imooc rabbitmq]$ cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc ~]$ sudo mv /home/imooc/rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.5/plugins
[imooc@imooc plugins]$ sudo systemctl restart rabbitmq-server
[imooc@imooc plugins]$ sudo rabbitmq-plugins list
Listing plugins with pattern &quot;.*&quot; ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@imooc
 |/
[  ] rabbitmq_amqp1_0                  3.8.5
[  ] rabbitmq_auth_backend_cache       3.8.5
[  ] rabbitmq_auth_backend_http        3.8.5
[  ] rabbitmq_auth_backend_ldap        3.8.5
[  ] rabbitmq_auth_backend_oauth2      3.8.5
[  ] rabbitmq_auth_mechanism_ssl       3.8.5
[  ] rabbitmq_consistent_hash_exchange 3.8.5
[  ] rabbitmq_delayed_message_exchange 3.8.0
[  ] rabbitmq_event_exchange           3.8.5
[  ] rabbitmq_federation               3.8.5
[  ] rabbitmq_federation_management    3.8.5
[  ] rabbitmq_jms_topic_exchange       3.8.5
[E*] rabbitmq_management               3.8.5
[e*] rabbitmq_management_agent         3.8.5
[  ] rabbitmq_mqtt                     3.8.5
[  ] rabbitmq_peer_discovery_aws       3.8.5
[  ] rabbitmq_peer_discovery_common    3.8.5
[  ] rabbitmq_peer_discovery_consul    3.8.5
[  ] rabbitmq_peer_discovery_etcd      3.8.5
[  ] rabbitmq_peer_discovery_k8s       3.8.5
[  ] rabbitmq_prometheus               3.8.5
[  ] rabbitmq_random_exchange          3.8.5
[  ] rabbitmq_recent_history_exchange  3.8.5
[  ] rabbitmq_sharding                 3.8.5
[  ] rabbitmq_shovel                   3.8.5
[  ] rabbitmq_shovel_management        3.8.5
[  ] rabbitmq_stomp                    3.8.5
[  ] rabbitmq_top                      3.8.5
[  ] rabbitmq_tracing                  3.8.5
[  ] rabbitmq_trust_store              3.8.5
[e*] rabbitmq_web_dispatch             3.8.5
[  ] rabbitmq_web_mqtt                 3.8.5
[  ] rabbitmq_web_mqtt_examples        3.8.5
[  ] rabbitmq_web_stomp                3.8.5
[  ] rabbitmq_web_stomp_examples       3.8.5
[imooc@imooc plugins]$ service rabbitmq-server restart #[重启服务]
Redirecting to /bin/systemctl restart rabbitmq-server.service
</code></pre>
<h3 id="实现延迟队列【延迟队列】"><a href="#实现延迟队列【延迟队列】" class="headerlink" title="实现延迟队列【延迟队列】"></a>实现延迟队列【延迟队列】</h3><pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

//        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
//        String articleId = payload;
//        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java
package com.imooc.article.controller;

import com.imooc.api.config.RabbitMQConfig;
import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.AmqpException;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.core.MessagePostProcessor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController&#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
    /**
     * RabbitMQ的路由规则 routing key
     * display.*.*  →  * 代表一个占位符
     * .with(&quot;article.#.do&quot;)  //类似于API的规则
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done 不匹配
     *
     * display.# → # 代表任意多个占位符
     * 例：
     *      display.do.download      匹配
     *      display.do.upload.done.over 匹配
     */

        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.publish.download.do&quot;, //要绑定规则
                &quot;1001~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.success.do&quot;, //要绑定规则
                &quot;1002~&quot;);
        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_ARTICLE,
                &quot;article.play&quot;, //要绑定规则
                &quot;1003~&quot;);
        return GraceJSONResult.ok();
    &#125;

    @GetMapping(&quot;/delay&quot;)
    public Object delay() &#123;
        //重写延迟方法  【生产者】
        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
            @Override
            public Message postProcessMessage(Message message) throws AmqpException &#123;
                // 设置消息的持久
                message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                // 设置消息延迟的时间 单位ms毫秒
                message.getMessageProperties().setDelay(5000);
                return message;
            &#125;
        &#125;;
        rabbitTemplate.convertAndSend(RabbitMQDelayConfig.EXCHANGE_DELAY,
                &quot;delay.demo&quot;, //要绑定规则
                &quot;这是一条延时消息~&quot;,
                messagePostProcessor);
        System.out.println(&quot;生产者发送的延迟消息：&quot; + new Date());
        return &quot;OK&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">确保 rabbitmq_delayed_message_exchange 插件正确启用：

复制代码
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
sudo systemctl restart rabbitmq-server

======================================================================
http://localhost:8001/producer/delay

生产者发送的延迟消息：Thu Aug 01 20:17:30 CST 2024

这是一条延时消息~
delay.demo
消费者接受的延迟消息：Thu Aug 01 20:17:35 CST 2024
</code></pre>
<h3 id="实现文章的定时延时发布【延迟队列】"><a href="#实现文章的定时延时发布【延迟队列】" class="headerlink" title="实现文章的定时延时发布【延迟队列】"></a>实现文章的定时延时发布【延迟队列】</h3><pre><code class="java">service-article  com/imooc/article/service/ArticleService.java
/**
     * 更新定时发布为即使发布
     
    public void updateAppointToPublish(); **/

    /**
     * 更新单条文章为记时发布
     */
    public void updateArticleToPublish(String articleId);
</code></pre>
<pre><code class="java">service-article  com/imooc/article/service/impl/ArticleServiceImpl.java
【32-64行  89-101行】
 @Transactional
    @Override
    public void createArticle(NewArticleBO newArticleBO, Category category) &#123;
        String articleId = sid.nextShort();

        Article article = new Article();
        BeanUtils.copyProperties(newArticleBO, article);

        article.setId(articleId);
        article.setCategoryId(category.getId());
        article.setArticleStatus(ArticleReviewStatus.REVIEWING.type);
        article.setCommentCounts(0);
        article.setReadCounts(0);

        article.setIsDelete(YesOrNo.NO.type);
        article.setCreateTime(new Date());
        article.setUpdateTime(new Date());

        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;
            article.setPublishTime(newArticleBO.getPublishTime()); //用户可以在前端选择定时发布
        &#125; else if (article.getIsAppoint() == ArticleAppointType.IMMEDIATELY.type) &#123;
            article.setPublishTime(new Date());
        &#125;

        int res = articleMapper.insert(article);
        if (res != 1) &#123;
            GraceException.display(ResponseStatusEnum.ARTICLE_CREATE_ERROR);
        &#125;

        // 发送延迟消息到mq，计算定时发布时间和当前时间的时间差，则为往后延迟的时间
        if (article.getIsAppoint() == ArticleAppointType.TIMING.type) &#123;

            Date endDate = newArticleBO.getPublishTime();
            Date startDate = new Date();

          int delayTimes = (int)(endDate.getTime() - startDate.getTime());

            System.out.println(DateUtil.timeBetween(startDate, endDate));

            // FIXME: 为了测试方便，写死10s
//            int delayTimes = 10 * 1000;

            MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;
                @Override
                public Message postProcessMessage(Message message) throws AmqpException &#123;
                    // 设置消息的持久
                    message.getMessageProperties()
                            .setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                    // 设置消息延迟的时间，单位ms毫秒
                    message.getMessageProperties()
                            .setDelay(delayTimes);
                    return message;
                &#125;
            &#125;;
            rabbitTemplate.convertAndSend(
                    RabbitMQDelayConfig.EXCHANGE_DELAY,
                    &quot;publish.delay.display&quot;,
                    articleId,
                    messagePostProcessor);

            System.out.println(&quot;延迟消息-定时发布文章：&quot; + new Date());
        &#125;


        /**
         * FIXME: 我们只检测正常的词汇，非正常词汇大家课后去检测
         */
        // 通过阿里智能AI实现对文章文本的自动检测（自动审核）
//        String reviewTextResult = aliTextReviewUtils.reviewTextContent(newArticleBO.getContent());
        String reviewTextResult = ArticleReviewLevel.REVIEW.type;

        if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.PASS.type)) &#123;
            // 修改当前的文章，状态标记为审核通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.SUCCESS.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.REVIEW.type)) &#123;
            // 修改当前的文章，状态标记为需要人工审核
            this.updateArticleStatus(articleId, ArticleReviewStatus.WAITING_MANUAL.type);
        &#125; else if (reviewTextResult
                .equalsIgnoreCase(ArticleReviewLevel.BLOCK.type)) &#123;
            // 修改当前的文章，状态标记为审核未通过
            this.updateArticleStatus(articleId, ArticleReviewStatus.FAILED.type);
        &#125;
    &#125;

@Transactional //添加事务[更新操作]
/** @Override
    public void updateAppointToPublish() &#123;
        articleMapperCustom.updateAppointToPublish();
    &#125; **/

    @Override
    public void updateArticleToPublish(String articleId) &#123;
        Article article = new Article();
        article.setId(articleId);
        article.setIsAppoint(ArticleAppointType.IMMEDIATELY.type);
        articleMapper.updateByPrimaryKeySelective(article);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/RabbitMQDelayConsumer.java
package com.imooc.article;

import com.imooc.api.config.RabbitMQDelayConfig;
import com.imooc.article.service.ArticleService;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class RabbitMQDelayConsumer &#123;

    @Autowired
    private ArticleService articleService;

    @RabbitListener(queues = &#123;RabbitMQDelayConfig.QUEUE_DELAY&#125;)
    public void watchQueue(String payload, Message message) &#123;
        System.out.println(payload);

        String routingKey = message.getMessageProperties().getReceivedRoutingKey();
        System.out.println(routingKey);

        System.out.println(&quot;消费者接受的延迟消息：&quot; + new Date());

        // 消费者接收到定时发布的延迟消息，修改当前的文章状态为`即时发布`
        String articleId = payload;
        articleService.updateArticleToPublish(articleId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/RabbitMQDelayConfig.java //【换一下绑定类型.with(...)】
package com.imooc.api.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * RabbitMQ 的配置类
 */
@Configuration
public class RabbitMQDelayConfig &#123;

    // 定义交换机的名字
    public static final String EXCHANGE_DELAY = &quot;exchange_delay&quot;;

    // 定义队列的名字
    public static final String QUEUE_DELAY = &quot;queue_delay&quot;;

    // 创建延迟交换机
    @Bean(EXCHANGE_DELAY)
    public CustomExchange delayExchange() &#123;
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;, &quot;topic&quot;);
        return new CustomExchange(EXCHANGE_DELAY, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    // 创建队列
    @Bean(QUEUE_DELAY)
    public Queue queue()&#123;
        return new Queue(QUEUE_DELAY);
    &#125;

    // 队列绑定交换机 ↓ binding必须要唯一
    @Bean
    public Binding delayBinding(
            @Qualifier(QUEUE_DELAY) Queue queue,
            @Qualifier(EXCHANGE_DELAY) Exchange exchange)&#123;
        return BindingBuilder
                .bind(queue)
                .to(exchange)
                .with(&quot;publish.delay.#&quot;)
                .noargs();      // 执行绑定
    &#125;
&#125;
</code></pre>
<pre><code class="java">http://writer.imoocnews.com:9090/imooc-news/writer/createArticle.html 发布一篇定时文章
// 在数据库里面是article → is_appoint 是1 然后延迟3天后会变成0
Registering transaction synchronization for SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
JDBC Connection [HikariProxyConnection@441638108 wrapping org.mariadb.jdbc.MariaDbConnection@159b2e33] will be managed by Spring
==&gt;  Preparing: INSERT INTO article ( id,title,category_id,article_type,article_cover,is_appoint,article_status,publish_user_id,publish_time,read_counts,comment_counts,mongo_file_id,is_delete,create_time,update_time,content ) VALUES( ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,? ) 
==&gt; Parameters: 240801FNS7M8G354(String), b10(String), 14(Integer), 2(Integer), (String), 1(Integer), 1(Integer), 240629F21AK1BHX4(String), 2024-08-04 00:00:00.0(Timestamp), 0(Integer), 0(Integer), null, 0(Integer), 2024-08-01 20:36:24.971(Timestamp), 2024-08-01 20:36:24.971(Timestamp), &lt;p&gt;b10&lt;/p&gt;(String)
//★ &lt;==    Updates: 1 ★
Releasing transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472]
//★ 2天3小时23分钟 ★
//★ 延迟消息-定时发布文章：Thu Aug 01 20:36:24 CST 2024 ★
Fetched SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@15650472] from current transaction
==&gt;  Preparing: UPDATE article SET article_status = ? WHERE ( ( id = ? ) ) 
==&gt; Parameters: 2(Integer), 240801FNS7M8G354(String)
&lt;==    Updates: 1
</code></pre>
<h3 id="互联网框架演变【微服务块】"><a href="#互联网框架演变【微服务块】" class="headerlink" title="互联网框架演变【微服务块】"></a>互联网框架演变【微服务块】</h3><ul>
<li><strong>架构演变</strong></li>
<li><strong>微服务入门</strong></li>
<li><strong>SpringCloud各个组件学习</strong></li>
<li><strong>改造项目服务化</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6d9d64a0daa29b87ebdd0c5ca1240264d5b802ed/data/r%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98.png"></p>
<h3 id="注冊中心模型"><a href="#注冊中心模型" class="headerlink" title="注冊中心模型"></a>注冊中心模型</h3><ul>
<li>Eureka</li>
<li>可以把每個服務注入到eureka，更利於管理和維護，使得服務閒通信更方便</li>
</ul>
<blockquote>
<p>Lilei [上户口] → <strong>派出所</strong>  ← [上户口] HanMeimei</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/317410ba901fb06e893bcdd7e2eb05980a9d19d0/data/Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="构建Eureka注册服务【eureka】"><a href="#构建Eureka注册服务【eureka】" class="headerlink" title="构建Eureka注册服务【eureka】"></a>构建Eureka注册服务【eureka】</h3><pre><code class="java">springcloud-eureka  com/imooc/eureka/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
http://localhost:7000/hello  #运行接口
http://localhost:7000         #运行eureka
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/eureka/controller/HelloController.java
package com.imooc.eureka.controller;

import com.imooc.api.controller.user.HelloControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.RedisOperator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController implements HelloControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(HelloController.class);
    public Object hello()&#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
            &lt;/dependency&gt;
            &lt;!-- 其他必要的依赖 --&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR12&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">springcloud-eureka  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
&lt;!--    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/service-admin&quot;/&gt;--&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;C:/Users/Pluminary/Desktop/imooc-news-dev/springcloud-eureka&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/eureka.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="yaml">springcloud-eureka  application.yml
############################################################
#
# eureka 注册中心
# web访问端口号  约定：7000
#
############################################################
server:
  port: 7000
  tomcat:
    uri-encoding: UTF-8
    max-swallow-size: -1  # tomcat默认大小2M，超过2M的文件不会被捕获，需要调整此处大小为100MB或者-1即可

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:  # eureka 实例的hostname，也可以是自定义配置hostname
    hostname: eureka
  client:  # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="java">http://localhost:7000/
进入了Spring Eureka
Instances currently registered with Eureka
</code></pre>
<h3 id="实现用户与文章的服务注册【eureka】"><a href="#实现用户与文章的服务注册【eureka】" class="headerlink" title="实现用户与文章的服务注册【eureka】"></a>实现用户与文章的服务注册【eureka】</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/longd123/article/details/124440454">关于eureka客户端启动报错UnknownHostException详细解决方法_eureka unknownhostexception-CSDN博客</a> </p>
<pre><code class="mysql"># 问题：
http://eureka:7000/eureka   找不到 eureka 的服务器 IP 地址

在cmd里面
C:\Users\Pluminary&gt;ping eureka
Ping 请求找不到主机 eureka。请检查该名称，然后重试。

# 解答：
从你的描述来看，主机eureka无法解析，这是导致服务无法注册到Eureka Server的原因。你可以通过以下方法解决这个问题：

1. 更新 hosts 文件
在你的开发机器上更新 hosts 文件以手动解析 eureka 主机名。

Windows
打开记事本以管理员身份运行。

打开文件 C:\Windows\System32\drivers\etc\hosts。

添加以下行，将 &lt;eureka服务器的IP地址&gt; 替换为实际的IP地址：

plaintext
复制代码
&lt;eureka服务器的IP地址&gt; eureka
保存并关闭文件。

=================================================================
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com
</code></pre>
<pre><code class="yaml">springcloud-eureka  resources/application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
</code></pre>
<pre><code class="yaml">service-user  resources/application.yml
上面的其余不变 底下添加eureka
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient // 开启eureka client 注册到server中
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">springcloud-eureka  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-eureka&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-eureka  com/imooc/user/Application.java
package com.imooc.eureka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;


@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, MongoAutoConfiguration.class&#125;)
@EnableEurekaServer // 开启注册中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================
// 先启动这个服务 再启动user的服务
随后就能看见http://localhost:7000/
里面有一个注册的服务
/*  
   Instances currently registered with Eureka
   Application    AMIs    Availability Zones    Status
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003 
*/
</code></pre>
<pre><code class="yaml">service-article  resources/application.yml
# 定义freemarker生成的HTML
freemarker:
  html:
    target: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a
    article: D:/apache-tomcat-8.5.93/webapps/imooc-news/portal/a

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
      defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java 
//【此时再去启动这个article服务 会发现SERVICE-ARTICLE也成功的注册到Eureka中】
package com.imooc.article;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
/*
   Application    AMIs    Availability Zones    Status
★ SERVICE-ARTICLE    n/a (1)    (1)    UP (1) - localhost:service-article:8001
★ SERVICE-USER    n/a (1)    (1)    UP (1) - localhost:service-user:8003
*/
</code></pre>
<h3 id="使用AppName优化服务间的通信【eureka】"><a href="#使用AppName优化服务间的通信【eureka】" class="headerlink" title="使用AppName优化服务间的通信【eureka】"></a>使用AppName优化服务间的通信【eureka】</h3><h6 id="实行动态化调用-地址拼接"><a href="#实行动态化调用-地址拼接" class="headerlink" title="实行动态化调用 地址拼接"></a>实行动态化调用 地址拼接</h6><p>AppName是eureka的ApplicationId &#x3D; <strong>SERVICE-USER</strong></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·[文章article]自媒体接口api</a> 如果页面没有信息那就是在<strong>Swagger2.java</strong>中代码的问题<br><a target="_blank" rel="noopener" href="http://localhost:7000/">Eureka</a></p>
<blockquote>
<p>门户端文章业务的controller →  &#x2F;portal&#x2F;article&#x2F;detail  →  articleId&#x3D;2006117B57WRZGHH</p>
</blockquote>
<pre><code class="java">package com.imooc.api.config;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.RequestHandler;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration //Springboot啓動的時候會被掃描到并且加載
@EnableSwagger2
public class Swagger2 &#123;

    //    http://localhost:8088/swagger-ui.html     原路径
    //    http://localhost:8088/doc.html            新路径

    // 配置swagger2核心配置 docket
    @Bean
    public Docket createRestApi() &#123;
        Predicate&lt;RequestHandler&gt; adminPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.admin.controller&quot;);
        Predicate&lt;RequestHandler&gt; articlePredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.article.controller&quot;);
        Predicate&lt;RequestHandler&gt; userPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.user.controller&quot;);
        Predicate&lt;RequestHandler&gt; filesPredicate = RequestHandlerSelectors.basePackage(&quot;com.imooc.files.controller&quot;);

        return new Docket(DocumentationType.SWAGGER_2)  // 指定api类型为swagger2
                .apiInfo(apiInfo())                 // 用于定义api文档汇总信息
                .select()
//                .apis(Predicates.or(userPredicate, adminPredicate, filesPredicate))
                .apis(Predicates.or(adminPredicate, articlePredicate, userPredicate, filesPredicate))
                .paths(PathSelectors.any())         // 所有controller
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕课新闻·自媒体接口api&quot;)                       // 文档页标题
                .contact(new Contact(&quot;imooc&quot;,
                        &quot;https://www.imooc.com&quot;,
                        &quot;abc@imooc.com&quot;))                   // 联系人信息
                .description(&quot;专为慕课新闻·自媒体平台提供的api文档&quot;)      // 详细信息
                .version(&quot;1.0.1&quot;)                               // 文档版本号
                .termsOfServiceUrl(&quot;https://www.imooc.com&quot;)     // 网站地址
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
// 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<h3 id="动态构建eureka集群【eureka】保证高可用"><a href="#动态构建eureka集群【eureka】保证高可用" class="headerlink" title="动态构建eureka集群【eureka】保证高可用"></a>动态构建eureka集群【eureka】<del>保证高可用</del></h3><blockquote>
<p>创建一个新的<strong>module</strong> 其内容和 <strong>springcloud-eureka</strong> 里面的一样</p>
</blockquote>
<pre><code class="mysql">SwitchHosts配置信息
# imooc-news 192.168.1.3
127.0.0.1 www.imoocnews.com
127.0.0.1 writer.imoocnews.com
127.0.0.1 admin.imoocnews.com
```
127.0.0.1 article.imoocnews.com
127.0.0.1 user.imoocnews.com
127.0.0.1 files.imoocnews.com
127.0.0.1 html.imoocnews.com

# SpringCloud
127.0.0.1 eureka
127.0.0.1 eureka-cluster-7001
127.0.0.1 eureka-cluster-7002
127.0.0.1 eureka-cluster-7003
</code></pre>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: 7001
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-7001
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

####################################################################################
http://localhost:7001/

DS Replicas
eureka-cluster-7003
eureka-cluster-7002
####################################################################################
如果后面服务很多 100个 那是不是也要创建100个module呢？
并不是 因为每个都是一样的只是改一下application.yml的port端口号而已
所以我们要去把它设置为动态的端口
</code></pre>
<h3 id="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"><a href="#↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓" class="headerlink" title="↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓"></a><span style = "color:red">↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></h3><pre><code class="yaml">springcloud-eureka-cluster  application.yml【改后】
############################################################
#
# eureka 集群的注册中心
# web访问端口号  约定：7001~7003
#
############################################################
server:
  port: $&#123;7001&#125;
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-eureka-cluster

############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/

####################################################################################
http://eureka-cluster-7001:7001/  #【可运行】
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyl-0110/p/14368753.html">1一站式管理所有SpringBoot启动类，Services服务窗口 - 喵酱张-Eric - 博客园 (cnblogs.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44603382/article/details/121593216">IDEA 2021没有VM options_idea2021怎么找到“vm options”-CSDN博客</a></p>
<blockquote>
<p>复制eureka-cluster-7001服务 变成eureka-cluster-7002 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**-DPORT&#x3D;7002 -DP2&#x3D;7001 -DP3&#x3D;7003**<br>同理弄一个eureka-cluster-7003 输入VM代码：**-DPORT&#x3D;7003 -DP2&#x3D;7001 -DP3&#x3D;7002**<br>全部启动后都可以在浏览器正常运行 【集群】<br><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">http://eureka-cluster-7001:7001/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/">http://eureka-cluster-7002:7002/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/">http://eureka-cluster-7003:7003/</a>  DS Replicas：<a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a> + <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/eureka/">eureka-cluster-7001</a><br>如果把里面的application.yml配置注释掉 就可以把自己注册到eureka中<br>client:<br>  <em>#</em> *是否要把当前的<strong>eureka server</strong>注册到自己<br>    *  register-with-eureka: false<br>  <em>#</em> *从注册中心获得检索服务实例，<strong>server</strong>没有必要，直接<strong>false</strong>即可<br>    *  fetch-registry: false<br>之后再重新启动eureka-cluster-7001~7003</p>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">eureka-cluster-7001:7001</a></p>
<h5 id="DS-Replicas"><a href="#DS-Replicas" class="headerlink" title="DS Replicas"></a>DS Replicas</h5><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h5 id="Instances-currently-registered-with-Eureka"><a href="#Instances-currently-registered-with-Eureka" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h5><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="微服务注册到eureka集群【eureka】-port-8003"><a href="#微服务注册到eureka集群【eureka】-port-8003" class="headerlink" title="微服务注册到eureka集群【eureka】${port:8003}"></a>微服务注册到eureka集群【eureka】<del>${port:8003}</del></h3><pre><code class="yaml">service-user  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
    # 注册中心的服务地址
    service-url:
  # defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001_api</a><br>门户端文章业务的controller → get：&#x2F;portal&#x2F;article&#x2F;detail → articleId：2006117B57WRZGHH</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-1"><a href="#DS-Replicas-1" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-1"><a href="#Instances-currently-registered-with-Eureka-1" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="构建微服务集集群【eureka】"><a href="#构建微服务集集群【eureka】" class="headerlink" title="构建微服务集集群【eureka】"></a>构建微服务集集群【eureka】</h3><blockquote>
<p>复制<strong>service-user:8003</strong>服务 变成service-user:8013 并且在Edit configuration的地方点击Modify options中的Add VM 输入代码：**–DPORT&#x3D;8013** </p>
</blockquote>
<pre><code class="yaml">service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a></p>
<h6 id="DS-Replicas-2"><a href="#DS-Replicas-2" class="headerlink" title="DS Replicas"></a>DS Replicas</h6><ul>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/eureka/">eureka-cluster-7003</a></li>
<li><a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/eureka/">eureka-cluster-7002</a></li>
</ul>
<h6 id="Instances-currently-registered-with-Eureka-2"><a href="#Instances-currently-registered-with-Eureka-2" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<h3 id="实现轮训负载均衡【eureka】"><a href="#实现轮训负载均衡【eureka】" class="headerlink" title="实现轮训负载均衡【eureka】"></a>实现轮训负载均衡【eureka】</h3><pre><code class="yaml">imooc-news-dev-service-user  application-dev.yml
server:
  port: $&#123;port:8003&#125;

spring:
  redis:
    database: 0
    host: 127.0.0.1
    port: 6379
# open mybatis log in dev
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
# setup CN from java, This is resource
website:
  domain-name: imoocnews.com
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
//每次调用的时候 都会输出其Port
 @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡 @CloudConfig 
                // public RestTemplate restTemplate()
        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;
    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡
    public RestTemplate restTemplate() &#123;
        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口:8001-api</a><br>门户端文章业务的controller → articleId：2006117B57WRZGHH</p>
</blockquote>
<h3 id="自我保护功能【eureka】"><a href="#自我保护功能【eureka】" class="headerlink" title="自我保护功能【eureka】"></a>自我保护功能【eureka】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/6475d580b535921c2886327b5964ef9fdcad0663/data/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4.png"></p>
<pre><code class="yaml">springcloud-eureka-cluster  application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # 集群中每个eureka的名字都是唯一的
    hostname: eureka-cluster-$&#123;server.port&#125;
    # 自定义端口号
  other-node-port2: $&#123;p2:7002&#125;
  other-node-port3: $&#123;p3:7003&#125;
  client:
    # 是否要把当前的eureka server注册到自己
      # register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
      # fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://eureka-cluster-$&#123;eureka.other-node-port2&#125;:$&#123;eureka.other-node-port2&#125;/eureka/,http://eureka-cluster-$&#123;eureka.other-node-port3&#125;:$&#123;eureka.other-node-port3&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">springcloud-eureka application.yml
############################################################
#
# eureka 配置信息
#
############################################################
eureka:
  instance:
    # eureka 实例的hostname，可以是hostname，也可以自定义配置hostname
    hostname: eureka
  client:
    # 是否要把当前的eureka server注册到自己
    register-with-eureka: false
    # 从注册中心获得检索服务实例，server没有必要，直接false即可
    fetch-registry: false
    # 单实例配置自己的服务地址，高可用集群则配置多个地址
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
  server:
    enable-self-preservation: false # 关闭eureka的自我保护功能
    eviction-interval-timer-in-ms: 5000 # 清理无效节点的时间，可以缩短为5s 默认60s
</code></pre>
<pre><code class="yaml">service-user  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/ 三个节点的注册
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/">Eureka:7001</a><br>先把所有服务全启动<br>eureka:7000<br>eureka-cluster-7001<br>eureka-cluster-7002<br>eureka-cluster-7003<br>service-article:8001<br>service-user:8003<br>service-user:8013<br>然后去刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-3"><a href="#Instances-currently-registered-with-Eureka-3" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SERVICE-ARTICLE</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://localhost:8001/actuator/info">localhost:service-article:8001</a></td>
</tr>
<tr>
<td align="left"><strong>SERVICE-USER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (2)</td>
<td align="left">(2)</td>
<td align="left"><strong>UP</strong> (2) - <a target="_blank" rel="noopener" href="http://localhost:8003/actuator/info">localhost:service-user:8003</a> , <a target="_blank" rel="noopener" href="http://localhost:8013/actuator/info">localhost:service-user:8013</a></td>
</tr>
<tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (3)</td>
<td align="left">(3)</td>
<td align="left"><strong>UP</strong> (3) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7003:7003/actuator/info">localhost:springcloud-eureka-cluster:7003</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a> , <a target="_blank" rel="noopener" href="http://eureka-cluster-7002:7002/actuator/info">localhost:springcloud-eureka-cluster:7002</a></td>
</tr>
</tbody></table>
<p>随后只留下eureka-cluster-7001其他全部Stop<br>再次刷新</p>
<h6 id="Instances-currently-registered-with-Eureka-4"><a href="#Instances-currently-registered-with-Eureka-4" class="headerlink" title="Instances currently registered with Eureka"></a>Instances currently registered with Eureka</h6><table>
<thead>
<tr>
<th align="left">Application</th>
<th align="left">AMIs</th>
<th align="left">Availability Zones</th>
<th align="left">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SPRINGCLOUD-EUREKA-CLUSTER</strong></td>
<td align="left"><strong>n&#x2F;a</strong> (1)</td>
<td align="left">(1)</td>
<td align="left"><strong>UP</strong> (1) - <a target="_blank" rel="noopener" href="http://eureka-cluster-7001:7001/actuator/info">localhost:springcloud-eureka-cluster:7001</a></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="负载均衡工具"><a href="#负载均衡工具" class="headerlink" title="负载均衡工具"></a>负载均衡工具</h3><ul>
<li><strong>Ribbon</strong>[本地] &#x3D; <strong>RestTemplate</strong> + <strong>@LoadBalanced</strong></li>
<li><strong>服务间通信的负载均衡工具，提供完善的超时重试机制</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a0b97158e7b360bc72b677aad99c5cb41b32d995/data/ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<h3 id="实现多种负载均衡算法【ribbon】"><a href="#实现多种负载均衡算法【ribbon】" class="headerlink" title="实现多种负载均衡算法【ribbon】"></a>实现多种负载均衡算法【ribbon】</h3><h6 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h6><p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a></p>
<pre><code class="java">service-api  com/imooc/api/config/CloudConfig.java
package com.imooc.api.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.OkHttp3ClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class CloudConfig &#123;

    public CloudConfig() &#123;
    &#125;

    /**
     * 会基于OKHttp3的配置来实例RestTemplate
     * @return
     */
    @Bean
    @LoadBalanced //添加负载均衡 默认的负载均衡算法：枚举
    public RestTemplate restTemplate() &#123;

        return new RestTemplate(new OkHttp3ClientHttpRequestFactory());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/rule/MyRule.java
package com.rule;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 官方定义了规则不要被 @ComponentScan( 扫描到
@Configuration
public class MyRule &#123;
    @Bean
    public IRule iRule()&#123;// 随机的负载均衡策略
        return new RandomRule();
        // 在调用方article的启动类开启注解 @RibbonClient
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h6 id="运用配置文件进行配置"><a href="#运用配置文件进行配置" class="headerlink" title="运用配置文件进行配置"></a>运用配置文件进行配置</h6><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口api</a> 发送11次请求 <strong>门户端文章业务</strong>→articleId：2006117B57WRZGHH<br>service-user:8003请求到myPort&#x3D;8003 8次<br>service-user:8013请求到myPort&#x3D;8013 3次</p>
</blockquote>
<pre><code class="yaml">service-article  resources/application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="重试机制【ribbon】"><a href="#重试机制【ribbon】" class="headerlink" title="重试机制【ribbon】"></a>重试机制【ribbon】</h3><h6 id="节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制"><a href="#节点有可能因为网络问题访问不到-而为了不让其返回错误-需要重试机制" class="headerlink" title="节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制"></a>节点有可能因为网络问题访问不到 而为了不让其返回错误 需要重试机制</h6><pre><code class="xml">sevice-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
            &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
#    com.imooc.api.controller.user.UserControllerApi: debug
    root: debug
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口-8001api</a>     articleId：2006117B57WRZGHH<br>先把所有服务全部启动 然后把service-user:8013 的服务Stop<br>再去api接口发送请求 查看servcice-article:8001的Console输出日志<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;0<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;1<br>14:10.288 [http-nio-8001-exec-1] DEBUG o.s.retry.support.RetryTemplate - Retry: count&#x3D;2<br>14:10.774 [http-nio-8001-exec-1] DEBUG o.s.web.client.RestTemplate - Response 200 OK</p>
</blockquote>
<h3 id="简化服务调用【feign】以Api作为接口-面向接口的编程风格"><a href="#简化服务调用【feign】以Api作为接口-面向接口的编程风格" class="headerlink" title="简化服务调用【feign】以Api作为接口,面向接口的编程风格"></a>简化服务调用【feign】<del>以Api作为接口,面向接口的编程风格</del></h3><h5 id="声明式HTTP工具"><a href="#声明式HTTP工具" class="headerlink" title="声明式HTTP工具"></a>声明式HTTP工具</h5><ul>
<li><strong>Feign</strong></li>
<li><strong>声明式的http工具，用于简化服务调用</strong></li>
</ul>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/ArticlePortalController.java
    // 注入服务发现，可以获得已经注册的服务相关信息
    @Autowired
    private DiscoveryClient discoveryClient;

    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
    private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
//        String serviceId = &quot;SERVICE-USER&quot;;
//        List&lt;ServiceInstance&gt; instanceList = discoveryClient.getInstances(serviceId);
//        ServiceInstance userService = instanceList.get(0);
    // 实行动态化调用 地址拼接
//        String userServerUrlExecute
                //因为seviceId里面的SERVICE—USER就存在着userService.getHost()和.getPort()
//                = &quot;http://&quot;+ serviceId + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet));
//        String userServerUrlExecute
//                = &quot;http://&quot;+ userService.getHost() + &quot;:&quot; + userService.getPort() + &quot;/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
//        String userServerUrlExecute
//                = &quot;http://user.imoocnews.com:8003/user/queryByIds?userIds=&quot; + JsonUtils.objectToJson(idSet);
        // 为restTemplate增加一个负载均衡@CloudConfig public RestTemplate restTemplate()
//        ResponseEntity&lt;GraceJSONResult&gt; responseEntity
//                = restTemplate.getForEntity(userServerUrlExecute, GraceJSONResult.class);
//        GraceJSONResult bodyResult = responseEntity.getBody();
        List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【EnableFeignClients】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/config/MyServiceList.java
package com.imooc.api.config;

public class MyServiceList &#123;
    public static final String SERVICE_USER = &quot;service-user&quot;;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/api/controller/user/UserControllerApi.java【@FeignClient】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;)
@FeignClient(value = MyServiceList.SERVICE_USER) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
                                          @RequestParam BindingResult result); //RequestParam  BindingResult result 加了肯定在前端不可用 对Feign而言不能存在两个对象不然会认为有两个model

    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<h3 id="统一检验处理【feign】"><a href="#统一检验处理【feign】" class="headerlink" title="统一检验处理【feign】"></a>统一检验处理【feign】</h3><blockquote>
<p>把所有的BindingResult都可以采用全局调用的方法去调用<br><a target="_blank" rel="noopener" href="http://localhost:8003/doc.html">慕课新闻·自媒体接口8003api</a> → 用户信息相关 → 修改&#x2F;完善用户信息  Post &#x2F;user&#x2F;updateUserInfo</p>
</blockquote>
<pre><code class="java">dev-common  com/imooc/exception/GraceExceptionHandler.java
package com.imooc.exception;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MaxUploadSizeExceededException;

import javax.naming.Binding;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 统一异常拦截处理
 * 可以针对异常的类型进行捕获 然后返回json信息到前端
 */
@ControllerAdvice
public class GraceExceptionHandler &#123;
 /* @ExceptionHandler(MyCustomException.class)
    //只要是这个类的异常都会进入下面的方法
    @ResponseBody
    public GraceJSONResult returnMyException(MyCustomException e)&#123;
        e.printStackTrace(); //打印信息
        return GraceJSONResult.exception(e.getResponseStatusEnum());
    &#125;

    @ExceptionHandler(MaxUploadSizeExceededException.class)
    @ResponseBody
    public GraceJSONResult returnMaxUploadSizeExceededException(MaxUploadSizeExceededException e) &#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.FILE_MAX_SIZE_ERROR);
    &#125;*/

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody //该异常是基于所有的vo验证
    public GraceJSONResult returnException(MethodArgumentNotValidException e) &#123;
        BindingResult result = e.getBindingResult();
        Map&lt;String, String&gt; map = getErrors(result);
        return GraceJSONResult.errorMap(map);
    &#125;

    public Map&lt;String, String&gt; getErrors(BindingResult result) &#123;
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
        List&lt;FieldError&gt; errorList = result.getFieldErrors();
        for (FieldError error : errorList) &#123;
            // 发送验证错误的时候所对应的某个属性
            String field = error.getField();
            // 验证的错误消息
            String msg = error.getDefaultMessage();
            map.put(field, msg);
        &#125;
        return map;
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java
//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
    @Override
  public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO)&#123;
    //, BindingResult result) &#123;
//        // 0.校验BO
//        if (result.hasErrors())&#123;
//            Map&lt;String, String&gt; map = getErrors(result);
//            return GraceJSONResult.errorMap(map);
//        &#125;
        // 1.执行更新操作
        userService.updateUserInfo(updateUserInfoBO);
        return GraceJSONResult.ok();
        //调用UserService把独有信息传入
    &#125;
</code></pre>
<h3 id="开启日志调式【feign】基于http的调用"><a href="#开启日志调式【feign】基于http的调用" class="headerlink" title="开启日志调式【feign】基于http的调用"></a>开启日志调式【feign】<del>基于http的调用</del></h3><pre><code class="yaml">service-article  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  # 自定义eureka server的信息
  server:
    hostname: eureka
    port: 7000
  client:
    # 所有的微服务都必须注册到eureka中
    register-with-eureka: true
    # 从注册中心获得检索服务实例
    fetch-registry: true

    # 注册中心的服务地址
    service-url:
#     defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
  instance:
    # 调整微服务(eureka client)和注册中心(eureka server)的心跳时间
    lease-renewal-interval-in-seconds: 3
    # eureka 距离最近的一次心跳等待提出的时间 默认90s
    lease-expiration-duration-in-seconds: 5

# 配置指定自定义的ribbon规则
SERVICE-USER:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule


ribbon:
  ConnectTimeout: 5000          # 创建连接的超时时间，单位：ms
  ReadTimeout: 5000             # 在连接创建好以后，调用接口的超时时间，单位：ms
  MaxAutoRetries: 1             # 最大重试次数
  MaxAutoRetriesNextServer: 2   # 切换到下个微服务实例的重试次数
  # 当请求到某个微服务5s，超时后会进行重试，先重试连接自己当前的这个实例
  # 如果当前重试失败1次，则会切换到访问集群中的下一个微服务实例，切换最大为2次

logging:
  level:
    com.imooc.api.controller.user.UserControllerApi: debug
#    root: debug 日志打印级别

# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full
</code></pre>
<blockquote>
<p>重启所有服务 调用<a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>门户端→文章详情 articleId：2006117B57WRZGHH<br>09:19.009 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— HTTP&#x2F;1.1 200 (590ms)<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] connection: keep-alive<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] content-type: application&#x2F;json<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] date: Mon, 05 Aug 2024 09:09:19 GMT<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] keep-alive: timeout&#x3D;60<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] transfer-encoding: chunked<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Headers<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Access-Control-Request-Method<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] vary: Origin<br>09:19.011 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds]<br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] {“status”:200,”msg”:”操作成功！”,”success”:true,”data”:[{“id”:”200628AFYM7AGWPH”,”nickname”:”我是慕课网”,”face”:”<a target="_blank" rel="noopener" href="https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null%7D]%7D">https://imooc-news-dev.oss-cn-shanghai.aliyuncs.com/images/abc/200628AFYM7AGWPH/2007088XH2WT7GXP.png&quot;,&quot;activeStatus&quot;:1,&quot;myFollowCounts&quot;:null,&quot;myFansCounts&quot;:null}]}</a><br>09:19.013 [http-nio-8001-exec-7] DEBUG c.i.a.c.user.UserControllerApi - [UserControllerApi#queryByIds] &lt;— END HTTP (286-byte body)<br>09:19.518 [PollingServerListUpdater-0] INFO  c.n.config.ChainedDynamicProperty - Flipping property: service-user.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit &#x3D; 2147483647<br>09:21.013 [scheduling-1] INFO  c.imooc.api.aspect.ServiceLogAspect - 开始执行 class com.imooc.article.service.impl.ArticleServiceImpl.updateAppointToPublish </p>
</blockquote>
<h3 id="阐述断路器及概念【hystrix】"><a href="#阐述断路器及概念【hystrix】" class="headerlink" title="阐述断路器及概念【hystrix】"></a>阐述断路器及概念【hystrix】</h3><h6 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h6><ul>
<li><strong>Hystrix</strong></li>
<li><strong>提供容错机制，避免微服务系统雪崩</strong></li>
</ul>
<h6 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/397bfbaea5edddda83d11dce86c9e70cbac33f5c/data/hystrix%E6%96%AD%E8%B7%AF%E5%99%A8_%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7.png"></p>
<h3 id="模拟服务故障【hystrix】"><a href="#模拟服务故障【hystrix】" class="headerlink" title="模拟服务故障【hystrix】"></a>模拟服务故障【hystrix】</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8001/doc.html">慕课新闻·自媒体接口8001api</a>  同上<br>会报Timeout超时的异常</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
   @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;

    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="服务提供者熔断【hystrix】"><a href="#服务提供者熔断【hystrix】" class="headerlink" title="服务提供者熔断【hystrix】"></a>服务提供者熔断【hystrix】</h3><pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;


    public GraceJSONResult queryByIdsFallback(String userIds) &#123;
        System.out.println(&quot;进入降级方法：queryByIdsFallback&quot;);

        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        for (String userId : userIdList)&#123;
            // 手动构建空对象，详情页所展示的用户信息可有可无 返回空对象
            AppUserVO userVO = new AppUserVO();
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<pre><code class="java">service-user  com/imooc/user/Application.java
package com.imooc.user;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.ComponentScan;
import tk.mybatis.spring.annotation.MapperScan;

@SpringBootApplication(exclude = MongoAutoConfiguration.class)
@MapperScan(basePackages = &quot;com.imooc.user.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient   // 开启eureka client 注册到server中
@EnableCircuitBreaker // 开启hystrix的熔断机制
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
===============================================================
进入降级方法
</code></pre>
<pre><code class="yaml">service-user  application.yml
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
</code></pre>
<h3 id="全局降级【hystrix】"><a href="#全局降级【hystrix】" class="headerlink" title="全局降级【hystrix】"></a>全局降级【hystrix】</h3><blockquote>
<p>只需要return一个错误就行了没必要100个方法写100个降级<br>{</p>
<p>​    status: 555,<br>​    msg: “”全局降级：系统繁忙，请稍后再试！””<br>​    success: false,<br>​    data: null</p>
<p>}</p>
</blockquote>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java
@RestController
@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)
public class UserController extends BaseController implements UserControllerApi &#123;
    final static Logger logger = LoggerFactory.getLogger(UserController.class);

    @Autowired
    private UserService userService;

    // 其他方法一旦发现异常就会进入这个方法里面 全局唯一 其他的降级方法要注释
    public GraceJSONResult defaultFallback()&#123;
        return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_GLOBAL);
    &#125;
......
&#125;
</code></pre>
<pre><code class="java">// 改动是为了不报错空指针异常 因为已经变成了全局降级  降级的错误信息要调整
    @Autowired
    private UserControllerApi userControllerApi;
    //面向接口 UserControllerApi
    // 发起远程调用，获得用户的基本信息
   /* private List&lt;AppUserVO&gt; getPublisherList(Set idSet) &#123;
GraceJSONResult bodyResult = userControllerApi.queryByIds(JsonUtils.objectToJson(idSet)); 
List&lt;AppUserVO&gt; publisherList = null;
        if (bodyResult.getStatus() == 200) &#123;
            String userJson = JsonUtils.objectToJson(bodyResult.getData());
            publisherList = JsonUtils.jsonToList(userJson, AppUserVO.class);
        &#125;*/ else &#123;
            publisherList = new ArrayList&lt;&gt;();
        &#125;
        return publisherList;
    &#125;
</code></pre>
<pre><code class="java">dev-common  com/imooc/grace/result/ResponseStatusEnum.java
 // 系统错误，未预期的错误 555
    SYSTEM_ERROR(555, false, &quot;系统繁忙，请稍后再试！&quot;),
    SYSTEM_OPERATION_ERROR(556, false, &quot;操作失败，请重试或联系管理员&quot;),
    SYSTEM_RESPONSE_NO_INFO(557, false, &quot;&quot;),
    SYSTEM_ERROR_GLOBAL(558, false, &quot;全局降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;),
    SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<h3 id="服务调用者降级【hystrix】"><a href="#服务调用者降级【hystrix】" class="headerlink" title="服务调用者降级【hystrix】"></a>服务调用者降级【hystrix】</h3><pre><code class="yaml">service-article  application.yml
# 配置feign
feign:
  client:
    config:
      # 配置服务提供方的名称
      service-user:
        logger-level: full

  hystrix:  #打开feign客户端的内置hystrix
    enabled: true
</code></pre>
<pre><code class="java">service-article  com/imooc/article/Application.java //【增加一个@EnableHystrix】
package com.imooc.article;

import com.rule.MyRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.ComponentScan;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import tk.mybatis.spring.annotation.MapperScan;

@EnableSwagger2
@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.article.mapper&quot;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;,&quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@RibbonClient(name = &quot;service-user&quot;, configuration = MyRule.class) //微服务名称
@EnableFeignClients(&#123;&quot;com.imooc&quot;&#125;)
@EnableHystrix
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
====================================================================================
service-article:8001  进入客户端(服务调用者)的降级方法
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/UserControllerApi.java//【@FeignClient增加fallbackFactory】
package com.imooc.api.controller.user;

import com.imooc.api.config.MyServiceList;
import com.imooc.api.controller.user.fallbacks.UserControllerFactoryFallback;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.pojo.bo.RegistLoginBO;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

@Api(value = &quot;用户信息相关Controller&quot;,tags = &#123;&quot;用户信息相关Controller&quot;&#125;)
@RequestMapping(&quot;user&quot;) //fallbackFactory所有方法的降级
@FeignClient(value = MyServiceList.SERVICE_USER, fallbackFactory = UserControllerFactoryFallback.class ) //作为客户端直接调用
public interface UserControllerApi &#123;

    @ApiOperation(value = &quot;获得用户基本信息&quot;,notes = &quot;获得用户基本信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getUserInfo&quot;)
    public GraceJSONResult getUserInfo(@RequestParam String userId);
    @ApiOperation(value = &quot;获得用户账户信息&quot;,notes = &quot;获得用户账户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/getAccountInfo&quot;)
    public GraceJSONResult getAccountInfo(@RequestParam String userId);

//    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
//    @PostMapping(&quot;/updateUserInfo&quot;)
//    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO,
//                                          @RequestParam BindingResult result);
    @ApiOperation(value = &quot;修改/完善用户信息&quot;,notes = &quot;修改/完善用户信息&quot;,httpMethod = &quot;POST&quot;)
    @PostMapping(&quot;/updateUserInfo&quot;)
    public GraceJSONResult updateUserInfo(@RequestBody @Valid UpdateUserInfoBO updateUserInfoBO);


    @ApiOperation(value = &quot;根据用户的ids查询用户列表&quot;,notes = &quot;根据用户的ids查询用户列表&quot;,httpMethod = &quot;GET&quot;)
    @GetMapping(&quot;/queryByIds&quot;)
    public GraceJSONResult queryByIds(@RequestParam String userIds);
&#125;
</code></pre>
<pre><code class="java">service-api  com/imooc/api/controller/user/fallbacks/UserControllerFactoryFallback.java
package com.imooc.api.controller.user.fallbacks;

import com.imooc.api.controller.user.UserControllerApi;
import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.pojo.bo.UpdateUserInfoBO;
import com.imooc.pojo.vo.AppUserVO;
import feign.hystrix.FallbackFactory;
import org.springframework.stereotype.Component;

import javax.validation.Valid;
import java.util.ArrayList;
import java.util.List;

@Component //这个类让容器加载
public class UserControllerFactoryFallback implements FallbackFactory&lt;UserControllerApi&gt; &#123;
    @Override
    public UserControllerApi create(Throwable throwable) &#123;
 // 重写的过程就是降级的过程
        return new UserControllerApi() &#123;
            //SYSTEM_ERROR_FEIGN(559, false, &quot;客户端Feign降级：系统繁忙，请稍后再试！&quot;)
            @Override
            public GraceJSONResult getUserInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult getAccountInfo(String userId) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult updateUserInfo(@Valid UpdateUserInfoBO updateUserInfoBO) &#123;
                return GraceJSONResult.errorCustom(ResponseStatusEnum.SYSTEM_ERROR_FEIGN);
            &#125;

            @Override
            public GraceJSONResult queryByIds(String userIds) &#123;
                System.out.println(&quot;进入客户端(服务调用者)的降级方法&quot;);
                List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
                return GraceJSONResult.ok(publisherList);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<h3 id="自动触发熔断隔离与恢复【hystrix】"><a href="#自动触发熔断隔离与恢复【hystrix】" class="headerlink" title="自动触发熔断隔离与恢复【hystrix】"></a>自动触发熔断隔离与恢复【hystrix】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c67b7337984e7ad3913d8d161ec90de36aba38a8/data/%E7%86%94%E6%96%AD%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<pre><code class="yaml">service-user  application.yml #【配置熔断器】
#  配置hystrix
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000   # 设置hystrix超时时间，超过2秒触发降级
      circuitBreaker:   # 配置断路器
        enabled: true
        requestVolumeThreshold: 10    # 触发熔断最小请求次数，默认：20
        sleepWindowInMilliseconds: 15000    # 熔断后过几秒后尝试半开状态（请求重试），默认：5s
        errorThresholdPercentage: 50  # 触发熔断的失败率（异常率/阈值），默认：50
</code></pre>
<pre><code class="java">service-user  com/imooc/user/controller/UserController.java //[FIXME:]
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String myPort;
    // 添加熔断机制 一旦熔断会有替补方法[降级的方法]
    @HystrixCommand//(fallbackMethod = &quot;queryByIdsFallback&quot;)
    @Override
    public GraceJSONResult queryByIds(String userIds) &#123;
        // 1.手动触发异常
        int a = 1/0;
        // 2.模拟超时异常
        try &#123;
            Thread.sleep(6000);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;


        System.out.println(&quot;myPort=&quot; + myPort);
        if (StringUtils.isBlank(userIds))&#123;
            return GraceJSONResult.errorCustom(ResponseStatusEnum.USER_NOT_EXIST_ERROR);
        &#125;
        List&lt;AppUserVO&gt; publisherList = new ArrayList&lt;&gt;();
        List&lt;String&gt; userIdList = JsonUtils.jsonToList(userIds, String.class);//传过来两个用户的id
        // FIXME: 仅用于dev测试，硬编码动态判断来抛出异常
        if (userIdList.size() &gt; 1)&#123;
            System.out.println(&quot;出现异常~~&quot;);
            throw new RuntimeException(&quot;出现异常~~&quot;);
        &#125;

        for (String userId : userIdList)&#123;
            //获得用户基本信息
            AppUserVO userVO = getBasicUserInfo(userId);
            // 3.添加到publisherList
            publisherList.add(userVO);
        &#125;
        return GraceJSONResult.ok(publisherList);
    &#125;
</code></pre>
<h3 id="微服务网关【zuul】维护微服务的ip地址"><a href="#微服务网关【zuul】维护微服务的ip地址" class="headerlink" title="微服务网关【zuul】维护微服务的ip地址"></a>微服务网关【zuul】<del>维护微服务的ip地址</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/56aa521f01816d47174142d710bde78e0f31fd7e/data/%E5%BE%AE1%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3.png"></p>
<h5 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h5><ul>
<li>Zuul (祖尔)</li>
<li>微服务的网关，可以实现动态路由、过滤器等功能</li>
</ul>
<h3 id="构建网关微服务【zuul】"><a href="#构建网关微服务【zuul】" class="headerlink" title="构建网关微服务【zuul】"></a>构建网关微服务【zuul】</h3><pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-zuul&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/zuul.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/logger&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">service-api  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【exclusions是重点】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-zuul-server&lt;/artifactId&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!--&lt;dependency&gt;--&gt;
        &lt;!--&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;
        &lt;!--&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;--&gt;
        &lt;!--&lt;/dependency&gt;--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yml">springcloud-zuul-server  application.yml 
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/controller/HelloController.java
package com.imooc.zuul.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置路由【zuul】"><a href="#配置路由【zuul】" class="headerlink" title="配置路由【zuul】"></a>配置路由【zuul】</h3><pre><code class="yaml">zuul-server  application.yml
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
</code></pre>
<pre><code class="yaml">localhost:8001/portal/article/detail?articleId=2006117B57WRZGHH
直接可以访问到详情数据
微服务网关→ 7070
// service-article: /service-article/** # 请求路径(前缀**)
# localhost:7070/service-article/portal/detail?articleId=2006117B57WRZGHH

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
      path: /service-article/**       # 请求路径(前缀)
      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
# localhost:7070/api/service-article/portal/detail?articleId=2006117B57WRZGHH
</code></pre>
<h3 id="配置微服务实例的路由【zuul】"><a href="#配置微服务实例的路由【zuul】" class="headerlink" title="配置微服务实例的路由【zuul】"></a>配置微服务实例的路由【zuul】</h3><pre><code class="yaml">在路由规则里面的  url: http://192.168.1.2:8001  很容易发生变化
所以直接去请求eureka的SERVICE-USER/ARTICLE
</code></pre>
<pre><code class="xml">springcloud-zuul-server  pom.xml 【取消exclusions注释 包含eureka client】
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除包--&gt;
          &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml
############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-zuul-server  com/imooc/zuul/Application.java 【打开@EnableEurekaClient】
@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
//@EnableZuulServer
@EnableZuulProxy      // @EnableZuulProxy是@EnableZuulServer的一个增强升级版，当zuul和eureka、ribbon等组件共同使用，则使用增强版即可
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【实现service-id进行请求转发 ip发生变化没有关系】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀
</code></pre>
<h3 id="过滤器【zuul】网端ip黑名单拦截"><a href="#过滤器【zuul】网端ip黑名单拦截" class="headerlink" title="过滤器【zuul】网端ip黑名单拦截"></a>过滤器【zuul】<del>网端ip黑名单拦截</del></h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/3cb9704aa86555cd937cb6b045ace81a44ec3dbd/data/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.png"></p>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/MyFilter.java
package com.imooc.zuul.filters;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.stereotype.Component;

/**
 * 构建zuul的自定义过滤器
 */
@Component
public class MyFilter extends ZuulFilter &#123;

    /**
     * 定义过滤器的类型
     *      pre：    在请求被路由之前执行
     *      route：  在路由请求的时候执行
     *      post：   请求路由以后执行
     *      error：  处理请求时发生错误的时候执行
     * @return
     */
    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    /**
     * 过滤器执行的顺序，配置多个有顺序的过滤
     * 执行顺序从小到大
     * @return
     */
    @Override
    public int filterOrder() &#123;
        return 1;
    &#125;

    /**
     * 是否开启过滤器
     *      true：开启
     *      false：禁用
     * @return
     */
    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    /**
     * 过滤器的业务实现
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;display pre zuul filter...&quot;);

        return null;    // 没有意义可以不用管。
    &#125;
&#125;
</code></pre>
<blockquote>
<p> localhost:7070&#x2F;api&#x2F;service-article&#x2F;portal&#x2F;detail?articleId&#x3D;2006117B57WRZGHH<br>刷新成功后 在zuul-7070服务console会有一行<br>display pre zuul filter… [启动成功]</p>
</blockquote>
<h3 id="限制ip黑名单的频繁请求【zuul】"><a href="#限制ip黑名单的频繁请求【zuul】" class="headerlink" title="限制ip黑名单的频繁请求【zuul】"></a>限制ip黑名单的频繁请求【zuul】</h3><pre><code class="yaml">zuul-server  application.yml 【增加ip请求限制的参数配置】
# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
      service-article:                  # 配置微服务的路由id，微服务的实例id
      path: /service-article/**       # 请求路径(前缀)
      service-id: service-article     # 请求转发的微服务实例id
#     url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 简化版本 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀

# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    @Override
    public Object run() throws ZuulException &#123;

        System.out.println(&quot;执行【ip黑名单】过滤器...&quot;);

        System.out.println(&quot;continueCounts: &quot; + continueCounts);
        System.out.println(&quot;timeInterval: &quot; + timeInterval);
        System.out.println(&quot;limitTimes: &quot; + limitTimes);


        // 获得上下文对象
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();

        // 获得ip
        String ip = IPUtil.getRequestIp(request);

        /**
         * 需求：
         *  判断ip在10秒内的请求次数是否超过10次
         *  如果超过，则限制这个ip访问15秒，15秒以后再放行
         */

        final String ipRedisKey = &quot;zuul-ip:&quot; + ip;
        final String ipRedisLimitKey = &quot;zuul-ip-limit:&quot; + ip;

        // 获得当前ip这个key的剩余时间
        long limitLeftTime = redis.ttl(ipRedisLimitKey);
        // 如果当前限制ip的key还存在剩余时间，说明这个ip不能访问，继续等待
        if (limitLeftTime &gt; 0) &#123;
            stopRequest(context);
            return null;
        &#125;

        // 在redis中累加ip的请求访问次数
        long requestCounts = redis.increment(ipRedisKey, 1);
        // 从0开始计算请求次数，初期访问为1，则设置过期时间，也就是连续请求的间隔时间
        if (requestCounts == 1) &#123;
            redis.expire(ipRedisKey, timeInterval);
        &#125;

        // 如果还能取得请求次数，说明用户连续请求的次数落在10秒内
        // 一旦请求次数超过了连续访问的次数，则需要限制这个ip的访问
        if (requestCounts &gt; continueCounts) &#123;
            // 限制ip的访问时间
            redis.set(ipRedisLimitKey, ipRedisLimitKey, limitTimes);
            stopRequest(context);
        &#125;

        return null;
    &#125;

    private void stopRequest(RequestContext context) &#123;
        // 停止zuul继续向下路由，禁止请求通信
        context.setSendZuulResponse(false);
        context.setResponseStatusCode(200);
        String result = JsonUtils.objectToJson(
                GraceJSONResult.errorCustom(
                        ResponseStatusEnum.SYSTEM_ERROR_ZUUL));
        context.setResponseBody(result);
        context.getResponse().setCharacterEncoding(&quot;utf-8&quot;);
        context.getResponse().setContentType(MediaType.APPLICATION_JSON_VALUE);
    &#125;
&#125;

=============================================================================
dev-common  com/imooc/grace/result/ResponseStatusEnum.java
SYSTEM_ERROR_ZUUL(560, false, &quot;请求系统过于繁忙，请稍后再试！&quot;);
</code></pre>
<pre><code class="yaml">zuul-server  application.yml 【把redis增加进来】
############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<blockquote>
<p>此时redis中会出现<br>zuul-ip(1) → zuul-ip  → Value:1<br>zuul-ip-limit(1) → zuul-ip-limit: 本机地址<br>在zuul-7070服务里的Console 显示：<br>display pre zuul filter …<br>执行【ip黑名单】过滤器…</p>
</blockquote>
<h3 id="分布式配置中心【config】"><a href="#分布式配置中心【config】" class="headerlink" title="分布式配置中心【config】"></a>分布式配置中心【config】</h3><ul>
<li><strong>SpringCloud Config</strong></li>
<li><strong>为所有服务提供统一的配置管理服务</strong><del>微服务配置一下子全部生效</del></li>
<li><strong>包含配置服务端与配置客户端</strong></li>
</ul>
<h5 id="配置中心的功能"><a href="#配置中心的功能" class="headerlink" title="配置中心的功能"></a>配置中心的功能</h5><ul>
<li><strong>统一管理配置</strong></li>
<li><strong>管理不同环境下的配置</strong></li>
<li><strong>动态调整配置</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/b1fb9d3f444bf78ad6621441538f809d208f8c1a/data/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.png"></p>
<h3 id="搭配配置中心【config】"><a href="#搭配配置中心【config】" class="headerlink" title="搭配配置中心【config】"></a>搭配配置中心【config】</h3><p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
==========================================================================
config-7080
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/


# 配置动态刷新git配置的路径终端请求地址
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
<pre><code class="xml">springcloud-config  logback-spring.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;configuration&gt;
    &lt;!-- 指定日志文件的存储地址，使用绝对路径 --&gt;
    &lt;property name=&quot;LOG_HOME&quot; value=&quot;/workspaces/logs/imooc-news-dev/springcloud-config&quot;/&gt;

    &lt;!-- Console 输出设置 --&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%white(%d&#123;mm:ss.SSS&#125;) %green([%thread]) %cyan(%-5level) %yellow(%logger&#123;36&#125;) %magenta(-) %black(%msg%n)&lt;/pattern&gt;
            &lt;charset&gt;utf8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- 按照每天生成日志文件 --&gt;
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;!-- 日志文件输出的文件名 --&gt;
            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/config.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--&lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;--&gt;
        &lt;!--&lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;--&gt;
    &lt;!--&lt;/logger&gt;--&gt;

    &lt;root level=&quot;info&quot;&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/controller/HelloController.java
package com.imooc.config.controller;

import com.imooc.grace.result.GraceJSONResult;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController &#123;

    @GetMapping(&quot;/hello&quot;)
    public Object hello() &#123;
        return GraceJSONResult.ok();
    &#125;
&#125;
</code></pre>
<h3 id="配置中心实现git配置读取【config】"><a href="#配置中心实现git配置读取【config】" class="headerlink" title="配置中心实现git配置读取【config】"></a>配置中心实现git配置读取【config】</h3><pre><code class="xml">springcloud-config  pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;imooc-news-dev&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;springcloud-config&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.imooc&lt;/groupId&gt;
            &lt;artifactId&gt;imooc-news-dev-service-api&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="yaml">springcloud-config  application.yml
#增加  cloud:config:server:git: uri
############################################################
#
# 配置服务Config
# web访问端口号  约定：7080
#
############################################################
server:
  port: 7080
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-config
  cloud:
    config:
      server:
        git:
          uri: https://github.com/leechenxiang/imooc-news-config.git
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/
</code></pre>
<pre><code class="java">springcloud-config  com/imooc/config/Application.java
package com.imooc.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration;
import org.springframework.cloud.config.server.EnableConfigServer;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class,
                                    MongoAutoConfiguration.class&#125;)
@ComponentScan(basePackages = &#123;&quot;com.imooc&quot;, &quot;org.n3r.idworker&quot;&#125;)
@EnableEurekaClient
@EnableConfigServer //开启这个配置中心
public class Application &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/leechenxiang/imooc-news-config/tree/master">leechenxiang&#x2F;imooc-news-config (github.com)</a></p>
<blockquote>
<p>localhost:7080&#x2F;zuul-prod.yml    这里直接引用了github上面的yml<br>localhost:7080&#x2F;master&#x2F;zuul-prod.yml   </p>
</blockquote>
<pre><code class="yaml">zuul-dev.yml
blackIp:
  continueCounts: 10
  timeInterval: 10
  limitTimes: 15

zuul-prod.yml
blackIp:
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="配置客户端拉取配置"><a href="#配置客户端拉取配置" class="headerlink" title="配置客户端拉取配置"></a>配置客户端拉取配置</h3><pre><code class="xml">zuul-server  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yml
############################################################
# 系统全局加载文件 先加载这个文件
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server
  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  cloud:
    config:
      label: master # github上的分支
      name: zuul # 定义的服务
      profile: prod  # 所加载的环境变量
#      uri: http://192.168.1.2:7080
      discovery:
        enabled: true
        service-id: springcloud-config


############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/**
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址
  prefix: /api                        # 请求前缀
</code></pre>
<pre><code class="java">启动zuul-7070  //客户端连接config(server)并且动态获得了github的数据
打印控制台Console
display pre zuul filter...
执行【ip黑名单】过滤器...
// zuul-prod.yml
  continueCounts: 40
  timeInterval: 70
  limitTimes: 315
</code></pre>
<h3 id="动态刷新git配置"><a href="#动态刷新git配置" class="headerlink" title="动态刷新git配置"></a>动态刷新git配置</h3><pre><code class="java">// zuul-prod.yml 动态修改数值
  continueCounts: 35
  timeInterval: 305
  limitTimes: 65
在浏览器会显示更新后的数值 但是在console打印台不会显示改后的 只会显示之前的
需要重启服务才可以达到修改后的效果 显示修改的数值
</code></pre>
<pre><code class="xml">zuul-server  pom.xml
添加健康检测的配置
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">zuul-server  com/imooc/zuul/filters/BlackIPFilter.java
//【开启刷新 @RefreshScope 不能全自动 需要触碰某些请求 在yaml配置动态刷新的地址】
package com.imooc.zuul.filters;

import com.imooc.grace.result.GraceJSONResult;
import com.imooc.grace.result.ResponseStatusEnum;
import com.imooc.utils.IPUtil;
import com.imooc.utils.JsonUtils;
import com.imooc.utils.RedisOperator;
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
/* application.yml
*  blackIp:
   continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
   timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
   limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
* */
@Component
@RefreshScope
public class BlackIPFilter extends ZuulFilter &#123;

    @Value(&quot;$&#123;blackIp.continueCounts&#125;&quot;)
    public Integer continueCounts;
    @Value(&quot;$&#123;blackIp.timeInterval&#125;&quot;)
    public Integer timeInterval;
    @Value(&quot;$&#123;blackIp.limitTimes&#125;&quot;)
    public Integer limitTimes;

    @Autowired
    private RedisOperator redis;

    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    @Override
    public int filterOrder() &#123;
        return 2;
    &#125;

    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="yaml">zuul-server  bootstrap.yml  +  springcloud-config  application.yaml
# 配置动态刷新git配置的路径终端请求地址 只需要通过URL请求不用重启就可以自动刷新 后期要通过脚本运行才可【通过请求处理 postman → POST → https://localhost:7070/actuator/refresh】
management:
  endpoints:
    web:
      exposure:
        include: refresh
# 此时回到console就可以有更新后的数据显示了
</code></pre>
<h3 id="消息总线概述【bus】-RabbitMQ"><a href="#消息总线概述【bus】-RabbitMQ" class="headerlink" title="消息总线概述【bus】[RabbitMQ]"></a>消息总线概述【bus】<del>[RabbitMQ]</del></h3><h5 id="Config遗留问题"><a href="#Config遗留问题" class="headerlink" title="Config遗留问题"></a>Config遗留问题</h5><ul>
<li><strong>手动刷新与业务耦合</strong> [也可能在文章&#x2F;user模块发生]</li>
<li>Config配置中心的刷新去解决动态刷新</li>
<li><strong>N个微服务端需要N次手动书信</strong></li>
</ul>
<h5 id="消息总线-要和config与微服务端进行配置"><a href="#消息总线-要和config与微服务端进行配置" class="headerlink" title="消息总线(要和config与微服务端进行配置)"></a>消息总线<del>(要和config与微服务端进行配置)</del></h5><ul>
<li><strong>SpringCloud Bus</strong></li>
<li>为SpringCloud Config提供增益buff</li>
<li><strong>可以实现配置自动刷新</strong>[1k个 1w个]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5fc0f342c2ab14a5e7e3aa9869b97348c7ed39ed/data/%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0.jpg"></p>
<h3 id="配置实现消息统一发送【bus】"><a href="#配置实现消息统一发送【bus】" class="headerlink" title="配置实现消息统一发送【bus】"></a>配置实现消息统一发送【bus】</h3><blockquote>
<p>config把消息推給zull-server</p>
</blockquote>
<pre><code class="xml">springcloud-config  pom.xml    ＋    zuul-server  pom.xml
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server  resources/bootstrap.yaml  +  springcloud-config  application.yaml
  rabbitmq:
    host: 192.168.1.204
    port: 5672
    username: admin
    password: admin
    virtual-host: imooc-news-dev
</code></pre>
<blockquote>
<p>实现刷新server端达到所有的刷新配置<br>【通过请求处理 postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh%E3%80%91">https://localhost:7080/actuator/bus-refresh】</a><br>若想精确刷新某个服务 需要拼接<br> postman → POST → <a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/%7B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E4%BE%8Bid%7D:%7Bport%7D">https://localhost:7080/actuator/bus-refresh/{微服务的实例id}:{port}</a><br>微服务实例id是yaml配置项目信息 → spring.application.name：springcloud-zuul-server<br><a target="_blank" rel="noopener" href="https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070">https://localhost:7080/actuator/bus-refresh/springcloud-zuul-server:7070</a> 【目标微服务地址实现精确打击】</p>
</blockquote>
<h3 id="消息驱动概述【stream】"><a href="#消息驱动概述【stream】" class="headerlink" title="消息驱动概述【stream】"></a>消息驱动概述【stream】</h3><h5 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h5><ul>
<li><strong>SpringCloud Stream</strong></li>
<li><strong><span style = "color:red">统一封装消息的服务框架</span></strong></li>
<li>RabbitMQ，RocketMQ，Kafka，ActiveMQ，ZeroMQ，…</li>
</ul>
<h5 id="Stream消息模型"><a href="#Stream消息模型" class="headerlink" title="Stream消息模型"></a>Stream消息模型</h5><img src="https://raw.githubusercontent.com/P-luminary/images/995964c627f628ee94ebb76bbbe6fe7872884f32/data/Stream%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.png" style="zoom:80%;" />



<h3 id="实现消费者与生产者【stream】"><a href="#实现消费者与生产者【stream】" class="headerlink" title="实现消费者与生产者【stream】"></a>实现消费者与生产者【stream】</h3><blockquote>
<p>将zuul-server的resources&#x2F;application.yml 恢复到原来配置</p>
</blockquote>
<pre><code class="yaml">############################################################
#
# 网关zuul
# web访问端口号  约定：7070
#
############################################################
server:
  port: 7070
  tomcat:
    uri-encoding: UTF-8

############################################################
#
# 配置项目信息
#
############################################################
spring:
  application:
    name: springcloud-zuul-server

  redis:
    database: 0
    host: 192.168.1.201
    port: 6379
    password: 123456
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1

############################################################
#
# eureka client 配置信息
#
############################################################
eureka:
  server:
    hostname: eureka
    port: 7000
  client:
    register-with-eureka: true
    fetch-registry: true
    service-url:
      #defaultZone: http://$&#123;eureka.server.hostname&#125;:$&#123;eureka.server.port&#125;/eureka/
      defaultZone: http://eureka-cluster-7001:7001/eureka/,http://eureka-cluster-7002:7002/eureka/,http://eureka-cluster-7003:7003/eureka/

# 路由规则: http://[网关地址]:[端口号]/[prefix]/[微服务实例id]/[请求地址路径]
zuul:
  routes:
    # 由于路由id和微服务实例id相同，我们可以简化转发的配置
    service-article: /service-article/** # 请求路径(前缀)
  #    service-article:                  # 配置微服务的路由id，微服务的实例id
#      path: /service-article/**       # 请求路径(前缀)
#      service-id: service-article     # 请求转发的微服务实例id
#      url: http://192.168.1.2:8001    # 请求转发到指定的微服务所在的ip地址(8001文章服务)
  prefix: /api                        # 请求前缀



# ip请求限制的参数配置
blackIp:
  continueCounts: $&#123;counts:10&#125;    # ip连续请求的次数
  timeInterval: $&#123;interval:10&#125;    # ip判断的事件间隔，单位：秒
  limitTimes: $&#123;times:15&#125;         # 限制的事件，单位：秒
</code></pre>
<pre><code class="xml">service-article  pom.xml  +  service-user  pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;
            &lt;version&gt;4.1.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">service-article  application.yaml      +      service-user  application.yaml
    cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;

import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;

    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();  //订阅能力的通道
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamChannel.java
package com.imooc.article.stream;


import org.springframework.cloud.stream.annotation.Input;
import org.springframework.cloud.stream.annotation.Output;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.stereotype.Component;

/**
 * 声明构建通道channel
 */
@Component
public interface MyStreamChannel &#123;
    String OUTPUT = &quot;myOutput&quot;;
    String INPUT = &quot;myInput&quot;;

    @Output(MyStreamChannel.OUTPUT)
    MessageChannel output();

    @Input(MyStreamChannel.INPUT)
    SubscribableChannel input();
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
    public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
    public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125;

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125;

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
        streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<h3 id="消息分组与持久化【stream】"><a href="#消息分组与持久化【stream】" class="headerlink" title="消息分组与持久化【stream】"></a>消息分组与持久化【stream】</h3><blockquote>
<p>避免重复消费  分组group 组内消费者不会重复消费</p>
</blockquote>
<h5 id="Stream消息分组"><a href="#Stream消息分组" class="headerlink" title="Stream消息分组"></a>Stream消息分组</h5><pre><code class="yaml">service-article  application.yml  
  cloud:
    stream:
      bindings:                    # 绑定通道和交换机
        myOutput:                   # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput:                    # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: boys

------------------------------------------------------------------------------

service-user  application.yml
  cloud:
    stream:
      bindings: # 绑定通道和交换机
        myOutput: # 定义生产者的通道
          # 自定义交换机的名字，也就是代码里构建的信息，交给底层mq的交换机
          destination:
        myInput: # 定义消费者通道
          # 自定义交换机的名字，也就是消息从底层mq输入到消费端进行消费
          destination:
          group: girls
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamService.java
package com.imooc.article.stream;

public interface StreamService &#123;
  //public void sendMsg();
    public void eat(String dumpling);
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/StreamServiceImpl.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

/**
 * 开启绑定器
 * 绑定通道channel
 */
@Component
@EnableBinding(MyStreamChannel.class)
public class StreamServiceImpl implements StreamService &#123;

    @Autowired
    private MyStreamChannel myStreamChannel;

    @Override
 /* public void sendMsg() &#123;
        AppUser user = new AppUser();
        user.setId(&quot;10101&quot;);
        user.setNickname(&quot;imooc&quot;);

        // 消息通过绑定器发送给mq
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(user).build());
    &#125; */

    @Override
    public void eat(String dumpling) &#123;
        myStreamChannel.output()
                .send(MessageBuilder.withPayload(dumpling).build());
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/stream/MyStreamConsumer.java
package com.imooc.article.stream;

import com.imooc.pojo.AppUser;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.annotation.StreamListener;
import org.springframework.stereotype.Component;

/**
 * 构建消费端
 */
@Component
@EnableBinding(MyStreamChannel.class) //开启通道绑定
public class MyStreamConsumer &#123;

    /**
     * 监听并且实现消息的消费和相关业务处理
     */
 /* @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(AppUser user) &#123;
        System.out.println(user.toString());
    &#125; */

    @StreamListener(MyStreamChannel.INPUT)
    public void receiveMsg(String dumpling) &#123;
        System.out.println(dumpling);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service-article  com/imooc/article/controller/HelloController.java

@RestController
@RequestMapping(&quot;producer&quot;)
public class HelloController &#123;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private StreamService streamService;

    @GetMapping(&quot;/stream&quot;)
    public Object stream() &#123;
     // streamService.sendMsg();

        for (int i = 0 ; i &lt; 10 ; i ++ ) &#123;
            streamService.eat(&quot;我吃了第&quot; + (i+1) + &quot;只饺子~&quot;);
        &#125;

        return &quot;ok~~!!!&quot;;
    &#125;
</code></pre>
<blockquote>
<p>消息不会被重复消费<br>service-article:8001   我吃了1-10只饺子~  【消费的饺子总数一共10次】<br>service-user:8003(女生) 我吃了1 3 5 7 9只饺子~    【饺子随机】<br>service-user:8013(男生) 我吃了2 4 6 8 10只饺子~  【饺子随机】</p>
<p>如果把service-user:8003(女生)  service-user:8013(男生) 服务stop 用户微服务无法接收任何消息<br>但是我们定义了group → 消息是可以持久化的 当重启用户微服务之后  就会打印出刚刚已经吃的饺子了<br>服务器宕机  &#x3D;  吃饺子中途去上厕所 回来后仍然还能吃到饺子</p>
</blockquote>
<h3 id="链路追踪概述与zipkin【sleuth】组件"><a href="#链路追踪概述与zipkin【sleuth】组件" class="headerlink" title="链路追踪概述与zipkin【sleuth】组件"></a>链路追踪概述与zipkin【sleuth】<del>组件</del></h3><h5 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h5><ul>
<li><strong>Sleuth</strong></li>
<li><strong>贯穿整个微服务系统中，追踪一个请求的过程</strong></li>
<li><strong>zipkin 可视化控制面板</strong></li>
</ul>
<blockquote>
<p>下载zipkin-server-2.12.6-exec.jar<br>CMD → C:\Users\Pluminary&gt;java -jar &#x2F;Users&#x2F;Pluminary&#x2F;Desktop&#x2F;zipkin-server-2.12.6-exec.jar<br><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="整合zipkin【sleuth】项目入口是网关"><a href="#整合zipkin【sleuth】项目入口是网关" class="headerlink" title="整合zipkin【sleuth】项目入口是网关"></a>整合zipkin【sleuth】<del>项目入口是网关</del></h3><pre><code class="xml">zuul-server  pom.xml  +  service-article  pom.xml  +  service-user  pom.xml
         &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">zuul-server与service-article与service-user  application.yml
  zipkin:
    # 配置zipkin采集的服务地址，数据会发送到这里
    base-url: http://192.168.1.2:9411/
    sender:
      # 数据采集的传输通信方式，web http的形式
      type: web
  sleuth:
    sampler:
      # 数据采样比例（百分数），0~1
      probability: 1
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://localhost:9411/zipkin/">https://localhost:9411/zipkin/</a></p>
</blockquote>
<h3 id="SpringCloud章节总结"><a href="#SpringCloud章节总结" class="headerlink" title="SpringCloud章节总结"></a>SpringCloud章节总结</h3><ul>
<li><strong>eureka 注册中心</strong></li>
<li><strong>ribbon 负载均衡</strong></li>
<li><strong>feign 声明式客户端</strong></li>
<li><strong>hystrix 熔断降级组件</strong></li>
<li><strong>zuul 网关</strong></li>
<li><strong>config 配置中心</strong></li>
<li><strong>bus 消息总线</strong></li>
<li><strong>stream 消息驱动</strong></li>
<li><strong>zipkin + sleuth 链路追踪</strong></li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/12/后端/Cloud分布式微服务打造大型自媒体3大业务平台/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/">
        <h2>
            Zookeeper+Dubbo应用与面试
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/5/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Zookeeper-Dubbo与面试周介绍"><a href="#Zookeeper-Dubbo与面试周介绍" class="headerlink" title="Zookeeper+Dubbo与面试周介绍"></a>Zookeeper+Dubbo与面试周介绍</h1><ul>
<li>Zookeeper的下载、配置与运行</li>
<li>数据结构node与常用命令</li>
<li>Watcher机制和权限cal介绍</li>
<li>使用Zookeeper的Java原生客户端和Curator进行开发</li>
<li>RPC调用，在Dubbo架构下各服务的关系</li>
<li>整合Dubbo和Zookeeper</li>
<li>完成Dubbo开发案例</li>
<li>线程进阶面试</li>
<li>分布式、微服务面试题</li>
<li>Spring Cloud、Zookeeper的理解</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li>理解Zookeeper</li>
<li>安装、配置</li>
<li>节点znode</li>
<li>常用命令</li>
<li>Watcher机制</li>
<li>ACL权限控制</li>
<li>代码实操</li>
</ul>
<h3 id="理解Zookeeper"><a href="#理解Zookeeper" class="headerlink" title="理解Zookeeper"></a>理解Zookeeper</h3><ul>
<li>5大特点</li>
<li>集群架构</li>
<li>Zookeeper和CAP关系</li>
<li>Zookeeper作用</li>
</ul>
<h3 id="为什么需要Zookeeper"><a href="#为什么需要Zookeeper" class="headerlink" title="为什么需要Zookeeper"></a>为什么需要Zookeeper</h3><ul>
<li><p>用起来像<strong>单机</strong>但是又比单机更<strong>可靠</strong></p>
</li>
<li><p>leader在团队里的<strong>协调</strong>作用  </p>
</li>
<li><p>内存、单机 </p>
</li>
<li><p>集群、<strong>可靠</strong></p>
</li>
<li><p>当信息<strong>还没同步完成时，不对外提供服务</strong></p>
</li>
<li><p>同步的时间压缩的更短</p>
</li>
</ul>
<h3 id="Zookeeper诞生历史"><a href="#Zookeeper诞生历史" class="headerlink" title="Zookeeper诞生历史"></a>Zookeeper诞生历史</h3><p>雅虎研究室</p>
<ul>
<li>无单点问题的<strong>分布式协调架构</strong>，精力集中在处理业务逻辑</li>
<li>内部很多项目都是使用动物的名字来命名</li>
<li>大型动物园</li>
</ul>
<h3 id="Zookeeper是什么-底层是Java"><a href="#Zookeeper是什么-底层是Java" class="headerlink" title="Zookeeper是什么 [底层是Java]"></a>Zookeeper是什么 [底层是Java]</h3><ul>
<li>Zookeeper是<strong>开源的高性能的分布式应用协调系统</strong>，一个高性能的分布式数据一致性解决方案</li>
</ul>
<h3 id="5大特点"><a href="#5大特点" class="headerlink" title="5大特点"></a>5大特点</h3><ul>
<li>顺序一致性</li>
<li>原子性 [全部成功或者全部不成功]</li>
<li>单一视图 [无论连接哪个 都是一致的信息]</li>
<li>可靠性</li>
<li>及时性 [一定时间内能从服务器读到状态]</li>
</ul>
<h5 id="架构图、集群、工作过程"><a href="#架构图、集群、工作过程" class="headerlink" title="架构图、集群、工作过程"></a>架构图、集群、工作过程</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/b25f2311da13cf23726ffd71545a05cdc2630f95/data/zookeeper%E6%9E%B6%E6%9E%84%E5%9B%BE%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.jpg"></p>
<h3 id="Zookeeper和CAP的关系"><a href="#Zookeeper和CAP的关系" class="headerlink" title="Zookeeper和CAP的关系"></a>Zookeeper和CAP的关系</h3><ul>
<li>CP：一致性+分区容错性</li>
<li>能<strong>得到一致的数据结果</strong>，同时系统对网络具备容错性</li>
<li>但是它不能保证每次服务请求的可用性</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>分布式服务注册与订阅</li>
<li>统一配置文件</li>
<li>生成分布式唯一ID [&#x2F;order-0000001、&#x2F;order-0000002]</li>
<li>Master节点选举</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/96130bcb29ba40dee3d21543e5d7b46f33ad9920/data/Zookeeper%E7%89%B9%E7%82%B9.jpg"></p>
<h5 id="针对不能同时进行写数据，保证互斥同步-→-分布式锁"><a href="#针对不能同时进行写数据，保证互斥同步-→-分布式锁" class="headerlink" title="针对不能同时进行写数据，保证互斥同步 → 分布式锁"></a>针对不能同时进行写数据，保证互斥同步 → 分布式锁</h5><h3 id="Zookeeper的安装、配置"><a href="#Zookeeper的安装、配置" class="headerlink" title="Zookeeper的安装、配置"></a>Zookeeper的安装、配置</h3><ul>
<li>寻找教辅里的<code>apache-zookeeper-3.6.0-bin.tar</code></li>
<li>解压压缩包：<code>tar zxvf apache-zookeeper-3.6.0-bin.tar.gz</code></li>
<li>进入压缩包：<code>cd apache-zookeeper-3.6.0-bin</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls
bin  conf  docs  lib  LICENSE.txt  NOTICE.txt  README.md README_packaging.md
</code></pre>
<ul>
<li>配置[进入文件]：<code>cp conf/zoo_sample.cfg conf/zoo</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# cp conf/zoo_sample.cfg conf/zoo
[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ls conf/
configuration.xsl  log4j.properties  zoo  zoo.cfg  zoo_sample.cfg
</code></pre>
<ul>
<li>打开文件, 进行修改：<code>vi conf/zoo.cfg</code></li>
</ul>
<pre><code class="java">找到 dataDir=/tmp/zookeeper
修改成 dataDir=/tmp/lib/zookeeper 以免被自动清除
</code></pre>
<ul>
<li>启动：<code>./bin/zkServer.sh start</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 1877.
======================================================================
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... ^[[ASTARTED
[root@iZbp1dssknxftmjczbtpndZ bin]# ./zkServer.sh status
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: standalone
======================================================================
</code></pre>
<ul>
<li>停止：<code>./bin/zkServer.sh stop</code></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh stop
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Stopping zookeeper ... STOPPED
</code></pre>
<h3 id="znode节点-基本数据模型"><a href="#znode节点-基本数据模型" class="headerlink" title="znode节点 [基本数据模型]"></a>znode节点 [基本数据模型]</h3><ul>
<li><h5 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h5></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h5 id="节点性质"><a href="#节点性质" class="headerlink" title="节点性质"></a>节点性质</h5><ul>
<li>树形结构，也可以理解为linux的文件目录</li>
<li>每一个节点都是znode，里面可以包含<strong>数据</strong>，也可以有<strong>子节点</strong></li>
<li>点分为<strong>永久节点</strong>和<strong>临时节点</strong>(与客户端绑定) [session失效，也就是客户端断开过，临时节点消失]</li>
<li>每个znode都有<strong>版本号</strong>，每当数据变化，版本号都会累加(<strong>乐观锁</strong>)</li>
<li>删除或修改节点，版本号不匹配的话(版本号已超时), 会报错)</li>
<li>每个节点存储的<strong>数据不宜过大</strong>，几k即可 [保存路径再去查询]</li>
<li>节点可以设置<strong>权限</strong>，来限制用户的访问</li>
<li>Zookeeper保证读和写都是<strong>原子操作</strong>，且每次读写操作都是对数据的完整读取或完整写入</li>
</ul>
<h5 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h5><ul>
<li><strong>持久</strong>节点</li>
<li><strong>临时</strong>节点</li>
<li><strong>顺序</strong>节点</li>
</ul>
<h5 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h5><ul>
<li>dataVersion</li>
<li>cversion [child]</li>
<li>aclVersion [权限]</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><span style = "color:blue">常用命令</span></h2><ul>
<li><p>启动：<code>./bin/zkServer.sh start</code></p>
</li>
<li><p>连接到Zookeeper</p>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... STARTED

[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkCli.sh -server 127.0.0.1:2181
</code></pre>
</li>
<li><p><span style = "color:red"><strong>查看节点</strong></span></p>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 3] ls 
ls [-s] [-w] [-R] path
[zk: 127.0.0.1:2181(CONNECTED) 4] ls /
[zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 5] ls /zookeeper
[config, quota]
[zk: 127.0.0.1:2181(CONNECTED) 6] 
</code></pre>
<ul>
<li>查看节点状态：<code>stat /</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 6] stat /
cZxid = 0x0
ctime = Thu Jan 01 08:00:00 CST 1970
mZxid = 0x0
mtime = Thu Jan 01 08:00:00 CST 1970
pZxid = 0x0
cversion = -1    //子节点更改的次数
dataVersion = 0  //数据更改的情况
aclVersion = 0   //权限修改的情况
ephemeralOwner = 0x0  //[0是永久节点 其他的是临时节点]
dataLength = 0
numChildren = 1  //有几个子节点
</code></pre>
<ul>
<li>查看节点的数据和状态：<code>get</code></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 7] get /45
jj
</code></pre>
<ul>
<li>创建、修改、删除节点</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 8] create
create [-s] [-e] [-c] [-t ttl] path [data] [acl]

//创建
[zk: 127.0.0.1:2181(CONNECTED) 9] create /imooc2
Created /imooc2
[zk: 127.0.0.1:2181(CONNECTED) 10] create /imooc3 123
Created /imooc3
[zk: 127.0.0.1:2181(CONNECTED) 11] get /imooc3
123

[zk: 127.0.0.1:2181(CONNECTED) 12] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x5
mtime = Sun May 05 01:41:21 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0

//修改
[zk: 127.0.0.1:2181(CONNECTED) 13] set /imooc3 456
[zk: 127.0.0.1:2181(CONNECTED) 14] get /imooc3
456
[zk: 127.0.0.1:2181(CONNECTED) 15] stat /imooc3
cZxid = 0x5
ctime = Sun May 05 01:41:21 CST 2024
mZxid = 0x6
mtime = Sun May 05 01:42:16 CST 2024
pZxid = 0x5
cversion = 0
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
</code></pre>
</li>
</ul>
<h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a><span style = "color:blue">高级命令</span></h2><h4 id="创建节点的高级功能"><a href="#创建节点的高级功能" class="headerlink" title="创建节点的高级功能"></a>创建节点的高级功能</h4><ul>
<li><h5 id="创建顺序节点-s-会戴上序号"><a href="#创建顺序节点-s-会戴上序号" class="headerlink" title="创建顺序节点 [-s] (会戴上序号)"></a>创建顺序节点 [-s] (会戴上序号)</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 16] create /imooc4
Created /imooc4
[zk: 127.0.0.1:2181(CONNECTED) 17] create -s /imooc4 /s
Created /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 18] create -s /imooc4 /s
Created /imooc40000000004
</code></pre>
<ul>
<li><h5 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h5><blockquote>
<p>ephemeralOwner &#x3D; 0x0  [0是永久节点 其他的是临时节点]</p>
</blockquote>
</li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 22] create /imooc
Created /imooc
[zk: 127.0.0.1:2181(CONNECTED) 23] create -e /imooc/tmp 123
Created /imooc/tmp
[zk: 127.0.0.1:2181(CONNECTED) 24] stat /imooc/tmp
cZxid = 0xd
ctime = Sun May 05 01:48:50 CST 2024
mZxid = 0xd
mtime = Sun May 05 01:48:50 CST 2024
pZxid = 0xd
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x10085ad02c90001  //[0x0是永久节点 其他的是临时节点]
dataLength = 3
numChildren = 0
</code></pre>
<ul>
<li><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 27] set /imooc 6
[zk: 127.0.0.1:2181(CONNECTED) 28] get /imooc
6
[zk: 127.0.0.1:2181(CONNECTED) 29] stat /imooc
cZxid = 0xc
ctime = Sun May 05 01:48:46 CST 2024
mZxid = 0xe
mtime = Sun May 05 01:51:15 CST 2024
pZxid = 0xd
cversion = 1
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 1
numChildren = 1 
//set -v 1 /imooc 9 是因为上面 dataVersion = 1  指定条件版本更新
[zk: 127.0.0.1:2181(CONNECTED) 35] set -v 1 /imooc 9  
[zk: 127.0.0.1:2181(CONNECTED) 36] get /imooc
9
</code></pre>
<ul>
<li><h5 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h5></li>
</ul>
<pre><code class="java">[zk: 127.0.0.1:2181(CONNECTED) 38] delete
delete [-v version] path //也可以按照版本号去删除
[zk: 127.0.0.1:2181(CONNECTED) 42] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000003, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 43] delete /imooc40000000003
[zk: 127.0.0.1:2181(CONNECTED) 44] ls /
[imooc, imooc2, imooc3, imooc4, imooc40000000004, imooc40000000005, zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 45] 
</code></pre>
<h3 id="Watcher机制"><a href="#Watcher机制" class="headerlink" title="Watcher机制"></a><span style = "color:red">Watcher机制</span></h3><ul>
<li><h5 id="触发器、监督者"><a href="#触发器、监督者" class="headerlink" title="触发器、监督者"></a>触发器、监督者</h5></li>
<li><h5 id="使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息"><a href="#使用场景：统一资源配置-发生变化时-会給所有监听客户端发送信息" class="headerlink" title="使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]"></a>使用场景：统一资源配置 [发生变化时 会給所有监听客户端发送信息]</h5></li>
</ul>
<h5 id="Watcher事件类型"><a href="#Watcher事件类型" class="headerlink" title="Watcher事件类型"></a>Watcher事件类型</h5><table>
<thead>
<tr>
<th>EventType</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>NodeCreated (节点创建)</td>
<td>Watcher监听的对应数据节点被创建</td>
</tr>
<tr>
<td>NodeDeleted (节点删除)</td>
<td>Watcher监听的对应数据节点被删除</td>
</tr>
<tr>
<td>NodeDataChanged(节点数据修改)</td>
<td>Watcher监听的对应数据节点的数据内容发生变更</td>
</tr>
<tr>
<td>NodeChildrenChanged(子节点变更)</td>
<td>Watcher监听的对应数据节点的子节点列表发生变更</td>
</tr>
</tbody></table>
<h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><ul>
<li>access control list 权限控制</li>
<li>它使用<strong>权限位</strong>来允许&#x2F;禁止对话节点及其所作用域的各种操作</li>
<li>ACL仅与特定的znode有关，与<strong>子节点无关</strong></li>
</ul>
<h5 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h5><ul>
<li>ACL：[scheme采用的权限机制：id用户：permissions权限组合字符串]</li>
<li>world</li>
<li>auth [认证登录]</li>
<li>digest [密文加密]</li>
<li>ip [只允许特定ip访问]</li>
<li>super [超级权限]</li>
</ul>
<h5 id="权限字符串crdwa"><a href="#权限字符串crdwa" class="headerlink" title="权限字符串crdwa"></a>权限字符串crdwa</h5><ul>
<li><h6 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h6></li>
<li><h6 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h6></li>
<li><h6 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h6></li>
<li><h6 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h6></li>
<li><h6 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h6></li>
</ul>
<h5 id="ACL-权限使用场景"><a href="#ACL-权限使用场景" class="headerlink" title="[ACL]权限使用场景"></a>[ACL]权限使用场景</h5><ul>
<li>区分开发&#x2F;测试&#x2F;运维环境，防止误操作</li>
<li>可以针对不同IP而产生具体的配置，更安全</li>
</ul>
<h3 id="Java原生客户端连接到zookeeper-ZK"><a href="#Java原生客户端连接到zookeeper-ZK" class="headerlink" title="Java原生客户端连接到zookeeper [ZK]"></a>Java原生客户端连接到zookeeper [ZK]</h3><ul>
<li>利用<strong>ZK原生的Java</strong>的API</li>
<li>利用Apache <strong>Curator</strong>作为客户端来操作ZK</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;zk-practicer&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.6.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/ZKConnect.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.omg.CORBA.TIMEOUT;

import java.io.IOException;

/**
 * 连接到ZK服务端，打印连接状态
 */
public class ZKConnect implements Watcher &#123;
    public static final String SERVER_PATH=&quot;47.98.225.105:2181&quot;;
    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args) throws IOException, InterruptedException &#123;
        //后面new的相当于把这个作为参数传递进去
        //客户端和服务端是异步连接，连接成功之后，客户端会收到watcher通知
        //connectString：服务器的IP+端口号
        //sessionTImeout：超时时间
        //watcher：接收通知事件
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKConnect());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());
    &#125;

    @Override
    public void process(WatchedEvent watchedEvent) &#123;
        System.out.println(&quot;收到了通知&quot; + watchedEvent);
    &#125;
&#125;
===========================================================
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.free=466MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.max=7209MB
17:35:46 INFO zookeeper.ZooKeeper: Client environment:os.memory.total=487MB
17:35:46 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=127.0.0.1:2181 sessionTimeout=5000 watcher=com.imooc.zkjavaapi.ZKConnect@7591083d
17:35:46 INFO common.X509Util: Setting -D jdk.tls.rejectClientInitiatedRenegotiation=true to disable client-initiated TLS renegotiation
17:35:46 INFO zookeeper.ClientCnxnSocket: jute.maxbuffer value is 1048575 Bytes
17:35:46 INFO zookeeper.ClientCnxn: zookeeper.request.timeout value is 0. feature enabled=false
客户端开始连接ZK服务器了
CONNECTING
17:35:46 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:35:46 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:35:46 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:50517, server: 127.0.0.1/127.0.0.1:2181
17:35:46 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
</code></pre>
<pre><code class="xml">log4j.properties
log4j.rootLogger=INFO, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d&#123;HH:mm:ss&#125; %p %c&#123;2&#125;: %m%n
</code></pre>
<pre><code class="linux">[root@iZbp1dssknxftmjczbtpndZ apache-zookeeper-3.6.0-bin]# ./bin/zkServer.sh start
/usr/bin/java
ZooKeeper JMX enabled by default
Using config: /root/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg
Starting zookeeper ... already running as process 4147.
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33316784/article/details/88563482">windows环境下安装zookeeper教程详解（单机版）_windows zooke-CSDN博客</a></p>
<h3 id="用代码对节点进行操作"><a href="#用代码对节点进行操作" class="headerlink" title="用代码对节点进行操作"></a>用代码对节点进行操作</h3><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:57:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:57:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:57:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57443, server: 127.0.0.1/127.0.0.1:2181
17:57:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710008, negotiated timeout = 5000
/imooc-create-node2
==========================================================================
==========================================================================
 /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
//        System.out.println(zk.create(&quot;/imooc-create-node2&quot;, &quot;imooc2&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
//                CreateMode.PERSISTENT));
//        zk.setData(&quot;/imooc-create-node&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
    &#125;
==========================================================================
客户端开始连接ZK服务器了
CONNECTING
17:58:09 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
17:58:09 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
17:58:09 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:57766, server: 127.0.0.1/127.0.0.1:2181
17:58:09 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec08710009, negotiated timeout = 5000
imooc2
</code></pre>
<h5 id="version版本不一样-保证不做修改"><a href="#version版本不一样-保证不做修改" class="headerlink" title="version版本不一样 保证不做修改"></a>version版本不一样 保证不做修改</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
修改值 让版本变成1
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 1);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data)); 
----------------------------------------------------------------------------
Exception in thread &quot;main&quot; org.apache.zookeeper.KeeperException$BadVersionException: KeeperErrorCode = BadVersion for /imooc-create-node2
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:122)
    at org.apache.zookeeper.KeeperException.create(KeeperException.java:54)
    at org.apache.zookeeper.ZooKeeper.setData(ZooKeeper.java:2551)
    at com.imooc.zkjavaapi.ZKOperator.main(ZKOperator.java:41)

报错=&gt;版本不一致
===========================================================================
[修改]
 zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);
        System.out.println(new String(data));
----------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:01:35 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:01:35 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:01:35 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:58870, server: 127.0.0.1/127.0.0.1:2181
18:01:35 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000d, negotiated timeout = 5000
imooc3 [修改成功]
</code></pre>
<h5 id="删除节点-引入回调函数-休眠"><a href="#删除节点-引入回调函数-休眠" class="headerlink" title="删除节点 [引入回调函数+休眠]"></a>删除节点 [引入回调函数+休眠]</h5><pre><code class="java">com/imooc/zkjavaapi/ZKOperator.java
package com.imooc.zkjavaapi;

import java.io.IOException;

import com.imooc.zkjavaapi.callback.DeleteCallBack;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooDefs.Ids;
import org.apache.zookeeper.ZooKeeper;

/**
 * 描述：     演示对节点的操作，包含创建、读取、删除等。
 */
public class ZKOperator implements Watcher &#123;

    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    public static void main(String[] args)
            throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKOperator());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);

        /**
         * path:创建的路径
         * data：存储的数据
         * acl：权限，开放
         * createMode：永久、临时、顺序。
         */
        zk.create(&quot;/imooc-create-node3&quot;, &quot;imooc3&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE,
                CreateMode.PERSISTENT);
//        zk.setData(&quot;/imooc-create-node2&quot;, &quot;imooc3&quot;.getBytes(), 0);
//        byte[] data = zk.getData(&quot;/imooc-create-node2&quot;, null, null);

        String ctx = &quot;删除成功&quot;; //把ctx的内容代入到DeleteCallBack()里面去运行
        zk.delete(&quot;/imooc-create-node3&quot;,0,new DeleteCallBack(),ctx);
        Thread.sleep(2000);
//        System.out.println(new String(data));
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
    &#125;
&#125;
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:10:01 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:10:01 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:10:01 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:2600, server: 127.0.0.1/127.0.0.1:2181
18:10:01 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x10004ec0871000f, negotiated timeout = 5000
删除节点/imooc-create-node3
删除成功
</code></pre>
<pre><code class="java">com/imooc/zkjavaapi/callback/DeleteCallBack.java
package com.imooc.zkjavaapi.callback;

import org.apache.zookeeper.AsyncCallback;

/**
 * 删除后运行的方法
 */
public class DeleteCallBack implements AsyncCallback.VoidCallback &#123;
    @Override
    public void processResult(int rc, String path, Object ctx) &#123;
        System.out.println(&quot;删除节点&quot; + path);
        System.out.println((String)ctx);
    &#125;
&#125;
</code></pre>
<h3 id="处理Watcher事件"><a href="#处理Watcher事件" class="headerlink" title="处理Watcher事件"></a>处理Watcher事件</h3><pre><code class="java">com/imooc/zkjavaapi/ZKGetNode.java
package com.imooc.zkjavaapi;

import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;

/**
 * 和节点相关：是否存在，获取数据，加上Watch
 */
public class ZKGetNode implements Watcher &#123;
    public static final String SERVER_PATH = &quot;127.0.0.1:2181&quot;;

    public static final Integer TIMEOUT = 5000;

    //这个是门闩
    private static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws IOException, InterruptedException, KeeperException &#123;
        /**
         * 客户端和服务端他们是异步连接，连接成功之后，客户端会收到watcher通知。
         * connectString：服务器的IP+端口号，比如127.0.0.1:2181
         * sessionTimeout：超时时间
         * watcher：通知事件
         */
        ZooKeeper zk = new ZooKeeper(SERVER_PATH, TIMEOUT, new ZKGetNode());
        System.out.println(&quot;客户端开始连接ZK服务器了&quot;);
        System.out.println(zk.getState());
        Thread.sleep(2000);
        System.out.println(zk.getState());

//        Stat exists = zk.exists(&quot;/imooc-create-node&quot;, false);//不需要额外监听
//        if (exists != null)&#123;
//            System.out.println(&quot;节点的版本为： &quot;+exists.getVersion());
//        &#125;else&#123;
//            System.out.println(&quot;该节点不存在&quot;);
//        &#125;
        zk.getData(&quot;/imooc-create-node&quot;, true, null);
        countDownLatch.await();
    &#125;

    @Override
    public void process(WatchedEvent event) &#123;
        if (event.getType() == Event.EventType.NodeChildrenChanged)&#123;
            System.out.println(&quot;数据被改变&quot;);
            countDownLatch.countDown();
        &#125;
        System.out.println(&quot;收到了通知&quot; + event);
    &#125;
&#125;
--------------------------------------------------------------------------------
在运行的情况下 去cmd中 修改
[zk: localhost:2181(CONNECTED) 1] set /imooc-create-node 11
--------------------------------------------------------------------------------
客户端开始连接ZK服务器了
CONNECTING
18:52:14 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
18:52:14 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
18:52:14 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:16204, server: 127.0.0.1/127.0.0.1:2181
18:52:14 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0001, negotiated timeout = 5000
收到了通知WatchedEvent state:SyncConnected type:None path:null
CONNECTED
数据被改变
收到了通知WatchedEvent state:SyncConnected type:NodeDataChanged path:/imooc-create-node
</code></pre>
<h3 id="用Curator操作ZK"><a href="#用Curator操作ZK" class="headerlink" title="用Curator操作ZK"></a><span style = "color:red">用Curator操作ZK</span></h3><h5 id="原生的Java的API的缺点"><a href="#原生的Java的API的缺点" class="headerlink" title="原生的Java的API的缺点"></a>原生的Java的API的缺点</h5><ul>
<li>不支持连接超时后的<strong>自动连接</strong></li>
<li>Watcher<strong>注册一次</strong>后会失效</li>
<li>不支持<strong>递归</strong>创建节点</li>
</ul>
<h5 id="利用Apache-Curator"><a href="#利用Apache-Curator" class="headerlink" title="利用Apache Curator"></a>利用Apache Curator</h5><ul>
<li>解决了Watcher注册一次后会失效的问题</li>
<li>API更加<strong>简单易用</strong>，提供了工具类</li>
</ul>
<pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;

/**
 * 用Curator来操作ZK
 */
public class CuratorTests &#123;
    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        String path = &quot;/curator&quot;;
        String data = &quot;test&quot;;
        client.create().withMode(CreateMode.PERSISTENT).forPath(path,data.getBytes());
        byte[] bytes = client.getData().forPath(path);
        System.out.println(new String(bytes));
    &#125;
&#125;
</code></pre>
<h6 id="更改高级一点！！！【添加-修改-删除】"><a href="#更改高级一点！！！【添加-修改-删除】" class="headerlink" title="更改高级一点！！！【添加+修改+删除】"></a>更改高级一点！！！【添加+修改+删除】</h6><pre><code class="java">com/imooc/curator/CuratorTests.java
package com.imooc.curator;

import com.sun.net.httpserver.Authenticator.Retry;
import java.text.MessageFormat;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.api.CuratorEvent;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher.Event.EventType;

/**
 * 描述：     用Curator来操作ZK
 */
public class CuratorTests &#123;

    public static void main(String[] args) throws Exception &#123;
        String connectString = &quot;127.0.0.1:2181&quot;;
        String path = &quot;/curator2&quot;;

        RetryPolicy retry = new ExponentialBackoffRetry(1000, 3);
        CuratorFramework client = CuratorFrameworkFactory.newClient(connectString, retry);
        client.start();
        client.getCuratorListenable().addListener((CuratorFramework c, CuratorEvent event) -&gt; &#123;
            switch (event.getType()) &#123;
                case WATCHED:
                    WatchedEvent watchedEvent = event.getWatchedEvent();
                    if (watchedEvent.getType() == EventType.NodeDataChanged) &#123;
                        System.out.println(new String(c.getData().forPath(path)));
                    &#125;
            &#125;
        &#125;);
        String data = &quot;test&quot;;
        String data2 = &quot;test2&quot;;
        //添加
        client.create().withMode(CreateMode.PERSISTENT).forPath(path, data.getBytes());

        byte[] bytes = client.getData().watched().forPath(path);
        System.out.println(new String(bytes));
        //更改
        client.setData().forPath(path, data2.getBytes());
        //删除
        client.delete().forPath(path);
        Thread.sleep(2000); //保证足够时间运行成功
    &#125;
&#125;
-------------------------------------------------------------------------------------
19:44:41 INFO zookeeper.ClientCnxn: Opening socket connection to server 127.0.0.1/127.0.0.1:2181.
19:44:41 INFO zookeeper.ClientCnxn: SASL config status: Will not attempt to authenticate using SASL (unknown error)
19:44:41 INFO zookeeper.ClientCnxn: Socket connection established, initiating session, client: /127.0.0.1:32984, server: 127.0.0.1/127.0.0.1:2181
19:44:41 INFO zookeeper.ClientCnxn: Session establishment complete on server 127.0.0.1/127.0.0.1:2181, session id = 0x1000534afde0005, negotiated timeout = 40000
19:44:41 INFO state.ConnectionStateManager: State change: CONNECTED
test
test2
</code></pre>
<h2 id="Dubbo-RPC远程过程调用"><a href="#Dubbo-RPC远程过程调用" class="headerlink" title="Dubbo [RPC远程过程调用]"></a>Dubbo [RPC远程过程调用]</h2><ul>
<li>初识Dubbo</li>
<li><strong>RPC</strong>介绍</li>
<li>Dubbo<strong>工作原理</strong></li>
<li>案例实操：项目编写</li>
<li>整合Dubbo和Zookeeper</li>
<li>实现服务间调用</li>
</ul>
<h3 id="初始Dubbo"><a href="#初始Dubbo" class="headerlink" title="初始Dubbo"></a>初始Dubbo</h3><h5 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h5><ul>
<li>轻量级、高性能的<strong>RPC框架</strong></li>
<li>并不是要成为一个微服务的全面解决方案</li>
<li>以Java语言而出名</li>
</ul>
<h5 id="Dubbo现状"><a href="#Dubbo现状" class="headerlink" title="Dubbo现状"></a>Dubbo现状</h5><ul>
<li>全称是<strong>Apache Dubbo</strong></li>
<li>微店、网易云音乐、滴滴、中国电信、中国人寿</li>
<li>star有30K+个，fork有20K+个</li>
</ul>
<h5 id="Dubbo的故事"><a href="#Dubbo的故事" class="headerlink" title="Dubbo的故事"></a>Dubbo的故事</h5><ul>
<li>09年开始做，做的第一个版本</li>
<li>10年初的时候，架构升级，Dubbo2.0</li>
<li><strong>开源</strong></li>
<li>one company战略</li>
<li>合到HSF去</li>
<li>第3节点，捐给Apache</li>
</ul>
<h5 id="开源的理解"><a href="#开源的理解" class="headerlink" title="开源的理解"></a>开源的理解</h5><ul>
<li><strong>共同成长</strong>、巨人的肩膀上</li>
<li>演化慢、不断革新、很强大的生命力</li>
<li>突破任何的束缚，突破任何的常规，<strong>包容和开放</strong></li>
</ul>
<h3 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h3><ul>
<li>RPC ——远程过程调用</li>
<li>早期单机时代：IPC</li>
<li>网络时代：<strong>把IPC扩展到网络上，这就是RPC</strong></li>
<li>实现RPC很头疼，于是有了<strong>RPC框架</strong></li>
<li>调用其他机器上的程序和<strong>调用本地的程序一样方便</strong></li>
</ul>
<h5 id="常见的RPC框架"><a href="#常见的RPC框架" class="headerlink" title="常见的RPC框架"></a>常见的RPC框架</h5><ul>
<li>阿里的Dubbo</li>
<li>新浪的Montan</li>
<li>Facebook的Thrift</li>
<li>各个框架都有其各自的优缺点</li>
</ul>
<h5 id="HTTP和RPC对比"><a href="#HTTP和RPC对比" class="headerlink" title="HTTP和RPC对比"></a>HTTP和RPC对比</h5><ul>
<li><strong>普通话</strong>[通用] 与 <strong>方言</strong>[企业内部]</li>
<li>普通话本质上也是一种方言，只不过它是官方的方言</li>
<li>传输效率 <ul>
<li>RPC定制自己传输请求让传输效率更高</li>
<li>HTTP会包含一些无用的内容效率较低</li>
</ul>
</li>
<li>性能消耗，主要在于序列化和反序列化的耗时</li>
<li>负载均衡</li>
</ul>
<h3 id="Dubbo工作原理"><a href="#Dubbo工作原理" class="headerlink" title="Dubbo工作原理"></a>Dubbo工作原理</h3><h6 id="一旦注册中心的信息有变化的时候会主动推送信息"><a href="#一旦注册中心的信息有变化的时候会主动推送信息" class="headerlink" title="一旦注册中心的信息有变化的时候会主动推送信息"></a>一旦注册中心的信息有变化的时候会主动推送信息</h6><ul>
<li>服务<strong>容器</strong>负责启动，加载，<strong>运行服务提供者</strong></li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>注册</strong>自己提供的服务</li>
<li><strong>服务提供者</strong>在启动时，向注册中心<strong>订阅</strong>自己所需的服务</li>
<li>注册中心返回服务提供者<strong>地址列表</strong>给消费者</li>
<li>从提供者地址列表中，<strong>选一台</strong>提供者进行调用</li>
<li>定期发送一次<strong>统计数据</strong>到监控中心</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的控制中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<h3 id="服务提供者开发"><a href="#服务提供者开发" class="headerlink" title="服务提供者开发"></a>服务提供者开发</h3><h5 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h5><ul>
<li>引入依赖</li>
<li>添加注解</li>
<li>整合Dubbo和<strong>Zookeeper</strong></li>
</ul>
<pre><code class="xml">pom.xml[dubbo-practice]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
        &lt;module&gt;producer&lt;/module&gt;
    &lt;/modules&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.12.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;name&gt;dubbo-practice&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-boot.version&gt;2.1.12.RELEASE&lt;/spring-boot.version&gt;
        &lt;dubbo.version&gt;2.7.4.1&lt;/dubbo.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- Spring Boot --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- Apache Dubbo  --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-dependencies-bom&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
                &lt;exclusions&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                        &lt;artifactId&gt;spring&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
                        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                    &lt;exclusion&gt;
                        &lt;groupId&gt;log4j&lt;/groupId&gt;
                        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
                    &lt;/exclusion&gt;
                &lt;/exclusions&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">pom.xml[dubbo-practice-producer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
        &lt;groupId&gt;com.imooc&lt;/groupId&gt;
        &lt;version&gt;0.0.1&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;producer&lt;/artifactId&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- Dubbo Spring Boot Starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.7.4.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Zookeeper dependencies --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- Web 功能 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- MyBatis依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/producer/service/CourseListService.java
package com.imooc.producer.service;

import com.imooc.producer.entity.Course;

import java.util.List;

/**
 * 课程列表服务
 */
public interface CourseListService &#123;
    List&lt;Course&gt; getCourseList();
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/entity/Course.java
package com.imooc.producer.entity;

import java.io.Serializable;

/**
 * 描述：     Course实体类
 */
public class Course implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    //1上架，0下架
    Integer valid;

    @Override
    public String toString() &#123;
        return &quot;Course&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, valid=&quot; + valid +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/service/impl/CourseListServiceImpl.java
package com.imooc.producer.service.impl;

import com.imooc.producer.entity.Course;
import com.imooc.producer.mapper.CourseMapper;
import com.imooc.producer.service.CourseListService;
import java.util.List;
import org.apache.dubbo.config.annotation.Service;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * 描述：     课程列表服务实现类
 */
@Service(version = &quot;$&#123;demo.service.version&#125;&quot;)
public class CourseListServiceImpl implements CourseListService &#123;

    @Autowired
    CourseMapper courseMapper;

    public List&lt;Course&gt; getCourseList() &#123;
        return courseMapper.findValidCourses();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/producer/mapper/CourseMapper.java
package com.imooc.producer.mapper;

import com.imooc.producer.entity.Course;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Mapper类
 */
@Mapper
@Repository
public interface CourseMapper &#123;
    @Select(&quot;SELECT * FORM course WHERE valid = 1&quot;)
    List&lt;Course&gt; findValidCourses();
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

#server.port=8081

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_prepare?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-list

#dubbo协议
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubbo注册
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache

mybatis.configuration.map-underscore-to-camel-case=true

dubbo.scan.base-packages=com.imooc.producer.service.impl
</code></pre>
<pre><code class="java">com/imooc/producer/DubboProducerApplication.java
package com.imooc.producer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@EnableAutoConfiguration
public class DubboProducerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboProducerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="服务消费方开发"><a href="#服务消费方开发" class="headerlink" title="服务消费方开发"></a>服务消费方开发</h3><p>查看PID为8080：<code>netstat -ano|findstr 8080</code><br>杀死进程：<code>taskkill /pid 查询的PID /f</code></p>
<pre><code class="xml">pom.xml[dubbo-practice-consumer]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;dubbo-practice&lt;/artifactId&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;version&gt;0.0.1&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;artifactId&gt;concumer&lt;/artifactId&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- Dubbo Spring Boot Starter --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.7.4.1&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- Zookeeper dependencies --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;
      &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;!-- Web 功能 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL connector, 需要与 MySQL 版本对应 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- MyBatis依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.imooc&lt;/groupId&gt;
      &lt;artifactId&gt;producer&lt;/artifactId&gt;
      &lt;version&gt;0.0.1&lt;/version&gt;
      &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/CoursePriceService.java
package com.imooc.consumer.service;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import java.util.List;

/**
 * 描述：     课程价格服务
 */
public interface CoursePriceService &#123;

    CoursePrice getCoursePrice(Integer courseId);

    List&lt;CourseAndPrice&gt; getCoursesAndPrice();
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/service/impl/CoursePriceServiceImpl.java
package com.imooc.consumer.service.impl;

import com.imooc.consumer.dao.CoursePriceMapper;
import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import com.imooc.producer.entity.Course;
import com.imooc.producer.service.CourseListService;
import java.util.ArrayList;
import java.util.List;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 描述：     课程 价格服务
 */
@Service
public class CoursePriceServiceImpl implements CoursePriceService &#123;

    @Autowired
    CoursePriceMapper coursePriceMapper;

    @Reference(version = &quot;$&#123;demo.service.version&#125;&quot;)
    CourseListService courseListService;

    @Override
    public CoursePrice getCoursePrice(Integer courseId) &#123;
        return coursePriceMapper.findCoursePrices(courseId);
    &#125;

    @Override
    public List&lt;CourseAndPrice&gt; getCoursesAndPrice() &#123;
        List&lt;CourseAndPrice&gt; courseAndPriceList = new ArrayList&lt;&gt;();
        List&lt;Course&gt; courseList = courseListService.getCourseList();
        for (int i = 0; i &lt; courseList.size(); i++) &#123;
            Course course = courseList.get(i);
            if (course != null) &#123;
                CoursePrice price = getCoursePrice(course.getCourseId());
                if (price != null &amp;&amp; price.getPrice() &gt; 0) &#123;
                    CourseAndPrice courseAndPrice = new CourseAndPrice();
                    courseAndPrice.setId(course.getId());
                    courseAndPrice.setCourseId(course.getCourseId());
                    courseAndPrice.setName(course.getName());
                    courseAndPrice.setPrice(price.getPrice());
                    courseAndPriceList.add(courseAndPrice);
                &#125;
            &#125;
        &#125;
        return courseAndPriceList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/dao/CoursePriceMapper.java
package com.imooc.consumer.dao;

import com.imooc.consumer.entity.CoursePrice;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 描述：     Mapper类
 */
@Mapper
@Repository
public interface CoursePriceMapper &#123;

    @Select(&quot;SELECT * FROM course_price WHERE course_id = #&#123;courseId&#125;&quot;)
    CoursePrice findCoursePrices(Integer courseId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CourseAndPrice.java
package com.imooc.consumer.entity;

import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CourseAndPrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    String name;
    Integer price;

    @Override
    public String toString() &#123;
        return &quot;CourseAndPrice&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, courseId=&quot; + courseId +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125; Getter+Setter
&#125;
</code></pre>
<pre><code class="java">com/imooc/consumer/entity/CoursePrice.java
package com.imooc.consumer.entity;


import java.io.Serializable;

/**
 * 描述：     CoursePrice实体类
 */
public class CoursePrice implements Serializable &#123;

    Integer id;
    Integer courseId;
    Integer price;
&#125; Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/consumer/controller/CoursePriceController.java
package com.imooc.consumer.controller;

import com.imooc.consumer.entity.CourseAndPrice;
import com.imooc.consumer.entity.CoursePrice;
import com.imooc.consumer.service.CoursePriceService;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 描述：CoursePriceController
 */
@RestController
public class CoursePriceController &#123;

    @Autowired
    CoursePriceService coursePriceService;


    @GetMapping(&#123;&quot;/price&quot;&#125;)
    public Integer getCoursePrice(Integer courseId) &#123;
        CoursePrice coursePrice = coursePriceService.getCoursePrice(courseId);
        if (coursePrice != null) &#123;
            return coursePrice.getPrice();
        &#125; else &#123;
            return -1;
        &#125;
    &#125;


    @GetMapping(&#123;&quot;/coursesAndPrice&quot;&#125;)
    public List&lt;CourseAndPrice&gt; getcoursesAndPrice() &#123;
        return coursePriceService.getCoursesAndPrice();
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties
demo.service.version=1.0.0

server.port=8084

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/course_practice?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root

logging.pattern.console=%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:%wEx&#125;


spring.application.name=course-price

#dubboåè®®
dubbo.protocol.name=dubbo
dubbo.protocol.port=-1
#dubboæ³¨å
dubbo.registry.address=zookeeper://127.0.0.1:2181
dubbo.registry.file=$&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache
</code></pre>
<pre><code class="java">com/imooc/consumer/DubboConsumerApplication.java
package com.imooc.consumer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 描述：     Spring Boot启动类
 */
@SpringBootApplication
public class DubboConsumerApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(DubboConsumerApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="案例实操总结"><a href="#案例实操总结" class="headerlink" title="案例实操总结"></a>案例实操总结</h5><ul>
<li><strong>自动检查</strong>zk和依赖的服务</li>
<li>dubbo.scan.base-packages配置</li>
<li>实现<strong>服务间调用</strong></li>
</ul>
<h1 id="面试课"><a href="#面试课" class="headerlink" title=" 面试课"></a><span style = "color:red"> 面试课</span></h1><ul>
<li><h5 id="Spring-Boot常见面试题"><a href="#Spring-Boot常见面试题" class="headerlink" title="Spring Boot常见面试题"></a>Spring Boot常见面试题</h5></li>
<li><h5 id="线程常见面试题"><a href="#线程常见面试题" class="headerlink" title="线程常见面试题"></a>线程常见面试题</h5></li>
<li><h5 id="分布式的面试题"><a href="#分布式的面试题" class="headerlink" title="分布式的面试题"></a>分布式的面试题</h5></li>
<li><h5 id="Docker相关面试题"><a href="#Docker相关面试题" class="headerlink" title="Docker相关面试题"></a>Docker相关面试题</h5></li>
<li><h5 id="Nginx和Zookeeper相关面试题"><a href="#Nginx和Zookeeper相关面试题" class="headerlink" title="Nginx和Zookeeper相关面试题"></a>Nginx和Zookeeper相关面试题</h5></li>
<li><h5 id="RabbitMQ相关面试题"><a href="#RabbitMQ相关面试题" class="headerlink" title="RabbitMQ相关面试题"></a>RabbitMQ相关面试题</h5></li>
<li><h5 id="微服务相关"><a href="#微服务相关" class="headerlink" title="微服务相关"></a>微服务相关</h5></li>
<li><h5 id="彩蛋：学习方法"><a href="#彩蛋：学习方法" class="headerlink" title="彩蛋：学习方法"></a>彩蛋：学习方法</h5></li>
<li><h5 id="锁分类、死锁"><a href="#锁分类、死锁" class="headerlink" title="锁分类、死锁"></a>锁分类、死锁</h5></li>
<li><h5 id="HashMap和final"><a href="#HashMap和final" class="headerlink" title="HashMap和final"></a>HashMap和final</h5></li>
<li><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5></li>
<li><h5 id="面试避坑指南"><a href="#面试避坑指南" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h5></li>
<li><h5 id="重要的软实力"><a href="#重要的软实力" class="headerlink" title="重要的软实力"></a>重要的软实力</h5></li>
</ul>
<h3 id="Spring、Spring-Boot和Spring-Cloud的关系？"><a href="#Spring、Spring-Boot和Spring-Cloud的关系？" class="headerlink" title="Spring、Spring Boot和Spring Cloud的关系？"></a>Spring、Spring Boot和Spring Cloud的关系？</h3><ul>
<li>Spring最初利用<strong>IOC</strong>和<strong>AOP</strong>解耦</li>
<li>按照这种模式搞了<strong>MVC框架</strong> [之后就配置太繁琐了]</li>
<li>写了很多样板代码很麻烦，就有了Spring Boot</li>
<li>Spring Boot是在强大的Spring帝国发展起来的，发明Spring Boot是为了让人们更好更高效的使用Spring，Spring Boot理念是约定优于配置</li>
<li>Spring Cloud是在Spring Boot基础上诞生的 [一系列框架的有序集合]</li>
</ul>
<h3 id="Spring-Boot如何配置多环境"><a href="#Spring-Boot如何配置多环境" class="headerlink" title="Spring Boot如何配置多环境"></a>Spring Boot如何配置多环境</h3><ul>
<li><h5 id="开发、测试、预发、生产"><a href="#开发、测试、预发、生产" class="headerlink" title="开发、测试、预发、生产"></a>开发、测试、预发、生产</h5></li>
</ul>
<blockquote>
<p>面试官你好，我这边平时是会使用多套环境，比如说”开发、测试、预发、生产”环境。<br>开发环境通常在本地，它所连接的数据库也是专门用于开发的，里面的数据也是一定情况下算出来的，因为并不需要在开发环境的情况下保证数据的完全精确，为了开发效率的提高，我们通常造一些模拟的数据，通常开发完后我们要把程序部署到测试环境，因为测试环境通常是公司所提供的服务器，而开发环境通常是我们本机，对于本机而言如果关闭或关机后别人就无法访问了，但是测试的同学工作时间不一定能和开发的同学一致，如果把程序关掉了他们就没办法测试了。我们需要给测试同学提供一套稳定的环境去测试。而且有的时候会同时开发多种功能，前一个功能开发完了需要去测试，这个时候就要去开发新的功能了，此时本地的代码已经发生了变化，如果把开发环境当成测试环境的话会发生很多问题，它实际测试的和我们想要测试的不是同一套代码，正是这个原因测试环境是必不可少的，需要用一台稳定的服务器把我们开发好的部署上测试环境中去，这样的话无论电脑是否关机都不会影响测试人员的进度。但是在测试环境的数据库往往可以和开发环境的保持一致可以允许公用同一个数据。<br>预发环境是预备发布，和真正的线上环境高度统一，和测试环境的区别：<br>1.网络隔离 为了保证线上环境的稳定会采取环境隔离，在本地或者测试环境下是没有办法访问到预发环境的机器，不可直接访问。在预发环境通常采用真实的数据库去测试。在测试环境并不能把所有问题都测试出来，所以在测试环境中无法测试到的问题在预发环境就可以暴露出来了，有时候在测试环境中模拟的数据不是准确，比如模拟一个商品详情，报的是50个字，最后发现真实情况是100个字，就能看到数据库大小不够，再次比如测试的是整数，到真实环境中发现是小数。隔离+数据验真<br>生产环境是真实对外的数据，也会有很多流量进来，直接面向所有用户，也有并发问题，要确保数据稳定</p>
</blockquote>
<ul>
<li><h5 id="提供多套配置文件"><a href="#提供多套配置文件" class="headerlink" title="提供多套配置文件"></a>提供多套配置文件</h5></li>
</ul>
<blockquote>
<p>在发布到某个环境之前，不建议把配置文件全部删除替换，有可能漏了文件导致了错误的替换，如果发布环境是测试环境的数据库，有可能会产生对外暴露的是测试环境的情况，这是很严重的事故</p>
</blockquote>
<ul>
<li><h5 id="通过改变application里的profiles-active值来加载对应的环境"><a href="#通过改变application里的profiles-active值来加载对应的环境" class="headerlink" title="通过改变application里的profiles.active值来加载对应的环境"></a>通过改变application里的profiles.active值来加载对应的环境</h5></li>
</ul>
<pre><code class="java">com/imooc/profiles/ProfilesApplication.java
package com.imooc.profiles;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProfilesApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ProfilesApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="mysql">application.properties

spring.profiles.active=prod
</code></pre>
<pre><code class="mysql">application-pre.properties

spring.profiles.active=test
server.port=8082
</code></pre>
<pre><code class="mysql">application-prod.properties

spring.profiles.active=test
server.port=8083
</code></pre>
<pre><code class="mysql">application-test.properties

spring.profiles.active=test
server.port=8081
</code></pre>
<h3 id="实际工作中，如何全局处理异常？"><a href="#实际工作中，如何全局处理异常？" class="headerlink" title="实际工作中，如何全局处理异常？"></a>实际工作中，如何全局处理异常？</h3><ul>
<li><h5 id="为什么异常需要全局处理？不处理行不行？"><a href="#为什么异常需要全局处理？不处理行不行？" class="headerlink" title="为什么异常需要全局处理？不处理行不行？"></a>为什么异常需要全局处理？不处理行不行？</h5></li>
</ul>
<blockquote>
<p>如果我们不进行处理的话，异常可能会把整个堆栈抛出去，一旦发生异常，用户或者别用用心的黑客可以看到详细的异常发生情况，包含详细的错误信息和代码的行数，这样的话对方可以利用一个漏洞进行不同的尝试，而且可以顺藤摸瓜分析出更多潜在的风险，最终把系统攻击破，异常是必须处理的。<br>但为什么要全局处理呢？电商项目→exception→GlobalExceptionHandler</p>
</blockquote>
<ul>
<li><h5 id="GlobalExceptionHandler-使用全局处理"><a href="#GlobalExceptionHandler-使用全局处理" class="headerlink" title="GlobalExceptionHandler [使用全局处理]"></a>GlobalExceptionHandler [使用全局处理]</h5>识别到什么异常，调用什么其处理器。写了全局异常处理器，轻松的针对不同的异常做出定制化的解决方案，不但增加了安全性，对用户也是友好的</li>
</ul>
<pre><code class="java">package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常 所有异常的父类
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    
    // 处理自己所定义的异常 用户/密码不能为空......
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="线程如何启动？"><a href="#线程如何启动？" class="headerlink" title="线程如何启动？"></a>线程如何启动？</h3><blockquote>
<p>Thread.start.run</p>
</blockquote>
<ul>
<li><h5 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢？" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？"></a>既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？</h5></li>
</ul>
<blockquote>
<p>因为它只是一个普通的java代码，而不会真正的启动一个线程，调用一次run()方法只执行一次，而且是在主线程执行的，就没有起到任何创建线程的效果了。<br>如果选择start方法的话会在后台执行很多操作，比如去申请一个线程、让子方法去执行run()里的内容，而且还包括执行之后的对线程状态的调整。所以说表面上是相同都是执行一段代码，但是实际上是不同的。</p>
</blockquote>
<ul>
<li><h5 id="两次调用start-方法会出现什么情况？"><a href="#两次调用start-方法会出现什么情况？" class="headerlink" title="两次调用start()方法会出现什么情况？"></a>两次调用start()方法会出现什么情况？</h5></li>
</ul>
<blockquote>
<p>两次调用start()方法会报异常，异常类型叫做<code>IllegalThreadStateException</code>，在start()的时候首先会进行线程状态的检测只有是new的时候才能正常启动，不允许启动两次</p>
</blockquote>
<pre><code class="java">com/imooc/interniew/StartTwice.java
package com.imooc.interniew;

/**
 * 描述：     两次启动线程
 */
public class StartTwice &#123;

    public static void main(String[] args) &#123;
        Thread thread = new Thread();
        thread.start();
        thread.start();
    &#125;
&#125;
======================== 报错信息  ==========================
Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException
    at java.lang.Thread.start(Thread.java:705)
    at com.imooc.interniew.StartTwice.main(StartTwice.java:11)
</code></pre>
<pre><code class="java">Thread.java
public synchronized void start() &#123;
        /**
         * This method is not invoked for the main method thread or &quot;system&quot;
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state &quot;NEW&quot;.
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group&#39;s list of threads
         * and the group&#39;s unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try &#123;
            start0();
            started = true;
        &#125; finally &#123;
            try &#123;
                if (!started) &#123;
                    group.threadStartFailed(this);
                &#125;
            &#125; catch (Throwable ignore) &#123;
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="实现多线程的方法有几种？"><a href="#实现多线程的方法有几种？" class="headerlink" title="实现多线程的方法有几种？"></a>实现多线程的方法有几种？</h3><ul>
<li><h5 id="方法一：实现Runnable接口"><a href="#方法一：实现Runnable接口" class="headerlink" title="方法一：实现Runnable接口"></a>方法一：实现<strong>Runnable</strong>接口</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/RunnableStyle.java
package com.imooc.interniew.createthreads;

import java.util.concurrent.Callable;

/**
 * 描述：     用Runnable方式创建线程
 */
public class RunnableStyle implements Runnable &#123;
//new里new的意思是 把这个Runnable类作为参数传进Thread里面
    public static void main(String[] args) &#123;
        Thread thread = new Thread(new RunnableStyle());
        thread.start();
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;用Runnable方法实现线程&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><h5 id="方法二：继承Thread类"><a href="#方法二：继承Thread类" class="headerlink" title="方法二：继承Thread类"></a>方法二：继承Thread类</h5></li>
</ul>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
</code></pre>
<h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h3><h4 id="方法1-实现Runnable接口更好"><a href="#方法1-实现Runnable接口更好" class="headerlink" title="方法1(实现Runnable接口更好)"></a><span style = "color:blue">方法1(实现Runnable接口更好)</span></h4><h5 id="实现多线程——常见面试问题"><a href="#实现多线程——常见面试问题" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li><p><span style = "color:red"><strong>实现Runnable接口和继承Thread类哪种方式更好？</strong></span></p>
<ul>
<li><h5 id="从代码架构角度"><a href="#从代码架构角度" class="headerlink" title="从代码架构角度"></a>从代码架构角度</h5></li>
</ul>
<blockquote>
<p>本意是想让我们的执行类和任务的具体内容解耦，关系不那么密切，从架构角度好<br>★ Runnable具体描述的是工作的内容和线程的启动没有什么关系<br>★ Thread是维护整个线程的: 线程的启动、线程状态更改、线程结束，这两个本身的任务很分明的，不应该过度耦合[未来会发生很难扩展的问题]</p>
</blockquote>
<ul>
<li><h5 id="新建线程损耗"><a href="#新建线程损耗" class="headerlink" title="新建线程损耗"></a>新建线程损耗</h5></li>
</ul>
<blockquote>
<p>★ Runnable 在线程池更高级的用法中，一定不是每个任务都去新建一个线程的，为了提高整体的效率会让有限数量的线程由我们自己来确定，10个线程可以运行成千上万个任务。减少了新建线程的损耗。<br>可以把任务作为一个参数直接传递给线程池，线程池里面用固定的线程去执行任务不需要每次都新建和销毁线程，这样大大降低了线程的开销。</p>
<p>★ Runnable 如果用这个不得不去把线程损耗承担起来，有的时候run方法执行的比较少，开销的少比不上新建线程的开销[捡了芝麻丢了西瓜]。</p>
</blockquote>
<ul>
<li><h5 id="Java不支持双继承"><a href="#Java不支持双继承" class="headerlink" title="Java不支持双继承"></a>Java不支持双继承</h5></li>
</ul>
<blockquote>
<p>public class ThreadStyle extends Thread,Date (×)<br>Class cannot extend multiple classes</p>
<p>从语法的角度不允许继承多个类，一旦选定了一个父类就无法更改了[一辈子就被定死了]。在创建线程起就限制了代码的可扩展性，如果实现Runnable接口就不会出现这个问题，实现接口并不仅仅只能实现一个，实现接口后还可以继承类</p>
<blockquote>
<p>public class RunnableStyle extends Thread implements Runnable,Callable</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="两种方法的本质对比"><a href="#两种方法的本质对比" class="headerlink" title="两种方法的本质对比"></a><span style = "color:blue">两种方法的本质对比</span></h4><h5 id="方法一：最终调用target-run"><a href="#方法一：最终调用target-run" class="headerlink" title="方法一：最终调用target.run();"></a><span style = "color:red">方法一：最终调用target.run();</span></h5><blockquote>
<p>此方法本质是传入类后调用！<br>Ctrl+F12可以精确查找方法<br>@Override<br>public void run(){<br>    if(target !&#x3D; null){<br>        target.run()<br>    }<br>}<br>而target是什么呢？实际上就是我们写的<br>@Override<br>public void run() {<br>    System.<em>out</em>.println(“用Runnable方法实现线程”);<br>}</p>
</blockquote>
<h5 id="方法二：run-整个都被重写"><a href="#方法二：run-整个都被重写" class="headerlink" title="方法二：run()整个都被重写"></a><span style = "color:red">方法二：run()整个都被重写</span></h5><blockquote>
<p>整个重写代码</p>
</blockquote>
<h4 id="若同时使用这两种方法会发生什么？"><a href="#若同时使用这两种方法会发生什么？" class="headerlink" title="若同时使用这两种方法会发生什么？"></a>若同时使用这两种方法会发生什么？</h4><ul>
<li><h5 id="从面向对象的思想去考虑"><a href="#从面向对象的思想去考虑" class="headerlink" title="从面向对象的思想去考虑"></a>从面向对象的思想去考虑</h5></li>
</ul>
<pre><code class="java">com/imooc/interniew/createthreads/BothRunnableThread.java
package com.imooc.interniew.createthreads;
/**
 * 描述：     同时使用RUNNABLE和Thread两种方式实现线程
 */
public class BothRunnableThread &#123;

    public static void main(String[] args) &#123;
        Thread t1 = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;实现Runnable接口的方式&quot;);
            &#125;
        &#125;) &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我来自Thread&quot;);
            &#125;
        &#125;;
        t1.start();
    &#125;
&#125;
=========================================================
我来自Thread
---------------------------------------------------------
因为 run重写会被覆盖！！子类覆盖父类时 实行子类方法
@Override
public void run()&#123;
    if(target != null)&#123;
        target.run()
    &#125;
&#125;
</code></pre>
<h5 id="其他观点分析"><a href="#其他观点分析" class="headerlink" title="其他观点分析"></a>其他观点分析</h5><ul>
<li><p><strong>线程池</strong>创建线程也算是一种新建线程的方式 [把那两种方式进行包装]</p>
</li>
<li><p>通过<strong>Callable</strong>创建线程，也算是一种新建线程的方式</p>
</li>
<li><p>定时器[方法二：extends Thread]</p>
<pre><code class="java">package com.imooc.interniew.createthreads;

import java.util.Timer;
import java.util.TimerTask;

/**
 * 描述：     利用定时器新建线程
 */
public class TimerDemo &#123;

    public static void main(String[] args) &#123;
        System.out.println(Thread.currentThread().getName());
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() &#123;
            @Override
            public void run() &#123;
                System.out.println(Thread.currentThread().getName());
            &#125;
        &#125;, 1000, 1000);
    &#125;
&#125;
=======================================================
main     //两个不一致证明新建了一个线程
Timer-0
Timer-0
......
</code></pre>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>Lambda表达式</p>
</li>
</ul>
<h5 id="实现多线程——常见面试问题-1"><a href="#实现多线程——常见面试问题-1" class="headerlink" title="实现多线程——常见面试问题"></a>实现多线程——常见面试问题</h5><ul>
<li>有多少种实现线程的方法？5点思路<ul>
<li>从<strong>不同的角度</strong>看，会有不同的答案</li>
<li>经典答案是<strong>两</strong>种</li>
<li>我们看原理，两种<strong>本质</strong>都是一样的</li>
<li>具体<strong>展开</strong>说其他方式</li>
</ul>
</li>
</ul>
<h5 id="总结：最精准的描述"><a href="#总结：最精准的描述" class="headerlink" title="总结：最精准的描述"></a>总结：最精准的描述</h5><blockquote>
<p>准确地讲：创建线程只有一种方法那就是构造Thread类，而实现线程的执行单元有两种方式<br>  ★ 方法一：实现<strong>Runnable</strong>接口的run方法，并把Runnable实例传給Thread类<br>  ★ 方法二：重写Thread的run方法(继承<strong>Thread</strong>类)<br>多线程的实现方法，在代码种写法千变万化，但其本质<strong>万变不离其宗</strong></p>
</blockquote>
<h3 id="线程的生命周期是什么？"><a href="#线程的生命周期是什么？" class="headerlink" title="线程的生命周期是什么？"></a>线程的生命周期是什么？</h3><h5 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h5><ul>
<li>有哪<strong>6</strong>种状态</li>
<li><strong>每个状态</strong>是什么含义？</li>
<li>状态间的转化？</li>
<li><strong>阻塞</strong>状态是什么？</li>
</ul>
<h5 id="每个状态是什么含义？"><a href="#每个状态是什么含义？" class="headerlink" title="每个状态是什么含义？"></a>每个状态是什么含义？</h5><ul>
<li>New</li>
<li>Runnable [从new到调用start方法]</li>
<li>Blocked [线程状态由sychronized修饰]</li>
<li>Waiting</li>
<li>Timed Waiting</li>
<li>Terminated</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/215ff6397d1cc14f17c11471dc420af64d92ea83/data/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" style="zoom: 200%;" />



<h3 id="状态转换的注意点和阻塞"><a href="#状态转换的注意点和阻塞" class="headerlink" title="状态转换的注意点和阻塞"></a>状态转换的注意点和阻塞</h3><pre><code class="java">com/imooc/interniew/NewRunnableTerminated.java
package com.imooc.interniew;

/**
 * 描述：     演示New、Runnable、Terminated状态。
 */
public class NewRunnableTerminated &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Thread thread = new Thread();
        //打印出NEW的状态 线程被创建但没有启动会打出new状态
        System.out.println(thread.getState());
        thread.start();
        //打印出Runnable状态 线程被启动后打印runnable状态
        System.out.println(thread.getState());
        Thread.sleep(100);
        //打印出TERMINATED状态 打印terminate状态
        System.out.println(thread.getState());
    &#125;
&#125;
=================================================================================
NEW
RUNNABLE
TERMINATED

Process finished with exit code 0
</code></pre>
<pre><code class="java">com/imooc/interniew/BlockedWaitingTimedWaiting.java
package com.imooc.interniew;

/**
 * 描述：     展示Blocked、Waiting、Timed_Waiting状态
 */
public class BlockedWaitingTimedWaiting implements Runnable &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Runnable runnable = new BlockedWaitingTimedWaiting();
        Thread t1 = new Thread(runnable);
        t1.start();
        Thread t2 = new Thread(runnable);
        t2.start();
        Thread.sleep(10);
        //打印Timed_Waiting状态，因为正在执行Thread.sleep(1000);
        System.out.println(t1.getState());
        //打印出BLOCKED状态，因为t2拿不到synchronized锁[线程1还在休眠]
        System.out.println(t2.getState());

        Thread.sleep(1300);
        //打印出WAITING状态，以为执行了wait()
        System.out.println(t1.getState());
    &#125;

    @Override
    public void run() &#123;
        syn();
    &#125;

    private synchronized void syn() &#123; //锁！！
        try &#123;
            Thread.sleep(1000);
            wait();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=================================================================================
TIMED_WAITING
BLOCKED
WAITING
</code></pre>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><ul>
<li>一般习惯而言，把<strong>Blocked</strong>(被阻塞)、<strong>Waiting</strong>(等待)、<strong>Timed_waiting</strong>(计时等待)都称为阻塞状态</li>
<li>不仅仅是Blocked</li>
</ul>
<h1 id="分布式面试题"><a href="#分布式面试题" class="headerlink" title="分布式面试题"></a><span style = "color:red">分布式面试题</span></h1><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5><ul>
<li>饭店厨师的例子<ul>
<li>一个厨师</li>
<li>多个厨师</li>
<li>术业有专攻：配菜师、洗菜工</li>
</ul>
</li>
<li>实际项目的演进过程<ul>
<li>一个项目，大而全</li>
<li>多台机器，部署同样的应用</li>
<li>分布式：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h5 id="分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓"><a href="#分布式和单体结构哪个更好？-脱离业务场景和发展阶段的空谈就是耍流氓" class="headerlink" title="分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]"></a>分布式和单体结构哪个更好？[脱离业务场景和发展阶段的空谈就是耍流氓]</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体架构</th>
<th>分布式架构</th>
</tr>
</thead>
<tbody><tr>
<td>新人的学习成本</td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td>部署、运维</td>
<td>容易</td>
<td>发布频繁、发布顺序复杂、运维难</td>
</tr>
<tr>
<td>隔离性</td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
</tbody></table>
<h3 id="CAP理论是什么？-只选其二-三者不可兼得"><a href="#CAP理论是什么？-只选其二-三者不可兼得" class="headerlink" title="CAP理论是什么？[只选其二 三者不可兼得]"></a>CAP理论是什么？[只选其二 三者不可兼得]</h3><ul>
<li>C(Consistency, 一致性)：读操作是否总能读到前一个写操作的结果</li>
<li>A(Availability, 可用性)：非故障节点应该在合理的时间内做出合理的响应</li>
<li>P(Partition tolerance, 分区容错性)：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<h5 id="CAP怎么选？"><a href="#CAP怎么选？" class="headerlink" title="CAP怎么选？"></a>CAP怎么选？</h5><ul>
<li>CP或者AP</li>
<li>在什么场合，可用性高于一致性？</li>
</ul>
<h3 id="为什么需要Docker？"><a href="#为什么需要Docker？" class="headerlink" title="为什么需要Docker？"></a>为什么需要Docker？</h3><ul>
<li>Docker：用来装程序以及环境的容器</li>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机</li>
</ul>
<h5 id="Docker的用途是什么？"><a href="#Docker的用途是什么？" class="headerlink" title="Docker的用途是什么？"></a>Docker的用途是什么？</h5><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong></li>
</ul>
<p>Docker的架构是什么样的？</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h5 id="Docker的网络模式有哪些？"><a href="#Docker的网络模式有哪些？" class="headerlink" title="Docker的网络模式有哪些？"></a>Docker的网络模式有哪些？</h5><ul>
<li><strong>Bridge</strong> [桥接 用外面主机的端口号映射到里面的端口号 实现了一座桥]</li>
<li><strong>Host</strong> [里面的容器不会获得独立的网络配置 不会使用虚拟网卡ip 而是使用宿主机上的ip和端口号]</li>
<li>None [不需要网络模式]</li>
</ul>
<h3 id="Nginx的适用场景有哪些？"><a href="#Nginx的适用场景有哪些？" class="headerlink" title="Nginx的适用场景有哪些？"></a>Nginx的适用场景有哪些？</h3><ul>
<li><p>HTTP的<strong>反向代理</strong>服务器</p>
</li>
<li><p><strong>动态静态</strong>资源分离</p>
<ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会直接获取到当前请求的文件并返回</li>
<li>静态资源服务器</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx常用命令有哪些？"><a href="#Nginx常用命令有哪些？" class="headerlink" title="Nginx常用命令有哪些？"></a>Nginx常用命令有哪些？</h3><pre><code class="java">/usr/sbin/nginx 启动
-h 帮助
-c 读取指定的配置文件
-t 测试
-v 版本
-s信号
  stop 立即停止(不再接收任何请求立刻停止)  
  quit 优雅停止(不接收了但目前的请求要作完)
  reload 重启
  reopen 更换日志文件
</code></pre>
<h3 id="Zookeeper有哪些节点类型？"><a href="#Zookeeper有哪些节点类型？" class="headerlink" title="Zookeeper有哪些节点类型？"></a>Zookeeper有哪些节点类型？</h3><ul>
<li>持久节点</li>
<li>临时节点</li>
<li>顺序节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/15f1b158dfd61ad9498e5febc8d809e4dcb7f0af/data/Znode%E8%8A%82-%20%E6%A0%91%E5%BD%A2%E5%9B%BE.jpg"></p>
<h3 id="为什么要用消息队列？什么场景用？"><a href="#为什么要用消息队列？什么场景用？" class="headerlink" title="为什么要用消息队列？什么场景用？"></a>为什么要用消息队列？什么场景用？</h3><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用</li>
<li>流量<strong>削峰</strong></li>
</ul>
<h5 id="消息队列RabbitMQ核心概念？"><a href="#消息队列RabbitMQ核心概念？" class="headerlink" title="消息队列RabbitMQ核心概念？"></a>消息队列RabbitMQ核心概念？</h5><p>同一个RabbitMQ的Server下建立不同的虚拟主机，他们之间是相互独立的，用于不同的业务线。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h5 id="交换机工作模式有哪4种？"><a href="#交换机工作模式有哪4种？" class="headerlink" title="交换机工作模式有哪4种？"></a>交换机工作模式有哪4种？</h5><ul>
<li><p><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</p>
</li>
<li><p><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<ul>
<li><p><strong>topic</strong>：比如消息严重性怎么样、只想记录error模块的用户信息</p>
<ul>
<li><p>***** 可以替代一个单词</p>
</li>
<li><p><strong>#</strong> 可以替代零个或多个单词</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<ul>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h1 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a><span style = "color:red">微服务面试题</span></h1><h3 id="微服务有哪两大门派？"><a href="#微服务有哪两大门派？" class="headerlink" title="微服务有哪两大门派？"></a>微服务有哪两大门派？</h3><ul>
<li><strong>Spring Cloud</strong>：众多子项目</li>
<li><strong>dubbo</strong>：高性能、轻量级的开源RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</li>
<li>dubbo提供的能力只是SpringCloud的一部分<strong>子集</strong></li>
</ul>
<h5 id="Spring-Cloud核心组件有哪些？"><a href="#Spring-Cloud核心组件有哪些？" class="headerlink" title="Spring Cloud核心组件有哪些？"></a>Spring Cloud核心组件有哪些？</h5><table>
<thead>
<tr>
<th align="center">核心组件</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务注册中心</td>
<td align="center">Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td align="center">服务调用</td>
<td align="center">Spring Cloud Netflix Feign</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td align="center">断路器</td>
<td align="center">Spring Cloud Netflix Hystrix</td>
</tr>
</tbody></table>
<h5 id="画一下Eureka架构"><a href="#画一下Eureka架构" class="headerlink" title="画一下Eureka架构"></a>画一下Eureka架构</h5><ul>
<li>EureKa <strong>Server</strong> 和 EureKa <strong>Client</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6a3bfcded810da5a827559f3b8f868a0de867787/data/Eureka%E6%9E%B6%E6%9E%84.png"></p>
<ul>
<li><strong>集群</strong> [只要能获得一个Eureka Server 就能获得整个信息]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f756e06eed90edb75c6b3b6f234eee57763d8811/data/Eureka%E6%9E%B6%E6%9E%84-%E9%9B%86%E7%BE%A4.png"></p>
<h5 id="负载均衡的两种类型是什么？"><a href="#负载均衡的两种类型是什么？" class="headerlink" title="负载均衡的两种类型是什么？"></a>负载均衡的两种类型是什么？</h5><ul>
<li><strong>客户端</strong>负载均衡(Ribbon)</li>
<li><strong>服务端</strong>负载均衡(Nginx)</li>
</ul>
<h5 id="负载均衡有哪些策略？"><a href="#负载均衡有哪些策略？" class="headerlink" title="负载均衡有哪些策略？"></a>负载均衡有哪些策略？</h5><ul>
<li>RandomRule表示<strong>随机</strong>策略</li>
<li>RoundRobinRule表示<strong>轮询</strong>策略</li>
<li>ResponseTimeWeightedRule<strong>加权</strong>，根据每一个Server的平均响应时间动态加权</li>
</ul>
<h5 id="为什么需要断路器？"><a href="#为什么需要断路器？" class="headerlink" title="为什么需要断路器？"></a>为什么需要断路器？</h5><p>防止线程突然卡住，当发现某个模块不可用时，把它摘除不影响主要流程。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e441bfbcf0e2cf07f9d53564669b2dbd90533142/data/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%AD%E8%B7%AF%E5%99%A8.jpg"></p>
<h5 id="为什么需要网关？"><a href="#为什么需要网关？" class="headerlink" title="为什么需要网关？"></a>为什么需要网关？</h5><ul>
<li>签名校验、登录校验<strong>冗余</strong>问题</li>
<li>统一对外，安全 [对恶意IP进行拦截 打出日志]</li>
</ul>
<h5 id="Dubbo的工作流程是什么？"><a href="#Dubbo的工作流程是什么？" class="headerlink" title="Dubbo的工作流程是什么？"></a>Dubbo的工作流程是什么？</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/2ded5afda4ae8cff8392f5ccf0217657054c8981/data/Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<h3 id="彩蛋：学习编程知识的优质路径"><a href="#彩蛋：学习编程知识的优质路径" class="headerlink" title="彩蛋：学习编程知识的优质路径"></a>彩蛋：学习编程知识的优质路径</h3><ul>
<li><h5 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h5></li>
</ul>
<ol>
<li>并不是靠工作年限，有的人工作5年技术却还是只懂皮毛</li>
<li>要有强大的责任心，不放过任何bug，找到原因并去解决，这就是提高</li>
<li>主动：永远不会觉得自己的时间多余，重构、优化、学习、总结等</li>
<li>敢于承担：虽然这个技术难题以前没有碰到过，但是在一定的了解调研后，敢于承担技术难题，让工作充满挑战，这一次次攻克难关的过程种，进步是飞速的</li>
<li>关心产品，关心业务，而不是只写代码</li>
</ol>
<ul>
<li><h5 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h5></li>
</ul>
<ol>
<li>系统化的学习 看经典的书籍</li>
<li>看官方文档</li>
<li>自己动手写代码，尝试应用到项目中</li>
<li>不理解的内容参考多个知识来源，综合判断</li>
<li>学习开源项目，总结代码</li>
</ol>
<h3 id="Synchronized和Lock"><a href="#Synchronized和Lock" class="headerlink" title="Synchronized和Lock"></a>Synchronized和Lock</h3><h5 id="Lock简介、地址、作用"><a href="#Lock简介、地址、作用" class="headerlink" title="Lock简介、地址、作用"></a>Lock简介、地址、作用</h5><ul>
<li>锁是一种工具，用于控制对<strong>共享资源</strong>的访问</li>
<li>Lock和Synchronized，这两个是最常见的锁，它们都可以达到<strong>线程安全</strong>的目的，但是在使用上和功能上又有较大的不同</li>
<li>Lock并不是用来替代Synchronized的，而是当使用Synchronized不合适或不满足要求的时候，来提供<strong>高级功能</strong>的</li>
<li>Lock接口最常见的实现类是<strong>ReentrantLock</strong></li>
<li><strong>lock()、tryLock()、tryLock(long time, TimeUnit unit)</strong> 和<strong>locakInterruptibly()</strong></li>
</ul>
<h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><ul>
<li>lock()就是最普通的获取锁。如果锁已经被其他线程获取，则进行等待</li>
<li>Lock不会像Synchronized一样在<strong>异常时自动释放锁</strong></li>
<li>因此最佳实践是，在<strong>finally中释放锁</strong>，以保证发生异常时锁一定被释放</li>
<li>lock()方法不能被中断，这就会带来很大隐患：一旦陷入<strong>死锁</strong>，lock()就会陷入永久等待</li>
</ul>
<h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><ul>
<li>tryLock()用来<strong>尝试获取锁</strong>，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li>
<li>相对比lock，这样的方法显然功能更加强大了，我们可以根据是否能获取到锁来<strong>决定后续程序的行为</strong></li>
<li>该方法会<strong>立即返回</strong>，即便在拿不到锁时不会一直在那等</li>
</ul>
<h5 id="tryLock-long-time-TimeUnit-unit-：超时就放弃"><a href="#tryLock-long-time-TimeUnit-unit-：超时就放弃" class="headerlink" title="tryLock(long time, TimeUnit unit)：超时就放弃"></a>tryLock(long time, TimeUnit unit)：超时就放弃</h5><p><strong>locakInterruptibly()<strong>：相当于tryLock(long time, TimeUnit unit)把超时时间设置为无限。在等待锁的过程中，线程可以被</strong>中断</strong></p>
<p><strong>unlock()：</strong>解锁 [最应该写在try…finally里面]</p>
<h4 id="Synchronized和Lock有什么不同？"><a href="#Synchronized和Lock有什么不同？" class="headerlink" title="Synchronized和Lock有什么不同？"></a>Synchronized和Lock有什么不同？</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ul>
<li>保障资源线程的安全：目的和作用都是为了 保障资源线程的安全<br>[使用Synchronized后被保护的代码块最多只有一个线程可以访问]</li>
<li>可重入 [不然就必须在获得第二个锁前释放]</li>
</ul>
<pre><code class="java">com/imooc/interniew/Reentrant.java
package com.imooc.interniew;

/**
 * 描述：     synchronized可重入
 */
public class Reentrant &#123;

    public synchronized void f1() &#123;
        System.out.println(&quot;f1方法被运行了&quot;);
        f2();
    &#125;

    public synchronized void f2() &#123;
        System.out.println(&quot;f2方法被运行了&quot;);
    &#125;

    public static void main(String[] args) &#123;
        Reentrant reentrant = new Reentrant();
        reentrant.f1();
    &#125;
&#125;
========================================================
f1方法被运行了
f2方法被运行了
</code></pre>
<ul>
<li><strong>ReentrantLock</strong> [实现了Lock接口]</li>
</ul>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><ul>
<li><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><ul>
<li>Synchronized用在方法上、用在同步代码块上 [隐式]</li>
<li>Lock必须使<u>用lock方法加锁</u>，<u>unlock方法解锁</u> [显式]</li>
</ul>
</li>
<li><h6 id="加解锁顺序不同"><a href="#加解锁顺序不同" class="headerlink" title="加解锁顺序不同"></a>加解锁顺序不同</h6><ul>
<li>Synchronized是java内部控制，自动加解锁</li>
<li>Lock可以手动调节</li>
</ul>
</li>
<li><h6 id="Synchronized锁不够灵活"><a href="#Synchronized锁不够灵活" class="headerlink" title="Synchronized锁不够灵活"></a>Synchronized锁不够灵活</h6><ul>
<li>Synchronized获得了一个锁 其他的只能等待</li>
<li>Lock获得锁很灵活 可以随时调整</li>
</ul>
</li>
<li><h6 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h6><ul>
<li>Synchronized由差到好 目前同等程度的性能</li>
</ul>
</li>
</ul>
<h3 id="你知道有几种锁？"><a href="#你知道有几种锁？" class="headerlink" title="你知道有几种锁？"></a>你知道有几种锁？</h3><ul>
<li><p><span style = "color:blue"><strong>共享锁</strong>[读写锁] 和 <strong>独占锁</strong>[排他锁]</span></p>
</li>
<li><p>共享锁，又称为读锁，获得<strong>共享锁</strong>之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但<strong>无法修改和删除</strong>数据</p>
</li>
<li><p>共享锁和排他锁的典型是读写锁<strong>ReentrantReadWriteLock</strong>，其中<strong>读锁是共享锁，写锁是独享锁</strong></p>
</li>
</ul>
<h5 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h5><ul>
<li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也<strong>浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</strong></li>
<li>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果<strong>没有写锁的情况下，读是无阻塞的</strong>，提高了程序的执行效率</li>
</ul>
<h5 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h5><ul>
<li>多个线程只申请读锁，都可以申请到</li>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li>
<li>一句话总结：要么是<strong>一个</strong>或<strong>多个</strong>线程同时有<strong>读锁</strong>，要么一个线程有写锁，但是两者不会同时出现(要么多读，要麽一写)</li>
</ul>
<h5 id="公平锁-和-非公平锁"><a href="#公平锁-和-非公平锁" class="headerlink" title="公平锁 和 非公平锁"></a><span style = "color:blue">公平锁 和 非公平锁</span></h5><ul>
<li>公平指的是按照线程请求的顺序，来分配锁</li>
<li>非公平指的是不完全按照请求的顺序，在一定情况下，可以插队 </li>
<li>注意：<strong>非公平</strong>也同样不提倡 ”插队“ 行为，这里的非公平，指的是”在合适的时机”插队，而不是盲目插队</li>
<li>什么是合适的时机呢？<ul>
<li>买火车票被插队的例子，排队买的例子</li>
</ul>
</li>
<li>实际情况并不是这样的，java设计者这样设计的目的是为了<strong>提高效率</strong></li>
<li><span style = "color:red"><strong>避免唤醒带来的空档期，提升吞吐量</strong></span></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>公平锁</td>
<td>各线程公平平等，每个线程在等待一段时间后，总有执行的机会</td>
<td>更慢，吞吐量更小</td>
</tr>
<tr>
<td>不公平锁</td>
<td>更快，吞吐量更大</td>
<td>有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行</td>
</tr>
</tbody></table>
<h5 id="悲观锁-和-乐观锁"><a href="#悲观锁-和-乐观锁" class="headerlink" title=" 悲观锁 和 乐观锁"></a><span style = "color:blue"> 悲观锁 和 乐观锁</span></h5><ul>
<li>从<strong>是否锁住资源</strong>的角度分类</li>
</ul>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><ul>
<li>如果我不锁住这个资源，别人就会来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失</li>
<li>java中悲观锁的实现就是<code>synchronized</code>和<code>Lock</code>相关类</li>
</ul>
<h5 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h5><ul>
<li>认为自己在处理操作的时候不会有其他线程来干扰，所以并<strong>不会锁住</strong>被操作对象</li>
<li>在更新的时候，去对比在我修改的期间数据有没有被其他人改变过，如果<strong>没被改变过</strong>，就说明真的是只有我自己在操作，那我就正常去修改数据</li>
<li>如果数据和我<strong>一开始拿到的不一样</strong>了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略</li>
<li>乐观锁的实现一般都是利用<strong>CAS</strong>算法来实现的</li>
</ul>
<h6 id="在数据库中"><a href="#在数据库中" class="headerlink" title="在数据库中"></a>在数据库中</h6><ul>
<li><strong>select for update</strong>就是悲观锁</li>
<li>用<strong>version</strong>控制数据库就是乐观锁</li>
</ul>
<h6 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h6><pre><code class="mysql">添加一个字段lock_version
先查询这个更新语句的vesion：SELECT * FROM table
然后
UPDATE SET num = 2, 
version = version + 1 WHERE version = 1 AND id = 5
如果version被更新了等于2，不一样就会更新出错，这就是乐观锁的原理
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a6265784dee5e723d22bfceddca39a9a2afe91b8/data/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.jpg"></p>
<h5 id="自旋锁-和-非自旋锁"><a href="#自旋锁-和-非自旋锁" class="headerlink" title="自旋锁 和 非自旋锁"></a><span style = "color:blue">自旋锁 和 非自旋锁</span></h5><ul>
<li>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</li>
<li>如果同步代码块的内容过于简单，<strong>状态转换消耗的时间有可能比用户代码执行的时间还要长</strong></li>
<li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让系统<strong>得不偿失</strong></li>
<li>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁 </li>
<li>而为了让当前线程“<strong>稍等一下</strong>”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而<strong>避免切换线程的开销</strong>，这就是自旋锁。</li>
</ul>
<h5 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h5><ul>
<li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源</li>
<li>在自旋的过程中，一直消耗CPU，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的</li>
</ul>
<h5 id="可重入锁-和-非可重入锁"><a href="#可重入锁-和-非可重入锁" class="headerlink" title="可重入锁 和 非可重入锁"></a><span style = "color:blue">可重入锁 和 非可重入锁</span></h5><ul>
<li><p>什么是可重入 [摇一个号拿N个牌]</p>
</li>
<li><p>好处 [避免死锁]</p>
</li>
</ul>
<h5 id="可中断锁-和-不可中断锁"><a href="#可中断锁-和-不可中断锁" class="headerlink" title="可中断锁 和 不可中断锁"></a><span style = "color:blue">可中断锁 和 不可中断锁</span></h5><ul>
<li>可中断锁 [可以随时中断]</li>
</ul>
<h3 id="死锁相关"><a href="#死锁相关" class="headerlink" title="死锁相关"></a>死锁相关</h3><h5 id="写一个必然死锁的例子？"><a href="#写一个必然死锁的例子？" class="headerlink" title="写一个必然死锁的例子？"></a>写一个必然死锁的例子？</h5><h6 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h6><ul>
<li><p>发生在<strong>并发</strong>中</p>
</li>
<li><p><strong>互不相让</strong>：当两个(或更多)线程(或进程)相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁</p>
</li>
<li><p>一图胜千言</p>
</li>
<li><p>线程A持有锁1但试图获取锁2 线程B持有锁2但视图获取锁1</p>
</li>
</ul>
<h5 id="多个线程造成死锁的情况"><a href="#多个线程造成死锁的情况" class="headerlink" title="多个线程造成死锁的情况"></a>多个线程造成死锁的情况</h5><ul>
<li>如果多个线程之间的依赖关系是<strong>环形</strong>，存在环路的锁的依赖关系，那么也可能会发生死锁</li>
</ul>
<h5 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h5><ul>
<li>死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力<ul>
<li><strong>数据库</strong>中：检测并放弃事务</li>
<li><strong>JVM</strong>中：无法自动处理</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ce81bd17386cbcc3d04b5ef352a1c492ec9b0668/data/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81.jpg"></p>
<h5 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h5><ul>
<li>不一定发生，但是遵守<strong>墨菲定律</strong></li>
<li>一旦发生，多是<strong>高并发</strong>场景，影响用户多</li>
<li>整个<strong>系统崩溃</strong>、子系统崩溃、性能降低</li>
<li>压力测试<strong>无法找出</strong>所有潜在的死锁</li>
</ul>
<pre><code class="java">deadlock/DeadLock.java
package deadlock;

/**
 * 描述：     必然发生死锁
 */
public class DeadLock implements Runnable &#123;

    public int flag;

    static Object o1 = new Object();
    static Object o2 = new Object();

    public void run() &#123;
        System.out.println(&quot;开始执行&quot;);
        if (flag == 1) &#123;
            synchronized (o1) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o2) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
        if (flag == 2) &#123;
            synchronized (o2) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (o1) &#123;
                    System.out.println(&quot;成功获取到了两把锁&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        DeadLock r1 = new DeadLock();
        DeadLock r2 = new DeadLock();
        r1.flag = 1;
        r2.flag = 2;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;
&#125;
====================================== 分析 =======================================
★ 当类的对象flag=1时(T1),先锁定O1,睡眠500毫秒，然后锁定O2;
★ 而T1在睡眠的时候另一个flag=2的对象(T2)线程启动，先锁定O2，睡眠500毫秒，等待T1释放O1;
★ T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定
★ T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定
★ T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁
</code></pre>
<h3 id="哲学家就餐问题？"><a href="#哲学家就餐问题？" class="headerlink" title="哲学家就餐问题？"></a>哲学家就餐问题？</h3><ul>
<li>先拿起左手的筷子</li>
<li>然后拿起右手的筷子</li>
<li>如果筷子被人使用了，那就等别人用完</li>
</ul>
<pre><code class="java">while(true)&#123; //伪代码
    think();
    pick_up_left_fork();
    pick_up_right_fork();
    eat();
    put_down_right_fork();
    put_down_left_fork();
&#125;
</code></pre>
<pre><code class="java">package deadlock;

/**
 * 描述：     哲学家就餐问题导致的死锁
 */
public class DiningPhilosophers &#123;

    public static class Philosopher implements Runnable &#123;

        private Object leftChopstick;

        public Philosopher(Object leftChopstick, Object rightChopstick) &#123;
            this.leftChopstick = leftChopstick;
            this.rightChopstick = rightChopstick;
        &#125;

        private Object rightChopstick;

        @Override
        public void run() &#123;
            try &#123;
                while (true) &#123;
                    doAction(&quot;Thinking&quot;);
                    synchronized (leftChopstick) &#123;
                        doAction(&quot;Picked up left chopstick&quot;);
                        synchronized (rightChopstick) &#123;
                            doAction(&quot;Picked up right chopstick - eating&quot;);
                            doAction(&quot;Put down right chopstick&quot;);
                        &#125;
                        doAction(&quot;Put down left chopstick&quot;);
                    &#125;
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        private void doAction(String action) throws InterruptedException &#123;
            System.out.println(Thread.currentThread().getName() + &quot; &quot; + action);
            Thread.sleep((long) (Math.random() * 10));
        &#125;
    &#125;

    public static void main(String[] args) &#123;//五个哲学家方便管理
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];
        for (int i = 0; i &lt; chopsticks.length; i++) &#123;
            chopsticks[i] = new Object();
        &#125;
        for (int i = 0; i &lt; philosophers.length; i++) &#123;
            Object leftChopstick = chopsticks[i]; //从0开始 i为5 所以底下要加1 但是越界就取余
            Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];
            //领导调节(检测与恢复策略) [定期巡视命令哲学家] 让最后一个 跟别人不一样 
            //别人都是先左后右面 它是先后面再左边 避免了环路的形成
            //直接避免死锁发生！！！！！
            if (i == philosophers.length - 1) &#123;
                philosophers[i] = new Philosopher(rightChopstick, leftChopstick);
            &#125; else &#123;
                philosophers[i] = new Philosopher(leftChopstick, rightChopstick);
            &#125;
            new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();
        &#125;
    &#125;
&#125;
=============================================================================
哲学家4号 Thinking
哲学家5号 Thinking
哲学家3号 Thinking
哲学家1号 Thinking
哲学家2号 Thinking
哲学家2号 Picked up left chopstick
哲学家3号 Picked up left chopstick
哲学家1号 Picked up left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家4号 Thinking
哲学家3号 Picked up right chopstick - eating
哲学家3号 Put down right chopstick
哲学家3号 Put down left chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
哲学家4号 Put down right chopstick
哲学家4号 Put down left chopstick
哲学家3号 Thinking
哲学家2号 Picked up right chopstick - eating
哲学家4号 Thinking
哲学家2号 Put down right chopstick
哲学家4号 Picked up left chopstick
哲学家4号 Picked up right chopstick - eating
.............................
发生死锁的时候哲学家都拿着左边的筷子
原理：Thread.sleep((long) (Math.random() * 10));
random到了一个更大的数
</code></pre>
<h5 id="多种解决策略"><a href="#多种解决策略" class="headerlink" title="多种解决策略"></a>多种解决策略</h5><ul>
<li>服务员检查(避免策略) [提前看一看是否发生死锁]</li>
<li><strong>改变一个哲学家拿叉子的顺序</strong>(避免策略)</li>
<li>餐票(避免策略)</li>
<li>领导调节(检测与恢复策略) [定期巡视命令哲学家]</li>
</ul>
<h5 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h5><h6 id="①-设置超时时间"><a href="#①-设置超时时间" class="headerlink" title="① 设置超时时间"></a>① 设置<strong>超时</strong>时间</h6><ul>
<li>Lock的<strong>tryLock</strong>(long timeout, TImeUnit unit)</li>
<li><strong>synchronized</strong>不具备尝试锁的能力</li>
<li>造成超时的可能性很多：发生了死锁、线程陷入死循环、线程执行很慢</li>
<li>获取锁失败：打日志、发报警邮件、<strong>重启</strong>等</li>
<li>代码演示：<strong>退一步海阔天空</strong></li>
</ul>
<pre><code class="java">package deadlock;

import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 描述：     用tryLock来避免死锁
 */
public class TryLockDeadlock implements Runnable &#123;

    int flag = 1;
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();

    public static void main(String[] args) &#123;
        TryLockDeadlock r1 = new TryLockDeadlock();
        TryLockDeadlock r2 = new TryLockDeadlock();
        r1.flag = 1;
        r2.flag = 0;
        new Thread(r1).start();
        new Thread(r2).start();
    &#125;

    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            if (flag == 1) &#123;
                try &#123;
                    if (lock1.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程1获取到了锁1&quot;);
                        Thread.sleep(new Random().nextInt(1000));
                        if (lock2.tryLock(800, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程1获取到了锁2&quot;);
                            System.out.println(&quot;线程1成功获取到了两把锁&quot;);
                            lock2.unlock();
                            lock1.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程1尝试获取锁2失败，已重试&quot;);
                            lock1.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程1获取锁1失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if (flag == 0) &#123;
                try &#123;
                    if (lock2.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                        System.out.println(&quot;线程2获取到了锁2&quot;);

                        Thread.sleep(new Random().nextInt(1000));
                        if (lock1.tryLock(3000, TimeUnit.MILLISECONDS)) &#123;
                            System.out.println(&quot;线程2获取到了锁1&quot;);
                            System.out.println(&quot;线程2成功获取到了两把锁&quot;);
                            lock1.unlock();
                            lock2.unlock();
                            break;
                        &#125; else &#123;
                            System.out.println(&quot;线程2尝试获取锁1失败，已重试&quot;);
                            lock2.unlock();
                            Thread.sleep(new Random().nextInt(1000));
                        &#125;
                    &#125; else &#123;
                        System.out.println(&quot;线程2获取锁2失败，已重试&quot;);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
====================================================================================
线程1获取到了锁1
线程2获取到了锁2
线程1尝试获取锁2失败，已重试 【正是有了线程1的释放 才让线程2拿到了锁1】
线程2获取到了锁1
线程2成功获取到了两把锁
线程1获取到了锁1
线程1获取到了锁2
线程1成功获取到了两把锁
</code></pre>
<h6 id="②-多使用并发类而不是自己设置锁"><a href="#②-多使用并发类而不是自己设置锁" class="headerlink" title="② 多使用并发类而不是自己设置锁"></a>② 多使用并发类而不是自己设置锁</h6><h6 id="③-尽量降低锁的使用粒度：用不同的锁而不是一个锁"><a href="#③-尽量降低锁的使用粒度：用不同的锁而不是一个锁" class="headerlink" title="③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁"></a>③ 尽量降低锁的使用粒度：用不同的锁而不是一个锁</h6><h6 id="④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"><a href="#④-如果能使用同步代码块，就不使用同步方法：自己锁定锁对象" class="headerlink" title="④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象"></a>④ 如果能使用同步代码块，就不使用同步方法：自己锁定锁对象</h6><h6 id="⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"><a href="#⑤-给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践" class="headerlink" title="⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践"></a>⑤ 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</h6><h3 id="Hashmap为什么-线程-不安全？"><a href="#Hashmap为什么-线程-不安全？" class="headerlink" title="Hashmap为什么[线程]不安全？"></a>Hashmap为什么[线程]不安全？</h3><ul>
<li><p>i++</p>
<ul>
<li>第一个步骤是<strong>读取</strong></li>
<li>第二个步骤是<strong>增加</strong></li>
<li>第三个步骤是<strong>保存</strong></li>
</ul>
<p>有可能会发生线程不安全的情况<br><img src="https://raw.githubusercontent.com/P-luminary/images/ae6685b2f5be7812a77134895bdd7c4fe843933f/data/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AE%89%E5%85%A8.jpg"></p>
</li>
<li><p>同时put碰撞导致数据丢失</p>
</li>
<li><p>可见性问题无法保证</p>
</li>
</ul>
<h3 id="final的作用是什么？有哪些用法？"><a href="#final的作用是什么？有哪些用法？" class="headerlink" title="final的作用是什么？有哪些用法？"></a>final的作用是什么？有哪些用法？</h3><ul>
<li>final修饰<strong>变量</strong></li>
<li>final修饰<strong>方法</strong></li>
<li>final修饰<strong>类</strong></li>
</ul>
<h5 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h5><ul>
<li>早期<ul>
<li>锁定</li>
<li>final效率：早期的Java实现版本中，会将final方法转为内嵌调用</li>
</ul>
</li>
<li>现在<ul>
<li><strong>类防止被继承、方法防止被重写、变量防止被修改</strong></li>
<li>天生是<strong>线程安全</strong>的，而不需要额外的同步开销</li>
</ul>
</li>
</ul>
<h5 id="final的3种用法"><a href="#final的3种用法" class="headerlink" title="final的3种用法"></a>final的3种用法</h5><h6 id="final修饰变量：赋值时机"><a href="#final修饰变量：赋值时机" class="headerlink" title="final修饰变量：赋值时机"></a>final修饰变量：赋值时机</h6><ul>
<li><p><strong>属性</strong>被声明为final后，该变量则<strong>只能被赋值一次</strong>。且一旦被赋值，final的变量就<strong>不能再被改变</strong>，无论如何也不会改变</p>
</li>
<li><p>final修饰<strong>变量</strong></p>
<ul>
<li><p>final instance variable (类中的final属性) </p>
<ul>
<li>第一种是在声明变量的<strong>等号右边</strong>直接赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static int a = 5;

    public static void main(String[] args) &#123;
        FinalVariable.a = 8;
    &#125;
&#125;
</code></pre>
<ul>
<li>第二种就是<strong>构造函数</strong>中赋值</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public final int a;

    public testFinal(int a) &#123;
        this.a = b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>第三种就是在类的<strong>初始代码块种</strong>赋值(不常用)</li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰变量
 */
public class FinalVariable &#123;

    public static final int a;

    static &#123;
        a = 9;
    &#125;

    void testFinal() &#123;
        final int b;
    &#125;
    public static void main(String[] args) &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>如果不采用第一种赋值方法，那么就必须在第2、3种挑一个来赋值，而不能不赋值，这是final语法所 规定的</li>
</ul>
</li>
<li><p>final <strong>static</strong> variable (类中的static final属性)</p>
<ul>
<li>两种赋值时机：除了在声明变量的<strong>等号右边</strong>直接赋值外，static final变量还可以用<strong>static初始代码块</strong>赋值，但是不能用普通的初始代码块赋值</li>
</ul>
</li>
<li><p>final <strong>local</strong> variable (方法中的final变量)</p>
<ul>
<li>和前两种不同，由于这里的变量是在方法里的，所以没有构造函数，也不存在初始代码块</li>
<li>final local variable不规则赋值时机，只要求在<strong>使用前必须赋值</strong>，这和方法中的非final变量的要求也是一样的</li>
</ul>
</li>
</ul>
<h6 id="为什么要规定赋值时机？"><a href="#为什么要规定赋值时机？" class="headerlink" title="为什么要规定赋值时机？"></a>为什么要规定赋值时机？</h6><ul>
<li>如果初始化不赋值，<strong>后续赋值，就是从null变成你的赋值</strong>，这就违反final不变的规则了</li>
</ul>
</li>
<li><p>final修饰<strong>方法</strong></p>
<ul>
<li><strong>构造方法</strong>不允许final修饰</li>
<li><strong>不可被重写</strong>，也就是不能被<strong>override</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew;

/**
 * 描述：     final修饰方法
 */
public class FinalMethodDemo&#123;

    public void drink() &#123;
    &#125;

    public final void eat() &#123;
    &#125;
&#125;

class SubClass extends FinalMethodDemo &#123;

    @Override
    public void drink() &#123;
        super.drink();
    &#125;

//    @Override
//    public void eat() &#123;
//        super.drink();
//    &#125;
&#125;
</code></pre>
</li>
<li><p>final修饰<strong>类</strong></p>
<ul>
<li><strong>不可被继承</strong></li>
<li>例如经典的<strong>String类就是final</strong>的，我们从见过哪个类是继承String类的</li>
</ul>
</li>
</ul>
<h3 id="单例模式你会写吗？"><a href="#单例模式你会写吗？" class="headerlink" title="单例模式你会写吗？"></a><span style = "color:red">单例模式你会写吗？</span></h3><ul>
<li><h5 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h5></li>
</ul>
<p>保证只有一个实例且提供只有一个全局入口</p>
<ul>
<li><h5 id="为什么需要单例：节省内存和计算、保证结果正确、方便管理"><a href="#为什么需要单例：节省内存和计算、保证结果正确、方便管理" class="headerlink" title="为什么需要单例：节省内存和计算、保证结果正确、方便管理"></a>为什么需要单例：节省内存和计算、保证结果正确、方便管理</h5></li>
<li><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>无状态的工具类</li>
<li>全局信息类</li>
</ul>
</li>
<li><h5 id="单例模式的8种写法"><a href="#单例模式的8种写法" class="headerlink" title="单例模式的8种写法"></a>单例模式的8种写法</h5><ul>
<li>饿汉式(静态常量) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态常量）（可用）
 */
public class Singleton1 &#123;

    private Singleton1() &#123;

    &#125;

    private final static Singleton1 INSTANCE = new Singleton1();
// [未达到懒加载] 直接创建出来了
    public static Singleton1 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>饿汉式(静态代码块) [可用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     饿汉式（静态代码块）（可用） // [未达到懒加载]
 */
public class Singleton2 &#123;

    private Singleton2() &#123;

    &#125;

    static &#123;
        INSTANCE = new Singleton2();
    &#125;
    private final static Singleton2 INSTANCE;

    public static Singleton2 getInstance() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程不安全) <strong>[不可用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程不安全）
 */
public class Singleton3 &#123;

    private Singleton3() &#123;

    &#125;

    private static Singleton3 INSTANCE;

    public static Singleton3 getInstance() &#123;
        if (INSTANCE == null) &#123;//第一次访问方法
            INSTANCE = new Singleton3();//初始化
        &#125;
        //此时如果两个线程同时访问，都是null，就创造了两个初始化 违反单例模式
        return INSTANCE; //已经被初始化 就返回
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式(线程安全，同步方法) <strong>[不推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton4 &#123;

    private Singleton4() &#123;

    &#125;

    private static Singleton4 INSTANCE;
    //synchronized同步关键字 最多一个线程访问
    //不推荐用的原因是因为一旦适用了synchronized同步关键字 线程就要排队 并发量大
    public synchronized static Singleton4 getInstance() &#123;
        if (INSTANCE == null) &#123;
            INSTANCE = new Singleton4();
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//方法上不进行同步了
package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton5 &#123;

    private Singleton5() &#123;

    &#125;

    private static Singleton5 INSTANCE;

    public static Singleton5 getInstance() &#123;
        if (INSTANCE == null) &#123; //此时不会存在两个线程同时出来了
            synchronized (Singleton5.class) &#123;
                //假如第一个执行完了 第二个进去执行 那么结果还是生成了两个 不符合单例
                INSTANCE = new Singleton5();
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>双重检查[推荐用]</strong><ul>
<li>新建一个对象，但还未初始化</li>
<li>调用构造函数等来初始化该对象</li>
<li>把对象指向引用</li>
</ul>
</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     懒汉式（线程安全，同步方法）（不推荐）
 */
public class Singleton6 &#123;

    private Singleton6() &#123;//2

    &#125;

    private static volatile Singleton6 INSTANCE;

    public static Singleton6 getInstance() &#123;
        if (INSTANCE == null) &#123;
            synchronized (Singleton6.class) &#123;
                if (INSTANCE == null) &#123; //3
                    //就不会出现多个结果了
                    INSTANCE = new Singleton6 //1
                &#125;
            &#125;
        &#125;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类[推荐用]</li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     静态内部类写法（推荐用）
 */
public class Singleton7 &#123;

    private Singleton7() &#123;

    &#125;

    private static class SingletonInstance &#123;
        private static Singleton7 INSTANCE = new Singleton7();
    &#125;

    public static Singleton7 getInstance() &#123;
        return SingletonInstance.INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>枚举[推荐用]</strong></li>
</ul>
<pre><code class="java">package com.imooc.interniew.singleton;

/**
 * 描述：     枚举单例模式
 */
public enum Singleton8 &#123;
    //1.写法简洁
    //2.线程安全
    //3.防止反射
    
    INSTANCE;
&#125;
</code></pre>
</li>
</ul>
<h5 id="不同写法对比"><a href="#不同写法对比" class="headerlink" title="不同写法对比"></a>不同写法对比</h5><ul>
<li><strong>饿汉</strong>：简单，但是没有lazy loading</li>
<li><strong>懒汉</strong>：有线程安全问题</li>
<li><strong>静态内部类</strong>：可用</li>
<li><strong>双重检查：面试用</strong></li>
<li><strong>枚举：最好</strong></li>
</ul>
<h5 id="单例模式面试常见问题"><a href="#单例模式面试常见问题" class="headerlink" title="单例模式面试常见问题"></a>单例模式面试常见问题</h5><ul>
<li>饿汉式的缺点？[没有懒加载]</li>
<li>懒汉式的缺点？[不可以保证线程安全]</li>
<li><strong>为什么要用double-check</strong>？不用就不安全吗？</li>
<li>为什么双重检查模式要用<strong>volatile</strong>？</li>
<li>应该如何选择，<strong>用哪种单例的实现方案最好</strong>？<ul>
<li>单元素的枚举类型已经成为实现Singleton的最佳方法</li>
<li>写法简单</li>
<li>线程安全有保障</li>
<li>避免反射破坏单例</li>
</ul>
</li>
</ul>
<h3 id="面试避坑指南-1"><a href="#面试避坑指南-1" class="headerlink" title="面试避坑指南"></a>面试避坑指南</h3><ul>
<li>何时投简历 [Offer数量只会越来越少，越早越好]  秋招7-9月 社招金3银4 </li>
<li>信息尽量全面</li>
<li>技术栈契合</li>
<li>慎用”<strong>精通</strong>“ [对源码有很多熟悉] &#x3D;&gt; 多写<strong>熟悉</strong></li>
<li>面试无处不在 [如果没时间可以申请换一个时间节点 并询问对方是否有时间]</li>
<li>提前调试设备</li>
<li>仪容仪表、提前到场 [提前5分钟左右联系面试官]</li>
<li>确认问题 [实在不会可以说思路设想]</li>
<li>问面试官的问题 [提前查公司信息 我了解到我们公司… 可不可以介绍一下… 未来规划… 技术栈…]</li>
</ul>
<h3 id="哪些软素质值得面试官认可？"><a href="#哪些软素质值得面试官认可？" class="headerlink" title="哪些软素质值得面试官认可？"></a>哪些软素质值得面试官认可？</h3><ul>
<li>基本能力：聆听、沟通表达、<strong>学习能力</strong></li>
<li>工作能力：<strong>协作</strong>、<strong>执行力</strong>、管理能力</li>
<li>个人素质：技术自驱力、韧性、积极开放的心态</li>
</ul>
<h3 id="面试课总结"><a href="#面试课总结" class="headerlink" title="面试课总结"></a>面试课总结</h3><ul>
<li>Spring Boot常见面试题</li>
<li>线程常见面试题</li>
<li>分布式的面试题</li>
<li>Docker相关面试题</li>
<li>Nginx和Zookeeper相关面试题</li>
<li>RabbitMQ相关面试题</li>
<li>微服务相关</li>
<li>彩蛋：学习方法</li>
<li>锁分类、死锁</li>
<li>HashMap和final</li>
<li>单例模式[高频考点]</li>
<li>面试避坑指南</li>
<li>重要的软实力</li>
</ul>
<h4 id="2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习"><a href="#2024-5-9-14-34-在创新楼B105-JSP动态网页设计课上-完成了java-4399全部课程的学习" class="headerlink" title="2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习"></a><span style = "color:red">2024.5.9 14:34   在创新楼B105-JSP动态网页设计课上  完成了java+4399全部课程的学习</span></h4>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ffa2c4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/05/04/后端/Zookeeper-Dubbo应用与面试/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/2/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            

            
            <a href="/">
                <span class="page-num">1</span>
            </a>
            

            

            
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
        </span>
        

        <span class="current">
            3
        </span>

        
        <span>
            <a href="/page/4/">
                <span class="page-num">
                    4
                </span>
            </a>
            
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/4/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2026 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>