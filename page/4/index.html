
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2024/04/04/后端/多线程与分布式/">
        <h2>
            多线程与分布式
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/4/4
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="多线程与分布式-周介绍"><a href="#多线程与分布式-周介绍" class="headerlink" title="多线程与分布式 [周介绍]"></a>多线程与分布式 [周介绍]</h1><ul>
<li><h6 id="线程池的基本使用、特点、注意点"><a href="#线程池的基本使用、特点、注意点" class="headerlink" title="线程池的基本使用、特点、注意点"></a>线程池的基本使用、特点、注意点</h6></li>
<li><h6 id="ThreadLoacal的基本使用、原理和注意事项"><a href="#ThreadLoacal的基本使用、原理和注意事项" class="headerlink" title="ThreadLoacal的基本使用、原理和注意事项"></a>ThreadLoacal的基本使用、原理和注意事项</h6></li>
<li><h6 id="分布式基础、核心概念"><a href="#分布式基础、核心概念" class="headerlink" title="分布式基础、核心概念"></a>分布式基础、核心概念</h6></li>
<li><h6 id="docker的下载、安装和基本命令"><a href="#docker的下载、安装和基本命令" class="headerlink" title="docker的下载、安装和基本命令"></a>docker的下载、安装和基本命令</h6></li>
<li><h6 id="独立制作docker容器"><a href="#独立制作docker容器" class="headerlink" title="独立制作docker容器"></a>独立制作docker容器</h6></li>
<li><h6 id="Nginx的安装、基本使用和使用命令"><a href="#Nginx的安装、基本使用和使用命令" class="headerlink" title="Nginx的安装、基本使用和使用命令"></a>Nginx的安装、基本使用和使用命令</h6></li>
<li><h6 id="使用Nginx搭建文件服务"><a href="#使用Nginx搭建文件服务" class="headerlink" title="使用Nginx搭建文件服务"></a>使用Nginx搭建文件服务</h6></li>
<li><h6 id="消息队列RabbitMQ的核心概念queue、message和exchange"><a href="#消息队列RabbitMQ的核心概念queue、message和exchange" class="headerlink" title="消息队列RabbitMQ的核心概念queue、message和exchange"></a>消息队列RabbitMQ的核心概念queue、message和exchange</h6></li>
<li><h6 id="RabbitMQ的四种交换机模式"><a href="#RabbitMQ的四种交换机模式" class="headerlink" title="RabbitMQ的四种交换机模式"></a>RabbitMQ的四种交换机模式</h6></li>
<li><h6 id="SpringBoot整合RabbitMQ案例"><a href="#SpringBoot整合RabbitMQ案例" class="headerlink" title="SpringBoot整合RabbitMQ案例"></a>SpringBoot整合RabbitMQ案例</h6></li>
</ul>
<h2 id="线程池-——-治理线程的法宝"><a href="#线程池-——-治理线程的法宝" class="headerlink" title="线程池 —— 治理线程的法宝"></a>线程池 —— 治理线程的法宝</h2><ul>
<li>线程池的<strong>自我介绍</strong></li>
<li><strong>创建</strong>和停止线程池</li>
<li><strong>常见线程池</strong>的特点和用法</li>
<li>任务太多，怎么<strong>拒绝</strong></li>
<li>钩子方法，给线程池加点料</li>
<li>实现<strong>原理、源码分析</strong></li>
<li>使用线程池的注意点</li>
</ul>
<h5 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h5><ul>
<li>线程池的重要性 [可以复用我们的线程]</li>
<li>什么是”池” – 软件中的”池”，可以理解为计划经济</li>
<li>如果不适用线程池，每个任务都新开一个线程处理<ul>
<li>一个线程</li>
<li>for循环创建线程</li>
<li>当任务数量上升到1000<br><code>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建并销毁线程所带来的开销问题</code>[多了会报错 内存不足异常]</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/ForLoop.java
package threadpool;
/**
 * 描述：     TODO
 */
public class ForLoop &#123;

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Thread thread = new Thread(new Task());
            thread.start();
        &#125;
    &#125;

    static class Task implements Runnable &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;执行了任务&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><ul>
<li>问题一：反复创建线程开销大</li>
<li>问题二：过多的线程会占用太多内存</li>
<li>解决以上两个问题的思路<ul>
<li>用少量的线程——避免内存占用过多</li>
<li>让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗</li>
</ul>
</li>
</ul>
<h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>加快响应速度</li>
<li>合理利用CPU和内存</li>
<li>统一管理</li>
</ul>
<h5 id="线程池使用应用的场合"><a href="#线程池使用应用的场合" class="headerlink" title="线程池使用应用的场合"></a>线程池使用应用的场合</h5><ul>
<li>服务器(Tomcat)接收到大量请求时，使用线程池技术是非常合适的，它可以大大减少现成的创建和销毁次数，提高服务器的工作效率</li>
<li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理</li>
</ul>
<h3 id="线程增减的时机"><a href="#线程增减的时机" class="headerlink" title="线程增减的时机"></a>线程增减的时机</h3><h5 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h5><ul>
<li>线程池<strong>构造方法的参数</strong></li>
<li>线程池应该<strong>手动创建</strong>还是自动创建</li>
<li>线程池里的<strong>线程数量</strong>设定为多少比较合适</li>
<li><strong>停止</strong>线程池的方法</li>
</ul>
<h5 id="线程池构造方法的参数"><a href="#线程池构造方法的参数" class="headerlink" title="线程池构造方法的参数"></a>线程池构造方法的参数</h5><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程的时候，会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>由于线程池无法接收你所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<h5 id="参数中的corePoolSize和maxPoolSize"><a href="#参数中的corePoolSize和maxPoolSize" class="headerlink" title="参数中的corePoolSize和maxPoolSize"></a>参数中的corePoolSize和maxPoolSize</h5><ul>
<li><p><strong>corePoolSize</strong>指的是核心线程数<br>线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新的线程去执行任务</p>
</li>
<li><p>最大量<strong>maxPoolSize</strong><br>在核心线程数的基础上，格外增加的线程数的上限</p>
</li>
</ul>
<h5 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h5><ol>
<li>如果线程数小于corePoolSize，创建一个新线程来运行新任务</li>
<li>如果线程数等于(或大于) corePoolSize但少于maximumPoolSize，则将任务放入<strong>队列</strong></li>
<li>如果队列已满，并且线程数小于maxPoolSize，则创建一个<strong>新线程</strong></li>
<li>如果队列已满，并且线程数大于或等于maxPoolSize，则<strong>拒绝</strong></li>
</ol>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4cb2755066dc76e6602ff1110cfc24124f38b42f/data/%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png"></p>
<ul>
<li>是否需要增加线程的判断顺序是：<ul>
<li>corePoolSize</li>
<li>workQueue</li>
<li>maxPoolSize</li>
</ul>
</li>
</ul>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h6><ul>
<li>线程池：核心池大小为5，最大池大小为10，队列为100</li>
<li>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务，就拒绝</li>
</ul>
<h5 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h5><ul>
<li>通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池</li>
<li>线程池<strong>希望保持较小的线程数</strong>，并且只有在负载变得很大时才增加它</li>
<li>通过设置maximumPoolSize为很高的值，可以允许线程池容纳任意数量的并发任务</li>
<li>只有在队列填满时才创建多于corePoolSize的线程，如果使用的是无界队列，那么线程数就不会超过corePoolSize</li>
</ul>
<h3 id="线程存活时间和工作队列"><a href="#线程存活时间和工作队列" class="headerlink" title="线程存活时间和工作队列"></a>线程存活时间和工作队列</h3><h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><ul>
<li>如果线程池当前的线程多余corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止</li>
</ul>
<h5 id="ThreadFactory-用来创建线程"><a href="#ThreadFactory-用来创建线程" class="headerlink" title="ThreadFactory 用来创建线程"></a>ThreadFactory 用来创建线程</h5><ul>
<li>默认使用Executors.defaultThreadFactory()</li>
<li>创建出来的线程都在同一个线程组</li>
<li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等</li>
</ul>
<h5 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h5><ul>
<li>有三种最常见的队列类型<ul>
<li>直接交接：SynchronousQueue</li>
<li>无界队列：LinkedBlockingQueue</li>
<li>有界队列：ArrayBlockingQueue</li>
</ul>
</li>
</ul>
<h3 id="自动创建线程池的风险"><a href="#自动创建线程池的风险" class="headerlink" title="自动创建线程池的风险"></a>自动创建线程池的风险</h3><h5 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h5><ul>
<li>手动创建更好，因为这样可以更加明确线程池的运行规则，避免资源耗尽的风险<br>自动创建线程池(即直接调用JDK封装好的构造方法) 可能会带来哪些问题？</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>容易造成大量内存占用，可能会导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/FixedThreadPoolThread.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FixedThreadPoolThread &#123;
    public static void main(String[] args) &#123; //核心线程数量
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
class Task implements Runnable&#123;

    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;
=======================================================================
pool-1-thread-3
pool-1-thread-4
pool-1-thread-1
pool-1-thread-2
    
pool-1-thread-3
pool-1-thread-1
pool-1-thread-4
pool-1-thread-2
因为核心线程数量只规定了4个 这有这四个线程跑程序
</code></pre>
<pre><code class="java">threadpool/FixedThreadPoolOOM.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示nexFixedThreadPool出错的情况
 */
public class FixedThreadPoolOOM &#123;
    private static ExecutorService executorService = Executors.newFixedThreadPool(1);

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; Integer.MAX_VALUE; i++)&#123;
            executorService.execute(new SubThread());
        &#125;
    &#125;
&#125;
class SubThread implements Runnable&#123;

    @Override
    public void run() &#123;
        try&#123;//一直睡觉 不让它结束
            Thread.sleep(1000000000);
        &#125;catch (InterruptedException e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
=======================================================================
报错：java.lang.OutOfMemoryError:GC overhead limilt exceeded
</code></pre>
<ul>
<li><strong>newSingleThreadExecutor</strong> [单独的线程]<ul>
<li>当请求堆积的时候，可能会占用大量的内存</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/SingleThreadExecutor.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutor &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
=======================================================================
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
pool-1-thread-1
</code></pre>
<ul>
<li><strong>CachedThreadPool</strong> [可缓存线程池]<ul>
<li>特点：具有自动回收多余线程的功能</li>
<li>弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE, 这可能会创建数量非常多的线程，甚至导致OOM</li>
</ul>
</li>
</ul>
<pre><code class="java">threadpool/CachedThreadPool.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPool &#123;
    public static void main(String[] args) &#123;
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new Task());
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>newScheduledThreadPool</strong> [跟时间相关的]</li>
</ul>
<pre><code class="java">threadpool/ScheduledThreadPool.java
package threadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPool &#123;
    public static void main(String[] args) &#123;
        ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(10);
        threadPool.schedule(new Task(), 5, TimeUnit.SECONDS);
        threadPool.scheduleAtFixedRate(new Task(), 1, 3, TimeUnit.SECONDS);//每隔3s运行
    &#125;
&#125;
</code></pre>
<ul>
<li>正确的创建线程池的方法<ul>
<li><strong>根据不同的业务场景</strong>，设置线程池参数</li>
<li>比如：内存有多大，给线程取什么名字等等</li>
</ul>
</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="线程池里的线程数量设定为多少比较合适？"><a href="#线程池里的线程数量设定为多少比较合适？" class="headerlink" title="线程池里的线程数量设定为多少比较合适？"></a>线程池里的线程数量设定为多少比较合适？</h3><ul>
<li><strong>CPU密集型</strong>(加密、计算hash等)：最佳线程数为CPU核心数的1-2倍左右</li>
<li><strong>耗时IO型</strong>(读写数据库、文件、网络读写等)：最佳线程数一般会大于CPU核心数很多倍<br>参考Brain Goetz推荐的计算方法：<br><span style = "color:red"><strong>线程数 &#x3D; CPU核心数 × (1 + 平均等待时间 &#x2F; 平均工作时间)</strong></span></li>
</ul>
<h3 id="对比各种线程池的特点"><a href="#对比各种线程池的特点" class="headerlink" title="对比各种线程池的特点"></a>对比各种线程池的特点</h3><h5 id="常见的线程池的特点"><a href="#常见的线程池的特点" class="headerlink" title="常见的线程池的特点"></a>常见的线程池的特点</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/ee67f47de97062e593b16348ff148cd52f7b7d6e/data/%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg"></p>
<h5 id="以上4种线程池的构造方法的参数"><a href="#以上4种线程池的构造方法的参数" class="headerlink" title="以上4种线程池的构造方法的参数"></a>以上4种线程池的构造方法的参数</h5><table>
<thead>
<tr>
<th>Parameter</th>
<th>FixedThreadPool</th>
<th>CachedThreadPool</th>
<th>ScheduledThreadPool</th>
<th>SingleThreaded</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>constructor-arg</td>
<td>0</td>
<td>constructor-arg</td>
<td>1</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>same as corePoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>Integer.MAX_VALUE</td>
<td>1</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>0 seconds</td>
<td>60 seconds</td>
<td>0 seconds</td>
<td>0 seconds</td>
</tr>
</tbody></table>
<h3 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h3><ul>
<li>FixedThreadPool和SingleThreadExecutor的Queue是<strong>LinedBlockingQueue</strong>？</li>
<li>CachedThreadPool使用的是Queue是<strong>SynchronousQueue</strong>？</li>
<li>ScheduledThreadPool使用延迟队列DelayedWorkQueue</li>
</ul>
<h5 id="workStealingPool是JDK1-8加入的"><a href="#workStealingPool是JDK1-8加入的" class="headerlink" title="workStealingPool是JDK1.8加入的"></a>workStealingPool是JDK1.8加入的</h5><ul>
<li>这个线程池和之前的都有很大不同</li>
<li>子任务</li>
<li>窃取 [并行执行]</li>
</ul>
<h3 id="如何正确关闭线程池"><a href="#如何正确关闭线程池" class="headerlink" title="如何正确关闭线程池"></a>如何正确关闭线程池</h3><h5 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h5><ul>
<li><strong>shutdown</strong> [再给就拒绝 新的任务不会增加了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        executorService.execute(new ShutDownTask());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;

=================================================================================
pool-1-thread-4
pool-1-thread-9
pool-1-thread-10
Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task threadpool.ShutDownTask@61bbe9ba rejected from java.util.concurrent.ThreadPoolExecutor@610455d6[Shutting down, pool size = 10, active threads = 10, queued tasks = 970, completed tasks = 20]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
    at threadpool.Shutdown.main(Shutdown.java:18)
pool-1-thread-8
pool-1-thread-1
pool-1-thread-3
</code></pre>
<ul>
<li><strong>isShutdown</strong> [判断是否进入停止状态]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 1000; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>isTerminated</strong> [线程停止返回 整个程序执行完毕]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500);
        System.out.println(executorService.isShutdown());//false
        executorService.shutdown();//绅士的暂停 再去提交的任务就不会增加了
        System.out.println(executorService.isShutdown());//true 已经结束了
        System.out.println(executorService.isTerminated());
        Thread.sleep(10000);
        System.out.println(executorService.isTerminated());
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
==========================================================================
pool-1-thread-5
pool-1-thread-10
false
true
false
pool-1-thread-2
pool-1-thread-6
pool-1-thread-6
pool-1-thread-2
true
</code></pre>
<ul>
<li><strong>awaitTermination</strong> [测试一段时间内线程会不会完全停止的方法 <u>等待的时间进程被打乱了</u> 等待的时间到了]</li>
</ul>
<pre><code class="java">threadpool/Shutdown.java
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdown();
        boolean b = executorService.awaitTermination(7L, TimeUnit.SECONDS);
        System.out.println(b);
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong>shutdownNow</strong> [立刻关闭线程池]</li>
</ul>
<pre><code class="java">///正在执行的和不要关闭 正在等待的内容直接返回 如何优雅编写？
package threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * 演示关闭线程池
 */
public class Shutdown &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //任务往线程池中提交
        for (int i = 0; i &lt; 100; i++) &#123;
            executorService.execute(new ShutDownTask());
        &#125;
        Thread.sleep(1500); //七秒钟之内是否完全运行完毕了
        executorService.shutdownNow();//暴力关闭线程
        //这是正在队列中的数据 取了个List集合 都到runnableList里面了 要给它一个交代
        List&lt;Runnable&gt; runnableList = executorService.shutdownNow();
    &#125;
&#125;
class ShutDownTask implements Runnable&#123;
    @Override
    public void run() &#123;
        try &#123;
            Thread.sleep(500);
            System.out.println(Thread.currentThread().getName());
        &#125; catch (InterruptedException e) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;被中断了&quot;);
        &#125;
    &#125;
&#125;

=================================================================
pool-1-thread-6
pool-1-thread-4
pool-1-thread-10
pool-1-thread-8
pool-1-thread-3被中断了
pool-1-thread-1被中断了
pool-1-thread-8被中断了
pool-1-thread-2被中断了
</code></pre>
<h3 id="暂停和恢复线程池"><a href="#暂停和恢复线程池" class="headerlink" title="暂停和恢复线程池"></a>暂停和恢复线程池</h3><ul>
<li><strong>拒绝时机</strong><ul>
<li>当Executor关闭时，提交<strong>新任务</strong>会<strong>被拒绝</strong></li>
<li>以及当Executor对最大线程和工作队列容量使用有限边界并且<strong>已经饱和</strong>时</li>
</ul>
</li>
</ul>
<h5 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h5><ul>
<li><strong>AbortPolicy</strong> [直接抛出异常]</li>
<li><strong>DiscardPolicy</strong> [默默的丢弃]</li>
<li><strong>DiscardOldestPolicy</strong> [丢弃最老的]</li>
<li><strong>CallerRunsPolicy</strong> [誰提交任务誰去跑(避免了业务损失 提交任务速度下降 给了线程池缓冲时间)]</li>
</ul>
<h5 id="钩子方法，给线程池加点料"><a href="#钩子方法，给线程池加点料" class="headerlink" title="钩子方法，给线程池加点料"></a>钩子方法，给线程池加点料</h5><ul>
<li>每个任务执行前后</li>
<li>日志、统计</li>
<li>代码演示</li>
</ul>
<pre><code class="java">threadpool/PauseableThreadPool.java
package threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 演示每个任务执行前后放钩子函数
 */
public class PauseableThreadPool extends ThreadPoolExecutor &#123;
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unpaused = lock.newCondition();
    private boolean isPaused;
    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    &#125;

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    &#125;

    @Override //在执行任务之前都会调用这个函数
    protected void beforeExecute(Thread t, Runnable r) &#123;
        super.beforeExecute(t, r);
        lock.lock();
        //如果检测到就暂停休息
        try &#123;
            while (isPaused) &#123;
                unpaused.await();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    private void pause()&#123;
        lock.lock();
        try&#123;
            isPaused = true;
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
    public void resume()&#123;
        lock.lock();
        try&#123;
            isPaused = false;
            unpaused.signalAll(); //唤醒全部
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l,
                TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());
        Runnable runnable = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;我被执行&quot;);
                try &#123;
                    Thread.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;;
        for (int i = 0; i &lt; 10000; i++) &#123;
            pauseableThreadPool.execute(runnable);
        &#125;
            Thread.sleep(1500);
            pauseableThreadPool.pause();
            System.out.println(&quot;线程池被暂停了&quot;);
            Thread.sleep(1500);
            pauseableThreadPool.resume();
            System.out.println(&quot;线程池被恢复了&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="线程池实现复用的原因"><a href="#线程池实现复用的原因" class="headerlink" title="线程池实现复用的原因"></a>线程池实现复用的原因</h3><ul>
<li>线程池组成部分<ul>
<li>线程池管理器</li>
<li>工作线程</li>
<li>任务队列</li>
<li>任务接口(Task)</li>
</ul>
</li>
</ul>
<h5 id="Executor家族"><a href="#Executor家族" class="headerlink" title="Executor家族"></a>Executor家族</h5><ul>
<li><p>线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，都是什么关系？</p>
<p>Executor ← ExecutorService ← AbstractExecutorService ← ThreadPoolExecutor</p>
</li>
</ul>
<h5 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h5><ul>
<li>相同线程执行不同任务</li>
</ul>
<h3 id="线程池状态和使用注意点"><a href="#线程池状态和使用注意点" class="headerlink" title="线程池状态和使用注意点"></a>线程池状态和使用注意点</h3><h5 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h5><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>接收新任务并处理排队任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>不接受新任务，但处理排队任务</td>
</tr>
<tr>
<td>STOP</td>
<td>不接受新任务，也不处理排队任务，并中断正在进行的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminate()运行完成</td>
</tr>
</tbody></table>
<h5 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h5><ul>
<li>避免任务<strong>堆积</strong></li>
<li>避免线程数<strong>过度增加</strong></li>
<li>排查<strong>线程泄露</strong></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h6 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h6><ul>
<li>让某个需要用到的对象在<strong>线程间隔离</strong></li>
<li>在任何方法中都可以<strong>轻松获取</strong>到该对象 .get</li>
</ul>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问) 时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是ptivate static类型的，用于关联线程和线程上下文，它的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂性。</p>
<ul>
<li>定义：提供<strong>线程局部</strong>变量；一个线程局部变量在多个线程中，分别由独立的值(副本)</li>
<li>特点：简单(开箱即用)、快速(无格外开销)、安全(线程安全)</li>
<li>场景：多线程场景(<strong>资源持有、线程一致性、并发计算、线程安全</strong>等场景)</li>
<li>实现原理：Java中使用<strong>哈希表</strong>实现</li>
<li>应用范围：几乎<strong>所有</strong>提供多线程特征的语言</li>
<li>设计者追求开箱即用的体验</li>
</ul>
<h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><ul>
<li>构造函数 <strong>ThreadLocal<T>()</strong></li>
<li>初始化 <strong>initialValue()</strong><ul>
<li>该方法会返回当前线程对应的”初始值”，这是一个<strong>延迟加载</strong>的方法，只有在<strong>调用get</strong>的时候，才会触发</li>
<li>当线程<strong>第一次使用get</strong>方法访问变量时，将调用此方法</li>
<li>每个线程最多调用<strong>一次</strong>此方法，但如果已经调用了remove()后，在调用get()，则可以再次调用此方法</li>
<li>如果不重写本方法，这个方法会返回null。一般使用匿名内部类的方法来**重写initialValue()**方法</li>
</ul>
</li>
<li>访问器 T <strong>get</strong>()：得到这个线程对应的value，如果是首次调用get()则会调用initialize来得到这个值 &#x2F;&#x2F; void <strong>set</strong>(T t)：为这个线程设置一个新值</li>
<li>回收 void <strong>remove</strong>(): 删除这个线程</li>
</ul>
<h6 id="根据共享对象的生成时机不同，选择initialValue或set来保存对象"><a href="#根据共享对象的生成时机不同，选择initialValue或set来保存对象" class="headerlink" title="根据共享对象的生成时机不同，选择initialValue或set来保存对象"></a>根据共享对象的生成时机不同，选择initialValue或set来保存对象</h6><h6 id="场景一：initialValue"><a href="#场景一：initialValue" class="headerlink" title="场景一：initialValue"></a>场景一：initialValue</h6><ul>
<li>在ThreadLocal<strong>第一次get</strong>的时候把对象給初始化出来，对象的初始化时机可以<strong>由我们控制</strong></li>
</ul>
<h6 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h6><ul>
<li>如果需要保存到ThreadLocal里的对象的生成时机<strong>不由我们随机控制</strong>，例如拦截器生成的用户信息</li>
<li>用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用</li>
</ul>
<h6 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h6><ul>
<li>达到<strong>线程安全</strong></li>
<li><strong>不需要加锁</strong>，提高执行<strong>效率</strong></li>
<li>更高效地<strong>利用内存、节省开销</strong></li>
<li><strong>避免传参</strong>的繁琐</li>
</ul>
<pre><code class="java">threadpool/ThreadLocalAPI.java
package threadpool;

public class ThreadLocalAPI &#123;
    public static ThreadLocal&lt;Long&gt; x = new ThreadLocal()&#123;
        @Override
        protected Long initialValue()&#123;
            System.out.println(&quot;Inital Value run...&quot;);
            return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        new Thread() &#123;
            @Override
            public void run() &#123;
                System.out.println(x.get());
            &#125;
        &#125;.start(); //调用一次initialValue 每个线程单独拥有一个
        x.set(101l);
        x.remove();//清空线程 结果为1 因为 Thread.currentThread().getId();
        System.out.println(x.get());//发现x.remove被移除了 结果去重新触发initialValue
        System.out.println(x.get());
    &#125;
&#125;
========================================================================
Inital Value run...
Inital Value run...
20
1
1

若注释掉x.remove则会出现结果：
Inital Value run...
101
101
20
</code></pre>
<h3 id="ThreadLocal的4种核心场景"><a href="#ThreadLocal的4种核心场景" class="headerlink" title="ThreadLocal的4种核心场景"></a>ThreadLocal的4种核心场景</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e19e3d304bdfe6eeda2ae3a7f83a22ad4b9f274c/data/ThreadLocal%E7%9A%844%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF.png"></p>
<ul>
<li><strong>持有资源</strong>——持有线程资源供线程的各个部分使用，全局获取，减少<strong>编程难度</strong></li>
<li><strong>线程一致</strong>——帮助需要保持线程一致的资源(如数据库事务) 维护一致性，降低<strong>编程难度</strong></li>
<li><strong>线程安全</strong>——帮助只考虑了单线程的程序库，无缝向多线程场景迁移</li>
</ul>
<h3 id="ThreadLocal并发场景分析01"><a href="#ThreadLocal并发场景分析01" class="headerlink" title="ThreadLocal并发场景分析01"></a>ThreadLocal并发场景分析01</h3><h5 id="例1-200QPS压测统计接口"><a href="#例1-200QPS压测统计接口" class="headerlink" title="例1 200QPS压测统计接口"></a>例1 200QPS压测统计接口</h5><ul>
<li>观察200QPS下Spring框架的执行情况</li>
<li>目标：理解并发、竞争条件、临界区等概念</li>
<li>代表场景：交易场景</li>
</ul>
<h5 id="并发、竞争条件和临界区"><a href="#并发、竞争条件和临界区" class="headerlink" title="并发、竞争条件和临界区"></a>并发、竞争条件和临界区</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7abcc6448891d1b18f32a37dcaf90210ca396b58/data/ThreadLocal%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF.jpg" alt="ThreadLocal并发场景"></p>
<ul>
<li>并发：多个程序<strong>同时执行</strong></li>
<li>竞争条件：多个进程(线程)同时访问<strong>同一个内存资源</strong>，最终的执行结果依赖于多个进程执行时的<strong>精确时序</strong></li>
<li>临界区：访问共享内存的程序片段</li>
</ul>
<pre><code class="java">StatController.java
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;
    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Integer&gt; c = new ThreadLocal&lt;Integer&gt;() &#123;
        @Override
        protected Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
    synchronized void _add() throws InterruptedException &#123;
        Thread.sleep(100);
        c.set(c.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return c.get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;

&#125;
</code></pre>
<pre><code class="java">SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;
&#125;
</code></pre>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>基于线程池模型synchronize(排队操作很危险)</li>
<li>用ThreadLocal收集数据很快速且安全</li>
<li>思考：如何在多个ThreadLocal中收集数据？</li>
</ul>
<h3 id="ThreadLocal场景分析——减少同步"><a href="#ThreadLocal场景分析——减少同步" class="headerlink" title="ThreadLocal场景分析——减少同步"></a>ThreadLocal场景分析——减少同步</h3><h5 id="ThreadLocal-lt-T-gt-同步"><a href="#ThreadLocal-lt-T-gt-同步" class="headerlink" title="ThreadLocal&lt; T &gt;同步"></a>ThreadLocal&lt; T &gt;同步</h5><pre><code class="java">StatController.java    高效解决高并发
package com.imooc.springbootlearn;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.HashSet;

@Controller //并发可能导致同时 数据错误 需要加★后面的代码
public class StatController &#123;

    static HashSet&lt;Val&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
    synchronized static void addSet(Val&lt;Integer&gt; v)&#123;
        set.add(v);
    &#125;

    //★★ 避免用锁 导致当数据多的话线程缓慢
    static ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = new ThreadLocal&lt;Val&lt;Integer&gt;&gt;() &#123;
        @Override
        protected Val&lt;Integer&gt; initialValue() &#123;
            Val&lt;Integer&gt; v = new Val&lt;&gt;();
            v.set(0);
            //set.add(v);//容易产生同步问题 小锁一下
            return v;
        &#125;
    &#125;;

    //★ 请求并发也要排队synchronized(但是不要轻易使用锁) 应该怎么办 见★★
/*synchronized*/void _add() throws InterruptedException &#123;
        Thread.sleep(100); //高并发
        Val&lt;Integer&gt; v = c.get();
        v.set(v.get() + 1);
    &#125;

    @RequestMapping(&quot;/stat&quot;)
    public Integer stat() &#123;
        return set.stream().map(x -&gt; x.get()).reduce((a, x) -&gt; a + x).get();
    &#125;

    @RequestMapping(&quot;/add&quot;)
    public Integer add() throws InterruptedException &#123;
//        Thread.sleep(100l);
//        c++;
        _add();
        return 1;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Val.java
package com.imooc.springbootlearn;

public class Val&lt;T&gt;&#123;
    T v;
    public void set(T _v)&#123;
        v = _v;
    &#125;
    public T get()&#123;
        return v;
    &#125;
&#125;
</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul>
<li>完全避免同步(<strong>难</strong>)</li>
<li>缩小同步范围(<strong>简单</strong>) + ThreadLocal解决问题</li>
<li>思考：还可以用在哪些场景？</li>
</ul>
<h6 id="源码分析1-Quartz-SimpleSemaphore"><a href="#源码分析1-Quartz-SimpleSemaphore" class="headerlink" title="源码分析1-Quartz SimpleSemaphore"></a>源码分析1-Quartz SimpleSemaphore</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/d20d4cb3a98413a2fb910922671f8a98e6d114a5/data/Quartz%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>Quartz的SimpleSemaphore提供资源隔离(上锁)</li>
<li>SimpleSemaphore中的lockOwners(ThreadLocal)为重度锁操作前置过滤</li>
<li>思考：学易，用难！</li>
</ul>
<h6 id="源码分析2-Mybatis框架保持连接池线程一致"><a href="#源码分析2-Mybatis框架保持连接池线程一致" class="headerlink" title="源码分析2-Mybatis框架保持连接池线程一致"></a>源码分析2-Mybatis框架保持连接池线程一致</h6><h5 id="什么是本地事务"><a href="#什么是本地事务" class="headerlink" title="什么是本地事务"></a>什么是本地事务</h5><ul>
<li>A(Atomic)原子性，操作不可分割</li>
<li>C(Consistency)一致性，任何时刻数据都能保持一致</li>
<li>I(Isolation)隔离性，多事务并发执行的时许不影响结果</li>
<li>D(Durability)持久性，对数据结构的存储是永久的</li>
</ul>
<p>Begin → [本地事务：(更新订单状态 →&lt;订单状态更新成功&gt;→发放资源) → <strong>资源发放成功(提交)</strong> → Commit →&lt;持久化&gt;→DB。**若资源发放失败(回滚)**→Rollback]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/9693ffeda32d871b1665958a7febca56da0011bd/data/Mybatis%E6%A1%86%E6%9E%B6%E4%BF%9D%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%BA%BF%E7%A8%8B%E4%B8%80%E8%87%B4.jpg"></p>
<h6 id="源码分析03-Spring框架对分布式事务的支持"><a href="#源码分析03-Spring框架对分布式事务的支持" class="headerlink" title="源码分析03 Spring框架对分布式事务的支持"></a>源码分析03 Spring框架对分布式事务的支持</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/b2cc782319836bb4d81765c38fe5b8de5098bb21/data/Spring%E6%A1%86%E6%9E%B6%E5%AF%B9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81.jpg"></p>
<h3 id="技术选型——实现自己的ThreadLocal"><a href="#技术选型——实现自己的ThreadLocal" class="headerlink" title="技术选型——实现自己的ThreadLocal"></a>技术选型——实现自己的ThreadLocal</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/ec226021e343c1f8dbc268e9809361c629e6cb4d/data/threadLocalMap.jpg"></p>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;

class MyThreadLocal&lt;T&gt; &#123;
    static HashMap&lt;Thread, HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;MyThreadLocal&lt;?&gt;, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this)) &#123;
            map.put(this, initialValue());
        &#125;
        return (T) map.get(this);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this, v);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Test.java
package com.imooc.springbootlearn;

public class Test &#123;
    static MyThreadLocal&lt;Long&gt; v = new MyThreadLocal&lt;Long&gt;()&#123;
        @Override
        protected Long initialValue() &#123;
         return Thread.currentThread().getId();
        &#125;
    &#125;;

    public static void main(String[] args) &#123;
        for (Integer i = 0; i &lt; 100; i++) &#123;
            new Thread(()-&gt;&#123;
                System.out.println(v.get());
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>HashMap中直接存储了MyThreadLocal的引用，导致内存无法回收</li>
<li>思考：可以用整数ID替代对MyThreadLocal的引用</li>
</ul>
<pre><code class="java">MyThreadLocal.java
package com.imooc.springbootlearn;

import java.util.HashMap;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

class MyThreadLocal&lt;T&gt; &#123;
    static AtomicInteger atomic = new AtomicInteger(); //保证数据唯一性
    Integer threadLocalHash = atomic.addAndGet(0x61c88647); //这个值保证hash的更平均性
    static HashMap&lt;Thread, HashMap&lt;Integer, Objects&gt;&gt; threadLocalMap = new HashMap&lt;&gt;();//这里会产生临界区

    synchronized static HashMap&lt;Integer, Objects&gt; getMap() &#123; //这是锁临界区
        var thread = Thread.currentThread();
        if (!threadLocalMap.containsKey(thread)) &#123;
            threadLocalMap.put(thread, new HashMap&lt;Integer, Objects&gt;());
        &#125;
        return threadLocalMap.get(thread);
    &#125;

    T value;

    protected T initialValue() &#123;
        return null;
    &#125;

    public T get() &#123;
        var map = getMap();
        if (!map.containsKey(this.threadLocalHash)) &#123;
            map.put(this.threadLocalHash, initialValue());
        &#125;
        return (T) map.get(this.threadLocalHash);
    &#125;

    public void set(T v)&#123;
        var map = getMap();
        map.put(this.threadLocalHash, v);
    &#125;
&#125;
</code></pre>
<ul>
<li>HashMap无限增加？初始空间分配是否合理？</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h5 id="源码解读——哈希表实现ThreadLocal"><a href="#源码解读——哈希表实现ThreadLocal" class="headerlink" title="源码解读——哈希表实现ThreadLocal"></a>源码解读——哈希表实现ThreadLocal</h5><h6 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h6><p><strong>哈希表</strong>(散列 HashTable) 根据键(Key) 访问&#x2F;设置内存中存储的位置的值</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c2851c7bd5792200e8f9af16f6f08a33520c6f2d/data/%E9%80%89%E5%AD%A6HashTable.png"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>架构是严密且精确的东西(切记夸夸其谈)</li>
<li>并发是一个很危险的场景，提高能力才会获得安全感</li>
<li>保持怀疑，持续学习</li>
<li>会用 → 场景查找 → 轻量实现 → 源码对照 → 场景沉淀</li>
<li>程序架构：低耦合(独立)、高内聚(组合做到开箱即用)</li>
<li>无论达到什么高度，要永远认为自己是个<strong>菜鸡</strong></li>
</ul>
<h2 id="分布式章节"><a href="#分布式章节" class="headerlink" title="分布式章节"></a>分布式章节</h2><ul>
<li><h5 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h5></li>
<li><h5 id="分布式的作用"><a href="#分布式的作用" class="headerlink" title="分布式的作用"></a>分布式的作用</h5></li>
<li><h5 id="分布式和单体结构的对比"><a href="#分布式和单体结构的对比" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5></li>
<li><p><strong>CAP</strong>定理</p>
</li>
<li><p><span style = "color:red"><strong>集群、分布式、微服务</strong></span>的区别</p>
</li>
</ul>
<h3 id="什么是分布式-1"><a href="#什么是分布式-1" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><ul>
<li><p>利用物理架构形成多个自治的处理元素，<strong>不共享主内存</strong>，但是通过<strong>发送信息</strong>合作。</p>
</li>
<li><h6 id="饭店初始的例子"><a href="#饭店初始的例子" class="headerlink" title="饭店初始的例子"></a>饭店初始的例子</h6><ul>
<li><strong>一个</strong>厨师 [单例]</li>
<li><strong>多个</strong>厨师 </li>
<li>术业有<strong>专攻</strong>：配菜师、洗菜工</li>
</ul>
</li>
<li><p>实际项目的演进过程</p>
<ul>
<li>一个项目，<strong>大而全</strong></li>
<li><strong>多台机器</strong>，部署相同的应用</li>
<li><strong>分布式</strong>：权限系统、员工系统、请假系统</li>
</ul>
</li>
</ul>
<h3 id="分布式的作用-1"><a href="#分布式的作用-1" class="headerlink" title="分布式的作用"></a>分布式的作用</h3><h5 id="为什么需要分布式"><a href="#为什么需要分布式" class="headerlink" title="为什么需要分布式"></a>为什么需要分布式</h5><ul>
<li>实际工作中的痛点<ul>
<li>工程<strong>臃肿</strong> [相互耦合 相互冲突]</li>
<li>测试、上线<strong>繁琐</strong></li>
<li>开发<strong>效率低</strong></li>
</ul>
</li>
</ul>
<h5 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h5><ul>
<li>应用代码<strong>耦合</strong>严重，功能扩展难</li>
<li>新需求开发交互周期长，测试工作量大</li>
<li>新加入的开发同事需要很长时间才能熟悉系统</li>
<li>升级维护也很困难(改动任何一点地方都要升级整个系统)</li>
<li>系统性能提升艰难，可用性低，不稳定</li>
</ul>
<h5 id="分布式的好处"><a href="#分布式的好处" class="headerlink" title="分布式的好处"></a>分布式的好处</h5><ul>
<li>增大系统容量</li>
<li>加强系统可用[某个模块出bug 但不影响其他]</li>
<li>因为模块化，所以系统模块重用度更高</li>
<li>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快</li>
<li>系统<strong>扩展性</strong>更高</li>
<li>团队<strong>协作流程</strong>也会得到改善</li>
<li><strong>技术升级</strong></li>
</ul>
<h3 id="单体和分布式的对比"><a href="#单体和分布式的对比" class="headerlink" title="单体和分布式的对比"></a>单体和分布式的对比</h3><h5 id="分布式和单体结构的对比-1"><a href="#分布式和单体结构的对比-1" class="headerlink" title="分布式和单体结构的对比"></a>分布式和单体结构的对比</h5><table>
<thead>
<tr>
<th></th>
<th>传统单体构架</th>
<th>分布式构架</th>
</tr>
</thead>
<tbody><tr>
<td><strong>新人的学习成本</strong></td>
<td>业务逻辑成本高</td>
<td>架构逻辑成本高</td>
</tr>
<tr>
<td><strong>部署、运维</strong></td>
<td>容易</td>
<td>发布频繁，顺序复杂、运维难</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>一损俱损，殃及鱼池</td>
<td>故障影响范围小</td>
</tr>
<tr>
<td><strong>架构设计</strong></td>
<td>难度低</td>
<td>难度指数级上升</td>
</tr>
<tr>
<td><strong>系统性能</strong></td>
<td>响应快、吞吐量小</td>
<td>响应慢、吞吐量大</td>
</tr>
<tr>
<td><strong>测试成本</strong></td>
<td>低</td>
<td>很高</td>
</tr>
<tr>
<td><strong>技术多样性</strong></td>
<td>技术单一且封闭</td>
<td>技术多样且开放</td>
</tr>
<tr>
<td><strong>系统扩展性</strong></td>
<td>扩展性差</td>
<td>扩展性很好</td>
</tr>
<tr>
<td><strong>系统管理成本</strong></td>
<td>成本低</td>
<td>成本高</td>
</tr>
</tbody></table>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><h5 id="CAP的重要性"><a href="#CAP的重要性" class="headerlink" title="CAP的重要性"></a>CAP的重要性</h5><p>分布式不可能同时满足三个条件</p>
<h5 id="CAP理论是什么？"><a href="#CAP理论是什么？" class="headerlink" title="CAP理论是什么？"></a>CAP理论是什么？</h5><ul>
<li><span style = "color:red"><strong>C</strong>(Consistency, 一致性)</span>：读操作是否总能读到前一个写操作的结果</li>
<li><span style = "color:red"><strong>A</strong>(Availability, 可用性)</span>：非故障节点应该在合理的时间内作出合理的响应(不是错误或超时的响应),但是可能<strong>不是最新的数据</strong>。</li>
<li><span style = "color:red"><strong>P</strong>(Partition tolerance, 分区容错)</span>：当出现网络分区现象后，系统能够继续运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/793eb4ab3003af82869b186bcc016fcb8c2c2f5b/data/CAP%E5%AE%9A%E7%90%86.jpg"></p>
<h5 id="CAP如何选择？"><a href="#CAP如何选择？" class="headerlink" title="CAP如何选择？"></a>CAP如何选择？</h5><ul>
<li><strong>CP</strong>[支付宝]或者<strong>AP</strong>[超级跑跑系统维护]</li>
<li>在什么场合，可用性高于一致性？<ul>
<li>网页必须要保障<strong>可用性</strong>(一定能看到最重要 是不是最新的不重要)和<strong>分区容错</strong></li>
<li>支付的时候一定要保障<strong>一致性</strong>(我可以保证不可用 但我不允许余额不一致)和<strong>分区容错</strong></li>
</ul>
</li>
<li>合适的才是最好的</li>
</ul>
<h3 id="集群、分布式、微服务的区别"><a href="#集群、分布式、微服务的区别" class="headerlink" title="集群、分布式、微服务的区别"></a>集群、分布式、微服务的区别</h3><h5 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h5><ul>
<li>分布式：一个业务分拆<strong>多个子业务</strong>，部署在不同的服务器上 [服务器之间要通信]</li>
<li>集群：<strong>同一个</strong>业务，部署在多个服务器上 [五台机器可以不通信]</li>
</ul>
<h5 id="集群和微服务的区别"><a href="#集群和微服务的区别" class="headerlink" title="集群和微服务的区别"></a>集群和微服务的区别</h5><ul>
<li>集群：分散<strong>压力</strong></li>
<li>微服务：分散<strong>压力</strong></li>
</ul>
<h5 id="微服务和分布式的区别"><a href="#微服务和分布式的区别" class="headerlink" title="微服务和分布式的区别"></a>微服务和分布式的区别</h5><ul>
<li><p>微服务是<strong>架构设计</strong>方式 [逻辑架构]</p>
</li>
<li><p>分布式是<strong>系统部署</strong>方式 [物理架构]</p>
</li>
<li><p>微服务：是一种架构方式 [大的服务拆成小的服务 每个服务独立开发测试]</p>
</li>
<li><p>分布式：主要强调部署的方式</p>
</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>基本概念、用途、核心思想</li>
<li>Docker的组成、架构、重要概念</li>
<li>Docker的安装</li>
<li><strong>第一个Docker容器</strong></li>
<li>运用Nginx镜像，并访问到Docker容器内部 [从外部进行访问]</li>
<li>制作自己的Docker容器，<strong>dockerfile</strong>实战</li>
</ul>
<h3 id="Docker的基本概念、用途、核心思想"><a href="#Docker的基本概念、用途、核心思想" class="headerlink" title="Docker的基本概念、用途、核心思想"></a>Docker的基本概念、用途、核心思想</h3><ul>
<li>Docker应用广泛<br>京东618：15万个Docker实例，所有业务全部容器化</li>
<li>Docker是什么？<br>[以前的图标是大鲸鱼拖着集装箱]<ul>
<li>Docker是一个用来装程序及其环境的<strong>容器</strong>[类似于<u>安装包.exe</u>]，属于Linux容器的一种封装，提供简单易用的容器使用接口。它是目前<strong>最流行</strong>的Linux容器解决方案</li>
<li>比喻：客车可以装人，衣柜可以放衣服 [Windows下写的小游戏也可以放在Docker中]</li>
</ul>
</li>
</ul>
<h3 id="为什么需要Docker"><a href="#为什么需要Docker" class="headerlink" title="为什么需要Docker"></a>为什么需要Docker</h3><ul>
<li><strong>环境配置</strong>的难题</li>
<li>虚拟机[资源占用很多 模拟一套完整系统但步骤多(有些步骤无法跳过) 启动慢]</li>
<li>Docker的基础——<strong>Linux容器</strong> [体积小 速度快 轻量级虚拟机]</li>
</ul>
<h3 id="Docker的用途"><a href="#Docker的用途" class="headerlink" title="Docker的用途"></a>Docker的用途</h3><ul>
<li>提供<strong>统一</strong>的环境</li>
<li>提供<strong>快速拓展</strong>、弹性伸缩的云服务 [解决双十一淘宝+天猫 数据量剧增问题]</li>
<li>防止其他用户的进程把服务器资源<strong>占用过多</strong> [程序相互之间可以隔离]</li>
<li>部署简单 运维简单 节省服务器资源</li>
</ul>
<h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><h5 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h5><ul>
<li><p><strong>运输方式</strong>(把程序和环境从一个机器运送到另一个机器)</p>
</li>
<li><p><strong>存储方式</strong>(程序和环境的存储)</p>
</li>
<li><p><strong>API接口</strong>(不需要Tomcat等应用的命令了，都标准化了)</p>
</li>
<li><p><strong>灵活</strong>：即使是最复杂的应用也可以集装箱化</p>
</li>
<li><p><strong>轻量级</strong>：容器利用并共享主机内核</p>
</li>
<li><p><strong>便携式</strong>：可以在本地构建，部署到云，并在任何地方运行</p>
</li>
</ul>
<h5 id="Docker带来的好处"><a href="#Docker带来的好处" class="headerlink" title="Docker带来的好处"></a>Docker带来的好处</h5><ul>
<li>开发团队的好处 完全可以控制所有的环境[同一个镜像] 降低了风险</li>
</ul>
<h3 id="image镜像"><a href="#image镜像" class="headerlink" title="image镜像"></a>image镜像</h3><ul>
<li>存储：联合文件系统，UnionFS</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/28665426b3b7f9351280ab4c58b1ea388391f211/data/image%E9%95%9C%E5%83%8F.jpg"></p>
<h3 id="容器和仓库"><a href="#容器和仓库" class="headerlink" title="容器和仓库"></a>容器和仓库</h3><ul>
<li><strong>镜像类似于Java中的类，而容器就是实例化</strong></li>
<li>容器的这一层是可以修改的，而镜像是不可以修改的</li>
<li>同一个镜像可以生成多个容器独立运行，而她们之间没有任何的干扰</li>
</ul>
<h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul>
<li><strong>hub.docker.com</strong></li>
<li><a target="_blank" rel="noopener" href="https://c.163yun.com/hub#/m/home/">https://c.163yun.com/hub#/m/home/</a></li>
<li>共有、私有</li>
</ul>
<h5 id="client和deamon"><a href="#client和deamon" class="headerlink" title="client和deamon"></a>client和deamon</h5><ul>
<li><strong>client</strong>[<strong>客户端</strong>]：提供給用户一个终端，用户输入Docker提供的命令来管理本地或远程的服务器</li>
<li><strong>deamon</strong>：<strong>服务端</strong>守护进程，接收Client发送的命令并执行相应的操作</li>
</ul>
<h3 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h3><ul>
<li><h6 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h6><a target="_blank" rel="noopener" href="https://www.docker.com/products/docker-desktop/">Docker Desktop: The #1 Containerization Tool for Developers | Docker</a></li>
</ul>
<h5 id="更换系统镜像"><a href="#更换系统镜像" class="headerlink" title="更换系统镜像"></a>更换系统镜像</h5><p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a> → 实例 → 更多 → 更换操作系统 → CentOS 7.6 64位</p>
<pre><code class="java">C:\Users\Pluminary&gt;ssh root@47.98.225.105
    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:THXnakQ0Se5ee+d7oHO0NYKBTW7mhEKc426m9+rQgnk.
Please contact your system administrator.
Add correct host key in C:\\Users\\Pluminary/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in C:\\Users\\Pluminary/.ssh/known_hosts:7
Host key for 47.98.225.105 has changed and you have requested strict checking.
Host key verification failed.
    
//使用命令或手动删除 C:\\Users\\Pluminary/.ssh/known_hosts 防火墙拦截了
vim C:\\Users\\Pluminary/.ssh/known_hosts

C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:Panchunyao123!

[root@iZbp1dssknxftmjczbtpndZ ~]# cat /etc/redhat-release
CentOS Linux release 7.6.1810 (Core)
//yum地址换成国内yum源
   //wget-O 这是大写的字母O 含义是放到指定目录下 替换本地文件为国内文件
[root@iZbp1dssknxftmjczbtpndZ ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
[root@iZbp1dssknxftmjczbtpndZ ~]# yum clean all
[root@iZbp1dssknxftmjczbtpndZ ~]# yum makecache //读取新的源

//较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。
[root@iZbp1dssknxftmjczbtpndZ ~]# yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
//如果yum报告未安装这些软件包，也没问题。
    //更新yum 先查看需要更新哪些
[root@iZbp1dssknxftmjczbtpndZ ~]# yum check-update
[root@iZbp1dssknxftmjczbtpndZ ~]# yum update
// 安装所需的软件包
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install -y yum-utils \
                  device-mapper-persistent-data \
                  lvm2
// 使用以下命令来设置稳定的存储库 sudo是用超级管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

// 查看docker版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list docker-ce --showduplicates | sort -r
// 安装指定的版本
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io
// Docker 是服务器----客户端架构
// 命令行运行docker命令的时候，需要本机有 Docker 服务。用下面的命令启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl start docker
// 安装完成后，运行下面的命令，验证是否安装成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# docker version 或者 docker info
</code></pre>
<h3 id="第一个Docker容器"><a href="#第一个Docker容器" class="headerlink" title="第一个Docker容器"></a>第一个Docker容器</h3><ul>
<li><span style = "color:red"><strong>下载镜像</strong></span></li>
<li><strong>docker pull [OPTIONS] NAME[:TAG]</strong></li>
<li><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong> 查看本机有没有任何镜像</li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
c1ec31eb5944: Pull complete
Digest: sha256:53641cd209a4fecfc68e21a99871ce8c6920b2e7502df0a20671c6fccc73a7c6
Status: Downloaded newer image for hello-world:latest
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              d2c94e258dcb        11 months ago       13.3kB
</code></pre>
<ul>
<li><span style = "color:red"><strong>运行镜像</strong></span></li>
<li><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello-world
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal. 

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre>
<h3 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h3><h5 id="运行Nginx镜像，并访问到Docker容器内部"><a href="#运行Nginx镜像，并访问到Docker容器内部" class="headerlink" title="运行Nginx镜像，并访问到Docker容器内部"></a>运行Nginx镜像，并访问到Docker容器内部</h5><ul>
<li><strong>前台、后台</strong></li>
</ul>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# docker images //查看一下程序镜像是否还在
[root@iZbp1dssknxftmjczbtpndZ ~]# docker pull hub.c.163.com/library/nginx:1.13.0
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hub.c.163.com/library/nginx:1.13.0
//上面的没反应是正常情况，再开一个cmd窗口


//第二个窗口：另一个cmd窗口 
C:\Users\Pluminary&gt;ssh root@47.98.225.105
root@47.98.225.105&#39;s password:
Last login: Sun Apr  7 16:30:40 2024 from 182.102.75.173

Welcome to Alibaba Cloud Elastic Compute Service !
//展示当前容器列表
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED              STATUS              PORTS               NAMES
298f7e19f6a8        hub.c.163.com/library/nginx:1.13.0   &quot;nginx -g &#39;daemon of…&quot;   About a minute ago   Up About a minute   80/tcp              kind_taussig
//这时回到第一个窗口 ctrl+c 关掉运行 这时去第二个窗口docker ps的时候已经没有了
// ↓↓↓↓↓↓ 要把Nginx在后台运行才可以解决上述问题 ↓↓↓↓↓↓
[root@iZbp1dssknxftmjczbtpndZ ~]# docekr run -d hub.c.163.com/library/nginx:1.13.0
f124fc9171824e508639768b800efba5c780385dc1d135ab0ff70d80d3d75510 //返回容器ID
//此时再去第二个窗口 docker ps就会看到 CONTAINER ID 有f124fc917182
//第一个窗口 查看容器内部的风景 -i让容器输入有效 t是給我们分配一个终端 bash是启动终端
[root@iZbp1dssknxftmjczbtpndZ ~]# docker exec -it f124 bash //让docker明白我们让哪个启动
root@f124fc917182:/#  //已经进入到容器内部
root@f124fc917182:/# pwd
/
root@f124fc917182:/# touch 1 //创建了一个1
root@f124fc917182:/# ls
1  bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@f124fc917182:/# which nginx
/usr/sbin/nginx
</code></pre>
<h3 id="Docker三种网络模式-网络会隔离-需要配置进行端口映射"><a href="#Docker三种网络模式-网络会隔离-需要配置进行端口映射" class="headerlink" title="Docker三种网络模式 [网络会隔离 需要配置进行端口映射]"></a>Docker三种网络模式 [网络会隔离 需要配置进行端口映射]</h3><ul>
<li><strong>Bridge</strong> 网卡网络独立的端口</li>
<li><strong>Host</strong> 同步宿主机的端口</li>
<li>None</li>
<li>端口映射技术</li>
</ul>
<h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><ul>
<li>访问Docker内的Nginx</li>
</ul>
<pre><code class="java">cmd窗口2
[root@iZbp1dssknxftmjczbtpndZ ~]# docker stop f12
f12
[root@iZbp1dssknxftmjczbtpndZ ~]# docker ps //目前没有容器在运行了
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
    //-p 本机的8080端口去映射内部的80端口 前面的是本机 后面的是容器内部的
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -p 8080:80 hub.c.163.com/library/nginx:1.13.0
3906129ced72b668581a58dc36595b08734b82e247e2927eb2a8da6fbe7508ae
//拔出端口的信息
[root@iZbp1dssknxftmjczbtpndZ ~]# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在网页上输入 http://47.98.225.105:8080/

Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.
For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.
Thank you for using nginx.

这个不是在宿主机启动的nginx 而是在容器中启动的【通过宿主机中转 并通过Bridge实现独立】
★★ 通过一台服务器上去布置多台Docker 而每台docker里面是独立的 并且可以通过一个端口 来实现和外界的映射关系 ★★
//这个与7行代码的区别 这里是大P 将这个容器的所有端口都进行映射
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run -d -P hub.c.163.com/library/nginx:1.13.0
</code></pre>
<h3 id="制作自己的Docker容器，dockerfile实战"><a href="#制作自己的Docker容器，dockerfile实战" class="headerlink" title="制作自己的Docker容器，dockerfile实战"></a>制作自己的Docker容器，dockerfile实战</h3><p>[把自己的软件程序打包好传給别人]</p>
<ul>
<li>dockerfile作用</li>
<li>使用dockerfile的好处[一目了然 哪个环境跑在什么环境下 非常方便知道如何配置]</li>
<li>写一个自己的dockerfile</li>
</ul>
<blockquote>
<p>因此我们只需要在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。</p>
</blockquote>
<pre><code class="sql">FROM alpine:latest #继承父类 alpine及其小的环境
MAINTAINER imooc   #描述这个镜像由誰维护的
CMD echo &#39;hello my dockerfile&#39;  #进入任何想要的dockerfile命令
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# touch Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Dockerfile
[root@iZbp1dssknxftmjczbtpndZ ~]# vim Dockerfile
//按小写i进入编辑模式  按ESC退出编辑模式 :wq会保存
//取名字 .dockerfile现在的路径
[root@iZbp1dssknxftmjczbtpndZ ~]# docker build -t hello_docker .
    //先发送到服务器
Sending build context to Docker daemon  285.7kB
    //从父类中拉取下来
Step 1/3 : FROM alpine:latest
latest: Pulling from library/alpine
4abcf2066143: Pull complete
Digest: sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b
Status: Downloaded newer image for alpine:latest
 ---&gt; 05455a08881e
    //写定它的维护者
Step 2/3 : MAINTAINER imooc
 ---&gt; Running in 38a73abca50e
Removing intermediate container 38a73abca50e
---&gt; f44831f49afe
    //把这个语句写进去
Step 3/3 : CMD echo &#39;hello my dockerfile&#39;
 ---&gt; Running in 1ff431539208
Removing intermediate container 1ff431539208
 ---&gt; f45b88d0cabc
Successfully built f45b88d0cabc
Successfully tagged hello_docker:latest

//运行自己的镜像
[root@iZbp1dssknxftmjczbtpndZ ~]# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello_docker                  latest              f45b88d0cabc        3 minutes ago       7.38MB
alpine                        latest              05455a08881e        2 months ago        7.38MB
hello-world                   latest              d2c94e258dcb        11 months ago       13.3kB
hub.c.163.com/library/nginx   1.13.0              46102226f2fd        6 years ago         109MB
[root@iZbp1dssknxftmjczbtpndZ ~]# docker run hello_docker
hello my dockerfile
</code></pre>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ul>
<li><h6 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h6></li>
<li><h6 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h6></li>
<li><h6 id="常用命令讲解和演示"><a href="#常用命令讲解和演示" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h6></li>
<li><h6 id="配置文件讲解"><a href="#配置文件讲解" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h6></li>
<li><h6 id="场景实战：搭建一个静态文件的Nginx服务"><a href="#场景实战：搭建一个静态文件的Nginx服务" class="headerlink" title="场景实战：搭建一个静态文件的Nginx服务"></a>场景实战：搭建一个静态文件的Nginx服务</h6></li>
</ul>
<h3 id="Nginx介绍-1"><a href="#Nginx介绍-1" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><ul>
<li>Nginx是什么、适用场景</li>
<li>Nginx应用广泛</li>
<li>Nginx优点</li>
</ul>
<h4 id="Nginx是什么、适用场景"><a href="#Nginx是什么、适用场景" class="headerlink" title="Nginx是什么、适用场景"></a>Nginx是什么、适用场景</h4><ul>
<li>HTTP的<strong>反向代理</strong>服务器</li>
<li><strong>动态静态</strong>资源分离</li>
</ul>
<h5 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><span style = "color:red">正向代理</span></h5><p>普通的请求转发，客户端把信息传递到代理服务器，代理服务器找到信息转发给我们<br>提供安全功能 代理服务器有防火墙，可以隐藏自身的信息 </p>
<h5 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><span style = "color:red">反向代理</span></h5><p>提供安全和防火墙 在多个服务器后端提供负载均衡 为服务器提供缓存 把来自用户的压力平均分配[负载均衡]</p>
<h5 id="动态静态资源分离-加速访问-整体速度提高"><a href="#动态静态资源分离-加速访问-整体速度提高" class="headerlink" title="动态静态资源分离 [加速访问 整体速度提高]"></a><span style = "color:red">动态静态资源分离</span> [加速访问 整体速度提高]</h5><ul>
<li>不分离会<strong>变慢</strong></li>
<li>静态资源<strong>无需经过Tomcat</strong>，Tomcat只负责处理动态请求</li>
<li>后缀为gif的时候，Nginx会<strong>直接</strong>获取到当前请求的文件并返回</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/93ef10f6db6a389181a9f20268c6c4b8b82c46d7/data/%E6%AD%A3%E5%90%91_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86_.jpg"></p>
<h3 id="Nginx应用广泛"><a href="#Nginx应用广泛" class="headerlink" title="Nginx应用广泛"></a>Nginx应用广泛</h3><h5 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h5><ul>
<li>高并发、高性能</li>
<li>可扩展性好</li>
<li>高可靠性 [服务器运行可以达到数年之久]</li>
<li>热部署</li>
<li>开源、可商用</li>
</ul>
<h3 id="Nginx的安装-1"><a href="#Nginx的安装-1" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h5 id="Nginx在CentOs安装"><a href="#Nginx在CentOs安装" class="headerlink" title="Nginx在CentOs安装"></a>Nginx在CentOs安装</h5><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# yum install yum-utils
[root@iZbp1dssknxftmjczbtpndZ ~]# vim /etc/yum.repos.d/nginx.repo  //输入源信息 告诉它从哪下载
//输入：3-18行 配置源
[root@iZbp1dssknxftmjczbtpndZ ~]# [nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
    //然后查看源 列出可以使用的ngix地址
[root@iZbp1dssknxftmjczbtpndZ ~]# yum list | grep nginx
    //运行安装命令
[root@iZbp1dssknxftmjczbtpndZ ~]# yum install nginx 1:1.16.1-1.el7.ngx
    //查看版本，若出现版本号，则安装成功
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -v
nginx version: nginx/1.24.0
用whereis nginx可以查看到目录：
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
</code></pre>
<h3 id="常用命令讲解和演示-1"><a href="#常用命令讲解和演示-1" class="headerlink" title="常用命令讲解和演示"></a>常用命令讲解和演示</h3><pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# /usr/sbin/ngix 启动
[root@iZbp1dssknxftmjczbtpndZ ~]# systemctl stop docker //把之前的docker关停
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -aux | grep nginx //提取相关进程 80是默认端口
[root@iZbp1dssknxftmjczbtpndZ ~]# nginx -h //提取帮助
    
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /etc/nginx
[root@iZbp1dssknxftmjczbtpndZ nginx]# ls //里面有nginx.conf配置文件 conf.d中也有一个defalut.conf
conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params
[root@iZbp1dssknxftmjczbtpndZ nginx]# cd conf.d/
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c   //读取指定配置文件
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop //停止nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //以这个文件启动nginx

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //发布前的测试
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -s stop
[root@iZbp1dssknxftmjczbtpndZ conf.d]# /usr/sbin/nginx //开启nginx
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -t //查看使用的哪个配置文件
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -v //打印版本信息
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -V //打印详细参数
    
[root@iZbp1dssknxftmjczbtpndZ conf.d]# whereis uginx//找nginx的路径
nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz
[root@iZbp1dssknxftmjczbtpndZ conf.d]# ps aux | grep nginx //打印进程信息

    //-s信号 1.stop立即停止 2.quit优雅停止 3.reload重启[优雅停止quit] 4.reopen更换日志文件
</code></pre>
<h3 id="配置文件讲解-1"><a href="#配置文件讲解-1" class="headerlink" title="配置文件讲解"></a>配置文件讲解</h3><ul>
<li><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul>
<li>“; “ 结尾</li>
<li>“{}” 组织多条指令 </li>
<li>“include” 引入</li>
<li>‘’#’’ 注释</li>
</ul>
</li>
<li><h5 id="实操演示"><a href="#实操演示" class="headerlink" title="实操演示"></a>实操演示</h5></li>
<li><h5 id="默认配置文件分析"><a href="#默认配置文件分析" class="headerlink" title="默认配置文件分析"></a>默认配置文件分析</h5><ul>
<li>nginx.conf</li>
<li>default.conf</li>
</ul>
</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ conf.d]# cat /etc/nginx/nginx.conf //打开文件配置
nginx.conf配置文件讲解
首先我们进入到cd etc/nginx.然后通过ls查看nginx目录的相关内容。在nginx目录下，我们需要关注nginx.conf文件，这个文件是我们的主配置文件，cat打开：
cat nginx.conf 【效果显示在下方分割线后】

[root@iZbp1dssknxftmjczbtpndZ conf.d]# cd /usr/share/nginx/html
[root@iZbp1dssknxftmjczbtpndZ html]# vim stst.html //新建文件
[root@iZbp1dssknxftmjczbtpndZ html]# ls
50x.html     index.html
[root@iZbp1dssknxftmjczbtpndZ html# vim test.html //新建一个html文件保存下来
//i编辑       hello nginx           esc + :wq
[root@iZbp1dssknxftmjczbtpndZ conf.d]# nginx -c /etc/nginx/nginx.conf //启动！
//如果不显示一定是服务器规则组的问题  自定义 TCP    目的:1/65535   源:0.0.0.0/0
网址输入：http://47.98.225.105/test.html 
============================================================================
# 运行用户，默认是nginx
user  nginx;
# nginx进程数,一般设置为和cpu核数一样
worker_processes  1;

# 全局错误日志路径
error_log  /var/log/nginx/error.log warn;
# 进程pid路径
pid        /var/run/nginx.pid;
 
events &#123;
# 最大连接数
    worker_connections  1024;
&#125;

# 设置http服务器
http &#123;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
# 设置日志的格式
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
# 访问日志的路径
    access_log  /var/log/nginx/access.log  main;

# 开启高效传输模式
    sendfile        on;
    #tcp_nopush     on;
# 长连接超时时间，单位是秒
    keepalive_timeout  65;
#传输时是否压缩，压缩的话需要解压，但是传的大小就小了
    #gzip  on;
#加载其他的配置文件，一带多
    include /etc/nginx/conf.d/*.conf;
&#125;
============================================================================
</code></pre>
<h3 id="搭建静态资源服务器"><a href="#搭建静态资源服务器" class="headerlink" title="搭建静态资源服务器"></a>搭建静态资源服务器</h3><h5 id="搭建一个静态文件的Nginx服务"><a href="#搭建一个静态文件的Nginx服务" class="headerlink" title="搭建一个静态文件的Nginx服务"></a>搭建一个静态文件的Nginx服务</h5><ul>
<li>实操演示</li>
<li>配置和网页文件作为教辅提供 [静态网页]</li>
</ul>
<pre><code class="java">//scp传输文件 -r每一个文件夹都传递归 /usr/share/nginx/web/ 上传到这个文件夹
cmd本机框
C:\Users\Pluminary&gt; scp -r /Users/Pluminary/Desktop/静态资源/静态网页/ root@47.98.225.105:/usr/share/nginx/web/

cmd服务器框
[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/share/nginx/web/
[root@iZbp1dssknxftmjczbtpndZ web]# pwd //查看现在位置
/usr/share/nginx/web
[root@iZbp1dssknxftmjczbtpndZ web]# ls
css  fonts  images  index.html  js
//修改文件 可以让nginx访问到文件 访问web下面的内容
[root@iZbp1dssknxftmjczbtpndZ web]# vim /etc/nginx/conf.d/default.conf  
//修改location：.../web
===============================================================
location / &#123;
        root   /usr/share/nginx/web;
        index  index.html index.htm;
    &#125;

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html &#123;
        root   /usr/share/nginx/web;
    &#125;
===============================================================
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -t //测试一下是否有问题
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@iZbp1dssknxftmjczbtpndZ web]# nginx -s reload //重启服务
//浏览器访问：http://47.98.225.105/index.html
[root@iZbp1dssknxftmjczbtpndZ web]# cat /etc/nginx/nginx.conf
//进去看到 access_log  /var/log/nginx/access.log  main; 打开它
[root@iZbp1dssknxftmjczbtpndZ web]# cat /var/log/nginx/access.log //打开日志文件
</code></pre>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><ul>
<li><h5 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h5></li>
<li><h5 id="RabbitMQ的安装和启动-Erlang语言"><a href="#RabbitMQ的安装和启动-Erlang语言" class="headerlink" title="RabbitMQ的安装和启动 [Erlang语言]"></a>RabbitMQ的安装和启动 [Erlang语言]</h5></li>
<li><h5 id="RabbitMQ管理后台"><a href="#RabbitMQ管理后台" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5></li>
<li><h5 id="实战案例演示"><a href="#实战案例演示" class="headerlink" title="实战案例演示"></a>实战案例演示</h5></li>
<li><h5 id="交换机工作模式-fanout、direct、topic、headers"><a href="#交换机工作模式-fanout、direct、topic、headers" class="headerlink" title="交换机工作模式 [fanout、direct、topic、headers]"></a>交换机工作模式 [fanout、direct、topic、headers]</h5></li>
<li><h5 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h5></li>
</ul>
<h3 id="初识RabbitMQ-1"><a href="#初识RabbitMQ-1" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h3><ul>
<li><p>核心思想：<strong>接收并转发消息</strong>。类似于<strong>邮局</strong></p>
</li>
<li><p><strong>producer</strong>：<u>信息生产者</u></p>
</li>
<li><p><strong>queue</strong>：<u>队列</u></p>
</li>
<li><p><strong>consumer</strong>：<u>会从queue中获取消息</u></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/ca2883b4e8981a89118a71e0e1590f837b4300de/data/RabbitMQ.jpg"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li>什么是消息队列</li>
<li><strong>MQ</strong>(Message Queue)</li>
</ul>
<h5 id="消息队列的性质"><a href="#消息队列的性质" class="headerlink" title="消息队列的性质"></a>消息队列的性质</h5><ul>
<li>业务无关 [不需要考虑上层业务模型]</li>
<li>FIFO [先进先出]</li>
<li>容灾 [对于消息队列可以持久化 断电后也可以保存数据后重新发送]</li>
<li>性能</li>
</ul>
<h5 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h5><ul>
<li>系统<strong>解耦</strong></li>
<li><strong>异步</strong>调用 [我告诉你要做 我可以不等你做完 我再返回 <u>相互不影响</u>]<br>[点外卖 用户发送外卖请求給中间件，随后MQ帮助分发后续流程(扣钱、召唤骑手 计算天气、时间等)]</li>
<li>流量<strong>削峰</strong> [MQ把请求先存在队列中 以合适的速度发送 化解压力]</li>
</ul>
<h3 id="RabbitMQ的特点和核心概念"><a href="#RabbitMQ的特点和核心概念" class="headerlink" title="RabbitMQ的特点和核心概念"></a>RabbitMQ的特点和核心概念</h3><ul>
<li>开源、跨语言</li>
<li>Erlang语言编写 [交换机、通信方面] [数据复制与转发性能好]</li>
<li>应用广泛</li>
<li>社区活跃、API丰富</li>
</ul>
<h5 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h5><ul>
<li>Advanced Message Queuing Protocol 高级消息队列协议</li>
</ul>
<h5 id="RabbitMQ核心概念"><a href="#RabbitMQ核心概念" class="headerlink" title="RabbitMQ核心概念"></a>RabbitMQ核心概念</h5><ul>
<li><strong>Server</strong>：服务</li>
<li><strong>connection</strong>：与Server建立连接</li>
<li><strong>channel</strong>：信道，几乎所有的操作都在信道上进行，客户端可以建立多个信道</li>
<li><strong>message</strong>：消息，由properties和body组成</li>
<li><strong>virtual host</strong>：虚拟主机，顶层隔离。同一个虚拟主机下，不能由重复的交换机和queue</li>
<li><strong>Exchange</strong>：交换机，接收生产者的信息的，然后根据指定的路由器把消息转发到所绑定的队列上</li>
<li><strong>binding</strong>：绑定交换机和队列</li>
<li><strong>routing key</strong>：路由键，路由规则，虚拟机可以用它来确定这个消息如何进行一个路由</li>
<li><strong>queue</strong>：队列，消费者只需要监听队列来消费消息，不需要关注消息来自于哪个Exchange</li>
<li>Exchange和Message Queue存在着绑定的关系，一个Exchange可以绑定多个消息队列</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/8fc65400c147b4cda128b49a11d646330a5860fc/data/RabiitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F.jpg"></p>
<h3 id="RabbitMQ的安装和启动"><a href="#RabbitMQ的安装和启动" class="headerlink" title="RabbitMQ的安装和启动"></a>RabbitMQ的安装和启动</h3><ul>
<li>安装<strong>Erlang</strong></li>
<li><strong>安装</strong>RabbitMQ</li>
<li><strong>启动</strong>RabbitMQ</li>
</ul>
<h5 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h5><ul>
<li>安装erlang-rpm包，该包经过RabbitMQ官方处理</li>
<li>使用Erlang Solutions源进行安装</li>
<li>使用EPEL(“Extra Packages for Enterprise Linux”)进行安装</li>
</ul>
<pre><code class="java">我们先准备两个安装包：//★★★★别看下面胡咧咧 直接教辅中有erlang和rabbitmq与教材相同★★★★
RabbitMQ： https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.13
Erlang：https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm

注意： 如果说你选的是最新的版本那么你就要选取对应支持的 erlang 的版本才行，具体看下面的连接
https://www.rabbitmq.com/which-erlang.html

这些都准备好之后我们使用 Xptf 软件把这个安装包传输到 linux 端对应文件下（自己建一个文件夹）即可。

安装
第一步：
我们第一步先要对 linux 端进行一个 erlang 的环境配置，所以我们要先解压 erlang 包。
    # rpm -Uvh erlang-solutions-2.0-1.noarch.rpm
    # yum install -y erlang
安装完成后，查看一下版本号，能查到说明就是安装好了
    # erl -v

第二步：
在安装一下
    # yum install -y socat

第三步：
接下来我们就需要进行 RabbitMQ 的安装了

    # rpm -Uvh rabbitmq-server-3.8.33-1.el8.noarch.rpm 
    # yum install rabbitmq-server -y

安装完之后我们来启动测试一下：

    # systemctl start rabbitmq-server
    # systemctl status rebbitmq-server

最后一步：
安装跑起来之后我们设置一下开机自启动

    # systemctl enable rabbitmq-server
    # systemctl stop rabbitmq-server   # 关闭开机自起
=========================================================
可以在这些目录中查找RabbitMQ的配置文件、启动脚本等。另外，RabbitMQ的启动脚本通常会被安装到/usr/sbin或/usr/bin目录下。你可以尝试使用以下命令来查找RabbitMQ的启动脚本位置：

find /usr/sbin /usr/bin -name &#39;rabbitmq*&#39;
=========================================================
</code></pre>
<pre><code class="java">[root@iZbp1dssknxftmjczbtpndZ ~]# cd /usr/sbin
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl start rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl status rabbitmq-server
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since Mon 2024-04-08 23:24:39 CST; 38min ago
 Main PID: 3570 (beam.smp)
===================================================================================
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl enable rabbitmq-server
[root@iZbp1dssknxftmjczbtpndZ sbin]# systemctl stop rabbitmq-server   # 关闭开机自起
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57828911/article/details/131777471?ops_request_misc=%7B%22request_id%22:%22171259388816800186514596%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171259388816800186514596&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-131777471-null-null.142%5Ev100%5Epc_search_result_base9&utm_term=linux%E5%8D%B8%E8%BD%BDrabbitmq&spm=1018.2226.3001.4187">Linux环境如何彻底卸载感干净RabbitMQ_linux卸载rabbitmq-CSDN博客</a></p>
<pre><code class="java">停止RabbitMQ
$rabbitmqctl stop

设置开机启动
$ systemctl enable rabbitmq-server 

启动RabbitMQ
$ systemctl start rabbitmq-server

看看端口有没有起来，查看状态

$ rabbitmqctl status 

要检查RabbitMQ服务器的状态，请运行：

systemctl status rabbitmq-server

开启web管理界面
rabbitmq-plugins enable rabbitmq_management
</code></pre>
<h3 id="RabbitMQ管理后台-1"><a href="#RabbitMQ管理后台-1" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h3><h5 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h5><ul>
<li>启动RabbitMQ：<code>systemctl start rabbitmq-server</code></li>
<li>查看状态：<code>rabbitmqctl status</code></li>
<li>启动管理台</li>
<li>配置admin用户</li>
</ul>
<pre><code class="mysql">[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@iZbp1dssknxftmjczbtpndZ:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@iZbp1dssknxftmjczbtpndZ...
Plugin configuration unchanged. ##添加账户
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl add_user admin password
Adding user &quot;admin&quot; ...            ##设置管理员
[root@iZbp1dssknxftmjczbtpndZ ~]# rabbitmqctl set_user_tags admin administrator
Setting tags for user &quot;admin&quot; to [administrator] ...
浏览器进入RabbitMQ管理后台 输入 http://47.98.225.105:15672/
</code></pre>
<h5 id="RabbitMQ管理后台-2"><a href="#RabbitMQ管理后台-2" class="headerlink" title="RabbitMQ管理后台"></a>RabbitMQ管理后台</h5><ul>
<li>浏览页面</li>
<li>添加用户</li>
<li>创建虚拟主机(Virtual Hosts) &#x3D;&gt; 都有各自的队列、交换机</li>
</ul>
<h3 id="第一个生产者"><a href="#第一个生产者" class="headerlink" title="第一个生产者"></a>第一个生产者</h3><h5 id="实战案例演示-1"><a href="#实战案例演示-1" class="headerlink" title="实战案例演示"></a>实战案例演示</h5><ul>
<li>新建项目</li>
<li>Hello World<br>P(生产者)→hello→C(消费者)</li>
<li>创建一个rabbitmq(Maven)新项目</li>
<li>rabbitmq支持多语言</li>
</ul>
<pre><code class="java">登录上RabbitMQ后台 上面Admin 右面Virtual Hosts 
点表里的 /  下面增加一个admin

pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;20&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;20&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
            &lt;version&gt;5.8.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
            &lt;version&gt;1.7.29&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">helloworld/send.java
package helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Hello World的发送类，连接到RabbitMQ服务端，然后发送一条消息后退出
 */
public class send &#123;
    //队列名字
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME,false,false,false,null);
        //发布消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">helloworld/Recv.java
package helloworld;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收消息，并打印，持续运行
 */
public class Recv &#123;
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws Exception &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        //接收消息并消费 2:是否确认收到(快递签收 自动消息确认) 3：消息收到后进行处理
        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            //收到信息后会执行的函数
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot; + message);
            &#125;
        &#125;);
    &#125;
&#125;
=======================================================
//由于是持续接收消息的 若将send.java中改为Hello World2 将会持续打印到控制台
开始接收消息
收到消息：Hello World!
收到消息：Hello World2!
</code></pre>
<h3 id="根据消息内容做处理"><a href="#根据消息内容做处理" class="headerlink" title="根据消息内容做处理"></a>根据消息内容做处理</h3><h5 id="多个消费者分担压力"><a href="#多个消费者分担压力" class="headerlink" title="多个消费者分担压力"></a>多个消费者分担压力</h5><p><strong>RabbitMQ后台</strong><a target="_blank" rel="noopener" href="http://47.98.225.105:15672/">http://47.98.225.105:15672/</a></p>
<h6 id="循环调度"><a href="#循环调度" class="headerlink" title="循环调度"></a>循环调度</h6><pre><code class="java">workqueues/NewTask.java
package workqueues;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 生产者：生产批量消息
 */
public class NewTask &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME,true,false,false,null);
        for (int i = 0; i &lt; 10; i++) &#123;
            String message = i + &quot;...&quot;;
            channel.basicPublish(&quot;&quot;,TAKS_QUEUE_NAME,null,message.getBytes(&quot;UTF-8&quot;));
            System.out.println(&quot;发送了消息：&quot; + message);
        &#125;
        //关闭连接
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================================
发送了消息：0...
发送了消息：1...
发送了消息：2...
发送了消息：3...
发送了消息：4...
发送了消息：5...
发送了消息：6...
发送了消息：7...
发送了消息：8...
发送了消息：9...
</code></pre>
<pre><code class="java">workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicConsume(TAKS_QUEUE_NAME, true, new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==========================================================================================
收到了消息：0...
完成消息处理
收到了消息：1...
完成消息处理
收到了消息：2...
完成消息处理
收到了消息：3...
完成消息处理
收到了消息：4...
完成消息处理
收到了消息：5...
完成消息处理
收到了消息：6...
完成消息处理
收到了消息：7...
完成消息处理
收到了消息：8...
完成消息处理
收到了消息：9...
完成消息处理
</code></pre>
<h5 id="并行-多个消费者平均压力！！！"><a href="#并行-多个消费者平均压力！！！" class="headerlink" title="并行 多个消费者平均压力！！！"></a>并行 多个消费者平均压力！！！</h5><h6 id="公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】"><a href="#公平派遣-因为奇数偶数压力不同-消息确认-【以工作量的程度去分任务】" class="headerlink" title="公平派遣[因为奇数偶数压力不同] + 消息确认 【以工作量的程度去分任务】"></a>公平派遣[因为奇数偶数压力不同] + 消息确认 【<u>以工作量的程度去分任务</u>】</h6><pre><code class="java">//在Worker消费方打开并行消费 Run/Debug Configurations → Modify options蓝字 → Allow multiple instances             此时两个woker开始配合平均压力 一起工作
workqueues/Worker.java
package workqueues;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 消费者，接收前面的批量消息
 */
public class Worker &#123;
    private final static String TAKS_QUEUE_NAME = &quot;task_queue&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        //创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置RabbitMQ地址
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        //建立连接
        Connection connection = factory.newConnection();
        //获得信道
        Channel channel = connection.createChannel();
        //声明队列 参数：第二个会不会随着重启消失 第三个队列是否仅能給连接使用 第四个未使用自动删除？ 第五个参数
        channel.queueDeclare(TAKS_QUEUE_NAME, true, false, false, null);
        System.out.println(&quot;开始接收消息&quot;);
        channel.basicQos(1); //最希望处理的数量 处理完之前不会接收下一个任务
        channel.basicConsume(TAKS_QUEUE_NAME, false, new DefaultConsumer(channel) &#123; //关掉自动接收 要手动确认false
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到了消息：&quot; + message);
                try&#123;
                    doWork(message);
                &#125;finally &#123;
                    System.out.println(&quot;完成消息处理&quot;);
                    channel.basicAck(envelope.getDeliveryTag(), false); //false 不同时一起确认 手动确认消息
                &#125;
            &#125;
        &#125;);
    &#125;

    private static void doWork(String task) &#123;
        //有点延迟1秒
        char[] chars = task.toCharArray();
        for (char ch : chars) &#123;
            if (ch == &#39;.&#39;) &#123;
                try &#123;
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
=======================================================================================
开始接收消息
收到了消息：1
消息处理完成
收到了消息：2...
消息处理完成
......
</code></pre>
<h3 id="交换机工作模式"><a href="#交换机工作模式" class="headerlink" title="交换机工作模式"></a>交换机工作模式</h3><ul>
<li><strong>fanout</strong>：广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的</li>
<li><strong>direct</strong>：根据RoutingKey匹配消息路由到指定队列</li>
<li><strong>topic</strong>：生产者指定RoutingKey消息根据消费端指定的队列通过模糊匹配的方式进行相应转发</li>
<li><strong>headers</strong>：根据发送消息内容中的headers属性来匹配</li>
</ul>
<h5 id="fanout模式"><a href="#fanout模式" class="headerlink" title="fanout模式"></a>fanout模式</h5><h6 id="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送"><a href="#广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的-所有消息无差别发送" class="headerlink" title="广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]"></a>广播，这种模式只需要将队列绑定到交换机上即可，是不需要设置路由键的 [所有消息无差别发送]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3aa53b6e78e1fd67145c5d2acf905c22eee0b44a/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-fanout.png"></p>
<pre><code class="java">fanout/EmitLog.java【生产者】
package fanout;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 发送日志信息
 */
public class EmitLog &#123;
    //创建交换机
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        String message = &quot;info: Hello World！&quot;;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<pre><code class="java">fanout/ReceiveLogs.java【消费者】
package fanout;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * 描述：接收日志消息 有多个接收同样的消息
 */
public class ReceiveLogs &#123;
    private static final String EXCHANGE_NAME = &quot;logs&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
        //非持久会自动删除的队列 在同一个类中多次启动 每一次队列名字都不一样
        String queueName = channel.queueDeclare().getQueue();
        //交换机和队列的绑定
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;开始接收消息&quot;);
        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
</code></pre>
<h5 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h5><h6 id="根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致"><a href="#根据RoutingKey匹配消息路由到指定队列-消费者接收消息不一致" class="headerlink" title="根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]"></a>根据RoutingKey匹配消息路由到指定队列 [消费者接收消息不一致]</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/df64342f867398846ad29a0cb944a8490cd247b0/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-direct.jpg"></p>
<pre><code class="java">direct/ReceiveLogsDirect1.java
package direct;

import com.rabbitmq.client.*;

import java.io.IOException;

/**
 * 接收3个等级的日志
 */
public class ReceiveLogsDirect1 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定三个queue
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);

        System.out.println(&quot; 开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/ReceiveLogsDirect2.java
package direct;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;
import java.io.IOException;

/**
 * 接收1个等级的日志
 */
public class ReceiveLogsDirect2 &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        //生成一个随机的临时的queue
        String queueName = channel.queueDeclare().getQueue();

        //一个交换机同时绑定两个queue，比刚第一个Receiver少接收了一个error等级
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer =  new DefaultConsumer(channel)&#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot;收到消息：&quot;+message);
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
=============================================================================
收到消息：Hello World！
收到消息：Hello World！
收到消息：Hello World！
</code></pre>
<pre><code class="java">direct/EmitLogDirect.java
package direct;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class EmitLogDirect &#123;

    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
        //声明交换机 DIRECT
        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);
        String message = &quot;Hello World！&quot;;
        //发送第一个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;info&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为info,消息内容：&quot; + message);

        //发送第二个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;warning&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为warning,消息内容：&quot; + message);

        //发送第三个等级消息
        channel.basicPublish(EXCHANGE_NAME, &quot;error&quot;,null, message.getBytes(&quot;UTF-8&quot;));
        System.out.println(&quot;发送了消息：&quot; + &quot;等级为error,消息内容：&quot; + message);
        channel.close();
        connection.close();
    &#125;
&#125;
=============================================================================
发送了消息：等级为info,消息内容：Hello World！
发送了消息：等级为warning,消息内容：Hello World！
发送了消息：等级为error,消息内容：Hello World！
</code></pre>
<h5 id="topic模式"><a href="#topic模式" class="headerlink" title="topic模式"></a><span style = "color:red"><strong>topic模式</strong></span></h5><h6 id="比如消息严重性怎么样、只想记录error模块的用户信息"><a href="#比如消息严重性怎么样、只想记录error模块的用户信息" class="headerlink" title="比如消息严重性怎么样、只想记录error模块的用户信息"></a>比如消息严重性怎么样、只想记录error模块的用户信息</h6><ul>
<li>***** 可以替代一个单词</li>
<li><strong>#</strong> 可以替代零个或多个单词</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/76b7e6d6ebbac01f8f73850149fefbf50ca51712/data/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-topic%E7%94%9F%E4%BA%A7%E8%80%85.jpg"></p>
<pre><code class="java">【发送者/生产者】
topic/EmitLogTopic.java
package topic;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

/**
 * topic模式交换机，发送消息
 */
public class EmitLogTopic &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) &#123;
        Connection connection = null;
        Channel channel = null;
        try &#123;
            ConnectionFactory factory = new ConnectionFactory();
            factory.setHost(&quot;47.98.225.105&quot;);
            factory.setUsername(&quot;admin&quot;);
            factory.setPassword(&quot;password&quot;);

            connection = factory.newConnection();
            channel = connection.createChannel();

            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);

            String message = &quot;Animal WorldroutingKey&quot;;

            String[] routingKeys = new String[9];
            routingKeys[0] = &quot;quick.orange.rabbit&quot;;
            routingKeys[1] = &quot;lazy.orange.elephant&quot;;
            routingKeys[2] = &quot;quick.orange.fox&quot;;
            routingKeys[3] = &quot;lazy.brown.fox&quot;;
            routingKeys[4] = &quot;lazy.pink.rabbit&quot;;
            routingKeys[5] = &quot;quick.brown.fox&quot;;
            routingKeys[6] = &quot;orange&quot;;
            routingKeys[7] = &quot;quick.orange.male.rabbit&quot;;
            routingKeys[8] = &quot;lazy.orange.male.rabbit&quot;;
            for (int i = 0; i &lt; routingKeys.length; i++) &#123;
                channel.basicPublish(EXCHANGE_NAME, routingKeys[i], null,
                        message.getBytes(&quot;UTF-8&quot;));
                System.out.println(&quot;发送了：&quot; + message + &quot;:&quot; + routingKeys[i]);
            &#125;


        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if (connection != null) &#123;
                try &#123;
                    connection.close();
                &#125; catch (Exception ignore) &#123;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
==================================================================================
发送了：Animal WorldroutingKey:quick.orange.rabbit
发送了：Animal WorldroutingKey:lazy.orange.elephant
发送了：Animal WorldroutingKey:quick.orange.fox
发送了：Animal WorldroutingKey:lazy.brown.fox
发送了：Animal WorldroutingKey:lazy.pink.rabbit
发送了：Animal WorldroutingKey:quick.brown.fox
发送了：Animal WorldroutingKey:orange
发送了：Animal WorldroutingKey:quick.orange.male.rabbit
发送了：Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<pre><code class="java">【接收者/消费者Ⅰ(对&quot;*.orange.*&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.*;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic1 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey 最重要的一步！
        String bindingKey = &quot;*.orange.*&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:quick.orange.fox
</code></pre>
<pre><code class="java">【接收者/消费者Ⅱ(对&quot;*.*.rabbit&quot; 和 &quot;lazy.#&quot; 数据感兴趣)】
package topic;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
import com.rabbitmq.client.Envelope;

import java.io.IOException;
/**
 * 特定路由键
 */
public class ReceiveLogsTopic2 &#123;

    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;

    public static void main(String[] argv) throws Exception &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;47.98.225.105&quot;);
        factory.setUsername(&quot;admin&quot;);
        factory.setPassword(&quot;password&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
        String queueName = channel.queueDeclare().getQueue();

        //指定bindingKey
        String bindingKey1 = &quot;*.*.rabbit&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey1);
        String bindingKey2 = &quot;lazy.#&quot;;
        channel.queueBind(queueName, EXCHANGE_NAME, bindingKey2);

        System.out.println(&quot;开始接收消息&quot;);

        Consumer consumer = new DefaultConsumer(channel) &#123;
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                    AMQP.BasicProperties properties, byte[] body) throws IOException &#123;
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(
                        &quot; 接收消息： &quot; + message + &quot;:&quot; + envelope.getRoutingKey());
            &#125;
        &#125;;
        channel.basicConsume(queueName, true, consumer);
    &#125;
&#125;
==================================================================================
开始接收消息
 接收消息： Animal WorldroutingKey:quick.orange.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.elephant
 接收消息： Animal WorldroutingKey:lazy.brown.fox
 接收消息： Animal WorldroutingKey:lazy.pink.rabbit
 接收消息： Animal WorldroutingKey:lazy.orange.male.rabbit
</code></pre>
<ul>
<li><h6 id="headers：根据发送消息内容中的headers属性来匹配"><a href="#headers：根据发送消息内容中的headers属性来匹配" class="headerlink" title="headers：根据发送消息内容中的headers属性来匹配"></a>headers：根据发送消息内容中的headers属性来匹配</h6></li>
</ul>
<h3 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h3><ul>
<li><h6 id="实操代码演示"><a href="#实操代码演示" class="headerlink" title="实操代码演示"></a>实操代码演示</h6></li>
</ul>
<blockquote>
<p>创建两个Springboot项目<br>spring-boot-rabbitmq-consumer 和 spring-boot-rabbitmq-consumer<br>在application.properties中设置 如果是本机用户名和密码都是guest<br>spring.rabbitmq.username&#x3D;guest</p>
</blockquote>
<h6 id="项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者"><a href="#项目：spring-boot-rabbitmq-producer-消息发送者-x2F-生产者" class="headerlink" title="项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]"></a>项目：spring-boot-rabbitmq-producer [消息发送者&#x2F;生产者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-producer
server.port=8080
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/MsgSender.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * 发送消息
 */
//@Component让springboot发现
@Component
public class MsgSender &#123;
    @Autowired
    private AmqpTemplate rabbitmqTemplate;
    public void send1()&#123;
        String message = &quot;This is message 1, routing key is dog.red&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.red&quot;,message);
    &#125;
    public void send2()&#123;
        String message = &quot;This is message 2, routing key is dog.black&quot;;
        System.out.println(&quot;发送了：&quot; + message);
        //指定交换机的名字  routing key is dog.red  消息内容
        this.rabbitmqTemplate.convertAndSend(&quot;bootExchange&quot;,&quot;dog.black&quot;,message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootrabbitmqproducer/TopicRabbitConfig.java
package com.imooc.springbootrabbitmqproducer;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.core.TopicExchange;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


/**
 * rabbitmq配置类
 */
@Configuration
public class TopicRabbitConfig &#123;
    @Bean
    public Queue queue1()&#123;
        return new Queue(&quot;queue1&quot;);
    &#125;
    @Bean
    public Queue queue2()&#123;
        return new Queue(&quot;queue2&quot;);
    &#125;
    //用一个Bean定义交换机
    @Bean
    TopicExchange exchange()&#123;
        return new TopicExchange(&quot;bootExchange&quot;);
    &#125;

    //有了Q1 Q2后去指定一个topic交换机
    //绑定到交换机上
    @Bean
    Binding bingdingExchangeMessage1(Queue queue1, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue1()).to(exchange).with(&quot;dog.red&quot;);
    &#125;
    @Bean
    Binding bingdingExchangeMessage2(Queue queue2, TopicExchange exchange)&#123;
        //to绑定到哪个交换机 with指定routingKey
        return BindingBuilder.bind(queue2()).to(exchange).with(&quot;dog.#&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">用test的测试类
com/imooc/springbootrabbitmqproducer/SpringBootRabbitmqProducerApplicationTests.java
package com.imooc.springbootrabbitmqproducer;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootRabbitmqProducerApplicationTests &#123;

    @Autowired
    MsgSender msgSender;

    @Test
    public void send1()&#123;
        msgSender.send1();
    &#125;
    @Test
    public void send2()&#123;
        msgSender.send2();
    &#125;
&#125;
</code></pre>
<h6 id="项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者"><a href="#项目：spring-boot-rabbitmq-consumer-消息接收者-x2F-消费者" class="headerlink" title="项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]"></a>项目：spring-boot-rabbitmq-consumer [消息接收者&#x2F;消费者]</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-rabbitmq-consumer&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;spring-boot-rabbitmq-consumer&lt;/name&gt;
    &lt;description&gt;spring-boot-rabbitmq-consumer&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="mysql">application.properties
spring.application.name=spring-boot-rabbitmq-consumer
server.port=8081
spring.rabbitmq.addresses=127.0.0.1:15672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000
</code></pre>
<pre><code class="java">Receiver1.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者1
 */
@Component
@RabbitListener(queues = &quot;queue1&quot;)
public class Receiver1 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver1：&quot; + message);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Receiver2.java
package com.imooc.springbootrabbitmqconsumer;

import org.springframework.amqp.rabbit.annotation.RabbitHandler;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

/**
 * 消费者2
 */
@Component
@RabbitListener(queues = &quot;queue2&quot;)
public class Receiver2 &#123;
    @RabbitHandler //收到这个消息后怎么处理
    public void process(String message)&#123;
        System.out.println(&quot;Receiver2：&quot; + message);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>先启动消费者 然后再启动生产者test中的测试<br>就可以发现<br>send1() → 发送了：This is message 1, routing key is dog.red<br>send2() → 发送了：This is message 2, routing key is dog.black</p>
</blockquote>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/04/04/后端/多线程与分布式/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/03/28/面试/Java面试/">
        <h2>
            Java面试
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/3/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Java面试-——-准备"><a href="#Java面试-——-准备" class="headerlink" title="Java面试 —— 准备"></a>Java面试 —— 准备</h1><h3 id="給职场新人的建议"><a href="#給职场新人的建议" class="headerlink" title="給职场新人的建议"></a>給职场新人的建议</h3><ul>
<li>不要有为老板工作的心态</li>
<li>永远不要敷衍工作</li>
<li>事情做完马上汇报</li>
<li>管理好自己的情绪，做一个可爱的人</li>
<li>接受任务有确认机制</li>
<li>注意工作汇报方式</li>
<li>注重细节</li>
<li>提建议要有数据支撑</li>
<li>給主管选择题 而不是判断题 </li>
<li>要提升自己的价值 [人脉网]</li>
<li>认真对待工作汇报3</li>
</ul>
<h3 id="介绍面试环节中常见问题"><a href="#介绍面试环节中常见问题" class="headerlink" title="介绍面试环节中常见问题"></a>介绍面试环节中常见问题</h3><h5 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h5><ul>
<li><h6 id="我是誰"><a href="#我是誰" class="headerlink" title="我是誰"></a>我是誰</h6></li>
<li><h6 id="我做过什么"><a href="#我做过什么" class="headerlink" title="我做过什么"></a>我做过什么</h6></li>
<li><h6 id="我的优势在哪里"><a href="#我的优势在哪里" class="headerlink" title="我的优势在哪里"></a>我的优势在哪里</h6></li>
</ul>
<blockquote>
<p>张总你好，我叫潘春尧，<strong>今年23岁</strong>，来自河北唐山人，来<strong>应聘贵公司的Java软件工程师职位</strong>，26年毕业于南昌工学院<strong>软件工程专业</strong>，从事Java开发有2年的工作时间了，我<strong>对编程有着浓厚的兴趣</strong>，擅长基于HTML5的互联网应用开发，擅长使用Mysql数据库对大数据量方面的调优有经验，同时具备完整的项目开发能力，具备一定的分布式架构经验，之前<strong>我做过两个项目</strong>，都是独立完成的，<strong>第一个</strong>是XX 在2024年开发，这是一个电商网站，已经运用了一年的时间，我负责底层的架构搭建与前后端开发，技术方面采用了XXXX。架构方面底层使用了XXX，我负责的模块设计XXX，这些都是由我完整开发的，而<strong>第二个</strong>项目是由我开发的xxx，这是一个xxx平台，基于阿里云搭建，技术方面与上一个相似，工作原因产品需要增加XXX，我负责的网站模块主要负责xxx，这也是由我负责开发的，以上是我的个人介绍，有不足的请您多保函。</p>
</blockquote>
<h5 id="现场面对面-要面试官知道我有闪光的价值"><a href="#现场面对面-要面试官知道我有闪光的价值" class="headerlink" title="现场面对面  [要面试官知道我有闪光的价值]"></a>现场面对面  [要面试官知道我有闪光的价值]</h5><ul>
<li><strong>容貌要求</strong> [注意形象(<u>刮胡子,短发,指甲</u>)]</li>
<li><strong>着装要求</strong> [品牌+面料+皮鞋(商务休闲)]</li>
<li><strong>面试礼仪</strong> [提前15分钟到达面试场地填写表格、敬语(您好,感谢,再见)、善意的微笑] [和前台了解面试官的称呼和职位 主动握手 张总… ] [跟着面试官进去后 注意关门  进去前注意敲门] [沟通时眼神不要游离] [提交简历调转180°双手呈递] [不要抖腿翘腿] [手放腿上 十指交叉放桌子上 不许靠着椅子靠背]</li>
<li><strong>一对多面试</strong> [一男一女   <strong>男:</strong> 技术主管[考察技术能力]  <strong>女:</strong> HR[根据动作分析本人能力]] [面试紧张的时候要降低语速]</li>
</ul>
<h5 id="面试必知必会"><a href="#面试必知必会" class="headerlink" title="面试必知必会"></a>面试必知必会</h5><ul>
<li><h6 id="谈谈你的职业规划-对未来职业有清晰的规划"><a href="#谈谈你的职业规划-对未来职业有清晰的规划" class="headerlink" title="谈谈你的职业规划 [对未来职业有清晰的规划]"></a>谈谈你的职业规划 [对未来职业有清晰的规划]</h6></li>
</ul>
<blockquote>
<p>我从小对软件技术有着很浓厚的兴趣，在未来我五年内我希望从事于与技术相关的岗位，我给自己定位了一个小目标，在五年的时间内我希望拿下系统架构师的认证，同时在分布式、微服务的领域有自己独道的见识。希望在未来的一段时间里公司能给我提供成长的机会。</p>
</blockquote>
<ul>
<li><h6 id="与同时遇到正面冲突，你会怎么办"><a href="#与同时遇到正面冲突，你会怎么办" class="headerlink" title="与同时遇到正面冲突，你会怎么办"></a>与同时遇到正面冲突，你会怎么办</h6></li>
</ul>
<blockquote>
<p>[不诋毁任何人 不传达任何负面情绪 以大局为重]<br>我很少与别人产生正面的冲突，面对别人对我个人的职责批评，我通常先会反思我是不是真的做错了，如果是我会虚心接受，尽快改正。如果是别人对我无端的诽谤，在公共场合也会保持沉默，我会在私下跟他心平气和的沟通看看之间是不是有什么误会。如果是在工作中就某些问题产生了分歧。在会议时直接打开天窗说亮话，阐述自己的观点，这种是典型的对事不对人，这也是点到为止，如果双方意见僵持不下，这可能需要项目经理在中间做出定夺，他看到的问题可能比我们的更加全面而且更有建设性，总之我处事的原则是对事不对人，做事必须认真，做人还是要谦虚一些</p>
</blockquote>
<ul>
<li><h6 id="你生活中最重要的是什么"><a href="#你生活中最重要的是什么" class="headerlink" title="你生活中最重要的是什么"></a>你生活中最重要的是什么</h6></li>
</ul>
<blockquote>
<p>[考察你对待工作 生活 家庭是什么态度] [<strong>强调以事业为重</strong>]<br>我一个人来到XX打拼，目前是单身，对于我现在而言，事业就是我的全部，我会珍惜每一天，让自己尽快的成长起来</p>
</blockquote>
<ul>
<li><h6 id="这份工作你能遇见哪些问题"><a href="#这份工作你能遇见哪些问题" class="headerlink" title="这份工作你能遇见哪些问题"></a>这份工作你能遇见哪些问题</h6></li>
</ul>
<blockquote>
<p>[不能太过实在 避重就轻 强调自己的特性]<br>我对咱们公司的业务不太了解，经验很少，进入公司以后我会听取领导的指示和要求，尽快的熟悉公司的业务和技能，并且制定一份近期的工作计划并报告給领导批准，最后按照计划展开工作，其实针对这个问题，明眼人都看得出来，都说了一堆套话，废话，但是对于面试官来说，你正面的回答了这些问题。而这些问题肯定是现实中存在的，这样既无伤大雅又巧妙的表达了自己对这份工作的期望</p>
</blockquote>
<ul>
<li><h6 id="你希望与什么样的同事或上级公事"><a href="#你希望与什么样的同事或上级公事" class="headerlink" title="你希望与什么样的同事或上级公事"></a>你希望与什么样的同事或上级公事</h6></li>
</ul>
<blockquote>
<p>[考察情商]<br>作为刚步入社会的新人，我应该要求自己多熟悉工作环境适应环境，而不是对环境提出要求，对于我的工作只要能发挥我的专长就可以了，如果工作中有做的不对的地方还请领导多批评指正</p>
</blockquote>
<ul>
<li><h6 id="你将如何开展工作"><a href="#你将如何开展工作" class="headerlink" title="你将如何开展工作"></a>你将如何开展工作</h6></li>
</ul>
<blockquote>
<p>[面试通过几率已经很大了]<br>每天我会提高工作效率，完成公司交付的工作任务，任务未完成绝不下班，根据领导的指示和工作安排制定好工作计划，提前预备并按照计划完成，多请示领导及时汇报，如果有遇到不明白的地方要向前辈们请教，抓住缝隙时间多学习多提升，尽快的提高自己的专业能力与业务水平</p>
</blockquote>
<ul>
<li><h6 id="你有想过创业吗"><a href="#你有想过创业吗" class="headerlink" title="你有想过创业吗"></a>你有想过创业吗</h6></li>
</ul>
<blockquote>
<p>[面试官喜欢有冲劲的小伙子 给出明确的时间规划 不要说我是来公司学习的]<br>我当然有想过创业，但我觉得不是现在，我计划在30岁前后选择创业，软件行业需要大量的技术积累才能有竞争力，同时呢创业对我来说也需要很多的资金，我是一名刚走出校园的新人，在这两方面都不成熟，所以在未来的5年时间内，我会努力的工作，在经验和资金方面做好准备，同时之所以来贵公司，是因为贵公司在XXX行业是一个知名的企业，我想在为公司创造价值的同时，也能进一步的掌握咱们行业最新的动向，希望您能给我一次证明自己的机会，我肯定不会让公司失望的。</p>
</blockquote>
<ul>
<li><h6 id="你还应聘了哪些公司"><a href="#你还应聘了哪些公司" class="headerlink" title="你还应聘了哪些公司"></a>你还应聘了哪些公司</h6></li>
</ul>
<blockquote>
<p>[千万不能说海投 也不能说hr打了电话才来 最好不要跨行业]<br>做一些准备了</p>
</blockquote>
<ul>
<li><h6 id="为什么你的学历是专科"><a href="#为什么你的学历是专科" class="headerlink" title="为什么你的学历是专科"></a>为什么你的学历是专科</h6></li>
</ul>
<blockquote>
<p>[很难回答 送命题 学历非常重要的 话术把劣势转换优势]<br>实话实说上高中的时候我并不是一个好学生，在那时候爱玩电脑，确实也耽误了不少学业。但我认为学历的高低并不代表能力的好坏，在我上了专科以后我更加意识到因为学历比别人落后，自己就更需要努力了，从小对编程感兴趣，上了大学后就更有时间朝着自己喜欢的领域努力。在大学几年的时间里面我没有醉生梦死，自己呢也连续学习了XXX技术内容，我知道有朝一日，这些知识一定能给我带来用处，我一定能成为所向往的软件工程师，我能用实际行动来证明专科不比本科差</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对加班的看法"><a href="#谈谈你对加班的看法" class="headerlink" title="谈谈你对加班的看法"></a>谈谈你对加班的看法</h6></li>
</ul>
<blockquote>
<p>[测试你是否能为公司奉献 要强调上班提高效率 强调加班并不是我的工作效率低下]<br>上班时间我会提高效率，做到当日事当日毕，但是如果当天的事没有按时完成，我会义不容辞的加班，现在我是单身，没有家庭的负担，可以全身心的工作</p>
</blockquote>
<ul>
<li><h6 id="你的薪资的要求"><a href="#你的薪资的要求" class="headerlink" title="你的薪资的要求"></a>你的薪资的要求</h6></li>
</ul>
<blockquote>
<p>[提前有明确主张 自己能赚多少钱 给出hr谈薪资的余地期待8k 可以报价8.5k 千万不要说区间6-8k]<br>我期望的薪资是8.5k，每一个公司都有自己的薪资结构，咱们公司是xxx行业中是非常有实力的企业，相对于薪资来说我更看重技术和行业本身，如果您觉得薪资水平超出了公司的预期的话，这个咱们可以谈</p>
</blockquote>
<ul>
<li><h6 id="谈谈你对跳槽的看法"><a href="#谈谈你对跳槽的看法" class="headerlink" title="谈谈你对跳槽的看法"></a>谈谈你对跳槽的看法</h6></li>
</ul>
<blockquote>
<p>[千万不要说负面话语 也不能说工资太低、福利太差、没有晋升空间]<br>我这个人稳定性很好，本身反对频繁跳槽，但是有一种情况我会选择跳槽，就是公司的发展对于我的事业规划不符，我之前在进入xxx公司的时候，公司主要从事金融行业的项目开发，后来该行业金融不理想改作了电信行业了，当我的长期规划是想成为长期的金融软件工程师与架构师，如果遇到这种情况我会好不容易的选择离开。</p>
</blockquote>
<h1 id="Java面试——Java基础面试技巧"><a href="#Java面试——Java基础面试技巧" class="headerlink" title="Java面试——Java基础面试技巧"></a>Java面试——Java基础面试技巧</h1><h3 id="JDK、JRE、JVM有什么区别"><a href="#JDK、JRE、JVM有什么区别" class="headerlink" title="JDK、JRE、JVM有什么区别"></a>JDK、JRE、JVM有什么区别</h3><ul>
<li><strong>JDK：</strong>Java Development Kit 针对Java程序员的产品</li>
<li><strong>JRE：</strong>Java Runtime Environment是运行Java的环境集合</li>
<li><strong>JVM</strong>：Java虚拟机用于运行Java字节码文件[class]，跨平台的核心。通过JVM隐藏了操作系统最底层的API，对于我们java工程师只需要面对jvm层面进行开发，再转移到其他就可以了</li>
</ul>
<h5 id="为什么可以跨平台？"><a href="#为什么可以跨平台？" class="headerlink" title="为什么可以跨平台？"></a>为什么可以跨平台？</h5><p>因为JVM可以跨平台，JVM只认识<strong>字节码</strong>，能够解释到系统的API调用，对于不同的系统有不同的JVM实现。Windows和Linux有不同的JVM实现，但是编成字节码后都是一样的。</p>
<h3 id="常用数字类型的区别"><a href="#常用数字类型的区别" class="headerlink" title="常用数字类型的区别"></a>常用数字类型的区别</h3><table>
<thead>
<tr>
<th align="center">名次</th>
<th align="center">取值范围</th>
<th align="center">存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节(byte)</td>
<td align="center">-$2^7$ ~ $2^7$-1<br />-128 ~ 127</td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center">短整数(short)</td>
<td align="center">-$2^{15}$ ~ $2^{15}$-1 <br />-32768 ~ 32767</td>
<td align="center">2个字节</td>
</tr>
<tr>
<td align="center"><span style = "color:red"><strong>整数(int)</strong></span></td>
<td align="center"><span style = "color:red"> -$2^{31}$ ~ $2^{31}$-1<br />-2147483648 ~ 2147483647</span></td>
<td align="center"><span style = "color:red">4个字节</span></td>
</tr>
<tr>
<td align="center">长整数(long)</td>
<td align="center">-$2^{63}$ ~ $2^{63}$-1</td>
<td align="center">8个字节</td>
</tr>
<tr>
<td align="center">单精度(float)</td>
<td align="center">$2^{-149}$ ~ $2^{128}$-1</td>
<td align="center">4个字节</td>
</tr>
<tr>
<td align="center">双精度(double)</td>
<td align="center">$2^{-1074}$ ~ $2^{1024}$-1</td>
<td align="center">8个字节</td>
</tr>
</tbody></table>
<h3 id="Float在JVM的表达方式及使用陷阱"><a href="#Float在JVM的表达方式及使用陷阱" class="headerlink" title="Float在JVM的表达方式及使用陷阱"></a>Float在JVM的表达方式及使用陷阱</h3><pre><code class="java">float d1 = 423432423f;
float d2 = d1 + 1;
if(d1 == d2)&#123;
    System.out.println(&quot;d1==d2&quot;);
&#125;else&#123;
    System.out.println(&quot;d1!=d2&quot;);
&#125;

答案：d1 == d2
对于单精度浮点型float d1在内存中是采用科学计数法表示
表达为：4.2343242E7 保留小数点后七位 [如果更高精度的用double]
d1是八位数
无论是d1还是d2不考虑最后一位
d2用科学计数法表示同样为4.2343242E7
因此 d1 == d2

银行业务数值精确计算要用BigDecimal类进行加减乘除的计算
</code></pre>
<h3 id="随机数的使用"><a href="#随机数的使用" class="headerlink" title="随机数的使用"></a>随机数的使用</h3><pre><code class="java">编程题：随机生成30~100之间的整数
==========================================================
package com.example.demo12;

import java.util.Random;

public class RandomSample &#123;
    public Integer randomInt1()&#123;
        int min = 30;
        int max = 100;
        //生成正整数范围0-70的随机数 =&gt; 30~100
        int result = new Random().nextInt(max - min) + min;
        return  result;
    &#125;
    public Integer randomInt2()&#123;
        int min = 30;
        int max = 100;
        int result = (int)(Math.random() * (max-min)) + min;
        return result;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(new RandomSample().randomInt1());
        System.out.println(new RandomSample().randomInt2());
    &#125;
&#125;
</code></pre>
<pre><code class="java">编程题：列出1-1000的质数[大于1的情况下 只能被1和自身整除的数]
==========================================================
package com.example.demo12;

public class PrimeNumber &#123;
    public static void main(String[] args) &#123;
        for (int i = 2; i &lt;= 1000; i++)&#123;
            boolean flag = true;
            for (int j = 2; j &lt; i; j++)&#123;
                if(i % j == 0)&#123;
                    flag = false;
                    break;
                &#125;
            &#125;
            if (flag)&#123;
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="面向对象的三大特征是什么"><a href="#面向对象的三大特征是什么" class="headerlink" title="面向对象的三大特征是什么"></a>面向对象的三大特征是什么</h3><ul>
<li><p><strong>封装</strong><br>对同一类事务的特征和功能包装到一起，只对外暴露需要调用接口而已<br>[我想让你看到的你能看到 不想让你看到的不能看到]。作用：对接口进行实现的过程中每一个接口的实现类对接口进行了实现，但是在调用的时候通常是面对接口的，对于使用者来说只需要知道接口对应的哪些方法做什么用的就可以了，对内部的什么是不需要理解的。接口是体现封装的常见方法<br><strong>封装的好处</strong>：</p>
<ol>
<li>实现专业的分工</li>
<li>减少代码耦合</li>
<li>可以自由修改类的内部结构</li>
</ol>
</li>
<li><p><strong>继承</strong><br>是Java中面向对象最显著的特征，继承是从已有的类中派生出新的类，新的类能够吸收原有属性的属性和行为并扩展新的类，<u>Java中类是不支持多继承的，接口可以，一个接口可以继承多个其他接口</u> 父类是子类的抽象化，子类是父类的具体化。<br><strong>接口与抽象类有那些异同？</strong></p>
<table>
<thead>
<tr>
<th align="center">相同点</th>
<th align="center">不同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">都是上层的抽象</td>
<td align="center">抽象类可包含方法的实现<br />接口则只能包含方法的声明</td>
</tr>
<tr>
<td align="center">不能被实例化 [不可new]</td>
<td align="center">继承类只能继承一个抽象类<br />实现类可以实现多个接口</td>
</tr>
<tr>
<td align="center">都可以包含抽象发发</td>
<td align="center">抽象级别：接口&gt;抽象类&gt;实现类</td>
</tr>
</tbody></table>
<p><span style = "color : red"><strong>作用不同</strong>：接口用于约束程序行为。继承则用于代码复用</span><br>注意：JDK8以上版本，接口可以有default方法，包含方法实现</p>
</li>
<li><p><strong>多态</strong><br>最重要的特性 前面是为多态服务的<br>多态是三大特性中最重要的操作<br>多态是同一个行为具有多个不同表现形式或形态的能力<br>多态是同一个接口，使用不同的实例而执行不同操作</p>
</li>
</ul>
<h3 id="静态和实例变量-方法-的区别"><a href="#静态和实例变量-方法-的区别" class="headerlink" title="静态和实例变量(方法)的区别"></a>静态和实例变量(方法)的区别</h3><ul>
<li><strong>语法区别</strong>：静态变量前要加static关键字，实例则不用</li>
<li><strong>隶属区别</strong>：实例变量属于某个对象的属性，而静态属于类</li>
<li><strong>运行区别</strong>：<u>静态变量</u>在JVM加载类字节码创建，<u>实例变量</u>在实例化对象时创建</li>
</ul>
<h6 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h6><p>在类中定义，使用static关键字修饰<br>静态方法：可以通过类名直接访问，也可以通过对象访问<br>调用上下文：不依赖于类的实例，不能访问实例变量和实例方法<br>生命周期：从类加载到类卸载，生命周期与类相同</p>
<h6 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h6><p>在类中定义，不适用static关键字修饰<br>实例方法：只能通过对象访问<br>调用上下文：依赖于类的实例，可以访问实例变量和实例方法<br>生命周期：从对象创建到对象被垃圾回收，生命周期与对象相同</p>
<h3 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h3><pre><code class="java">package com.example.text;
//请写出程序输出结果
//1. 静态优先
//2. 父类优先
//3. 非静态块优先于构造函数
public class ExecutionSequence &#123;
    public static void main(String[] args) &#123;
        new GeneralClass();
    &#125;
&#125;
class ParentClass&#123;
    static &#123;
        System.out.println(&quot;①我是父类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;②我是父类非静态块&quot;);
    &#125;
    public ParentClass()&#123;
        System.out.println(&quot;③我是父类构造函数&quot;);
    &#125;
&#125;

class GeneralClass extends ParentClass&#123;
    static&#123;
        System.out.println(&quot;④我是子类静态块&quot;);
    &#125;

    &#123;
        System.out.println(&quot;⑤我是子类非静态块&quot;);
    &#125;

    public GeneralClass()&#123;
        System.out.println(&quot;⑥我是子类构造函数&quot;);
    &#125;
&#125;
/*
①我是父类静态块
④我是子类静态块
②我是父类非静态块
③我是父类构造函数
⑤我是子类非静态块
⑥我是子类构造函数
*/
</code></pre>
<blockquote>
<p>总结<br>静态块：静态块在类加载时执行，且父类静态块先于子类静态块执行。<br>非静态块和构造函数：在对象创建时，先执行父类的非静态块和构造函数，再执行子类的非静态块和构造函数。</p>
</blockquote>
<h3 id="请说明java的异常体系"><a href="#请说明java的异常体系" class="headerlink" title="请说明java的异常体系"></a>请说明java的异常体系</h3><p>Error → Throwable<br>RuntimeException → Exception → Throwable<br>运行时产生的异常不要求对其强制try catch…</p>
<h5 id="Error和Exception的区别和联系"><a href="#Error和Exception的区别和联系" class="headerlink" title="Error和Exception的区别和联系"></a>Error和Exception的区别和联系</h5><table>
<thead>
<tr>
<th align="center">Exception</th>
<th align="center">Error</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可以是可被控制或不可控制的</td>
<td align="center">总是不可控制的</td>
</tr>
<tr>
<td align="center">表示一个由程序员导致的错误</td>
<td align="center">经常用来用于表示系统错误或低层资源的错误</td>
</tr>
<tr>
<td align="center">表示在应用程序级被处理</td>
<td align="center">如果可能的话，应该在系统级被捕捉</td>
</tr>
</tbody></table>
<h3 id="String与字符串常量池-比较内存地址"><a href="#String与字符串常量池-比较内存地址" class="headerlink" title="String与字符串常量池 [比较内存地址]"></a>String与字符串常量池 [比较内存地址]</h3><pre><code class="java">String s1 = &quot;abc&quot;;
String s2 = &quot;abc&quot;;
String s3 = &quot;abc&quot;+&quot;def&quot;;
String s4 = &quot;abcdef&quot;;
String s5 = s2 + &quot;def&quot;;
String s6 = new String(&quot;abc&quot;);
System.ouut.println(s1==s2); //true
System.ouut.println(s3==s4); //true 相等的都保存到常量池
System.ouut.println(s4==s5); //false 
//s5中的s2属于引用类型 在java编译期间无法确定其类型 只有在运行时才能确定具体的值 会产生一个新的内存地址给s5 所以不相等
System.ouut.println(s4.equals(s5));//true equals比较的是内容
System.ouut.println(s1==s6); //false
//s1是在常量池的常量 new String(&quot;abc&quot;);创建的东西不在常量池 存储的地方是完全不同的
</code></pre>
<h3 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h3><table>
<thead>
<tr>
<th></th>
<th align="center">String</th>
<th align="center">StringBuffer</th>
<th align="center">StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>执行速度</td>
<td align="center">最差</td>
<td align="center">其次</td>
<td align="center">最高</td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程安全</td>
<td align="center">线程不安全</td>
</tr>
<tr>
<td>使用场景</td>
<td align="center">少量字符串操作</td>
<td align="center">多线程环境下的大量操作</td>
<td align="center">单线程环境下的大量操作</td>
</tr>
</tbody></table>
<blockquote>
<p>优先使用哪个？<br><strong>单线程环境</strong>：优先使用 <strong>StringBuilder</strong>。因为 StringBuilder 没有线程同步开销，性能更高。<br><strong>多线程环境</strong>：优先使用 <strong>StringBuffer</strong>。因为 StringBuffer 提供了线程安全的保证，避免了多线程环境下的并发问题</p>
</blockquote>
<h3 id="List与Set的区别"><a href="#List与Set的区别" class="headerlink" title="List与Set的区别"></a>List与Set的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">List</th>
<th align="center">Set</th>
</tr>
</thead>
<tbody><tr>
<td align="center">允许重复</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否允许null</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">是否有序</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">常用类</td>
<td align="center">ArrayList<br />LinkedList</td>
<td align="center">HashSet<br />LinkedHashSet<br />TreeSet</td>
</tr>
</tbody></table>
<h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">ArrayList</th>
<th align="center">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">基于动态数组</td>
<td align="center">基于链表</td>
</tr>
<tr>
<td align="center">遍历方式</td>
<td align="center">连续读取</td>
<td align="center">基于指针</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">大数据量读取</td>
<td align="center">频繁新增、插入[写入类型]</td>
</tr>
</tbody></table>
<h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HashSet</th>
<th align="center">TreeSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排序方式</td>
<td align="center">不能保证顺序</td>
<td align="center">按预置规则顺序</td>
</tr>
<tr>
<td align="center">底层存储</td>
<td align="center">基于HashMap</td>
<td align="center">基于TreeMap</td>
</tr>
<tr>
<td align="center">底层实现</td>
<td align="center">基于Hash表实现</td>
<td align="center">基于二叉树实现</td>
</tr>
</tbody></table>
<h3 id="List排序的编码实现"><a href="#List排序的编码实现" class="headerlink" title="List排序的编码实现"></a>List排序的编码实现</h3><pre><code class="java">编程题：List排序
Employee.java
package com.example.text;

public class Employee &#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;

    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
</code></pre>
<pre><code class="java">ListSorter.java
package com.example.text;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class ListSorter &#123;
    public static void main(String[] args) &#123;
        List&lt;Employee&gt; emps = new ArrayList&lt;&gt;();
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        Collections.sort(emps, new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                //以薪资排序 如果是以年龄的话o1.getAge() - o2.getAge();
                return (int) (o1.getSalary() - o2.getSalary());
                //返回正数 第一个大于第二个
            &#125;
        &#125;);
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="TreeSet排序的编码实现"><a href="#TreeSet排序的编码实现" class="headerlink" title="TreeSet排序的编码实现"></a>TreeSet排序的编码实现</h3><pre><code class="java">编程题:TreeSet排序
Employee.java 同上
[自定义排序]
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;(new Comparator&lt;Employee&gt;() &#123;
            @Override
            public int compare(Employee o1, Employee o2) &#123;
                return (int)(o2.getSalary() - o1.getSalary());
            &#125;
        &#125;);
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
    &#125;
&#125;
</code></pre>
<pre><code class="java">[自然排序]
package com.example.text;

public class Employee implements Comparable&lt;Employee&gt;&#123;
    private String ename;
    private Integer age;
    private Float salary;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, salary=&quot; + salary +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public int compareTo(Employee o)&#123;
 //如果返回-1 Employee对象返回到红黑树的左边 采用降序排列
 //如果返回1
        return this.getAge().compareTo(o.getAge());
//      return o.getAge().compareTo(this.getAge()); 输出降序
//如果前面比后面大 返回1 反之返回-1 如果两者相等返回0
    &#125;
    public Employee() &#123;&#125;
    public Employee(String ename, Integer age, Float salary) &#123;
        this.ename = ename;
        this.age = age;
        this.salary = salary;
    &#125;
    public String getEname() &#123; return ename;&#125;
    public void setEname(String ename) &#123;this.ename = ename;&#125;
    public Integer getAge() &#123; return age;&#125;
    public void setAge(Integer age) &#123;this.age = age;&#125;
    public Float getSalary() &#123;return salary;&#125;
    public void setSalary(Float salary) &#123;this.salary = salary;&#125;
&#125;
=============================================================
SetSorter.java 
package com.example.text.TreeSet;

import java.util.*;

//自定义排序
public class SetSorter &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Employee&gt; emps = new TreeSet&lt;Employee&gt;
        emps.add(new Employee(&quot;张三&quot;, 33, 1800f));
        emps.add(new Employee(&quot;李四&quot;, 55, 3800f));
        emps.add(new Employee(&quot;王五&quot;, 40, 2300f));
        System.out.println(emps);
    &#125;
&#125;
</code></pre>
<h3 id="hashCode与equals的联系与区别"><a href="#hashCode与equals的联系与区别" class="headerlink" title="hashCode与equals的联系与区别"></a>hashCode与equals的联系与区别</h3><h5 id="Object类hashCode-和equals-的区别"><a href="#Object类hashCode-和equals-的区别" class="headerlink" title="Object类hashCode()和equals()的区别"></a>Object类hashCode()和equals()的区别</h5><ul>
<li><p>equals()方法用来判断两个对象是否”相同”</p>
</li>
<li><p>hashCode()返回一个int，代表”将该对象的内部地址” [如果不相等肯定不是同一个对象] [小概率情况下不同的对象也产生相同的hashCode(), 之后再用equals()去比较]</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">两个对象如果equals()成立, hashcode()一定成立</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">如果equals()不成立, hashcode()可能成立</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">如果hashcode()成立, equals()不一定成立</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">hashcode()不相等, equals()一定不成立</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>hashCode 方法用于快速定位哈希表中的桶（bucket），而 equals 方法用于确认桶中的具体对象。通过 hashCode 快速过滤掉大部分不相等的对象，可以显著提高查找效率。<br>通常是先调用 hashCode 方法来定位桶，然后再调用 equals 方法来确认具体对象。equals 方法不会直接调用 hashCode 方法，而是依赖于 hashCode 方法的一致性。</p>
</blockquote>
<h3 id="Java-IO中有集中类型的流"><a href="#Java-IO中有集中类型的流" class="headerlink" title="Java IO中有集中类型的流"></a>Java IO中有集中类型的流</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">InputStream[父类]<br />     FileInputStream<br />BufferedInputStream[缓存]</td>
<td align="center">OutputStream[父类]<br />      FileOutputStream<br />  BufferedOutputStream[缓存]</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">Reader<br />FileReader<br />InputStreamReader<br />BufferedReader</td>
<td align="center">Writer<br />FileWeiter<br />OutputStreamWriter<br />BufferedWeiter</td>
</tr>
</tbody></table>
<h3 id="★-利用IO实现文件复制-★-笔试"><a href="#★-利用IO实现文件复制-★-笔试" class="headerlink" title="★ 利用IO实现文件复制 ★ [笔试]"></a>★ 利用IO实现文件复制 ★ [笔试]</h3><pre><code class="java">编程题：复制文件到指定文件夹
package com.example.text.FileCopy;

import java.io.*;

public class FileCopy &#123;
    public static void main(String[] args) &#123;
        //1. 利用JavaIo
        File source = new File(&quot;D:/application.rar&quot;);
        File target = new File(&quot;D:/target/application.rar&quot;);
        InputStream input = null;
        OutputStream output = null;
        try &#123;
            input = new FileInputStream(source);
            output = new FileOutputStream(target);
            byte[] buf = new byte[1024];
            int byteRead;
            while((byteRead = input.read(buf)) != -1)&#123;
                output.write(buf,0,byteRead);
            &#125;
        &#125; catch (FileNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;finally &#123;
            try &#123;
                input.close();
                output.close();
            &#125; catch (IOException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
        //2. 利用FileChannel实现文件复制
        //3. Commons Io组件实现文件复制
        //FileUtils.copyFile(Source,Target);
    &#125;
&#125;
</code></pre>
<h3 id="请介绍JVM的内存组成"><a href="#请介绍JVM的内存组成" class="headerlink" title="请介绍JVM的内存组成"></a>请介绍JVM的内存组成</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/c2c6b396e3573fda209d5b4db42d40799b0be3f1/data/JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90.png"></p>
<blockquote>
<p>[共享区：供所有对象共享 所有线程都访问到的地方]<br><strong>堆</strong>：垃圾回收销毁处理区<br><strong>方法区</strong>：虚拟机加载的类的信息、常量、静态变量等信息</p>
<p>[私有区：所有对象都是私有的]<br><strong>程序计数器PC</strong>： 当前线程所执行的字节码指令的行号指示器[<strong>分值、跳转</strong>、循环、异常处理、线程恢复] 每个线程都有单独的程序计数器 [私有的]<br><strong>虚拟机栈VM Stack</strong>：为Java的方法服务 当线程创建的时候虚拟机栈会为线程分配一个虚拟机栈，在线程执行的时候创建的每个方法都会创建一个栈针，用于存放局部变量、操作方法等 [入栈+出栈]<br><strong>本地方法栈</strong>：类似于虚拟机栈，本地方法栈是执行<u>本地方法使用</u>的</p>
</blockquote>
<h3 id="请简述Java的垃圾回收-GC"><a href="#请简述Java的垃圾回收-GC" class="headerlink" title="请简述Java的垃圾回收(GC)"></a>请简述Java的垃圾回收(GC)</h3><ul>
<li>GC(Garbage Collection)用于回收不再使用的内存</li>
<li>GC负责3项任务：分配内存、确保引用、回收内存</li>
<li>GC回收的依据某对象没有任何引用、则可以被回收</li>
</ul>
<h5 id="垃圾回收-GC-算法"><a href="#垃圾回收-GC-算法" class="headerlink" title="垃圾回收(GC)算法"></a>垃圾回收(GC)算法</h5><ul>
<li><strong>引用计数算法</strong> [计数器 引用到这个对象的时候+1  被释放或断开计数器-1  当计数器变成0就可以被垃圾回收]<br>若两个对象相互引用就会产生循环计数器 这个对于引用计数算法是无效的</li>
<li><strong>跟踪回收算法</strong> [利用JVM维护的对象引用图 每个对象彼此依赖和引用 从根节点标记对象引用图和可以被标记的对象 遍历结束以后未被标记的对象是不能够使用的对象可以被回收]</li>
<li><strong>压缩回收算法</strong> [将JVM堆中活动的对象放到一个集中的区域中 另外一大块留出一个活动的区域 对堆中的碎片进行集中的处理]</li>
<li><strong>复制回收算法</strong> [把堆分成两个相同大小的区域 只有其中的一个区域被使用 直到这个区域被消耗完 垃圾回收器就会中断这个程序的运行 以遍历的方式把活动的对象移动到另一个区域 移动的过程中对象是紧密挨在一起的 可以消除其中的碎片 【在复制的同时也对对象进行重新复制和安排 一次性解决了内存碎片的问题】【需要两倍大小的内存空间 降低了效率】]</li>
<li><strong>按代回收算法</strong> [把堆分成多个子堆，每个堆命名成一代，算法优先收集年幼年轻的对象，在这其中对象仍然存活的就把它移动到高级堆中 【减少扫描次数和范围 提高回收效益】]</li>
</ul>
<h3 id="Java的内存泄露的场景"><a href="#Java的内存泄露的场景" class="headerlink" title="Java的内存泄露的场景"></a>Java的内存泄露的场景</h3><h5 id="请列举Java中内存泄漏的场景"><a href="#请列举Java中内存泄漏的场景" class="headerlink" title="请列举Java中内存泄漏的场景"></a>请列举Java中内存泄漏的场景</h5><p>一个不需要使用的对象还在内存中占用并使用其内存空间，忘记释放就会存在内存泄露</p>
<ul>
<li><strong>静态集合类</strong> static描述对象 存储在方法区 垃圾回收器不会对其扫描回收</li>
<li><strong>各种连接</strong> JVM一直可达不会被回收</li>
<li><strong>监听器</strong> 全局存在的</li>
<li><strong>不合理的作用域</strong> 能用在方法中public 不要用在方法外private</li>
<li>没有把对象及时设置为null【极少发生】</li>
</ul>
<h3 id="请实现对象的浅复制与深复制"><a href="#请实现对象的浅复制与深复制" class="headerlink" title="请实现对象的浅复制与深复制"></a>请实现对象的浅复制与深复制</h3><ul>
<li><strong>浅复制</strong>：只对对象及变量值进行复制，引用对象地址不变</li>
<li><strong>深复制</strong>[序列化方式]：创建一个新的对象，并且复制所有引用类型字段的对象。修改新对象的引用类型字段不会影响原对象。[彼此互不干扰]</li>
</ul>
<pre><code class="java">com/example/text/clone/Dancer.java
package com.example.text.clone;

import java.io.*;

public class Dancer implements Cloneable,Serializable&#123;
    private String name;
    private Dancer partner;

    public Dancer() &#123;
    &#125;

    public Dancer(String name, Dancer partner) &#123;
        this.name = name;
        this.partner = partner;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Dancer getPartner() &#123;
        return partner;
    &#125;

    public void setPartner(Dancer partner) &#123;
        this.partner = partner;
    &#125;
    public Dancer deepClone() throws IOException, ClassNotFoundException &#123;
        //序列化, 将内存中的对象序列化为字节数组
        //序列化要注意加Serializable接口
        ByteArrayOutputStream bos = new ByteArrayOutputStream();//字节数组
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        //反序列化, 将字节数组转回到对象, 同时完成深复制的任务
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis); //字节数组还原成对象
        return (Dancer) ois.readObject();
    &#125;
    //初始化一下
    public static void main(String[] args) throws CloneNotSupportedException, IOException, ClassNotFoundException &#123;
        Dancer d1 = new Dancer();
        d1.setName(&quot;小明&quot;);
        Dancer d2 = new Dancer();
        d2.setName(&quot;小红&quot;);
        d1.setPartner(d2);
        //hashCode()是内存地址转化后的一个整数
        System.out.println(&quot;Partner:&quot; + d2.hashCode());
        //浅复制
        Dancer shallow =  (Dancer)d1.clone();
        System.out.println(&quot;浅复制：&quot; + shallow.getPartner().hashCode());
        //深复制
        Dancer deep = (Dancer) d1.deepClone();
        System.out.println(&quot;深复制：&quot; + deep.getPartner().hashCode());
    &#125;
&#125;
</code></pre>
<h5 id="简述一下equalsIgnoreCase和equals的区别"><a href="#简述一下equalsIgnoreCase和equals的区别" class="headerlink" title="简述一下equalsIgnoreCase和equals的区别"></a>简述一下equalsIgnoreCase和equals的区别</h5><pre><code class="java">equalsIgnoreCase：比较两个字符串的内容是否相等, 忽略大小写
equals：比较两个字符的内容是否完全相等, 包括大小写
equalsIgnoreCase 和 equals 都是 String 类的方法，用于比较两个字符串是否相等(返回值都是Boolean)。它们的主要区别在于对大小写的处理方式。
</code></pre>
<h1 id="Java面试——Web基础与数据处理"><a href="#Java面试——Web基础与数据处理" class="headerlink" title="Java面试——Web基础与数据处理"></a>Java面试——Web基础与数据处理</h1><h3 id="请说明Servlet执行流程"><a href="#请说明Servlet执行流程" class="headerlink" title="请说明Servlet执行流程"></a>请说明Servlet执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/94561f5b5984c6a6ac9be3dd6a81d295e2955040/data/Servlet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<h6 id="问：Servlet什么时候被实例化的呢？"><a href="#问：Servlet什么时候被实例化的呢？" class="headerlink" title="问：Servlet什么时候被实例化的呢？"></a>问：Servlet什么时候被实例化的呢？</h6><blockquote>
<p>Servlet默认情况下是<u>第一次访问的时候</u><strong>实例化</strong>的<br>也可以通过web.xml配置load-on-startup，使其在服务启动的时候实例化</p>
</blockquote>
<h6 id="问：Servlet在并发条件下如何处理的？"><a href="#问：Servlet在并发条件下如何处理的？" class="headerlink" title="问：Servlet在并发条件下如何处理的？"></a>问：Servlet在并发条件下如何处理的？</h6><blockquote>
<p>基于<strong>单例多线程</strong>技术提供web服务<br>使用servlet时不允许使用存在状态改变的变量</p>
</blockquote>
<blockquote>
<p>补充：</p>
<p><strong><u>单例多线程技术</u></strong><br><strong>单例模式</strong>：Servlet 实例在 Web 容器中通常是单例的，即一个 Servlet 类只有一个实例。这意味着所有的请求都会共享同一个 Servlet 实例。<br>优点：减少了对象的创建和销毁开销，提高了性能。<br>缺点：需要特别注意线程安全问题，因为多个请求可能会同时访问同一个 Servlet 实例。</p>
<p><strong>多线程</strong>：Web 容器为每个请求分配一个独立的线程来处理。当多个请求同时到达时，这些请求会被分配到不同的线程中，但这些线程都共享同一个 Servlet 实例。<br>线程安全：由于多个线程共享同一个 Servlet 实例，因此必须确保 Servlet 实例中的代码是线程安全的。</p>
<p><u><strong>状态改变的变量</strong></u><br><strong>状态改变的变量</strong>：指的是在 Servlet 实例中定义的成员变量（实例变量），这些变量在不同请求之间可能会被修改。</p>
<p><strong>线程安全问题</strong>：<u>如果多个线程同时访问和修改同一个成员变量，可能会导致数据不一</u>致、<strong>竞态条件</strong>等问题。<br>竞态条件（Race Condition）是指在多线程或多进程环境中，由于多个线程或进程对共享资源的访问顺序不确定，导致程序的行为依赖于这些线程或进程的执行顺序，从而产生不可预测的结果。简单来说，竞态条件发生在多个线程或进程竞争同一资源时，如果这些线程或进程的执行顺序不同，会导致不同的结果。</p>
</blockquote>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><ul>
<li><h6 id="启动时装载-web-xml"><a href="#启动时装载-web-xml" class="headerlink" title="启动时装载 - web.xml"></a>启动时装载 - web.xml</h6></li>
<li><h6 id="创建-构造函数"><a href="#创建-构造函数" class="headerlink" title="创建 - 构造函数"></a>创建 - 构造函数</h6></li>
<li><h6 id="初始化-init-专门的初始化资源"><a href="#初始化-init-专门的初始化资源" class="headerlink" title="初始化 - init()  [专门的初始化资源]"></a>初始化 - init()  [专门的初始化资源]</h6></li>
<li><h6 id="提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost"><a href="#提供服务-service-对于发来的请求无论是get-post-一律使用service进行处理-细化分出doget-dopost" class="headerlink" title="提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]"></a>提供服务 - service() [对于发来的请求无论是get post 一律使用service进行处理] [细化分出doget() dopost()]</h6></li>
<li><h6 id="停止时销毁-destory-销毁资源"><a href="#停止时销毁-destory-销毁资源" class="headerlink" title="停止时销毁 - destory() [销毁资源]"></a>停止时销毁 - destory() [销毁资源]</h6></li>
</ul>
<pre><code class="java">com/example/text/servlet/SampleServlet.java
package com.example.text.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class SampleServlet extends HttpServlet &#123;
    public SampleServlet()&#123;
        System.out.println(&quot;正在创建Servlet&quot;);
    &#125;

    @Override
    public void init() throws ServletException &#123;
        System.out.println(&quot;正在初始化Servlet&quot;);
    &#125;

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;
        System.out.println(this.hashCode() + &quot;: Service()正在提供服务&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        resp.getWriter().print(this.hashCode() + &quot;: Service()正在提供服务&quot;);
    &#125;

    @Override
    public void destroy()&#123;
        System.out.println(&quot;正在销毁Servlet&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.example.text.servlet.SampleServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SampleServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/sample&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

=================================================
http://localhost:8080/sample

正在创建Servlet 【启动时】
正在初始化Servlet
1025518765: Service()正在提供服务
正在销毁Servlet 【停止时】
</code></pre>
<h3 id="请求与响应的结构"><a href="#请求与响应的结构" class="headerlink" title="请求与响应的结构"></a>请求与响应的结构</h3><ul>
<li>HTTP请求包含三部分：请求行、请求头、请求体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/22dcc798c61eeec0f74ca5dd6e7372dfa0fa135e/data/HTTP%E8%AF%B7%E6%B1%82%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP请求三部分"></p>
<ul>
<li>HTTP响应包含三部分：响应行、响应头、响应体</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="HTTP响应三部分"></p>
<h3 id="请求转发与响应重定向的区别"><a href="#请求转发与响应重定向的区别" class="headerlink" title="请求转发与响应重定向的区别"></a>请求转发与响应重定向的区别</h3><h5 id="请求转发-一次请求"><a href="#请求转发-一次请求" class="headerlink" title="请求转发 [一次请求]"></a>请求转发 [一次请求]</h5><ul>
<li>请求转发是<strong>服务器跳转</strong>，只会产生一次请求</li>
<li>请求转发语句是：<code>request.getRequestDispatcher().forward()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/5c6c25addb904f020840b00a3b10ed5b3c707469/data/HTTP%E5%93%8D%E5%BA%94%E4%B8%89%E9%83%A8%E5%88%86.jpg" alt="请求转发"></p>
<blockquote>
<p>网页请求Tomcat的Servlet1，Servlet1请求Servlet2，Servlet2响应给网页，网页收到响应</p>
</blockquote>
<h5 id="响应重定向-两次请求"><a href="#响应重定向-两次请求" class="headerlink" title="响应重定向 [两次请求]"></a>响应重定向 [两次请求]</h5><ul>
<li>重定向则是<strong>浏览器端跳转</strong>，会产生两次请求</li>
<li>响应重定向语句是：<code>response.sendRedirect()</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/de72ec8d8af2b71272c785f5fb04bad0df88d78f/data/%E5%93%8D%E5%BA%94%E9%87%8D%E5%AE%9A%E5%90%911.jpg" alt="响应重定向"></p>
<blockquote>
<p>网页$请求_1$Tomcat的Servlet1，Servlet1直接$响应_1$给网页，网页收到$响应_1$[让网页创建一个新的$请求_2$]<br>网页新创了一个$请求_2$Tomcat的Servlet2，Servlet2只对请求进行处理返回给$响应_2$网页</p>
</blockquote>
<h3 id="请阐述Session的原理"><a href="#请阐述Session的原理" class="headerlink" title="请阐述Session的原理"></a>请阐述Session的原理</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/e69d245dd6d92882f32e9bee19e85bb5646a145c/data/%E7%AE%80%E8%BF%B0Session%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="简述Session的原理"></p>
<blockquote>
<p>浏览器第一次向Tomcat发送请求，Tomcat收到请求自动在tomcat运行内存中生成一个存储空间并赋予一个SessionId:7U809J唯一编号，<strong>若使用了session.setAttribute(name,小潘)<strong>，会在那个运行内存中存放一个</strong>小潘</strong>的内存属性[name:小潘] 当程序处理完后返回给浏览器其中包含了一个特殊信息SessionId:7U809J，浏览器收到响应后把SessionId:7U809J保存到浏览器的Cookie中SessionId:7U809J[只要当前浏览器没有被关闭的话 Cookie会一直存在 会在发送请求的时候一并发送给服务器]，当第二次发送请求的时候浏览器会把SessionId:7U809J第二次发送给Tomcat，<strong>若使用了session.getAttribute(name) &#x3D; 小潘</strong>，得到的结果就出现了小潘 返回浏览器响应</p>
</blockquote>
<h3 id="JSP九大内置对象是什么"><a href="#JSP九大内置对象是什么" class="headerlink" title="JSP九大内置对象是什么"></a>JSP九大内置对象是什么</h3><table>
<thead>
<tr>
<th align="left">内置对象</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">request</td>
<td align="left">请求对象 - HttpServletRequest</td>
</tr>
<tr>
<td align="left">response</td>
<td align="left">响应对象 - HttpServletResponse</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">用户会话 - HttpSession</td>
</tr>
<tr>
<td align="left">application [全局实例]</td>
<td align="left">应用全局对象 - ServletContext</td>
</tr>
<tr>
<td align="left">out</td>
<td align="left">输出对象 - PrintWriter</td>
</tr>
<tr>
<td align="left">page</td>
<td align="left">当前页面对象 - this [Object实例]</td>
</tr>
<tr>
<td align="left">pageContext</td>
<td align="left">页面上下文对象 - PageContext</td>
</tr>
<tr>
<td align="left">config [全局参数]</td>
<td align="left">应用配置对象 - ServletConfig</td>
</tr>
<tr>
<td align="left">exception</td>
<td align="left">应用异常对象 - Throwable</td>
</tr>
</tbody></table>
<h3 id="Statement-和-PreparedStatement的区别"><a href="#Statement-和-PreparedStatement的区别" class="headerlink" title="Statement 和 PreparedStatement的区别"></a>Statement 和 PreparedStatement的区别</h3><ul>
<li>PreparedStatement是预编译的SQL语句，效率高于Statement</li>
<li>PreparedStatement支持 ‘?’ 操作符，相对于Statement更加灵活</li>
<li>PreparedStatement可以防止SQL注入，安全性高于Statement</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;
    //使用Statement sql语句解释N多次
    //SQL注入攻击：  &#39; or 1=1 or &#39;
    public void findByEname1(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);
            Statement ps = conn.createStatement();
            //使用Statement
            String sql = &quot;SELECT * FROM emp where ename = &#39;&quot; + ename + &quot;&#39; &quot;;
            System.out.println(sql);
            ResultSet rs = ps.executeQuery(sql);

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class StatementSample &#123;

    //使用预编译PreparedStatement sql语句解释一次
    public void findByEname2(String ename) &#123;
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;

        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            Class.forName(driverName);
            conn = DriverManager.getConnection(URL, username, password);

            //使用预编译PreparedStatement
            String sql = &quot;SELECT * FROM emp where ename = ?&quot;;
            System.out.println(sql);
            PreparedStatement ps = conn.prepareStatement(sql);
            ps.setString(1, ename);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        StatementSample sample = new StatementSample();
        sample.findByEname1(&quot;SMITH&#39; or 1=1 or &#39;&quot;); //SQL注入攻击
        sample.findByEname2(&quot;SMITH&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="请说明JDBC的使用步骤"><a href="#请说明JDBC的使用步骤" class="headerlink" title="请说明JDBC的使用步骤"></a>请说明JDBC的使用步骤</h3><ul>
<li>加载JDBC驱动</li>
<li>创建数据库连接(Connection)</li>
<li>创建命令(Statement)</li>
<li>处理结果(ResultSet)</li>
<li>关闭连接</li>
</ul>
<pre><code class="java">package com.example.text.jdbc;

import java.sql.*;

public class MysqlJDBC &#123;
    public static void main(String[] args) &#123;
        //连接需要提前下载好包   mysql-connector-java-5.1.47.jar
        String driverName = &quot;com.mysql.jdbc.Driver&quot;;
        String URL = &quot;jdbc:mysql://127.0.0.1:3306/scott&quot;;
        String sql = &quot;SELECT * FROM emp&quot;;
        String username = &quot;root&quot;;
        String password = &quot;root&quot;;
        Connection conn = null;
        try &#123;
            //1.加载JDBC驱动
            Class.forName(driverName);
            //2.建立连接
            conn = DriverManager.getConnection(URL, username, password);
            //3.创建命令（Statement)
            Statement ps = conn.createStatement();
            //4.处理结果
            ResultSet rs = ps.executeQuery(sql);
            while (rs.next()) &#123;
                System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; +
                        rs.getString(&quot;job&quot;) + &quot;,&quot; +
                        rs.getFloat(&quot;sal&quot;));
            &#125;
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; catch (SQLException e) &#123;
            e.printStackTrace();
        &#125;
        //5.关闭连接
        finally &#123;
            if (conn != null) &#123;
                try &#123;
                    conn.close();
                &#125; catch (SQLException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="SQL编程训练"><a href="#SQL编程训练" class="headerlink" title="SQL编程训练"></a>SQL编程训练</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bc48ea2eefeb9921758f69d1ee9d506366d73753/data/scott_sql%E7%BB%83%E4%B9%A0%E9%A2%98.png"></p>
<pre><code class="sql">scott.sql文件已准备好

★按部门编号升序、工资倒序的排列员工信息
SELECT * FROM emp ORDER BY deptno ASC, sal DESC

★列出deptno=30的部门名称及员工[关联查询]
SELECT dept.dname, emp.* FROM emp,dept
WHERE emp.deptno = dept.deptno
AND dept.deptno = 30

★列出每个部门最高、最低、平均工资 #若再列出人数只需要再SELECT后面加 COUNT(*)
SELECT deptno, max(sal), min(sal), avg(sal)
FROM emp 
GROUP BY deptno  

★列出市场部(SALES)及研发部(RESEARCH)的员工
SELECT * FROM dept d, emp e
WHERE d.deptno = e.deptno 
AND (d.dname = &#39;SALES&#39; or d.dname = &#39;RESEARCH&#39;)

★列出人数超过3人的部门 #按照部门分组 
# WHERE对原始数据进行筛选[在GROUP BY之前进行的] 
# HAVING对分组后的进行二次筛选[在GROUP BY之后进行的]
SELECT d.dname, count(*)
FROM dept d, emp e
WHERE d.deptno = e.deptno 
GROUP BY d.dname 
HAVING count(*)&gt;3

★计算MILLER年薪比SMITH高多少
SELECT a.a_sal, b.b_sal, a.a_sal - b.b_sal FROM 
(SELECT sal * 12 a_sal FROM emp WHERE ename = &#39;MILLER&#39;) a,
(SELECT sal * 12 b_sal FROM emp WHERE ename = &#39;SMITH&#39;) b

★★列出直接向King汇报的员工
SELECT * FROM emp
WHERE mgr = (SELECT empno FROM emp WHERE ename = &#39;KING&#39;)
#或
SELECT e.* FROM emp e, (SELECT empno FROM emp WHERE ename = &#39;KING&#39;) k
WHERE e.mgr = k.empno

★★列出公司所有员工的工龄，并倒序排列 
# NOW获取当前时间 
# SELECT DATE_FORMAT(date,format)   DATE_FORMAT只对日期形式的数据生效
SELECT * FROM(
    SELECT emp.*, DATE_FORMAT(NOW(),&quot;%Y&quot;) - DATE_FORMAT(hiredate,&quot;%Y&quot;) yg 
    FROM emp
)d 
ORDER BY d.yg DESC

★★计算管理者与基层员工平均薪资差额
SELECT a_avg - b_avg 
FROM
 (SELECT avg(sal) a_avg 
 FROM emp
 WHERE job = &#39;MANAGER&#39; OR job = &#39;PRESIDENT&#39;) a,
  (SELECT avg(sal) b_avg
  FROM emp
  WHERE job IN (&#39;CLERK&#39;,&#39;SALESMAN&#39;,&#39;ANALYST&#39;))b
</code></pre>
<h1 id="Java面试-——-主流框架"><a href="#Java面试-——-主流框架" class="headerlink" title="Java面试 —— 主流框架"></a>Java面试 —— 主流框架</h1><h3 id="谈谈你对IOC和DI的理解"><a href="#谈谈你对IOC和DI的理解" class="headerlink" title="谈谈你对IOC和DI的理解"></a>谈谈你对IOC和DI的理解</h3><ul>
<li><h6 id="IOC控制反转，设计理念，由第三方来管理与控制对象"><a href="#IOC控制反转，设计理念，由第三方来管理与控制对象" class="headerlink" title="IOC控制反转，设计理念，由第三方来管理与控制对象"></a>IOC控制反转，设计理念，由第三方来管理与控制对象</h6></li>
<li><h6 id="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"><a href="#DI依赖注入，具体实现，由对象容器在运行时动态注入对象" class="headerlink" title="DI依赖注入，具体实现，由对象容器在运行时动态注入对象"></a>DI依赖注入，具体实现，由对象容器在运行时动态注入对象</h6></li>
</ul>
<p>[<strong><u>DI是一种具体的技术实现，是对宏观IOC里面的一种技术上的形式，在Spring中使用了反射+工厂模式来实现DI</u></strong>]</p>
<pre><code class="java">IDAO dao = new UserDao(); //原始版本 原本的容器控制器

运行时Spring动态进行创建 对程序进行有效的解耦 //将控制权交给第三方控制容器  IOC容器
// applicationContext最底层是类工厂模式
IDAO dao = (IDAO)applicationContext.getBean(&quot;userDAO&quot;); //ICO容器 动态实例化DAO
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserDAO&quot;/&gt;
 &lt;bean id = &quot;userDAO&quot; class = &quot;com.imooc.dao.UserExtDAO&quot;/&gt; //方便随时更改
</code></pre>
<h3 id="Spring中Bean实例化有几种方式"><a href="#Spring中Bean实例化有几种方式" class="headerlink" title="Spring中Bean实例化有几种方式"></a>Spring中Bean实例化有几种方式</h3><ul>
<li>使用<strong>类构造器</strong>实例化</li>
<li>使用<strong>静态工厂方法</strong>实例化</li>
<li>使用<strong>实例工厂方法</strong>实例化</li>
</ul>
<pre><code class="java">com/example/text/spring/Person.java
package com.example.text.spring;

public class Person &#123;

    private String name;
    private Integer age;


    public Person() &#123;
        System.out.println(&quot;Person默认构造函数&quot;);
    &#125;

    public Person(String name, Integer age) &#123;
        this.name = name;
        this.age = age;

        System.out.println(&quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonStaticFactory.java
package com.example.text.spring;

/**
 * Person静态工厂
 */
public class PersonStaticFactory &#123;
    public static Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/spring/PersonFactory.java
package com.example.text.spring;

/**
 * Person实例工厂 实例化以后才可以调用
 */
public class PersonFactory &#123;
    public Person createPerson(String name,int age)&#123;
        return new Person(name,age);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">C:\Users\Pluminary\Desktop\text\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!--构造函数实例化--&gt;
    &lt;!-- 1.调用无参构造函数 --&gt;
    &lt;bean id=&quot;person1&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;&lt;/bean&gt;

    &lt;!-- 2.调用有参构造函数 --&gt;
    &lt;bean id=&quot;person2&quot; class=&quot;com.imooc.spring.instance.Person&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;枫叶(构造函数)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;23&quot;/&gt;
    &lt;/bean&gt;


    &lt;!-- 通过静态工厂创建对象--&gt;
    &lt;bean id=&quot;person3&quot; class=&quot;com.imooc.spring.instance.PersonStaticFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;蓝天(静态工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;27&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 通过实例工厂创建对象--&gt;
&lt;!-- 实例化PersonFactory--&gt;
    &lt;bean id=&quot;instanceFactory&quot; class=&quot;com.imooc.spring.instance.PersonFactory&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;person4&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;createPerson&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;绿地(实例工厂)&quot;/&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;29&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/example/text/Application.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
===================================================================
Person默认构造函数
Person&#123;name=&#39;枫叶(构造函数)&#39;,age=23&#125;
Person&#123;name=&#39;蓝天(静态工厂)&#39;,age=27&#125;
Person&#123;name=&#39;绿地(实例工厂)&#39;,age=29&#125;
</code></pre>
<h3 id="Bean注入属性有哪几种方式"><a href="#Bean注入属性有哪几种方式" class="headerlink" title="Bean注入属性有哪几种方式"></a>Bean注入属性有哪几种方式</h3><ul>
<li><h6 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h6></li>
<li><h6 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h6></li>
<li><h6 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h6></li>
<li><h6 id="Java-Config注入"><a href="#Java-Config注入" class="headerlink" title="Java Config注入"></a>Java Config注入</h6></li>
</ul>
<h6 id="setter注入-1"><a href="#setter注入-1" class="headerlink" title="setter注入"></a>setter注入</h6><blockquote>
<p>在UserService使用的时候依赖于UserDao，目前UserDao是空的，要想运行时通过setter方法注入的话，我们需要在injection.xml中<br>&lt;context:component-scan base-package&#x3D;”com.imooc.spring”&#x2F;&gt;<br><bean id="userDAO" class="com.imooc.spring.injection.UserDAOImpl"/><br><bean id="userService" class="com.imooc.spring.injection.UserService"><br>    <property name="userDAO" ref="userDAO"/><br>    <constructor-arg name="userDAO" ref="userDAO"/><br>前面的name&#x3D;”userDAO”对应着UserService.java中的userDAO属性 <code>private UserDAO userDAO</code><br>后面的ref&#x3D;”userDAO”对应着当前文件中的bean id &#x3D; “userDAO”<br></bean></p>
</blockquote>
<pre><code class="java">com/example/text/injection/UserDAO.java
package com.example.text.injection;

public interface UserDAO &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserDAOImpl.java
package com.example.text.injection;

import org.springframework.stereotype.Repository;

//@Repository(&quot;userDAO&quot;) ★注解方式注入
public class UserDAOImpl implements UserDAO&#123;
    public UserDAOImpl()&#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
    public void insert() &#123;
        System.out.println(this + &quot;:正在调用UserDAOImpl.insert()&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/injection/UserService.java
package com.example.text.injection;

import org.springframework.stereotype.Service;

import javax.annotation.Resource;

//@Service(&quot;userService&quot;) ★注解方式注入
//spring需要动态将userDao注入到UserService上
public class UserService &#123;
//  @Resource(name=&quot;userDAO&quot;)  注解方式注入 可以把原始的bean都注释掉
    private UserDAO userDAO;

    public UserService() &#123;
        System.out.println(this + &quot;已创建&quot;);
    &#125;
/* 注解方式这些可以抛弃 并且摒弃了xml的那些bean 只需要增加个扫描的注解方式注入
    //通过构造函数注入
    public UserService(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用构造函数注入，UserService(&quot; + userDAO + &quot;)&quot;);
    &#125;

    //通过Setter方法注入
    public void setUserDAO(UserDAO userDAO) &#123;
        this.userDAO = userDAO;
        System.out.println(this + &quot;:正在调用Setter方法注入，setUserDAO(&quot; + userDAO + &quot;)&quot;);
    &#125;
*/

    public void createUser()&#123;
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        userDAO.insert();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/example/text/InjectionRunner.java
package com.example.text;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class InjectionRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:injection.xml&quot;);
        UserService userService = (UserService)ctx.getBean(&quot;userService&quot;);
        userService.createUser();
    &#125;
&#125;

==============================================================
UserDAOImpl@531be3c5对象已创建
UserService@5034c75a对象已创建
UserService@5034c75a:正在调用Setter方法注入,setUserDAO
UserService@5034c75a:正在调用UserService.createUser()
UserDAOImpl@531be3c5:正在调用UserDAOImpl.insert()
</code></pre>
<pre><code class="java">C:\Users\Pluminary\Desktop\text\src\main\resources\injection.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.spring&quot;/&gt; //★扫描注解方式注入
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.injection.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.injection.UserService&quot;&gt;
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是setter注入
        &lt;constructor-arg name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt; //★这个是构造函数注入
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="Java-config注入"><a href="#Java-config注入" class="headerlink" title="Java config注入"></a>Java config注入</h6><pre><code class="java">Appconfig.java 
[配置文件 在原有代码之外的东西 优点：不用破坏原始代码去达到效果 比xml优点在于java可以及时检查]
package com.imooc.spring.injection;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig &#123; //类似创建对象的方法
    @Bean(name=&quot;userDAO&quot;)
    public UserDAO userDAO()&#123;
        return new UserDAOImpl();
    &#125;

    @Bean(name=&quot;userService&quot;)
    public UserService userService()&#123;
        UserService userService = new UserService();
        userService.setUserDAO(this.userDAO());
        return userService;
    &#125;
&#125;
</code></pre>
<h3 id="Spring常见面试问题"><a href="#Spring常见面试问题" class="headerlink" title="Spring常见面试问题"></a>Spring常见面试问题</h3><pre><code class="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDAO&quot; class=&quot;com.imooc.spring.scope.UserDAOImpl&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.scope.UserService&quot; scope=&quot;prototype&quot; lazy-init=&quot;false&quot;&gt;  
//scope是控制对象的数量是单例(singleton)还是多例(prototype)[每一次创建getbean创建对象]
//还有两个不常见的值 request[同一个对象是同一个请求 不同对象ICO容器创建不同对象] 和 
//session[调用多个getbean是同一个对象 不同session是不同对象] [SpringMVC时用]
        //lazy-init=&quot;true&quot; 延迟初始化 需要的时候才会加载 若getBean被注释则不会加载
        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ScopeRunner.java
package com.imooc.spring.scope;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScopeRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:scope.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        UserService userService2 = (UserService)ctx.getBean(&quot;userService&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDAO.java   UserDAOImpl.java   UserService.java 与上方相同
</code></pre>
<h6 id="两个注解"><a href="#两个注解" class="headerlink" title="两个注解"></a>两个注解</h6><p><code>@Autowired</code>[第三方] 和 <code>@Resource</code>[官方推荐]</p>
<blockquote>
<p>@Resource(name&#x3D;”userDAO”) &#x2F;&#x2F;设置了则进行精准匹配<br>private UserDAO userDAO;&#x2F;&#x2F;没设置则优先将名字userDAO在beanId内查找, 再没有就按照UserDAO类型在IOC容器中查找</p>
</blockquote>
<h3 id="AOP有几种通知类型"><a href="#AOP有几种通知类型" class="headerlink" title="AOP有几种通知类型"></a>AOP有几种通知类型</h3><h6 id="在不修改原始程序的前提下使用通知来对程序进行扩展"><a href="#在不修改原始程序的前提下使用通知来对程序进行扩展" class="headerlink" title="在不修改原始程序的前提下使用通知来对程序进行扩展"></a>在不修改原始程序的前提下使用通知来对程序进行扩展</h6><ul>
<li><h6 id="前置通知-Before"><a href="#前置通知-Before" class="headerlink" title="前置通知[Before]"></a>前置通知[Before]</h6></li>
<li><h6 id="返回通知-After-returning"><a href="#返回通知-After-returning" class="headerlink" title="返回通知[After returning]"></a>返回通知[After returning]</h6></li>
<li><h6 id="异常通知-After-throwing"><a href="#异常通知-After-throwing" class="headerlink" title="异常通知[After throwing]"></a>异常通知[After throwing]</h6></li>
<li><h6 id="后置通知-After"><a href="#后置通知-After" class="headerlink" title="后置通知[After]"></a>后置通知[After]</h6></li>
<li><h6 id="环绕通知-Around-统统实现"><a href="#环绕通知-Around-统统实现" class="headerlink" title="环绕通知[Around] (统统实现)"></a><span style = "color:red">环绕通知[Around]</span> (统统实现)</h6></li>
</ul>
<pre><code class="java">SampleAspect.java
package com.imooc.spring.aop;

import java.util.Date;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;

//切面类
public class SampleAspect &#123;
    
    //1.前置通知
    public void doBefore(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        Object args = jp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
    &#125;
    
    //2.后置通知
    public void doAfter(JoinPoint jp)&#123;
        String clzName = jp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = jp.getSignature().getName();//即将要执行的方法
        System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method );

    &#125;
    
    //3.返回通知
    public void doAfterReturning(JoinPoint jp , Object ret)&#123;
        System.out.println(&quot;【返回后通知】&quot; + ret);
        
    &#125;
    //4.异常通知
    public void doAfterThrowing(JoinPoint jp , Throwable t)&#123;
        System.out.println(&quot;【异常通知】&quot; + t.getMessage());
    &#125;

    //5.环绕通知
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable&#123;
        String clzName = pjp.getTarget().getClass().getName();
        //getTarget() 获取即将要执行的对象
        String method = pjp.getSignature().getName();//即将要执行的方法
        Object args = pjp.getArgs();
        System.out.println(&quot;【前置通知】&quot;  + clzName + &quot;.&quot; + method );
        Object ret = null;
        try &#123;
            ret = pjp.proceed();//执行目标方法
            System.out.println(&quot;【返回后通知】&quot; + ret);
        &#125; catch (Throwable t) &#123;
            // TODO Auto-generated catch block
            System.out.println(&quot;【异常通知】&quot; + t.getMessage());
            throw t;
        &#125;finally&#123;
            System.out.println(&quot;【后置通知】&quot;  + clzName + &quot;.&quot; + method + &quot;()&quot;);
        &#125;
        return ret;
    &#125;
    
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;

    public String createUser()&#123;
        //打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //提交事务
        //catch块中回滚事务 - RuntimeException
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">AOPRunner.java
package com.imooc.spring.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPRunner &#123;
    public static void main(String[] args) &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:aop.xml&quot;);
        UserService userService1 = (UserService)ctx.getBean(&quot;userService&quot;);
        userService1.createUser();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">aop.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/context
 http://www.springframework.org/schema/context/spring-context.xsd
 http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/aop
 http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 定义类被Spring IOC容器管理 --&gt;
    &lt;bean name=&quot;sampleAspect&quot; class=&quot;com.imooc.spring.aop.SampleAspect&quot;&gt;&lt;/bean&gt;
    &lt;bean name=&quot;userService&quot; class=&quot;com.imooc.spring.aop.UserService&quot;&gt;&lt;/bean&gt;
    &lt;!-- 配置Spring AOP --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置过程中引用切面类  sampleAspect是切面 扩展--&gt;
        &lt;aop:aspect ref=&quot;sampleAspect&quot;&gt;
            &lt;!-- PointCut(切点) 限制了切面应用的范围 ↓↓aop作用了哪些方法上↓↓--&gt;
            &lt;aop:pointcut id=&quot;samplePC&quot; expression=&quot;execution(* com.imooc.spring.aop.*Service.create*(..))&quot; /&gt;
            &lt;!-- 定义通知 --&gt;
            &lt;!-- 前置通知 method=对应着SampleAspect.java中的doBefore--&gt;
            &lt;aop:before pointcut-ref=&quot;samplePC&quot; method=&quot;doBefore&quot;/&gt;
            &lt;!-- 后置通知 --&gt;
            &lt;aop:after pointcut-ref=&quot;samplePC&quot; method=&quot;doAfter&quot;/&gt;
            &lt;!-- 返回后通知，注意：返回后通知需要增加retruning属性
            指向doAfterReturning的名为ret的参数，使用ret参数获取方法的返回值 --&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; pointcut-ref=&quot;samplePC&quot; returning=&quot;ret&quot;/&gt; 
&lt;!--3.ret是返回通知里面的参数 public void doAfterReturning(JoinPoint jp , Object ret)--&gt;
             &lt;!-- 异常通知 --&gt;
&lt;!--public void doAfterThrowing(JoinPoint jp , Throwable t)中的Throwable的参数是目标方法所抛出的异常  throwing=&quot;t&quot;相关噢~ --&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; pointcut-ref=&quot;samplePC&quot; throwing=&quot;t&quot;/&gt;
            --&gt;
            &lt;!-- ★★★★ 环绕通知 ★★★★ --&gt;
            &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;samplePC&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="请介绍Spring的声明式事务"><a href="#请介绍Spring的声明式事务" class="headerlink" title="请介绍Spring的声明式事务"></a>请介绍Spring的声明式事务</h3><p>Spring的声明式事务是Spring框架提供的一种管理事务的方法，它允许开发者通过声明的方式管理事务，而不是通过编写繁琐的事务管理代码。这种方式使得事务管理更加解耦，业务逻辑代码不需要直接处理事务的开启、提交、回滚等操作，从而使得代码更加简洁和易于维护。</p>
<ul>
<li>在执行方法前自动开启的事务</li>
<li>声明式事务式指利用AOP自动提交、回滚数据库事务</li>
<li>声明式事务式规则进入方法打开事务，成功提交，<strong>运行时异常</strong>回滚</li>
<li><code>@Transactional</code>是声明式事务的注解 放在类上则所有方法执行此事务 放在方法上则单独方法执行此事务</li>
<li>propagation &#x3D; 确定方法是否启动事务[Propagation.REQUIRED]执行的方法自动使用事务<br>rollbackFor &#x3D; Exception.class在什么时机进行回滚  readOnly &#x3D; true 方法只读</li>
<li>通过程序打开或关闭事务属于<strong>编程式事务</strong></li>
</ul>
<pre><code class="java">UserService.java
package com.imooc.spring.aop;

import com.imooc.spring.scope.UserDAO;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
//@Transactional(propagation = Propagation.REQUIRED , rollbackFor = Exception.class)
@Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true )
public class UserService &#123;
    public String createUser()&#123;
        //进入方法 → 打开事务
        System.out.println(this + &quot;:正在调用UserService.createUser()&quot;);
        //方法执行成功 → 提交事务
        
        //方法抛出运行时异常 → 回滚事务
        //catch块中回滚事务 - RuntimeException[及其子类会自动回滚]
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="使用SpringMVC实现REST风格"><a href="#使用SpringMVC实现REST风格" class="headerlink" title="使用SpringMVC实现REST风格"></a>使用SpringMVC实现REST风格</h3><ul>
<li>REST(表述性状态传递)以URL表示要访问的资源</li>
<li><strong>GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</strong>对应<strong>查询、新增、更新、删除</strong>操作[浏览器不支持PUT和DELETE操作]<br><span style = "color:red"><strong>[用GET对应查询操作(写)、用POST对应新增、更新、删除操作(写)]</strong></span></li>
<li><u>REST风格<strong>只响应的数据</strong>，通常是以JSON形式体现</u></li>
</ul>
<p>以下是一些常用的HTTP方法及其在REST中的用途：</p>
<ul>
<li><strong>GET</strong>：检索资源的表示。</li>
<li><strong>POST</strong>：创建新的资源或子资源。</li>
<li><strong>PUT</strong>：更新或替换资源。</li>
<li><strong>DELETE</strong>：删除资源。</li>
</ul>
<p>REST风格的API通常被称为RESTful API，它们通过使用标准的HTTP方法、状态代码和URI来提供一种简单、一致和可预测的方式来访问和操作网络资源。RESTful API的设计通常遵循一些最佳实践，比如使用名词而不是动词来命名资源，使用HTTP状态码来传达操作的结果等。</p>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.54&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">interview-springmvc\src\main\resources\applicationContext.xml
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- 配置扫描的包 --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.interview&quot;/&gt;
    &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 开启注解模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.rest;

public class Employee &#123;
    private String name;
    private int age;
    private String department;

    public Employee(String name, int age, String department) &#123;
        this.name = name;
        this.age = age;
        this.department = department;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public String getDepartment() &#123;
        return department;
    &#125;

    public void setDepartment(String department) &#123;
        this.department = department;
    &#125;
&#125;
</code></pre>
<pre><code class="java">RestfulController.java
package com.imooc.interview.rest;

import com.alibaba.fastjson.JSON;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
@Controller //在IOC容器初始化的情况下自动扫描这个类进行加载并且通知IOC容器 这个是一个MVC中的控制类
//@RestController
public class RestfulController &#123; //&#123;XXX&#125;是路径变量 随时产生变化的 注解@PathVariable(&quot;DEPT&quot;)
    @GetMapping(&quot;/emp/list/&#123;DEPT&#125;&quot;) //响应GET请求 前面的是响应URL输入这个的时候响应下面的方法
    @ResponseBody
    public String list(@PathVariable(&quot;DEPT&quot;) String department) &#123;
        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
        if (department.equals(&quot;RESEARCH&quot;)) &#123;
            list.add(new Employee(&quot;JAMES&quot;, 38, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;ANDY&quot;, 23, &quot;RESEARCH&quot;));
            list.add(new Employee(&quot;SMITH&quot;, 31, &quot;RESEARCH&quot;));
        &#125;
        return JSON.toJSONString(list);//只返回纯粹的JSON数据 只返回页面名称
        //如何只返回数据不跳转页面呢？ 用 @RespondBoday 直接将返回的数据输出到客户端
//但是可以简化使用 @RestController 所有的可以直接不用写 @RespondBoday
    &#125;
&#125;//前端使用AJAX技术接收数据
</code></pre>
<h3 id="请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术"><a href="#请说明SpringMVC拦截器的作用-底层就是AOP面向切面编程技术" class="headerlink" title="请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]"></a>请说明SpringMVC拦截器的作用 [底层就是AOP面向切面编程技术]</h3><ul>
<li>SpringMVC拦截器用于对控制器方法进行前置、后置处理</li>
<li>拦截器的底层实现技术是AOP(面向切面编程)</li>
<li>拦截器必须实现HandlerInterceptor接口</li>
</ul>
<pre><code class="java">★★ 上一个代码通用 ★★
interview-springmvc\src\main\java\com\imooc\interview\rest\MyInterceptor.java
package com.imooc.interview.rest;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.logging.Logger;

public class MyInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(&quot;进入 preHandle 方法...&quot; + request.getRequestURL().toString());
        return true;
    &#125;
 

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;进入 postHandle 方法...&quot; + request.getRequestURL().toString());
    &#125;
 

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;进入 afterCompletion 方法...&quot; + request.getRequestURL().toString());
    &#125;
&#125;
====================================================================================
查看上面的applicationContext.xml
&lt;bean&gt;
&lt;!-- 访问静态资源 --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt; //所有URL不分层级和格式
            &lt;bean class=&quot;com.imooc.interview.rest.MyInterceptor&quot;/&gt; 
            //对上面这个类进行处理和拦截
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/bfd26ff021aa3755cfc43c62bfa86e0b3ef77144/data/SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg"></p>
<h3 id="说明Mybatis的开发过程"><a href="#说明Mybatis的开发过程" class="headerlink" title="说明Mybatis的开发过程"></a>说明Mybatis的开发过程</h3><blockquote>
<p>案例沿用之前的scott.sql表</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
             
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;interview-mybatis&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.46&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">mybatis.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot; /&gt;
            &lt;!-- 配置数据库连接信息 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--数据库连接池的方式--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/scott&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">Employee.java
package com.imooc.interview.mybatis.entity;

import java.io.Serializable;
import java.util.Date;

public class Employee implements Serializable &#123;
    private Integer empno;
    private String ename;
    private String job;
    private Integer mgr;
    private Date hiredate;
    private Float sal;
    private Float comm;
    private Integer deptno;
&#125;Getter + Setter
</code></pre>
<pre><code class="xml">用于查询的配置文件 emp.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!-- 命名空间是个虚拟的类 --&gt;
&lt;mapper namespace=&quot;com.imooc.interview.mybatis.mapper.EmpMapper&quot;&gt; 
    &lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
        select * from emp
    &lt;/select&gt;
&lt;!-- 类型是int 把传入的int代入到#&#123;value&#125;中 --&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; 
            resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;true&quot;&gt;
        select * from emp where empno = #&#123;value&#125;
&lt;!--查询数据 根据数据自动创建Employee对象 根据字段名把值一一的设置到属性中--&gt;
&lt;!--记得写完以后再mybatis.xml中注册 通知mybatis 有个&lt;mapper resource=&quot;mapper/emp.xml&quot;&gt;--&gt;
&lt;!--至此mybatis的配置全部完成 --&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">MybatisRunner.java
package com.imooc.interview.mybatis.entity;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.InputStream;

public class MybatisRunner &#123;
    public static void main(String[] args) &#123;
        //mybatis的配置文件 核心配置文件↓
        String resource = &quot;mybatis.xml&quot;;
        InputStream is = MybatisRunner.class.getClassLoader().getResourceAsStream(resource);
        //构建sqlSession的工厂(对Mybatis进行解析)  build(is)是初始化
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);
//com.imooc.interview.mybatis.mapper.EmpMapper前面是命名空间
        //.findById对应着select的Id
        String statement = &quot;com.imooc.interview.mybatis.mapper.EmpMapper.findById&quot;;
        SqlSession session = sessionFactory.openSession();
//selectOne获取唯一的查询结果  之前定义了要传入整数int
        Employee emp1 = session.selectOne(statement, 7566);
        System.out.println(emp1);
        session.close();
    &#125;
&#125;
</code></pre>
<h3 id="Mybatis的缓存机制"><a href="#Mybatis的缓存机制" class="headerlink" title="Mybatis的缓存机制"></a>Mybatis的缓存机制</h3><h6 id="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"><a href="#把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率" class="headerlink" title="把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率"></a>把一些不太常变动的数据保存在内存中或高速存储器中，从而降低查询时间提高查询效率</h6><ul>
<li><p>Mybatis存在两级缓存</p>
<ul>
<li><p>一级缓存与SqlSession会话绑定，默认开启 [巨大的HashMap] [默认开启]</p>
</li>
<li><p>二级缓存是应用全局缓存，所有SqlSession共享 [分布式数据库等]</p>
</li>
</ul>
</li>
</ul>
<pre><code class="java">//一级缓存验证结果
Employee emp1 = session.selectOne(statement, 7566);
Employee emp2 = session.selectOne(statement, 7566);
System.out.println(emp1);
System.out.println(emp2);
======================打印结果========================
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
com.imooc.interview.mybatis.entity.Employee@6a41eaa2
从缓存中将这个7566提出来，所以对象是一样的
随着session的关闭 → session.close(); 一级缓存也随着消失; 输出的对象结果就不相同了
</code></pre>
<pre><code class="java">//二级缓存验证结果  让7566全局缓存 默认是不开启的 需要在mapper中开启 → emp.xml
//在缓存中最大容纳512个对象 缓存多余清除策略[FIFO先进先出算法 LRU访问最少的对象清除] 
//flushInterval=&gt;时间间隔定时清理缓存[毫秒数 每60秒]
&lt;cache size=&quot;512&quot; eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; readOnly=&quot;true&quot;/&gt;
//若对全部查找 则不适合使用缓存 因为每次都变化 这样就可以设置useCache=&quot;false&quot;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.imooc.interview.mybatis.entity.Employee&quot; useCache=&quot;false&quot;&gt;
//对数据进行新增、修改、删除也会对缓存进行强制更新 上面设置 readOnly=&quot;true&quot; 保存在缓存中的数据都是只读的
//二级缓存要对工具类Employee进行接口的实现
public class Employee implements Serializable &#123;...&#125;
</code></pre>
<h3 id="Spring、SpringMVC与SpringBoot的区别"><a href="#Spring、SpringMVC与SpringBoot的区别" class="headerlink" title="Spring、SpringMVC与SpringBoot的区别"></a>Spring、SpringMVC与SpringBoot的区别</h3><ul>
<li>Spring是所有应用的基础，提供了IOC与AOP特性实现对对象轻松的管理</li>
<li>SpringMVC是Spring的子项目用于提供Web支持 替代传统的Servlet [<u>提高兼容性和可维护性</u>]</li>
<li>SpringBoot是Spring体系的敏捷开发框架，提高了开发效率 [<u>对Spring整个体系都有良好的支撑</u>]<ul>
<li>Spring Framework是整个Spring的框架基础</li>
<li>Spring Cloud对分布式架构与微服务提供了良好的支持</li>
<li>Spring Data简化关系型数据库 非关系型数据库 大数据源</li>
<li>Spring Batch提供高效率的批处理任务</li>
<li>Spring Security超级牛逼的安全框架 登录验证之类的</li>
<li>Spring Amqp消息队列进行支持 统一的接口进行适配</li>
<li>Spring Mobile手机开发特性</li>
</ul>
</li>
</ul>
<h3 id="SpringBoot面试题"><a href="#SpringBoot面试题" class="headerlink" title="SpringBoot面试题"></a>SpringBoot面试题</h3><ul>
<li><p>Spring Initializr是创建SpringBoot Project的唯一方法吗？</p>
<blockquote>
<p>否！也可以用Maven进行手动创建，也可以官网创建</p>
</blockquote>
</li>
<li><p>SpringBoot支持几种配置文件？</p>
<blockquote>
<p>只有两种</p>
<pre><code class="xml">一种
server.port=80
debug=false
server.servlet.context-path=/myspringboot
logging.file=d:/logs/msb.log
spring.mvc.date-format=yyyy-MM-dd
</code></pre>
<pre><code class="xml">二种 [按层级进行区分 yml 对程序维护有很大帮助]
debug:false
server:
  port:8000
  servlet:
    context-path:/
spring:
  mvc:
    date-format:yyyy-MM-dd
</code></pre>
</blockquote>
</li>
<li><p>请列举至少五个SpringBoot中配置选项</p>
<table>
<thead>
<tr>
<th>配置名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>server.port</td>
<td>8080</td>
<td>端口号</td>
</tr>
<tr>
<td>server.servlet.context-path</td>
<td>&#x2F;</td>
<td>设置应用上下文</td>
</tr>
<tr>
<td>logging.file</td>
<td>无</td>
<td>日志文件输出路径</td>
</tr>
<tr>
<td>logging.level</td>
<td>info</td>
<td>最低日志输出级别</td>
</tr>
<tr>
<td>debug</td>
<td>false</td>
<td>开启&#x2F;关闭调试模式</td>
</tr>
<tr>
<td>spring.datasource.*</td>
<td></td>
<td>与数据库相关的设置</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Maven的构建生命周期"><a href="#Maven的构建生命周期" class="headerlink" title="Maven的构建生命周期"></a>Maven的构建生命周期</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mvn archetype:generate</td>
<td align="center">创建Maven工程构建</td>
</tr>
<tr>
<td align="center">mvn validate</td>
<td align="center">验证工程结构</td>
</tr>
<tr>
<td align="center">mvn compile</td>
<td align="center">编译源代码</td>
</tr>
<tr>
<td align="center">mvn test</td>
<td align="center">执行测试用例</td>
</tr>
<tr>
<td align="center">mvn package</td>
<td align="center">项目打包</td>
</tr>
<tr>
<td align="center">mvn install</td>
<td align="center">安装至本地仓库</td>
</tr>
<tr>
<td align="center">mvn deploy</td>
<td align="center">发布至远程仓库</td>
</tr>
</tbody></table>
<h3 id="请简述一下Java反射的作用和原理"><a href="#请简述一下Java反射的作用和原理" class="headerlink" title="请简述一下Java反射的作用和原理"></a>请简述一下Java反射的作用和原理</h3><p><strong>作用：</strong><br>Java反射(Reflection)允许程序在运行时检查和操作类、接口、字段和方法的信息<br>① 动态获取类的信息：获取类的名称、父类、实现的接口等；获取类的构造方法、字段和方法的信息<br>② 动态创建和访问对象：创建类的实例；访问和修改对象的字段；调用对象的方法<br>③ 动态调用方法：调用私有方法、静态方法、实例方法等；传递参数和处理返回值<br>④ 动态代理：创建动态代理类，实现接口和动态代理</p>
<p><strong>原理：</strong><br>① 获取Class对象：<br>   Ⅰ. 通过类名获取：Class.forName(“类的路径”)；<br>  Ⅱ. 通过类字面常量获取：类名.class；<br> Ⅲ. 通过对象获取：对象名.getClass();<br>② 获取类的信息：<br>   Ⅰ. 获取类名：类名.getName;<br>  Ⅱ. 获取父名：类名.getSuperclass();<br> Ⅲ. 获取实现的接口：类名.getInterfaces();<br> Ⅳ. 获取构造方法：类名.getConstructors();<br>  Ⅴ. 获取字段：类名.getFields();<br> Ⅵ. 获取方法：类名.getMethods();</p>
<p><strong>优点和缺点</strong>：<br>优点：能够运行时动态获取类的实例，提高灵活性；与动态编译结合<br>缺点：使用反射性能较低，需要解析字节码，将内存中的对象进行解析<br>  解决办法→通过setAccessible(true)关闭JDK的安全检查来提升反射速度；多次创建一个类的实例时有缓存会快很多</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>；；；；；；；；；；；；；；；；；；；；<strong>洪哥面试题分隔符</strong>；；；；；；；；；；；；；；；；；；；；；；</p>
<h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.继承Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.实现Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。<br>3.实现 Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。<br>4.使用线程池创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li>异步任务处理：将任务提交到线程池异步执行，而不阻塞主线程</li>
</ul>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在URL之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，敏感数据不应通过过GET请求发送</li>
<li>URL长度限制通常在2000个字符左右，这意味着GET请求能够传输的数据有限</li>
<li>可以被缓存，也会被浏览器保存在历史记录中</li>
<li>常用于信息查询、数据检索等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上没有大小限制，适用于传输大量数据.</li>
<li>不会被缓存，且不会保存在浏觉器历史记录中</li>
<li>常用于数据提交、表单提交等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br>发展前景？表明上家公司不好<br>太想进步？表名上家公司提供的技术不好 自己技术不好<br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据属性名称去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据属性类型去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和@Autowired类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> 不可多个方法都加@Autowired  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
</li>
<li><p><strong>普通方法注入</strong></p>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时且数组长度大于64时，将链表转化为红黑树，以减少搜索时间。扩容 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对数组长度取模 eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcde值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是hash冲突  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单项链表[linkedlist才是双向链表]。拉链法的解决哈希冲突。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高，</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p>底层是包装了一个hashmap，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。计算hashcode会比equals更快，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，所以先判断hashcode 再判断equals   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个 ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用ConcurrentHashMap、Collections.synchronizedMap()、<strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>hashtable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了ConcurrentHashMap读不加锁 写加锁。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是log(n)<br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>bash</p>
<p>复制</p>
<pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p>WebSocket【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component<br>定义切点 <code>@Pointcut</code> 声明切点表达式</p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.BigDecimal</p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

    @Autowired
    private MyService self; // 注入自身代理实例

    public void methodA() &#123;
        // ... 业务逻辑 ...

        self.methodB(); // 通过代理实例调用，事务注解将生效
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() &#123;
        // ... 业务逻辑 ...
    &#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><ul>
<li><strong>String</strong>：存储对象信息(转JSON)、</li>
<li><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构</li>
<li><strong>Hash</strong>：获取局部属性，小key不能设置过期时间</li>
<li><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)</li>
<li><strong>Zset</strong>：排序场景，排行榜，姓名排序</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除</li>
<li>定时删除：设置键的过期时间，当键过期时，立即删除</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br> [商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p>try catch 在里面继续再去查mysql数据库</p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中</p>
<ul>
<li><h6 id="JDK动态代理是基于接口实现来实现增强"><a href="#JDK动态代理是基于接口实现来实现增强" class="headerlink" title="JDK动态代理是基于接口实现来实现增强"></a>JDK动态代理是基于接口实现来实现增强</h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是基于继承目标类并覆写其方法来实现</h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的代理类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，有一些简单的需求是没有的[沟通成本太高了]<br>稍微复杂的需求会有需求文档，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当参数是用户输入时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会自动转义参数。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
</ul>
<h4 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚这个技术是解决什么领域的问题，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h2><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);
            getData(&quot;t1&quot;);
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);
            getData(&quot;t2&quot;);
        &#125;, &quot;t1&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p>成员变量是在jvm的堆<br>局部变量是在jvm的栈<br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行代码审查，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行单元测试，确保代码的功能正确无误。</li>
<li>进行代码优化，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，它将现实世界的事物抽象成程序中的对象。Java面向对象的主要特征包括：</p>
<ul>
<li>封装：将对象的属性和行为封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li>继承：允许子类继承父类的属性和行为，实现代码的复用。</li>
<li>多态：同一个接口可以有多个不同的实现，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较基本数据类型时，比较的是值；比较引用数据类型时，比较的是对象的内存地址。</li>
<li>equals：是Object类的一个方法，默认比较的是对象的内存地址。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：读多写少 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：写多读少 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br>**<u>工厂模式</u>**：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过递归调用来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><p>第一个是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br>第二个是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br>第三个是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。<br>第四个是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁</p>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p>insert不带查询筛选条件  上行锁<del>底层是索引，b+树底层叶子</del><br>update看where后面的条件 带索引加行锁<del>构建b+树</del> 不带索引的加表锁<br>表锁的速度比行锁速度快</p>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的基本数据类型和引用类型地址，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于启动一个新线程，并执行该线程的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并不会启动一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程暂停执行并释放当前对象上的锁，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是基于内存的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持数据持久化，可以将内存中的数据保存到磁盘中，防止数据丢失。<br><strong>分布式</strong>：Redis支持主从复制、哨兵和集群模式，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，服务消费者，注册中心，服务提供者提供者在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务，默认为轮询，还有加权轮询，随机。同时服务消费者还会定时去注册中心拉取服务提供者的信息如果我们的服务挂掉了怎么办?<br>服务提供者会每隔一段时间去向注册中心报告自己的状态，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><strong>公平锁</strong>：多个线程按照它们请求锁的顺序来获取锁，先来先得。这种方式不会产生饥饿现象，但可能会降低吞吐量，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></li>
<li><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></li>
</ul>
<p>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持<br>Synchronized 公平锁</p>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java 动态代理技术，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证可见性和有序性。</p>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的<br>定义了一个并发情况下一些抽象的资源 资源能否共享&#x2F;独享 定义了公平和非公平<br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于重量级锁，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p>一段很长的时间内都只被一个线程使用锁 <strong>偏向锁</strong><br>有线程交替或线程加锁的时间是错开的 <strong>轻量级锁</strong><br>有很多线程来抢 <strong>重量级锁</strong></p>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是用对象头找个地方存一把锁，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(自旋锁64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以自动加锁和解锁，而 <code>ReentrantLock</code> 需要手动加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方，分别锁的是什么"><a href="#synchronized可以作用在哪些地方，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方，分别锁的是什么"></a>synchronized可以作用在哪些地方，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/03/28/面试/Java面试/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/">
        <h2>
            SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/2/28
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-Boot电商项目入门与实战"><a href="#Spring-Boot电商项目入门与实战" class="headerlink" title="Spring Boot电商项目入门与实战"></a>Spring Boot电商项目入门与实战</h1><ul>
<li>重量级的电商项目，前后端彻底分离</li>
<li>体验企业级开发流程：需求分析、设计、编码、测试、上线</li>
<li>用户管理、商品分析、商品管理、购物车、订单等核心功能</li>
<li>数据库的设计与实现</li>
<li>应用<strong>RESTful</strong>进行接口设计，并使用<strong>Postman</strong>进行接口测试</li>
<li>应用<strong>MyBatis generator</strong>代码自动生成插件，提升开发效率</li>
<li>使用阿里云完成项目的线上部署</li>
<li>使用<strong>Swagger2</strong>构建强大的API文档</li>
<li>使用<strong>Redis</strong>对商品分类信息进行缓存</li>
<li>使用<strong>JSR-303</strong>实现请求参数校验</li>
</ul>
<h2 id="Spring-Boot入门"><a href="#Spring-Boot入门" class="headerlink" title="Spring Boot入门"></a>Spring Boot入门</h2><h5 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h5><ul>
<li>Java 1.8.0</li>
<li>MySQL 8.0.12</li>
<li>Maven 3.3.9</li>
<li>Spring Boot 2.2.1(严格一致)</li>
</ul>
<h3 id="Spring-Boot诞生历史"><a href="#Spring-Boot诞生历史" class="headerlink" title="Spring Boot诞生历史"></a>Spring Boot诞生历史</h3><ul>
<li>Spring的缺点：配置过于繁琐</li>
<li>Spring Boot开发团队：Pivotal</li>
</ul>
<h3 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h3><ul>
<li>简化初始搭建以及开发过程</li>
<li>不再需要定义样板化的配置</li>
<li>快速应用开发领域</li>
</ul>
<h3 id="Spring、Spring-MVC、Spring-Boot"><a href="#Spring、Spring-MVC、Spring-Boot" class="headerlink" title="Spring、Spring MVC、Spring Boot"></a>Spring、Spring MVC、Spring Boot</h3><ul>
<li><strong>Spring</strong>最初利用IOC和AOP解耦</li>
<li>按照这种模式搞了MVC框架</li>
<li>写很多样板代码很麻烦，就有了<strong>Spring Boot</strong></li>
<li><strong>Spring Cloud</strong>是在Spring Boot基础上</li>
</ul>
<h3 id="Spring-Boot核心特点"><a href="#Spring-Boot核心特点" class="headerlink" title="Spring Boot核心特点"></a>Spring Boot核心特点</h3><ul>
<li>开箱即用</li>
<li>约定优于配置</li>
</ul>
<h3 id="Spring-Boot版本介绍"><a href="#Spring-Boot版本介绍" class="headerlink" title="Spring Boot版本介绍"></a>Spring Boot版本介绍</h3><ul>
<li>CURRENT             2.2.1 CURRENT GA [最新版本]</li>
<li>GA                         2.2.2 SNAPSHOT [GA&#x3D;General Availability 面向大众稳定版本 版本永恒不变]</li>
<li>SNAPSHOT          2.1.11 SNAPSHOT [快照 版本随时被修改]</li>
<li>如何选择版本？   <strong>2.1.10 GA</strong></li>
</ul>
<h3 id="新建Spring-Boot项目演示"><a href="#新建Spring-Boot项目演示" class="headerlink" title="新建Spring Boot项目演示"></a>新建Spring Boot项目演示</h3><ul>
<li>Spring官网 <strong><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a></strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/c9c72f61bc8fdb6d207a1221c3e2fb6ed9dcad81/data/%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA.jpg"></p>
<ul>
<li>IDEA集成的Spring Initializr</li>
</ul>
<h3 id="第一个接口开发"><a href="#第一个接口开发" class="headerlink" title="第一个接口开发"></a>第一个接口开发</h3><pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootlearnApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示各种传参形式
 */
@RestController
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest()&#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;SpringBootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="多种配置URL的方式"><a href="#多种配置URL的方式" class="headerlink" title="多种配置URL的方式"></a>多种配置URL的方式</h3><pre><code class="java">com/imooc/springbootlearn/ParaController.java
package com.imooc.springbootlearn;

import org.springframework.web.bind.annotation.*;

/**
 * 演示各种传参形式
 */
@RestController
@RequestMapping(&quot;/prefix&quot;)//统一增加公共前缀
public class ParaController &#123;
    @GetMapping(&#123;&quot;/firstrequest&quot;&#125;)
    public String firstRequest() &#123;
        return &quot;第一个Spring Boot接口&quot;;
    &#125;

    //@RequestParam 从请求中找到这个参数进行绑定
    @GetMapping(&#123;&quot;/requestpara&quot;&#125;)
    public String requestpara(@RequestParam Integer num) &#123;
        return &quot;para from request: &quot; + num;
    &#125;

    //@PathVariable 从URL中寻找对应的参数进行绑定
    @GetMapping(&#123;&quot;/para/&#123;num&#125;&quot;&#125;)
    public String pathpara(@PathVariable Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //多URL的用法
    @GetMapping(&#123;&quot;/multiurl1&quot;, &quot;/multiurl2&quot;&#125;)
    public String multiurl(@RequestParam Integer num) &#123;
        return &quot;para from path: &quot; + num;
    &#125;

    //增加程序健壮性 不一定必须传值
    @GetMapping(&#123;&quot;/required&quot;&#125;)
    public String required(@RequestParam(required =
            false, defaultValue = &quot;0&quot;) Integer num) &#123;
        return &quot;para form request: &quot; + num;
    &#125;
&#125;
</code></pre>
<h3 id="Web项目的三层结构"><a href="#Web项目的三层结构" class="headerlink" title="Web项目的三层结构"></a>Web项目的三层结构</h3><ul>
<li><strong>Controller职责</strong>：对外暴露接口</li>
<li><strong>Service职责</strong>：复杂业务场景下对业务逻辑做一层抽象和封装，保持Controller的简洁和独立，抽象出来的Service可以被Controller重复调用。具体业务代码写在service层，Controller只做简单的逻辑判断</li>
<li><strong>DAO层职责</strong>：和数据相关的、增删改查数据库代码</li>
</ul>
<h3 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h3><ul>
<li><p><strong>properties</strong>：容器端口名、数据库信息、日志级别…</p>
<ul>
<li>environments.dev.url&#x3D;<a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>environments.dev.name&#x3D;Developer</li>
</ul>
</li>
<li><p><strong>yml</strong>：分层级，冒号后需要空格</p>
<ul>
<li>enviroments:<ul>
<li>dev:<ul>
<li>url: <a target="_blank" rel="noopener" href="http://imooc.com/">http://imooc.com</a></li>
<li>name: Developer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以自动转换的网址：<a target="_blank" rel="noopener" href="https://www.toyaml.com/">在线yaml转properties-在线properties转yaml-ToYaml.com</a></p>
<pre><code class="java">Properties:
server.port=8081
server.servlet.context-path=/first
============================================================
YAML:
server:
  port: 8081
  servlet:
    context-path: /first
</code></pre>
<h3 id="进行自定义配置"><a href="#进行自定义配置" class="headerlink" title="进行自定义配置"></a>进行自定义配置</h3><p><strong>注解类</strong>配置载入数据[利用@Value注解]</p>
<pre><code class="java">com/imooc/springbootlearn/PropertiesController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 演示读取配置的Controller
 */
@RestController
public class PropertiesController &#123;
    //用@Value将properties的设置值进行绑定
    @Value(&quot;$&#123;school.grade&#125;&quot;)
    Integer grade;
    @Value(&quot;$&#123;school.classnum&#125;&quot;)
    Integer classnum;
    @GetMapping(&quot;/gradeclass&quot;)
    public String gradeClass()&#123;
        return &quot;年级： &quot; + grade + &quot; 班级：&quot; + classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">resoources/application.properties
#server.port=8081
##对于整个项目建立统一的前缀 http://127.0.0.1:8081/first/prefix/required
#server.servlet.context-path=/first
#school.方便分类
school.grade=3
school.classnum=6
</code></pre>
<p><strong>配置类</strong>文件配置载入数据</p>
<pre><code class="java">com/imooc/springbootlearn/SchoolConfig.java
package com.imooc.springbootlearn;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * School配置类
 */
@Component
@ConfigurationProperties(prefix = &quot;school&quot;)
public class SchoolConfig &#123;
    //自动去配置信息里寻找且绑定
    Integer grade;
    Integer classnum;

    public Integer getGrade() &#123;
        return grade;
    &#125;

    public void setGrade(Integer grade) &#123;
        this.grade = grade;
    &#125;

    public Integer getClassnum() &#123;
        return classnum;
    &#125;

    public void setClassnum(Integer classnum) &#123;
        this.classnum = classnum;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/ConfigController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * 读取配置类
 */
@RestController
public class ConfigController &#123;
    @Autowired
    SchoolConfig schoolConfig;
    @GetMapping(&#123;&quot;/gradefromconfig&quot;&#125;)
    public String gradeclass()&#123;
        return &quot;年级： &quot; + schoolConfig.grade + &quot; 班级：&quot; + schoolConfig.classnum;

    &#125;
&#125;
</code></pre>
<h3 id="Service和Dao的编写"><a href="#Service和Dao的编写" class="headerlink" title="Service和Dao的编写"></a>Service和Dao的编写</h3><ul>
<li><h5 id="学生信息查询案例"><a href="#学生信息查询案例" class="headerlink" title="学生信息查询案例"></a>学生信息查询案例</h5></li>
</ul>
<pre><code class="java">com/imooc/springbootlearn/Student.java
package com.imooc.springbootlearn;

/**
 * 学生实体类
 */
public class Student &#123;
    Integer id;
    String name;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentController.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 学生Controller
 */
@RestController
public class StudentController &#123;
    @Autowired
    StudentService studentService;
    //服务层 去中转

    @GetMapping(&quot;/student&quot;)
    public String student(@RequestParam Integer num)&#123;
        Student student = studentService.findStudent(num);
        return student.toString();
    &#125;
&#125;
/*
联系
@Autowired和@Resource注解都是作为bean对象注入的时候使用的
两者都可以声明在字段和setter方法上
注意：如果声明在字段上，那么就不需要再写setter方法。但是本质上，该对象还是作为set方法的实参，通过执行set方法注入，只是省略了setter方法罢了

区别
@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的
@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入
@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错
*/
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentService.java
package com.imooc.springbootlearn;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 学生Service  之后调用mapper操作数据库[interface]
 */
@Service
public class StudentService &#123;
    @Autowired
    StudentMapper studentMapper;

    public Student findStudent(Integer id)&#123;
        return studentMapper.findById(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/StudentMapper.java 【接口】
package com.imooc.springbootlearn;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

/**
 * 学生Mapper
 */
@Mapper
@Repository
public interface StudentMapper &#123;
    @Select(&quot;select * from students where id = #&#123;id&#125;&quot;)
    Student findById(Integer id);
&#125;
</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;springbootlearn&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;SpringBootlearn&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">com/imooc/springbootlearn/SpringBootlearnApplication.java
package com.imooc.springbootlearn;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication(scanBasePackages=&quot;com.imooc&quot;)
public class SpringBootlearnApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBootlearnApplication.class, args);
    &#125;

&#125;
</code></pre>
<pre><code class="java">application.properties
#server.port=8081
#server.servlet.context-path=/first
school.grade=10
school.classnum=6

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<hr>
<hr>
<h1 id="SpringBoot电商项目"><a href="#SpringBoot电商项目" class="headerlink" title="SpringBoot电商项目"></a>SpringBoot电商项目</h1><p><a target="_blank" rel="noopener" href="http://127.0.0.1:8083/#/index">慕慕生鲜前台</a><br><a target="_blank" rel="noopener" href="http://127.0.0.1:8083//admin/index.html#/login">慕慕生鲜后台</a></p>
<h3 id="课程整体介绍"><a href="#课程整体介绍" class="headerlink" title="课程整体介绍"></a>课程整体介绍</h3><ul>
<li>为什么要做电商项目</li>
<li>项目亮点以及功能模块介绍</li>
<li>项目演示</li>
<li>项目开发所需要工具准备</li>
<li>数据库设计与项目初始化</li>
<li>功能模块开发</li>
<li>阿里云部署</li>
<li>项目总结</li>
</ul>
<h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ul>
<li>最新的业界的互联网企业的优质技术</li>
<li>代码规范简介，充分优化</li>
<li>流程完整、电商功能丰富</li>
<li>前后端彻底分离，符合未来趋势，学了就能用</li>
</ul>
<h3 id="功能模块介绍"><a href="#功能模块介绍" class="headerlink" title="功能模块介绍"></a>功能模块介绍</h3><ul>
<li><h4 id="项目功能："><a href="#项目功能：" class="headerlink" title="项目功能："></a>项目功能：</h4><ul>
<li><h5 id="前台-用户、商品分类、商品信息、购物车、订单"><a href="#前台-用户、商品分类、商品信息、购物车、订单" class="headerlink" title="前台  {用户、商品分类、商品信息、购物车、订单}"></a><span style = "color:red">前台  {用户、商品分类、商品信息、购物车、订单}</span></h5><ul>
<li><strong>用户模块</strong>{注册、登录、更新签名、身份认证、登出}</li>
<li><strong>商品分类模块</strong>{多级目录、递归查询、缓存}</li>
<li><strong>商品模块</strong>{商品搜索、商品排序、商品列表、目录展示、商品详情}</li>
<li><strong>购物车模块</strong>{加入商品、列表显示、数量更改、删除商品、勾选反选、全选全不选}</li>
<li><strong>订单模块</strong>{下单、订单流程、订单详情、取消订单、支付二维码、扫码支付、个人订单、确认收货}</li>
</ul>
</li>
<li><h5 id="后台-用户、商品分类、商品信息、订单"><a href="#后台-用户、商品分类、商品信息、订单" class="headerlink" title="后台  {用户、商品分类、商品信息、订单}"></a><span style = "color:red">后台  {用户、商品分类、商品信息、订单}</span></h5><ul>
<li><strong>管理员模块</strong>{登录登出、身份认证、安全限制}</li>
<li><strong>商品分类模块</strong>{分类列表、增加分类、修改分类、删除分类}</li>
<li><strong>商品模块</strong>{商品列表、新增商品、图片上传、更新删除、批量上下架}</li>
<li><strong>订单模块</strong>{订单列表、地址信息、发货、订单完结}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><ul>
<li>前后端分离</li>
<li>接口文档</li>
<li>全栈、CTO</li>
<li>核心是接口的设计</li>
</ul>
<h3 id="项目开发所需工具准备"><a href="#项目开发所需工具准备" class="headerlink" title="项目开发所需工具准备"></a>项目开发所需工具准备</h3><ul>
<li><strong>IDEA</strong>常用优质插件介绍<ul>
<li>Maven Helper</li>
<li>Free MyBatis plugin [跳转&#x2F;识别mapper语法错误]</li>
</ul>
</li>
<li><strong>Postman</strong>安装和常用功能演示</li>
<li><strong>MySQL可视化工具</strong></li>
</ul>
<h3 id="数据库设计与项目初始化"><a href="#数据库设计与项目初始化" class="headerlink" title="数据库设计与项目初始化"></a>数据库设计与项目初始化</h3><ul>
<li>表设计</li>
<li>技术选型、思路</li>
<li>新建项目，整合Mybatis，跑通接口</li>
<li>引用log4j2日志组件</li>
<li>使用AOP统一处理Web请求日志 [请求的参数  返回的商品、字段]</li>
</ul>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>Spring Boot 2.2.1RELEASE</li>
<li>MyBatis 3.4.6(优点)</li>
<li>Maven 3.6.1</li>
</ul>
<h3 id="技术选型需要考虑的点"><a href="#技术选型需要考虑的点" class="headerlink" title="技术选型需要考虑的点"></a>技术选型需要考虑的点</h3><ul>
<li>选择你最熟悉的技术 [最好不要超过30%的新技术]</li>
<li>选择拥有强大社区支撑的开源技术</li>
<li>确保技术前进步伐</li>
<li>学会从业务端开始思考</li>
<li>重视经验</li>
</ul>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul>
<li>新建项目</li>
<li>mybatis-generator的安装配置</li>
<li>自动生成DAO层文件</li>
<li>跑通接口</li>
</ul>
<p>【下方链接的主要问题就是 由于项目中的jdk和你实际安装的jdk不匹配】<br>{修改Project Structure → Project的版本}<br>{修改启动Edit的版本}<br>{修改setting→Build,Execution,Deployment→Compiler→Java Compiler中的<strong>Project version</strong>以及项目的<strong>Target version</strong>}</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44664231/article/details/131544077">【Java异常】完美解决this version of the Java Runtime only recognizes class file versions up to xx.0异常_java runtime (class file version 61.0), this versi-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51970165/article/details/128242289">fileversion 55.0 this version of the Java Runtime only recognizes class file versions up to 52.0：已解决_class file version 55.0-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54878983/article/details/134912368">彻底解决：IDEA java: 警告: 源发行版 17 需要目标发行版 17-CSDN博客</a></p>
<pre><code class="xml">generatorConfig.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;generatorConfiguration&gt;
  &lt;!-- 配置文件，放在resource目录下即可 --&gt;
  &lt;!--数据库驱动个人配置--&gt;
  &lt;classPathEntry
    location=&quot;/Users/Pluminary/.m2/repository/mysql/mysql-connector-java/8.0.18/mysql-connector-java-8.0.18.jar&quot;/&gt;
  &lt;context id=&quot;MysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;
    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;
    &lt;!--可以使用``包括字段名，避免字段名与sql保留字冲突报错--&gt;
    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;
    &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;
    &lt;commentGenerator&gt;
      &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
      &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;
    &lt;/commentGenerator&gt;
    &lt;!--数据库链接地址账号密码--&gt;
    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
      connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&quot;
      userId=&quot;root&quot;
      password=&quot;root&quot;&gt;
      &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;
    &lt;/jdbcConnection&gt;
    &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;
    &lt;javaTypeResolver&gt;
      &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
    &lt;/javaTypeResolver&gt;
    &lt;!--生成Model类存放位置--&gt;
    &lt;javaModelGenerator targetPackage=&quot;com.imooc.mall.model.pojo&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;
      &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
      &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;
      &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;
    &lt;/javaModelGenerator&gt;
    &lt;!--生成mapper映射文件存放位置--&gt;
    &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/sqlMapGenerator&gt;
    &lt;!--生成Dao类存放位置--&gt;
    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.imooc.mall.model.dao&quot;
      targetProject=&quot;src/main/java&quot;&gt;
      &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
    &lt;/javaClientGenerator&gt;
    &lt;!--生成对应表及类名--&gt;
    &lt;table schema=&quot;root&quot; tableName=&quot;imooc_mall_cart&quot; domainObjectName=&quot;Cart&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_order_item&quot; domainObjectName=&quot;OrderItem&quot;
      enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;
    &lt;table tableName=&quot;imooc_mall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot;
      enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot;
      selectByExampleQueryId=&quot;false&quot;&gt;
    &lt;/table&gt;

  &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<pre><code class="xml">application.properties
spring.datasource.name=imooc_mall_datasource
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/imooc_mall?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;mall&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;small&lt;/name&gt;
    &lt;description&gt;small&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;17&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;!--  1.依赖mysql-connector-java  mybatis-spring-boot-starter 加入generatorConfig.xml 写下面的Plugins--&gt;
&lt;!-- 2. 加入imooc_mall_local.sql后 点Maven -&gt; Plugins -&gt; mybatis-generator -&gt; 点击第一个 --&gt;
&lt;!--  通过插件生成 此时就出来了com/imooc/mall/model/dao里面所有的 和 com/imooc/mall/model/pojo里面所有的 和 mappers--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">package com.imooc.mall.controller;

import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml
        return userService.getUser();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="log4j2日志"><a href="#log4j2日志" class="headerlink" title="log4j2日志"></a>log4j2日志</h3><ul>
<li>日志级别(优先级降低)：error, warn, info, debug, trace</li>
<li>排除Logback依赖</li>
</ul>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">log4j2.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;fatal&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot; value=&quot;$&#123;sys:user.home&#125;/Desktop/idea_Space/logs&quot;/&gt;
  &lt;/Properties&gt;

  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;
      &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot;
        onMismatch=&quot;DENY&quot;/&gt;
      &lt;PatternLayout
        pattern=&quot;[%d&#123;MM:dd HH:mm:ss.SSS&#125;] [%level] [%logger&#123;36&#125;] - %msg%n&quot;/&gt;
    &lt;/Console&gt;

    &lt;!--debug级别日志文件输出--&gt;
    &lt;RollingFile name=&quot;debug_appender&quot; fileName=&quot;$&#123;baseDir&#125;/debug.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/debug_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在debug及以上在info以下 --&gt;
        &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
        &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- info级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;info_appender&quot; fileName=&quot;$&#123;baseDir&#125;/info.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/info_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在info及以上在error以下 --&gt;
        &lt;ThresholdFilter level=&quot;info&quot;/&gt;
        &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;!-- 策略 --&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;

    &lt;!-- error级别日志文件输出 --&gt;
    &lt;RollingFile name=&quot;error_appender&quot; fileName=&quot;$&#123;baseDir&#125;/error.log&quot;
      filePattern=&quot;$&#123;baseDir&#125;/error_%i.log.%d&#123;yyyy-MM-dd&#125;&quot;&gt;
      &lt;!-- 过滤器 --&gt;
      &lt;Filters&gt;
        &lt;!-- 限制日志级别在error及以上 --&gt;
        &lt;ThresholdFilter level=&quot;error&quot;/&gt;
      &lt;/Filters&gt;
      &lt;!-- 日志格式 --&gt;
      &lt;PatternLayout pattern=&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;/&gt;
      &lt;Policies&gt;
        &lt;!-- 每隔一天转存 --&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt;
        &lt;!-- 文件大小 --&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;debug&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
      &lt;AppenderRef ref=&quot;debug_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;info_appender&quot;/&gt;
      &lt;AppenderRef ref=&quot;error_appender&quot;/&gt;
    &lt;/Root&gt;

  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="AOP统一处理Web请求日志"><a href="#AOP统一处理Web请求日志" class="headerlink" title="AOP统一处理Web请求日志"></a>AOP统一处理Web请求日志</h3><ul>
<li>为什么需要AOP统一处理Web请求日志 [对系统健壮性的保证 创建filter]</li>
</ul>
<pre><code class="java">com/imooc/mall/filter/WebLogAspect.java
package com.imooc.mall.filter;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;

/**
 * 打印请求和响应信息
 */
@Aspect
@Component
public class WebLogAspect &#123;
    //生成loger类
    private final Logger log = LoggerFactory.getLogger(WebLogAspect.class);
//10.增加一个拦截点AOP
    @Pointcut(&quot;execution(public * com.imooc.mall.controller..*.*(..))&quot;)
    public void webLog()&#123;

    &#125;
//  10.提供请求参数
    @Before(&quot;webLog()&quot;)
    public void doBefore(JoinPoint joinPoint)&#123;
        //收到请求,记录请求内容  请求到来所作的事情
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        log.info(&quot;URL: &quot; + request.getRequestURI().toString());
        log.info(&quot;HTTP_METHOD: &quot; + request.getMethod());
        log.info(&quot;IP: &quot; + request.getRemoteAddr());
        log.info(&quot;CLASS_METHOD: &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());
        log.info(&quot;ARGS: &quot; + Arrays.toString(joinPoint.getArgs()));
    &#125;
//  11.返回的时候也要拦截  返回参数res 拦截点webLog
    @AfterReturning(returning = &quot;res&quot;,pointcut = &quot;webLog()&quot;)
    public void doAfterReturning(Object res)throws Exception&#123;
        //处理完请求,返回内容
        log.info(&quot;RESPONSE: &quot; + new ObjectMapper().writeValueAsString(res));
    &#125;
&#125;
</code></pre>
<h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><ul>
<li>整体介绍：知识点、功能点<br> [<u>登录、注册、重名校验、密码加密存储、Session的使用、越权校验、统一响应对象、异常枚举、Java异常体系、Postman实操、统一异常处理、更新个人信息</u>]</li>
<li>接口设计</li>
<li>编码设计</li>
</ul>
<h3 id="API统一返回对象"><a href="#API统一返回对象" class="headerlink" title="API统一返回对象"></a>API统一返回对象</h3><pre><code class="java">package com.imooc.mall.common;

import com.imooc.mall.exception.ImoocMallExceptionEnum;

/**
 * 通用返回对象 T有可能是返回的购物车对象
 * 12.编写响应API      13创建枚举异常com/imooc/mall/exception/ImoocMallExceptionEnum.java
 */
public class ApiRestResponse&lt;T&gt; &#123;
    private Integer status;
    private String msg;
    private T data;
    private static final int OK_CODE = 10000;
    private static final String OK_MSG = &quot;SUCCESS&quot;;

    public ApiRestResponse(Integer status, String msg, T data) &#123;
        this.status = status;
        this.msg = msg;
        this.data = data;
    &#125;

    public ApiRestResponse(Integer status, String msg) &#123;
        this.status = status;
        this.msg = msg;
    &#125;

    public ApiRestResponse() &#123;
        //默认请求信息
        this(OK_CODE, OK_MSG);
    &#125;
    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success()&#123;
//   建立带着10000 和 SUCCESS的方法
        return new ApiRestResponse&lt;&gt;();
    &#125;

    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(Integer code, String msg) &#123;
        return new ApiRestResponse&lt;&gt;(code, msg);
    &#125;
//  14.用枚举来搞错误 为了方便调试编写完后生成一个toString方法 15修改UserController的register()
    public static &lt;T&gt; ApiRestResponse&lt;T&gt; error(ImoocMallExceptionEnum ex) &#123;
        return new ApiRestResponse&lt;&gt;(ex.getCode(), ex.getMsg());
    &#125;
//   把错误[异常]创建成一个枚举类

    public static&lt;T&gt; ApiRestResponse&lt;T&gt; success(T result)&#123;
//    两个成功success的方法
        ApiRestResponse&lt;T&gt; response = new ApiRestResponse&lt;&gt;();
        response.setData(result);
        return response;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;ApiRestResponse&#123;&quot; +
                &quot;status=&quot; + status +
                &quot;, msg=&#39;&quot; + msg + &#39;\&#39;&#39; +
                &quot;, data=&quot; + data +
                &#39;&#125;&#39;;
    &#125;

    public Integer getStatus() &#123;
        return status;
    &#125;

    public void setStatus(Integer status) &#123;
        this.status = status;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;

    public T getData() &#123;
        return data;
    &#125;

    public void setData(T data) &#123;
        this.data = data;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="注册接口开发"><a href="#注册接口开发" class="headerlink" title="注册接口开发"></a>注册接口开发</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 用户控制器
 */
@Controller
public class UserController &#123;
    //4.返回对象的基本信息 return里面会写和service相关的  5建立Service层
    @Autowired
    UserService userService;
    @GetMapping(&quot;/test&quot;)
    @ResponseBody //返回Json格式内容
    public User personalPage()&#123;
//  6.补全return 7告诉mapper在哪里怎么去找 去application.properties编写 mybatis.mapper-locations:......
//  去主类里编写@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;) 以防找不到mapper 8.去配置端口8083
//   9.加入log4j2.xml  增加aop的pom
        return userService.getUser();
    &#125;
// 12.创造一个统一返回对象 com/imooc/mall/common/ApiRestResponse.java
    // 15.参数加在请求中所以加上@RequestParam 编写校验  16去UserService增加register接口
    @PostMapping(&quot;/register&quot;)
    @ResponseBody
    public ApiRestResponse register(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password) throws ImoocMallException &#123;
//    字符串为空 || 符合参数
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;
//   防止用户密码长度设置简单 密码长度不能少于8
        if (password.length()&lt;8)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PASSWORD_TOO_SHORT);
        &#125;
 //18.补全操作  19进行统一处理异常[对前端安全考虑] GlobalExceptionHandler.java
        userService.register(userName, password);
        return ApiRestResponse.success();
    &#125;
&#125;

=========================================
http://127.0.0.1:8083/register

Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Wed Mar 06 00:06:06 CST 2024
There was an unexpected error (type=Method Not Allowed, status=405).
Request method &#39;GET&#39; not supported
    
因为注册的时候采用的是@PostMapping(&quot;/register&quot;)
单纯查询用get 往数据库写东西post
@RequestMapping(&quot;/register&quot;)是GET和POST都支持的 但是不推荐
根据不同的业务逻辑选择类型

打开postman 新建一个去查询post
POST: 127.0.0.1:8083/register?userName=mumu&amp;password=12345678

&#123;
    &quot;status&quot;: 10000,
    &quot;msg&quot;: &quot;SUCCESS&quot;,
    &quot;data&quot;: null
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.User;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
        user.setPassword(password);
        //先判断是不是空 不是空才修改  实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/UserMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.User;
import org.springframework.stereotype.Repository;

@Repository
public interface UserMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(User record);

    int insertSelective(User record);

    User selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(User record);

    int updateByPrimaryKey(User record);

    // 16. 新增功能 去对应的UserMapper.xml进行描述 117行  BaseResultMap就是一开始自动生成的User对象
    // &lt;include refid=&quot;Base_Column_List&quot;/&gt; 选取完整的User对象
    User selectByName(String userName);
&#125;
</code></pre>
<pre><code class="xml">mappers/UserMapper.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.mall.model.dao.UserMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;
    &lt;result column=&quot;personalized_signature&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;personalizedSignature&quot; /&gt;
    &lt;result column=&quot;role&quot; jdbcType=&quot;INTEGER&quot; property=&quot;role&quot; /&gt;
    &lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&gt;
    &lt;result column=&quot;update_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;updateTime&quot; /&gt;
  &lt;/resultMap&gt;
  &lt;sql id=&quot;Base_Column_List&quot;&gt;
    id, username, `password`, personalized_signature, `role`, create_time, update_time
  &lt;/sql&gt;
  &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select 
    &lt;include refid=&quot;Base_Column_List&quot; /&gt;
    from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/select&gt;
  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from imooc_mall_user
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/delete&gt;
  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user (id, username, `password`, 
      personalized_signature, `role`, create_time, 
      update_time)
    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, 
      #&#123;personalizedSignature,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, #&#123;createTime,jdbcType=TIMESTAMP&#125;, 
      #&#123;updateTime,jdbcType=TIMESTAMP&#125;)
  &lt;/insert&gt;
  &lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    insert into imooc_mall_user
    &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        id,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password`,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role`,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time,
      &lt;/if&gt;
    &lt;/trim&gt;
    &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt;
      &lt;if test=&quot;id != null&quot;&gt;
        #&#123;id,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/trim&gt;
  &lt;/insert&gt;
  &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;
        username = #&#123;username,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;
        `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;personalizedSignature != null&quot;&gt;
        personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;role != null&quot;&gt;
        `role` = #&#123;role,jdbcType=INTEGER&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;createTime != null&quot;&gt;
        create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
      &lt;if test=&quot;updateTime != null&quot;&gt;
        update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;,
      &lt;/if&gt;
    &lt;/set&gt;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.imooc.mall.model.pojo.User&quot;&gt;
    update imooc_mall_user
    set username = #&#123;username,jdbcType=VARCHAR&#125;,
      `password` = #&#123;password,jdbcType=VARCHAR&#125;,
      personalized_signature = #&#123;personalizedSignature,jdbcType=VARCHAR&#125;,
      `role` = #&#123;role,jdbcType=INTEGER&#125;,
      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,
      update_time = #&#123;updateTime,jdbcType=TIMESTAMP&#125;
    where id = #&#123;id,jdbcType=INTEGER&#125;
  &lt;/update&gt;
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
        &lt;include refid=&quot;Base_Column_List&quot;/&gt;
        from imooc_mall_user
        where username = #&#123;userName,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallException.java
package com.imooc.mall.exception;

/**
 * 17. 统一异常(感觉像递归之前编写的枚举异常)
 */
public class ImoocMallException extends Exception&#123;
    private final Integer code;
    private final String message;

    public ImoocMallException(Integer code, String message) &#123;
        this.code = code;
        this.message = message;
    &#125;

    public ImoocMallException(ImoocMallExceptionEnum exceptionEnum) &#123;
        this(exceptionEnum.getCode(), exceptionEnum.getMsg());
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    @Override
    public String getMessage() &#123;
        return message;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="GlobalExceptionHandler编写"><a href="#GlobalExceptionHandler编写" class="headerlink" title="GlobalExceptionHandler编写"></a>GlobalExceptionHandler编写</h3><ul>
<li>对前端安全考虑，敏感信息不会暴露给用户</li>
<li>抛出异常，直接转化为Json的APIResponse</li>
<li>抛出重名异常</li>
<li>拦截异常并且转变成APIRespond统一类型输出</li>
</ul>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  
   20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;
    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e682b6dfead4194de33f37c0a5d1f116f2d9ad96/data/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<h3 id="对密码进行MD5保护"><a href="#对密码进行MD5保护" class="headerlink" title="对密码进行MD5保护"></a>对密码进行MD5保护</h3><pre><code class="java">com/imooc/mall/util/MD5Utils.java
package com.imooc.mall.util;

import com.imooc.mall.common.Constant;
import org.apache.tomcat.util.codec.binary.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//20.不具备解密的协议 哈希算法  因为有破解MD5的网站所以需要加盐 21com/imooc/mall/common/Constant.java
public class MD5Utils &#123;
    public static String getMD5Str(String strValue) throws NoSuchAlgorithmException &#123;
        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
        return Base64.encodeBase64String(md5.digest((strValue+ Constant.SALT).getBytes()));
    &#125;
//  用这个方法测试生成MD5的值
    public static void main(String[] args) throws NoSuchAlgorithmException &#123;
        String md5Str = getMD5Str(&quot;12345&quot;);
        System.out.println(md5Str);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.UserMapper;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import com.imooc.mall.util.MD5Utils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.security.NoSuchAlgorithmException;

/**
 * UserService实现类
 */
@Service
//5.重写里面的方法  @Autowired引入一个mapper去查询数据库返回真正的信息 6返回UserController补全return
public class UserServiceImpl implements UserService &#123;
    @Autowired
    UserMapper userMapper;

    @Override
    public User getUser()&#123;
        //通过主键来查询一个对象
        return userMapper.selectByPrimaryKey(1);
    &#125;
    @Override
    public void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException &#123;
//    16.查询用户名是否存在, 不允许重名 用userMapper去查数据
//    但未编写功能 去手动编写UserMapper.java
        User result = userMapper.selectByName(userName);
        if (result != null)&#123;
//    17. 用户已存在 在Service层不能直接return但是controller可以直接返回
            // 创建一个异常类 com/imooc/mall/exception/ImoocMallException.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
    // 通过检测 允许写入数据库
        User user = new User();
        user.setUsername(userName);
//        user.setPassword(password);
        //21.重写密码
        user.setPassword(MD5Utils.getMD5Str(password));
        //先判断是不是空 不是空才修改  18实现完以后回到controller层进行调用
        int count = userMapper.insertSelective(user);
        if (count==0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.INSERT_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="登录功能分析"><a href="#登录功能分析" class="headerlink" title="登录功能分析"></a>登录功能分析</h3><ul>
<li>登录状态需要保持 </li>
<li>session的实现方案：登陆后，会保存用户信息到session</li>
<li>之后的访问，会先从session中获取用户信息，然后再执行业务逻辑</li>
</ul>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;if (StringUtils.isEmpty(password))&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中
        session.setAttribute(Constant.IMOOC_MALL_USER,user);
        return ApiRestResponse.success(user);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
    //23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
</code></pre>
<h3 id="用户模块剩余接口开发-更新个性签名"><a href="#用户模块剩余接口开发-更新个性签名" class="headerlink" title="用户模块剩余接口开发 [更新个性签名]"></a>用户模块剩余接口开发 [更新个性签名]</h3><pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/UserController.java
//22登录login接口的开发 23返回UserServiceImpl写login
    @PostMapping(&quot;/login&quot;)
    @ResponseBody
    public ApiRestResponse login(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//26.编写完毕login接口  27更新个性签名接口
        User user = userService.login(userName, password);
        //保存用户信息时，不保存密码
        user.setPassword(null);
        //把对象放入session中 KEY
        session.setAttribute(Constant.IMOOC_MALL_USER, user);
        return ApiRestResponse.success(user);
    &#125;

    //  27.个性签名接口 28编写UserServiceImpl的updateUserInfo方法
    @PostMapping(&quot;/user/update&quot;)
    @ResponseBody
    public ApiRestResponse updateUserInfo(HttpSession session, @RequestParam String signature) throws ImoocMallException &#123;
        User currentUser = (User)session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;
        User user = new User();
        user.setId(currentUser.getId());
        user.setPersonalizedSignature(signature);
        //29.搞全代码
        userService.updateInformation(user);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//23.写方法判断md5与其匹配
    @Override
    public User login(String userName, String password) throws ImoocMallException &#123;
        String md5Password = null;
        try &#123;
            md5Password = MD5Utils.getMD5Str(password);
        &#125; catch (NoSuchAlgorithmException e) &#123;
            e.printStackTrace();
        &#125;
//   23写方法判断md5与其匹配 UserMapper中写 login
        //25.匹配 且去接口增加
        User user = userMapper.selectLogin(userName, md5Password);
        if (user == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_PASSWORD);
        &#125;//能找到就返回用户 直接从上面写@Override再自动修复就可以自动生成login的接口
        //26.返回UserController写完login接口
        return user;
    &#125;
// 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    @Override
    public void updateInformation(User user) throws ImoocMallException &#123;
//    更新个性签名
        int updateCount = userMapper.updateByPrimaryKeySelective(user);
        if(updateCount&gt;1)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
        //快速使用@Override 快速补全接口代码 29返回UserController补全代码
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/UserService.java
package com.imooc.mall.service;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.model.pojo.User;

import java.security.NoSuchAlgorithmException;

//5.这是抽象的接口 还要让它实现 再创建一个impl 实现接口类 UserServiceImpl.java
public interface UserService &#123;
    User getUser();
// 16.写完接口去实现接口UserServiceImpl.java
    void register(String userName, String password) throws ImoocMallException, NoSuchAlgorithmException;

    //23.写方法判断md5与其匹配
    User login(String userName, String password) throws ImoocMallException;

    // 28写updateUserInfo方法 不需要返回任何信息 只需要提醒更行成功即可
    void updateInformation(User user) throws ImoocMallException;
&#125;
</code></pre>
<h3 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
//30.退出登录接口
    @PostMapping(&quot;/user/logout&quot;)
    @ResponseBody
    public ApiRestResponse logout(HttpSession session)&#123;
        session.removeAttribute(Constant.IMOOC_MALL_USER);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<h3 id="管理员接口"><a href="#管理员接口" class="headerlink" title="管理员接口"></a>管理员接口</h3><pre><code class="java">com/imooc/mall/controller/UserController.java
    //  31.管理员登录接口 思路可以借鉴
    @PostMapping(&quot;/adminLogin&quot;)
    @ResponseBody
    public ApiRestResponse adminLogin(@RequestParam(&quot;userName&quot;) String userName, @RequestParam(&quot;password&quot;) String password, HttpSession session) throws ImoocMallException, NoSuchAlgorithmException &#123;
        if (StringUtils.isEmpty(userName)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_USER_NAME);
        &#125;
        if (StringUtils.isEmpty(password)) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_PASSWORD_NAME);
        &#125;//31.拿到用户名和密码的时候 对其进行校验是否为管理员
        //数据库中 role=1是普通用户   role=2是管理员用户
        // 32去serviceImpl写一个方法
        User user = userService.login(userName, password);
        //33.判断是否为管理员
//        userService.checkAdminRole(user).if
        if (userService.checkAdminRole(user)) &#123;
            //是管理员
            //保存用户信息时，不保存密码
            user.setPassword(null);
            //把对象放入session中 KEY
            session.setAttribute(Constant.IMOOC_MALL_USER, user);
            return ApiRestResponse.success(user);
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
    //  34.创建分类接口 CategoryController
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/UserServiceImpl.java
//  32.拿到用户  role=1是普通用户   role=2是管理员用户
    //33.回到Controller
    @Override
    public boolean checkAdminRole(User user)&#123;
        return user.getRole().equals(2);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名，注册失败&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="总结用户模块"><a href="#总结用户模块" class="headerlink" title="总结用户模块"></a>总结用户模块</h3><ul>
<li><strong>重难点</strong>：统一响应对象、登录状态保持、统一异常处理</li>
<li><strong>常见错误</strong>：响应对象不规范、异常不统一处理</li>
</ul>
<h3 id="商品分类管理模块开发"><a href="#商品分类管理模块开发" class="headerlink" title="商品分类管理模块开发"></a>商品分类管理模块开发</h3><ul>
<li>模块介绍</li>
<li>编码</li>
<li>自测</li>
<li>总结</li>
</ul>
<h5 id="什么是商品分类"><a href="#什么是商品分类" class="headerlink" title="什么是商品分类"></a>什么是商品分类</h5><ul>
<li>条例清楚，层次分明</li>
<li>方便用户进行筛选和辨别</li>
<li>可以通过分类的设置快速的进入对应的商品列表页面进行商品选择</li>
</ul>
<h5 id="分类层级"><a href="#分类层级" class="headerlink" title="分类层级"></a>分类层级</h5><ul>
<li>在商品分类上需要继续做归类操作</li>
<li>分类设置成三级</li>
<li>层级太深的弊端：<ul>
<li>一是对用户不太友好，不利于寻找</li>
<li>二是对后台管理人员不友好，不方便管理</li>
</ul>
</li>
</ul>
<h3 id="分类模块的主要功能"><a href="#分类模块的主要功能" class="headerlink" title="分类模块的主要功能"></a>分类模块的主要功能</h3><ul>
<li>分类数据的设置</li>
<li>分类的父一级目录、递归</li>
</ul>
<h5 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h5><ul>
<li>接口设计</li>
<li>表设计</li>
</ul>
<h3 id="开发添加分类接口part1"><a href="#开发添加分类接口part1" class="headerlink" title="开发添加分类接口part1"></a>开发添加分类接口part1</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.CategoryService;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpSession;

//  34.创建分类接口 CategoryController
@Controller
public class CategoryController &#123;
    @Autowired
    UserService userService;
    @Autowired
    CategoryService categoryService;
    @PostMapping(&quot;admin/category/add&quot;)
    @ResponseBody
    public ApiRestResponse addCategory(HttpSession session, @RequestBody AddCategoryReq addCategoryReq) &#123;
        //登录且必须为管理员才可以 参数中需要添加很多元素 可以使用封装来搞
        //com/imooc/mall/model/model/AddCategoryReq.java
        if (addCategoryReq.getName() == null || addCategoryReq.getType() == null || addCategoryReq.getParentId() == null || addCategoryReq.getOrderNum() == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.PARA_NOT_NULL);
        &#125;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole)&#123; //35.创建一个CategoryService 分类目录Service
        //37.补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            categoryService.add(addCategoryReq);
            return ApiRestResponse.success();
        &#125;else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;
//38.简化参数校验过程 || || || ||  @Valid  @Size(AddCategoryReq) @NotNull
        //39.增加GlobalExceptionHandler.java中的提示代码 不仅仅只提供20000 系统异常 handleMethodArg。。。
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
&#125;+GETTER SETTER
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
package com.imooc.mall.service.impl;

import com.fasterxml.jackson.databind.util.BeanUtil;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.model.AddCategoryReq;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.service.CategoryService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 36.目录分类Service实现类
 */
@Service
public class CategoryServiceImpl implements CategoryService &#123;
    @Autowired
//   去Mapper里增加selectbyName 117行
    CategoryMapper categoryMapper;
    public void add(AddCategoryReq addCategoryReq) &#123;
        Category category = new Category();
//        category.setName(addCategoryReq.getName());
        //字段类型一样 字段名一样的话可以自动拷贝进去
        BeanUtils.copyProperties(addCategoryReq,category);
        Category categoryOld = categoryMapper.selectByName(addCategoryReq.getName());
        if (categoryOld != null)&#123; //重名目录 不允许创建 (优化)将ImoocMallException中的extends换一个
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = categoryMapper.insertSelective(category);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//37.回到CategoryController.java
    &#125;
&#125;
</code></pre>
<pre><code class="xml">mappers/CategoryMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where name = #&#123;name,jdbcType=VARCHAR&#125;
  &lt;/select&gt;
</code></pre>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Valid</td>
<td>需要验证</td>
</tr>
<tr>
<td>@NotNull</td>
<td>非空</td>
</tr>
<tr>
<td>@Max(value)</td>
<td>最大值</td>
</tr>
<tr>
<td>@Size(max, min)</td>
<td>字符串长度范围限制</td>
</tr>
</tbody></table>
<pre><code class="java">com/imooc/mall/model/model/AddCategoryReq.java
package com.imooc.mall.model.model;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 34.AddCategoryReq 新建一个类 供添加接口进行封装 回去引用
 */
public class AddCategoryReq &#123;
    @Size(min=2,max=5)
    private String name;
    @NotNull
    @Max(3)
    private Integer type;
    @NotNull(message = &quot;parentId不能为null&quot;)
    private Integer parentId;
    @NotNull
    private Integer orderNum;
    
===================================================
POST:127.0.0.1:8083/admin/category/add
Body→raw→JSON：&#123;&quot;name&quot;:&quot;鸭货伴手零食&quot;,&quot;type&quot;:2,&quot;parentId&quot;:6,&quot;orderNum&quot;:10&#125;

&#123;
    &quot;status&quot;: 20000,
    &quot;msg&quot;: &quot;系统异常&quot;,
    &quot;data&quot;: null
&#125;

org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [1] in public com.imooc.mall.common.ApiRestResponse com.imooc.mall.controller.CategoryController.addCategory(javax.servlet.http.HttpSession,com.imooc.mall.model.model.AddCategoryReq): [Field error in object &#39;addCategoryReq&#39; on field &#39;name&#39;: rejected value [鸭货伴手零食]; codes [Size.addCategoryReq.name,Size.name,Size.java.lang.String,Size]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [addCategoryReq.name,name]; arguments []; default message [name],5,2]; default message [个数必须在2和5之间]] 
</code></pre>
<pre><code class="java">com/imooc/mall/exception/GlobalExceptionHandler.java
package com.imooc.mall.exception;

import com.imooc.mall.common.ApiRestResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.ArrayList;
import java.util.List;

/**
 * 19.处理统一异常的handler 业务异常 处理不同逻辑异常  20对密码进行MD5加密UserServiceImpl 先创建MD5Utils
 */
@ControllerAdvice
public class GlobalExceptionHandler &#123;
    private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    //   统一处理Exception.class异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Object handleException(Exception e) &#123;
        log.error(&quot;Default Exception: &quot;, e);
        return ApiRestResponse.error(ImoocMallExceptionEnum.SYSTEM_ERROR);
    &#125;

    @ExceptionHandler(ImoocMallException.class)
    @ResponseBody
    public Object handleImoocMallException(ImoocMallException e) &#123;
        log.error(&quot;ImoocMallException: &quot;, e); //传进来的是什么就传出去
        return ApiRestResponse.error(e.getCode(), e.getMessage());
    &#125;

    //  39.处理方法参数不合规的情况
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ApiRestResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e) &#123;
        log.error(&quot;handleMethodArgumentNotValidException: &quot;, e);
        return handleBindingResult(e.getBindingResult());
    &#125;
//  40.处理返回异常的ApiRespond 41去pom引入Swagger自动生成API文档
    private ApiRestResponse handleBindingResult(BindingResult result)&#123;
//  把异常处理为对外暴露的提示
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        if (result.hasErrors())&#123;
            List&lt;ObjectError&gt; allErrors = result.getAllErrors();
            for (ObjectError objectError : allErrors) &#123; //itli快速  对着for按alt+回车 改成增强for
                String message = objectError.getDefaultMessage();
                list.add(message);
            &#125;
        &#125;
        if (list.size() == 0)&#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR);
        &#125; //list.toString()生成所创建的异常描述信息
        return ApiRestResponse.error(ImoocMallExceptionEnum.REQUEST_PARAM_ERROR.getCode(), list.toString());
    &#125;
&#125;
</code></pre>
<h3 id="Swagger自动生成API文档"><a href="#Swagger自动生成API文档" class="headerlink" title="Swagger自动生成API文档"></a>Swagger自动生成API文档</h3><pre><code class="xml">pom.xml
&lt;!--41.导入Swagger自动生成API文档 并在main函数中加入注解 @EnableSwagger2--&gt;
&lt;!--42.再去创造一个config  配置文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/config/SpringFoxConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

@Configuration
public class SpringFoxConfig &#123;
 //41.访问http://localhost:8083/swagger-ui.html可以看到API文档 
    //42创建ImoocMallWebMvcConfig
    @Bean
    public Docket api() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
                .title(&quot;慕慕生鲜&quot;)
                .description(&quot;&quot;)
                .termsOfServiceUrl(&quot;&quot;)
                .build();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 
 * 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
   44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;

    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
==================================================
http://localhost:8083/swagger-ui.html
</code></pre>
<h3 id="更新目录接口"><a href="#更新目录接口" class="headerlink" title="更新目录接口"></a>更新目录接口</h3><pre><code class="java">com/imooc/mall/model/request/UpdateCategoryReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

/**
 * 45.CategoryController.java中创建新增方法
 */
public class UpdateCategoryReq &#123;
    @NotNull(message = &quot;id不能为null&quot;)
    private Integer id;

    @Size(min=2,max=5)
    private String name;
    @Max(3)
    private Integer type;

    private Integer parentId;
    private Integer orderNum;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
 @Override //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    public void update(Category updateCategory)&#123;
        if (updateCategory.getName() != null)&#123;
            Category categoryOld = categoryMapper.selectByName(updateCategory.getName());
            if (categoryOld != null &amp;&amp; !categoryOld.getId().equals(updateCategory.getId()))&#123; //不能为空且和原来的名字不一样
                throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
            &#125;
        &#125;
        categoryMapper.updateByPrimaryKeySelective(updateCategory); //根据主键更新
// 不和其他名字冲突
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CategoryService.java
package com.imooc.mall.service;

import com.imooc.mall.model.pojo.Category;
import com.imooc.mall .model.request.AddCategoryReq;

//35.创建一个CategoryService 分类目录Service 36创建一个它的实现类CategoryServiceImpl
public interface CategoryService &#123;
    void add(AddCategoryReq addCategoryReq);

    //47.快速生成
    // 46在CategoryServiceImpl.java中新增更新方法
    void update(Category updateCategory);
&#125;
</code></pre>
<h3 id="统一校验管理员身份"><a href="#统一校验管理员身份" class="headerlink" title="统一校验管理员身份"></a>统一校验管理员身份</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//    45.创建新增接口   46在CategoryServiceImpl.java中新增更新方法
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody
    public ApiRestResponse updateCategory( @Valid @RequestBody UpdateCategoryReq updateCategoryReq, HttpSession session) &#123;
        //对身份进行校验 用session获取当前的用户
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_LOGIN);
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123;
            //补全代码 是管理员  在上面添加@RequestBody 去postman Body-&gt;(raw/JSON)里测试接口
            //46.补全接口代码
            Category category = new Category(); //复制过来
            BeanUtils.copyProperties(updateCategoryReq, category);
            categoryService.update(category);
            return ApiRestResponse.success();
        &#125; else &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.NEED_ADMIN);
        &#125;//47.为了统一接口校验管理员身份 NEED_LOGIN NEED_ADMIN
        // 创建一个com/imooc/mall/filter/AdminFilter.java
    &#125;
    @ApiOperation(&quot;后台更新目录&quot;)
    @PostMapping(&quot;admin/category/update&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse deleteCategory()&#123;
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 47. 管理员校验过滤器  48.Admin过滤器的配置
 */
public class AdminFilter implements Filter &#123;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        User currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;//校验管理员 userService写过直接引用过来
        boolean adminRole = userService.checkAdminRole(currentUser);
        if (adminRole) &#123; //放行代码
            filterChain.doFilter(servletRequest,servletResponse);
        &#125; else &#123;
            PrintWriter out = new HttpServletResponseWrapper(
                    (HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot;
                    + &quot;    \&quot;status\&quot;: 10009,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_ADMIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
        &#125;
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/filter/AdminFilterConfig.java
package com.imooc.mall.filter;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Admin过滤器的配置
 */
@Configuration
public class AdminFilterConfig &#123;
    @Bean
    public AdminFilter adminFilter()&#123;
        return new AdminFilter();
    &#125;
    @Bean(name = &quot;adminFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(adminFilter());
        filterRegistrationBean.addUrlPatterns(&quot;/admin/category/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/product/*&quot;);
        filterRegistrationBean.addUrlPatterns(&quot;/admin/order/*&quot;);
        filterRegistrationBean.setName(&quot;adminFilterConfig&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
com/imooc/mall/filter/AdminFilterConfig.java
</code></pre>
<h3 id="删除目录接口、分页功能开发"><a href="#删除目录接口、分页功能开发" class="headerlink" title="删除目录接口、分页功能开发"></a>删除目录接口、分页功能开发</h3><pre><code class="java">@RequestBody用来接收http post请求的body，前端传入序列化好的json数据，后端可以解析为json对象（Content-Type需要指定为 application/json）。
@RequestParam用来接收请求url?后面的参数，或者Content-Type为multipart/form-data、application/x-www-form-urlencoded时的http body数据。
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
     @ApiOperation(&quot;后台删除目录&quot;)
    @PostMapping(&quot;admin/category/delete&quot;)
    @ResponseBody //没有在接口里做权限校验
    //49.编写delete接口  再去CategoryServiceImpl.java 写delete方法
    public ApiRestResponse deleteCategory(@RequestParam Integer id) &#123;
        categoryService.delete(id);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//49.写delete方法     @Override快速更新service
    @Override
    public void delete(Integer id)&#123;
        Category categoryOld = categoryMapper.selectByPrimaryKey(id);
        //查不到记录，无法删除，删除失败
        if (categoryOld == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = categoryMapper.deleteByPrimaryKey(id);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CategoryController.java
 //50.写后台查询商品分类列表的接口
    @ApiOperation(&quot;后台目录列表&quot;)
    @PostMapping(&quot;admin/category/list&quot;)
    @ResponseBody //没有在接口里做权限校验
    public ApiRestResponse listCategoryForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //51.去CategoryServiceImpl编写该接口的实现类
        PageInfo pageInfo = categoryService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
package com.imooc.mall.model.vo;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class CategoryVO &#123;
    private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//51.创建vo[转换过后反应给前端的一个类]  pageInfo里面蕴藏着一个List&lt;Category&gt;
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        //把分页的功能包裹在List后 而不是直接返回
        //52.引入分页查询的pom 续写分页代码
        PageHelper.startPage(pageNum,pageSize,&quot;type,order_num&quot;);
        //53.写一个查询的mapper新的sql语句 CategoryMapper.java =&gt; List&lt;Category&gt; selectList();
        //54.返回Categorycontroller补全代码
        List&lt;Category&gt; categoryList = categoryMapper.selectList();
        PageInfo pageInfo = new PageInfo(categoryList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  52.引入分页的依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.13&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="用户分类列表接口开发"><a href="#用户分类列表接口开发" class="headerlink" title="用户分类列表接口开发"></a>用户分类列表接口开发</h3><pre><code class="java">com/imooc/mall/controller/CategoryController.java
//54.用户分类列表接口开发 去Impl补写实现类
    @ApiOperation(&quot;前台目录列表&quot;)
    @GetMapping(&quot;category/list&quot;)
    @ResponseBody
    public ApiRestResponse listCategoryForCustomer()&#123;
        List&lt;CategoryVO&gt; categoryVOS = categoryService.listCategoryForCustomer();
        return ApiRestResponse.success(categoryVOS);
    &#125;

============================================
目录列表(給用户看)：127.0.0.1:8083/category/list
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//54.用户分类列表接口开发
    @Override
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CategoryMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Category;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CategoryMapper &#123;
    int deleteByPrimaryKey(Integer id);
    int insert(Category record);
    int insertSelective(Category record);
    Category selectByPrimaryKey(Integer id);
    int updateByPrimaryKeySelective(Category record);
    int updateByPrimaryKey(Category record);
    Category selectByName(String name);
    List&lt;Category&gt; selectList();
    List&lt;Category&gt; selectCategoriesByParentId(Integer parentId);
&#125;
</code></pre>
<pre><code class="java">mappers/CategoryMapper.xml
&lt;mapper&gt;
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
  &lt;/select&gt;
  &lt;select id=&quot;selectCategoriesByParentId&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;int&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_category
    where parent_id = #&#123;parentId&#125;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率"><a href="#利用Redis缓存加速响应-目录变化频繁-访问量大的-增加效率" class="headerlink" title="利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]"></a>利用Redis缓存加速响应 [目录变化频繁(访问量大的) 增加效率]</h3><pre><code class="xml">pom.xml
&lt;!--    55.导入Redis的pom文件    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">56.增加一个@EnableCaching注解让idea知道你想打开缓存功能
com/imooc/mall/MallApplication.java
package com.imooc.mall;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.imooc.mall.model.dao&quot;)
@EnableSwagger2
@EnableCaching
//56.增加注解 并去想用的前面加注解 @Cacheable(value = &quot;listCategoryForCustomer&quot;)
public class MallApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MallApplication.class, args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>import org.springframework.cache.annotation.Cacheable; [对的]<br><del>import springfox.documentation.annotations.Cacheable;</del> [错的]</p>
</blockquote>
<pre><code class="java">com/imooc/mall/service/impl/CategoryServiceImpl.java
//这里要格外注意 不要导错包 不然运行不了redis 里面的keys会没有键值对
// import org.springframework.cache.annotation.Cacheable; [对的]
// import springfox.documentation.annotations.Cacheable; [错的]
 //54.用户分类列表接口开发
    @Override //56.在下方加想用Redis的注解  
  //57.创建一个对于缓存的配置类com/imooc/mall/config/CachingConfig.java
    @Cacheable(value = &quot;listCategoryForCustomer&quot;)
    public List&lt;CategoryVO&gt; listCategoryForCustomer()&#123;
        ArrayList&lt;CategoryVO&gt; categoryVOList = new ArrayList&lt;&gt;();
        recursivelyFindCategories(categoryVOList, 0);
        //55.去Mapper.java 和 Mapper.xml写方法
        return categoryVOList;
    &#125;

    private void recursivelyFindCategories(List&lt;CategoryVO&gt; categoryVOList, Integer parentId)&#123;
        //递归获取所有子类别并组合 合成一个&quot;目录树&quot;
        List&lt;Category&gt; categoryList = categoryMapper.selectCategoriesByParentId(parentId);
        if (!CollectionUtils.isEmpty(categoryList))&#123;
            //空 或 有无元素   itli
            for (int i = 0; i &lt; categoryList.size(); i++) &#123;
                Category category =  categoryList.get(i);
                CategoryVO categoryVO = new CategoryVO();
                //拷贝链接  比原来的多一个childCategory这个字段未被赋值
                BeanUtils.copyProperties(category, categoryVO);
                categoryVOList.add(categoryVO);
                //拿到childCategory字段并赋值 再从上面return categoryVOList;
                recursivelyFindCategories(categoryVO.getChildCategory(), categoryVO.getId());
            &#125;
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/CachingConfig.java
package com.imooc.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;

import java.time.Duration;

/**
 * 57.缓存的配置类 想要运行成功保存序列化 要去弄个序列化接口com/imooc/mall/model/vo/CategoryVO.java
 */
@Configuration
@EnableCaching
public class CachingConfig &#123;
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory connectionFactory) &#123;

        RedisCacheWriter redisCacheWriter = RedisCacheWriter
                .lockingRedisCacheWriter(connectionFactory);
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        cacheConfiguration = cacheConfiguration.entryTtl(Duration.ofSeconds(30));

        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter,
                cacheConfiguration);
        return redisCacheManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/CategoryVO.java
public class CategoryVO implements Serializable &#123;
     private Integer id;
    private String name;
    private Integer type;
    private Integer parentId;
    private Integer orderNum;
    private Date createTime;
    private Date updateTime;
    private List&lt;CategoryVO&gt; childCategory = new ArrayList&lt;&gt;();
&#125;Setter+Getter
</code></pre>
<h3 id="Idea调试技巧"><a href="#Idea调试技巧" class="headerlink" title="Idea调试技巧"></a>Idea调试技巧</h3><ul>
<li>断点统一开关</li>
<li>条件断点</li>
<li>单步调试<ul>
<li>step into 会进入方法内部</li>
<li>step out 跳出方法</li>
</ul>
</li>
<li>表达式求值 [Evaluate Expression]</li>
</ul>
<h3 id="总结商品分类模块"><a href="#总结商品分类模块" class="headerlink" title="总结商品分类模块"></a>总结商品分类模块</h3><ul>
<li>重难点：参数校验、Swagger[API文档自动]、统一鉴权[Filter过滤器]、Redis整合[Springboot整合]、调试功能</li>
<li>常见错误：参数手动校验、<span style = "color:red"><strong>项目没用Redis缓存</strong></span>、不善用调试</li>
</ul>
<h1 id="商品模块介绍"><a href="#商品模块介绍" class="headerlink" title="商品模块介绍"></a>商品模块介绍</h1><h6 id="演示、数据表设计、接口设计"><a href="#演示、数据表设计、接口设计" class="headerlink" title="演示、数据表设计、接口设计"></a>演示、数据表设计、接口设计</h6><h3 id="新增商品功能开发"><a href="#新增商品功能开发" class="headerlink" title="新增商品功能开发"></a>新增商品功能开发</h3><pre><code class="java">com\imooc\mall\controller\ProductAdminController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;

/**
 * 58.后台商品管理Controller  pojo的product复制一份到request变成AddProductReq
   59.需要ProductService.java
 */
@Controller
public class ProductAdminController &#123;
    @Autowired
    ProductService productService;
    @PostMapping(&quot;admin/product/add&quot;)
    public ApiRestResponse addProduct(@Valid @RequestBody AddProductReq addProductReq)&#123;
    //61.补全代码  目前图片上传还未开发成功
        productService.add(addProductReq);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/request/AddProductReq.java
package com.imooc.mall.model.request;

import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

public class AddProductReq &#123;
    @NotNull(message = &quot;商品名称不能为null&quot;)
    private String name;
    @NotNull(message = &quot;商品图片不能为null&quot;)
    private String image;

    private String detail;
    @NotNull(message = &quot;商品分类不能为null&quot;)
    private Integer categoryId;
    @NotNull(message = &quot;商品价格不能为null&quot;)
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @NotNull(message = &quot;商品库存不能为null&quot;)
    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/service/ProductService.java
package com.imooc.mall.service;

import com.imooc.mall.model.request.AddProductReq;

/**
 * 59.商品Service 再创建一个实现类ProductServiceImpl
 */
public interface ProductService &#123;

    void add(AddProductReq addProductReq);
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.AddProductReq;
import com.imooc.mall.service.ProductService;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * 59.商品服务实现类
 */
@Service
public class ProductServiceImpl implements ProductService &#123;
    @Autowired
    ProductMapper productMapper;//60.ProductMapper SQL通过名字查找product是否存在 151行
    @Override
    public void add(AddProductReq addProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(addProductReq, product);//赋值
        //61.商品重名情况  返回ProductAdminController补全代码  
        //62.图片上传接口 ProductAdminController
        Product productOld = productMapper.selectByName(addProductReq.getName());
        if (productOld != null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.insertSelective(product);
        if (count == 0)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CREATE_FAILED);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>文件名UUID</li>
<li>通用唯一识别码(Universally Unique Identifier)</li>
<li>防止重名、防止爬图</li>
<li>生成规则：日期和时间、<strong>MAC地址、HashCode、随机数</strong></li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//62.图片上传接口
    @PostMapping(&quot;admin/upload/file&quot;)
    public  ApiRestResponse upload(HttpServletRequest httpServletRequest, @RequestParam(&quot;file&quot;) MultipartFile file)&#123;
        String fileName = file.getOriginalFilename();
        String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));//用文件后面的名字
        //生成文件名称UUID
        UUID uuid = UUID.randomUUID();
        String newFileName = uuid.toString() + suffixName;
        //创建文件 放在常量类中 Constant.java
        //63.application.properties配置file.upload.dir
//        new File()
        File fileDirectory = new File(Constant.FILE_UPLOAD_DIR);
        File destFile = new File(Constant.FILE_UPLOAD_DIR + newFileName);
        if (!fileDirectory.exists())&#123;
            if (!fileDirectory.mkdir())&#123;//新建文件夹
                throw new ImoocMallException(ImoocMallExceptionEnum.MKDIR_FAILED);
            &#125;
        &#125;
        try &#123;
            file.transferTo(destFile); //传进来的写到空的方法中去
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        try &#123;
            return ApiRestResponse.success(getHost(new URI(httpServletRequest.getRequestURL()+&quot;&quot;))+&quot;/images/&quot;+newFileName); //生成的路径IP和端口号
        &#125; catch (URISyntaxException e) &#123;
            return ApiRestResponse.error(ImoocMallExceptionEnum.UPLOAD_FAILED);
        &#125;
    &#125;
    private URI getHost(URI uri)&#123;
        URI effectiveURI;
        try &#123;
            effectiveURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(),null,null,null);
        &#125; catch (URISyntaxException e) &#123;
            effectiveURI = null; //如果新建失败 就返回回去
        &#125;
        return effectiveURI;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public static String FILE_UPLOAD_DIR;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    PARA_NOT_NULL(10011,&quot;参数不能为空&quot;),
    CREATE_FAILED(10012,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10013,&quot;参数错误&quot;),
    DELETE_FAILED(10014,&quot;删除失败&quot;),
    MKDIR_FAILED(10015,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);
&#125;
</code></pre>
<h3 id="资源映射开发"><a href="#资源映射开发" class="headerlink" title="资源映射开发"></a>资源映射开发</h3><blockquote>
<p>此时从postman中创建一个上传图片的接口<br>127.0.0.1:8083&#x2F;admin&#x2F;upload&#x2F;file<br>选择Body→form-data<br>此时上传图片会报错 {<br>  “status”: 20000,<br>  “msg”: “系统异常”,<br>  “data”: null<br>}</p>
</blockquote>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则
&#125;
</code></pre>
<h3 id="自定义静态资源映射目录"><a href="#自定义静态资源映射目录" class="headerlink" title="自定义静态资源映射目录"></a>自定义静态资源映射目录</h3><ul>
<li>上传图片后回显</li>
<li>配置SpringBootWebMvcConfig</li>
<li>静态资源到本地目录的映射</li>
<li>演示打开图片</li>
</ul>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="更新-UpdateProductReq-和新增-AddProductReq-商品"><a href="#更新-UpdateProductReq-和新增-AddProductReq-商品" class="headerlink" title="更新(UpdateProductReq)和新增(AddProductReq)商品"></a>更新(UpdateProductReq)和新增(AddProductReq)商品</h3><ul>
<li>合并写法不可取</li>
<li>业务逻辑清晰、独立</li>
</ul>
<pre><code class="java">com/imooc/mall/model/request/UpdateProductReq.java
public class UpdateProductReq &#123;
    @NotNull
    private Integer id; 
    private String name;
    private String image;
    private String detail;
    private Integer categoryId;
    @Min(value = 1, message = &quot;价格不能为null&quot;)
    private Integer price;

    @Max(value = 10000, message = &quot;库存不能大于10000&quot;)
    private Integer stock;

    private Integer status;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //66. 接口 复制一个request中的AddProductReq 之后回来补全代码
    @ApiOperation(&quot;后台更新商品&quot;)
    @PostMapping(&quot;/admin/product/update&quot;)
    public ApiRestResponse updateProduct(@Valid @RequestBody UpdateProductReq updateProductReq)&#123;
        Product product = new Product();
        BeanUtils.copyProperties(updateProductReq, product);
        //67.进入ProductServiceImpl编写接口实现类
        productService.update(product);
        return ApiRestResponse.success();
    &#125;
    //68. 搞一个删除的接口 同理也在ProductServiceImpl中写实现类 之后回来补全代码
    @ApiOperation(&quot;后台删除商品&quot;)
    @PostMapping(&quot;/admin/product/delete&quot;)
    public ApiRestResponse deleteProduct(@RequestParam Integer id)&#123;
        productService.delete(id);
        return ApiRestResponse.success();
    &#125;com/imooc/mall/controller/ProductAdminController.java
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//67.写updateProduct实现类 @Override自动导入
    @Override
    public void update(Product updateProduct) &#123;
        Product productOld = productMapper.selectByName(updateProduct.getName());
        //同名且不同id，不能继续修改
        if (productOld != null &amp;&amp; productOld.getId().equals(updateProduct.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NAME_EXISTED);
        &#125;
        int count = productMapper.updateByPrimaryKeySelective(updateProduct);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;
    &#125;

    //68.删除实现类  @Override自动导入
    @Override
    public void delete(Integer id) &#123;
        Product productOld = productMapper.selectByPrimaryKey(id);
        //查不到该记录，无法删除
        if (productOld == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
        int count = productMapper.deleteByPrimaryKey(id);
        if (count == 0) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;
    &#125;
</code></pre>
<h3 id="批量上下架"><a href="#批量上下架" class="headerlink" title="批量上下架"></a>批量上下架</h3><ul>
<li>MyBatis遍历List</li>
<li>where语句拼接</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
//69. 批量上下架接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL
    // 之后回来补全代码
    @ApiOperation(&quot;后台批量上下架接口&quot;)
    @PostMapping(&quot;/admin/product/batchUpdateSellStatus&quot;)
    public ApiRestResponse batchUpdateSellStatus(@RequestParam Integer[] ids, @RequestParam Integer sellStatus)&#123;
        productService.batchUpdateSellStatus(ids,sellStatus);
        return ApiRestResponse.success();
    &#125;
=====================================================
127.0.0.1:8083//admin/product/batchUpdateSellStatus?ids=2,3&amp;sellStatus=0
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//69.去ProductAdminController增加batchUpdateSellStatus接口
    @Override
    public void batchUpdateSellStatus(Integer[] ids, Integer sellStatus)&#123;
        productMapper.batchUpdateSellStatus(ids, sellStatus);
    return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
  &lt;select id=&quot;selectByName&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;BaseResultMap&quot;&gt;
    select &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    where name = #&#123;name,jdbcType = VARCHAR&#125;
  &lt;/select&gt;
  &lt;update id=&quot;batchUpdateSellStatus&quot;&gt;
    update imooc_mall_product
    set status=#&#123;sellStatus&#125;
    where id in
    &lt;foreach collection=&quot;ids&quot; close=&quot;)&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
      #&#123;id&#125;
    &lt;/foreach&gt;
  &lt;/update&gt;
</code></pre>
<h3 id="后台商品列表、商品详情接口"><a href="#后台商品列表、商品详情接口" class="headerlink" title="后台商品列表、商品详情接口"></a>后台商品列表、商品详情接口</h3><pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
 //70.后台商品列表接口
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize)&#123;
        PageHelper.startPage(pageNum, pageSize); //在mapper里写查询sql
        List&lt;Product&gt; products = productMapper.selectListForAdmin();
        PageInfo pageInfo = new PageInfo(products);
        return pageInfo;
    &#125;
    //72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductAdminController.java
 //70.后台商品列表接口 同理也在ProductServiceImpl中写实现类 Napper中增加批量上下架的SQL 补全代码
    //71.开发与前台商品ProductController.java
    @ApiOperation(&quot;后台商品列表接口&quot;)
    @PostMapping(&quot;/admin/product/list&quot;)
    public ApiRestResponse list(@RequestParam Integer[] pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = productService.batchUpdateSellStatus(pageNum,pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
&#125;
</code></pre>
<h3 id="前台商品列表接口part1"><a href="#前台商品列表接口part1" class="headerlink" title="前台商品列表接口part1"></a>前台商品列表接口part1</h3><h5 id="商品列表：搜索功能"><a href="#商品列表：搜索功能" class="headerlink" title="商品列表：搜索功能"></a>商品列表：搜索功能</h5><p>入参判空 → 加%通配符 → like关键字</p>
<h5 id="对于查询目录的in处理"><a href="#对于查询目录的in处理" class="headerlink" title="对于查询目录的in处理"></a>对于查询目录的in处理</h5><ul>
<li>目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录的所有商品</li>
<li>所以这里要拿到某一个目录Id下的所有子目录id的List</li>
</ul>
<h5 id="前台：商品列表"><a href="#前台：商品列表" class="headerlink" title="前台：商品列表"></a>前台：商品列表</h5><ul>
<li>排序功能</li>
<li>MyBatis PageHelper</li>
<li>枚举：order by [自定义]</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/ProductServiceImpl.java
//72.商品详情接口开发 再去ProductController调用
    @Override
    public Product detail(Integer id)&#123;
        Product product = productMapper.selectByPrimaryKey(id);
        return product;
    &#125;
    //73.完成实现类
    @Override
    public PageInfo list(ProductListReq productListReq)&#123;
        //复杂查询就构建一个querry对象 ProductListQuery.java
        ProductListQuery productListQuery = new ProductListQuery();
        //☆☆搜索处理☆☆  拼接且转换成字符串去数据库查找
        if (!StringUtils.isEmpty(productListReq.getKeyword()))&#123;
            String keyword = new StringBuilder().append(&quot;%&quot;).append(productListReq.getKeyword()).append(&quot;%&quot;).toString();
            productListQuery.setKeyword(keyword);
        &#125;
        //☆☆目录处理☆☆：如果查某个目录下的商品，不仅是需要查出该目录下的，还要把所有子目录的所有商品都查出来，所以要拿到一个目录id的List
        if (productListReq.getCategoryId() != null)&#123;
            //要拿到子目录 引用CategoryService   CategoryVO原本是给前台目录用的 需要重构一下 不是所有目录而是指定目录
            //改动代码 CategoryServiceImpl.java中的listCategoryForCustomer 传入的参数是Integer parentId
            //productListReq获取了所有根节点的list  因为点开List&lt;CategoryVO&gt;里面包括一个  private List&lt;CategoryVO&gt;递归结构
            List&lt;CategoryVO&gt; categoryVOList = categoryService.listCategoryForCustomer(productListReq.getCategoryId());
            ArrayList&lt;Integer&gt; categoryIds = new ArrayList&lt;&gt;(); //拿过来之后存储的list
            categoryIds.add(productListReq.getCategoryId());
            getCategoryIds(categoryVOList,categoryIds);
            productListQuery.setCategoryIds(categoryIds);
        &#125;
        //74.排序能力 错误:前端传什么就 就传到sql中排序  这样是不安全的 要提前处理好
        //☆☆排序处理☆☆：去Constant定义支持的排序模式和手段
        String orderBy = productListReq.getOrderBy();
        if (Constant.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy)) &#123;
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize(), orderBy);
        &#125;else &#123;//前端不一定包含数据的话就不排序了
            PageHelper.startPage(productListReq.getPageNum(), productListReq.getPageSize());
        &#125;//75.去写Mapper 最后回到ProductController写调用
        List&lt;Product&gt; productList = productMapper.selectList(productListQuery);
        PageInfo pageInfo = new PageInfo(productList);
        return pageInfo;
    &#125;
    //74.写一个方法拿到所有的id 拿到参数之后往哪里存放
    private void getCategoryIds(List&lt;CategoryVO&gt;categoryVOList, ArrayList&lt;Integer&gt; categoryIds)&#123;
        for (int i = 0; i &lt; categoryVOList.size(); i++) &#123;
            CategoryVO categoryVO =  categoryVOList.get(i);
            if (categoryVO != null)&#123;
                categoryIds.add(categoryVO.getId());
                //递归子节点 子子节点
                getCategoryIds(categoryVO.getChildCategory(), categoryIds); //去上面调用方法 传入对象
            &#125;
            
        &#125;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/query/ProductListQuery.java
package com.imooc.mall.model.query;

import java.util.List;

/**
 * 查询商品列表的Query
 */
public class ProductListQuery &#123;
    private String keyword;
    private List&lt;Integer&gt; categoryIds;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的
    List&lt;Product&gt; selectList(@Param(&quot;ids&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">mappers/ProductMapper.xml
 &lt;select id=&quot;selectList&quot; resultMap=&quot;BaseResultMap&quot;
          parameterType=&quot;com.imooc.mall.model.query.ProductListQuery&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_product
    &lt;where&gt;
      &lt;if test=&quot;query.keyword != null&quot;&gt;
        and name like #&#123;query.keyword&#125;
      &lt;/if&gt;
      &lt;if test=&quot;query.categoryIds != null&quot;&gt;
        and category_id in
        &lt;foreach collection=&quot;query.categoryIds&quot; close=&quot;)&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
          #&#123;item&#125;
        &lt;/foreach&gt;
      &lt;/if&gt;
      and status = 1
    &lt;/where&gt;
    order by update_time desc
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/ProductMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.query.ProductListQuery;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Product record);

    int insertSelective(Product record);

    Product selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Product record);

    int updateByPrimaryKey(Product record);

    Product selectByName(String name);
    int batchUpdateSellStatus(@Param(&quot;ids&quot;) Integer[] ids, @Param(&quot;sellStatus&quot;) Integer sellStatus);

    List&lt;Product&gt; selectListForAdmin(); //给前台用户用的

    List&lt;Product&gt; selectList(@Param(&quot;query&quot;)ProductListQuery query); //给后台用户用的 Type是一个类

&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/ProductController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.ProductListReq;
import com.imooc.mall.service.ProductService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 71.前台商品Controller 72新增detail接口 ProductServiceImpl.java
 */
@RestController
public class ProductController &#123;
    @Autowired
    ProductService productService;

    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/detail&quot;)
    public ApiRestResponse detail(@RequestParam Integer id)&#123;
        Product product = productService.detail(id);
        return ApiRestResponse.success(product);
    &#125;
    //73.开发前台商品列表 开一个ProductListReq.java 去ProductServiceImpl
    @ApiOperation(&quot;商品详情&quot;)
    @GetMapping(&quot;product/list&quot;)
    public ApiRestResponse list(ProductListReq productListReq)&#123;
        PageInfo list = productService.list(productListReq);
        return ApiRestResponse.success(list);
    &#125;
&#125;
</code></pre>
<h3 id="总结商品模块"><a href="#总结商品模块" class="headerlink" title="总结商品模块"></a>总结商品模块</h3><ul>
<li>重难点：<strong>商品的搜索</strong>[<u>like</u>]、<strong>排序</strong>[<u>枚举+自定义</u>]、<strong>目录查询</strong>[<u>所有目录id都查到  再用查询列表方式</u>]</li>
<li>常见错误：更新和新增放在同一个接口、排序字段不用枚举</li>
</ul>
<h3 id="购物车模块介绍"><a href="#购物车模块介绍" class="headerlink" title="购物车模块介绍"></a>购物车模块介绍</h3><h5 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h5><ul>
<li>添加商品到购物车 → 商品是否在售、是否有库存 <ul>
<li>→[否] 提示用户</li>
<li>→[是] 该商品之前就在购物车里<ul>
<li>→[否] 添加新商品</li>
<li>→[是] 原有基础上添加数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * 76.购物车Controller  77.用一个通用UserFilter逻辑
 */
@Controller
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @PostMapping(&quot;/add&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        return null;
    &#125;
&#125;
========================================================
127.0.0.1:8083/cart/add?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/filter/UserFilter.java
package com.imooc.mall.filter;

import com.imooc.mall.common.Constant;
import com.imooc.mall.model.pojo.User;
import com.imooc.mall.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.PrintWriter;

/**
 *
 * 77.用户过滤器 希望把用户信息currentUser保存下来
 */
public class UserFilter implements Filter &#123;
    public static User currentUser;
    @Autowired
    UserService userService;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        //对身份进行校验 用session获取当前的用户
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpSession session = request.getSession();
        currentUser = (User) session.getAttribute(Constant.IMOOC_MALL_USER);
        if (currentUser == null) &#123;
            PrintWriter out = new HttpServletResponseWrapper((HttpServletResponse) servletResponse).getWriter();
            out.write(&quot;&#123;\n&quot; //用户未登录
                    + &quot;    \&quot;status\&quot;: 10007,\n&quot;
                    + &quot;    \&quot;msg\&quot;: \&quot;NEED_LOGIN\&quot;,\n&quot;
                    + &quot;    \&quot;data\&quot;: null\n&quot;
                    + &quot;&#125;&quot;);
            out.flush();
            out.close();
            return;
        &#125;
        //78.续写过滤器链条 写好后对用户链条进行config配置 UserFilterConfig.java
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/config/UserFilterConfig.java
package com.imooc.mall.config;

import com.imooc.mall.filter.UserFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 78.对调用接口时对哪个类进行拦截 过滤器的配置 79创建cartService
 */
@Configuration
public class UserFilterConfig &#123;
    @Bean
    public UserFilter userFilter()&#123;
        return new UserFilter();
    &#125;
    @Bean(name = &quot;userFilterConf&quot;)
    public FilterRegistrationBean adminFilterConfig()&#123;
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        filterRegistrationBean.setFilter(userFilter());
        //下面的是校验与拦截
        filterRegistrationBean.addUrlPatterns(&quot;/cart/*&quot;); //CartController.java
        filterRegistrationBean.addUrlPatterns(&quot;/order/*&quot;);
        filterRegistrationBean.setName(&quot;userFilterConf&quot;);
        return filterRegistrationBean;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.vo.CartVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 80.购物车Service实现类 其中List&lt;&gt;中间是需要包括 商品id 图片 名字 商品选中 数量信息
 * 81.创建一个VO增加那些属性放在&lt;&gt;中 是返回给前端组合后的对象
 */
@Service
public class CartServiceImpl &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;

    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);

    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 
    //84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
</code></pre>
<pre><code class="java">@Service
public class CartServiceImpl implements CartService &#123;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CategoryMapper categoryMapper;
    @Autowired
    CartMapper cartMapper;
@Override
    public List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count) &#123;
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        //84.补全代码
        if (cart==null)&#123;
            //这个商品之前不在购物车里，需要新增一个记录
            cart = new Cart();
            cart.setProductId(productId);
            cart.setUserId(userId);
            cart.setQuantity(count);
            cart.setSelected(Constant.Cart.CHECKED);
            cartMapper.insertSelective(cart);
        &#125;else &#123;
            //这个商品已经在购物车里了，数量相加
            count = cart.getQuantity() + count;
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        //85.去CartController补全代码逻辑 返回购物车列表哦~ 86.CartMapper.java
        return null;
    &#125;

    private void validProduct(Integer productId, Integer count) &#123;
        Product product = productMapper.selectByPrimaryKey(productId);
        //判断商品是否存在，商品是否上架
        if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
            //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
        &#125;
        //判断商品库存 如果要买的比库存多 就买不了
        if (count &gt; product.getStock()) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/CartMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.vo.CartVO;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Repository
public interface CartMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Cart record);

    int insertSelective(Cart record);

    Cart selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Cart record);

    int updateByPrimaryKey(Cart record);

    //86.选中列表的方法 传入的参数是userId
    List&lt;CartVO&gt; selectList(@Param(&quot;userId&quot;) Integer userId);
    Cart selectCartByUserIdAndProductId(@Param(&quot;userId&quot;) Integer userId, @Param(&quot;productId&quot;)Integer productId);
&#125;
</code></pre>
<pre><code class="xml">mappers/CartMapper.xml
 &lt;select id=&quot;selectList&quot; resultType=&quot;com.imooc.mall.model.vo.CartVO&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    select
    c.id as id,
    p.id as productId,
    c.user_id as userId,
    c.quantity as quantity,
    c.selected as selected,
    p.price as price,
    p.name as productName,
    p.image as productImage
    from imooc_mall_cart c
    left join imooc_mall_product p on p.id = c.product_id
    where c.user_id = #&#123;userId&#125;
    and p.status = 1
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/CartController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * 76.购物车Controller  77.用一个通用User_filter逻辑
 */
@RestController //404的错误① 返回的json格式 要用RestController
@RequestMapping(&quot;/cart&quot;)
public class CartController &#123;//因为放在url中 要加数据绑定 通过HttpSession获取用户信息太麻烦 用一个通用filter逻辑
    @Autowired
    CartService cartService;
    @PostMapping(&quot;/list&quot;)
    @ApiOperation(&quot;购物车列表&quot;)
    public ApiRestResponse list()&#123;
        //86.去写service的list接口 CartMapper中写选中列表的方法
        //内部获取用户Id,防止横向越权
        List&lt;CartVO&gt; cartList = cartService.list(UserFilter.currentUser.getId());
        return ApiRestResponse.success();
    &#125;

    @PostMapping(&quot;/add&quot;)
    @ApiOperation(&quot;添加商品到购物车&quot;)
    public ApiRestResponse add(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //85.补全完逻辑代码 87在下面补全代码 List&lt;CartVO&gt; cartVOList =
        List&lt;CartVO&gt; cartVOList = cartService.add(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;
&#125;
</code></pre>
<h3 id="更新、删除购物车接口"><a href="#更新、删除购物车接口" class="headerlink" title="更新、删除购物车接口"></a>更新、删除购物车接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
@PostMapping(&quot;/update&quot;)
    @ApiOperation(&quot;更新购物车&quot;)
    public ApiRestResponse update(@RequestParam Integer productId, @RequestParam Integer count)&#123;
        //86.去service层中写更新方法 CartServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.update(UserFilter.currentUser.getId(), productId, count);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/delete&quot;)
    @ApiOperation(&quot;删除保护购物车&quot;)
    public ApiRestResponse delete(@RequestParam Integer productId)&#123;
        //87.删除保护购物车方法
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.delete(UserFilter.currentUser.getId(), productId);
        return ApiRestResponse.success(cartVOList);
    &#125;
=====================================================================
127.0.0.1:8083/cart/delete?productId=22
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
 @Override
    public List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count)&#123;
        //86.去service层中写更新方法
        validProduct(productId, count);
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则更新数量
            Cart cartNew = new Cart();
            cartNew.setQuantity(count);
            cartNew.setId(cart.getId());
            cartNew.setProductId(cart.getProductId());
            cartNew.setUserId(cart.getUserId());
            //无论是否想买都选中
            cartNew.setSelected(Constant.Cart.CHECKED);
            cartMapper.updateByPrimaryKeySelective(cartNew);
        &#125;
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; delete(Integer userId, Integer productId)&#123;
        //86.去service层中写更新方法
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //这个商品之前不在购物车里，无法更新
            throw new ImoocMallException(ImoocMallExceptionEnum.DELETE_FAILED);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以删除
            cartMapper.deleteByPrimaryKey(cart.getId());
        &#125;
        return this.list(userId);
    &#125;
======================================================================
127.0.0.1:8083/cart/update?productId=22&amp;count=1
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/624114484">浅谈@RequestParam、@RequestBody、@PathVariable - 知乎 (zhihu.com)</a></p>
<h3 id="选中购物车相关接口"><a href="#选中购物车相关接口" class="headerlink" title="选中购物车相关接口"></a>选中购物车相关接口</h3><pre><code class="java">com/imooc/mall/controller/CartController.java
 @PostMapping(&quot;/select&quot;)
    @ApiOperation(&quot;选择/不选择购物车的某商品&quot;)
    public ApiRestResponse select(@RequestParam Integer productId, @RequestParam Integer selected)&#123;
        //88.选/不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
        List&lt;CartVO&gt; cartVOList = cartService.selectOrNot(UserFilter.currentUser.getId(), productId,selected);
        return ApiRestResponse.success(cartVOList);
    &#125;

    @PostMapping(&quot;/selectAll&quot;)
    @ApiOperation(&quot;全选择/全不选择购物车的某商品&quot;)
    public ApiRestResponse selectAll(@RequestParam Integer selected)&#123;
        //89.全选/全不选购物车某商品
        //不能传入userId, cartId, 否则可以删除别人的购物车
////90.订单模块接口编写 91创建OrderController.java  OrderService.java  OrderServiceImpl.java
        List&lt;CartVO&gt; cartVOList = cartService.selectAllOrNot(UserFilter.currentUser.getId(), selected);
        return ApiRestResponse.success(cartVOList);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/CartServiceImpl.java
    @Override
    public List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected)&#123;
        Cart cart = cartMapper.selectCartByUserIdAndProductId(userId, productId);
        if (cart==null)&#123;
            //88.这个商品之前不在购物车里，无法选择/不选中
            throw new ImoocMallException(ImoocMallExceptionEnum.UPDATE_FAILD);
        &#125;else &#123;
            //这个商品已经在购物车里了，则可以选中/不选中
            cartMapper.selectOrNot(userId, productId, selected);
        &#125;//返回购物车列表
        return this.list(userId);
    &#125;

    @Override
    public List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected)&#123;
        //89.这里填null是对mapper中的sql进行等于null判断的语句 改变选中状态
        cartMapper.selectOrNot(userId, null, selected);
        return this.list(userId);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/CartService.java
package com.imooc.mall.service;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.model.pojo.Category;
import com.imooc.mall.model.request.AddCategoryReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.model.vo.CategoryVO;

import java.util.List;

/**
 * 79.购物车service 增加CartServiceImpl
 */
public interface CartService &#123;

    //87.补全list实现类
    List&lt;CartVO&gt; list(Integer userId);

    List&lt;CartVO&gt; add(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; update(Integer userId, Integer productId, Integer count);

    List&lt;CartVO&gt; delete(Integer userId, Integer productId);

    List&lt;CartVO&gt; selectOrNot(Integer userId, Integer productId, Integer selected);

    List&lt;CartVO&gt; selectAllOrNot(Integer userId, Integer selected);
&#125;
</code></pre>
<h3 id="总结购物车模块"><a href="#总结购物车模块" class="headerlink" title="总结购物车模块"></a>总结购物车模块</h3><ul>
<li><h5 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h5><ul>
<li>MyBatis返回非标准对象、后期计算单样商品的总价 [数据库无法直接查到]</li>
<li>添加商品到购物车时，根据是否已经存在该商品，有不同逻辑</li>
</ul>
</li>
<li><p>常见错误：不做越权判断 [不允许前端传入Id]</p>
</li>
</ul>
<h3 id="创建订单接口-主流程框架搭建"><a href="#创建订单接口-主流程框架搭建" class="headerlink" title="创建订单接口 - 主流程框架搭建"></a>创建订单接口 - 主流程框架搭建</h3><ul>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h3 id="生成订单-——-用户下单"><a href="#生成订单-——-用户下单" class="headerlink" title="生成订单 —— 用户下单"></a>生成订单 —— 用户下单</h3><ul>
<li>入参</li>
<li>从购物车中查找已经勾选的商品</li>
<li>判断商品是否正在售卖中</li>
<li>判断库存，保证不超卖，扣库存</li>
<li>数据库事务(实操演示效果)</li>
<li>删除购物车中对应的商品</li>
<li>生成订单</li>
<li>订单号生成规则</li>
<li>循环保存每个商品到order_item表</li>
<li>进入Coding阶段</li>
</ul>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        return null;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.CartMapper;
import com.imooc.mall.model.dao.CategoryMapper;
import com.imooc.mall.model.dao.ProductMapper;
import com.imooc.mall.model.pojo.Cart;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;

    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
    &#125;
    //判断商品是否存在、上下架状态、库存
    //把购物车对象转换为订单item对象
    //扣库存
    //把购物车中的已勾选商品删除
    //生成订单
    //生成订单号,有独立的规则
    //循环保存每个商品的order_item表
    //把结果返回
&#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/exception/ImoocMallExceptionEnum.java
package com.imooc.mall.exception;

/**
 * 异常枚举
 */
//13.编写异常枚举 注意类是enum噢  14返回ApiRestResponse
public enum ImoocMallExceptionEnum &#123;
//  正确状态码是10000 这个错误的就10001 变红是因为没构造函数
    NEED_USER_NAME(10001,&quot;用户名不能为空&quot;),
    NEED_PASSWORD_NAME(10002,&quot;密码不能为空&quot;),
    PASSWORD_TOO_SHORT(10003,&quot;密码长度不能小于8位&quot;),
    NAME_EXISTED(10004,&quot;不允许重名&quot;),
    INSERT_FAILED(10005,&quot;插入失败，请重试&quot;),
    WRONG_PASSWORD(10006,&quot;密码错误&quot;),
    NEED_LOGIN(10007,&quot;用户未登录&quot;),
    UPDATE_FAILD(10008,&quot;更新失败&quot;),
    NEED_ADMIN(10009,&quot;无管理员权限&quot;),
    NAME_NOT_NULL(10010,&quot;参数不能为空&quot;),
    CREATE_FAILED(10011,&quot;新增失败&quot;),
    REQUEST_PARAM_ERROR(10012,&quot;参数错误&quot;),
    DELETE_FAILED(10013,&quot;删除失败&quot;),
    MKDIR_FAILED(10014,&quot;文件夹创建失败&quot;),
    UPLOAD_FAILED(10015,&quot;图片上传失败&quot;),
    NOT_SALE(10016,&quot;商品状态不可售&quot;),
    NOT_ENOUGH(10017,&quot;商品库存不足&quot;),
    CART_EMPTY(10018, &quot;购物车已勾选的商品为空&quot;),
    SYSTEM_ERROR(20000,&quot;系统异常&quot;);


    //异常码
    Integer code;
    //异常信息
    String msg;

    ImoocMallExceptionEnum(Integer code, String msg) &#123;
        this.code = code;
        this.msg = msg;
    &#125;

    public Integer getCode() &#123;
        return code;
    &#125;

    public void setCode(Integer code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<h3 id="创建订单-——-对象转换与扣库存"><a href="#创建订单-——-对象转换与扣库存" class="headerlink" title="创建订单 —— 对象转换与扣库存"></a>创建订单 —— 对象转换与扣库存</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
package com.imooc.mall.service.impl;

import com.imooc.mall.common.Constant;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import com.imooc.mall.filter.UserFilter;
import com.imooc.mall.model.dao.*;
import com.imooc.mall.model.pojo.Order;
import com.imooc.mall.model.pojo.OrderItem;
import com.imooc.mall.model.pojo.Product;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.CartVO;
import com.imooc.mall.service.CartService;
import com.imooc.mall.service.OrderService;
import com.imooc.mall.util.OrderCodeFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
        //拿到用户ID
        Integer userId = UserFilter.currentUser.getId();
        //从购物车查找已经勾选的商品 CartVO里面包含着任何信息
        List&lt;CartVO&gt; cartVOList = cartService.list(userId);
        //勾选的单独拿出来
        ArrayList&lt;CartVO&gt; cartVOListTemp = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO = cartVOList.get(i);
            if (cartVO.getSelected().equals(Constant.Cart.CHECKED)) &#123;
                cartVOListTemp.add(cartVO);
            &#125;
        &#125;
        cartVOList = cartVOListTemp;
        //如果购物车已勾选的为空,报错
        if (CollectionUtils.isEmpty(cartVOList))&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.CART_EMPTY);
        &#125;
        //判断商品是否存在、上下架状态、库存
        validSaleStatusAndStock(cartVOList);
        //把购物车对象转换为订单item对象
        List&lt;OrderItem&gt; orderItemList = cartVOListToOrderItemList(cartVOList);
        //扣库存
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            Product product = productMapper.selectByPrimaryKey(orderItem.getProductId());
            int stock = product.getStock() - orderItem.getQuantity();
            if (stock &lt; 0)&#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
            product.setStock(stock);
            productMapper.updateByPrimaryKeySelective(product);
        &#125;
        //把购物车中的已勾选商品删除
        cleanCart(cartVOList);
        //生成订单
        Order order = new Order();
        //93.创建一个Util/OrderCodeFactory
        //生成订单号,有独立的规则
        String orderNo = OrderCodeFactory.getOrderCode(Long.valueOf(userId));
        order.setOrderNo(orderNo);
        order.setUserId(userId);
        order.setTotalPrice(totalPrice(orderItemList));
        order.setReceiverName(createOrderReq.getReceiverName());
        order.setReceiverMobile(createOrderReq.getReceiverMobile());
        order.setReceiverAddress(createOrderReq.getReceiverAddress());
        order.setOrderStatus(Constant.OrderStatusEnum.NOT_PAID.getCode()); //94.去Constant定义订单状态
        //循环保存每个商品的order_item表
        order.setPostage(0);
        order.setPaymentType(1);
        //插入到Order表
        orderMapper.insertSelective(order);
        //循环保存每个商品到order_item表
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            orderItem.setOrderNo(order.getOrderNo());
            orderItemMapper.insertSelective(orderItem);
        &#125;
        //把结果返回
        return orderNo;
        //95.回到Controller调用
    &#125;
//92.生成相似代码并改造
    private void validSaleStatusAndStock(List&lt;CartVO&gt; cartVOList) &#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            Product product = productMapper.selectByPrimaryKey(cartVO.getProductId());
            //判断商品是否存在，商品是否上架
            if (product == null || product.getStatus().equals(Constant.SaleStatus.NOT_SALE)) &#123;
                //82. 1是上架 1不明确要形成代码让顾客知道 Constant.java
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_SALE);
            &#125;
            //判断商品库存 如果要买的比库存多 就买不了
            if (cartVO.getQuantity() &gt; product.getStock()) &#123;
                throw new ImoocMallException(ImoocMallExceptionEnum.NOT_ENOUGH);
            &#125;
        &#125;
    &#125;
    private List&lt;OrderItem&gt; cartVOListToOrderItemList(List&lt;CartVO&gt; cartVOList) &#123;
        List&lt;OrderItem&gt; orderItemList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(cartVO.getProductId());
            //记录商品快照信息
            orderItem.setProductName(cartVO.getProductName());
            orderItem.setProductImg(cartVO.getProductImage());
            orderItem.setUnitPrice(cartVO.getPrice());
            orderItem.setQuantity(cartVO.getQuantity());
            orderItem.setTotalPrice(cartVO.getTotalPrice());
            orderItemList.add(orderItem);
        &#125;
        return orderItemList;
    &#125;
    private void cleanCart(List&lt;CartVO&gt; cartVOList)&#123;
        for (int i = 0; i &lt; cartVOList.size(); i++) &#123;
            CartVO cartVO =  cartVOList.get(i);
            cartMapper.deleteByPrimaryKey(cartVO.getId());

        &#125;
    &#125;
    private Integer totalPrice(List&lt;OrderItem&gt; orderItemList)&#123;
        Integer totalPrice = 0;
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem =  orderItemList.get(i);
            totalPrice += orderItem.getTotalPrice();
        &#125;
        return totalPrice;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/OrderCodeFactory.java
package com.imooc.mall.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Random;

/**
 * 描述：     生成订单No工具类
 */
public class OrderCodeFactory &#123;

    /**
     * 订单类别头
     */
    private static final String ORDER_CODE = &quot;1&quot;;
    /**
     * 随机编码
     */
    private static final int[] r = new int[]&#123;7, 9, 6, 2, 8, 1, 3, 0, 5, 4&#125;;
    /**
     * 用户id和随机数总长度
     */
    private static final int maxLength = 5;

    /**
     * 更具id进行加密+加随机数组成固定长度编码
     */
    private static String toCode(Long id) &#123;
        String idStr = id.toString();
        StringBuilder idSb = new StringBuilder();
        for (int i = idStr.length() - 1; i &gt;= 0; i--) &#123;
            idSb.append(r[idStr.charAt(i) - &#39;0&#39;]);
        &#125;
        return idSb.append(getRandom(maxLength - idStr.length())).toString();
    &#125;

    /**
     * 生成时间戳
     */
    private static String getDateTime() &#123;
        DateFormat sdf = new SimpleDateFormat(&quot;HHmmss&quot;);
        return sdf.format(new Date());
    &#125;

    /**
     * 生成固定长度随机码
     *
     * @param n 长度
     */
    private static long getRandom(long n) &#123;
        long min = 1, max = 9;
        for (int i = 1; i &lt; n; i++) &#123;
            min *= 10;
            max *= 10;
        &#125;
        long rangeLong = (((long) (new Random().nextDouble() * (max - min)))) + min;
        return rangeLong;
    &#125;

    /**
     * 生成不带类别标头的编码
     */
    private static synchronized String getCode(Long userId) &#123;
        userId = userId == null ? 10000 : userId;
        return getDateTime() + toCode(userId);
    &#125;

    /**
     * 生成订单单号编码
     */
    public static String getOrderCode(Long userId) &#123;
        return ORDER_CODE + getCode(userId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/common/Constant.java
package com.imooc.mall.common;

import com.google.common.collect.Sets;
import com.imooc.mall.exception.ImoocMallException;
import com.imooc.mall.exception.ImoocMallExceptionEnum;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Set;


/**
 * 21.SALT常量值 写完以后去UserServiceImpl重写密码代码
 */
@Component //让spring帮注入value
public class Constant &#123;
    public static final String SALT = &quot;aSp[PCx,aw.xq246&#125;&quot;;
    public static final String IMOOC_MALL_USER = &quot;imooc_mall_user&quot;;
    public static String FILE_UPLOAD_DIR;
    //64.为了解决上传图片系统异常报错 注入失败的原因是上方是static普通变量 set方法把静态变量赋值
    @Value(&quot;$&#123;file.upload.dir&#125;&quot;)
    public void setFileUploadDir(String fileUploadDir)&#123;
        FILE_UPLOAD_DIR = fileUploadDir;
    &#125;//65.打开ImoocMallWebMvcConfig 加一个映射规则

    //74.排序处理 去Constant定义支持的排序模式和手段
    public interface ProductListOrderBy&#123;
        Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet(&quot;price desc&quot;,&quot;price asc&quot;);
    &#125;
    //83.创建商品上下架的状态 创建CartMapper[Cart selectCartByUserIdAndProductId] 写sql 84再去CartServiceImpl
    public interface SaleStatus&#123;
        int NOT_SALE = 0; //商品下架状态
        int SALE = 1; //商品上架状态
    &#125;
    public interface Cart&#123;
        int UN_CHECKED = 0; //购物车未选中状态
        int CHECKED = 1; //购物车选中状态
    &#125;
    public enum OrderStatusEnum&#123;
        CANCELED(0, &quot;用户已取消&quot;),
        NOT_PAID(10, &quot;未付款&quot;),
        PAID(20, &quot;已付款&quot;),
        DELIVERED(30, &quot;已发货&quot;),
        ;

        private String value;
        private int code;
        //94.去Constant定义订单状态
        OrderStatusEnum(int code,String value)&#123;
            this.value = value;
            this.code = code;
        &#125;
        public static OrderStatusEnum codeOf(int code)&#123;
            for (OrderStatusEnum orderStatusEnum : values())&#123;
                if (orderStatusEnum.getCode() == code)&#123;
                    return orderStatusEnum;
                &#125;
            &#125;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ENUM);
        &#125;

        public String getValue() &#123;
            return value;
        &#125;

        public void setValue(String value) &#123;
            this.value = value;
        &#125;

        public int getCode() &#123;
            return code;
        &#125;

        public void setCode(int code) &#123;
            this.code = code;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="添加数据库事务"><a href="#添加数据库事务" class="headerlink" title="添加数据库事务"></a>添加数据库事务</h3><pre><code class="java">//95.写数据库事务代码 @Transactional (要么全对全要 要么全不要)
    @Transactional(rollbackFor = Exception.class)
    @Override
    public String create(CreateOrderReq createOrderReq) &#123;
     ......
    &#125;
</code></pre>
<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
    public OrderVO detail(String orderNo)&#123;

    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderItemVO.java
public class OrderItemVO &#123;
    private Integer id;

    private String orderNo;

    private Integer productId;

    private String productName;

    private String productImg;

    private Integer unitPrice;

    private Integer quantity;

    private Integer totalPrice;
</code></pre>
<pre><code class="java">com/imooc/mall/model/vo/OrderVO.java
public class OrderVO &#123;
    private Integer id;

    private String orderNo;

    private Integer userId;

    private Integer totalPrice;

    private String receiverName;

    private String receiverMobile;

    private String receiverAddress;

    private Integer orderStatus;

    private Integer postage;

    private Integer paymentType;

    private Date deliveryTime;

    private Date payTime;

    private Date endTime;

    private Date createTime;

    private Date updateTime;
</code></pre>
<h5 id="订单状态"><a href="#订单状态" class="headerlink" title="订单状态"></a>订单状态</h5><ul>
<li>0 用户已取消</li>
<li>10 未付款(下单后的初始状态)</li>
<li>20 已付款</li>
<li>30 已发货</li>
<li>40 交易完成</li>
</ul>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 /* 95.继续实现Service实现类 拷贝一个Order成OrderVo 新增两个属性
        private String orderStatusName;
        private List&lt;OrderItemVo&gt; orderItemVoList;
        因为没有&lt;OrderItemVo&gt;要根据需求去创建
        拷贝OrderItem成OrderItemVO 更改属性
        之后回来补写代码
     */
   @Override
    public OrderVO detail(String orderNo)&#123;
        //96.去创建mapper的方法后回来补写代码 97写订单controller
        Order order = orderMapper.selectByOrderNo(orderNo);
        //订单不存在,则报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        OrderVO orderVO = getOrderVo(order);
        return orderVO;
    &#125;

    private OrderVO getOrderVo(Order order) &#123;
        OrderVO orderVO = new OrderVO();
        BeanUtils.copyProperties(order,orderVO);
        //获取订单对应的orderItemVOList
        List&lt;OrderItem&gt; orderItemList = orderItemMapper.selectByOrderNo(order.getOrderNo());
        //OrderItem和OrderItem相比少了几个字段
        List&lt;OrderItemVO&gt; orderItemVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderItemList.size(); i++) &#123;
            OrderItem orderItem = orderItemList.get(i);
            OrderItemVO orderItemVO = new OrderItemVO();
            BeanUtils.copyProperties(orderItem, orderItemVO);
            orderItemVOList.add(orderItemVO);
        &#125;
        orderVO.setOrderItemVOList(orderItemVOList);
        //com/imooc/mall/common/Constant.java的列举枚举
        orderVO.setOrderStatusName(Constant.OrderStatusEnum.codeOf(orderVO.getOrderStatus()).getValue());
        return orderVO;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
package com.imooc.mall.model.dao;

import com.imooc.mall.model.pojo.Order;
import org.springframework.stereotype.Repository;

@Repository
public interface OrderMapper &#123;
    int deleteByPrimaryKey(Integer id);

    int insert(Order record);

    int insertSelective(Order record);

    Order selectByPrimaryKey(Integer id);

    int updateByPrimaryKeySelective(Order record);

    int updateByPrimaryKey(Order record);

    Order selectByOrderNo(String orderNo);
&#125;

=====================================================
 &lt;select id=&quot;selectByOrderNo&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.String&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where order_no = #&#123;orderNo&#125;
  &lt;/select&gt;
</code></pre>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
package com.imooc.mall.controller;

import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.model.request.CreateOrderReq;
import com.imooc.mall.model.vo.OrderVO;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 91.订单Controller 新建一个根据pojo的Order → CreateOrderReq 新建一个OrderService
 */
@RestController
public class OrderController &#123;
    @Autowired
    OrderService orderService;

    @PostMapping(&quot;order/create&quot;)
    @ApiOperation(&quot;创建订单&quot;)
    public ApiRestResponse create(@RequestBody CreateOrderReq createOrderReq)&#123;
        //95.调用orderService
        String orderNo = orderService.create(createOrderReq);
        return ApiRestResponse.success(orderNo);
    &#125;

    @GetMapping(&quot;order/detail&quot;)
    @ApiOperation(&quot;前台订单详情&quot;)
    public ApiRestResponse detail(@RequestParam String orderNo)&#123;
        //95.调用orderService  Service层具体实现
        OrderVO orderVO = orderService.detail(orderNo);
        return ApiRestResponse.success(orderVO);
    &#125;
&#125;
==========================================
生成订单详情 GET:127.0.0.1:8083/order/detail?orderNo=100233359639
</code></pre>
<h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//97.写一个订单列表controller
    @GetMapping(&quot;order/list&quot;)
    @ApiOperation(&quot;前台订单列表&quot;)
    public ApiRestResponse list(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        //95.调用list   Service  Service层具体实现
        PageInfo pageInfo = orderService.listForCustomer(pageNum, pageSize);
        return  ApiRestResponse.success(pageInfo);
    &#125;
===============================================
订单列表：GET:127.0.0.1:8083/order/list?pageNum=1&amp;pageSize=10
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
  //97.前台订单实现类 搞个OrderMapper中的selectForCustomer
    @Override
    public PageInfo listForCustomer(Integer pageNum, Integer pageSize)&#123;
        Integer userId = UserFilter.currentUser.getId();
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectForCustomer(userId);
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;

    private List&lt;OrderVO&gt; orderListToOrderVOList(List&lt;Order&gt; orderList) &#123;
        List&lt;OrderVO&gt; orderVOList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; orderList.size(); i++) &#123;
            Order order =  orderList.get(i);
            OrderVO orderVO = getOrderVo(order);
            orderVOList.add(orderVO);
        &#125;
        return  orderVOList;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
 List&lt;Order&gt; selectForCustomer(Integer userId);
===============================================
mappers/OrderMapper.xml
  &lt;select id=&quot;selectForCustomer&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    where user_id = #&#123;userId&#125;
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><pre><code class="java">com/imooc/mall/controller/OrderController.java
//98.写一个订单取消controller
    @PostMapping(&quot;order/cancel&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse cancel(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//98.写一个订单取消实现类
    @Override
    public void cancel(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null)&#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //验证用户身份
        //订单存在,需要判断所属
        Integer userId = UserFilter.currentUser.getId();
        if (!order.getUserId().equals(userId)) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //没有付款才可以取消
        if (order.getOrderStatus().equals(Constant.OrderStatusEnum.NOT_PAID.getCode())) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.CANCELED.getCode());
            order.setEndTime(new Date());
            //更新状态
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="二维码接口开发"><a href="#二维码接口开发" class="headerlink" title="二维码接口开发"></a>二维码接口开发</h3><p><a target="_blank" rel="noopener" href="https://tool.oschina.net/qr?type=2">在线生成 QR Code (oschina.net)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/mall/controller/OrderController.java
//99.生成支付二维码
    @GetMapping(&quot;order/qrcode&quot;)
    @ApiOperation(&quot;前台取消订单&quot;)
    public ApiRestResponse qrcode(@RequestParam String orderNo)&#123;
        orderService.cancel(orderNo);
        return  ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //99.生成支付二维码 pom.xml生成新的二维码依赖 util新建一个QRCodeGenerator类
       @Override
    public String qrcode(String orderNo) &#123;
        //得到请求相关的信息
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();//不能直接拿到内网的信息 要经过多层转发才可以
        //去application.properties配置一下可以访问的ip  去上面String ip
        String address = ip + &quot;:&quot; + request.getLocalPort();//拼接一下 这下生成的是整个地址
        String payUrl = &quot;http://&quot; + address + &quot;/pay?orderNo=&quot; + orderNo;
        System.out.println(address);
        System.out.println(payUrl);
        try &#123;
            QRCodeGenerator.generateQRCodeImage(payUrl, 350, 350, Constant.FILE_UPLOAD_DIR + orderNo + &quot;.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
        //这个图片可以通过这个url访问到
        String pngAddress = &quot;http://&quot; + address + &quot;/images/&quot; + orderNo + &quot;.png&quot;;
        return pngAddress;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/util/QRCodeGenerator.java
package com.imooc.mall.util;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

/**
 * 99.生成二维码工具
 */
public class QRCodeGenerator &#123;
    public static void generateQRCodeImage(String text, int width, int height, String filePath) throws WriterException, IOException &#123;
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height);
        Path path = FileSystems.getDefault().getPath(filePath);
        MatrixToImageWriter.writeToPath(bitMatrix,&quot;PNG&quot;,path);
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            generateQRCodeImage(&quot;PANCHUNYAO&quot;, 350,350,&quot;/Users/Pluminary/Desktop/idea_Space/mall_file_upload/QRTest.png&quot;);
        &#125; catch (WriterException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">application.properties
file.upload.dir=/Users/Pluminary/Desktop/idea_Space/mall_file_upload/
file.upload.ip=127.0.0.1
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
/**
 * 91.★★ 订单Service实现类 ★★
 */
@Service
public class OrderServiceImpl implements OrderService &#123;
    @Autowired
    CartService cartService;
    @Autowired
    ProductMapper productMapper;
    @Autowired
    CartMapper cartMapper;
    @Autowired
    OrderMapper orderMapper;
    @Autowired
    OrderItemMapper orderItemMapper;
    @Value(&quot;$&#123;file.upload.ip&#125;&quot;)
    String ip;
............
&#125;
</code></pre>
<h3 id="后台订单列表接口"><a href="#后台订单列表接口" class="headerlink" title="后台订单列表接口"></a>后台订单列表接口</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //100.实现类
    @Override
    public PageInfo listForAdmin(Integer pageNum, Integer pageSize) &#123;//想看到所有订单
        PageHelper.startPage(pageNum, pageSize);
        List&lt;Order&gt; orderList = orderMapper.selectAllForAdmin();
        List&lt;OrderVO&gt; orderVOList = orderListToOrderVOList(orderList);
        //新建一个pageinfo返回 方便前端查看
        PageInfo pageInfo = new PageInfo&lt;&gt;(orderList);
        pageInfo.setList(orderVOList);
        return pageInfo;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/model/dao/OrderMapper.java
List&lt;Order&gt; selectAllForAdmin();
===========================================
mappers/OrderMapper.xml 
&lt;select id=&quot;selectAllForAdmin&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;integer&quot;&gt;
    select
    &lt;include refid=&quot;Base_Column_List&quot;/&gt;
    from imooc_mall_order
    order by create_time desc
  &lt;/select&gt;
</code></pre>
<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><h6 id="根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付"><a href="#根据订单号生成支付二维码-→-扫码支付-→-访问支付URL-完成支付" class="headerlink" title="根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付"></a>根据订单号生成支付二维码 → 扫码支付 → 访问支付URL, 完成支付</h6><pre><code class="java">com/imooc/mall/controller/OrderController.java
 //101.支付接口
    @GetMapping(&quot;pay&quot;)
    @ApiOperation(&quot;支付接口&quot;)
    public ApiRestResponse pay(@RequestParam String orderNo)&#123;
        orderService.pay(orderNo);
        return ApiRestResponse.success();
    &#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
//101.支付
    @Override
    public void pay(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 未付款才可以付款
        if (order.getOrderStatus() == Constant.OrderStatusEnum.NOT_PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.PAID.getCode());
            order.setPayTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="完结订单"><a href="#完结订单" class="headerlink" title="完结订单"></a>完结订单</h3><pre><code class="java">com/imooc/mall/controller/OrderAdminController.java
package com.imooc.mall.controller;

import com.github.pagehelper.PageInfo;
import com.imooc.mall.common.ApiRestResponse;
import com.imooc.mall.service.OrderService;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * 100.订单后台管理Controller
 */
@RestController
public class OrderAdminController &#123;
    @Autowired
    OrderService orderService;

    @GetMapping(&quot;admin/order/list&quot;)
    @ApiOperation(&quot;管理员订单列表&quot;)
    public ApiRestResponse listForAdmin(@RequestParam Integer pageNum, @RequestParam Integer pageSize)&#123;
        PageInfo pageInfo = orderService.listForAdmin(pageNum, pageSize);
        return ApiRestResponse.success(pageInfo);
    &#125;

    /**
     * 102.发货。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     */
    @GetMapping(&quot;admin/order/delivered&quot;)
    @ApiOperation(&quot;管理员发货&quot;)
    public ApiRestResponse delivered(@RequestParam String orderNo)&#123;
        orderService.deliver(orderNo);
        return ApiRestResponse.success();
    &#125;

    /**
     * 103.完结订单。订单状态流程：0用户已取消，10未付款，20已付款，30已发货，40交易完成
     * 管理员和用户都可以调用
     */
    @GetMapping(&quot;order/finish&quot;)
    @ApiOperation(&quot;完结订单&quot;)
    public ApiRestResponse finish(@RequestParam String orderNo)&#123;
        orderService.finish(orderNo);
        return ApiRestResponse.success();
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/mall/service/impl/OrderServiceImpl.java
 //102.管理订单实现类开发 发货
    @Override
    public void deliver(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //支付前的判断 判断已付款的
        if (order.getOrderStatus() == Constant.OrderStatusEnum.PAID.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.DELIVERED.getCode());
            order.setDeliveryTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
    //103.完结订单
    @Override
    public void finish(String orderNo)&#123;
        //能查到订单就取消
        Order order = orderMapper.selectByOrderNo(orderNo);
        //查不到订单，报错
        if (order == null) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NO_ORDER);
        &#125;
        //有可能管理员调用 有可能用户调用 如果是普通用户, 要去校验一下订单所属
        if (!userService.checkAdminRole(UserFilter.currentUser) &amp;&amp; !order.getUserId().equals(UserFilter.currentUser.getId())) &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.NOT_YOUR_ORDER);
        &#125;
        //支付前的判断 判断已付款的 //发货后可以完结订单
        if (order.getOrderStatus() == Constant.OrderStatusEnum.DELIVERED.getCode()) &#123;
            order.setOrderStatus(Constant.OrderStatusEnum.FINISHED.getCode());
            order.setEndTime(new Date());
            orderMapper.updateByPrimaryKeySelective(order);
        &#125;else &#123;
            throw new ImoocMallException(ImoocMallExceptionEnum.WRONG_ORDER_STATUS);
        &#125;
    &#125;
</code></pre>
<h3 id="全流程测试"><a href="#全流程测试" class="headerlink" title="全流程测试"></a>全流程测试</h3><ul>
<li>Postman实操</li>
<li>登录 → 浏览商品 → 加入购物车 → 下单 <ul>
<li>​                                                            → 取消订单</li>
<li>​                                                            → 扫码支付 → 发货 → 收获 → 订单完结</li>
</ul>
</li>
</ul>
<h5 id="总结订单模块"><a href="#总结订单模块" class="headerlink" title="总结订单模块"></a>总结订单模块</h5><ul>
<li><p>重难点</p>
<ul>
<li>VO的封装、裁剪</li>
<li>一个订单内包括多个商品</li>
<li>订单状态流转</li>
<li>二维码生成</li>
</ul>
</li>
<li><p>常见错误：把POJO返回到前端</p>
</li>
</ul>
<h1 id="上线前准备工作"><a href="#上线前准备工作" class="headerlink" title="上线前准备工作"></a>上线前准备工作</h1><h3 id="阿里云部署"><a href="#阿里云部署" class="headerlink" title="阿里云部署"></a>阿里云部署</h3><p>把每个 com&#x2F;imooc&#x2F;mall&#x2F;model&#x2F;request&#x2F;… 类都加上**toString()**方法 方便调试<br><strong>后台、前台、获取类的行为</strong> 的目录列表都是 <strong>Get</strong>Mapping</p>
<h3 id="前端准备工作"><a href="#前端准备工作" class="headerlink" title="前端准备工作"></a>前端准备工作</h3><h6 id="把static里的前端文件导入项目中"><a href="#把static里的前端文件导入项目中" class="headerlink" title="把static里的前端文件导入项目中"></a>把static里的前端文件导入项目中</h6><pre><code class="java">com/imooc/mall/config/ImoocMallWebMvcConfig.java
//104.ImoocMallWebMvcConfig.java 根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
package com.imooc.mall.config;

import com.imooc.mall.common.Constant;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 42.配置地址映射 43去CategoryController.java 加一个 @ApiOperation(&quot;后台添加目录&quot;)
 * 44.新增一个目录的updateCategory的参数 [UpdateCategoryReq.java  ]
 */
@Configuration  //代表是一个配置
public class ImoocMallWebMvcConfig implements WebMvcConfigurer &#123;
    public void addResourceHandles(ResourceHandlerRegistry registry)&#123;
        //104.根据路由配置相关文件 以admin开头的文件会被路由到下面的Locations
        registry.addResourceHandler(&quot;/admin/**&quot;).addResourceLocations(&quot;classpath:/static/admin&quot;);
        //65.增加一个registry  66.新增接口继续开发 ProductAdminController
        registry.addResourceHandler(&quot;/images/**&quot;).addResourceLocations(&quot;file:&quot; + Constant.FILE_UPLOAD_DIR);
//     把地址给到对应的目录下
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(
                &quot;classpath:/META-INF/resources/webjars&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="部署云服务器"><a href="#部署云服务器" class="headerlink" title="部署云服务器"></a>部署云服务器</h3><ul>
<li>阿里云简介</li>
<li>选择云服务器并购买</li>
<li>环境配置</li>
<li>Spring Boot部署[包括maven打包 sql文件也要上传]</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ecs.console.aliyun.com/server/region/cn-hangzhou">云服务器管理控制台 (aliyun.com)</a></p>
<blockquote>
<p>免费试用三个月<br>账号: root<br>密码: panchunyao123!</p>
</blockquote>
<pre><code class="java">复制服务器的公网ip：47.98.225.105
cmd本地电脑 → ssh root@47.98.225.105
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57581439/article/details/124928451">在阿里云购买Linux服务器，配置宝塔环境，全图文，最最详细图解，保姆级教学_阿里云服务器怎么直接买宝塔-CSDN博客</a></p>
<blockquote>
<h2 id="【宝塔安装jdk1-8-yum安装-】"><a href="#【宝塔安装jdk1-8-yum安装-】" class="headerlink" title="【宝塔安装jdk1.8(yum安装)】"></a><strong>【宝塔安装jdk1.8(yum安装)】</strong></h2><p>1、检索检索1.8的列表</p>
<pre><code class="none">yum list java-1.8*
</code></pre>
<p>2、安装1.8.0的所有文件</p>
<pre><code class="none">yum install java-1.8.0-openjdk* -y
</code></pre>
<p>3、使用命令检查是否安装成功</p>
<pre><code class="none">java -version
</code></pre>
</blockquote>
<p>登录宝塔 → 绑定宝塔 → 下载软件<br>宝塔服务器[<a target="_blank" rel="noopener" href="http://47.98.225.105:22003/]">http://47.98.225.105:22003/]</a></p>
<pre><code class="sql">☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ 宝塔BaoTa ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
========================面板账户登录信息=========================
 外网面板地址: http://47.98.225.105:22003/1259ebfa
 内网面板地址: http://172.24.91.49:22003/1259ebfa
 username: grltvl7d
 password: 46303f93


======================== mysql-5.7 ===========================
root密码成功修改为: Panchunyao123![mysql-8.0]

[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123!
mysql&gt; create database imooc_mall;
mysql&gt; use imooc_mall;
Database changed
导入sql文件:imooc_mall_online.sql
从本机将其上传到服务器在cmd中运行:
scp /Users/Pluminary/Desktop/imooc_mall_online.sql root@47.98.225.105:22003:/root
输入服务器密码:panchunyao123!

回到服务器端输入：
mysql&gt; use imooc_mall
Database changed
mysql&gt; source /root/imooc_mall_online.sql
mysql&gt; show tables;
+-----------------------+
| Tables_in_imooc_mall  |
+-----------------------+
| imooc_mall_cart       |
| imooc_mall_category   |
| imooc_mall_order      |
| imooc_mall_order_item |
| imooc_mall_product    |
| imooc_mall_user       |
+-----------------------+
#为数据库赋予权限！！！
mysql&gt; grant all privileges on imooc_mall.* to &#39;root&#39;@&#39;127.0.0.1&#39; identified by &#39;Panchunyao123!&#39;;
--------------------------------------------------------------
MySql8.0
CREATE USER &#39;root&#39;@&#39;47.98.225.105&#39; IDENTIFIED BY &#39;Panchunyao123!&#39;;
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;47.98.225.105&#39; WITH GRANT OPTION;
--------------------------------------------------------------
mysql&gt; quit
Bye
[root@iZbp1dssknxftmjczbtpndZ ~]# mysql -uroot -pPanchunyao123! -h127.0.0.1
去云服务器 安全组 访问规则 入方向 手动添加一个 目的:8081/8081 源:0.0.0.0/0
==============================================================
</code></pre>
<p>整理文件上传到服务器 先**Build → Rebuild Project **<br>打包 <strong>Maven → Lifecycle → clean[之前的内容删除 不容易出错] → package[打包操作]</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_62488212/article/details/132412209">spring打包报错：Java Runtime (class file version 55.0), class file versions up to 52.0_there was an error in the forked process org&#x2F;testn-CSDN博客</a></p>
<pre><code class="sql">[INFO] Building jar: C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar
在本机cmd中运行把导好的包发送給服务器
C:\Users\Pluminary&gt;scp C:\Users\Pluminary\Desktop\idea_Space\mall\target\mall-0.0.1-SNAPSHOT.jar root@c:/root
#rm -rf images/ 删除images文件夹
新建一个文件夹
[root@iZbp1dssknxftmjczbtpndZ ~]# pwd
[root@iZbp1dssknxftmjczbtpndZ ~]# mkdir image

图片上传到服务器中[图片尽量在没有根目录空格的文件夹下 比如Spring Boot 中间有空格]
C:\Users\Pluminary&gt;scp C:/Users/Pluminary/Desktop/images/. root@47.98.225.105:/root/images/

在Xshell7中阿里云服务器
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
images  imooc_mall_online.sql  install.sh  mall-0.0.1-SNAPSHOT.jar

每一次部署之前要把当前的java停止掉
[root@iZbp1dssknxftmjczbtpndZ images]# lsof -i:8081
[root@iZbp1dssknxftmjczbtpndZ images]# kill -9 12345 //按照PID杀死端口号
-bash: kill: (12345) - No such process

部署到云服务器 [/root/null 2&gt;&amp;1 &amp;]将日志输出到哪里 这里是丢弃的意思
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 -Dspring.profiles.active=prod /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;
[1] 18656
如果没有别名就一个本来的application.properties
[root@iZbp1dssknxftmjczbtpndZ ~]# nohup java -jar -Dserver.port=8081 /root/mall-0.0.1-SNAPSHOT.jar &gt; /root/null 2&gt;&amp;1 &amp;


 #代表当前程序的进程号
[root@iZbp1dssknxftmjczbtpndZ ~]# lsof -i:8081   //查询端口号
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java    18656 root   19u  IPv6 195648      0t0  TCP *:tproxy (LISTEN)

============================================================================

若打不开请检查网页报错 寻找传入的application.prod.properties的 
spring.datasource.url地址和spring.datasource.username &amp;&amp; password数据库用户和密码

查看服务器的端口: mysql&gt; show global variables like &#39;port&#39;;

阿里云控制台:
https://ecs.console.aliyun.com/server/i-bp1dssknxftmjczbtpnd/detail?regionId=cn-hangzhou

如何查看linux服务器安装了tomcat：
rpm -qa|grep tomcat

宝塔安装目录: $cd /www/server/.....
[root@iZbp1dssknxftmjczbtpndZ data]# cd /www/server/tomcat/bin
#找到文件后启动tomcat
[root@iZbp1dssknxftmjczbtpndZ bin]# ./startup.sh
#看进程，如果返回一大串东西，说明tomcat启动成功。
[root@iZbp1dssknxftmjczbtpndZ ~]# ps -ef|grep tomcat

运行SpringBoot: 
[root@iZbp1dssknxftmjczbtpndZ ~]# ls
Desktop  images  imooc_mall_online.sql  install.sh  logs  mall-0.0.1-SNAPSHOT.jar  null
[root@iZbp1dssknxftmjczbtpndZ ~]# java -jar mall-0.0.1-SNAPSHOT.jar 

===============================================
当把SpringBoot项目的jar包部署到linux服务器中，启动SpringBoot项目，却无法正常访问，这是怎么回事呢？
主要的原因是端口号被Linux的firewall防火墙拦截掉了
解决办法：
1、查询已开启的端口列表：firewall-cmd --list-ports 
不出意外的话，是啥也没有，这也表示，所有端口都未放行，当然springboot项目的80端口也被拦截掉了
2、firewall-cmd --zone=public --add-port=1-12345/tcp --permanent
将端口1~12345全都开启
3、重启防火墙
service firewalld restart
4、重新运行springboot项目
5、成功访问
===============================================
</code></pre>
<blockquote>
<p>server.port&#x3D;8083<br>spring.datasource.name&#x3D;imooc_mall_datasource<br>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;47.98.225.105&#x2F;imooc_mall?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;true&amp;allowPublicKeyRetrieval&#x3D;true&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai<br>spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver<br>spring.datasource.username&#x3D;root<br>spring.datasource.password&#x3D;Panchunyao123!<br>mybatis.mapper-locations&#x3D;classpath:mappers&#x2F;*.xml<br>spring.redis.host&#x3D;localhost<br>spring.redis.port&#x3D;6379<br>spring.redis.password&#x3D;<br>file.upload.dir&#x3D;&#x2F;root&#x2F;images&#x2F;<br>file.upload.ip&#x3D;47.98.225.105<br>icode&#x3D;ABCDE</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46070108/article/details/116495116">SpringBoot上传图片，图片不能及时显示问题_springboot项目上传照片到uoload 不会实时更新-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42456466/article/details/91869955">Springboot 上传图片到项目路径下不能访问，需要重启_springboot能上传图片到win11中但无法访问图片-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/124680688">关于springboot项目图片上传到本地，必须重启之后才能访问的解决方案_springboot上传图片需要重启-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rqz__/article/details/130304492">关于IDEA2022开启热部署没有compiler.automake.allow.when.app.running的解决方案-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37954460/article/details/125842857">Linux部署SpringBoot项目无法访问问题_linux springboot项目启动外面不能访问-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/terry711/article/details/106226298/">linux服务器部署SpringBoot项目并查看项目运行日志_linux 怎么实时查看springboot 日志-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://class.imooc.com/course/qadetail/269346">线上发布报数据库没有连接成功，麻烦帮忙看…-慕课网 (imooc.com)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63693805/article/details/132626318">linux安装mysql 8 数据库（保姆级）_linux安装mysql8-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52885524/article/details/127076560">慕慕生鲜详细步骤全部打通(从无到上线)-CSDN博客</a></p>
<p>mysql8.0密码&#x3D;&gt; root &amp; Panchunyao123!</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/02/28/后端/SpringBoot入门及电商项目[SpringBoot_MyBatis.generator_Swagger2_Redis_Postman_RESTful_AOP_UUID_QRCode_Linux_Aliyun]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/">
        <h2>
            SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/18
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="慕课书评网学习内容"><a href="#慕课书评网学习内容" class="headerlink" title="慕课书评网学习内容"></a><span style ="color:red">慕课书评网学习内容</span></h1><p><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span></p>
<ul>
<li>讲解Spring&#x2F;Spring MVC&#x2F;MyBatis(SSM)整合配置过程</li>
<li>讲解<span style ="color:red"><strong>MyBatis-Plus</strong></span>敏捷开发插件的用法</li>
<li>开发Java Web应用”慕课书评网”</li>
</ul>
<h3 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h3><ul>
<li>SSM整合配置</li>
<li>MyBatis-Plus配置与应用</li>
<li>Kaptcha验证码组件使用</li>
<li>富文本编辑器wangEditor</li>
<li>Spring Task任务调度</li>
<li>基于阿里云实现短信验证</li>
<li>基于腾讯云的滑块验证码实现前置的人机登录检查</li>
</ul>
<h4 id="工程结构与开发规约-复习知识点"><a href="#工程结构与开发规约-复习知识点" class="headerlink" title="工程结构与开发规约 [复习知识点]"></a>工程结构与开发规约 [<span style = "color:red">复习知识点</span>]</h4><h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">mgallery - eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc.mgallery //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h3 id="什么是整合"><a href="#什么是整合" class="headerlink" title="什么是整合"></a>什么是整合</h3><ul>
<li>通过Spring IoC容器管理第三方框架对象, 让多框架形成整体</li>
<li><span style ="color:blue"><strong>SSM</strong> &#x3D;&gt; <span style ="color:red"><strong>S</strong></span>pring &#x2F; <span style ="color:red"><strong>S</strong></span>pring MVC &#x2F; <span style ="color:red"><strong>M</strong></span>yBatis</span>是业内最主流的框架搭配<ul>
<li>Spring MVC提供了控制器 基于Spring的Web交互的能力</li>
<li>Spring是对应用程序的对象进行创建和管理</li>
<li>MyBatis是完成了与底层数据库实现增删改查的操作</li>
</ul>
</li>
<li>SSM配置与使用是所有Java工程师必须掌握的技能</li>
</ul>
<h3 id="SSM整合三阶段"><a href="#SSM整合三阶段" class="headerlink" title="SSM整合三阶段"></a>SSM整合三阶段</h3><ul>
<li><span style ="color:red"><strong>Spring与Spring MVC环境配置</strong></span></li>
<li><span style ="color:red"><strong>Spring与MyBatis的整合配置</strong></span></li>
<li><span style ="color:red"><strong>整合其他组件: 声明式事务&#x2F;日志&#x2F;任务调度&#x2F;…</strong></span></li>
</ul>
<h3 id="Spring与Spring-MVC环境配置"><a href="#Spring与Spring-MVC环境配置" class="headerlink" title=" Spring与Spring MVC环境配置"></a><span style ="color:purple"> <strong>Spring与Spring MVC环境配置</strong></span></h3><ul>
<li>依赖Spring-WebMVC</li>
<li>配置DispatcherServlet</li>
<li>启用Spring MVC注解模式</li>
<li>配置请求与相应字符集</li>
<li>配置FreeMarker模板引擎</li>
<li>配置JSON序列化组件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/958385c851d8c4239be83aec9c90132408b1f53b/data/reader%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.png"></p>
<p>编写pom.xml  引入导入的依赖jar包<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fittec/article/details/118942425?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-118942425-blog-120412354.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.2&utm_relevant_index=4">IntelliJ IDEA 2021 自动下载pom文件中的依赖_pom中的自定义插件下载-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67401055/article/details/123938800?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123938800-blog-108093107.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.1&utm_relevant_index=3">idea编译Java项目的部分java文件并且生成class文件_idea将java文件编译成class-CSDN博客</a></p>
<blockquote>
<p>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★<br>设置resource和source<br>方法：点击文件右键-&gt;<strong>make direction as</strong></p>
<p>需要运行和引用的java文件设置为source文件，将配置文件(xml)等设置为resource文件<br>★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-reader&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;!--1.Maven依赖Spring-webmvc 第二步web.xml--&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--    Freemarker --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--   Jackson依赖包  --&gt;
        &lt;dependency&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.11.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">WEB-INF/web.xml    init-param变量 这个是放在servlet里面的，只有此servlet可以访问
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    2.配置DispatcherServlet 第三步applicationContext.xml--&gt;
 &lt;!--    DispatcherServlet是Spring MVC是最核心的对象
         DispatcherServlet用于拦截http请求        --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!--自动加载applicationContext--&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
&lt;!--        启动时初始化 servlet--&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt; &lt;!--与上面保持一致--&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;!-- 4.解决中文乱码问题  只会对Post请求生效 Get只需要修改tomcat的server.xml(8.0以上是自动的) 72行增加URIEncoding=&quot;UTF-8&quot; 第五步application--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt; &lt;!--初始化参数--&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/task
            http://www.springframework.org/schema/task/spring-task.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- 3.Spring框架启用SpringMVC注解模式 第四步web.xml--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
&lt;!-- 真正开启SpringMVC注解 --&gt;
&lt;!-- https://blog.csdn.net/u011066470/article/details/112438252 --&gt;
&lt;!-- &lt;mvc:annotation-driven&gt; Spring MVC用来提供Controller请求转发，json自动转换等功能。，默认会帮我们注册默认处理请求，参数和返回值的类 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
&lt;!-- 解决相应里的中文输出 --&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!-- 6.JSON(Jackson)序列化输出配置   --&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
&lt;!-- 诸如css/图片/js静态资源排除在外 使得SpringMVC对url处理效率加大   --&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性。 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名 --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="html">WEB-INF/ftl/test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
测试页面！！
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/controller/TestController.java
package com.imooc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import java.util.HashMap;
import java.util.Map;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/test/t1&quot;)
    public ModelAndView test1()&#123;
        return new ModelAndView(&quot;/test&quot;);
    &#125;
    @GetMapping(&quot;test/t2&quot;)
    @ResponseBody
    public Map test2()&#123;
        Map result = new HashMap();
        result.put(&quot;test&quot;,&quot;测试文本&quot;);
        return result;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a2272062968/article/details/120404192">IDEA Web项目out&#x2F;classes目录没有编译的class类文件 - IDEA环境下创建Maven WebApp_out中没有class文件夹-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/31486d18fb2b0875fc03efc01fd1d1b5939a6c84/data/idea%E4%B8%ADout%E7%9A%84WEB-INF%E7%83%AD%E9%83%A8%E7%BD%B2%E7%A9%B6%E6%9E%81%E6%96%B9%E6%B3%95.jpg"></p>
<h3 id="Spring与MyBatis整合配置"><a href="#Spring与MyBatis整合配置" class="headerlink" title=" Spring与MyBatis整合配置"></a><span style ="color:purple"> <strong>Spring与MyBatis整合配置</strong></span></h3><p>MyBatisUtils封装初始化代码 如果自己new了对象就不会享受spring的福利待遇</p>
<ul>
<li>依赖mybatis-spring及驱动</li>
<li>配置数据源与连接池</li>
<li>配置SqlSessionFactory</li>
<li>配置Mapper扫描器</li>
<li>创建mybatis-config.xml</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;!-- 5.配置Freemarker模板引擎 脚本存放地址 第六步见pom.xml mybatis依赖 --&gt;
    &lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
&lt;!--        对于本身的参数配置  --&gt;
        &lt;property name=&quot;freemarkerSettings&quot;&gt;
            &lt;props&gt;
&lt;!--        默认的编码类型 UTF-8 freemarker读取指定ftl文件时采用此字符集--&gt;
                &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;!--    使用何种模板引擎 创建的后缀名   --&gt;
    &lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    7. MyBatis与Spring的整合配置   --&gt;
      &lt;!--②.配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc_reader?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;initialSize&quot; value=&quot;5&quot;/&gt;
        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
    &lt;/bean&gt;
&lt;!--8. SqlSessionFactoryBean用于根据配置信息创建SqlSessionFactory,不再需要我们自己编码创建--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器 下一步9TestMapper --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!--  6. Mybatis整合步骤：①引入依赖 第七步看applicationContext.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.4&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        MyBatis与Spring整合组件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.14&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;
//接口作用Mybatis通过接口自动生成实现类
public interface TestMapper &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insert();
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="整合其他组件"><a href="#整合其他组件" class="headerlink" title="整合其他组件"></a><span style ="color:purple"><strong>整合其他组件</strong></span></h3><ul>
<li>配置logback日志输出</li>
<li>声明式事务配置</li>
<li>整合JUnit单元测试</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   11. 单元测试依赖 mappers加入test.xml mapper扫描接口后生成对应实现类 12test.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--  15导入依赖 scope打包时不会放进去 tomcat自带 但是测试时不用tomcat所以要加--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
&lt;!--   16加入日志依赖 logback日志组件 17创建logback.xml--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="xml">mappers/test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.TestMapper&quot;&gt;
&lt;!--   12. 与接口对应的完整类路径  ↓用于对应数据新增 对应TestMapper.java接口  13TestService --&gt;
    &lt;insert id=&quot;insert&quot;&gt;
        insert into test(content) values(&#39;测试内容&#39;)
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestService.java
package com.imooc.reader.service;

import com.imooc.reader.mapper.TestMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

@Service
public class TestService &#123;
// 13.运行时注入生成的对象 自动生成Test 选中上面的类 Code generate 14TestServiceTest.java
    @Resource
    private TestMapper testMapper;
//      @Transactional 要么全部完成 要么什么也不做
    @Transactional
    public void batchImport()&#123;
        for (int i = 0; i &lt; 5; i++) &#123;
//            if (i==3) &#123;
//                throw new RuntimeException(&quot;预期外异常&quot;);
//            &#125;
            testMapper.insert();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/TestServiceTest.java
package com.imooc.reader.service;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import static org.junit.Assert.*;

//14. 运行时自动初始IoC容器 + 说明配置文件在什么地方完成初始化 15依赖javaservlet pom.xml
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class TestServiceTest &#123;
    @Resource
    private TestService testService;

    @Test
    public void batchImport() &#123;
        testService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;
&lt;!--           17.       小时分钟秒   日志级别  线程名   说明何类何方法  对应日志消息+换行--&gt;
&lt;!--            18转至声明式事务 applicationContext上面的文件头加些配置信息 再去下面写--&gt;
            &lt;pattern&gt;%d&#123;HH:mm:ss&#125; %-5level [%thread] %logger&#123;30&#125; - %msg%n&lt;/pattern&gt;
            &lt;charset&gt;UTF-8&lt;/charset&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
&lt;!--    输出级别   --&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="java">@RunWith作用
@RunWith 就是一个运行器
@RunWith(JUnit4.class) 就是指用JUnit4来运行
@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境
@RunWith(Suite.class) 的话就是一套测试集合，
@ContextConfiguration Spring整合JUnit4测试时，使用注解引入多个配置文件
单个文件
@ContextConfiguration(Locations=“classpath：applicationContext.xml”)
@ContextConfiguration(classes = SimpleConfiguration.class)

多个文件时，可用&#123;&#125;
@ContextConfiguration(locations = &#123; “classpath:spring1.xml”, “classpath:spring2.xml” &#125;)
</code></pre>
<h3 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h3><p><a target="_blank" rel="noopener" href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a></p>
<ul>
<li>MyBatis-Plus(简称MP)是一个MyBatis的增强工具</li>
<li>自动实现Mapper CRUD操作, 极致提高数据库开发效率</li>
<li>MP在MyBatis的基础上只做增强不做改变</li>
</ul>
<h3 id="MyBatis-Plus整合三部曲"><a href="#MyBatis-Plus整合三部曲" class="headerlink" title="MyBatis-Plus整合三部曲"></a>MyBatis-Plus整合三部曲</h3><ul>
<li>pom引入mybatis-plus依赖</li>
<li>Spring XML更改配置SqlSessionFactory实现类</li>
<li>mybatis-config.xml增加MP分页插件</li>
</ul>
<h3 id="MyBatis-Plus开发三部曲"><a href="#MyBatis-Plus开发三部曲" class="headerlink" title="MyBatis-Plus开发三部曲"></a>MyBatis-Plus开发三部曲</h3><ul>
<li><p>创建实体类, <code>@TableName/ @Tableld/ @TableField</code>实现映射</p>
</li>
<li><p>创建Mapper接口继承BaseMapper, 创建Mapper XML</p>
</li>
<li><p>开发时注入Mapper对象, 通过内置API实现CRUD操作</p>
</li>
</ul>
<h3 id="MyBatis-Plus核心注解"><a href="#MyBatis-Plus核心注解" class="headerlink" title="MyBatis-Plus核心注解"></a>MyBatis-Plus核心注解</h3><ul>
<li><code>@TableName</code> - 将实体类与表名映射</li>
<li><code>@Tableld</code> - 说明对应属性是表的主键</li>
<li><code>@TableField</code> - 设置属性与列名的对应关系</li>
</ul>
<h3 id="BaseMapper接口核心API"><a href="#BaseMapper接口核心API" class="headerlink" title="BaseMapper接口核心API"></a>BaseMapper接口核心API</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>insert</strong>(entity)</td>
<td>数据新增,自动生成insert sql, 根据@Tableld决定注解生成方式</td>
</tr>
<tr>
<td><strong>updateById</strong>(entity)</td>
<td>根据主键更新对应对象, 自动生成update sql</td>
</tr>
<tr>
<td><strong>deleteById</strong>(id)</td>
<td>根据主键删除数据, 自动更新delete sql</td>
</tr>
<tr>
<td><strong>selectById</strong>(id)</td>
<td>按主键查询对应的实体对象</td>
</tr>
<tr>
<td>selectList(queryWrapper)</td>
<td>根据查询生成器(QueryWrapper)的条件自动生成sql查询返回List集合</td>
</tr>
<tr>
<td>selectPage(page,queryWrapper)</td>
<td>分页查询方法, 自动生成分页limit子句, 返回IPage分页对象</td>
</tr>
</tbody></table>
<pre><code class="xml">pom.xml
&lt;!--   19 整合Mybatis-plus依赖  修改application中65行   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml  【替换之前的sessionFactory】
&lt;!--  19. 原生Mybatis与Spring整合  自动实现接口的增删改查  20增加plus底层的分页查询插件 mybatis-config.xml--&gt;
&lt;!--    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;--&gt;
    &lt;bean id=&quot;sessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;!--    存储sql语句的mapper.xml文件 存储在哪个目录中 去创建mapper接口--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mappers/*.xml&quot;/&gt;
&lt;!-- 10.  MyBatis配置文件地址 去创建一个xml  第十一步pom加单元测试依赖--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;
&lt;!--  9. 配置Mapper扫描器  --&gt;
&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
&lt;!--  这样初始化mybatis时 会对所有mapper接口进行扫描 --&gt;
    &lt;property name=&quot;basePackage&quot; value=&quot;com.imooc.reader.mapper&quot;/&gt;
&lt;/bean&gt;
&lt;!--    18.声明式事务配置 控制事务的打开 提交 回滚 ↓--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    与之对应的注解模式！ 再去TestService.java添加  @Transactional --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
&lt;!--        驼峰命名转换 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;plugins&gt;
&lt;!--  20.配置Mybatis-Plus分页查询     21创entity/Test.java--&gt;
        &lt;plugin interceptor=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Test.java
// 21 Mybatis-plus运用   22mapper中TestMapper
@TableName(&quot;test&quot;) //说明实体对应哪一张表
public class Test &#123;
    @TableId(type = IdType.AUTO) //数据自增
    @TableField(&quot;id&quot;) //说明属性对应哪个字段
    private Integer id;
    //如果字段名与属性名相同或者符合驼峰命名转换规则 则TableField可以省略
    @TableField(&quot;content&quot;)
    private String content;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/TestMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Test;
//22.为了和BaseMapper里的insert()区别开 这个改名成insertSample
//接口作用Mybatis通过接口自动生成实现类 23.MyBatisPlusTest.java
public interface TestMapper extends BaseMapper&lt;Test&gt; &#123;
// 系统中接口很多不是所有的都对应mapper 9.application.xml
    public void insertSample();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/MyBatisPlusTest.java
package com.imooc.reader;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Test;
import org.junit.runner.RunWith;
import com.imooc.reader.mapper.TestMapper;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.List;

//23.利用插件调用增删改查  24以Bootstrap开发前端index.ftl
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MyBatisPlusTest &#123;
    @Resource
    private TestMapper testMapper;

    //增
    @org.junit.Test //直接进行调用 与注解重名 故此加包名
    public void testInsert() &#123;
        Test test = new Test();
        test.setContent(&quot;MyBatis Plus测试&quot;);
        //在接口中 com/imooc/reader/mapper/TestMapper.java
        testMapper.insert(test);
    &#125;

    //改
    @org.junit.Test
    public void testUpdate() &#123;
        Test test = testMapper.selectById(30);//按id号查询
        test.setContent(&quot;MyBatis Plus测试1&quot;);
        testMapper.updateById(test);
    &#125;

    //删
    @org.junit.Test
    public void testDelete() &#123;
        testMapper.deleteById(30);
    &#125;

    //查
    @org.junit.Test
    public void testSelect() &#123;
        //传入特殊包装对象
        QueryWrapper&lt;Test&gt; queryWrapper = new QueryWrapper&lt;Test&gt;();
//        queryWrapper.eq(&quot;id&quot;, 31); //eq是等值比较 若写多行语句则sql语言用and连接
        queryWrapper.gt(&quot;id&quot;, 5);//选择范围 查询大于5的数据
        List&lt;Test&gt; list = testMapper.selectList(queryWrapper);//返回获取7号数据的集合
        System.out.println(list.get(0));
    &#125;
&#125;
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/06dcc63a2b2136dc8423f58abfc719549d2fe9ab/data/for%E7%9A%84%E4%BC%98%E5%8C%96%E6%B5%81.jpg" style="zoom: 80%;" />

<h3 id="基于SSM开发慕课书评网"><a href="#基于SSM开发慕课书评网" class="headerlink" title="基于SSM开发慕课书评网"></a>基于SSM开发慕课书评网</h3><p>导入训练素材的<code>imooc-reader.sql</code></p>
<h5 id="Bootstrap入门介绍-优秀的前端UI框架"><a href="#Bootstrap入门介绍-优秀的前端UI框架" class="headerlink" title="Bootstrap入门介绍 [优秀的前端UI框架]"></a>Bootstrap入门介绍 [优秀的前端UI框架]</h5><ul>
<li>Bootstrap是全球最受欢迎的前端组件库, 由推特(TWitter)开源</li>
<li>Bootstrap用于开发<strong>响应式布局</strong>、移动设备优先的WEB项目</li>
<li>Bootstrap提供完整的HTML、CSS和JS开发工具集</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bootcss.com/">Bootstrap中文网 (bootcss.com)</a></p>
<h3 id="显示图书类别-全部-前端-后端-测试-产品"><a href="#显示图书类别-全部-前端-后端-测试-产品" class="headerlink" title="显示图书类别 [全部 | 前端 | 后端 | 测试 | 产品]"></a>显示图书类别 [<strong>全部</strong> | 前端 | 后端 | 测试 | 产品]</h3><pre><code class="html">index.ftl [只写入顺序关键信息 在这里插入素材中的index.html并更名]
&lt;#--在这块进行动态数据编写 24.创建entity/Category分类实体--&gt;
        &lt;div class=&quot;col-8 mt-2&quot;&gt;
            &lt;span data-category=&quot;-1&quot; style=&quot;cursor: pointer&quot; class=&quot;highlight  font-weight-bold category&quot;&gt;全部&lt;/span&gt;
            |
&lt;#--     31.对页面进行动态的数据导入       --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--                取消最后一个的竖线--&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Category.java
// 24.图书分类实体 25mapper创建一个CategoryMapper
public class Category &#123;
    @TableId(type = IdType.AUTO)
    private Long categoryId;
// 已自动配置好了驼峰命名法 可以忽略
// @TableField(&quot;category_name&quot;)
    private String categoryName;
&#125;Getter + Setter + 重写toString
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/CategoryMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Category;
//25.BaseMapper自动提供了增删改查的功能 泛型指向Category
// 图书分类Mapper接口 26在mappers中创建一个category.xml
public interface CategoryMapper extends BaseMapper&lt;Category&gt; &#123;

&#125;
</code></pre>
<pre><code class="xml">mappers/category.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.CategoryMapper&quot;&gt;
&lt;!-- 26.如何使用呢？ 27创建一个service/CategoryService接口--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/CategoryService.java
package com.imooc.reader.service;
//27.有了service的接口 28就要有实现实现类存放包CategoryServiceImpl

import com.imooc.reader.entity.Category;
import java.util.List;

public interface CategoryService &#123;
    public List&lt;Category&gt; selectAll();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;

//28.向接口编程的规则,注入写好的CategoryMapper接口 设置Transactional事务传播
//默认所有方法是不使用事务的 查询较多的方法不使用事务 写入方法较多下写入事务
//29生成测试类 code-generate-Test  com/imooc/reader/service/impl/CategoryServiceImplTest.java
@Service(&quot;categoryService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class CategoryServiceImpl implements CategoryService &#123;
    @Resource
    private CategoryMapper categoryMapper;
    /**
     * 查询所有图书分类
     * @return 图书分类List
     */
    @Override
    public List&lt;Category&gt; selectAll() &#123;
        //查询列表 返回多个数据 插入条件构造器[查询所有]
        List&lt;Category&gt; list = categoryMapper.selectList(new QueryWrapper&lt;Category&gt;());
        return list;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/CategoryServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.imooc.reader.entity.Category;
import com.imooc.reader.mapper.CategoryMapper;
import com.imooc.reader.service.CategoryService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class CategoryServiceImplTest &#123;
    @Resource
    //29.保证属性和刚才的 @Service(&quot;categoryService&quot;)一致 重写Category的tostring方法重新运行selectAll
    //30进入controller开发环节 新建url与方法绑定的BookController.java
    private CategoryService categoryService;
    @Test
    public void selectAll() &#123;
        List&lt;Category&gt; list = categoryService.selectAll();
        System.out.println(list);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.imooc.reader.entity.Category;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行
    /**
     * 显示首页
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex()&#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;,categoryList);
        return mav;
    &#125;
&#125;

----------------------------------------------------------
index.ftl
&lt;#-- 31.对页面进行动态的数据导入 32创建全新实体类Book --&gt;
            &lt;#list categoryList as category&gt;
                &lt;a style=&quot;cursor: pointer&quot; data-category=&quot;$&#123;category.categoryId&#125;&quot; class=&quot;text-black-50 font-weight-bold category&quot;&gt;$&#123;category.categoryName&#125;&lt;/a&gt;
&lt;#--   取消最后一个的竖线 --&gt;
                &lt;#if category_has_next&gt;|&lt;/#if&gt;
            &lt;/#list&gt;
        &lt;/div&gt;
</code></pre>
<h3 id="实现图书分页查询"><a href="#实现图书分页查询" class="headerlink" title="实现图书分页查询"></a>实现图书分页查询</h3><pre><code class="java">com/imooc/reader/entity/Book.java
// 32.创建完Book实体类  33去创建全新的BookMapper接口[mapper中]
@TableName(&quot;book&quot;)
public class Book &#123;
    @TableId(type = IdType.AUTO)
    private Long bookId;
    private String bookName;
    private String subTitle;
    private String author;
    private String cover;
    private String description;
    private Long categoryId;
    private Float evaluationScore;
    private Integer evaluationQuantity;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/book.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.BookMapper&quot;&gt;
&lt;!--33.完成底层与数据交互代码 34完成分页处理 是在Service中完成的创建BookService完成分页对象查询--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl
    public IPage&lt;Book&gt; paging(Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;
    /**
     * 分页查询图书
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page,rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImplTest.java[Test]
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.service.BookService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

import java.util.List;

import static org.junit.Assert.*;
//36.测试分页的代码编写  37去BookController新加一个方法
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class BookServiceImplTest &#123;
    @Resource
    private BookService bookService;
    @Test
    public void paging() &#123;
        //查询每页十条
        IPage&lt;Book&gt; pageObject = bookService.paging(1,10);
        //获取当前页数据
        List&lt;Book&gt; records = pageObject.getRecords();
        for (Book b:records)&#123;
            System.out.println(b.getBookId() + &quot;:&quot; + b.getBookName());
        &#125;
        System.out.println(&quot;总页数：&quot; + pageObject.getPages());
        System.out.println(&quot;总记录数：&quot; + pageObject.getTotal());
    &#125;
&#125;
</code></pre>
<h3 id="Ajax动态加载图书信息"><a href="#Ajax动态加载图书信息" class="headerlink" title="Ajax动态加载图书信息"></a>Ajax动态加载图书信息</h3><pre><code class="java">com/imooc/reader/controller/BookController.java
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 83行
    /**  
     * 分页查询图书列表
     * @param p 页号
     * @return 分页对象
     */
package com.imooc.controller;

import com.imooc.reader.entity.Book;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.annotation.Resource;

@Controller
public class BookController &#123;
    @Resource
    private BookService bookService;
    
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">index.ftl
  &lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面 http://localhost/ --&gt;
    &lt;script&gt;
        $(function () &#123;
            $.ajax(&#123;
                url: &quot;/books&quot;,
                data : &#123;p:1&#125;,
                type : &quot;get&quot;,
                dataType : &quot;json&quot;,
                success: function(json)&#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        //动态将数据组合成html
                        var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                &#125;
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="Art-Template-腾讯JS模板引擎"><a href="#Art-Template-腾讯JS模板引擎" class="headerlink" title="Art - Template 腾讯JS模板引擎"></a>Art - Template 腾讯JS模板引擎</h3><p><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/zh-cn/index.html">art-template (aui.github.io)</a></p>
<p>整段HTML模板化 静态文本不变化 动态的数据用响应表达式进行提取</p>
<p>两组大括号进行数据提取</p>
<pre><code class="java">index.ftl
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;./resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;
-------------------------------------------------------------------------------------
&lt;#--39.type=&quot;text/html&quot;说明当前script块中包含的内容是一段一段的html浏览器不会作为javascript进行解析--&gt;
&lt;#-- ★ ★ ★ id是模板名字 两组大括号进行提取数据 ★ ★ ★ 使用模板引擎简化产生html过程--&gt;
&lt;#--    40去修改下方script代码导入的形式--&gt;
    &lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;
        &lt;a href=&quot;/book/&#123;&#123;bookId&#125;&#125;&quot; style=&quot;color: inherit&quot;&gt;
            &lt;div class=&quot;row mt-2 book&quot;&gt;
                &lt;div class=&quot;col-4 mb-2 pr-2&quot;&gt;
                    &lt;img class=&quot;img-fluid&quot; src=&quot;&#123;&#123;cover&#125;&#125;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;col-8  mb-2 pl-0&quot;&gt;
                    &lt;h5 class=&quot;text-truncate&quot;&gt;&#123;&#123;bookName&#125;&#125;&lt;/h5&gt;

                    &lt;div class=&quot;mb-2 bg-light small  p-2 w-100 text-truncate&quot;&gt;&#123;&#123;author&#125;&#125;&lt;/div&gt;


                    &lt;div class=&quot;mb-2 w-100&quot;&gt;&#123;&#123;subTitle&#125;&#125;&lt;/div&gt;

                    &lt;p&gt;
                        &lt;span class=&quot;stars&quot; data-score=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; title=&quot;gorgeous&quot;&gt;&lt;/span&gt;
&lt;#--                        &lt;img alt=&quot;1&quot; 加入了星型组件免去这些操作 --&gt;
&lt;#--                             src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                             title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img alt=&quot;2&quot;--&gt;
&lt;#--                                                         src=&quot;./resources/raty/lib/images/star-on.png&quot;--&gt;
&lt;#--                                                         title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;3&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;4&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&amp;nbsp;&lt;img--&gt;
&lt;#--                                alt=&quot;5&quot; src=&quot;./resources/raty/lib/images/star-on.png&quot; title=&quot;gorgeous&quot;&gt;&lt;input--&gt;
&lt;#--                                name=&quot;score&quot; type=&quot;hidden&quot; value=&quot;&#123;&#123;evaluationScore&#125;&#125;&quot; readonly=&quot;&quot;&gt;&lt;/span&gt;--&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationScore&#125;&#125;&lt;/span&gt;
                        &lt;span class=&quot;mt-2 ml-2&quot;&gt;&#123;&#123;evaluationQuantity&#125;&#125;人已评&lt;/span&gt;
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/a&gt;
    &lt;/script&gt;

&lt;#--    38.编写Json序列化格式并追加到当前网页 上方以导入Art-Template[js]模板引擎 39将&lt;div id=&quot;bookList&quot;&gt;下面的代码裁切放到上面--&gt;
        &lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件--&gt;
            $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
            $(function () &#123;
                $.ajax(&#123;
                    url: &quot;/books&quot;,
                    data : &#123;p:1&#125;,
                    type : &quot;get&quot;,
                    dataType : &quot;json&quot;,
                    success: function(json)&#123;
                        console.info(json);
                        var list = json.records;//获取当前分页数据
                        for (var i = 0; i &lt; list.length; i++) &#123;
                            var book = json.records[i];
                            // 动态将数据组合成html
                            // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                            // 40.替换导入数据形式 (传入模板id,传入数据) 将数据结合tpl模板,生成html
                            // 41当评分降低的时候顺带着星星的亮度降低 raty星型评分组件 上面已准备好raty css js引入
                            // 41在上面几行引入星型评分的script方法
                            var html = template(&quot;tpl&quot;, book);
                            console.info(html);
                            //jquery的id选择器选中div对象 追加
                            $(&quot;#bookList&quot;).append(html);
                        &#125;
                        //42.显示星型评价组件 只读并不能修改
                        $(&quot;.stars&quot;).raty(&#123;readonly:true&#125;);
                    &#125;
                &#125;)
            &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书列表分页查询"><a href="#实现图书列表分页查询" class="headerlink" title="实现图书列表分页查询"></a>实现图书列表分页查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44下面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">&lt;script&gt;
&lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据
        function loadMore(isReset)&#123;
            if (isReset == true)&#123;
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            var nextPage = $(&quot;#nextPage&quot;).val();
            $.ajax(&#123;
                url: &quot;/books&quot;,
                //nextPage为2可以加载第二页
                data: &#123;p: nextPage&#125;,
                type: &quot;get&quot;,
                dataType: &quot;json&quot;,
                success: function (json) &#123;
                    console.info(json);
                    var list = json.records;//获取当前分页数据
                    for (var i = 0; i &lt; list.length; i++) &#123;
                        var book = json.records[i];
                        var html = template(&quot;tpl&quot;, book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readonly: true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if (json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current + 1));
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else &#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
     
        $(function () &#123;
            loadMore(true);
        &#125;)

        // 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function () &#123;
            $(&quot;#btnMore&quot;).click(function ()&#123;
                loadMore();
            &#125;)
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="实现图书多条件动态查询"><a href="#实现图书多条件动态查询" class="headerlink" title="实现图书多条件动态查询"></a>实现图书多条件动态查询</h3><pre><code class="java">index.ftl
// 43.用于绑定加载更多按钮单击事件 44上面的设置页面的逻辑及处理
        $(function()&#123;
            $(&quot;#btnMore&quot;).click(function()&#123;
                loadMore();
            &#125;)
            //46 增加点击的显示控件
            $(&quot;.category&quot;).click(function () &#123;
                $(&quot;.category&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.category&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //49添加数量与热度 ↓点击的超链接 在下面也要添加order
                var categoryId = $(this).data(&quot;category&quot;); //214行定义了data-category
                $(&quot;#categoryId&quot;).val(categoryId);
                loadMore(true); //每次点完要重新查询
            &#125;)//在排序处显示控件 47点击 全部|前端|后端 产生数据联动BookService上

            $(&quot;.order&quot;).click(function()&#123;
                $(&quot;.order&quot;).removeClass(&quot;highlight&quot;); //移除高亮
                $(&quot;.order&quot;).addClass(&quot;text-black-50&quot;);//增添灰色
                $(this).addClass(&quot;highlight&quot;);//增加高亮
                //~49.提取设置到隐藏域中 发送请求到Ajax服务器上最上面 50var categoryId
                var order = $(this).data(&quot;order&quot;);
                $(&quot;#order&quot;).val(order); //点击不同隐藏域时为其赋值
                loadMore(true);
            &#125;)
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
package com.imooc.reader.service;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
//图书服务
public interface BookService &#123;
    //34.泛型&lt;Book&gt; 说明查询出来的每一行数据都是一个Book对象
    // 瞄准BookService快速生成实现类Alt+Enter =&gt; Implement interface
    //35编写com.imooc.reader.service.impl.BookServiceImpl

    /**
     * 分页查询图书
     * @param categoryId 分类编号
     * @param order 排序方式
     * @param page 页号
     * @param rows 每页记录数
     * @return 分页对象
     */
//    47增加两个变量且在BookServiceImpl中也对应增加上
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
&#125;
</code></pre>
<pre><code class="java">package com.imooc.reader.service.impl.BookServiceImpl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.imooc.reader.entity.Book;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.service.BookService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;

//35. 实现分类代码编写  36生成测试用例 Code generate Test =&gt; BookServiceImplTest
@Service(&quot;bookService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class BookServiceImpl implements BookService &#123;
    @Resource
    private BookMapper bookMapper;

    /**
     * 分页查询图书
     *
     * @param categoryId 分类编号
     * @param order      排序方式
     * @param page       页号
     * @param rows       每页记录数
     * @return 分页对象
     */
    public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows) &#123;
        Page&lt;Book&gt; p = new Page&lt;Book&gt;(page, rows);
        QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;Book&gt;();
        //47.编写匹配条件 48去BookController更改调用参数
        if (categoryId != null &amp;&amp; categoryId != -1) &#123;//代表传入了有效分类编号
            queryWrapper.eq(&quot;category_id&quot;, categoryId);//查询的where子句
        &#125;
        if (order != null) &#123;
            if (order.equals(&quot;quantity&quot;)) &#123; //前台必须传入↓ 评价人数排序
                queryWrapper.orderByDesc(&quot;evaluation_quantity&quot;);//降序排序
            &#125; else if (order.equals(&quot;score&quot;)) &#123;
                queryWrapper.orderByDesc(&quot;evaluation_score&quot;);//评分降序
            &#125;
        &#125;
        IPage&lt;Book&gt; pageObject = bookMapper.selectPage(p, queryWrapper);//传入两个参数: page对象哪一页数据  每页记录数[条件构造器]
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
package com.imooc.reader.controller;

import com.baomidou.mybatisplus.core.metadata.IPage;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Category;
import com.imooc.reader.service.BookService;
import com.imooc.reader.service.CategoryService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import java.util.List;

//30.显示之前写好的index.ftl
@Controller
public class BookController &#123;
    //传入模板数据 分类信息
    @Resource
    private CategoryService categoryService;
    @Resource
    private BookService bookService;
    //showIndex与url绑定  31继续向前推进因为index.ftl所有数据都是静态写死的
    //31要对每一个分类进行读取 List标签&lt;#list&gt;读取 转至index.ftl 64行

    /**
     * 显示首页
     *
     * @return
     */
    @GetMapping(&quot;/&quot;)
    public ModelAndView showIndex() &#123;
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&lt;Category&gt; categoryList = categoryService.selectAll();//拿到列表
        //结果放入其中 属性名,值
        mav.addObject(&quot;categoryList&quot;, categoryList);
        return mav;
    &#125;
//37.编写一个page方法 上面加个@Resource 绑定一个Ajax @GetMapping
    //http://localhost/books 非常长的JSON序列化结果  38index.ftl 40行

    /**
     * 分页查询图书列表
     *
     * @param p 页号
     * @return 分页对象
     */
    //48.更改调用参数 更改BookServiceImplTest.java调用参数 49回到index.ftl 增加function第二个
    @GetMapping(&quot;/books&quot;)
    @ResponseBody //具体数据来自客户端传入
    public IPage&lt;Book&gt; selectBook(Long categoryId, String order, Integer p) &#123;
        if (p == null) &#123;
            p = 1;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(categoryId, order, p, 10);
        return pageObject;
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl
&lt;script&gt;
        &lt;#-- 41.引入星星图片 和 评价方法 上面的script运用简便写法 42下面 $(&quot;.stars&quot;)将星星的span标签选中 raty转换成可视的星星组件(被注释)--&gt;
        $.fn.raty.defaults.path = &quot;./resources/raty/lib/images&quot;
        // 45.对两次Ajax的代码进行重构与梳理(定义一个loadMore()方法将下面的裁切进来底下写进递归)
        // isReset参数设置true,代表从第一页开始查询,否则按nextPage查询后续页
        // 对下面那个data: &#123;p: 1&#125;, 进行重构 ↓↓↓↓ isReset 下面代码已经被注释但未完全删除
        // loadMore()加载更多数据 46下方整理点击时的高亮显示 [全部]
        function loadMore(isReset)&#123;
            if(isReset == true)&#123;
                $(&quot;#bookList&quot;).html(&quot;&quot;);
                $(&quot;#nextPage&quot;).val(1);
            &#125;
            // 50.让Ajax获取数据在下方data填写 下方$(&quot;.category和.order&quot;)都要重新调用递归
            // 细节清空再显示 上方$(&quot;#bookList&quot;).html(&quot;&quot;);
            var nextPage = $(&quot;#nextPage&quot;).val();
            var categoryId= $(&quot;#categoryId&quot;).val();
            var order = $(&quot;#order&quot;).val();
            //接下来就是发送数据时 组织成参数发送服务器
            $.ajax(&#123;
                url : &quot;/books&quot; ,
                //nextPage为2可以加载第二页  ↓字符串：变量
                data : &#123;p:nextPage,&quot;categoryId&quot;:categoryId , &quot;order&quot;:order&#125;,
                type : &quot;get&quot; ,
                dataType : &quot;json&quot; ,
                success : function(json)&#123;
                    console.info(json);
                    var list = json.records;
                    for(var i = 0 ; i &lt; list.length ; i++)&#123;
                        var book = json.records[i];
                        // var html = &quot;&lt;li&gt;&quot; + book.bookName + &quot;&lt;/li&gt;&quot;;
                        //将数据结合tpl模板,生成html
                        var html = template(&quot;tpl&quot; , book);
                        console.info(html);
                        //jquery的id选择器选中div对象 追加
                        $(&quot;#bookList&quot;).append(html);
                    &#125;
                    $(&quot;.stars&quot;).raty(&#123;readOnly:true&#125;);
                    // 44.如果当前页小于总页数 下面利用val设置隐藏域的值
                    // 可能将按照字符串处理 结果是31而不是4 要强制转换
                    // 若有后续数据的话 最后几行的divNoMore需要隐藏起来
                    // 45对两次的Ajax代码进行重构与梳理 上面找到第一个script
                    if(json.current &lt; json.pages)&#123;
                        $(&quot;#nextPage&quot;).val(parseInt(json.current) + 1);
                        $(&quot;#btnMore&quot;).show();
                        $(&quot;#divNoMore&quot;).hide();
                    &#125;else&#123;
                        $(&quot;#btnMore&quot;).hide();
                        $(&quot;#divNoMore&quot;).show();
                    &#125;
                &#125;
            &#125;)
        &#125;
</code></pre>
<h3 id="图书详情页-读取图书信息"><a href="#图书详情页-读取图书信息" class="headerlink" title="图书详情页-读取图书信息"></a>图书详情页-读取图书信息</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gybshen/article/details/79990533">img标签src引用网络图片，响应403的解决方法_img src引用其他网站图片-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
public IPage&lt;Book&gt; paging(Long categoryId, String order, Integer page, Integer rows);
    /**
     * 根据图书编号查询图书对象
     * @param bookId 图书编号
     * @return 图书对象
     */
    //51.增加一个查询书籍的接口 再去BookServiceImpl中实现
    public Book selectById(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //51实现后再向上推进 BookController
    @Override
    public Book selectById(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id)&#123;
        Book book = bookService.selectById(id);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        mav.addObject(&quot;book&quot;, book);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
&lt;#-- 52.更改detail.ftl将静态页面改成动态页面 &lt;title&gt; 还有下面图书细节 --&gt;
&lt;#--  53.来源于数据底层的description描述字段   54显示动态评论列表 数据库有evaluation表 创建一个entity/Evaluation--&gt;

    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt; &lt;#--防止网页图片加载不出来--&gt;
    &lt;title&gt;$&#123;book.bookName&#125;&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/bootstrap/bootstrap.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/raty/lib/jquery.raty.css&quot;&gt;
    &lt;script src=&quot;/resources/jquery.3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/bootstrap/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/art-template.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/resources/raty/lib/jquery.raty.js&quot;&gt;&lt;/script&gt;

-------------------------------------------------------------------
&lt;div class=&quot;row p-2 description&quot;&gt;
        &lt;#-- 53.来源于数据底层的description描述字段     --&gt;
        $&#123;book.description&#125;
    &lt;/div&gt;
</code></pre>
<h3 id="图书详情页-显示评论列表"><a href="#图书详情页-显示评论列表" class="headerlink" title="图书详情页-显示评论列表"></a>图书详情页-显示评论列表</h3><pre><code class="java">com/imooc/reader/entity/Member.java
//59.创建Member实体后完成MemberMapper接口
@TableName(&quot;member&quot;)
public class Member &#123;
    @TableId(type = IdType.AUTO)
    private Long memberId;
    private String username;
    private String password;
    private Integer salt;
    private String nickname;
    private Date createTime;
&#125;Getter+Setter
</code></pre>
<pre><code class="java">com/imooc/reader/entity/Evaluation.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.util.Date;
//54.创造了评论相关的底层entity 55定义一个EvaluationMapper.java接口
//再定义一个 evaluation.xml  再service上创建一个新的接口EvaluationService.java
@TableName(&quot;evaluation&quot;)
public class Evaluation &#123;
//  id是主键
    @TableId(type= IdType.AUTO)
    private Long evaluationId;
    private Long bookId;
    private String content;
    private Integer score;
    private Long memberId;
    private Date createTime;
    private Integer enjoy;
    private String state;
    private String disableReason;
    private Date disableTime;
    @TableField(exist = false) //58.说明book属性没有对应字段,不会参与到sql自动生成
    private Book book; //Book的关联字段 加注解不存在 不会参与sql语句自动生成中 59创建会员entity对象Member实体
    @TableField(exist = false)
    private Member member; //59.获取集合后查询每个评论的信息 EvaluationServiceImpl中
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/EvaluationMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Evaluation;
//55
public interface EvaluationMapper extends BaseMapper&lt;Evaluation&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/evaluation.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.EvaluationMapper&quot;&gt;
&lt;!--55--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/EvaluationService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Evaluation;

import java.util.List;
//55.再创建一个它的实现类 Alt+回车 com/imooc/reader/service/impl/EvaluationServiceImpl.java
public interface EvaluationService&#123;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return 评论列表
     */
    public List&lt;Evaluation&gt; selectByBookId(Long bookId);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/EvaluationServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Book;
import com.imooc.reader.entity.Evaluation;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.BookMapper;
import com.imooc.reader.mapper.EvaluationMapper;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.EvaluationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.List;
//55.按图书编号查询有效短评   56BookController得到对应的图书编号以后 基于service查询对应短评信息
@Service(&quot;evluationService&quot;)
@Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
public class EvaluationServiceImpl implements EvaluationService &#123;
    @Resource
    private EvaluationMapper evaluationMapper;
    //59
    @Resource
    private MemberMapper memberMapper;
    @Resource
    private BookMapper bookMapper;
    /**
     * 按图书编号查询有效短评
     * @param bookId 图书编号
     * @return
     */
    @Override
    public List&lt;Evaluation&gt; selectByBookId(Long bookId) &#123;
        Book book = bookMapper.selectById(bookId); //59根据参数查询book对象
        QueryWrapper&lt;Evaluation&gt; queryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;state&quot;,&quot;enable&quot;);
        queryWrapper.orderByDesc(&quot;create_time&quot;);
        List&lt;Evaluation&gt; evaluationList = evaluationMapper.selectList(queryWrapper);
        //59.查询每个评论的信息
        for(Evaluation eva:evaluationList)&#123;
            Member member = memberMapper.selectById(eva.getMemberId());//59获得会员对象要使用接口咯
            eva.setMember(member);
            eva.setBook(book);//59循环的时候为每一个Evaluation设置一个book对象 60回到detail.ftl
        &#125;
        return evaluationList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;div class=&quot;alert alert-primary w-100 mt-2&quot; role=&quot;alert&quot;&gt;短评
        &lt;button type=&quot;button&quot; id=&quot;btnEvaluation&quot; class=&quot;btn btn-success btn-sm text-white float-right&quot;
                style=&quot;margin-top: -3px;&quot;&gt;
            写短评
        &lt;/button&gt;
    &lt;/div&gt;
    &lt;div class=&quot;reply pl-2 pr-2&quot;&gt;
&lt;#--  57.对短评进行动态页面的整合与梳理 进行循环遍历  58注意下面的慕粉-126对应着数据库的会员表 再重来一遍 Evaluation--&gt;
        &lt;#list evaluationList as evaluation&gt;
            &lt;div&gt;
                &lt;div&gt;
                    &lt;span class=&quot;pt-1 small text-black-50 mr-2&quot;&gt;$&#123;evaluation.createTime?string(&#39;MM-dd&#39;)&#125;&lt;/span&gt;
&lt;#--   60.修改 慕粉-126 变为动态的--&gt;
                    &lt;span class=&quot;mr-2 small pt-1&quot;&gt;$&#123;evaluation.member.nickname&#125;&lt;/span&gt;
                    &lt;span class=&quot;stars mr-2&quot; data-score=&quot;$&#123;evaluation.score&#125;&quot;&gt;&lt;/span&gt;

                    &lt;button type=&quot;button&quot; data-evaluation-id=&quot;$&#123;evaluation.evaluationId&#125;&quot;
                            class=&quot;btn btn-success btn-sm text-white float-right&quot; style=&quot;margin-top: -3px;&quot;&gt;
                        &lt;img style=&quot;width: 24px;margin-top: -5px;&quot; class=&quot;mr-1&quot;
                             src=&quot;https://img3.doubanio.com/f/talion/7a0756b3b6e67b59ea88653bc0cfa14f61ff219d/pics/card/ic_like_gray.svg&quot;/&gt;
                        &lt;span&gt;$&#123;evaluation.enjoy&#125;&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;

                &lt;div class=&quot;row mt-2 small mb-3&quot;&gt;
                    $&#123;evaluation.content&#125;
                &lt;/div&gt;
                &lt;hr/&gt;
            &lt;/div&gt;
        &lt;/#list&gt;
    &lt;/div&gt;
</code></pre>
<h3 id="会员注册与登录"><a href="#会员注册与登录" class="headerlink" title="会员注册与登录"></a>会员注册与登录</h3><h5 id="Kaptcha验证码的配置与使用"><a href="#Kaptcha验证码的配置与使用" class="headerlink" title="Kaptcha验证码的配置与使用"></a>Kaptcha验证码的配置与使用</h5><ul>
<li>Kaptcha 是谷歌开源的可高度配置的使用验证码生成工具</li>
<li>通过 Kaptcha 可阻拦大多数机器人脚本操作</li>
<li>Kaptcha 典型应用于注册、登录、重要信息提交等用户交互</li>
</ul>
<h5 id="Kaptcha-使用步骤"><a href="#Kaptcha-使用步骤" class="headerlink" title="Kaptcha 使用步骤"></a>Kaptcha 使用步骤</h5><ul>
<li>Kaptcha 配置验证码生成参数</li>
<li>开发 KaptchaController 生成验证码图片</li>
<li>将前台输入验证码与session保存的验证码进行比对</li>
</ul>
<pre><code class="xml">pom.xml
&lt;!--   61.增加Kaptcha验证码组件依赖 applicationContext增加一个bean  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;
            &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/KaptchaController.java
package com.imooc.reader.controller;

import com.google.code.kaptcha.Producer;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import javax.annotation.Resource;
import javax.imageio.ImageIO;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.IOException;
//62.完成图片的随机生成与控制台的输出相同 63将原型里的 注册页 复制到项目工程register.ftl
@Controller
public class KaptchaController &#123;
    @Resource
    private Producer kaptchaProducer;
//    Ioc动态注入 因为验证码组件设计的时候没有考虑过SpringMVC的集成 要使用原生的请求与响应
    @GetMapping(&quot;/verify_code&quot;)
    public void createVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        //响应立即过期
        response.setDateHeader(&quot;Expires&quot;,0);
        //不存储 不缓存任何图片数据
        response.setHeader(&quot;Cache-Control&quot;,&quot;no-store,no-cache,must-revalidate&quot;);
        response.setHeader(&quot;Cache-Control&quot;,&quot;post-check=0,pre-check=0&quot;);
        response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);
        response.setContentType(&quot;image/png&quot;);
        //生成验证码字符文本
        String verifyCode = kaptchaProducer.createText();
        request.getSession().setAttribute(&quot;kaptchaVerifyCode&quot;,verifyCode);
        System.out.println( request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;));
        BufferedImage image = kaptchaProducer.createImage(verifyCode);//创建验证码图片 二进制图片
        //二进制用getOutputStream() 字符用getWritter()
        ServletOutputStream out = response.getOutputStream();
        ImageIO.write(image,&quot;png&quot;,out);//输出图片流
        out.flush(); //立即输出
        out.close(); //关闭输出流

    &#125;
&#125;
</code></pre>
<h3 id="Kaptcha验证码的使用与对比-运用到前端"><a href="#Kaptcha验证码的使用与对比-运用到前端" class="headerlink" title="Kaptcha验证码的使用与对比 [运用到前端]"></a>Kaptcha验证码的使用与对比 [运用到前端]</h3><pre><code class="java">register.ftl
&lt;div class=&quot;col-4 p-0 pl-2 pt-0&quot;&gt;
   &lt;!-- 63.验证码图片 src要显示从服务器后台动态生成的验证码 KaptchaController生成的url粘贴在这里 64弄一个MemberController--&gt;
   &lt;img id=&quot;imgVerifyCode&quot; src=&quot;/verify_code&quot;
   style=&quot;width: 120px;height:50px;cursor: pointer&quot;&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;
    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request)&#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode  = (String)request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode))&#123;
            result.put(&quot;code&quot;,&quot;VC01&quot;);
            result.put(&quot;msg&quot;,&quot;验证码错误&quot;);
        &#125;else &#123;
            result.put(&quot;code&quot;,&quot;0&quot;);
            result.put(&quot;msg&quot;,&quot;success&quot;);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="java">register.ftl
&lt;script&gt;
    //控制错误信息的显示与隐藏
    function showTips(isShow, css, text) &#123;
        if (isShow) &#123;
            $(&quot;#tips&quot;).removeClass(&quot;d-none&quot;)
            $(&quot;#tips&quot;).hide();
            $(&quot;#tips&quot;).addClass(css);
            $(&quot;#tips&quot;).text(text);
            $(&quot;#tips&quot;).fadeIn(200);
        &#125; else &#123;
            $(&quot;#tips&quot;).text(&quot;&quot;);
            $(&quot;#tips&quot;).fadeOut(200);
            $(&quot;#tips&quot;).removeClass();
            $(&quot;#tips&quot;).addClass(&quot;alert&quot;)
        &#125;
    &#125;
    //65.重新发送请求,刷新验证码 66验证码与后台绑定[比对校验]
    function reloadVerifyCode()&#123;
        //请在这里实现刷新验证码 ts timestamp是时间戳 增加时间戳取消缓存
        $(&quot;#imgVerifyCode&quot;).attr(&quot;src&quot;,&quot;/verify_code?ts=&quot; + new Date().getTime())
    &#125;
    
    //点击验证码图片刷新验证码
    $(&quot;#imgVerifyCode&quot;).click(function () &#123;
        reloadVerifyCode();
    &#125;);
    
    // 66.点击提交按钮,向/registe发起ajax请求
    //提交请求包含四个参数
    //vc:前台输入验证码  username:用户名 password:密码 nickname:昵称
    $(&quot;#btnSubmit&quot;).click(function () &#123;
        //表单校验
        var username = $.trim($(&quot;#username&quot;).val());
        var regex = /^.&#123;6,10&#125;$/;
        if (!regex.test(username)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;用户名请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        var password = $.trim($(&quot;#password&quot;).val());

        if (!regex.test(password)) &#123;
            showTips(true, &quot;alert-danger&quot;, &quot;密码请输入正确格式（6-10位）&quot;);
            return;
        &#125; else &#123;
            showTips(false);
        &#125;

        $btnReg = $(this);

        $btnReg.text(&quot;正在处理...&quot;);
        $btnReg.attr(&quot;disabled&quot;, &quot;disabled&quot;);
        
        //66.发送ajax请求 67编写MemberController.java实现url
        $.ajax(&#123;
            url: &quot;/registe&quot;,
            type: &quot;post&quot;,
            dataType: &quot;json&quot;,
            data: $(&quot;#frmLogin&quot;).serialize(),
            success: function (data) &#123;
                //结果处理,根据服务器返回code判断服务器处理状态
                //服务器要求返回JSON格式:
                //&#123;&quot;code&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;处理消息&quot;&#125;
                console.info(&quot;服务器响应:&quot; , data);
                if (data.code == &quot;0&quot;) &#123;
                    //显示注册成功对话框
                    $(&quot;#exampleModalCenter&quot;).modal(&#123;&#125;);
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125; else &#123;
                    //服务器校验异常,提示错误信息
                    showTips(true, &quot;alert-danger&quot;, data.msg);
                    reloadVerifyCode();
                    $btnReg.text(&quot;注    册&quot;);
                    $btnReg.removeAttr(&quot;disabled&quot;);
                &#125;
            &#125;
        &#125;);
        return false;
    &#125;);
&lt;/script&gt;
============================
67在上面MemberController.java
</code></pre>
<h3 id="实现会员注册功能"><a href="#实现会员注册功能" class="headerlink" title="实现会员注册功能"></a>实现会员注册功能</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mask_boys/article/details/118273990">500 (Internal Server Error)_谷歌浏览器 internal server error-CSDN博客</a></p>
<pre><code class="java">com/imooc/reader/service/MemberService.java
package com.imooc.reader.service;

import com.imooc.reader.entity.Member;
//68.创建一个实现类MemberServiceImpl.java[Alt + Enter]
public interface MemberService &#123;
    /**
     * 会员注册,创建新会员
     * @param username
     * @param password
     * @param nickname
     * @return
     */
    public Member createMember(String username, String password, String nickname);
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/exception.java
package com.imooc.reader.service.exception;

/**
 * 68.业务逻辑异常 回到MemberServiceImpl编写用户名异常 69返回MemberServiceImpl
 */
public class BussinessException extends RuntimeException&#123;
    private String code;
    private String msg;

    //构造方法
    public BussinessException(String code, String msg) &#123;
        super(msg); //继承自运行时异常
        this.code = code;
        this.msg = msg;
    &#125;

    public String getCode() &#123;
        return code;
    &#125;

    public void setCode(String code) &#123;
        this.code = code;
    &#125;

    public String getMsg() &#123;
        return msg;
    &#125;

    public void setMsg(String msg) &#123;
        this.msg = msg;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/utils/MD5Utils.java
package com.imooc.reader.utils;

import org.apache.commons.codec.digest.DigestUtils;
//70.生成MD5方法 返回MemberServiceImpl编写随机数
public class MD5Utils &#123;
    public static String md5Digest(String source, Integer salt)&#123;
        char[] ca = source.toCharArray();//获取字符数组
        for (int i = 0; i &lt; ca.length; i++) &#123;
            ca[i] = (char) (ca[i] + salt);
        &#125;
        String target = new String(ca);
        String md5 = DigestUtils.md5Hex(target);
        return md5;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
package com.imooc.reader.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.imooc.reader.entity.Member;
import com.imooc.reader.mapper.MemberMapper;
import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import com.imooc.reader.utils.MD5Utils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
import java.util.List;
import java.util.Random;

//68.完成与会员的交互[写操作居多] 完成运行异常service/BussinessException.java
@Service(&quot;memberService&quot;)
@Transactional
public class MemberServiceImpl implements MemberService &#123;
    @Resource
    private MemberMapper memberMapper;

    /**
     * 会员注册,创建新会员
     *
     * @param username 用户名
     * @param password 密码
     * @param nickname 昵称
     * @return 新会员对象
     */
    public Member createMember(String username, String password, String nickname) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        List&lt;Member&gt; memberList = memberMapper.selectList(queryWrapper);
        //判断用户名是否已存在 68定义一个异常BussinessException.java
        //69.续写异常  70增加加密组件pom.xml
        if (memberList.size() &gt; 0) &#123;
            throw new BussinessException(&quot;M01&quot;, &quot;用户名已存在&quot;);
        &#125;
        Member member = new Member();
        member.setUsername(username);
        member.setNickname(nickname);
        //70. 随机数md5  71生成测试用例MemberServiceImplTest
        int salt = new Random().nextInt(1000)+1000; //盐值
        String md5 = MD5Utils.md5Digest(password, salt);
        member.setPassword(md5);
        member.setSalt(salt);
        member.setCreateTime(new Date()); //创建时间
        memberMapper.insert(member);
        return member;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImplTest.java
package com.imooc.reader.service.impl;

import com.imooc.reader.service.MemberService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//71.生成测试用例 72MemberController后续的工作
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class MemberServiceImplTest &#123;
    @Resource
    private MemberService memberService;
    @Test
    public void createMember() &#123;
        memberService.createMember(&quot;s123457&quot;, &quot;123456&quot;, &quot;测试&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
package com.imooc.reader.controller;

import com.imooc.reader.service.exception.BussinessException;
import com.imooc.reader.service.MemberService;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

//64.嵌入验证码 65编写单机验证码刷新register.ftl中的function reloadVerifyCode()
@Controller
public class MemberController &#123;
    //72后续工作 进行注入
    @Resource
    private MemberService memberService;

    @GetMapping(&quot;/register.html&quot;)
    public ModelAndView showRegister() &#123;
        return new ModelAndView(&quot;/register&quot;);
    &#125;

    //67. 验证码匹配比对 request拿到对象  68编写会员服务MemberService.java
    @PostMapping(&quot;/registe&quot;)
    @ResponseBody
    public Map registe(String vc, String username, String password, String nickname, HttpServletRequest request) &#123;
        //接收kaptchaController.java中的request.getSession().setAttribute响应
        //正确验证码
        String verityCode = (String) request.getSession().getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125; else &#123;
            //72.调用过程  73将登录页复制进去 74MemberServiceImpl
            try &#123;
                memberService.createMember(username, password, nickname);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123;
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
&#125;
http://localhost/register.html
</code></pre>
<h3 id="实现会员登录功能"><a href="#实现会员登录功能" class="headerlink" title="实现会员登录功能"></a>实现会员登录功能</h3><pre><code class="java"> com/imooc/reader/service/impl/MemberServiceImpl.java
 /**
     * 登陆检查
     * @param username 用户名
     * @param password 密码
     * @return 登录对象
     */
    //74.登录方法的接口实现 校验密码 75再续方法 MemberController.java
    public Member checkLogin(String username, String password) &#123;
        QueryWrapper&lt;Member&gt; queryWrapper = new QueryWrapper&lt;Member&gt;();
        queryWrapper.eq(&quot;username&quot;, username);
        Member member = memberMapper.selectOne(queryWrapper);
        if (member == null)&#123;
            throw new BussinessException(&quot;M02&quot;, &quot;用户不存在&quot;);
        &#125;//校验密码
        String md5 = MD5Utils.md5Digest(password, member.getSalt());
        if (!md5.equals(member.getPassword()))&#123;
            throw new BussinessException(&quot;M03&quot;, &quot;输入密码有误&quot;);
        &#125;
        return member;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
// 75.HttpSession session 登录校验后会将这个会员信息存放到session中
    // 76登录校验成功以后会返回一个member对象 存放在session中
    @PostMapping(&quot;/check_login&quot;) //前台url
    @ResponseBody
    public Map checkLogin(String username, String password, String vc, HttpSession session)&#123;
        //正确验证码                     ↓为了得到session对象
        String verityCode = (String)session.getAttribute(&quot;kaptchaVerifyCode&quot;);
        //验证码比对  后面的是大小写对比
        Map result = new HashMap();
        if (vc == null || verityCode == null || !vc.equalsIgnoreCase(verityCode)) &#123;
            result.put(&quot;code&quot;, &quot;VC01&quot;);
            result.put(&quot;msg&quot;, &quot;验证码错误&quot;);
        &#125;else &#123;
            try &#123;//处理成功
                Member member = memberService.checkLogin(username, password);
                //76.member存放在session中  77去index.ftl下方登录块改造
                session.setAttribute(&quot;loginMember&quot;,member);
                result.put(&quot;code&quot;, &quot;0&quot;);
                result.put(&quot;msg&quot;, &quot;success&quot;);
            &#125; catch (BussinessException ex) &#123; //处理失败
                ex.printStackTrace();
                result.put(&quot;code&quot;, ex.getCode());
                result.put(&quot;msg&quot;, ex.getMsg());
            &#125;
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">index.ftl 
&lt;#--   77.将获取到的member的session数据替换成登录右上角的动态数据--&gt;
  &lt;#--  两个问号代表前面的属性是存在的情况下输出其中的html --&gt;
&lt;#-- 78新增entity/MemberReadState.java会员阅读状态 --&gt;
        &lt;#if loginMember??&gt;
            &lt;h6 class=&quot;mt-1&quot;&gt;
                &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;$&#123;loginMember.nickname&#125;
            &lt;/h6&gt;
            &lt;#else&gt; &lt;#--上面是已登录 下面是未登录--&gt;
                &lt;a href=&quot;/login.html&quot; class=&quot;btn btn-light btn-sm&quot;&gt;
                    &lt;img style=&quot;width: 2rem;margin-top: -5px&quot; class=&quot;mr-1&quot; src=&quot;./images/user_icon.png&quot;&gt;登录
                &lt;/a&gt;
        &lt;/#if&gt;
</code></pre>
<h3 id="获取会员阅读状态"><a href="#获取会员阅读状态" class="headerlink" title="获取会员阅读状态"></a>获取会员阅读状态</h3><h5 id="实现会员交互功能"><a href="#实现会员交互功能" class="headerlink" title="实现会员交互功能"></a>实现会员交互功能</h5><ul>
<li>想看&#x2F;看过的阅读状态变更</li>
<li>为图书写短评</li>
<li>为喜欢的短评点赞</li>
</ul>
<pre><code class="java">com/imooc/reader/entity/MemberReadState.java
package com.imooc.reader.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;

import java.util.Date;

/**
 * 会员阅读状态实体
 */
//78.搞实体 再去创MemberReadStateMapper.java接口
public class MemberReadState &#123;
    @TableId(type = IdType.AUTO)
    private Long rsId;
    private Long bookId;
    private Long memberId;
    private Integer readState;
    private Date createTime;
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/MemberReadStateMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.MemberReadState;

//78接口创完 再去搞个Member_Read_State.xml
public interface MemberReadStateMapper extends BaseMapper&lt;MemberReadState&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">mappers/member_read_state.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.reader.mapper.MemberReadStateMapper&quot;&gt;
&lt;!--  78. 去MemberService 阅读状态--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java 
//78.获取阅读状态 再去实现这个方法

    /**
     * 获取阅读状态
     *
     * @param memberId 会员编号
     * @param bookId   图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
 //78.新增方法实现那个方法 再去上方进行方法注入 79根据会员编号进行查询BookController

    /**
     * 获取阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @return 阅读状态对象
     */
    public MemberReadState selectMemberReadState(Long memberId, Long bookId)&#123;
        QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper();
        queryWrapper.eq(&quot;book_id&quot;, bookId);
        queryWrapper.eq(&quot;member_id&quot;, memberId);
        MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/BookController.java
//51.进行页面的绑定 获取读书编号 52把所有ftl相对路径改成绝对路径 ./前面的.删掉
    //加上了./就是  localhost/book/......   删掉就是 localhost/......
    //52更改detail.ftl将静态页面改成动态页面
    @GetMapping(&quot;/book/&#123;id&#125;&quot;) //↓ 路径变量 和 上面的保持一致
    //79.新增一个参数 获取当前用户登录信息
    public ModelAndView showDetail(@PathVariable(&quot;id&quot;) Long id, HttpSession session) &#123;
        Book book = bookService.selectById(id);
        //56.写完并放入 mav.addObject 57得到了对象就要去detail.ftl渲染循环遍历[写短评下方的div]
        List&lt;Evaluation&gt; evaluationList = evaluationService.selectByBookId(id);
        //79.将之前设置的用户信息拿出来 两种情况 ①会员没登录就null ②会员登录了member对象存在了 注入memberService
        Member member = (Member)session.getAttribute(&quot;loginMember&quot;);
        ModelAndView mav = new ModelAndView(&quot;/detail&quot;);
        if (member != null) &#123; //获取会员阅读状态    会员编号 图书编号  80 detail.ftl想看[1]与看过[2] 页面上方找script块
            MemberReadState memberReadState = memberService.selectMemberReadState(member.getMemberId(), id);
            mav.addObject(&quot;memberReadState&quot;, memberReadState);

        &#125;
        mav.addObject(&quot;book&quot;, book);
        mav.addObject(&quot;evaluationList&quot;, evaluationList);
        return mav;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
 &lt;script&gt;
        $.fn.raty.defaults.path = &#39;/resources/raty/lib/images&#39;;
        $(function () &#123;
            $(&quot;.stars&quot;).raty(&#123;readOnly: true&#125;);
        &#125;)
       // 80 想看与看过 freemark脚本 如果它存在(想看/看过) 81产生对应的状态数据 MemberService
        $(function () &#123;
            &lt;#if memberReadState ??&gt;
            // 重选阅读状态回填
            $(&quot;*[data-read-state=&#39;$&#123;memberReadState.readState&#125;&#39;]&quot;).addClass(&quot;highlight&quot;);
            &lt;/#if&gt;
            &lt;#if !loginMember ??&gt;
                $(&quot;*[data-read-state]&quot;).click(function () &#123;
                    // 利用jquery选择div的对话框函数 显示需要登录
                    $(&quot;#exampleModalCenter&quot;).modal(&quot;show&quot;);
                &#125;)
            &lt;/#if&gt;
        &#125;)
    &lt;/script&gt;
</code></pre>
<h3 id="更新会员阅读状态"><a href="#更新会员阅读状态" class="headerlink" title="更新会员阅读状态"></a>更新会员阅读状态</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 更新阅读状态
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param readState 阅读状态
     * @return 阅读对象状态
     */         //81定义方法 MemberServiceImpl实现状态
    public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
 * 更新阅读状态
 * @param memberId 会员编号
 * @param bookId 图书编号
 * @param readState 阅读状态
 * @return 阅读对象状态
 */
//81.编写阅读状态代码 编写完打开MemberController
public MemberReadState updateMemberReadState(Long memberId, Long bookId, Integer readState)&#123;
    QueryWrapper&lt;MemberReadState&gt; queryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
    queryWrapper.eq(&quot;book_id&quot;, bookId);
    queryWrapper.eq(&quot;member_id&quot;, memberId);
    MemberReadState memberReadState = memberReadStateMapper.selectOne(queryWrapper);
    //空的代表没有点过按钮 数据是空的
        //无则新增,有则更新
        if(memberReadState == null)&#123;
            memberReadState = new MemberReadState();
            memberReadState.setMemberId(memberId);
            memberReadState.setBookId(bookId);
            memberReadState.setReadState(readState);
            memberReadState.setCreateTime(new Date());
            memberReadStateMapper.insert(memberReadState);
        &#125;else&#123;
            memberReadState.setReadState(readState);
            memberReadStateMapper.updateById(memberReadState);
        &#125;

        return memberReadState;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//81. 完成更新状态的事务  82去完成detail.ftl后面的loginMember存在的代码
    @PostMapping(&quot;/update_read_state&quot;)
    @ResponseBody
    public Map updateReadState(Long memberId, Long bookId, Integer readState)&#123;
        Map result = new HashMap();
        try &#123;
            memberService.updateMemberReadState(memberId, bookId, readState);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//82 完成登录状态
            &lt;#if loginMember ??&gt;
            /**
             * 更新会员阅读状态
             */
            $(&quot;*[data-read-state]&quot;).click(function () &#123;
                //会员阅读状态
                var readState = $(this).data(&quot;read-state&quot;);
                //发送请求
                $.post(&quot;/update_read_state&quot;, &#123;
                    memberId: $&#123;loginMember.memberId&#125;,
                    bookId: $&#123;book.bookId&#125;,
                    readState: readState
                &#125;, function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123; //服务器处理成功
                        $(&quot;*[data-read-state]&quot;).removeClass(&quot;highlight&quot;);//高亮的清除
                        $(&quot;*[data-read-state=&#39;&quot; + readState + &quot;&#39;]&quot;).addClass(&quot;highlight&quot;);//状态值放入其中
                    &#125;
                &#125;, &quot;json&quot;)
            &#125;);
            &lt;/#if&gt;
</code></pre>
<h3 id="实现写短评功能"><a href="#实现写短评功能" class="headerlink" title="实现写短评功能"></a>实现写短评功能</h3><pre><code class="java">detail.ftl
 //83.短评功能  下面短评联动现象
            $(&quot;#btnEvaluation&quot;).click(function () &#123;
                // 选中id＝score的标签 转换为星型组件
                $(&quot;#score&quot;).raty(&#123;&#125;);
                $(&quot;#dlgEvaluation&quot;).modal(&quot;show&quot;);//显示短评对话框
            &#125;)
---------------------------------------------------------------
&lt;!-- Modal --&gt;
&lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-body&quot;&gt;
&lt;#-- 83. 短评联动   84 MemberService.java 短评实现代码 --&gt;
                &lt;h6&gt;为$&#123;book.bookName&#125;写短评&lt;/h6&gt;
                &lt;form id=&quot;frmEvaluation&quot;&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;span id=&quot;score&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;input-group  mt-2 &quot;&gt;
                        &lt;input type=&quot;text&quot; id=&quot;content&quot; name=&quot;content&quot; class=&quot;form-control p-4&quot;
                               placeholder=&quot;这里输入短评&quot;&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
            &lt;div class=&quot;modal-footer&quot;&gt;
                &lt;button type=&quot;button&quot; id=&quot;btnSubmit&quot; class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/service/MemberService.java
//84.短评代码!  MemberServiceImpl 组一个全新的对象
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
/**
     * 发布新的短评
     * @param memberId 会员编号
     * @param bookId 图书编号
     * @param score 评分
     * @param content 短评内容
     * @return
     */ // 84 完成评论信息的更新 85在MemberController编写与web交互功能
    public Evaluation evaluate(Long memberId, Long bookId, Integer score, String content) &#123;
        Evaluation evaluation = new Evaluation();
        evaluation.setMemberId(memberId);
        evaluation.setBookId(bookId);
        evaluation.setScore(score);
        evaluation.setContent(content);
        evaluation.setCreateTime(new Date());
        evaluation.setState(&quot;enable&quot;);
        evaluation.setEnjoy(0); //注入evaluationMapper 完成数据新增
        evaluationMapper.insert(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
//85.与web交互功能 前台请求传入数据 86回到detail.ftl写
    @PostMapping(&quot;/evaluate&quot;)
    @ResponseBody
    public Map evaluate(Long memberId, Long bookId, Integer score, String content)&#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            memberService.evaluate(memberId, bookId, score, content);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
//          result.put(&quot;evaluation&quot;, eva);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
//86.评论对话框提交数据  87完成点赞核心实现 MemberService
            $(&quot;#btnSubmit&quot;).click(function () &#123;
                var score = $(&quot;#score&quot;).raty(&quot;score&quot;);//获取评分
                var content = $(&quot;#content&quot;).val();
                if (score == 0 || $.trim(content) == &quot;&quot;)&#123; //没有进行选择 或 删除前后空格
                    return; //禁止提交方法中断
                &#125;
                $.post(&quot;/evaluate&quot;,&#123;
                    score : score,
                    bookId: $&#123;book.bookId&#125;,
                    memberId: $&#123;loginMember.memberId&#125;,
                    content: content
                &#125;,function (json) &#123;
                    if (json.code == &quot;0&quot;) &#123;//处理成功
                        window.location.reload();//列表进行刷新
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="完成会员短评点赞核心实现"><a href="#完成会员短评点赞核心实现" class="headerlink" title="完成会员短评点赞核心实现"></a>完成会员短评点赞核心实现</h3><pre><code class="java">com/imooc/reader/service/MemberService.java
 /**
     * 短评点赞
     * @param evaluationId 短评编号
     * @return 短评对象
     */
//    87完成点赞核心实现 MemberServiceImpl
    public Evaluation enjoy(Long evaluationId);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/MemberServiceImpl.java
// 87.短评点赞 自增+1 Membercontroller
    public Evaluation enjoy(Long evaluationId) &#123;
        Evaluation evaluation = evaluationMapper.selectById(evaluationId);
        evaluation.setEnjoy(evaluation.getEnjoy()+1);
        evaluationMapper.updateById(evaluation);
        return evaluation;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/MemberController.java
 //87.实现controller 88让客户端页面发送ajax请求
    @PostMapping(&quot;/enjoy&quot;)
    @ResponseBody
    public Map evaluate(Long evaluationId) &#123;
        Map result = new HashMap();
        try &#123;
//    Evaluation eva = memberService.evaluate(memberId, bookId, score, content);
            Evaluation eva = memberService.enjoy(evaluationId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
            result.put(&quot;evaluation&quot;, eva); //包含最新点赞数
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<pre><code class="java">detail.ftl
// 88.评论点赞
            $(&quot;*[data-evaluation-id]&quot;).click(function()&#123;
                var evaluationId = $(this).data(&quot;evaluation-id&quot;);
                $.post(&quot;/enjoy&quot;,&#123;evaluationId:evaluationId&#125;,function(json)&#123;
                    if(json.code == &quot;0&quot;)&#123;
                        $(&quot;*[data-evaluation-id=&#39;&quot; + evaluationId + &quot;&#39;] span&quot;).text(json.evaluation.enjoy);
                    &#125;
                &#125;,&quot;json&quot;)
            &#125;)
</code></pre>
<h3 id="Spring-Task定时任务-eg-闹钟命令"><a href="#Spring-Task定时任务-eg-闹钟命令" class="headerlink" title="Spring Task定时任务 [eg:  闹钟命令]"></a>Spring Task定时任务 [eg:  闹钟命令]</h3><ul>
<li>Spting Task 是 Spring 3.0后推出的定时任务模块</li>
<li>Spring Task的职责是按周期后台自动执行任务</li>
<li>Spring Task可利用Cron表达式实现灵活的定时处理</li>
</ul>
<h5 id="Cron表达式实例"><a href="#Cron表达式实例" class="headerlink" title="Cron表达式实例"></a>Cron表达式实例</h5><table>
<thead>
<tr>
<th align="center">秒</th>
<th align="center">分</th>
<th align="center">小时</th>
<th align="center">日</th>
<th align="center">月</th>
<th align="center">星期</th>
<th align="center">年</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0,30</td>
<td align="center">0-5</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">*</td>
<td align="center">?</td>
<td align="center">2000</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">9-18</td>
<td align="center">?</td>
<td align="center">*</td>
<td align="center">WED</td>
<td align="center"></td>
</tr>
</tbody></table>
<h5 id="利用Spring-Task自动计算图书评分-所有图书评价信息重算"><a href="#利用Spring-Task自动计算图书评分-所有图书评价信息重算" class="headerlink" title="利用Spring-Task自动计算图书评分 [所有图书评价信息重算]"></a>利用Spring-Task自动计算图书评分 [所有图书评价信息重算]</h5><pre><code class="java">mappers/book.xml
&lt;!--    89.增加平均评分增加信息  增加接口BookMapper --&gt;
    &lt;update id=&quot;updateEvaluation&quot;&gt;
        update book b SET evaluation_score = (
            select ifnull(avg(score),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        ),evaluation_quantity = (
            select ifnull(count(*),0) from evaluation where book_id = b.book_id and state=&#39;enable&#39;
        )
    &lt;/update&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/mapper/BookMapper.java
package com.imooc.reader.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.imooc.reader.entity.Book;
//33.创建完Book接口  34与之对应的创建book.xml文件
//89. 更新图书评分  BookService去定义
public interface BookMapper extends BaseMapper&lt;Book&gt; &#123;
    /**
     * 更新图书评分/评价数量
     */
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 /**
     * 更新图书评分/评价数量
     */
    //89. 定义完去impl定义实现类
    public void updateEvaluation();
&#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书评分/评价数量  Controller直接面向Service Service面向Mapper
     */
    //89. 更新操作需要声明式事务 开启  90applicationContext.xml开启task
    @Transactional
    public void updateEvaluation() &#123;
        bookMapper.updateEvaluation();
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;!--  61.配置Kaptcha 的bean  62创造KaptchaController.java--&gt;
    &lt;bean id=&quot;KaptchaProducer&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;
        &lt;property name=&quot;config&quot;&gt;
            &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;
                &lt;constructor-arg&gt;
                    &lt;props&gt;
                        &lt;!-- 验证码图片不生成边框 --&gt;
                        &lt;prop key=&quot;kaptcha.border&quot;&gt;no&lt;/prop&gt;
                        &lt;!-- 验证码图片宽度为120像素  --&gt;
                        &lt;prop key=&quot;kaptcha.image.width&quot;&gt;120&lt;/prop&gt;
                        &lt;!-- 验证码图片字体颜色为蓝色  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;
                        &lt;!-- 每个字符最大占用40像素  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/prop&gt;
                        &lt;!-- 验证码包含4个字符  --&gt;
                        &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;
                    &lt;/props&gt;
                &lt;/constructor-arg&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 90.开启Spring Task定时任务的注解模式 创建一个reader/task/ComputeTask.java--&gt;
    &lt;task:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/task/ComputeTask.java
package com.imooc.reader.task;

import com.imooc.reader.service.BookService;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

//90.组件注解 不确定是哪个类 但是会被扫描实例化和管理
@Component
public class ComputeTask &#123;
    @Resource
    private BookService bookService;
//  每分钟0秒时候 执行一次Cron表达式
    @Scheduled(cron = &quot;0 * * * * ?&quot;)
    public void updateEvaluation()&#123;
        bookService.updateEvaluation();
        System.out.println(&quot;已更新所有图书评分&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="后台管理功能-图书管理"><a href="#后台管理功能-图书管理" class="headerlink" title="后台管理功能-图书管理"></a>后台管理功能-图书管理</h3><h5 id="富文本编辑器wangEditor使用入门"><a href="#富文本编辑器wangEditor使用入门" class="headerlink" title="富文本编辑器wangEditor使用入门"></a>富文本编辑器<code>wangEditor</code>使用入门</h5><ul>
<li>基于Javascript与css开发的Web富文本编辑器</li>
</ul>
<pre><code class="java">test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!-- 91.引入wangEditor  创建WEB-INF/ftl/management/book.ftl--&gt;
    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
    &lt;button id=&quot;btnRead&quot;&gt;读取内容&lt;/button&gt;
    &lt;button id=&quot;btnWrite&quot;&gt;写入内容&lt;/button&gt;
&lt;/div&gt;
&lt;div id=&quot;divEditor&quot; style=&quot;width: 800px;height:600px&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var E = window.wangEditor;
    var editor = new E(&quot;#divEditor&quot;);//完成富文本编辑器初始化
    editor.create();//创建富文本编辑器,显示在页面上
    document.getElementById(&quot;btnRead&quot;).onclick = function()&#123;
        var content = editor.txt.html();//获取编辑器现有的html内容
        alert(content);
    &#125;
    document.getElementById(&quot;btnWrite&quot;).onclick = function()&#123;
        var content = &quot;&lt;li style=&#39;color:red&#39;&gt;我是&lt;b&gt;新内容&lt;/b&gt;&lt;/li&gt;&quot;;
        editor.txt.html(content);
    &#125;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现图书管理功能"><a href="#实现图书管理功能" class="headerlink" title="实现图书管理功能"></a>实现图书管理功能</h3><h6 id="在训练素材中导入图书管理页"><a href="#在训练素材中导入图书管理页" class="headerlink" title="在训练素材中导入图书管理页"></a>在训练素材中导入图书管理页</h6><pre><code class="java">book.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;#-- 91.创建后台图书管理控制器com/imooc/reader/controller/management/MBookController.java   --&gt;
    &lt;title&gt;图书管理功能&lt;/title&gt;
    &lt;style&gt;
        #dlgBook&#123;
            padding: 10px
        &#125;
    &lt;/style&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;

    &lt;script src=&quot;/resources/wangEditor.min.js&quot;&gt;&lt;/script&gt;


    &lt;script type=&quot;text/html&quot; id=&quot;toolbar&quot;&gt;
        &lt;div class=&quot;layui-btn-container&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-sm&quot; id=&quot;btnAdd&quot; onclick=&quot;showCreate()&quot;&gt;添加&lt;/button&gt;
        &lt;/div&gt;
    &lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;


&lt;div class=&quot;layui-container&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;图书列表&lt;/blockquote&gt;
    &lt;!-- 数据表格 --&gt;
    &lt;table id=&quot;grdBook&quot; lay-filter=&quot;grdBook&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;!--表单内容--&gt;
&lt;div id=&quot;dialog&quot; style=&quot;padding: 10px;display: none&quot;&gt;
    &lt;form class=&quot;layui-form&quot; &gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 图书类别 --&gt;
            &lt;select id=&quot;categoryId&quot; name=&quot;categoryId&quot; lay-verify=&quot;required&quot; lay-filter=
            &quot;categoryId&quot;&gt;
                &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
                &lt;option value=&quot;1&quot;&gt;前端&lt;/option&gt;
                &lt;option value=&quot;2&quot;&gt;后端&lt;/option&gt;
                &lt;option value=&quot;3&quot;&gt;测试&lt;/option&gt;
                &lt;option value=&quot;4&quot;&gt;产品&lt;/option&gt;
            &lt;/select&gt;

        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 书名 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;bookName&quot; name=&quot;bookName&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入书名&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;


        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 子标题 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;subTitle&quot; name=&quot;subTitle&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入子标题&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!-- 作者 --&gt;
            &lt;input type=&quot;text&quot; id=&quot;author&quot; name=&quot;author&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入作者信息&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top: 30px;font-size: 130%&quot;&gt;图书介绍(默认第一图将作为图书封面)&lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot; &gt;
            &lt;!-- wangEditor编辑器 --&gt;
            &lt;div id=&quot;editor&quot; style=&quot;width: 100%&quot;&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 图书编号 --&gt;
        &lt;input id=&quot;bookId&quot; type=&quot;hidden&quot;&gt;
        &lt;!-- 当前表单操作类型,create代表新增 update代表修改 --&gt;
        &lt;input id=&quot;optype&quot;  type=&quot;hidden&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot; style=&quot;text-align: center&quot;&gt;
            &lt;!-- 提交按钮 --&gt;
            &lt;button class=&quot;layui-btn&quot; lay-submit=&quot;&quot; lay-filter=&quot;btnSubmit&quot;&gt;立即提交&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

    var table = layui.table; //table数据表格对象
    var $ = layui.$; //jQuery
    var editor = null; //wangEditor富文本编辑器对象
    //初始化图书列表
    table.render(&#123;
        elem: &#39;#grdBook&#39;  //指定div
        , id : &quot;bookList&quot; //数据表格id
        , toolbar: &quot;#toolbar&quot; //指定工具栏,包含新增添加
        , url: &quot;/management/book/list&quot; //数据接口
        , page: true //开启分页
        , cols: [[ //表头
            &#123;field: &#39;bookName&#39;, title: &#39;书名&#39;, width: &#39;300&#39;&#125;
            , &#123;field: &#39;subTitle&#39;, title: &#39;子标题&#39;, width: &#39;200&#39;&#125;
            , &#123;field: &#39;author&#39;, title: &#39;作者&#39;, width: &#39;200&#39;&#125;
            , &#123;type: &#39;space&#39;, title: &#39;操作&#39;, width: &#39;200&#39; , templet : function(d)&#123;
                    //为每一行表格数据生成&quot;修改&quot;与&quot;删除&quot;按钮,并附加data-id属性代表图书编号
                    return &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-update&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39; data-type=&#39;update&#39; onclick=&#39;showUpdate(this)&#39;&gt;修改&lt;/button&gt;&quot; +
                        &quot;&lt;button class=&#39;layui-btn layui-btn-sm btn-delete&#39;  data-id=&#39;&quot; + d.bookId + &quot;&#39;   onclick=&#39;showDelete(this)&#39;&gt;删除&lt;/button&gt;&quot;;
                &#125;
            &#125;
        ]]
    &#125;);
    //显示更新图书对话框
    //obj对应点击的&quot;修改&quot;按钮对象
    function showUpdate(obj)&#123;
        //弹出&quot;编辑图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;, //指定div
            title: &quot;编辑图书&quot;, //标题
            type: 1, 
            content: $(&#39;#dialog&#39;).html(), //设置对话框内容,复制自dialog DIV
            area: [&#39;820px&#39;, &#39;730px&#39;], //设置对话框宽度高度
            resize: false //是否允许调整尺寸
        &#125;)

        var bookId = $(obj).data(&quot;id&quot;); //获取&quot;修改&quot;按钮附带的图书编号
        $(&quot;#dlgBook #bookId&quot;).val(bookId); //为表单隐藏域赋值,提交表单时用到

        editor = new wangEditor(&#39;#dlgBook #editor&#39;); //初始化富文本编辑器
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39; //设置图片上传路径
        editor.customConfig.uploadFileName = &#39;img&#39;; //图片上传时的参数名
        editor.create(); //创建wangEditor
        $(&quot;#dlgBook #optype&quot;).val(&quot;update&quot;); //设置当前表单提交时提交至&quot;update&quot;更新地址

        //发送ajax请求,获取对应图书信息
        $.get(&quot;/management/book/id/&quot; + bookId , &#123;&#125; , function(json)&#123;
            //文本框回填已有数据
            $(&quot;#dlgBook #bookName&quot;).val(json.data.bookName);//书名
            $(&quot;#dlgBook #subTitle&quot;).val(json.data.subTitle); //子标题
            $(&quot;#dlgBook #author&quot;).val(json.data.author);//作者
            $(&quot;#dlgBook #categoryId&quot;).val(json.data.categoryId); //分类选项
            editor.txt.html(json.data.description); //设置图文内容
            layui.form.render();//重新渲染LayUI表单
        &#125; , &quot;json&quot;)



    &#125;
    //显示新增图书对话框
    function showCreate()&#123;
        //弹出&quot;新增图书&quot;对话框
        layui.layer.open(&#123;
            id: &quot;dlgBook&quot;,
            title: &quot;新增图书&quot;,
            type: 1,
            content: $(&#39;#dialog&#39;).html(),
            area: [&#39;820px&#39;, &#39;730px&#39;],
            resize: false
        &#125;)
        //初始化wangEditor
        editor = new wangEditor(&#39;#dlgBook #editor&#39;);
        editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
        editor.customConfig.uploadFileName = &#39;img&#39;;//设置图片上传参数
        editor.create();//创建wangEditor

        layui.form.render(); //LayUI表单重新
        $(&quot;#dlgBook #optype&quot;).val(&quot;create&quot;);//设置当前表单提交时提交至&quot;create&quot;新增地址

    &#125;;

    //对话框表单提交
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
    //删除图书
    function showDelete(obj)&#123;
        //获取当前点击的删除按钮中包含的图书编号
        var bookId = $(obj).data(&quot;id&quot;);
        //利用layui的询问对话框进行确认
        layui.layer.confirm(&#39;确定要执行删除操作吗?&#39;, &#123;icon: 3, title:&#39;提示&#39;&#125;, function(index)&#123;
                    
                //确认按钮后发送ajax请求,包含图书编号
                $.get(&quot;/management/book/delete/&quot; + bookId, &#123;&#125;, function (json) &#123;
                    if(json.code==&quot;0&quot;)&#123;
                        //删除成功刷新表格
                        table.reload(&#39;bookList&#39;);
                        //提示操作成功
                        layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
                        //关闭对话框
                        layui.layer.close(index);
                    &#125;else&#123;
                        //处理失败,提示错误信息
                        layui.layer.msg(json.msg);
                    &#125;
                &#125;, &quot;json&quot;);
            
        &#125;);

    &#125;

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

//http://localhost/management/book/index.html
//91.后台管理系统 编写富文本编辑器的图片上传功能book.ftl已全实现
//editor.customConfig.uploadImgServer = &#39;/management/book/upload&#39;;//设置图片上传地址
//92提供文件上传地址的接口 pom.xml增加文件上传依赖 apache
@Controller
@RequestMapping(&quot;/management/book&quot;)
public class MBookController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showBook()&#123;
        return new ModelAndView(&quot;/management/book&quot;);
    &#125;

    /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;!-- 92.增加文件上传依赖 SpringMVC文件上传底层依赖 93去applicationContext.xml激活--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--  93.激活文件上传功能 回到MBookController--&gt;
    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 /**
     * wangEditor文件上传
     * @param file 上传文件
     * @param request 原生请求对象
     * @return
     * @throws IOException
     */
    //93. 接收提交的文件 上传的文件保存到upload目录中 代码编写 94book.ftl对话框表单提交
    @PostMapping(&quot;/upload&quot;)
    @ResponseBody
    public Map upload(@RequestParam(&quot;img&quot;) MultipartFile file, HttpServletRequest request) throws IOException &#123;
        //得到上传目录
        String uploadPath = request.getServletContext().getResource(&quot;/&quot;).getPath() + &quot;/upload/&quot;;//在out里 运行时执行获取路径
        //文件名
        String fileName = new SimpleDateFormat(&quot;yyyyMMddHHmmssSSS&quot;).format(new Date());
        //原始文件扩展名
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;));//最后一次获得点
        //保存文件到upload目录
        file.transferTo(new File(uploadPath + fileName + suffix));
        Map result = new HashMap();
        result.put(&quot;errno&quot;, 0);
        result.put(&quot;data&quot;, new String[]&#123;&quot;/upload/&quot; + fileName + suffix&#125;);
        return result;
    &#125;
</code></pre>
<h3 id="实现图书新增功能"><a href="#实现图书新增功能" class="headerlink" title="实现图书新增功能"></a>实现图书新增功能</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
        
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //95.创建新的图书 BookServiceImpl
    public Book createBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
 //95.数据增加 MBookController
    @Transactional
    public Book createBook(Book book) &#123;
        bookMapper.insert(book);
        return book;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//95.获取书籍数据
    @PostMapping(&quot;/create&quot;)
    @ResponseBody
    public Map createBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            book.setEvaluationQuantity(0);
            book.setEvaluationScore(0f);
            Document doc = Jsoup.parse(book.getDescription()); //一个个片段被解析
            Element img = doc.select(&quot;img&quot;).first();//选中所有标签提取第一个 获取图书详情第一图的元素对象
            String cover = img.attr(&quot;src&quot;);//获取当前元素指定值
            book.setCover(cover); //95.来自于description描述的第一幅图
            //用html解析器jsoup.jorg从前台的描述里截取图片位置 96加入依赖
            bookService.createBook(book); //此处可以打点debug
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;msg&quot;, ex.getMsg());
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书分页查询-显示图书列表"><a href="#实现图书分页查询-显示图书列表" class="headerlink" title="实现图书分页查询[显示图书列表]"></a>实现图书分页查询[显示图书列表]</h3><pre><code class="java">com/imooc/reader/controller/management/MBookController.java
 //96.设计列表显示加载 97回到book.ftl
    @GetMapping(&quot;/list&quot;)
    @ResponseBody
    public Map list(Integer page, Integer limit)&#123;
        if (page == null)&#123;
            page = 1;
        &#125;
        if (limit == null)&#123;
            limit = 10;
        &#125;
        IPage&lt;Book&gt; pageObject = bookService.paging(null, null, page, limit);//返回paging的分页对象
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        //layUI返回值必须要求写的
        result.put(&quot;data&quot;, pageObject.getRecords()); //当前页面数据
        result.put(&quot;count&quot;, pageObject.getTotal()); //未分页时记录总数
        return result;
    &#125;
</code></pre>
<h3 id="实现图书修改更新功能-原有数据调整-回填数据"><a href="#实现图书修改更新功能-原有数据调整-回填数据" class="headerlink" title="实现图书修改更新功能 [原有数据调整 回填数据]"></a>实现图书修改更新功能 [原有数据调整 回填数据]</h3><pre><code class="java">book.ftl
// 94.对话框表单提交 95增加全新方法声明BookService
    layui.form.on(&#39;submit(btnSubmit)&#39;, function(data)&#123;
        //获取表单数据
        var formData = data.field;
        
        //判断是否包含至少一副图片,默认第一图作为封面显示
        var description = editor.txt.html();
        if(description.indexOf(&quot;img&quot;) == -1)&#123;
            layui.layer.msg(&#39;请放置一副图片作为封面&#39;);
            return false;
        &#125;
        //获取当前表单要提交的地址
        //如果是新增数据则提交至create
        //如果是更新数据则提交至update
        var optype = $(&quot;#dlgBook #optype&quot;).val();
     // 97.从隐藏域拿数据   98 MBookController
        if(optype == &quot;update&quot;)&#123;
            //更新数据时,提交时需要附加图书编号
            formData.bookId=$(&quot;#dlgBook #bookId&quot;).val();
        &#125;
        //附加图书详细描述的图文html
        formData.description = description;
        //向服务器发送请求
        $.post(&quot;/management/book/&quot; + optype , formData , function(json)&#123;
            if(json.code==&quot;0&quot;)&#123;
                //处理成功,关闭对话框,刷新列表,提示操作成功
                layui.layer.closeAll();
                table.reload(&#39;bookList&#39;);
                layui.layer.msg(&#39;数据操作成功,图书列表已刷新&#39;);
            &#125;else&#123;
                //处理失败,提示错误信息
                layui.layer.msg(json.msg);
            &#125;
        &#125; ,&quot;json&quot;)
        return false;
    &#125;);
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//98 前台ajax发送的格式保持一致 /managemet/book/id/ + bookId
    @GetMapping(&quot;/id/&#123;id&#125;&quot;)
    @ResponseBody
    public Map selectById(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Book book = bookService.selectById(bookId);
        Map result = new HashMap();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;success&quot;);
        result.put(&quot;data&quot;, book); //服务器返回json.data book.ftl132行
        return result;
        //99 点击修改后的确认提交 增添更新操作 BookService.java
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/service/BookService.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.创建新的更新 BookServiceImpl
    public Book updateBook(Book book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
/**
     * 更新图书
     * @param book 新图书数据
     * @return 更新后的数据
     */
    //99.更新数据 100 MBookController
    @Transactional
    public Book updateBook(Book book) &#123;
        bookMapper.updateById(book);
        return null;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
    /**
     * 更新图书数据
     * @param book
     * @return
     */
    //100. 更新代码 不要轻易对Book book数据直接更新 根据传入的book编号把数据库记录查出来
//101 删除方法BookService
    @PostMapping(&quot;/update&quot;)
    @ResponseBody
    public Map updateBook(Book book)&#123;
        Map result = new HashMap();
        try &#123;
            Book rawBook = bookService.selectById(book.getBookId());
            //通过前台数据获取
            rawBook.setBookName(book.getBookName());
            rawBook.setSubTitle(book.getSubTitle());
            rawBook.setAuthor(book.getAuthor());
            rawBook.setCategoryId(book.getCategoryId());
            rawBook.setDescription(book.getDescription());
            Document doc = Jsoup.parse(book.getDescription());
            String cover = doc.select(&quot;img&quot;).first().attr(&quot;src&quot;);
            rawBook.setCover(cover);
            bookService.updateBook(rawBook);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="实现图书删除功能"><a href="#实现图书删除功能" class="headerlink" title="实现图书删除功能"></a>实现图书删除功能</h3><p><a target="_blank" rel="noopener" href="http://localhost/management/book/index.html">http://localhost/management/book/index.html</a><br><a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a></p>
<pre><code class="java">com/imooc/reader/service/BookService.java
 //101.删除方法 BookServiceImpl
    public void deleteBook(Long book);
</code></pre>
<pre><code class="java">com/imooc/reader/service/impl/BookServiceImpl.java
//101.删除相关数据 上面增加memberReadStateMapper evaluationMapper
    //一次性三个表删除 有声明式事务不会删一半 102 MBookController.java
    /**
     * 删除图书及其数据
     * @param bookId 图书编号
     */
    @Transactional
    public void deleteBook(Long bookId) &#123;
        bookMapper.deleteById(bookId);//单独删除id效率太低 写个构造器
        QueryWrapper&lt;MemberReadState&gt; mrsQueryWrapper = new QueryWrapper&lt;MemberReadState&gt;();
        mrsQueryWrapper.eq(&quot;book_id&quot;, bookId);
        memberReadStateMapper.delete(mrsQueryWrapper);
        QueryWrapper&lt;Evaluation&gt; evaluationQueryWrapper = new QueryWrapper&lt;Evaluation&gt;();
        evaluationQueryWrapper.eq(&quot;book_id&quot;, bookId);
        evaluationMapper.delete(evaluationQueryWrapper);
    &#125;
</code></pre>
<pre><code class="java">com/imooc/reader/controller/management/MBookController.java
//102. 封装 以及 code输出  103加入后台首页=&gt;index.ftl 后增加ManagementController
    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)
    @ResponseBody
    public Map deleteBook(@PathVariable(&quot;id&quot;) Long bookId) &#123;
        Map result = new HashMap();
        try &#123;
            bookService.deleteBook(bookId);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;msg&quot;, &quot;success&quot;);
        &#125; catch (BussinessException ex) &#123;
            ex.printStackTrace();
            result.put(&quot;code&quot;, ex.getCode()); ///成功时
            result.put(&quot;msg&quot;, ex.getMsg());//失败时
        &#125;
        return result;
    &#125;
</code></pre>
<h5 id="增加后台框架"><a href="#增加后台框架" class="headerlink" title="增加后台框架"></a>增加后台框架</h5><p><a target="_blank" rel="noopener" href="http://localhost/management/index.html">慕课书评网数据管理系统</a></p>
<pre><code class="java">com/imooc/reader/controller/management/ManagementController.java
package com.imooc.reader.controller.management;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;
//103.后台管理系统控制器 104 修改index.ftl的静态地址
/**
 * 后台管理系统控制器
 */
@Controller
@RequestMapping(&quot;/management&quot;) //功能启动后台所需
public class ManagementController &#123;
    @GetMapping(&quot;/index.html&quot;)
    public ModelAndView showIndex()&#123;
        return new ModelAndView(&quot;/management/index&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">index.ftl

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;慕课书评网数据管理系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课书评网数据管理系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    admin
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/management/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;


                    &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                        &lt;a href=&quot;javascript:void(0)&quot;&gt;数据管理&lt;/a&gt;
                        &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;xxx&quot;&gt;
&lt;#--       104.静态地址改为动态地址--&gt;
                            &lt;dd&gt;&lt;a href=&quot;/management/book/index.html&quot; target=&quot;ifmMain&quot;&gt;图书管理&lt;/a&gt;&lt;/dd&gt;
                            &lt;dd&gt;&lt;a href=&quot;短评管理.html&quot; target=&quot;ifmMain&quot;&gt;短评管理
                                &lt;/a&gt;&lt;/dd&gt;
                        &lt;/dl&gt;
                    &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot; src=&quot;/management/book/index.html&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;);
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/18/后端/SSM开发社交网站[Freemarker+Spring+SpringMVC+Mybatis(Plus)构成SSM+Bootstrap+Art-Template+Kaptcha+SpringTask+wangEditor]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/16/软考/软件设计师刷题考点/">
        <h2>
            软件设计师刷题考点
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/16
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h2><p>@@ 如果”2x”的补码是”90H”, 那么x的真值是 <u><strong>-56</strong></u><br>90H 拆开根据8 4 2 1由十六进制转换为二进制：10010000；补码最高位为符号位, 1代表负号, 所以说明此数为<strong>负数</strong>，可以根据口诀直接得源码(注意符号位不变)：1111 0000 即 -112；故2X&#x3D;-112  X&#x3D;-56</p>
<p>@@ 计算机中CPU对其访问速度最快的是<u><strong>通用寄存器</strong></u><br>计算机系统中的CPU内部对通用寄存器的存取操作是速度最快的 其次是Cache 再次是内存 最慢的是作为外存的硬盘</p>
<p>@@ 属于CPU中算术逻辑单元的部位是**<u>加法器</u>**<br>控制单元部件：<strong>指</strong>令寄存器、<strong>程</strong>序计数器、地<strong>址</strong>寄存器、<strong>数</strong>据寄存器[紫橙子树]                                                                                                                                                                                                                                                                                                                                                                                                                                         加法器是算数逻辑运算单元的部件</p>
<p>@@ 在CPU中，常用来为ALU执行算数逻辑运算提供数据并暂存运算结果的寄存器是<strong>累加寄存器</strong>[是专门存放算术或逻辑运算的一个操作数和运算结果的寄存器(加 减 读出 移位)]</p>
<p>@@ 所谓定点数，就是表示数据时小数点的位置固定不变。<br>小数点的位置通常由两种约定方式：<br>①定点整数(纯整数, 小数点在最低有效数值位之后)<br>②定点小数(纯小数, 小数点在最高有效数值位之前)<br>当机器字长为n时, 定点数的补码和移码可表示$2^n$个数, 而其源码和反码只能表示$2^n-1$个数(0占用了两个编码), 所以定点数所能表示的数值范围比较小, 运算中很容易因结果超出范围而溢出<br>数的浮点表示的一般形式为：N&#x3D;F×$2^E$, 其中E称为阶码，F为尾数。<br>尾数部分F的位数越多↑，数的精度越高↑；指数部分E的位数越多↑，能表示的范围越大↑<br><strong>阶码</strong>通常为带符号的纯整数<br><strong>尾数</strong>为带符号的纯小数<br>在尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同<br>当<strong>1&#x2F;2 ≤ |F|＜ 1</strong>时，应有0.1xx…x形式；<br>当**-1 ≤ M ＜ -1&#x2F;2<strong>时，应有1.0xx…x形式<br>当</strong>M&#x3D;-1&#x2F;2**时，对于源码来说是规格化数，而对于补码来说不是规格化数</p>
<p>@@ <strong>寄存器</strong>既可以用来存放<u>数据</u>和<u>地址</u>，也可以存放<u>控制信息</u>或<u>CPU工作时的状态</u><br>在CPU中增加寄存器的数量，可以使CPU把执行程序时所需的数据尽可能地放在寄存器中，从而减少访问内存的次数，提高其运行速度</p>
<p>@@ 程序计数器(PC)用于存放<strong>下一条指令所在单元的地址</strong>的地方</p>
<p>@@ 计算机系统中采用补码来表示和运算数据，原因是采用补码可以<strong>简化计算机运算部件的设计</strong><br>使用补码表示数据时，可以将符号位和其他位统一处理，减法也可按加法来处理，从而简化运算部件的设计</p>
<p>@@ 为了使一个系统能检查和纠正一个差错，间码最小距离必须至少是3<br><strong>海明码</strong>是一种可以纠正一位差错的编码，是<u>利用奇偶性来检错和纠错的一种校验方法</u>；海明码的基本意思是給传输的数据增加r个校验位，从而增加两个合法消息的不同位的个数。海明码利用奇偶性进行<u>检错</u>和<u>纠错</u>；其码距最小为<u>2n+1</u> [海明校验码只有在代码中只存在一个错误的前提下，才能实现纠错 ]<br>**循环冗余校验码(CRC)**编码方法是在k位信息码后再拼接r位的校验码，形成长度位n位的编码，其特点是检错能力极强且开销小，用于<u>编码器</u>及<u>检测电路实现</u><br><strong>奇偶校验</strong>是由若干位有效信息，再加上1  一个二进制位(校验位)组成校验码；奇偶校验只能查错不能纠错，<u>只有奇数个数发生错误，才能发现错误</u>；若有奇数个数据位出错，则可以检测出该错误但无法纠正错误</p>
<p>@@ 冗余技术：<br>1.结构冗余，按其工作方法可以分位<strong>静态</strong>、<strong>动态</strong>和<strong>混合</strong>冗余<br>2.信息冗余，指的是为了<strong>检测</strong>或<strong>纠正</strong>信息在运算或传输中的错误另外附加的一部分信息<br>3.时间冗余，指的是以重复执行指令或程序来消除顺时错误带来的影响<br>4.冗余附件技术，指的是为实现上述冗余技术所需的资源和技术</p>
<p>@@ CPU依据<strong>指令周期的不同阶段</strong>来区分在内存中以二进制编码形式存放的指令和数据<br>指令周期是执行一条指令所需时间，一般由若干个机器周期组成，是从取指令、分析指令到执行完所需的全部时间</p>
<p>@@ 浮点数相加，对阶时，小数向大数看齐；对阶是通过较小数的尾数右移实现的。将小阶向大阶对齐，同时将尾数右移n位</p>
<p>@@ 在CPU的寄存器中，<strong>指令寄存器</strong>对用户是完全透明的</p>
<p>@@ 程序计数器是用于存放下一条指令所在单元的地址的地方</p>
<p>@@ 属于CPU中算数逻辑单元的部件是<strong>加法器</strong></p>
<p>@@ 高速缓存地址是为了高速缓存的读取和写入而使用的地址，在CPU和高速缓存之间进行数据传输时使用的；当CPU需要读取数据时，DMA控制器和中断CPU发出的数据地址是<strong>主存的物理地址</strong>[<u>中断向量</u>提供的是<strong>中断服务程序的入口地址</strong>]；硬盘的扇区地址是用于访问硬盘上指定扇区的地址，并不直接与CPU进行数据交互；虚拟地址，是指在操作系统中使用的地址，它需要通过地址映射和页表等机制转换为物理地址才能被CPU使用</p>
<p>@@ <strong>相联存储器</strong>是指<u>按内容访问</u>的存储器<br>按<strong>构成存储器</strong>的材料：磁存储器、半导体存储器、光存储器<br>按存储器的<strong>工作方式</strong>：读写存储器、只读存储器<br>按<strong>访问</strong>方式：按地址访问的存储器、按内容访问的存储器<br>按**[寻]地址**访问的存储器：随机存储器、顺序存储器、直接存储器</p>
<p>@@ ±0编码相同的是<strong>补码和移码</strong></p>
<p>@@ 计算机感染特洛伊木马后的典型现象是<strong>有未知程序试图建立网络连接</strong>。特洛伊木马是一种通过网络传播的病毒，分为客户端和服务器端两部分，服务器端位于被感染的计算机，特洛伊木马服务器端运行后会<strong>试图建立网络连接</strong>，所以计算机感染特洛伊木马后的典型现象是有未知程序试图建立网络连接</p>
<p>@@ 再微型计算机中，管理键盘最适合采用的1&#x2F;0控制方式是<strong>中断方式</strong></p>
<p>@@    在移臂调度算法中，<strong>先来先服务</strong>和<strong>最短寻找时间优先</strong>(<u>根据当前磁臂到要请求访问磁道的距离，誰短满足誰的请求</u>)算法可能会随时改变移动臂的运动方向</p>
<p>@@ 计算机中，系统总线用于<strong>CPU、主存及外设部件</strong>连接</p>
<p>@@ 双核是指<strong>在一个CPU中集成两个运算核心以提高运算能力</strong></p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong></p>
<p>@@ 在程序执行过程中，Cache与主存的地址映射是由<strong>硬件自动</strong>完成的</p>
<p>@@ 关于软件著作权产生的时间是<strong>自作品完成创作之日</strong></p>
<p>@@ 人耳：20Hz ~ 20kHz。 说话：300 ~ 3400Hz。音乐：20 ~ 20kHz。白噪音：20 ~ 20kHz</p>
<p>@@ <strong>存储动画</strong>的文件格式有<strong>FLC、GIF、SWF</strong></p>
<p>@@ <strong>网络视频格式</strong>包括<strong>MOV、RM、ASF、WMV</strong>&#x3D;&#x3D;</p>
<p>@@ <strong>多媒体视频图像文件</strong>格式有<strong>AVI、MPG、ASF、MP4</strong></p>
<p>@@ <strong>声音、音频文件</strong>格式有<strong>WAV、WMA、MP3、MIDI、RA、APE</strong></p>
<p>@@ 属于<strong>图像文件</strong>格式有<strong>GIF、BMP、JPG、PNG、TIF</strong></p>
<blockquote>
<p><strong>.wma</strong>微软公司的有损压缩，压缩比高于MP3，Win7录音机默认格式</p>
</blockquote>
<p>@@ 位图（Bitmap）&#x3D;&gt; <strong>BMP</strong></p>
<p>@@ <strong>语音识别技术</strong>体现了<u><strong>多媒体技术</strong>与<strong>人工智能技术</strong></u>相结合</p>
<p>@@ 计算机系统的主存主要是由<strong>DRAM</strong>构成的。<br>随机访问存储器(<strong>RAM</strong>)有两类：静态的(SRAM) 和 动态的(DRAM)</p>
<p>@@ 存储系统采用Cache技术的主要目的是提高存储器的访问速度，因此是由<strong>硬件自动完成</strong>Cache与主存之间的操作</p>
<p>@@ 主存与Cache的地址映射方式中，<strong>全相联</strong>方式可以实现主存任意一块装入Cache中任意位置，只有装满才需要替换<br><strong>全相联地址映射：</strong>主存的任意一块可以映射到Cache中的<strong>任意</strong>一块<br><strong>直接相联映射：</strong>主存中一块只能映射到到Cache的一个<strong>特定</strong>的块中<br><strong>组相联的映射：</strong>各区中的某一块只能存入缓存的同组号的空间内，但组内各块地址之间则可以任意存放。即从<strong>主存</strong>的组到Cache的组之间采用直接映像方式，在两个对应的<strong>组内部</strong>采用全相联映像方式</p>
<p>@@ 常用的虚拟存储器由<strong>主存-赋存</strong>两级存储器构成<br>虚拟存储技术使辅助存储器和主存储器密切配合。虚拟存储器的地址称为虚地址或逻辑地址  </p>
<p>@@ 虚拟存储体系由<strong>主存-赋存</strong>两级存储器构成<br>一般计算机系统中主要由两种存储体系：<br><u><strong>Cache存储体系</strong></u>由<strong>Cache</strong>和<strong>主存储器</strong>构成，主要目的是提高存储器速度，对系统程序员以上均透明<br><u><strong>虚拟存储体系</strong></u>由主存储器和在线磁盘存储器等辅存构成，主要目的是扩大存储器容量，对应用程序员透明</p>
<p>@@ Cache的地址映像方式中，发生块冲突次数最小的是<strong>全相联映像</strong><br>Cache的地址映射方法主要有三种：全相联地址映射、直接相联地址映射、组相联地址映射<br>**全相联地址映射 **[意味着主存的任意一块可以映射到Cache中的任意一块，特点：块冲突概率低，Cache空间利用率高，但相联目录表容量大导致成本高、查表速度慢]<br><strong>直接映像方式</strong> [指主存的每一块只能映像到Cache的一个特定的块中，整个Cache地址与主存地址的低位部分完全相同，其特点是硬件简单，不需要相联存储器，访问速度快，Cache块冲突概率高，Cache控件利用率低]<br><strong>组相联映射</strong> [是上面两种方法的这种处理]</p>
<p>@@ 计算机采用分级存储体系的主要目的是为了解决<strong>存储容量、成本和速度之间的矛盾</strong>问题<br>高速缓存一般用SRAM[速度快,成本高]<br>内存一般用DRAM[集成度高,动态刷新]<br>外存一般用磁存储器[速度慢,容量大,价格便宜]</p>
<p>@@ Cache的设计思想是在合理成本下提高命中率</p>
<p>@@ <strong>并行总线</strong>适合<strong>近距离高速数据传输</strong>、<strong>串行总线</strong>适合<strong>长距离数据传输</strong><br>在单总线结构中，CPU与主存之间、CPU与I&#x2F;O设备之间、I&#x2F;O设备与主存之间、各种设备之间都通过系统总线交换信息。单总线结构的优点是控制简单方便，扩充方便</p>
<p>@@ 处理机主要由处理器、存储器和总线组成</p>
<p>@@ 总线：数(数据总线) 控(控制总线) 地(地址总线) ISA EISA PCI MCA<br>SCSI是一种用于计算机和智能设备之间系统级接口的独立处理器标准</p>
<p>@@ 总线复用方式可以<strong>减少总线中信号线的数量</strong><br>总线式一组能为多个部件分时共享的信息传送线，用来连接多个部件并为之提供信息交换通路，通过<strong>总线复用方式</strong><u>可以减少总线中信号线的数量，以较少的信号线传输更多的消息</u></p>
<p>@@ 在计算机系统中采用总线结构，便于实现系统的积木化结构，同时可以<strong>减少总线中信号线的数量</strong> </p>
<p>@@ <strong><u>直接主存存取</u></strong>(<strong>DMA</strong>)[Direct Memory Access]控制方式是在<strong>主存与外设</strong>之间直接建立数据通路进行数据的交换处理</p>
<p>@@ 在I&#x2F;O设备与主机间进行数据传输时，CPU只需在开始和结束时作少量处理，而无需干预数据传送过程的是<strong>直接存储器存取 [DMA]<strong>方式。[直接内存存取(Direct Memory Access)方式的基本思想是通过</strong>硬件控制</strong>实现<u><strong>主存</strong></u>与**<u>I&#x2F;O设备</u>**间的直接数据传送，数据的传递过程由DMA控制器进行控制，不需要CPU的干预。在DMA方式下由CPU启动传送过程，即向设备发出”传送一块数据”的命令，在传送过程结束时，DMAC通过中断方式通知CPU进行一些后续处理工作]</p>
<p>@@ 在微机系统中，BIOS(基本输入输出系统)保存在<strong>主板上的ROM</strong>中 [BIOS是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从<strong>CMOS</strong>中读写系统设置的具体信息]</p>
<p>@@ 计算机运行过程中，遇到突发事件，要求CPU暂时停止正在运行的程序，转去为突发事件服务，服务完毕，再自动返回原程序继续执行，这个过程成为<strong>中断</strong>，其处理过程中保存现场的目的是<strong>返回去继续执行原程序</strong></p>
<p>@@ CPU是再<strong>一个总线周期</strong>结束时响应DMA请求的 [DMA请求的检测点设置在每个机器周期也即总线周期结束时执行，这样使得总线利用率最高]</p>
<p>@@ 计算机中CPU的中断响应时间指的是<strong>从发出中断请求到开始进入中断处理程序</strong>的时间</p>
<p>@@ 中断向量可提供<strong>中断服务程序的入口地址</strong>[为了提高响应中断的速度，通常把所有<u>中断服务<strong>程序的入口地址</strong></u>[称中断向量]汇聚为<strong>中断向量表</strong>]</p>
<p>@@ 为了便于实现多级中断嵌套，使用<strong>堆栈</strong>来保护断点和现场最有效 【<u>实现中断嵌套<strong>后进先出</strong>的栈来保护断点和现场最有效(当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程中又有高级中断申请中断，则高级中断可以打断低级中断处理，转去处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为<strong>中断嵌套</strong>)</u>】</p>
<p>@@ <strong>由I&#x2F;O设备提出的中断请求是可屏蔽中断，电源掉电是不可屏蔽中断</strong><br>可将中断分为两大类：<br><strong>不可屏蔽中断</strong>(非屏蔽中断) 和 <strong>可屏蔽中断</strong><br><strong>不可屏蔽中断源</strong>[断电]一旦提出请求，CPU必须无条件响应，而对<strong>可屏蔽中断源</strong>[打印机中断(处于等待请求响应)]的请求，CPU可以响应，也可以不响应。</p>
<p>@@ 计算机在一个指令周期过程中，为从内存读取指令操作码，首先要将**程序计数器(PC)**的内容送到地址总线上<br>CPU首先从程序计数器获得需要执行的指令地址，从内存(或高速缓存)读取到的指令则暂存在指令寄存器(IR)，然后进行分析和执行</p>
<p><strong>程序计数器</strong>是PC用于存放下一条指令所在单元的地址的地方<br><strong>指令寄存器</strong>是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一套指令<br><strong>地址寄存器</strong>用来保存当前CPU所访问的内存单元的地址<br><strong>指令译码器</strong>从内存中取出一条指令经数据总线送往指令寄存器中</p>
<p>@@ 对于只有单条指令的情况下，流水线方式与顺序执行时没有区别的。流水线的原理是在某一时刻可以让多个部件同时处理多条指令，避免各部件等待空闲，由此提高了各部件的利用率，也提高了系统的吞吐率</p>
<p>@@ 流水线的吞吐率是指单位时间流水线处理机输出的结果的数目，因此流水线的吞吐率为一个流水级时间的倒数，即最长流水级时间的倒数</p>
<p>@@ CPU执行算术运算或者逻辑运算时，常将源操作数和结果暂存在<strong>累加器(AC)<strong>中<br>CPU中常设置多个寄存器，其中，<u><strong>程序计数器</strong>的作用是保存<em>待读取</em> 指令在内存中的地址</u>，</strong>累加器(AC)<strong>是算数逻辑运算单位中用来<u><strong>暂存</strong>源操作数</u>和<u>计算结果的寄存器</u>，</strong>指令寄存器</strong>暂存从内存读取的指令，<strong>地址寄存器</strong>暂存要访问的内存单元的地址。</p>
<p>@@ <strong>VLIW</strong>(Very Long Instruction Word, 超长指令字) 一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度</p>
<p>@@ 在机器指令的地址字段中，直接指出操作数本身的寻址方式称为<strong>立即寻址</strong>[是一种特殊的寻址方式 指令中在操作码字段后面的部分不是通常意义的操作数，而是操作数本身，也就是说数据就包含在指令中，只要取出指令，也就是去除了可以立即使用的操作数]</p>
<p>@@ 若CPU要执行的指令为：MOV R1，#45(即将数值45传递到寄存器R1中)，则该指令中采用的寻址方式是<strong>寄存器寻址和立即寻址</strong> [45是立即数，R1是寄存器]<br><strong>立即寻址：</strong>操作数就包含在指令中<br><strong>直接寻址：</strong>操作数存放在内存单元中，指令中直接給处操作数所在内存单元的地址<br><strong>寄存器寻址：</strong>操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名<br><strong>寄存器间接寻址：</strong>操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中<br><strong>间接寻址：</strong>指令中给出操作数地址的地址<br><strong>相对寻址：</strong>指令地址码给出的是一个偏移量可正可负，操作数地址等于本条指令的地址加上该偏移量<br><strong>变址寻址：</strong>操作数地址等于变址寄存器的内容加偏移量</p>
<p>@@ CISC(Complex Instruction Set Computer)是<strong>复杂指令系统计算机</strong>的简称 其基本思想是：<u>进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化，导致机器的指令系统越来越庞大而复杂。CISC计算机一般所含的指令数目至少300条以上</u><br>RISC(Reduced  Instruction Set Computer <strong>精简指令集计算机</strong>) 其基本思想是：<u>通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用<strong>硬布线</strong>控制逻辑优化编译程序。</u> 通常会比CISC配置更多的寄存器、RISC编译器的子程序库通常要比CISC编译器的子程序库大很多、RISC比CISC更加适合VLSI工艺的规整性要求。</p>
<p>@@ Flynn分类法基于信息流特征将计算机分成4类，其中<strong>MISD</strong>只有理论意义而无实例<br>Flynn主要根据指令流和数据流来分类：<br>① 单指令流单数据流机器(SISD)<br>② 单指令流多数据流机器(SIMD)<br>③ 多指令流单数据流机器(MISD)[<strong>M</strong>ulti <strong>I</strong>nstruction <strong>S</strong>ingle <strong>D</strong>ata] [采用多个指令流来处理单个数据流 在实际情况中，采用多指令流处理多数据流才是最有效的方法，因此MISD<strong>只是作为理论模型出现，没有投入实际应用</strong>]<br>④ 多指令流多数据流机器(MIMD)</p>
<p>@@ 取指令时间4Δt，分析时间为2Δt，执行时间为3Δt，按顺序方式从头到尾执行完600条指令所需时间为<strong>5400</strong>Δt，使用流水线从头到尾执行完600条指令所需的时间为<strong>2405</strong>Δt [未说流水线就普通乘法计算 流水线则按公式计算]<br>① 指令顺序执行时，每条指令需要(4Δt+2Δt+3Δt)&#x3D;9Δt     9Δt×600&#x3D;5400Δt<br>② (4Δt+2Δt+3Δt) + (600-1) × 4 &#x3D; 2405Δt</p>
<p>@@ 指令系统中采用不同寻址方式的目的是<strong>扩大寻址控件并提高编程灵活性</strong></p>
<p>@@ 计算机指令一般包括操作码和地址码两部分，为分析执行一条指令，其<strong>操作码和地址吗都应存入指令寄存器(IR)</strong> [程序被加载到内存后开始运行，当CPU执行一条指令时，<u><strong>先把它从内存器取到缓冲寄存器DR中，再送入IR暂存</strong></u>，指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所有功能。]</p>
<p>@@ CPU产生每条指令的操作信号并将操作信号送往相应的部件进行控制、CPU中的控制器决定计算机运行过程的自动化、指令译码器是CPU控制器中的部件<br>CPU是计算机的控制中心，主要由运算器、控制器、寄存器组、和内部总线等部件组成。<br><strong>控制器</strong>由程序计数器、指令寄存器、指令译码器、时序产生器和操作控制器组成</p>
<p>@@ 可靠度串并联：串联系统可靠度为R1×R2，并联系统可靠度为R1&#x2F;R2&#x3D;1-(1-R)</p>
<p>@@ 计算机系统的<strong>可靠性</strong>可以用**MTBF &#x2F; (1+MTBF)**来度量，其中MTBF为平衡失效间隔时间 [又称平均无敌故障时间] 是衡量一个产品(尤其是电器产品)的可靠性指标，单位为”小时”</p>
<p>@@ 软件产品的可靠性并不取决于<strong>软件产品的开发方式</strong> 而取决于<strong>潜在的错误数量和位置，软件产品的使用方式</strong>；软件可靠性指的是一个系统对于给定的时间间隔内，在给定条件下**<u>无失效运作的概率</u>**。</p>
<p>@@ <u>软件<strong>可靠性</strong></u>是指一个系统在给定时间间隔内和给定条件下<strong>无失败运行的概率</strong>，一个软件系统能够按照规格说明正确运行的概率。<u>软件<strong>可维护性</strong></u>是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源<strong>完成维护活动的概率</strong></p>
<p>@@ <strong>应用级网关</strong>防火墙是内部网和外部网的隔离点，它可对应用层的通信数据流进行监控和过滤。应用级网关可以工作在OSI七层模型上的任意一层，能够检查进出的数据包，通过网关复制传递数据，防止在受信任服务器和客户机与不受信任的主机之间直接建立联系。</p>
<p>@@ 用户A和B要进行安全通信，通信过程需确认双方身份和消息不可否认，A和B通信时使用<strong>数字证书</strong>来对用户的身份进行认证；使用<strong>数字签名</strong>确保消息不可否认。数字签名是对<strong>真实性</strong>的保护</p>
<p>@@ <strong>震网</strong>病毒是一种破坏工业基础设施的恶意代码，利用系统漏洞攻击工业控制系统，是一种危害性极大的<strong>蠕虫病毒</strong>。<strong>蠕虫(Worm)<strong>是一个程序或程序序列。它利用网络进行复制和传播，传染途径是通过网络、移动存储设备和电子邮件。最初的蠕虫病毒定义是在DOS环境下，病毒发作时会在频幕上出现一条类似虫子的东西，胡乱吞吃屏幕上的字母并将其改正。常见的蠕虫病毒有：</strong>快乐时光、红色代码、爱虫病毒、熊猫烧香、Nimda病毒、爱丽兹病毒</strong>。<strong>CIH</strong>：系统病毒      <strong>X卧底</strong>：以木马形式传播目标为智能手机的病毒<br><strong>引导区病毒</strong>：破坏的是引导盘、文件目录<br><strong>宏病毒</strong>[<strong>Macro</strong>]：破坏的是OFFICE文件相关(病毒宏将自身复制至Word的通用Normal模板中)<br><strong>木马</strong>：一般强调控制操控 [<strong>冰河</strong>是木马软件，主要用于远程监控。冰河木马后经其他人多次改写形成多种变种，并被用于入侵其他用户的计算机木马程序]</p>
<p>@@ Sniffer(<strong>嗅探器</strong>)是一种基于被动侦听原理的网络分析方式。使用这种技术方式可以监视网络的状态、数据流动情况以及网上传输的信息。它不是木马程序</p>
<p>@@ 属于DoS攻击的是<strong>SYN Flooding攻击</strong> [<u>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</u>]<br>① <strong>特洛伊木马</strong>[Trojan]是附着在应用程序中或者单独存在的一些恶意程序，它可以利用网络远程控制网络的另一端的安装有服务端服务的主机，实现对被植入了木马程序的计算机的控制，或者窃取被植入了木马程序的计算机上的机密资料。<br>② <strong>拒绝服务攻击</strong>通过网络的内外部用户来发动攻击。内部用户可以通过长时间占用系统的内存、CPU处理时间使其他用户不能及时得到这些资源，而引起拒绝服务器攻击；外部黑客也可以通过占用网络连接使其他用户得不到网络服务   <strong>SYN Flooding攻击</strong>以多个随机的源主机地址向目的路由器发送SYN包，在收到目的路由器的SYN ACK后并不回应，于是目的路由器就为这些源主机建立大量的连接队列，由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致服务器崩溃。服务器要等待超时才能断开已分配的资源，所以SYN Flooding攻击是一种DOS攻击<br>③ <strong>端口欺骗攻击</strong>是采用端口扫描到系统漏洞从而实施攻击<br>④ <strong>IP欺骗攻击</strong>是产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份</p>
<p>@@ DES是<strong>共享密钥加密</strong>算法；常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES<br><u>共享密钥加密</u>指<u><strong>对称加密</strong></u>；<br><u>非共享密钥</u>加密指<u><strong>公开密钥加密</strong></u></p>
<p>@@ 计算机病毒的特征：<strong>隐蔽性、传染性、潜伏性、触发性、破坏性</strong></p>
<p>@@ MD5是<strong>摘要</strong>算法，对任意长度的输入计算得到的结果长度是<strong>128未散列值</strong></p>
<p>@@ 攻击者通过发送一个目的主机已经接受过的报文来达到攻击目的，这种攻击方式属于<strong>重放</strong>攻击<br>**重放攻击(Replay Attacks)**又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行</p>
<p>@@ kerberos系统中可通过在报文中加入<strong>时间戳</strong>来防止重放攻击。发送的数据包带时间戳的，服务器可以根据时间戳来判断是否为重放包，以此防止重放攻击</p>
<p>@@  防火墙最基本的功能就是控制在计算机网络中，不同信任程度区域间传送的数据流。防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可也关闭不适用的端口，屏蔽内部细节。所有的访问都经过防火墙，防火墙就能记录下这些访问并做出日志记录，同时也能提供网络使用情况的统计数据</p>
<p>@@ 防火墙的性能及特点：<br>① <strong>工作层次：</strong>决定防火墙效率及安全的主要因素，<u><strong>工作层次越低，则工作效率越高，其安全性就越低</strong></u><br>② <strong>防火墙机制：</strong>采用代理机制，则防火墙具有内部信息隐藏的特点，相对而言，安全性越高，效率越低。如果采用<strong>过滤机制</strong>，则效率高，安全性却降低</p>
<p>@@ 包过滤防火墙和代理服务防火墙的叙述中正确的是<strong>包过滤技术对应用和用户是透明的</strong>。包过滤技术是一种基于网络层、传输层的安全技术，优点是简单实用，实现成本较低同时，<strong>包过滤操作对于应用层来说是透明的</strong>，使用此类防火墙时外部网络与内部网络之间不存在直接连接，即使防火墙发生了问题，外部网络也无法被保护的网络连接。</p>
<p>@@ 包过滤防火墙对数据包的过滤依据包括<strong>源IP地址、源端口号、目标IP地址、目标端口号</strong> 而不是<del>MAC地址</del></p>
<p>@@ 防火墙通常分为<strong>内网、外网、DMZ</strong>三个区域<br>按照<u>受保护程序</u>[安全级别]从高到低正确排列顺序依次为<strong>内网、DMZ、外网</strong>；<br>① 内网可以访问外网、内网可以访问DMZ<br>② 外网可以访问DMZ、外网不能访问内网<br>③ DMZ不能访问外网、DMZ不能访问内网</p>
<p>@@ 入侵检测技术包括<strong>专家系统、模型检测、简单匹配</strong> [<u>入侵检测</u>和<u>流量控制</u>属于网络安全措施]</p>
<p>@@ 这四种加密算法均能对明文进行加密。<br><strong>RSA</strong>是一种非对称加密算法，由于加密和解密的密钥不同，因此便于密钥管理和发放，同时用户或机构之间进行身份认证方面有较好的应用 [基于大数定律，通常用于对消息摘要进行签名(<strong>数字签名算法</strong>) 而IDEA和RC4适用于对数据传输加密]<br><strong>SHA-1</strong>是一种安全散列算法，常用于对接接收到的明文输入产生固定长度的输出，来确保明文在传输过程中不会被篡改<br><strong>MD5</strong>是一种使用最为广泛的报文摘要算法(<strong>摘要算法</strong>)<br><strong>RC5</strong>是一种用于对明文进行加密的算法，在加密速度和强度上均较为合适，适用于大量明文进行加密并传输</p>
<p>@@ 假定用户A、B分别为I1和I2两个CA处取得了各自的证书，下面<strong>I1、I2互换公钥</strong>是A、B互信的必要条件</p>
<p>@@ <strong>MIME</strong>是一个互联网标准，<u>扩展了电子邮件标准</u>，使其能够支持，与安全无关。<br><strong>SSL</strong>和<strong>HTTPS</strong>涉及到<u>邮件传输过程的安全</u><br><strong>PGP</strong>是一套用于信息加密、验证的应用程序，可用于<u>加密电子邮件内容</u></p>
<p>@@ 数字签名用于通信的A、B双方，使得A向B发送签名的消息P，提供以下服务：<br>① B可以验证消息P确实是来源于A<br>② A不能否认发送过消息P<br>③ B不能便在或修改消息P<br>数字签名首先需要生成消息摘要，使用非对称加密算法以及私钥对摘要进行加密。接收方使用发送方的公钥对消息摘要进行验证。</p>
<p>@@ 用户B收到用户A带数字签名的消息M，为了验证M的真实性，<span style = "color : red">首先需要从CA获取用户A的数字证书，并利用<strong>CA的公钥</strong>验证该证书的<strong>真伪</strong></span>，然后利用<strong>A的公钥</strong>验证M的真实性 [<u>验证证书的真伪需要用CA的公钥验证CA的签名，验证M的真实性需要用用户A的公钥验证用户A的签名</u>]</p>
<p>@@ <span style = "color : red">从认证中心CA获取用户B的数字证书，该证书用<strong>CA的私钥</strong>作<strong>数字签名</strong></span>：<u>从用户B的数字证书中可以获得B的公钥</u> 【<strong>CA公钥→合法性、CA签名→真伪、CA私钥→数字签名</strong>】</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/030ab484289fb8237b38a9a6a073451c201af8c5/data/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p>
<p>@@ 公钥体系中，<strong>私钥用于<u>解密和签名</u>，公钥用于<u>加密和认证</u></strong></p>
<p>@@ 某网站向CA申请了数字证书，用户通过<strong>CA的签名</strong>来验证网站的<strong>真伪</strong>，通过使用<strong>CA的公钥</strong>来确定该网站的<strong>合法性</strong></p>
<p>@@ <strong>设置防雷击</strong>属于物理线路安全措施、<strong>入侵检测, 流量控制</strong>属于网络安全措施、<strong>漏洞发现于补丁管理</strong>属于系统安全措施</p>
<p>@@ <strong>网络攻击</strong>有<strong>主动攻击</strong>和<strong>被动攻击</strong>两类，主动攻击是指通过一系列方法主动向被攻击对象试试破坏的一种攻击方式，<strong>主动攻击</strong>有：<u>重放攻击、IP地址欺骗、拒绝服务</u>。<strong>流量分析攻击</strong>[被动攻击]是通过持续检测现有网络中的流量变化或者变化趋势，而得到相应信息的一种被动攻击方式</p>
<p>@@ 端口443明确用于<strong>HTTPS服务</strong>，因此是HTTPS（加密）流量的标准端口。 它也称为HTTPS端口443，因此所有受保护的事务都是使用端口443进行的。 您可能会惊讶地发现，几乎95％的安全站点都使用端口443进行安全传输。80端口是<strong>HTTP超文本传输协议</strong>。</p>
<table>
<thead>
<tr>
<th align="center">Proto</th>
<th align="center">Local Address</th>
<th align="center">Foreign Address</th>
<th align="center">State</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2011</td>
<td align="center">202.100.112.12:443</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2052</td>
<td align="center">128.105.129.30:80</td>
<td align="center">ESTABLISHED</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">192.168.0.200:2038</td>
<td align="center">100.29.200.110:110</td>
<td align="center">TIME_WAIT</td>
</tr>
</tbody></table>
<p>① 其中已经与主机202.100.112.12的443端口建立连接，由于443端口主要用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP协议，是建立了<strong>安全连接</strong>。<br>② 其中已经与主机128.105.129.30的80端口建立了普通连接。<br>③ 其中与主机100.29.200.110的110端口正在等待建立连接</p>
<p>@@ <strong>SSH</strong>(Secure Shell)是<strong>终端设备</strong>与<strong>远程站点</strong>之间建立安全连接的协议，是专为远程登录会话和其他网络服务提供安全性的协议，利用SSH协议可以有效防止远程管理过程中的信息泄露问题，SSH最初是UNIX上的程序</p>
<p>@@ <strong>机房安全</strong>属于物理安全、<strong>入侵检测</strong>属于网络安全、<strong>漏洞补丁管理</strong>属于系统安全、<strong>数据库安全</strong>属于应用安全</p>
<p>@@ 网络系统中，通常把<strong>Web服务器</strong>置于DMZ区 [DMZ是为了<u>解决安装防火墙后外部网络不能访问内部网络服务器的问题</u>，而设立的一个非安全系统与安全系统之间的缓冲区。这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，在这个小网络区域内可以防止一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛]</p>
<p>@@ 拒绝服务攻击即攻击者想办法让目标机器停止提供服务，这是黑客常用的攻击手段之一，其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于<strong>拒绝服务攻击</strong>。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是<u><strong>迫使服务器的缓冲区满</strong></u>，不接收新的请求。二是<u><strong>使用IP欺骗</strong></u>，迫使服务器把合法用户的连接复位，影响合法用户的连接</p>
<p>@@ PKI体制中，保证数字证书不被篡改的方法是<strong>用CA的私钥对数字证书签名</strong>[防伪造,不可抵赖]</p>
<p>@@ <strong>ECC、DSA、RSA</strong>属于公开密钥加密算法     <strong>DES</strong>属于<strong>私钥加密体制</strong></p>
<p>@@ 利用<strong>报文摘要算法</strong>生成报文主要的目的是<strong>防止发送的报文被篡改</strong> [报文摘要是用来保证数据完整性的，传输的数据一旦被修改，摘要就不同了，只要对比两次摘要就可以确定数据是否被修改过]</p>
<p>@@ <strong>TLS</strong>是安全传输层协议的简称，用于在两个通信应用程序之间提供保密性和数据完整性<br><strong>SSL</strong>是安全套接层协议的简称，是一种为网络通信提供安全和数据完整性的协议，它与TLS非常相似，它们都是在<u>传输层</u>对网络连接进行加密<br><strong>PGP</strong>是基于RSA公钥加密体系的邮件加密软件，用它可以对邮件保密以防止非授权者阅读<br><strong>HTTPS</strong>即安全版的<strong>HTTP</strong>(超文本传输协议)，它是在HTTP下加入SSL层，HTTPS的安全基础就是SSL<br><strong>IPSec</strong>是<u>网络层</u>的安全协议，它通过使用加密的安全服务来确保在网络上进行保密而安全的通讯</p>
<p>@@ 在Windows系统中，默认权限最低的用户组是<strong>everyone</strong><br>用户组默认权限由高到低的顺序是<strong>administrators &gt; power users &gt; users &gt; everyone</strong></p>
<p>@@ IIS6.0支持的身份验证安全机制有[<u>.NET Passport身份验证、集成Windows身份验证、摘要式身份验证、基本身份验证</u>]安全级别最高的验证方法是<strong>集成Windows身份验证</strong></p>
<p>@@ 利用<strong>漏洞扫描系统</strong>可以获取某FTP服务器中是否存在可写目录的信息 [通过与目标主机TCP&#x2F;IP端口建立连接并请求某些服务(TELNET、FTP)，记录目标主机的应答，搜索目标主机相关信息，从而发现目标主机某些内在的安全弱点]</p>
<p>@@ FTP服务器的控制端口为<strong>21</strong>，上传文件时的端口为<strong>20</strong></p>
<p>@@ 防范网络监听最有效的方法是<strong>数据加密</strong></p>
<p>@@ “三网合一”的三网是指<strong>电信网、广播电视网、互联网</strong></p>
<h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>@@ <strong>LISP</strong>是一种通用高级计算机程序语言、<strong>C</strong>是命令式过程式语言、<strong>Java</strong>面向对象语言、<strong>C#<strong>结构化程序设计语言、</strong>Java,Python,JavaScript</strong>都是解释型程序设计语言[其中python[弱类型语言]和javascript是<u>脚本语言</u>(主要采用<strong>解释方式实现</strong>)]<br>强&#x2F;弱类型指的是语言类型系统的类型检查的严格程度。弱类型相对于强类型来说类型检查<strong>更不严格</strong>, 比如<u>允许变量类型的隐式转换，允许强制类型转换</u>等</p>
<p>@@ <strong><u>语法制导翻译</u><strong>是一种</strong>静态语义分析</strong>方法。程序设计语言的语义分为<strong>静态语义</strong>和<strong>动态语义</strong>，其中静态语义分析方法是语法制导翻译，其基本思想是将语言结构的语义以属性的形式赋予代表此结构的文法符号，而属性的计算以语义规则的形式赋予文法的产生式。</p>
<p>@@ 常用的函数参数传递方式有<strong>传值</strong>与<strong>传引用</strong>两种；<strong>在传引用方式下，修改形参实质上改变了实参的值</strong>。[<u>在<strong>传值</strong>调用方式下，是将实参的值传递给形参，该传递是单方向的，结束调用后不会再将形参的值传递給实参</u>。<u>在<strong>引用</strong>调用方式下，实质上是将实参的地址传递給形参，借助指针的间接访问数据方式下(或者将形参看作是实参的别名)，在被调用函数中对形参的修改实质上是对实参的修改。</u>]</p>
<p>@@ 在<strong>值调用</strong>方式下是将参数的值传給形参。在<strong>引用调用</strong>方式下是将实参的地址传递给形参                 </p>
<p>@@ 在<strong>传值调用</strong>方式下，实参可以是变量，也可以是常数和表达式<br>在<strong>引用调用</strong>方式下，可以是实现形参和实参间双向传递数据的效果          </p>
<p>@@ 传地址方式下，<u>将<strong>实参</strong>的地址传給<strong>形参</strong></u>，因此，实参必须有地址                                                                       </p>
<p>@@ 函数中print(x)执行后输出的值为<strong>40</strong></p>
<pre><code class="C">main()&#123;                      f(int x, int &amp;a)&#123;
  int x = 5;                    x = x * x - 1;
  f(x+1,x);                        a = x + a;
  print(x);                        return;
&#125;                               &#125;
</code></pre>
<p>@@ 函数中return(a-x)执行后输出的值为<strong>33</strong><br><img src="https://raw.githubusercontent.com/P-luminary/images/92ef1aa18e2abcd24f114fb254939f65a6933028/data/%E5%BD%A2%E5%8F%82%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92%E5%9C%B0%E5%9D%80.png" style="zoom:50%;" /></p>
<p>@@ 编译器对高级语言源程序的处理过程：<br><u>源程序 → 词法分析 → 语法分析 → 语义分析 → 中间代码生成 → 代码优化 → 目标代码生成 → 目标代码</u>；<br>其中<strong>中间代码生成和代码优化</strong>并不是每个编译器都必需的，与编译器相比，解释器<strong>参与运行控制，程序执行的速度慢</strong></p>
<p><strong>词法分析</strong>：根据语言的词法规则，对源程序进行逐个字符地描述，从中识别出一个个单词符号，针对词汇的检查<br><strong>语法分析</strong>：在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位；<br><strong>语义分析</strong>：分析各语法结构的含义，检查源程序是否包含语义错误，主要针对句子含义的检查；</p>
<p>@@ <strong>语法分析阶段</strong>的输入是<strong>记号流</strong>，若程序中的符号不匹配，则会在<strong>语法分析阶段</strong>检查出错误<br><strong>记号流</strong>：词法分析的输出是记号流，也就是语法分析的输入。<br><strong>源程序</strong>：词法分析的任务是把源程序的字符串转换成单词符号序列<br><strong>分析树</strong>：如果没有语法错误，语法分析后就能正常的构造出语法树</p>
<p>@@ <strong>语法错误</strong>是指语言结构上的使用错误，是指编译时所发现的程序错误，如<strong>单词拼写错误、标点符号错误、表达式中缺少操作数、符号不匹配</strong>等有关语言结构上的错误 [<u>语法分析阶段可以发现程序中所有的语法错误、但是不能在语义分析阶段发现程序中的所有语义错误(循环越界)</u>]</p>
<p>@@ 若程序在运行时陷入死循环，则情况属于<strong>动态的语义错误</strong>；在编译过程中，进行类型分析和检查是<strong>语义分析</strong>阶段的一个主要工作。**<u>死循环，零除数，其他逻辑错误</u><strong>是属于</strong>动态语义错误<strong>。语义检查时不检查动态语义，因此</strong><u>编译正确的程序不包含语法错误</u>**</p>
<p>@@ 高级程序设计语言不依赖具体的<strong>机器硬件</strong>；程序中局部变量的值在运行时<u>可以改变</u>，局部函数只能在函数内部使用，其作用域是从定义位置起至函数体或复合语句体结束位置。</p>
<p>@@ 在编写C&#x2F;C++时，若表达式中引用的变量从定义到使用始终没有赋值，则该变量中的值表现为一个<strong>随机数</strong>，这样对表达式的求值结果就是不确定的了。故[可以通过编译并运行，但运行结果不一定是期望的结果]</p>
<p>@@ 关于高级程序设计语言翻译的叙述中正确的是<strong>目标代码生成阶段的工作与目标机器的体系结构密切相关</strong></p>
<p>@@ 变量与常量：<strong>变量具有类型属性，常量则没有</strong> [<u>常量在程序运行过程中不能修改</u>]</p>
<p>@@ 可视化程序设计是以”<strong>所见即所得</strong>“的编程思想为原创，力图实现编程工作的可视化，即随时可以看到结果，程序与结果的调整同步。可视化程序设计仅通过直观的操作方式即可完成界面的设计工作[其基于面向对象的思想，引入了控件的概念和事件驱动；程序开发遵循步骤：即<u>先进行界面的绘制工作，再基于事件编写程序代码，以响应鼠标、键盘的各种动作</u>]。可视化程序设计最大的有点是设计人员可以不用编写或只需要编写很少程序代码，就能完成应用程序的设计，极大提高设计人员的工作效率</p>
<p>@@ PHP不是标记语言，PHP，全称 Hypertext Preprocessor ，中文翻译“超文本预处理器”。是在 服务器 端执行的 脚本语言 ，尤其适用于 Web 开发并可嵌入 HTML 中。 </p>
<p>@@ 创建指向邮箱地址的连接**<code>&lt;a href = &quot;mailto:test@test.com&quot;&gt; test@test.com &lt;/a&gt;</code>** 使用**<code>&lt;mailto&gt;</code>**标签定义一个指向电子邮件地址的超级链接</p>
<p>@@ <strong>指针变量</strong>可以是全局变量也可以是局部变量 </p>
<p>@@ 若一个程序语言可以提供链表的定义和运算，则其运算时的<strong>数据空间必须采用堆存储分配策略</strong></p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等，在结构上的变化。动态语言的类型检查是在运行时进行的。优点是方便阅读，不需要写非常多的与类型相关的代码；缺点是不方便调试，命名不规范时会读不懂、不利于理解。事实上脚本语言都是动态语言，而动态语言都是解释型语言，不管它们是否是面向对象的语言 ；C语言属于<strong>静态语言</strong>，其所有成分可在编译时确定</p>
<p>@@ HTML<code>&lt;body&gt;</code>元素中，<strong>vlink</strong>属性用于定义超链接被鼠标点击后所显示的颜色<br><strong>alink</strong>：用于设置正在被击中的链接的颜色<br><strong>vlink</strong>：用于设置已使用的链接的颜色<br><strong>bgcolor</strong>：用于设置文档整体背景颜色<br><strong>background</strong>：用于设置背景图片的URL</p>
<p>@@ XML文档语法规范中：<strong>标记之间不可以交叉嵌套</strong></p>
<p>@@ <strong>动态</strong>绑定是指在运行时把过程调用和响应调用所需要执行的代码加以结合。<strong>运行时结合</strong>是<strong>动态绑定</strong>、<strong>编译时结合</strong>是<strong>静态绑定</strong></p>
<p>@@ 汇编程序的功能是将用<strong>汇编语言</strong>写的源程序翻译成机器指令程序。汇编程序的基本工作包括将一条可执行汇编语句转换成对应的机器指令；处理源程序中出现的伪指令。由于汇编指令中形成操作数指令的部分可能出现后面才会定义的符号，所以汇编程序一般需要两次扫描源程序才能完成翻译过程</p>
<p>@@ 对高级语言源程序进行编译或解释处理的过程中，需要不断收集、记录和使用源程序中一些相关符号的类型和特征等信息，并将其存入<strong>符号表</strong> [这些信息一般以表格形式存储于系统中]</p>
<p>@@ 将高级语言源程序翻译称目标程序的是<strong>编译程序</strong></p>
<p>@@ 将高级语言源程序翻译为可在计算机上执行的形式有多种不同的方式，其中<strong>编译方式生成逻辑上与源程序等价的目标程序，解释方式不生成</strong>[为源程序中变量所分配的存储单元的地址属于<strong>逻辑地址</strong>]<br>编译语言是一种以编译器来实现的编程语言，它不像直译语言一样，由解释器将代码一句一句运行，而是以编译器，先将代码编译为机器码，再加以运行。将某一种程序设计语言写的程序翻译成等价的另一种语言的程序的程序，称为编译程序</p>
<p>@@ 将高级语言源程序通过编译或解释方式进行翻译时，可以先生成与源程序等价的某种中间代码。<strong>后缀式和三地址码是常用的中间代码</strong>。[不同高级程序语言可以产生同一种中间代码]<br><strong>中间代码</strong>的作用是<u>可使程序的结构再逻辑上更为简单明确</u>(<strong>有利于进行与机器无关的优化处理，优化一般建立在对程序的控制流和数据流分析的基础之上, 与机器无关</strong>)，特别是可以使目标代码的优化比较容易实现。中间代码由很多形式，常见的由**<u>逆波兰记号(后缀式)、四元式、三元式(三地址码)、语法树</u><strong>，它们的共同特点是与具体的机器无关，不依赖于具体的计算机。</strong>中间代码**是源程序的一种内部表示，称中间语言。<u>中间代码不依赖于具体的机器、使用中间代码可提高编译程序的可移植性、中间代码可以用树或图表示</u></p>
<p>@@ 编译程序不参加与用户程序的运行控制，而解释程序则参与。编译程序(编译器)则是将源程序翻译成目标语言程序，然后再计算机上运行目的程序。再解释方式下。翻译源程序时不生成独立的目标程序，而编译器则将源程序翻译成独立保存的目标程序。</p>
<p>@@ 编译和解释是实现高级程序设计语言翻译的两种基本形式，<u><strong>在编译方式下，必须进行词法、语法和语义分析，然后再产生源程序的目标代码</strong></u></p>
<p>@@ 对高级语言源程序进行编译的过程可分为多个阶段，分配寄存器的工作再<strong>目标代码生成</strong>阶段进行。[<strong>目标代码生成</strong>是编译器工作的最后一个阶段，这一阶段的任务是把中间代码变换成特定机器上的绝对指令代码、了重定位的指令代码或汇编指令代码，这个阶段的工作与具体的机器密切相关，因此在目标代码生成阶段分配寄存器。]</p>
<p>@@ 汇编程序输入的是用汇编语法书写的源程序，输出的是用机器语言表示的目标程序[<u>汇编语言源程序中的指令语句将被翻译成机器代码</u>、<u>汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出</u>、<u>汇编语言的指令语句必须具有操作码字段，可以没有操作数字段</u>]</p>
<p>@@ 编译过程中，对高级语言程序语句的翻译主要考虑声明语句和可执行语句。对声明语句，主要是将所需要的信息正确地填入合理组织的<strong>符号表</strong>中；对可执行语句，则是<strong>翻译成中间代码或目标代码</strong></p>
<p>@@ <strong>编译</strong>和<strong>解释</strong>是语言处理的两种基本方式：<br><strong>编译过程</strong>包括(词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等阶段)，以及**<u>符号表管理</u><strong>和</strong><u>出错处理模块</u>**<br><strong>解释过程</strong>在词法、语法和语义分析方面与编译程序的工作原理基本相同，但是在运行用户程序时，它直接执行<strong>源程序或源程序的内部形式</strong><br>这两种语言处理程序的根本区别：在编译方式下，机器上运行的是与源程序等价的目标程序，源程序和编译程序都不再参与目标程序的执行过程；而在解释方式下，解释程序和源程序(某种等价表示)要参与到程序的运行过程中，运行程序的控制权在解释程序。解释器翻译源程序时不产生独立的目标程序，而编译器则需要将源程序翻译成独立的目标程序</p>
<p>@@ <strong>移进—归约</strong>分析法是编译程序(解释程序)对高级语言源程序进行语法分析的一种方法，属于<strong>自下而上</strong>的语法分析方法<br><strong>递归下降分析法、预测分析法</strong> → 是<u><strong>自上而下</strong></u>分析法<br><strong>移进-归约分析法</strong> → 是**<u>自下而上</u>**分析法</p>
<p>@@ 已知某高级语言源程序A经编译后得到机器C上的目标程序B，则<strong>对B进行反编译，不能还原出源程序A</strong><br>编译是将高级语言源程序翻译成机器语言程序，<u>反编译是编译的逆过程</u>，<u><strong>反编译</strong>通常不能把可执行文件还原成高级语言源程序，只能转换成功能上等价的汇编程序</u></p>
<p>@@ 对于表达式<code>a or ((c&lt;d) and b)</code>，当<strong>a为true</strong>时可进行<strong>短路计算</strong>，最后计算的是or，对 <strong>或运算</strong> ，只要有一个真则结果为真，此题当a为true时，可进行短路计算，直接得到后面的结果</p>
<p>@@ 文法分为4种类型，程序设计语言的大多数语法现象可用<strong>乔姆斯基</strong>的<strong>上下文无关文法</strong>描述</p>
<p>@@ 在仅由字符a、b构成的所有字符串种，其中<u>以b结尾的<strong>字符串集合</strong></u>可用正则表达式为<br>$(b|ab)^<em>b$表示的<strong>字符串集合</strong>为<code>&#123;b,bb,abb,bbb,abab,bbbb,abbb,babb,...&#125;</code><u>除了以b结尾, 还要求每个a后面至少有1个b</u> 不符合题意只要有b结尾的！！<br>$(a|b)^</em>b$ 表示的<strong>字符串集合</strong><code>&#123;b,ab,bb,aab,abb,bab,bbb,aaab,aabb,abab,abbb,baab,babb,bbab,...&#125;</code></p>
<p>@@ 表达式采用逆波兰式表示时，利用<strong>栈</strong>进行求值<br>后缀式(逆波兰式)表达方式把运算符写在运算对象后面，**把a+b写成ab+**，所以也称为后缀式。借助栈可以方便地对后缀式进行求职。</p>
<p>@@ 与算术表达式**(a+(b-c))*d**对应的树是  求值运算处理顺序是：先进行b-c，然后与a相加，最后再与d相乘[中序遍历二叉树即可得出]</p>
<p>@@ 算数表达式**(a-b)<em>(c+d)<strong>的后缀式是</strong>ab-cd+**</em>  后缀式(逆波兰式)</p>
<p>@@ 算术表达式<em>*a+(b-C)*d**的后缀式是</em><em>abc-d</em>+** 利用逆波兰式，但是要把得到的步骤式子当成整体<br>原式&#x3D;<code>a+bC-*d</code> &#x3D;<code>a+bC-d*</code>&#x3D;<code>abC-d*+</code>  其中的着重点在于把bC-变成一个整体<strong>bC- * d</strong>再用逆波兰式 <strong>bC-d</strong>*<br>算术表达式**(a-b)<em>c+d<strong>的后缀式是</strong>ab-c</em>d+**</p>
<p>@@ 逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code> 的后缀式是**<code>ab^cbx0&gt;v^v</code>**<br>此题有大坑   <code>^是&quot;与&quot;门的意思、v是异&quot;或&quot;门的意思</code>；<br><u>逻辑与运算</u>的优先级高于<u>逻辑或运算</u><br>“<strong>逻辑与运算</strong>“ 表达式 “<code>x^y</code>“的短路求值逻辑是：若x为假，则可知”<code>x^y</code>“的值为假，无需再对y求值。因此只有在x为真时继续对y求值<br>“<strong>逻辑或运算</strong>“ 表达式 “<code>xvy</code>“的短路求值逻辑是：若x为真，则可知”<code>xvy</code>“的值为真，无需再对y求值。因此只有在x为假时继续对y求值<br>对于逻辑表达式<code>&quot;a^bvc^(bvx&gt;0)&quot;</code>，从运算符的优先级方面考虑需先对”<code>a^b</code>“求值。然后对”<code>c^(b^x&gt;0)</code>“求值，最后进行对<code>&quot;v&quot;</code>运算，因此后缀式是**<code>ab^cbx0&gt;v^v</code>**</p>
<p>@@ 递归下降分析方法是一种<strong>自上而下的语法分析</strong><br>程序式设计语言的绝大多数语法规则可以采用<strong>上下文无关文法</strong>进行描述。语法分析方法有多种，根据产生语法树的方向，可分为<u><span style = "color:red"><strong>自底向上</strong></span>[算符优先分析法、LR分析法]</u>     <u><strong><span style = "color:red">自顶向下</span></strong>[递归下降分析法、预测分析法]</u>两类。</p>
<p>@@ 对于大多数通用程序设计语言，用<strong>上下文无关文法</strong>描述其语法即可<br>文法分成四种类型：0型、1型、2型、3型。<br><strong>0型文法</strong>也称为短语文法，其能力相当于图灵机，任何0型语言都是递归可枚举的；反之，递归可枚举集也必定是一个0型语言<br><strong>1型文法</strong>也称为上下文有关文法，这种文法意味着对非终结符的替换必须考虑上下文<br><strong>2型文法</strong>也称为上下文无关文法，非终结符的替换无需考虑上下文【通用程序设计语言绝大多数使用上下文无关文法(此文法拥有足够强的表达能力来表示大多数程序设计语言的语法)】<br><strong>3型文法</strong>等价于正规式，因此也被称为正规文法或线性文法。</p>
<p>@@ 在c&#x2F;c++程序种，整型变量a的值为0且应用在表达式”c&#x3D;b&#x2F;a”种，则最可能发生的情形是<strong>运行时产生异常</strong><br>c&#x3D;b&#x2F;a符合c&#x2F;c++语言的语法逻辑，编译时不会报错，运行时，代入a的值，发生错误</p>
<p>@@ 对高级语言源程序进行编译过程中，有限自动机(NFA或DFA)是进行<strong>词法分析</strong>的适当工具<br>词法分析的任务是把构成源程序的字符串转换成单词符号序列。有限自动机是一种识别装置的抽象概念，它能准确地识别正规集。有限自动机分为两类：<strong>确定的有限自动机(DFA)<strong>和</strong>不确定的有限自动机(NFA)</strong></p>
<p>@@ L&#x3D;{$a^n$$b^n$|n&gt;&#x3D;1}<strong>不能用正规式表示，也不能通过有限自动机识别</strong>[此字符串的特点是a的个数与b的个数相同，且所有的a都在b之前]，因为该集合不是正规集，不能用正规式表示。而语言**L&#x3D;{$a^m$$b^n$|m≥0, n≥1}**的正规式表达式式<code>a*bb*</code>  因为在此集合中表示，若干个a之后跟若干个b，a可以不出现，b至少出现1次。</p>
<p>@@ 包含8个成员的开发小组的沟通路径最多有<strong>28</strong>条 [任意小组成员之间均可能有沟通路径，则可用完全连通图来对开发小组的沟通路径建模，最多的沟通路径为<strong>完全连通图的边数</strong>，即n个成员的开发小组的沟通路径是<strong>n(n-1)&#x2F;2</strong>，因此8个成员的开发小组沟通路径最多有28条]</p>
<img src="https://raw.githubusercontent.com/P-luminary/images/cbacb3bb4e0bb351d573b25f7a61a12cfdcddc4a/data/%E7%A1%AE%E5%AE%9E_%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A9%E6%9C%BA.png" style="zoom: 67%;" />

<p>@@ 一个文法的语言是从文法能产生的句子的集合。<u><strong>一个文法产生的句子是从文法开始符号发出推导出的所有终结符号串</strong></u></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>@@ 从减少成本和缩短研发周期考虑，要求<strong>嵌入式操作系统</strong>能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置。该要求体现了嵌入式操作系统的<strong>可定制性</strong><br><strong>嵌入式操作系统的特点：</strong><br>① <strong>微型化：</strong>从性能和成本角度考虑，希望占用的资源和系统代码量少<br>② <strong>可定制：</strong>从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的<strong>微处理器平台</strong>上，能针对硬件变化进行结构与功能上的配置，以满足不同应用的需求<br>③ <strong>实时性：</strong>嵌入式操作性系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领域需要迅速响应的场合，所以对实时性要求较高<br>④ <strong>可靠性：</strong>系统构建、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施<br>⑤ <strong>可移植性：</strong>为了提高系统的易移植性，通常采用<strong>硬件抽象层</strong>和<strong>板级支撑包</strong>的底层设计技术</p>
<p>@@ 在Linux中，要更改一个文件的权限设置可使用<strong>chmod</strong>命令，修改文件夹名可使用<strong>modify</strong>命令<br>Linux中只有一个根目录，用”&#x2F;“表示</p>
<p>@@ 计算机系统由<strong>硬件</strong>和<strong>软件</strong>两部分组成，通常把未配置软件的计算机称为裸机。操作系统目的是为了填充人与机器之间的鸿沟，即建立用户与计算机之间的接口，而为裸机配置的一种系统软件。从用户角度看，当计算机配置了操作系统后，用户不再直接使用计算机系统硬件，而是使用操作系统所提供的命令和服务去操纵计算机，操作系统已称为现代计算机系统中必不可少的最重要的系统软件，因此<strong>操作系统</strong>是<strong>用户</strong>与<strong>计算机之间</strong>的<u>接口</u><br><img src="https://raw.githubusercontent.com/P-luminary/images/9f871f12e0e525d3f04ed912fcaa537b19f5203a/data/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%9C%B0%E4%BD%8D.jpg" style="zoom:50%;" /></p>
<p>@@ 实时操作系统主要用于<strong>实时要求的过程控制</strong>等领域，实时系统对于来自外部的事件必须在<strong>被操控对象规定的事件内做出及时响应并对其进行处理</strong>。<br><strong>实时操作系统</strong>与<strong>分时操作系统</strong>的第一点区别就是：<br>① 交互性强弱不同，<u>分时系统</u>交互型强，<u>实时系统</u>交互型弱，但可靠性要求高<br>② 响应事件的敏感性强，对随机发生的外部事件必须在被控制对象规定的时间做出及时响应并对其进行处理<br>③ 系统的设计目的不同，<u>分时系统</u>是设计称一个多用方的通用系统，交互能力强；而<u>实时系统</u>大多数都是专用系统。</p>
<p>@@ <strong>嵌入式系统初始化</strong>过程分为3个主要环节，按照<u>自底向上</u>，<u>从硬件到软件</u>的次序依次为：<u><strong>片级初始化</strong>、<strong>板级初始化</strong>、<strong>系统级初始化</strong></u>。系统初始化主要任务是<strong>以软件初始化为主，主要进行操作系统的初始化</strong><br><strong>片级初始化：</strong><u>片级初始化完成嵌入式微处理器的初始化</u>，包括设置嵌入式微处理器的核心寄存器和控制寄存器、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。片级初始化把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个纯硬件的初始化过程。<br><strong>板级初始化：</strong><u>板级初始化完成嵌入式微处理器以外的其他硬件设备的初始化</u>。另外，还需设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。这是一个同时包含软硬件两部分在内的初始化过程。<br><strong>系统初始化：</strong><u>系统初始化过程以软件初始化为主，主要进行操作系统的初始化</u>。BSP将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创建应用程序环境，并将控制权交给应用程序的入口。</p>
<p>@@ 设计操作系统时不需要考虑的问题是<strong>语言编译器的设计实现</strong><br>操作系统有两个重要作用：<br>① 通过资源管理提高计算机系统的效率，<strong>操作系统</strong>是计算机的资源管理者，它含有对系统软&#x2F;硬件资源实施管理的一组程序<br>② 改善人机界面，向用户提供有好的工作环境</p>
<p>@@ <strong>磁盘格式化</strong>是指把一张空白的盘划分称一个个小区域并编号，以供计算机存储和读取数据，格式化是一种纯物理操作，实在磁盘的所有数据区上写0的操作过程，同时对硬盘介质做一致性检测，并且标记出不可读和坏的扇区。由于大部分硬盘在出厂时已经格式化过，所以有在硬盘介质产生错误时才需要进行格式化。<br><strong>磁盘分区</strong>是将磁盘划分成一块块的存储区域。在传统的磁盘管理中，将一个硬盘分为两大类分区：主分区和扩展分区。主分区是能够安装操作系统、能够进行计算机启动的分区，这样的分区可以直接格式化，然后安装系统，直接存放文件。<br>磁盘里的文件都是按存储时间先后来排列的，理论上文件之间都是紧凑排列而没有空隙的。但是，用户常常会对文件进行修改，而且新增加的内容并不是直接加到原文件的位置的，而是放在磁盘存储空间的最末尾，系统会在这两段之间加上联系标识。当有多个文件被修改后，磁盘里就会有很多不连续的文件。一旦文件被删除，所占用的不连 续空间就会空着，并不会被自动填满，而且，新保存的文件也不会放在这些地方，这些 空着的磁盘空间，就被称作”磁盘碎片”。因此，硬盘的每个分区里都会有碎片。碎片太多，其他的不连续文件相应也多，系统在执行文件操作时就会因反复寻找联系标识，工作效率大大降低，直接的反映就是感觉慢。磁盘清理将删除计算机上所有不需要的文件（这些文件由用户或系统进行确认）。<br><strong>磁盘碎片整理</strong>就是通过系统软件或者专业的磁盘碎片整理软件对电脑磁盘在长期使用过程中产生的碎片和凌乱文件重新整理，释放出更多的磁盘空间，可提高电脑的整体性能和运行速度。</p>
<p>@@ 在WinXP操作系统中，用户利用”<strong>磁盘管理</strong>“程序可以对磁盘进行初始化、创建卷，<strong>可以选择使用FAT、FAT32或NTFS文件系统格式化券</strong>，通常将<code>&quot;C:\Windows\myprogram.exe&quot;</code>文件设置成<strong>只读</strong>和<strong>隐藏</strong>属性，以便控制用户对该文件的访问。这一级安全管理称之为<strong>文件级</strong>安全管理。<br>文件级安全管理是通过系统管理员或文件组对文件设置来控制用户对文件的访问。用户对文件的访问，将由用户<strong>访问权、目录访问权、文件属性</strong>三者的权限所确定。</p>
<p>@@ 假设磁盘臂位于15号柱面上，进程的请求序列如下表表示，如果采用<strong>最短移臂调度算法</strong>，那么系统的响应序列应为<strong>⑤①②④③⑥</strong></p>
<table>
<thead>
<tr>
<th>请求序列</th>
<th>柱面号</th>
<th>磁头号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td>12</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>②</td>
<td>19</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>③</td>
<td>23</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>④</td>
<td>19</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>⑤</td>
<td>12</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>⑥</td>
<td>28</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p><strong>最短移臂调度算法</strong>，即有限响应距离比较近磁道的申请<br>1.当磁头位于15号柱面 (柱面号即磁道编号)，请求序列分别位于12号柱面(①⑤)、19号柱面(②④)、23号柱面(③)、28号柱面(⑥)<br>2.距离15号柱面最近的应该是12号柱面(①⑤)，优先响应(①⑤)，次序不限；</p>
<p>@@ P(Pass)(通过)消耗一个信号量  V(释放)发送一个信号量<br>V(S1)唤醒P(S1)：<strong>收银员进程操作</strong>只有等待着<strong>购书者</strong>拿出去前台后才能触发</p>
<p>@@ PV操作是操作系统提供的具有特定功能的原语，利用PV操作可以<strong>实现资源的互斥使用</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37063785/article/details/88802580">软考必考题型之PV操作_pv操作中p和v各代表什么-CSDN博客</a></p>
<p>@@ 某计算机系统中互斥资源R的可用数为8，系统中有3个进程P1、P2和P3竞争R，且每个进程都需要i个R，该系统可能会发生死锁的最小i值为：<strong>4</strong><br>本题对于R资源可用数为8，分配到3个进程中，为了让最后的i值最小，所以每个进程尽量平均分配，可以得到3、3、2的分配情况，此时如果假设i的取值为3，则必定不会发生死锁，当i&gt;3时系统会产生死锁，此时取整，即最小i值为4</p>
<p>@@ 常用的进程控制块的组织方式有<strong>链接方式</strong>和<strong>索引方式</strong>：<br>采用<span style ="color:red"><strong><u>链接方式</u></strong></span>是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样可以形成<strong>就绪队列</strong>、若干个<strong>阻塞队列</strong>和<strong>空白队列</strong>等。其中的就绪队列常按进程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O操作完成的队列和等待分配内存的队列等。<br>采用<span style ="color:red"><strong><u>索引方式</u></strong></span>是系统根据所有进程的状态<u><strong>建立若干索引表</strong></u>。例如，<strong>就绪索引表、阻塞索引表</strong>，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。<br><img src="https://raw.githubusercontent.com/P-luminary/images/dddb1b1a79e0de02dd213d846e7b7c8045a9dc70/data/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97.jpg"  /></p>
<p>@@ 某系统中有3个并发进程竞争资源R，每个进程都需要5个R，那么至少有<u><strong>13</strong>个R</u>，才能保证系统不会发生死锁。[<u>每个进程所需资源数-1，再相加，就是发生死锁的临界资源数</u>]<br><code>3(5-1)+1&lt;=y</code> 所以y＝13个</p>
<pre><code class="java">某系统有n个进程，每个进程需要x个同类资源，系统不会产生死锁的最少资源是多少？
★ 设：最少资源数位y个，满足如下表达式即可：★
n(x-1)+1&lt;=y
每个进程需要x个资源，初始时給每个进程x-1个资源，最后再給一个格外的资源，每当一个进程运行完后马上释放其占有的资源，其它进程可以申请资源继续运行
</code></pre>
<p>@@ 某系统中仅有5个并发进程竞争某类资源，且都需要3个该类资源，那么至少有<strong>11</strong>个该类资源，才能保证系统不会发生死锁。5×(3-1)+1&#x3D;11</p>
<p>@@ 某计算机系统页面大小为4k，进程的页面变换表如下。若进程的逻辑地址为2D16H。该地址经过变换后，其物理地址应为<strong>4D16H</strong></p>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">物理块号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>4</strong></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">6</td>
</tr>
</tbody></table>
<p>根据题意，页面大小为4k，逻辑地址2D16H所在<strong>页号为2</strong>，页内地址为D16H，查看表后可知<strong>物理块号为4</strong>，该地址i过变换后，其物理地址应为物理块号4拼接上页内地址D16H，即十六进制4D16H</p>
<p>@@ <em>让我们来看一下这道13年上半年的软设选择题：</em><span style = "color:red"> <strong>图(a)中<u>B</u>；</strong></span><br><img src="https://raw.githubusercontent.com/P-luminary/images/be02605405d236b87be94947a28e00f477fd4bdf/data/%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%8A%82%E7%82%B9.jpg"></p>
<p><span style = "color:red"><strong>图(b)中<u>C</u></strong></span><br>A. P1、P2、P3都是非阻塞节点，该图可以化简，是非死锁的<br>B. P1、P2、P3都是阻塞节点，该图不可以化简，是死锁的<br><span style = "color:red">C. P2是阻塞节点，P1、P3是非阻塞节点，该图可以化简，是非死锁的</span><br>D. P1、P2是非阻塞节点，P3是阻塞节点，该图不可以化简，是死锁的</p>
<pre><code class="java">★ 如何看进程资源图呢？
P:进程    R:一类资源     R中的圆圈数：该类资源有几个
★ 字母箭头都是啥意思？
R→P(R指向P)：分配一份R类资源給进程P
P→R(P指向R)：进程P申请一份R类资源
★ 判断一个进程节点是否堵塞？
读图时，先看资源分配R→P，再看资源申请P→R
【注意】
读图时，不要将同时存在R→P、P→R双向箭头的情况理解成：
P先申请一个资源，R再分配一个资源给P！

可能存在的情况：
① R中所有资源分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为阻塞节点
② R中所有资源没有全部都分配出去了(R→P)，而此时还有进程P向R申请资源(P→R)
此时申请资源R的进程P：成为非阻塞节点

★ 判断一个进程资源图是否是死锁的？
如果所有节点都是阻塞的———此进程图不可以化简，是死锁的
如果有节点不是阻塞的————此进程图可以花间，是非死锁的
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
★[将非阻塞节点周围的箭头删除，只保留阻塞节点的箭头，此时观察在图中原来的阻塞节点是否阻塞]★
</code></pre>
<h6 id="图a"><a href="#图a" class="headerlink" title="图a"></a>图a</h6><pre><code class="java">R1一共有2个资源，给P1、P2各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

同理，R2一共有3个资源，给P1分配1个、P2分配2个，已经无可分配资源
此时P1还向R2申请1个资源，因为没有资源可以申请了，所以P1也会阻塞；

因为P1、P2节点都阻塞了，所以此图无法化简，是死锁的
</code></pre>
<h6 id="图b"><a href="#图b" class="headerlink" title="图b"></a>图b</h6><pre><code class="java">R1一共有2个资源，给P1、P3各分配一个，已经无可分配资源
此时P2还向R1申请1个资源，因为没有资源可以申请了，所以P2会阻塞；

R2一共有3个资源，给P2、P3各分配一个，还剩1个可分配资源
此时P1向R2申请1个资源，因为还有可分配资源，所以P1不会阻塞；
（此时P3也向R2申请1个资源，同理P3也不会阻塞）
【这里要特别注意：P1、P3虽然同时都在申请剩下的1个资源，但是并不意味着这个资源申请已经被响应了，从而造成死锁的现象】
--------------------------------------------------------------------------
R1出去两个资源，R1资源数为0，此时P2申请R1资源，P2阻塞。R2总资源数3，出去2个资源。P1,P3申请R2资源，P1,P3非阻塞。[R2资源有3个，已分配2个，P3申请1个R2资源可以得到满足，故进程P3可以进行完毕释放其占有的资源。这样可以使得P1、P3都变成非阻塞节点，得到所需资源进行完毕，因此，该进程资源图是可以化简的]
</code></pre>
<p>@@ 在支持多线程的操作系统中，假设进程P创建了若干个线程，那么<strong>该进程中某线程的栈指针</strong>是不能被这些线程共享的。<u>在同一进程中的各个线程都可以共享进程所拥有的资源</u>，如访问进程地址空间中的每一个虚地址；访问进程所拥有的已打开文件、定时器、信号量机构等，但是<u>不能共享进程中某线程的栈指针</u> </p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥。若n个进程<strong>共享两台打印机</strong>，那么信号量S的取值范围为 <strong>-(n-2) ~ 2</strong>。信号量初值等于资源数量，即为2，由于同时最多有2个进程访问打印机，其余进程必须处理等待状态，故S的最小值为 <strong>-(n-2)</strong> </p>
<pre><code class="java">·每个进程开始的时候执行P操作(信号量减一操作)，结束的时候执行V操作(信号量加一操作)。P作挂起阻塞，V为激活唤醒。信号量的原则是从左到右，从上到下。
·假设系统采用PV操作实现进程同步与互斥，若n个进程共享两台打印机，那么信号量S的取值范围为-(n-2)~2。两台打印机，所以最多等待状态的进程数就是(n-2)，
★★如果没有进程申请打印机，打印机的信号量就是2★★
信号量的值小于0，表示没有可用的资源，其绝对值表示阻塞队列中等待该资源的进程数。

·同步信号量，值为可用资源的个数。信号量的值小于0，则线程进行等待；信号量的值大于0，表示值为可用资源的个数。初始值为0。
·互斥信号量，只有两个值：0和1。0表示资源被占用，线程等待；1表示资源没有被占用，线程可以进入。初始值为1。
</code></pre>
<p>@@ 假设系统中有n个进程<strong>共享3台扫描仪</strong>，并采用PV操作实现进程同步与互斥。若系统信号量S的当前值为-1，**<u>进程P1、P2又分别执行了一次P(S)操作</u><strong>，那么信号量S的值应为___。<br>[<strong>当有进程运行时</strong>,其他进程访问信号量,信号量就会减1。S&#x3D;-1-2]<br>[当进程执行P(S)操作时，它试图将信号量S的值减去1。因此，如果</strong><u>进程P1和P2都执行了一次P(S)操作</u>**，并且信号量S的初始值为-1，那么它们会尝试将S的值减去1两次，结果是S的值变为-3。这是因为当信号量S的值为-1时，两个进程都尝试将其减去1，每次减去1后，S的值分别变为-2和-3。所以最终S的值为-3]</p>
<p>@@ 假设系统采用PV操作实现进程同步与互斥，若有n个进程共享一台扫描仪，那么当信号量S的值为-3时，表示系统中有<strong>3</strong>个进程等待使用扫描仪<br>[信号量不用减1是因为<strong>本题并没有进程运行</strong>]</p>
<p>@@ 假设某分时系统采用简单时间片轮转法，当系统中的用户数为n、时间片为q时，系统对每个用户的相应时间T&#x3D;(n*q) [<u>在分时系统中是将把CPU的时间分成很短的时间片轮流地分配給各个终端用户</u>]</p>
<p>@@ 如果系统采用信箱通信方式，当进程调用Send原语被设置为”等信箱”状态时，其原因是<strong>指定的信箱中存满了信件</strong>；因为Send原语是发送原语，如果系统采用信箱通信方式，那么当进程调用Send原语被设置成”<strong>等信箱</strong>“状态时，意味着指定的信箱存满了信件，无可用空间</p>
<p>@@ <span style = "color:red"><strong>绝对路径</strong>从根目录\开始</span>，本题book2.doc的绝对路径为 <code>\MyDrivers\user2\</code><br><span style = "color:blue"><strong>相对路径</strong>从当前目录下一级开始</span>，本题book2.doc的相对路径为 <code>user2\</code></p>
<p>@@ 直接索引即索引直接指向物理块，可用表示逻辑块号范围：0-4号<br>一级索引即索引节点指向的物理块用来存放地址项，可用表示256个地址项，即256个物理块<br>二级索引即索引节点指向的物理块，存放的是一级索引的地址块地址。一共有256个地址块用来存放以及索引</p>
<p>@@ 某文件系统采用多级索引结构。若磁盘块的大小为1k字节，每个块号占3字节，那么采用二级索引时的文件最大长度为<strong>116281</strong>k字节 。<br>磁盘块的大小为1KB，每个块号需占3B，因此一个磁盘物理块可存放1024&#x2F;3&#x3D;341个块号(取整)<br>采用一级索引时的文件最大长度为：341×1024&#x2F;1024&#x3D;341KB<br>采用二级索引时的文件最大长度为：341×341×1024&#x2F;1024&#x3D;116281KB</p>
<p>@@ 若系统正在将<strong>系统目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。<br>影响文件系统可靠性因素之一是文件系统的一致性问题。<u>很多文件系统是先<strong>读取磁盘块到主存</strong>，在主存进行修改，修改完毕再写回磁盘。</u> <strong>一致性检查</strong>包括 <u>块的一致性检查</u> 和 <u>文件的一致性检查</u></p>
<p>@@ 双击”xxx.jpg”文件名时，系统会自动通过建立的<strong>文件关联</strong>来决定使用什么程序打开该图像文件</p>
<h6 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h6><p>@@ 若系统正在将<strong>目录</strong>文件修改的结果写回磁盘时系统发生崩溃，则对系统的影响相对较大。很多文件系统是先读取磁盘块到主存，在主存进行修改，修改完毕再写回磁盘。</p>
<p>@@ 若某计算机系统的I&#x2F;O接口与主存采用统一编址，则输入输出操作是通过<strong>访存</strong>指令来完成的。<br>常用的I&#x2F;O接口编制方法有两种：<br>一是<strong>内存单元统一编址</strong>[将I&#x2F;O接口中有关的寄存器或存储部件看作存储器单元，与主存中的存储单元统一编址。内存地址和接口地址统一在一个公共的地址空间里，<u>对I&#x2F;O接口的访问就如同对主存单元的访问一样，可以用访问内存单元的指令访问I&#x2F;O接口</u>]<br>二是<strong>单独编址</strong>[通过设置单独的I&#x2F;O地址空间，为接口中的有关寄存器或存储部件分配地址码，需要设置专门的I&#x2F;O指令进行访问。这种编址方式的优点是不占用主存的地址空间，访问主存的指令和访问接口的指令不同。]</p>
<p>@@ I&#x2F;O设备管理软件一般分为4个层次。具体层次从上往下分别是**<u>用户级I&#x2F;O层、设备无关I&#x2F;O层、设备驱动程序、中断处理程序、硬件</u>** [用户五官射中硬件]</p>
<table>
<thead>
<tr>
<th>用户级I&#x2F;O层：发出I&#x2F;O调用</th>
</tr>
</thead>
<tbody><tr>
<td>设备无关I&#x2F;O层：设备名解析、阻塞进程、分配缓冲区</td>
</tr>
<tr>
<td>设备驱动程序：设置寄存器、检查设备状态</td>
</tr>
<tr>
<td>中断处理程序：I&#x2F;O完成后唤醒设备驱动程序</td>
</tr>
<tr>
<td>硬件：完成具体的I&#x2F;O操作</td>
</tr>
</tbody></table>
<p>@@ DMA工作方式下，在<strong>主存与外设</strong>之间建立了直接的数据链路</p>
<p>@@ 计算机运行过程中，cpu需要与外设进行数据交换。采用**<u>中断方式和DMA方式</u><strong>控制技术时，CPU与外设可并行工作。</strong>程序查询<strong>和</strong>中断方式<strong>都需要CPU来执行程序指令进行数据的输入和输出，DMA方式则不同，这是<u>一种不经过CPU而</strong>直接从内存存取数据**的数据交换模式</u>。[DMA模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传达，数据传达完毕再把信息反馈给CPU即可]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/0ab1d3a552633777cd974d25748160cc91ad68a5/data/%E7%A3%81%E7%9B%98CT%E9%A2%98.jpg"></p>
<p>@@ 某磁盘有100个磁道，磁头从一个磁道移至另一个磁道需要6ms。文件在磁盘上非连续存放，逻辑上相邻数据块的平均距离为10个磁道，每块的旋转延迟时间及传输时间分别为100ms和20ms，则读取一个100块的文件需要<strong>18000</strong>ms。[访问一个数据块的时间应为寻道时间加旋转延迟时间及传输时间之和。根据题意，每块的旋转延迟时间及传输时间共需120ms，磁头从一个磁道移至另一个磁道需要6ms，但逻辑上相邻数据块的平均距离为10个磁道，即读完一个数据块到下一个数据块寻道时间需要60ms。通过上述分析，本题访问一个数据块的时间T&#x3D;120ms+60ms&#x3D;180ms，而读取一个100块的文件共需要18000ms。]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/a5957207201dabc57750a4659ee50c53b8017761/data/%E7%A3%81%E7%9B%98%E8%87%82%E8%86%80%E5%93%8D%E5%BA%94%E5%BA%8F%E5%88%97%E9%A2%98.png"></p>
<p>@@ 假设某磁盘的每个磁道划分成9个物理块，每块存放1个逻辑记录。逻辑记录R0,RI,…,R8存放在同一个磁道上，记录的安排顺序如下表所示：如果磁盘的旋转速度为27ms／周，磁头当前处在RO的开始处。若系统顺序处理这些记录，使用单缓冲区，每个记录处理时间为3ms，则处理这9个记录的最长时间为<strong>246ms</strong>：若对信息存储进行优化分布后，处理9个记录的最少时间为<strong>54ms</strong> 。</p>
<table>
<thead>
<tr>
<th align="center">物理块</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑记录</td>
<td align="center">R0</td>
<td align="center">R1</td>
<td align="center">R2</td>
<td align="center">R3</td>
<td align="center">R4</td>
<td align="center">R5</td>
<td align="center">R6</td>
<td align="center">R7</td>
<td align="center">R8</td>
</tr>
</tbody></table>
<p>[因为系统使用的是单缓冲区，且顺序处理9个记录，每个记录处理时间为3ms，加上读写时间，总的时间就超过3ms了。而磁盘旋转一圈的时间为27ms，也就是说，当系统读取第0个记录后，正在处理的过程中，磁盘已经旋过了第1个记录。那么，要读取第1个记录，就需要磁盘再次旋转到第1个记录（即磁盘旋转1圈后，27+3&#x3D;30ms)。同理，要读取第2个记录时，也需要等30ms。这样，要读取后面8个记录，需要8x30&#x3D;240ms，同时加上处理第0个记录的时间（3ms）和处理第8个记录的时间（3ms)，共需246ms。] [对于第二种情况，若对信息进行分布优化的结果如下所示：从上表可以看出，当读出记录RI并处理结束后，磁头刚好转至R2记录的开始处，立即就可以读出并处理，因此处理9个记录的总时间为：<u>9X (3ms （读记录）+3ms （处理记录）)&#x3D;9X6ms&#x3D;54ms</u>]</p>
<p>@@ 在移臂调度算法中，<strong>先来先服务和最短寻找时间优先</strong>算法可能会随时改变移动臂的运动方向</p>
<p>@@ 概要设计文档的内容包括<strong>系统构架、模块划分、系统接口、数据设计</strong>四个方面</p>
<p>@@ 三层C&#x2F;S体系结构由逻辑上互相分离的**<u>表示层、业务层、数据层</u><strong>构成。其中</strong>表示层<strong>向客户提供数据，</strong>业务层<strong>实施业务相关数据规划，</strong>数据层**定义数据访问表中。</p>
<p>@@ 对软件过程的考虑：<u>在整体上按照<strong>瀑布模型</strong>的流程实施项目开发</u>，以方便对项目的管理；但在软件的实际创建中，则将软件系统按照功能分为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。</p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">详情信息</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>增量</strong>模型</td>
<td align="left">又称渐增模型，也称为有计划的产品改进模型，从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，直到系统完成。每个中间版本都需要执行必需的过程、活动和任务。增量模型是 [<u>瀑布模型+原型</u>] 进化模型的综合<br />[增量模型具有非常显著的优越性，但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成；<strong>不必等到整个系统开发完成就可以使用</strong>、<strong>可以使用较早的增量构件作为原型</strong>、<strong>优先级最高的服务先交付</strong>, 这样<u>最重要的服务接收最多的测试</u>。<span style = "color:red">其<strong>难点</strong>是<u>如何进行模块的划分</u></span>。]<br />融合了瀑布模型的基本成分和原型实现迭代的特征，该模型随着日程时间的进展而交错的线性序列。<br />增量式开发的<strong>主要优点包括</strong>：<br/>1．由于能够在较短的时间内向用户提交一些有用的工作产品，因此能够解决用户的一些急用功能。<br/>2．由于每次只提交用户部分功能，用户有较充分的时间学习和适应新的产品。<br/>3．对系统的可维护性是一个极大的提高，因为整个系统是由一个个构件集成在一起的，当需求变更时只变更部分部件，而不必影响整个系统。<br/><strong>主要缺点包括</strong>：<br/>1．由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。<br/>2．在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。<br/>3．增量包之间存在相交的情况且未很好处理</td>
</tr>
<tr>
<td align="left"><strong>瀑布</strong>模型</td>
<td align="left">将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。将软件生存周期各个活动规定为线性顺序链接的若干阶段的模型[<u>计划、分析、设计、编程、测试、维护</u>]。规定了由前至后，相互衔接的固定次序，如同瀑布流水，逐级下落。是一种理想的开发模式，但<span style = "color:red"><u><strong>缺乏</strong>灵活性，无法解决软件需求不明确或不准确的问题；不适用于开发初期对软件需求缺乏准确全面认识的情况</u></span>；<span style = "color:blue"><strong>优点</strong>：可强迫开发人员采用规范的方法；严格规定了各阶段必须提交的文档；要求每个阶段结束后，都要进行严格的审核。</span></td>
</tr>
<tr>
<td align="left"><strong>原型</strong>模式</td>
<td align="left">开发人员<u>快速地构造整个系统</u>或者<u>系统的一部分以理解或澄清问题</u>。增量模型是把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块组成，并且能够完成特定的功能；并非所有的需求在系统开发之前都能准确地说明和定义。<span style = "color:blue">采用了动态定义需求的方法。适用于需求不明确的开发环境</span>；可以有效地捕获系统需求</td>
</tr>
<tr>
<td align="left"><strong>喷泉</strong>模型</td>
<td align="left">喷泉模型是典型的面向对象生命周期模型，在开发过程中<strong>以用户需求为动力</strong>，以对象为驱动，适合于面向对象的开发方法；<span style = "color:blue">喷泉模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性；模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统</span>；”喷泉”一词本身体现了迭代和无间隙特性。<strong>迭代意味着模型中的开发活动常常需要重复多次</strong>，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。</td>
</tr>
<tr>
<td align="left"><strong>螺旋</strong>模型</td>
<td align="left">将开发活动和风险管理结合起来，以减小风险。将<u>瀑布模型</u>与<u>快速原型模型</u>结合起来，还增加了风险分析；螺旋模型包含了四个方面的活动：制订计划、风险分析、实施工程、客户评估，<span style = "color:blue">螺旋模型适用于<strong>复杂的大型软件</strong></span>；</td>
</tr>
</tbody></table>
<p>@@ 若用户<u>需求<strong>不清晰</strong></u>且经常发生变化，但<u>系统规模不太大且不太复杂</u>，则最适宜采用<strong>原型化</strong>开发方法<br>对于<u>数据处理领域不太复杂的软件，若系统规模不太大且不太复杂，需求变化也不大</u>，则最适宜采用<strong>结构化</strong>开发方法</p>
<p>@@ 软件工程的基本要素包括<strong>方法、工具、过程</strong></p>
<p>@@ 在<strong>概要</strong>设计阶段选择适当的解决方案，将系统分解为若干个子系统，建立整个系统的体系结构。<br>软件设计的任务是基于需求分析的结果建立各种设计模型，给出问题的解决方案。<br><strong>从工程管理的角度，可以将软件设计分为两个阶段：</strong><u>概要设计阶段</u>和<u>详细设计阶段</u>。<br><strong>概要设计阶段</strong>进行软件体系结构的设计、数据设计和接口设计；<br><strong>详细设计阶段</strong>进行数据结构和算法的设计。面向对象设计方法中，概要设计阶段进行体系结构设计、初步的类设计&#x2F;数据设计、结构设计：详细设计阶段进行构件设计。结构化设计和面向对象设计是两种不同的设计方法，结构化设计根据系统的数据流图进行设计，模块体现为函数、过程及子程序：面向对象设计基于面向对象的基本概念进行，模块体现为类、对象和构件等。</p>
<p>@@ “软件产品必须能够在3秒内对用户请求作出响应”属于软件需求中的<strong>非功能需求</strong>。<br>软件需求是软件系统必须完成的事以及必须具备的品质。软件需求包括<strong>功能需求、非功能需求和设计约束</strong>三个方面的内容。功能需求是所开发的软件必须具备什么样的功能：非功能需求是指产品必须具备的属性或品质，如可靠性、性能、响应时间和扩展性等等；设计约束通常对解决方案的一些约束说明。”软件产品必须能够在3秒内对用户请求作出响应”主要表述软件的响应时间，属于非功能需求</p>
<p>@@ 软件复杂性度量是软件度量的一个重要分支。参数有很多主要包括：<br>①<strong>规模</strong>。即指令数或者源程序行数；②<strong>难度</strong>。通常由程序中出现的操作数所决定的量来表示；<br>③<strong>结构</strong>。通常用与程序结构有关的度量来表示；④<strong>智能度</strong>。即算法的难易程度</p>
<p>@@ 基于构件的软件开发，主要强调在构建软件系统时复用已有的软件”构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行<strong>合格性检验、适应性修改</strong>，然后集成到新系统中</p>
<p>@@ 程序的三种基本控制结构式<strong>顺序、选择和重复</strong></p>
<p>@@ 软件工程每一个阶段结束前，应该着重对可维护性进行复审。在系统设计阶段的复审期间，应该从<strong>容易修改、模块化和功能独立的目的</strong>出发，评价软件的结构和过程。可维护性式所有软件都具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。</p>
<p>@@ I&#x2F;O软件隐藏了I&#x2F;O操作实现的细节。I&#x2F;O软件向用户提供的式逻辑接口。I&#x2F;O软件将硬件与较高层次的软件隔离开来，而最高层软件向硬件提供一个友好的、清晰的、统一的接口，方便用户使用。</p>
<p>@@ 在面向对象技术构建软件系统时，很多敏捷方法都建议的一种重要的设计活动是<strong>重构</strong>，它是一种重新组织的技术，可以简化构件的设计而无需改变其功能或行为</p>
<p>@@ 软件风险一般包含<strong>不确定性</strong>和<strong>损失</strong>。<strong>救火</strong>和<strong>危机管理</strong>是对不适合但经常采用的软件风险管理策略，<strong>已知风险</strong>和<strong>未知风险</strong>是对软件风险进行分类的一种方式。<strong>员工</strong>和<strong>预算</strong>是在识别项目风险时需要识别的因素</p>
<p>@@ 在传值方式下是将<strong>实参</strong>的值传递给形参，因此实参可以是表达式、常量、变量、数组元素，这种信息传递是单方向的，形参不能再将值传回给实参。在传地址方式下，需要将实参的地址传递给形参，因此实参必须是变量、数组名或数组元素。不能是表达式或常量。在这种方式下，被调用函数中对形式参数的修改实际上就是对实际参数的修改，客观上可以实现数据的双向传递。</p>
<p>@@ 编译是将高级语言源程序翻译成机器语言程序，反编译是编译的逆过程。反编译通常不能把可执行文件还原成高级语言源代码，只能转换成功能上等价的汇编程序。</p>
<p>@@ <strong>动态语言</strong>是指程序在运行时可以改变其结构，例如新的函数可以被引进、已有的函数可以被删除等在结构上的变化等。动态语言的类型检查是在<strong>运行时进行的</strong>，其有点是方便阅读，不需要非常多的与类型相关的代码；缺点是不方便调试。<strong>脚本语言</strong>代表一套与系统程序设计语言不同的协定。更适合在联系复杂的应用程序中进行胶着(粘合)，一般都是面向字符的。脚本语言都是动态语言，而动态语言都是解释型语言</p>
<p>@@ WinXP支持<strong>FAT、FAT32、NTFS</strong>的文件系统格式化卷，而Win11默认仅提供<strong>NTFS</strong>格式 (ReFS主要面向企业级存储)</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/软考" style=color:#1bccbc>
                软考
            </a>
        </span>
        
    </div>

    <a href="/2024/01/16/软考/软件设计师刷题考点/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/">
        <h2>
            SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/1/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring MVC入门</td>
<td>Spring MVC开发流程与环境配置</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>接收Web数据</td>
<td>Spring MVC参数接收与数据绑定</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>URL Mapping</td>
<td>讲解URL绑定过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>中文乱码问题</td>
<td>解决请求与相应中文乱码</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>拦截器</td>
<td>Spring MVC拦截器的使用</td>
<td>★★★</td>
</tr>
</tbody></table>
<h1 id="Restful开发风格-主流"><a href="#Restful开发风格-主流" class="headerlink" title="Restful开发风格 [主流]"></a>Restful开发风格 [主流]</h1><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Restful风格介绍</td>
<td>介绍Restful开发规范</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful开发实战</td>
<td>实例讲解Restful在Spring MVC中的实现</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>JSON序列化</td>
<td>通过相应输出数据</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Restful的跨域问题</td>
<td>分析跨域问题的来源与解决办法</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-MVC-Model-View-Controller-中介"><a href="#Spring-MVC-Model-View-Controller-中介" class="headerlink" title="Spring MVC[Model+View+Controller(中介)]"></a>Spring MVC[<u>Model+View+Controller(中介)</u>]</h3><p>比servlet方便许多 简化web程序的开发</p>
<ul>
<li>Spring MVC是Spring体系的轻量级Web MVC框架</li>
<li>Spring MVC的核心<strong>Controller</strong>控制器，用于处理请求，产生相应</li>
<li>Spring MVC基于Spring IOC容器运行，所有对象被IoC管理</li>
</ul>
<h6 id="学习向导"><a href="#学习向导" class="headerlink" title="学习向导"></a>学习向导</h6><ul>
<li>Spring MVC入门</li>
<li>Spring MVC数据绑定</li>
<li>Restful 开发风格</li>
<li>Spring MVC拦截器</li>
</ul>
<h3 id="Spring-MVC环境配置"><a href="#Spring-MVC环境配置" class="headerlink" title="Spring MVC环境配置"></a>Spring MVC环境配置</h3><h5 id="IDEA环境下创建Maven-WebApp"><a href="#IDEA环境下创建Maven-WebApp" class="headerlink" title="IDEA环境下创建Maven WebApp"></a>IDEA环境下创建Maven WebApp</h5><p>Project Structure 点加号 添加Web 右侧Path是Web描述符所存储的路径<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp\WEB-INF\web.xml</code><br>Deployment descriptor version &#x3D;&gt; 3.1<br>下面的 Web Resource Directory【用于目录存储页面】<br><code>C:\Users\Pluminary\Desktop\SpringMVC\src\main\webapp</code><br>再次点下方的Create Artifact<br>右上角Type：<br><strong>Web Application: Exploded 目录方式运行</strong><br>Web Application: Archive 打包成war包运行<br>配置Tomcat Server &#x3D;&gt; Deployment 添加当前工程 SpringMVC:Web exploded<br>下面的Application context: 设置为 <strong>&#x2F;</strong>    只访问localhost即可<br>Server选项框里的 On ‘Update’ action: 把Restart server 改成 Update classes and resources【热部署】<br>当页面源代码发生变化时 不需要重启 </p>
<ul>
<li>Maven依赖Spring-WebMVC</li>
<li>web.xml配置DispatcherServlet</li>
<li>配置applicationContext的mvc标记</li>
<li>开发Controller控制器</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
&lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        DispatcherServlet是Spring MVC是最核心的对象
            DispatcherServlet用于拦截http请求
            并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
--&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
&lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
&lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
&lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
   及子包中拥有以下注解的对象：
       @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
       @Service     ...Service类上 业务逻辑类
       @Controller 描述SpringMVC的控制器类
       @Component  无法确定的类型种类
   --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
&lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
&lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
//  将当前的方法绑定某个get方式请求的url  //localhost/t
    @GetMapping(&quot;/t&quot;)
//  直接向响应输出字符串数据,不跳转页面
    @ResponseBody
    public String test()&#123;
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<p>添加依赖jar包进入项目工程 配置tomcat服务<code>Run/Debug Configurations</code> 中的 <code>Deployment</code> 点一下小铅笔修改 将右侧的Avaliable Elements中的依赖包全部put进入<br><code>404bug 配置都正常无误 寻找一下项目工程里的out/artifacts/WEB-INF/web.xml</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/4e2dcf96e18f478fddb9049b2544a008edd8f706/data/SpringMVC%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<h3 id="Spring-MVC数据绑定"><a href="#Spring-MVC数据绑定" class="headerlink" title="Spring MVC数据绑定"></a>Spring MVC数据绑定</h3><h5 id="URL-Mapping-URL映射"><a href="#URL-Mapping-URL映射" class="headerlink" title="URL Mapping(URL映射)"></a>URL Mapping(URL映射)</h5><ul>
<li>URL Mapping指将URL与Controller方法绑定</li>
<li>通过将URL与方法绑定，SpringMVC便可通过Tomcat对外暴露服务</li>
</ul>
<h5 id="URL-Mapping注解"><a href="#URL-Mapping注解" class="headerlink" title="URL Mapping注解"></a>URL Mapping注解</h5><ul>
<li>@RequestMapping - 通用绑定  &#x2F;&#x2F;<u>在全局用则是通用请求映射访问前缀 若在方法上则不区分get&#x2F;post请求</u></li>
<li>@GetMapping - 绑定Get请求</li>
<li>@PostMapping - 绑定Post请求</li>
</ul>
<p><code>@GetMapping(&quot;/g&quot;)   ======   @RequestMapping(value=&quot;/g&quot;,method=RequestMethod.GET)</code></p>
<pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;first-springmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式--&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/TestController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController &#123;
    @GetMapping(&quot;/t&quot;) //localhost/t
    @ResponseBody //直接向响应输出字符串数据,不跳转页面
    public String test()&#123;
        return &quot;Hello Spring MVC&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping (&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping()&#123;
        return &quot;This is get method&quot;;
    &#125;
//  直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping()&#123;
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Controller方法参数接收请求参数"><a href="#Controller方法参数接收请求参数" class="headerlink" title="Controller方法参数接收请求参数"></a>Controller方法参数接收请求参数</h3><h5 id="接收请求参数的常用做法"><a href="#接收请求参数的常用做法" class="headerlink" title="接收请求参数的常用做法"></a>接收请求参数的常用做法</h5><ul>
<li><h6 id="使用Controller方法参数接收"><a href="#使用Controller方法参数接收" class="headerlink" title="使用Controller方法参数接收"></a>使用Controller方法参数接收</h6></li>
</ul>
<pre><code class="java">&lt;form action=&quot;/m1&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;username&quot;/&gt;
    &lt;input name=&quot;password&quot;/&gt;
&lt;/form&gt;
----------------------------------------------------
@PostMapping(&quot;/m1&quot;)
@ResponseBody
public String post(String username, Long password)&#123;
    return username + &quot;:&quot; + password;
&#125;
</code></pre>
<p>特殊的注解<code>@RequestParam(&quot;&quot;)</code> 接收特殊自定义的参数</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, String password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;
&#125;

=========================
网页中输入 http://localhost/um/g?manager_name=lily
控制台返回 managerName:lily
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><h6 id="使用Java-Bean接收数据"><a href="#使用Java-Bean接收数据" class="headerlink" title="使用Java Bean接收数据"></a>使用Java Bean接收数据</h6></li>
</ul>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>​         用<strong>实体对象</strong><code>User</code>进行接收多个对象的创建和注入以及类型转换 [一次性完成]</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@PostMapping(&quot;/p1&quot;)
    @ResponseBody //只要拥有User属性和参数 就可以一起赋值
    public String postMapping1(User user, String username)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
&#125; Setter + Getter
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30254749/article/details/123139736">踩坑记录：IDEA web项目out artifacts文件夹只包含WEB-INF_out artifacts无法生成test.html-CSDN博客</a></p>
<h3 id="综合训练：学员调查问卷"><a href="#综合训练：学员调查问卷" class="headerlink" title="综合训练：学员调查问卷"></a>综合训练：学员调查问卷</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul>
<li>利用数组或者List接收请求中的复合数据</li>
<li>利用@RequestParam为参数设置默认值</li>
<li>使用Map对象接收请求参数及注意事项</li>
</ul>
<h5 id="URI绝对路径与相对路径"><a href="#URI绝对路径与相对路径" class="headerlink" title="URI绝对路径与相对路径"></a>URI绝对路径与相对路径</h5><p><img src="https://raw.githubusercontent.com/P-luminary/images/7faa031203ba69b146426bd6c3fa7431902da258/data/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%841.jpg"></p>
<h5 id="相对地址的应用案例"><a href="#相对地址的应用案例" class="headerlink" title="相对地址的应用案例"></a>相对地址的应用案例</h5><ul>
<li><code>&lt;form action=&quot;./apply&quot; method=&quot;post&quot;</code></li>
<li>页面地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/form.html">http://localhost:8080/[上下文路径]/form.html</a></li>
<li>提交地址：<a target="_blank" rel="noopener" href="http://localhost:8080/[%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84]/apply">http://localhost:8080/[上下文路径]/apply</a></li>
</ul>
<pre><code class="html">src/main/webapp/form.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;学员调查问卷&lt;/title&gt;
    &lt;style&gt;
        .container &#123;
            position: absolute;
            border: 1px solid #cccccc;
            left: 50%;
            top: 50%;
            width: 400px;
            height: 300px;
            margin-left: -200px;
            margin-top: -150px;
            box-sizing: border-box;
            padding: 10px;
        &#125;
        h2&#123;
            margin: 10px 0px;
            text-align: center;
        &#125;
        h3&#123;
            margin: 10px  0px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;h2&gt;学员调查问卷&lt;/h2&gt;
        &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt;
        &lt;h3&gt;您的姓名&lt;/h3&gt;
        &lt;input name=&quot;name&quot; class=&quot;text&quot;  style=&quot;width: 150px&quot;&gt;
        &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt;
        &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt;
            &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt;
            &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt;
            &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt;
            &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt;
        &lt;/select&gt;
        &lt;div&gt;
&lt;!--复选框用数组 或 ArrayList接收--&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
        &lt;/form&gt;

    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果要接收复合数据 直接用数组接收是最简单的 但使用起来并不轻松<br>可以使用List来接收 但是前方记得要有<code>@RequestParam</code><br>更加高级的可以封装成一个对象 用List接收复合数据<br>Map只能接收单个数据 接收复合数据的时候会造成数据丢失</p>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  ★★★第一次尝试★★★
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  ★★★第二次尝试★★★
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)  
    //★★★★★ 推荐使用 ★★★★★
    // 实体类+List 极大简化表单工作量  
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;
    //不推荐直接使用Map导入数据 因为复合数据[数组数据]会丢失
&#125;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
&#125;Setter + Getter
</code></pre>
<h3 id="关联对象赋值"><a href="#关联对象赋值" class="headerlink" title="关联对象赋值"></a>关联对象赋值</h3><h5 id="复杂内容表单"><a href="#复杂内容表单" class="headerlink" title="复杂内容表单"></a>复杂内容表单</h5><pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;name&quot;&gt;
身份证号：&lt;input name=&quot;idno&quot;&gt;
过期时间：&lt;input name=&quot;expire&quot;&gt;
</code></pre>
<h6 id="面向对象设计-【关联对象赋值】"><a href="#面向对象设计-【关联对象赋值】" class="headerlink" title="面向对象设计 【关联对象赋值】"></a>面向对象设计 【关联对象赋值】</h6><pre><code class="java">public class User&#123;
    private String username;
    private String password;
    private IDcard idcard = new IDCard();
    //Getter + Setter
&#125;
★★ 关联上IDcard ★★
public class IDcard&#123;
    private String name;
    private String idno;
    private Date expire;
    //Getter + Setter
&#125;
</code></pre>
<pre><code class="html">用户名: &lt;input name=&quot;username&quot;&gt;
密码：&lt;input name=&quot;password&quot;&gt;
--------------------------------
姓名：&lt;input name=&quot;idcard.name&quot;&gt;
身份证号：&lt;input name=&quot;idcard.idno&quot;&gt;
过期时间：&lt;input name=&quot;idcard.expire&quot;&gt;
</code></pre>
<pre><code class="html">src/main/webapp/form.html
 &lt;div&gt;
            &lt;h3&gt;您的学习目的：&lt;/h3&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好
            &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他
        &lt;/div&gt;
            &lt;h3&gt;收货人&lt;/h3&gt;
&lt;!--  private Delivery delivery = new Delivery() --&gt;
            &lt;input name=&quot;delivery.name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;联系电话&lt;/h3&gt;
            &lt;input name=&quot;delivery.mobile&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;
            &lt;h3&gt;收货地址&lt;/h3&gt;
            &lt;input name=&quot;delivery.address&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt;

        &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt;
        &lt;/div&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Form.java
public class Form &#123;
    private String name;
    private String course;
    private List&lt;Integer&gt; purpose;
    private Delivery delivery = new Delivery();
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/entity/Delivery.java
public class Delivery &#123;
    private String name;
    private String address;
    private String mobile;
&#125; Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FormController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.Form;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import java.util.List;
import java.util.Map;

@Controller
public class FormController &#123;
//    @PostMapping(&quot;/apply&quot;)  第一次尝试
    @ResponseBody
//    如果在请求中不包含默认值 =&gt; 取别名  默认值机制：ANON匿名
    public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;)  第二次尝试
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose)&#123;
        System.out.println(name);
        System.out.println(course);
        for (Integer p:purpose)&#123;
            System.out.println(p);
        &#125;
        return &quot;SUCCESS&quot;;
    &#125;

//    @PostMapping(&quot;/apply&quot;) 第三次尝试[这个可以 但有更好]
    // 实体类+List 极大简化表单工作量
    // 请求中的复合数据要被转换为List进行存储
    @ResponseBody
    public String apply(Form form)&#123;
        return &quot;SUCCESS&quot;;
    &#125;

    @PostMapping(&quot;/apply&quot;)
    @ResponseBody
    public String applyDelivery(Form form)&#123;
        System.out.println(form.getDelivery().getName());
        return &quot;SUCCESS&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="日期类型转换"><a href="#日期类型转换" class="headerlink" title="日期类型转换"></a>日期类型转换</h3><p>①注解方法</p>
<pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
@PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<hr>
<p>②实体对象接收数据</p>
<pre><code class="java">com/imooc/springmvc/entity/User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
// SpringMVC会自动按照这个类型进行转换
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125; Getter + Setter
</code></pre>
<hr>
<p>③自定义转换器：全局的默认时间转换器</p>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service     ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><h5 id="Web应用的中文乱码由来"><a href="#Web应用的中文乱码由来" class="headerlink" title="Web应用的中文乱码由来"></a>Web应用的中文乱码由来</h5><ul>
<li>Tomcat默认使用字符集ISO-8859-1，属于西欧字符集</li>
<li>解决乱码的核心思路是将ISO-8859-1转换为UTF-8</li>
<li>Controller中请求与响应都需要设置UTF-8字符集</li>
</ul>
<h5 id="中文乱码的配置"><a href="#中文乱码的配置" class="headerlink" title="中文乱码的配置"></a>中文乱码的配置</h5><ul>
<li>Get请求乱码 - server.xml增加URIEncoding属性</li>
</ul>
<p>去Tomcat-conf文件中寻找server.xml进行增加</p>
<pre><code class="java"> &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot;
               URIEncoding=&quot;UTF-8&quot;
               maxParameterCount=&quot;1000&quot;
               /&gt;

===============================================
http://localhost/um/g?manager_name=丽丽
控制台：managerName:丽丽
</code></pre>
<ul>
<li>Post请求乱码 - web.xml配置CharacterEncodingFilter</li>
</ul>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：??????:123456
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/web.xml
&lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">http://localhost/
输入:
张三  123456 2001-03-02
随后点击提交
控制台：张三:123456
</code></pre>
<ul>
<li>Response相应乱码 - Spring配置StringHttpMessageConverter</li>
</ul>
<h3 id="解决响应中的中文乱码"><a href="#解决响应中的中文乱码" class="headerlink" title="解决响应中的中文乱码"></a>解决响应中的中文乱码</h3><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.util.Date;

@Controller
@RequestMapping(&quot;/um&quot;) //类上直接使用默认访问前缀 全局通用请求映射
public class URLMappingController &#123;
    @GetMapping(&quot;/g&quot;)
    @ResponseBody
    public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName) &#123;
        System.out.println(&quot;managerName:&quot;+managerName);
        return &quot;This is get method&quot;;
    &#125;

    //    直接访问会出错 post请求如何访问 用进行html表单提交
    @PostMapping(&quot;/p&quot;)
    @ResponseBody
    public String postMapping(String username, Long password) &#123;
        System.out.println(username + &quot;:&quot; + password);
        return &quot;This is post method&quot;;
    &#125;

//    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;This is post method&quot;;
    &#125;

    @PostMapping(&quot;/p1&quot;)
    @ResponseBody
    public String postMapping1(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime)&#123;
        System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword());
        return &quot;这是Post响应&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">User.java
//标准的java bean
public class User &#123;
    private String username;
    private Long password;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
    private Date createTime;
&#125;Getter + Setter
</code></pre>
<pre><code class="java">com/imooc/springmvc/converter/MyDateConverter.java
package com.imooc.springmvc.converter;

import org.springframework.core.convert.converter.Converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class MyDateConverter implements Converter&lt;String, Date&gt; &#123;
    public Date convert(String s) &#123; //转换工作
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        try &#123;
            Date d = sdf.parse(s);
            return d;
        &#125; catch (ParseException e) &#123;
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt;
        &lt;input name=&quot;username&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;password&quot;&gt;&lt;br/&gt;
        &lt;input name=&quot;createTime&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;!-- context:component-scan标签作用 在Spring IoC初始化过程中, 自动创建并管理com.imooc.springmvc
       及子包中拥有以下注解的对象：
           @Repository 通常存放在Dao类上 通常都是与数据发生直接交互的类
           @Service    ...Service类上 业务逻辑类
           @Controller 描述SpringMVC的控制器类
           @Component  无法确定的类型种类
       --&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt;
    &lt;!--    启用Spring MVC的注解开发模式 让底下的转换类生效--&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;
&lt;!--        设置消息转换器--&gt;

        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
&lt;!--                转换什么呢？--&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
&lt;!--  在servlet中是直接  response.setContentType(&quot;text/html;charset=utf-8&quot;)  --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;

    &lt;/mvc:annotation-driven&gt;
    &lt;!--    将图片/JS/CSS等静态资源排除在外, 可提高执行效率--&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!--    通知SpringMVC有哪些转换类--&gt;
    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;!--    这是转换类定义的地方--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;
    &lt;!--    DispatchServlet 对所有请求进行拦截  --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        DispatcherServlet是Spring MVC是最核心的对象
                    DispatcherServlet用于拦截http请求
                    并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理
        --&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--        在Web应用启动时自动创建Spring IoC容器,并初始化DispatcherServlet --&gt;
        &lt;!--        applicationContext.xml 初始化参数 启动时候加载--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;!--        &quot;/&quot; 所有请求都要拦截--&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念"><a href="#响应中产生结果-ModelAndView-x3D-gt-MVC高效解耦理念" class="headerlink" title="响应中产生结果 [ModelAndView &#x3D;&gt; MVC高效解耦理念]"></a>响应中产生结果 [<span style = "color:red">ModelAndView</span> &#x3D;&gt; MVC高效解耦理念]</h3><ul>
<li><p>@ResponseBody - 产生响应文本</p>
<ul>
<li>@ResponseBody直接产生响应体数据, 过程不涉及任何视图</li>
<li>@ResponseBody可产生标准字符串&#x2F;JSON&#x2F;XML等格式数据</li>
<li>@ResponseBody被StringHttpMessageConverter所影响</li>
</ul>
</li>
<li><p>ModelAndView - 利用模板引擎渲染输出</p>
<ul>
<li>ModelAndView对象是指”模型(数据)与视图(界面)”对象</li>
<li>通过ModelAndView可将包含数据对象与模板引擎进行绑定</li>
<li>SpringMVC中默认的View是JSP, 也可以配置其他模板引擎</li>
</ul>
</li>
</ul>
<blockquote>
<p>提问：为什么不直接访问view.jsp 而是绕了一个圈子还是同样的效果<br>回答：因为jsp页面是写死的如何将页面和数据绑定在一起呢？先通过访问&#x2F;um&#x2F;view这个controller让其方法中产生数据, 之后再将这个数据通过modelandview对象绑定到页面中才可以做到</p>
<p>从请求传来一个用户编号把数据查询出来得到一个user用户对象 然后再view.jsp中把刚刚查询的对象进行显示[动态的]</p>
</blockquote>
<h6 id="高效解耦"><a href="#高效解耦" class="headerlink" title="高效解耦"></a>高效解耦</h6><pre><code class="java">后端：com/imooc/springmvc/controller/URLMappingController.java
// http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
        ModelAndView mav = new ModelAndView(&quot;/view.jsp&quot;);
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
    //  在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<pre><code class="jsp">前端：src/main/webapp/view.jsp
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;I&#39;m view page&lt;/h1&gt;
&lt;hr&gt;
&lt;h2&gt;Username:$&#123;u.username&#125;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="ModelAndView-重定向"><a href="#ModelAndView-重定向" class="headerlink" title="ModelAndView [重定向]"></a><span style = "color:red">ModelAndView</span> [重定向]</h2><h6 id="SpringMVC若跳转页面需要使用此对象进行数据绑定"><a href="#SpringMVC若跳转页面需要使用此对象进行数据绑定" class="headerlink" title="[SpringMVC若跳转页面需要使用此对象进行数据绑定]"></a>[SpringMVC若跳转页面需要使用此对象进行数据绑定]</h6><ul>
<li>mav.addObject()方法设置的属性默认存放在当前请求中</li>
<li>默认ModelAndView使用请求转发(forward)至页面</li>
<li><strong>重定向</strong>使用 new ModelAndView(“<strong>redirect:</strong>&#x2F;index.jsp”) 新请求</li>
</ul>
<p>页面重定向使用时机：内部的controller处理逻辑和跳转页面之间没有直接关系时可以用”redirect:&#x2F;view.jsp”</p>
<pre><code class="java">ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
直接访问到了jsp  http://localhost/view.jsp

访问：http://localhost/um/view?userId=1
建立一个 没有斜杠的相对路径 src/main/webapp/um/view.jsp
com/imooc/springmvc/controller/URLMappingController.java
 // http://localhost/um/view?userId=1 数据动态查询产生
    @GetMapping(&quot;/view&quot;)
    public ModelAndView showView(Integer userId)&#123;
//        ModelAndView mav = new ModelAndView(&quot;redirect:/view.jsp&quot;);
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;view.jsp&quot;);
//        没有斜杠是代表相对路径 相对于@RequestMapping(&quot;/um&quot;)地址
//        mav.setViewName(&quot;view.jsp&quot;);

        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
//      在当前请求中增加一个对象 数据绑定view.jsp
        mav.addObject(&quot;u&quot;, user);
        return mav;
    &#125;
</code></pre>
<h5 id="String与ModelMap实现ModelAndView类似功能-工作中的小技巧"><a href="#String与ModelMap实现ModelAndView类似功能-工作中的小技巧" class="headerlink" title="String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]"></a>String与ModelMap实现ModelAndView类似功能  [工作中的小技巧]</h5><pre><code class="java">com/imooc/springmvc/controller/URLMappingController.java
//   String 与 ModelMap[为模型数据] 返回字符串
//    Controller方法返回String的情况
//    1.方法被@ResponseBody描述, 则SpringMVC直接响应Spring字符串本身
//    2.方法不存在@ResponseBody, 则SpringMVC处理String指代的视图(页面)
// 这里的String是直接代替了@ResponseBody - 产生响应文本
    public String showView1(Integer userId, ModelMap modelMap)&#123;
        String view = &quot;/um/view.jsp&quot;;
        User user = new User();
        if (userId == 1)&#123;
            user.setUsername(&quot;lily&quot;);
        &#125;else if (userId == 2)&#123;
            user.setUsername(&quot;smith&quot;);
        &#125;
        modelMap.addAttribute(&quot;u&quot;, user);
        return view;
    &#125;
</code></pre>
<h3 id="SpringMVC整合Freemarker-项目：first-springmvc"><a href="#SpringMVC整合Freemarker-项目：first-springmvc" class="headerlink" title="SpringMVC整合Freemarker [项目：first-springmvc]"></a>SpringMVC整合Freemarker [项目：first-springmvc]</h3><h5 id="①-pom-xml引入依赖"><a href="#①-pom-xml引入依赖" class="headerlink" title="① pom.xml引入依赖"></a>① pom.xml引入依赖</h5><pre><code class="xml">要随时导入包 tomcat → Edit configuration → Deployment → Artifacts 将右侧包put in
&lt;dependency&gt;
  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
  &lt;version&gt;2.3.28&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
  &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="②-启用Freemarker模板引擎"><a href="#②-启用Freemarker模板引擎" class="headerlink" title="② 启用Freemarker模板引擎"></a>② 启用Freemarker模板引擎</h5><pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;ViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
   &lt;!-- 设置响应输出，并解决中文乱码 --&gt; 
&lt;!-- 渲染完成后向客户端浏览器响应式 响应体中使用的字符集编码 --&gt;
   &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;&gt;&lt;/property&gt;
   &lt;!-- 指定Freemarker模板文件扩展名 --&gt;
   &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="③-本身配置Freemarker参数"><a href="#③-本身配置Freemarker参数" class="headerlink" title="③ 本身配置Freemarker参数"></a>③ 本身配置Freemarker参数</h5><pre><code class="xml">&lt;bean id=&quot;freemarkerConfig&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
&lt;!-- 设置模板保存的目录 tomcat无法直接解析freemarker模板引擎 所以新增/WEB-INF/ftl --&gt;
   &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl&quot;/&gt;
   &lt;!-- 其他模板引擎设置 --&gt;
   &lt;property name=&quot;freemarkerSettings&quot;&gt;
     &lt;props&gt;
         &lt;!-- 设置Freemarker脚本与数据渲染时使用的字符集 --&gt;
         &lt;!-- 模板与数据绑定渲染的过程中使用的字符集编码 --&gt;
         &lt;prop key=&quot;defaultEncoding&quot;&gt;UTF-8&lt;/prop&gt;
     &lt;/props&gt; 
   &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="xml">src/main/webapp/WEB-INF/ftl/test.ftl
&lt;h1&gt;$&#123;u.username&#125;&lt;/h1&gt;
</code></pre>
<pre><code class="java">com/imooc/springmvc/controller/FreemarkerController.java
package com.imooc.springmvc.controller;

import com.imooc.springmvc.entity.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
// http://localhost/fm/test  显示 andy
@Controller
@RequestMapping(&quot;/fm&quot;)
public class FreemarkerController &#123;
    @GetMapping(&quot;/test&quot;)
    public ModelAndView showTest()&#123;
//        因为之前配置所有配置扩展名是.ftl 所以下面不用写
        ModelAndView mav = new ModelAndView(&quot;/test&quot;);
        User user = new User();
        user.setUsername(&quot;andy&quot;);
        mav.addObject(&quot;u&quot;,user);
        return mav;
    &#125;
&#125;
=====================================================
// http://localhost/fm/test  显示 andy
</code></pre>
<h1 id="RESTful开发风格"><a href="#RESTful开发风格" class="headerlink" title="RESTful开发风格"></a>RESTful开发风格</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zzvar/article/details/118164133">RESTful 风格（详细介绍 + 案例实现）_c# restful风格接口-CSDN博客</a></p>
<h3 id="REST与RESTful"><a href="#REST与RESTful" class="headerlink" title="REST与RESTful"></a>REST与RESTful</h3><ul>
<li>REST- 表现层状态转换, 资源在网络中以某种表现形式进行状态转移</li>
<li>RESTful是基于REST理念的一套开发风格, 是具体的开发规则</li>
</ul>
<h3 id="RESTful开发规范"><a href="#RESTful开发规范" class="headerlink" title="RESTful开发规范"></a>RESTful开发规范</h3><p>URL中所有的都是名词 请求都有不同的含义  返回的数据是JSON或者XML格式 </p>
<ul>
<li>使用URL作为用户交互入口</li>
<li>明确的语义规范(GET, POST, PUT, DELETE)</li>
<li>只返回数据(JSON, XML)不包含任何展现</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/13679a67b4eec21f54b5f30a53b45aafaf3fbebc/data/RESTful%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC.jpg" style="zoom: 67%;" />

<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>@RestController</td>
<td>由 @Controller + @ResponseBody组成（返回 JSON 数据格式）</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到控制器处理方法的形参中</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>注解用于请求地址的解析，是最常用的一种注解</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>查询请求</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>添加请求</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>更新请求</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>删除请求</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）</td>
</tr>
</tbody></table>
<h3 id="RESTful命名要求"><a href="#RESTful命名要求" class="headerlink" title="RESTful命名要求"></a>RESTful命名要求</h3><table>
<thead>
<tr>
<th>URI</th>
<th>说明</th>
<th>修改建议</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;articles?au&#x3D;lily</td>
<td><span style = "color:green">正确用法</span></td>
<td></td>
</tr>
<tr>
<td>GET &#x2F;a&#x2F;1</td>
<td><span style = "color:red">URI必须具有语义</span></td>
<td>GET &#x2F;student&#x2F;1</td>
</tr>
<tr>
<td>POST &#x2F;createArticle&#x2F;1</td>
<td><span style = "color:red">URI必须使用名词</span></td>
<td>POST &#x2F;article&#x2F;1</td>
</tr>
<tr>
<td>GET &#x2F;articles&#x2F;author&#x2F;1</td>
<td><span style = "color:red">URI扁平化, 不超两级</span></td>
<td>GET &#x2F;articles&#x2F;author?id&#x3D;1</td>
</tr>
<tr>
<td>DELETE&#x2F;articles&#x2F;1</td>
<td><span style = "color:red">URI名词区分单复数</span></td>
<td>GET &#x2F;articles?au&#x3D;lily<br />DELETE &#x2F;article&#x2F;1</td>
</tr>
</tbody></table>
<img src="https://raw.githubusercontent.com/P-luminary/images/1cd2b6c624167b8007e3b67c15b03d631b2d1e92/data/%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%20URI%20%E5%92%8C%20RESTful%20%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94.jpg"  />

<h3 id="开发第一个RESTful应用"><a href="#开发第一个RESTful应用" class="headerlink" title="开发第一个RESTful应用"></a>开发第一个RESTful应用</h3><p><strong>404究极报错</strong><br>项目生成文件out&#x2F;artifacts&#x2F;XXX&#x2F;WEB-INF中没有导入lib包<br>没有将下面的web文件里的web.xml手动复制进去</p>
<pre><code class="xml">pom.xml 
写完pom.xml后记得在tomcat配置中的Deployment中加入依赖包
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web/WEB-INF/web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
&#125;

=======================================================
http://localhost/restful/request
&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;
</code></pre>
<h3 id="实现RESTful实验室"><a href="#实现RESTful实验室" class="headerlink" title="实现RESTful实验室"></a>实现RESTful实验室</h3><pre><code class="java">com/imooc/restful/controller/RestfulController.java
package com.imooc.restful.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequestMapping(&quot;/restful&quot;)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    @ResponseBody
    public String doGetRequest()&#123;
//  双引号中如果包括双引号 要用转义字符 \&quot;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;
    @PostMapping(&quot;/request&quot;)
    @ResponseBody
    public String doPostRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;&#125;&quot;;
    &#125;
    @PutMapping (&quot;/request&quot;)
    @ResponseBody
    public String doPutRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
    @DeleteMapping(&quot;/request&quot;)
    @ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
===========================
http://localhost/client.html
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt;
                        &lt;value&gt;text/html;charset=utf-8&lt;/value&gt;
                        &lt;!--只要响应产生就会使用utf-8字符集--&gt;
                        &lt;value&gt;application/json;charset=utf-8&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
    &lt;mvc:default-servlet-handler/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc&lt;/groupId&gt;
    &lt;artifactId&gt;restful&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="html">web/client.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        $(function () &#123;
            $(&quot;#btnGet&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;get&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;post&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;put&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
        $(function () &#123;
            $(&quot;#btnDelete&quot;).click(function () &#123;
                $.ajax(&#123;
                    url: &quot;/restful/request&quot;,
                    type: &quot;delete&quot;,
                    dataType: &quot;json&quot;,
                    success: function (json) &#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="RestController注解与路径变量"><a href="#RestController注解与路径变量" class="headerlink" title="RestController注解与路径变量"></a>RestController注解与路径变量</h3><p>在post请求中通过client.html利用Ajax动态注入了一个rid到RestfulController.java<br>代替了所有的@ResponseBody 默认向请求台进行输出</p>
<pre><code class="java">@Controller： 用于标识一个类是Spring MVC中的控制器，类似于标准的@Controller 注解。它告诉Spring框架该类是一个控制器，可以处理HTTP请求。

@ResponseBody： 用于将方法的返回值直接作为HTTP响应的主体（Body）内容。这意味着不会进行视图解析，而是直接将返回的对象（通常是JSON或XML）写入HTTP响应

因此，@RestController 的作用是将一个控制器类标记为RESTful风格的控制器，其中的每个方法都被视为返回数据，而不是视图。这样就不需要在每个方法上都添加 @ResponseBody 注解，因为该注解已经包含在 @RestController 中。
</code></pre>
<pre><code class="java">client.html
 $(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                   $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
    
package com.imooc.restful.controller;
import org.springframework.web.bind.annotation.*;
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId) &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest() &#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="简单请求与非简单请求"><a href="#简单请求与非简单请求" class="headerlink" title="简单请求与非简单请求"></a>简单请求与非简单请求</h3><ul>
<li>简单请求是指标准结构的HTTP请求, 对应GET&#x2F;POST请求</li>
<li>非简单请求是复杂要求的HTTP请求, 指PUT&#x2F;DELETE、扩展标准请求</li>
<li>两者最大区别是非简单请求发送前需要发送<strong>预检请求</strong> [看看能不能进行处理 可以才实际处理 预先处理不符合的数据挡在外面]</li>
</ul>
<pre><code class="xml">web.xml
&lt;!--    对put和delete请求进行支持--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<pre><code class="java">web/client.html
$(function()&#123;
            $(&quot;#btnPost&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request/100&quot;,
                    type : &quot;post&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id);
                    &#125;
                &#125;)
            &#125;);
        &#125;)

        $(function()&#123;
            $(&quot;#btnPut&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/request&quot;,
                    type : &quot;put&quot; ,
                    data : &quot;name=lily&amp;age=23&quot;,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        $(&quot;#message&quot;).text(json.message);
                    &#125;
                &#125;)
            &#125;);
        &#125;)
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
 // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;
====================
lily:23
</code></pre>
<p>创建一个Person用来插入数据 并打印在控制台</p>
<pre><code class="java">com/imooc/restful/entity/Person.java
public class Person &#123;
    private String name;
    private Integer age;
&#125;Getter + Setter
</code></pre>
<h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><pre><code class="xml">pom.xml
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
            &lt;version&gt;2.9.9&lt;/version&gt;
        &lt;/dependency&gt;
一定要使用2.9以后的版本 之前的版本有严重的安全风险
</code></pre>
<pre><code class="java">http://localhost/restful/person?id=1
@GetMapping(&quot;/person&quot;)
//不返回String 返回JSON序列化的对象
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;
============================================
&#123;
    &quot;name&quot;: &quot;lily&quot;,
    &quot;age&quot;: 23
&#125;



http://localhost/restful/persons
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);
        
        return list;
    &#125;
=============================================
[
    &#123;
        &quot;name&quot;: &quot;lily&quot;,
        &quot;age&quot;: 23
    &#125;,
    &#123;
        &quot;name&quot;: &quot;smith&quot;,
        &quot;age&quot;: 22
    &#125;
]
</code></pre>
<p>服务器返回json数组</p>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt;
    &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;hr/&gt;
    &lt;!-- 点击btnPersons按钮时发送Ajax请求[上面有操作代码] 将所有人员信息追加到div中--&gt;
    &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt;
    &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/controller/RestfulController.java
@GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        list.add(p2);

        return list;
    &#125;

===============================================
http://localhost/client.html
点击查询所有人员
=&gt; 
lily-23
smith-22
</code></pre>
<p>增加时间！</p>
<pre><code class="java">Person.java
public class Person &#123;
    private String name;
    private Integer age;
// 记得用日期的格式化输出
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private Date birthday;
&#125;Getter + Setter
</code></pre>
<pre><code class="html">client.html
$(function()&#123;
            $(&quot;#btnPersons&quot;).click(function () &#123;
                $.ajax(&#123;
                    url : &quot;/restful/persons&quot;,
                    type : &quot;get&quot; ,
                    dataType : &quot;json&quot; ,
                    success : function(json)&#123;
                        console.info(json);
                        for (var i=0; i&lt;json.length; i++)&#123;
                            var p = json[i];
                            $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;)
                        &#125;
                    &#125;
                &#125;)
            &#125;);
        &#125;)

===================================
lily-23-2024-01-17 09:09:28
smith-22-2024-01-17 09:09:28
</code></pre>
<h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><ul>
<li>同源策略阻止从一个域加载的脚本去获取另一个域上的资源</li>
<li>只要<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>有任何一个不同，都被当做是不同的域</li>
<li>浏览器Console看到<strong>Access-Control-Allow-Origin</strong>就代表了跨域了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/161c64c96177be1c274357912c48055b196806cd/data/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%A4%BA%E4%BE%8B.jpg"></p>
<h3 id="HTML中允许跨域的标签"><a href="#HTML中允许跨域的标签" class="headerlink" title="HTML中允许跨域的标签"></a>HTML中允许跨域的标签</h3><ul>
<li>&lt; img &gt; - 显示远程图片</li>
<li>&lt; script &gt; - 加载远程JS</li>
<li>&lt; link &gt; - 加载远程CSS</li>
</ul>
<h3 id="CORS跨域资源访问"><a href="#CORS跨域资源访问" class="headerlink" title="CORS跨域资源访问"></a>CORS跨域资源访问</h3><ul>
<li>CORS是一种机制, 使用额外的HTTP头通知浏览器可以访问其他域</li>
<li>URL响应头包含 <strong>Access-Control-</strong>* 指明请求允许跨域</li>
</ul>
<h3 id="Spring-MVC解决跨域访问"><a href="#Spring-MVC解决跨域访问" class="headerlink" title="Spring MVC解决跨域访问"></a>Spring MVC解决跨域访问</h3><ul>
<li><strong>@CrossOrigin - Controller</strong>跨域注解</li>
<li>&lt; mvc:cors &gt; - Spring MVC全局跨域配置</li>
</ul>
<pre><code class="java">RestfulController.java [代码第四行]
@RestController
@RequestMapping(&quot;/restful&quot;)
//@CrossOrigin(origins = &#123;&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;&#125;)
//@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) 所有端口都会访问发送请求
//maxAge = 3600 一小时时间后发送预检请求  之内的就发送实际请求 【非简单请求】
public class RestfulController &#123;
    @GetMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doGetRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;返回查询结果\&quot;&#125;&quot;;
    &#125;

    // POST /article/1
    // POST /restful/request/100
    @PostMapping(&quot;/request/&#123;rid&#125;&quot;)
    //@ResponseBody
    public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据新建成功\&quot;,\&quot;id\&quot;:&quot; + requestId + &quot;&#125;&quot;;
    &#125;

    @PutMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doPutRequest(Person person)&#123;
        System.out.println(person.getName() + &quot;:&quot; + person.getAge());
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据更新成功\&quot;&#125;&quot;;
    &#125;

    @DeleteMapping(&quot;/request&quot;)
    //@ResponseBody
    public String doDeleteRequest()&#123;
        return &quot;&#123;\&quot;message\&quot;:\&quot;数据删除成功\&quot;&#125;&quot;;
    &#125;

    @GetMapping(&quot;/person&quot;)
    public Person findByPersonId(Integer id)&#123;
        Person p = new Person();
        if (id==1)&#123;
            p.setName(&quot;lily&quot;);
            p.setAge(23);
        &#125; else if (id==2) &#123;
            p.setName(&quot;smith&quot;);
            p.setAge(22);
        &#125;
        return p;
    &#125;

    @GetMapping(&quot;/persons&quot;)
    public List&lt;Person&gt; findPersons()&#123;
        List list = new ArrayList();
        Person p1 = new Person();
        p1.setName(&quot;lily&quot;);
        p1.setAge(23);
        p1.setBirthday(new Date());
        list.add(p1);

        Person p2 = new Person();
        p2.setName(&quot;smith&quot;);
        p2.setAge(22);
        p2.setBirthday(new Date());
        list.add(p2);
        return list;
    &#125;
&#125;
</code></pre>
<h3 id="CORS全局配置"><a href="#CORS全局配置" class="headerlink" title="CORS全局配置"></a>CORS全局配置</h3><pre><code class="xml">&lt;mvc:cors&gt;
    &lt;mvc:mapping path=&quot;/restful/**&quot;
        allowed-origins=&quot;http://localhost:8080,http://www.imooc.com&quot;
        max-age=&quot;3600&quot;/&gt;
&lt;/mvc:cors&gt;
</code></pre>
<h3 id="SpringMVC拦截器-高级组件"><a href="#SpringMVC拦截器-高级组件" class="headerlink" title="SpringMVC拦截器 [高级组件]"></a>SpringMVC拦截器 [高级组件]</h3><h5 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器-Interceptor"></a>拦截器-Interceptor</h5><ul>
<li>拦截器(Interceptor)用于对URL请求进行前置&#x2F;后置过滤</li>
<li>Interceptor与Filter用途相似, 但实现方式不同</li>
<li>Interceptor底层基于Spring AOP面向切面编程实现[类似于<strong>环绕通知</strong>]</li>
</ul>
<h5 id="拦截器开发流程"><a href="#拦截器开发流程" class="headerlink" title="拦截器开发流程"></a>拦截器开发流程</h5><ul>
<li>Maven依赖servlet-api</li>
<li>实现HandlerInterceptor接口</li>
<li>applicationContext配置过滤地址</li>
</ul>
<h5 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a>HandlerInterceptor接口</h5><ul>
<li><strong>preHandle</strong> - 前置执行处理</li>
<li><strong>postHandle</strong> - 目标资源已被Spring MVC框架处理 没产生响应文本</li>
<li><strong>afterCompletion</strong> - 相应文本已经产生</li>
</ul>
<pre><code class="xml">pom.xml
     &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
&lt;!-- 只有在开发编译才会引用 打包最终使用的时候会排除在外 因为 servlet-api与tomcat-api冲突  --&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;响应内容已产生&quot;);
    &#125;
//  随后去applicationContext.xml配置
&#125;

=============================================================
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
/准备执行
/目标处理成功
/响应内容已产生
    
http://localhost/restful/persons
/restful/persons准备执行
/restful/persons目标处理成功
/restful/persons响应内容已产生
    
http://localhost/client.html
/client.html准备执行
/client.html目标处理成功
/client.html响应内容已产生
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--  哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个类中处理]--&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="拦截器使用细则"><a href="#拦截器使用细则" class="headerlink" title="拦截器使用细则"></a>拦截器使用细则</h3><pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
&lt;!--            哪些[所有]地址进行拦截 下面加个bean是哪个类进行处理[送到这个java中处理]--&gt;
       &lt;!-- &lt;mvc:mapping path=&quot;/**&quot;/&gt; --&gt;
            &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt;
            &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt;
&lt;!--            以下是不需要拦截 排除在外的--&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt;
&lt;!--   创建一个resources  规范静态文件目录 一次性都排除在外--&gt;
            &lt;mvc:exclude-mapping path=&quot;/rescources/**&quot;/&gt;

            &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/e1dbff67f8b3f8c785e7ca12d62741c295469782/data/%E5%A4%9AInterceptor%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg"></p>
<pre><code class="java">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURI()+&quot;准备执行&quot;);
        return true;
    &#125;
通过preHandle的返回值可以做很多事情
对某一个url进行前置检查 对请求放行 如果不符合要求 直接在拦截器中返回相应
return true; 请求依次向后发送
return false; 请求被阻挡
</code></pre>
<h3 id="开发”用户流量”拦截器"><a href="#开发”用户流量”拦截器" class="headerlink" title="开发”用户流量”拦截器"></a>开发”用户流量”拦截器</h3><pre><code class="xml">pom.xml [引入新的依赖后一定要去Tomcat导入新的依赖包]
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">logback.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;d:/logs/history.%d.log&lt;/fileNamePattern&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;[%thread] %d %level %logger&#123;10&#125; - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;console&quot;/&gt;
    &lt;/root&gt;
    &lt;logger name=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;
            level=&quot;INFO&quot; additivity=&quot;false&quot;&gt;
        &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt;
    &lt;/logger&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/AccessHistoryInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class AccessHistoryInterceptor implements HandlerInterceptor &#123;
    private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class);
//    前置处理

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        StringBuilder log = new StringBuilder();
        log.append(request.getRemoteAddr());
        log.append(&quot;|&quot;);
        log.append(request.getRequestURL());
        log.append(&quot;|&quot;);
        log.append(request.getHeader(&quot;user-agent&quot;));
        logger.info(log.toString());
        return true;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/restful/interceptor/MyInterceptor.java
package com.imooc.restful.interceptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;
//    Code -&gt; Implement Methods

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-准备执行&quot;);
//        response.getWriter().print(&quot;[]&quot;);
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;);
    &#125;

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;);
    &#125;
&#125;

==============================================================
http://localhost/client.html
[http-nio-80-exec-1] 2024-01-18 10:43:54,739 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/login.html&quot;, parameters=&#123;&#125;
[http-nio-80-exec-1] 2024-01-18 10:43:54,750 DEBUG o.s.w.s.h.SimpleUrlHandlerMapping - Mapped to org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler@5c0e8bb9
[http-nio-80-exec-1] 2024-01-18 10:43:54,758 DEBUG o.s.w.s.DispatcherServlet - Completed 404 NOT_FOUND
[http-nio-80-exec-2] 2024-01-18 10:44:00,495 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/request&quot;, parameters=&#123;&#125;
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.lang.String com.imooc.restful.controller.RestfulController.doGetRequest()
http://localhost/restful/request-准备执行
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json;charset=utf-8&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [text/html;charset=utf-8, application/json;charset=utf-8, text/plain, */*, application/json, application/*+json]
[http-nio-80-exec-2] 2024-01-18 10:44:00,539 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [&quot;&#123;&quot;message&quot;:&quot;返回查询结果&quot;&#125;&quot;]
http://localhost/restful/request-目标处理成功
http://localhost/restful/request-响应内容已产生
[http-nio-80-exec-2] 2024-01-18 10:44:00,580 DEBUG o.s.w.s.DispatcherServlet - Completed 200 OK
[http-nio-80-exec-5] 2024-01-18 10:44:08,194 DEBUG o.s.w.s.DispatcherServlet - GET &quot;/restful/persons&quot;, parameters=&#123;&#125;
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public java.util.List&lt;com.imooc.restful.entity.Person&gt; com.imooc.restful.controller.RestfulController.findPersons()
http://localhost/restful/persons-准备执行
RestfulController.findPersons() - return list
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Using &#39;application/json&#39;, given [application/json, text/javascript, */*;q=0.01] and supported [application/json, application/*+json]
[http-nio-80-exec-5] 2024-01-18 10:44:08,211 DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Writing [[com.imooc.restful.entity.Person@619c4d80, com.imooc.restful.entity.Person@71459fb]]
http://localhost/restful/persons-目标处理成功
http://localhost/restful/persons-响应内容已产生
===================================================================
D:\logs\history.2024-01-18
[http-nio-80-exec-1] 2024-01-18 10:43:54,755 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/login.html|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-2] 2024-01-18 10:44:00,502 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-5] 2024-01-18 10:44:08,195 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/persons|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-3] 2024-01-18 10:44:10,137 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request/100|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-4] 2024-01-18 10:44:10,935 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
[http-nio-80-exec-6] 2024-01-18 10:44:11,481 INFO c.i.r.i.AccessHistoryInterceptor - 0:0:0:0:0:0:0:1|http://localhost/restful/request|Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot;/&gt;
            &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt;
            &lt;bean class=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;/&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
</code></pre>
<h3 id="Spring-MVC处理流程"><a href="#Spring-MVC处理流程" class="headerlink" title="Spring MVC处理流程"></a>Spring MVC处理流程</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/42e2897ef9dc2075cb7c71f43c2a2e54e11ffea7/data/SpringMVC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/01/15/后端/SpringMVC[Mapping,中文乱码,Restful及跨域,JSON序列化,非简单请求,拦截器]/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/">
        <h2>
            Spring
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/12/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><img src="https://raw.githubusercontent.com/P-luminary/images/8fdafeebf37a6ccf8de24be3ce4d857524f07204/data/Spring%E6%A8%A1%E5%9D%97.png" style="zoom: 200%;" />

<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring框架介绍</td>
<td>Spring IoC、DI和AOP等核心概念</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>Spring IoC容器</td>
<td>Spring实例化与管理对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>集合对象注入</td>
<td>注入List、Set、Map集合对象</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>底层原理</td>
<td>Spring Bean的生命周期</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>注解与Java Config</td>
<td>Spring注解分类和常用注解应用</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h6 id="不修改源代码的程序扩展"><a href="#不修改源代码的程序扩展" class="headerlink" title="不修改源代码的程序扩展"></a>不修改源代码的程序扩展</h6><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>理解AOP及名词</td>
<td>Spring AOP开发与配置流程</td>
<td>★★★★★★(面试)</td>
</tr>
<tr>
<td>五种通知类型</td>
<td>Spring五种通知类型与应用场景</td>
<td>★★★</td>
</tr>
<tr>
<td>切点表达式</td>
<td>PointCut切点表达式的语法规则及应用</td>
<td>★★</td>
</tr>
<tr>
<td>代理模式</td>
<td>JDK动态代理和CGLib代理的执行过程</td>
<td>★★★★★★(面试)</td>
</tr>
</tbody></table>
<h3 id="Spring-JDBC与声明式事务"><a href="#Spring-JDBC与声明式事务" class="headerlink" title="Spring JDBC与声明式事务"></a>Spring JDBC与声明式事务</h3><p>JDBC的扩展</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>重要程度</th>
</tr>
</thead>
<tbody><tr>
<td>Spring JDBC</td>
<td>Spring JDBC的环境配置</td>
<td>★★★★</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>基于RestTemplate实现SQL处理</td>
<td>★★★</td>
</tr>
<tr>
<td>配置声明式事务</td>
<td>声明式事务的配置过程</td>
<td>★★★★★★</td>
</tr>
<tr>
<td>事务传播行为介绍</td>
<td>讲解常用事务传播行为的用途</td>
<td>★★★</td>
</tr>
<tr>
<td>声明式事务注解形式</td>
<td>基于注解使用声明式事务</td>
<td>★★★★★★</td>
</tr>
</tbody></table>
<h1 id="★★★★★★-Spring-★★★★★★"><a href="#★★★★★★-Spring-★★★★★★" class="headerlink" title="★★★★★★  Spring  ★★★★★★"></a><span style = "color:red">★★★★★★  Spring  ★★★★★★</span></h1><p>IoC容器负责<strong>实例化</strong>，<strong>配置</strong>和<strong>组装</strong>对象。 IoC容器从XML文件获取信息并相应地工作。</p>
<p>IoC容器执行的主要任务是:</p>
<ul>
<li>实例化应用程序类</li>
<li>配置对象</li>
<li>组装对象之间的依赖关系</li>
</ul>
<p>有两种类型的IoC容器</p>
<ul>
<li><code>BeanFactory</code></li>
<li><code>ApplicationContext</code></li>
</ul>
<h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><h6 id="对象的控制权交给第三方进行管理-中间人"><a href="#对象的控制权交给第三方进行管理-中间人" class="headerlink" title="对象的控制权交给第三方进行管理(中间人)"></a>对象的控制权交给第三方进行管理(中间人)</h6><ul>
<li>IoC控制反转，全称Inverse of Control，是一种设计理念</li>
<li>由代理人来创建与管理对象，消费者通过代理人来获取对象</li>
<li>IoC的目的是降低对象之间直接耦合[更好适合对象之间的变化]</li>
<li>加入<strong>IoC容器</strong>将对象统一管理，让对象关联变为弱耦合</li>
</ul>
<p><strong>顾客</strong> ←(快递) <strong>果商冷冻仓库</strong> (批发)→ <strong>苹果</strong></p>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><ul>
<li>IoC是设计理念，是现代程序设计遵循的标准，是宏观目标</li>
<li>DI(Dependency Injection)是具体技术实现，是微观实现</li>
<li>DI在Java中利用<strong>反射</strong>技术实现对象注入(Injection) [不同语言运用不同技术]</li>
</ul>
<h3 id="Spring含义"><a href="#Spring含义" class="headerlink" title="Spring含义"></a>Spring含义</h3><ul>
<li>Spring可以从广义和狭义两个角度看待</li>
<li>广义的Spring是指Spring生态系统</li>
<li>狭义的Spring是指Spring框架(Spring Framework)</li>
</ul>
<h5 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h5><ul>
<li>分布式微服务 SpringCloud</li>
<li>Reactive相应服务</li>
<li>Web apps 是 SpringMVC 中的</li>
<li>Serverless 无服务器内容</li>
<li>Event Driven 和 Batch</li>
<li>Spring Framework     Spring Boot     Spring Cloud     Spring Cloud Data Flow…</li>
</ul>
<h5 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h5><ul>
<li>Spring框架是企业开发复杂性的<strong>一站式</strong>解决方案</li>
<li>Spring框架的核心是<strong>IoC容器</strong>与<strong>AOP面向切面编程</strong></li>
<li>Spring IoC负责创建与管理系统对象，并在此基础上扩展功能(不修改源代码)</li>
</ul>
<h5 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h5><ul>
<li>对象直接引用导致对象硬性关联，程序难以扩展维护 new B new A</li>
</ul>
<h5 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h5><ul>
<li><p>IoC容器是Spring生态的地基，用于统一创建于管理对象依赖</p>
<p><strong>使用者</strong>直接<strong>提取</strong>Spring IoC容器中的已经将<strong>依赖</strong>ObjectB<strong>注入</strong>到ObjectA 直接提取A</p>
</li>
</ul>
<h5 id="Spring-IoC容器职责-宏观理念"><a href="#Spring-IoC容器职责-宏观理念" class="headerlink" title="Spring IoC容器职责 [宏观理念]"></a>Spring IoC容器职责 [宏观理念]</h5><ul>
<li>对象的控制权交由<strong>第三方</strong>统一管理 <u>(IoC控制反转)</u></li>
<li>利用Java<strong>反射</strong>技术实现<strong>运行时</strong>对象创建与关联 <u>(DI依赖注入)</u> [<strong>技术实现</strong>]</li>
<li>基于配置提高应用程序的可维护性与扩展性</li>
</ul>
<h3 id="Spring-IoC初体验"><a href="#Spring-IoC初体验" class="headerlink" title="Spring IoC初体验"></a>Spring IoC初体验</h3><h6 id="三个小孩吃三种不同的苹果"><a href="#三个小孩吃三种不同的苹果" class="headerlink" title="三个小孩吃三种不同的苹果"></a>三个小孩吃三种不同的苹果</h6><h5 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h5><p><strong>Apple.java</strong></p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;
    Construct(空+满) Getter+Setter
&#125;
</code></pre>
<p><strong>Child.java</strong></p>
<pre><code class="java">public class Child &#123;
    private String name;
    private Apple apple;
    Construct(空+满) Getter+Setter
    public void eat()&#123;
        System.out.println(name + &quot;吃到了&quot; + apple.getOrigin() + &quot;种植的&quot; + apple.getTitle());
    &#125;
&#125;
</code></pre>
<p><strong>Application.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;

public class Application &#123;
    public static void main(String[] args) &#123;
        Apple apple1 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Apple apple2 = new Apple(&quot;青苹果&quot;, &quot;绿色&quot;, &quot;中亚&quot;);
        Apple apple3 = new Apple(&quot;红富士&quot;, &quot;红色&quot;, &quot;欧洲&quot;);
        Child lily = new Child(&quot;莉莉&quot;,apple1);
        Child andy = new Child(&quot;安迪&quot;,apple2);
        Child luna = new Child(&quot;露娜&quot;,apple3);
        lily.eat();
        andy.eat();
        luna.eat();
    &#125;
&#125;
</code></pre>
<h5 id="Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理"><a href="#Spring-IoC方式代码-不修改源代码-不用new-引入容器让对象统一管理" class="headerlink" title="Spring IoC方式代码[不修改源代码 不用new 引入容器让对象统一管理]"></a><span style = "color:red">Spring IoC方式代码</span>[不修改源代码 不用new 引入容器让对象统一管理]</h5><p><strong>pom.xml</strong></p>
<pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<p><strong>applicationContext.xml</strong> [静态信息可以放其中]  **<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">SpringIoC核心配置文件 右键resources创建 所有对象的创建以及关联的设置都是在applicationContext.xml这里进行
Spring.io -&gt; Project -&gt; Spring Framework -&gt; LEARN -&gt; Reference Doc. -&gt;  Core

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt; 
并且加入配置Spring[出现在提示页面]

------------------------  更新一次  ------------------------
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;!--    在IoC容器启动时，自动由Spring实例化Apple对象，取名sweetApple放入到容器中  --&gt;
     &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;sourApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;softApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;沙果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;黄色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;rdApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;蛇果&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;origin&quot; value=&quot;美国&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;andy&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;安迪&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sourApple&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;luna&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;露娜&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;rdApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>SpringApplication.java</strong></p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
        //从IoC容器中提取beanId=lily的对象
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        lily.eat();
        Child andy = context.getBean(&quot;andy&quot;, Child.class);
        andy.eat();
        Child luna = context.getBean(&quot;luna&quot;, Child.class);
        luna.eat();
    &#125;
&#125;
————————————————————————————————————————————————————————————————————————————————————
红富士
莉莉吃到了欧洲种植的红富士
安迪吃到了中亚种植的青苹果
露娜吃到了美国种植的蛇果
</code></pre>
<p>利用IoC容器有利于对象与对象之间的<strong>解耦</strong>   springIoC大大提高了程序的维护与延展</p>
<h3 id="XML管理对象-Bean"><a href="#XML管理对象-Bean" class="headerlink" title="XML管理对象(Bean)"></a>XML管理对象(Bean)</h3><ul>
<li>基于XML配置Bean</li>
</ul>
<pre><code class="java">上述的吃苹果例题就是基于xml配置Bean
</code></pre>
<ul>
<li>基于注解配置Bean</li>
<li>基于Java代码配置Bean(java .config)</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
            &lt;property name=&quot;title&quot; value=&quot;红富士&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;红色&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
所有都要用bean标签 SpringIoC实例化以后在容器的唯一编号: id=&quot;sweetAppele&quot; SpringIoC就知道创建IoC容器时实例化一个Apple对象同时bean id=&quot;...&quot;
</code></pre>
<h5 id="XML方式创建IoC容器"><a href="#XML方式创建IoC容器" class="headerlink" title="XML方式创建IoC容器"></a>XML方式创建IoC容器</h5><pre><code class="xml">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new 
ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h3 id="实例化Bean的三种方式"><a href="#实例化Bean的三种方式" class="headerlink" title="实例化Bean的三种方式"></a>实例化Bean的三种方式</h3><ul>
<li><span style = "color:red">基于构造方法对象实例化</span> (90%以上)</li>
</ul>
<h6 id="利用构造方法参数名实例化-推荐"><a href="#利用构造方法参数名实例化-推荐" class="headerlink" title="利用构造方法参数名实例化 [推荐]"></a>利用构造方法<span style = "color:red">参数名</span>实例化 [推荐]</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 没有constructor-arg则代表调用默认构造方法实例化 --&gt;
  &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;           
  &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;     
&lt;/bean&gt;
</code></pre>
<p>Apple.java</p>
<pre><code class="java">public class Apple &#123;
    private String title;
    private String color;
    private String origin;

    public Apple() &#123;
        System.out.println(&quot;Apple对象已创建,&quot; + this);
    &#125;

    public Apple(String title, String color, String origin) &#123;
        System.out.println(&quot;通过带参构造方法创建对象&quot; + this);
        this.title = title;
        this.color = color;
        this.origin = origin;
    &#125;
    ......
</code></pre>
<p>SpringApplication.java</p>
<pre><code class="java">package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Apple;
import com.imooc.spring.ioc.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
___________________________________________________________________________
Apple对象已创建,com.imooc.spring.ioc.entity.Apple@39fb3ab6
通过带参构造方法创建对象com.imooc.spring.ioc.entity.Apple@1a968a59
</code></pre>
<h6 id="利用构造方法参数位置实例化"><a href="#利用构造方法参数位置实例化" class="headerlink" title="利用构造方法参数位置实例化"></a>利用构造方法<span style = "color:red">参数位置</span>实例化</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
  &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
  &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
  &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li><h3 id="基于静态工厂实例化-在IoC容器之外通过程序组织对象"><a href="#基于静态工厂实例化-在IoC容器之外通过程序组织对象" class="headerlink" title="基于静态工厂实例化 (在IoC容器之外通过程序组织对象)"></a>基于静态工厂实例化 (在IoC容器之外通过程序组织对象)</h3></li>
</ul>
<pre><code class="java">AppleStaticFactory.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

public class AppleStaticFactory &#123;
    public static Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用静态工厂获取对象--&gt;
    &lt;bean id=&quot;apple4&quot; class=&quot;com.imooc.spring.ioc.factory.AppleStaticFactory&quot;
          factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<hr>
<pre><code class="java">&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="java">A.java
package com.nhooo;
public class A &#123;
private static final A obj=new A();
private A()&#123;System.out.println(&quot;private constructor&quot;);&#125;
public static A getA()&#123;
    System.out.println(&quot;factory method &quot;);
    return obj;
&#125;
public void msg()&#123;
    System.out.println(&quot;hello user&quot;);
&#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
&lt;bean id=&quot;a&quot; class=&quot;com.nhooo.A&quot; factory-method=&quot;getA&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">Test.java
package org.sssit;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test &#123;
public static void main(String[] args) &#123;
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    A a=(A)context.getBean(&quot;a&quot;);
    a.msg();
&#125;
&#125;
=============================================================
private constructor
factory method
hello user
</code></pre>
<ul>
<li><h3 id="基于工厂实例方法实例化"><a href="#基于工厂实例方法实例化" class="headerlink" title="基于工厂实例方法实例化"></a>基于工厂实例方法实例化</h3></li>
</ul>
<pre><code class="java">AppleFactoryInstance.java
package com.imooc.spring.ioc.factory;

import com.imooc.spring.ioc.entity.Apple;

/**
 * 工厂实例方法创建对象是指IoC容器对工厂类进行实例化并调用对应的实例方法创建对象的过程
 */
public class AppleFactoryInstance &#123;
    public Apple createSweetApple()&#123; //静态工厂 用于创建对象的方法是静态的
        Apple apple = new Apple();
        apple.setTitle(&quot;红富士&quot;);
        apple.setOrigin(&quot;欧洲&quot;);
        apple.setColor(&quot;红色&quot;);
        return apple;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--利用工厂实例方法获取对象--&gt;
    &lt;bean id=&quot;factoryInstance&quot; class=&quot;com.imooc.spring.ioc.factory.AppleFactoryInstance&quot;/&gt;
    &lt;bean id=&quot;apple5&quot; factory-bean=&quot;factoryInstance&quot; factory-method=&quot;createSweetApple&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="从IoC容器获取bean"><a href="#从IoC容器获取bean" class="headerlink" title="从IoC容器获取bean"></a>从IoC容器获取bean</h3><pre><code class="java">Apple sweetApple = context.getBean(&quot;sweetApple&quot;,Apple.class); 【推荐】
                    或者
Apple sweetApple = (Apple)context.getBean(&quot;sweetApple&quot;);
-------------------------------------------------------------
System.out.println(sweetApple.getTitle());
</code></pre>
<pre><code class="java">public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Apple apple4 = context.getBean(&quot;apple4&quot;, Apple.class); 【推荐】
        System.out.println(apple4.getTitle());
        
        Apple apple3 = (Apple)context.getBean(&quot;apple3&quot;);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
</code></pre>
<h5 id="id与name属性相同点"><a href="#id与name属性相同点" class="headerlink" title="id与name属性相同点"></a>id与name属性相同点</h5><ul>
<li>bean id 与 name 都是设置对象在IoC容器中唯一标识</li>
</ul>
<pre><code class="java">&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;bean name=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
</code></pre>
<ul>
<li>两者在同一个配置文件中都不允许出现重复</li>
<li>两者允许在多个配置文件中出现重复，新对象覆盖旧对象</li>
<li><span style = "color:red"><strong>id要求更为严格，一次只能定义一个对象标识</strong></span> 【推荐】</li>
<li><span style = "color:red"><strong>name更为宽松，一次允许定义多个对象标识</strong></span> </li>
<li>tips: id与name的命名要求有意义，按驼峰命名书写</li>
</ul>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;apple3&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;红富士&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg index=&quot;2&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg index=&quot;3&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">applicationContext-1.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
 &lt;bean id=&quot;apple2&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
        &lt;!-- 利用构造方法参数位置实现对象实例化 --&gt;
        &lt;constructor-arg name=&quot;title&quot; value=&quot;红富士2号&quot;/&gt;
        &lt;constructor-arg name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
        &lt;constructor-arg name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple apple2 = context.getBean(&quot;apple2&quot;,Apple.class);
        System.out.println(apple2.getTitle());
        Apple apple3 = context.getBean(&quot;apple3&quot;,Apple.class);
        System.out.println(apple3.getTitle());
    &#125;
&#125;
______________________________________________________________________
红富士2号
红富士
</code></pre>
<blockquote>
<p>&lt; bean name &#x3D; “apple2, apple7”  class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt;<br>如果使用name(不使用id)可以在后面增加标识名<br>在没有id与name的bean默认使用类名全称作为bean标识<br>&lt; bean class&#x3D;”com.imooc.spring.ioc.entity.Apple” &gt; </p>
</blockquote>
<h3 id="路径匹配表达式"><a href="#路径匹配表达式" class="headerlink" title="路径匹配表达式"></a>路径匹配表达式</h3><h5 id="加载单个配置文件"><a href="#加载单个配置文件" class="headerlink" title="加载单个配置文件"></a>加载单个配置文件</h5><pre><code class="java">//创建IoC容器并根据配置文件创建对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
</code></pre>
<h5 id="加载多配置文件"><a href="#加载多配置文件" class="headerlink" title="加载多配置文件"></a>加载多配置文件</h5><pre><code class="java">String[] configLocations = new String[]&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;&#125;;
ApplicationContext context = new ClassPathXmlApplicationContext(configLocations);
</code></pre>
<h5 id="路径表达式-config-xml-x3D-ApplicationContext-xml"><a href="#路径表达式-config-xml-x3D-ApplicationContext-xml" class="headerlink" title="路径表达式 (config.xml &#x3D; ApplicationContext.xml)"></a>路径表达式 (config.xml &#x3D; ApplicationContext.xml)</h5><table>
<thead>
<tr>
<th>表达式实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:config.xml</td>
<td>扫描classpath根路径(不包含jar)的config.xml</td>
</tr>
<tr>
<td>classpath:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(不包含jar)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath*:com&#x2F;imooc&#x2F;config.xml</td>
<td>扫描classpath下(<strong>包含jar</strong>)com.imooc包中的config.xml</td>
</tr>
<tr>
<td>classpath:config-*.xml</td>
<td>扫描classpath根路径下所有以config-开头的XML文件</td>
</tr>
<tr>
<td>classpath:com&#x2F;**&#x2F;config.xml</td>
<td>扫描com包下(包含任何子包)的config.xml</td>
</tr>
<tr>
<td>file:c:&#x2F;config.xml</td>
<td>扫描c盘根路径config.xml</td>
</tr>
</tbody></table>
<h3 id="对象依赖注入"><a href="#对象依赖注入" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h3><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style = "color:red"><strong>基于setter方法注入对象</strong></span></li>
</ul>
<h6 id="利用setter实现静态数值注入"><a href="#利用setter实现静态数值注入" class="headerlink" title="利用setter实现静态数值注入"></a>利用setter实现静态数值注入</h6><pre><code class="java">&lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.entity.Apple&quot;&gt;
&lt;!-- IoC容器自动利用反射机制运行时调用setXXX方法为属性赋值 --&gt;
    &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt;
    &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
    &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="利用setter实现对象注入-【核心操作-ref-x3D-””】"><a href="#利用setter实现对象注入-【核心操作-ref-x3D-””】" class="headerlink" title="利用setter实现对象注入 【核心操作 ref&#x3D;””】"></a>利用setter实现对象注入 【<u>核心操作 ref&#x3D;””</u>】</h6><p>**<code>属性</code>**元素的 <u><strong>ref</strong> 属性用于定义另一个bean的引用。</u></p>
<pre><code class="java">&lt;bean id=&quot;lily&quot; class=&quot;com.imooc.spring.ioc.entity.Child&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
    &lt;!-- 利用ref注入依赖对象 --&gt;
    &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="java">Child.java   #创建好的apple对象赋予給参数进入setApple
public void setApple(Apple apple) &#123;
     System.out.println(&quot;注入的Apple对象：&quot; + apple);
     this.apple = apple;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //创建Spring IoC容器，并根据配置文件在容器中实例化对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;,&quot;classpath:applicationContext-1.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        System.out.println(sweetApple.getTitle());
    &#125;
&#125;
</code></pre>
<h3 id="体验依赖注入的优势-高效解耦"><a href="#体验依赖注入的优势-高效解耦" class="headerlink" title="体验依赖注入的优势 (高效解耦)"></a>体验依赖注入的优势 (高效解耦)</h3><pre><code class="xml">applicatioinContext-dao.xml    #用于数据库的增删改查
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookDao&quot; class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoImpl&quot;&gt;
//如果更改了数据库类型 只需要重新创建一个java实现接口BookDao的insert 之后只需更改class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">applicatioinContext-service.xml 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.imooc.spring.ioc.bookshop.service.BookService&quot;&gt;
&lt;!--        id=bookDao     --&gt;
       &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">BookDao.java
package com.imooc.spring.ioc.bookshop.dao;

public interface BookDao &#123;
    public void insert();
&#125;
</code></pre>
<pre><code class="java">BookDaoImpl.java
package com.imooc.spring.ioc.bookshop.dao;

public class BookDaoImpl implements BookDao&#123;
    @Override
    public void insert() &#123;
        System.out.println(&quot;向mysql book表插入数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookService.java
package com.imooc.spring.ioc.bookshop.service;

import com.imooc.spring.ioc.bookshop.dao.BookDao;

public class BookService &#123;
    private BookDao bookDao; //接口将在ioc启动的时候动态注入
    public void purchase()&#123;
        System.out.println(&quot;正在执行图书采购业务方法&quot;);
        bookDao.insert();
    &#125;
    public BookDao getBookDao()&#123;
        return bookDao;
    &#125;
    public void setBookDao(BookDao bookDao)&#123;
        this.bookDao = bookDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">BookShopApplication.java
package com.imooc.spring.ioc.bookshop;

import com.imooc.spring.ioc.bookshop.service.BookService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class BookShopApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class);
        bookService.purchase();
    &#125;
&#125;
</code></pre>
<h3 id="利用构造方法实现对象依赖注入"><a href="#利用构造方法实现对象依赖注入" class="headerlink" title="利用构造方法实现对象依赖注入"></a>利用构造方法实现对象依赖注入</h3><h5 id="对象依赖注入-1"><a href="#对象依赖注入-1" class="headerlink" title="对象依赖注入"></a>对象依赖注入</h5><ul>
<li>依赖注入是指运行时将容器内对象利用<strong>反射</strong>赋給其他对象的操作</li>
<li><span style="color:red"><strong>基于setter方法注入对象</strong></span></li>
<li>基于构造方法注入对象</li>
</ul>
<pre><code class="java">【com.imooc.spring.ioc.entity】
Child.java + Apple.java 

Apple.java中可以加一个
public void apple()&#123;
        System.out.println(origin+&quot;国家&quot; +color+&quot;的&quot;+title+&quot;食物&quot;);
    &#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;sweetApple&quot; class=&quot;com.imooc.Apple.entity.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;青苹果&quot;/&gt;
        &lt;property name=&quot;color&quot; value=&quot;绿色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;中亚&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;lily&quot; class=&quot;com.imooc.Apple.entity.Child&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;莉莉&quot;/&gt;
        &lt;property name=&quot;apple&quot; ref=&quot;sweetApple&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">package com.imooc.Apple;

import com.imooc.Apple.entity.Apple;
import com.imooc.Apple.entity.Child;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-*.xml&quot;);
        Apple sweetApple = context.getBean(&quot;sweetApple&quot;, Apple.class);
        Child lily = context.getBean(&quot;lily&quot;, Child.class);
        // 添加打印语句，检查属性是否正确注入
        System.out.println(&quot;lily&#39;s name: &quot; + lily.getName());
        System.out.println(&quot;lily&#39;s apple origin: &quot; + lily.getApple().getOrigin());
        System.out.println(&quot;lily&#39;s apple title: &quot; + lily.getApple().getTitle());
        System.out.println(&quot;====================================&quot;);
//        System.out.println(sweetApple.getTitle()+sweetApple.getColor()+sweetApple.getOrigin());
        lily.eat();
        sweetApple.apple();
    &#125;
&#125;
</code></pre>
<h3 id="注入集合对象-1"><a href="#注入集合对象-1" class="headerlink" title="注入集合对象_1"></a>注入集合对象_1</h3><h5 id="注入List-允许重复数据"><a href="#注入List-允许重复数据" class="headerlink" title="注入List [允许重复数据]"></a>注入List [允许重复数据]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someList&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;具体值&lt;/value&gt;
        &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Set-不允许重复数据-自动去除重复"><a href="#注入Set-不允许重复数据-自动去除重复" class="headerlink" title="注入Set  [不允许重复数据 自动去除重复]"></a>注入Set  [不允许重复数据 自动去除重复]</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someSet&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;具体值&lt;/value&gt;
      &lt;ref bean=&quot;beanId&quot;&gt;&lt;/ref&gt;
    &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Map"><a href="#注入Map" class="headerlink" title="注入Map"></a>注入Map</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someMap&quot;&gt;
    &lt;Map&gt;
        &lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&gt;&lt;/entry&gt; #静态数值
      &lt;entry key=&quot;k2&quot; value-ref=&quot;beanId&quot;&gt;&lt;/entry&gt; #对象引用
    &lt;/Map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入Properties"><a href="#注入Properties" class="headerlink" title="注入Properties"></a>注入Properties</h5><pre><code class="java">&lt;bean id = &quot;...&quot; class = &quot;...&quot;&gt;
    &lt;property name = &quot;someProperties&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;k1&quot;&gt;v1&lt;/prop&gt;
      &lt;prop key=&quot;k2&quot;&gt;v2&lt;/prop&gt;
    &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="公司资产配置清单-小案例"><a href="#公司资产配置清单-小案例" class="headerlink" title="公司资产配置清单[小案例]"></a>公司资产配置清单[小案例]</h3><p><strong>constructor-arg：通过 构造函数注入 。</strong></p>
<p><strong>property：通过 setter对应的方法注入</strong> 。</p>
<pre><code class="java">Company.java
package com.imooc.spring.ioc.entity;

import java.util.List;
import java.util.Map;
import java.util.Properties;

public class Company &#123;
    private List&lt;String&gt; rooms;
    private Map&lt;String,Computer&gt; computers; //每一条数据保存的都是Computer型
    private Properties info;//键值对的写

    @Override
    public String toString() &#123;
        return &quot;Company&#123;&quot; +
                &quot;rooms=&quot; + rooms +
                &quot;, computers=&quot; + computers +
                &quot;, info=&quot; + info +
                &#39;&#125;&#39;;
    &#125;
    + Getter Setter
&#125;
</code></pre>
<pre><code class="java">Computer.java
public class Computer &#123;
    private String brand;
    private String type;
    private String sn;
    private Float price;
    constructor(空+满)+Getter Setter
&#125;
</code></pre>
<p>如何在ioc容器创建后自动的实例化Company对象并且填充信息呢?<br>所有的工作都在<code>applicationContext.xml</code>中进行的</p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;list&gt; //【允许重复】
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Company;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        Company company = context.getBean(&quot;company&quot;, Company.class);
        System.out.println(company);
    &#125;
&#125;
------------------------------------------------------------
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=null, info=null&#125;

Process finished with exit code 0
------------------------------------------------------------
下方xml更新后的显示数据：
Company&#123;rooms=[2001-总裁办, 2003-总经理办公室, 2010-研发部会议室], computers=&#123;dev-88172=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;, dev-88173=Computer&#123;brand=&#39;联想&#39;, type=&#39;台式机&#39;, sn=&#39;8389283012&#39;, price=3085.0&#125;&#125;, info=&#123;phone=010-12345678, address=北京市朝阳区XX路XX大厦, website=https://p-luminary.github.io&#125;&#125;
https://p-luminary.github.io

Process finished with exit code 0
</code></pre>
<p>list的底层是ArrayList<br>Set的底层是LinkedHashSet [双向有序列表]<br>Map的底层是LinkedHashMap [双向列表 提取也是存放顺序]</p>
<pre><code class="xml">applicationContext.xml [更新一次]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;

或者【简便方法】↓
</code></pre>
<pre><code class="xml">applicationContext.xml 更新二次【新增简便方法】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;c1&quot; class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;【方法一】
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;company&quot; class=&quot;com.imooc.spring.ioc.entity.Company&quot;&gt;
        &lt;property name=&quot;rooms&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;2001-总裁办&lt;/value&gt;
                &lt;value&gt;2003-总经理办公室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
                &lt;value&gt;2010-研发部会议室&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;computers&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;dev-88172&quot; value-ref=&quot;c1&quot;/&gt; &lt;!-- 对象引用c1在上方 --&gt;
                &lt;entry key=&quot;dev-88173&quot;&gt;【方法二 (推荐)】
                    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
                        &lt;constructor-arg name=&quot;brand&quot; value=&quot;联想&quot;/&gt;
                        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
                        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
                        &lt;constructor-arg name=&quot;price&quot; value=&quot;3085&quot;/&gt;
                    &lt;/bean&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;phone&quot;&gt;010-12345678&lt;/prop&gt;
                &lt;prop key=&quot;address&quot;&gt;北京市朝阳区XX路XX大厦&lt;/prop&gt;
                &lt;prop key=&quot;website&quot;&gt;https://p-luminary.github.io&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/43856e9419b6b12dba03ffb97458b89e4dd7ec1e/data/constructor%E4%B8%8Eproperty%E5%8C%BA%E5%88%AB.jpg"></p>
<h3 id="查看容器内对象-【-getBeanDefinitionNames-】"><a href="#查看容器内对象-【-getBeanDefinitionNames-】" class="headerlink" title="查看容器内对象 【.getBeanDefinitionNames()】"></a>查看容器内对象 【.getBeanDefinitionNames()】</h3><pre><code class="java">多个同类型的bean会自动增加编号 #1  #2
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;微星&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;8389283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;3000&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean class=&quot;com.imooc.spring.ioc.entity.Computer&quot;&gt;
        &lt;constructor-arg name=&quot;brand&quot; value=&quot;华硕&quot;/&gt;
        &lt;constructor-arg name=&quot;type&quot; value=&quot;台式机&quot;/&gt;
        &lt;constructor-arg name=&quot;sn&quot; value=&quot;9023283012&quot;/&gt;
        &lt;constructor-arg name=&quot;price&quot; value=&quot;5600&quot;/&gt;
    &lt;/bean&gt;

//获取容器内所有beanId数组       
        String[] beanNames = context.getBeanDefinitionNames();
        for (String beanName:beanNames)&#123;
            System.out.println(beanName); //c1 company ...&lt;bean id=&quot;...&quot;&gt;
             System.out.println(&quot;类型：&quot; + context.getBean(beanName).getClass().getName());
            System.out.println(&quot;内容：&quot; + context.getBean(beanName).toString());
        &#125;
        Computer computer = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer&quot;, Computer.class);
        System.out.println(computer.getBrand());
        Computer computer1 = context.getBean(&quot;com.imooc.spring.ioc.entity.Computer#1&quot;, Computer.class);
        System.out.println(computer1.getBrand());
</code></pre>
<h3 id="bean-scope属性"><a href="#bean-scope属性" class="headerlink" title="bean scope属性"></a>bean scope属性</h3><ul>
<li>bean scope属性用于决定对象何时被创建与作用范围</li>
<li>bean scope配置将影响容器内对象的数量</li>
<li>bean scope默认值singleton(单例), 指全局共享同一个对象实例</li>
</ul>
<h5 id="scope用法"><a href="#scope用法" class="headerlink" title="scope用法"></a>scope用法</h5><pre><code class="java">&lt;bean id=&quot;bookDao&quot;
    class=&quot;com.imooc.spring.ioc.bookshop.dao.BookDaoOracleImpl&quot;
    scope=&quot;prototype&quot;/&gt;
</code></pre>
<h5 id="bean-scope属性清单"><a href="#bean-scope属性清单" class="headerlink" title="bean scope属性清单"></a>bean scope属性清单</h5><table>
<thead>
<tr>
<th>scope属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><span style = "color:red">singleton</span></td>
<td><span style = "color:red">单例(默认值),每一个容器有且只有唯一的实例,实例被全局共享</span></td>
</tr>
<tr>
<td><span style = "color:red">prototype</span></td>
<td><span style = "color:red">多例,每次使用时都是创建一个实例</span></td>
</tr>
<tr>
<td>request</td>
<td>web环境下,每一个独立请求存在唯一实例</td>
</tr>
<tr>
<td>session</td>
<td>web环境下,每一个session存在有唯一实例</td>
</tr>
<tr>
<td>application</td>
<td>web环境下,ServletContext存在唯一实例</td>
</tr>
<tr>
<td>websocket</td>
<td>每一次WebSocket连接中存在唯一实例</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/59d168487d0ef9aa2a23cf8057d454e1d3f26fc9/data/singleton%E4%B8%8Eprototype%E6%AF%94%E8%BE%83%E5%9B%BE.png"></p>
<h5 id="singleton与prototype对比"><a href="#singleton与prototype对比" class="headerlink" title="singleton与prototype对比"></a>singleton与prototype对比</h5><table>
<thead>
<tr>
<th></th>
<th>singleton</th>
<th>prototype</th>
</tr>
</thead>
<tbody><tr>
<td>对象数量</td>
<td>全局唯一</td>
<td>存在多个</td>
</tr>
<tr>
<td>实例化时机</td>
<td>IoC容器启动时</td>
<td>getBean() 或 对象注入时</td>
</tr>
<tr>
<td>线程安全问题</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>执行效率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public UserDao()&#123;
        System.out.println(&quot;UserDao已创建: &quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    public UserDao userDao;

    public UserService() &#123;
        System.out.println(&quot;UserService已创建: &quot; + this);
    &#125;

    public UserService(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        System.out.println(&quot;调用setUserDao: &quot; + userDao);
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
   &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java 【单例】

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserDao userDao = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao1 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao2 = context.getBean(&quot;userDao&quot;, UserDao.class);
        UserDao userDao3 = context.getBean(&quot;userDao&quot;, UserDao.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; &gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出：
UserService已创建: com.imooc.spring.ioc.service.UserService@3dd3bcd
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@7c16905e
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@7c16905e
    
Process finished with exit code 0
</code></pre>
<pre><code class="java">SpringApplication.java 【多例】
public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;IoC容器已初始化&quot;);
        UserService userService1 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService2 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService3 = context.getBean(&quot;userService&quot;, UserService.class);
        UserService userService4 = context.getBean(&quot;userService&quot;, UserService.class);
    &#125;
&#125;

applicationContext.xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
      &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
   &lt;/bean&gt;

================================================================
输出:
IoC容器已初始化
UserService已创建: com.imooc.spring.ioc.service.UserService@5c7fa833
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4dfa3a9d
UserService已创建: com.imooc.spring.ioc.service.UserService@4b952a2d
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@3159c4b8
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@3159c4b8
UserService已创建: com.imooc.spring.ioc.service.UserService@73846619
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@4bec1f0c
UserService已创建: com.imooc.spring.ioc.service.UserService@29ca901e
UserDao已创建: com.imooc.spring.ioc.dao.UserDao@5649fd9b
调用setUserDao: com.imooc.spring.ioc.dao.UserDao@5649fd9b

Process finished with exit code 0
</code></pre>
<p><span style = "color : red">一般来说dao类 service类 control类都是单例 因为单例安全根源是运行时发生不断的变化 如果在真正环境中一般不会重新设置那些类，在运行中都是恒定不变的。所以推荐用单例默认<code>singleton</code></span></p>
<h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/cbffd1149ca0b5b1b860325d72941880b7ca7fc4/data/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<pre><code class="java">Order.java
package com.imooc.spring.ioc.entity;

public class Order &#123;
    private Float price;
    private Integer quantity;
    private Float total;

    public Order() &#123;
        System.out.println(&quot;创建Order对象&quot; + this);
    &#125;

    public void init()&#123;
        System.out.println(&quot;执行init()方法&quot;);
        total = price * quantity;
    &#125;
    public void pay()&#123;
        System.out.println(&quot;订单金额为：&quot; + total);
    &#125;

    public Float getPrice() &#123;
        return price;
    &#125;

    public void setPrice(Float price) &#123;
        System.out.println(&quot;设置price：&quot; + price);
        this.price = price;
    &#125;

    public Integer getQuantity() &#123;
        return quantity;
    &#125;

    public void setQuantity(Integer quantity) &#123;
        System.out.println(&quot;设置quantity：&quot; + quantity);
        this.quantity = quantity;
    &#125;

    public Float getTotal() &#123;
        return total;
    &#125;

    public void setTotal(Float total) &#123;
        this.total = total;
    &#125;

    public void destroy()&#123;
        System.out.println(&quot;释放与订单对象相关的资源&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot; scope=&quot;prototype&quot;/&gt;  &lt;!-- 多例 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot; scope=&quot;prototype&quot;&gt; &lt;!-- 单例 创建一个对象 --&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;!-- 引用了上面的userDao多例 再创建一个对象 --&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;order1&quot; class=&quot;com.imooc.spring.ioc.entity.Order&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;
        &lt;property name=&quot;price&quot; value=&quot;19.8&quot;/&gt;
        &lt;property name=&quot;quantity&quot; value=&quot;1000&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        System.out.println(&quot;======IoC容器已初始化======&quot;);
        Order order1 = context.getBean(&quot;order1&quot;,Order.class);
        order1.pay();
        ((ClassPathXmlApplicationContext)context).registerShutdownHook(); //销毁容器 自动调用bean中设置的destory方法
    &#125;
&#125;

==========================================
创建Order对象com.imooc.spring.ioc.entity.Order@153f5a29
设置price：19.8
设置quantity：1000
执行init()方法
======IoC容器已初始化======
订单金额为：19800.0
释放与订单对象相关的资源

Process finished with exit code 0
</code></pre>
<h3 id="实现极简IoC容器-利用反射机制完成对象的创建和注入"><a href="#实现极简IoC容器-利用反射机制完成对象的创建和注入" class="headerlink" title="实现极简IoC容器 [利用反射机制完成对象的创建和注入]"></a>实现极简IoC容器 [利用反射机制完成对象的创建和注入]</h3><pre><code class="java">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        Dom4j是Java的XML解析组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;
            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        jaxen是Xpath表达式解释器--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jaxen&lt;/groupId&gt;
            &lt;artifactId&gt;jaxen&lt;/artifactId&gt;
            &lt;version&gt;1.1.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">Apple.java
public class Apple &#123;
    private String title;
    private String color;
    private String origin;
&#125; + Getter Setter
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans&gt;
    &lt;bean id = &quot;sweetApple&quot; class=&quot;com.imooc.spring.ioc.context.Apple&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;红富士&quot;/&gt; //这里的title是在setter中 public void setTitle(String title)&#123;this.title=title;&#125;
        &lt;property name=&quot;color&quot; value=&quot;红色&quot;/&gt;
        &lt;property name=&quot;origin&quot; value=&quot;欧洲&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">ApplicationContext.java[接口]
package com.imooc.spring.ioc.context;

public interface ApplicationContext &#123;
    public Object getBean(String beanId);
&#125;
</code></pre>
<pre><code class="java">ClassPathXmlApplicationContext.java
package com.imooc.spring.ioc.context;

import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.Node;
import org.dom4j.io.SAXReader;

import java.io.File;
import java.lang.reflect.Method;
import java.net.URLDecoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClassPathXmlApplicationContext implements ApplicationContext&#123;
    private Map iocContainer = new HashMap();
    public ClassPathXmlApplicationContext()&#123;
        try &#123;
            String filePath = this.getClass().getResource(&quot;/applicationContext.xml&quot;).getPath();
            filePath = new URLDecoder().decode(filePath,&quot;UTF-8&quot;);
            SAXReader reader = new SAXReader();
            Document document = reader.read(new File(filePath));
            List&lt;Node&gt; beans = document.getRootElement().selectNodes(&quot;bean&quot;);//得到节点的集合
            for (Node node:beans)&#123;
                Element ele = (Element) node;
                String id = ele.attributeValue(&quot;id&quot;);
                String className = ele.attributeValue(&quot;class&quot;);
                Class c = Class.forName(className);//加载指定类
                Object obj = c.newInstance();
                List&lt;Node&gt; properties = ele.selectNodes(&quot;property&quot;);
                for (Node p:properties)&#123;
                    Element property = (Element) p;
                    String propName = property.attributeValue(&quot;name&quot;);
                    String propValue= property.attributeValue(&quot;value&quot;);
//基于property完成注入是通过Setter的set方法，set方法命名的格式为setTitle 属性名第一个字母有个大写
                    String setMethodName = &quot;set&quot; + propName.substring(0,1).toUpperCase()+propName.substring(1);
                    System.out.println(&quot;准备执行&quot; + setMethodName + &quot;方法注入数据&quot;);
                    Method setMethod = c.getMethod(setMethodName, String.class);
                    setMethod.invoke(obj, propValue); //执行哪个对象的实例方法
                &#125;
                iocContainer.put(id,obj); //赋予了bean id
            &#125;
            System.out.println(iocContainer);
            System.out.println(&quot;IoC容器初始化完毕&quot;);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
    @Override
    public Object getBean(String beanId) &#123;
        return iocContainer.get(beanId);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Application.java
package com.imooc.spring.ioc.context;

public class Application &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext();
        Apple apple = (Apple) context.getBean(&quot;sweetApple&quot;);
        System.out.println(apple);
    &#125;
&#125;

=================================================
准备执行setTitle方法注入数据
准备执行setColor方法注入数据
准备执行setOrigin方法注入数据
&#123;sweetApple=com.imooc.spring.ioc.context.Apple@484b61fc&#125;
IoC容器初始化完毕
com.imooc.spring.ioc.context.Apple@484b61fc

Process finished with exit code 0
</code></pre>
<h3 id="四种组件类型注解"><a href="#四种组件类型注解" class="headerlink" title="四种组件类型注解"></a>四种组件类型注解</h3><h5 id="基于注解配置IoC容器"><a href="#基于注解配置IoC容器" class="headerlink" title="基于注解配置IoC容器"></a>基于注解配置IoC容器</h5><h6 id="基于注解的优势"><a href="#基于注解的优势" class="headerlink" title="基于注解的优势"></a>基于注解的优势</h6><ul>
<li>摆脱繁琐的XML形式的bean与依赖注入配置</li>
<li>基于”声明式”的原则,更适合轻量级的现代企业应用</li>
<li>让代码可读性变得更好,研发人员拥有更好的开发体验</li>
</ul>
<h5 id="三类注解"><a href="#三类注解" class="headerlink" title="三类注解"></a><span style = "color:red">三类注解</span></h5><ul>
<li>四种组件类型注解-声明当前类的功能与职责</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<p>   <strong>开启组件扫描</strong></p>
<pre><code class="xml">XML配置开启组件扫描,才能使用注解
&lt;context:component-scan base-package=&quot;com.imooc&quot;&gt;
   &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;com.imooc.exl.*&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<ul>
<li>自动装配注解-根据属性特征自动注入对象</li>
<li>元数据注解-更细化的辅助IoC容器管理对象的注解</li>
</ul>
<h3 id="基于注解初始化IoC容器"><a href="#基于注解初始化IoC容器" class="headerlink" title="基于注解初始化IoC容器"></a>基于注解初始化IoC容器</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Core Technologies (spring.io)</a></p>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt; //设置基准的包名去扫描

&lt;/beans&gt;
</code></pre>
<pre><code class="java">controller/UserController.java
package com.imooc.spring.ioc.controller;

import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao &#123;

&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;

&#125;
</code></pre>
<pre><code class="java">utils/StringUtils.java
package com.imooc.spring.ioc.utils;

import org.springframework.stereotype.Component;

@Component
public class StringUtils &#123;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123; //这些bean在容器中是单例，在初始化的时候创建对象
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
==============================================================
//组件类型解释默认beanId为类名首字母小写
userController:com.imooc.spring.ioc.controller.UserController@4f51b3e0
userDao:com.imooc.spring.ioc.dao.UserDao@4b9e255
userService:com.imooc.spring.ioc.service.UserService@5e57643e
stringUtils:com.imooc.spring.ioc.utils.StringUtils@133e16fd
    
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@51b279c9
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@1ad282e0
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@7f416310
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@1cab0bfb
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@5e955596

Process finished with exit code 0
</code></pre>
<h3 id="自动装配与Autowired注解"><a href="#自动装配与Autowired注解" class="headerlink" title="自动装配与Autowired注解"></a>自动装配与Autowired注解</h3><h5 id="两类自动装配注解-Primary-如果有两个写此注解作为主要"><a href="#两类自动装配注解-Primary-如果有两个写此注解作为主要" class="headerlink" title="两类自动装配注解  [@Primary 如果有两个写此注解作为主要]"></a>两类自动装配注解  [@Primary 如果有两个写此注解作为主要]</h5><table>
<thead>
<tr>
<th>分类</th>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按类型装配</td>
<td>@Autowired</td>
<td>按容器内对象类型动态注入属性,由Spring机构提供</td>
</tr>
<tr>
<td></td>
<td>@Inject</td>
<td>基于JSR-330标准,其他同@Autowired,但不支持required属性</td>
</tr>
<tr>
<td>按名称装配</td>
<td>@Named</td>
<td>与@Inject配合使用,JSR-330规范,按属性名自动装配属性</td>
</tr>
<tr>
<td></td>
<td><span style = "color:red">@Resource</span></td>
<td><span style = "color:red">基于JSR-250规范,优先按名称，再按类型智能匹配</span></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>这是默认的自动装配模式，意味着默认情况下没有自动装配</td>
</tr>
<tr>
<td>byName</td>
<td>byName模式根据bean的名称注入对象依赖项。在这种情况属性名称和bean名称必须相同，它在内部调用setter方法</td>
</tr>
<tr>
<td>byType</td>
<td>byType模式根据类型注入对象依赖项，因此属性名称和bean名称可以不同，它在内部调用setter方法</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数模式通过调用类的构造函数来注入依赖项。它会调用具有大量参数的构造函数。</td>
</tr>
<tr>
<td>autodetect</td>
<td>从Spring 3开始不推荐使用</td>
</tr>
</tbody></table>
<h5 id="无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】"><a href="#无法确认注入哪个bean-解决方案【UserDao-与-UserOracleDao】" class="headerlink" title="无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】"></a>无法确认注入哪个bean 解决方案【UserDao 与 UserOracleDao】</h5><pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

//组件类型解释默认beanId为类名首字母小写
//beanId = userDao
@Repository
public class UserDao implements IUserDao&#123;
    public UserDao()&#123;
        System.out.println(&quot;正在创建UseDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserOracleDao.java
package com.imooc.spring.ioc.dao;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;
@Repository
@Primary
public class UserOracleDao implements IUserDao&#123;

    public UserOracleDao()&#123;
        System.out.println(&quot;正在创建UserOracleDao：&quot; + this);
    &#125;
&#125;
</code></pre>
<pre><code class="java">IUserDao.java [接口]
package com.imooc.spring.ioc.dao;

public interface IUserDao &#123;
&#125;
</code></pre>
<pre><code class="java">DepartmentService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

@Service
public class DepartmentService &#123;
    /**
     * 1. @Resource设置name属性,则按name在IoC容器中将bean注入
     * 2. @Resource未设置name属性
     *  2.1 以属性名作为bean name在IoC容器中匹配bean，如有匹配则注入
     *  2.2 按属性名未匹配，则按类型进行匹配，同 @Autowired 需要加入 @Primary解决类型冲突
     *  使用建议: 在使用 @Resource对象时推荐设置name或保证属性名与bean名称一致
     */
    /*方法2.2.1
    @Resource(name = &quot;userOracleDao&quot;)
    private IUserDao udao;*/

    //方法2.2.2
    @Resource
    private IUserDao userOracleDao;
    public void joinDepartment()&#123;
        System.out.println(userOracleDao);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService &#123;
    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    private IUserDao udao;

    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java 
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
        DepartmentService departmentService = context.getBean(&quot;departmentService&quot;, DepartmentService.class);
        departmentService.joinDepartment();
    &#125;
&#125;
</code></pre>
<h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a>元数据注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Primary</td>
<td>按类型装配时出现多个相同类型对象,拥有此注解对象优先被注入</td>
</tr>
<tr>
<td>@PostConstruct</td>
<td>描述方法,相当于XML中init-method配置的注解版本</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>描述方法,相当于XML中destory-method配置的注解版本</td>
</tr>
<tr>
<td>@Scope</td>
<td>设置对象的scope属性  &#x2F;&#x2F;@Scope(“prototype”)设置多例</td>
</tr>
<tr>
<td>@Value</td>
<td>为属性注入静态数据</td>
</tr>
</tbody></table>
<pre><code class="java">applicationContext.xml 【新增第11行】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
&lt;!--    加载指定路径下的properties文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt;
&lt;!--
    在IoC容器初始化时自动扫描四种组件类型注解并完成实例化
    @Repository
    @Service
    @Controller
    @Component
--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">config.properties [这里属于动态注入噢~]
  metaData=imooc.com
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.IUserDao;
import com.imooc.spring.ioc.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;

@Service
@(&quot;prototype&quot;) //设置多例 与XML中bean scope完全相同
public class UserService &#123;
    @Value(&quot;$&#123;metaData&#125;&quot;)
    private String metaData; //对此数据的动态注入

    //@Autowired
    //Spring IoC容器会自动通过反射技术将属性private修饰符自动改为public,直接进行赋值
    //不再执行set方法
    public UserService() &#123;
        System.out.println(&quot;正在构建UserService&quot; + this);
    &#125;

    @PostConstruct //XML中bean init-method完全相同
    public void init()&#123;
        System.out.println(&quot;初始化UserService对象,metaData=&quot; + metaData);
    &#125;
    private IUserDao udao;


    public IUserDao getUdao() &#123;
        return udao;
    &#125;

    @Autowired
    //如果装配注解放在set方法上,则自动按类型/名称对set方法参数进行注入
    public void setUdao(UserDao udao) &#123;
        System.out.println(&quot;setUdao: &quot; + udao);
        this.udao = udao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.entity.Order;
import com.imooc.spring.ioc.service.DepartmentService;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        System.out.println(userService.getUdao());
    &#125;
&#125;
</code></pre>
<h3 id="基于Java-Config配置IoC容器"><a href="#基于Java-Config配置IoC容器" class="headerlink" title="基于Java Config配置IoC容器"></a>基于Java Config配置IoC容器</h3><ul>
<li>完全摆脱XML的束缚, 使用独立Java类管理对象与依赖</li>
<li>注解配置相对分散, 利用Java Config可对配置集中管理</li>
<li>可以在编译时进行依赖检查, 不容易出错</li>
</ul>
<h5 id="Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目"><a href="#Java-Config核心注解【敏捷开发-小型项目】-而XML是大型团队项目" class="headerlink" title="Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目"></a>Java Config核心注解【敏捷开发 小型项目】 而XML是大型团队项目</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Configuration</strong></td>
<td>描述类, 说明当前类是Java Config配置类, 完全替代XML文件</td>
</tr>
<tr>
<td>@<strong>Bean</strong></td>
<td>描述方法, 方法返回对象将被IoC容器管理, beanId默认为方法名</td>
</tr>
<tr>
<td>@ImportResource</td>
<td>描述类, 加载静态文件, 可使用@Value注解获取</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>描述类, 同XML的 &lt; context:compoment-scan &gt;标签</td>
</tr>
</tbody></table>
<pre><code class="java">UserController.java
package com.imooc.spring.ioc.controller;

import com.imooc.spring.ioc.service.UserService;
import org.springframework.stereotype.Controller;

@Controller
public class UserController &#123;
    private UserService userService;

    public UserService getUserService() &#123;
        return userService;
    &#125;

    public void setUserService(UserService userService) &#123;
        this.userService = userService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">Config.java [作为配置文件]
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        return userDao;
    &#125;
    @Bean
    public UserService userService()&#123;
        UserService userService = new UserService();
        return userService;
    &#125;
    @Bean
    public UserController userController()&#123;
        UserController userController = new UserController();
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;
=======================================================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@4f9a3314
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@3b2c72c2
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@491666ad
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@176d53b2
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@971d0d8
config:com.imooc.Config.Config$$EnhancerBySpringCGLIB$$c932e406@51931956
userDao:com.imooc.Config.UserDao@2b4a2ec7
userService:com.imooc.Config.UserService@564718df
userController:com.imooc.Config.UserController@51b7e5df
</code></pre>
<h3 id="JavaConfig-对象依赖注入"><a href="#JavaConfig-对象依赖注入" class="headerlink" title="JavaConfig-对象依赖注入"></a>JavaConfig-对象依赖注入</h3><p>Config的括号增加参数</p>
<pre><code class="java">Config.java
package com.imooc.spring.ioc;

import com.imooc.spring.ioc.controller.UserController;
import com.imooc.spring.ioc.dao.UserDao;
import com.imooc.spring.ioc.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration //当前是个配置类,用于代替applicationContext.xml
@ComponentScan(basePackages = &quot;com.imooc&quot;) //扫描其他的组件类 因为其他人也会写
public class Config &#123;
    @Bean //Java Config利用方法创建对象,将方法返回对象放入容器,beanId=方法名
    public UserDao userDao()&#123;
        UserDao userDao = new UserDao();
        System.out.println(&quot;已创建&quot;+userDao);
        return userDao;
    &#125;
    @Bean
    //先按name尝试注入,name不存在则按类型注入 冲突则@Primary
    public UserService userService(UserDao userDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        return userService;
    &#125;
    @Bean //&lt;bean id=&quot;xxx&quot; class=&quot;xxx&quot;&gt;
    public UserController userController(UserService userService)&#123;
        UserController userController = new UserController();
        System.out.println(&quot;已创建&quot; + userController);
        userController.setUserService(userService);
        System.out.println(&quot;调用setUserService:&quot;+userService);
        return userController;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.ioc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        //基于Java Config配置IoC容器的初始化
        ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
        System.out.println(&quot;=============================&quot;);
        String[] ids = context.getBeanDefinitionNames();
        for (String id:ids)&#123;
            System.out.println(id+&quot;:&quot;+context.getBean(id));
        &#125;
    &#125;
&#125;

=================================================================
已创建com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.service.UserService@473b46c3
调用setUserDao:com.imooc.spring.ioc.dao.UserDao@10b48321
已创建com.imooc.spring.ioc.controller.UserController@797badd3
调用setUserService:com.imooc.spring.ioc.service.UserService@473b46c3
=============================
org.springframework.context.annotation.internalConfigurationAnnotationProcessor:org.springframework.context.annotation.ConfigurationClassPostProcessor@44a664f2
org.springframework.context.annotation.internalAutowiredAnnotationProcessor:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@7f9fcf7f
org.springframework.context.annotation.internalCommonAnnotationProcessor:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@2357d90a
org.springframework.context.event.internalEventListenerProcessor:org.springframework.context.event.EventListenerMethodProcessor@6328d34a
org.springframework.context.event.internalEventListenerFactory:org.springframework.context.event.DefaultEventListenerFactory@145eaa29
config:com.imooc.spring.ioc.Config$$EnhancerBySpringCGLIB$$8a99aa4c@15bb6bea
userDao:com.imooc.spring.ioc.dao.UserDao@10b48321
userService:com.imooc.spring.ioc.service.UserService@473b46c3
userController:com.imooc.spring.ioc.controller.UserController@797badd3

Process finished with exit code 0
</code></pre>
<pre><code class="java">如果突然想增加一个注入employeeDao
UserService.java 先增加一个私有的名字 再getter+setter
去Conifg.java 括号里新增
public UserService userService(UserDao userDao, EmployeeDao employeeDao)&#123;
        UserService userService = new UserService();
        System.out.println(&quot;已创建&quot;+userService);
        userService.setUserDao(userDao);
        System.out.println(&quot;调用setUserDao:&quot; + userDao);
        userService.setEmployeeDao(employeeDao);
        return userService;
    &#125;
</code></pre>
<h3 id="Spring-Test测试模块"><a href="#Spring-Test测试模块" class="headerlink" title="Spring Test测试模块"></a>Spring Test测试模块</h3><ul>
<li>Spring Test是Spring中用于测试的模块</li>
<li>Spring Test对JUnit单元测试框架有良好的整合</li>
<li>通过Spring Test可在Junit单元测试时自动初始化IoC容器</li>
</ul>
<h5 id="Spring与JUnit4整合过程"><a href="#Spring与JUnit4整合过程" class="headerlink" title="Spring与JUnit4整合过程"></a>Spring与JUnit4整合过程</h5><ul>
<li>Maven工程依赖spring-test</li>
<li>利用 <strong>@RunWith</strong> 与 <strong>@ContextConfiguration</strong>描述测试用例类</li>
<li>测试用例类从容器获取对象完成测试用例的执行</li>
</ul>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Spring_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
        &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">UserDao.java
package com.imooc.spring.ioc.dao;

public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserService.java
package com.imooc.spring.ioc.service;

import com.imooc.spring.ioc.dao.UserDao;

public class UserService &#123;
    private UserDao userDao;
    public void createUser()&#123;
        System.out.println(&quot;调用创建用户业务代码&quot;);
        userDao.insert();
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.ioc.dao.UserDao&quot;&gt;

    &lt;/bean&gt;

    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.ioc.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringTestor.java
import com.imooc.spring.ioc.service.UserService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

//将Junit4的执行权交给Spring Test,在测试用例执行前自动初始化IoC容器
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class SpringTestor &#123;
    @Resource
    private UserService userService;

    @Test
    public void testUserService()&#123;
        userService.createUser();
    &#125;
&#125;
</code></pre>
<hr>
<hr>
<h3 id="介绍AOP"><a href="#介绍AOP" class="headerlink" title="介绍AOP"></a>介绍AOP</h3><p><strong>Aspect Oriented Programming</strong>(AOP)从某种意义上说是对OOP的补充，因为它还提供了模块化的功能。但是模块化的关键单元是方面而不是类。</p>
<h5 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h5><ul>
<li>介绍Spring AOP与相关概念名词</li>
<li>Spring AOP开发与配置流程</li>
<li>Spring 五种通知类型与应用场景</li>
</ul>
<h5 id="Spring中的可插拔组件技术-类似于插件"><a href="#Spring中的可插拔组件技术-类似于插件" class="headerlink" title="Spring中的可插拔组件技术 [类似于插件]"></a>Spring中的可插拔组件技术 [类似于插件]</h5><p>应用程序执行前检测的作用</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/63abc993304f86f346667a404430e2ad28f989cb/data/Spring%E4%B8%AD%E7%9A%84%E5%8F%AF%E6%8F%92%E6%8B%94%E7%BB%84%E4%BB%B6%E6%8A%80%E6%9C%AF.jpg"></p>
<h5 id="Spring-AOP-在不修改源码的情况下对程序进行扩展"><a href="#Spring-AOP-在不修改源码的情况下对程序进行扩展" class="headerlink" title="Spring AOP [在不修改源码的情况下对程序进行扩展]"></a>Spring AOP [在不修改源码的情况下对程序进行扩展]</h5><p>[IDEA创建项目出现Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request_id%22:%22170678007016800227455895%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142%5Ev99%5Epc_search_result_base9&amp;utm_term=Cannot">https://blog.csdn.net/weixin_45429409/article/details/118068484?ops_request_misc=%7B%22request%5Fid%22%3A%22170678007016800227455895%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170678007016800227455895&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118068484-null-null.142^v99^pc_search_result_base9&amp;utm_term=Cannot</a> resolve plugin org.apache.maven.plugins%3Amaven-site-plugin%3A3.3&amp;spm&#x3D;1018.2226.3001.4187)</p>
<ul>
<li>Spring AOP - Aspect Oriented Programming 面向切面编程</li>
<li>AOP的做法是将通用、与业务无关的功能抽象封装为切面类</li>
<li>切面可配置在<strong>目标方法</strong>的执行前、后运行，真正做到即插即用</li>
</ul>
<p>运行前进行拦截在运行前打印时间 再运行代码；没有IoC就没有AOP；写完扩展之后要再applicationContext.xml中新增&lt; aop:config &gt;…来认可切面</p>
<pre><code class="java">aop/dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
---------------------------------------------
aop/service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

import java.util.Date;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
---------------------------------------------
aop/service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        if(1==1)&#123;
            throw new RuntimeException(&quot;用户已存在&quot;);
        &#125;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------
aop/aspect/MethodAspect
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.JoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

//切面类
public class MethodAspect &#123;
    //切面方法,用于扩展额外功能
    //JoinPoint 连接点,通过连接点可以获取目标类/方法的信息
    public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;

    public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
    public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 16);
    &#125;
&#125;
====================================================================
----&gt;2024-02-01 18:09:38 050:com.imooc.AOP.UserService.createUser
----&gt;参数个数:0
执行创建用户业务逻辑
新增用户数据
&lt;----返回后通知:null
&lt;----触发后置通知
----&gt;2024-02-01 18:09:38 058:com.imooc.AOP.UserService.generateRandomPassword
----&gt;参数个数:2
----&gt;参数:MD5
----&gt;参数:16
按MD5方式生成16位随机密码
&lt;----返回后通知:PzZo3Fzqe!r4$
&lt;----触发后置通知
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;aop&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--aspectjweaver是Spring AOP的底层依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="Spring-AOP-与-AspectJ的关系-实现类与方法的匹配"><a href="#Spring-AOP-与-AspectJ的关系-实现类与方法的匹配" class="headerlink" title="Spring AOP 与 AspectJ的关系 [实现类与方法的匹配]"></a>Spring AOP 与 <u>AspectJ</u>的关系 [实现类与方法的匹配]</h3><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15949848/6813110">Spring【SpringAOP（通知类型、切点表达式 、多切面配置 、注解配置AOP、原生Spring实现AOP）】(六)-全面详解（学习总结—从入门到深化）_童小纯呀的技术博客_51CTO博客</a></p>
<ul>
<li>Eclips AspectJ 是一种基于Java平台的面向切面编程的语言</li>
<li>Spring AOP使用AspectJWeaver实现类与方法匹配</li>
<li><strong>Spring AOP利用<u>代理模式</u>实现对象运行时功能扩展</strong></li>
</ul>
<h5 id="几个关键概念"><a href="#几个关键概念" class="headerlink" title="几个关键概念"></a>几个关键概念</h5><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面,具体的可插拔组件功能类,通常一个切面只能实现一个通用功能</td>
</tr>
<tr>
<td>Target Class&#x2F;Method</td>
<td>目标类、目标方法,指真正要执行与业务相关的方法</td>
</tr>
<tr>
<td><strong>PointCut</strong></td>
<td>切入点,<strong>使用execution表达式</strong>说明切面要作用再系统的哪些类上</td>
</tr>
<tr>
<td><strong>JoinPoint</strong></td>
<td>连接点,切面运行过程中是包含了目标类&#x2F;方法元数据的对象</td>
</tr>
<tr>
<td>Advice</td>
<td>通知,说明具体的切面的执行时机,Spring包含了不中不同类型通知</td>
</tr>
</tbody></table>
<blockquote>
<p>JoinPoint 连接点,通过连接点可以获取目标类&#x2F;方法的信息<br>public void printExecutionTime(JoinPoint joinPoint){}</p>
</blockquote>
<p><span style = "color:red"><strong>Spring AspectJ AOP实现提供了许多注释：</strong></span></p>
<p><strong>@Aspect</strong> 将该类声明为方面。<br><strong>@Pointcut</strong> 声明切入点表达式。</p>
<p>用于创建建议的注释如下:</p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<h5 id="AOP配置过程"><a href="#AOP配置过程" class="headerlink" title="AOP配置过程"></a>AOP配置过程</h5><ul>
<li>依赖AspectJ</li>
<li>实现切面类&#x2F;方法</li>
<li>配置Aspect Bean</li>
<li>定义PointCut</li>
<li>配置Advice  &#x2F;&#x2F;before通知(Advice)</li>
</ul>
<h3 id="JoinPoint核心方法"><a href="#JoinPoint核心方法" class="headerlink" title="JoinPoint核心方法"></a>JoinPoint核心方法</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object getTarget()</td>
<td>获取IoC容器内目标对象</td>
</tr>
<tr>
<td>Signature getSignature()</td>
<td>获取目标方法</td>
</tr>
<tr>
<td>Object[] getArgs()</td>
<td>获取目标方法<strong>参数</strong></td>
</tr>
</tbody></table>
<pre><code class="java">//很多线上的项目需要跟踪调试却不知道输入的参数是什么 就可以增加切片
public void printExecutionTime(JoinPoint joinPoint)&#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
        String now = sdf.format(new Date());
        String className = joinPoint.getTarget().getClass().getName();//获取类→获取目标类的名称
        String methodName = joinPoint.getSignature().getName();//获取目标方法名称
        System.out.println(&quot;----&gt;&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName);
        Object[] args = joinPoint.getArgs(); //传入目标方法的实际参数
        System.out.println(&quot;----&gt;参数个数:&quot; + args.length);
        for(Object arg:args)&#123;
            System.out.println(&quot;----&gt;参数:&quot; + arg);
        &#125;
    &#125;
</code></pre>
<h3 id="PointCut切点表达式-pointcut"><a href="#PointCut切点表达式-pointcut" class="headerlink" title="PointCut切点表达式 [@pointcut]"></a>PointCut切点表达式 [@pointcut]</h3><p>注释用于定义切入点。我们也可以通过名称引用切入点表达式</p>
<pre><code class="java">@Pointcut(&quot;execution(* Operation.*(..))&quot;)
private void doSomething() &#123;&#125;

//它将应用于所有公共方法
@Pointcut(&quot;execution(public * * (..))&quot;)

//它将应用于Operation类的所有公共方法
@Pointcut(&quot;execution(public Operation.*(..))&quot;)

//它将应用于Operation类的所有方法
@Pointcut(&quot;execution(* Operation.*(..))&quot;)

//它将应用于Employee类的所有公共设置方法
@Pointcut(&quot;execution(public Employee.set*(..))&quot;)

//它将应用于所有返回int值的Operation类方法
@Pointcut(&quot;execution(int Operation.*(..))&quot;)
</code></pre>
<blockquote>
<p>​                   public void com.imooc.service.UserService.createUser(形参1,形参2,..)<br>  ​                    ↑         ↑             ↑                 ↑                 ↑                   ↑                  ↑</p>
<p>execution(public   *     com.imooc       ..                 *       .           *       (          ..          ))<br>*通配符                            ..包通配符[包括所有后代查找]                            (..)参数通配符</p>
<p>第一项public可以默认</p>
</blockquote>
<pre><code class="xml">&lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;/aop:config&gt;

---------------------------------------------------------------------------------
切点表达式训练
&lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
</code></pre>
<h3 id="五种通知类型"><a href="#五种通知类型" class="headerlink" title="五种通知类型"></a>五种通知类型</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Before Advice</td>
<td>前置通知,目标方法运行前执行</td>
</tr>
<tr>
<td>After Returning Advice</td>
<td>返回后通知,目标方法返回数值后执行</td>
</tr>
<tr>
<td>After Throwing Advice</td>
<td>异常通知,目标方法抛出异常后执行</td>
</tr>
<tr>
<td>After Advice</td>
<td>后置通知,目标方法运行后执行</td>
</tr>
<tr>
<td><span style = " color : red"><strong>Around Advice</strong></span></td>
<td><span style = "color:red"><strong>最强大通知,自定通知执行时机,可决定目标方法是否运行</strong></span></td>
</tr>
</tbody></table>
<pre><code class="java">@Around(&quot;execution(* com.imooc..*Service.*(..))&quot;) 【通知 切面表达式】
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
</code></pre>
<p><span style = " color : red"><strong>用于创建建议的注释如下：</strong></span></p>
<p><strong>@Before</strong> 声明before建议。在调用实际方法之前将其应用。<br><strong>@After</strong> 声明after建议。在调用实际方法之后并返回结果之前应用。<br><strong>@AfterReturning</strong> 声明返回建议之后。在调用实际方法之后并返回结果之前应用。但是您可以在建议中获得结果值。<br><strong>@Around</strong> 声明环绕建议。它在调用实际方法之前和之后应用。<br><strong>@AfterThrowing</strong> 声明了throws建议。如果实际方法引发异常，则应用此方法。</p>
<p><span style = " color : red"><strong>让我们看看用于定义建议的xml元素：</strong></span><br><a target="_blank" rel="noopener" href="https://www.cainiaoplus.com/spring/spring-aop-aspectj-xml-configuration-example.html">Spring AOP AspectJ Xml配置示例 - Spring教程 - 菜鸟教程 (cainiaoplus.com)</a><br>**<code>aop: before </code>**在调用实际的业务逻辑方法之前应用。<br>**<code>aop: after </code>**在调用实际的业务逻辑方法之后应用。<br>**<code>aop: 返回后</code>**在调用实际的业务逻辑方法后应用。可用于拦截通知中的返回值。<br>**<code>aop: around </code>**在调用实际的业务逻辑方法之前和之后都将应用。<br>**<code>aop: 投掷后</code>**如果实际的业务逻辑方法抛出异常，则将其应用。</p>
<h5 id="特殊的“通知”-引介增强"><a href="#特殊的“通知”-引介增强" class="headerlink" title="特殊的“通知” - 引介增强"></a>特殊的“通知” - 引介增强</h5><ul>
<li>引介增强是对类的增强,而非方法</li>
<li>引介增强允许再运行时为目标类增加新属性或方法</li>
<li>引介增强允许再运行时改变类的行为,让类随运行环境动态变更</li>
</ul>
<pre><code class="java">MethodAspect.java
    public void doAfter(JoinPoint joinPoint)&#123;
        System.out.println(&quot;&lt;----触发后置通知&quot;);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
</code></pre>
<pre><code class="java">MethodAspect.java
     public void doAfterReturning(JoinPoint joinPoint,Object ret)&#123;
        System.out.println(&quot;&lt;----返回后通知:&quot; + ret);
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    
</code></pre>
<pre><code class="java">MethodAspect.java
public void doAfterThrowing(JoinPoint joinPoint,Throwable th)&#123;
        System.out.println(&quot;&lt;----异常通知:&quot; + th.getMessage());
    &#125;
-----------------------------------------------
applicationContext.xml
&lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

打印顺序根据applicationContext.xml代码排列顺序一致
</code></pre>
<pre><code class="xml">applicationContext.xml [最终]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- AOP配置 迎接新MethodAspect切面的到来--&gt;
    &lt;bean id=&quot;methodAspect&quot; class=&quot;com.imooc.spring.aop.aspect.MethodAspect&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt;
        &lt;!-- PointCut 切点,使用execution表达式描述切面的作用范围 --&gt;
        &lt;!-- execution(public * com.imooc..*.*(..)) 说明切面作用在com.imooc包下的所有类的所有方法上 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(public * com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--只对所有Service类生效--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--只对所有返回值为String类型方法生效--&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(String com.imooc..*Service.*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!--对方法名进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.create*(..))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 对参数进行约束 --&gt;
        &lt;!--&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(String,*))&quot;&gt;&lt;/aop:pointcut&gt;--&gt;
        &lt;!-- 定义切面类 --&gt;
        &lt;aop:aspect ref=&quot;methodAspect&quot;&gt; &lt;!--关联一下--&gt;
            &lt;!-- before通知(Advice),代表在目标方法运行前先执行methodAspect.printExecutionTime() --&gt;
            &lt;aop:before method=&quot;printExecutionTime&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-returning method=&quot;doAfterReturning&quot; returning=&quot;ret&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; throwing=&quot;th&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser(); //模拟创建新用户过程
        userService.generateRandomPassword(&quot;MD5&quot;, 15);
    &#125;
&#125;
===========================================================
----&gt;2024-01-12 13:40:56 885:com.imooc.spring.aop.service.UserService.createUser
----&gt;参数个数:0
&lt;----异常通知:用户已存在
&lt;----触发后置通知
Exception in thread &quot;main&quot; java.lang.RuntimeException: 用户已存在
    
</code></pre>
<hr>
<hr>
<h5 id="Before示例"><a href="#Before示例" class="headerlink" title="@Before示例"></a>@Before示例</h5><p>在实际业务逻辑方法之前应用AspectJ Before Advice。您可以在此处执行任何操作，例如转换，身份验证等。</p>
<p>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    //它将应用于Operation类的所有方法。
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @Before(&quot;k()&quot;)//在before通知上应用切入点
    public void myadvice(JoinPoint jp)//it is advice (before advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
    &lt;bean id=&quot;trackMyBean&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===========================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<h5 id="apo-before示例"><a href="#apo-before示例" class="headerlink" title="apo:before示例"></a>apo:before示例</h5><p>在实际业务逻辑方法之前应用”先行AspectJ建议”。您可以在此处执行任何操作，例如转换，身份验证等。<br>创建一个包含实际业务逻辑的类</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg method invoked&quot;);&#125;
    public int m()&#123;System.out.println(&quot;m method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>现在，创建包含在建议之前的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
public class TrackOperation&#123;
    public void myadvice(JoinPoint jp)//it is advice
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;
</code></pre>
<p>现在创建定义bean的applicationContext.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @Before --&gt;
     &lt;aop:pointcut id=&quot;pointCutBefore&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:before method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutBefore&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
    
&lt;/beans&gt;
</code></pre>
<p>现在，让我们称为实际方法</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling msg...&quot;);
        e.msg();
        System.out.println(&quot;calling m...&quot;);
        e.m();
        System.out.println(&quot;calling k...&quot;);
        e.k();
    &#125;
&#125;

===================================================================
calling msg...
additional concern
msg() method invoked
calling m...
additional concern
m() method invoked
calling k...
additional concern
k() method invoked
</code></pre>
<p>如您所见，在调用msg()，m()和k()方法之前，还会打印出其他问题。</p>
<hr>
<hr>
<h5 id="After示例"><a href="#After示例" class="headerlink" title="@After示例"></a>@After示例</h5><p>在调用实际的业务逻辑方法之后，应用了after建议之后的AspectJ。它可以用来维护日志，安全性，通知等。<br>在这里，我们假设 <strong>Operation.java</strong> ， <strong>applicationContext.xml</strong> 和 <strong>Test.java</strong> 文件与@Before示例中给出的文件相同。</p>
<pre><code class="java">TrackOperation.Java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void k()&#123;&#125;//pointcut name
    
    @After(&quot;k()&quot;)//applying pointcut on after advice
    public void myadvice(JoinPoint jp)//it is advice (after advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        //System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
    &#125;
&#125;

===============================================================
calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<h5 id="aop-after示例"><a href="#aop-after示例" class="headerlink" title="aop:after示例"></a>aop:after示例</h5><p>在调用实际的业务逻辑方法之后，应用了通知之后的AspectJ。它可用于维护日志，安全性，通知等。<br>在这里，我们假设 **<code>Operation.java </code>**， **<code>TrackOperation.java </code>**和 **<code>Test.java </code>**文件与aop:before 中的示例相同。<br>现在创建定义bean的applicationContext.xml文件。</p>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
    http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;
&lt;aop:aspectj-autoproxy /&gt;
&lt;bean id=&quot;opBean&quot; class=&quot;com.nhooo.Operation&quot;&gt;    &lt;/bean&gt;
&lt;bean id=&quot;trackAspect&quot; class=&quot;com.nhooo.TrackOperation&quot;&gt;&lt;/bean&gt;
        
&lt;aop:config&gt;
  &lt;aop:aspect id=&quot;myaspect&quot; ref=&quot;trackAspect&quot; &gt;
     &lt;!-- @After --&gt;
     &lt;aop:pointcut id=&quot;pointCutAfter&quot;    expression=&quot;execution(* com.nhooo.Operation.*(..))&quot; /&gt;
     &lt;aop:after method=&quot;myadvice&quot; pointcut-ref=&quot;pointCutAfter&quot; /&gt;
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<pre><code class="java">calling msg...
msg() method invoked
additional concern
calling m...
m() method invoked
additional concern
calling k...
k() method invoked
additional concern
</code></pre>
<p>您可以看到在调用msg()，m()和k()方法之后，还会出现其他问题。</p>
</blockquote>
<hr>
<hr>
<h5 id="AfterReturning示例"><a href="#AfterReturning示例" class="headerlink" title="@AfterReturning示例"></a>@AfterReturning示例</h5><p>通过在<strong>返回建议后</strong>使用，我们可以在建议中获得结果。创建包含以下内容的类业务逻辑。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public  class Operation&#123;
    public int m()&#123;System.out.println(&quot;m() method invoked&quot;);return 2;&#125;
    public int k()&#123;System.out.println(&quot;k() method invoked&quot;);return 3;&#125;
&#125;
</code></pre>
<p>创建返回建议后包含的方面类</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
@Aspect
public class TrackOperation&#123;
    @AfterReturning(pointcut = &quot;execution(* Operation.*(..))&quot;, returning= &quot;result&quot;)
    
    public void myadvice(JoinPoint jp,Object result)  //it is advice (after returning advice)
    &#123;
        System.out.println(&quot;additional concern&quot;);
        System.out.println(&quot;Method Signature: &quot;  + jp.getSignature());
        System.out.println(&quot;Result in advice: &quot;+result);
        System.out.println(&quot;end of after returning advice...&quot;);
    &#125;
&#125;
</code></pre>
<p>文件: applicationContext.xml    与@Before建议示例中给出的</p>
<p>文件: Test.java   现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation e = (Operation) context.getBean(&quot;opBean&quot;);
        System.out.println(&quot;calling m...&quot;);
        System.out.println(e.m());
        System.out.println(&quot;calling k...&quot;);
        System.out.println(e.k());
    &#125;
&#125;
================================================================
calling m...
m() method invoked
additional concern
Method Signature: int com.nhooo.Operation.m()
Result in advice: 2
end of after returning advice...
2
calling k...
k() method invoked
additional concern
Method Signature: int com.nhooo.Operation.k()
Result in advice: 3
end of after returning advice...
3
</code></pre>
<h3 id="环绕通知-public-Object-check-ProceedingJoinPoint-pjp"><a href="#环绕通知-public-Object-check-ProceedingJoinPoint-pjp" class="headerlink" title="环绕通知 [public Object check(ProceedingJoinPoint pjp)]"></a>环绕通知 [public Object check(ProceedingJoinPoint pjp)]</h3><h5 id="利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化"><a href="#利用AOP进行方法性能筛查-筛查哪个实现时间长-可以进行代码优化" class="headerlink" title="利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]"></a>利用AOP进行方法性能筛查 [筛查哪个实现时间长 可以进行代码优化]</h5><pre><code class="java">dao/UserDao.java
package com.imooc.spring.aop.dao;

/**
 * 用户表Dao
 */
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;

---------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

/**
 * 员工表Dao
 */
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;

/**
 * 员工服务
 */
public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;

---------------------------------
service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;

/**
 * 用户服务
 */
public class UserService &#123;
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000); //沉睡 为了触发环绕通知
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">aspect/MethodChecker.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;

import java.text.SimpleDateFormat;
import java.util.Date;

public class MethodChecker &#123;
    ////ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();//方法执行前
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();//
            long duration = endTime - startTime; //方法执行后 执行时长
            if(duration &gt;= 1000)&#123;//认为执行太慢了 打印信息
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;//方法返回
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.imooc.spring.aop.dao.UserDao&quot;/&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.aop.dao.EmployeeDao&quot;/&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.imooc.spring.aop.service.UserService&quot;&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.aop.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;methodChecker&quot; class=&quot;com.imooc.spring.aop.aspect.MethodChecker&quot;&gt;&lt;/bean&gt;
    &lt;aop:config&gt; &lt;!--所有类进行拦截--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:aspect ref=&quot;methodChecker&quot;&gt;
            &lt;!--环绕通知--&gt;
            &lt;aop:around method=&quot;check&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;

pom.xml
&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;

==============================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 13:52:41 475:com.imooc.spring.aop.service.UserService.createUser(3010ms)======

Process finished with exit code 0
</code></pre>
<hr>
<hr>
<h3 id="Around示例"><a href="#Around示例" class="headerlink" title="@Around示例"></a>@Around示例</h3><p>围绕通知的AspectJ在调用实际的业务逻辑方法之前和之后都得到应用。在这里，我们是假设  <strong>applicationContext.xml</strong> 文件与@Before示例中给出的文件相同。创建一个包含实际业务逻辑的类。</p>
<pre><code class="java">Operation.java
package com.nhooo;
public class Operation&#123;
    public void msg()&#123;System.out.println(&quot;msg() is invoked&quot;);&#125;
    public void display()&#123;System.out.println(&quot;display() is invoked&quot;);&#125;
&#125;
</code></pre>
<p>创建包含围绕建议的方面类。您需要在advice方法中传递  <strong>PreceedingJoinPoint</strong> 引用，以便我们可以通过调用proce来进行请求()方法。文件: TrackOperation.java</p>
<pre><code class="java">TrackOperation.java
package com.nhooo;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
@Aspect
public class TrackOperation
&#123;
    @Pointcut(&quot;execution(* Operation.*(..))&quot;)
    public void abcPointcut()&#123;&#125;
    
    @Around(&quot;abcPointcut()&quot;)
    public Object myadvice(ProceedingJoinPoint pjp) throws Throwable 
    &#123;
        System.out.println(&quot;Additional Concern Before calling actual method&quot;);
        Object obj=pjp.proceed();
        System.out.println(&quot;Additional Concern After calling actual method&quot;);
        return obj;
    &#125;
&#125;
</code></pre>
<p>现在创建调用实际方法的Test类。</p>
<pre><code class="java">Test.java
package com.nhooo;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Test&#123;
    public static void main(String[] args)&#123;
        ApplicationContext context = new classPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Operation op = (Operation) context.getBean(&quot;opBean&quot;);
        op.msg();
        op.display();
    &#125;
&#125;

================================================================
Additional Concern Before calling actual method
msg() is invoked
Additional Concern After calling actual method
Additional Concern Before calling actual method
display() is invoked
Additional Concern After calling actual method
</code></pre>
<h3 id="基于注解配置Spring-AOP"><a href="#基于注解配置Spring-AOP" class="headerlink" title="基于注解配置Spring AOP"></a>基于注解配置Spring AOP</h3><pre><code class="java">aspect/MethodChecher.java
package com.imooc.spring.aop.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;
@Component //标记当前类为组件
@Aspect //说明当前类是切面类
public class MethodChecker &#123;
    //环绕通知,参数为PointCut切点表达式
    @Around(&quot;execution(* com.imooc..*Service.*(..))&quot;)
    // @Before()   @After()   @AfterThrowing   @AfterReturning
    //ProceedingJoinPoint是JoinPoint的升级版,在原有功能外,还可以控制目标方法是否执行
    public Object check(ProceedingJoinPoint pjp) throws Throwable &#123;
        try &#123;
            long startTime = new Date().getTime();
            Object ret = pjp.proceed();//执行目标方法
            long endTime = new Date().getTime();
            long duration = endTime - startTime; //执行时长
            if(duration &gt;= 1000)&#123;
                String className = pjp.getTarget().getClass().getName();
                String methodName = pjp.getSignature().getName();
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);
                String now = sdf.format(new Date());
                System.out.println(&quot;=======&quot; + now + &quot;:&quot; + className + &quot;.&quot; + methodName + &quot;(&quot; + duration + &quot;ms)======&quot;);
            &#125;
            return ret;
        &#125; catch (Throwable throwable) &#123;
            System.out.println(&quot;Exception message:&quot; + throwable.getMessage());
            throw throwable;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">dao/UserDao
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 用户表Dao
 */
@Repository
public class UserDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增用户数据&quot;);
    &#125;
&#125;
----------------------------------------------
dao/EmployeeDao.java
package com.imooc.spring.aop.dao;

import org.springframework.stereotype.Repository;

/**
 * 员工表Dao
 */
@Repository
public class EmployeeDao &#123;
    public void insert()&#123;
        System.out.println(&quot;新增员工数据&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">service/UserService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.UserDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 用户服务
 */
@Service
public class UserService &#123;
    @Resource
    private UserDao userDao;

    public void createUser()&#123;
        try &#123;
            Thread.sleep(3000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        userDao.insert();
    &#125;

    public String generateRandomPassword(String type , Integer length)&#123;
        System.out.println(&quot;按&quot; + type + &quot;方式生成&quot;+ length  + &quot;位随机密码&quot;);
        return &quot;Zxcquei1&quot;;
    &#125;

    public UserDao getUserDao() &#123;
        return userDao;
    &#125;

    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
&#125;
---------------------------------------------------------
service/EmployeeService.java
package com.imooc.spring.aop.service;

import com.imooc.spring.aop.dao.EmployeeDao;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * 员工服务
 */
@Service
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    public void entry()&#123;
        System.out.println(&quot;执行员工入职业务逻辑&quot;);
        employeeDao.insert();
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
        userService.createUser();
    &#125;
&#125;
========================================================================
执行员工入职业务逻辑
新增用户数据
=======2024-01-12 17:06:18 669:com.imooc.spring.aop.service.UserService.createUser(3015ms)======

Process finished with exit code 0
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!--初始化IoC容器--&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
  ★  &lt;!--启用Spring AOP注解模式--&gt; ★
    &lt;aop:aspectj-autoproxy/&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="增加了是说明这个类是需要被IoC实例化的"><a href="#增加了是说明这个类是需要被IoC实例化的" class="headerlink" title="增加了是说明这个类是需要被IoC实例化的"></a>增加了是说明这个类是需要被IoC实例化的</h6><ul>
<li>四种组件类型注解-声明当前类的功能与职责 【回忆上面的知识点】</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>组件注解,通用注解,被该注解描述的类将被IoC容器管理并实例化</td>
</tr>
<tr>
<td><strong>@Controller</strong></td>
<td>语义注解,说明当前类是MVC应用中的控制器类</td>
</tr>
<tr>
<td><strong>@Service</strong></td>
<td>语义注解,说明当前类是Service业务服务类</td>
</tr>
<tr>
<td><strong>@Repository</strong></td>
<td>语义注解,说明当前类用于业务持久层,通常描述对应Dao类</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP实现原理"><a href="#Spring-AOP实现原理" class="headerlink" title="Spring AOP实现原理"></a>Spring AOP实现原理</h3><h6 id="★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★"><a href="#★★★★★-面试-Spring-AOP-底层的实现原理-★★★★★★" class="headerlink" title="★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★"></a><span style = "color:red">★★★★★ 面试 Spring AOP 底层的实现原理 ★★★★★★</span></h6><ul>
<li><span style = "color:blue">Spring基于<strong>代理模式</strong>实现功能动态扩展，包含两种形式：</span><ul>
<li><strong><span style = "color:blue">目标类拥有接口，通过JDK动态代理实现功能扩展 来实现目标类的代理从而实现扩展</span></strong></li>
<li><strong><span style = "color:blue">目标类没有接口，通过CGLib组件实现功能扩展 通过继承的方式实现扩展</span></strong></li>
</ul>
</li>
</ul>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ul>
<li>代理模式通过代理对象对原对象的实现功能扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/1d5a848e492cf6e991719bfdc5cbbd31ef8a31fb/data/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></p>
<p>基于UserService接口实现代理类 同时持有与之对应的具体实现</p>
<h6 id="静态代理-每一个具体的委托类都要手动创造一个代理类"><a href="#静态代理-每一个具体的委托类都要手动创造一个代理类" class="headerlink" title="静态代理 [每一个具体的委托类都要手动创造一个代理类]"></a>静态代理 [每一个具体的委托类都要手动创造一个代理类]</h6><pre><code class="java">aop/service/UserService [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;
-------------------------------------
aop/service/UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy.java [代理]
package com.imooc.spring.aop.service;

import java.text.SimpleDateFormat;
import java.util.Date;
//静态代理是指必须手动创建代理类的代理模式使用方式
public class UserServiceProxy implements UserService&#123;
    //持有委托类的对象
    private UserService userService;
    public UserServiceProxy(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        userService.createUser();
    &#125;
&#125;
-------------------------------------
aop/service/UserServiceProxy1.java [代理1]
package com.imooc.spring.aop.service;

public class UserServiceProxy1 implements UserService&#123;
    private UserService userService ;
    public UserServiceProxy1(UserService userService)&#123;
        this.userService = userService;
    &#125;

    public void createUser() &#123;
        userService.createUser();
        System.out.println(&quot;========后置扩展功能======&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.imooc.spring.aop;

import com.imooc.spring.aop.service.UserService;
import com.imooc.spring.aop.service.UserServiceImpl;
import com.imooc.spring.aop.service.UserServiceProxy;
import com.imooc.spring.aop.service.UserServiceProxy1;

public class Application &#123;
    public static void main(String[] args) &#123; //类似于二房东
        UserService userService = new UserServiceProxy1(new UserServiceProxy(new UserServiceImpl()));
        userService.createUser();
    &#125;
&#125;
</code></pre>
<h3 id="AOP底层逻辑—JDK动态代理"><a href="#AOP底层逻辑—JDK动态代理" class="headerlink" title="AOP底层逻辑—JDK动态代理"></a>AOP底层逻辑—JDK动态代理</h3><pre><code class="java">aop/service.UserService.java [接口]
package com.imooc.spring.aop.service;

public interface UserService &#123;
    public void createUser();
&#125;


-------------------------------------
aop/service.EmployeeService.java [接口]
package com.imooc.spring.aop.service;

public interface EmployeeService &#123;
    public void createEmployee();
&#125;
</code></pre>
<pre><code class="java">aop/service.EmployeeServiceImpl.java
package com.imooc.spring.aop.service;

public class EmployeeServiceImpl implements EmployeeService &#123;
    public void createEmployee() &#123;
        System.out.println(&quot;执行创建员工业务逻辑&quot;);
    &#125;
&#125;
--------------------------------------
aop/service.UserServiceImpl.java
package com.imooc.spring.aop.service;

public class UserServiceImpl implements UserService&#123;
    public void createUser() &#123;
        System.out.println(&quot;执行创建用户业务逻辑&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">ProxyInvocationHandler.java
package com.imooc.spring.aop.service;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * InvocationHandler是JDK提供的反射类,用于在JDK动态代理中对目标方法进行增强
 * InvocationHandler实现类与切面类的环绕通知类似
 */
public class ProxyInvocationHandler implements InvocationHandler &#123;
    private Object target;//目标对象
    private ProxyInvocationHandler(Object target)&#123;
        this.target = target;
    &#125;
    /**
     * 在invoke()方法对目标方法进行增强 反射method方法的时候遇见过invoke
     * @param proxy 代理类对象
     * @param method 目标方法对象
     * @param args 目标方法实参
     * @return 目标方法运行后返回值
     * @throws Throwable 目标方法抛出的异常
     */
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;=====&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;).format(new Date()) +&quot;=========&quot;);
        Object ret = method.invoke(target, args);//调用目标方法,ProceedingJoinPoint.proceed()
        return ret;
    &#125;

    public static void main(String[] args) &#123;
        UserService userService = new UserServiceImpl();
        ProxyInvocationHandler invocationHandler = new ProxyInvocationHandler(userService);
        //动态创建代理类
        UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),
                userService.getClass().getInterfaces(),
                invocationHandler);
        userServiceProxy.createUser();

        //动态代理,必须实现接口才可以运行
        EmployeeService employeeService = new EmployeeServiceImpl();
        EmployeeService employeeServiceProxy = (EmployeeService)Proxy.newProxyInstance(employeeService.getClass().getClassLoader(),
                employeeService.getClass().getInterfaces(),
                new ProxyInvocationHandler(employeeService));
        employeeServiceProxy.createEmployee();
    &#125;
&#125;

=======================================================

=====2024-01-12 19:52:34 179=========
执行创建用户业务逻辑
=====2024-01-12 19:52:34 181=========
执行创建员工业务逻辑

Process finished with exit code 0
</code></pre>
<img src="https://raw.githubusercontent.com/P-luminary/images/7942f4deaa97d742e38e14b1326c7064e1a28f50/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png"  />





<h3 id="AOP底层逻辑—CGLib实现代理类"><a href="#AOP底层逻辑—CGLib实现代理类" class="headerlink" title="AOP底层逻辑—CGLib实现代理类"></a>AOP底层逻辑—CGLib实现代理类</h3><ul>
<li>CGLib是运行时字节码增强技术</li>
<li>Spring AOP扩展无接口类使用CGLib</li>
<li>AOP会运行时生成目标继承类字节码的方式进行行为扩展</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/7aa4a34eb72920c28d071577e2c074f4cf266e1a/data/AOP%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E2%80%94CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB.jpg"></p>
<img src="https://raw.githubusercontent.com/P-luminary/images/107a911bbe025f10f9f6629b01583a222956ca9f/data/CGLib%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%B1%BB%20%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" style="zoom:80%;" />



<h3 id="Spring-JDBC与事务管理"><a href="#Spring-JDBC与事务管理" class="headerlink" title="Spring JDBC与事务管理"></a>Spring JDBC与事务管理</h3><h5 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h5><ul>
<li>Spring JDBC是Spring框架用于处理关系型数据库的模块</li>
<li>Spring JDBC对JDBC API进行封装，极大简化开发工作量</li>
<li>JdbcTemplate是Spring JDBC核心类, 提供数据CRUD方法</li>
</ul>
<h5 id="为什么有了Mybatis还需要Spring-JDBC？"><a href="#为什么有了Mybatis还需要Spring-JDBC？" class="headerlink" title="为什么有了Mybatis还需要Spring JDBC？"></a>为什么有了Mybatis还需要Spring JDBC？</h5><p>因为这两者面向的对象是不一样的<br><strong>mybatis 封装程度</strong>高适合中小企业敏捷开发, 快速完成与数据库交互的工作, 封装程度高 执行效率低【慢】<br>Spring JDBC只是对原始的JDBC的API进行了简单封装 大厂使用【轻量级】可二次封装</p>
<h3 id="Spring-JDBC的使用步骤"><a href="#Spring-JDBC的使用步骤" class="headerlink" title="Spring JDBC的使用步骤"></a>Spring JDBC的使用步骤</h3><ul>
<li><p>Maven工程引入依赖<code>spring-jdbc</code></p>
</li>
<li><p>applicationContext.xml配置<code>DataSource</code>数据源 [<u>用于指向连接哪数据库的哪种服务器 账号密码都是啥</u>]</p>
</li>
<li><p>在Dao注入<code>JdbcTemplate</code>对象, 实现数据CRUD</p>
</li>
</ul>
<h2 id="JdbcTemplate类"><a href="#JdbcTemplate类" class="headerlink" title="JdbcTemplate类"></a>JdbcTemplate类</h2><h6 id="Spring-JdbcTemplate类的方法"><a href="#Spring-JdbcTemplate类的方法" class="headerlink" title="Spring JdbcTemplate类的方法"></a>Spring JdbcTemplate类的方法</h6><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int update(String query)</td>
<td>用于插入，更新和删除记录。</td>
</tr>
<tr>
<td>public int update(String query，Object … args)</td>
<td>用于通过使用给定参数的PreparedStatement插入，更新和删除记录。</td>
</tr>
<tr>
<td>public void execute(String query)</td>
<td>用于执行DDL查询。</td>
</tr>
<tr>
<td>public T execute(String sql, PreparedStatementCallback action)</td>
<td>通过使用PreparedStatement回调执行查询。</td>
</tr>
<tr>
<td>public T query(String sql, ResultSetExtractor rse)</td>
<td>用于使用ResultSetExtractor获取记录。</td>
</tr>
<tr>
<td>public List query(String sql, RowMapper rse)</td>
<td>用于使用RowMapper获取记录。</td>
</tr>
</tbody></table>
<h3 id="JdbcTemplate实现增删改查"><a href="#JdbcTemplate实现增删改查" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml [SpringIoC基础配置文件]
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
&lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API 让IoC容器初始化的时候自动实例化jdbcTemplate 实例化的过程中要将设置好的数据源dataSource注入到jdbcTemplate属性中 此时就完成了实例化--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
&lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;

    @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
&#125; +Setter Getter
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">SpringApplication.java
package com.imooc.spring.jdbc;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class SpringApplication &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        EmployeeDao employeeDao = context.getBean(&quot;employeeDao&quot;, EmployeeDao.class);
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);

    &#125;
&#125;

=======================================================
Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;

Process finished with exit code 0
</code></pre>
<h3 id="JdbcTemplate的数据查询方法"><a href="#JdbcTemplate的数据查询方法" class="headerlink" title="JdbcTemplate的数据查询方法"></a>JdbcTemplate的数据查询方法</h3><pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class EmployeeDao &#123;
/*    依赖与jdbcTemplate 要持有其
* &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
* */
    private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        //查询单条数据 转换成对象
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;
    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据                             sql  对应的参数数组  转换的Mapper对象
        //多条记录 每一条记录转换为一个实体对象 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;yan&#39;fa&#39;bu&quot;));
    &#125;
&#125;
================================================================
[Employee&#123;eno=3308, ename=&#39;张三&#39;, salary=6000.0, dname=&#39;研发部&#39;, hiredate=2011-05-08 00:00:00.0&#125;, Employee&#123;eno=3420, ename=&#39;李四&#39;, salary=8700.0, dname=&#39;研发部&#39;, hiredate=2006-11-11 00:00:00.0&#125;]


Process finished with exit code 0
</code></pre>
<pre><code class="java">★★ 新增 ★★
在没有对应的实体类情况下也可以得到相应的结果 结果被封装成为了Map对象
EmployeeDao.java
//    按列表返回每一条按Map对象列表返回
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;


JdbcTemplateTestor.java
@Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;
================================================================
[&#123;empno=3308, a=6000.0&#125;, &#123;empno=3420, a=8700.0&#125;]

Process finished with exit code 0
</code></pre>
<pre><code class="java">总结  [★★★★ queryForObject query queryForList ★★★★]
 private JdbcTemplate jdbcTemplate;
    public Employee findById(Integer eno)&#123;
//      //将唯一转换的数据返回对应的对象 jdbcTemplate为了运行时的动态注入
        String sql = &quot;select * from employee where eno=?&quot;;
        //将bean属性与每一行的一一对应   数据库记录到实体对象的转换
        // ★★查询单条数据 转换成对象 ★★
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        // ★★查询复合数据★★                      sql  对应的参数数组  转换的Mapper对象
        // ★★多条记录 每一条记录转换为一个实体对象★★ 放入List集合中进行返回
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

//    按列表返回每一条按Map对象列表返回
//特殊情况：无法进行实体类的映射则可用直接用queryForList特殊返回Map 来完成对应数据的封装
    public List findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno, salary as a from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

</code></pre>
<h3 id="JdbcTemplate实现增删改查-1"><a href="#JdbcTemplate实现增删改查-1" class="headerlink" title="JdbcTemplate实现增删改查"></a>JdbcTemplate实现增删改查</h3><pre><code class="java">★★ 增 ★★
EmployeeDao.java
public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        jdbcTemplate.update(sql,new Object[]&#123;
                employee.getEno(), employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate()
        &#125;);
    &#125;

JdbcTemplateTestor.java
@Test
    public void testinsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;


★★ 更新 ★★
EmployeeDao.java
public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename=?, salary=?, dname=?, hiredate=? WHERE eno=?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次更新1条数据

Process finished with exit code 0


★★ 删除 ★★
EmployeeDao.java
public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno=?&quot;;
        int update = jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
        return update;
    &#125;

JdbcTemplateTestor.java
@Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;
=========================================================
本次删除1条数据
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul>
<li>事务式以一种可靠、一致的方法，访问和操作数据库的程序单元</li>
<li>说人话：要么把事情做完，要么什么都不做，不要做一半</li>
<li>事务依赖于数据库实现，MySQL通过<strong>事务区</strong>作为数据缓冲地带</li>
</ul>
<h3 id="编程式事务-手动控制啥时候提交-啥时候回滚"><a href="#编程式事务-手动控制啥时候提交-啥时候回滚" class="headerlink" title="编程式事务 [手动控制啥时候提交 啥时候回滚]"></a>编程式事务 [手动控制啥时候提交 啥时候回滚]</h3><ul>
<li>编程式事务是指通过代码手动提交回滚事务的事务控制方法</li>
<li>SpringJDBC通过TransactionManager事务管理器实现事务控制</li>
<li>事务管理器提供commit&#x2F;rollback方法进行事务提交与回滚</li>
</ul>
<blockquote>
<p>S1需求：公司来了10名新员工 批量导入员工表中 (要么什么都不做，要么把事情做完) 【类似银行存钱】</p>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    public void bathImport()&#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;



applicationContext.xml
&lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

    

JdbcTemplateTestor.java
@Resource
    private EmployeeService employeeService;
@Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

此方法是一条一条的增加写入sql操作
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.565 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.567 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.684 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.564&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
09:47:33.690 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL statement [insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)]
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DataSourceUtils - Fetching JDBC Connection from DataSource
09:47:33.690 [main] DEBUG org.springframework.jdbc.datasource.DriverManagerDataSource - Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - SQLWarning ignored: SQL state &#39;22007&#39;, error code &#39;1292&#39;, message [Incorrect date value: &#39;2024-01-14 09:47:33.69&#39; for column &#39;hiredate&#39; at row 1]
09:47:33.695 [main] DEBUG org.springframework.jdbc.core.JdbcTemplate - Executing prepared SQL update
</code></pre>
<hr>
<hr>
<h3 id="编程式事务-2-放入事务区统一管理"><a href="#编程式事务-2-放入事务区统一管理" class="headerlink" title="编程式事务-2 [放入事务区统一管理]"></a>编程式事务-2 [放入事务区统一管理]</h3><pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private DataSourceTransactionManager transactionManager;
    public void bathImport()&#123;
        //定义了事务默认的标准配置
        TransactionDefinition definition = new DefaultTransactionDefinition();
        //开始一个事务 放在事务区中统一进行管理
        TransactionStatus status = transactionManager.getTransaction(definition);

        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                if (i==3)&#123;
                    throw new RuntimeException(&quot;意料之外的异常&quot;);
                &#125;
                Employee employee = new Employee();
                employee.setEno(8010 + i);
                employee.setEname(&quot;员工&quot; + i);
                employee.setSalary(4000f);
                employee.setDname(&quot;市场部&quot;);
                employee.setHiredate(new Date());
                employeeDao.insert(employee);
            &#125;
            //提交事务
            transactionManager.commit(status);
        &#125; catch (Exception e) &#123;
            //回滚事务
            transactionManager.rollback(status);
            e.printStackTrace();
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public DataSourceTransactionManager getTransactionManager() &#123;
        return transactionManager;
    &#125;

    public void setTransactionManager(DataSourceTransactionManager transactionManager) &#123;
        this.transactionManager = transactionManager;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;!-- 数据源设置：使用哪种服务器 哪种数据源 账号密码是什么 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--    创建数据库连接 找数据源    JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--    为Dao注入JdbcTemplate对象 --&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
&lt;!--     将属性进行注入 要添加其getter setter--&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    事务管理器 数据源  [整体提交以及回滚] 需要控制的类中注入bean id=&quot;transactionManager&quot; --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById() &#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname() &#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname() &#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testinsert() &#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void testUpdate() &#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testDelete() &#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.bathImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;
&#125;

========================================================
都是在一个数据库连接里操作的
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Initiating transaction rollback
10:01:16.165 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Rolling back JDBC transaction on Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337]
10:01:16.166 [main] DEBUG org.springframework.jdbc.datasource.DataSourceTransactionManager - Releasing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c88a337] after transaction
java.lang.RuntimeException: 意料之外的异常
    at com.imooc.spring.jdbc.service.EmployeeService.bathImport(EmployeeService.java:24)
    at JdbcTemplateTestor.testBatchImport(JdbcTemplateTestor.java:63)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
</code></pre>
<p>★★★ 编程式事务 ★★★<br>优点：容易理解 编程快<br>缺点：容易受到人为因素影响 结果致命</p>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><ul>
<li>声明式事务指在<strong>不修改源代码</strong>情况下通过配置形式自动实现事务控制, 声明式事务本质就是AOP环绕通知</li>
<li>当目标方法执行成功时, 自动提交事务</li>
<li>当目标方法抛出运行异常时, 自动事务回滚</li>
</ul>
<h5 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h5><ul>
<li>配置TransactionManager事务管理器</li>
<li>配置事务通知与事务属性</li>
<li>为事务通知绑定PointCut切点</li>
</ul>
<blockquote>
<p>需求：在不修改原始代码的情况下 配置Service里面的声明式事务</p>
</blockquote>
<pre><code class="xml">pom.xml
&lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
 &lt;!-- ★★★★ 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用  propagation是事务传播行为★★★★--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 不支持事务--&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">EmployeeService.java
vpackage com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            //注意噢 这里是被注释的
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">EmployeeDao.java 未改变
</code></pre>
<pre><code class="java">JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<h3 id="事务传播行为【面试】"><a href="#事务传播行为【面试】" class="headerlink" title="事务传播行为【面试】"></a>事务传播行为【面试】</h3><p><img src="https://raw.githubusercontent.com/P-luminary/images/dfcdce285d42fc77d69cb614b61e298b10a7252a/data/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E4%B8%83%E7%A7%8D%E7%B1%BB%E5%9E%8B.jpg"></p>
<ul>
<li>事务传播行为是指多个拥有事务的方法在嵌套调用时的事务控制方式</li>
<li><code>XML:&lt;tx:method name=&quot;...&quot; propagation=&quot;REQUIRED&quot;/&gt;</code></li>
<li>注解: <code>@Transactional(propagation=Propagation.REQUIRED)</code></li>
</ul>
<blockquote>
<p>加个BatchService 然后在EmployeeService加一个private BatchService batchService;(getter + setter)  再次插入一个public void startImportJob()<br>进行applicationContext.xml的bean注入<br><bean id="batchService" class="com.imooc.spring.jdbc.service.BatchService"><br>    <property name="employeeDao" ref="employeeDao"/><br></bean></p>
<bean id="employeeService" class="com.imooc.spring.jdbc.service.EmployeeService">
    <property name="employeeDao" ref="employeeDao"/>
    <property name="batchService" ref="batchService"/>
</bean>

<p>会被声明式事务范围包裹噢<br>&lt;aop:pointcut id&#x3D;”pointcut” expression&#x3D;”execution(* com.imooc..*Service.*(..))”&#x2F;&gt;</p>
<pre><code class="java">applicationContext.xml
加入 importJob1 importJob2
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
</code></pre>
<p>补充public void startImportJob()</p>
<pre><code class="java">public void startImportJob()&#123;
    //会有关联行为 若2失败则无法导入 1也会回滚
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

//方法： REQUIRES_NEW 不同方法运行在不同事务中 
//事务1开始 事务1挂起事务2开始 事务2提交 事务1恢复 事务1挂起事务3开始 事务3提交事务1恢复 事务1提交
          &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
上面的分这写
</code></pre>
</blockquote>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;
 
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;
public class BatchService &#123;

    private EmployeeDao employeeDao;

    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;

import java.util.Date;

public class EmployeeService &#123;
    private EmployeeDao employeeDao;
    private BatchService batchService;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
//            if(i==3)&#123;
//                throw new RuntimeException(&quot;意料之外的异常&quot;);
//            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
public class EmployeeDao &#123;
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;!-- 数据源 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate提供数据CRUD的API--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeDao&quot; class=&quot;com.imooc.spring.jdbc.dao.EmployeeDao&quot;&gt;
        &lt;!--为Dao注入JdbcTemplate对象--&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employeeService&quot; class=&quot;com.imooc.spring.jdbc.service.EmployeeService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
        &lt;property name=&quot;batchService&quot; ref=&quot;batchService&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;batchService&quot; class=&quot;com.imooc.spring.jdbc.service.BatchService&quot;&gt;
        &lt;property name=&quot;employeeDao&quot; ref=&quot;employeeDao&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    1-3具体含义：当我们目标方法是imooc包下Service 且方法名为batchImport的时候 则认为当前方法需要使用事务--&gt;
&lt;!--    利用transactionManager来完成对事务的提交以及回滚--&gt;

    &lt;!-- 1.事务管理器,用于创建事务/提交/回滚 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--2.事务通知配置,决定哪些方法使用事务,哪些方法不使用事务 advice是通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 目标方法名为batchImport时,启用声明式事务,成功提交,运行时异常回滚 propagation=&quot;REQUIRED&quot;需要使用--&gt;
            &lt;tx:method name=&quot;batchImport&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;batch*&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;!-- 设置所有findXXX方法不需要使用事务 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;get*&quot; propagation=&quot;NOT_SUPPORTED&quot; read-only=&quot;true&quot;/&gt;

            &lt;tx:method name=&quot;importJob1&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;importJob2&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--3. 定义声明式事务的作用范围--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc..*Service.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="java">jdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="注解配置声明式事务"><a href="#注解配置声明式事务" class="headerlink" title="注解配置声明式事务"></a>注解配置声明式事务</h3><pre><code class="java">//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
写在类上就是所有 
写在方法就是单独方法运用
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/dao/EmployeeDao.java
package com.imooc.spring.jdbc.dao;

import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
@Repository
public class EmployeeDao &#123;
    @Resource
    private JdbcTemplate jdbcTemplate;

    public Employee findById(Integer eno)&#123;
        String sql = &quot;select * from employee where eno = ?&quot;;
        //查询单条数据
        Employee employee = jdbcTemplate.queryForObject(sql, new Object[]&#123;eno&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return employee;
    &#125;

    public List&lt;Employee&gt; findByDname(String dname)&#123;
        String sql = &quot;select * from employee where dname = ?&quot;;
        //查询复合数据
        List&lt;Employee&gt; list = jdbcTemplate.query(sql, new Object[]&#123;dname&#125;, new BeanPropertyRowMapper&lt;Employee&gt;(Employee.class));
        return list;
    &#125;

    public List&lt;Map&lt;String, Object&gt;&gt; findMapByDname(String dname)&#123;
        String sql = &quot;select eno as empno , salary as s from employee where dname = ?&quot;;
        //将查询结果作为Map进行封装
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql, new Object[]&#123;dname&#125;);
        return maps;
    &#125;

    public void insert(Employee employee)&#123;
        String sql = &quot;insert into employee(eno,ename,salary,dname,hiredate) values(?,?,?,?,?)&quot;;
        //利用update方法实现数据写入操作
        jdbcTemplate.update(sql,new Object[]&#123;
           employee.getEno() , employee.getEname(),employee.getSalary(),employee.getDname() , employee.getHiredate()
        &#125;);
    &#125;

    public int update(Employee employee)&#123;
        String sql = &quot;UPDATE employee SET ename = ?, salary = ?, dname = ?, hiredate = ? WHERE eno = ?&quot;;
        int count = jdbcTemplate.update(sql, new Object[]&#123;employee.getEname(), employee.getSalary(), employee.getDname(), employee.getHiredate(), employee.getEno()&#125;);
        return count;
    &#125;

    public int delete(Integer eno)&#123;
        String sql = &quot;delete from employee where eno = ?&quot;;
        return jdbcTemplate.update(sql, new Object[]&#123;eno&#125;);
    &#125;


    public JdbcTemplate getJdbcTemplate() &#123;
        return jdbcTemplate;
    &#125;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;
        this.jdbcTemplate = jdbcTemplate;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/entity/Employee.java
public class Employee &#123;
    private Integer eno;
    private String ename;
    private Float salary;
    private String dname;
    private Date hiredate;
&#125; getter+setter
     @Override
    public String toString() &#123;
        return &quot;Employee&#123;&quot; +
                &quot;eno=&quot; + eno +
                &quot;, ename=&#39;&quot; + ename + &#39;\&#39;&#39; +
                &quot;, salary=&quot; + salary +
                &quot;, dname=&#39;&quot; + dname + &#39;\&#39;&#39; +
                &quot;, hiredate=&quot; + hiredate +
                &#39;&#125;&#39;;
    &#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/BatchService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.sun.xml.internal.ws.developer.Serialization;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//不需要使用事务 只读操作
@Transactional(propagation = Propagation.NOT_SUPPORTED,readOnly = true)
public class BatchService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob1()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;研发部员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;研发部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void importJob2()&#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            Employee employee = new Employee();
            employee.setEno(9000 + i);
            employee.setEname(&quot;市场部员工&quot; + i);
            employee.setSalary(4500f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/imooc/spring/jdbc/service/EmployeeService.java
package com.imooc.spring.jdbc.service;

import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.Date;
@Service
//声明式事务核心注解
//放在类上,将声明式事务配置应用于当前类所有方法,默认事务传播为 REQUIRED
@Transactional(propagation = Propagation.REQUIRED) //不写也默认
public class EmployeeService &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private BatchService batchService;

    @Transactional(propagation = Propagation.NOT_SUPPORTED , readOnly = true)
    public Employee findById(Integer eno)&#123;
        return employeeDao.findById(eno);
    &#125;

    public void batchImport() &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if(i==3)&#123;
                throw new RuntimeException(&quot;意料之外的异常&quot;);
            &#125;
            Employee employee = new Employee();
            employee.setEno(8000 + i);
            employee.setEname(&quot;员工&quot; + i);
            employee.setSalary(4000f);
            employee.setDname(&quot;市场部&quot;);
            employee.setHiredate(new Date());
            employeeDao.insert(employee);
        &#125;
    &#125;

    public void startImportJob()&#123;
        batchService.importJob1();
        if(1==1)&#123;
            throw new RuntimeException(&quot;意料之外的异常&quot;);
        &#125;
        batchService.importJob2();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    public EmployeeDao getEmployeeDao() &#123;
        return employeeDao;
    &#125;

    public void setEmployeeDao(EmployeeDao employeeDao) &#123;
        this.employeeDao = employeeDao;
    &#125;

    public BatchService getBatchService() &#123;
        return batchService;
    &#125;

    public void setBatchService(BatchService batchService) &#123;
        this.batchService = batchService;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">applicationContext.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;
    &lt;!--数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot;
                  value=&quot;jdbc:mysql://localhost:3306/imooc?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--JdbcTemplate--&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
    &lt;!-- 启用注解形式声明式事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.imooc.spring&lt;/groupId&gt;
    &lt;artifactId&gt;jdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.16&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--logback日志组件,Spring框架默认集成--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">test/java/JdbcTemplateTestor.java
import com.imooc.spring.jdbc.dao.EmployeeDao;
import com.imooc.spring.jdbc.entity.Employee;
import com.imooc.spring.jdbc.service.EmployeeService;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import java.util.Date;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)
public class JdbcTemplateTestor &#123;
    @Resource
    private EmployeeDao employeeDao;
    @Resource
    private EmployeeService employeeService;

    @Test
    public void testFindById()&#123;
        Employee employee = employeeDao.findById(3308);
        System.out.println(employee);
    &#125;

    @Test
    public void testFindByDname()&#123;
        System.out.println(employeeDao.findByDname(&quot;市场部&quot;));
    &#125;

    @Test
    public void testFindMapByDname()&#123;
        System.out.println(employeeDao.findMapByDname(&quot;研发部&quot;));
    &#125;

    @Test
    public void testInsert()&#123;
        Employee employee = new Employee();
        employee.setEno(8888);
        employee.setEname(&quot;赵六&quot;);
        employee.setSalary(6666f);
        employee.setDname(&quot;研发部&quot;);
        employee.setHiredate(new Date());
        employeeDao.insert(employee);
    &#125;

    @Test
    public void  testUpdate()&#123;
        Employee employee = employeeDao.findById(8888);
        employee.setSalary(employee.getSalary() + 1000);
        int count = employeeDao.update(employee);
        System.out.println(&quot;本次更新&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void  testDelete()&#123;
        int count = employeeDao.delete(8888);
        System.out.println(&quot;本次删除&quot; + count + &quot;条数据&quot;);
    &#125;

    @Test
    public void testBatchImport()&#123;
        employeeService.batchImport();
        System.out.println(&quot;批量导入成功&quot;);
    &#125;

    @Test
    public void testStartImportJob()&#123;
        employeeService.startImportJob();
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/12/09/后端/Spring(切点表达式,通知,AOP,CGLib代理,Spring JdbcTemplate,事务)/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/19/英语/四级作文-新/">
        <h2>
            四级作文(新)
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="作文评分原则"><a href="#作文评分原则" class="headerlink" title="作文评分原则"></a>作文评分原则</h3><h6 id="内容：50-结构：10-语言：40"><a href="#内容：50-结构：10-语言：40" class="headerlink" title="内容：50%    结构：10%    语言：40%"></a>内容：50%    结构：10%    语言：40%</h6><ol>
<li>充实文章的内容：七种方法</li>
<li>固定文章的结构：总分总</li>
<li>丰富文章的语言：读范文；讲句型；躲错误；备模板</li>
</ol>
<h1 id="特点一：内容充实"><a href="#特点一：内容充实" class="headerlink" title="特点一：内容充实"></a><span style = "color:orange">特点一：内容充实</span></h1><h6 id="expert-testimony-专家证言法"><a href="#expert-testimony-专家证言法" class="headerlink" title="expert testimony 专家证言法"></a><span style = "color:blue">expert testimony 专家证言法</span></h6><p><strong>declare</strong> 宣称,声称 (替代think)<br><strong>claim</strong> (替代think)<br><del>exclaim 大叫(shout , yell)</del></p>
<p><strong>① It is plain common sense from those authoritative research that…</strong><br><strong>② Based on their findings, the experts claim that…</strong></p>
<h6 id="statistics-统计数据法"><a href="#statistics-统计数据法" class="headerlink" title="statistics 统计数据法"></a><span style = "color:blue">statistics 统计数据法</span></h6><p>reduce<br>dramatically</p>
<p><strong>① According to a recent survey, thousands of people has found 80% of respondents claimed that…</strong></p>
<h6 id="example-举例子-文章字不够举例子来凑-2个"><a href="#example-举例子-文章字不够举例子来凑-2个" class="headerlink" title="example 举例子 (文章字不够举例子来凑) (2个)"></a><span style = "color:red">example 举例子</span> (文章字不够举例子来凑) (2个)</h6><p>deal with &#x3D; cope with &#x3D; dispose of (解决)<br>efficiently(有效地) &#x2F; effective(有效率的)<br><strong>concentrate on</strong> &#x3D; pay attention to &#x3D; <strong>absorb in</strong> &#x3D; dedicate to &#x3D; indulge in &#x3D; focus on</p>
<p><strong>① Taking a look around, we can find the following examples in our daily lives.</strong><br><strong>② A good case in point is that…</strong><br><strong>③ As an illustration, we may take …as an example.</strong><br><strong>④ A typical example of this is that…</strong><br><u>A typical example of this is that</u> in most families, there is only one child who is loved by not only patents, but also grandparents.</p>
<h6 id="personal-experience-个人经历"><a href="#personal-experience-个人经历" class="headerlink" title="personal experience 个人经历"></a><span style = "color:blue">personal experience 个人经历</span></h6><h6 id="Logic-amp-Reasoning-逻辑推理"><a href="#Logic-amp-Reasoning-逻辑推理" class="headerlink" title="Logic &amp; Reasoning 逻辑推理"></a><span style = "color:blue">Logic &amp; Reasoning 逻辑推理</span></h6><p>​    <strong>分析原因段</strong> (一般都是第二段)<br>​    ① 三个原因 + 一个例子<br>​    ② 两个原因 + 两个例子</p>
<p>​    <strong>解决问题段</strong><br>​    deal with &#x3D; cope with &#x3D; dispose of (解决)</p>
<p>​    ① <strong>国家</strong>政府角度谈 (权威)<br>​    ② 全<strong>社会</strong>人民角度谈 (广泛)<br>​    ③ 就我<strong>个人</strong>而言 (个人)</p>
<h6 id="known-facts-常识法"><a href="#known-facts-常识法" class="headerlink" title="known facts 常识法"></a><span style = "color:blue">known facts 常识法</span></h6><p>consider&#x2F;considerate(adj)<br>consideration(共同的名词词性)[考虑&#x2F;]<br>take sth. into consideration</p>
<p><strong>① It is truism that…</strong><br><strong>② It comes to light that…</strong></p>
<h6 id="analogy-类比-目标A-但是去说B最后与A关联"><a href="#analogy-类比-目标A-但是去说B最后与A关联" class="headerlink" title="analogy 类比(目标A 但是去说B最后与A关联)"></a><span style = "color:blue">analogy 类比</span>(目标A 但是去说B最后与A关联)</h6><p>tend(照顾,倾向于)  extend(延伸,口)    pretend(假装)    intend(打算) &#x3D; mean to do</p>
<h3 id="第二部分：四级写作的出题方式"><a href="#第二部分：四级写作的出题方式" class="headerlink" title="第二部分：四级写作的出题方式"></a>第二部分：四级写作的出题方式</h3><h4 id="一-提纲式作文"><a href="#一-提纲式作文" class="headerlink" title="(一) 提纲式作文"></a>(一) 提纲式作文</h4><p>… on the topic Will <strong>E-books replaced traditional books</strong>? You should write at 150 words following the outline given below in Chinese:<br>① 随着信息技术的发展, 电子图书越来越多<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="二-图表作文-x2F-漫画式作文"><a href="#二-图表作文-x2F-漫画式作文" class="headerlink" title="(二) 图表作文&#x2F;漫画式作文"></a>(二) 图表作文&#x2F;漫画式作文</h4><h4 id="三-应用文"><a href="#三-应用文" class="headerlink" title="(三) 应用文"></a>(三) 应用文</h4><p>… to write <strong>a letter to a company declining a job offer</strong>.<br>① 对公司提供职位标识感激<br>② 有人认为电子图书会取代传统图书<br>③ 我的看法</p>
<h4 id="四-记叙文"><a href="#四-记叙文" class="headerlink" title="(四) 记叙文"></a>(四) 记叙文</h4><p>… to write a composition on the topic “<strong>The most unforgettable person I ever know.</strong>“</p>
<hr>
<h3 id="第三部分：四级的三段论"><a href="#第三部分：四级的三段论" class="headerlink" title="第三部分：四级的三段论"></a>第三部分：四级的三段论</h3><h4 id="一-现象描述型"><a href="#一-现象描述型" class="headerlink" title="(一) 现象描述型"></a>(一) 现象描述型</h4><p>第一段：描述现象，引出话题<br>第二段：阐述正反观点<br>第三段：观点结论</p>
<h4 id="二-问题解决型"><a href="#二-问题解决型" class="headerlink" title="(二) 问题解决型"></a>(二) 问题解决型</h4><p>第一段：问题描述<br>第二段：解决问题的原因<br>第三段：解决问题的措施</p>
<h4 id="三-对比观点型"><a href="#三-对比观点型" class="headerlink" title="(三) 对比观点型"></a>(三) 对比观点型</h4><p>第一段：正方观点 + 理由<br>第二段：反方观点 + 理由<br>第三段：观点结论</p>
<h4 id="四-应用文-每段的第一个句子要成为主题句出现-三个主题句"><a href="#四-应用文-每段的第一个句子要成为主题句出现-三个主题句" class="headerlink" title="(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)"></a>(四) 应用文 (每段的第一个句子要成为主题句出现 三个主题句)</h4><p>第一段：写信目的<br>第二段：写信内容<br>第三段：结束语</p>
<h4 id="五-引语类"><a href="#五-引语类" class="headerlink" title="(五) 引语类"></a>(五) 引语类</h4><p>第一段：引语含义<br>第二段：观点阐述<br>第三段：观点结论</p>
<h4 id="六-漫画-x2F-图表作文"><a href="#六-漫画-x2F-图表作文" class="headerlink" title="(六) 漫画&#x2F;图表作文"></a>(六) 漫画&#x2F;图表作文</h4><p>第一段：描述漫画&#x2F;图表内容<br>第二段：分析原因&#x2F;观点阐述 (可单独 可融合)<br>第三段：展望未来&#x2F;解决问题</p>
<h4 id="七-记叙文"><a href="#七-记叙文" class="headerlink" title="(七) 记叙文"></a>(七) 记叙文</h4><p>第一段：描述概况<br>第二段：描述事件经过细节<br>第三段：得出结论</p>
<hr>
<h3 id="第四部分：四级写作评分实例-阅读范文"><a href="#第四部分：四级写作评分实例-阅读范文" class="headerlink" title="第四部分：四级写作评分实例(阅读范文)"></a>第四部分：四级写作评分实例(阅读范文)</h3><p>… on the topic <strong>Should one expect a reward when doing a good deed ?</strong><br>① 有人做好事期望得到回报<br>② 有人认为应该像雷锋那样做好事不图回报<br>③ 我的观点<br><span style = " color : red">每当写完一个句子 就问问自己后面能写原因吗**(原因状语从句)**</span></p>
<p>​                                            Should one expect a reward when doing a good deed<br>​    <span style = " color : blue"><strong>Different people hold different view about</strong></span> whether or not one should expect a reward when doing a good deed. <span style = " color : blue"><strong>Some argue<span style = "color:red">(替代think)</span> that people should be given</strong></span> a certain reward for their good deed, <span style = " color : blue">because they believe<span style = "color:red">(替代think)</span> the saying</span> “No pain, no gains”. <span style = " color : blue"><strong>In addition<span style = "color:red">(替代and)</span>, they maintain<span style = "color:red">(替代think)</span> that in some sense</strong></span> rewards can <span style = " color : blue">stimulate<span style = "color:red">(代替encourage)</span> people’s enthusiasm to do</span> good deeds.</p>
<h5 id="①-argue可以替代think的"><a href="#①-argue可以替代think的" class="headerlink" title="① argue可以替代think的"></a><span style = " color : red">① argue</span>可以替代think的</h5><h6 id="单词：assume，deem，reckon，maintain"><a href="#单词：assume，deem，reckon，maintain" class="headerlink" title="单词：assume，deem，reckon，maintain"></a>单词：assume，deem，reckon，maintain</h6><h6 id="短语："><a href="#短语：" class="headerlink" title="短语："></a>短语：</h6><p>​    (1) hold the opinion&#x2F; belief&#x2F; point that…<br>​    (2) harbor the idea that…<br>​    (3) take the attitude that…<br>​    (4) be firmly&#x2F; fully convinced that…</p>
<h6 id="句子："><a href="#句子：" class="headerlink" title="句子："></a>句子：</h6><p>​    (1) It is widely shared that…<br>​    (2) It is universally acknowledged</p>
<p><span style = " color : red"><strong>argue</strong></span>的扩展<br><strong>I think</strong><br>&#x3D; to my knowledge<br>&#x3D; from my personal perspective<br>&#x3D; from my point of view<br>&#x3D; from my angle</p>
<p>所有的介词或介词短语后面都要加 名词&#x2F;名词短语。只有连词后面才可以加句子</p>
<p><span style = " color : red">**② because of **</span>+ 短语 (because of your help)<br>on account of、due to、thanks to、by virtue of、in light of、<br>be responsible for</p>
<p><span style = " color : red">③ because</span> + 句子 (because you help me)<br>in that、for the reason that、on the ground that、seeing that、<strong>considering that</strong></p>
<p><span style = " color : red"><strong>④ 动词短语</strong></span></p>
<ul>
<li>(1) 前<strong>因</strong>后<strong>果</strong> “导致”    <ul>
<li>contribute to</li>
<li>lead to</li>
<li>result in</li>
</ul>
</li>
</ul>
<p>例句：Eating too much fat can ___ heart disease.</p>
<ul>
<li>(2) 前<strong>果</strong>后<strong>因</strong> “归因于”<ul>
<li>attribute to</li>
<li>result from</li>
<li>credit to (credit hour学时  credit card信用卡)</li>
</ul>
</li>
</ul>
<p>例句：The accident <strong>resulted from</strong> the driver’s carelessness.<br>例句：The driver’s carelessness **resulted in **the accident.</p>
<ul>
<li>(3) 混合<strong>因果</strong> (誰前誰后都可以)<ul>
<li>be bound up with<br>(<u>be bound to do sth</u>    The cars are bound to be disused[可<u>+原因状语从句</u>].)</li>
<li>be associated with<br>(association 协会&#x2F;团队)</li>
</ul>
</li>
</ul>
<p>例句：Cancer <strong>is bound up with</strong> smoking.<br>例句：Smoking <strong>is bound up with</strong> cancer.</p>
<p>​    <span style = " color : blue"><strong>However, others have different viewpoint.</strong></span> They regard LeiFeng as a model, <strong>who</strong>(定语从句)) always helps others without ever expecting any reward. <span style = " color : blue"><strong>They assume that</strong></span> doing a good deed <span style = " color : blue"><strong>should be based on</strong></span> people’s individual consciousness of responsibility, <span style = " color : blue"><strong>and hence<span style = "color:red">(结果从句)</span> little<span style = "color:red">(不…)</span> significance should be attached to</strong></span> monetary reward. <span style = " color : blue"><strong>In addition</strong></span>, one can enjoy the happiness and peace through <strong>what</strong>(宾语从句) he had done, they think, <strong>which</strong>(定语从句) is the best return.</p>
<p>​    <span style = " color : blue"><strong>Personally, I prefer the latter(former) opinion.</strong></span> <span style = " color : blue"><strong>It is imperative for us to</strong></span>(对…来说做…是) conduct good deeds without expecting any reward. <span style = " color : blue"><strong>For one thing, the authorities should make laws and regulations to encourage people to do<span style = "color:red">(法律法规)</span></strong></span> good deeds. <span style = " color : blue"><strong>For another, people’s awareness should be cultivated that</strong></span> conducing good deeds <span style = " color : blue"><strong>is extremely<span style = "color:red">(very)</span> meaningful to our lives. It should be universally acknowledged that</strong></span> we do good deeds for enjoyment, self-fulfillment and spiritual enhancement, not for the rewards.</p>
<h1 id="第二部分：语言丰富"><a href="#第二部分：语言丰富" class="headerlink" title="第二部分：语言丰富"></a><span style = "color:orange">第二部分：语言丰富</span></h1><h4 id="一、长句-短句错落有致-3-4"><a href="#一、长句-短句错落有致-3-4" class="headerlink" title="一、长句|短句错落有致 (3-4)"></a>一、长句|短句错落有致 (3-4)</h4><h4 id="二、主动-被动适当穿插-2-3"><a href="#二、主动-被动适当穿插-2-3" class="headerlink" title="二、主动|被动适当穿插 (2-3)"></a>二、主动|被动适当穿插 (2-3)</h4><h4 id="三、比较结构巧妙使用-1-2"><a href="#三、比较结构巧妙使用-1-2" class="headerlink" title="三、比较结构巧妙使用 (1-2)"></a>三、比较结构巧妙使用 (1-2)</h4><h4 id="四、强调倒装恰当运用-1-1"><a href="#四、强调倒装恰当运用-1-1" class="headerlink" title="四、强调倒装恰当运用 (1-1)"></a>四、强调倒装恰当运用 (1-1)</h4><h4 id="五、句和句间衔接紧密"><a href="#五、句和句间衔接紧密" class="headerlink" title="五、句和句间衔接紧密"></a>五、句和句间衔接紧密</h4><hr>
<h6 id="一、短句"><a href="#一、短句" class="headerlink" title="一、短句"></a>一、短句</h6><ul>
<li>类型1：<strong>主语 + 谓语</strong> (I seen)</li>
<li>类型2：<strong>主语 + 谓语 + 宾语</strong> (主体+动词+对象)</li>
<li>类型3：<strong>主语 + 系动词 + 表语</strong>  (主体+系动词(be_感官)(动词分支)+对象)</li>
<li>类型4：<strong>主语 + 谓语 + 双宾语</strong> (主体+动词+对象+对象)(<strong>都可以改被动就是双宾否则就是宾补</strong>)</li>
<li>类型5：<strong>主语 + 谓语 + 宾语 + 宾补</strong> (主体+动词+对象+对宾语的补充说明)</li>
</ul>
<p><span style = "color:red">只有<strong>名词、形容词、副词</strong>才可以变成句子(名词性从句、形容词性从句[<strong>定语从句</strong>]、副词性从句[<strong>状语从句</strong>])</span></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/bd258af508752dfcfab1c2bbb18dd828579f1338/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.png"></p>
<h6 id="长句"><a href="#长句" class="headerlink" title="长句"></a>长句</h6><h4 id="1-定语从句"><a href="#1-定语从句" class="headerlink" title="(1) 定语从句"></a><strong>(1) 定语从句</strong></h4><p>① This is <strong>the present</strong> <u>that</u> <em>he gave me for my birthday</em>. (什么样的present)<br>② <strong>The person</strong> <u>who</u> <em>broke the window</em> must pay for it.<br>③ <strong>Mr.Lee</strong>(<u>whom</u>) <em>you want to see</em> has come.<br>④ <strong>The girl</strong> <u>whose</u> <em>mother is ill is staying</em> at home today.<br>⑤ A dictionary is <strong>a book</strong> <u>which</u> <em>gives the meaning of words.</em></p>
<p>任何一个<strong>主语</strong>后面都可以加一个<strong>定语从句</strong>对<u>主语</u>进行修饰<br>任何一个<strong>宾语</strong>后面都可以加一个<strong>定语从句</strong>对<u>宾语&#x2F;双宾</u>进行修饰<br>每当造完一个短句子都要时刻提醒自己能不能加<strong>定语从句</strong> [<strong>人</strong>用who whom  <strong>物</strong>用which  that都可以用]</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/236d7eb4836934e7fff851ca296af067241d7378/data/%E4%BB%8E%E5%8F%A5%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F2.jpg"></p>
<h4 id="2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子"><a href="#2-状语从句-与含义相关-两句话粘一起-本质是连词-连接句子" class="headerlink" title="(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])"></a>(2) 状语从句 (与含义相关 两句话粘一起) (本质是连词[连接句子])</h4><p><span style = "color : red"><strong>时间</strong>，<strong>地点</strong>是一对儿</span>；<br><span style = "color : red"><strong>原因</strong>，<strong>结果</strong>为一家；</span><br><span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟；</span>(一般不用)<br><span style = "color : red">我<strong>比较</strong>喜欢<strong>让步</strong>的<strong>方式</strong></span><br>人,物 + 定 (想一想能不能加！)<br>句子 + 原因结果时间</p>
<h5 id="1-时间状语从句-造完句问自己能产生时间吗"><a href="#1-时间状语从句-造完句问自己能产生时间吗" class="headerlink" title="1) 时间状语从句 (造完句问自己能产生时间吗)"></a>1) 时间状语从句 (造完句问自己能产生时间吗)</h5><p><strong>定语从句</strong>是内战 <strong>状语从句</strong>是侵略战争(拉一个句子来)(寻找句子之间的逻辑关系)<br><strong>When</strong> I arrived home, I had a little rest.<br>He sang <strong>as</strong> he danced.<br>You will grow wiser <strong>as</strong> you grow older.</p>
<h5 id="2-条件状语从句：-真实条件句和虚拟条件句"><a href="#2-条件状语从句：-真实条件句和虚拟条件句" class="headerlink" title="2) 条件状语从句：(真实条件句和虚拟条件句)"></a>2) 条件状语从句：(真实条件句和虚拟条件句)</h5><p>You will fail <strong>unless</strong> you study hard.<br>You will not fail <strong>if</strong> you study hard.<br>You may go there, <strong>as long as</strong> you keep quite.<br>I shall give you the book <strong>on condition that</strong> you return it tomorrow.<br>I will go <strong>provided that</strong> you go too.</p>
<h5 id="3-让步状语从句"><a href="#3-让步状语从句" class="headerlink" title="3) 让步状语从句"></a>3) 让步状语从句</h5><p><strong>Though&#x2F;Although</strong> it is raining, they are still running outside.<br>Child <strong>though</strong> he was, he knew what was the right thing to do.<br>Tired <strong>as</strong> he is, he goes on with his work.<br><strong>Despite&#x2F;In spite of</strong> wanting to see him again, she refused to reply to his letter.</p>
<h5 id="4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成"><a href="#4-原因状语从句-强调句-找主谓宾-关联连接-任何一句话都可能变成" class="headerlink" title="4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)"></a>4) 原因状语从句(+强调句) [找主谓宾 关联连接] (任何一句话都可能变成)</h5><p><strong>It is because she is too inexperienced that</strong> she does know how to deal with the situation<br><strong>As&#x2F;Since</strong> you are not very well[主谓宾], you had better have a rest.[主谓宾]<br>&#x3D; It is Since you are not very well that you had better have a rest</p>
<p>It must have rained last night[主谓宾], <strong>for</strong> the ground is wet now.[主系表]<br>&#x3D; It is because&#x2F;for the ground is wet now that It must have rained last night</p>
<h5 id="5-目的状语从句-怎么怎么滴…-为了…-以防…"><a href="#5-目的状语从句-怎么怎么滴…-为了…-以防…" class="headerlink" title="5) 目的状语从句 (怎么怎么滴…  为了…  以防…)"></a>5) 目的状语从句 (怎么怎么滴…  为了…  以防…)</h5><p>You must speak louder <strong>so that&#x2F;in order that</strong> you can be heard by all.<br>He wrote the name down <strong>for fear that</strong> he should forget it.<br>Better take more clothes <strong>in case</strong> the weather be cold.</p>
<h6 id="注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟"><a href="#注意：lest-in-case-for-fear-that所引导的状语从句中，动词可以用虚拟语气，形式为-should-动词原形-条件，目的有虚拟" class="headerlink" title="注意：lest, in case, for fear that所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (条件，目的有虚拟)"></a>注意：<u>lest, in case, for fear that</u>所引导的状语从句中，动词可以用虚拟语气，形式为 should + 动词原形 (<span style = "color : red"><strong>条件</strong>，<strong>目的</strong>有虚拟)</span></h6><p>People must 关注 the P, lest it should be more and more 严重</p>
<h5 id="6-结果状语从句"><a href="#6-结果状语从句" class="headerlink" title="6) 结果状语从句"></a>6) 结果状语从句</h5><h6 id="引导结果状语从句的连词有：so-that-so…that-such…that"><a href="#引导结果状语从句的连词有：so-that-so…that-such…that" class="headerlink" title="引导结果状语从句的连词有：so that, so…that, such…that"></a>引导结果状语从句的连词有：so that, so…that, such…that</h6><p>He is <strong>so</strong> young <strong>that</strong> he can not go to school.<br>He is <strong>such</strong> a young boy <strong>that</strong> he can not go to school.</p>
<h6 id="补充常用句型"><a href="#补充常用句型" class="headerlink" title="补充常用句型"></a>补充常用句型</h6><p><strong>① so + 形容词&#x2F;副词 + that从句</strong><br>② so + 形容词 + a&#x2F;an + 单数可数名词 + that从句<br>③ such + a&#x2F;an + 形容词 + 单数可数名词 + that从句<br>④ such + 形容词 + 复数可数名词&#x2F;不可数名词 + that从句</p>
<h5 id="7-比较状语从句"><a href="#7-比较状语从句" class="headerlink" title="7) 比较状语从句"></a>7) 比较状语从句</h5><h6 id="引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等"><a href="#引导比较状语从句的连词有：as…as-than-not-so…as-the-more…the-more等" class="headerlink" title="引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等"></a>引导比较状语从句的连词有：as…as, than, not so…as, the more…the more等</h6><p>He speaks English as fluently as his brother(does).<br>I can’t jump so&#x2F;as high as he(does).</p>
<h5 id="8-地点状语从句"><a href="#8-地点状语从句" class="headerlink" title="8) 地点状语从句"></a>8) 地点状语从句</h5><h6 id="引导地点状语从句的连词有：where-wherever以及-where构成的复合词等"><a href="#引导地点状语从句的连词有：where-wherever以及-where构成的复合词等" class="headerlink" title="引导地点状语从句的连词有：where, wherever以及 where构成的复合词等"></a>引导地点状语从句的连词有：where, wherever以及 where构成的复合词等</h6><p>① She found her calculator where she lost it.<br>② Wherever I am, I will miss you.<br>③ I happened to see your dictionary lie where I used it last time.<br>④ I happened to see your dictionary lie in the lab where I used it last time.</p>
<h5 id="9-方式状语从句"><a href="#9-方式状语从句" class="headerlink" title="9) 方式状语从句"></a>9) 方式状语从句</h5><p>① Just do as you are told.<br>② The workers went on working as if nothing had happened.</p>
<h4 id="3-名词性从句"><a href="#3-名词性从句" class="headerlink" title="(3) 名词性从句"></a>(3) 名词性从句</h4><h5 id="1-主语从句"><a href="#1-主语从句" class="headerlink" title="1) 主语从句"></a>1) 主语从句</h5><p>① That <u>she</u> had <u>won</u> <u>the first place</u>(主谓宾) <u>made us</u> very <u>happy</u>(主谓宾宾).<br><u><strong>五之一</strong>完整的主谓宾</u> (原因,结果,目的,条件) <u><strong>五之一</strong>完整的主谓宾</u><br>【五之一＋连词+五之一】<br>主语比较长的时候避免头重脚轻 可以用It做形式主语<br>&#x3D; It made us very happy that she had won the first place.</p>
<p>② Which team will win the match<br>&#x3D; It is still unknown which team will win the match is still unknown.<br><u><strong>五之一</strong>完整的主谓宾</u> 但是这是主语从句 所以主语就变成了一个句子<br><u>people protect the environment(主谓宾做主语)</u> is important要用连词连接一起<br>&#x3D; It is important that people protect the environment.(It可做形式主语但不是必须)</p>
<h6 id="补充：用it作形式主语的that-从句"><a href="#补充：用it作形式主语的that-从句" class="headerlink" title="补充：用it作形式主语的that-从句"></a>补充：用it作形式主语的that-从句</h6><h6 id="1-It-be-形容词-that从句"><a href="#1-It-be-形容词-that从句" class="headerlink" title="1. It + be + 形容词 + that从句"></a>1. It + be + 形容词 + that从句</h6><p>① It is necessary that… 有必要…<br>② It is important that… 重要的是…<br>③ It is obvious that… 很明显</p>
<h6 id="2-It-be-ed分词-that-从句"><a href="#2-It-be-ed分词-that-从句" class="headerlink" title="2. It + be + -ed分词 + that-从句"></a>2. It + be + -ed分词 + that-从句</h6><p>① It is believed that… 人们相信…<br>② It is known to all that… 纵所周知<br>③ It has been decided that… 已决定</p>
<h6 id="3-It-be-名词-that-从句"><a href="#3-It-be-名词-that-从句" class="headerlink" title="3. It + be + 名词 + that-从句"></a>3. It + be + 名词 + that-从句</h6><p>① It is common knowledge that…  …是常识<br>② It is a surprise that… 令人惊奇的是…<br>③ It is a fact that… 事实是</p>
<p>每当写完一个人能不能在人后面加定语从句<br>每当写完一个物能不能在物后面加定语从句<br>每当写完一个句子想一想在后面能不能加原因&#x2F;结果&#x2F;时间状语从句<br>写主语的时候想一想能不能把一个句子当主语</p>
<h5 id="2-宾语从句"><a href="#2-宾语从句" class="headerlink" title="2) 宾语从句"></a>2) 宾语从句</h5><h5 id="3-表语从句"><a href="#3-表语从句" class="headerlink" title="3) 表语从句"></a>3) 表语从句</h5><h5 id="4-同位语从句"><a href="#4-同位语从句" class="headerlink" title="4) 同位语从句"></a>4) 同位语从句</h5><h3 id="语言丰富方式二：主动被动适当穿插"><a href="#语言丰富方式二：主动被动适当穿插" class="headerlink" title="语言丰富方式二：主动被动适当穿插"></a>语言丰富方式二：主动被动适当穿插</h3><h5 id="1-被动语态的构成"><a href="#1-被动语态的构成" class="headerlink" title="1.被动语态的构成"></a>1.被动语态的构成</h5><p>**<span style = "color : red">① 一般现在时</span>**：am&#x2F;is&#x2F;are + done<br>**<span style = "color : red">② 一般过去时</span>**：was&#x2F;were + done<br>**<span style = "color : red">③ 一般将来时</span>**：will&#x2F;shall&#x2F;be going to be + done<br><strong>④ 过去将来时</strong>：would&#x2F;should&#x2F;be going to be + done<br><strong>⑤ 现在进行时</strong>：am&#x2F;is&#x2F;are being + done<br><strong>⑥ 过去进行时</strong>：was&#x2F;were being + done<br><strong>⑦ 过去完成时</strong>：had been + done</p>
<h5 id="2-被动语态的用法-至少3个"><a href="#2-被动语态的用法-至少3个" class="headerlink" title="2.被动语态的用法(至少3个)"></a>2.被动语态的用法(至少3个)</h5><h6 id="1-不知道或没有必要说明动作的执行者是誰-句子没主语"><a href="#1-不知道或没有必要说明动作的执行者是誰-句子没主语" class="headerlink" title="1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)"></a>1) 不知道或没有必要说明动作的执行者是誰 (句子没主语)</h6><p>① Some new computers were stolen last night.<br>② This book was published in 1981.</p>
<h6 id="2-强调动作的承受者"><a href="#2-强调动作的承受者" class="headerlink" title="2) 强调动作的承受者"></a>2) 强调动作的承受者</h6><p>① Eight hours per day for sleep must be guaranteed.</p>
<h6 id="3-主动语态变被动语态的方法"><a href="#3-主动语态变被动语态的方法" class="headerlink" title="3) 主动语态变被动语态的方法"></a>3) 主动语态变被动语态的方法</h6><p><span style = "color : red">① 把主动语态的<strong>宾语</strong>变为被动语态的<strong>主语</strong></span><br><span style = "color : red">② 把谓语变成被动结构 (<strong>be+过去分词</strong>) [被动形式]</span><br><span style = "color : red">③ 把主动语态中的<strong>主语</strong><u>放在</u>介词<u><strong>by</strong>之后</u>作<strong>宾语</strong>, 将主格改为宾格</span></p>
<p>Ⅰ. All the people laughed at him.[一般过去时]<br>      He was laughed at by all the people.</p>
<p>Ⅱ. They make</p>
<h6 id="4-含有情态动词的被动语态：”情态动词-be-done”"><a href="#4-含有情态动词的被动语态：”情态动词-be-done”" class="headerlink" title="4) 含有情态动词的被动语态：”情态动词 + be + done”"></a>4) 含有情态动词的被动语态：”情态动词 + be + done”</h6><p>Ⅰ. We can repair this watch in two days.<br>      This watch can be repaired in two days.<br>Ⅱ. We must finish this work soon.<br>      This work must be done soon.</p>
<h6 id="5-主动语态变被动语态需要注意的几个问题"><a href="#5-主动语态变被动语态需要注意的几个问题" class="headerlink" title="5) 主动语态变被动语态需要注意的几个问题"></a>5) 主动语态变被动语态需要注意的几个问题</h6><p><strong>① 时态保持一致</strong><br>    Ⅰ. I have repaired my computer. [现在完成时]<br>         My computer has been repaired.</p>
<p><strong>② 被动语态不能丢掉动词短语的介词或副词</strong><br>    Ⅰ. His best friend often <strong>looks after</strong> him.<br>          He is often <strong>looked after</strong> by his best friend.</p>
<p><strong>③ 若双宾语(一个人一个物),将其中一个宾语变为被动句的主语,另一个宾语不变</strong><br>     make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>    Ⅰ. Vivian gave <strong>me</strong> a book<br>          <strong>I</strong> was given <strong>a book</strong> by Vivian.<br>         <strong>A book</strong> was given to me by Vivian.<br>双宾： make&#x2F;buy&#x2F;get用<strong>for</strong>； give&#x2F;send&#x2F;lend&#x2F;take用<strong>to</strong><br>一定是一个人一个物<br><span style = "color : blue">如果先都说人 无论主动被动<strong>都没有介词</strong></span><br>I’ll give you the child</p>
<p><span style = "color : blue">如果先都说物    无论主动被动<strong>都有介词</strong></span><br>I am writing to your child</p>
<p><strong>④ 若复合宾语，将主动句的宾语变成被动句的主语，宾补不变</strong><br>    Ⅰ. <strong>They</strong> call <strong>him</strong> Louis.<br>          <strong>He</strong> is called Louis.</p>
<p><strong>⑤ “动词+宾语+宾语补足语”</strong>, 将宾语变为被动结构中的主语, 其余不动<br>    Ⅰ. Someone <strong>caught</strong> <strong><u>the boy</u></strong> <strong>smoking a cigarette</strong>.<br>          <strong>The boy</strong> was caught smoking a cigarette.</p>
<p><strong>⑥ It is said that+从句及类似句型</strong> 【据说…   人们…】</p>
<p>​    “It + be + 过去分词 + that从句” <strong>或</strong> “主语 + be + 过去分词 + to do sth”</p>
<pre><code class="java">被动句型(不会改被动就直接套用)
① It is said that... 据说
② It is reported that... 据报道
③ It is believed that... 大家相信
④ It is hoped that... 大家希望
⑤ It is well known that... 众所周知
⑥ It is thought that... 大家认为
⑦ It is suggested that... 据建议
</code></pre>
<h3 id="语言丰富方式三：比较结构巧妙使用"><a href="#语言丰富方式三：比较结构巧妙使用" class="headerlink" title="语言丰富方式三：比较结构巧妙使用"></a>语言丰富方式三：比较结构巧妙使用</h3><h5 id="1-同级比较"><a href="#1-同级比较" class="headerlink" title="1.同级比较"></a>1.同级比较</h5><h6 id="①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样"><a href="#①-as…as-出现形容词副词-the-same-as-the-identical-with-与…一样" class="headerlink" title="① as…as(出现形容词副词); the same as; the identical with;  与…一样"></a>① as…as(出现形容词副词); the same as; the identical with;  与…一样</h6><p>She has written <u>as many essays as</u> her brother.</p>
<h6 id="②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…"><a href="#②-no-more…-than-或-not…any-more-than-和…一样不-A是不…-B也不…" class="headerlink" title="② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)"></a>② no more… than 或 not…any more than;  和…一样不 (A是不… B也不…)</h6><p>the more…the more句型【越来越…       越… 越…】</p>
<p>The heart is <u>no more intelligent than</u> the stomach, for they are both controlled by the brain.</p>
<h5 id="2-表最高程度"><a href="#2-表最高程度" class="headerlink" title="2.表最高程度"></a>2.表最高程度</h5><h6 id="①-no-名词-more…than；-没有什么比…更…-莫过于"><a href="#①-no-名词-more…than；-没有什么比…更…-莫过于" class="headerlink" title="① no + 名词 + more…than；  没有什么比…更…;  莫过于"></a>① no + 名词 + more…than；  没有什么比…更…;  莫过于</h6><p><u><strong>No</strong></u> tool is <u><strong>more <strong>powerful</u> for understanding the natural world <u><strong>than</strong> the scientific method.</u> 【<u>拉长 添加</strong>状语</strong> 定语</u>】</p>
<h6 id="②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…"><a href="#②-more…than-anyone-和人比-x2F-anything-和物比-else；-比其他任何…都…、没有比…更…" class="headerlink" title="② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…"></a>② more…than + anyone(和人比)&#x2F;anything(和物比) else； 比其他任何…都…、没有比…更…</h6><p>He did <u>more</u> work this morning <u>than anyone else.</u></p>
<h5 id="3-表示倍数-【as、of、than】"><a href="#3-表示倍数-【as、of、than】" class="headerlink" title="3. 表示倍数 【as、of、than】"></a>3. 表示倍数 【as、of、than】</h5><p><strong>as</strong>…只能跟adj&#x2F;adv        <strong>of</strong>…只能跟n        <strong>than</strong>…只能跟比较级</p>
<h6 id="①-倍数-as-形容词或副词-as"><a href="#①-倍数-as-形容词或副词-as" class="headerlink" title="① 倍数 + as + 形容词或副词 + as"></a>① 倍数 + as + 形容词或副词 + as</h6><p>An ordinary subway train, approaching the station, can be <u>twice as loud as</u> the loudest jet.</p>
<h6 id="②-倍数-名词-of"><a href="#②-倍数-名词-of" class="headerlink" title="② 倍数 + 名词 + of"></a>② 倍数 + 名词 + of</h6><p>The bridge is <u>three times the length of</u> that one.</p>
<h6 id="③-倍数-比较级-than"><a href="#③-倍数-比较级-than" class="headerlink" title="③ 倍数 + 比较级 + than"></a>③ 倍数 + 比较级 + than</h6><p>This hole is <u>three times deeper than</u> that one.</p>
<h5 id="4-more-than"><a href="#4-more-than" class="headerlink" title="4. more than"></a>4. more than</h5><h6 id="①-more-than-动词或名词：”不仅仅是-不只是”"><a href="#①-more-than-动词或名词：”不仅仅是-不只是”" class="headerlink" title="① more than + 动词或名词：”不仅仅是, 不只是”"></a>① more than + 动词或名词：”不仅仅是, 不只是”</h6><p>They may teach very well, and more than earn their salaries, but most of them make little…</p>
<h6 id="②-more-than-形容词：非常-代替not-only、very、over"><a href="#②-more-than-形容词：非常-代替not-only、very、over" class="headerlink" title="② more than + 形容词：非常 (代替not only、very、over)"></a>② more than + 形容词：非常 (代替not only、very、over)</h6><p>The USA remains <u>more than capable</u> of holding down.</p>
<h3 id="语言丰富方式四：强调倒装恰当使用"><a href="#语言丰富方式四：强调倒装恰当使用" class="headerlink" title="语言丰富方式四：强调倒装恰当使用"></a>语言丰富方式四：强调倒装恰当使用</h3><h4 id="一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分"><a href="#一-强调句：It-is-x2F-was-被强调的部分-that-句子的其他部分" class="headerlink" title="(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分"></a>(一) 强调句：It is&#x2F;was + 被强调的部分 + that + 句子的其他部分</h4><p>(<strong>谓语以外的任何成分</strong>都可以放在被强调部分当中进行强调)</p>
<h6 id="改写句子①"><a href="#改写句子①" class="headerlink" title="改写句子①"></a>改写句子①</h6><p><u>Wester health-care system</u> <strong>are spending</strong> <u>huge sums of money</u> <u>on the surgical treatment of the disease</u>.( 可以改成三个强调句)<br>① It is <strong>Wester health-care system</strong> that are spending huge sums of money on the surgical treatment of the disease.<br>② It is <strong>huge sums of money</strong> that Western health-care system are spending on the surgical treatment of the disease.<br>③ It is **on the surgical treatment of the disease ** that Western health-care system are spending huge sums of money.</p>
<h6 id="改写句子②"><a href="#改写句子②" class="headerlink" title="改写句子②"></a>改写句子②</h6><p><u>Ann Peters’ husband</u> <strong>rushed</strong> <u>her</u> <u>to a nearby hospital</u> <u>last night.</u><br>① It was <strong>Ann Peters’ husband</strong> that(who) rushed her to nearby hospital last night.<br>② It was <strong>her</strong> that(who) Ann Peters’ husband rushed her to nearby hospital last night.<br>③ It was <strong>to a nearby hospital</strong> that Ann Peters’ husband rushed her last night.<br>④ It was <strong>last night</strong> that Ann Peters’ husband rushed her to a nearby hospital.<br><strong>提示1：</strong><br>1.叙述的是现在或者将来：“It is … that … ”<br>2.叙述的是过去：”It was … that …”</p>
<p><strong>提示2：</strong></p>
<h6 id="强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形"><a href="#强调动词的时候-没有强调句子谓语的强调句，但又其通常的强调手段：do-x2F-does-x2F-did-动词原形" class="headerlink" title="强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形"></a>强调动词的时候 没有强调句子谓语的强调句，但又其通常的强调手段：do &#x2F; does &#x2F; did + 动词原形</h6><p>I <strong>do</strong> believe that he is an honest man.<br>They <strong>did</strong> go to see you yesterday, but failed to meet you.</p>
<h4 id="二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that"><a href="#二-倒装：-主谓-→-谓主-3个被动-定语-原因状语-强调句-倒装-only时间状语-so…that" class="headerlink" title="(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])"></a>(二) 倒装：(主谓 → 谓主) ( 3个被动 定语 原因状语 强调句 倒装[only时间状语  so…that])</h4><p>① 指将谓语的一部分(如助动词或情态)至主语之前<br>② 如果句子的谓语没有助动词或情态动词，需加助动词do, does或did, 将其置于主语之前</p>
<h6 id="全部倒装"><a href="#全部倒装" class="headerlink" title="全部倒装"></a>全部倒装</h6><p>要把<strong>所有的谓语</strong>都拿到主语前面 和其他成分无关</p>
<h6 id="部分倒装"><a href="#部分倒装" class="headerlink" title="部分倒装"></a>部分倒装</h6><p>要把<strong>谓语的一部分</strong>拿到主语前面<br>助动词+动词        情态动词+动词</p>
<h6 id="1-only句首"><a href="#1-only句首" class="headerlink" title="1. only句首"></a>1. only句首</h6><p>① <strong>Only in this way can you learn</strong>(介词短语) English well.<br>② <strong>Only after being asked three times</strong>(非谓语动词) did he come to the meeting.<br>③ <span style = "color:red"><strong>Only when he is seriously ill</strong>(从句)</span> does he ever stay in bed.<br>Only when 大学生… do they 意识到…</p>
<h6 id="2-句首为否定意义的词语"><a href="#2-句首为否定意义的词语" class="headerlink" title="2. 句首为否定意义的词语"></a>2. 句首为否定意义的词语</h6><h6 id="如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等"><a href="#如：no-never-seldom-little-hardly-at-no-time-in-no-way-not-until…等" class="headerlink" title="如：no, never, seldom, little, hardly, at no time, in no way, not until…等"></a>如：no, never, seldom, little, hardly, at no time, in no way, not until…等</h6><p>① Never have I seen such a performance.<br>② Nowhere will you find the answer to this question.<br>③ Not until the child fell asleep did the mother leave the room.</p>
<h6 id="3-so…that-句型中的so位于句首时，需倒装"><a href="#3-so…that-句型中的so位于句首时，需倒装" class="headerlink" title="3. so…that 句型中的so位于句首时，需倒装"></a>3. so…that 句型中的so位于句首时，需倒装</h6><p>   he was so frightened that he did not dare to move an inch.<br>&#x3D;<strong>So</strong> frightened <strong>was he</strong> that he did not dare to move an inch.</p>
<h6 id="4-在虚拟语气中-可将if省略-采取部分倒装"><a href="#4-在虚拟语气中-可将if省略-采取部分倒装" class="headerlink" title="4. 在虚拟语气中, 可将if省略, 采取部分倒装"></a>4. 在虚拟语气中, 可将if省略, 采取部分倒装</h6><p>Were I you, I would try it again</p>
<h5 id="3个被动-定语-原因状语-强调句-倒装-写作必须拥有的"><a href="#3个被动-定语-原因状语-强调句-倒装-写作必须拥有的" class="headerlink" title="3个被动 定语 原因状语 强调句 倒装 写作必须拥有的"></a><span style = "color:red">3个被动 定语 原因状语 强调句 倒装 写作必须拥有的</span></h5><h3 id="八种万能功能段-三八大盖"><a href="#八种万能功能段-三八大盖" class="headerlink" title="八种万能功能段 (三八大盖)"></a>八种万能功能段 (三八大盖)</h3><h6 id="现象-x2F-问题描述功能段"><a href="#现象-x2F-问题描述功能段" class="headerlink" title="现象&#x2F;问题描述功能段"></a><span style = "color:blue">现象&#x2F;问题描述功能段</span></h6><p><strong>①</strong> In recent years, … is becoming increasingly popular&#x2F;prevalent at an amazing rate.<br>近年来, …越来越流行(现象)<br><strong>②</strong> <span style = "color:red">Along with the advance of the society more and more problems are brought to our attention, one of which is that…</span><br>随着社会的不断发展，出现了越来越多的问题引起我们的注意                                                                                                                                                                                  ，其中之一便是…</p>
<h6 id="原因分析功能段-总原因的阐述"><a href="#原因分析功能段-总原因的阐述" class="headerlink" title="原因分析功能段 (总原因的阐述)"></a><span style = "color:blue">原因分析功能段 (总原因的阐述)</span></h6><p>① <span style = "color:red">A number of factors might <u>contribute to</u>&#x2F;<u>account for</u> the phenomenon&#x2F;problem.</span><br>许多因素可能是造成这种现象&#x2F;问题的原因。<br>② The reasons for … mainly lie in the following two aspects.<br>原因…主要表现在以下两个方面。<br>(<strong>分原因阐述&#x3D;&gt;原因数量决定</strong>)<br>① <span style = "color:red">One of the most common factor is that…</span><br>② Another contributing cause is…<br>③ Perhaps the primary reason is that…<br>④ But the fundamental element is that…</p>
<h6 id="观点阐述功能段"><a href="#观点阐述功能段" class="headerlink" title="观点阐述功能段"></a><span style = "color:blue">观点阐述功能段</span></h6><p><strong>观点主题句</strong><br>① <span style = "color:red">People have (take,adopt,assume) different attitudes towards.</span><br>② People have different opinions on this problem.</p>
<p><strong>观点</strong><br>① <span style = "color:red">According to a survey, some people are in favor of the idea of doing… They point out the fact that(+支持…的第一个原因) they also argue that… (+支持…的另一个原因)</span></p>
<h6 id="观点结论功能段"><a href="#观点结论功能段" class="headerlink" title="观点结论功能段"></a><span style = "color:blue">观点结论功能段</span></h6><p>① <span style = "color:red">From what has been discussed above, we may safely draw the conclusion that…</span><br>根据以上讨论，我们可以得出下面的结论</p>
<h6 id="解决问题功能段"><a href="#解决问题功能段" class="headerlink" title="解决问题功能段"></a><span style = "color:blue">解决问题功能段</span></h6><p><strong>措施主题句</strong><br>① ___ has been playing an increasingly important role in our day-to-day life, which has brought us a lot of benefits but has created some serious problems as well.<br>…在日常生活中发挥着越来越重要的作用, 它给我们带来了很多好处</p>
<p><strong>分措施</strong><br>① <strong>First and foremost</strong>, government should establish some regulations to…<br>② <strong>What’s more</strong>, people should get ready to…<br>③ <strong>After all</strong>, it is necessary to advocate the whole society to…</p>
<p><strong>解决问题总结句</strong><br>① In summary, if we continue to ignore the above-mentioned issue, more problems will crop up.<br>总之，如果我们继续忽略上述问题，会有更多问题出现<br>② From my point of view, college students should … when it comes to … What’s more, we should always bear in mind that…<br>我认为, … 大学生应该自己…此外, 我们应牢记…</p>
<h6 id="未来展望功能段"><a href="#未来展望功能段" class="headerlink" title="未来展望功能段"></a><span style = "color:blue">未来展望功能段</span></h6><p>① It can directly promote the rapid progress of … , and eventually brings …<br>它可以直接促进…还可也用来…</p>
<h6 id="漫画-x2F-图表描述功能段"><a href="#漫画-x2F-图表描述功能段" class="headerlink" title="漫画&#x2F;图表描述功能段"></a><span style = "color:blue">漫画&#x2F;图表描述功能段</span></h6><p>① It  can be easily seen from the picture(chart&#x2F;line&#x2F;graph) that… The picture is intended to inform us of the bad effects of college student’s…<br>从图片中很容易可以看到, …这幅画是在告诉我们 … 有着不好的影响<br>② <span style = "color:red">According to the <u>figure&#x2F;number&#x2F;statistics</u> in the <u>chart&#x2F; bar graph&#x2F;line</u>, it can be seen that…</span></p>
<h6 id="引语解释功能段"><a href="#引语解释功能段" class="headerlink" title="引语解释功能段"></a><span style = "color:blue">引语解释功能段</span></h6><p>① <span style = "color:red">There is such a saying … This saying <strong>not only</strong> emphasizes the importance of… <strong>but also</strong> indicates that…</span><br>有这样一句名言：….这句话不仅强调了…的重要性，而且指出…</p>
<h5 id="附加：举例子"><a href="#附加：举例子" class="headerlink" title="附加：举例子"></a>附加：举例子</h5><p>① There may be no better example than the following one.</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/英语" style=color:#00bcd4>
                英语
            </a>
        </span>
        
    </div>

    <a href="/2023/11/19/英语/四级作文-新/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/">
        <h2>
            Linux,Redis,Jedis
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/15
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Linux基础入门"><a href="#Linux基础入门" class="headerlink" title="Linux基础入门"></a>Linux基础入门</h1><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li><h6 id="介绍Linux与CentOS"><a href="#介绍Linux与CentOS" class="headerlink" title="介绍Linux与CentOS"></a>介绍Linux与CentOS</h6></li>
<li><h6 id="讲解Linux基础"><a href="#讲解Linux基础" class="headerlink" title="讲解Linux基础"></a>讲解Linux基础</h6></li>
<li><h6 id="Linux文本工具与命令"><a href="#Linux文本工具与命令" class="headerlink" title="Linux文本工具与命令"></a>Linux文本工具与命令</h6></li>
<li><h6 id="yum应用安装与卸载"><a href="#yum应用安装与卸载" class="headerlink" title="yum应用安装与卸载"></a>yum应用安装与卸载</h6></li>
<li><h6 id="CentOS的权限与系统安全"><a href="#CentOS的权限与系统安全" class="headerlink" title="CentOS的权限与系统安全"></a>CentOS的权限与系统安全</h6></li>
<li><h6 id="部署OA项目至Linux服务器"><a href="#部署OA项目至Linux服务器" class="headerlink" title="部署OA项目至Linux服务器"></a>部署OA项目至Linux服务器</h6></li>
</ul>
<h3 id="主流操作系统"><a href="#主流操作系统" class="headerlink" title="主流操作系统"></a>主流操作系统</h3><p>不同领域的主流操作系统，主要分为以下这么几类： 桌面操作系统、服务器操作系统、移动设备操作系统、嵌入式操作系统。接下来，这几个领域中，代表性的操作系统是那些?</p>
<p>1). 桌面操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Windows</td>
<td>用户数量最多</td>
</tr>
<tr>
<td>MacOS</td>
<td>操作体验好，办公人士首选</td>
</tr>
<tr>
<td>Linux</td>
<td>用户数量少(桌面操作系统,Linux使用较少)</td>
</tr>
</tbody></table>
<p>2). 服务器操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Unix</td>
<td>安全、稳定、付费</td>
</tr>
<tr>
<td>Linux</td>
<td>安全、稳定、免费、占有率高</td>
</tr>
<tr>
<td>Windows Server</td>
<td>付费、占有率低</td>
</tr>
</tbody></table>
<p>3). 移动设备操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Android</td>
<td>基于 Linux 、开源，主要用于智能手机、平板电脑和智能电视</td>
</tr>
<tr>
<td>IOS</td>
<td>苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、 iPad</td>
</tr>
</tbody></table>
<p>4). 嵌入式操作系统</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>机顶盒、路由器、交换机</td>
</tr>
</tbody></table>
<h3 id="2-2-Linux系统版本"><a href="#2-2-Linux系统版本" class="headerlink" title="2.2 Linux系统版本"></a>2.2 Linux系统版本</h3><p>Linux系统的版本分为两种，分别是： 内核版 和 发行版。</p>
<p><strong>1). 内核版</strong></p>
<ul>
<li><p>由Linus Torvalds及其团队开发、维护</p>
</li>
<li><p>免费、开源</p>
</li>
<li><p>负责控制硬件</p>
</li>
</ul>
<p><strong>2). 发行版</strong></p>
<ul>
<li><p>基于Linux内核版进行扩展</p>
</li>
<li><p>由各个Linux厂商开发、维护</p>
</li>
<li><p>有收费版本和免费版本</p>
</li>
</ul>
<p>我们使用Linux操作系统，实际上选择的是Linux的发行版本。在linux系统中，有各种各样的发行版本，具体如下： </p>
<table>
<thead>
<tr>
<th>发行版本</th>
<th>Logo</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu</td>
<td><img src="assets/image-20210809001838861.png" alt="image-20210809001838861" style="zoom:50%;" /></td>
<td>以桌面应用为主</td>
</tr>
<tr>
<td>RedHat</td>
<td><img src="assets/image-20210809001731378.png" alt="image-20210809001731378" style="zoom:50%;" /></td>
<td>应用最广泛、收费</td>
</tr>
<tr>
<td><strong>CentOS</strong></td>
<td><img src="assets/image-20210809001741238.png" alt="image-20210809001741238" style="zoom:50%;" /></td>
<td>RedHat的社区版、免费</td>
</tr>
<tr>
<td>openSUSE</td>
<td><img src="assets/image-20210809001750999.png" alt="image-20210809001750999" style="zoom:50%;" /></td>
<td>对个人完全免费、图形界面华丽</td>
</tr>
<tr>
<td>Fedora</td>
<td><img src="assets/image-20210809001800676.png" alt="image-20210809001800676" style="zoom:50%;" /></td>
<td>功能完备、快速更新、免费</td>
</tr>
<tr>
<td>红旗Linux</td>
<td><img src="assets/image-20210809001814942.png" alt="image-20210809001814942" style="zoom:50%;" /></td>
<td>北京中科红旗软件技术有限公司开发</td>
</tr>
</tbody></table>
<p>除了上述罗列出来的发行版，还有很多Linux发行版，这里，我们就不再一一列举了。</p>
<h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><ul>
<li>操作系统(<strong>O</strong>perating <strong>S</strong>ystem)是应用程序运行的基础支撑环境</li>
<li>操作系统作用是管理和控制计算机系统的硬件与软件资源</li>
<li>Intel x86架构上常见的操作系统：Windows、Linux、Unix…</li>
</ul>
<h3 id="Linux操作系统-1"><a href="#Linux操作系统-1" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul>
<li>Linux是开源的基于Inter x86架构的类Unix多用户操作系统</li>
<li>支持多任务、多用户、多CPU</li>
<li>高效而灵活</li>
<li>兼容任意x86架构计算机</li>
<li>强大易用的系统命令</li>
<li>完整的应用软件生态</li>
</ul>
<h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><ul>
<li>Linux系统内核(kernel)提供了Linux操作系统的核心功能</li>
<li>不同开发商在内核基础上扩展封装，形成了不同发行版本</li>
<li>常见发行版：Red Hat Linux、CentOS、Ubuntu、SUSE…</li>
</ul>
<h3 id="Linux发行版选择建议"><a href="#Linux发行版选择建议" class="headerlink" title="Linux发行版选择建议"></a>Linux发行版选择建议</h3><ul>
<li>桌面系统：Ubuntu</li>
<li>服务器操作系统：**CentOS(免费)**、Red Hat Linux(收费)</li>
<li>特定需求：Debian(稳定性)、Fedoras(新特性)、麒麟Linux(国产)</li>
</ul>
<h3 id="CentOS-社区企业操作系统"><a href="#CentOS-社区企业操作系统" class="headerlink" title="CentOS - 社区企业操作系统"></a>CentOS - 社区企业操作系统</h3><ul>
<li>基于<strong>R</strong>ed <strong>H</strong>at <strong>E</strong>nterprice <strong>L</strong>inux的开源企业级Linux发行版本</li>
<li>各版本CentOS都会获得十年的支持，与RHEL保持同步更新</li>
<li>CentOS采用社区支持，同步修正了RHEL许多BUG</li>
</ul>
<h3 id="CentOS版本选择"><a href="#CentOS版本选择" class="headerlink" title="CentOS版本选择"></a>CentOS版本选择</h3><ul>
<li>CentOS 5&#x2F;6：历史淘汰版本</li>
<li><strong>CentOS 7：主流版本，成熟稳定，大多数服务器的首先版本</strong></li>
<li>CentOS 8：全新版本，全新内核，存在漏洞隐患</li>
</ul>
<h3 id="安装CentOS-7-7"><a href="#安装CentOS-7-7" class="headerlink" title="安装CentOS 7.7"></a>安装CentOS 7.7</h3><p>vmware.com&#x2F;cn.html</p>
<p>VMware-workstation-full-14.1.2-8497320.exe<br>[链接： <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ">https://pan.baidu.com/s/1EbuhZ4D4kh_NcRJqTA-vhQ</a><br>密码：oq37]</p>
<p>mirrors.aliyun.com&#x2F;centos&#x2F;7.7.1908&#x2F;isos&#x2F;x86_64&#x2F; 下载 Everything-1908.iso<br>[<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/centos-vault/centos/7.7.1908/isos/x86_64/">centos-vault-centos-7.7.1908-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a>]</p>
<p>VM典型 镜像Iso 存储地址放在最快的硬盘 将虚拟磁盘存储为单个文件 自定义(内存2GB 处理器2核  虚拟化 Intel VT-x)</p>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>根目录&#x2F; 下各个目录的作用及含义说明:  </p>
<table>
<thead>
<tr>
<th>编号</th>
<th>目录</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x2F;bin</td>
<td>存放二进制可执行文件</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;boot</td>
<td>存放系统引导时使用的各种文件</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;dev</td>
<td>存放设备文件</td>
</tr>
<tr>
<td>4</td>
<td><strong>&#x2F;etc</strong></td>
<td>存放系统配置文件</td>
</tr>
<tr>
<td>5</td>
<td><strong>&#x2F;home</strong></td>
<td>存放系统用户的文件</td>
</tr>
<tr>
<td>6</td>
<td>&#x2F;lib</td>
<td>存放程序运行所需的共享库和内核模块</td>
</tr>
<tr>
<td>7</td>
<td>&#x2F;opt</td>
<td>额外安装的可选应用程序包所放置的位置</td>
</tr>
<tr>
<td>8</td>
<td><strong>&#x2F;root</strong></td>
<td>超级用户目录</td>
</tr>
<tr>
<td>9</td>
<td>&#x2F;sbin</td>
<td>存放二进制可执行文件，只有root用户才能访问</td>
</tr>
<tr>
<td>10</td>
<td>&#x2F;tmp</td>
<td>存放临时文件</td>
</tr>
<tr>
<td>11</td>
<td><strong>&#x2F;usr</strong></td>
<td>存放系统应用程序</td>
</tr>
<tr>
<td>12</td>
<td>&#x2F;var</td>
<td>存放运行时需要改变数据的文件，例如日志文件</td>
</tr>
</tbody></table>
<h3 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h3><h6 id="命令-参数选项-文件或路径"><a href="#命令-参数选项-文件或路径" class="headerlink" title="命令 [参数选项] [文件或路径]"></a>命令 [参数选项] [文件或路径]</h6><h5 id="Linux文件操作核心命令"><a href="#Linux文件操作核心命令" class="headerlink" title="Linux文件操作核心命令"></a>Linux文件操作核心命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前目录</td>
</tr>
<tr>
<td><strong>ls</strong>、ll(详细列表)</td>
<td>显示目录内容</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td><strong>cp</strong></td>
<td>复制文件与目录</td>
</tr>
<tr>
<td><strong>mv</strong></td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件或目录</td>
</tr>
<tr>
<td>find</td>
<td>查找目录或文件</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43585157/article/details/106992907">Xshell连接虚拟机详细教程-CSDN博客</a></p>
<pre><code class="java">按下Tab可以自动提示
输入su 密码root 进入root最高权限

cd ..                 返回上级目录
cd ./local             ./代表当前目录
cd local            到当前目录    

mkdir ./imooc
mkdir -p ./imooc/sample/demo       -p是连续创建多级目录

mkdir -p ./imooc1/sample1
mkdir -p -v./imooc1/sample1     -v是显示执行过程
mkdir -p -v./imooc1/sample1/demo1
=
mkdir -pv ./imooc1/sample1
    
cp Xftp-7.0.014lp.exe ./imooc/sample/demo 文件复制到指定目录
cp -r imooc/sample/demo imooc1/sample1/demo1 复制整个文件夹

cd imooc/sample/demo
mv Xftp-7.0.014lp.exe xftp.exe 重命名
ls

mv xftp.exe /imooc1/sample1/demo1 移动到其他目录
mv demo imooc1/sample1/demo1 移动文件夹到其他目录

cd game/share
rm -r music  y y y    依次删除文件夹中的文件
rm -f music 强制直接删除, 不经过询问
rm -rf music 强制迭代删除            【不要轻易使用】
【ex】 rm -rf / imooc/sample/demo 中间不小心加了空格 就把/后面的整个都删除了

find / -name *.exe 按指定的格式去搜索文件
cd ..
[root@imooc home] find / -name *
</code></pre>
<h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h3><h6 id="远程在线文本编辑器"><a href="#远程在线文本编辑器" class="headerlink" title="远程在线文本编辑器"></a>远程在线文本编辑器</h6><ul>
<li>vi是linux重要的文字编辑工具，vim是增强版</li>
<li>vim用于在远程环境下用命令形式对文本进行在线编辑</li>
<li>用法格式：<strong>vim [选项] [文件]</strong></li>
</ul>
<h3 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h3><ul>
<li>普通模式：默认模式，文本只读，不可编辑</li>
<li>编辑模式：编辑文本模式，普通模式按i键进入，ESC键退出</li>
<li>命令模式：执行保存、搜索、退出等操作</li>
</ul>
<h3 id="vim重要快捷键"><a href="#vim重要快捷键" class="headerlink" title="vim重要快捷键"></a>vim重要快捷键</h3><p>按<strong>i</strong>进入编辑模式</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>delete或x</td>
<td>删除单个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>&#x2F;str</td>
<td>全文查找str字符串，n下一个，N前一个</td>
</tr>
<tr>
<td>:% s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换文件内所有old字符串为new</td>
</tr>
<tr>
<td>u</td>
<td>撤销最近一次操作</td>
</tr>
<tr>
<td>:wq或者**:wq!**</td>
<td><strong>退出并保存</strong>，只读文件要格外加！</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出放弃保存</td>
</tr>
</tbody></table>
<pre><code class="java">vim server.xml         修改文件
按i进入编辑模式
Home跳转行首
End跳转行尾
Esc退出编辑模式

命令只允许在普通模式下运行
/8080                     查找端口(高亮显示)
查找到后按n是查找下一个 按N是查找上一个
u  撤销最近一次操作
:% s/8080/8900/g        进行端口的全局替换
:% s/&quot;80&quot;/8900/g         想要把80改成8900 且不影响其他数值[把引号也加入其中]
</code></pre>
<h3 id="Linux文本工具"><a href="#Linux文本工具" class="headerlink" title="Linux文本工具"></a>Linux文本工具</h3><h5 id="常用文本工具"><a href="#常用文本工具" class="headerlink" title="常用文本工具"></a>常用文本工具</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>屏幕打印与文本输出 后面要加引号”hello”</td>
</tr>
<tr>
<td>cat</td>
<td>合并文件或查看文件内容</td>
</tr>
<tr>
<td>tail</td>
<td>显示文件内容尾部</td>
</tr>
<tr>
<td>grep</td>
<td>文本过滤工具</td>
</tr>
</tbody></table>
<pre><code class="java">echo &quot;hello&quot; &gt; hello.txt 将左侧命令的结果重写到右侧文件
vim hello.txt
:q        退出

echo &quot;hello&quot; &gt;&gt; hello.txt 内容的追加

cat hello.txt 直接打印到控制台
cat -n hello.txt  -n是在每一行前加行号
cat -nE hello.txt  结尾的时候显示结束符$

echo &quot;hello&quot; &gt; hello.txt
cat hello.txt  =&gt; hello
echo &quot;my name is lili&quot; &gt; myname.txt
cat hello.txt myname.txt &gt;&gt; full.txt    合并文件内容为新的文件    
vim full.txt
echo 和 cat 在实际开发中 打印日志 最后用cat拼接日志

cat &gt; test.txt &lt;&lt; EOF   在当前的输入环境中产生输入流 输入的全输入到test.txt 输入流结束字符串是EOF
&gt; Welcome to imooc.com
&gt; I like linux
&gt; bye!
&gt; EOF

tail处理日志很方便 bug日志
tail full.txt =&gt; hello       my name is lili
tail -n 1 full.txt =&gt; my name is lili   &quot;1&quot;代表显示文本最后一行
tail -f full.txt      对文件进行监听 一旦产生变化就输出控制台【适合用在服务器】
ctrl + c 退出

#cat test.txt
=&gt; welcome to imooc.com
=&gt; I like linux
=&gt; bye!
#grep l test.txt
we&quot;l&quot;come to imooc.com
I &quot;l&quot;ike &quot;l&quot;inux

#grep l test.txt &gt; out.txt            符合条件的可以输出到out.txt文件中
#grep -v l test.txt                    -v 挑选出不包含l的test.txt文件
#grep i...c test.txt                &quot;.&quot;代表匹配任意字符

#ll | grep .txt                     通道特殊使用方法：筛选出后缀是.txt的 
前面ll命令输出的结果会作为后面gerp命令的依据   通过|进行分割 

#ll | grep -E &quot;log[0-9]&#123;1,5&#125;.txt&quot;    通道特殊使用方法：扩展正则表达式
-rw-r--r--. 1 root root 3 12月 23 13:10 log1.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log2.txt
-rw-r--r--. 1 root root 3 12月 23 13:10 log3.txt
</code></pre>
<h3 id="文件打包-文件组织-与压缩-磁盘节省"><a href="#文件打包-文件组织-与压缩-磁盘节省" class="headerlink" title="文件打包[文件组织]与压缩[磁盘节省]"></a>文件打包<del>[文件组织]</del>与压缩<del>[磁盘节省]</del></h3><h5 id="Linux压缩程序-gzip"><a href="#Linux压缩程序-gzip" class="headerlink" title="Linux压缩程序-gzip"></a>Linux压缩程序-gzip</h5><ul>
<li>gzip是Linux系统的文件压缩程序</li>
<li>gzip压缩包文件扩展名 <strong>.gz</strong></li>
<li>大流量的网站默认都在使用 <strong>gzip</strong> 进行数据压缩传输</li>
</ul>
<h5 id="tar打包与压缩"><a href="#tar打包与压缩" class="headerlink" title="tar打包与压缩"></a>tar打包与压缩</h5><ul>
<li>tar是linux系统将多个文件打包和压缩的工具</li>
<li>tar本质的打包软件，扩展名是 **.tar **</li>
<li>tar可结合gzip或其他压缩工具实现打包压缩，扩展名 <strong>.tar.gz</strong></li>
<li><strong>压缩命令：</strong><code>tar zcvf tomcat.tar.gz game/src</code></li>
<li><strong>解压缩命令：</strong><code>tar zxvf tomcat.tar.gz -C game/src</code></li>
</ul>
<h3 id="tar常用可选项"><a href="#tar常用可选项" class="headerlink" title="tar常用可选项"></a>tar常用可选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>通过gzip压缩或解压</td>
</tr>
<tr>
<td>c</td>
<td>创建新的tar.gz文件</td>
</tr>
<tr>
<td>v</td>
<td>显示执行过程</td>
</tr>
<tr>
<td>f</td>
<td>指定压缩文件名称</td>
</tr>
<tr>
<td>x</td>
<td>解压缩tar.gz文件</td>
</tr>
<tr>
<td>-C</td>
<td>指定解压缩目录</td>
</tr>
</tbody></table>
<h3 id="安装与卸载应用程序"><a href="#安装与卸载应用程序" class="headerlink" title="安装与卸载应用程序"></a>安装与卸载应用程序</h3><h5 id="为CentOS安装应用程序"><a href="#为CentOS安装应用程序" class="headerlink" title="为CentOS安装应用程序"></a>为CentOS安装应用程序</h5><ul>
<li><span style = "color:red">在CentOS中安装第三方应用程序包含<strong>两种方式</strong>：</span><ul>
<li>rpm: Red Hat 软件包管理器, 相当于应用程序安装文件的执行者</li>
<li><strong><u>编译安装</u><strong>：用户自己从网站下载程序</strong>源码</strong>进行<strong>编译安装</strong></li>
</ul>
</li>
</ul>
<h3 id="yum与rpm的关系"><a href="#yum与rpm的关系" class="headerlink" title="yum与rpm的关系"></a>yum与rpm的关系</h3><ul>
<li>rpm安装过程中, 需要用户自己解决依赖问题</li>
<li>yum通过引入软件仓库，联网下载rpm包及依赖，并依次自动安装</li>
<li>yum是rpm的前端程序，其目的就是简化rpm的安装过程</li>
</ul>
<h5 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h5><ul>
<li>yum search 应用名                  #在仓库中查询是否存在指定应用</li>
<li>yum instal -y 应用名                #全自动下载安装应用及依赖</li>
<li>yum info 应用名                       #查看应用详细信息</li>
<li>yum list installed 应用名         #查看已安装的应用程序</li>
<li>rpm -ql 应用名                          #查看安装后输出的文件清单</li>
<li>yum remove -y 应用名            #全自动卸载指定应用</li>
</ul>
<h5 id="①-利用yum安装tree"><a href="#①-利用yum安装tree" class="headerlink" title="① 利用yum安装tree"></a>① 利用yum安装tree</h5><pre><code class="java">yum search tree
yum install tree.x86_64 安装tree
yum install -y tree.x86_64 遇到所有的默认y进行安装
tree -d 或 tree                查看文件树型结构
which tree                     查看刚刚tree安装的目录
rpm -ql tree.x86_64         查看刚刚tree安装了哪些文件
yum list installed          查看已经安装的应用
yum list installed *tree*   查看已安装的应用其中有tree的
    
yum remove tree.x86_64  卸载程序
</code></pre>
<h5 id="②-利用编译方式安装应用程序"><a href="#②-利用编译方式安装应用程序" class="headerlink" title="② 利用编译方式安装应用程序"></a>② 利用编译方式安装应用程序</h5><ul>
<li>如yum仓库未提供rpm，往往需要采用编译安装方式</li>
<li>编译安装是指从应用网站下载源码后，对源码进行编译后使用</li>
<li>编译命令：**make #**使用对应编译器对源码编译生成可执行文件</li>
</ul>
<h6 id="yum与编译安装的比较"><a href="#yum与编译安装的比较" class="headerlink" title="yum与编译安装的比较"></a>yum与编译安装的比较</h6><table>
<thead>
<tr>
<th></th>
<th>yum安装</th>
<th>编译安装</th>
</tr>
</thead>
<tbody><tr>
<td>兼容性</td>
<td>差，每种发行版都要准备</td>
<td>好，全平台适用</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>安装速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>来源</td>
<td>应用仓库</td>
<td>官网下载</td>
</tr>
<tr>
<td>应用场景</td>
<td>日常系统软件</td>
<td>开源软件，最新版本</td>
</tr>
</tbody></table>
<h3 id="编译安装Redis-非关系型数据库"><a href="#编译安装Redis-非关系型数据库" class="headerlink" title="编译安装Redis[非关系型数据库]"></a>编译安装Redis<del>[非关系型数据库]</del></h3><pre><code class="java"># make
# yum install -y gcc
# cd ..
# clear
# rm -rf ./redis-4.0.14
# tar zxvf redis-4.0.14.tar,gz
# cd redis-4.0.14/
# clear
# make

[root@imooc redis-4.0.14]# ./src/redis-server redis.conf
</code></pre>
<h3 id="Linux系统管理命令"><a href="#Linux系统管理命令" class="headerlink" title="Linux系统管理命令"></a>Linux系统管理命令</h3><h5 id="使用-ifconfig-查看网卡ip"><a href="#使用-ifconfig-查看网卡ip" class="headerlink" title="使用 ifconfig 查看网卡ip"></a>使用 <code>ifconfig</code> 查看网卡ip</h5><h4 id="netstat-查看网络端口号"><a href="#netstat-查看网络端口号" class="headerlink" title="netstat 查看网络端口号"></a><code>netstat</code> 查看网络端口号</h4><ul>
<li><p><strong>netstat -tulpn</strong> 或者 <strong>netstat -ano</strong></p>
<ul>
<li><p><strong>netstat</strong> 常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>显示tcp传输协议的连接状况</td>
</tr>
<tr>
<td>u</td>
<td>显示udp传输协议的连接状况</td>
</tr>
<tr>
<td>l</td>
<td>显示处于监听状态的网络连接</td>
</tr>
<tr>
<td>p</td>
<td>显示应用PID和程序名称</td>
</tr>
<tr>
<td>n</td>
<td>显示ip地址</td>
</tr>
<tr>
<td>a</td>
<td>显示所有连接</td>
</tr>
<tr>
<td>o</td>
<td>显示计时器</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="查看进程-amp-杀掉进程"><a href="#查看进程-amp-杀掉进程" class="headerlink" title="查看进程 &amp; 杀掉进程"></a>查看进程 &amp; 杀掉进程</h4><ul>
<li><strong>ps -ef</strong><br><code># ps -ef | grep vim</code>     ‘|’代表通道</li>
<li>**kill -9 PID ** 专门按照pid杀死指定进程(强制删除)</li>
</ul>
<pre><code class="java">#ps -ef | grep redis
#netstart -tulpn | grep 6379
</code></pre>
<h3 id="应用服务化"><a href="#应用服务化" class="headerlink" title="应用服务化"></a>应用服务化</h3><ul>
<li>应用服务化是指让应用程序以服务方式在系统后台运行</li>
<li>Linux系统对服务化应用进行统一管理</li>
<li>服务管理命令：<strong>systemctl</strong></li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>启动服务</td>
</tr>
<tr>
<td>stop</td>
<td>停止服务</td>
</tr>
<tr>
<td>restart</td>
<td>重启服务</td>
</tr>
<tr>
<td>enable</td>
<td>设置开机启动</td>
</tr>
<tr>
<td>disable</td>
<td>禁止开机启动</td>
</tr>
<tr>
<td>status</td>
<td>查看服务状态</td>
</tr>
<tr>
<td>daemon-reload</td>
<td>重载服务配置文件</td>
</tr>
<tr>
<td>list-unit-files</td>
<td>列出所有服务</td>
</tr>
</tbody></table>
<pre><code class="java">启动redis
./src/redis-server redis.conf  进入到redis安装目录下执行
ctrl + z 
#ps -ef | grep redis

#find / -name *.pid

cd.. cd.. cd.. 
cd usr/lib/systemd/system 
#pwd
=&gt;/usr/lib/systemd/system 
#vim redis.service 按i进入编写模式
=&gt;
&lt;==========================================================================&gt;
[Unit]
Description=Redis
After=syslog.target network.target remote-fs.target nss-lookup.target

[Service]
Type=forking                    #描述服务类型：后台运行
PIDFile=/run/redis_6379.pid     #指向刚刚继承编号的pid
ExecStart=/usr/local/redis-4.0.14/src/redis-server /usr/local/redis-4.0.14/redis.conf                                 #服务启动时使用什么命令 调用redis-server
ExecStop=/bin/kill -s QUIT $MAINPID 
                                #对指定的命令关闭 $后自动带入pidfile  -s quit是按正常流程关闭
PrivateTmp=true
            
[Install]
WantedBy=multi-user.target         #将radis分配到multi-user.target服务组上[随系统自动启动]
&lt;==========================================================================&gt;
[root@imooc system]#systemctl daemon-reload   对所有redis进行重载

[root@imooc system]#ps -ef | grep redis  
[root@imooc system]#kill -s QUIT #杀死所有redis进程测试能否实现自启动
[root@imooc system]#systemctl start redis
[root@imooc system]#systemctl status redis

https://www.cnblogs.com/niway/p/15346572.html

[root@imooc system]#systemctl stop redis  #停止服务
[root@imooc system]#systemctl enable redis #随着系统启动
[root@imooc system]#systemctl list-unit-files #查看系统中每一个服务命令
[root@imooc system]#systemctl list-unit-files | grep enabled #查看自启动的命令

[root@imooc system]#shutdown -r now   #断开连接
</code></pre>
<h3 id="Linux用户与权限"><a href="#Linux用户与权限" class="headerlink" title="Linux用户与权限"></a>Linux用户与权限</h3><h5 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h5><ul>
<li>Linux是多用户多任务系统，包含两个概念：<strong>用户</strong>与<strong>用户组</strong></li>
<li>用户与账户是同一概念，用于登录系统与区分资源权限</li>
<li>用户让系统变的更安全，同时也保护了用户的个人数字资产</li>
</ul>
<h5 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h5><ul>
<li>用户组就是将用户分组，隶属用户自动拥有组权限</li>
<li>一个用户可隶属于多个组，用户可任意切换当前组</li>
<li>用户组的出现让用户权限管理变更轻松</li>
</ul>
<h5 id="用户与用户组的常用命令"><a href="#用户与用户组的常用命令" class="headerlink" title="用户与用户组的常用命令"></a>用户与用户组的常用命令</h5><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>useradd</td>
<td>创建新用户</td>
</tr>
<tr>
<td>passwd</td>
<td>修改密码</td>
</tr>
<tr>
<td>usermod</td>
<td>修改用户信息&#x2F;分配组 (覆盖原组)</td>
</tr>
<tr>
<td>groupadd</td>
<td>创建新的用户组</td>
</tr>
<tr>
<td><strong>chown</strong></td>
<td>更改文件的属主或属组</td>
</tr>
<tr>
<td><strong>chmod</strong></td>
<td>更改文件的访问权限</td>
</tr>
<tr>
<td>newgrp</td>
<td>切换用户当前组</td>
</tr>
</tbody></table>
<h3 id="项目内部文件权限管理实践"><a href="#项目内部文件权限管理实践" class="headerlink" title="项目内部文件权限管理实践"></a>项目内部文件权限管理实践</h3><pre><code class="java">3员工(2个程序员 1个测试员)
[root@imooc imooc]# adduser d1
[root@imooc imooc]# adduser d2
[root@imooc imooc]# adduser t1
[root@imooc imooc]# passwd d1 =&gt; shuangyu1
[root@imooc imooc]# passwd d2 =&gt; shuangyu2
[root@imooc imooc]# passwd t1 =&gt; shuangyu3
[root@imooc imooc]# groupadd developer
[root@imooc imooc]# groupadd testor
[root@imooc imooc]# usermod -g developer d1
[root@imooc imooc]# usermod -g developer d2
[root@imooc imooc]# usermod -g testor t1
在上方点击打开 并且复制3个Centos7 分别改用户名(d1 d2 t1)和密码(shuangyu1/2/3) 
[root@imooc imooc]# cd
[root@imooc ~]# cd /usr/local/share
[root@imooc share]# mkdir dev-document
[root@imooc share]# ll
drwxr-xr-x.  2 root root  28 11月 15 18:37 applications
drwxr-xr-x.  2 root root   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root   6 4月  11 2018 info
drwxr-xr-x. 21 root root 243 11月 15 18:25 man
【前方的drwxr-xr-x 含义见图】

[root@imooc share]# chown d1:developer dev-document  更改对应目录文件的属主(由超级管理员交給研发组) d1可以对developer拥有完整的操作权限 developer以外的用户有读取执行权 其他用户 只有执行权
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-xr-x.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

[root@imooc share]# chmod 750 dev-document/ 其他用户不允许任何权限
[root@imooc share]# ll
总用量 0
drwxr-xr-x.  2 root root       28 11月 15 18:37 applications
drwxr-x---.  2 d1   developer   6 12月  3 20:36 dev-document
drwxr-xr-x.  2 root root        6 4月  11 2018 info
drwxr-xr-x. 21 root root      243 11月 15 18:25 man

返回到Centos 7 - t1
[t1@imooc ~]$ cd /usr/local/share/dev-document/
-bash: cd: /usr/local/share/dev-document/: 权限不够
返回到Centos 7 - d2
[d2@imooc ~]$ cd /usr/local/share
[d2@imooc share]$ mv dev-document/ doc
mv: 无法将&quot;dev-document/&quot; 移动至&quot;doc&quot;: 权限不够


上方的chmod 750 的意思是 对应下方的表 第一个7是第一个rwx相加之和4+2+1
====================chmod命令====================
★ chmod 750：组用户可读写，其他用户不允许访问 ★        
★ chmod 777：所有用户拥有完整权限 ★
★ chmod 700：只有属主拥有完整权限 ★
====================++++++++====================
d1弄个文档整个公司的所有人都可以使用
[d1@imooc ~]$ cd /usr/local/share/dev-document/
[d1@imooc dev-document]$ vim code.md
[d1@imooc dev-document]$ ll
-rw-r--r--. 1 d1 developer 13 12月  3 20:59 code.md
第一个是d则是文件夹 -则是文件 属主可以对文件读写。组仅仅可以读取。其他人仅仅可以读取
[d1@imooc dev-document]$ chmod 770 code.md
[d1@imooc dev-document]$ ll
总用量 4
-rwxrwx---. 1 d1 developer 13 12月  3 20:59 code.md
d2即可读写
[d2@imooc dev-document]$ vim code.md

如何让d1同时拥有两个组
[root@imooc share]# usermod -G developer,testor d1
[root@imooc share]# groups d1
d1: developer testor

将当前组切换到新的用户组上
[d1@imooc ~]$ newgrp testor
[d1@imooc ~]$ groups
d1：testor developer
</code></pre>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/2ee7e298b43a3cdebf4f9be2ae0e3f72592adee2/data/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%BB%A3%E7%A0%81%E8%A1%A8.png"></p>
<h3 id="sudo获取超级管理员权限"><a href="#sudo获取超级管理员权限" class="headerlink" title="sudo获取超级管理员权限"></a>sudo获取超级管理员权限</h3><ul>
<li>sudo可以让普通用户拥有超级管理员的执行权限</li>
<li>普通用户要经过超级管理员授权才能使用</li>
<li>授权命令：visudo</li>
</ul>
<pre><code class="java">在root端输入 visudo 并且输入100gg 快速定位到100行
[root@imooc ~]#visudo
## The COMMANDS section may have other options added to it.
##
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1        ALL=(ALL)        ALL     #按i进入编辑模式且增加此行
        ↑：ALL任意电脑可以连接    后ALL可以切换其他用户执行命令   后后ALL允许哪些命令
ESC退出模式后输入
[root@imooc imooc]# visudo -c
/etc/sudoers：解析正确


[d1@imooc ~]$ useradd d3    #目前还没有权限
useradd: Permission denied.
useradd：无法锁定 /etc/passwd，请稍后再试。
[d1@imooc ~]$ sudo useradd d3     #以d1的身份給d3一个超级管理员的权限
我们信任您已经从系统管理员那里了解了日常注意事项。
总结起来无外乎这三点：

    #1) 尊重别人的隐私。
    #2) 输入前要先考虑(后果和风险)。
    #3) 权力越大，责任越大。

[sudo] d1 的密码：=》 shuangyu1
[d1@imooc ~]$ sudo passwd d3 
更改用户 d3 的密码 =》 shuangyu33

回到主Centos 7
[root@imooc ~]#visudo
## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL
d1      ALL=(ALL)       NOPASSWD:ALL
NOPASSWD:ALL意味着做任何命令之前不用输入密码

[d1@imooc ~]$ sudo useradd d4
[d1@imooc ~]$                     #直接不需要输入密码了
</code></pre>
<h3 id="CentOS7防火墙firewall"><a href="#CentOS7防火墙firewall" class="headerlink" title="CentOS7防火墙firewall"></a>CentOS7防火墙firewall</h3><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><ul>
<li>防火墙是借助硬件和软件对内外部网络环境的保护措施</li>
<li>CentOS 7基于firewall实现应用层防火墙，CentOS6基于iptables</li>
<li>firewall-cmd是firewall的核心命令</li>
</ul>
<h5 id="对外开放Tomcat"><a href="#对外开放Tomcat" class="headerlink" title="对外开放Tomcat"></a>对外开放Tomcat</h5><pre><code class="java">把apache-tomcat.tar.gz放入/usr/local中 
[root@imooc local]# tar zxvf apache-tomcat-9.0.34.tar.gz
[root@imooc local]# ll
[root@imooc local]# cd apache-tomcat-9.0.34/
[root@imooc apache-tomcat-9.0.34]# cd bin
[root@imooc bin]# ./startup.sh
[root@imooc bin]# ./startup.sh
Using CATALINA_BASE:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_HOME:   /usr/local/apache-tomcat-9.0.34
Using CATALINA_TMPDIR: /usr/local/apache-tomcat-9.0.34/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/apache-tomcat-9.0.34/bin/bootstrap.jar:/usr/local/apache-tomcat-9.0.34/bin/tomcat-juli.jar
Tomcat started.
[root@imooc bin]# netstat -tulpn|grep 8080  #查看端口是否开启
tcp6    0    0 :::8080        :::*         LISTEN      4302/java  
在虚拟机内部去fox浏览器搜索 localhost:8080  就会看到可爱的绿色小猫咪
    
若想在计算机中访问端口 192.168.170.129:8080 则需要关闭虚拟机的防火墙
[root@imooc bin]# firewall-cmd --state   #查看防火墙状态
running
[root@imooc bin]# firewall-cmd --list-ports #查看防火墙放行的端口(空代表无任何放行端口)
[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8080/tcp
#### zone防火墙定义的规则区域、产生永久变更、增加端口8080、tcp形式
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

若不需要开放8080端口则需要
[root@imooc bin]# firewall-cmd --zone=public --permanent --remove-port=8080/tcp
[root@imooc bin]# firewall-cmd --reload  #进行配置重载

[root@imooc bin]# firewall-cmd --zone=public --permanent --add-port=8000-9000/tcp 
###放行区域端口
[root@imooc bin]# firewall-cmd --reload  #进行配置重载
</code></pre>
<h3 id="Bash-Shell"><a href="#Bash-Shell" class="headerlink" title="Bash Shell"></a>Bash Shell</h3><ul>
<li>Shell是一个用c语言编写的脚本解释器，是用户通过代码操作Linux的桥梁</li>
<li>Shell脚本描述要执行的任务，完成系列复杂操作，文件通常以**.sh**后缀</li>
<li>Shell脚本通过Shell解释器执行，按解释器分类分为多种类型</li>
</ul>
<h3 id="Linux-Shell分类"><a href="#Linux-Shell分类" class="headerlink" title="Linux Shell分类"></a>Linux Shell分类</h3><table>
<thead>
<tr>
<th>Shell种类</th>
<th>Shell解释器</th>
</tr>
</thead>
<tbody><tr>
<td>Bourne Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;sh 或 &#x2F;bin&#x2F;sh</td>
</tr>
<tr>
<td><strong>Boourne Again Shell</strong></td>
<td><strong>&#x2F;bin&#x2F;bash(默认)</strong></td>
</tr>
<tr>
<td>C Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;csh</td>
</tr>
<tr>
<td>K Shell</td>
<td>&#x2F;usr&#x2F;bin&#x2F;ksh</td>
</tr>
<tr>
<td>Shell for Root</td>
<td>&#x2F;sbin&#x2F;sh</td>
</tr>
</tbody></table>
<h5 id="一键发布Tomcat应用程序"><a href="#一键发布Tomcat应用程序" class="headerlink" title="一键发布Tomcat应用程序"></a>一键发布Tomcat应用程序</h5><pre><code class="java">编写shall脚本
[root@imooc local]# vim deploy_tomcat.sh
======================================================================
echo &quot;准备下载Tomcat9&quot;
wget https://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.34/bin/apache-tomcat-9.0.34.tar.gz
echo &quot;正在解压缩Tomcat9&quot;
tar zxf apache-tomcat-9.0.34.tar,gz
echo &quot;防火墙开放8080端口&quot;
firewall-cmd --zone=public --permanent --add-port=8080/tcp
firewall-cmd --reload
echo &quot;启动Tomcat&quot;
cd ./apache-tomcat-9.0.34/bin
./startup.sh
======================================================================
[root@imooc local]# ./deploy_tomcat.sh        开启文件
</code></pre>
<h3 id="综合训练：Linux部署慕课网办公OA"><a href="#综合训练：Linux部署慕课网办公OA" class="headerlink" title="综合训练：Linux部署慕课网办公OA"></a>综合训练：Linux部署慕课网办公OA</h3><h5 id="部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】"><a href="#部署架构：Chrome-Tomcat-Web服务器-MySQL服务器-【中间通过网络通信】" class="headerlink" title="部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】"></a>部署架构：Chrome + Tomcat Web服务器 + MySQL服务器 【中间通过网络通信】</h5><pre><code class="java">重新安装CentOS 7-DB【最小值安装】
[root@localhost ~]# yum install -y net-tools
CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
DB按照MySQL
WEB按照Tomcat
</code></pre>
<h3 id="CentOS安装MySQL-8"><a href="#CentOS安装MySQL-8" class="headerlink" title="CentOS安装MySQL 8"></a>CentOS安装MySQL 8</h3><pre><code class="java">查找有没有mysql安装包
[centos-db@localhost ~]$ yum search mysql-community
去官网找到Linux版的 右键复制链接地址
[root@localhost ~]# wget https://dev.mysql.com/get/mysql80-community-release-el7-11.noarch.rpm
bash: wget: command not found
卧槽 wegt不存在，那就按装wget
[root@localhost ~]# yum install -y wget
[root@localhost mysql]# ll
total 16
-rw-r--r--. 1 root root 14064 Oct 24 07:44 mysql80-community-release-el7-11.noarch.rpm

[root@localhost mysql]# yum localinstall -y mysql80-community-release-el7- 11.noarch.rpm     #自动安装mysql源
[root@localhost mysql]# yum search mysql-comm #此时查找一下就会出现大量mysql组件
[root@localhost mysql]# yum install -y mysql-community-server #安装mysql&#123;在欧美很慢&#125;
ctrl+c 停止安装
[root@localhost mysql]# cd /var/cache/yum/x86_64/7/mysql80-community/packages/
#yum下载的缓存路径 在网上下载好后Linux版的MySQL后 进入

[root@localhost mysql80-community]  /var/cache/yum/x86_64/7/mysql80-community
用命令更改文件夹权限：chmod 777 test01（需要赋予权限的文件夹）
之后将解压缩的MySQL拖进去

注意：如果直接下载 yum localinstall mysql80-community-release-el7- 11.noarch.rpm  的话会有很多依赖不会被自动下载，最保准的就是去网上下载Linux版本的MySQL再利用Xftp拖进去

[root@localhost package]# yum install -y mysql-community-server 【最快最省事 自动下载&amp;安装依赖】
[root@localhost package]# systemctl start mysqld
[root@localhost package]# netstat -tulpn
tcp6    0    0    :::3306        :::*        LISTEM        21850/mysqld
[root@localhost package]# systemctl status mysqld     #查看myql启动状态
[root@localhost package]# systemctl enable mysqld     #设置开机自启动
</code></pre>
<h3 id="初始化MySQL-CentOS-7-DB"><a href="#初始化MySQL-CentOS-7-DB" class="headerlink" title="初始化MySQL[CentOS 7-DB]"></a>初始化MySQL[CentOS 7-DB]</h3><pre><code class="java">查看mysql日志寻找mysql密码
[root@localhost package]# vi /var/log/mysqld.log
root@localhost: Y,#)foTQ,7js
[root@localhost package]# mysql -uroot -p
修改密码！
mysql&gt; alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;Panchunyao123!&#39;
mysql&gt; use mysql
mysql&gt; select host,user from user;
mysql&gt; update user set host=&#39;%&#39; where user=&#39;root&#39;; #任意设备都可使用%连接到mysql服务器
host: %            user: root
mysql&gt; flush privileges; #使修改的权限数据生效
mysql&gt; exit

下一步是放行防火墙3306端口
[root@localhost package]# firewall-cmd --zone=public --permanent --add-port=3306/tcp
[root@localhost package]# firewall-cmd --reload

去电脑端的Navicat Premium 连接新数据库
MySQL-新建连接
连接名：centos-db
主机：192.168.170.131
端口：3306
用户名：root
密码：Panchunyao123！

新建数据库 imooc-oa  utf8mb4 执行sql文件 imooc-oa.sql
</code></pre>
<h3 id="部署配置Web应用服务器"><a href="#部署配置Web应用服务器" class="headerlink" title="部署配置Web应用服务器"></a>部署配置Web应用服务器</h3><pre><code class="java">CentOS 7-DB        ifconfig ==》 192.168.170.131    账户：centos-db 密码：panchunyao123
CentOS 7-WEB    ifconfig ==》 192.168.170.133    账户：centos-web 密码：panchunyao123
</code></pre>
<pre><code class="java">[root@localhost ~]# yum search jdk  #查看仓库中包含哪些jdk
[root@localhost ~]# yum install -y java-1.8.0-openjdk    #安装jdk以及所有依赖
[root@localhost ~]# java -version
[root@localhost ~]# which java      #查看安装到哪个地方
/bin/java
安装tomcat
[root@localhost ~]# cd /usr
用命令更改文件夹权限：chmod 777 local
[root@localhost usr]# cd local
打开Xftp将apache-tomcat-9.0.34.tar.gz 传入到local内
[root@localhost local]# tar zxf apache-tomcat-9.0.34.tar.gz     #对压缩包进行解压
将素材资料里的imooc_oa.war拖入Xftp的local中 之后进行解压
[root@localhost local]# tar zxf imooc_oa.war 
需要将imooc_oa复制到tomcat9的webapps下才可生效
[root@localhost local]# mv imooc_oa ./apache-tomcat-9.0.34/webapps/
[root@localhost local]# cd apache-tomcat-9.0.34/webapps/
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
#远程对服务器配置连接数据库服务器
-bash: vim: 未找到命令 需要先安装vim
[root@localhost webapps]# yum install -y vim-common
[root@localhost webapps]# yum install -y vim-enhanced  #再安装一个增强的vim包
[root@localhost webapps]# vim ./imooc_oa/WEB-INF/classes/mybatis-config.xml
输入/root 进行全文查找 修改&lt;property 中的value=&quot;jdbc:mysql:...&quot; loacalhost改为自己网络ip：192.168.170.131
再修改一下下面的password：  Panchunyao123！
:wq
[root@localhost webapps]# cd ..
[root@localhost apache-tomcat-9.0.34]# vim ./conf/server.xml
/8080 搜索 &lt;Connector port=&quot;80&quot; 只保留80端口
/Host&gt; 找到最下面 在上面一行加入
&lt;Context path=&quot;/&quot; docaBacs=&quot;imooc_oa&quot;/&gt; #将imooc_oa目录映射到根路径&quot;/&quot;
:wq

之后启动tomcat
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
[root@localhost apache-tomcat-9.0.34]# netstat -tulpn  #查看进程
tcp6        0        0 :::80        :::*        LISTEN        20303/java

用防火墙将80端口对外进行暴露
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --zone=public --permanent --add-port=80/tcp
[root@localhost apache-tomcat-9.0.34]# firewall-cmd --reload  #重载

回到电脑浏览器输入：http://192.168.170.133/login.html

数据库安全【根据3306端口可以查到数据库根源】：对指定IP端口进行放行
[root@localhost ~]# firewall-cmd --zone=public --permanent --remove-port=3306/tcp
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.170.133&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept &quot;    #-rich-rule防火墙内部规则强大的定义表达式
[root@localhost ~]# firewall-cmd --reload  #重载
[root@localhost apache-tomcat-9.0.34]# ./bin/shutdown.sh
[root@localhost apache-tomcat-9.0.34]# ./bin/startup.sh
</code></pre>
<hr>
<hr>
<h1 id="Redis-内存-非常快-数据库、非关系型数据库"><a href="#Redis-内存-非常快-数据库、非关系型数据库" class="headerlink" title="Redis (内存[非常快]数据库、非关系型数据库)"></a>Redis (内存<del>[非常快]</del>数据库、非关系型数据库)</h1><ul>
<li>Redis是<strong>Key-Value型</strong>NoSQL数据库</li>
<li><strong>Redis</strong>将数据<strong>存储在内存(RAM)中</strong>，同时也能<strong>持久化到磁盘</strong></li>
<li>Redis常用于缓存，利用内存的高效提高程序的处理速度</li>
</ul>
<h5 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h5><ul>
<li>速度快</li>
<li>广泛的语言支持</li>
<li>持久化</li>
<li>多种数据结构</li>
<li>主从复制(多台Redis可以保持数据同步)</li>
<li>分布式与高可用(7×24小时服务 淘宝&#x2F;京东) 全国各地多个主机 降低网络传输时间</li>
</ul>
<h3 id="Redis的安装与启动"><a href="#Redis的安装与启动" class="headerlink" title="Redis的安装与启动"></a>Redis的安装与启动</h3><ul>
<li>在Linux系统中安装redis (<a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a>)</li>
</ul>
<pre><code class="java">$ wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
$ tar xzf redis-5.0.2.tar.gz
$ cd redis-5.0.2
$ make
</code></pre>
<pre><code class="java">[root@imooc imooc]# cd /usr/local
[root@imooc local]# ll
[root@imooc local]# mkdir redis
[root@imooc local]# ll
[root@imooc local]# cd redic
[root@imooc redic]# yum install gcc
[root@imooc redic]# wegt http://download.redis.io/releases/redis-5.0.2.tar.gz
[root@imooc redis]# tar xzf redis-5.0.2.tar.gz
[root@imooc redis]# cd redis-5.0.2
[root@imooc redis-5.0.2]# make
Hint: It&#39;s a good idea to run &#39;make test&#39; ;)   安装成功
[root@imooc redis-5.0.2]# ll  #找redis.conf
总用量 240
-rw-rw-r--.  1 root root 85327 11月 22 2018 00-RELEASENOTES
-rw-rw-r--.  1 root root    53 11月 22 2018 BUGS
-rw-rw-r--.  1 root root  1894 11月 22 2018 CONTRIBUTING
-rw-rw-r--.  1 root root  1487 11月 22 2018 COPYING
drwxrwxr-x.  6 root root   192 12月  5 11:47 deps
-rw-rw-r--.  1 root root    11 11月 22 2018 INSTALL
-rw-rw-r--.  1 root root   151 11月 22 2018 Makefile
-rw-rw-r--.  1 root root  4223 11月 22 2018 MANIFESTO
-rw-rw-r--.  1 root root 20555 11月 22 2018 README.md
-rw-rw-r--.  1 root root 62155 11月 22 2018 redis.conf
-rwxrwxr-x.  1 root root   275 11月 22 2018 runtest
-rwxrwxr-x.  1 root root   280 11月 22 2018 runtest-cluster
-rwxrwxr-x.  1 root root   281 11月 22 2018 runtest-sentinel
-rw-rw-r--.  1 root root  9710 11月 22 2018 sentinel.conf
drwxrwxr-x.  3 root root  8192 12月  5 11:49 src
drwxrwxr-x. 10 root root   167 11月 22 2018 tests
drwxrwxr-x.  8 root root  4096 11月 22 2018 utils
[root@imooc redis-5.0.2]# cd src
[root@imooc src]# ll     #找redis- server启动目录

[root@imooc src]#cd ..
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
</code></pre>
<pre><code class="java">若端口被占用

找到redis-server的进程，然后杀死对应的进程，然后重新启动redis

&gt;&gt;&gt; ps -ef | grep -i redis
root      3585 19590  0 10:36 pts/20   00:00:00 redis-server *:6379
user      3684  3663  0 10:38 pts/21   00:00:00 grep --color=auto -i redis
进程3585是redis的服务，

kill -9 3585
</code></pre>
<ul>
<li>在Windows系统安装Redis</li>
</ul>
<pre><code class="java">https://github.com/microsoftarchive/redis/releases 下载后解压
打开cmd
C:\Users\Pluminary&gt;d:
D:\&gt;cd Redis-x64-3.0.504
D:\Redis-x64-3.0.504&gt;dir
D:\Redis-x64-3.0.504&gt;redis-server redis.windows.conf
                _._
           _.-``__ &#39;&#39;-._
      _.-``    `.  `_.  &#39;&#39;-._           Redis 3.0.504 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &#39;&#39;-._
 (    &#39;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
 |    `-._   `._    /     _.-&#39;    |     PID: 22828
  `-._    `-._  `-./  _.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
 |    `-._`-._        _.-&#39;_.-&#39;    |
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
      `-._    `-.__.-&#39;    _.-&#39;
          `-._        _.-&#39;
              `-.__.-&#39;
</code></pre>
<h3 id="Redis的常用基本配置"><a href="#Redis的常用基本配置" class="headerlink" title="Redis的常用基本配置"></a>Redis的常用基本配置</h3><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">daemonize</td>
<td align="center">daemonize yes</td>
<td align="center">是否启用后台运行, 默认no</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">port 6379</td>
<td align="center">设置端口号, 默认6379</td>
</tr>
<tr>
<td align="center">logfile</td>
<td align="center">logfile 日志文件</td>
<td align="center">设置日志文件</td>
</tr>
<tr>
<td align="center">databases</td>
<td align="center">databases 255</td>
<td align="center">设置redis数据库总量</td>
</tr>
<tr>
<td align="center">dir</td>
<td align="center">dir 数据文件目录</td>
<td align="center">设置数据文件存储目录</td>
</tr>
<tr>
<td align="center">requirepass</td>
<td align="center">requirepass 12345</td>
<td align="center">设置使用密码</td>
</tr>
</tbody></table>
<h5 id="守护进程方式启动Redis"><a href="#守护进程方式启动Redis" class="headerlink" title="守护进程方式启动Redis"></a>守护进程方式启动Redis</h5><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf    #打开后台启动
136行 daemonize no 改成 daemonize yes
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
关闭终端打开全新终端
[root@imooc ~]# netstat -tulpn
tcp        0        0        127.0.0.1:6379 ...     6338/./src/redis-se

如果关闭
kill -9 6338
</code></pre>
<h5 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h5><pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli    #执行redis内置指令
127.0.0.1:6379&gt; ping        #启动成功
PONG
127.0.0.1:6379&gt; exit        #退出
[root@imooc redis-5.0.2]# ./src/redis-cli shutdown  #更加安全的关闭redis

报错(添加log文件 将redis命令行的结果打印到log中)
https://blog.csdn.net/qq_46127735/article/details/113933690


为了保护安全将port从6379改为6380
[root@imooc redis-5.0.2]# vim redis.conf
/port 寻找92行
port 6380
[root@imooc redis-5.0.2]# ./src/redis-cli -p 6380
127.0.0.1:6380&gt; select 0        #当前使用第几号数据库
127.0.0.1:6380&gt; select 15
[root@imooc redis-5.0.2]# vim redis.conf
在186行 可以改变数据连接数量
databases 15→255
    
[root@imooc redis-5.0.2]# vim redis.conf
507行注释去掉 此行是输入密码
requirepass panchunyao123
再次登录就 
127.0.0.1:6380&gt; auth panchunyao123

redis中有一个dump.rdb 全量备份 同时备份到磁盘中
</code></pre>
<h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">select</td>
<td align="center">select 0</td>
<td align="center">选择0号数据库</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set name lily</td>
<td align="center">设置key&#x3D;name, value&#x3D;lily</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获得key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">keys</td>
<td align="center">keys he*</td>
<td align="center">根据Pattern表达查询符合条件的key</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">dbsize</td>
<td align="center">返回key的总数</td>
</tr>
<tr>
<td align="center">exists</td>
<td align="center">exists a</td>
<td align="center">检查key&#x3D;a是否存在</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del a</td>
<td align="center">删除key&#x3D;a的数据</td>
</tr>
<tr>
<td align="center">expire</td>
<td align="center">expire hello 20</td>
<td align="center">设置key&#x3D;hello 20秒后过期</td>
</tr>
<tr>
<td align="center">ttl</td>
<td align="center">ttl hello</td>
<td align="center">查看key&#x3D;a的过期剩余时间</td>
</tr>
</tbody></table>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redids-cli -p 6380   #重新连接到端口
127.0.0.1:6380&gt; select 10
127.0.0.1:6380[10]&gt; set name lily   #十号数据库中增加key=name value=lily
127.0.0.1:6380[10]&gt; get name  =&gt; &quot;lily&quot;
127.0.0.1:6380[10]&gt; select 9
127.0.0.1:6380[9]&gt; get name =&gt;(nil)
127.0.0.1:6380[9]&gt; set name kitty
127.0.0.1:6380[9]&gt; get name =&gt;&quot;kitty&quot;
127.0.0.1:6380[9]&gt; keys *  #列举表达式能匹配的所有key
127.0.0.1:6380[9]&gt; set sex male
127.0.0.1:6380[9]&gt; keys *
127.0.0.1:6380[9]&gt; keys n* #模糊匹配表达式
127.0.0.1:6380[9]&gt; dbsize  #显示当前数据库的总量 =&gt; 2个 =&gt; &quot;name&quot;  &quot;sex&quot;
127.0.0.1:6380[9]&gt; del sex #删除 =&gt; 1 返回0则不存在
127.0.0.1:6380[9]&gt; expire name 30   #生效开始之后30秒存活时间
127.0.0.1:6380[9]&gt; ttl name #查看存活时间 时间一到自动清除     keys*中无name数据
</code></pre>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a><span style = "color:red">Redis数据类型</span></h3><ul>
<li><h5 id="String-字符串类型-String最大512mb-建议单个kv不超过100kb"><a href="#String-字符串类型-String最大512mb-建议单个kv不超过100kb" class="headerlink" title="String - 字符串类型 (String最大512mb 建议单个kv不超过100kb)"></a>String - 字符串类型 (<u>String最大512mb 建议单个kv不超过100kb</u>)</h5></li>
</ul>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">Lily</td>
</tr>
<tr>
<td align="center">counter</td>
<td align="center">3321</td>
</tr>
<tr>
<td align="center">sn</td>
<td align="center">7361-7749</td>
</tr>
</tbody></table>
<h6 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">get hello</td>
<td align="center">获取key&#x3D;hello结果</td>
</tr>
<tr>
<td align="center">set</td>
<td align="center">set hello world</td>
<td align="center">设置key&#x3D;hello, value&#x3D;hello</td>
</tr>
<tr>
<td align="center">mset mget</td>
<td align="center">mset hello world java best<br />mget hello java</td>
<td align="center">一次性设置或者获取多个值</td>
</tr>
<tr>
<td align="center">del</td>
<td align="center">del hello</td>
<td align="center">删除key&#x3D;hello</td>
</tr>
<tr>
<td align="center">incr&#x2F;decr</td>
<td align="center">incr count<br/>decr count</td>
<td align="center">key值自增&#x2F;自减1</td>
</tr>
<tr>
<td align="center">incrby&#x2F;decrby</td>
<td align="center">incrby count 99<br/>decrby count 99</td>
<td align="center">自增自减指定步长</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[9]&gt; select 10 
127.0.0.1:6380[10]&gt; set name lily
127.0.0.1:6380[10]&gt; set sex 18
127.0.0.1:6380[10]&gt; set birthday 1998-03-11
127.0.0.1:6380[10]&gt; keys *
1) &quot;birthday&quot;  2)&quot;name&quot;  3)&quot;sex&quot;
127.0.0.1:6380[10]&gt; mset name1 kitty sex1 20 birthday1 2001-03-02 #一次性设置多个键值对
127.0.0.1:6380[10]&gt; mget name sex birthday  #一次性提取多个
127.0.0.1:6380[10]&gt; clear  #当前屏幕清空
127.0.0.1:6380[10]&gt; incr age  #将指定的数字自增+1
127.0.0.1:6380[10]&gt; set age 20
127.0.0.1:6380[10]&gt; keys age =&gt; &quot;age&quot;
127.0.0.1:6380[10]&gt; get age =&gt; &quot;20&quot;
127.0.0.1:6380[10]&gt; incr age =&gt; (integer) 22 #不可以自增字符串噢
127.0.0.1:6380[10]&gt; decrby age 3 #对指定的key自减 =&gt; 20-3=17
127.0.0.1:6380[10]&gt; del age #删除某个key
</code></pre>
<ul>
<li><h5 id="Hash-Hash类型"><a href="#Hash-Hash类型" class="headerlink" title="Hash - Hash类型"></a>Hash - Hash类型</h5></li>
</ul>
<h5 id="Hash类型用于存储结构化数据"><a href="#Hash类型用于存储结构化数据" class="headerlink" title="Hash类型用于存储结构化数据"></a>Hash类型用于存储结构化数据</h5><p>↓↓↓ ↓↓↓ key &#x3D; <strong>emp:1</strong> ↓↓↓ ↓↓↓ 在value中又产生一个键值对[下面全是单个的emp:1的key值]</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">smith</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>age</strong></td>
<td align="center">35</td>
</tr>
<tr>
<td align="center"><strong>birthday</strong></td>
<td align="center">2001-02-02</td>
</tr>
<tr>
<td align="center"><strong>height</strong></td>
<td align="center">178</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hget</td>
<td align="center">hget emp:1 age</td>
<td align="center">获取hash中key&#x3D;age的值</td>
</tr>
<tr>
<td align="center">hset</td>
<td align="center">hset emp:1 age 23</td>
<td align="center">设置hash中age&#x3D;23</td>
</tr>
<tr>
<td align="center">hmset<br />hmget<br />hgetall<br /></td>
<td align="center">hmset emp:1 age 30 name kaka<br />hmget emp:1 age name<br />hgetall emp:1<br /></td>
<td align="center">设置hash多个值<br />获取hash多个值<br />获取hash所有值<br /></td>
</tr>
<tr>
<td align="center">hdel</td>
<td align="center">hdel emp:1 age</td>
<td align="center">删除emp:1的age</td>
</tr>
<tr>
<td align="center">hexists</td>
<td align="center">hexists emp:1 name</td>
<td align="center">检查是否存在</td>
</tr>
<tr>
<td align="center">hlen</td>
<td align="center">hlen emp:1</td>
<td align="center">获取指定长度</td>
</tr>
</tbody></table>
<pre><code class="java">127.0.0.1:6380[1]&gt; hset emp:1 name zhangsan       #设置某个hash值
127.0.0.1:6380[1]&gt; hset emp:1 age 35
127.0.0.1:6380[1]&gt; hset emp:1 birthday 2001-02-02
127.0.0.1:6380[1]&gt; hset emp:1 height 178
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;emp:1&quot;
127.0.0.1:6380[1]&gt; hget emp:1 name    #获取指定hash值 =&gt;&quot;zhangsan&quot;
127.0.0.1:6380[1]&gt; hget emp:1 age =&gt; &quot;35&quot;
127.0.0.1:6380[1]&gt; hgetall emp:1 #提取所有的数据 

127.0.0.1:6380[1]&gt; hmset emp:2 name lisa age 23 birthday 1990-05-03 height 165
127.0.0.1:6380[1]&gt; hgetall emp:2
127.0.0.1:6380[1]&gt; del emp:2     #删除整个对象
127.0.0.1:6380[1]&gt; hlen emp:1 =&gt; (integer) 4     #代表在emp:1中有4个属性
127.0.0.1:6380[1]&gt; hgetall emp:1 
127.0.0.1:6380[1]&gt; hexists emp:1 name  #判断属性是否存在 是则返回1
</code></pre>
<ul>
<li><h5 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List - 列表类型"></a>List - 列表类型</h5><ul>
<li>List列表就是一系列字符串的”数组”, 按插入顺序排序</li>
<li>List列表最大长度为2的32次方-1, 可以包含40亿个元素</li>
</ul>
<h6 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h6><ul>
<li><strong>rpush listkey c b a</strong> - 右侧插入 <u>先c后b最后a</u></li>
<li><strong>lpush listkey f e d</strong> - 左侧插入 <u>先f后e最后d</u>         <em>d e f c b a</em></li>
<li><strong>rpop listkey</strong> - 右侧弹出          <em>d e f c b</em></li>
<li><strong>lpop listkey</strong> -左侧弹出             <em>e f c b</em></li>
</ul>
</li>
</ul>
<pre><code class="java">127.0.0.1:6380[1]&gt; rpush list c =&gt;(integer) 1
127.0.0.1:6380[1]&gt; lrange list 0 -1  #输出指定列表起始到结束范围内的所有元素 [开始 末尾]
127.0.0.1:6380[1]&gt; rpush list b a =&gt;(integer) 3
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list f      #在左侧插入
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; lpush list b a
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot; &quot;a&quot;
127.0.0.1:6380[1]&gt; rpop list =&gt; &quot;a&quot;
127.0.0.1:6380[1]&gt; lrange list 0 -1 =&gt; &quot;a&quot; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; lpop list =&gt; &quot;b&quot; &quot;f&quot; &quot;c&quot; &quot;b&quot;
</code></pre>
<ul>
<li><h5 id="Set-集合类型-Zset-有序集合类型"><a href="#Set-集合类型-Zset-有序集合类型" class="headerlink" title="Set - 集合类型      Zset - 有序集合类型"></a>Set - 集合类型      Zset - 有序集合类型</h5><ul>
<li>Set集合是字符串的无序集合, 集合成员是唯一的</li>
<li>Zset集合是字符串的有序集合, 集合成员是唯一的</li>
</ul>
</li>
</ul>
<pre><code class="java">Set集合
127.0.0.1:6380[1]&gt; sadd set1 a =&gt; 1
127.0.0.1:6380[1]&gt; keys * =&gt; &quot;set1&quot; &quot;emp:1&quot; &quot;list&quot;
127.0.0.1:6380[1]&gt; sadd set1 b =&gt; &quot;b&quot;
127.0.0.1:6380[1]&gt; sadd set1 c =&gt; &quot;c&quot;
127.0.0.1:6380[1]&gt; sadd set1 d =&gt; &quot;d&quot;
127.0.0.1:6380[1]&gt; sadd set1 e =&gt; &quot;e&quot;
127.0.0.1:6380[1]&gt; sadd set1 f =&gt; &quot;f&quot;
127.0.0.1:6380[1]&gt; smembers set1 =&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;e&quot;  #字母顺序打乱 乱序

127.0.0.1:6380[1]&gt; sadd set2 d     #创建一个set2与set1有重叠
127.0.0.1:6380[1]&gt; sadd set2 e
127.0.0.1:6380[1]&gt; sadd set2 f
127.0.0.1:6380[1]&gt; sadd set2 h
127.0.0.1:6380[1]&gt; sadd set2 g
127.0.0.1:6380[1]&gt; smembers set2 =&gt; &quot;d&quot; &quot;h&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;
127.0.0.1:6380[1]&gt; sinter set1 set2 =&gt;     &quot;d&quot; &quot;f&quot; &quot;e&quot;     #取其中的交集
127.0.0.1:6380[1]&gt; sunion set1 set2 =&gt;     &quot;d&quot; &quot;g&quot; &quot;b&quot; &quot;c&quot; &quot;h&quot; &quot;f&quot; &quot;e&quot; &quot;a&quot;    #取其中的并集[取并集并去除重复元素]
127.0.0.1:6380[1]&gt; sdiff set1 set2 #寻找叉集(在set1有 在set2中没有[两个部分交集排除在外])
=&gt; &quot;a&quot; &quot;c&quot; &quot;b&quot;
127.0.0.1:6380[1]&gt; sdiff set2 set1 =&gt; &quot;h&quot; &quot;g&quot;
</code></pre>
<pre><code class="java">Zset集合
127.0.0.1:6380[1]&gt; zadd zset1 100 a =&gt;1
127.0.0.1:6380[1]&gt; zadd zset1 101 b =&gt; 1
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;a&quot; &quot;b&quot; #按照顺序排序
127.0.0.1:6380[1]&gt; zadd zset1 99 c =&gt; 1  
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 =&gt; &quot;c&quot; &quot;a&quot; &quot;b&quot; #按照分数升序排列
127.0.0.1:6380[1]&gt; zadd zset1 102 d
127.0.0.1:6380[1]&gt; zadd zset1 103 e
127.0.0.1:6380[1]&gt; zadd zset1 104 f
127.0.0.1:6380[1]&gt; zrange zset1 0 -1 withscores #升序打印分数
127.0.0.1:6380[1]&gt; zrangebyscore zset1 100 103 #符合score从100-103的名字
</code></pre>
<h3 id="Java客户端-Jedis"><a href="#Java客户端-Jedis" class="headerlink" title="Java客户端-Jedis"></a>Java客户端-Jedis</h3><ul>
<li>Jedis是Java语言开发的Redis客户端工具包</li>
<li>Jedis只是对Redis命令的封装, 掌握Redis命令便可轻易上手</li>
</ul>
<h6 id="允许远程访问需要改文件"><a href="#允许远程访问需要改文件" class="headerlink" title="允许远程访问需要改文件"></a>允许远程访问需要改文件</h6><pre><code class="java">[root@imooc ~]# cd /usr/local/redis/redis-5.0.2/
[root@imooc redis-5.0.2]# vim redis.conf
第88行 protected-mode yes 将yes设置为no
第69行 bind 127.0.0.1 改为 bind 0.0.0.0     #四个0代表所有ip主机都可以访问进来【真正开发时要用特定的ip号】
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf
[root@imooc redis-5.0.2]# netstat -tulpn | grep redis
[root@imooc redis-5.0.2]# firewall-cmd --zone=public --add-port=6379/tcp --permanent
[root@imooc redis-5.0.2]# firewall-cmd --reload
[root@imooc redis-5.0.2]# ifconfig =&gt; IP地址: 192.168.170.135

[root@imooc redis-5.0.2]# ./src/redis-cli -p 6379
</code></pre>
<p>报错连接超时：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41830655/article/details/106114663">Java远程连接Redis时出现: java.net.SocketTimeoutException: connect timed out的解决办法-CSDN博客</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zinbin/article/details/109336852">Java连接Redis connection timed out 报错的解决方法_caused by: io.netty.channel.abstractchannel$annota-CSDN博客</a></p>
<pre><code class="java">systemctl start firewalld  #开启防火墙
systemctl enable firewalld.service  #开机自启动防火墙

systemctl stop firewalld.service #关闭防火墙
重启 Redis 服务端
ps -ef|grep redis    #查看 Redis 进程 
kill -s 9 进程号      #杀死 Redis 进程
[root@imooc redis-5.0.2]# ./src/redis-server redis.conf 
</code></pre>
<pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.List;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">pom.xml【两个jar:    jedis-2.9.0.jar        fastjson-1.2.62.jar】
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;Jedis_test&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

&lt;/project&gt;
</code></pre>
<pre><code class="java">[root@imooc redis-5.0.2]# ./src/redis-cli
127.0.0.1:6379&gt; auth root
127.0.0.1:6379&gt; select 2
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot;
127.0.0.1:6379[2]&gt; get sn =&gt; &quot;7781-9938&quot;
【此处更换新的java代码再次插入 奶粉...】
------------------------------------------------------------------
jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
------------------------------------------------------------------
127.0.0.1:6379[2]&gt; keys * =&gt; &quot;sn&quot; &quot;num&quot; &quot;title&quot;
127.0.0.1:6379[2]&gt; get num =&gt; 21
127.0.0.1:6379[2]&gt; get title =&gt; \xe5\xa9\xb4\xe5\xb9\xbc\xe5...
</code></pre>
<h3 id="Jedis操作Hash类型"><a href="#Jedis操作Hash类型" class="headerlink" title="Jedis操作Hash类型"></a>Jedis操作Hash类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            jedis.auth(&quot;root&quot;);
            jedis.select(2);
            System.out.println(&quot;Redis连接成功&quot;);
            //字符串
            jedis.set(&quot;sn&quot;, &quot;7781-9938&quot;);
            String sn = jedis.get(&quot;sn&quot;);
            System.out.println(sn);
            jedis.mset(new String[]&#123;&quot;title&quot;, &quot;婴幼儿奶粉&quot;, &quot;num&quot;, &quot;20&quot;&#125;);
            List&lt;String&gt; goods = jedis.mget(new String[]&#123;&quot;sn&quot;, &quot;title&quot;, &quot;num&quot;&#125;);
            System.out.println(goods);
            Long num = jedis.incr(&quot;num&quot;);
            System.out.println(num);

            //Hash
            jedis.hset(&quot;student:3312&quot;, &quot;name&quot;, &quot;张晓明&quot;);
            String name = jedis.hget(&quot;student:3312&quot;, &quot;name&quot;);
            System.out.println(name);

            Map&lt;String,String&gt; studentMap = new HashMap();
            studentMap.put(&quot;name&quot;, &quot;李兰&quot;);
            studentMap.put(&quot;age&quot;, &quot;18&quot;); //所有数据类型都是String
            studentMap.put(&quot;id&quot;, &quot;3313&quot;);
            jedis.hmset(&quot;student:3313&quot;, studentMap);
            Map&lt;String,String&gt; smap = jedis.hgetAll(&quot;student:3313&quot;);
            System.out.println(smap);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;

---------------------------------------------------------------
Redis连接成功
7781-9938
[7781-9938, 婴幼儿奶粉, 20]
21
张晓明
&#123;name=李兰, age=18, id=3313&#125;
</code></pre>
<pre><code class="java">127.0.0.1:6380[2]&gt; hgetall student:3313
</code></pre>
<h3 id="Jedis操作List类型"><a href="#Jedis操作List类型" class="headerlink" title="Jedis操作List类型"></a>Jedis操作List类型</h3><pre><code class="java">package com.imooc.jedis;

import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JedisTestor &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123; //List
            jedis.del(&quot;letter&quot;); //要先删除不然lpop、rpop的时候会追加数据
            jedis.rpush(&quot;letter&quot;, new String[]&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;);
            jedis.lpush(&quot;letter&quot;, new String[]&#123;&quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;);
            List&lt;String&gt; letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            jedis.lpop(&quot;letter&quot;);
            jedis.rpop(&quot;letter&quot;);
            letter = jedis.lrange(&quot;letter&quot;, 0, -1);
            System.out.println(letter);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
----————--——----------------------------------------------------
[a, b, c, d, e, f] =&gt; [b, c, d, e]
</code></pre>
<h3 id="利用Jedis缓存数据-放在内存处理-速度快"><a href="#利用Jedis缓存数据-放在内存处理-速度快" class="headerlink" title="利用Jedis缓存数据 [放在内存处理 速度快]"></a>利用Jedis缓存数据 [放在内存处理 速度快]</h3><h6 id="缓存数据：资料不要太大-信息比较稳定更新次数较低"><a href="#缓存数据：资料不要太大-信息比较稳定更新次数较低" class="headerlink" title="缓存数据：资料不要太大 信息比较稳定更新次数较低"></a>缓存数据：资料不要太大 信息比较稳定更新次数较低</h6><pre><code class="java">Goods.java
public class Goods &#123;
    private Integer goodsId;
    private String goodsName;
    private String description;
    private Float price;
    Getter + Setter + Constructor[空+全]
&#125;
</code></pre>
<pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
    &#125;
&#125;
________________________________________________________________
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8818,&quot;goodsName&quot;:&quot;红富士苹果&quot;,&quot;price&quot;:3.5&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8819,&quot;goodsName&quot;:&quot;赣南脐橙&quot;,&quot;price&quot;:5.0&#125;
&#123;&quot;description&quot;:&quot;&quot;,&quot;goodsId&quot;:8820,&quot;goodsName&quot;:&quot;进口香蕉&quot;,&quot;price&quot;:2.0&#125;
________________________________________________________________
127.0.0.1:6379[3]&gt; keys *
127.0.0.1:6379[3]&gt; &quot;goods:8820&quot; &quot;goods:8819&quot; &quot;goods:8818&quot;
127.0.0.1:6379[3]&gt; get goods:8820
</code></pre>
<hr>
<h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><pre><code class="java">CacheSample.java
package com.imooc.jedis;

import com.alibaba.fastjson.JSON;
import redis.clients.jedis.Jedis;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class CacheSample &#123;
    public CacheSample()&#123; //数据初始化
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;, 6379);
        try &#123;
            List&lt;Goods&gt; goodsList = new ArrayList();
            goodsList.add(new Goods(8818,&quot;红富士苹果&quot;,&quot;&quot;,3.5f));
            goodsList.add(new Goods(8819,&quot;赣南脐橙&quot;,&quot;&quot;,5f));
            goodsList.add(new Goods(8820,&quot;进口香蕉&quot;,&quot;&quot;,2f));
            //javabean序列化为json字符串保存到java里
            jedis.auth(&quot;root&quot;);
            jedis.select(3);
            for (Goods goods : goodsList)&#123;
                String json = JSON.toJSONString(goods);
                System.out.println(json);
                String key = &quot;goods:&quot; + goods.getGoodsId();
                jedis.set(key, json); //key + value[序列化为json]
            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125; finally &#123;
            jedis.close();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new CacheSample();
        System.out.println(&quot;请输入要查询的商品编号:&quot;);
        String goodsId = new Scanner(System.in).next();
        Jedis jedis = new Jedis(&quot;192.168.170.135&quot;);
        jedis.auth(&quot;root&quot;);
        jedis.select(3);
        String key = &quot;goods:&quot; + goodsId;
        if (jedis.exists(key))&#123;
            String json = jedis.get(key);
            System.out.println(json);
            //由json转回到java对象
            Goods g = JSON.parseObject(json, Goods.class);
            System.out.println(g.getGoodsName());
            System.out.println(g.getPrice());
        &#125;else&#123;
            System.out.println(&quot;您输入的商品编号不存在，请重新输入!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#1bccbc>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/11/15/后端/Linux,Redis,Jedis/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/11/07/后端/MyBatis实现OA系统项目实战/">
        <h2>
            MyBatis实现OA系统项目实战
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/11/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="慕课网办公OA平台"><a href="#慕课网办公OA平台" class="headerlink" title="慕课网办公OA平台"></a>慕课网办公OA平台</h3><h5 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h5><ul>
<li>需求说明与环境准备</li>
<li>开发基于RBAC的访问控制模块</li>
<li>开发多级请假审批流程</li>
</ul>
<h3 id="办公自动化OA系统"><a href="#办公自动化OA系统" class="headerlink" title="办公自动化OA系统"></a>办公自动化OA系统</h3><ul>
<li>办公自动化系统(Office Automation)是替代传统办公的解决方案</li>
<li>OA系统是利用软件技术构建的单位内部办公平台，用于辅助办公</li>
<li>利用OA系统可将办公数据数字化，可扩大提高办公流程执行效率</li>
</ul>
<h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul>
<li>慕课网办公OA系统要求采用多用户B&#x2F;S架构设计开发</li>
<li>HR为每一位员工分配系统账户，员工用此账户登录系统</li>
<li>公司采用分级定岗，从1-8依次提升，不同岗位薪资水平不同<ul>
<li>6级(含)以下员工为<strong>业务岗</strong>，对应人员执行公司业务事宜</li>
<li>7-8级为<strong>管理岗</strong>，其中<u>7级为部门经理</u>，<u>8级为总经理</u></li>
<li>业务岗与管理岗员工可用系统功能不同，要求允许灵活配置</li>
</ul>
</li>
</ul>
<h3 id="请假流程"><a href="#请假流程" class="headerlink" title="请假流程"></a>请假流程</h3><ul>
<li>公司所有员工都可以使用”请假申请”功能申请休假</li>
<li>请假时间少于72小时，部门经理审批后直接通过</li>
<li>请假时间大于72小时，部门经理审批后还需总经理进行审批</li>
<li>部门经理只允许批准本部门员工申请</li>
<li>部门经理请假需直接由总经理审批</li>
<li>总经理提起请假申请，系统自动批准通过</li>
</ul>
<h3 id="搭建基础架构"><a href="#搭建基础架构" class="headerlink" title="搭建基础架构"></a>搭建基础架构</h3><h5 id="框架-amp-组件"><a href="#框架-amp-组件" class="headerlink" title="框架&amp;组件"></a>框架&amp;组件</h5><ul>
<li>MySQL 8</li>
<li>Mybatis 3.5</li>
<li>Alibaba Druid</li>
<li>Servlet 3.1</li>
<li>Freemarker 2.3</li>
<li>LayUl 2.5</li>
</ul>
<h5 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h5><pre><code class="java">imooc-oa  eclipse工程项目
 /src - java源代码目录
 /WebContent - Web资源目录
 /css - css文件目录
 /js - js文件目录
 /image - 图片资源目录
 /upload - 上传文件目录
 /WEB-INF   //jsp数据来自controller 不允许在web中直接访问 要从控制器跳转
   /jsp - jsp页面目录
   /lib - jar文件目录
   /classes - 编译后的class目录
   /web.xml web描述符文件
</code></pre>
<h5 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h5><pre><code class="java">com.imooc-oa //逆命名法
    /controller - 存放Servlet控制器类 //承上启下接收参数 调用逻辑 返回处理结果
    /service - 存放处理逻辑类model[伪数据库] //完成业务逻辑 service与dao进行传递调用
    /dao - Data Access Object 数据访问对象类 数据读写的java类 数据来自xml文件
    /entity - 存放实体类 JavaBean java中的简单对象
    /utils - 通用工具类 底层通用的工具类或方法
</code></pre>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><img src="https://raw.githubusercontent.com/P-luminary/images/1f7a3c8c83e3c7c1743888e25207d2ff4d0b116d/data/OA%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE.png" style="zoom: 67%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58642210/article/details/123806612">Mybatis复习_resources.getresourceasreader的读取路径-CSDN博客</a></p>
<h6 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h6><pre><code class="xml">pom.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;imooc-oa&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;

    &lt;dependencies&gt;
        &lt;!--Mybatis 框架--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--MySQL 8 JDBC驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.19&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Druid数据库连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.14&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Junit4单元测试框架--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
            &lt;!--只参与Maven Test,不进行发布--&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--Logback日志输出组件--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Freemarker依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.29&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--servlet-api--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;!--依赖只参与编译测试,不进行发布--&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
&lt;!--用Maven时必打的代码--&gt;
                &lt;!--利用Maven编译插件将编译级别提高至1.8,解决lambda表达式错误--&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;!--maven-compiler-plugin是Maven自带的编译插件--&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.3&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;!--检查源码采用1.8规则,默认为1.5--&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;!--按1.8规则生成字节码--&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</code></pre>
<h6 id="配置数据库连接池"><a href="#配置数据库连接池" class="headerlink" title="配置数据库连接池"></a>配置数据库连接池</h6><pre><code class="xml">mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;dev&quot;&gt;
        &lt;!--开发环境配置--&gt;
        &lt;environment id=&quot;dev&quot;&gt;
            &lt;!--事务管理器采用JDBC方式--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--利用Mybatis自带连接池管理连接--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;!--MyBatis与Druid的整合--&gt;
                &lt;!--JDBC连接属性--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc-oa?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="开发Mybatis"><a href="#开发Mybatis" class="headerlink" title="开发Mybatis"></a>开发Mybatis</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58642210/article/details/123806612">Mybatis复习_resources.getresourceasreader的读取路径-CSDN博客</a></p>
<pre><code class="xml">test.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;test&quot;&gt;
    &lt;select id=&quot;sample&quot; resultType=&quot;string&quot;&gt;
        select &#39;success&#39;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">util-MybatisUtils.java
package util;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.Reader;
import java.util.function.Function;

public class MybatisUtils &#123;
    //利用static(静态)属于类不属于对象,且全局唯一
    private static SqlSessionFactory sqlSessionFactory = null;
    //利用静态块在初始化类时实例化sqlSessionFactory
    static&#123;
        Reader reader = null;
        try&#123;
            reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        &#125;catch(IOException e)&#123;
            //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;

    /**
     * 执行SELECT查询SQL
     * @param func 要执行查询语句的代码块
     * @return 查询结果
     */
    //用于数据的查询[极大的简化查询] mybatis执行SQL时一定要有mapper的xml
    public static Object executeQuery(Function&lt;SqlSession,Object&gt; func)&#123; //函数式接口
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try&#123;//具体查询交给Function实现 查询前完成连接的打开和关闭
            Object obj = func.apply(sqlSession);
            return obj;
        &#125;finally &#123;
            sqlSession.close(); //最后一步释放连接资源
        &#125;
    &#125;

    /**
     * 执行INSERT/UPDATE/DELETE写操作SQL
     * @param func 要执行的写操作代码块
     * @return 写操作后返回的结果
     */
    public static Object executeUpdate(Function&lt;SqlSession,Object&gt; func)&#123; //函数式接口
        SqlSession sqlSession = sqlSessionFactory.openSession(false);
        try&#123;//具体查询交给Function实现 查询前完成连接的打开和关闭
            Object obj = func.apply(sqlSession);
            sqlSession.commit();
            return obj;
        &#125;catch (RuntimeException e)&#123;
            sqlSession.rollback();
            throw e;
        &#125;finally &#123;
            sqlSession.close(); //最后一步释放连接资源
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">MybatisUtilsTestor.java
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import util.MybatisUtils;

public class MybatisUtilsTestor &#123;
//    @Test
//    public void testcase1()&#123;
//        String result = (String)MybatisUtils.executeQuery(sqlSession -&gt; &#123;
//            String out = (String)sqlSession.selectOne(&quot;test.sample&quot;);
//            return out; //out会被retrun obj接收 返回Object
//        &#125;);
//        System.out.println(result);
//    &#125;
    @Test
    public void testcase2()&#123;
        String result = (String) MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;));
        System.out.println(result);
    &#125;
&#125;
</code></pre>
<h3 id="MyBatis整合Druid连接池-自定义连接池"><a href="#MyBatis整合Druid连接池-自定义连接池" class="headerlink" title="MyBatis整合Druid连接池 (自定义连接池)"></a>MyBatis整合Druid连接池 (自定义连接池)</h3><pre><code class="xml">重新整合mybatis-config.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
    &lt;environments default=&quot;dev&quot;&gt;
        &lt;!--开发环境配置--&gt;
        &lt;environment id=&quot;dev&quot;&gt;
            &lt;!--事务管理器采用JDBC方式--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
            &lt;!--利用Mybatis自带连接池管理连接--&gt;
&lt;!--            &lt;dataSource type=&quot;POOLED&quot;&gt;--&gt;
            &lt;dataSource type=&quot;com.imooc.oa.datasource.DruidDataSourceFactory&quot;&gt;
            &lt;!--MyBatis与Druid的整合--&gt;
                &lt;!--JDBC连接属性--&gt;
                &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/imooc-oa?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowPublicKeyRetrieval=true&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
                &lt;!--连接池初始连接数--&gt;
                &lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&gt;
                &lt;!--连接池最大连接数--&gt;
                &lt;property name=&quot;maxActive&quot; value=&quot;20&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<pre><code class="java">com.imooc.oa.datasource.DruidDataSourceFactory
package com.imooc.oa.datasource;

import com.alibaba.druid.pool.DruidDataSource;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;

import javax.sql.DataSource;
import java.sql.SQLException;

public class DruidDataSourceFactory extends UnpooledDataSourceFactory &#123;
    public DruidDataSourceFactory()&#123; //1.创造空的数据源对象
        // 2.调用setProperties读取xml对dataSource属性源进行设置
        this.dataSource = new DruidDataSource(); //表达数据源信息
    &#125;
    //3.数据源需要额外设置要重写
    @Override
    public DataSource getDataSource() &#123; //获取已经初始化的连接池进行返回
        try &#123;
            ((DruidDataSource)this.dataSource).init(); //初始化Druid数据源
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125;
        return this.dataSource;
    &#125;
&#125;
</code></pre>
<h6 id="Ctrl-Shift-N-文件查找对话框"><a href="#Ctrl-Shift-N-文件查找对话框" class="headerlink" title="Ctrl + Shift + N 文件查找对话框"></a>Ctrl + Shift + N 文件查找对话框</h6><h3 id="整合Freemarker"><a href="#整合Freemarker" class="headerlink" title="整合Freemarker"></a>整合Freemarker</h3><pre><code class="xml">pom.xml
    &lt;!--Freemarker依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
            &lt;version&gt;2.3.29&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--servlet-api--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;!--依赖只参与编译测试,不进行发布--&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="ftl">web-WEB-INF-ftl-test.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;$&#123;result&#125;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="xml">web.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;freemaker&lt;/servlet-name&gt;
        &lt;servlet-class&gt;freemarker.ext.servlet.FreemarkerServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;!--        定义模板的存储路径--&gt;
            &lt;param-name&gt;TemplatePath&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/ftl&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
&lt;!-- default_encoding用于设置读取ftl文件时采用的字符集,进而避免中文乱码的产生--&gt;
            &lt;param-name&gt;default_encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;freemaker&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.ftl&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="java">TestServlet.java
package com.imooc.oa.test;

import com.imooc.oa.util.MybatisUtils;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = &quot;TestServlet&quot;, urlPatterns = &quot;/test&quot;)
public class TestServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;

    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String result = (String)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;test.sample&quot;));
        req.setAttribute(&quot;result&quot;,result);
        req.getRequestDispatcher(&quot;/test.ftl&quot;).forward(req,resp);
    &#125;
&#125;
</code></pre>
<h3 id="RBAC-Role-Based-Access-Control-介绍"><a href="#RBAC-Role-Based-Access-Control-介绍" class="headerlink" title="RBAC(Role-Based Access Control)介绍"></a>RBAC(Role-Based Access Control)介绍</h3><ul>
<li><p>基于**<u>角色权限控制</u>**(<strong>RBAC</strong>)是面向企业安全策略的访问控制方式</p>
</li>
<li><p>RBAC核心思想是将控制访问的资源与角色(Role)进行绑定</p>
</li>
<li><p>系统的用户(User)与角色(Role)再进行绑定, 用户便拥有对应权限</p>
</li>
</ul>
<h6 id="一般主键cno或id都要设定字段类型为-BigInt"><a href="#一般主键cno或id都要设定字段类型为-BigInt" class="headerlink" title="一般主键cno或id都要设定字段类型为 BigInt"></a>一般主键cno或id都要设定字段类型为 BigInt</h6><h5 id="imooc-oa-sql"><a href="#imooc-oa-sql" class="headerlink" title="imooc-oa.sql"></a>imooc-oa.sql</h5><h2 id="实现用户登录"><a href="#实现用户登录" class="headerlink" title="实现用户登录"></a>实现用户登录</h2><h4 id="基于LayUI开发登录页"><a href="#基于LayUI开发登录页" class="headerlink" title="基于LayUI开发登录页"></a>基于LayUI开发登录页</h4><h4 id="LayUI前端框架"><a href="#LayUI前端框架" class="headerlink" title="LayUI前端框架"></a>LayUI前端框架</h4><p><a target="_blank" rel="noopener" href="https://www.layuiweb.com/">Layui - 经典开源模块化前端 UI 框架（官网文档镜像站） (layuiweb.com)</a></p>
<pre><code class="html">login.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui-main/src/css/layui.css&quot;&gt;
    &lt;style&gt;
        body &#123;
            background-color: #f2f2f2;
        &#125;

        .oa-container &#123;
            /*background-color: white;*/
            position: absolute;
            width: 400px;
            height: 350px;
            top: 50%;
            left: 50%;
            padding: 20px;
            margin-left: -200px;
            margin-top: -175px;
        &#125;
        #username,#password&#123;
            /*text-align: center;*/
            /*font-size: 24px;*/
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;oa-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center; margin-bottom: 20px&quot;&gt;办公OA系统&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现用户登录-1"><a href="#实现用户登录-1" class="headerlink" title="实现用户登录-1"></a>实现用户登录-1</h3><pre><code class="java">com.imooc.oa.entity.User
package com.imooc.oa.entity;

public class User &#123;
    /*
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
     */
    private Long userId;
    private String username;
    private String password;
    private Long employeeId;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">com.imooc.oa.dao.UserDao
package com.imooc.oa.dao;

import com.imooc.oa.entity.User;
import com.imooc.oa.util.MybatisUtils;

/**
 * 用户表
 */
public class UserDao &#123;
    /**
     * 按照用户名查询用户表
     * @param username 用户名
     * @return User对象包含对应的用户信息，null则代表对象不存在
     */
    public User selectByUsername(String username)&#123;
        User user = (User)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectOne(&quot;usermapper.selectByUsername&quot;,username));
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="xml">user.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;usermapper&quot;&gt;
    &lt;select id=&quot;selectByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;com.imooc.oa.entity.User&quot;&gt;
        select * from sys_user where username = #&#123;value&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mappers&gt;
    &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
    &lt;mapper resource=&quot;mappers/user.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p><strong>Dao → Service</strong></p>
<h6 id="创建测试用例快捷键-Ctrl-Shift-T"><a href="#创建测试用例快捷键-Ctrl-Shift-T" class="headerlink" title="创建测试用例快捷键 Ctrl+Shift+T"></a>创建测试用例快捷键 Ctrl+Shift+T</h6><pre><code class="java">UserSerive.java
package com.imooc.oa.serive;

import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.User;
import com.imooc.oa.serive.exception.BussinessException;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后，包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */ 
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        if(!password.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">test/serive.UserServiceTest.java
package com.imooc.oa.serive;

import junit.framework.TestCase;
import org.junit.Test;

public class UserServiceTest extends TestCase &#123;
    private UserService userService = new UserService();

    @Test
    public void testCheckLogin1() &#123;
        userService.checkLogin(&quot;uu&quot;,&quot;1234&quot;);
    &#125;
    @Test
    public void testCheckLogin2() &#123;
        userService.checkLogin(&quot;m8&quot;,&quot;1234&quot;);
    &#125;
    @Test
    public void testCheckLogin3() &#123;
        userService.checkLogin(&quot;uu&quot;,&quot;test&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">serive.exception.BussinessException.java
package com.imooc.oa.serive.exception;

/**
 * 业务逻辑异常
 */
public class BussinessException extends RuntimeException&#123;
    private String code; //异常编码,异常的以为标识
    private String message; //异常的具体文本消息
    public BussinessException(String code, String msg)&#123;
        super(code + &quot;:&quot; + msg);
        this.code = code;
        this.message = msg;
    &#125;

    public String getCode() &#123;
        return code;
    &#125;

    public void setCode(String code) &#123;
        this.code = code;
    &#125;

    @Override
    public String getMessage() &#123;
        return message;
    &#125;

    public void setMessage(String message) &#123;
        this.message = message;
    &#125;
&#125;
</code></pre>
<h3 id="实现用户登录-2"><a href="#实现用户登录-2" class="headerlink" title="实现用户登录-2"></a>实现用户登录-2</h3><pre><code class="java">com.imooc.oa.controller.LoginServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;
import com.imooc.oa.service.exception.BussinessException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LoginServlet&quot; ,urlPatterns = &quot;/check_login&quot;)
public class LoginServlet extends HttpServlet &#123;
    Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //接收用户输入
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        try &#123;
            //调用业务逻辑
            User user = userService.checkLogin(username, password);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
        &#125;catch (BussinessException ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;catch (Exception ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getClass().getSimpleName());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;
        //返回对应结果
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;
&#125;
</code></pre>
<h4 id="实现用户登录-3"><a href="#实现用户登录-3" class="headerlink" title="实现用户登录-3"></a>实现用户登录-3</h4><pre><code class="xml">pom.xml
&lt;dependency&gt;
   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
   &lt;version&gt;1.2.62&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="html">login.xml实现增添表单校验
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;慕课网办公OA系统&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        body&#123;
            background-color: #F2F2F2;
        &#125;
        .oa-container&#123;
            /*background-color: white;*/
            position: absolute;
            width: 400px;
            height: 350px;
            top: 50%;
            left: 50%;
            padding: 20px;
            margin-left: -200px;
            margin-top: -175px;
        &#125;
        #username,#password&#123;
            /*text-align: center;*/
            /*font-size: 24px;*/
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;oa-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;办公OA系统&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; lay-verify=&quot;required&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt;
        &lt;/div&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; lay-verify=&quot;required&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot; &gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid&quot; lay-submit lay-filter=&quot;login&quot;&gt;登录&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    // 表单提交事件 表单输入校验 在上面加 lay-verify=&quot;requrired&quot;
    layui.form.on(&quot;submit(login)&quot; , function(formdata)&#123;//data参数包含了当前表单的数据
        console.log(formdata);
        //发送ajax请求进行登录校验
        layui.$.ajax(&#123;
            url : &quot;/check_login&quot;,
            data : formdata.field, //提交表单数据
            type : &quot;post&quot;,
            dataType : &quot;json&quot; ,
            success : function(json)&#123;
                console.log(json);
                if(json.code == &quot;0&quot;)&#123; //登录校验成功 内置弹出层
                    layui.layer.msg(&quot;登录成功&quot;);
                &#125;else&#123;
                    layui.layer.msg(json.message);
                &#125;
            &#125;
        &#125;)
        return false;//submit提交事件返回true则表单提交,false则阻止表单提交
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/html&gt;
</code></pre>
<h6 id="后面通过Ajax-浏览器后台-上面return-false-请求向服务器发起异步通信获取校验是否通过"><a href="#后面通过Ajax-浏览器后台-上面return-false-请求向服务器发起异步通信获取校验是否通过" class="headerlink" title="后面通过Ajax[浏览器后台(上面return false)]请求向服务器发起异步通信获取校验是否通过"></a>后面通过Ajax[浏览器后台(上面return false)]请求向服务器发起异步通信获取校验是否通过</h6><h3 id="分析后台首页布局与设计"><a href="#分析后台首页布局与设计" class="headerlink" title="分析后台首页布局与设计"></a>分析后台首页布局与设计</h3><pre><code class="html">index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    姓名[部门-职务]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;!--父节点--&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;模块1&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;1&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能1&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能2&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;1&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt;
                &lt;/dd&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;模块2&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;2&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能3&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能4&lt;/a&gt;
                &lt;/dd&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;2&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;功能5&lt;/a&gt;
                &lt;/dd&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="动态显示功能菜单-1-【核心：rbac-xml】"><a href="#动态显示功能菜单-1-【核心：rbac-xml】" class="headerlink" title="动态显示功能菜单-1 【核心：rbac.xml】"></a>动态显示功能菜单-1 【<u>核心：rbac.xml</u>】</h3><p>通过用户找到角色sys_user 再通过角色找到节点sys_role_user 接下来通过节点编号sys_role_node去获取与之对应的节点其他信息(三表关联)</p>
<p>xml→Dao→UserService</p>
<pre><code class="xml">resources.mappers.rbac.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;rbacmapper&quot;&gt;
    &lt;select id=&quot;selectNodeByUserId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Node&quot;&gt;
        select distinct n.*
        from
            sys_role_user ru, sys_role_node rn, sys_node n
        where
            ru.role_id = rn.role_id and user_id = #&#123;value&#125; and rn.node_id = n.node_id
        order by n.node_code
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="xml">mybatis-config.xml
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mappers/test.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/user.xml&quot;/&gt;
        &lt;mapper resource=&quot;mappers/rbac.xml&quot;/&gt;
    &lt;/mappers&gt;
</code></pre>
<pre><code class="java">imooc.oa.dao.RbacDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Node;
import com.imooc.oa.util.MybatisUtils;

import java.util.List;

public class RbacDao &#123;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        return (List)MybatisUtils.executeQuery(sqlSession -&gt; sqlSession.selectList(&quot;rbacmapper.selectNodeByUserId&quot;, userId));
    &#125;
&#125;
</code></pre>
<pre><code class="java">service.UserService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.RbacDao;
import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.exception.BussinessException;

import java.util.List;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化
    private RbacDao rbacDao = new RbacDao();

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后,包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        if(!password.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId);
        return nodeList;
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceTest.java
@Test
    public void selectNodeByUserId()&#123;
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(2l);
        System.out.println(nodeList);
    &#125;
</code></pre>
<pre><code class="java">Node.java
public class Node &#123;
    private Long nodeId;
    private Integer nodeType;
    private String nodeName;
    private String url;
    private Integer nodeCode;
    private Long parentId;
    Setter + Getter
&#125;
</code></pre>
<h3 id="动态显示功能菜单-2-不同用户登录不同功能"><a href="#动态显示功能菜单-2-不同用户登录不同功能" class="headerlink" title="动态显示功能菜单-2 (不同用户登录不同功能)"></a>动态显示功能菜单-2 (不同用户登录不同功能)</h3><pre><code class="java">修改LoginServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;
import com.imooc.oa.service.exception.BussinessException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LoginServlet&quot; ,urlPatterns = &quot;/check_login&quot;)
public class LoginServlet extends HttpServlet &#123;
    Logger logger = LoggerFactory.getLogger(LoginServlet.class);
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        //接收用户输入
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        try &#123;
            //调用业务逻辑 不能直接 request.setAttribute 选更大的对象
            User user = userService.checkLogin(username, password);
            HttpSession session = request.getSession();
            //session种存在用户信息 向session存入登录用户信息,属性名：login_user
            session.setAttribute(&quot;login_user&quot;, user);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
            result.put(&quot;redirect_url&quot;, &quot;/index&quot;); //url登陆成功直接返回客户端
        &#125;catch (BussinessException ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getCode());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;catch (Exception ex)&#123;
            logger.error(ex.getMessage() , ex);
            result.put(&quot;code&quot;, ex.getClass().getSimpleName());
            result.put(&quot;message&quot;, ex.getMessage());
        &#125;
        //返回对应结果
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="java">oa.controller.IndexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;
//接收数据传入
@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        request.setAttribute(&quot;node_list&quot;,nodeList);
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="html">将index.html 变成 index.ftl并放在Web/WEB-INF/ftl/index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    姓名[部门-职务]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Xml配置下实现Mapper接口-登录用户所对应员工"><a href="#Xml配置下实现Mapper接口-登录用户所对应员工" class="headerlink" title="Xml配置下实现Mapper接口 (登录用户所对应员工)"></a>Xml配置下实现Mapper接口 (登录用户所对应员工)</h3><p>接口 xml mapper增加 employeeservice </p>
<p>index.ftl  indexServlet  改index.ftl</p>
<p>增加自动化部门 entity.Department  dao.创建接口DepartmentDao  mappers.department.xml  -config.xml注册     DepartmentSerive.java<br>IndexServlet.java   index.ftl</p>
<pre><code class="java">entity.Employee.java
public class Employee&#123;
    private Long employeeId;
    private String name;
    private Long departmentId;
    private String title;
    private Integer level;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">dao.EmployeeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Department;

public interface DepartmentDao &#123;
    public Department selectById(Long departmentId);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/employee.xml&quot;/&gt;

index.ftl
 &lt;!--右侧当前用户信息--&gt;
   &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
       &lt;li class=&quot;layui-nav-item&quot;&gt;
           &lt;a href=&quot;javascript:void(0)&quot;&gt;
               &lt;!--图标--&gt;
              &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
               &lt;/span&gt;
               &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
</code></pre>
<pre><code class="java">IndexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Department;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.DepartmentService;
import com.imooc.oa.service.EmployeeService;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;

@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    private EmployeeService employeeService = new EmployeeService();
    private DepartmentService departmentService = new DepartmentService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        //得到当前登录用户对象
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        Employee employee = employeeService.selectById(user.getEmployeeId());
        //获取登录用户可用功能模块列表
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        //获取员工对应的部门
        Department department = departmentService.selectById(employee.getDepartmentId());
        //放入请求属性 session生存时间长
        request.setAttribute(&quot;node_list&quot;,nodeList);
        session.setAttribute(&quot;current_employee&quot;,employee);
        session.setAttribute(&quot;current_department&quot;, department);
        //请求派发至ftl进行展现
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<h6 id="增加自动化部门"><a href="#增加自动化部门" class="headerlink" title="增加自动化部门"></a>增加自动化部门</h6><pre><code class="java">entity.Department.java
public class Department &#123;
    private Long departmentId;
    private String departmentName;
    Getter+Setter
&#125;
</code></pre>
<pre><code class="java">dao.DepartmentDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Department;

public interface DepartmentDao &#123;
    public Department selectById(Long departmentId);
&#125;
</code></pre>
<pre><code class="xml">mapper.department.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace与包名类名一致--&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.DepartmentDao&quot;&gt;
    &lt;!--id与方法名对应 parameterType与方法参数类型对应 resultType与方法返回类型对应--&gt;
    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Department&quot;&gt;
        select * from adm_department where department_id = #&#123;value&#125;
    &lt;/select&gt;
&lt;/mapper&gt;

mybatis-config.xml
&lt;mapper resource=&quot;mappers/department.xml&quot;/&gt;
</code></pre>
<pre><code class="java">service.DepartmentServlet.java
package com.imooc.oa.service;

import com.imooc.oa.dao.DepartmentDao;
import com.imooc.oa.entity.Department;
import com.imooc.oa.util.MybatisUtils;

public class DepartmentService &#123;
    /**
     * 按编号得到部门对象
     * @param departmentId 部门编号
     * @return 部门对象,null代表部门不存在
     */
    public Department selectById(Long departmentId)&#123;
        return (Department) MybatisUtils.executeQuery(
                sqlSession -&gt; sqlSession.getMapper(DepartmentDao.class).selectById(departmentId));
    &#125;
&#125;
</code></pre>
<pre><code class="java">controller.indexServlet.java
package com.imooc.oa.controller;

import com.imooc.oa.entity.Department;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.DepartmentService;
import com.imooc.oa.service.EmployeeService;
import com.imooc.oa.service.UserService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;

@WebServlet(name = &quot;IndexServlet&quot;, urlPatterns = &quot;/index&quot;)
public class IndexServlet extends HttpServlet &#123;
    private UserService userService = new UserService();
    private EmployeeService employeeService = new EmployeeService();
    private DepartmentService departmentService = new DepartmentService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response)&#123;

    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        //得到当前登录用户对象
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        Employee employee = employeeService.selectById(user.getEmployeeId());
        //获取登录用户可用功能模块列表
        List&lt;Node&gt; nodeList = userService.selectNodeByUserId(user.getUserId());
        //获取员工对应的部门
        Department department = departmentService.selectById(employee.getDepartmentId());
        //放入请求属性 session生存时间长
        request.setAttribute(&quot;node_list&quot;,nodeList);
        session.setAttribute(&quot;current_employee&quot;,employee);
        session.setAttribute(&quot;current_department&quot;, department);
        //请求派发至ftl进行展现
        request.getRequestDispatcher(&quot;/index.ftl&quot;).forward(request, response);
    &#125;
&#125;
</code></pre>
<pre><code class="html">index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="基于MD5算法对密码加密"><a href="#基于MD5算法对密码加密" class="headerlink" title="基于MD5算法对密码加密"></a>基于MD5算法对密码加密</h3><h5 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h5><ul>
<li>MD5信息摘要算法广泛使用的密码散列函数</li>
<li>MD5可以产生出一个128位的散列值用于唯一标识源数据</li>
<li>项目中通常使用MD5作为敏感数据的加密算法</li>
</ul>
<h5 id="MD5特点"><a href="#MD5特点" class="headerlink" title="MD5特点"></a>MD5特点</h5><ul>
<li>压缩性, MD5生成的摘要长度固定</li>
<li>抗修改, 源数据哪怕有一个字节变化, MD5也会有巨大差异</li>
<li>不可逆, 无法通过MD5反向推算源数据</li>
</ul>
<h5 id="Apache-Commons-Codec"><a href="#Apache-Commons-Codec" class="headerlink" title="Apache Commons Codec"></a>Apache Commons Codec</h5><ul>
<li>Commons-Codec是Apache提供的编码&#x2F;解码组件</li>
<li>通过Commons-Codec可以轻易生成源数据的MD5摘要</li>
<li>MD5摘要方法: <strong>String md5 &#x3D; DigestUtils.md5Hex</strong> (源数据)</li>
</ul>
<pre><code class="java">util.MD5Utils.java
package com.imooc.oa.util;

import org.apache.commons.codec.digest.DigestUtils;

public class MD5Utils &#123;
    public static String md5Digest(String source)&#123;
        return DigestUtils.md5Hex(source);
    &#125;
&#125;
</code></pre>
<h3 id="敏感数据加盐混淆"><a href="#敏感数据加盐混淆" class="headerlink" title="敏感数据加盐混淆"></a>敏感数据加盐混淆</h3><p> md5utilstest  userservice user</p>
<pre><code class="java">public class User &#123;
    /*
    &lt;settings&gt;
        &lt;!--开启驼峰命名转换 form_id -&gt; formId--&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
     */
    private Long userId;
    private String username;
    private String password;
    private Long employeeId;
    private Integer salt;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">util.MD5Utils.java
package com.imooc.oa.util;

import org.apache.commons.codec.digest.DigestUtils;

public class MD5Utils &#123;
    /**
     * 对数据源加盐混淆后生成MD5摘要
     * @param source 源数据
     * @return MD5摘要
     */
    public static String md5Digest(String source)&#123;
        return DigestUtils.md5Hex(source);
    &#125;
    public static String md5Digest(String source, Integer salt)&#123;
        char[] ca = source.toCharArray(); //字符数组
        for (int i = 0; i &lt; ca.length; i++) &#123;
            ca[i] = (char)(ca[i] + salt);
        &#125;
        String target = new String(ca);
//        System.out.println(target);
        String md5 = DigestUtils.md5Hex(target);
        return md5;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(MD5Utils.md5Digest(&quot;test&quot;, 188));
    &#125;
&#125;
</code></pre>
<pre><code class="java">修改UserService.java 中的密码校验
package com.imooc.oa.service;

import com.imooc.oa.dao.RbacDao;
import com.imooc.oa.dao.UserDao;
import com.imooc.oa.entity.Node;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.exception.BussinessException;
import com.imooc.oa.util.MD5Utils;

import java.util.List;

public class UserService &#123; //创建测试用例快捷键 Ctrl+Shift+T
    private UserDao userDao = new UserDao(); //实例化
    private RbacDao rbacDao = new RbacDao();

    /**
     * 根据前台输入进行登录校验
     * @param username 前台输入的用户名
     * @param password 前台输入的密码
     * @return 校验通过后,包含对应用户数据的User实体类
     * @throws BussinessException L001-用户名不存在,L002-密码错误
     */
    public User checkLogin(String username, String password)&#123;
        User user = userDao.selectByUsername(username);
        if (user == null)&#123;
            //抛出用户不存在异常
            throw new BussinessException(&quot;L001&quot;, &quot;用户名不存在&quot;);
        &#125;
        //对前台输入的密码加盐混淆后生成MD5,与保存在数据库中的MD5密码进行对比
        String md5 = MD5Utils.md5Digest(password, user.getSalt());
        if(!md5.equals(user.getPassword()))&#123;
            throw new BussinessException(&quot;L002&quot;, &quot;密码错误&quot;);
        &#125;
        return user;
    &#125;
    public List&lt;Node&gt; selectNodeByUserId(Long userId)&#123;
        List&lt;Node&gt; nodeList = rbacDao.selectNodeByUserId(userId);
        return nodeList;
    &#125;
&#125;
</code></pre>
<h3 id="实现注销功能"><a href="#实现注销功能" class="headerlink" title="实现注销功能"></a>实现注销功能</h3><p>loginServlet保存着数据 indexservlet中的session保存着数据<br>清除session</p>
<pre><code class="java">oa.controller.LogoutServlet.java
package com.imooc.oa.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = &quot;LogoutServlet&quot;, urlPatterns = &quot;/logout&quot;)
public class LogoutServlet extends HttpServlet &#123;
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        request.getSession().invalidate(); //会话注销
        response.sendRedirect(&quot;/login.html&quot;); //跳转回去
    &#125;
&#125;
</code></pre>
<pre><code class="xml">index.ftl
&lt;!--注销按钮--&gt;
&lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
</code></pre>
<h3 id="请假流程数据库设计"><a href="#请假流程数据库设计" class="headerlink" title="请假流程数据库设计"></a>请假流程数据库设计</h3><h6 id="开发多级审批流程"><a href="#开发多级审批流程" class="headerlink" title="开发多级审批流程"></a>开发多级审批流程</h6><ul>
<li>公司所有员工都可以使用”请假申请”功能申请休假</li>
<li>请假时间少于72小时，部门经理审批后直接通过</li>
<li>请假时间大于72小时，部门经理审批后还需总经理进行审批</li>
<li>部门经理只允许批准本部门员工申请</li>
<li>部门经理请假需直接由总经理审批</li>
<li>总经理提起请假申请，系统自动批准通过</li>
</ul>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/87fb5232c47e90f94a7580b26bd204150433faf5/data/OA%E7%B3%BB%E7%BB%9F%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B.jpg"></p>
<h5 id="工作流程表设计"><a href="#工作流程表设计" class="headerlink" title="工作流程表设计"></a>工作流程表设计</h5><p><span style = "color:red"><strong>请假单表</strong>LeaveForm → <strong>审批任务流程表</strong>ProcessFlow → <strong>消息通知表</strong>Notice</span></p>
<h5 id="设计约束"><a href="#设计约束" class="headerlink" title="设计约束"></a>设计约束</h5><ul>
<li><p>每一个请假单对应一个审批流程</p>
</li>
<li><p>请假单创建后, 按业务规则生成部门经理、总经理审批任务</p>
</li>
<li><p>审批任务的经办人只能审批自己辖区内的请假申请(总裁办可以审批所有 软件只能审批软件)</p>
</li>
<li><p>所有审批任务”通过”, 代表请假已经批准</p>
</li>
<li><p>任意审批任务”驳回”操作, 其余审批任务取消, 请假申请驳回</p>
</li>
<li><p>请假流程中注意节点产生的操作都要生成对应的系统通知</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/P-luminary/images/324ce1f7aa2d127ed415e216b61742f0b1550c7d/data/OA%E7%B3%BB%E7%BB%9F%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8.jpg" style="zoom: 150%;" />



<h3 id="实现Dao与数据交互"><a href="#实现Dao与数据交互" class="headerlink" title="实现Dao与数据交互"></a>实现Dao与数据交互</h3><p>entity  数据新增接口dao(依靠Mybatis) 增加mapper 创造LeaveFormDaoTest<br>                                    ProcessFlowDao + Test mapper<br>                                    NoticeDao</p>
<pre><code class="java">entity.LeaveForm.java
public class LeaveForm &#123;
    private Long formId;
    private Long employeeId;
    private Integer formType;
    private Date startTime;
    private Date endTime;
    private String reason;
    private Date createTime;
    private String state;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">dao.LeaveForm.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;

public interface LeaveFormDao &#123;
    public void insert(LeaveForm form);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/leave_form.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.LeaveFormDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class LeaveFormDaoTest extends TestCase &#123;
    @Test
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = new LeaveForm();
            form.setEmployeeId(4L);//员工编号
            form.setFormType(1); //事假
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            Date startTime = null; //起始时间
            Date endTime = null; //结束时间
            try &#123;
                startTime = sdf.parse(&quot;2020-03-25 08:00:00&quot;);
                endTime = sdf.parse(&quot;2020-04-01 18:00:00&quot;);
            &#125; catch (ParseException e) &#123;
                throw new RuntimeException(e);
            &#125;
            form.setStartTime(startTime);
            form.setEndTime(endTime);
            form.setReason(&quot;回家探亲&quot;); //请假事由
            form.setCreateTime(new Date()); //创建时间
            form.setState(&quot;processing&quot;); //当前状态
            dao.insert(form);
            return null;
        &#125;);
    &#125;

&#125;
</code></pre>
<hr>
<pre><code class="java">entity.ProcessFlow.java
package com.imooc.oa.entity;

import java.util.Date;

public class ProcessFlow &#123;
    private Long processId;
    private Long formId;
    private Long operatorId;
    private String action;
    private String result;
    private String reason;
    private Date createTime;
    private Date auditTime;
    private Integer orderNo;
    private String state;
    private Integer isLast;
    Setter + Getter
&#125;
</code></pre>
<pre><code class="java">dao.ProcessFlowDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.ProcessFlow;

public interface ProcessFlowDao &#123;
    public void insert(ProcessFlow processFlow);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/process_flow.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.ProcessFlowDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;

import java.util.Date;

public class ProcessFlowDaoTest extends TestCase &#123;
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            ProcessFlowDao dao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow = new ProcessFlow();
            flow.setFormId(31L);
            flow.setOperatorId(21L);
            flow.setAction(&quot;audit&quot;);
            flow.setReason(&quot;approved&quot;);
            flow.setReason(&quot;同意&quot;);
            flow.setCreateTime(new Date());
            flow.setAuditTime(new Date());
            flow.setOrderNo(1);
            flow.setState(&quot;ready&quot;);
            flow.setIsLast(1);
            dao.insert(flow);
            return null;
        &#125;);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">entity.Notice.java
public class Notice &#123;
    private Long noticeId;
    private Long receiverId;
    private String content;
    private Date createTime;
    Getter + Setter
&#125;
</code></pre>
<pre><code class="java">dao.NoticeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;

public interface NoticeDao &#123;
    public void insert(Notice notice);
&#125;
</code></pre>
<pre><code class="xml">mybatis-config.xml
&lt;mapper resource=&quot;mappers/notice.xml&quot;/&gt;
</code></pre>
<pre><code class="java">test.dao.NoticeDaoTest.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;
import com.imooc.oa.util.MybatisUtils;
import junit.framework.TestCase;
import org.junit.Test;

import java.util.Date;

public class NoticeDaoTest extends TestCase &#123;
    @Test
    public void testInsert()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            NoticeDao dao = sqlSession.getMapper(NoticeDao.class);
            Notice notice = new Notice();
            notice.setReceiverId(21L);
            notice.setContent(&quot;测试消息&quot;);
            notice.setCreateTime(new Date());
            dao.insert(notice);
            return null;
        &#125;);
    &#125;
&#125;
</code></pre>
<h3 id="实现请假申请业务逻辑-1"><a href="#实现请假申请业务逻辑-1" class="headerlink" title="实现请假申请业务逻辑-1"></a>实现请假申请业务逻辑-1</h3><p>LeaveFormService employee.xml{动态审批sql}</p>
<pre><code class="xml">employee.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace与包名类名一致--&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.EmployeeDao&quot;&gt;
    &lt;!--id与方法名对应 parameterType与方法参数类型对应 resultType与方法返回类型对应--&gt;
    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Employee&quot;&gt;
        select * from adm_employee where employee_id = #&#123;value&#125;
    &lt;/select&gt;
    &lt;select id=&quot;selectLeader&quot; parameterType=&quot;com.imooc.oa.entity.Employee&quot; resultType=&quot;com.imooc.oa.entity.Employee&quot;&gt;
        select * from adm_employee where
            &lt;if test=&quot;emp.level &amp;lt; 7&quot;&gt;
                level = 7 and department_id = #&#123;emp.departmentId&#125;
            &lt;/if&gt;
            &lt;if test=&quot;emp.level == 7&quot;&gt;
                level = 8;
            &lt;/if&gt;
            &lt;if test=&quot;emp.level == 8&quot;&gt;
                employee_id = #&#123;emp.employeeId&#125;
            &lt;/if&gt;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">service.LeaveFormService.java (重要业务走向代码不放在程序中)
package com.imooc.oa.service;

import com.imooc.oa.dao.EmployeeDao;
import com.imooc.oa.dao.LeaveFormDao;
import com.imooc.oa.dao.ProcessFlowDao;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.util.MybatisUtils;

import java.util.Date;

/**
 * 请假单流程服务
 */
public class LeaveFormService &#123;
    /**
     * 创建请假单
     * @param form 前端输入的请假单数据
     * @return 持久化后的请假单对象
     */
    public LeaveForm createLeaveForm(LeaveForm form)&#123;
            LeaveForm savedForm = (LeaveForm) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.持久化form表单数据,8级以下员工表单状态位processing,8级(总经理)状态位approved
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());
            if (employee.getLevel() == 8)&#123;
                form.setState(&quot;approved&quot;);
            &#125;else &#123;
                form.setState(&quot;processing&quot;);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            leaveFormDao.insert(form);
            //2.增加第一条流程数据,说明表单已提交,状态位complete 初始化数据↓
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow1 = new ProcessFlow();
            flow1.setFormId(form.getFormId());
            flow1.setOperatorId(employee.getEmployeeId());
            flow1.setAction(&quot;apply&quot;);
            flow1.setCreateTime(new Date());
            flow1.setOrderNo(1);
            flow1.setState(&quot;complete&quot;);
            flow1.setIsLast(0);
            processFlowDao.insert(flow1);
            //3.分情况创建其余流程数据 employee.xml(动态sql语句)
              //3.1 7级以下员工,生成部门经理审批任务,请假时间大于36小时(后期单独处理),还需生成总经理审批任务
            if (employee.getLevel() &lt; 7)&#123;
                //动态sql EmployeeDao
                Employee dmanage = employeeDao.selectLeader(employee);
                ProcessFlow flow2 = new ProcessFlow();
                flow2.setFormId(form.getFormId());
                flow2.setOperatorId(dmanage.getEmployeeId());
                flow2.setAction(&quot;audit&quot;);//审批任务
                flow2.setCreateTime(new Date());
                flow2.setOrderNo(2);
                flow2.setState(&quot;process&quot;);
                long diff = form.getEndTime().getTime() - form.getStartTime().getTime(); //毫秒数
                float hours = diff/(1000*60*60) * 1f;
                if (hours &gt;= BussinessConstants.MANAGER_AUDIT_HOURS)&#123;
                    flow2.setIsLast(0); //最后节点
                    processFlowDao.insert(flow2);
                    Employee manager = employeeDao.selectLeader(dmanage);//总经理
                    ProcessFlow flow3 = new ProcessFlow();
                    flow3.setFormId(form.getFormId());
                    flow3.setOperatorId(manager.getEmployeeId());
                    flow3.setAction(&quot;audit&quot;);
                    flow3.setCreateTime(new Date());
                    flow3.setState(&quot;ready&quot;);
                    flow3.setOrderNo(3);
                    flow3.setIsLast(1);
                    processFlowDao.insert(flow3);
                &#125;else &#123;//小于3天&#123;
                    flow2.setIsLast(1);
                    processFlowDao.insert(flow2);
                &#125;
            &#125; else if (employee.getLevel() == 7) &#123;//部门经理
                //3.2 7级员工,生成总经理审批任务
                Employee manager = employeeDao.selectLeader(employee);
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(manager.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setCreateTime(new Date());
                flow.setState(&quot;process&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
            &#125;else if (employee.getLevel() == 8)&#123;
                //3.3 8级员工,生成总经理审批任务,系统自动通过
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(employee.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setResult(&quot;自动通过&quot;);
                flow.setCreateTime(new Date());
                flow.setAuditTime(new Date());
                flow.setState(&quot;complete&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
            &#125;
            return form;
        &#125;);
        return savedForm;
    &#125;
&#125; 
</code></pre>
<pre><code class="java">service.BussinessConstants.java
package com.imooc.oa.service;

public class BussinessConstants &#123;
    public static final int MANAGER_AUDIT_HOURS = 36; //总经理请假审批时间阈值
&#125;
</code></pre>
<p>ctrl+shift+t 生成测试用例</p>
<pre><code class="java">Test.service.LeaveFormServiceTest.java
package com.imooc.oa.service;

import com.imooc.oa.entity.LeaveForm;
import org.junit.Test;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import static org.junit.Assert.*;

public class LeaveFormServiceTest &#123;
    LeaveFormService leaveFormService = new LeaveFormService();

    /**
     * 市场部员工请假单(72小时以上)测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm1() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(8l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1); //事假
        form.setReason(&quot;市场部员工请假单(72小时以上)&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 市场部员工请假单(72小时内)测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm2() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(8l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020032718&quot;));
        form.setFormType(1);
        form.setReason(&quot;市场部员工请假单(72小时内)&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 研发部部门经理请假单测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm3() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(2l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1);
        form.setReason(&quot;研发部部门经理请假单&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;

    /**
     * 总经理请假单测试用例
     * @throws ParseException
     */
    @Test
    public void createLeaveForm4() throws ParseException &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHH&quot;);
        LeaveForm form = new LeaveForm();
        form.setEmployeeId(1l);
        form.setStartTime(sdf.parse(&quot;2020032608&quot;));
        form.setEndTime(sdf.parse(&quot;2020040118&quot;));
        form.setFormType(1);
        form.setReason(&quot;总经理请假单&quot;);
        form.setCreateTime(new Date());
        LeaveForm savedForm = leaveFormService.createLeaveForm(form);
        System.out.println(savedForm.getFormId());
    &#125;
&#125;
</code></pre>
<h3 id="实现请假申请控制"><a href="#实现请假申请控制" class="headerlink" title="实现请假申请控制"></a>实现请假申请控制</h3><h5 id="Servlet-前后端整体交互-底层"><a href="#Servlet-前后端整体交互-底层" class="headerlink" title="Servlet 前后端整体交互(底层)"></a>Servlet 前后端整体交互(底层)</h5><p>leaveformservlet</p>
<pre><code class="java">controller.LeaveFormServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.LeaveFormService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@WebServlet(name = &quot;LeaveFormServlet&quot;, urlPatterns = &quot;/leave/*&quot;)
public class LeaveFormServlet extends HttpServlet &#123;
    private LeaveFormService leaveFormService = new LeaveFormService();
    private Logger logger = LoggerFactory.getLogger(LoggerFactory.class);
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // http://localhost/leave/create
        String uri = request.getRequestURI();
        String methodName = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); //截取本身就包含斜杠
        if (methodName.equals(&quot;create&quot;))&#123;

        &#125;
    &#125;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123;
        this.doPost(request,response);
    &#125;

    /**
     * 创建请假单
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        HttpSession session = request.getSession();
        User user = (User) session.getAttribute(&quot;login_user&quot;);
        String formType = request.getParameter(&quot;formType&quot;);
        String strStartTime = request.getParameter(&quot;startTime&quot;);
        String strEndTime = request.getParameter(&quot;endTime&quot;);
        String reason = request.getParameter(&quot;reason&quot;);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH&quot;);
        Map result = new HashMap();
        try &#123;
            LeaveForm form = new LeaveForm();
            form.setEmployeeId(user.getEmployeeId());
            form.setStartTime(sdf.parse(strStartTime));
            form.setEndTime(sdf.parse(strEndTime));
            form.setFormType(Integer.parseInt(formType));
            form.setReason(reason);
            form.setCreateTime(new Date());
            //2.调用业务逻辑方法
            leaveFormService.createLeaveForm(form);
            result.put(&quot;code&quot;, &quot;0&quot;);
            result.put(&quot;message&quot;, &quot;success&quot;);
        &#125; catch (Exception e)&#123;
            logger.error(&quot;请假申请异常&quot;,e);
            result.put(&quot;code&quot;, e.getClass().getSimpleName());
            result.put(&quot;message&quot;, e.getMessage());
        &#125;
        //3.组织相应数据
        String json = JSON.toJSONString(result); //将result转换为字符串
        response.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<h3 id="完整实现请假申请功能"><a href="#完整实现请假申请功能" class="headerlink" title="完整实现请假申请功能"></a>完整实现请假申请功能</h3><pre><code class="java">controller.ForwardServlet.java
package com.imooc.oa.controller;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 页面跳转Servlet
 */
@WebServlet(name=&quot;ForwardServlet&quot;, urlPatterns = &quot;/forward/*&quot;)
public class ForwardServlet extends HttpServlet &#123;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String uri = request.getRequestURI();
        /** 动态提取 把第一个/抛出外 再去寻找第一个‘/’
         * /forward/form
         * /forward/a/b/c/form
         */
        String subUri = uri.substring(1);
        String page = subUri.substring(subUri.indexOf(&quot;/&quot;));
        request.getRequestDispatcher(page + &quot;.ftl&quot;).forward(request,response); //扩展名 + web.xml映射路径
    &#125;
&#125;
</code></pre>
<pre><code class="html">form.html 变换为 form.ftl 放在ftl内

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;请假申请&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        /*表单容器*/
        .ns-container &#123;
            position: absolute;
            width: 500px;
            height: 450px;
            top: 150px;
            left: 50%;
            margin-left: -250px;
            padding: 20px;
            box-sizing: border-box;
            border: 1px solid #cccccc;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h2&gt;请假申请&lt;/h2&gt;
    &lt;/blockquote&gt;
    &lt;table id=&quot;grdNoticeList&quot; lay-filter=&quot;grdNoticeList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;ns-container&quot;&gt;
    &lt;h1 style=&quot;text-align: center;margin-bottom: 20px&quot;&gt;请假申请单&lt;/h1&gt;
    &lt;form class=&quot;layui-form&quot;&gt;
        &lt;!--基本信息--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;部门&lt;/label&gt;
            &lt;div class=&quot;layui-input-block&quot;&gt;
                &lt;div class=&quot;layui-col-md12&quot; style=&quot;padding-top: 10px;&quot;&gt;
                    研发部
                &lt;/div&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;申请人&lt;/label&gt;
            &lt;div class=&quot;layui-input-block&quot;&gt;
                &lt;div class=&quot;layui-col-md12&quot; style=&quot;padding-top: 10px;&quot;&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_employee.title&#125;]
                &lt;/div&gt;

            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!--请假类型下拉框--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假类别&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;select name=&quot;formType&quot; lay-verify=&quot;required&quot; lay-filter=&quot;cityCode&quot;&gt;
                        &lt;option value=&quot;1&quot;&gt;事假&lt;/option&gt;
                        &lt;option value=&quot;2&quot;&gt;病假&lt;/option&gt;
                        &lt;option value=&quot;3&quot;&gt;工伤假&lt;/option&gt;
                        &lt;option value=&quot;4&quot;&gt;婚嫁&lt;/option&gt;
                        &lt;option value=&quot;5&quot;&gt;产假&lt;/option&gt;
                        &lt;option value=&quot;6&quot;&gt;丧假&lt;/option&gt;
                    &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!--请假时长日期选择框--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假时长&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;input name=&quot;leaveRange&quot; type=&quot;text&quot; class=&quot;layui-input&quot; id=&quot;daterange&quot; placeholder=&quot; - &quot;&gt;
                    &lt;input id=&quot;startTime&quot; name=&quot;startTime&quot; type=&quot;hidden&quot;&gt;
                    &lt;input id=&quot;endTime&quot; name=&quot;endTime&quot; type=&quot;hidden&quot;&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!--请假事由--&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;label class=&quot;layui-form-label&quot;&gt;请假事由&lt;/label&gt;
            &lt;div class=&quot;layui-input-block layui-col-space5&quot;&gt;
                    &lt;input name=&quot;reason&quot; type=&quot;text&quot;  lay-verify=&quot;required|mobile&quot; placeholder=&quot;&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!--提交按钮--&gt;
        &lt;div class=&quot;layui-form-item &quot; style=&quot;text-align: center&quot;&gt;
                &lt;button class=&quot;layui-btn&quot; type=&quot;button&quot; lay-submit lay-filter=&quot;sub&quot;&gt;立即申请&lt;/button&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;!--Sweetalert2对话框--&gt;
&lt;script src=&quot;/resources/sweetalert2.all.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
        var layDate = layui.laydate; //Layui日期选择框JS对象
        var layForm = layui.form; //layui表单对象
        var $ = layui.$; //jQuery对象
        //日期时间范围
        layDate.render(&#123;
            elem: &#39;#daterange&#39;  //daterange渲染成日期选择框
            ,type: &#39;datetime&#39;
            ,range: true
            ,format: &#39;yyyy年M月d日H时&#39;
            ,done: function(value, start, end)&#123;
                //选择日期后出发的时间,设置startTime与endTime隐藏域
                var startTime = start.year + &quot;-&quot; + start.month + &quot;-&quot; + start.date + &quot;-&quot; + start.hours;
                var endTime = end.year + &quot;-&quot; + end.month + &quot;-&quot; + end.date + &quot;-&quot; + end.hours;
                console.info(&quot;请假开始时间&quot;,startTime);
                $(&quot;#startTime&quot;).val(startTime);
                console.info(&quot;请假结束时间&quot;,endTime);
                $(&quot;#endTime&quot;).val(endTime);
            &#125;
        &#125;);

        //表单提交时间
        layForm.on(&#39;submit(sub)&#39;, function(data)&#123;
            console.info(&quot;向服务器提交的表单数据&quot;,data.field);
            $.post(&quot;/leave/create&quot;,data.field,function (json) &#123;
                console.info(&quot;服务器返回数值&quot;,json);
                if(json.code == &quot;0&quot;)&#123;
                    /*SweetAlert2确定对话框*/
                    swal(&#123;
                        type: &#39;success&#39;,
                        html: &quot;&lt;h2&gt;请假单已提交,等待上级审批&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;).then(function (result) &#123;
                        window.location.href=&quot;/forward/notice&quot;;
                    &#125;);
                &#125;else&#123;
                    swal(&#123;
                        type: &#39;warning&#39;,
                        html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;);
                &#125;
            &#125;,&quot;json&quot;);
            return false;
        &#125;);

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="把localhost-x2F-index-主页添加数据"><a href="#把localhost-x2F-index-主页添加数据" class="headerlink" title="把localhost&#x2F;index 主页添加数据"></a>把localhost&#x2F;index 主页添加数据</h5><pre><code class="html">index.ftl中的47行到50行
 &lt;!--子节点--&gt;
&lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
 &lt;a href=&quot;#&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
&lt;/dd&gt;
</code></pre>
<h3 id="请假审批功能"><a href="#请假审批功能" class="headerlink" title="请假审批功能"></a>请假审批功能</h3><pre><code class="java">leave_form.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.LeaveFormDao&quot;&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;
        useGeneratedKeys=&quot;true&quot; keyProperty=&quot;formId&quot; keyColumn=&quot;form_id&quot;&gt;
        INSERT INTO adm_leave_form( employee_id, form_type, start_time, end_time, reason, create_time, state)
        VALUES ( #&#123;employeeId&#125;, #&#123;formType&#125;, #&#123;startTime&#125;, #&#123;endTime&#125;, #&#123;reason&#125;, #&#123;createTime&#125;, #&#123;state&#125;)
    &lt;/insert&gt;
    &lt;select id=&quot;selectByParams&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;java.util.Map&quot;&gt;
        select f.* ,e.name , d.*
        from
          adm_leave_form f,adm_process_flow pf , adm_employee e , adm_department d
        where
          f.form_id = pf.form_id
          and f.employee_id = e.employee_id
          and e.department_id = d.department_id
          and pf.state = #&#123;pf_state&#125; and pf.operator_id = #&#123;pf_operator_id&#125;
    &lt;/select&gt;
&lt;!--    &lt;select id=&quot;selectById&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt;--&gt;
&lt;!--        select * from adm_leave_form where form_id = #&#123;value&#125;--&gt;
&lt;!--    &lt;/select&gt;--&gt;

&lt;!--    &lt;update id=&quot;update&quot; parameterType=&quot;com.imooc.oa.entity.LeaveForm&quot;&gt;--&gt;
&lt;!--        UPDATE adm_leave_form SET employee_id = #&#123;employeeId&#125; , form_type = #&#123;formType&#125;, start_time = #&#123;startTime&#125;, end_time = #&#123;endTime&#125;, reason = #&#123;reason&#125;, state = #&#123;state&#125; ,create_time = #&#123;createTime&#125; WHERE form_id = #&#123;formId&#125;--&gt;
&lt;!--    &lt;/update&gt;--&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="java">dao.LeaveFormDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.LeaveForm;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

public interface LeaveFormDao &#123;
    public void insert(LeaveForm form);
    public List&lt;Map&gt; selectByParams(@Param(&quot;pf_state&quot;) String pfState , @Param(&quot;pf_operator_id&quot;) Long operatorId);
&#125; 
</code></pre>
<pre><code class="java">Test
  @Test
    public void testSelectByParams()&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            List&lt;Map&gt; list = dao.selectByParams(&quot;process&quot;, 21L);
            System.out.println(list);
            return list;
        &#125;);
    &#125;
</code></pre>
<pre><code class="java">controller.LeaveFormServlet.java
   /**
     * 查询需要审核的请假单列表
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void getLeaveFormList(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        User user = (User) request.getSession().getAttribute(&quot;login_user&quot;);
        List&lt;Map&gt; formList = leaveFormService.getLeaveFormList(&quot;process&quot;, user.getEmployeeId());
        Map result = new HashMap();
        result.put(&quot;code&quot;,&quot;0&quot;); //服务器处理成功
        result.put(&quot;msg&quot;,&quot;&quot;); //服务器返回具体处理消息
        result.put(&quot;count&quot;, formList.size()); //数据总数
        result.put(&quot;data&quot;, formList); //当前显示的对象页表
        String json = JSON.toJSONString(result);
        response.getWriter().println(json);
    &#125;
</code></pre>
<h3 id="实现待审批请假列表"><a href="#实现待审批请假列表" class="headerlink" title="实现待审批请假列表"></a>实现待审批请假列表</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
    &lt;title&gt;请假审批&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
    &lt;style&gt;
        .form-item&#123;
            padding: 10px;
        &#125;
        .form-item-value&#123;
            padding: 10px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h1&gt;请假审批&lt;/h1&gt;
    &lt;/blockquote&gt;
    &lt;!--待审批列表--&gt;
    &lt;table id=&quot;grdFormList&quot; lay-filter=&quot;grdFormList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;!--请假详情对话框--&gt;
&lt;div id=&quot;divDialog&quot; style=&quot;display: none;padding: 10px&quot;&gt;
    &lt;form class=&quot;layui-form&quot;&gt;

        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;部门&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;dname&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;姓名&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;name&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;起始时间&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;startTime&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;结束时间&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs4 form-item-value&quot; id=&quot;endTime&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-row&quot;&gt;
                &lt;div class=&quot;layui-col-xs2 form-item&quot;&gt;请假原因&lt;/div&gt;
                &lt;div class=&quot;layui-col-xs10 form-item-value&quot; id=&quot;reason&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
            &lt;!--表单Id--&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;formId&quot; id=&quot;formId&quot;&gt;
            &lt;!--审批结果--&gt;
            &lt;select name=&quot;result&quot; lay-verfity=&quot;required&quot;&gt;
                &lt;option value=&quot;approved&quot;&gt;同意&lt;/option&gt;
                &lt;option value=&quot;refused&quot;&gt;驳回&lt;/option&gt;
            &lt;/select&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;!--审批意见--&gt;
            &lt;input type=&quot;text&quot; name=&quot;reason&quot; placeholder=&quot;请输入审批意见&quot;
                   autocomplete=&quot;off&quot; class=&quot;layui-input&quot;/&gt;
        &lt;/div&gt;
        &lt;div class=&quot;layui-form-item&quot;&gt;
            &lt;button class=&quot;layui-btn layui-btn-fluid &quot; lay-submit lay-filter=&quot;audit&quot;&gt;确认提交&lt;/button&gt;

        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/resources/sweetalert2.all.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    var $ = layui.$;
    //将毫秒数转换为&quot;yyyy-MM-dd HH时&quot;字符串格式
    function formatDate(time)&#123;
        var newDate = new Date(time);
        return newDate.getFullYear() + &quot;-&quot; +
            (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate()
            + &quot; &quot; + newDate.getHours() + &quot;时&quot;;
    &#125;
    // 将table渲染为数据表格
    layui.table.render(&#123;
        elem : &quot;#grdFormList&quot; , //选择器
        id : &quot;grdFormList&quot; , //id
        url : &quot;/leave/list&quot; , //ajax请求url
        page : false , //是否分页 true-是 false-否
        cols :[[ //列描述
            &#123;title : &quot;&quot; , width:70 , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;, // numbers代表序号列
            &#123;field : &quot;create_time&quot; , title : &quot;申请时间&quot; , width : 150 , templet: function (d) &#123;
                //templet代表对数据进行加工后再显示
                return formatDate(d.create_time)
            &#125;&#125;,
            &#123;field : &quot;form_type&quot; , title : &quot;类型&quot; , width : 100 , templet: function(d)&#123;
                switch (d.form_type) &#123;
                    case 1:
                        return &quot;事假&quot;;
                    case 2:
                        return &quot;病假&quot;;
                    case 3:
                        return &quot;工伤假&quot;;
                    case 4:
                        return &quot;婚假&quot;;
                    case 5:
                        return &quot;产假&quot;;
                    case 6:
                        return &quot;丧假&quot;;
                &#125;
            &#125;&#125;,
            &#123;field : &quot;department_name&quot; , title : &quot;部门&quot; , width : 100&#125;,
            &#123;field : &quot;name&quot; , title : &quot;员工&quot; , width : 100&#125;,
            &#123;field : &quot;start_time&quot; , title : &quot;起始时间&quot; , width : 150, templet: function (d) &#123;
                    return formatDate(d.start_time)
                &#125;&#125;,
            &#123;field : &quot;end_time&quot; , title : &quot;结束时间&quot; , width : 150 , templet: function (d) &#123;
                    return formatDate(d.end_time)
                &#125;&#125;,
            &#123;field : &quot;reason&quot; , title : &quot;请假原因&quot; , width : 350 &#125;,
            &#123;title : &quot;&quot; , width:150 ,type:&quot;space&quot; , templet : function(d)&#123;
                var strRec = JSON.stringify(d);
                console.info(&quot;请假单数据&quot;, d);
                console.info(&quot;请假单数据&quot;, strRec);
                //将请假单数据存放至data-laf属性中
                return &quot;&lt;button class=&#39;layui-btn layui-btn-danger layui-btn-sm btn-audit&#39; data-laf=&quot; + strRec + &quot; &gt;审批&lt;/button&gt;&quot;;
            &#125;&#125;
        ]]
    &#125;)

    // 绑定每一行的审批按钮
    $(document).on(&quot;click&quot; , &quot;.btn-audit&quot; , function()&#123;
        //初始化表单
        $(&quot;#divDialog form&quot;)[0].reset();
        $(&quot;#divDialog form form-item-value&quot;).text(&quot;&quot;);
        //获取当前点击按钮的请假单数据,回填至显示项 json对象 内置数据显示页面
        var laf = $(this).data(&quot;laf&quot;);
        $(&quot;#dname&quot;).text(laf.department_name);
        $(&quot;#name&quot;).text(laf.name);
        $(&quot;#startTime&quot;).text(formatDate(laf.start_time));
        $(&quot;#endTime&quot;).text(formatDate(laf.end_time));
        $(&quot;#reason&quot;).text(laf.reason);
        $(&quot;#formId&quot;).val(laf.form_id);
        //弹出layui对话框
        layui.layer.open(&#123;
            type : &quot;1&quot; , //页面层
            title : &quot;请假审批&quot; , //标题
            content : $(&quot;#divDialog&quot;) , //指定对话框容器对象
            area : [&quot;500px&quot; , &quot;400px&quot;] , //尺寸
            end : function()&#123; //销毁后触发事件
                $(&quot;#divDialog&quot;).hide();
            &#125;
        &#125;)
    &#125;)
    /**
     * 提交审批数据 本质:发送Ajax请求
     */
    layui.form.on(&quot;submit(audit)&quot; , function(data)&#123;
        $.ajax(&#123;
            url : &quot;/leave/audit&quot;, //审核URL
            data : data.field ,
            type : &quot;post&quot; ,
            dataType : &quot;json&quot; ,
            success: function (json) &#123;
                //关闭所有layui对话框
                layui.layer.closeAll();
                //显示处理结果
                if(json.code == &quot;0&quot;)&#123;
                    swal(&#123;
                        type: &#39;success&#39;,
                        html: &quot;&lt;h2&gt;请假已审批完毕&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;).then(function (result) &#123;
                        window.location.href=&quot;/forward/notice&quot;;
                    &#125;);
                &#125;else&#123;
                    swal(&#123;
                        type: &#39;warning&#39;,
                        html: &quot;&lt;h2&gt;&quot; + json.message + &quot;&lt;/h2&gt;&quot;,
                        confirmButtonText: &quot;确定&quot;
                    &#125;);
                &#125;
            &#125;
        &#125;)
        return false;
    &#125;)

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="实现审批业务逻辑"><a href="#实现审批业务逻辑" class="headerlink" title="实现审批业务逻辑"></a>实现审批业务逻辑</h3><pre><code class="java">service.LeaveFormService.java
 public void audit(Long formId, Long operatorId, String result, String reason)&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.无论同意/驳回, 当前任务状态变更为complete
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            List&lt;ProcessFlow&gt; flowList = processFlowDao.selectByFormId(formId);
            if (flowList.size() == 0)&#123;
                throw new BussinessException(&quot;PF001&quot;, &quot;无效的审批流程&quot;);//自定义错误抛出
            &#125;
            //获取当前任务ProcessFlow对象
            List&lt;ProcessFlow&gt; processList = flowList.stream().filter(p-&gt;p.getOperatorId() == operatorId &amp;&amp; p.getState().equals(&quot;process&quot;)).collect(Collectors.toList());
            ProcessFlow process = null;
            if (processList.size() == 0)&#123;
                throw new BussinessException(&quot;PF002&quot;, &quot;未找到待处理任务&quot;);
            &#125;else&#123;
                process = processList.get(0);
                process.setState(&quot;complete&quot;);
                process.setResult(result);
                process.setReason(reason);
                process.setAuditTime(new Date());
                processFlowDao.update(process);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = leaveFormDao.selectById(formId);
            //2.如果当前任务是最后一个节点,代表流程结束,更新请假单状态对应的approved/refused
            if (process.getIsLast() == 1)&#123;
                form.setState(result); // approved\refused
                leaveFormDao.update(form);
            &#125;else &#123;
                //readyList包含所有后续任务节点
                List&lt;ProcessFlow&gt; readyList = flowList.stream().filter(p-&gt;p.getState().equals(&quot;ready&quot;)).collect(Collectors.toList());
                //3.如果当前任务不是最后一个节点且审批通过,那下一个节点的状态从ready变为process
                if (result.equals(&quot;approved&quot;))&#123;
                    ProcessFlow readyProcess = readyList.get(0);
                    readyProcess.setState(&quot;process&quot;);
                    processFlowDao.update(readyProcess);
                &#125; else if (result.equals(&quot;refused&quot;)) &#123;
                    //4.如果当前任务不是最后一个切点且审核驳回,则后续所有任务状态变为cancel,请假单状态变为refused
                    for (ProcessFlow p : readyList)&#123;
                        p.setState(&quot;cancel&quot;);
                        processFlowDao.update(p);
                    &#125;
                    form.setState(&quot;refused&quot;);
                    leaveFormDao.update(form);
                &#125;
            &#125;
            return null;
        &#125;);
    &#125;
</code></pre>
<pre><code class="java">test.LeaveFormServiceTest.java (在数据库中增加新建查询 导入训练素材的 请假单审核测试数据.sql)
   /**
     * 请假3天以上,部门经理审批通过
     */
    @Test
    public void audit1()&#123;
        leaveFormService.audit(31l,2l,&quot;approved&quot;,&quot;祝早日康复&quot;);
    &#125;

    /**
     * 请假3天以上,部门经理审批驳回
     */
    @Test
    public void audit2()&#123;
        leaveFormService.audit(32l,2l,&quot;refused&quot;,&quot;工期紧张,请勿拖延&quot;);
    &#125;

    /**
     * 部门经理请假,总经理审批通过
     */
    @Test
    public void audit3()&#123;
        leaveFormService.audit(33l,1l,&quot;approved&quot;,&quot;同意&quot;);
    &#125;
</code></pre>
<h3 id="完整实现请假审批"><a href="#完整实现请假审批" class="headerlink" title="完整实现请假审批"></a>完整实现请假审批</h3><pre><code class="java">controller.LeaveFormServlet.java
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123;
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        // http://localhost/leave/create
        String uri = request.getRequestURI();
        String methodName = uri.substring(uri.lastIndexOf(&quot;/&quot;) + 1); //截取本身就包含斜杠
        if (methodName.equals(&quot;create&quot;))&#123;
            this.create(request,response);
        &#125;else if (methodName.equals(&quot;list&quot;))&#123;
            this.getLeaveFormList(request,response);
        &#125; else if (methodName.equals(&quot;audit&quot;)) &#123;
            this.audit(request,response);
        &#125;
    &#125;
...
...
...
  /**
     * 处理审批操作
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    private void audit(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String formId = request.getParameter(&quot;formId&quot;);
        String result = request.getParameter(&quot;result&quot;);
        String reason = request.getParameter(&quot;reason&quot;);
        User user = (User) request.getSession().getAttribute(&quot;login_user&quot;);
        Map mpResult = new HashMap();
        try &#123;
            leaveFormService.audit(Long.parseLong(formId), user.getEmployeeId(), result,reason);
            mpResult.put(&quot;code&quot;, &quot;0&quot;);
            mpResult.put(&quot;message&quot;, &quot;success&quot;);

        &#125; catch (Exception e) &#123;
            logger.error(&quot;请假单审核失败&quot;, e);
            mpResult.put(&quot;code&quot;, e.getClass().getSimpleName());
            mpResult.put(&quot;message&quot;, e.getMessage());
        &#125;
        String json = JSON.toJSONString(mpResult);
        response.getWriter().println(json);
    &#125;
</code></pre>
<h3 id="实现系统消息业务逻辑"><a href="#实现系统消息业务逻辑" class="headerlink" title="实现系统消息业务逻辑"></a>实现系统消息业务逻辑</h3><pre><code class="java">entity.Notice.java
    private Long noticeId;
    private Long receiverId;
    private String content;
    private Date createTime;
    public Notice()&#123;

    &#125;
    public Notice(Long receiverId, String content)&#123;
        this.receiverId = receiverId;
        this.content = content;
        this.createTime = new Date();
    &#125;
    Getter + Setter
</code></pre>
<pre><code class="java">service.LeaveFormService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.EmployeeDao;
import com.imooc.oa.dao.LeaveFormDao;
import com.imooc.oa.dao.NoticeDao;
import com.imooc.oa.dao.ProcessFlowDao;
import com.imooc.oa.entity.Employee;
import com.imooc.oa.entity.LeaveForm;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.entity.ProcessFlow;
import com.imooc.oa.service.exception.BussinessException;
import com.imooc.oa.util.MybatisUtils;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * 请假单流程服务
 */
public class LeaveFormService &#123;
    /**
     * 创建请假单
     * @param form 前端输入的请假单数据
     * @return 持久化后的请假单对象
     */
    public LeaveForm createLeaveForm(LeaveForm form)&#123;
            LeaveForm savedForm = (LeaveForm) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.持久化form表单数据,8级以下员工表单状态位processing,8级(总经理)状态位approved
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());
            if (employee.getLevel() == 8)&#123;
                form.setState(&quot;approved&quot;);
            &#125;else &#123;
                form.setState(&quot;processing&quot;);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            leaveFormDao.insert(form);
            //2.增加第一条流程数据,说明表单已提交,状态位complete 初始化数据↓
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            ProcessFlow flow1 = new ProcessFlow();
            flow1.setFormId(form.getFormId());
            flow1.setOperatorId(employee.getEmployeeId());
            flow1.setAction(&quot;apply&quot;);
            flow1.setCreateTime(new Date());
            flow1.setOrderNo(1);
            flow1.setState(&quot;complete&quot;);
            flow1.setIsLast(0);
            processFlowDao.insert(flow1);
            //3.分情况创建其余流程数据 employee.xml(动态sql语句)
                // 3.1 7级以下员工,生成部门经理审批任务,请假时间大于36小时(后期单独处理),还需生成总经理审批任务
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);
                NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            if (employee.getLevel() &lt; 7)&#123;
                //动态sql EmployeeDao
                Employee dmanager = employeeDao.selectLeader(employee);
                ProcessFlow flow2 = new ProcessFlow();
                flow2.setFormId(form.getFormId());
                flow2.setOperatorId(dmanager.getEmployeeId());
                flow2.setAction(&quot;audit&quot;);//审批任务
                flow2.setCreateTime(new Date());
                flow2.setOrderNo(2);
                flow2.setState(&quot;process&quot;);
                long diff = form.getEndTime().getTime() - form.getStartTime().getTime(); //毫秒数
                float hours = diff/(1000*60*60) * 1f;
                if (hours &gt;= BussinessConstants.MANAGER_AUDIT_HOURS)&#123;
                    flow2.setIsLast(0); //最后节点
                    processFlowDao.insert(flow2);
                    Employee manager = employeeDao.selectLeader(dmanager);//总经理
                    ProcessFlow flow3 = new ProcessFlow();
                    flow3.setFormId(form.getFormId());
                    flow3.setOperatorId(manager.getEmployeeId());
                    flow3.setAction(&quot;audit&quot;);
                    flow3.setCreateTime(new Date());
                    flow3.setState(&quot;ready&quot;);
                    flow3.setOrderNo(3);
                    flow3.setIsLast(1);
                    processFlowDao.insert(flow3);
                &#125;else &#123;//小于3天&#123;
                    flow2.setIsLast(1);
                    processFlowDao.insert(flow2);
                &#125;
                //请假单已提交消息
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交,请等待上级审批.&quot;
                        , sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
                //通知部门经理审批消息
                noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot;,
                        employee.getTitle() , employee.getName() ,sdf.format(form.getStartTime()),sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(dmanager.getEmployeeId(),noticeContent));
            &#125; else if (employee.getLevel() == 7) &#123;//部门经理
                //3.2 7级员工,生成总经理审批任务
                Employee manager = employeeDao.selectLeader(employee);
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(manager.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setCreateTime(new Date());
                flow.setState(&quot;process&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
                //请假单已提交消息
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]已提交,请等待上级审批.&quot;
                        , sdf.format(form.getStartTime()), sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
                //通知总经理审批消息
                noticeContent = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot;,
                        employee.getTitle() , employee.getName() ,sdf.format(form.getStartTime()),sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(manager.getEmployeeId(),noticeContent));
            &#125;else if (employee.getLevel() == 8)&#123;
                //3.3 8级员工,生成总经理审批任务,系统自动通过
                ProcessFlow flow = new ProcessFlow();
                flow.setFormId(form.getFormId());
                flow.setOperatorId(employee.getEmployeeId());
                flow.setAction(&quot;audit&quot;);
                flow.setResult(&quot;自动通过&quot;);
                flow.setCreateTime(new Date());
                flow.setAuditTime(new Date());
                flow.setState(&quot;complete&quot;);
                flow.setOrderNo(2);
                flow.setIsLast(1);
                processFlowDao.insert(flow);
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]系统已自动批准通过.&quot; ,
                        sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()));
                noticeDao.insert(new Notice(employee.getEmployeeId(),noticeContent));
            &#125;
            return form;
        &#125;);
        return savedForm;
    &#125;
    /**
     * 获取指定任务状态及指定经办人对应的请假单列表
     * @param pfState ProcessFlow任务状态
     * @param operatorId 经办人编号
     * @return 请假单及相关数据列表
     */
    public List&lt;Map&gt; getLeaveFormList(String pfState, Long operatorId)&#123;
        return (List&lt;Map&gt;)MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            LeaveFormDao dao = sqlSession.getMapper(LeaveFormDao.class);
            List&lt;Map&gt; formList = dao.selectByParams(pfState, operatorId);
            return formList;
        &#125;);
    &#125;
    /**
     * 审核请假单
     * @param formId 表单编号
     * @param operatorId 经办人(当前登录员工)
     * @param result 审批结果
     * @param reason 审批意见
     */
    public void audit(Long formId, Long operatorId, String result, String reason)&#123;
        MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            //1.无论同意/驳回, 当前任务状态变更为complete
            ProcessFlowDao processFlowDao = sqlSession.getMapper(ProcessFlowDao.class);
            List&lt;ProcessFlow&gt; flowList = processFlowDao.selectByFormId(formId);
            if (flowList.size() == 0)&#123;
                throw new BussinessException(&quot;PF001&quot;, &quot;无效的审批流程&quot;);//自定义错误抛出
            &#125;
            //获取当前任务ProcessFlow对象
            List&lt;ProcessFlow&gt; processList = flowList.stream().filter(p-&gt;p.getOperatorId() == operatorId &amp;&amp; p.getState().equals(&quot;process&quot;)).collect(Collectors.toList());
            ProcessFlow process = null;
            if (processList.size() == 0)&#123;
                throw new BussinessException(&quot;PF002&quot;, &quot;未找到待处理任务&quot;);
            &#125;else&#123;
                process = processList.get(0);
                process.setState(&quot;complete&quot;);
                process.setResult(result);
                process.setReason(reason);
                process.setAuditTime(new Date());
                processFlowDao.update(process);
            &#125;
            LeaveFormDao leaveFormDao = sqlSession.getMapper(LeaveFormDao.class);
            LeaveForm form = leaveFormDao.selectById(formId);
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH时&quot;);
            EmployeeDao employeeDao = sqlSession.getMapper(EmployeeDao.class);
            Employee employee = employeeDao.selectById(form.getEmployeeId());//表单提交人信息
            Employee operator = employeeDao.selectById(operatorId);//任务经办人信息
            NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            //2.如果当前任务是最后一个节点,代表流程结束,更新请假单状态对应的approved/refused
            if (process.getIsLast() == 1)&#123;
                form.setState(result); // approved\refused
                leaveFormDao.update(form);
                String strResult = null;
                if (result.equals(&quot;aproved&quot;))&#123;
                    strResult = &quot;批准&quot;;
                &#125; else if (result.equals(&quot;refused&quot;)) &#123;
                    strResult = &quot;驳回&quot;;
                &#125;
                String noticeContent = String.format(&quot;您的请假申请[%s-%s]%s%s已%s,审批意见:%s,审批流程已结束&quot;
                        sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                        operator.getTitle(),operator.getName(), //批准\驳回
                        strResult,reason);//发给表单提交人的通知
                noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent));
            &#125;else &#123;
                //readyList包含所有后续任务节点
                List&lt;ProcessFlow&gt; readyList = flowList.stream().filter(p-&gt;p.getState().equals(&quot;ready&quot;)).collect(Collectors.toList());
                //3.如果当前任务不是最后一个节点且审批通过,那下一个节点的状态从ready变为process
                if (result.equals(&quot;approved&quot;))&#123;
                    ProcessFlow readyProcess = readyList.get(0);
                    readyProcess.setState(&quot;process&quot;);
                    processFlowDao.update(readyProcess);
                    //消息1: 通知表单提交人,部门经理已经审批通过,交由上级继续审批
                    String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已批准,审批意见:%s ,请继续等待上级审批&quot; ,
                            sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                            operator.getTitle() , operator.getName(),reason);
                    noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));

                    //消息2: 通知总经理有新的审批任务
                    String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s],请尽快审批&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()));
                    noticeDao.insert(new Notice(readyProcess.getOperatorId(),noticeContent2));

                    //消息3: 通知部门经理(当前经办人),员工的申请单你已批准,交由上级继续审批
                    String noticeContent3 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已批准,审批意见:%s,申请转至上级领导继续审批&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);
                    noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent3));
                &#125; else if(result.equals(&quot;refused&quot;)) &#123;
                    //4.如果当前任务不是最后一个节点且审批驳回,则后续所有任务状态变为cancel,请假单状态变为refused
                    for(ProcessFlow p:readyList)&#123;
                        p.setState(&quot;cancel&quot;);
                        processFlowDao.update(p);
                    &#125;
                    form.setState(&quot;refused&quot;);
                    leaveFormDao.update(form);
                    //消息1: 通知申请人表单已被驳回
                    String noticeContent1 = String.format(&quot;您的请假申请[%s-%s]%s%s已驳回,审批意见:%s,审批流程已结束&quot; ,
                            sdf.format(form.getStartTime()) , sdf.format(form.getEndTime()),
                            operator.getTitle() , operator.getName(),reason);
                    noticeDao.insert(new Notice(form.getEmployeeId(),noticeContent1));

                    //消息2: 通知经办人表单&quot;您已驳回&quot;
                    String noticeContent2 = String.format(&quot;%s-%s提起请假申请[%s-%s]您已驳回,审批意见:%s,审批流程已结束&quot; ,
                            employee.getTitle() , employee.getName() , sdf.format( form.getStartTime()) , sdf.format(form.getEndTime()), reason);
                    noticeDao.insert(new Notice(operator.getEmployeeId(),noticeContent2));
                &#125;
            &#125;
            return null;
        &#125;);
</code></pre>
<h3 id="完整实现系统消息功能"><a href="#完整实现系统消息功能" class="headerlink" title="完整实现系统消息功能"></a>完整实现系统消息功能</h3><pre><code class="java">dao.NoticeDao.java
package com.imooc.oa.dao;

import com.imooc.oa.entity.Notice;

import java.util.List;

public interface NoticeDao &#123;
    public void insert(Notice notice);
    public List&lt;Notice&gt; selectByReceiverId(Long receiverId);
&#125;
</code></pre>
<pre><code class="java">service.NoticeService.java
package com.imooc.oa.service;

import com.imooc.oa.dao.NoticeDao;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.util.MybatisUtils;

import java.util.List;

/**
 * 消息服务
 */
public class NoticeService &#123;
    /**
     * 查询指定员工的系统消息
     * @param receiverId
     * @return 最近100条消息列表
     */
    public List&lt;Notice&gt; getNoticeList(Long receiverId)&#123;
        return (List) MybatisUtils.executeQuery(sqlSession -&gt; &#123;
            NoticeDao noticeDao = sqlSession.getMapper(NoticeDao.class);
            return noticeDao.selectByReceiverId(receiverId);
        &#125;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">controller.NoticeServlet.java
package com.imooc.oa.controller;

import com.alibaba.fastjson.JSON;
import com.imooc.oa.entity.Notice;
import com.imooc.oa.entity.User;
import com.imooc.oa.service.NoticeService;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet(name = &quot;NoticeServlet&quot; , urlPatterns = &quot;/notice/list&quot;)
public class NoticeServlet extends HttpServlet &#123;
    private NoticeService noticeService = new NoticeService();
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;

    &#125;

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        User user = (User)request.getSession().getAttribute(&quot;login_user&quot;);
        List&lt;Notice&gt; noticeList = noticeService.getNoticeList(user.getEmployeeId());
        Map result = new HashMap&lt;&gt;();
        result.put(&quot;code&quot;, &quot;0&quot;);
        result.put(&quot;msg&quot;, &quot;&quot;);
        result.put(&quot;count&quot;, noticeList.size());
        result.put(&quot;data&quot;, noticeList);
        String json = JSON.toJSONString(result);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        response.getWriter().println(json);
    &#125;
&#125;
</code></pre>
<pre><code class="xml">resources.mappers.notice.xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.imooc.oa.dao.NoticeDao&quot;&gt;
    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.imooc.oa.entity.Notice&quot;
            useGeneratedKeys=&quot;true&quot; keyProperty=&quot;noticeId&quot; keyColumn=&quot;notice_id&quot;&gt;
        INSERT INTO sys_notice( receiver_id, content, create_time) VALUES (#&#123;receiverId&#125;, #&#123;content&#125;, #&#123;createTime&#125;)
    &lt;/insert&gt;

    &lt;select id=&quot;selectByReceiverId&quot; parameterType=&quot;Long&quot; resultType=&quot;com.imooc.oa.entity.Notice&quot;&gt;
        select * from sys_notice where receiver_id = #&#123;value&#125; order by create_time desc limit 0,100
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<pre><code class="html">index.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;办公OA系统&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;

&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;!-- Layui后台布局CSS --&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
    &lt;!--头部导航栏--&gt;
    &lt;div class=&quot;layui-header&quot;&gt;
        &lt;!--系统标题--&gt;
        &lt;div class=&quot;layui-logo&quot; style=&quot;font-size:18px&quot;&gt;慕课网办公OA系统&lt;/div&gt;
        &lt;!--右侧当前用户信息--&gt;
        &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;
                &lt;a href=&quot;javascript:void(0)&quot;&gt;
                    &lt;!--图标--&gt;
                    &lt;span class=&quot;layui-icon layui-icon-user&quot; style=&quot;font-size: 20px&quot;&gt;
                    &lt;/span&gt;
                    &lt;!--用户信息--&gt;
                    $&#123;current_employee.name&#125;[$&#123;current_department.departmentName&#125;-$&#123;current_employee.title&#125;]
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;!--注销按钮--&gt;
            &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;/logout&quot;&gt;注销&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--左侧菜单栏--&gt;
    &lt;div class=&quot;layui-side layui-bg-black&quot;&gt;
        &lt;!--可滚动菜单--&gt;
        &lt;div class=&quot;layui-side-scroll&quot;&gt;
            &lt;!--可折叠导航栏--&gt;
            &lt;ul class=&quot;layui-nav layui-nav-tree&quot;&gt;
                &lt;#list node_list as node&gt;
                &lt;!--父节点--&gt;
                    &lt;#if node.nodeType == 1&gt;
                &lt;li class=&quot;layui-nav-item layui-nav-itemed&quot;&gt;
                    &lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                    &lt;dl class=&quot;layui-nav-child module&quot; data-node-id=&quot;$&#123;node.nodeId&#125;&quot;&gt;&lt;/dl&gt;
                &lt;/li&gt;
                    &lt;/#if&gt;
                    &lt;#if node.nodeType == 2&gt;
                &lt;!--子节点--&gt;
                &lt;dd class=&quot;function&quot; data-parent-id=&quot;$&#123;node.parentId&#125;&quot;&gt;
                    &lt;a href=&quot;$&#123;node.url&#125;&quot; target=&quot;ifmMain&quot;&gt;$&#123;node.nodeName&#125;&lt;/a&gt;
                &lt;/dd&gt;
                    &lt;/#if&gt;
                &lt;/#list&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--主体部分采用iframe嵌入其他页面--&gt;
    &lt;div class=&quot;layui-body&quot; style=&quot;overflow-y: hidden&quot;&gt;
        &lt;iframe name=&quot;ifmMain&quot; src=&quot;/forward/notice&quot; style=&quot;border: 0px;width: 100%;height: 100%&quot;&gt;&lt;/iframe&gt;
    &lt;/div&gt;
    &lt;!--版权信息--&gt;
    &lt;div class=&quot;layui-footer&quot;&gt;
        Copyright © imooc. All Rights Reserved.
    &lt;/div&gt;
&lt;/div&gt;
&lt;!--LayUI JS文件--&gt;
&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //将所有功能根据parent_id移动到指定模块下 一开始先dl与dd对齐[程序维护方便]
    layui.$(&quot;.function&quot;).each(function () &#123;
        var func = layui.$(this);
        var parentId = func.data(&quot;parent-id&quot;);
        layui.$(&quot;dl[data-node-id=&quot; + parentId + &quot;]&quot;).append(func);
    &#125;)
    //刷新折叠菜单
    layui.element.render(&#39;nav&#39;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="html">notice.ftl
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;系统通知&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/resources/layui/css/layui.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;layui-row&quot;&gt;
    &lt;blockquote class=&quot;layui-elem-quote&quot;&gt;
        &lt;h2&gt;系统通知&lt;/h2&gt;
    &lt;/blockquote&gt;
    &lt;table id=&quot;grdNoticeList&quot; lay-filter=&quot;grdNoticeList&quot;&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;script src=&quot;/resources/layui/layui.all.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
    layui.table.render(&#123;
        elem : &quot;#grdNoticeList&quot; ,
        id : &quot;grdNoticeList&quot; ,
        url : &quot;/notice/list&quot; ,
        page : false ,
        cols :[[
            &#123;field : &quot;&quot; , title : &quot;序号&quot; , width:&quot;10%&quot; , style : &quot;height:60px&quot; , type:&quot;numbers&quot;&#125;,
            &#123;field : &quot;create_time&quot; , title : &quot;通知时间&quot; , width : &quot;20%&quot; , templet: function (d) &#123;
                    var newDate = new Date(d.createTime);
                    return newDate.getFullYear() + &quot;-&quot; +
                        (newDate.getMonth() + 1) + &quot;-&quot; + newDate.getDate()
                        + &quot; &quot; + newDate.getHours() + &quot;:&quot; + newDate.getMinutes() + &quot;:&quot; + newDate.getSeconds();
                &#125;&#125;,
            &#123;field : &quot;content&quot; , title : &quot;通知内容&quot; , width : &quot;60%&quot;&#125;
        ]]
    &#125;)

&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#879cff>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2023/11/07/后端/MyBatis实现OA系统项目实战/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/page/3/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            
            <a href="/"><span class="page-num">1</span></a>
            <span class="page-omit">...</span>
            

            

            

            
            <a href="/page/2">
                <span class="page-num">
                    2
                </span>
            </a>
            

            
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
        </span>
        

        <span class="current">
            4
        </span>

        
        <span>
            <a href="/page/5/">
                <span class="page-num">
                    5
                </span>
            </a>
            
            <a href="/page/6">
                <span class="page-num">
                    6
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/5/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>