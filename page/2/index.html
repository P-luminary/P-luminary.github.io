
<!DOCTYPE html>
<html lang="zh_CH ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P-luminary || </title>
    <meta name="author" content="Asuna">
    <meta name="description" content=" ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/maiden-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">P-luminary</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/tags/语法">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>P-luminary</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/tags/语法">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>P-luminary</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2025/03/05/AI/RAGFlow/">
        <h2>
            RAGFlow
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/3/5
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h3 id="什么是RAGFlow"><a href="#什么是RAGFlow" class="headerlink" title="什么是RAGFlow"></a>什么是RAGFlow</h3><p>RAGFlow 是一种基于生成模型的技术，常用于智能聊天系统、推荐系统和自然语言处理任务。如果你是从零基础开始学习 RAGFlow（可能指的是 <strong>Retrieval-Augmented Generation Flow</strong> 或与其相关的模型&#x2F;框架），以下是一些推荐的学习路径：</p>
<h5 id="1-理解基础概念"><a href="#1-理解基础概念" class="headerlink" title="1. 理解基础概念"></a><strong>1. 理解基础概念</strong></h5><p>在学习 RAGFlow 之前，你需要了解一些相关的基本概念：</p>
<ul>
<li><strong>自然语言处理（NLP）</strong>：学习 NLP 的基本概念，比如分词、词向量（Word Embedding）、序列建模等。</li>
<li><strong>机器学习基础</strong>：了解机器学习的基本原理，包括监督学习、无监督学习、深度学习等。</li>
<li><strong>深度学习框架</strong>：熟悉一些常用的深度学习框架，如 TensorFlow 和 PyTorch，它们会在训练和实现 RAGFlow 模型时用到。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/infiniflow/ragflow/blob/main/README_zh.md">ragflow&#x2F;README_zh.md at main · infiniflow&#x2F;ragflow</a></p>
<h6 id="先装个win版的Docker-Desktop"><a href="#先装个win版的Docker-Desktop" class="headerlink" title="先装个win版的Docker Desktop"></a>先装个win版的Docker Desktop</h6><h6 id="打开-Anaconda-Prompt-先放着不管"><a href="#打开-Anaconda-Prompt-先放着不管" class="headerlink" title="打开 Anaconda Prompt 先放着不管"></a>打开 Anaconda Prompt 先放着不管</h6><p>克隆 <strong>RAGFlow</strong> 的仓库 <code>$ git clone https://github.com/infiniflow/ragflow.git</code></p>
<p>——————————— ★ ★ ———————————</p>
<p>在<strong>Anaconda Prompt</strong>的命令窗口里<br>输入 <code>cd E:\Python\ragflow\docker</code><br>接着 <code>E:</code><br>然后就开始 <u><strong>装载</strong></u>      <u><strong>查看状态</strong></u></p>
<p><span style = "color:red"><strong>关闭</strong></span>            <code>docker-compose down</code><br><span style = "color:red"><strong>装载</strong></span>            <code>docker compose up -d</code><br><span style = "color:red"><strong>查看状态</strong></span>    <code>docker logs -f ragflow-server</code><br>——————————— ★ ★ ———————————</p>
<blockquote>
<p>在你的 <code>docker-compose.yml</code> 配置中，Redis 的连接问题可能是因为 RAGFlow 配置文件中的 Redis 部分使用了密码，并且 Redis 运行在 <code>localhost</code> 上。如果 Redis 没有设置密码且端口号是 <code>localhost</code>，你可以尝试以下步骤进行调整：</p>
<ol>
<li><p><strong>修改 RAGFlow 的配置</strong>：在 <code>ragflow</code> 服务的配置中，确保 Redis 的连接信息正确。需要确保 Redis 连接时不使用密码并且连接到 <code>localhost</code>。</p>
</li>
<li><p><strong>更新 <code>service_conf.yaml</code> 配置</strong>：根据日志，RAGFlow 连接 Redis 时使用了密码。你需要检查 <code>service_conf.yaml</code> 中的 Redis 配置信息，将其修改为不使用密码，并指定 <code>localhost</code>。</p>
<p>示例修改：</p>
<pre><code class="python">  host: localhost
  port: 6379
  db: 1
  password: &quot;&quot;
</code></pre>
</li>
<li><p><strong>检查 <code>docker-compose.yml</code> 配置</strong>：确保 <code>ragflow</code> 服务的 Redis 部分没有设置密码，且连接端口是 <code>localhost</code>。根据你的配置，默认情况下应该是没有密码的。</p>
</li>
<li><p><strong>重新启动服务</strong>：在修改配置后，可以重新启动 Docker 服务以使修改生效。</p>
<p>执行命令：</p>
<pre><code class="python">docker-compose down
docker-compose up -d
</code></pre>
</li>
</ol>
<p>这样，你应该能够解决 Redis 连接的相关问题。如果还有其他问题，请继续提供日志或详细信息。</p>
</blockquote>
<h6 id="如果改了配置还是不行-↓"><a href="#如果改了配置还是不行-↓" class="headerlink" title="如果改了配置还是不行 ↓"></a>如果改了配置还是不行 ↓</h6><blockquote>
<h3 id="检查与解决步骤"><a href="#检查与解决步骤" class="headerlink" title="检查与解决步骤"></a><strong>检查与解决步骤</strong></h3><h4 id="1-确保-service-conf-yaml-已正确修改"><a href="#1-确保-service-conf-yaml-已正确修改" class="headerlink" title="1. 确保 service_conf.yaml 已正确修改"></a><strong>1. 确保 <code>service_conf.yaml</code> 已正确修改</strong></h4><p>你可以进入 RAGFlow 容器，查看 RAGFlow 读取的配置是否正确：</p>
<pre><code class="python">docker exec -it ragflow-server cat /ragflow/conf/service_conf.yaml
</code></pre>
<p>检查 <code>redis</code> 配置项是否是：</p>
<pre><code class="python">  redis:
  host: ragflow-redis  
  port: 6379
  db: 1
  password: &quot;&quot;  
</code></pre>
<p>如果不是，说明 <code>docker-compose</code> 可能仍然使用了旧的配置，你需要手动更新。</p>
</blockquote>
<blockquote>
<h4 id="1-确保-service-conf-yaml-绑定到了容器"><a href="#1-确保-service-conf-yaml-绑定到了容器" class="headerlink" title="1. 确保 service_conf.yaml 绑定到了容器"></a><strong>1. 确保 <code>service_conf.yaml</code> 绑定到了容器</strong></h4><p><strong>检查 <code>docker-compose.yml</code> 是否正确挂载 <code>service_conf.yaml</code></strong><br>在 <code>docker-compose.yml</code> 里应该有：</p>
<pre><code class="python">yaml复制编辑volumes:
  - ./service_conf.yaml:/ragflow/conf/service_conf.yaml
</code></pre>
<p>如果没有这行，说明 <code>service_conf.yaml</code> 没有正确挂载，导致 RAGFlow 仍然使用容器内部的默认配置。</p>
<p>如果你修改了 <code>docker-compose.yml</code>，请执行：</p>
<pre><code class="python">docker-compose down
docker-compose up -d
</code></pre>
<p>然后 <strong>重新检查</strong> 容器内的 <code>service_conf.yaml</code> 是否正确：</p>
<pre><code class="python">docker exec -it ragflow-server cat /ragflow/conf/service_conf.yaml
</code></pre>
</blockquote>
<hr>
<p>你需要在请求中提供正确的凭证。根据之前你提供的账号密码 <code>elastic:infini_rag_flow</code>，你可以尝试以下命令：</p>
<pre><code class="python">docker exec -it 3a50f571ce26 curl -u elastic:infini_rag_flow http://localhost:9200
</code></pre>
<hr>
<h3 id="关于RAGFlow的顶级逆天Bug解决办法-gt"><a href="#关于RAGFlow的顶级逆天Bug解决办法-gt" class="headerlink" title="关于RAGFlow的顶级逆天Bug解决办法&gt;"></a><span style="color:red">关于RAGFlow的顶级逆天Bug解决办法</span>&gt;</h3><blockquote>
<p>这个不是BUG，是使用问题，如果你是如下和我一样的报错，可以参考我的解决步骤<br>是使用问题，我这边完美解决了这个问题，解决步骤如下：<br>问题: docker logs -f 917c48df8473(infiniflow&#x2F;ragflow:v0.16.0的容器日志)<br>peewee.OperationalError: (1045, “Access denied for user ‘root‘@’172.24.0.6’ (using password: YES)”)</p>
<h1 id="问题原因，这个镜像的mysql密码一致是默认密码，只要配置没改全就会报错"><a href="#问题原因，这个镜像的mysql密码一致是默认密码，只要配置没改全就会报错" class="headerlink" title="问题原因，这个镜像的mysql密码一致是默认密码，只要配置没改全就会报错"></a>问题原因，这个镜像的mysql密码一致是默认密码，只要配置没改全就会报错</h1><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h5><ol>
<li>停止并移除现有容器<br>cd .&#x2F;docker<br>docker compose -f docker-compose.yml down</li>
<li>删除或备份数据卷<br>备份命令：<br>cp -r &#x2F;home&#x2F;data&#x2F;docker&#x2F;volumes&#x2F;docker_esdata01 &#x2F;backup&#x2F;docker_esdata01_backup<br>cp -r &#x2F;home&#x2F;data&#x2F;docker&#x2F;volumes&#x2F;docker_minio_data &#x2F;backup&#x2F;docker_minio_data_backup<br>cp -r &#x2F;home&#x2F;data&#x2F;docker&#x2F;volumes&#x2F;docker_mysql_data &#x2F;backup&#x2F;docker_mysql_data_backup<br>cp -r &#x2F;home&#x2F;data&#x2F;docker&#x2F;volumes&#x2F;docker_redis_data &#x2F;backup&#x2F;docker_redis_data_backup<br>删除命令：<br>docker volume rm docker_esdata01<br>docker volume rm docker_minio_data<br>docker volume rm docker_mysql_data<br>docker volume rm docker_redis_data</li>
<li>删除未使用的网络配置<br>docker network prune</li>
<li>修改docker&#x2F;.env 、 docker&#x2F;service_conf.yaml.template和conf&#x2F;service_conf.yaml 这三个文件<br>中所有的密码，设置成自己的，务必这三处都保持一致（重要）</li>
<li>重新启动服务<br>cd .&#x2F;docker<br>[root@localhost docker]# docker compose -f docker-compose.yml up -d<br>WARN[0000] The “HF_ENDPOINT” variable is not set. Defaulting to a blank string.<br>WARN[0000] The “MACOS” variable is not set. Defaulting to a blank string.<br>[+] Running 10&#x2F;10<br>✔ Network docker_ragflow Created 0.0s<br>✔ Volume “docker_esdata01” Created 0.0s<br>✔ Volume “docker_mysql_data” Created 0.0s<br>✔ Volume “docker_minio_data” Created 0.0s<br>✔ Volume “docker_redis_data” Created 0.0s<br>✔ Container ragflow-minio Started 0.4s<br>✔ Container ragflow-es-01 Started 0.4s<br>✔ Container ragflow-redis Started 0.4s<br>✔ Container ragflow-mysql Healthy 10.9s<br>✔ Container ragflow-server Started 11.1s</li>
</ol>
<h1 id="6-查看日志看看，没有如下报错了："><a href="#6-查看日志看看，没有如下报错了：" class="headerlink" title="6.查看日志看看，没有如下报错了："></a>6.查看日志看看，没有如下报错了：</h1><p>2025-02-26 10:51:53,554 INFO 20 TaskExecutor: RAGFlow version: v0.16.0 full<br>2025-02-26 10:51:53,554 INFO 20 Use Elasticsearch <a target="_blank" rel="noopener" href="http://es01:9200/">http://es01:9200</a> as the doc engine.<br>2025-02-26 10:51:53,563 INFO 20 GET <a target="_blank" rel="noopener" href="http://es01:9200/">http://es01:9200/</a> [status:200 duration:0.007s]<br>2025-02-26 10:51:53,566 INFO 20 HEAD <a target="_blank" rel="noopener" href="http://es01:9200/">http://es01:9200/</a> [status:200 duration:0.003s]<br>2025-02-26 10:51:53,566 INFO 20 Elasticsearch <a target="_blank" rel="noopener" href="http://es01:9200/">http://es01:9200</a> is healthy.<br>2025-02-26 10:51:53,572 WARNING 20 Load term.freq FAIL!<br>2025-02-26 10:51:53,577 WARNING 20 Realtime synonym is disabled, since no redis connection.<br>2025-02-26 10:51:53,583 WARNING 20 Load term.freq FAIL!<br>2025-02-26 10:51:53,588 WARNING 20 Realtime synonym is disabled, since no redis connection.<br>2025-02-26 10:51:53,588 INFO 20 MAX_CONTENT_LENGTH: 134217728<br>2025-02-26 10:51:53,588 INFO 20 SERVER_QUEUE_MAX_LEN: 1024<br>2025-02-26 10:51:53,588 INFO 20 SERVER_QUEUE_RETENTION: 3600<br>2025-02-26 10:51:53,588 INFO 20 MAX_FILE_COUNT_PER_USER: 0<br>2025-02-26 10:51:53,591 WARNING 20 RedisDB.queue_info rag_flow_svr_queue got exception: no such key<br>2025-02-26 10:51:53,592 INFO 20 task_consumer_0 reported heartbeat: {“name”: “task_consumer_0”, “now”: “2025-02-26T10:51:53.591+08:00”, “boot_at”: “2025-02-26T10:51:53.554+08:00”, “pending”: 0, “lag”: 0, “done”: 0, “failed”: 0, “current”: null}</p>
<h1 id="7-注册登录注册测试：OK"><a href="#7-注册登录注册测试：OK" class="headerlink" title="7.注册登录注册测试：OK"></a>7.注册登录注册测试：OK</h1><p>👍2</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://ollama.com/shaw/dmeta-embedding-zh">shaw&#x2F;dmeta-embedding-zh</a><br><strong>Anaconda Prompt</strong>启动： <code>ollama pull shaw/dmeta-embedding-zh</code></p>
<p>把每个段落做成<strong>向量化的编码</strong></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#00bcd4>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/03/05/AI/RAGFlow/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/27/AI/AutoGen/">
        <h2>
            AutoGen
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/27
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><span style = "color:red"><strong>待完成</strong>：架构 设计思想 整个代码怎么组织起来的 怎么去满足各种需求 </span><br><u>B站牛人UP主【DataSense】</u><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7462775772009938970">AutoGen 技术博客系列 (一)：基础介绍与入门教程这篇博客提供了对 AutoGen 的基础介绍和入门教程，包括核心 - 掘金</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16u4y1j7so/?vd_source=a4d980c3208d51858f08b3025a6ab2d9">AutoGen 智能应用开发（一）｜AutoGen 基础_哔哩哔哩_bilibili</a></p>
<p>[microsoft&#x2F;autogen: A programming framework for agentic AI 🤖 PyPi: autogen-agentchat Discord: <a target="_blank" rel="noopener" href="https://aka.ms/autogen-discord">https://aka.ms/autogen-discord</a> Office Hour: <a target="_blank" rel="noopener" href="https://aka.ms/autogen-officehour]">https://aka.ms/autogen-officehour]</a> (<a target="_blank" rel="noopener" href="https://github.com/microsoft/autogen">https://github.com/microsoft/autogen</a>)</p>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>AutoGen</strong> 和 <strong>AutoGen Studio</strong> 都是由微软开发的用于创建和管理人工智能（AI）智能体的工具，但它们在功能和目标方面存在一些差异。</p>
<p>AutoGen 是一款基于 AI 和大数据技术的产品设计工具，旨在通过自动提取产品需求、智能优化设计方案并生成最终的产品模型或解决方案。其核心目标是将人工干预降至最低，从而提升用户体验和系统开发效率。AutoGen 是一个开源的 Python 框架，用于定义、配置和组合 AI 代理以构建多智能体应用。它提供了一种用于描述代理行为和它们之间交互的声明性语言。AutoGen 非常灵活，可用于构建各种多智能体应用，但它需要一定的编程技能才能使用。</p>
<p>AutoGen Studio 是一个基于 AutoGen 框架的图形用户界面（GUI）工具。它使开发人员能够更轻松地创建和管理多智能体应用，而无需编写代码。AutoGen Studio 提供了拖放式界面和各种预构建模块，可以简化多智能体应用的开发过程。但是，AutoGen Studio 的灵活性不如 AutoGen，并且它可能不适用于需要高度定制的应用。</p>
<p>以下表格总结了 AutoGen 和 AutoGen Studio 的一些关键区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">AutoGen</th>
<th align="left">AutoGen Studio</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类型</td>
<td align="left">框架</td>
<td align="left">GUI 工具</td>
</tr>
<tr>
<td align="left">抽象级别</td>
<td align="left">更底层</td>
<td align="left">更高层</td>
</tr>
<tr>
<td align="left">灵活度</td>
<td align="left">更灵活</td>
<td align="left">不太灵活</td>
</tr>
<tr>
<td align="left">易用性</td>
<td align="left">更难使用</td>
<td align="left">更易使用</td>
</tr>
<tr>
<td align="left">编程要求</td>
<td align="left">需要编程技能</td>
<td align="left">无需编程技能</td>
</tr>
<tr>
<td align="left">常见用例</td>
<td align="left">高度定制的多智能体应用</td>
<td align="left">通用多智能体应用</td>
</tr>
</tbody></table>
<p><strong>总而言之，AutoGen</strong> 适合需要高度定制和灵活性的多智能体应用开发人员，而 <strong>AutoGen Studio</strong> 适合需要快速构建通用多智能体应用的开发人员。</p>
<p>AI + 行业 &#x3D; Agent</p>
<p>只需要把接口复制粘贴来到AutoGen Studio的技能表<br>**<u>万能API</u>**：[<strong>天聚数行TianAPI - 应用开发者API数据调用平台</strong>] (<a target="_blank" rel="noopener" href="https://www.tianapi.com/">https://www.tianapi.com/</a>)</p>
<p>我们要去给智能体配置上你需要的能力！</p>
<p>我结合智能体我可以做到每个行业 但每个行业都有自己角色的一个定义<br>我要给智能体定义角色</p>
<hr>
<blockquote>
<ol>
<li><strong>技术基础和领域：</strong><ul>
<li>“AutoGen” 可能依赖于特定的技术，如机器学习算法、自然语言处理模型等，<br>主要用于自动化代码生成、文档自动提取或数据分析任务。</li>
<li>“AiAgent” 则是人工智能领域的核心概念，涵盖从需求理解到解决方案生成的<br>全生命周期管理。它能够将不同领域的需求整合起来，提供综合性的解决方案。</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li>在“AutoGen”的应用中，可能包括自动化代码生成、文档自动化处理、数据分析<br>工具的构建等。</li>
<li>在“AiAgent”的应用中，可能涉及需求分析和理解，数据预处理与清洗，以及生<br>成生成模型（如“AutoGen”）中的产品设计生成。</li>
</ul>
</li>
<li><strong>功能特点：</strong><ul>
<li>“AutoGen” 可能专注于自动化、快速迭代和标准化能力，适合需要大量重复劳<br>动的任务。</li>
<li>“AiAgent” 通常结合人工智能的高级算法和分布式系统，能够处理复杂、多领<br>域的问题，并提供灵活的解决方案。</li>
</ul>
</li>
<li><strong>研究方向与应用深度：</strong><ul>
<li>在“AutoGen”的研究中，可能侧重于特定任务的具体实现和技术优化。</li>
<li>在“AiAgent”的研究中，可能涉及跨领域的知识融合、分布式计算环境等高级技<br>术，推动了AI领域的发展。</li>
</ul>
</li>
</ol>
</blockquote>
<p>全自动化的 <strong>AI Agents</strong></p>
<p>LangChain可以实现做AI Agent<br>XAgent || <strong>AutoGen</strong> 是更一步进化的</p>
<p>如果有与图片输出相关的，帮忙加一个GenImg(“图片生成提示 <strong>Prompt</strong>“)<br>利用Prompt设定可以分配任务到不同的Agent上</p>
<p><strong>AutoGen</strong> 是一个框架，支持使用多个代理来开发 LLM 应用程序这些代理可以相互对话来解决任务。AutoGen 代理是可定制的、可对话的，并且无缝地允许人参与其中。他们可以结合 LLM、人工输入和不同工具的各种模式运行。</p>
<p><strong>AutoGen</strong>是微软的开源框架</p>
<p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/microsoft/autogen">microsoft&#x2F;autogen: A programming framework for agentic AI 🤖 PyPi: autogen-agentchat Discord: https://aka.ms/autogen-discord Office Hour: https://aka.ms/autogen-officehour</a></p>
<p>文档博客：<a target="_blank" rel="noopener" href="https://microsoft.github.io/autogen/stable/">AutoGen — AutoGen</a></p>
<h5 id="AutoGen-主要特点"><a href="#AutoGen-主要特点" class="headerlink" title="AutoGen 主要特点"></a>AutoGen 主要特点</h5><p>AutoGen 可以轻松构建基于多代理对话的下一代 LLM 应用程序。它简化了复杂的LLM 工作流程的编排、自动化和优化。它最大限度地提高了 LLM 模型的性能并克服了它们的弱点。<br>它支持复杂工作流程的多种对话模式。借助可定制和可对话的代理，开发人员可以使用 AutoGen 构建各种涉及对话自主性、代理数量和代理对话拓扑的对话模式。<br>它提供了一系列具有不同复杂性的工作系统。 这些系统涵盖各种领域和复杂性的广泛应用。 这演示了 AutoGen 如何轻松支持不同的对话模式。<br>AutoGen 提供增强的 LLM 推理。 它提供 API统一和缓存等实用程序，以及错误处理、多配置推理、上下文编程等高级使用模式。</p>
<p>AutoGen 抽象并实现了可对话代理，旨在通过代理间对话来解决任务。<br><strong>可对话</strong>：AutoGen 中的代理是可对话的，这意味着任何代理都可以从其他代理发送和接收消息以发起或继续对话<br><strong>可定制</strong>：AutoGen 中的代理可以定制以集成 LLM、人、工具或它们的组合。</p>
<hr>
<h6 id="★-PyCharm怎么打开-ipynb后缀文件-我需要详细步骤-我pycharm里面没有这个？"><a href="#★-PyCharm怎么打开-ipynb后缀文件-我需要详细步骤-我pycharm里面没有这个？" class="headerlink" title="★ PyCharm怎么打开.ipynb后缀文件 我需要详细步骤 我pycharm里面没有这个？"></a>★ PyCharm怎么打开.ipynb后缀文件 我需要详细步骤 我pycharm里面没有这个？</h6><p>如果 PyCharm 版本较老或者插件不可用，可以用外部 Jupyter Notebook 运行：</p>
<ol>
<li><p>安装 Jupyter</p>
<p>打开 PyCharm 自带的 Terminal（终端）输入：</p>
<pre><code class="python">pip install jupyter
</code></pre>
</li>
<li><p>在 Terminal 里启动 <strong>Jupyter</strong></p>
<pre><code class="python">jupyter notebook
</code></pre>
</li>
<li><p><strong>在浏览器中打开 .ipynb</strong> Jupyter Notebook 会在浏览器中打开，你可以在其中编辑 <code>.ipynb</code> 文件。</p>
</li>
</ol>
<h5 id="AutoGen基础环境配置"><a href="#AutoGen基础环境配置" class="headerlink" title="AutoGen基础环境配置"></a>AutoGen基础环境配置</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/epitomizelu/article/details/140287498?ops_request_misc=%7B%22request_id%22:%2202bd36b0219fe5e5f9a59b0a71085885%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=02bd36b0219fe5e5f9a59b0a71085885&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-140287498-null-null.142%5Ev101%5Epc_search_result_base7&utm_term=%E6%80%8E%E4%B9%88%E4%B8%8B%E8%BD%BDautogen&spm=1018.2226.3001.4187">AutoGen基础环境安装_autogen安装-CSDN博客</a></p>
<p>windows开始菜单搜索栏，搜索prompt，搜索结果中可以看应用<code>Aanconda Powershell Prompt</code>。</p>
<p>接下来，我们将使用这个工具创建一个特定版本的Python环境。<br>在打开的命令行工具中输入如下命令，然后回车。</p>
<p><code>conda create -n lcy python=3.10</code></p>
<blockquote>
<p>-n 后面是的lcy是环境的名称，相当于一个标识，后续要用这个环境时通过这个名称进行查找<br>python&#x3D;3.10，是指定python的版本</p>
</blockquote>
<p>接下来，输入如下命令，切换到创建好的环境。</p>
<p>★ <code>conda activate lcy</code></p>
<p>接下来我们需要安装Autogen Studio。<br>那怎么安装呢？超级简单，在刚刚我们准备好的python环境中执行一个命令就好。</p>
<p><code>pip install autogen studio</code></p>
<p>但如果直接这样执行的话，因为它会访问国外的网站完成下载，所以速度非常慢，慢到不能忍受。所以我们需要让它去国内的镜像下载。通过参数-i指定国内镜像地址，我们使用阿里云的镜像。</p>
<p>上述命令就变成如下这样了。</p>
<p><code>pip install autogenstudio -i https://mirrors.aliyun.com/pypi/simple</code></p>
<p>下载之后，使用如下命令启动autogen studio服务。</p>
<pre><code class="bash">★ (lcy) C:\Users\Pluminary&gt; autogenstudio ui --port 6001
</code></pre>
<p>之后直接访问<code>AutoGen Studio [Beta]</code> → [127.0.0.1:6001] (<a target="_blank" rel="noopener" href="http://127.0.0.1:6001/">http://127.0.0.1:6001/</a>)</p>
<blockquote>
<p>在AutoGen Studio中，Team Builder是一个功能模块，允许用户配置和管理不同的Agents来构建多智能体系统。下面是对您提到的几种Agents的详细分析：</p>
<h6 id="AssistantAgent"><a href="#AssistantAgent" class="headerlink" title="AssistantAgent"></a>AssistantAgent</h6><ul>
<li><strong>用途</strong>：AssistantAgent 是一种用于处理和生成对话的智能体。它可以用来创建聊天机器人、虚拟助手或任何需要与用户进行交互的应用程序。</li>
<li>功能<ul>
<li><strong>对话生成</strong>：能够基于用户的输入生成自然语言响应。</li>
<li><strong>任务执行</strong>：可以执行特定的任务，如信息查询、简单计算或执行预设的命令。</li>
<li><strong>上下文管理</strong>：保持对话的上下文，使得对话更加连贯和自然。</li>
</ul>
</li>
</ul>
<h6 id="Web-Surfer-Agent"><a href="#Web-Surfer-Agent" class="headerlink" title="Web Surfer Agent"></a>Web Surfer Agent</h6><ul>
<li><strong>用途</strong>：Web Surfer Agent 专门用于从互联网上检索信息。它是一个网络爬虫，能够访问网页并提取有用的信息。</li>
<li>功能<ul>
<li><strong>网页访问</strong>：能够访问指定的网页，获取内容。</li>
<li><strong>信息提取</strong>：从网页中提取结构化或非结构化数据。</li>
<li><strong>数据整合</strong>：将提取的数据整合到对话或应用程序中。</li>
</ul>
</li>
</ul>
<h6 id="Verification-Assistant"><a href="#Verification-Assistant" class="headerlink" title="Verification Assistant"></a>Verification Assistant</h6><ul>
<li><strong>用途</strong>：Verification Assistant 用于验证信息的准确性或执行某些检查任务。</li>
<li>功能<ul>
<li><strong>数据验证</strong>：检查数据的准确性，例如验证用户输入的信息是否符合特定的格式或标准。</li>
<li><strong>逻辑验证</strong>：执行逻辑检查，比如验证某个流程是否按照预定的规则执行。</li>
<li><strong>合规性检查</strong>：确保操作符合特定的行业或法律标准。</li>
</ul>
</li>
</ul>
<h6 id="UserProxyAgent"><a href="#UserProxyAgent" class="headerlink" title="UserProxyAgent"></a>UserProxyAgent</h6><ul>
<li><strong>用途</strong>：UserProxyAgent 代表用户执行操作，通常用于模拟用户行为或自动化用户任务。</li>
<li>功能<ul>
<li><strong>行为模拟</strong>：模拟用户的行为，例如在测试环境中模拟用户操作。</li>
<li><strong>任务自动化</strong>：自动化重复性的用户任务，提高效率。</li>
<li><strong>隐私保护</strong>：在需要保护用户隐私的场景中，代替用户执行操作，减少个人信息泄露的风险。</li>
</ul>
</li>
</ul>
<p>在Team Builder中，这些Agents可以被配置和组合，以构建复杂的工作流程。例如，一个工作流程可能首先使用Web Surfer Agent从网络上获取信息，然后由AssistantAgent处理这些信息并生成响应，最后由Verification Assistant验证响应的准确性。通过这种方式，AutoGen Studio 提供了一个灵活且强大的平台，用于创建高效且可扩展的多智能体系统。</p>
</blockquote>
<hr>
<hr>
<p><strong>ConversableAgent</strong> 是一个综合性的智能对话系统，它能够提供个性化和高效的交流体验</p>
<p><strong>AssistantAgent（助手代理）</strong>：</p>
<p>想象一下你有一个智能助手，比如Siri或Alexa，AssistantAgent就像是这个助手的大脑。它的任务是理解和处理用户的请求，然后做出相应的回应。在AutoGen系统中，AssistantAgent负责接收用户的信息，分析这些信息，并根据预设的规则或逻辑来执行任务。比如，如果你告诉助手“我明天有个会议”，AssistantAgent就会帮你设置提醒或者添加到日程中。</p>
<p><strong>UserProxyAgent（用户代理代理）</strong>：</p>
<p>想象你在玩一个角色扮演游戏，UserProxyAgent就像是你的角色，它代表你在游戏世界中行动。在AutoGen系统中，UserProxyAgent代表用户与系统或其他用户进行交互。它可以是用户的替身，执行用户的命令，或者代表用户参与某些活动。比如，如果你在一个在线论坛上，UserProxyAgent可以帮你发帖或者回复别人的评论。</p>
<p><strong>GroupChatManager（群聊管理器）</strong>：</p>
<p>想象你在参加一个多人在线会议或群聊，GroupChatManager就像是会议的主持人或者群聊的管理员。它的职责是协调群聊中的所有参与者，确保信息流畅且有序地传递。在AutoGen系统中，GroupChatManager负责管理群聊的各个方面，比如邀请成员加入、监控聊天内容、维持聊天秩序等。如果有人在群聊中发了不合适的内容，GroupChatManager可能会介入处理。</p>
<hr>
<p><span style = "color:red">在PyCharm中新建一个基于<strong>conda</strong>的工程文件</span><br><u><strong>在命令行里输入</strong></u>:<code> pip install pyautogen</code></p>
<p>本地启动 DeepSeek → <code>C:\Users\Pluminary&gt;ollama run deepseek-r1:1.5b</code></p>
<h5 id="配置Open-WebUI"><a href="#配置Open-WebUI" class="headerlink" title="配置Open WebUI"></a>配置Open WebUI</h5><p><span style = "color:red"><strong>可以测试模型的问答</strong></span></p>
<h6 id="先安装conda"><a href="#先安装conda" class="headerlink" title="先安装conda"></a>先安装conda</h6><pre><code class="python">conda create -n open-webui python=3.11.0
activate open-webui

# 开源的访问大模型管理页面
pip install open-webui
</code></pre>
<h6 id="配置WebUI：启动"><a href="#配置WebUI：启动" class="headerlink" title="配置WebUI：启动"></a>配置WebUI：启动</h6><pre><code class="python">open-webui serve
------------------
http://localhost:8080
</code></pre>
<pre><code class="python">sentence_bert_config.json: 100%|████████████████████████████████████████████████████████████| 53.0/53.0 [00:00&lt;?, ?B/s]
tokenizer_config.json: 100%|██████████████████████████████████████████████████████████████████| 350/350 [00:00&lt;?, ?B/s]
vocab.txt: 100%|████████████████████████████████████████████████████████████████████| 232k/232k [00:00&lt;00:00, 1.17MB/s]
tokenizer.json: 100%|███████████████████████████████████████████████████████████████| 466k/466k [00:00&lt;00:00, 26.0MB/s]
special_tokens_map.json: 100%|████████████████████████████████████████████████████████████████| 112/112 [00:00&lt;?, ?B/s]
INFO:     Started server process [18264]
INFO:     Waiting for application startup.
2025-02-28 08:29:21.807 | INFO     | open_webui.utils.logger:start_logger:140 - GLOBAL_LOG_LEVEL: INFO - &#123;&#125;

# 等看到端口号再去访问 18264
</code></pre>
<hr>
<h4 id="利用Python部署本地DeepSeek并进行连通"><a href="#利用Python部署本地DeepSeek并进行连通" class="headerlink" title="利用Python部署本地DeepSeek并进行连通"></a>利用Python部署本地DeepSeek并进行连通</h4><pre><code class="python"># 用于发送 HTTP 请求。在此代码中，我们使用它与本地部署的 DeepSeek 服务进行通信
import requests
# 用于处理 JSON 数据，尤其是在发送和接收 HTTP 请求时
import json


# 定义与 DeepSeek 服务交互的类
class DeepSeekChat:
    # 这个类负责与 DeepSeek 服务进行交互 它接受两个参数：
    &#39;&#39;&#39;
     model：模型名称，在这个案例中是 &quot;deepseek-r1:1.5b&quot;。
     base_url：DeepSeek 服务的 API 基础 URL，即本地部署的 DeepSeek 服务地址。
     
我们通常使用self作为第一个参数的名称。这是为了代码的可读性和一致性。这个约定使得其他阅读你代码的Python程序员能够立即识别出self代表的是类的实例。
    &#39;&#39;&#39;
    def __init__(self, model, base_url):
        self.model = model
        self.base_url = base_url

    # send_message 方法：该方法接收一个消息列表 messages
    # 并构建一个 POST 请求的有效负载（payload），包括模型名称和消息内容。messages 是一个包含多条消息的列表。
    def send_message(self, messages):
        # 构建请求数据
        payload = &#123;
            &quot;model&quot;: self.model,
            &quot;messages&quot;: messages
        &#125;
        # 设置请求头，指定请求体的内容类型为 application/json
        headers = &#123;
            &quot;Content-Type&quot;: &quot;application/json&quot;
        &#125;

        # 发送请求到本地 DeepSeek 服务
 &#39;&#39;&#39;
使用 requests.post() 发送 HTTP POST 请求到 DeepSeek 服务的 API 地址 self.base_url
json.dumps(payload) 将请求体的负载 payload 转换为 JSON 格式的字符串。
 &#39;&#39;&#39;
        response = requests.post(self.base_url, headers=headers, data=json.dumps(payload))

        if response.status_code == 200:
            return response.json()  # 返回 DeepSeek 返回的响应
        else:
            return &#123;&quot;error&quot;: f&quot;Request failed with status code &#123;response.status_code&#125;&quot;&#125;


# 定义初始化消息 定义启动对话函数
&#39;&#39;&#39;
此函数启动并管理与用户的对话。它定义了一个初始化的 messages 列表，其中包含一个系统消息，系统消息的角色是 &quot;system&quot;，内容是 &quot;You are a helpful assistant.&quot;，这将告诉模型其应扮演的角色
&#39;&#39;&#39;
def start_conversation():
    messages = [
        &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;  # 系统消息定义角色
    ]

    # 初始化 DeepSeekChat 实例
    deepseek_chat = DeepSeekChat(
        model=&quot;deepseek-r1:1.5b&quot;,  # 使用的本地模型
        base_url=&quot;http://localhost:11434/v1/chat/completions&quot;  # 本地服务 URL
    )
# 创建一个 DeepSeekChat 类的实例 deepseek_chat，并传入本地模型和服务的 URL
    while True:
        try:
            # 获取用户输入问题
            user_input = input(&quot;You: &quot;)

            # 如果用户输入 &quot;exit&quot; 退出循环
            # 进入一个 while True 循环，不断等待用户输入
            #用户的每次输入都会被捕获并存储在 user_input 变量中。

            if user_input.lower() == &quot;exit&quot;:
                print(&quot;Exiting the conversation.&quot;)
                break

            # 添加用户消息
             essages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;)

            # 发送用户消息并获取模型回答 将用户的输入添加到 messages 列表中，消息的角色设置为 &quot;user&quot;。
            response = deepseek_chat.send_message(messages)

            # 检查响应是否包含错误
            if &quot;error&quot; in response:
                print(response[&quot;error&quot;])
            else:
                # 打印 DeepSeek 模型的回答
                answer = response.get(&quot;choices&quot;, [&#123;&#125;])[0].get(&quot;message&quot;, &#123;&#125;).get(&quot;content&quot;, &quot;No response&quot;)
                print(&quot;DeepSeek: &quot; + answer)

        except KeyboardInterrupt:
            print(&quot;\nExiting the conversation due to user interrupt.&quot;)
            break
&#39;&#39;&#39;
if __name__ == &quot;__main__&quot;: 语句保证只有当脚本作为主程序执行时才会调用 start_conversation 函数。如果该脚本被作为模块导入到其他脚本中，则不会执行该函数。
&#39;&#39;&#39;

if __name__ == &quot;__main__&quot;:
    start_conversation()
</code></pre>
<h6 id="假设你已经理解了-DeepSeek-的基础代码，下面的例子演示了如何使用-AutoGen-集成-DeepSeek："><a href="#假设你已经理解了-DeepSeek-的基础代码，下面的例子演示了如何使用-AutoGen-集成-DeepSeek：" class="headerlink" title="假设你已经理解了 DeepSeek 的基础代码，下面的例子演示了如何使用 AutoGen 集成 DeepSeek："></a><strong>假设你已经理解了 DeepSeek 的基础代码，下面的例子演示了如何使用 AutoGen 集成 DeepSeek：</strong></h6><pre><code class="python">import requests
from autogen import Agent, GroupChat, GroupChatManager
from autogen.models.openai import OpenAIChatCompletionClient
import json

# 定义与 DeepSeek 服务交互的类
class DeepSeekChat:
    def __init__(self, model, base_url):
        self.model = model
        self.base_url = base_url

    def send_message(self, messages):
        payload = &#123;
            &quot;model&quot;: self.model,
            &quot;messages&quot;: messages
        &#125;
        headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;
        response = requests.post(self.base_url, headers=headers, data=json.dumps(payload))
        
        if response.status_code == 200:
            return response.json()
        else:
            return &#123;&quot;error&quot;: f&quot;Request failed with status code &#123;response.status_code&#125;&quot;&#125;

# 创建自定义代理（DeepSeek 代理）
class DeepSeekAgent(Agent):
    def __init__(self, model, base_url):
        super().__init__(name=&quot;DeepSeekAgent&quot;)
        self.chat = DeepSeekChat(model, base_url)

    def on_message(self, message):
        response = self.chat.send_message([&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message&#125;])
        return response.get(&quot;choices&quot;, [&#123;&#125;])[0].get(&quot;message&quot;, &#123;&#125;).get(&quot;content&quot;, &quot;No response&quot;)

# 创建用户代理
class UserAgent(Agent):
    def __init__(self):
        super().__init__(name=&quot;UserAgent&quot;)

    def on_message(self, message):
        return message

# 设置 DeepSeek 代理
deepseek_agent = DeepSeekAgent(model=&quot;deepseek-r1:1.5b&quot;, base_url=&quot;http://localhost:11434/v1/chat/completions&quot;)
user_agent = UserAgent()

# 创建群聊
group_chat = GroupChat(agents=[deepseek_agent, user_agent])
group_chat_manager = GroupChatManager(group_chat)

# 启动对话
def start_conversation():
    while True:
        try:
            user_input = input(&quot;You: &quot;)
            if user_input.lower() == &quot;exit&quot;:
                print(&quot;Exiting the conversation.&quot;)
                break
            
            response = group_chat_manager.handle_message(user_input)
            print(f&quot;DeepSeek: &#123;response&#125;&quot;)
        
        except KeyboardInterrupt:
            print(&quot;\nExiting the conversation due to user interrupt.&quot;)
            break

if __name__ == &quot;__main__&quot;:
    start_conversation()
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#ffa2c4>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/02/27/AI/AutoGen/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/26/AI/python/">
        <h2>
            python
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/26
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Python-基础初级"><a href="#Python-基础初级" class="headerlink" title="Python 基础初级"></a><span style = "color:red">Python 基础初级</span></h1><h6 id="print函数输出数组"><a href="#print函数输出数组" class="headerlink" title="print函数输出数组"></a>print函数输出数组</h6><pre><code class="python">py3.x使用输出集合
list = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
print (list)
-------------------
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</code></pre>
<h6 id="带引号的是同一行显示多条语句"><a href="#带引号的是同一行显示多条语句" class="headerlink" title="带引号的是同一行显示多条语句"></a>带引号的是同一行显示多条语句</h6><pre><code class="python">print(&#39;hello&#39;); print(&#39;world&#39;)
</code></pre>
<h6 id="py代码块不能使用大括号-只能用缩进"><a href="#py代码块不能使用大括号-只能用缩进" class="headerlink" title="py代码块不能使用大括号 只能用缩进"></a>py代码块不能使用大括号 只能用缩进</h6><pre><code class="python">if True:
    print(&#39;true&#39;)
else:
    print(&#39;false&#39;)
</code></pre>
<h6 id="多行语句可以用斜杠"><a href="#多行语句可以用斜杠" class="headerlink" title="多行语句可以用斜杠( \ )"></a>多行语句可以用斜杠( \ )</h6><h6 id="多行注释可以用-单引号-也可以用双引号"><a href="#多行注释可以用-单引号-也可以用双引号" class="headerlink" title="多行注释可以用 单引号 也可以用双引号"></a>多行注释可以用 单引号 也可以用双引号</h6><pre><code class="python"># 多引号
&quot;&quot;&quot;
111

1
&quot;&quot;&quot;

# 单引号
&#39;&#39;&#39;
1
1
1
&#39;&#39;&#39;
</code></pre>
<h6 id="print输出是否换行-不换行就末尾加逗号-在py3之后就要用end-x3D-”-“"><a href="#print输出是否换行-不换行就末尾加逗号-在py3之后就要用end-x3D-”-“" class="headerlink" title="print输出是否换行 不换行就末尾加逗号 在py3之后就要用end&#x3D;” “"></a>print输出是否换行 不换行就末尾加逗号 在py3之后就要用end&#x3D;” “</h6><pre><code class="python">x = &quot;a&quot;
y = &quot;b&quot;
print(x, end=&quot; &quot;)
print(y)
</code></pre>
<h6 id="整型-浮点-字符串"><a href="#整型-浮点-字符串" class="headerlink" title="整型 浮点 字符串"></a>整型 浮点 字符串</h6><pre><code class="python">counter = 100
miles = 100.0
name = &quot;Runoob&quot;

print(counter)
print(miles)
print(name)
</code></pre>
<h6 id="加号是字符串连接运算符-型号是重复操作"><a href="#加号是字符串连接运算符-型号是重复操作" class="headerlink" title="加号是字符串连接运算符 型号是重复操作"></a>加号是字符串连接运算符 型号是重复操作</h6><pre><code class="python">str = &quot;Hello World!&quot;
print(str * 2)
print(str + &quot;TEST&quot;)

list = [&#39;sac&#39;, 123, 2.32, &#39;john&#39;, 70.2]
print list[2:] # 输出从第三个开始至列表末尾的所有元素
-------------------
Hello World!Hello World!
Hello World!TEST

[2.32, &#39;john&#39;, 70.2]
</code></pre>
<h6 id="列表是有序的对象集合，字典是无序的对象集合"><a href="#列表是有序的对象集合，字典是无序的对象集合" class="headerlink" title="列表是有序的对象集合，字典是无序的对象集合"></a>列表是有序的对象集合，字典是无序的对象集合</h6><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存储<br>字典用’{ }’标识，字典由索引(key)和它对应的值value组成</p>
<blockquote>
<p>Python中的集合（Set）、元组（Tuple）和字典（Dictionary）是三种不同的数据结构，它们各自有不同的特点和用途：</p>
<ol>
<li><strong>集合（Set）</strong>：<ul>
<li>无序的集合数据类型，其中每个元素都是唯一的，没有重复的元素。</li>
<li>支持集合的数学运算，如并集、交集、差集等。</li>
<li>用大括号 <code>&#123;&#125;</code> 或者 <code>set()</code> 函数来创建，但空集合只能用 <code>set()</code> 创建，因为 <code>&#123;&#125;</code> 创建的是空字典。</li>
<li>例子：<code>&#123;1, 2, 3&#125;</code></li>
</ul>
</li>
<li><strong>元组（Tuple）</strong>：<ul>
<li>有序的集合数据类型，元素用圆括号 <code>()</code> 括起来。</li>
<li>元组中的元素不可修改，即一旦创建，就不能更改其内容。</li>
<li>元组可以包含不同类型的元素。</li>
<li>例子：<code>(1, &quot;hello&quot;, 3.14)</code></li>
</ul>
</li>
<li><strong>字典（Dictionary）</strong>：<ul>
<li>无序的键值对集合，每个键都是唯一的。</li>
<li>键和值之间用冒号 <code>:</code> 分隔，多个键值对之间用逗号 <code>,</code> 分隔，整个字典包括在大括号 <code>&#123;&#125;</code> 中。</li>
<li>键必须是不可变的数据类型，如字符串、数字或元组，而值可以是任何数据类型。</li>
<li>可以通过键来访问、修改或删除对应的值。</li>
<li>例子：<code>&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;</code></li>
</ul>
</li>
</ol>
<p>总结区别：</p>
<ul>
<li><strong>唯一性</strong>：集合和字典中的元素（对于集合是元素，对于字典是键）都是唯一的，而元组中的元素可以重复。</li>
<li><strong>可变性</strong>：集合和字典是可变的，可以添加、删除元素，而元组是不可变的。</li>
<li><strong>有序性</strong>：元组是有序的，可以索引访问；集合和字典是无序的，不能通过索引访问。</li>
<li><strong>用途</strong>：集合用于处理集合操作，字典用于存储键值对，元组用于存储不可变的有序元素</li>
</ul>
</blockquote>
<pre><code class="python">tinydict = &#123;&#39;name&#39;: &#39;runoob&#39;,&#39;code&#39;:6734, &#39;dept&#39;:&#39;sales&#39;&#125;
print(tinydict)
print(tinydict.keys())
print(tinydict.values())
------------------------------------
&#123;&#39;name&#39;: &#39;runoob&#39;, &#39;code&#39;: 6734, &#39;dept&#39;: &#39;sales&#39;&#125;
dict_keys([&#39;name&#39;, &#39;code&#39;, &#39;dept&#39;])
dict_values([&#39;runoob&#39;, 6734, &#39;sales&#39;])
</code></pre>
<h6 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h6><blockquote>
<p>‘<em>‘ 两个数相乘<br>‘%’ 返回除法的余数 — 取模<br>‘**’ 幂 返回x的y次幂        a * * b为10的20次方<br>‘</em> *&#x3D;’                                  c * * &#x3D; a 等效于 c &#x3D; c * * a</p>
</blockquote>
<h6 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h6><blockquote>
<p>‘&lt;&gt;’ 不等于 类似于 !&#x3D;</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符：将二进制表示中的每一位取反，0 变为 1，1 变为 0。**~x** 类似于 <strong>-x-1</strong></td>
<td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011 (以补码形式表示)，在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td>
<td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，**&gt;&gt;** 右边的数字指定了移动的位数</td>
<td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<h6 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h6><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">in</td>
<td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<pre><code class="python">a = 10
b = 20
list = [1,2,3,4,5];
if(a in list):
    print(&quot;a 在列表内&quot;)
else:
    print(&quot;a 不在列表内&quot;)
if(b not in list):
    print(&quot;b 不在列表内&quot;)
else:
    print(&quot;b 在列表内&quot;)
--------------------------
a 不在列表内
b 不在列表内
</code></pre>
<h6 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h6><table>
<thead>
<tr>
<th align="left">算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<pre><code class="python">a1 = 20
b1 = 20
if(a1 is b1):
    print(&quot;a1 与 b1 是相同的对象&quot;)
else:
    print(&quot;a1 与 b1 不是相同的对象&quot;)

if(a1 is not b1):
    print(&quot;a1 与 b1 不是相同的对象&quot;)
else:
    print(&quot;a1 与 b1 是相同的对象&quot;)
----------------------------------
a1 与 b1 是相同的对象
a1 与 b1 是相同的对象
</code></pre>
<h6 id="while循环语句-continue-break"><a href="#while循环语句-continue-break" class="headerlink" title="while循环语句 + continue + break"></a>while循环语句 + continue + break</h6><pre><code class="python">count = 0
while(count &lt; 9):
    print(&#39;The count is:&#39;, count)
    count = count + 1
print(&quot;Good bye!&quot;)
--------------------------------
The count is: 0
The count is: 1
The count is: 2
The count is: 3
The count is: 4
The count is: 5
The count is: 6
The count is: 7
The count is: 8
Good bye!
</code></pre>
<pre><code class="python">count = 0
while(count &lt; 9):
    print(&#39;The count is:&#39;, count)
    count = count + 1
    print(&quot;Good bye!&quot;)
---------------------------------
The count is: 0
Good bye!
The count is: 1
Good bye!
The count is: 2
Good bye!
The count is: 3
Good bye!
The count is: 4
Good bye!
The count is: 5
Good bye!
The count is: 6
Good bye!
The count is: 7
Good bye!
The count is: 8
Good bye!
</code></pre>
<hr>
<pre><code class="python"># continue 和 break 用法
 
i = 1
while i &lt; 10:   
    i += 1
    if i%2 &gt; 0:     # 非双数时跳过输出
        continue
    print i         # 输出双数2、4、6、8、10
 
i = 1
while 1:            # 循环条件为1必定成立
    print i         # 输出1~10
    i += 1
    if i &gt; 10:     # 当i大于10时跳出循环
        break
</code></pre>
<h6 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h6><pre><code class="python">for letter in &#39;Python&#39;:
    print(&#39;当前字母 : %s&#39; %letter)

fruits = [&#39;banana&#39;, &#39;apple&#39;,  &#39;mango&#39;]
for fruit in fruits:
    print(&#39;当前水果 :&#39;, fruit)
print(&#39;Good bye!&#39;)
--------------------------------------
当前字母 : P
当前字母 : y
当前字母 : t
当前字母 : h
当前字母 : o
当前字母 : n
当前水果 : banana
当前水果 : apple
当前水果 : mango
Good bye!
</code></pre>
<h6 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h6><p>Python 语言允许在一个循环体里面嵌入另一个循环。</p>
<h6 id="Python-for-循环嵌套语法："><a href="#Python-for-循环嵌套语法：" class="headerlink" title="Python for 循环嵌套语法："></a><strong>Python for 循环嵌套语法：</strong></h6><pre><code class="python">for iterating_var in sequence:
   for iterating_var in sequence:
      statements(s)
   statements(s)
</code></pre>
<h6 id="Python-while-循环嵌套语法："><a href="#Python-while-循环嵌套语法：" class="headerlink" title="Python while 循环嵌套语法："></a><strong>Python while 循环嵌套语法：</strong></h6><pre><code class="python">while expression:
   while expression:
      statement(s)
   statement(s)
</code></pre>
<h6 id="Python-break-用法"><a href="#Python-break-用法" class="headerlink" title="Python break 用法"></a>Python break 用法</h6><pre><code class="python">for letter in &#39;python&#39;:
    if letter == &#39;h&#39;:
        break
    print(&#39;当前字母 :&#39;, letter)
------------------------------
当前字母 : p
当前字母 : y
当前字母 : t
</code></pre>
<h6 id="Python-pass-用法"><a href="#Python-pass-用法" class="headerlink" title="Python pass 用法"></a>Python pass 用法</h6><pre><code class="python">在 Python 中有时候会看到一个 def 函数:

def sample(n_samples):
    pass

该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错
当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行

-----------------------------------

在 Python3.x 的时候 pass 可以写或不写。
python2.x：

def function():
    # 空函数在Python2.x版本中pass是必须的
    pass
python3.x

def function():
    # 在Python3.x的时候pass可以写或不写
    pass
</code></pre>
<h6 id="Python-Number数字"><a href="#Python-Number数字" class="headerlink" title="Python Number数字"></a>Python Number数字</h6><p>Python Number 数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。<br>以下实例在变量赋值时 Number 对象将被创建：</p>
<pre><code class="python">var1 = 1
var2 = 10
</code></pre>
<p>您也可以使用del语句删除一些 Number 对象引用。<br>del语句的语法是：</p>
<pre><code class="python">del var1[,var2[,var3[....,varN]]]]
</code></pre>
<p>您可以通过使用del语句删除单个或多个对象，例如：</p>
<pre><code class="python">del var
del var_a, var_b
</code></pre>
<p>Python 支持四种不同的数值类型：</p>
<ul>
<li><p><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。</p>
</li>
<li><p><strong>长整型(long integers)</strong> - 无限大小的整数，整数最后是一个大写或小写的L。</p>
</li>
<li><p><strong>浮点型(floating point real values)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250）</p>
</li>
<li><p><strong>复数(complex numbers)</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</p>
</li>
</ul>
<h6 id="Python-Number-类型转换"><a href="#Python-Number-类型转换" class="headerlink" title="Python Number 类型转换"></a>Python Number 类型转换</h6><pre><code class="python">int(x [,base ])         将x转换为一个整数  
long(x [,base ])        将x转换为一个长整数  
float(x )               将x转换到一个浮点数  
complex(real [,imag ])  创建一个复数  
str(x )                 将对象 x 转换为字符串  
repr(x )                将对象 x 转换为表达式字符串  
eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象  
tuple(s )               将序列 s 转换为一个元组  
list(s )                将序列 s 转换为一个列表  
chr(x )                 将一个整数转换为一个字符  
unichr(x )              将一个整数转换为Unicode字符  
ord(x )                 将一个字符转换为它的整数值  
hex(x )                 将一个整数转换为一个十六进制字符串  
oct(x )                 将一个整数转换为一个八进制字符串  
</code></pre>
<h6 id="Python-math-模块、cmath-模块"><a href="#Python-math-模块、cmath-模块" class="headerlink" title="Python math 模块、cmath 模块"></a>Python math 模块、cmath 模块</h6><p>Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。<br>Python math 模块提供了许多对浮点数的数学运算函数。<br>Python cmath 模块包含了一些用于复数运算的函数。<br><code>cmath</code> 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数<br><code>math</code> 模块运算的是数学运算。<br>要使用 math 或 cmath 函数必须先导入：</p>
<p>查看 math 查看包中的内容:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; dir(math)
[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan&#39;, &#39;atan2&#39;, &#39;atanh&#39;, &#39;ceil&#39;, &#39;copysign&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;degrees&#39;, &#39;e&#39;, &#39;erf&#39;, &#39;erfc&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;fabs&#39;, &#39;factorial&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;frexp&#39;, &#39;fsum&#39;, &#39;gamma&#39;, &#39;gcd&#39;, &#39;hypot&#39;, &#39;inf&#39;, &#39;isclose&#39;, &#39;isfinite&#39;, &#39;isinf&#39;, &#39;isnan&#39;, &#39;ldexp&#39;, &#39;lgamma&#39;, &#39;log&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log2&#39;, &#39;modf&#39;, &#39;nan&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;radians&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;tan&#39;, &#39;tanh&#39;, &#39;tau&#39;, &#39;trunc&#39;]
&gt;&gt;&gt;
</code></pre>
<p>下文会介绍各个函数的具体应用。</p>
<p>查看 cmath 查看包中的内容</p>
<pre><code>&gt;&gt;&gt; import cmath
&gt;&gt;&gt; dir(cmath)
[&#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;e&#39;, &#39;exp&#39;, &#39;inf&#39;, &#39;infj&#39;, &#39;isclose&#39;, &#39;isfinite&#39;, &#39;isinf&#39;, &#39;isnan&#39;, &#39;log&#39;, &#39;log10&#39;, &#39;nan&#39;, &#39;nanj&#39;, &#39;phase&#39;, &#39;pi&#39;, &#39;polar&#39;, &#39;rect&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;tan&#39;, &#39;tanh&#39;, &#39;tau&#39;]
&gt;&gt;&gt;
</code></pre>
<h6 id="Python数学函数"><a href="#Python数学函数" class="headerlink" title="Python数学函数"></a>Python数学函数</h6><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-abs.html">abs(x)</a></td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-ceil.html">ceil(x)</a></td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-cmp.html">cmp(x, y)</a></td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-exp.html">exp(x)</a></td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-fabs.html">fabs(x)</a></td>
<td align="left">以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-floor.html">floor(x)</a></td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-log.html">log(x)</a></td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-log10.html">log10(x)</a></td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-max.html">max(x1, x2,…)</a></td>
<td align="left">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-min.html">min(x1, x2,…)</a></td>
<td align="left">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-modf.html">modf(x)</a></td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-pow.html">pow(x, y)</a></td>
<td align="left">x**y 运算后的值。</td>
</tr>
<tr>
<td align="left">[round(x <a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-round.html">,n])</a></td>
<td align="left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-sqrt.html">sqrt(x)</a></td>
<td align="left">返回数字x的平方根</td>
</tr>
</tbody></table>
<h6 id="Python随机数函数"><a href="#Python随机数函数" class="headerlink" title="Python随机数函数"></a>Python随机数函数</h6><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-choice.html">choice(seq)</a></td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td align="left">[randrange (<a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-randrange.html">start,] stop [,step])</a></td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-random.html">random()</a></td>
<td align="left">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td align="left"><u>seed([x])</u></td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-shuffle.html">shuffle(lst)</a></td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-uniform.html">uniform(x, y)</a></td>
<td align="left">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody></table>
<h6 id="Python数学常量"><a href="#Python数学常量" class="headerlink" title="Python数学常量"></a>Python数学常量</h6><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody></table>
<h6 id="Python-字符串"><a href="#Python-字符串" class="headerlink" title="Python 字符串"></a>Python 字符串</h6><p>字符串是 Python 中最常用的数据类型。我们可以使用引号 ( <strong>‘</strong> 或 <strong>“</strong> ) 来创建字符串。<br>创建字符串很简单，只要为变量分配一个值即可。例如：</p>
<pre><code class="python">var1 = &#39;Hello World!&#39;
var2 = &quot;Python Runoob&quot;
</code></pre>
<h6 id="Python-字符串格式化符号"><a href="#Python-字符串格式化符号" class="headerlink" title="Python 字符串格式化符号"></a>Python 字符串格式化符号</h6><table>
<thead>
<tr>
<th align="left">符  号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%c</td>
<td align="left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">格式化字符串</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">格式化整数</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">格式化无符号整型</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">格式化无符号八进制数</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">格式化无符号十六进制数</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%E</td>
<td align="left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%g</td>
<td align="left">%f和%e的简写</td>
</tr>
<tr>
<td align="left">%G</td>
<td align="left">%F 和 %E 的简写</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<h6 id="格式化操作符辅助指令"><a href="#格式化操作符辅助指令" class="headerlink" title="格式化操作符辅助指令:"></a>格式化操作符辅助指令:</h6><table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">用做左对齐</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td align="left"><sp></td>
<td align="left">在正数前面显示空格</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td align="left">(var)</td>
<td align="left">映射变量(字典参数)</td>
</tr>
<tr>
<td align="left">m.n.</td>
<td align="left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody></table>
<h6 id="Python-的字符串内建函数"><a href="#Python-的字符串内建函数" class="headerlink" title="Python 的字符串内建函数"></a>Python 的字符串内建函数</h6><p>字符串方法是从 Python1.6 到 2.0 慢慢加进来的 —— 它们也被加到了Jython 中。</p>
<p>这些方法实现了 string 模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对 Unicode 的支持，有一些甚至是专门用于 Unicode 的。</p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-capitalize.html">string.capitalize()</a></td>
<td align="left">把字符串的第一个字符大写</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td>
<td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-count.html">string.count(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td>
<td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td>
<td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td>
<td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg&#x3D;0, end&#x3D;len(string))</a></strong></td>
<td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize&#x3D;8)</a></td>
<td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td>
<td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td>
<td align="left">格式化字符串</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td>
<td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td>
<td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td>
<td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td>
<td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td>
<td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td>
<td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td>
<td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td>
<td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td>
<td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td>
<td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td>
<td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td>
<td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td>
<td align="left">转换 string 中所有大写字符为小写.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td>
<td align="left">截掉 string 左边的空格</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab)</a></td>
<td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td>
<td align="left">返回字符串 <em>str</em> 中最大的字母。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td>
<td align="left">返回字符串 <em>str</em> 中最小的字母。</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td>
<td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str &#x3D;&#x3D; string.</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num&#x3D;string.count(str1))</a></strong></td>
<td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg&#x3D;0,end&#x3D;len(string) )</a></td>
<td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg&#x3D;0,end&#x3D;len(string))</a></td>
<td align="left">类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td>
<td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td>
<td align="left">类似于 partition()函数,不过是从右边开始查找</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td>
<td align="left">删除 string 字符串末尾的空格.</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-split.html">string.split(str&#x3D;””, num&#x3D;string.count(str))</a></strong></td>
<td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 <strong>num+1</strong> 个子字符串</td>
</tr>
<tr>
<td align="left">[string.splitlines(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-splitlines.html">keepends])</a></td>
<td align="left">按照行(‘\r’, ‘\r\n’, ‘\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg&#x3D;0,end&#x3D;len(string))</a></td>
<td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td>
</tr>
<tr>
<td align="left"><strong>[string.strip(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-strip.html">obj])</a></strong></td>
<td align="left">在 string 上执行 lstrip()和 rstrip()</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-swapcase.html">string.swapcase()</a></td>
<td align="left">翻转 string 中的大小写</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-title.html">string.title()</a></td>
<td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>
</tr>
<tr>
<td align="left"><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del&#x3D;””)</a></strong></td>
<td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td>
<td align="left">转换 string 中的小写字母为大写</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-zfill.html">string.zfill(width)</a></td>
<td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td>
</tr>
</tbody></table>
<h6 id="访问列表中的值-amp-amp-追加列表【append】-amp-amp-删除列表元素【del】"><a href="#访问列表中的值-amp-amp-追加列表【append】-amp-amp-删除列表元素【del】" class="headerlink" title="访问列表中的值 &amp;&amp; 追加列表【append】&amp;&amp; 删除列表元素【del】"></a>访问列表中的值 &amp;&amp; 追加列表【append】&amp;&amp; 删除列表元素【del】</h6><pre><code class="python">print(&quot;----------------&quot;)
list1 = [&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000]
print(list1)
print(list1[0])
list1.append(&#39;Google&#39;)
print(list1)

del list1[4] #删除了Google
print(list1)
-------------------------------
[&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000]
physics
[&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000, &#39;Google&#39;]
[&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000]  #删除了Google
</code></pre>
<h6 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h6><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print x,</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<h6 id="记得负号是倒数的噢"><a href="#记得负号是倒数的噢" class="headerlink" title="记得负号是倒数的噢"></a>记得负号是倒数的噢</h6><pre><code class="python">&gt;&gt;&gt;L = [&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;]
&gt;&gt;&gt; L[2]
&#39;Taobao&#39;
&gt;&gt;&gt; L[-2]
&#39;Runoob&#39;
&gt;&gt;&gt; L[1:]
[&#39;Runoob&#39;, &#39;Taobao&#39;]
&gt;&gt;&gt;
</code></pre>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取列表中第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">读取列表中倒数第二个元素</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">从第二个元素开始截取列表</td>
</tr>
</tbody></table>
<h6 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h6><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-cmp.html">cmp(list1, list2)</a> 比较两个列表的元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[list.pop(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-pop.html">index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-sort.html">list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
</tbody></table>
<h6 id="Python日期和时间"><a href="#Python日期和时间" class="headerlink" title="Python日期和时间"></a>Python日期和时间</h6><p>Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。<br>Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。<br>时间间隔是以秒为单位的浮点小数。<br>每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。<br>Python 的 time 模块下有很多函数可以转换常见日期格式。<br>如函数<code>time.time()</code>用于获取当前时间戳, 如下实例:</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import time  # 引入time模块
 
ticks = time.time()
print &quot;当前时间戳为:&quot;, ticks
--------------------------
当前时间戳为: 1459994552.51
</code></pre>
<h6 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h6><p><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-time-time.html"> time.time( )</a> 返回当前时间的时间戳（1970纪元后经过的浮点秒数）<br><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-time-sleep.html"> time.sleep(secs)</a> 推迟调用线程的运行，secs指秒数。<br>time.localtime([<a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-time-localtime.html">secs])</a> 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</p>
<pre><code class="python">import  calendar
cal = calendar.month(2025, 2)
print(&quot;以下输出是 2025 年 2 月的日历:&quot;)
print(cal)
------------------------------------
以下输出是 2025 年 2 月的日历:
   February 2025
Mo Tu We Th Fr Sa Su
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28
</code></pre>
<h6 id="Python函数"><a href="#Python函数" class="headerlink" title="Python函数"></a>Python函数</h6><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li>
<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ul>
<pre><code class="python">def functionname( parameters ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre>
<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<pre><code class="python">def readme(str):
    print(str)
    return
readme(&quot;Hello World!&quot;)
readme(&quot;Runoob&quot;)
----------------
Hello World!
Runoob
</code></pre>
<h6 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h6><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<pre><code class="python">def functionname([formal_args,] *var_args_tuple ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre>
<p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print &quot;输出: &quot;
   print arg1
   for var in vartuple:
      print var
   return
 
# 调用printinfo 函数
printinfo( 10 )
printinfo( 70, 60, 50 )
------------------------------
输出:
10
输出:
70
60
50
</code></pre>
<h6 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h6><p>python 使用 <strong><u>lambda</u></strong> 来创建匿名函数。</p>
<ul>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<p>lambda函数的语法只包含一个语句，如下：</p>
<blockquote>
<pre><code class="python">lambda [arg1 [,arg2,.....argn]]:expressio
</code></pre>
</blockquote>
<p><strong>实例如下：</strong></p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2
 
# 调用sum函数
print &quot;相加后的值为 : &quot;, sum( 10, 20 )
print &quot;相加后的值为 : &quot;, sum( 20, 20 )
---------------------------------------
相加后的值为 :  30
相加后的值为 :  40
</code></pre>
<blockquote>
<p>Python 中的 <code>lambda</code> 表达式是一种匿名函数，即没有名字的函数。<code>lambda</code> 表达式通常用于需要短小精悍函数的场景，比如排序时的键函数，或者作为高阶函数的参数。</p>
<p><code>lambda</code> 表达式的语法如下：</p>
<pre><code>lambda arguments: expression
</code></pre>
<p>这里的关键点如下：</p>
<ul>
<li><code>lambda</code> 是一个关键字，用于定义匿名函数。</li>
<li><code>arguments</code> 是函数的参数，可以有多个，用逗号分隔。</li>
<li><code>expression</code> 是一个表达式，其结果将作为函数的返回值。</li>
</ul>
<p>以下是一些 <code>lambda</code> 表达式的使用示例：</p>
<h3 id="示例-1：定义一个简单的加法函数"><a href="#示例-1：定义一个简单的加法函数" class="headerlink" title="示例 1：定义一个简单的加法函数"></a>示例 1：定义一个简单的加法函数</h3><pre><code>add = lambda x, y: x + y
print(add(5, 3))  # 输出 8
</code></pre>
<h3 id="示例-2：列表排序"><a href="#示例-2：列表排序" class="headerlink" title="示例 2：列表排序"></a>示例 2：列表排序</h3><p>使用 <code>lambda</code> 表达式来按照列表中元素的某个属性进行排序：</p>
<pre><code># 假设有一个包含字典的列表
list_of_dicts = [&#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 25&#125;, &#123;&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 20&#125;, &#123;&#39;name&#39;: &#39;Charlie&#39;, &#39;age&#39;: 30&#125;]

# 按照年龄排序
sorted_list = sorted(list_of_dicts, key=lambda x: x[&#39;age&#39;])
print(sorted_list)  # 输出 [&#123;&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 20&#125;, &#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 25&#125;, &#123;&#39;name&#39;: &#39;Charlie&#39;, &#39;age&#39;: 30&#125;]
</code></pre>
<h3 id="示例-3：高阶函数中的使用"><a href="#示例-3：高阶函数中的使用" class="headerlink" title="示例 3：高阶函数中的使用"></a>示例 3：高阶函数中的使用</h3><p><code>lambda</code> 表达式常用于 <code>map</code>, <code>filter</code>, <code>reduce</code> 等高阶函数：</p>
<pre><code># 使用 map 函数将列表中的每个元素乘以2
numbers = [1, 2, 3, 4, 5]
doubled = map(lambda x: x * 2, numbers)
print(list(doubled))  # 输出 [2, 4, 6, 8, 10]

# 使用 filter 函数过滤出列表中的偶数
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # 输出 [2, 4]
</code></pre>
<p>需要注意的是，虽然 <code>lambda</code> 表达式非常方便，但它们通常只用于简单的函数。如果函数逻辑较为复杂，最好还是使用常规的 <code>def</code> 语句来定义函数，这样可以提高代码的可读性和可维护性。</p>
</blockquote>
<h6 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h6><p>return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 可写函数说明
def sum( arg1, arg2 ):
   # 返回2个参数的和.&quot;
   total = arg1 + arg2
   print &quot;函数内 : &quot;, total
   return total
 
# 调用sum函数
total = sum( 10, 20 )
</code></pre>
<h6 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h6><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
total = 0 # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
   #返回2个参数的和.&quot;
   total = arg1 + arg2 # total在这里是局部变量.
   print &quot;函数内是局部变量 : &quot;, total
   return total
 
#调用sum函数
sum( 10, 20 )
print &quot;函数外是全局变量 : &quot;, total
------------------------------------------
函数内是局部变量 :  30
函数外是全局变量 :  0
</code></pre>
<h6 id="from…import-语句"><a href="#from…import-语句" class="headerlink" title="from…import 语句"></a>from…import 语句</h6><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre>
<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<pre><code>from fib import fibonacci
</code></pre>
<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h6 id="from…import-语句-1"><a href="#from…import-语句-1" class="headerlink" title="from…import* 语句"></a>from…import* 语句</h6><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<pre><code>from modname import *
</code></pre>
<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<p>例如我们想一次性引入 math 模块中所有的东西，语句如下：</p>
<pre><code>from math import *
</code></pre>
<h6 id="globals-和-locals-函数"><a href="#globals-和-locals-函数" class="headerlink" title="globals() 和 locals() 函数"></a>globals() 和 locals() 函数</h6><p>根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。</p>
<p>如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。</p>
<p>如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。</p>
<p>两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。</p>
<hr>
<h6 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h6><p>Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下：</p>
<ul>
<li>raw_input</li>
<li>input</li>
</ul>
<p><strong>input函数</strong></p>
<p><code>input([prompt])</code> 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）</p>
<pre><code class="python">请输入：23
你输入的内容是:  23
</code></pre>
<h6 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h6><p>您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。<br>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 <strong>file</strong> 对象做大部分的文件操作</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h3><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p>
<p>语法：</p>
<pre><code>file object = open(file_name [, access_mode][, buffering])
</code></pre>
<p>各个参数的细节如下：</p>
<ul>
<li>file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
<li>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">t</td>
<td align="left">文本模式 (默认)。</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">二进制模式。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">通用换行模式（不推荐）。</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td align="left">rb</td>
<td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">rb+</td>
<td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb</td>
<td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb+</td>
<td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td align="left">ab+</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">r</th>
<th align="center">r+</th>
<th align="center">w</th>
<th align="center">w+</th>
<th align="center">a</th>
<th align="center">a+</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center">+</td>
<td align="center"></td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">写</td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">覆盖</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">指针在开始</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">指针在结尾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody></table>
<h6 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h6><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p>
<p>以下是和file对象相关的所有属性的列表：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file.closed</td>
<td align="left">返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td align="left">file.mode</td>
<td align="left">返回被打开文件的访问模式。</td>
</tr>
<tr>
<td align="left">file.name</td>
<td align="left">返回文件的名称。</td>
</tr>
<tr>
<td align="left">file.softspace</td>
<td align="left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody></table>
<p>以上实例输出结果：</p>
<pre><code>文件名:  foo.txt
是否已关闭 :  False
访问模式 :  w
末尾是否强制加空格 :  0
</code></pre>
<h6 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h6><p>File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。</p>
<p>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。</p>
<p>语法：</p>
<pre><code>fileObject.close()
</code></pre>
<p>例子：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open(&quot;foo.txt&quot;, &quot;w&quot;)
print &quot;文件名: &quot;, fo.name
 
# 关闭打开的文件
fo.close()
</code></pre>
<p>以上实例输出结果：</p>
<pre><code>文件名:  foo.txt
</code></pre>
<h6 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h6><p>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p>write()方法不会在字符串的结尾添加换行符(‘\n’)：</p>
<p>语法：</p>
<pre><code>fileObject.write(string)
</code></pre>
<p>在这里，被传递的参数是要写入到已打开文件的内容。</p>
<p>例子：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open(&quot;foo.txt&quot;, &quot;w&quot;)
fo.write( &quot;www.runoob.com!\nVery good site!\n&quot;)
 
# 关闭打开的文件
fo.close()
</code></pre>
<h6 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h6><p>read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p>
<p>语法：</p>
<pre><code>fileObject.read([count])
</code></pre>
<p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p>
<p>例子：</p>
<p>这里我们用到以上创建的 foo.txt 文件。</p>
<p>实例：</p>
<pre><code class="python">\#!/usr/bin/python
\# -*- coding: UTF-8 -*-

\# 打开一个文件
fo = open(&quot;foo.txt&quot;, &quot;r+&quot;)
str = fo.read(10)
**print** &quot;读取的字符串是 : &quot;, str
\# 关闭打开的文件
fo.close()
---------------------
读取的字符串是 :  www.runoob
</code></pre>
<h6 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h6><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。<br>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p>
<h6 id="rename-方法"><a href="#rename-方法" class="headerlink" title="rename() 方法"></a>rename() 方法</h6><p>rename() 方法需要两个参数，当前的文件名和新文件名。</p>
<p>语法：</p>
<pre><code>os.rename(current_file_name, new_file_name)
</code></pre>
<p>例子：</p>
<p>下例将重命名一个已经存在的文件test1.txt。</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 重命名文件test1.txt到test2.txt。
os.rename( &quot;test1.txt&quot;, &quot;test2.txt&quot; )
</code></pre>
<h6 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h6><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。</p>
<p>语法：</p>
<pre><code class="python">os.remove(file_name)
</code></pre>
<p>例子：</p>
<p>下例将删除一个已经存在的文件test2.txt。</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 删除一个已经存在的文件test2.txt
os.remove(&quot;test2.txt&quot;)
</code></pre>
<h6 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h6><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p>
<p>语法：</p>
<pre><code>os.mkdir(&quot;newdir&quot;)
</code></pre>
<p>例子：</p>
<p>下例将在当前目录下创建一个新目录test。</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 创建目录test
os.mkdir(&quot;test&quot;)
</code></pre>
<h6 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h6><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。</p>
<p>语法：</p>
<pre><code>os.chdir(&quot;newdir&quot;)
</code></pre>
<p>例子：</p>
<p>下例将进入”&#x2F;home&#x2F;newdir”目录。</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 将当前目录改为&quot;/home/newdir&quot;
os.chdir(&quot;/home/newdir&quot;)
</code></pre>
<h6 id="getcwd-方法"><a href="#getcwd-方法" class="headerlink" title="getcwd() 方法"></a>getcwd() 方法</h6><p>getcwd()方法显示当前的工作目录。</p>
<p>语法：</p>
<pre><code>os.getcwd()
</code></pre>
<p>例子：</p>
<p>下例给出当前目录：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 给出当前的目录
print os.getcwd()
</code></pre>
<h6 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h6><p>rmdir()方法删除目录，目录名称以参数传递。</p>
<p>在删除这个目录之前，它的所有内容应该先被清除。</p>
<p>语法：</p>
<pre><code>os.rmdir(&#39;dirname&#39;)
</code></pre>
<p>例子：</p>
<p>以下是删除” &#x2F;tmp&#x2F;test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import os
 
# 删除”/tmp/test”目录
os.rmdir( &quot;/tmp/test&quot;  )
</code></pre>
<h5 id="Python-File-文件-方法"><a href="#Python-File-文件-方法" class="headerlink" title="Python File(文件) 方法"></a>Python File(文件) 方法</h5><h6 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h6><p>Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p>
<p><strong>注意：</strong>使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。</p>
<p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p>
<pre><code>open(file, mode=&#39;r&#39;)
</code></pre>
<p>完整的语法格式为：</p>
<pre><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
</code></pre>
<p>参数说明:</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li>
</ul>
<h6 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h6><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-next.html">file.next()</a>返回文件下一行。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[file.read(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">[file.readline(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">[file.readlines(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">[file.seek(offset<a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-seek.html">, whence])</a>设置文件当前位置</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-tell.html">file.tell()</a>返回文件当前位置。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">[file.truncate(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-truncate.html">size])</a>截取文件，截取的字节通过size指定，默认为当前文件位置。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody></table>
<h6 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h6><p>捕捉异常可以使用try&#x2F;except语句。</p>
<p>try&#x2F;except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。</p>
<p>如果你不想在异常发生时结束你的程序，只需在try里捕获它。</p>
<p>语法：</p>
<p>以下为简单的<em>try….except…else</em>的语法：</p>
<pre><code class="python">try:
&lt;语句&gt;        #运行别的代码
except &lt;名字&gt;：
&lt;语句&gt;        #如果在try部份引发了&#39;name&#39;异常
except &lt;名字&gt;，&lt;数据&gt;:
&lt;语句&gt;        #如果引发了&#39;name&#39;异常，获得附加的数据
else:
&lt;语句&gt;        #如果没有异常发生
</code></pre>
<p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p>
<ul>
<li>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li>
<li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</li>
<li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li>
</ul>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open(&quot;testfile&quot;, &quot;w&quot;)
    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)
except IOError:
    print &quot;Error: 没有找到文件或读取文件失败&quot;
else:
    print &quot;内容写入文件成功&quot;
    fh.close()
</code></pre>
<h6 id="使用except而不带任何异常类型"><a href="#使用except而不带任何异常类型" class="headerlink" title="使用except而不带任何异常类型"></a>使用except而不带任何异常类型</h6><pre><code class="python">try:
   # 正常的操作
   ......................
except:
   # 发生异常，执行这块代码
   ......................
else:
   # 如果没有异常执行这块代码
</code></pre>
<p>以上方式<code>try-except</code>语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</p>
<h6 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h6><p>你也可以使用相同的except语句来处理多个异常信息，如下所示：</p>
<pre><code class="python">try:
   # 正常的操作
   ......................
except(Exception1[, Exception2[,...ExceptionN]]):
   # 发生以上多个异常中的一个，执行这块代码
   ......................
else:
   # 如果没有异常执行这块代码
</code></pre>
<h6 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h6><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p>
<pre><code class="python">try:
&lt;语句&gt;
finally:
&lt;语句&gt;    #退出try时总会执行
raise

---------------------------
try:
    fh = open(&quot;testfile&quot;, &quot;w&quot;)
    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)
finally:
    print &quot;Error: 没有找到文件或读取文件失败&quot;
</code></pre>
<p>同样的例子也可以写成如下方式</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open(&quot;testfile&quot;, &quot;w&quot;)
    try:
        fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)
    finally:
        print &quot;关闭文件&quot;
        fh.close()
except IOError:
    print &quot;Error: 没有找到文件或读取文件失败&quot;
</code></pre>
<p>当在try块中抛出一个异常，立即执行finally块代码。finally块中的所有语句执行后，异常被再次触发，并执行except块代码。参数的内容不同于异常。</p>
<h6 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a><strong>触发异常</strong></h6><p>实例</p>
<p>一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。</p>
<p>定义一个异常非常简单，如下所示：</p>
<p>实例</p>
<pre><code class="python">def functionName( level ):
  if level &lt; 1:
    raise Exception(&quot;Invalid level!&quot;, level)
    \# 触发异常后，后面的代码就不会再执行
</code></pre>
<p>为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。例如我们捕获以上异常，”except”语句如下所示：</p>
<pre><code class="python"># 触发异常后，后面的代码就不会再执行  触发异常后，后面的代码就不会再执行
try:
    正常逻辑
except Exception,err:
    触发自定义异常    
else:
    其余代码

----------------------
#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 定义函数
def mye( level ):
    if level &lt; 1:
        raise Exception,&quot;Invalid level!&quot;
        # 触发异常后，后面的代码就不会再执行
try:
    mye(0)            # 触发异常
except Exception,err:
    print 1,err
else:
    print 2
----------------------
$ python test.py 
1 Invalid level!
</code></pre>
<h6 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h6><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。</p>
<pre><code class="python">class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg
</code></pre>
<p>在你定义以上类后，你可以触发该异常，如下所示：</p>
<pre><code class="python">try:
    raise Networkerror(&quot;Bad hostname&quot;)
except Networkerror,e:
    print e.args
</code></pre>
<h6 id="Python-OS-文件-x2F-目录方法"><a href="#Python-OS-文件-x2F-目录方法" class="headerlink" title="Python OS 文件&#x2F;目录方法"></a>Python OS 文件&#x2F;目录方法</h6><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-access.html">os.access(path, mode)</a> 检验权限模式</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-chmod.html">os.chmod(path, mode)</a> 更改权限</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">[os.fdopen(fd<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-getcwdu.html">os.getcwdu()</a> 返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">[os.makedirs(path<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left">[os.mkdir(path<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left">[os.mkfifo(path<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left">[os.mknod(filename<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-mknod.html">, mode&#x3D;0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left">[os.open(file, flags<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left">[os.popen(command<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td align="left">49</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td align="left">50</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td align="left">51</td>
<td align="left">[os.stat_float_times(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td align="left">52</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td align="left">53</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td>
</tr>
<tr>
<td align="left">54</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td align="left">55</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td align="left">56</td>
<td align="left">[os.tempnam(<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-tempnam.html">dir[, prefix]])</a> 返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td align="left">57</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-tmpfile.html">os.tmpfile()</a> 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td align="left">58</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-tmpnam.html">os.tmpnam()</a> 为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td align="left">59</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td align="left">60</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-unlink.html">os.unlink(path)</a> 删除文件</td>
</tr>
<tr>
<td align="left">61</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td align="left">62</td>
<td align="left">[os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])](<a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-walk.html">https://www.runoob.com/python/os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
<tr>
<td align="left">64</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-os-path.html">os.path 模块</a> 获取文件的属性信息。</td>
</tr>
</tbody></table>
<h6 id="Python-内置函数"><a href="#Python-内置函数" class="headerlink" title="Python 内置函数"></a>Python 内置函数</h6><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left">内置函数</th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-abs.html">abs()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-divmod.html">divmod()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-input.html">input()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-open.html">open()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-staticmethod.html">staticmethod()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-all.html">all()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-enumerate.html">enumerate()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-int.html">int()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-ord.html">ord()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-str.html">str()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-any.html">any()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-eval.html">eval()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-isinstance.html">isinstance()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-pow.html">pow()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-sum.html">sum()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-basestring.html">basestring()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-execfile.html">execfile()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-issubclass.html">issubclass()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-print.html">print()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-super.html">super()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-bin.html">bin()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-file.html">file()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-iter.html">iter()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-property.html">property()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-tuple-tuple.html">tuple()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-bool.html">bool()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-filter.html">filter()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-len.html">len()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-range.html">range()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-type.html">type()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-bytearray.html">bytearray()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-float.html">float()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-list.html">list()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-raw_input.html">raw_input()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-unichr.html">unichr()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-callable.html">callable()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-format.html">format()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-locals.html">locals()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-reduce.html">reduce()</a></td>
<td align="left">unicode()</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-chr.html">chr()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-frozenset.html">frozenset()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-long.html">long()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-reload.html">reload()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-vars.html">vars()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-classmethod.html">classmethod()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-getattr.html">getattr()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-map.html">map()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-repr.html">repr()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-xrange.html">xrange()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-cmp.html">cmp()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-globals.html">globals()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-max.html">max()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-reverse.html">reverse()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-zip.html">zip()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-compile.html">compile()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-hasattr.html">hasattr()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-memoryview.html">memoryview()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-round.html">round()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-__import__.html"><strong>import</strong>()</a></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-complex.html">complex()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-hash.html">hash()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/func-number-min.html">min()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-set.html">set()</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-delattr.html">delattr()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-help.html">help()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-next.html">next()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-setattr.html">setattr()</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-dict.html">dict()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-hex.html">hex()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python-func-object.html">object()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-slice.html">slice()</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-dir.html">dir()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-id.html">id()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-oct.html">oct()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-sorted.html">sorted()</a></td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-func-exec.html">exec 内置表达式</a></td>
</tr>
</tbody></table>
<hr>
<hr>
<hr>
<h1 id="Python高级"><a href="#Python高级" class="headerlink" title="Python高级"></a><span style = "color:red">Python高级</span></h1><h6 id="创建类-面向对象"><a href="#创建类-面向对象" class="headerlink" title="创建类 [面向对象]"></a>创建类 [面向对象]</h6><pre><code class="python">class Employee:
    &#39;所有员工的基本类型&#39;
    empCount = 0

    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount += 1

    def displayCount(self):
        print (&quot;Total Employee %d&quot; % Employee.empCount)
    def displayEmployee(self):
        print (&quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary)

------------------------------------------
class Employee:  
    # 定义一个名为 Employee 的新类
    &#39;所有员工的基本类型&#39;  
    # 类的文档字符串，描述类的用途

    empCount = 0  
    # 类变量，用于跟踪类实例的数量

    def __init__(self, name, salary):  
        # 类的构造函数，用于创建类的新实例
        self.name = name  
        # 将参数 name 的值赋给实例变量 name
        self.salary = salary 
        # 将参数 salary 的值赋给实例变量 salary
        Employee.empCount += 1  
        # 每创建一个实例，类变量 empCount 的值就增加 1

    def displayCount(self):  
        # 类的方法，用于显示当前员工数量
        print(&quot;Total Employee %d&quot; % Employee.empCount)              # 打印员工总数

    def displayEmployee(self):  
        # 类的方法，用于显示员工信息
        print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary)  
        # 打印员工的姓名和薪水
</code></pre>
<ul>
<li>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</li>
<li>第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</li>
<li>self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</li>
</ul>
<h6 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h6><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。以下使用类的名称 Employee 来实例化，并通过 <strong>init</strong> 方法接收参数</p>
<pre><code class="python"># 其余的都在上面的代码中
emp1 = Employee(&quot;Zara&quot;, 2000)
emp2 = Employee(&quot;Manni&quot;, 5000)
</code></pre>
<h6 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h6><p>您可以使用点号 <strong>.</strong> 来访问对象的属性。使用如下类的名称访问类变量:</p>
<pre><code class="python">emp1.displayEmployee()
emp2.displayEmployee()
print &quot;Total Employee %d&quot; % Employee.empCount
----------------------------------
Name :  Zara , Salary:  2000
Name :  Manni , Salary:  5000
Total Employee：2
</code></pre>
<p>你可以添加，删除，修改类的属性，如下所示：</p>
<pre><code class="python">emp1.age = 7  # 添加一个 &#39;age&#39; 属性
emp1.age = 8  # 修改 &#39;age&#39; 属性
del emp1.age  # 删除 &#39;age&#39; 属性
</code></pre>
<p>你也可以使用以下函数的方式来访问属性：</p>
<ul>
<li><strong>getattr</strong>(obj, name[, default]) : 访问对象的属性。</li>
<li><strong>hasattr</strong>(obj,name) : 检查是否存在一个属性。</li>
<li><strong>setattr</strong>(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</li>
<li><strong>delattr</strong>(obj, name) : 删除属性。</li>
</ul>
<blockquote>
<p>hasattr(emp1, ‘age’)        # 如果存在 ‘age’ 属性返回 True。<br>getattr(emp1, ‘age’)         # 返回 ‘age’ 属性的值<br>setattr(emp1, ‘age’, 8)     # 添加属性 ‘age’ 值为 8<br>delattr(emp1, ‘age’)         # 删除属性 ‘age’</p>
</blockquote>
<pre><code class="python">emp1.displayEmployee()
emp2.displayEmployee()
emp1.age = 7 # 添加一个 &#39;age&#39; 属性
print(&quot;姓名：%s&quot; %emp1.name, &quot;年龄：%d&quot; %emp1.age)
print (&quot;总计：%d&quot; %Employee.empCount)
-----------------------------------
Name :  Zara , Salary:  2000
Name :  Manni , Salary:  5000
姓名：Zara 年龄：7
总计：2
</code></pre>
<h6 id="python对象销毁-垃圾回收"><a href="#python对象销毁-垃圾回收" class="headerlink" title="python对象销毁(垃圾回收)"></a>python对象销毁(垃圾回收)</h6><p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。在 Python 内部记录着所有使用中的对象各有多少引用。一个内部跟踪变量，称为一个引用计数器。当对象被创建时,就创建了一个引用计数,当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是”立即”的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p>
<pre><code class="python">a = 40      # 创建对象  &lt;40&gt;
b = a       # 增加引用， &lt;40&gt; 的计数
c = [b]     # 增加引用.  &lt;40&gt; 的计数

del a       # 减少引用 &lt;40&gt; 的计数
b = 100     # 减少引用 &lt;40&gt; 的计数
c[0] = -1   # 减少引用 &lt;40&gt; 的计数
</code></pre>
<p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p>
<h6 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h6><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p>
<p><strong>继承语法</strong></p>
<pre><code class="python">class 派生类名(基类名)
    ...
</code></pre>
<p>在python中继承中的一些特点：</p>
<ul>
<li>1、如果在子类中需要父类的构造方法就需要显式的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-extends-init.html"> python 子类继承父类构造函数说明</a>。</li>
<li>2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数</li>
<li>3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</li>
</ul>
<p>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。</p>
<p><strong>语法：</strong></p>
<p>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后<br>如下所示：</p>
<pre><code class="python">class SubClassName (ParentClass1[, ParentClass2, ...]):
    ...
</code></pre>
<h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法：</p>
<pre><code class="python">class Parent:
    def myMethod(self):
        print (&#39;调用父类方法&#39;)
class Child(Parent):
    def myMethod(self):
        print (&#39;调用子类方法&#39;)
c = Child()
c.myMethod()
</code></pre>
<h6 id="类属性与方法"><a href="#类属性与方法" class="headerlink" title="类属性与方法"></a>类属性与方法</h6><p><strong>类的私有属性</strong></p>
<p>“_ _” → <code>__private_attrs</code> 两个下划线开头，声明属性为私有，不能在外部被使用或直接访问。在类内部的方法中使用时 <code>self.__private_attrs</code></p>
<p><strong>类的方法</strong></p>
<p>在类的内部，使用<code>def</code>关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数</p>
<p><strong>类的私有方法</strong></p>
<p><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。<br>在类的内部调用<code>self.__private_methods</code></p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
 
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print self.__secretCount
 
counter = JustCounter()
counter.count()
counter.count()
print counter.publicCount
print counter.__secretCount  # 报错，实例不能访问私有变量
----------------------------------------------------
1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 17, in &lt;module&gt;
    print counter.__secretCount  # 报错，实例不能访问私有变量
AttributeError: JustCounter instance has no attribute &#39;__secretCount&#39;
</code></pre>
<p>Python不允许实例化的类访问私有数据，但你可以使用 <strong>object._className__attrName</strong>（ <strong>对象名._类名__私有属性名</strong> ）访问属性，参考以下实例：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Runoob:
    __site = &quot;www.runoob.com&quot;

runoob = Runoob()
print runoob._Runoob__site
</code></pre>
<p>执行以上代码，执行结果如下：</p>
<pre><code class="python">www.runoob.com
</code></pre>
<h6 id="下划线、双下划线、头尾双下划线说明："><a href="#下划线、双下划线、头尾双下划线说明：" class="headerlink" title="下划线、双下划线、头尾双下划线说明："></a>下划线、双下划线、头尾双下划线说明：</h6><ul>
<li><strong>_ _ foo _ _</strong>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong><strong>init</strong>()</strong> 之类的。</li>
<li><strong>_ foo</strong>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li>
<li><strong>_ _ foo</strong>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li>
</ul>
<h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><h6 id="re-match-与-re-search-的区别"><a href="#re-match-与-re-search-的区别" class="headerlink" title="re.match() 与 re.search()的区别"></a>re.match() 与 re.search()的区别</h6><p>在 Python 的正则表达式模块 <code>re</code> 中，<code>re.match()</code> 和 <code>re.search()</code> 都用于在字符串中查找正则表达式的匹配项，但它们在查找匹配项的方式上有所不同。</p>
<p><strong>re.match()</strong> 只在字符串的开始处进行匹配。如果字符串的开头与正则表达式不匹配，<code>re.match()</code>将返回None</p>
<pre><code class="python">import re
# 使用 re.search()
string = &quot;hello world&quot;
pattern = &quot;hello&quot;
match = re.match(pattern, string)
if match:
    print(f&quot;匹配成功: &#123;match.group()&#125;&quot;)
else:
    print(&quot;匹配失败&quot;)
----------------------
匹配成功: hello
</code></pre>
<p><strong>re.search()</strong> 会扫描整个字符串，直到找到第一个匹配正则表达式的子串。它在整个字符串中查找匹配项，而不仅仅是在字符串的开始处。</p>
<pre><code class="python">import re
# 使用 re.search()
string = &quot;world hello&quot;
pattern = &quot;hello&quot;

search = re.search(pattern, string)

if search:
    print(f&quot;Match found: &#123;search.group()&#125;&quot;)
else:
    print(&quot;No match found.&quot;)
-------------------------------
Match found: hello
</code></pre>
<h6 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h6><p>Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。</p>
<pre><code class="python">re.sub(pattern, repl, string, count=0, flags=0)
</code></pre>
<p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
</ul>
<blockquote>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><pre><code class="python">import re

phone = &quot;2004-959-559 # 这是一个国外电话号码&quot;

# 删除字符串中的 Python注释 
num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone)
print(&quot;电话号码是: &quot;, num)

# 删除非数字(-)的字符串 
num = re.sub(r&#39;\D&#39;, &quot;&quot;, phone)
print(&quot;电话号码是 : &quot;, num)
</code></pre>
<h4 id="第一部分：删除字符串中的注释"><a href="#第一部分：删除字符串中的注释" class="headerlink" title="第一部分：删除字符串中的注释"></a>第一部分：删除字符串中的注释</h4><pre><code class="python">num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone)
</code></pre>
<ul>
<li><p><code>re.sub()</code> 是 re 模块中的函数，用于替换字符串中的匹配项。</p>
</li>
<li><pre><code class="python">r&#39;#.*$&#39;
</code></pre>
<p>是正则表达式模式：</p>
<ul>
<li><code>#</code> 表示匹配字符 <code>#</code>。</li>
<li><code>.*</code> 表示匹配任意字符（<code>.</code>）任意次数（<code>*</code>）。</li>
<li><code>$</code> 表示匹配字符串的末尾。</li>
</ul>
</li>
<li><p><code>&quot;&quot;</code> 是替换字符串，这里是一个空字符串，表示匹配到的部分将被删除。</p>
</li>
<li><p><code>phone</code> 是要被处理的原始字符串。</p>
</li>
</ul>
<p>这个正则表达式 <code>r&#39;#.*$&#39;</code> 的意思是：从 <code>#</code> 字符开始，匹配直到字符串末尾的所有字符。因此，该行代码将删除字符串 <code>phone</code> 中从 <code>#</code> 开始到字符串末尾的所有内容。</p>
<p>执行结果：</p>
<p>复制</p>
<pre><code class="python">电话号码是:  2004-959-559 
</code></pre>
<h4 id="第二部分：删除非数字字符"><a href="#第二部分：删除非数字字符" class="headerlink" title="第二部分：删除非数字字符"></a>第二部分：删除非数字字符</h4><pre><code class="python">num = re.sub(r&#39;\D&#39;, &quot;&quot;, phone)
</code></pre>
<ul>
<li><p><code>re.sub()</code> 同上，用于替换字符串中的匹配项。</p>
</li>
<li><pre><code class="python">r&#39;\D&#39;
</code></pre>
<p>是正则表达式模式：</p>
<ul>
<li><code>\D</code> 表示匹配任意非数字字符。</li>
</ul>
</li>
<li><p><code>&quot;&quot;</code> 同上，是一个空字符串，表示匹配到的非数字字符将被删除。</p>
</li>
<li><p><code>phone</code> 同上，是要被处理的原始字符串。</p>
</li>
</ul>
<p>这个正则表达式 <code>r&#39;\D&#39;</code> 的意思是：匹配字符串中所有的非数字字符。因此，该行代码将删除字符串 <code>phone</code> 中所有非数字字符。</p>
<pre><code class="python">电话号码是 :  2004959559 
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这段代码展示了如何使用 <code>re.sub()</code> 函数结合正则表达式来清理和格式化字符串。第一个例子中，我们移除了字符串末尾的注释。第二个例子中，我们移除了电话号码中的所有非数字字符，从而得到一个仅包含数字的字符串。这些操作在数据清洗和预处理中非常有用。</p>
</blockquote>
<pre><code class="python">import re
string = &quot;hello world&quot;
pattern = &quot;hello&quot;
match = re.match(pattern, string)
if match:
    print(f&quot;匹配成功: &#123;match.group()&#125;&quot;)
else:
    print(&quot;匹配失败&quot;)
print(&#39;-----------------&#39;)
import re
phone = &quot;2004-959-559 # 这是一个国外电话号码&quot;
num = re.sub(&quot;#.*$&quot;,&quot;&quot;,phone)
print(&quot;电话号码是: &quot;, num)
num2 = re.sub(r&#39;\D&#39;,&quot;&quot;,phone)
print(&quot;电话号码是: &quot;, num2)
-----------------------------------------
电话号码是:  2004-959-559 
电话号码是:  2004959559
</code></pre>
<p>★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ ★ </p>
<blockquote>
<p><code>print(f&quot;匹配成功: &#123;match.group()&#125;&quot;)</code></p>
<p>f-string 是 Python 3.6 及以上版本中引入的一种新的字符串格式化方法，它允许你在字符串字面量中嵌入表达式，并在运行时动态地进行求值和格式化。</p>
<ul>
<li><code>f</code> 告诉 Python 这是一个格式化字符串。</li>
<li><code>&#123;match.group()&#125;</code> 是一个表达式，它将被求值，并且其结果将插入到字符串中相应的位置。</li>
</ul>
</blockquote>
<h6 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h6><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p>
<p><strong>注意：</strong> match 和 search 是匹配一次，findall 是匹配所有。</p>
<p>语法格式为：</p>
<pre><code>findall(string[, pos[, endpos]])
</code></pre>
<p>参数：</p>
<ul>
<li><strong>string</strong> : 待匹配的字符串。</li>
<li><strong>pos</strong> : 可选参数，指定字符串的起始位置，默认为 0。</li>
<li><strong>endpos</strong> : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li>
</ul>
<p>查找字符串中的所有数字：</p>
<pre><code class="python"># -*- coding:UTF8 -*-
 
import re
# 这里您编译了一个正则表达式模式，该模式 r&#39;\d+&#39; 匹配一个或多个数字。
# \d 表示数字 [0-9]，+ 表示一个或多个。
pattern = re.compile(r&#39;\d+&#39;)   # 查找数字
# 这里您在字符串 &#39;runoob 123 google 456&#39; 中查找所有匹配的数字。
# 由于字符串中有两个数字序列 &#39;123&#39; 和 &#39;456&#39;，所以返回一个列表 [&#39;123&#39;, &#39;456&#39;]
result1 = pattern.findall(&#39;runoob 123 google 456&#39;)
# 在这里，您同样查找数字，但是指定了搜索的起始位置 0 和结束位置 10。
# 这意味着搜索只会在字符串的前10个字符内进行。在这个范围内，有两个数字序列 &#39;88&#39; 和 &#39;12&#39;，所以返回列表 [&#39;88&#39;, &#39;12&#39;]
result2 = pattern.findall(&#39;run88oob123google456&#39;, 0, 10)
 
print(result1)
print(result2)
</code></pre>
<p>输出结果：</p>
<pre><code class="python">[&#39;123&#39;, &#39;456&#39;]
[&#39;88&#39;, &#39;12&#39;]
</code></pre>
<h6 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h6><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<pre><code>re.finditer(pattern, string, flags=0)
</code></pre>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pattern</td>
<td align="left">匹配的正则表达式</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">要匹配的字符串。</td>
</tr>
<tr>
<td align="left">flags</td>
<td align="left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></td>
</tr>
</tbody></table>
<pre><code class="python"># -*- coding: UTF-8 -*-
 
import re
 
it = re.finditer(r&quot;\d+&quot;,&quot;12a32bc43jf3&quot;) 
for match in it:
    print(match)          # 打印匹配对象的描述
    print(&quot;==========&quot;)
    print(match.group())  # 打印匹配到的字符串
</code></pre>
<p>下面是具体的区别：</p>
<ul>
<li><p>当您执行 <code>print(match)</code> 时，您实际上是在打印匹配对象的内存地址或者一个表示匹配对象的字符串。这个输出通常用于调试，以便快速查看对象的类型和标识。</p>
<p>而 <code>print(match.group())</code> 是用来获取匹配对象中的实际匹配到的字符串。<code>group()</code> 方法返回正则表达式匹配到的整个字符串。</p>
</li>
<li><p><code>print(match)</code>：</p>
<ul>
<li>打印的是匹配对象的描述，通常包括对象的类型和内存地址。</li>
<li>对于调试目的，这有助于了解对象的身份，但不显示匹配到的文本。</li>
</ul>
</li>
<li><p><code>print(match.group())</code>：</p>
<ul>
<li>打印的是通过正则表达式匹配到的具体字符串。</li>
<li>这是获取匹配文本的实际内容的方法。</li>
</ul>
</li>
</ul>
<h6 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h6><p><code>split</code>方法按照能够匹配的子串将字符串分割后返回列表</p>
<pre><code class="python">import re
# 定义一个包含单词和数字的字符串
text = &quot;单词1单词2单词3单词4&quot;
# 使用 re.split() 按照数字进行分割，但不保留数字
# (?:\d+) 匹配一个或多个数字，但不会捕获匹配的数字
result = re.split(r&#39;(?:\d+)&#39;, text)
print(result)
</code></pre>
<h6 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a><span style = "color:red">正则表达式模式</span></h6><p>模式字符串使用特殊的语法来表示一个正则表达式：<br>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。<br>多数字母和数字前加一个反斜杠时会拥有不同的含义。<br>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。<br>反斜杠本身需要使用反斜杠转义。<br>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\t’，等价于 ‘\t’)匹配相应的特殊字符。<br>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配字符串的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配字符串的末尾。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td align="left">re*</td>
<td align="left">匹配0个或多个的表达式。</td>
</tr>
<tr>
<td align="left">re+</td>
<td align="left">匹配1个或多个的表达式。</td>
</tr>
<tr>
<td align="left">re?</td>
<td align="left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td align="left">re{ n}</td>
<td align="left">精确匹配 n 个前面表达式。例如， <strong>o{2}</strong> 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">re{ n,}</td>
<td align="left">匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td>
</tr>
<tr>
<td align="left">re{ n, m}</td>
<td align="left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td align="left">a| b</td>
<td align="left">匹配a或b</td>
</tr>
<tr>
<td align="left">(re)</td>
<td align="left">对正则表达式分组并记住匹配的文本</td>
</tr>
<tr>
<td align="left">(?imx)</td>
<td align="left">正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td align="left">(?-imx)</td>
<td align="left">正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td align="left">(?: re)</td>
<td align="left">类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td align="left">(?imx: re)</td>
<td align="left">在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td align="left">(?-imx: re)</td>
<td align="left">在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td align="left">(?#…)</td>
<td align="left">注释.</td>
</tr>
<tr>
<td align="left">(?&#x3D; re)</td>
<td align="left">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td align="left">(?! re)</td>
<td align="left">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td align="left">(?&gt; re)</td>
<td align="left">匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母数字及下划线</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配非字母数字及下划线</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意空白字符，等价于 **[ \t\n\r\f]**。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意非空字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配任意非数字</td>
</tr>
<tr>
<td align="left">\A</td>
<td align="left">匹配字符串开始</td>
</tr>
<tr>
<td align="left">\Z</td>
<td align="left">匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>
</tr>
<tr>
<td align="left">\z</td>
<td align="left">匹配字符串结束</td>
</tr>
<tr>
<td align="left">\G</td>
<td align="left">匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td align="left">\n, \t, 等.</td>
<td align="left">匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td align="left">\1…\9</td>
<td align="left">匹配第n个分组的内容。</td>
</tr>
<tr>
<td align="left">\10</td>
<td align="left">匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式</td>
</tr>
</tbody></table>
<h6 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h6><p><strong>字符匹配</strong></p>
<table>
<thead>
<tr>
<th align="left">实例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">python</td>
<td align="left">匹配 “python”.</td>
</tr>
</tbody></table>
<p><strong>字符类</strong></p>
<table>
<thead>
<tr>
<th align="left">实例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[Pp]ython</td>
<td align="left">匹配 “Python” 或 “python”</td>
</tr>
<tr>
<td align="left">rub[ye]</td>
<td align="left">匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td align="left">[aeiou]</td>
<td align="left">匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td align="left">[0-9]</td>
<td align="left">匹配任何数字。类似于 [0123456789]</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">匹配任何小写字母</td>
</tr>
<tr>
<td align="left">[A-Z]</td>
<td align="left">匹配任何大写字母</td>
</tr>
<tr>
<td align="left">[a-zA-Z0-9]</td>
<td align="left">匹配任何字母及数字</td>
</tr>
<tr>
<td align="left">[^aeiou]</td>
<td align="left">除了aeiou字母以外的所有字符</td>
</tr>
<tr>
<td align="left">[^0-9]</td>
<td align="left">匹配除了数字外的字符</td>
</tr>
</tbody></table>
<h6 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h6><table>
<thead>
<tr>
<th align="left">实例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td>
</tr>
</tbody></table>
<h6 id="request请求的用法"><a href="#request请求的用法" class="headerlink" title="request请求的用法"></a>request请求的用法</h6><p>以下是使用 Python 标准库中的 <code>urllib</code> 模块进行 HTTP <code>GET </code>和 <code>POST</code> 请求的简化用法。</p>
<p><strong>Get请求</strong><del>request.get()</del></p>
<pre><code class="python">import requests

# 简化的 GET 请求
def simple_get(url):
    response = requests.get(url)
    return response.text

# 使用 GET 请求
url = &#39;http://httpbin.org/get&#39;
response_text = simple_get(url)
print(response_text)
</code></pre>
<p><strong>Post请求</strong><del>request.post()</del></p>
<pre><code class="python">import requests

# 简化的 POST 请求
def simple_post(url, data):
    response = requests.post(url, data=data)
    return response.text

# 使用 POST 请求
url = &#39;http://httpbin.org/post&#39;
data = &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;
response_text = simple_post(url, data)
print(response_text)
</code></pre>
<h6 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h6><pre><code class="python">import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header


# 设置QQ邮箱的SMTP服务器地址和端口
smtp_server = &#39;smtp.qq.com&#39;
smtp_port = 465  # QQ邮箱SMTP服务器端口为465或587

# 设置发件人和收件人邮箱
sender_email = &#39;390415032@qq.com&#39;  # 发件人邮箱
receiver_email = &#39;recipient@example.com&#39;  # 收件人邮箱
password = &#39;your_qq_email_auth_code&#39;  # QQ邮箱授权码

# 设置邮件主题和内容
subject = &#39;Test Email from Python&#39;
body = &#39;This is a test email sent by Python.&#39;

# 创建MIMEText对象，设置邮件内容和编码
msg = MIMEText(body, &#39;plain&#39;, &#39;utf-8&#39;)
msg[&#39;From&#39;] = Header(sender_email, &#39;utf-8&#39;)
msg[&#39;To&#39;] = Header(receiver_email, &#39;utf-8&#39;)
msg[&#39;Subject&#39;] = Header(subject, &#39;utf-8&#39;)

# 发送邮件
try:
    # 创建SMTP对象
    server = smtplib.SMTP_SSL(smtp_server, smtp_port)
    # 登录SMTP服务器
    server.login(sender_email, password)
    # 发送邮件
    server.sendmail(sender_email, [receiver_email], msg.as_string())
    print(&#39;Email sent successfully!&#39;)
except smtplib.SMTPException as e:
    print(&#39;Error: unable to send email. &#39;, e)
finally:
    # 关闭服务器连接
    server.quit()
</code></pre>
<h6 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h6><p>Python中使用线程有两种方式：函数或者用类来包装线程对象。</p>
<p>函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:</p>
<pre><code class="python">thread.start_new_thread ( function, args[, kwargs] )
</code></pre>
<p>参数说明:</p>
<ul>
<li><strong>function</strong> - 线程函数。</li>
<li><strong>args</strong> - 传递给线程函数的参数,他必须是个tuple类型。</li>
<li><strong>kwargs</strong> - 可选参数。</li>
</ul>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import thread
import time
 
# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count &lt; 5:
      time.sleep(delay)
      count += 1
      print &quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) )
 
# 创建两个线程
try:
   thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) )
   thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )
except:
   print &quot;Error: unable to start thread&quot;
 
while 1:
   pass

-------------------------------------------------------
Thread-1: Thu Jan 22 15:42:17 2009
Thread-1: Thu Jan 22 15:42:19 2009
Thread-2: Thu Jan 22 15:42:19 2009
Thread-1: Thu Jan 22 15:42:21 2009
Thread-2: Thu Jan 22 15:42:23 2009
Thread-1: Thu Jan 22 15:42:23 2009
Thread-1: Thu Jan 22 15:42:25 2009
Thread-2: Thu Jan 22 15:42:27 2009
Thread-2: Thu Jan 22 15:42:31 2009
Thread-2: Thu Jan 22 15:42:35 2009
</code></pre>
<p>线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，他抛出SystemExit exception，达到退出线程的目的。</p>
<h4 id="线程模块"><a href="#线程模块" class="headerlink" title="线程模块"></a>线程模块</h4><p>Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。</p>
<p><strong>threading</strong> 模块提供的其他方法：</p>
<ul>
<li><code>threading.currentThread():</code>  返回当前的线程变量。</li>
<li><code>threading.enumerate():</code>  返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li>
<li><code>threading.activeCount(): </code> 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li>
</ul>
<p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p>
<ul>
<li><strong>run():</strong> 用以表示线程活动的方法。</li>
<li><strong>start():</strong> 启动线程活动。</li>
<li><strong>join([time]):</strong> 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</li>
<li><strong>isAlive():</strong> 返回线程是否活动的。</li>
<li><strong>getName():</strong> 返回线程名。</li>
<li><strong>setName():</strong> 设置线程名。</li>
</ul>
<h6 id="使用Threading模块创建线程"><a href="#使用Threading模块创建线程" class="headerlink" title="使用Threading模块创建线程"></a>使用Threading模块创建线程</h6><p>使用Threading模块创建线程，直接从threading.Thread继承<br>然后重写__init__方法和run方法：</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import threading
import time
 
exitFlag = 0
 
class myThread (threading.Thread):   #继承父类threading.Thread
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):                   #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 
        print &quot;Starting &quot; + self.name
        print_time(self.name, self.counter, 5)
        print &quot;Exiting &quot; + self.name
 
def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            (threading.Thread).exit()
        time.sleep(delay)
        print &quot;%s: %s&quot; % (threadName, time.ctime(time.time()))
        counter -= 1
 
# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)
 
# 开启线程
thread1.start()
thread2.start()
 
print &quot;Exiting Main Thread&quot;

------------------------------------------
Starting Thread-1
Starting Thread-2
Exiting Main Thread
Thread-1: Thu Mar 21 09:10:03 2013
Thread-1: Thu Mar 21 09:10:04 2013
Thread-2: Thu Mar 21 09:10:04 2013
Thread-1: Thu Mar 21 09:10:05 2013
Thread-1: Thu Mar 21 09:10:06 2013
Thread-2: Thu Mar 21 09:10:06 2013
Thread-1: Thu Mar 21 09:10:07 2013
Exiting Thread-1
Thread-2: Thu Mar 21 09:10:08 2013
Thread-2: Thu Mar 21 09:10:10 2013
Thread-2: Thu Mar 21 09:10:12 2013
Exiting Thread-2
</code></pre>
<h6 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h6><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p>
<p>使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有<code>acquire方法</code>和<code>release方法</code>，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。如下：</p>
<p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</p>
<p>考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。</p>
<p>那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</p>
<p>锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。</p>
<p>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</p>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import threading
import time
 
class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print &quot;Starting &quot; + self.name
       # 获得锁，成功获得锁定后返回True
       # 可选的timeout参数不填时将一直阻塞直到获得锁定
       # 否则超时后将返回False
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # 释放锁
        threadLock.release()
 
def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print &quot;%s: %s&quot; % (threadName, time.ctime(time.time()))
        counter -= 1
 
threadLock = threading.Lock()
threads = []
 
# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)
 
# 开启新线程
thread1.start()
thread2.start()
 
# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)
 
# 等待所有线程完成
for t in threads:
    t.join()
print &quot;Exiting Main Thread&quot;
</code></pre>
<h6 id="线程优先级队列（-Queue）"><a href="#线程优先级队列（-Queue）" class="headerlink" title="线程优先级队列（ Queue）"></a>线程优先级队列（ Queue）</h6><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。</p>
<p>Queue模块中的常用方法:</p>
<ul>
<li>Queue.qsize() 返回队列的大小</li>
<li>Queue.empty() 如果队列为空，返回True,反之False</li>
<li>Queue.full() 如果队列满了，返回True,反之False</li>
<li>Queue.full 与 maxsize 大小对应</li>
<li>Queue.get([block[, timeout]])获取队列，timeout等待时间</li>
<li>Queue.get_nowait() 相当Queue.get(False)</li>
<li>Queue.put(item, block&#x3D;True, timeout&#x3D;None) 写入队列，timeout等待时间</li>
<li>Queue.put_nowait(item) 相当 Queue.put(item, False)</li>
<li>Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</li>
<li>Queue.join() 实际上意味着等到队列为空，再执行别的操作</li>
</ul>
<pre><code class="python">#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import Queue
import threading
import time
 
exitFlag = 0
 
class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print &quot;Starting &quot; + self.name
        process_data(self.name, self.q)
        print &quot;Exiting &quot; + self.name
 
def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print &quot;%s processing %s&quot; % (threadName, data)
        else:
            queueLock.release()
        time.sleep(1)
 
threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]
nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]
queueLock = threading.Lock()
workQueue = Queue.Queue(10)
threads = []
threadID = 1
 
# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1
 
# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()
 
# 等待队列清空
while not workQueue.empty():
    pass
 
# 通知线程是时候退出
exitFlag = 1
 
# 等待所有线程完成
for t in threads:
    t.join()
print &quot;Exiting Main Thread&quot;
---------------------------------------------------
Starting Thread-1
Starting Thread-2
Starting Thread-3
Thread-1 processing One
Thread-2 processing Two
Thread-3 processing Three
Thread-1 processing Four
Thread-2 processing Five
Exiting Thread-3
Exiting Thread-1
Exiting Thread-2
Exiting Main Thread
</code></pre>
<h4 id="Python-XML解析"><a href="#Python-XML解析" class="headerlink" title="Python XML解析"></a>Python XML解析</h4><p>XML 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）；XML 被设计用来传输和存储数据。XML 是一套定义语义标记的规则，这些标记将文档分成许多部件并对这些部件加以标识。它也是元标记语言，即定义了用于定义其他与特定领域有关的、语义的、结构化的标记语言的句法语言。常见的 XML 编程接口有 DOM 和 SAX，这两种接口处理 XML 文件的方式不同，当然使用场合也不同。<br>Python 有三种方法解析 XML，SAX，DOM，以及 ElementTree:</p>
<h6 id="1-SAX-simple-API-for-XML"><a href="#1-SAX-simple-API-for-XML" class="headerlink" title="1.SAX (simple API for XML )"></a>1.SAX (simple API for XML )</h6><p>Python 标准库包含 SAX 解析器，SAX 用事件驱动模型，通过在解析XML的过程中触发一个个的事件并调用用户定义的回调函数来处理XML文件。</p>
<h6 id="2-DOM-Document-Object-Model"><a href="#2-DOM-Document-Object-Model" class="headerlink" title="2.DOM(Document Object Model)"></a>2.DOM(Document Object Model)</h6><p>将 XML 数据在内存中解析成一个树，通过对树的操作来操作XML。</p>
<h6 id="3-ElementTree-元素树"><a href="#3-ElementTree-元素树" class="headerlink" title="3.ElementTree(元素树)"></a>3.ElementTree(元素树)</h6><p>ElementTree就像一个轻量级的DOM，具有方便友好的API。代码可用性好，速度快，消耗内存少。</p>
<p><strong>注：</strong>因DOM需要将XML数据映射到内存中的树，一是比较慢，二是比较耗内存，而SAX流式读取XML文件，比较快，占用内存少，但需要用户实现回调函数（handler）。</p>
<p><strong>XML解析一下</strong></p>
<pre><code class="python">import xml.sax
from lxml import etree

# 确保文件路径正确
xml_file_path = &#39;movies.xml&#39;

# 使用 lxml 创建一个 XML 解析器
parser = etree.XMLParser()

# 解析 XML 文件
try:
    tree = etree.parse(xml_file_path, parser)
    # 遍历所有元素并打印
    for element in tree.iter():
        print(f&quot;Element tag: &#123;element.tag&#125;, text: &#123;element.text.strip() if element.text else &#39;&#39;&#125;&quot;)
except etree.XMLSyntaxError as e:
    print(f&quot;XML 解析错误: &#123;e&#125;&quot;)
</code></pre>
<pre><code class="xml">movies.xml
&lt;collection shelf=&quot;New Arrivals&quot;&gt;
&lt;movie title=&quot;Enemy Behind&quot;&gt;
   &lt;type&gt;War, Thriller&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;year&gt;2003&lt;/year&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;10&lt;/stars&gt;
   &lt;description&gt;Talk about a US-Japan war&lt;/description&gt;
&lt;/movie&gt;
&lt;movie title=&quot;Transformers&quot;&gt;
   &lt;type&gt;Anime, Science Fiction&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;year&gt;1989&lt;/year&gt;
   &lt;rating&gt;R&lt;/rating&gt;
   &lt;stars&gt;8&lt;/stars&gt;
   &lt;description&gt;A schientific fiction&lt;/description&gt;
&lt;/movie&gt;
   &lt;movie title=&quot;Trigun&quot;&gt;
   &lt;type&gt;Anime, Action&lt;/type&gt;
   &lt;format&gt;DVD&lt;/format&gt;
   &lt;episodes&gt;4&lt;/episodes&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;10&lt;/stars&gt;
   &lt;description&gt;Vash the Stampede!&lt;/description&gt;
&lt;/movie&gt;
&lt;movie title=&quot;Ishtar&quot;&gt;
   &lt;type&gt;Comedy&lt;/type&gt;
   &lt;format&gt;VHS&lt;/format&gt;
   &lt;rating&gt;PG&lt;/rating&gt;
   &lt;stars&gt;2&lt;/stars&gt;
   &lt;description&gt;Viewable boredom&lt;/description&gt;
&lt;/movie&gt;
&lt;/collection&gt;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#ff7d73>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/02/26/AI/python/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/25/AI/LlamaIndex/">
        <h2>
            LlamaIndex
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/25
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="LlamaIndex喂食给AI并进化升级"><a href="#LlamaIndex喂食给AI并进化升级" class="headerlink" title="LlamaIndex喂食给AI并进化升级"></a>LlamaIndex<del>喂食给AI并进化升级</del></h1><h4 id="将您的企业数据转化为可用于生产的LLM应用程序"><a href="#将您的企业数据转化为可用于生产的LLM应用程序" class="headerlink" title="将您的企业数据转化为可用于生产的LLM应用程序"></a>将您的企业数据转化为可用于生产的LLM应用程序</h4><p>LLM 提供人与数据之间的自然语言接口。LLM 预先训练过大量公开数据，但它们并非基于您的数据进行训练。您的数据可能是私有的，也可能是特定于您要解决的问题的数据。它隐藏在 AP1后面、SQL 数据库中，或隐藏在PDF 和幻灯片中。上下文增强使 LLM 可以使用您的数据来解决手头的问题。Llamalndex 提供构建任何上下文增强用例的工具，从原型到生产我们的工具允许您提取、解析、索引和处理您的数据，并快速实施将数据访问与 LLM 提示相结合的复杂查询工作流。<br>上下文增强最流行的示例是<strong>检索增强生成</strong>或 <strong>RAG</strong>，它在推理时将上下文与ILLM 相结合。</p>
<p>LlamaIndex 是一个将<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B&zhida_source=entity">大语言模型</a>（Large Language Models, LLMs，后简称大模型）和外部数据连接在一起的工具。大模型依靠上下文学习（Context Learning）来推理知识，针对一个输入（或者是prompt），根据其输出结果。因此Prompt的质量很大程度上决定了输出结果的质量，因此提示工程（<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=Prompt+engineering&zhida_source=entity">Prompt engineering</a>）现在也很受欢迎。目前大模型的输入输出长度因模型结构、显卡算力等因素影响，都有一个长度限制（以Token为单位，ChatGPT限制长度为4k个，GPT-4是32k等，Claude最新版有个100k的）。当我们外部知识的内容超过这个长度时，就无法同时将有效的信息传递给大模型。因此就诞生了 LlamaIndex 等项目。</p>
<p>假设有一个10w的外部数据，我们的原始输入Prompt长度为100，长度限制为4k，通过查询-检索的方式，我们能将最有效的信息提取集中在这4k的长度中，与Prompt一起送给大模型，从而让大模型得到更多的信息。此外，还能通过多轮对话的方式不断提纯外部数据，达到在有限的输入长度限制下，传达更多的信息给大模型。这部分知识可参考</p>
<p>LLamaIndex的任务是通过查询、检索的方式挖掘外部数据的信息，并将其传递给大模型，因此其主要由x部分组成：</p>
<ol>
<li><p>数据连接。首先将数据能读取进来，这样才能挖掘。</p>
</li>
<li><p>索引构建。要查询外部数据，就必须先构建可以查询的索引，llamdaIndex将数据存储在Node中，并基于Node构建索引。索引类型包括<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95&zhida_source=entity">向量索引</a>、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E5%88%97%E8%A1%A8%E7%B4%A2%E5%BC%95&zhida_source=entity">列表索引</a>、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E6%A0%91%E5%BD%A2%E7%B4%A2%E5%BC%95&zhida_source=entity">树形索引</a>等；</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E6%9F%A5%E8%AF%A2%E6%8E%A5%E5%8F%A3&zhida_source=entity">查询接口</a>。有了索引，就必须提供查询索引的接口。通过这些接口用户可以与不同的 大模型进行对话，也能自定义需要的Prompt组合方式。查询接口会完成 检索+对话的功能，即先基于索引进行检索，再将检索结果和之前的输入Prompt进行（自定义）组合形成新的<strong>扩充Prompt</strong>，对话大模型并拿到结果进行解析。</p>
</li>
</ol>
<h2 id="1-数据连接器（Data-Connectors）"><a href="#1-数据连接器（Data-Connectors）" class="headerlink" title="1 数据连接器（Data Connectors）"></a><strong>1 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%99%A8&zhida_source=entity">数据连接器</a>（Data Connectors）</strong></h2><p>数据连接器，读取文档的工具，最简单的就是读取本地文件。 LLamaIndex 的数据连接器包括</p>
<ul>
<li>本地文件、Notion、Google 文档、Slack、Discord</li>
</ul>
<p>具体可参考<a href="https://link.zhihu.com/?target=https://gpt-index.readthedocs.io/en/latest/how_to/data_connectors.html">Data Connectors。</a></p>
<h2 id="2-索引结构（Index-Structures）"><a href="#2-索引结构（Index-Structures）" class="headerlink" title="2 索引结构（Index Structures）"></a><strong>2 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84&zhida_source=entity">索引结构</a>（Index Structures）</strong></h2><p>LlamaIndex 的核心其实就是 索引结构的集合，用户可以使用索引结构或基于这些索引结构自行建图。</p>
<h3 id="2-1-索引如何工作"><a href="#2-1-索引如何工作" class="headerlink" title="2.1 索引如何工作"></a><strong>2.1 索引如何工作</strong></h3><p>两个概念：</p>
<ul>
<li><strong>Node（节点）</strong>：即一段文本（Chunk of Text），LlamaIndex读取文档（documents）对象，并将其解析&#x2F;划分（parse&#x2F;chunk）成 Node 节点对象，构建起索引。</li>
<li><strong>Response Synthesis（回复合成）</strong>：LlamaIndex 进行检索节点并响应回复合成，不同的模式有不同的响应模式（比如向量查询、树形查询就不同），合成不同的扩充Prompt。</li>
</ul>
<p>索引方式包括</p>
<ul>
<li><strong>List Index</strong>：Node顺序存储，可用关键字过滤Node</li>
<li><strong>Vector Store Index</strong>：每个Node一个向量，查询的时候取top-k相似</li>
<li><strong>Tree Index</strong>：树形Node，从树根向叶子查询，可单边查询，或者双边查询合并。</li>
<li>**<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=228316377&content_type=Article&match_order=1&q=Keyword+Table+Index&zhida_source=entity">Keyword Table Index</a>**：每个Node有很多个Keywords链接，通过查Keyword能查询对应Node。</li>
</ul>
<p>不同的索引方式决定了Query选择Node方式的不同。</p>
<p>回复合成方式包括：</p>
<ul>
<li><p>创建并提纯（Create and Refine)，即线性依次迭代；</p>
</li>
<li><p>树形总结（Tree Summarize）：自底向上，两两合并，最终合并成一个回复。</p>
</li>
</ul>
<h2 id="3-查询接口（Query-Inference）"><a href="#3-查询接口（Query-Inference）" class="headerlink" title="3 查询接口（Query Inference）"></a><strong>3 查询接口（Query Inference）</strong></h2><h3 id="3-1-LlamaIndex-使用模板"><a href="#3-1-LlamaIndex-使用模板" class="headerlink" title="3.1 LlamaIndex 使用模板"></a><strong>3.1 LlamaIndex 使用模板</strong></h3><p>LlamaIndex 常用使用模版：</p>
<ol>
<li>读取文档 (手动添加or通过Loader自动添加)；</li>
<li>将文档解析为Nodes；</li>
<li>构建索引（从文档or从Nodes，如果从文档，则对应函数内部会完成第2步的Node解析）</li>
<li>[可选，进阶] 在其他索引上构建索引，即多级索引结构</li>
<li>查询索引并对话大模型</li>
</ol>
<hr>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/6f518a5400d2e36ad851f0799a45911cc1bb90ff/LLM%E7%BE%8A%E9%A9%BC.png"></p>
<h6 id="LangChain-vs-LlamaIndex"><a href="#LangChain-vs-LlamaIndex" class="headerlink" title="LangChain vs LlamaIndex"></a>LangChain vs LlamaIndex</h6><p>要<strong>综合构建用于生产的高性能RAG程序</strong> 就用<code>LlamaIndex</code><br>LlamaIndex官网参考：<a target="_blank" rel="noopener" href="https://www.llamaindex.ai/">https://www.llamaindex.ai/</a><br>python文档参考：[LlamaIndex - LlamaIndex] (<a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/">https://docs.llamaindex.ai/en/stable/</a>)</p>
<h6 id="LLM官网最下方的入门项目也需要学习"><a href="#LLM官网最下方的入门项目也需要学习" class="headerlink" title="LLM官网最下方的入门项目也需要学习"></a>LLM官网最下方的入门项目也需要学习</h6><h5 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h5><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/create-llama">创建骆驼</a></li>
<li><a target="_blank" rel="noopener" href="https://secinsights.ai/">SEC 洞察</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/run-llama/llamabot">骆驼机器人</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/use_cases/q_and_a/rag_cli.html">RAG 命令行界面</a></li>
</ul>
</blockquote>
<h4 id="RAG-Work-Flow"><a href="#RAG-Work-Flow" class="headerlink" title="RAG Work Flow"></a>RAG Work Flow</h4><p><img src="https://raw.githubusercontent.com/P-luminary/images/183f045f8c4d37aefbb62c12d2c52ebd82d26b74/RAG%20Work%20flow.png"></p>
<h4 id="构建RAG管道—加载数据-镊取"><a href="#构建RAG管道—加载数据-镊取" class="headerlink" title="构建RAG管道—加载数据(镊取)"></a>构建RAG管道—加载数据(镊取)</h4><p>在您选择的 LLM 可以处理您的数据之前，您首先需要处理数据并加载数据。这与 ML 领域的数据清理&#x2F;特征工程管道或传统数据设置中的 ETL 管道有相似之处。</p>
<p>此引入管道通常包括三个主要阶段：</p>
<ol>
<li>加载数据</li>
<li>转换数据</li>
<li>索引和存储数据</li>
</ol>
<p>我们将在<a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/understanding/indexing/indexing/">后面</a><a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/understanding/storing/storing/">的章节</a>中介绍索引 &#x2F; 存储。在本指南中，我们将主要讨论 loader 和 transformations。</p>
<h4 id="装载机"><a href="#装载机" class="headerlink" title="装载机"></a>装载机</h4><p>在您选择的 LLM 可以处理您的数据之前，您需要加载它。LlamaIndex 执行此作的方式是通过数据连接器（也称为 .Data Connector 从不同的数据源摄取数据并将数据格式化为对象。A 是有关该数据的数据（<u>当前为<strong>文本</strong>，将来为<strong>图像</strong>和<strong>音频</strong></u>）和元数据的集合。<code>Reader Document Document</code></p>
<h4 id="使用-SimpleDirectoryReader-加载"><a href="#使用-SimpleDirectoryReader-加载" class="headerlink" title="使用 SimpleDirectoryReader 加载"></a>使用 SimpleDirectoryReader 加载</h4><p>最容易使用的阅读器是我们的 SimpleDirectoryReader，它从给定目录中的每个文件创建文档。它内置于 LlamaIndex 中，可以读取多种格式，包括 <strong>Markdown、PDF、Word 文档、PowerPoint 幻灯片、图像、音频和视频</strong>。</p>
<pre><code class="python">from llama_index.core import SimpleDirectoryReader
documents = SimpleDirectoryReader(&quot;./data&quot;).load_data()
</code></pre>
<p>★ ★ ★ ★ <u>更多教程请看<strong>官方接口文档</strong></u> <a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/understanding/loading/loading/"><span style = "color:blue"><strong><u>Loading Data (Ingestion) - LlamaIndex</u></strong></span></a> ★ ★ ★ ★</p>
<p><a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/getting_started/starter_example/">Starter Tutorial - LlamaIndex</a> + <a target="_blank" rel="noopener" href="https://colab.research.google.com/#scrollTo=S7b85AZVL5M5">欢迎使用 Colaboratory - Colab</a> &#x3D; 在线使用代码</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/640d982cf931112877ec183a26a25a678da433be/LlamaIndex+Colab.png"></p>
<h4 id="RAG"><a href="#RAG" class="headerlink" title="RAG"></a>RAG</h4><p>RAG，也称为检索增强生成，是利用个人或私域数据增强 <code>LLM</code> 的一种范式。通常，它包含两个阶段：</p>
<ol>
<li><p>索引</p>
<p>构建知识库。</p>
</li>
<li><p>查询</p>
<p>从知识库检索相关上下文信息，以辅助 <code>LLM</code> 回答问题。</p>
</li>
</ol>
<p><code>LlamaIndex</code> 提供了工具包帮助开发者极其便捷地完成这两个阶段的工作。</p>
<h4 id="索引阶段"><a href="#索引阶段" class="headerlink" title="索引阶段"></a>索引阶段</h4><p><code>LlamaIndex</code> 通过提供 Data connectors(数据连接器) 和 Indexes (索引) 帮助开发者构建知识库。</p>
<p>该阶段会用到如下工具或组件：</p>
<ul>
<li><p>Data connectors</p>
<p>数据连接器。它负责将来自不同数据源的不同格式的数据注入，并转换为 <code>LlamaIndex</code> 支持的文档（Document）表现形式，其中包含了文本和元数据。</p>
</li>
<li><p>Documents &#x2F; Nodes</p>
<p>Document是 <code>LlamaIndex</code> 中容器的概念，它可以包含任何数据源，包括，PDF文档，API响应，或来自数据库的数据。</p>
<p>Node是 <code>LlamaIndex</code> 中数据的最小单元，代表了一个 Document的分块。它还包含了元数据，以及与其他Node的关系信息。这使得更精确的检索操作成为可能。</p>
</li>
<li><p>Data Indexes</p>
<p><code>LlamaIndex</code> 提供便利的工具，帮助开发者为注入的数据建立索引，使得未来的检索简单而高效。</p>
<p>最常用的索引是向量存储索引 - <code>VectorStoreIndex</code>。</p>
</li>
</ul>
<h4 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h4><p>在查询阶段，<code>RAG</code> 管道根据的用户查询，检索最相关的上下文，并将其与查询一起，传递给 <code>LLM</code>，以合成响应。这使 <code>LLM</code> 能够获得不在其原始训练数据中的最新知识，同时也减少了虚构内容。该阶段的关键挑战在于检索、编排和基于知识库的推理。</p>
<p><code>LlamaIndex</code> 提供可组合的模块，帮助开发者构建和集成 <code>RAG</code> 管道，用于问答、聊天机器人或作为代理的一部分。这些构建块可以根据排名偏好进行定制，并组合起来，以结构化的方式基于多个知识库进行推理。</p>
<p>该阶段的构建块包括：</p>
<ul>
<li><p><strong>Retrievers</strong></p>
<p>检索器。它定义如何高效地从知识库，基于查询，检索相关上下文信息。</p>
</li>
<li><p><strong>Node Postprocessors</strong></p>
<p>Node后处理器。它对一系列文档节点（Node）实施转换，过滤，或排名。</p>
</li>
<li><p><strong>Response Synthesizers</strong></p>
<p>响应合成器。它基于用户的查询，和一组检索到的文本块（形成上下文），利用 <code>LLM</code> 生成响应。</p>
</li>
</ul>
<p>RAG管道包括：</p>
<ul>
<li><p><strong>Query Engines</strong></p>
<p>查询引擎 - 端到端的管道，允许用户基于知识库，以自然语言提问，并获得回答，以及相关的上下文。</p>
</li>
<li><p><strong>Chat Engines</strong></p>
<p>聊天引擎 - 端到端的管道，允许用户基于知识库进行对话（多次交互，会话历史）。</p>
</li>
<li><p><strong>Agents</strong></p>
<p>代理。它是一种由 <code>LLM</code> 驱动的自动化决策器。代理可以像查询引擎或聊天引擎一样使用。主要区别在于，代理动态地决定最佳的动作序列，而不是遵循预定的逻辑。这为其提供了处理更复杂任务的额外灵活性。</p>
</li>
</ul>
<h4 id="LlamaIndex个性化配置"><a href="#LlamaIndex个性化配置" class="headerlink" title="LlamaIndex个性化配置"></a>LlamaIndex个性化配置</h4><p><code>LlamaIndex</code> 对 <code>RAG</code> 过程提供了全面的配置支持，允许开发者对整个过程进行个性化设置。常见的配置场景包括：</p>
<ul>
<li>自定义文档分块</li>
<li>自定义向量存储</li>
<li>自定义检索</li>
<li>指定 <code>LLM</code></li>
<li>指定响应模式</li>
<li>指定流式响应</li>
</ul>
<p>注，个性化配置主要通过 <code>LlamaIndex</code> 提供的 <code>ServiceContext</code> 类实现。</p>
<h5 id="配置场景示例"><a href="#配置场景示例" class="headerlink" title="配置场景示例"></a>配置场景示例</h5><p>接下来通过简明示例代码段展示 <code>LlamaIndex</code> 对各种配置场景的支持。</p>
<h5 id="自定义文档分块"><a href="#自定义文档分块" class="headerlink" title="自定义文档分块"></a>自定义文档分块</h5><pre><code class="python">from llama_index import ServiceContext
service_context = ServiceContext.from_defaults(chunk_size=500)
</code></pre>
<h5 id="自定义向量存储"><a href="#自定义向量存储" class="headerlink" title="自定义向量存储"></a>自定义向量存储</h5><pre><code class="python">import chromadb
from llama_index.vector_stores import ChromaVectorStore
from llama_index import StorageContext

chroma_client = chromadb.PersistentClient()
chroma_collection = chroma_client.create_collection(&quot;quickstart&quot;)
# 向量存储
vector_store = ChromaVectorStore(chroma_collection=chroma_collection)
storage_context = StorageContext.from_defaults(vector_store=vector_store)
</code></pre>
<h5 id="自定义检索"><a href="#自定义检索" class="headerlink" title="自定义检索"></a>自定义检索</h5><p>自定义检索中，我们可以通过参数指定<strong>查询引擎</strong>(Query Engine)在检索时请求的相似文档数。</p>
<pre><code class="python">index = VectorStoreIndex.from_documents(documents)
query_engine = index.as_query_engine(similarity_top_k=5)
</code></pre>
<h5 id="指定-LLM"><a href="#指定-LLM" class="headerlink" title="指定 LLM"></a>指定 <code>LLM</code></h5><pre><code class="python"># 指定大语言模型
service_context = ServiceContext.from_defaults(llm=OpenAI())
</code></pre>
<h5 id="指定响应模式"><a href="#指定响应模式" class="headerlink" title="指定响应模式"></a>指定响应模式</h5><pre><code class="python">query_engine = index.as_query_engine(response_mode=&#39;tree_summarize&#39;)
</code></pre>
<h5 id="指定流式响应"><a href="#指定流式响应" class="headerlink" title="指定流式响应"></a>指定流式响应</h5><pre><code class="python"># 流式响应
query_engine = index.as_query_engine(streaming=True)
</code></pre>
<h5 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h5><p><strong>GitHub</strong>：<a target="_blank" rel="noopener" href="https://github.com/sugarforever/LlamaIndex-Tutorials/blob/main/03_Customization/03_Customization.ipynb">LlamaIndex-Tutorials&#x2F;03_Customization&#x2F;03_Customization.ipynb at main · sugarforever&#x2F;LlamaIndex-Tutorials</a><br><strong>Colab</strong>：<a target="_blank" rel="noopener" href="https://colab.research.google.com/github/sugarforever/LlamaIndex-Tutorials/blob/main/03_Customization/03_Customization.ipynb">03_Customization.ipynb - Colab</a></p>
<p>请参考<a target="_blank" rel="noopener" href="https://github.com/sugarforever/LlamaIndex-Tutorials/blob/main/03_Customization/03_Customization.ipynb">03_Customization.ipynb</a> ，这是一个基于第1课的示例实现上述的所有个性化配置：</p>
<ol>
<li>文档分块大小：500</li>
<li>Chromadb作为向量存储</li>
<li>自定义检索文档数为5</li>
<li>指定大模型为OpenAI的模型</li>
<li>响应模式为 <code>tree_summarize</code></li>
<li>问答实现流式响应</li>
</ol>
<p>注，响应模式会在后续课程中详细介绍。</p>
<hr>
<h4 id="强大的数据连接器"><a href="#强大的数据连接器" class="headerlink" title="强大的数据连接器"></a>强大的数据连接器</h4><p><strong>开源教程</strong>：<a target="_blank" rel="noopener" href="https://github.com/sugarforever/LlamaIndex-Tutorials/tree/main/04_Data_Connectors">LlamaIndex-Tutorials&#x2F;04_Data_Connectors at main · sugarforever&#x2F;LlamaIndex-Tutorials</a><br><strong>演示实例</strong>：<a target="_blank" rel="noopener" href="https://colab.research.google.com/github/sugarforever/LlamaIndex-Tutorials/blob/main/04_Data_Connectors/04_Data_Connectors.ipynb">04_Data_Connectors.ipynb - Colab</a></p>
<h4 id="文档与节点"><a href="#文档与节点" class="headerlink" title="文档与节点"></a>文档与节点</h4><p><strong>开源教程</strong>：<a target="_blank" rel="noopener" href="https://github.com/sugarforever/LlamaIndex-Tutorials/tree/main/05_Documents_Nodes">LlamaIndex-Tutorials&#x2F;05_Documents_Nodes at main · sugarforever&#x2F;LlamaIndex-Tutorials</a></p>
<h4 id="LlamaPack-新手入门"><a href="#LlamaPack-新手入门" class="headerlink" title="LlamaPack 新手入门"></a>LlamaPack 新手入门</h4><p><a target="_blank" rel="noopener" href="https://docs.llamaindex.ai/en/stable/community/llama_packs/">LlamaPacks - LlamaIndex</a></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/AI" style=color:#ffa2c4>
                AI
            </a>
        </span>
        
    </div>

    <a href="/2025/02/25/AI/LlamaIndex/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/09/面试/洪哥面试题/">
        <h2>
            洪哥面试题
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="线程池的执行流程大致如下"><a href="#线程池的执行流程大致如下" class="headerlink" title="线程池的执行流程大致如下:"></a><strong>线程池的执行流程大致如下</strong>:</h4><p>线程池：ThreadPoolExecutor<br>一开始new的时候没有 是空的。先当一个任务提交给线程池时，线程池首先检查当前运行的线程数是否达到核心线程数。如果没有达到核心线程数，线程池会创建一个新的线程来执行任务。如果已经达到核心线程数，线程池会将任务放入工作队列中等待执行。如果工作队列满了，并且当前运行的线程数小于最大线程数，线程池会创建新的线程来执行任务。如果工作队列满了，并且当前运行的线程数等于最大线程数，线程池会根据<strong>拒绝策略</strong></p>
<ul>
<li><u>丢弃任务抛出异常</u></li>
<li><u>丢弃任务不抛弃异常</u></li>
<li><u>丢弃队列最前面的任务,然后重新提交被拒绝的任务、</u></li>
<li><u>由主线程处理该任务来处理无法执行的任务</u>。【线程池无法起到异步问题】<ul>
<li>问题：想继续异步且不丢弃任务怎么办？</li>
<li>把这个业务先存到别的地方 ↓↓↓</li>
</ul>
</li>
<li><u>自定义拒绝策略</u> 自己写实现类实现拒绝策略 可以先存到mysql到时候再慢慢搞</li>
</ul>
<p><strong>怎么确定核心线程数和最大线程数</strong>？</p>
<h6 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h6><ul>
<li>CPU密集型任务：如果任务是CPU密集型的，即任务主要是进行计算而不是等待I&#x2F;O操作，核心线程数通常设置为CPU核心数加1。这样可以确保CPU在忙于计算的同时，还有额外的线程来处理可能出现的临时高峰。【纯内存计算 不涉及到网络计算和io计算】<ul>
<li>八个核 创建十个cpu 没意义 因为最多并发只是8，建议保持一致或者+1，<u>减少加入队列和创建队列的开销</u></li>
<li>先把其当成io密集 因为层级不一样 不断压测去逼近最理想值</li>
</ul>
</li>
<li>I&#x2F;O密集型任务：对于I&#x2F;O密集型任务，由于线程在等待I&#x2F;O操作时会阻塞，因此可以设置更多的核心线程数。一个常用的经验法则是核心线程数设置为CPU核心数的两倍。【线程数越多越好】【压测无限逼近取最合适的线程数】</li>
</ul>
<h6 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h6><p>需要一开始创建好线程等着访问来，如果 <u>核心&#x3D;最大</u>，此时没有临时线程</p>
<h4 id="创建线程有几种方式（必会）"><a href="#创建线程有几种方式（必会）" class="headerlink" title="创建线程有几种方式（必会）"></a>创建线程有几种方式（必会）</h4><p>1.继承Thread类并重写 run 方法创建线程，实现简单但不可以继承其他类<br>2.实现Runnable接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。<br>3.实现 Callable接口并重写 call 方法，创建线程。可以获取线程执行结果的返回值，并且可以抛出异常。<br>4.使用线程池创建（使用java.util.concurrent.Executor接口）</p>
<ul>
<li>想获得线程池里的返回结果用什么？<strong>execute + submit</strong></li>
<li>线程有哪些状态？ java线程有哪些状态？</li>
<li>线程池有哪些状态？</li>
</ul>
<pre><code class="java">// 1. 继承Thread类并重写run方法
class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 继承Thread类&quot;);
    &#125;
&#125;

// 2. 实现Runnable接口并重写run方法
class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;线程运行中 - 实现Runnable接口&quot;);
    &#125;
&#125;

// 3. 实现Callable接口并重写call方法
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable&lt;String&gt; &#123;
    @Override
    public String call() throws Exception &#123;
        System.out.println(&quot;线程运行中 - 实现Callable接口&quot;);
        return &quot;Callable线程返回结果&quot;;
    &#125;
&#125;

// 4. 使用线程池创建线程
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadCreationExamples &#123;
    public static void main(String[] args) &#123;
        // 继承Thread类创建线程
        Thread thread1 = new MyThread();
        thread1.start();

        // 实现Runnable接口创建线程
        Thread thread2 = new Thread(new MyRunnable());
        thread2.start();

        // 实现Callable接口创建线程
        MyCallable callable = new MyCallable();
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
        Thread thread3 = new Thread(futureTask);
        thread3.start();
        try &#123;
            // 获取线程执行结果的返回值
            String result = futureTask.get();
            System.out.println(result);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        // 使用线程池创建线程
        ExecutorService executor = Executors.newFixedThreadPool(2);
        executor.execute(new MyRunnable()); // 提交Runnable任务
        executor.submit(new MyCallable()); // 提交Callable任务
        executor.shutdown(); // 关闭线程池
    &#125;
&#125;
</code></pre>
<h4 id="线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池"><a href="#线程池哪些类型？通过JUC-包-的executes可以创建这四个类型的线程池" class="headerlink" title="线程池哪些类型？通过JUC[包]的executes可以创建这四个类型的线程池"></a>线程池哪些类型？<del>通过JUC[包]的executes可以创建这四个类型的线程池</del></h4><p>问题：为什么阿里巴巴不推荐JUC？有可能会出现OOM、资源浪费</p>
<ul>
<li>单线程线程池</li>
<li>可缓存线程池&#x2F;定长</li>
<li>变长的线程池</li>
<li>定时任务的线程池</li>
</ul>
<h4 id="java-线程池创建时核心参数-高薪常问"><a href="#java-线程池创建时核心参数-高薪常问" class="headerlink" title="java 线程池创建时核心参数(高薪常问)"></a>java 线程池创建时核心参数(高薪常问)</h4><p>核心线程池大小、线程池创建线程的最大个数(核心+非核心[临时线程])、临时线程存活时间、时间单位、阻塞队列、线程工厂(指定线程池创建线程的命名)、拒绝策略<br><u>线程工厂可以设置创建的属性</u>：<br><strong>守护线程</strong>：主线程(main)一天不死 守护线程不死 [同生共死]<br><strong>非守护线程</strong>：new一个就是 [不是同生共死]</p>
<p><u>阻塞队列常用的队列</u>：</p>
<ol>
<li><strong>ArrayBlockingQueue</strong>： 基于数组结构的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。创建时需要指定容量。【底层是数组 随机读写的 **时间复杂度O(1)**】<ul>
<li>开辟新空间创建新数组 把旧数组的数据迁移过去   <strong>new ArrayList</strong>为空 需要add才可以 <u>扩容是+10 取1.5倍</u></li>
<li>高并发不会超过某个值 数组不会涉及到扩容 性能会好一些【比较稳定能预估】</li>
<li>new的时候不用指定长度</li>
</ul>
</li>
<li><strong>LinkedBlockingQueue</strong>： 基于链表结构的有界阻塞队列（如果不指定容量，则默认为<code>Integer.MAX_VALUE</code>，即视为无界）。按照先进先出的原则排序元素。【随机读写的 <strong>时间复杂度O(n)</strong> 随机读写快  查询慢 是通过二分查找定位到下标元素(通过下标访问数组和链表) 只会走一次二分查找】<ul>
<li>读中间的慢 读头尾快</li>
<li>新增元素不涉及到数组的迁移</li>
<li>一般情况下高并发推荐使用，因为队列<del>高级数据结构</del>(可以用数组和链表的实现 由于底层数据结构不同)的特性是先进先出，链表不涉及到数组的扩容 末尾的最快是O(1)【不稳定】</li>
<li>new的时候可指定长度是最大链表的长度               </li>
<li>不可指定长度 [有界队列&amp;无界队列] → 可能产生JVM的OOM</li>
</ul>
</li>
</ol>
<h4 id="线程池的应用要有实际的业务场景"><a href="#线程池的应用要有实际的业务场景" class="headerlink" title="线程池的应用要有实际的业务场景"></a>线程池的应用<del>要有实际的业务场景</del></h4><ul>
<li>异步任务处理：将任务提交到线程池异步执行，而不阻塞主线程</li>
</ul>
<blockquote>
<p>假设我们有一个电商平台，其中一个核心业务是处理用户订单。在订单处理过程中，我们需要执行以下任务：</p>
<ol>
<li>验证订单信息（例如：检查库存、验证用户信息等）。</li>
<li>计算订单金额（包括商品价格、折扣、运费等）。</li>
<li>生成订单并保存到数据库。</li>
<li>发送订单确认邮件给用户。</li>
</ol>
<p>由于这些任务相对独立，并且处理时间可能较长，我们希望在不影响用户操作的前提下异步执行它们。以下是使用线程池处理这些异步任务的模拟代码：</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

class Order &#123;
    // 订单信息
    private String orderId;
    private String userId;
    private double amount;

    // 构造函数、getter和setter省略
&#125;

class OrderService &#123;
    private ExecutorService executorService = Executors.newFixedThreadPool(10); // 假设线程池大小为10

    // 处理订单
    public void processOrder(Order order) &#123;
        // 1. 验证订单信息
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;验证订单信息: &quot; + order.getOrderId());
            // 假设验证成功
        &#125;);

        // 2. 计算订单金额
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;计算订单金额: &quot; + order.getOrderId());
            // 假设计算成功，设置订单金额
            order.setAmount(100.0); // 示例金额
        &#125;);

        // 3. 生成订单并保存到数据库
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;生成订单并保存到数据库: &quot; + order.getOrderId());
            // 假设保存成功
        &#125;);

        // 4. 发送订单确认邮件
        executorService.submit(() -&gt; &#123;
            System.out.println(&quot;发送订单确认邮件: &quot; + order.getOrderId());
            // 假设邮件发送成功
        &#125;);
    &#125;

    // 关闭线程池
    public void shutdown() &#123;
        try &#123;
            executorService.shutdown();
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executorService.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executorService.shutdownNow();
        &#125;
    &#125;
&#125;

public class ThreadPoolApplication &#123;
    public static void main(String[] args) &#123;
        OrderService orderService = new OrderService();
        Order order = new Order();
        order.setOrderId(&quot;ORDER12345&quot;);
        order.setUserId(&quot;USER12345&quot;);

        // 处理订单
        orderService.processOrder(order);

        // 假设主线程还有其他任务，这里模拟等待其他任务完成
        try &#123;
            Thread.sleep(5000); // 等待5秒
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        // 关闭线程池
        orderService.shutdown();
    &#125;
&#125;

</code></pre>
<p>在这个模拟场景中，我们创建了一个 <code>OrderService</code> 类，它包含一个线程池用于异步处理订单的各个步骤。当用户创建订单时，<code>processOrder</code> 方法会将订单处理的各个任务提交到线程池中异步执行。这样，主线程不会被阻塞，可以继续处理其他用户请求或执行其他任务。在所有任务都提交到线程池后，主线程可能会执行其他逻辑，最后调用 <code>shutdown</code> 方法来优雅地关闭线程池。</p>
</blockquote>
<h4 id="你单独部署过项目吗？"><a href="#你单独部署过项目吗？" class="headerlink" title="你单独部署过项目吗？"></a>你单独部署过项目吗？</h4><p>前端打包ng配置文件<br>git所有人都用 需要拉分支 maven打包后端 包放到远程服务器 java -jar 启动！【不应该有人去做】<br>有专门工具去流水线制作 → <strong>Jenkins</strong>是一个开源的自动化服务器，它可以帮助您实现自动化构建、测试和部署项目   <strong><u>JenKins + docker 做自动化部署</u></strong><br>部署是建立本地的项目再推到服务器</p>
<blockquote>
<p><strong>安装 Docker</strong>：确保你的部署服务器上安装了 Docker。<br><strong>安装 Jenkins</strong>：可以通过 Docker 安装 Jenkins，或者直接在服务器上安装。</p>
<h4 id="步骤-1：安装-Jenkins-和-Docker"><a href="#步骤-1：安装-Jenkins-和-Docker" class="headerlink" title="步骤 1：安装 Jenkins 和 Docker"></a>步骤 1：安装 Jenkins 和 Docker</h4><p>确保 Jenkins 和 Docker 在服务器上都已经安装并运行。</p>
<h4 id="步骤-2：配置-Jenkins"><a href="#步骤-2：配置-Jenkins" class="headerlink" title="步骤 2：配置 Jenkins"></a>步骤 2：配置 Jenkins</h4><ol>
<li><p><strong>启动 Jenkins</strong>：</p>
<p>使用 Docker 启动 Jenkins：</p>
<pre><code>docker run -d --name jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts
</code></pre>
</li>
<li><p><strong>访问 Jenkins</strong>：在浏览器中访问 <code>http://&lt;服务器地址&gt;:8080</code>，并按照指示完成 Jenkins 的初始设置。</p>
</li>
<li><p><strong>安装必要的插件</strong>：安装 Docker、Git 等相关插件。</p>
</li>
</ol>
<h4 id="步骤-3：创建-Jenkins-任务"><a href="#步骤-3：创建-Jenkins-任务" class="headerlink" title="步骤 3：创建 Jenkins 任务"></a>步骤 3：创建 Jenkins 任务</h4><ol>
<li><p><strong>新建任务</strong>：在 Jenkins 主页上，点击“新建任务”。</p>
</li>
<li><p><strong>配置源码管理</strong>：配置 Git 仓库地址。</p>
</li>
<li><p><strong>配置构建触发器</strong>：选择合适的触发器。</p>
</li>
<li><p><strong>配置构建环境</strong>：勾选“Build inside a Docker container”。</p>
</li>
<li><p><strong>添加构建步骤</strong>：</p>
<ul>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker build -t myapp .
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加构建后操作</strong>：</p>
<ul>
<li><p><strong>Push built image</strong>：如果需要将镜像推送到 Docker 仓库，填写仓库信息。</p>
</li>
<li><p><strong>执行 Shell</strong>：</p>
<pre><code>docker stop myapp || true
docker rm myapp || true
docker run -d --name myapp -p 8080:8080 myapp
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="步骤-4：执行构建"><a href="#步骤-4：执行构建" class="headerlink" title="步骤 4：执行构建"></a>步骤 4：执行构建</h4><p>保存配置后，可以手动触发构建或者等待触发器自动执行构建。</p>
<h4 id="步骤-5：验证部署"><a href="#步骤-5：验证部署" class="headerlink" title="步骤 5：验证部署"></a>步骤 5：验证部署</h4><p>构建完成后，访问服务器的指定端口（例如 <code>http://&lt;服务器地址&gt;:8080</code>），验证应用是否成功部署。</p>
</blockquote>
<h4 id="你的期望薪资？"><a href="#你的期望薪资？" class="headerlink" title="你的期望薪资？"></a>你的期望薪资？</h4><p>我目前的薪资是8000，考虑到我即将承担的职责和我的职业发展，我期望的薪资是在现有基础上有所提升，大约在8000到10000之间。当然，我对整体的薪酬包[包括福利、奖金和职业发展机会]也很感兴趣。薪资是如何构成的，包括固定工资、奖金、股权、福利等。</p>
<h4 id="线程池场景题"><a href="#线程池场景题" class="headerlink" title="线程池场景题"></a>线程池场景题</h4><h6 id="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"><a href="#核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？" class="headerlink" title="核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？"></a>核心线程数5个，最大线程数设置了10个，队列也设置了10个，现在有并发6个任务来，线程池中有多少个任务？</h6><p>在您描述的线程池配置下，当有6个并发任务到来时，这些任务的处理情况如下：</p>
<ul>
<li>核心线程数是5，意味着线程池会首先创建5个线程来处理任务。</li>
<li>当第6个任务到来时，由于核心线程都在忙，线程池会将这个任务放入队列中，因为队列的大小也是10。</li>
</ul>
<p>所以，在这种情况下，线程池中会有6个任务：<strong>5个任务正在被5个核心线程处理，另外1个任务在队列中等待</strong>。线程池并没有达到最大线程数10个，因为当前的任务数量和队列容量还未超过核心线程数和队列的总和。</p>
<blockquote>
<p>在您提供的线程池配置下（核心线程数5个，最大线程数10个，队列容量10个），当6个并发任务到来时，线程池不会立即创建10个线程，原因如下：</p>
<ol>
<li><strong>核心线程数优先</strong>：线程池首先会使用核心线程来处理任务。核心线程数是5，所以前5个任务会分别由5个核心线程来处理。</li>
<li><strong>队列缓冲</strong>：当核心线程都在忙碌时，额外的任务会被放入队列中等待，而不是立即创建新的线程。您的队列容量是10，足以容纳当前的第6个任务。</li>
<li><strong>按需创建线程</strong>：线程池会根据任务的处理速度和队列的饱和度来决定是否需要创建超出核心线程数的线程。在您的例子中，尽管有6个并发任务，但队列还未满，因此没有必要创建额外的线程。</li>
<li><strong>最大线程数限制</strong>：最大线程数是线程池可以创建的线程数量的上限，但这并不意味着线程池会一开始就创建到这个上限。只有当队列满了，且还有新的任务到来时，线程池才会创建额外的线程（最多达到最大线程数）来处理这些任务。</li>
</ol>
<p>因此，在您的场景中，当6个并发任务到来时，线程池的操作是：</p>
<ul>
<li>5个核心线程各自处理一个任务。</li>
<li>第6个任务被放入队列中等待。</li>
</ul>
<p>此时，线程池中只有5个线程在运行，队列中有1个任务，总共6个任务。线程池不会创建额外的线程，因为当前的任务数量还未超过核心线程数和队列的总容量。只有当队列满了（即有10个任务在队列中），且还有新的任务到来时，线程池才会考虑创建额外的线程，直到达到最大线程数10个。</p>
</blockquote>
<h4 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h4><h6 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h6><ul>
<li>请求指定的资源。使用GET的目的是获取数据，</li>
<li>数据在URL中传输，通过将数据附在<strong>URL</strong>之后，以查询字符串的形式出现</li>
<li>由于数据在URL中可见，因此安全性较低，敏感数据不应通过过GET请求发送</li>
<li>URL长度限制通常在<strong>2000个字符</strong>左右，这意味着GET请求能够传输的数据有限</li>
<li><strong>可以被缓存</strong>，也会被浏览器保存在历史记录中</li>
<li>常用于<strong>信息查询、数据检索</strong>等操作.</li>
</ul>
<h6 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h6><ul>
<li>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在<strong>请求体</strong>中。</li>
<li>数据存储在请求体(HTTP消息主体)中，不会密在URL上</li>
<li>数据不会出现在URL中，相对更安全，适合传输敏感信息。</li>
<li>理论上<strong>没有大小限制</strong>，适用于传输大量数据.</li>
<li><strong>不会被缓存</strong>，且不会保存在浏觉器历史记录中</li>
<li>常用于<strong>数据提交、表单提交</strong>等操作</li>
</ul>
<p>请求行：请求类型 请求方法 url http版本1.1 老式1.0不支持长连接<br>请求头：key value<br>   <u>常见请求头</u>： 请求数据类型，restful基于json<br><strong>Content-Type</strong>：上传文件不用application 要用 multipart&#x2F;form-data”<br><strong>Host</strong>：指定请求的服务器的域名和端口号。<br><strong>User-Agent</strong>：包含发出请求的用户代理软件信息，通常包括浏览器类型和版本<br>请求体：get请求可以有请求体<br>响应：响应行 响应体 状态码 描述<br>  <u>常见响应头</u>：<strong>Content-Type</strong>：返回数据的格式   <strong>Content-Length</strong>：响应体的长度，以字节为单位</p>
<p>post请求也可以用问号的形式拼接到浏览器 也可以用路径参数</p>
<p>很大区别：get一般放在url后面 会展示url和后面参数 会暴露传参隐私  登录接口用post来做 有密码敏感信息<br>表单、密码、长数据用post 不过怕黑客抓包 相对来说安全<br>get请求后面传参的大小限制 理论上没有限制 只是浏览器厂商会有限制<br>get用来查询 post新增提交表单</p>
<h4 id="是否上传过图片"><a href="#是否上传过图片" class="headerlink" title="是否上传过图片"></a>是否上传过图片</h4><p>阿里云是最后存储的<br>完整的上传图片应该：<br><strong>前端</strong>要配合(表单 post提交)  <strong>Content-Type</strong>：上传文件不用application 要用 <strong>multipart&#x2F;form-data</strong>”  同一个请求能边上传图片和文本数据<br><strong>后端</strong>的操作：传到后端controller接收，有一个类multipart 专门接收二进制数据 图片视频等，有很多api → get input stream封装util 调用upload上传。中小型企业都用阿里云oss 因为要考虑容灾 地震 容易数据丢失，要考虑备份→集群，服务器有物理硬件上限(要有运维成本)，文件维护很专业交给专业的人。阿里云的机房在深圳，广州的人访问会比哈尔滨的更快。光纤受物理限制 越长越有损耗。大型运营商在全国各地都有机房，可以智能判断比如哈尔滨的就去访问黑龙江服务器。CSDN内容分发(收费)</p>
<h4 id="前端传过来的图片怎么设置图片大小-有没有什么办法？"><a href="#前端传过来的图片怎么设置图片大小-有没有什么办法？" class="headerlink" title="前端传过来的图片怎么设置图片大小 有没有什么办法？"></a>前端传过来的图片怎么设置图片大小 有没有什么办法？</h4><p>思考：为什么后端要限制前端图片传的大小？<br>大图片 + 多人上传，首先后端要读到jvm内存再二进制流给到阿里云，同时并发有可能超出OM的java内存大小<br>springboot yml加文件上传大小配置</p>
<pre><code class="yaml">spring:
  servlet:
    multipart:
      max-file-size: 10MB # 单个文件的最大大小
      max-request-size: 20MB # 整个请求的最大大小，包括多个文件的总和
</code></pre>
<blockquote>
<ol>
<li><strong>读取到 JVM 内存</strong>：<ul>
<li>当前端发送图片文件到后端时，后端服务器需要接收这个文件的数据。</li>
<li>在 Java 应用程序中，接收到的文件数据首先会被加载到 JVM（Java 虚拟机）的内存中。这是因为在 Java 应用程序中处理任何数据之前，数据必须先被加载到内存中。</li>
</ul>
</li>
<li><strong>二进制流给到阿里云</strong>：<ul>
<li>一旦文件数据被加载到 JVM 内存中，后端服务通常会将这些数据以二进制流的形式上传到云存储服务，比如阿里云的对象存储服务（OSS）。</li>
<li>这个过程涉及到数据的读取和写入操作，即从 JVM 内存读取数据，然后写入到云存储服务。</li>
</ul>
</li>
<li><strong>并发可能导致内存溢出</strong>：<ul>
<li>如果有多个用户同时上传大图片，后端服务器可能会同时处理多个上传请求。</li>
<li>每个上传请求都会占用一部分 JVM 内存。如果上传的图片非常大，且并发请求的数量很多，那么所有请求加起来的内存使用量可能会迅速增加。</li>
<li>如果内存使用量超过了 JVM 分配给应用程序的内存大小（即 OutOfMemory，简称 OOM），就会发生内存溢出错误。这种错误会导致应用程序崩溃或者变得不稳定。</li>
</ul>
</li>
<li><strong>限制上传大小的重要性</strong>：<ul>
<li>为了防止内存溢出错误，后端通常会限制上传文件的大小。</li>
<li>通过限制单个文件的最大大小（<code>max-file-size</code>）和整个请求的最大大小（<code>max-request-size</code>），可以有效地控制内存的使用，避免因大量并发上传大文件而耗尽服务器内存。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="你在里面主要负责哪方面的工作？"><a href="#你在里面主要负责哪方面的工作？" class="headerlink" title="你在里面主要负责哪方面的工作？"></a>你在里面主要负责哪方面的工作？</h4><p>我之前负责后端开发 也会参与一部分<strong>设计工作</strong><br>开发完会协助测试 和前端进行联调<br>和组长一起进行测试<br>和前后端的逻辑基本上都是可以的</p>
<h4 id="上家公司的离职原因，薪资多少，薪资结构"><a href="#上家公司的离职原因，薪资多少，薪资结构" class="headerlink" title="上家公司的离职原因，薪资多少，薪资结构"></a>上家公司的离职原因，薪资多少，薪资结构</h4><p>不要说一些面试官能挑刺的理由<br><del>发展前景？表明上家公司不好</del><br><del>太想进步？表名上家公司提供的技术不好 自己技术不好</del><br>在上家公司我学习了很多 成长了很多，个人发展原因 ，想要涨薪</p>
<pre><code class="java">// 来自AI的答案 仅供参考
我在上家公司学到了很多，但我觉得为了我的职业发展，我需要寻找一个能够提供更多成长机会和挑战的职位。我想要在[技能/领域]上进一步深耕，而贵公司的职位看起来非常符合我的职业规划；我在上家公司的年薪大约在6000到7000之间；我的薪资结构主要包括基本工资、每年两次的绩效奖金、股票期权以及一些标准福利，比如健康保险、退休金计划等。此外，公司还提供了一些额外的福利，比如灵活的工作时间和远程工作的机会
</code></pre>
<h6 id="简历公司"><a href="#简历公司" class="headerlink" title="简历公司"></a>简历公司</h6><p>上家公司<strong>如果问工作不好找 为什么不先找到再离职</strong>？<br>我在这一块想好好准备面试 但是上班的时间不好分配 我想专心去找工作<br>上家工作繁忙抽不出时间去准备 所以我想多多准备<br>若<strong>异地</strong>公司 → 万能理由：现在面的公司在哪家里人就在哪[地理位置要接近 精确到哪个城市] 异地很多都线下不方便先离职专心准备</p>
<h6 id="薪资多少"><a href="#薪资多少" class="headerlink" title="薪资多少"></a>薪资多少</h6><p>现在期望12k 上家最好保证**20%-30%**区间→8-9-10k(参考城市不同)</p>
<h6 id="薪资结构"><a href="#薪资结构" class="headerlink" title="薪资结构"></a>薪资结构</h6><p>基本工资(七八成)+绩效工资(20%-30%) 有公司先扣除 有的当月发<br>A 120%  S 150%-200%  C 80%</p>
<h6 id="你对上家公司的看法"><a href="#你对上家公司的看法" class="headerlink" title="你对上家公司的看法"></a>你对上家公司的看法</h6><p>不能贬低 要说优点 学习成长了很多 同事和领导都很照顾我</p>
<h6 id="什么时候能入职？"><a href="#什么时候能入职？" class="headerlink" title="什么时候能入职？"></a>什么时候能入职？</h6><p>三个工作日 到 一周之间</p>
<h6 id="你离职了-现在有多少个offer了？"><a href="#你离职了-现在有多少个offer了？" class="headerlink" title="你离职了 现在有多少个offer了？"></a>你离职了 现在有多少个offer了？</h6><p>不能说一个都没有</p>
<ul>
<li>我已经有2个offer 但是一定要表达对当前公司的期待 经过我的了解 我更喜欢贵公司的发展和文化</li>
<li>我也是刚刚开始找工作…</li>
</ul>
<h4 id="你可以接受加班吗"><a href="#你可以接受加班吗" class="headerlink" title="你可以接受加班吗"></a>你可以接受加班吗</h4><p>(必须完全接受全部加班 先拿到offer再说)</p>
<h4 id="Controller和RestController的区别"><a href="#Controller和RestController的区别" class="headerlink" title="Controller和RestController的区别"></a>Controller和RestController的区别</h4><p>@RestController &#x3D; @Controller + @ResponseBody</p>
<p>@Controller如果要返回JSON&#x2F;XML等格式的数据给客户端，必须显式的使用@ResponseBody注解将返回的对象转换为HTTP响应体内容。<br>@RestController 专门为构建RESTful Web服务设计的控制器。它简化了创建API的过程，因为所有方法默认都会将返回值直接写入HTTP响应体中作为JSON或XML格式的数据。</p>
<p>@Controller可以声明一个类为一个bean 控制器用<br>@ResponseBody 具体方法和类都可以 不是包装类和字符 都可以自动转成json数据格式 更符合restful风格</p>
<h4 id="在yaml文件中定义了一些参数，该怎么调用"><a href="#在yaml文件中定义了一些参数，该怎么调用" class="headerlink" title="在yaml文件中定义了一些参数，该怎么调用"></a><strong>在yaml文件中定义了一些参数，该怎么调用</strong></h4><ul>
<li>使用 @Value 注解，这是最直接的方式，适用于简单的属性注入。是bean的注解 <strong>用${key}还可以用#</strong><ul>
<li><code>$&#123;&#125;</code>：用于注入外部配置文件的值。它告诉Spring需要从环境变量、属性文件、系统属性等地方查找相应的值。</li>
<li><code>#&#123;&#125;</code>：用于执行SpEL（Spring Expression Language，Spring表达式语言）表达式。它允许你在注入值时执行一些简单的计算或逻辑。</li>
<li>如果在多个类里引用 配置多 杂乱  可以写个配置类写一堆的属性 提供get set方法 配置类.get获取到配置</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code class="yaml"># application.yml
server:
port: 8080

custom:
property: myCustomValue
number: 42
enabled: true
</code></pre>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class CustomComponent &#123;

 // 注入server.port属性
 @Value(&quot;$&#123;server.port&#125;&quot;)
 private String serverPort;

 // 注入custom.property属性
 @Value(&quot;$&#123;custom.property&#125;&quot;)
 private String customProperty;

 // 注入custom.number属性，并转换为int类型
 @Value(&quot;$&#123;custom.number&#125;&quot;)
 private int customNumber;

 // 注入custom.enabled属性，并转换为boolean类型
 @Value(&quot;$&#123;custom.enabled&#125;&quot;)
 private boolean customEnabled;

 // 使用SpEL表达式来计算值
 @Value(&quot;#&#123;$&#123;custom.number&#125; * 2&#125;&quot;)
 private int doubleCustomNumber;

 // 使用SpEL表达式来获取环境变量
 @Value(&quot;#&#123;systemProperties[&#39;os.name&#39;]&#125;&quot;)
 private String osName;

 // ... 使用注入的值进行操作

 // Getter和Setter方法
 // ...
&#125;
</code></pre>
</blockquote>
<ul>
<li>使用 @ConfigurationProperties 注解，通常会指定一个<strong>前缀</strong>（<strong>prefix</strong>），这个前缀用于指定配置文件中哪些属性应该被绑定到这个 Bean 上。然后确保主应用程序类或某个配置类上有<code>@EnableConfigurationProperties(AppProperties.class)</code> 注解<br><code>@ConfigurationProperties(prefix = &quot;prefix&quot;)</code></li>
</ul>
<h4 id="IOC和DI有了解过吗，它们的好处是什么"><a href="#IOC和DI有了解过吗，它们的好处是什么" class="headerlink" title="IOC和DI有了解过吗，它们的好处是什么"></a>IOC和DI有了解过吗，它们的好处是什么</h4><p><span style = "color:red">它们的目的是为了<strong>解耦</strong></span><br>IOC(控制反转)是Spring的两大核心之一，DI(依赖注入)<br>IOC把控制权交给spring容器<br>对象创建好之后 之间会有依赖关系 DI因此而生<br>实现方式：DI通常有四种实现方式</p>
<ul>
<li><p><strong>属性注入</strong> <del>注解注入</del></p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，用于自动装配 Bean。它可以用于字段、构造函数、方法或设置器上。当 Spring 容器启动时，它会自动查找并注入匹配的 Bean。<ul>
<li>偶尔有不影响程序运行的报错？写spring技术人员是根据jdk写，怕别人不用。</li>
</ul>
</li>
<li><code>@Resource</code> 是 Java 的注解[JDK的]，用于依赖注入，它也可以用于字段、方法或设置器上。与 <code>@Autowired</code> 不同的是，<code>@Resource</code> 默认通过名称进行匹配，如果未指定名称，则尝试通过类型进行匹配。</li>
<li>两者区别<ul>
<li>@Autowired 先根据<strong>属性类型</strong> 去容器里面找 如果找不到 再根据**属性名称[字段]**去找 如果实在找不到就会报错 [@Autowired永远不会放弃你的 尽其所能去帮你找]</li>
<li>@Resource 先根据<strong>属性名称</strong>去找 要么找不到 要么找到一个 找到就去注入 如果找不到 可以再根据<strong>属性类型</strong>去找 [类型找不到 或者 找到多个 也会报错]</li>
</ul>
</li>
</ul>
<h6 id="它俩最大的区别是什么？"><a href="#它俩最大的区别是什么？" class="headerlink" title="它俩最大的区别是什么？"></a>它俩最大的区别是什么？</h6><blockquote>
<p> <code>@Autowired</code> 更倾向于按<strong>类型注入</strong>，如果类型不唯一，则需要指定注入的名称。<br> <code>@Resource</code> 更倾向于按<strong>名称注入</strong>，如果没有指定名称，则尝试按类型注入。<br> 两者的不同在于默认的注入策略和如何处理不唯一的 Bean 定义。</p>
<p><code>@Autowired</code> 和 <code>@Resource</code> 最大的区别在于它们的默认注入策略和所依赖的注入机制：</p>
<ol>
<li><strong>默认注入策略</strong>：<ul>
<li><code>@Autowired</code>：默认是按照类型（Type）进行注入的。如果容器中存在多个相同类型的 Bean，则需要通过 <code>@Qualifier</code> 注解指定具体的 Bean 名称，或者通过设置 <code>@Autowired</code> 的 <code>required</code> 属性为 <code>false</code> 来允许没有找到匹配的 Bean 时不抛出异常。</li>
<li><code>@Resource</code>：默认是按照名称（Name）进行注入的。如果未指定名称，则尝试按类型进行注入。如果容器中存在多个相同类型的 Bean，且没有指定名称，可能会抛出异常。</li>
</ul>
</li>
<li><strong>依赖的注入机制</strong>：<ul>
<li><code>@Autowired</code>：是 Spring 框架提供的注解，因此它只能用于 Spring 管理的上下文中。</li>
<li><code>@Resource</code>：是 Java 的扩展包（javax.annotation）提供的注解，它是 JSR-250 规范的一部分，因此可以在任何实现了 JSR-250 规范的容器中使用，不仅限于 Spring。</li>
</ul>
</li>
</ol>
<p>简而言之，最大的区别在于 <code>@Autowired</code> 更侧重于<strong>类型匹配</strong>，而 <code>@Resource</code> 更侧重于<strong>名称匹配</strong>，并且 <code>@Resource</code> 是 Java 标准的一部分，具有更广泛的适用性。</p>
</blockquote>
</li>
<li><p><strong>构造函数注入</strong> [默认生成空参构造方法 若写有参构造原来无参会被覆盖 参数根据类型去找和<code>@Autowired</code>类型一样 可以写多个构造方法 如果去多个构造方法重载会报错 怎么办？加个<code>@Autowired[属性,构造方法,参数]都可加</code> <strong>不可多个方法都加@Autowired</strong>  反射会触发构造方法 @Bean &#x3D;&gt; new ] </p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;
    private DependencyB dependencyB;

    // 构造函数注入
    @Autowired
    public MyService(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // 另一个构造函数
    @Autowired
    public MyService(DependencyB dependencyB) &#123;
        this.dependencyB = dependencyB;
    &#125;

    // ... 其他方法 ...
&#125;
/////////////////////////////////////////////////////
在上面的例子中，由于有两个构造函数都使用了 @Autowired 注解，Spring 将无法确定使用哪一个构造函数，因此会抛出异常。要解决这个问题，你应该只在一个构造函数上使用 @Autowired 注解。
</code></pre>
</li>
<li><p>Set方法注入[原生spring 用xml去定义才有 SpringBoot没有这个注入 ]</p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // Set 方法注入
    @Autowired
    public void setDependencyA(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
在 Spring Boot 中，虽然不常用 XML 配置，但是你仍然可以通过注解来实现 Set 方法注入。
</code></pre>
</li>
<li><p><strong>普通方法注入</strong></p>
<pre><code class="java">public class MyService &#123;

    private DependencyA dependencyA;

    // 普通方法注入
    @Autowired
    public void init(DependencyA dependencyA) &#123;
        this.dependencyA = dependencyA;
    &#125;

    // ... 其他方法 ...
&#125;
//////////////////////////////////////////////////////
普通方法注入指的是在类中的任意非构造函数方法上使用 @Autowired 注解
</code></pre>
</li>
</ul>
<h4 id="测试过程有没有出现反复的困扰"><a href="#测试过程有没有出现反复的困扰" class="headerlink" title="测试过程有没有出现反复的困扰?"></a>测试过程有没有出现反复的困扰?</h4><p>客户<strong>需求频繁更改</strong><br>测试用例没有覆盖到<br>开发和测试环境未协调</p>
<p>太复杂的改动要先报备技术经理、项目经理</p>
<p>测试：自测 单元测试 专业人员</p>
<h4 id="公司使用哪些技术？"><a href="#公司使用哪些技术？" class="headerlink" title="公司使用哪些技术？"></a>公司使用哪些技术？</h4><p>后端：Redis RabbitMQ 搜索引擎 微服务常用组件 远程调用 统一网关 Springboot Springcloud MybatisPlus</p>
<h4 id="项目有多少个成员？"><a href="#项目有多少个成员？" class="headerlink" title="项目有多少个成员？"></a>项目有多少个成员？</h4><p>2前 8后 1测 1运维 1项目经理(小公司约13人左右) 要具体人数<br>自研公司？外包？</p>
<p><strong>自研公司</strong>：</p>
<ul>
<li>创业型自研公司：通常员工人数在10-50人之间，初期可能更少，只有几人到十几人。</li>
<li>成熟自研公司：员工人数可能从几十人到几百人甚至更多。</li>
</ul>
<p><strong>外包公司</strong>：</p>
<ul>
<li>小型外包公司：员工人数可能在10-50人之间。</li>
<li>中型外包公司：员工人数可能在50-200人之间。</li>
<li>大型外包公司：员工人数可能超过200人。</li>
</ul>
<h4 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h4><h5 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h5><p>jdk1.8之前底层结构是<strong>数组+链表</strong>(key+value)  数据结构通用的[键值对+哈希表的数据结构]<br>jdk1.8以后【数组+链表+红黑树】在解决哈希冲突时有了较大的变化，当<strong>链表长度</strong>大于阈值（默认为<strong>8</strong>）时且<strong>数组长度</strong>大于<strong>64</strong>时，将链表转化为红黑树，以减少搜索时间。扩容时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表。后期使用map获取值时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。<br>底层的地址运算出来 如果地址不一样计算出来的hashcode不一样，hashcode一般是数字[整数(±或0)] 通过key进行hashcode运算 对<strong>数组长度取模</strong> eg：任何整数去取模10   可以定位到value可以放在哪个桶下面</p>
<p>hashcode本身不同的对象算出来的hashcde值是相同的怎么办呢？<br>两个value不可能放在同一个桶 这就是<strong>hash冲突</strong>  如果数组长度是8 算出来一个hashcode值是8 和 16 此时取模余数相同这样的情况也是相同。所以此时应该用<strong>拉链法</strong>[小葡萄串]，即使桶一样 可以用指针一个个指，此时的链表是单向链表[linkedlist才是双向链表]。<br>在1.8后指出如果同一个桶的葡萄串太多了，此时要拿出数据，时间复杂度就是O(n)，如果没有很多就是O(1)数组的长度。红黑树的引入是解决链表过长的问题。<br>红黑树是树形的高级数据结构 时间复杂度O(logn)<br>二叉树在某些情况下会退化成链表 右子树永远比根节点大<br>红黑树会旋转自平衡[局部旋转达到平衡] 超过多少层会旋转 不至于退化成链表。</p>
<blockquote>
<p>拉链法（Chaining）是 Java 的 <code>HashMap</code> 在 JDK 1.8 之前以及之后都使用的一种解决哈希冲突的方法。在 JDK 1.8 之前，<code>HashMap</code> 的实现主要是基于拉链法，即使用链表来解决哈希冲突。当不同的键通过哈希函数计算出相同的哈希码，并且映射到同一个桶（bucket）时，这些键值对将以链表的形式存储在同一个桶中。</p>
<p>在 JDK 1.8 中，<code>HashMap</code> 的实现进行了改进，当链表的长度超过一定阈值（默认是 8）时，链表会被转换成红黑树。这是为了优化哈希表的性能，特别是当哈希冲突严重时，链表的查询效率会降低到 O(n)，而红黑树可以将查询效率提升到 O(log n)。</p>
<h3 id="红黑树如何避免哈希冲突"><a href="#红黑树如何避免哈希冲突" class="headerlink" title="红黑树如何避免哈希冲突"></a>红黑树如何避免哈希冲突</h3><p>红黑树本身并不直接解决哈希冲突，而是优化了哈希冲突发生后的数据结构。以下是红黑树在 <code>HashMap</code> 中是如何工作的：</p>
<ol>
<li><strong>哈希冲突</strong>：当不同的键产生相同的哈希码或经过取模运算后落在同一个桶时，就会发生哈希冲突。</li>
<li><strong>链表</strong>：在 JDK 1.8 中，如果桶中的元素少于一定数量（默认为 8），就会使用链表来存储这些元素。</li>
<li><strong>红黑树转换</strong>：当链表的长度超过阈值（默认为 8）时，并且数组的长度超过 64，链表会被转换成红黑树。这样可以减少查找时间，因为红黑树是一种自平衡的二叉搜索树。</li>
<li><strong>自平衡</strong>：红黑树通过旋转和重新着色操作来保持树的平衡，从而避免了二叉搜索树退化成链表的情况。</li>
</ol>
<h3 id="红黑树的旋转和自平衡"><a href="#红黑树的旋转和自平衡" class="headerlink" title="红黑树的旋转和自平衡"></a>红黑树的旋转和自平衡</h3><p>红黑树通过以下规则保持平衡：</p>
<ul>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li>
<li><strong>根节点</strong>：根节点是黑色的。</li>
<li><strong>红色规则</strong>：如果一个节点是红色的，则它的子节点必须是黑色的（不能有两个连续的红色节点）。</li>
<li><strong>黑色高度</strong>：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
<p>当插入或删除节点时，可能会破坏这些规则，此时红黑树会通过以下操作来重新平衡：</p>
<ul>
<li><strong>左旋转</strong>：当右子节点是红色，而左子节点是黑色或不存在时，进行左旋转。</li>
<li><strong>右旋转</strong>：当左子节点是红色，并且它的左子节点也是红色时，进行右旋转。</li>
<li><strong>重新着色</strong>：在某些情况下，通过改变节点颜色来维持红黑树的性质。</li>
</ul>
<p>通过这些操作，红黑树确保了即使在最坏的情况下，树的高度也不会超过 2log(n+1)，从而保证了 O(log n) 的时间复杂度。</p>
<p>总结来说，红黑树并不直接解决哈希冲突，而是优化了哈希冲突后的数据结构，使得即使在发生大量哈希冲突的情况下，<code>HashMap</code> 的性能也不会显著下降。</p>
</blockquote>
<h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>new的初始化 数组为空<br>当第一次put的时候才不会为空 为16<br>扩容因子为什么是0.75？hashmap不仅仅java 其他语言也有这种数据结构 但扩容因子可能不同，是通过大量的数学概率统计出的最好最平衡的值。达到12的时候会扩容成2倍<br>new一个hashmap可以指定数组长度为7 此时数组长度是8【hashmap的长度永远是2的幂次方 比你传入的长度永远大 且 是2的幂次方】 为什么2的幂次方？因为1.7要数组取模 怎么打这个符号 shift+5 &#x3D;&gt; %，1.8之后用了位运算，&gt;&gt;2 &lt;&lt;2 让你的取模运算更快。如果出现hash冲突会拉链 当它的<strong>数组长度</strong>大于64 并且 <strong>链表长度</strong>大于8时，当链表长度小于等于6临界值会变回来【为什么是6？避免频繁切换(离8太近) 链表 ←→ 红黑树[消耗性能]】</p>
<p>链表1.7之前是头插法 会产生一条首尾相接的死循环【并发情况<del>[但是hashmap线程不安全不会用在并发，要用ConcurrentHashMap]</del>一起put 且 同一个桶】<br>1.8之后是尾插法，并发情况下不会出现cpu飙高，</p>
<h5 id="HashSet底层数据结构"><a href="#HashSet底层数据结构" class="headerlink" title="HashSet底层数据结构"></a>HashSet底层数据结构</h5><p><strong>底层是包装了一个hashmap</strong>，无序 key不允许重复  value可重复<br>HashSet单列无序不重复的 key就是那个元素 value就是new了一个无意义的object对象</p>
<p>ArrayList和LinkedList不是线程安全的 用什么？</p>
<ul>
<li>Vector 读写都加锁。</li>
<li>CopyOnWriteArrayList 读不加锁 写加锁</li>
</ul>
<p>ConcurrentHashMap能存null吗？不允许使用 <code>null</code> 作为键，但是允许使用 <code>null</code> 作为值。<br>HashMap：null默认放在第一个桶下面 下标写死为0</p>
<h6 id="Hashcode相同equals一定相同吗？"><a href="#Hashcode相同equals一定相同吗？" class="headerlink" title="Hashcode相同equals一定相同吗？"></a>Hashcode相同equals一定相同吗？</h6><p><code>hashCode()</code> 相同不一定意味着 <code>equals()</code> 相同，但 <code>equals()</code> 相同则 <code>hashCode()</code> 必须相同。</p>
<ul>
<li><code>equals()</code> 方法用于判断两个对象是否逻辑上相等。</li>
<li><code>hashCode()</code> 方法用于返回对象的哈希码，这个哈希码通常用于哈希表的快速查找。</li>
</ul>
<p>key可以放复合对象，要注意要重写 hashcode()和equals() 如果不重写 new了的两个对象有可能会相同<br><code>&quot;重地&quot;</code> 和 <code>&quot;通话&quot;</code> 。<strong>计算hashcode会比equals更快</strong>，一个对象new出来后hashcode已经计算出来了。equals要比较每个对象值，<strong>所以先判断hashcode 再判断equals</strong>   重写：@Override 用属性里面的hashcode，user里面包含了复杂对象order 此时order也要重写。包装类已经重写了hashcode，要整个对象返回true才为正确的，要层层递进去判断。hashmap重写复杂对象就一定要重写那俩个   ∵ 是比较对象里的属性值<br>list 有序可重复单列<br>map 双列key不能重复value可重复  treemap是有序的<br>set 单列不重复无序 hashset 无序 treeset 有序 </p>
<p>&#x3D;&#x3D; 值 + 地址值<br>equals 是对象属性值是否一 一相等</p>
<h4 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h4><p>不安全的，可以使用<strong>ConcurrentHashMap<del>线程安全</del><strong>、Collections.synchronizedMap()、</strong>HashTable</strong><br><strong>线程安全</strong>：多线程对同一个数据进行增删改是否受到影响<br>怎么办？</p>
<ul>
<li><p><strong>加锁</strong></p>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>加锁为什么能解决线程安全问题？线程访问资源的先后顺序<br>多线程访问同一个数据 &#x3D;&gt; 多个线程访问同一个数据<br><strong>秒杀</strong> &#x3D;&gt;[思想] 1w个人买 对 100个库存进行扣减，只搞100个线程 把100个库存分成10份 其中每份有10个</p>
<pre><code class="java">初始化库存： 创建一个共享的库存计数器，初始值为100。
创建线程： 创建100个线程，每个线程在启动时分配到一个特定的库存分片。
扣减库存： 每个线程尝试扣减其分配到的库存分片中的一个商品。扣减操作必须是原子的，以确保线程安全。
同步机制： 使用适当的同步机制（如synchronized关键字、ReentrantLock等）来保护库存扣减操作，防止并发问题。
库存检查： 在扣减前，线程需要检查当前分片是否有剩余库存。如果没有，则线程可以终止或进行其他处理。
</code></pre>
<p>hashtable不管读写都会用synchronized加锁，并发一起来读都加锁 没必要，所以用了ConcurrentHashMap读不加锁 写加锁。<br>随着时间的推移，<code>Hashtable</code> 已经被认为是遗留代码，现代Java代码更倾向于使用 <code>HashMap</code>（非线程安全）或 <code>ConcurrentHashMap</code>（线程安全）。</p>
</li>
</ul>
<blockquote>
<p><strong>Synchronized</strong></p>
<pre><code class="java">public class SynchronizedExample &#123;
    public synchronized void synchronizedMethod() &#123;
        // 这里是同步代码块
        System.out.println(&quot;进入同步方法&quot;);
        // 执行一些操作
        System.out.println(&quot;退出同步方法&quot;);
    &#125;
&#125;
-----------------------------------------------------
public class SynchronizedBlockExample &#123;
    private final Object lock = new Object();

    public void synchronizedBlock() &#123;
        synchronized (lock) &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入同步代码块&quot;);
            // 执行一些操作
            System.out.println(&quot;退出同步代码块&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>ReentrantLock</strong></p>
<pre><code class="java">import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample &#123;
    private final ReentrantLock lock = new ReentrantLock();

    public void lockedMethod() &#123;
        lock.lock(); // 加锁
        try &#123;
            // 这里是同步代码块
            System.out.println(&quot;进入锁定的方法&quot;);
            // 执行一些操作
            System.out.println(&quot;退出锁定的方法&quot;);
        &#125; finally &#123;
            lock.unlock(); // 解锁
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="红黑树查询效率高的原因"><a href="#红黑树查询效率高的原因" class="headerlink" title="红黑树查询效率高的原因"></a>红黑树查询效率高的原因</h4><p>红黑树是一种自平衡的二叉搜索树，它通过特定的规则来保持树的平衡，这些规则确保了树的高度大约是log(n)<br>自平衡 局部旋转 </p>
<p>hashMap时间复杂度</p>
<ul>
<li>O(1)：不涉及到拉链</li>
<li>O(n)：拉链不是树</li>
<li>O(logn)：桶为红黑树</li>
</ul>
<h4 id="这个测试是你做的吗，还是你们团队去做的？"><a href="#这个测试是你做的吗，还是你们团队去做的？" class="headerlink" title="这个测试是你做的吗，还是你们团队去做的？"></a>这个测试是你做的吗，还是你们团队去做的？</h4><p>像自测的话是我自己去做的(测试用例、apifox)，然后交给专业测试人员</p>
<h4 id="团队是怎么协作的？"><a href="#团队是怎么协作的？" class="headerlink" title="团队是怎么协作的？"></a>团队是怎么协作的？</h4><p>像我们团队的话，有使用禅道来做我们的文档管理，需求管理和需求的变更控制，和工作的一个统计报表，大部分的协作任务都可以在禅道上完成，代码这一块我们是使用git来做一个代码管理和协作的。</p>
<h4 id="linux查看每个文件夹下的文件大小的命令"><a href="#linux查看每个文件夹下的文件大小的命令" class="headerlink" title="linux查看每个文件夹下的文件大小的命令"></a>linux查看每个文件夹下的文件大小的命令</h4><p>ls -lh</p>
<h4 id="linux查看文件夹大小的命令"><a href="#linux查看文件夹大小的命令" class="headerlink" title="linux查看文件夹大小的命令"></a>linux查看文件夹大小的命令</h4><p>du -sh<br>du -sh –all 隐藏<br>du -sh .&#x2F;* : 单独列出各子项占用的容量</p>
<h4 id="linux查看进程的命令，动态查看一个文件的最后100行的命令"><a href="#linux查看进程的命令，动态查看一个文件的最后100行的命令" class="headerlink" title="linux查看进程的命令，动态查看一个文件的最后100行的命令"></a>linux查看进程的命令，动态查看一个文件的最后100行的命令</h4><p>ps -ef<br>ps aux [查看所有用户的进程（包括其他用户的进程）：]<br>ps -ef | grep mysql</p>
<p><strong>动态</strong>：tail  -n 100 -f xxx 【-f → follow】<br><strong>静态</strong>：tail  -n 100 xxx</p>
<h4 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h4><h6 id="rm-x3D-romove"><a href="#rm-x3D-romove" class="headerlink" title="rm &#x3D; romove"></a>rm &#x3D; romove</h6><p>用于删除文件和目录<br> rm [-rf] name<br>-r(recursive递归)：将目录及目录中所有文件（目录）逐一删除，即递归删除<br>-f(force)：无需确认，直接删除</p>
<h6 id="rmdir-x3D-remove-directory"><a href="#rmdir-x3D-remove-directory" class="headerlink" title="rmdir &#x3D; remove directory"></a>rmdir &#x3D; remove directory</h6><p>它用于删除空目录。如果目录不为空，即目录中包含文件或其他子目录，rmdir 命令将无法删除该目录</p>
<h6 id="pwd-x3D-print-working-directory"><a href="#pwd-x3D-print-working-directory" class="headerlink" title="pwd &#x3D; print working directory"></a>pwd &#x3D; print working directory</h6><p>打印出当前工作目录的绝对路径。当你需要知道你在文件系统中的当前位置时，这个命令非常有用</p>
<h6 id="cp-x3D-copy"><a href="#cp-x3D-copy" class="headerlink" title="cp &#x3D; copy"></a>cp &#x3D; copy</h6><p>复制文件和目录。这个命令可以用来创建文件的副本或将文件从一个位置移动到另一个位置。<br>cp [-r] source dest<br>-r (recursive递归)：如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件</p>
<h6 id="mv-x3D-move"><a href="#mv-x3D-move" class="headerlink" title="mv &#x3D; move"></a>mv &#x3D; move</h6><p>为文件或目录改名、或将文件或目录移动到其他位置【移动 重命名 修改】</p>
<h6 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h6><p>用于搜索文本数据，特别是使用正则表达式来匹配指定的模式<br>查看特定进程的详细信息，例如进程名为 <u>mysql</u><br>ps -ef | grep mysql</p>
<h6 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar [tape archive]"></a>tar [tape archive]</h6><p>用于打包多个文件和目录到一个归档文件中，或者从归档文件中提取文件</p>
<h6 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h6><p>切换路径</p>
<h6 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h6><p>编辑文件</p>
<h6 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h6><p>查看文件[head]</p>
<h6 id="如何查日志"><a href="#如何查日志" class="headerlink" title="如何查日志"></a>如何查日志</h6><p>查看<code>/var/log/user.log</code>文件，并且想要跟踪用户 <u>name：<code>pcy</code></u> 的活动</p>
<p>tail -f &#x2F;var&#x2F;log&#x2F;user.log | grep “pcy”<br><span style = "color:red"><strong>高级专用使用</strong></span>：<code>awk</code> 可以用正则等一些逻辑操作去获取日志</p>
<blockquote>
<h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p><code>awk</code> 非常强大，可以用于执行复杂的文本分析和报告生成，<code>awk</code> 有许多内建函数，如 <code>length()</code>、<code>toupper()</code>、<code>tolower()</code> 等。</p>
<pre><code>awk &#39;&#123;print toupper($0)&#125;&#39; filename  # 将所有内容转换为大写
</code></pre>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre><code>awk &#39;&#123;if ($1 &gt; 100) print$1&#125;&#39; filename
</code></pre>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre><code>awk &#39;&#123;for (i=1; i&lt;=NF; i++) print $i&#125;&#39; filename
</code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre><code>awk &#39;&#123;count[$1]++&#125; END &#123;for (word in count) print word, count[word]&#125;&#39; filename
</code></pre>
</blockquote>
<h4 id="你们接口是如何让前端调用的"><a href="#你们接口是如何让前端调用的" class="headerlink" title="你们接口是如何让前端调用的"></a>你们接口是如何让前端调用的</h4><p>我们会在设计阶段提前设计好给前端 并行开发 前后端联调[本地ip端口告诉前端]</p>
<h4 id="接口文档怎么定下来的"><a href="#接口文档怎么定下来的" class="headerlink" title="接口文档怎么定下来的"></a>接口文档怎么定下来的</h4><p>根据页面原型、需求设计接口文档[后端自己写]，绝大部分后端看原型的出参入参 无太大需求和前端商量。【前端组件库】[若修改返回结构的时候] [按照数据结构修改] 需要听前端意见</p>
<h4 id="前端调用后端用的是什么请求方式"><a href="#前端调用后端用的是什么请求方式" class="headerlink" title="前端调用后端用的是什么请求方式"></a>前端调用后端用的是什么请求方式</h4><p><strong>WebSocket</strong>【基于长连接通讯】<br>HTTP</p>
<blockquote>
<p>前端开发中，以下是一些常见的使用场景：</p>
<ul>
<li>获取数据：使用GET请求。</li>
<li>提交表单或数据：使用POST请求。</li>
<li>更新资源：使用PUT或PATCH请求。</li>
<li>删除资源：使用DELETE请求。</li>
</ul>
<p>前端可以通过多种方式发起这些请求，例如：</p>
<ul>
<li>使用HTML表单（通常用于GET和POST请求）。</li>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或者更现代的<code>fetch</code> API来发起各种类型的HTTP请求。</li>
<li>使用各种前端框架和库（如React, Angular, Vue.js）中提供的封装好的HTTP服务。</li>
</ul>
</blockquote>
<h4 id="SpringBoot主要的一些注解？都有哪些，以及主要作用"><a href="#SpringBoot主要的一些注解？都有哪些，以及主要作用" class="headerlink" title="SpringBoot主要的一些注解？都有哪些，以及主要作用"></a><strong>SpringBoot主要的一些注解？都有哪些，以及主要作用</strong></h4><pre><code class="java">SpringBoot：
@SpringBootApplication [见↓↓]
@ConfigurationProperties：注解用于将外部配置（如来自properties文件、YAML文件或环境变量）绑定到JavaBean上。它的作用是将配置文件中的属性映射到JavaBean的属性上，这样就可以在应用程序中使用这些配置属性。
@SpringBootTest：用于测试 Spring Boot 应用，提供测试环境的支持
@EnableConfigurationProperties：启用对配置属性的支持，允许将配置文件中的属性注入到 bean 中。


Spring：
@Component 
@ComponentScan 
@Conditional 
</code></pre>
<pre><code class="java">@SpringBootApplication 是一个组合注解，它结合了以下三个注解的功能：
1. @SpringBootConfiguration: 表示这是一个Spring Boot配置类，它本质上是一个@Configuration注解，用于定义配置类，可以包含多个@Bean注解的方法。
2. @EnableAutoConfiguration: 告诉Spring Boot基于类路径设置、其他bean和各种属性设置来添加bean。例如，如果你添加了spring-webmvc和thymeleaf的依赖，这个注解就会自动配置你的应用程序为一个web应用程序。
3. @ComponentScan: 告诉Spring在包及其子包下扫描注解定义的组件（如@Component, @Service, @Repository等）。
</code></pre>
<h4 id="aop在项目中有没有使用？aop使用的一些注解及其功能"><a href="#aop在项目中有没有使用？aop使用的一些注解及其功能" class="headerlink" title="aop在项目中有没有使用？aop使用的一些注解及其功能"></a><strong>aop在项目中有没有使用？aop使用的一些注解及其功能</strong></h4><p>一定要描述项目场景，web使用aop打印操作日志、使用aop做数据脱敏(150***8786)<br><u>过滤器</u>是Servlet技术的一部分，它是Java EE规范的一部分<br><u>拦截器</u>是Spring MVC框架的一部分，用于在处理HTTP请求时拦截控制器方法调用。<br>AOP底层是动态代理设计模式，在<u>理论上</u>效果在一定程度上相同<br>过滤器拦截器一般拦截某个web的前后，在controller执行前后<br>AOP是万物皆可拦截、甚至接口和类都可以切，可以增强controller、service、mapper……</p>
<p><u>定义一个切面类 <code>@Aspect</code> 声明为切面类 + @Component</u><br><u>定义切点 <code>@Pointcut</code> 声明切点表达式</u></p>
<blockquote>
<p>eg：@AfterReturning(pointcut &#x3D; “execution(public String com.example.yourpackage.Controller.*(..))”, returning &#x3D; “result”)</p>
</blockquote>
<h6 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h6><ul>
<li>前置  @Before</li>
<li>后置  @After</li>
<li>返回  @AfterReturning</li>
<li>异常  @AfterThrowing</li>
<li>环绕  @Around</li>
</ul>
<h4 id="你在公司里负责的内容"><a href="#你在公司里负责的内容" class="headerlink" title="你在公司里负责的内容"></a><strong>你在公司里负责的内容</strong></h4><h4 id="想在controller访问完之后，想在aop实现之后再进行操作"><a href="#想在controller访问完之后，想在aop实现之后再进行操作" class="headerlink" title="想在controller访问完之后，想在aop实现之后再进行操作"></a><strong>想在controller访问完之后，想在aop实现之后再进行操作</strong></h4><p>UserThreadLocal 在执行完之后要 remove 出去，抛异常也会执行<br>@After 不管有无异常都会执行<br>@Around 结合try…catch…finally 里也可以达到同样效果</p>
<blockquote>
<p><code>@After</code>：这个注解用于定义一个通知（Advice），它在目标方法执行之后执行，无论目标方法执行的结果如何（成功或异常）。</p>
</blockquote>
<pre><code class="java">@Aspect
@Component
public class AroundFinallyAspect &#123;

    // 定义切点
    @Pointcut(&quot;execution(* com.example.yourpackage.controller..*(..))&quot;)
    public void controllerMethods() &#123;
    &#125;

    // 环绕通知
    @Around(&quot;controllerMethods()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;
        Object result = null;
        try &#123;
            // 在目标方法执行之前执行
            result = joinPoint.proceed(); // 执行目标方法
            // 在目标方法成功执行之后执行
        &#125; catch (Throwable e) &#123;
            // 在目标方法抛出异常时执行
            throw e; // 可以选择处理异常或者重新抛出
        &#125; finally &#123;
            // 无论目标方法是否成功执行或者是否抛出异常，这里的代码都会执行
            performFinallyAction();
        &#125;
        return result;
    &#125;

    private void performFinallyAction() &#123;
        // 在这里放置最终要执行的代码
    &#125;
&#125;

--------------------------------------------------------------------------------
// 后置通知
    @After(&quot;execution(* com.example.service.*.*(..))&quot;)
    public void afterAdvice(JoinPoint joinPoint) &#123;
        // 在目标方法执行之后执行的逻辑
    &#125;

    // 返回后通知
    @AfterReturning(pointcut = &quot;execution(* com.example.service.*.*(..))&quot;, returning = &quot;result&quot;)
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) &#123;
        // 在目标方法成功执行并返回结果后执行的逻辑
    &#125;

在第一个例子中，你直接在@After注解中指定了切点表达式，因此不需要额外的pointcut属性。

对于@AfterReturning注解，它不仅需要在目标方法执行之后执行通知，还需要访问目标方法的返回值。因此，@AfterReturning注解有一个额外的pointcut属性，用于指定切点表达式。此外，@AfterReturning注解还有一个returning属性，用于指定一个参数名，该参数将接收目标方法的返回值
</code></pre>
<p>@AfterReturning：在方法执行后返回结果后执行通知。【如果有异常不会处理】</p>
<h4 id="你们这个项目怎么技术选型的"><a href="#你们这个项目怎么技术选型的" class="headerlink" title="你们这个项目怎么技术选型的"></a>你们这个项目怎么技术选型的</h4><p>我进到项目中很多已经确认下来的 一般由组长确定了</p>
<h6 id="那你自己怎么想的？-开放性问题"><a href="#那你自己怎么想的？-开放性问题" class="headerlink" title="那你自己怎么想的？[开放性问题]"></a>那你自己怎么想的？[开放性问题]</h6><p>选xxx技术 网上资料&#x2F;备书 比较多可以参考[用的人多]<br>学习成本[框架厉害但上手复杂不好用]<br>社区的活跃度[官网持续更新版本 框架会不断发展]</p>
<h4 id="你处于后端的什么位置"><a href="#你处于后端的什么位置" class="headerlink" title="你处于后端的什么位置"></a>你处于后端的什么位置</h4><p>初级 中级 高级<br>中级 骨干开发位置[协助组长完成]<br>中高级 完成设计类</p>
<h4 id="你对你的职业规划是什么"><a href="#你对你的职业规划是什么" class="headerlink" title="你对你的职业规划是什么"></a>你对你的职业规划是什么</h4><p>讲实际的话<br>想成为高级开发&#x2F;某个领域的专家<br>提前了解公司领域，有备而来</p>
<h4 id="java基本类型"><a href="#java基本类型" class="headerlink" title="java基本类型"></a>java基本类型</h4><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20241222141950707.png" alt="image-20241222141950707" style="zoom:200%;" />

<p>short   可以占两个字节   可以用16位<br>int        可以占四个字节    -21亿 ~ 21亿<br>long     可以占八个字节   天文数字<br>float      可以占四个字节 0.2F&#x2F;f<br>double  可以占八个字节 0.2D&#x2F;d</p>
<p>float double尽量不要进行运算 ，在Java中进行金钱运算时，应当特别注意浮点数的精度问题，因为浮点数（如<code>float</code>和<code>double</code>）在表示某些数值时可能会丢失精度，这对于需要精确计算的金融计算来说是非常不合适的。</p>
<p>1.金钱转成分 向下取整<br>2.BigDecimal</p>
<p>ASCII码占1个字节 → Unicode字符占2个字节【有些汉字存不了】→ UTF-8占1-3个字节[灵活可变]<br>在我们性能中一般走Unicode编码性能更高一点 在网络中&#x2F;存入磁盘Unicode转成ASCII码</p>
<p>jdk？之后 jdk开始存储大量英文和数字 String类也作了更新 不是基于基本数据类型 而是基于byte数组</p>
<pre><code class="java">在Java的早期版本中（例如JDK 1.4及之前版本），String类内部确实使用char数组来存储字符串数据。每个char在Java中占用16位（2个字节），这意味着不管存储的是英文字符还是数字，每个字符都会占用2个字节的内存空间。

从JDK 5开始，Java平台引入了一些变化，但String类的内部表示仍然基于char数组。直到JDK 6和JDK 7，String类的内部表示并没有改为基于byte数组。

真正发生变化的是在JDK 9中，String类内部表示从char数组转变为byte数组加上一个编码标识（coder），这种改变是为了更有效地存储只有ASCII字符的字符串。ASCII字符只需要一个字节来表示，因此使用byte数组可以节省内存空间。当字符串包含Unicode字符时，String类可能会使用更多的编码方式，例如LATIN1或UTF-16。
</code></pre>
<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)</p>
<ol>
<li>beforeCreate创建前</li>
<li>created创建后</li>
<li>beforeMount载入前</li>
<li>mounted挂载完成</li>
<li>beforeUpdate数据更新前</li>
<li>updated数据更新后</li>
<li>beforeUnmount组件销毁前</li>
<li>unmounted组件销毁后</li>
</ol>
<h4 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h4><p>不是，是<code>java.lang</code>下的类</p>
<blockquote>
<p>String 在 Java 中并不是基础类型，而是一个引用类型。因为 String 是一个类，所以它是引用类型，意味着当我们声明一个 String 变量时，你实际上是指向一个 String 对象的引用</p>
</blockquote>
<pre><code class="java">String 的特性
不可变性：String 对象一旦创建就不能被修改。任何改变 String 内容的操作都会创建一个新的 String 对象。
线程安全：由于 String 的不可变性，它们是线程安全的，可以自由地在多个线程之间共享。
字符串池：为了提高性能和减少内存使用，Java 为 String 提供了字符串常量池（String Pool）。当创建一个新字符串时，如果字符串池中已经存在相同内容的字符串，则会返回池中的实例，而不是创建新的对象。
</code></pre>
<h4 id="java集合中list和set的区别"><a href="#java集合中list和set的区别" class="headerlink" title="java集合中list和set的区别?"></a>java集合中list和set的区别?</h4><p>都是接口 某个实现类</p>
<p>单链 有顺序 可重复 有索引[有下标]<br>单链 不可重复 无索引[无下标] 不能说是无序 因为TreeSet有序 HashSet就是无序的</p>
<h4 id="做了几年开发呢-实际几个项目"><a href="#做了几年开发呢-实际几个项目" class="headerlink" title="做了几年开发呢? 实际几个项目?"></a>做了几年开发呢? 实际几个项目?</h4><p>三年[初中级] → 四~五个项目</p>
<h4 id="你觉得敲代码最重要的是什么"><a href="#你觉得敲代码最重要的是什么" class="headerlink" title="你觉得敲代码最重要的是什么?"></a>你觉得敲代码最重要的是什么?</h4><p><strong>理解需求</strong>、<strong>前期设计工作</strong>[数据库、接口 → 流程图(思路清晰)]、<strong>编码阶段</strong>[考虑方法封装、注释、考虑代码后期和维护性(设计模式 → 可维护性+扩展性)]、<strong>编码风格</strong>[阿里巴巴规范]</p>
<h4 id="你的项目有上线吗-多少人进行开发-你主要负责后端吗"><a href="#你的项目有上线吗-多少人进行开发-你主要负责后端吗" class="headerlink" title="你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?"></a>你的项目有上线吗? 多少人进行开发? 你主要负责后端吗?</h4><p>有，介绍一下项目组成结构，是的[再问再回答]</p>
<h4 id="SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件"><a href="#SpringBoot的自动装配原理-启动过程中的一部分-SpringBoot启动原理-amp-amp-如何内嵌外部原件" class="headerlink" title="SpringBoot的自动装配原理[启动过程中的一部分]SpringBoot启动原理&amp;&amp;如何内嵌外部原件"></a><span style = "color:red"><strong>SpringBoot的自动装配原理</strong></span>[启动过程中的一部分]<del>SpringBoot启动原理&amp;&amp;如何内嵌外部原件</del></h4><p>Spring Boot的自动装配原理是基于Spring框架的IoC（控制反转）和DI（依赖注入）的核心概念，并结合了一系列的约定和条件注解来实现配置类的自动加载和Bean的自动注册</p>
<blockquote>
<ol>
<li><strong>启动类</strong>：Spring Boot 应用通常有一个带有 <code>@SpringBootApplication</code> 注解的启动类。这个注解是一个组合注解，它包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</li>
<li><strong>@EnableAutoConfiguration</strong>：这个注解是自动装配的关键。它告诉 Spring Boot 根据类路径下的类、Bean 的定义以及各种属性设置，自动配置 Spring 应用。这个注解会导入 <code>AutoConfigurationImportSelector</code> 类，该类会读取所有 <code>spring.factories</code> 文件中的 <code>EnableAutoConfiguration</code> 条目，并将它们作为配置类导入。</li>
<li><strong>条件化配置</strong>：Spring Boot 使用 <code>@Conditional</code> 注解及其一系列的派生注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等）来确保只有在满足特定条件时，配置类或 Bean 才会被创建。</li>
<li><strong>配置类</strong>：自动装配是通过一系列的配置类来实现的，这些配置类包含了 <code>@Bean</code> 方法，用于创建和配置 Spring 容器中的 Bean。</li>
</ol>
</blockquote>
<h6 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h6><pre><code class="xml">&lt;!-- Maven项目的依赖示例 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.xxx&lt;/groupId&gt;
    &lt;artifactId&gt;xxx-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>三大优点</strong>：依赖Maven特性[依赖传递]  自动配置  内嵌Tomcat<br>Spring Boot的自动装配原理是<br>在<code>src/main/resources/META-INF</code>目录下创建<code>spring.factories</code>文件，添加自动配置类的全限定名<br>我们可以在-info定义spring.factories位于<code>META-INF</code>目录下，Spring Boot使用它来发现和加载自动配置类。</p>
<p><strong>配置类扫描</strong>: 通过<code>@SpringBootApplication</code>注解，Spring Boot会触发对<code>@EnableAutoConfiguration</code>注解的处理，该注解会查找<code>spring.factories</code>文件中定义的自动配置类。</p>
<p>Maven里面写test类 用configuration声明 写很多的test类 但是我可以自己写test类然后调不同的方法 <strong>应该怎么办</strong>？@Conditional[Spring的注解] → 做成非常灵活的 如果没有就用自己写的 </p>
<h4 id="Spring里面的事务传播行为"><a href="#Spring里面的事务传播行为" class="headerlink" title="Spring里面的事务传播行为"></a><strong>Spring里面的事务传播行为</strong></h4><p>在Spring框架中，事务传播行为定义了事务方法之间的调用关系，即一个事务方法被另一个事务方法调用时，事务应该如何传播。</p>
<ol>
<li><span style = "color:blue"><u><strong>REQUIRED</strong>（默认值）</u></span> required<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
</ul>
</li>
<li><strong>SUPPORTS</strong> supports<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
</ul>
</li>
<li><strong>MANDATORY</strong> mandatory<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
</ul>
</li>
<li><strong>REQUIRES_NEW</strong> requires_new<ul>
<li>创建一个新的事务，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NOT_SUPPORTED</strong> not_supported<ul>
<li>以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
</ul>
</li>
<li><strong>NEVER</strong> never<ul>
<li>以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ul>
</li>
<li><strong>NESTED</strong> nested<ul>
<li>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则行为类似于<code>REQUIRED</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>REQUIRED：通常用于方法需要在一个事务中运行，但如果已经有一个事务在运行，那么它应该加入这个事务。<br>SUPPORTS：用于方法不需要事务上下文，但如果已经在一个事务中，它也可以在这个事务中运行。<br>MANDATORY：用于方法必须在事务中运行，如果没有事务，则会抛出异常。<br><strong>REQUIRES_NEW</strong>：用于方法必须在自己的新事务中运行，即使当前已经有一个事务在运行。<br>[一般适用于不管有没有抛出异常 都要记录某些操作日志 不能在同一个类里底层是动态代理]<br>[如果a()和b()方法在同一个类中，并且a()直接调用b()，那么Spring的事务代理无法拦截这个内部调用，因此b()的REQUIRES_NEW事务传播行为不会生效。这是因为内部方法调用不会通过代理，而是直接在同一个对象实例上调用。]</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
public class MyService &#123;

@Autowired
private MyService self; // 注入自身代理实例

public void methodA() &#123;
  // ... 业务逻辑 ...

  self.methodB(); // 通过代理实例调用，事务注解将生效
&#125;

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() &#123;
  // ... 业务逻辑 ...
&#125;
&#125;
</code></pre>
<p>NOT_SUPPORTED：用于方法不应该在事务中运行，如果有一个事务在运行，它将被挂起。<br>NEVER：用于方法绝对不应该在事务中运行，如果有一个事务在运行，将抛出异常。<br>NESTED：用于方法应该在嵌套事务中运行，嵌套事务可以独立于外部事务进行提交或回滚</p>
</blockquote>
<h4 id="用过Spring的事务吗"><a href="#用过Spring的事务吗" class="headerlink" title="用过Spring的事务吗"></a><strong>用过Spring的事务吗</strong></h4><p>一组数据库的增删改操作<br><strong>声明式事务管理</strong>：这是Spring推荐的用法，它通过使用注解（如<code>@Transactional</code>）或基于XML的配置来声明事务边界。底层基于AOP实现动态代理增强方法<br><strong>编程式事务管理</strong>：允许你通过编程的方式直接管理事务，通常使用<code>TransactionTemplate</code>或者直接使用底层的<code>PlatformTransactionManager</code>。</p>
<blockquote>
<h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><pre><code class="java">// 你需要在 Spring 配置中启用事务注解支持：
@Configuration
@EnableTransactionManagement
public class SpringConfig &#123;

    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) &#123;
        return new JpaTransactionManager(entityManagerFactory);
    &#125;
    
    // ... 其他配置
&#125;


// 然后，你可以在服务层的方法上使用 @Transactional 注解来声明事务边界：
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AccountService &#123;

    @Autowired
    private AccountRepository accountRepository;

    @Transactional
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
        // 执行转账操作，比如：
        Account fromAccount = accountRepository.findById(fromAccountId).orElseThrow(...);
        Account toAccount = accountRepository.findById(toAccountId).orElseThrow(...);
        
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        toAccount.setBalance(toAccount.getBalance().add(amount));
        
        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        
        // 如果这里发生异常，Spring 将回滚事务
    &#125;
&#125;
</code></pre>
<h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

@Service
public class AccountService &#123;

    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) &#123;
        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
                try &#123;
                    // 执行转账操作，与声明式事务管理中的操作相同
                    // ...
                &#125; catch (Exception e) &#123;
                    status.setRollbackOnly(); // 如果发生异常，标记事务回滚
                &#125;
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="你熟悉的技术栈有哪些，用了哪些"><a href="#你熟悉的技术栈有哪些，用了哪些" class="headerlink" title="你熟悉的技术栈有哪些，用了哪些?"></a>你熟悉的技术栈有哪些，用了哪些?</h4><p>SpringBoot Vue Git Maven MyBatis……</p>
<h4 id="解决难点的决策有和用户沟通的吗？"><a href="#解决难点的决策有和用户沟通的吗？" class="headerlink" title="解决难点的决策有和用户沟通的吗？"></a>解决难点的决策有和用户沟通的吗？</h4><p>有过沟通 让他们了解一下我们的方案</p>
<h6 id="万一用户听不懂怎么办？"><a href="#万一用户听不懂怎么办？" class="headerlink" title="万一用户听不懂怎么办？"></a>万一用户听不懂怎么办？</h6><p>我会用一些更加直白通俗的语言让用户理解我们的方案</p>
<h6 id="用户不接受这个方案怎么办？"><a href="#用户不接受这个方案怎么办？" class="headerlink" title="用户不接受这个方案怎么办？"></a>用户不接受这个方案怎么办？</h6><p>我们可以提供不止一个方案 或者 提供他提的方案 综合一下各种方案告诉其优缺点(站在我们的专业角度意见)和风险 让客户明知 让其选择</p>
<h4 id="通常一般怎么学习的？最近在研究什么技术？"><a href="#通常一般怎么学习的？最近在研究什么技术？" class="headerlink" title="通常一般怎么学习的？最近在研究什么技术？"></a>通常一般怎么学习的？<del>最近在研究什么技术？</del></h4><p>想面试的目的 要給公司带来一些好的<br>一般<strong>以公司的实际项目中为切入点</strong>去学习会更有效率</p>
<h5 id="学习一个新的技术大概要多久？"><a href="#学习一个新的技术大概要多久？" class="headerlink" title="学习一个新的技术大概要多久？"></a>学习一个新的技术大概要多久？</h5><p>1-2天 首先看官网 这个技术是解决哪些 看我们的项目需要哪些技术切入点能引用 然后去专门针对这个技术功能点去学习快速上手的接口文档</p>
<h4 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h4><ul>
<li><strong>主数据基于内存操作</strong></li>
<li><strong>Redis是单线程</strong>[操作数据的线程]，避免上下文的频繁切换<del>整个redis不是就一个线程</del></li>
<li><strong>底层基于C语言实现</strong> <del>得益于底层良好的数据结构[]</del></li>
<li><strong>基于<span style = "color:red">非阻塞</span>的IO</strong><del>提升IO读写性能，NIO,BIO,AIO…</del></li>
</ul>
<h6 id="Java四大杀手"><a href="#Java四大杀手" class="headerlink" title="Java四大杀手"></a>Java四大杀手</h6><p><u>集合数据结构     jvm    并发编程    网络IO</u></p>
<blockquote>
<p>非阻塞IO（Non-blocking I&#x2F;O）是一种IO模型，它允许程序在执行IO操作时不会被阻塞，即程序可以在发起IO请求后继续执行其他任务，而不需要等待IO操作完成。以下是关于非阻塞IO的一些关键点：</p>
<h3 id="非阻塞IO的特点："><a href="#非阻塞IO的特点：" class="headerlink" title="非阻塞IO的特点："></a>非阻塞IO的特点：</h3><ol>
<li><strong>异步操作</strong>：非阻塞IO操作通常是异步的，意味着程序发起IO请求后，不需要等待IO操作完成，而是可以立即返回去做其他事情。</li>
<li><strong>事件驱动</strong>：非阻塞IO往往与事件驱动模型结合使用，程序可以通过监听器来响应IO事件（如数据可读、连接可写等）。</li>
<li><strong>减少等待时间</strong>：由于程序在等待IO操作完成时不会阻塞，它可以继续处理其他任务，从而提高了程序的响应性和吞吐量。</li>
</ol>
<h3 id="非阻塞IO的实现方式："><a href="#非阻塞IO的实现方式：" class="headerlink" title="非阻塞IO的实现方式："></a>非阻塞IO的实现方式：</h3><ul>
<li><strong>NIO（New I&#x2F;O）</strong>：在Java中，NIO提供了一种非阻塞的IO方式，使用<code>Selector</code>来管理多个通道（Channel）上的IO事件。</li>
<li><strong>AIO（Asynchronous I&#x2F;O）</strong>：AIO是另一种非阻塞IO模型，它允许程序完全异步地执行IO操作，通常是通过完成端口（Completion Ports）来实现。</li>
<li><strong>BIO（Blocking I&#x2F;O）</strong>：与非阻塞IO相对的是阻塞IO，其中每个IO操作都会阻塞调用线程，直到操作完成。</li>
</ul>
<h3 id="非阻塞IO的优势："><a href="#非阻塞IO的优势：" class="headerlink" title="非阻塞IO的优势："></a>非阻塞IO的优势：</h3><ul>
<li><strong>资源利用率</strong>：非阻塞IO可以更有效地利用系统资源，因为单个线程可以处理多个IO操作。</li>
<li><strong>高并发处理</strong>：在处理大量并发连接时，非阻塞IO可以显著提高系统的并发处理能力。</li>
</ul>
<h3 id="非阻塞IO在Redis中的应用："><a href="#非阻塞IO在Redis中的应用：" class="headerlink" title="非阻塞IO在Redis中的应用："></a>非阻塞IO在Redis中的应用：</h3><ul>
<li><strong>单线程模型</strong>：Redis是一个基于内存的键值存储数据库，它使用单线程模型来处理所有客户端请求。由于操作是基于内存的，速度非常快，而单线程避免了上下文切换的开销。</li>
<li><strong>非阻塞IO和多路复用</strong>：尽管Redis是单线程的，但它使用非阻塞IO和多路复用技术（如epoll或kqueue）来同时处理多个IO流。这意味着Redis可以在等待IO操作（如网络响应）时不阻塞，从而可以继续处理其他请求。</li>
<li><strong>高性能</strong>：Redis的非阻塞IO和多路复用机制使得它即使在面对大量并发请求时也能保持高性能。</li>
</ul>
</blockquote>
<h4 id="redis的数据类型以及使用场景分别是什么"><a href="#redis的数据类型以及使用场景分别是什么" class="headerlink" title="redis的数据类型以及使用场景分别是什么"></a>redis的数据类型以及使用场景分别是什么</h4><h6 id="写入依赖"><a href="#写入依赖" class="headerlink" title="写入依赖"></a>写入依赖</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- Use the latest version available --&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p><strong>String</strong>：存储对象信息(转JSON)<br>将用户信息序列化为JSON字符串后存储。</p>
<pre><code class="json">SET user:1000 &#39;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:30,&quot;email&quot;:&quot;alice@example.com&quot;&#125;&#39;

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisStringExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.set(&quot;user:1000&quot;, &quot;&#123;\&quot;name\&quot;:\&quot;Alice\&quot;,\&quot;age\&quot;:30,\&quot;email\&quot;:\&quot;alice@example.com\&quot;&#125;&quot;);
        String userInfo = jedis.get(&quot;user:1000&quot;);
        System.out.println(userInfo);
        
        jedis.incr(&quot;visits&quot;);
        long visits = jedis.get(&quot;visits&quot;);
        System.out.println(&quot;Visits: &quot; + visits);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>List</strong>：链表，查询记录的缓存、列表，朋友圈，微博，队列数据结构<br>可以将数据库查询结果缓存为一个列表</p>
<pre><code class="mysql"># 查询记录的缓存
LPUSH recent:queries &quot;SELECT * FROM users WHERE age &gt; 30&quot;

# 消息队列
使用List作为消息队列，生产者将消息LPUSH到列表，消费者从列表中RPOP消息
LPUSH message:queue &quot;message1&quot;
RPOP message:queue

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisListExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.lpush(&quot;recent:queries&quot;, &quot;SELECT * FROM users WHERE age &gt; 30&quot;);
        String query = jedis.rpop(&quot;recent:queries&quot;);
        System.out.println(&quot;Recent Query: &quot; + query);
        
        jedis.close();
    &#125;
&#125;
w
</code></pre>
</li>
<li><p><strong>Hash</strong>：获取局部属性，小key不能设置过期时间<del>Hash是一个键值对集合，适合存储对象</del><br>Hash是一个键值对集合，适合存储对象</p>
<pre><code class="mysql">HSET user:1000 name &quot;Alice&quot; age 30 email &quot;alice@example.com&quot;
HGET user:1000 name

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisHashExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;name&quot;, &quot;Alice&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;age&quot;, &quot;30&quot;);
        jedis.hset(&quot;user:1000&quot;, &quot;email&quot;, &quot;alice@example.com&quot;);
        
        String name = jedis.hget(&quot;user:1000&quot;, &quot;name&quot;);
        System.out.println(&quot;Name: &quot; + name);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>Set</strong>：无序不可重复的，收藏，点赞，社交场景，聚合计算(∩∪差集)<br>社交场景：使用Set来存储用户的关注列表，确保关注关系的唯一性。</p>
<pre><code class="mysql">SADD user:1000:following 2000 3000 4000

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;

public class RedisSetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.sadd(&quot;user:1000:following&quot;, &quot;2000&quot;, &quot;3000&quot;, &quot;4000&quot;);
        Set&lt;String&gt; following = jedis.smembers(&quot;user:1000:following&quot;);
        System.out.println(&quot;Following: &quot; + following);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>聚合计算：计算两个用户的共同关注。</p>
<pre><code class="java">SINTER user:1000:following user:2000:following
</code></pre>
</li>
<li><p><strong>Zset</strong>：排序场景，排行榜，姓名排序</p>
<p>排行榜：根据用户得分来存储排行榜</p>
<pre><code class="mysql">ZADD leaderboard 1000 Alice 950 Bob 900 Charlie
ZRANGE leaderboard 0 -1 WITHSCORES

----------------------------------------------------------------------
import redis.clients.jedis.Jedis;
import java.util.Set;

public class RedisZsetExample &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 1000, &quot;Alice&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 950, &quot;Bob&quot;);
        jedis.zadd(&quot;leaderboard&quot;, 900, &quot;Charlie&quot;);
        
        Set&lt;String&gt; leaderboard = jedis.zrange(&quot;leaderboard&quot;, 0, -1);
        System.out.println(&quot;Leaderboard: &quot; + leaderboard);
        
        jedis.close();
    &#125;
&#125;
</code></pre>
<p>姓名排序：存储学生姓名和成绩，并按成绩排序。</p>
<pre><code class="mysql">ZADD students 92 John 85 Mary 88 Alice
ZRANGE students 0 -1 WITHSCORES
</code></pre>
</li>
</ul>
<p>分布式锁都可以用。Redisson是Redis的儿子，底层为Hash</p>
<h4 id="redis数据过期策略"><a href="#redis数据过期策略" class="headerlink" title="redis数据过期策略"></a>redis数据过期策略</h4><ul>
<li><p>惰性删除：键过期时不会立即删除，当访问该键时判断是否过期，如果过期就删除<br><strong>惰性删除策略是在访问键时检查键是否过期</strong>，如果过期则删除。</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class LazyExpiration &#123;
    private Jedis jedis;

    public LazyExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public String getKey(String key) &#123;
        // 检查键是否存在
        if (!jedis.exists(key)) &#123;
            return null;
        &#125;

        // 检查键是否过期
        if (isExpired(key)) &#123;
            // 如果键已过期，则删除它
            jedis.del(key);
            return null;
        &#125;

        // 如果键未过期，返回键的值
        return jedis.get(key);
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public static void main(String[] args) &#123;
        LazyExpiration lazyExpiration = new LazyExpiration();
        String value = lazyExpiration.getKey(&quot;myKey&quot;);
        if (value != null) &#123;
            System.out.println(&quot;Key value: &quot; + value);
        &#125; else &#123;
            System.out.println(&quot;Key does not exist or has expired.&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>定时删除：设置键的过期时间，当键过期时，立即删除</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class ActiveExpiration &#123;
    private Jedis jedis;

    public ActiveExpiration() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void activeExpireCycle() &#123;
        // 随机检查一定数量的键
        for (int i = 0; i &lt; 10; i++) &#123;
            String key = jedis.randomKey();
            if (key != null &amp;&amp; isExpired(key)) &#123;
                // 如果键已过期，则删除它
                jedis.del(key);
            &#125;
        &#125;
    &#125;

    private boolean isExpired(String key) &#123;
        // 获取键的剩余生存时间，如果返回值大于0，则键未过期
        return jedis.ttl(key) == -2;
    &#125;

    public void runPeriodicTask() &#123;
        // 定时任务，按照一定的频率运行
        while (true) &#123;
            activeExpireCycle();
            try &#123;
                Thread.sleep(1000); // 每秒执行一次
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        ActiveExpiration activeExpiration = new ActiveExpiration();
        // 启动定时任务
        activeExpiration.runPeriodicTask();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h6 id="高薪冲刺-→-定时删除详细策略"><a href="#高薪冲刺-→-定时删除详细策略" class="headerlink" title="高薪冲刺 → 定时删除详细策略"></a><span style = "color:red">高薪冲刺 → 定时删除详细策略</span></h6><blockquote>
<p>要扫描所有的定期任务删除 有策略可以设置阈值</p>
</blockquote>
<h4 id="啥时候离职的？半个月太长了"><a href="#啥时候离职的？半个月太长了" class="headerlink" title="啥时候离职的？半个月太长了"></a>啥时候离职的？<del>半个月太长了</del></h4><p>刚刚离职 也是刚刚开始投</p>
<h4 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h4><p>主要负责后端工作，协助测试，运维上线</p>
<h4 id="你对前端有了解过吗？"><a href="#你对前端有了解过吗？" class="headerlink" title="你对前端有了解过吗？"></a>你对前端有了解过吗？</h4><p>有了解过，如HTML、CSS、JavaScript、框架[Vue、Element]等 可以很快的上手<br><u>我主要专长在于后端开发，可以学习和了解更多的前端知识</u>。</p>
<h4 id="各种淘汰策略介绍"><a href="#各种淘汰策略介绍" class="headerlink" title="各种淘汰策略介绍"></a>各种淘汰策略介绍</h4><blockquote>
<p>Redis提供了8种淘汰策略，可以分成两大类：</p>
<p><strong>1、针对所有键的策略：</strong>对所有键进行选择和淘汰。</p>
<p><strong>2、仅针对有过期时间的键的策略：</strong>只在设置了过期时间的键中选择淘汰对象。</p>
</blockquote>
<p><strong>以下具体策略：</strong><br><strong>可以区分为两类</strong>：[有设置过期时间的key  不管你有没有设置过期时间]</p>
<h5 id="1-noeviction【默认】"><a href="#1-noeviction【默认】" class="headerlink" title="1. noeviction【默认】"></a>1. <strong>noeviction</strong>【默认】</h5><ul>
<li><strong>描述</strong>：达到内存限制时，不再执行删除操作，直接拒绝所有写入请求（包括插入和更新）。[可以读 但是拒绝写请求]</li>
<li><strong>适用场景</strong>：<u>希望数据永不丢失的场景</u>，但需要保证内存充足，否则会导致写入操作失败。</li>
</ul>
<h5 id="2-allkeys-lru（最近最少使用）"><a href="#2-allkeys-lru（最近最少使用）" class="headerlink" title="2. allkeys-lru（最近最少使用）"></a>2. <strong>allkeys-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：在所有的键中使用 LRU算法，删除最近最少使用的键。</li>
<li><strong>适用场景</strong>：适合缓存场景，保留<strong>频繁访问</strong>的键，逐出很少被访问的键。</li>
</ul>
<h5 id="3-allkeys-lfu（最少使用频率）【电商】"><a href="#3-allkeys-lfu（最少使用频率）【电商】" class="headerlink" title="3. allkeys-lfu（最少使用频率）【电商】"></a>3. <strong>allkeys-lfu（最少使用频率）</strong>【电商】</h5><ul>
<li><strong>描述</strong>：在所有键中使用 LFU 算法，删除使用频率最低的键。</li>
<li><strong>适用场景</strong>：适用于需根据<strong>使用频率</strong>进行淘汰的场景，更关注访问次数而非访问时间。</li>
</ul>
<h5 id="4-volatile-lru（最近最少使用）"><a href="#4-volatile-lru（最近最少使用）" class="headerlink" title="4. volatile-lru（最近最少使用）"></a>4. <strong>volatile-lru（最近最少使用）</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LRU 算法。</li>
<li><strong>适用场景</strong>：适合缓存一些有过期时间的数据，希望根据<strong>访问频率</strong>来进行内存管理的场景。</li>
</ul>
<h5 id="5-volatile-lfu（最少使用频率）【电商】"><a href="#5-volatile-lfu（最少使用频率）【电商】" class="headerlink" title="5. volatile-lfu（最少使用频率）【电商】"></a>5. <strong>volatile-lfu（最少使用频率）【电商】</strong></h5><ul>
<li><strong>描述</strong>：仅对设置了过期时间的键使用 LFU算法。</li>
<li><strong>适用场景</strong>：同 volatile-lru，但更关注<strong>使用频率</strong>。</li>
</ul>
<h5 id="6-allkeys-random"><a href="#6-allkeys-random" class="headerlink" title="6. allkeys-random"></a>6. <strong>allkeys-random</strong></h5><ul>
<li><strong>描述</strong>：在所有键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适用于缓存数据访问频率没有明显差异的情况。</li>
</ul>
<h5 id="7-volatile-random"><a href="#7-volatile-random" class="headerlink" title="7. volatile-random"></a>7. <strong>volatile-random</strong></h5><ul>
<li><strong>描述</strong>：在所有设置了过期时间的键中随机选择删除某个键。</li>
<li><strong>适用场景</strong>：适合缓存带有过期时间的数据，删除哪个数据不重要的场景。</li>
</ul>
<h5 id="8-volatile-ttl"><a href="#8-volatile-ttl" class="headerlink" title="8. volatile-ttl"></a>8. <strong>volatile-ttl</strong></h5><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先删除剩余生存时间（TTL）较短的键。</li>
<li><strong>适用场景</strong>：适合希望优先清理<strong>即将过期</strong>的数据的场景。</li>
</ul>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class RedisMaxMemoryPolicyExample &#123;
    private Jedis jedis;

    public RedisMaxMemoryPolicyExample() &#123;
        // 连接到Redis服务器
        this.jedis = new Jedis(&quot;localhost&quot;);
    &#125;

    public void setMaxMemoryPolicy(String policy) &#123;
        // 设置Redis的内存淘汰策略
        jedis.configSet(&quot;maxmemory-policy&quot;, policy);
    &#125;

    public String getMaxMemoryPolicy() &#123;
        // 获取当前Redis的内存淘汰策略
        return jedis.configGet(&quot;maxmemory-policy&quot;).get(1);
    &#125;

    public static void main(String[] args) &#123;
        RedisMaxMemoryPolicyExample example = new RedisMaxMemoryPolicyExample();

        // 设置不同的内存淘汰策略
        example.setMaxMemoryPolicy(&quot;noeviction&quot;);       // 默认策略，拒绝写请求
        example.setMaxMemoryPolicy(&quot;allkeys-lru&quot;);      // 所有键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-lfu&quot;);      // 所有键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lru&quot;);     // 仅有过期时间的键使用LRU淘汰
        example.setMaxMemoryPolicy(&quot;volatile-lfu&quot;);     // 仅有过期时间的键使用LFU淘汰
        example.setMaxMemoryPolicy(&quot;allkeys-random&quot;);   // 所有键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-random&quot;);  // 仅有过期时间的键随机淘汰
        example.setMaxMemoryPolicy(&quot;volatile-ttl&quot;);     // 优先淘汰TTL较短的键

        // 获取当前内存淘汰策略
        String currentPolicy = example.getMaxMemoryPolicy();
        System.out.println(&quot;Current Max Memory Policy: &quot; + currentPolicy);
    &#125;
&#125;
</code></pre>
<h4 id="缓存三兄弟-穿透、击穿、雪崩"><a href="#缓存三兄弟-穿透、击穿、雪崩" class="headerlink" title="缓存三兄弟(穿透、击穿、雪崩)"></a>缓存三兄弟(穿透、击穿、雪崩)</h4><p>一般在读缓存的时候出现的问题。<strong>思路</strong>：产生的原因 + 解决的方案</p>
<p>&#x3D;&#x3D;<strong>缓存穿透</strong>&#x3D;&#x3D;：用户或前端查询到一个在数据库中不存在的数据，先查redis再走数据库。对数据库压力会很大。<u>关系型数据库是性能的瓶颈 希望把高数量都挡在数据库前面</u>。查询一个<strong>不存在</strong>的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查询数据库(可能原因是数据库被攻击了 发送了假的&#x2F;大数据量的请求url)</p>
<ul>
<li><strong>解决方案一</strong>：<u>缓存空数据</u>，查询返回的数据为空，仍把这个空结果进行缓存 <strong>{key:1, value:null}</strong> 【空字符串】<del>没有Null的数据类型</del>下一次读取直接把空串返回<br>优点：简单<br>缺点：消耗内存，可能会发生不一致的问题</li>
</ul>
<p>如果一直模拟一个不同的不存在的key 这时候就要用到<strong>布隆过滤器</strong></p>
<ul>
<li><p><strong>解决方案二</strong>：<u>布隆过滤器</u> (拦截不存在的数据)<br>[商品读多写少上缓存，要把商品数据写到布隆过滤器中，以商品的id<del>独一无二</del>计算hashcode，用布隆过滤器。取模数组落到桶内 会把0置为1]<br>有很多个二进制数组每个二进制数组用不同的hash算法进行计算此时落到的桶就不一样<br>作用：读的时候 前端传id 之前怎么写进去就怎么拿出来。[位运算(与)速度很快 把多个数组的数据拿出来与运算如果都是1 则这个数据可能存在<del>再查一遍缓存</del> 若不存在直接return返回] 布隆过滤器说你不存在 一定不存在，说你存在 则可能存在[哈希冲突] </p>
<h6 id="★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？"><a href="#★-项目上线很久了-商品早就下架不卖了-这时候会发生什么问题？" class="headerlink" title="★ 项目上线很久了 商品早就下架不卖了 这时候会发生什么问题？"></a>★ 项目上线很久了 商品早就下架不卖了 <strong>这时候会发生什么问题</strong>？</h6><p>这时候布隆过滤器还有之前的痕迹，需要把那些1设置为0。<br>布隆过滤器 不支持对某个的1设置0 → 因为有哈希冲突<del>我不知道这个1曾经是誰设置的</del><br>支持将整个都置为0，之后可以搞个定时任务<br><strong>布隆过滤器具体实现</strong>：Redis、Redission<del>亲儿子</del>、1cache、咖啡因（Caffeine<del>提供了一种非常高效且易于使用的缓存解决方案，它支持多种缓存过期策略</del>）、Guava<del>谷歌</del></p>
<h6 id="★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据"><a href="#★-以前没设置过且上架过-后面加了布隆，后面要把之前所有数据重新搞进去-怎么解决？存量数据" class="headerlink" title="★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 怎么解决？存量数据"></a>★ 以前没设置过且上架过 后面加了布隆，后面要把之前所有数据重新搞进去 <strong>怎么解决</strong>？<del>存量数据</del></h6><p>写一个定时任务</p>
<h6 id="★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了"><a href="#★-场景：工商银行统计每天的用户日活量-上线就算-要查询某个人连续七天签到-怎么查-用位图-用户量太多了" class="headerlink" title="★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)用户量太多了"></a>★ 场景：工商银行统计每天的用户日活量[上线就算]  要查询某个人连续七天签到 怎么查(用位图)<del>用户量太多了</del></h6><p>搞一个二进制数组，10亿长度的数组，每个数组是一个bit &#x3D; 10亿个位，一个字节<del>1&#x2F;bit</del>&#x3D;8个位，综合计算后大概消耗119MB的空间<del>每天</del>。用用户id去hash 如果用户登录将0置为1<del>有单独的位图结构</del>，统计时间就可以拿日期 往前面数 拿某个id去取模得到桶 找前七个，去进行与运算，连续为1就达到了重复连续七天前端。否则非连续七天。</p>
<p>在缓存预热时，要预热布隆过滤器。根据id查询文章时查询布隆过滤器如果不存在直接返回</p>
<pre><code class="java">import redis.clients.jedis.Jedis;

public class DailyActiveUserCounter &#123;
    private Jedis jedis;

    public DailyActiveUserCounter() &#123;
        this.jedis = new Jedis(&quot;localhost&quot;); // 连接到Redis服务器
    &#125;

    // 映射用户ID到位图的键
    private String getUserBitmapKey(long userId, int day) &#123;
        return &quot;user:bitmap:&quot; + userId + &quot;:&quot; + day;
    &#125;

    // 用户签到
    public void userSignIn(long userId, int day) &#123;
        String key = getUserBitmapKey(userId, day);
        jedis.setbit(key, userId % 86400, true); // 假设一天有86400秒，使用秒数作为偏移量
    &#125;

    // 检查用户连续七天的签到情况
    public boolean checkContinuousSignIn(long userId, int day) &#123;
        for (int i = 0; i &lt; 7; i++) &#123;
            String key = getUserBitmapKey(userId, day - i);
            if (jedis.getbit(key, userId % 86400) == false) &#123;
                return false; // 如果在连续的七天内有一天没有签到，则返回false
            &#125;
        &#125;
        return true; // 连续七天都有签到
    &#125;

    public static void main(String[] args) &#123;
        DailyActiveUserCounter counter = new DailyActiveUserCounter();

        // 假设用户ID为12345，今天签到
        long userId = 12345;
        int today = 1; // 假设今天是第1天
        counter.userSignIn(userId, today);

        // 检查用户是否连续七天签到
        boolean isContinuous = counter.checkContinuousSignIn(userId, today);
        System.out.println(&quot;User &quot; + userId + &quot; has signed in for 7 consecutive days: &quot; + isContinuous);
    &#125;
&#125;
</code></pre>
<p>**bitmap（位图）<del>巨大的二进制数组</del>**：相当于一个以bit位为单位的数组，数组中每个单元只能存储二进制数0或1</p>
<p><strong>布隆过滤器作用</strong>：可以用于检索一个元素是否在集合中</p>
<ul>
<li><strong>存储数据</strong>：id为1的数据，通过多个hash函数获取hash值，根据hash计算数组对应位置<strong>改为1</strong></li>
<li><strong>查询数据</strong>：使用相同hash函数获取hash值，判断对应位置是否都为1</li>
</ul>
<p>存在<strong>误判率</strong>：数组越小 误判率越大 【要数组足够大 误判率就小】</p>
<pre><code class="java">bloomFilter.tryInit(size, 0.05) //误判率5%
</code></pre>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存击穿</strong>&#x3D;&#x3D;：给某<strong>一个</strong>热点key设置了过期时间，当key过期的时候，恰好这个时间点对这个key有大量的并发请求过来，这些并发请求可能一瞬间把DB击穿<del>微博[鹿晗+关晓彤]</del>【并发同一时间访问】</p>
<ul>
<li><p><strong>解决方案一</strong>：<strong>互斥锁</strong>【数据<strong>强一致性</strong> 性能差 (银行)】[控制一个个来访问的次数]</p>
<p><del>AQS、ReentrantLock</del>是进程级别的互斥锁，因为有数据在节点1或节点2，<strong>分布式锁</strong>是在不同场景都可以锁也可以控制访问顺序。</p>
<p>以商品id作为key  先redis开始查缓存 判断是否为空 不为空直接return后解锁，空就先<strong>加锁</strong> 去数据库查完备份一份redis后<strong>解锁</strong>。被锁的其他线程在外面等待。</p>
<h6 id="★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"><a href="#★-100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。" class="headerlink" title="★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。"></a>★ 100个人访问同一个商品，只有一个抢到锁，剩下的99个人也要查redis缓存和数据库。</h6><p>方案：**<u>双重缓存校验</u>**  先查缓存 查不到加锁 再查缓存 查不到再去数据库 查完后看是否备份后解锁<del>冷代码</del></p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁成功</strong> → 3.查询数据库重建缓存数据 → 4.写入缓存 → 5.释放锁</p>
<p>1.查询缓存,未命中 → 2.<strong>获取互斥锁失败</strong> → 3.休眠一会再重试 → 4.写入缓存重试 → 5.缓存命中</p>
</li>
<li><p><strong>解决方案二</strong>：<strong>逻辑过期</strong>[  <u><em>不设置过期时间</em></u>  ] 【高可用 性能优 不能保证数据绝对一致 (用户体验)】</p>
<blockquote>
<p>在数据库一条数据里面添加一个          “expire”: 153213455</p>
</blockquote>
<p>1.查询缓存,发现逻辑时间已过期 → 2.获取互斥锁成功 → 3.开启线程 ↓→ 4.返回过期数据</p>
<p>​                【在新的线程】→ 1.查询数据库重建缓存数据 → 2.写入缓存,重置逻辑过期时间 → 3.释放锁<br>1.查询数据缓存,发现逻辑时间已过期 → 2.获取互斥锁失败 → 3.返回过期数据</p>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>缓存雪崩</strong>&#x3D;&#x3D;：在同一个时段内<strong>大量</strong>的缓存key同时失效或者<u>Redis服务宕机</u>，导致大量请求到达数据库，带来压力</p>
<ul>
<li><strong>解决方案一：</strong>给不同的key的TTL(过期时间)添加随机值<del>不在同一时间过期</del></li>
<li><strong>解决方案二：</strong>利用Redis集群提高服务的可用性 【哨兵模式、集群模式】</li>
<li><strong>解决方案三：</strong><u>给缓存业务添加<strong>降级</strong>限流策略</u>【nginx、springcloud、gateway】</li>
<li><strong>解决方案四：</strong>给业务添加多级缓存 【Guava(做一级缓存 然后Redis是二级缓存)或Caffeine】</li>
</ul>
<h6 id="★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？"><a href="#★-redis宕机的时候-再RedisTemplate-set-后会报错-但是现在mysql还可以访问-应该怎么办？" class="headerlink" title="★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？"></a>★ redis宕机的时候 再RedisTemplate.set()后会报错 但是现在mysql还可以访问 应该怎么办？</h6><p><strong>try catch 在里面继续再去查mysql数据库</strong></p>
<h6 id="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"><a href="#降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。" class="headerlink" title="降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。"></a>降级代码：对于读操作，如果Redis缓存失效，可以直接从MySQL数据库读取数据。</h6><pre><code class="java">public boolean setData(String key, String value) &#123;
    try &#123;
        // 尝试将数据设置到Redis
        redisTemplate.opsForValue().set(key, value);
        return true;
    &#125; catch (Exception e) &#123;
        // 日志记录Redis错误
        log.error(&quot;Redis is down, failing over to MySQL&quot;, e);
        
        // Redis设置失败，降级到MySQL
        return setDataToMySQL(key, value);
    &#125;
&#125;

private boolean setDataToMySQL(String key, String value) &#123;
    // 这里实现将数据写入MySQL的逻辑
    // 例如：
    // mySqlTemplate.update(&quot;INSERT INTO cache (key, value) VALUES (?, ?)&quot;, key, value);
    // 注意：这里的mySqlTemplate和SQL语句需要根据实际情况调整
    return true; // 假设写入成功
&#125;
</code></pre>
<h6 id="如果公司对要求更高，需要限流降级、熔断"><a href="#如果公司对要求更高，需要限流降级、熔断" class="headerlink" title="如果公司对要求更高，需要限流降级、熔断"></a>如果公司对要求更高，需要限流<del>降级、熔断</del></h6><p>同一时间设置QPS为100 超过的返回友好提示[商品太火爆啦，请稍后再试]</p>
<h4 id="你有自己部署过环境吗"><a href="#你有自己部署过环境吗" class="headerlink" title="你有自己部署过环境吗"></a>你有自己部署过环境吗</h4><p>公司里面用 Jenkins + docker 测试环境我们部署 生产环境是组长部署</p>
<h4 id="未来1-3年规划"><a href="#未来1-3年规划" class="headerlink" title="未来1-3年规划"></a>未来1-3年规划</h4><p>将具体一点，从业务技术上提升自己的深度和广度达到高级工程师</p>
<h4 id="你平时做笔记吗"><a href="#你平时做笔记吗" class="headerlink" title="你平时做笔记吗"></a>你平时做笔记吗</h4><p>有做笔记 Xmind + Markdown<br>因为我觉得无论从网上的还是别人请教的不经历我的消化都不是我的东西<br>我还是会将这些知识点总结起来变成自己的知识</p>
<h4 id="什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？"><a href="#什么是动态代理？-amp-amp-动态代理有哪些，他们之间的区别？" class="headerlink" title="什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？"></a>什么是动态代理？&amp;&amp; 动态代理有哪些，他们之间的区别？</h4><h6 id="代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式"><a href="#代理是一种设计模式-用来增强目标的逻辑-与被增强的并没有太大关系装饰者模式" class="headerlink" title="代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系装饰者模式"></a>代理是一种设计模式 用来增强目标的逻辑 与被增强的并没有太大关系<del>装饰者模式</del></h6><p>在程序运行期间才会产生代理类加载到我们jvm中yaml文件</p>
<ul>
<li><h6 id="JDK动态代理是-基于接口实现来实现增强"><a href="#JDK动态代理是-基于接口实现来实现增强" class="headerlink" title="JDK动态代理是 基于接口实现来实现增强"></a>JDK动态代理是 <u>基于接口实现来实现增强</u></h6><p>[txt文本 把目标增强类 作为接口<del>本身就是接口</del> 实现过来写成源码 源文件 再用jdk工具把源码编译成class字节码 再用类加载器把class加载到jvm中]</p>
</li>
<li><h6 id="CGLIB动态代理是-基于继承目标类并覆写其方法来实现"><a href="#CGLIB动态代理是-基于继承目标类并覆写其方法来实现" class="headerlink" title="CGLIB动态代理是 基于继承目标类并覆写其方法来实现"></a>CGLIB动态代理是 <u>基于继承目标类并覆写其方法来实现</u></h6><p>[ASN字节码机制直接生成class 直接加载到内存中]<del>性能较高，速度更快。因为直接生成class</del></p>
</li>
</ul>
<p>要调用某个方法 CGLIB性能高 是通过反射来实现的 老版本的jdk的反射性能较低。如今在调用方法的性能上差距不大</p>
<p><strong>区别</strong>：</p>
<ul>
<li>JDK动态代理要求目标类必须实现一个或多个接口，而CGLIB没有这个要求。</li>
<li>JDK动态代理生成的代理类是接口的实现，而CGLIB生成的<strong>代理</strong>类是目标类的子类。</li>
<li>性能上，CGLIB通常比JDK动态代理更快，因为它直接操作字节码生成新的类。</li>
</ul>
<h4 id="什么样的代码是静态代理？"><a href="#什么样的代码是静态代理？" class="headerlink" title="什么样的代码是静态代理？"></a>什么样的代码是静态代理？</h4><p>发生在我们写代码的过程中 在编译阶段产生了代理类<br>静态代理是指代理类在编译时就已经确定，通常由程序员手动编写</p>
<h4 id="你用过Linux吗？"><a href="#你用过Linux吗？" class="headerlink" title="你用过Linux吗？"></a>你用过Linux吗？</h4><p>是的，我在工作中经常使用Linux操作系统。我熟悉Linux的基本命令<br>基础的命令：xxx【查看之前笔记】</p>
<h4 id="你工作的时候有需求文档吗？"><a href="#你工作的时候有需求文档吗？" class="headerlink" title="你工作的时候有需求文档吗？"></a>你工作的时候有需求文档吗？</h4><p>有的，<strong>有一些简单的需求是没有的</strong>[沟通成本太高了]<br><strong>稍微复杂的需求会有需求文档</strong>，我会根据需求文档来理解项目需求，并进行系统设计和开发。</p>
<h4 id="你有什么需要了解的？不要难为面试官-不问技术栈"><a href="#你有什么需要了解的？不要难为面试官-不问技术栈" class="headerlink" title="你有什么需要了解的？不要难为面试官,不问技术栈"></a><span style="color:red">你有什么需要了解的？</span><del>不要难为面试官,不问技术栈</del></h4><p>我想了解一下贵公司的业务是什么…好的那我这块已经没有什么想了解的了 <span style="color:red">感谢面试官</span><br>HR：想了解一下贵公司的上班时间…<br>我没有什么想了解的，来之前有了解过贵公司</p>
<h4 id="平时用注解创建的bean是单例的还是多例的？"><a href="#平时用注解创建的bean是单例的还是多例的？" class="headerlink" title="平时用注解创建的bean是单例的还是多例的？"></a>平时用注解创建的bean是单例的还是多例的？</h4><p>默认情况下，通过注解（如@Component、@Service、@Repository、@Bean等）创建的Bean是单例的。如果需要创建多例Bean，可以在注解上添加@Scope(“prototype”)来指定。</p>
<pre><code class="java">// 单例Bean
import org.springframework.stereotype.Component;

@Component
public class SingletonBean &#123;
    // Bean的代码
&#125;

----------------------------------------------------
    
// 多例Bean

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope(&quot;prototype&quot;)
public class PrototypeBean &#123;
    // Bean的代码
&#125;
</code></pre>
<h4 id="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"><a href="#SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？" class="headerlink" title="SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？"></a>SQL语句的执行顺序，为什么顺序是这样排的，这样的顺序有什么优势或者好处？</h4><p><code>FROM -&gt; Join -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY -&gt; limit</code><br>这样的顺序是为了优化查询性能。首先确定数据来源（FROM），然后筛选出满足条件的数据（WHERE），接着进行分组（GROUP BY），在分组的基础上进行进一步筛选（HAVING），然后选择需要的数据（SELECT），最后对结果进行排序（ORDER BY）。这样的顺序可以减少中间结果集的大小，提高查询效率。</p>
<h6 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h6><p><code>select -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit</code></p>
<h4 id="线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答"><a href="#线上项目发生死锁如何去解决？-我暂时没遇到过→分布式事务上去答" class="headerlink" title="线上项目发生死锁如何去解决？ 我暂时没遇到过→分布式事务上去答"></a>线上项目发生死锁如何去解决？ <del>我暂时没遇到过→分布式事务上去答</del></h4><p><strong>死锁</strong>：两个线程争夺两个资源的时候  <code>1线程拿到a 想拿b   2线程拿到了b 想拿a</code><br><strong>四个原因</strong>：<u>互斥条件 请求保持 不可剥夺 循环等待</u><br>产生死锁的四个因素 同时满足才会死锁     想要解决死锁 需要打破其中一个原因就行</p>
<blockquote>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时使用。即某个资源在一段时间内只能由一个线程占用，其他线程必须等待该资源被释放后才能使用。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源又被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：已经分配给某个线程的资源在该线程完成任务前不能被抢占，即只能由线程自己释放。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一种线程资源的循环等待链，每个线程都在等待下一个线程所持有的资源。</li>
</ol>
</blockquote>
<blockquote>
<h4 id="在实际操作中，以下是一些打破死锁的具体方法："><a href="#在实际操作中，以下是一些打破死锁的具体方法：" class="headerlink" title="在实际操作中，以下是一些打破死锁的具体方法："></a>在实际操作中，以下是一些打破死锁的具体方法：</h4><ul>
<li><strong>资源分配图</strong>：使用资源分配图来检测循环等待条件，并在检测到循环时采取措施。</li>
<li><strong>锁排序</strong>：确保所有线程以相同的顺序获取锁，从而避免循环等待。</li>
<li><strong>超时机制</strong>：线程在请求资源时设置超时时间，如果超过时间未获得资源，则放弃当前任务并释放已持有的资源。</li>
<li><strong>死锁检测算法</strong>：运行死锁检测算法，如银行家算法，来检测系统中的死锁，并在必要时采取措施。</li>
<li><strong>线程中断</strong>：允许系统或其他线程中断正在等待资源的线程。</li>
<li><strong>回滚操作</strong>：如果检测到死锁，可以让某些线程回滚它们的工作，并释放资源，从而打破死锁。</li>
</ul>
</blockquote>
<p>MySQL是不会有死锁的 自身会检测 [让后面的超时释放回滚]<br>在分布式事务 线程1拿着资源a是数据库1 线程2拿着资源b是数据库2<br>JVM中也有死锁，jvm没有超时机制不会解决 可以查看命令打印堆栈信息可以查看哪里产生死锁</p>
<blockquote>
<p>你可以使用<code>jstack</code>命令来打印指定进程ID的Java堆栈跟踪信息。这个命令可以帮助你分析线程的状态</p>
<ol>
<li><p>首先，找到你的Java进程ID（PID）。你可以使用<code>jps</code>命令来列出所有正在运行的Java进程及其PID。</p>
<pre><code>jps
</code></pre>
</li>
<li><p>使用<code>jstack</code>命令打印出该Java进程的堆栈跟踪。</p>
<pre><code>jstack &lt;PID&gt;
</code></pre>
<p>将<code>&lt;PID&gt;</code>替换为实际的进程ID。</p>
</li>
<li><p>查找堆栈跟踪中的”DEADLOCK”关键字。<code>jstack</code>会自动检测死锁并在输出中报告。</p>
</li>
</ol>
</blockquote>
<h4 id="如果你遇到-新的-技术栈，怎么去解决"><a href="#如果你遇到-新的-技术栈，怎么去解决" class="headerlink" title="如果你遇到(新的)技术栈，怎么去解决?"></a>如果你遇到(新的)技术栈，怎么去解决?</h4><p>【return Previous.notes(NowDay);】</p>
<h4 id="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通"><a href="#如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通" class="headerlink" title="如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?"></a>如果你在实际开发中遇到问题，你怎么去解决，怎么去沟通?</h4><p>首先尝试自己解决问题，通过搜索引擎、官方文档、Debug等。<br>尽可能不让这个问题不出现风险 实在解决不了就向上反馈 寻求帮助 请教上司领导或同事<br>平常和项目经理进行沟通 如果需求评审有些不理解还是会及时沟通 不清楚的一定要及时明确</p>
<h4 id="对于加班情况怎么看"><a href="#对于加班情况怎么看" class="headerlink" title="对于加班情况怎么看?"></a>对于加班情况怎么看?</h4><p>为了确保项目进度和团队利益，加班是可以接受的。</p>
<h4 id="多线程怎么保证线程之间的安全"><a href="#多线程怎么保证线程之间的安全" class="headerlink" title="多线程怎么保证线程之间的安全"></a>多线程怎么保证线程之间的安全</h4><h6 id="加锁-不让多线程抢夺资源"><a href="#加锁-不让多线程抢夺资源" class="headerlink" title="加锁  不让多线程抢夺资源"></a>加锁  不让多线程抢夺资源</h6><p>互斥锁、读写锁、线程局部存储(ThreadLocal每个线程独享自己变量)</p>
<h4 id="mybatis中-和-的区别，哪个更好-为什么"><a href="#mybatis中-和-的区别，哪个更好-为什么" class="headerlink" title="mybatis中${}和#{}的区别，哪个更好? 为什么?"></a>mybatis中${}和#{}的区别，哪个更好? 为什么?</h4><ol>
<li><h5 id="（字符串替换）："><a href="#（字符串替换）：" class="headerlink" title="${}（字符串替换）："></a><code>$&#123;&#125;</code>（字符串替换）：</h5><ul>
<li><code>$&#123;&#125;</code>会将参数直接替换到SQL语句中，不进行任何转义处理。</li>
<li>它适用于动态SQL中的表名或列名，或者在SQL语句中需要使用特定数据库函数的情况。</li>
<li>使用<code>$&#123;&#125;</code>时，如果参数是用户输入的，那么可能会引发SQL注入攻击，因为它不会对参数进行转义。</li>
</ul>
</li>
<li><h5 id="（预处理语句参数）："><a href="#（预处理语句参数）：" class="headerlink" title="#{}（预处理语句参数）："></a><code>#&#123;&#125;</code>（预处理语句参数）：</h5><ul>
<li><code>#&#123;&#125;</code>会创建预处理语句（prepared statement）的参数占位符，并在设置参数时进行适当的转义处理。</li>
<li>它适用于大部分情况，特别是当参数是用户输入时，可以有效防止SQL注入攻击。</li>
<li>MyBatis会根据参数的类型自动选择<code>setString</code>、<code>setInt</code>、<code>setDate</code>等预处理语句方法。</li>
</ul>
</li>
<li><h5 id="在大多数情况下，-是更好的选择，因为它提供了以下优势："><a href="#在大多数情况下，-是更好的选择，因为它提供了以下优势：" class="headerlink" title="在大多数情况下，#{}是更好的选择，因为它提供了以下优势："></a>在大多数情况下，<code>#&#123;&#125;</code>是更好的选择，因为它提供了以下优势：</h5><ul>
<li><strong>安全性</strong>：<code>#&#123;&#125;</code>可以防止SQL注入攻击，因为它会自动转义参数。</li>
<li><strong>类型处理</strong>：MyBatis会根据参数的实际类型来设置预处理语句的参数，这减少了类型错误的可能性。</li>
<li><strong>可读性和维护性</strong>：使用<code>#&#123;&#125;</code>可以使SQL语句更加清晰，因为它清楚地标识了参数的位置。</li>
</ul>
<p>然而，在某些特定的场景下，如需要动态地指定表名或列名时，<code>$&#123;&#125;</code>是必要的，因为预处理语句</p>
</li>
</ol>
<h4 id="说一下内连接和外连接的区别"><a href="#说一下内连接和外连接的区别" class="headerlink" title="说一下内连接和外连接的区别"></a>说一下内连接和外连接的区别</h4><p><strong>左外连接（Left Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：左外连接返回左表中的所有行，即使在右表中没有匹配的行。对于左表中没有匹配的行，结果集中的右表部分将包含NULL。</li>
<li>如果左表是主表，或者左表中的数据是查询的主要关注点，而右表中的数据是辅助信息时，通常使用左外连接。</li>
</ul>
<p><strong>右外连接（Right Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：右外连接返回右表中的所有行，即使在左表中没有匹配的行。对于右表中没有匹配的行，结果集中的左表部分将包含NULL。</li>
<li>如果右表是主表，或者右表中的数据是查询的主要关注点，而左表中的数据是辅助信息时，通常使用右外连接</li>
</ul>
<p><strong>全外连接（Full Outer Join）</strong>：</p>
<ul>
<li><strong>定义</strong>：全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配时，结果集中的相应部分将包含NULL。</li>
<li>全外连接不常用，因为它通常会返回大量的包含NULL的数据，这可能会导致查询结果难以解释。只有在确实需要两表中的所有数据时才使用。</li>
</ul>
<hr>
<blockquote>
<ul>
<li><strong>性能考虑</strong>：外连接可能会比内连接（Inner Join）更消耗资源，特别是当表很大时。如果可能，尽量使用内连接。</li>
<li><strong>数据完整性</strong>：如果业务逻辑要求查询结果必须包含某个表的所有记录，那么应该使用相应的外连接。</li>
</ul>
</blockquote>
<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>xxx</p>
<h4 id="你觉得学习我们这些技术最重要的是什么"><a href="#你觉得学习我们这些技术最重要的是什么" class="headerlink" title="你觉得学习我们这些技术最重要的是什么?"></a>你觉得学习我们这些技术最重要的是什么?</h4><p>首先要清楚**<u>这个技术是解决什么领域的问题</u>**，学习技术很多方面都是用来服务业务的，结合实际业务来学习技术融合性会更强</p>
<h4 id="技术栈有些不同，有没有想过换方向发展"><a href="#技术栈有些不同，有没有想过换方向发展" class="headerlink" title="技术栈有些不同，有没有想过换方向发展?"></a>技术栈有些不同，有没有想过换方向发展?</h4><p>没问题的 因为技术是相通的 可以去学新技术</p>
<h3 id="ThreadLocal相关面试题"><a href="#ThreadLocal相关面试题" class="headerlink" title="ThreadLocal相关面试题"></a>ThreadLocal相关面试题</h3><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><p>ThreadLocal(定义全局静态变量 项目中共用)是Java中的一个线程局部变量工具类，它提供了一种在多线程环境下，每个线程都可以独立访问自己的变量副本的机制。ThreadLocal中存储的数据对于每个线程来说都是独立的，互不干扰。</p>
<h5 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h5><p>ThreadLocal适用于以下场景：</p>
<ul>
<li>在多线程环境下，需要保持线程安全性的数据访问。</li>
<li>需要在多个方法之间共享数据，但又不希望使用传递参数的方式。<ul>
<li>在传递登录用户id是非常方便且适用</li>
</ul>
</li>
</ul>
<p><strong>以后获取用户id不用再解析token了，线程拿仅仅拿当前线程的数据 每个登录的用户都有自己的threadlocal数据</strong></p>
<p><strong>ThreadLocal</strong>并不是一个Thread，<strong>而是Thread的局部变量</strong>【可以存储数据】<br>ThreadLocal<strong>为每个线程提供单独一份存储空间</strong>，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。**<u>ThreadLocal实现一个线程内传递数据</u>**[就不用一个个参数往后传递了]<br>注意：客户端发送的每次请求，后端的tomcat服务器都会分配一个单独的线程来处理请求</p>
<ul>
<li><strong><u>一个请求是一个线程</u></strong>[意义：在第一个线程里面使用ThreadLocal存储用户Id 在后面controller或service中就可以取出来用户id]</li>
<li>第二个请求就是另一个线程 线程池用完第一个放回线程池 也有可能把上一个线程接着给它用</li>
</ul>
<p><code>postHandle </code>只有在正确调用返回才会引用 如果抛出异常则不会使用<br><code>afterCompletion </code>无论怎样最后都要运行</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="3-1-创建ThreadLocal对象"><a href="#3-1-创建ThreadLocal对象" class="headerlink" title="3.1 创建ThreadLocal对象"></a>3.1 创建ThreadLocal对象</h6><p>首先，我们需要创建一个ThreadLocal对象来存储线程局部变量。可以使用ThreadLocal的默认构造函数创建一个新的实例。【给每个线程拷贝一份 synchn + Lock锁】</p>
<pre><code class="Java">ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();
</code></pre>
<h6 id="3-2-设置线程局部变量的值"><a href="#3-2-设置线程局部变量的值" class="headerlink" title="3.2 设置线程局部变量的值"></a>3.2 设置线程局部变量的值</h6><p>使用<code>set()</code>方法可以设置当前线程的局部变量的值。</p>
<pre><code class="Java">threadLocal.set(&quot;value&quot;);
</code></pre>
<h6 id="3-3-获取线程局部变量的值"><a href="#3-3-获取线程局部变量的值" class="headerlink" title="3.3 获取线程局部变量的值"></a>3.3 获取线程局部变量的值</h6><p>使用<code>get()</code>方法可以获取当前线程的局部变量的值。</p>
<pre><code class="Java">String value = threadLocal.get();
</code></pre>
<h6 id="3-4-清除线程局部变量的值"><a href="#3-4-清除线程局部变量的值" class="headerlink" title="3.4 清除线程局部变量的值"></a>3.4 清除线程局部变量的值</h6><p>使用<code>remove()</code>方法可以清除当前线程的局部变量的值，建议在整个请求使用完一定要执行remove清除数据，不然可能会发生内存泄漏问题。</p>
<pre><code class="Java">threadLocal.remove();
</code></pre>
<h6 id="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"><a href="#下面是一个简单的示例代码，演示了如何使用ThreadLocal。" class="headerlink" title="下面是一个简单的示例代码，演示了如何使用ThreadLocal。"></a>下面是一个简单的示例代码，演示了如何使用ThreadLocal。</h6><pre><code class="Java">public class ThreadLocalTest &#123;

    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();

    public static void main(String[] args) &#123;

        Thread t1 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itheima&quot;);
            getData(&quot;t1&quot;);
        &#125;, &quot;t1&quot;);

        Thread t2 = new Thread(() -&gt; &#123;
            THREAD_LOCAL.set(&quot;itcast&quot;);
            getData(&quot;t2&quot;);
        &#125;, &quot;t1&quot;);

        t1.start();
        t2.start();

    &#125;

    private static void getData(String threadName)&#123;
        Object data = THREAD_LOCAL.get();
        System.out.println(threadName+&quot;-&quot;+data);
    &#125;
&#125;
</code></pre>
<p>运行以上代码，输出结果为：</p>
<pre><code class="Plain">t1-itheima
t2-itcast
</code></pre>
<p>在任意位置都可以调用Threadlocal，线程隔离互不影响，解决了线程安全问题：[每个线程存一份 线程不共享]</p>
<p>用mybatis+建造者模式 一定要在类里面加 一定要具有有参和无参构造缺一不可 否则mybatis数据封装无法映射<br>@AllArgsConstructor<br>@NoArgsConstructor<br>@Builder</p>
<h4 id="字符和字符串类型的区别"><a href="#字符和字符串类型的区别" class="headerlink" title="字符和字符串类型的区别"></a>字符和字符串类型的区别</h4><p>字符是基本数据类型 没有null 用单引号<br>字符串是引用数据类型[一个类] 用双引号</p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250102142357092.png" alt="image-20250102142357092"></p>
<h4 id="操作字符串的工具类是什么"><a href="#操作字符串的工具类是什么" class="headerlink" title="操作字符串的工具类是什么"></a>操作字符串的工具类是什么</h4><p>apache的common提供的String Utils工具类，hutool也有String Utils</p>
<h4 id="局部变量和成员变量的区别"><a href="#局部变量和成员变量的区别" class="headerlink" title="局部变量和成员变量的区别"></a>局部变量和成员变量的区别</h4><p><strong>成员变量</strong>是在jvm的<strong>堆</strong><br><strong>局部变量</strong>是在jvm的<strong>栈</strong><br>基本数据类型的引用类型 类在堆<br>基本数据类型的成员变量在堆 非静态在堆 静态变量在方法区<br>引用类型 无论静态还是非静态成员变量都在堆区</p>
<p>局部变量是在方法或代码块内部声明的变量，其作用域仅限于声明它的方法或代码块<br>局部变量不能被static修饰<br>局部变量必须被初始化才能使用</p>
<p>成员变量是在类内部声明的变量，其作用域是整个类<br>成员变量可以被static修饰<br>成员变量有默认值</p>
<h4 id="你编写完代码，写完这个功能后，会进行什么操作呢"><a href="#你编写完代码，写完这个功能后，会进行什么操作呢" class="headerlink" title="你编写完代码，写完这个功能后，会进行什么操作呢"></a>你编写完代码，写完这个功能后，会进行什么操作呢</h4><p>进行<strong>代码审查</strong>，检查代码是否符合编码规范和设计要求。</p>
<ul>
<li>进行<strong>单元测试</strong>，确保代码的功能正确无误。</li>
<li>进行<strong>代码优化</strong>，提高代码的性能和可维护性。</li>
<li>与团队成员进行代码合并，确保代码的集成。</li>
<li>编写文档，记录功能实现和代码变更。</li>
</ul>
<h4 id="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"><a href="#上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？" class="headerlink" title="上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？"></a>上一家公司的薪资是多少？期望薪资是多少？上一家还有什么其他的福利吗？</h4><p>期望薪资：<br>了解过广东这边的市场 我想换工作想涨薪10~20%<br>节假日会发放礼品和福利</p>
<h4 id="可以接受低代码平台吗？"><a href="#可以接受低代码平台吗？" class="headerlink" title="可以接受低代码平台吗？"></a>可以接受低代码平台吗？</h4><p>可以接受<br>低代码平台：类若依</p>
<h4 id="具体说说Java面向对象"><a href="#具体说说Java面向对象" class="headerlink" title="具体说说Java面向对象"></a>具体说说Java面向对象</h4><p>Java面向对象是一种编程范式，<strong>它将现实世界的事物抽象成程序中的对象</strong>。Java面向对象的主要特征包括：</p>
<ul>
<li><strong>封装</strong>：将对象的<strong>属性</strong>和<strong>行为</strong>封装在一起，对外只暴露必要的接口，隐藏内部实现细节。</li>
<li><strong>继承</strong>：允许<strong>子类继承父类的属性和行为</strong>，实现代码的复用。</li>
<li><strong>多态</strong>：<strong>同一个接口可以有多个不同的实现</strong>，通过对象的类型和方法的调用，实现不同的功能。</li>
</ul>
<h4 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别"></a>&#x3D;&#x3D; 和 equals 的区别</h4><ul>
<li>&#x3D;&#x3D;：比较<strong>基本数据类型</strong>时，比较的是<strong>值</strong>；比较<strong>引用数据类型</strong>时，比较的是对象的<strong>内存地址</strong>。</li>
<li>equals：是Object类的一个方法，<strong>默认比较</strong>的是<strong>对象的内存地址</strong>。但在很多类中（如String、Integer等），equals方法被重写，用于比较对象的内容是否相等。<br>没重写 就是 &#x3D;&#x3D; 比较对象地址。重写过的话就比较对象的值。</li>
</ul>
<h4 id="有没有做过权限控制，整个系统的权限"><a href="#有没有做过权限控制，整个系统的权限" class="headerlink" title="有没有做过权限控制，整个系统的权限"></a>有没有做过权限控制，整个系统的权限</h4><p>有过 SpringSecurity</p>
<h6 id="能具体说一下权限控制怎么做？"><a href="#能具体说一下权限控制怎么做？" class="headerlink" title="能具体说一下权限控制怎么做？"></a>能具体说一下权限控制怎么做？</h6><p>使用RBAC模型 不是把用户关联资源 而是中间利用角色间接关联<br><u>用户+角色+资源+用户角色中间表+角色资源中间表<del>多对多</del></u></p>
<h6 id="SpringSecurity-具体怎么实现"><a href="#SpringSecurity-具体怎么实现" class="headerlink" title="SpringSecurity 具体怎么实现"></a>SpringSecurity 具体怎么实现</h6><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息。</p>
<h4 id="线程池有哪些状态，这些状态是怎么进行转换的"><a href="#线程池有哪些状态，这些状态是怎么进行转换的" class="headerlink" title="线程池有哪些状态，这些状态是怎么进行转换的"></a>线程池有哪些状态，这些状态是怎么进行转换的</h4><p>线程池有以下几种状态：</p>
<ul>
<li>RUNNING：线程池正常运行，可以接受新的任务和处理任务队列中的任务。</li>
<li>SHUTDOWN：线程池不再接受新的任务，但会处理任务队列中的任务。</li>
<li>STOP：线程池不再接受新的任务，也不处理任务队列中的任务，并且会中断正在执行的任务。</li>
<li>TIDYING：所有任务都已终止，线程池即将关闭。</li>
<li>TERMINATED：线程池已关闭。</li>
</ul>
<p>状态转换过程如下：</p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：调用shutdown()方法。</li>
<li>RUNNING -&gt; STOP：调用shutdownNow()方法。</li>
<li>SHUTDOWN -&gt; TIDYING：当线程池和任务队列都为空时。</li>
<li>STOP -&gt; TIDYING：当线程池为空时。</li>
<li>TIDYING -&gt; TERMINATED：当terminated()钩子方法执行完成后。</li>
</ul>
<h4 id="说一下怎么使用多线程？"><a href="#说一下怎么使用多线程？" class="headerlink" title="说一下怎么使用多线程？"></a>说一下怎么使用多线程？</h4><ul>
<li><p>继承Thread类，并重写run()方法。</p>
</li>
<li><p>实现Runnable接口，并将实现类传递给Thread对象。</p>
</li>
<li><p>实现Callable接口，实现<code>call()</code>方法</p>
</li>
<li><p>使用Executor框架，如ExecutorService和ThreadPoolExecutor来管理线程池。</p>
</li>
</ul>
<h4 id="操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？"><a href="#操作系统上的线程有多少种状态-5-？Java线程有多少种状态-6-？" class="headerlink" title="操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？"></a>操作系统上的线程有多少种状态[5]？Java线程有多少种状态[6]？</h4><ul>
<li>新建（New）：创建后尚未启动的线程处于这个状态。<code>new Thread</code></li>
<li>可运行（Runnable）：包括运行（Running）和就绪（Ready）状态，线程正在执行或等待CPU调度。</li>
<li>阻塞（Blocked）：线程因为等待某些资源或锁而被阻塞。notify可以唤醒阻塞状态 睡眠完会自动唤醒</li>
<li>等待（Waiting）：线程等待其他线程执行特定操作（如通知）。</li>
<li>计时等待（Timed Waiting）：线程在一定时间内等待另一个线程的通知。</li>
<li>终止（Terminated）：线程执行完成或因异常而终止。</li>
</ul>
<h6 id="怎么把线程杀死-终止"><a href="#怎么把线程杀死-终止" class="headerlink" title="怎么把线程杀死 终止"></a>怎么把线程杀死 终止</h6><p><strong>stop</strong>()方法[暴力方法]    <strong>interrupt</strong>()方法[优雅关闭线程]    正常回收</p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><p>乐观锁：读多写少 线程执行时间相差较大  并发不太激烈</p>
<p>悲观锁：写多读少 线程执行时间相差不大 竞争激烈 并发锁多</p>
<p>加锁的时机不一样，<br>悲观锁：没改数据的时候先加锁 比较明显利用底层操作系统api实现<br>乐观锁：在改数据的时候才加锁 依靠底层的硬件</p>
<p><strong>java层面</strong>：<code>synchronized  ReentrantLock</code></p>
<p><strong>数据库层面</strong>：<br>悲观锁：select for update是mysql的的实现<br>乐观锁：JUC Java Util Concurrent）是Java并发工具包</p>
<blockquote>
<p><code>SELECT ... FOR UPDATE</code>：这个语句在读取记录时会锁定这些记录，直到事务提交或回滚。其他的事务不能更新这些锁定的记录，这是悲观锁的一个典型实现</p>
</blockquote>
<p>乐观锁要读取目前旧的值再将新设置的值以及旧的值比较 如果相同 就把新的值更新 如果不相同 就把旧的值重新提取 因为在这期间有人读取了这个数据跟我之前不一样(底层api 要调用两个 一个旧的值 一个新的值)。一般乐观锁是结合自旋 类于while(true)直到读到为止 <code>要设计次数后再报错</code></p>
<p>要更新数据库某个值 把旧的值读出来 想更新银行里的余额<br>这是<strong>典型的ABA问题</strong>：<u>要用<strong>时间戳</strong>或<strong>自增版本号</strong>去做</u></p>
<h4 id="Stream流的使用及常用API"><a href="#Stream流的使用及常用API" class="headerlink" title="Stream流的使用及常用API"></a>Stream流的使用及常用API</h4><p>Stream是Java 8中引入的一种新特性，用于简化数据处理和操作。它可以用来解决集合循环遍历处理的问题。在此之前用循环来代替</p>
<blockquote>
<h3 id="基础Stream操作"><a href="#基础Stream操作" class="headerlink" title="基础Stream操作"></a>基础Stream操作</h3><ul>
<li><code>stream()</code>: 为集合创建串行流。</li>
<li><code>parallelStream()</code>: 为集合创建并行流。</li>
<li><code>forEach</code>: 对每个元素执行操作。</li>
<li><code>map</code>: 将每个元素映射到对应的结果。</li>
<li><code>filter</code>: 过滤出满足条件的元素。</li>
<li><code>limit</code>: 限制流的大小。</li>
<li><code>skip</code>: 跳过流中的前n个元素。</li>
<li><code>sorted</code>: 对流进行排序。</li>
</ul>
<h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><ul>
<li><code>collect</code>: 将流转换为其他形式，比如列表、集合或Map。</li>
<li><code>reduce</code>: 通过一个起始值，反复利用BinaryOperator来处理和累积元素，返回一个值。</li>
<li><code>count</code>: 返回流中元素的数量。</li>
<li><code>min</code> &#x2F; <code>max</code>: 找到流中的最小&#x2F;最大值。</li>
<li><code>anyMatch</code>: 流中是否有一个元素匹配给定的谓词。</li>
<li><code>allMatch</code>: 流中的所有元素是否都匹配给定的谓词。</li>
<li><code>noneMatch</code>: 流中没有任何元素匹配给定的谓词。</li>
<li><code>findFirst</code>: 返回第一个元素。</li>
<li><code>findAny</code>: 返回当前流中的任意元素。</li>
</ul>
</blockquote>
<h4 id="项目中具体用到哪些设计模式"><a href="#项目中具体用到哪些设计模式" class="headerlink" title="项目中具体用到哪些设计模式"></a>项目中具体用到哪些<span style = "color:red">设计模式</span></h4><p><del><strong>单例模式</strong>：确保一个类只有一个实例，例如配置文件管理器。</del>[<u>Spring原本设计好的</u>]<br><strong><u>工厂模式</u><strong>：创建对象时无需指定具体的类，例如日志工厂。<br><strong>观察者模式</strong>：当一个对象状态发生改变时，</strong>所有依赖于它的对象</strong>都得到通知并自动更新，例如事件监听。<br>**<u>策略模式</u>**：定义一系列算法，将每个算法封装起来，并使它们可以互换，例如支付策略。<br><strong>模板方法模式</strong>：在项目中，我有一些具有相同操作步骤但具体实现不同的算法，我使用了模板方法模式来定义这些步骤的骨架，将具体的步骤实现留给子类。任链模式的目的是将请求的发送者和接收者解耦，从而使得多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。<br><strong>责任链模式</strong>：它允许将请求沿着处理者链进行发送。收到请求后，每个处理者都有机会对请求进行处理，或者将其传递给链上的下一个处理者。这样，请求就能在一系列处理者中传递，直到有一个处理者对其进行处理为止。    </p>
<p>1.<u>递归方式</u> ：在递归模式中，每个处理者内部调用下一个处理者的处理方法。如果当前处理者无法处理请求，它会直接调用下一个处理者的处理方法。这种方式通常是通过<strong>递归调用</strong>来实现的<br>2.<u>迭代模式</u>：在迭代模式中，处理者链被构建为一个线性结构，每个处理者都有一个指向下一个处理者的引用。请求从链的第一个处理者开始，依次传递给下一个处理者，直到找到能够处理该请求的处理者为止。这种方式通常是通过循环迭代来实现的<br><strong>代理模式</strong>：为了控制对远程服务的访问，我使用了代理模式。代理负责处理所有与服务对象的交互，并在必要时进行延迟加载。</p>
<p>在我的项目中结合<strong>工厂模式</strong>和<strong>策略模式</strong>来设计登录接口时，我们可以将登录验证的逻辑抽象为一个策略接口，并为每种登录方式（如：用户名密码登录、手机验证码登录、社交账号登录等）实现具体的策略类。工厂类则负责创建并管理这些策略对象</p>
<h6 id="思考一个问题：哪些方式创建单例模式？"><a href="#思考一个问题：哪些方式创建单例模式？" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全"><a href="#1-懒汉式，线程不安全" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。容易浪费资源</p>
<pre><code>public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁"><a href="#4-双重校验锁" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code>public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code>public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
<h4 id="MySQL支持四种隔离级别"><a href="#MySQL支持四种隔离级别" class="headerlink" title="MySQL支持四种隔离级别"></a><span style = "color:red"><u>MySQL支持四种隔离级别</u></span></h4><ul>
<li><p><u>第一个</u>是<strong>读未提交</strong>(readuncomm itted)它解决不了刚才提出的所有问题，一般项目中也不用这个。存在脏读问题  可解决不可重复读 幻读<br><code>**不可解决脏读**：读未提交允许一个事务读取另一个事务尚未提交的数据变更。如果一个事务读取了另一个事务的未提交数据，然后那个事务回滚，则第一个事务读取的数据就是无效的（脏数据）</code></p>
</li>
<li><p><u>第二个</u>是<strong>读已提交</strong>(readcomm ited)它能解决脏读的问题的，但是解决不了不可重复读和幻读。<br><code>**解决脏独**：读已提交确保一个事务只能读取已经提交的数据变更。如果一个事务正在修改某些数据，那么在它提交之前，其他事务不能读取这些数据。这样就可以避免脏读。</code><br><code>**不可解决不可重复读**：一个事务在读取某些数据后，另一个事务修改了这些数据并提交，导致第一个事务再次读取时得到不同的结果</code><br><code>**不可解决幻读**：一个事务在读取某个范围的数据后，另一个事务插入了一些新数据并提交，导致第一个事务在执行范围查询时看到了新插入的数据</code></p>
</li>
<li><p><u>第三个</u>是<strong>可重复读</strong>(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读[解决了一部分]，这个也是mysql默认的隔离级别。</p>
</li>
<li><p><u>第四个</u>是<strong>串行化</strong>(serializable)它可以解决刚才提出来的所有问题，但是由于让是事务串行执行的，性能比较低。<br>串行化里的读也要加锁 表锁：整个表上锁            行锁：只对一行加锁<br><code>串行化是最严格的事务隔离级别。它通过强制事务串行执行来避免上述所有问题。在一个事务执行时，它会锁定涉及的所有数据行或表，直到事务完成。这确保了事务完全隔离，但是会显著降低系统的并发性能</code></p>
</li>
</ul>
<h6 id="什么时候上行锁-x2F-表锁？"><a href="#什么时候上行锁-x2F-表锁？" class="headerlink" title="什么时候上行锁&#x2F;表锁？"></a>什么时候上行锁&#x2F;表锁？</h6><p><code>INSERT</code>不带查询筛选条件  <strong>上行锁</strong><del>底层是索引，b+树底层叶子</del></p>
<blockquote>
<ul>
<li><strong>行锁</strong>：通常情况下，插入操作会锁定插入行所在的索引项，以防止其他事务同时修改同一行。这是因为数据库通常使用B+树来维护索引，<strong>插入操作需要在B+树中找到正确的位置来插入新的索引项</strong>。如果插入操作涉及到唯一索引，数据库还会检查是否有重复的键值，这也会触发行锁。</li>
<li><strong>注意</strong>：即使插入操作没有查询筛选条件，它仍然可能涉及到行锁，因为数据库需要保证新插入的数据不会与现有数据冲突。</li>
</ul>
</blockquote>
<p><code>UPDATE</code>看where后面的条件 <strong>带索引</strong>加行锁<del>构建b+树</del> <strong>不带索引</strong>的加表锁<br>表锁的速度比行锁速度快</p>
<blockquote>
<h6 id="带索引的条件："><a href="#带索引的条件：" class="headerlink" title="带索引的条件："></a>带索引的条件：</h6><ul>
<li><strong>行锁</strong>：如果更新操作的条件是索引列，数据库能够快速定位到需要更新的行，因此只会锁定那些特定的行。行锁可以最大程度地减少锁定的数据量，从而提高并发性能。</li>
<li><strong>原理</strong>：数据库使用B+树索引来快速查找满足条件的行，然后对这些行加锁。</li>
</ul>
<h6 id="不带索引的条件："><a href="#不带索引的条件：" class="headerlink" title="不带索引的条件："></a>不带索引的条件：</h6><ul>
<li><strong>表锁</strong>：如果更新操作的条件不是索引列，数据库可能需要扫描整个表来找到需要更新的行。在这种情况下，为了简化锁定逻辑并防止在扫描过程中数据被修改，数据库可能会选择锁定整个表。</li>
<li><strong>原理</strong>：由于没有索引可以利用，数据库必须检查每一行来确定是否满足更新条件，因此使用表锁可以避免复杂的锁定管理。</li>
</ul>
</blockquote>
<p>MVCC底层是多版本并发控制 但底层并不怎么了解</p>
<h4 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h4><p><strong>浅拷贝</strong>：只复制对象的<strong>基本数据类型</strong>和<strong>引用类型地址</strong>，不复制引用类型指向的对象。如果原对象和浅拷贝对象中的一个改变了引用类型，另一个也会受到影响。旧对象改变新对象也会改变。<br><strong>深拷贝</strong>：创建一个新的对象，并复制对象的所有字段，包括基本数据类型和引用类型指向的对象。原对象和深拷贝对象之间不会相互影响。旧对象改变新对象不会改变<br>  Java是值传递 </p>
<h6 id="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"><a href="#如何实现深拷贝？数组不需要重写【体现了原型设计模式】" class="headerlink" title="如何实现深拷贝？数组不需要重写【体现了原型设计模式】"></a>如何实现深拷贝？<del>数组不需要重写</del>【体现了<code>原型设计模式</code>】</h6><ul>
<li><p>实现<strong>Cloneable接口</strong>并重写<strong>clone</strong>方法 会调用构造方法</p>
<p>这是最常见的实现深拷贝的方法。首先，你的类需要实现<code>Cloneable</code>接口，然后重写<code>clone()</code>方法<del>构造新对象的过程</del>，并在该方法中调用<code>super.clone()</code>，同时递归地克隆所有引用类型的字段。[如果里面有多层嵌套复杂对象 在每层都要实现Cloneable接口一直重写到基本数据类型的时候才停止]</p>
</li>
</ul>
<pre><code class="java">public class Person implements Cloneable &#123;
    private int age;
    private Address address;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Person cloned = (Person) super.clone();
        // 假设Address也实现了Cloneable接口
        cloned.address = (Address) this.address.clone(); 
        return cloned;
    &#125;
&#125;

public class Address implements Cloneable &#123;
    private String street;
    private String city;

    // 构造器、getter、setter 省略

    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;
</code></pre>
<ul>
<li>通过<strong>序列化</strong><del>对象转二进制</del>和<strong>反序列化</strong><del>二进制转对象</del>。这种方式不需要实现<code>Cloneable</code>接口，但你的类需要实现<code>Serializable</code>接口。反序列化不会调用构造方法</li>
</ul>
<h4 id="开启线程的时候为什么用的是thread-start方法："><a href="#开启线程的时候为什么用的是thread-start方法：" class="headerlink" title="开启线程的时候为什么用的是thread.start方法："></a>开启线程的时候为什么用的是thread.start方法：</h4><p>thread.start()方法用于<strong>启动一个新线程</strong>，并执行<strong>该线程</strong>的run()方法。调用start()方法后，线程会被放入线程调度队列，等待CPU调度执行。</p>
<p>直接调用run()方法，并<strong>不会启动</strong>一个新线程，而是在当前线程中执行run()方法，这不符合多线程编程的目的。使用start()方法可以确保线程并发执行，提高程序的性能和响应速度。</p>
<p>java没权限开启一个线程 要调用底层的操作系统 在JVM的底层实现中，会有相应的本地（C或C++）方法来处理线程的创建和管理</p>
<h4 id="你在你们项目中使用过多线程吗"><a href="#你在你们项目中使用过多线程吗" class="headerlink" title="你在你们项目中使用过多线程吗?"></a>你在你们项目中使用过多线程吗?</h4><p>是的，在我们的项目中，我确实使用过多线程。 【结合项目去说】<br>在处理大量数据计算或执行耗时的IO操作时，我会使用Java的线程池（如ExecutorService）来并行处理任务，以提高系统的响应速度和吞吐量<br><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250107153246645.png" alt="image-20250107153246645"></p>
<blockquote>
<h6 id="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"><a href="#我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统" class="headerlink" title="我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统"></a>我们将使用多线程来处理一个在线电子商务平台的后台订单处理系统</h6><h5 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h5><p>该系统需要处理大量的订单，包括订单验证、库存检查、支付处理和订单状态更新。为了提高处理效率，我们决定使用多线程来并行处理订单。</p>
<pre><code class="java">import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.Random;

public class OrderProcessingSystem &#123;

    public static void main(String[] args) &#123;
        // 创建一个固定大小的线程池
        int numberOfProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numberOfProcessors);

        // 模拟订单队列
        Random random = new Random();
        for (int orderId = 1; orderId &lt;= 100; orderId++) &#123;
            int finalOrderId = orderId;
            executor.submit(() -&gt; &#123;
                processOrder(finalOrderId, random.nextInt(1000));
            &#125;);
        &#125;

        // 关闭线程池
        executor.shutdown();
        try &#123;
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) &#123;
                executor.shutdownNow();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        &#125;
    &#125;

    private static void processOrder(int orderId, int orderAmount) &#123;
        System.out.println(&quot;Processing order ID: &quot; + orderId + &quot; - Thread: &quot; + Thread.currentThread().getName());
        
        // 模拟订单验证
        validateOrder(orderId);
        
        // 模拟库存检查
        checkInventory(orderId);
        
        // 模拟支付处理
        processPayment(orderId, orderAmount);
        
        // 更新订单状态
        updateOrderStatus(orderId, &quot;Completed&quot;);
    &#125;

    private static void validateOrder(int orderId) &#123;
        // 模拟订单验证逻辑
        try &#123;
            Thread.sleep(100);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Order ID &quot; + orderId + &quot; validated.&quot;);
    &#125;

    private static void checkInventory(int orderId) &#123;
        // 模拟库存检查逻辑
        try &#123;
            Thread.sleep(200);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Inventory checked for Order ID &quot; + orderId + &quot;.&quot;);
    &#125;

    private static void processPayment(int orderId, int orderAmount) &#123;
        // 模拟支付处理逻辑
        try &#123;
            Thread.sleep(300);
        &#125; catch (InterruptedException e) &#123;
            Thread.currentThread().interrupt();
        &#125;
        System.out.println(&quot;Payment processed for Order ID &quot; + orderId + &quot; - Amount: &quot; + orderAmount);
    &#125;

    private static void updateOrderStatus(int orderId, String status) &#123;
        // 模拟订单状态更新逻辑
        System.out.println(&quot;Order ID &quot; + orderId + &quot; status updated to &quot; + status + &quot;.&quot;);
    &#125;
&#125;
</code></pre>
<p>在这个示例中，我们创建了一个固定大小的线程池，其大小等于可用处理器的数量。然后，我们模拟了一个包含100个订单的队列，并为每个订单提交了一个任务到线程池中。每个任务代表订单处理的整个流程，包括验证、库存检查、支付处理和状态更新。<strong>每个步骤都通过休眠来模拟耗时操作</strong>。最后，我们关闭线程池并等待所有任务完成。</p>
</blockquote>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong>是Thread类的一个静态方法，它使当前线程暂停执行指定的时间，但不会释放锁资源。<br><strong>wait</strong>是Object类的一个方法，它使当前线程<strong>暂停执行</strong>并<strong>释放当前对象上的锁</strong>，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者过了指定的等待时间。</p>
<p>sleep是线程内的静态方法 需要指定睡眠的时间 或者自动自己唤醒 不会释放锁<br>wait是Object类的一个方法 可以指定睡眠时间 不指定就等于无限期 要释放锁<br>wait一定要搭配<code>synchronized</code>，且都为同一个对象 synchronized锁住了wait<del>万物对象皆为锁</del><br>可以被唤醒<code>notify()</code>或<code>notifyAll()</code>方法   区别：notify是随机唤醒一个 notifyall会唤醒全部</p>
<p>普通方法上 锁的是this<br>静态方法上 锁的是当前类的class对象</p>
<h4 id="ConcurrentHashMap-和-HashTable的区别"><a href="#ConcurrentHashMap-和-HashTable的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable的区别"></a>ConcurrentHashMap 和 HashTable的区别</h4><h6 id="是否支持传入NULL"><a href="#是否支持传入NULL" class="headerlink" title="是否支持传入NULL"></a>是否支持传入NULL</h6><p>HashMap可以支持为null<br>若尝试将 <code>null</code> 作为键或值放入 <code>ConcurrentHashMap</code> 将会抛出 <code>NullPointerException</code><br>ConcurrentHashMap 不能支持存null</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p>ConcurrentHashMap 1.8之前是分段锁来实现 默认是16个HashTable<br>1.8之后无限接近单个的HashMap  底层用CAS+synchronized<br>HashTable通过加<code>synchronized</code>锁来控制线程安全 </p>
<p>ConcurrentHashMap 读不要加锁 [读写的读也不会加锁] 会走最终一致性<br>HashTable 读要加锁 [读读都加锁]</p>
<h4 id="为什么要用Redis"><a href="#为什么要用Redis" class="headerlink" title="为什么要用Redis"></a>为什么要用Redis</h4><p><strong>高性能</strong>：Redis是<strong>基于内存</strong>的数据结构存储，可以提供高速的数据读写操作。<br><strong>数据结构丰富</strong>：Redis支持多种数据结构，如字符串、列表、集合、散列表、有序集合等，非常适合各种场景。<br><strong>持久化</strong>：Redis支持<strong>数据持久化</strong>，可以将内存中的数据<strong>保存到磁盘</strong>中，防止数据丢失。<br><strong>分布式</strong>：Redis支持<strong>主从复制</strong>、<strong>哨兵</strong>和<strong>集群模式</strong>，可以轻松实现分布式缓存。</p>
<h4 id="Redis中缓存了哪些数据"><a href="#Redis中缓存了哪些数据" class="headerlink" title="Redis中缓存了哪些数据"></a>Redis中缓存了哪些数据</h4><h6 id="可以存储一下类型的数据"><a href="#可以存储一下类型的数据" class="headerlink" title="可以存储一下类型的数据"></a>可以存储一下类型的数据</h6><blockquote>
<ol>
<li><strong>会话缓存（Session Store）</strong>：用户会话信息，如用户登录状态、用户偏好设置等。</li>
<li><strong>页面缓存</strong>：动态生成的网页内容，以减少数据库的读取次数。</li>
<li><strong>对象缓存</strong>：例如，用户信息、商品详情等，减少数据库访问。</li>
<li><strong>消息队列</strong>：用作消息队列，处理异步任务。</li>
<li><strong>排行榜或计数器</strong>：如用户点赞数、视频播放次数等。</li>
<li><strong>地理空间数据</strong>：用于实现基于地理位置的查询。</li>
<li><strong>分布式锁</strong>：在分布式系统中协调不同服务或节点的操作</li>
</ol>
</blockquote>
<h6 id="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："><a href="#关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：" class="headerlink" title="关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明："></a>关于您提到的替代JWT的方案，即使用Redis来管理登录状态而不是使用JWT，这里有一些详细说明：</h6><p>若放登录的信息到Redis的时候 不再用JWT了<br>Session在集群里面不能用了<br>替代方案：<span style = "color:red"><strong>用Redis 不用JWT</strong></span><br>JWT是无状态 无需集中存储</p>
<p>在我们的项目中，Redis中缓存了以下类型的数据：<br>会话信息：如用户登录信息、购物车内容等。<br><strong>热点数据</strong>：如热门商品信息、推荐内容等。<br><strong>计数器</strong>：如用户访问次数、点赞数、评论数等。<br>缓存数据库查询结果：减少数据库访问次数，提高系统响应速度。</p>
<blockquote>
<h3 id="JWT（JSON-Web-Tokens）"><a href="#JWT（JSON-Web-Tokens）" class="headerlink" title="JWT（JSON Web Tokens）"></a>JWT（JSON Web Tokens）</h3><p>JWT是一种在各方之间传递安全可靠信息的简洁的、URL安全的表达方式。其特点包括：</p>
<ul>
<li><strong>无状态</strong>：服务器不存储任何会话信息，每个请求都携带包含所有必要信息的JWT。</li>
<li><strong>自包含</strong>：JWT中包含了用户的所有声明，减少了服务器的数据库查询。</li>
<li><strong>跨域认证</strong>：特别适用于单点登录（SSO）。</li>
</ul>
<h3 id="JWT的局限性"><a href="#JWT的局限性" class="headerlink" title="JWT的局限性"></a>JWT的局限性</h3><ul>
<li><strong>无法失效</strong>：一旦签发了JWT，在它过期之前，它在任何地方都是有效的，无法提前失效。</li>
<li><strong>续签问题</strong>：JWT过期后需要重新签发，处理起来相对复杂。</li>
<li><strong>携带信息量大</strong>：每个请求都携带JWT，如果JWT中包含的信息较多，会增加请求的大小。</li>
</ul>
<h3 id="使用Redis替代JWT"><a href="#使用Redis替代JWT" class="headerlink" title="使用Redis替代JWT"></a>使用Redis替代JWT</h3><p>使用Redis作为会话存储，可以解决JWT的一些问题：</p>
<ol>
<li><strong>中心化控制</strong>：通过Redis，服务器可以集中管理会话信息，可以随时使会话失效。</li>
<li><strong>灵活的过期策略</strong>：可以设置更细粒度的过期时间，并在需要时刷新会话。</li>
<li><strong>状态管理</strong>：对于需要频繁更改用户状态的应用，使用Redis可以更方便地管理。</li>
<li><strong>安全性</strong>：虽然Redis存储会话信息，但可以结合HTTPS和合适的加密策略来保证传输过程的安全</li>
</ol>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ol>
<li><strong>用户登录</strong>：用户登录成功后，生成一个唯一的会话标识（如UUID），并将其作为key存储在Redis中，value可以是用户ID或者其他必要信息，并设置适当的过期时间。</li>
<li><strong>请求验证</strong>：用户每次请求时，需要在请求头中携带会话标识，服务器端通过这个标识在Redis中查找会话信息，进行验证。</li>
<li><strong>会话过期或失效</strong>：当用户登出或会话过期时，从Redis中删除对应的会话信息。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>数据持久性</strong>：Redis的数据是存储在内存中的，需要考虑持久化策略以防止数据丢失。</li>
<li><strong>高可用性</strong>：在集群环境下，需要配置Redis的高可用方案，如哨兵（Sentinel）或集群模式。</li>
<li><strong>安全性</strong>：确保Redis的安全性，防止未授权访问。</li>
</ul>
</blockquote>
<h4 id="检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考"><a href="#检测数据存在Redis中，有过期时间吗-过期时间是多少-仅参考" class="headerlink" title="检测数据存在Redis中，有过期时间吗? 过期时间是多少?仅参考"></a>检测数据存在Redis中，有过期时间吗? 过期时间是多少?<del>仅参考</del></h4><p>是的，我们在Redis中缓存的数据通常会设置过期时间，以避免过时的数据占用内存。具体的过期时间取决于数据的类型和业务需求。对于会话信息，我们可能会设置较短的过期时间，如30分钟或1小时；而对于热点数据，可能会设置较长的过期时间，如几小时或一天。具体的过期时间需要根据实际业务场景和数据访问模式来决定。</p>
<pre><code class="java">   // 用户登录，创建会话
    public String loginUser(String userId) &#123;
        String sessionId = UUID.randomUUID().toString();
        String sessionData = createSessionData(userId);
        jedis.setex(sessionId, 1800, sessionData); // 设置会话过期时间为30分钟
        return sessionId;
    &#125;
</code></pre>
<h4 id="微服务之间如何调用？"><a href="#微服务之间如何调用？" class="headerlink" title="微服务之间如何调用？"></a>微服务之间如何调用？</h4><p>通过注册中心去协调的<br>首先是有三个重要的概念，<strong>服务消费者</strong>，<strong>注册中心</strong>，<strong>服务提供者</strong>提供者在第一次会把自己的信息注册到注册中心中，比如ip端口，服务功能等消费者需要到注册中心来寻找服务进行消费，<strong>在服务消费者第一次请求的时候会拉取服务提供者的信息，注册中心会把提供者的实例列表给到消费者供消费者选择，使用负载均衡来选择服务</strong>，默认为轮询，还有加权轮询，随机。<strong>同时服务消费者还会定时去注册中心拉取服务提供者的信息</strong></p>
<h6 id="如果我们的服务挂掉了怎么办"><a href="#如果我们的服务挂掉了怎么办" class="headerlink" title="如果我们的服务挂掉了怎么办?"></a>如果我们的服务挂掉了怎么办?</h6><p>服务提供者会每隔一段时间去向注册中心报告自己的状态[发送心跳ping 30s&#x2F;次 共90s]，如果没有向注册中心报告状态，那么这个时候注册中心会认为服务提供者已经宕机，同时会推送到我们的服务消费者，这个服务提供者已经宕机</p>
<h4 id="微服务的五大组件"><a href="#微服务的五大组件" class="headerlink" title="微服务的五大组件"></a>微服务的五大组件</h4><ol>
<li><strong>服务注册与发现</strong>：如Eureka<del>已过时</del>、<strong>Nacos</strong>、Consul，用于服务的注册和发现。</li>
<li><strong>配置管理</strong>：如Spring Cloud Config、<strong>OpenFeign</strong> 用于集中管理服务的配置。</li>
</ol>
<p><code>Feign是一个声明式的Web服务客户端（Web服务客户端就是Http客户端），让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可。</code></p>
<p>&#96;&#96;OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。&#96;</p>
<pre><code class="java">@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;
&#125;

@Component
@FeignClient(url = &quot;http://localhost/8001&quot;)
public interface PaymentFeignService&#123;
&#125;
</code></pre>
<blockquote>
<pre><code class="java">二、OpenFeign使用
2.1.OpenFeign 常规远程调用
所谓常规远程调用，指的是对接第三方接口，和第三方并不是微服务模块关系，所以肯定不可能通过注册中心来调用服务。

第一步：导入OpenFeign的依赖

第二步：启动类需要添加@EnableFeignClients
    
第三步：提供者的接口
@RestController
@RequestMapping(&quot;/test&quot;)
public class FeignTestController &#123;

    @GetMapping(&quot;/selectPaymentList&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize) &#123;
        System.out.println(pageIndex);
        System.out.println(pageSize);
        Payment payment = new Payment();
        payment.setSerial(&quot;222222222&quot;);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + payment);
    &#125;

    @GetMapping(value = &quot;/selectPaymentListByQuery&quot;)
    public CommonResult&lt;Payment&gt; selectPaymentListByQuery(Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @PostMapping(value = &quot;/create&quot;, consumes = &quot;application/json&quot;)
    public CommonResult&lt;Payment&gt; create(@RequestBody Payment payment) &#123;
        System.out.println(payment);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;

    @GetMapping(&quot;/getPaymentById/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id) &#123;
        System.out.println(id);
        return new CommonResult(200, &quot;查询成功, 服务端口：&quot; + null);
    &#125;
    
第四步：消费者调用提供者接口
@FeignClient(name = &quot;feignTestService&quot;, url = &quot;http://localhost/8001&quot;)
public interface FeignTestService &#123;

    @GetMapping(value = &quot;/payment/selectPaymentList&quot;)
    CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize);

    @GetMapping(value = &quot;/payment/selectPaymentListByQuery&quot;)
    CommonResult&lt;Payment&gt; selectPaymentListByQuery(@SpringQueryMap Payment payment);

    @PostMapping(value = &quot;/payment/create&quot;, consumes = &quot;application/json&quot;)
    CommonResult&lt;Payment&gt; create(@RequestBody Payment payment);

    @GetMapping(&quot;/payment/getPaymentById/&#123;id&#125;&quot;)
    CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) String id);
&#125;
</code></pre>
</blockquote>
<ol>
<li><strong>服务网关</strong>：如Zuul、Spring Cloud <strong>Gateway</strong>，作为系统的唯一入口，处理外部请求的路由和过滤。</li>
<li><strong>负载均衡</strong>：如<strong>Ribbon</strong>，用于在多个服务实例之间分配请求。</li>
<li><strong>断路器</strong>：如<strong>Hystrix</strong>，用于服务熔断，防止系统雪崩</li>
</ol>
<h4 id="对于服务注册这块有什么了解？"><a href="#对于服务注册这块有什么了解？" class="headerlink" title="对于服务注册这块有什么了解？"></a>对于服务注册这块有什么了解？</h4><ul>
<li><strong>服务注册中心</strong>：服务实例在启动时向服务注册中心注册自己的地址和端口信息。检查 心跳 如果未查询就剔除，同时也有注册中心主动发起请求。</li>
<li><strong>健康检查</strong>：服务注册中心通常会定期对已注册的服务进行健康检查，以确保服务的可用性。</li>
<li><strong>服务发现</strong>：服务消费者通过服务注册中心查找可用的服务实例，以进行服务调用。</li>
<li><strong>服务去注册</strong>：当服务实例关闭或出现故障时，它需要从服务注册中心注销，以避免调用不可用的服务。</li>
</ul>
<h4 id="你能说一下小程序的登录流程吗"><a href="#你能说一下小程序的登录流程吗" class="headerlink" title="你能说一下小程序的登录流程吗?"></a>你能说一下小程序的登录流程吗?</h4><p>调用微信api，根据code获取openid；根据openid查询用户为空就新增；调用微信api <code>WechatService + WechatServiceImpl</code>(openId+phoneCode) 获取用户绑定的手机号；保存或修改该用户；将用户id存入token返回(JWT生成token)</p>
<h4 id="有哪些方式可以创建单例？"><a href="#有哪些方式可以创建单例？" class="headerlink" title="有哪些方式可以创建单例？"></a>有哪些方式可以创建单例？</h4><ol>
<li><strong>饿汉式</strong>：在<strong>类加载</strong>时就立即初始化并创建单例对象。</li>
<li><strong>懒汉式</strong>：在<strong>第一次调用时</strong>初始化单例对象，通常需要考虑线程安全问题。</li>
<li><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</li>
<li><strong>静态内部类</strong>：利用静态内部类的加载机制来确保单例对象的唯一性。</li>
<li><strong>枚举</strong>：利用枚举的特性，保证单例对象的唯一性和线程安全【不可用反射】</li>
</ol>
<h6 id="并发情况下严格控制单例？volatile→禁止进行指令重排序"><a href="#并发情况下严格控制单例？volatile→禁止进行指令重排序" class="headerlink" title="并发情况下严格控制单例？volatile→禁止进行指令重排序"></a>并发情况下严格控制单例？<del>volatile→禁止进行指令重排序</del></h6><p><strong>双重校验锁</strong>：在懒汉式的基础上，通过双重校验锁确保线程安全。</p>
<blockquote>
<h6 id="思考一个问题：哪些方式创建单例模式？-1"><a href="#思考一个问题：哪些方式创建单例模式？-1" class="headerlink" title="思考一个问题：哪些方式创建单例模式？"></a>思考一个问题：哪些方式创建单例模式？</h6><blockquote>
<h3 id="1-懒汉式，线程不安全-1"><a href="#1-懒汉式，线程不安全-1" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h3><p>这种方式在类加载时不初始化。在需要的时候才创建对象，节约资源。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="2-懒汉式，线程安全-1"><a href="#2-懒汉式，线程安全-1" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h3><p>通过同步方法确保线程安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance;
    private Singleton() &#123;&#125;

    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="3-饿汉式-1"><a href="#3-饿汉式-1" class="headerlink" title="3. 饿汉式"></a>3. 饿汉式</h3><p>类加载时就完成了初始化，保证了线程的安全性。</p>
<pre><code class="java">public class Singleton &#123;
    private static Singleton instance = new Singleton();
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h3 id="4-双重校验锁-1"><a href="#4-双重校验锁-1" class="headerlink" title="4. 双重校验锁"></a>4. 双重校验锁</h3><p>线程安全且在实例域需要延迟加载时提高性能。</p>
<pre><code class="java">public class Singleton &#123;
    private volatile static Singleton singleton;
    private Singleton() &#123;&#125;

    public static Singleton getInstance() &#123;
        if (singleton == null) &#123;
            synchronized (Singleton.class) &#123;
                if (singleton == null) &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h3 id="5-静态内部类-1"><a href="#5-静态内部类-1" class="headerlink" title="5. 静态内部类"></a>5. 静态内部类</h3><p>这种方式既实现了懒加载，又保证了线性安全。</p>
<pre><code class="java">public class Singleton &#123;
    private static class SingletonHolder &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;
    private Singleton() &#123;&#125;

    public static final Singleton getInstance() &#123;
        return SingletonHolder.INSTANCE;
    &#125;
&#125;
</code></pre>
<h3 id="6-枚举-1"><a href="#6-枚举-1" class="headerlink" title="6. 枚举"></a>6. 枚举</h3><p>实现单例的最佳方法，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象。</p>
<pre><code class="java">public enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;
</code></pre>
</blockquote>
</blockquote>
<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><ul>
<li><p><strong>公平锁</strong>：多个线程按照它们请求<strong>锁的顺序</strong>来获取锁，<strong>先来先得</strong>。这种方式不会产生饥饿现象，但可能会<strong>降低吞吐量</strong>，因为需要额外的开销来维护等待队列的顺序。【僵尸线程】<u>对资源顺序有严格要求</u></p>
<blockquote>
<h6 id="为什么会降低吞吐量？"><a href="#为什么会降低吞吐量？" class="headerlink" title="为什么会降低吞吐量？"></a>为什么会降低吞吐量？</h6><ol>
<li><strong>维护等待队列</strong>：公平锁为了保证按照请求锁的顺序来获取锁，必须维护一个有序的等待队列。这意味着每次有线程请求锁或者释放锁时，都需要进行额外的操作来管理这个队列，这会增加开销。</li>
<li><strong>上下文切换开销</strong>：当锁被释放时，公平锁需要唤醒等待队列中的第一个线程。这个过程涉及到线程的上下文切换，上下文切换是有成本的，因为它涉及到保存和恢复线程的状态。</li>
<li><strong>减少并发机会</strong>：由于公平锁要求先来先得，即使锁被释放，后请求锁的线程即使处于可运行状态，也必须等待前面的线程先执行。这可能会减少并发执行的机会，从而降低吞吐量。</li>
<li><strong>增加延迟</strong>：公平锁可能会增加线程获取锁的平均等待时间，因为每个线程都必须等待前一个线程完成。这种延迟可能会导致系统整体性能下降。</li>
</ol>
</blockquote>
</li>
<li><p><strong>非公平锁</strong>：线程获取锁的顺序不一定是按照请求锁的顺序，允许线程“插队”。这种方式可能会提高吞吐量，但可能导致某些线程长时间无法获取锁，产生饥饿现象。【为什么性能高？不用沉睡和阻塞 避免来回切换】<u>对性能要求高</u></p>
</li>
</ul>
<h6 id="ReentrantLock-看传参-公平-x2F-非公平都支持"><a href="#ReentrantLock-看传参-公平-x2F-非公平都支持" class="headerlink" title="ReentrantLock 看传参 公平&#x2F;非公平都支持"></a>ReentrantLock 看传参 <u>公平&#x2F;非公平</u>都支持</h6><pre><code class="java">ReentrantLock 是Java提供的显式锁，它允许你通过构造函数参数来选择是使用公平锁还是非公平锁：

公平锁（Fair Lock）：通过传递true给ReentrantLock的构造函数来创建。这确保了锁的获取是按照线程请求锁的顺序进行的，防止饥饿现象。
ReentrantLock fairLock = new ReentrantLock(true);

非公平锁（Non-Fair Lock）：通过传递false或者不传递参数（默认值）给ReentrantLock的构造函数来创建。这种方式允许线程“插队”，可能会提高吞吐量，但也可能导致某些线程长时间无法获取锁。
ReentrantLock nonFairLock = new ReentrantLock(false); // 或者
ReentrantLock nonFairLock = new ReentrantLock(); // 默认是非公平锁
</code></pre>
<h6 id="Synchronized-公平锁"><a href="#Synchronized-公平锁" class="headerlink" title="Synchronized 公平锁"></a>Synchronized 公平锁</h6><pre><code class="java">从Java 6开始，synchronized的实现得到了改进，它试图实现一种偏向锁和轻量级锁的策略，以提高性能。
以下是关于synchronized的一些关键点：

偏向性：synchronized在锁竞争不激烈的情况下，会尝试偏向第一个获取锁的线程，这有助于减少不必要的同步开销。
轻量级锁：当没有竞争时，synchronized会使用轻量级锁，这比使用操作系统提供的重量级锁要快得多。
重量级锁：当存在竞争时，synchronized会升级为重量级锁，这涉及到操作系统的线程调度。

synchronized不会严格地保证公平性，因为它允许锁的“重入”和偏向性，这意味着它更倾向于非公平锁的行为。然而，在锁竞争激烈的情况下，synchronized会尽量保持一定的公平性，因为它会按照线程在监视器队列中的顺序来获取锁。

总的来说，synchronized不是严格意义上的公平锁，但它的实现细节和调度策略可能会在一定程度上表现出公平锁的特性。与ReentrantLock相比，synchronized的锁获取机制更为复杂，并且它是由JVM内部实现的，因此具体的调度细节对开发者来说是透明的。
</code></pre>
<h4 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h4><ul>
<li><p>前端的HTTP请求到达时首先被<strong>DispatcherServlet</strong>接收</p>
</li>
<li><p>DispatcherServlet根据请求信息<del>路径</del>查找合适的<strong>HandlerMapping</strong>来确定哪个<strong>Controller</strong>应该处理该请求。</p>
</li>
<li><p>找到合适的Controller后，DispatcherServlet将请求转发给它处理。</p>
</li>
<li><p>Controller处理完请求后返回一个<strong>ModelAndView</strong>对象给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet再通过<strong>ViewResolver</strong>解析ModelAndView中的视图逻辑名，找到对应的视图。</p>
</li>
<li><p>最后，DispatcherServlet将模型数据渲染到视图上并响应给客户端。</p>
</li>
</ul>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250206094925513.png" alt="image-20250206094925513"></p>
<h4 id="OpenFeign的底层原理"><a href="#OpenFeign的底层原理" class="headerlink" title="OpenFeign的底层原理"></a>OpenFeign的底层原理</h4><p>OpenFeign 实现了简洁、声明式的 HTTP 请求调用，并且与 Spring Cloud 集成后能提供更多的功能如负载均衡等</p>
<p><strong>动态代理</strong>： OpenFeign 使用 Java 动态代理技术，基于接口创建代理类，代理类会自动发起 HTTP 请求。你定义的接口方法会映射到 HTTP 请求上，OpenFeign 会根据注解（如 <code>@RequestMapping</code>, <code>@GetMapping</code> 等）来构建请求。</p>
<p><strong>注解解析</strong>： OpenFeign 会解析接口方法上的注解，构造 HTTP 请求的 URL、请求方法类型（GET、POST 等），以及请求体和请求头等信息。</p>
<p><strong>请求拦截和处理</strong>： 在请求发起之前，OpenFeign 允许通过拦截器（<code>RequestInterceptor</code>）来修改请求，比如设置请求头、参数等。</p>
<p><strong>负载均衡与容错</strong>： 如果与 Spring Cloud 一起使用，OpenFeign 会集成 Ribbon（负载均衡）和 Hystrix（容错），使得服务调用更加健壮和可靠。</p>
<p><strong>序列化与反序列化</strong>： OpenFeign 会利用 Jackson 等库进行请求和响应的序列化和反序列化，将 Java 对象与 HTTP 请求&#x2F;响应内容相互转换</p>
<p>在使用OpenFeign时，开发者只需要定义接口并添加相应的注解，OpenFeign会在运行时动态生成实现类来执行HTTP请求。</p>
<h4 id="对Volatile的理解"><a href="#对Volatile的理解" class="headerlink" title="对Volatile的理解"></a>对Volatile的理解</h4><p><code>volatile</code> 是Java语言中的一个关键字，用于修饰变量，以确保该变量的读写操作对所有线程立即可见，并且防止指令重排序优化。</p>
<p>确保了不同线程对这个变量进行读写操作时的可见性。<br>是java的关键字是修饰共享的变量，不能修饰局部变量。<br>修饰普通或静态成员变量，主要用来保证<strong>可见性</strong>和<strong>有序性</strong>。</p>
<blockquote>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>在一个多线程程序中，为了提高性能，每个线程可能会将共享变量缓存到自己的CPU缓存中。如果一个线程修改了这个变量的值，而这个新值没有及时写回主内存，那么其他线程可能会读取到旧值。使用<code>volatile</code>关键字可以确保：</p>
<ul>
<li>每次读写变量都是直接操作主内存。</li>
<li>当一个线程修改了一个<code>volatile</code>变量时，新值会立即被写入主内存。</li>
<li>其他线程读取<code>volatile</code>变量时，会从主内存中读取最新值。</li>
</ul>
<p>这样，<code>volatile</code>就保证了不同线程之间共享变量的可见性。</p>
<h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><p>在没有<code>volatile</code>修饰的变量上，Java编译器和处理器可能会进行指令重排序，以提高程序运行的效率。指令重排序可能会导致程序的执行顺序与代码的编写顺序不一致。使用<code>volatile</code>可以防止以下两种类型的重排序：</p>
<ul>
<li><strong>写操作的重排序</strong>：<code>volatile</code>变量的写操作不允许与它之前的操作重排序。</li>
<li><strong>读操作的重排序</strong>：<code>volatile</code>变量的读操作不允许与它之后的操作重排序。</li>
</ul>
<p>这样，<code>volatile</code>就提供了一定的有序性保证。</p>
</blockquote>
<h4 id="Spring-Security的实现"><a href="#Spring-Security的实现" class="headerlink" title="Spring Security的实现"></a>Spring Security的实现</h4><p>我的项目是基于JWT的前后端分离的项目，在自定义认证管理器<code>AuthenticationManager</code>认证成功后，生成JWT令牌并返回给前端。前端在随后的请求中携带这个JWT令牌。这时候，我们使用<code>AccessDecisionManager</code>来实现接口的鉴权逻辑，其中包括一个check方法，该方法会校验JWT令牌的有效性。如果校验通过，就去查询数据库以确定用户拥有哪些权限。在用户登录时，其权限信息已经被缓存到Redis中。后续的请求中，我们可以直接从Redis中检索用户的权限信息。如果请求的接口权限与用户缓存中的权限匹配，则放行；如果不匹配，则返回一个友好的错误信息</p>
<h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>是多线程中的<del>抽象</del>队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，是一个抽象类。<br>像ReentrantLock都是基于AQS实现的</p>
<blockquote>
<p>在Java的并发编程中，<code>AbstractQueuedSynchronizer</code>（简称AQS）是一个非常重要的类，它提供了一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和其他同步器（例如信号量、事件等）。AQS 本身是一个抽象类，<strong>它内部定义了<u>获取资源（锁）</u>和<u>释放资源（锁）</u>的基本方法</strong>，以及<strong>管理同步状态</strong>和<strong>队列</strong>的机制。</p>
<p>当说“ReentrantLock是基于AQS实现的”，意味着<code>ReentrantLock</code>这个具体锁的实现类，是<strong>继承并利用了AQS提供的模板方法</strong>来构建其功能的。具体来说：</p>
<ul>
<li><strong>继承</strong>：<code>ReentrantLock</code>内部有一个内部类叫做<code>Sync</code>，这个<code>Sync</code>类直接继承自<code>AbstractQueuedSynchronizer</code>。</li>
<li><strong>实现</strong>：<code>Sync</code>类（及其子类）会根据需要重写AQS的一些方法，如<code>tryAcquire</code>和<code>tryRelease</code>，这些方法用于定义获取锁和释放锁的具体行为。</li>
<li><strong>利用模板方法</strong>：AQS提供了一系列的模板方法（如<code>acquire</code>、<code>release</code>等），这些方法内部会调用前面提到的可重写方法（如<code>tryAcquire</code>、<code>tryRelease</code>），从而允许<code>ReentrantLock</code>按照特定的逻辑来管理锁的状态。</li>
</ul>
<p>因此，<u>“基于AQS实现”的表述强调了<code>ReentrantLock</code>并不是从头开始构建锁的所有细节，而是站在AQS这个强大的基础框架之上</u>，通过实现特定的策略来完成锁的具体功能。这样做的好处是减少了代码量，提高了代码的可维护性和可重用性，并且由于AQS经过了严格的测试，基于它实现的锁也更加可靠。</p>
</blockquote>
<p>定义了一个并发情况下一些抽象的资源 资源能否<strong>共享&#x2F;独享</strong> 定义了<strong>公平&#x2F;非公平</strong><br>如果是非公平锁如果来了个新的线程来抢线程 也是会去抢一次<br>AQS成为了JUC很多类都去继承的 它<strong>抽象了很多并发的属性和行为</strong>，让子类去继承它扩展自己</p>
<h4 id="Synchronized的锁升级"><a href="#Synchronized的锁升级" class="headerlink" title="Synchronized的锁升级"></a>Synchronized的锁升级</h4><ul>
<li>Monitor实现的锁属于<strong>重量级锁</strong>，里面涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制：<strong>偏向锁和轻量级锁</strong>，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下使用传统锁机制带来的性能开销问题</li>
</ul>
<p><u>一段很长的时间内都只被一个线程使用锁</u> <strong>偏向锁</strong><br><u>有线程交替或线程加锁的时间是错开的</u> <strong>轻量级锁</strong><br><u>有很多线程来抢</u> <strong>重量级锁</strong></p>
<blockquote>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>偏向锁是一种优化锁的机制，它的设计初衷是：如果一个锁在大多数时间里只被一个线程访问，那么就没有必要进行线程间的同步操作，因为不存在锁竞争。在这种情况下，JVM会为这个锁赋予一个“偏向”，即偏向于第一个获取它的线程。在后续的锁操作中，如果该线程再次请求这个锁，就不需要进行同步操作，从而提高性能。偏向锁适用于只有一个线程访问同步块的场景。</p>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>轻量级锁是另一种锁的优化，它适用于锁竞争不是很激烈，且锁持有的时间短的场景。当线程交替访问同步块时，使用轻量级锁可以减少传统的重量级锁带来的性能开销。轻量级锁是通过在对象头中的一些标记位来实现的，当锁处于轻量级锁状态时，线程通过CAS操作来尝试获取锁，如果成功，则直接进入同步块执行，从而避免了使用操作系统级别的重量级锁机制。</p>
<h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>重量级锁是JVM中最传统的锁实现，也是性能开销最大的锁。当有很多线程同时竞争同一个锁时，JVM会使用重量级锁来确保线程安全。重量级锁依赖于操作系统的互斥量（mutex），会导致线程状态在用户态和核心态之间转换，这种转换是非常耗时的。因此，当锁竞争非常激烈时，使用重量级锁可以保证公平性和线程安全，但会带来较大的性能开销。</p>
<blockquote>
<p>在处理多线程同时竞争同一个锁的情况时，并不一定总是需要使用重量级锁。以下是一些优化和策略，可以帮助您更好地处理并发场景：</p>
<ol>
<li><strong>最小化同步范围</strong>：<ul>
<li>仅对必要的代码块进行同步，减少锁的竞争。</li>
<li>使用细粒度锁，比如对不同的数据结构使用不同的锁，而不是对整个对象加锁。</li>
</ul>
</li>
<li><strong>使用并发工具类</strong>：<ul>
<li>Java提供了许多并发工具类，如<code>java.util.concurrent</code>包中的<code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ConcurrentHashMap</code>等，它们提供了比synchronized更丰富的功能。</li>
</ul>
</li>
<li><strong>锁分离</strong>：<ul>
<li>对于读多写少的场景，可以使用读写锁（<code>ReadWriteLock</code>），它允许多个读线程同时访问，而写线程则互斥。</li>
</ul>
</li>
<li><strong>锁优化</strong>：<ul>
<li>在锁竞争不是很激烈的情况下，可以使用轻量级锁或偏向锁，这些锁的开销比重量级锁小。</li>
</ul>
</li>
<li><strong>无锁编程</strong>：<ul>
<li>使用原子类（如<code>AtomicInteger</code>、<code>AtomicReference</code>）和线程安全的数据结构，这些类通过CAS操作实现了无锁的线程安全。</li>
</ul>
</li>
<li><strong>线程池</strong>：<ul>
<li>使用线程池来管理线程，避免频繁创建和销毁线程带来的开销。</li>
</ul>
</li>
<li><strong>避免死锁</strong>：<ul>
<li>设计代码时注意锁的顺序，避免循环等待条件，减少死锁的发生。</li>
</ul>
</li>
<li><strong>性能测试</strong>：<ul>
<li>对并发代码进行性能测试，了解不同锁策略对性能的影响，并根据测试结果选择合适的锁。</li>
</ul>
</li>
</ol>
</blockquote>
</blockquote>
<p>java语言是高级语言如果想调用底层的操作系统和硬件要通过操作系统的API去操作。以前老的JDK版本 数据是在操作系统找的数据<del>锁</del>，Monitor的标志0 和 1，底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低 。<br>引入新型锁后，java里是<strong>用对象头找个地方存一把锁</strong>，这样就不涉及到调用操作系统底层。一开始new了个对象 此时是无锁状态。接下来来人拿锁，长期一个人拿到那个锁 此时是<strong>偏向锁</strong><del>竞争不激烈</del>。后面多线程一起来 <u>交替抢锁</u> 此时是<strong>轻量级锁</strong>。随着并发越来越高 此时在一个线程拿到锁后很多线程来抢锁 线程先尝试自己先获取几次(<strong>自旋锁</strong>64次未拿到锁就会升级为重量级锁) 这时就涉及到操作系统的底层对象涉及到了用户态<del>权限低</del>和内核态<del>权限高</del>的切换、进程的上下文切换，成本较高，性能比较低。锁不可逆<del>可能新版本可以降级</del></p>
<h4 id="Dockerfile-常用命令"><a href="#Dockerfile-常用命令" class="headerlink" title="Dockerfile 常用命令"></a>Dockerfile 常用命令</h4><ul>
<li><code>FROM</code>: 指定基础镜像。</li>
<li><code>ENV</code>: 设置环境变量。</li>
<li><code>RUN</code>: 执行命令并创建新的镜像层。</li>
<li><code>COPY</code>: 将文件从宿主机复制到容器中。</li>
<li><code>EXPOSE</code>: 声明容器运行时将监听的端口。</li>
<li><code>ENTRYPOINT</code>: 配置容器启动时运行的命令。</li>
</ul>
<h4 id="常用的-Docker-命令"><a href="#常用的-Docker-命令" class="headerlink" title="常用的 Docker 命令"></a>常用的 Docker 命令</h4><ul>
<li><code>docker run</code>: 创建一个新的容器并运行一个命令。</li>
<li><code>docker pull</code>: 从仓库中拉取或者更新一个镜像。</li>
<li><code>docker push</code>：推送镜像到服务</li>
<li><code>docker build</code>: 从 Dockerfile 构建一个镜像。</li>
<li><code>docker images</code>: 列出本地镜像。</li>
<li><code>docker ps</code>: 列出运行中的容器。</li>
<li><code>docker stop</code>: 停止一个运行中的容器。</li>
<li><code>docker start</code>: 启动一个停止的容器。</li>
<li><code>docker rm</code>: 删除一个容器。</li>
<li><code>docker rmi</code>: 删除一个镜像。</li>
<li><code>docker exec</code>: 在运行中的容器内执行命令。</li>
<li><code>docker logs</code>: 获取容器的日志。</li>
</ul>
<pre><code class="java">- docker volume create：创建数据卷
- docker volume ls：查看所有数据卷
- docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置
- docker volume rm：删除指定数据卷
</code></pre>
<p>Docker Compose 常用命令</p>
<ul>
<li><code>docker-compose up</code>: 启动所有服务的容器。</li>
<li><code>docker-compose down</code>: 停止并删除容器、网络、卷和镜像。</li>
<li><code>docker-compose ps</code>: 列出项目中所有的容器。</li>
<li><code>docker-compose exec</code>: 进入指定的容器。</li>
<li><code>docker-compose build</code>: 构建或重建服务。</li>
<li><code>docker-compose logs</code>: 查看服务的日志输出。</li>
<li><code>docker-compose stop</code>: 停止运行的容器。</li>
</ul>
<h4 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h4><ul>
<li><code>synchronized</code> 是Java的一个关键字<del>用于方法和代码块中</del>，而 <code>ReentrantLock</code> 是JUC包的一个类。</li>
<li><code>synchronized</code> 可以<strong>自动</strong>加锁和解锁，而 <code>ReentrantLock</code> 需要<strong>手动</strong>加锁和解锁。</li>
<li><code>synchronized</code> 的锁是非公平的，而 <code>ReentrantLock</code> 默认也是非公平的，但可以设置为公平锁。</li>
</ul>
<h4 id="你们公司是怎么部署项目的"><a href="#你们公司是怎么部署项目的" class="headerlink" title="你们公司是怎么部署项目的"></a>你们公司是怎么部署项目的</h4><p>是通过docker + jenkins<br>测试环境我们参与 生产环境组长部署</p>
<h4 id="varchar-与-char-区别"><a href="#varchar-与-char-区别" class="headerlink" title="varchar 与 char 区别"></a>varchar 与 char 区别</h4><ul>
<li><code>varchar</code> 是可变长度的字符串，而 <code>char</code> 是固定长度的字符串。</li>
<li><code>varchar</code> 的性能通常比 <code>char</code> 差，因为需要处理额外的长度信息。</li>
<li>当数据长度变化很大时，推荐使用 <code>varchar</code>；当数据长度几乎固定时，使用 <code>char</code> 可能更合适。</li>
</ul>
<h4 id="Redis的持久化有哪几种-它们的区别是什么"><a href="#Redis的持久化有哪几种-它们的区别是什么" class="headerlink" title="Redis的持久化有哪几种? 它们的区别是什么?"></a>Redis的持久化有哪几种? 它们的区别是什么?</h4><p>完整性 大小 数据恢复速度 建议</p>
<p><strong>Redis持久化</strong>：RDB全称Redis Database Backup file(Redis数据备份文件)，也被叫做Redis数据快照，简单来说就是<u>把内存中的所有数据都记录到磁盘中</u>。当Redis实例故障重启后，从磁盘读取快照文件，数据恢复。</p>
<pre><code class="mysql">[root@localhost ~]# redis-cli
127.0.0.1:6379&gt; save          #由Redis主进程来执行RDB，会阻塞所有命令
ok

127.0.0.1:6379&gt; bgsave        #开启子进程执行RDB，避免主进程受到影响
Background saving started
</code></pre>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre><code class="java">// 900秒内，如果至少有1个key被修改，则执行bgsave
save 900 1
save 300 10
save 60 10000
</code></pre>
<p>&#x3D;&#x3D;<strong>RDB的执行原理？</strong>&#x3D;&#x3D;<del>数据完整性高用RDB</del></p>
<p><strong><u>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据，完成fork后读取内存数据并写入RDB文件</u></strong></p>
<blockquote>
<p>在LInux中主进程并无法直接读取物理内存，它只能通过虚拟内存去读。因此有<strong>页表</strong>(记录虚拟地址与物理地址的映射关系)去执行操作 同时 主进程也会fork(复制页表) 成为一个新的子进程(携带页表) → 写新RDB文件替换旧的RDB文件 → 磁盘</p>
</blockquote>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行<strong>读操作</strong>时，访问共享内存</li>
<li>当主进程执行<strong>写操作</strong>时，则会拷贝一份数据，执行写操作</li>
</ul>
<p>优点：二进制数据重启后 Redis无需过多解析 直接恢复</p>
<p>&#x3D;&#x3D;<strong>AOF</strong>&#x3D;&#x3D;<del>对数据不敏感要求不高</del></p>
<p>AOF全称为Append Only File(追加文件)<del>底层硬盘顺序读写</del>。Redis处理的每个写命令都会记录在AOF，可以看作是命令日志文件<br><u>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</u>：</p>
<pre><code class="mysql"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename &quot;appendonly.aof&quot;
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配</p>
<pre><code class="mysql"># 表示每执行一次写命令，立即记录到AOF文件
appendfsync always
# 写命令执行完毕先放入AOF缓冲区，然后表示每隔一秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
</code></pre>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">刷盘时机</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">同步刷盘</td>
<td align="center">可靠性高，几乎不丢数据</td>
<td align="center">性能影响大</td>
</tr>
<tr>
<td align="center"><u>everysec</u></td>
<td align="center"><u>每秒刷盘</u></td>
<td align="center"><u>性能适中</u></td>
<td align="center"><u>最多丢失1秒数据</u></td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">操作系统控制</td>
<td align="center">性能最好</td>
<td align="center">可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。<u>通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重读功能，用最少的命令达到相同效</u>果</p>
<p>Redis会在出发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<pre><code class="mysql"># AOF文件比上次文件 增多超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写
auto-aof-rewrite-min-size 64mb
</code></pre>
<p><strong>★★★★★★★★ RDB与AOF对比 ★★★★★★★★</strong></p>
<p>RDB和AOF各有优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用<br>RDB是二进制文件，在保存时体积较小恢复较快，但也有可能丢失数据，我们通常在项目中使用AOF来恢复数据，虽然慢但丢失数据风险小，在AOF文件中可以设置刷盘策略(每秒批量写入一次命令)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照哦</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积大</td>
</tr>
<tr>
<td align="center">宕机恢复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源<br />但AOF重写时会占用大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更快的启动速度</td>
<td align="center">对数据安全性要求较高常见</td>
</tr>
</tbody></table>
<h4 id="项目中是怎么使用redis的"><a href="#项目中是怎么使用redis的" class="headerlink" title="项目中是怎么使用redis的"></a>项目中是怎么使用redis的</h4><p>需要结合项目中的业务进行回答，通常情况下，分布式锁的使用场景：<br>集群情况下的定时任务、抢单、幂等性场景<br>如果使用互斥锁的话 那么在集群项目有多个服务器就会出现问题</p>
<p>用Hash类型  大Key是Id  小key是商品id value是商品数量<br>数据量点击量 用String类型<br>用Set类型 Zset做排行榜</p>
<h4 id="你的项目中哪里使用到分布式锁"><a href="#你的项目中哪里使用到分布式锁" class="headerlink" title="你的项目中哪里使用到分布式锁?"></a>你的项目中哪里使用到分布式锁?</h4><p>&#x3D;&#x3D;<strong>Redis分布式锁</strong>&#x3D;&#x3D;</p>
<p>Redis实现分布式锁主要利用Redis的<strong>setnx</strong>命令，setnx是**<u>SET if not exists</u>**(如果不存在，则SET)的简写</p>
<ul>
<li><p><strong>获取锁</strong></p>
<blockquote>
<p>添加锁，NX是互斥、EX是设置超时时间<br><strong>SET lock value NX EX 10</strong></p>
</blockquote>
</li>
<li><p><strong>释放锁</strong></p>
<blockquote>
<p>释放锁，删除即可<br><strong>DEL key</strong></p>
</blockquote>
</li>
</ul>
<h4 id="你可以说一下redis的分布式锁的原理吗"><a href="#你可以说一下redis的分布式锁的原理吗" class="headerlink" title="你可以说一下redis的分布式锁的原理吗"></a>你可以说一下redis的分布式锁的原理吗</h4><h4 id="我在项目中是集成了redisson-底层基于Lua脚本-具有原子性"><a href="#我在项目中是集成了redisson-底层基于Lua脚本-具有原子性" class="headerlink" title="我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])"></a><del>我在项目中是集成了redisson(底层基于Lua脚本[具有原子性])</del></h4><p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 执行流程</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>加锁 ↓→ 加锁成功 → <strong>Watch dog(看门狗)<del>每隔(releaseTime&#x2F;3的时间做一次续期)</del></strong> → Redis<br>↓        操作redis → Redis<br>↓→→ 释放锁↑ → 通知看门狗无需继续监听 → Redis</p>
</blockquote>
<blockquote>
<p>加锁  → → → 是否加锁成功？→→→   ↓<br>↑←←while循环不断尝试获取锁←←←↓</p>
</blockquote>
<pre><code class="java">public void redisLock() throws InterruptedException&#123;
    RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
 // boolean isLock = lock.tryLock(10, 30, TimeUnit.SECONDS);
// 如果不设置中间的过期时间30 才会触发看门狗
// 加锁，设置过期时间等操作都是基于lua脚本完成的[调用redis命令来保证多条命令的原子性]
    boolean isLock = lock.tryLock(10, TimeUnit.SECONDS);
    if(isLock)&#123;
        try&#123;
            sout(&quot;执行业务&quot;);
        &#125; finally&#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 可重入</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>redis实现分布式锁是不可重入的 但是 redisson实现分布式锁是可以重入的<br>可重入原理：它俩是同一个线程 每个线程都有唯一的线程id 根据线程id唯一标识做判断 判断之前获取锁是不是同一个线程<br><strong>利用hash结构</strong>记录<strong>线程id</strong>和<strong>重入次数</strong></p>
<table>
<thead>
<tr>
<th align="center">KEY</th>
<th align="center">VALUE</th>
<th align="center">VALUE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">field</td>
<td align="center">value</td>
</tr>
<tr>
<td align="center">heimalock</td>
<td align="center">thread1</td>
<td align="center">0</td>
</tr>
</tbody></table>
</blockquote>
<pre><code class="java">public void add1()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
  add2();
// 释放锁
  lock.unlock();
&#125;
public void add2()&#123;
  RLock lock = redissonClient.getLock(&quot;heimalock&quot;);
  boolean isLock = lock.tryLock();
// 执行业务
// 释放锁 锁次数-1不完全释放
  lock.unlock();
&#125;
</code></pre>
<p>&#x3D;&#x3D;<strong>redisson实现分布式锁 - 主从一致性</strong>&#x3D;&#x3D;</p>
<p>Redis Master主节点：主要负责<strong>写操作</strong>(增删改) <del>只能写</del><br>Redis Slave从节点：主要负责<strong>读操作</strong><del>只能读</del></p>
<blockquote>
<p>当RedisMaster主节点突然宕机后 Java应用会去格外获取锁 这时两个线程就同时持有一把锁 容易出现脏数据<br>怎么解决呢？</p>
</blockquote>
<ul>
<li><strong>RedLock(红锁)<strong>：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁</strong>(n&#x2F;2+1)<strong>，避免在一个redis实例【实现复杂、性能差、运维繁琐】怎么解决？→ <strong>CP思想</strong>：</strong>zookeeper</strong></li>
</ul>
<h4 id="redis和mysql怎么保证数据一致性"><a href="#redis和mysql怎么保证数据一致性" class="headerlink" title="redis和mysql怎么保证数据一致性"></a>redis和mysql怎么保证数据一致性</h4><p><strong>写</strong>先插入数据库<br><u><strong>更新</strong>先更新数据库 更新数据库成功但redis不成功 影响不大 因为后面会有过期删除 最终会一致，更新mysql后缓存可以删除也可以修改</u><br><u>更新完数据库直接删除缓存了  有过期时间兜底 最终会保持一致 我们项目中对数据敏感性一致性不高 我们追求实时性</u><br><u>如果是最终保持一致性的就MQ 我们对实时性不高 对数据敏感性 一致性高</u><br><strong>删除</strong>问题不大 哪里都行！<br>读多写少的可以上缓存<br>mysql保存购物车表 但是再页面操作的时候 只操作redis 用<strong>mq</strong>给到消费者修改或<strong>定时任务</strong> 更新数据到mysql，MQ问题：我们对数据实时性要求不高 只需要保存最终一致性就行<br><strong>你如果只写redis 万一丢了数据怎么办</strong>？<br>购物车丢点订单无影响 数据安全性要求不太高 mysql尽量不要搞购物车的表 都在redis的表 丢就丢了呗。或者异步同步&#x2F;定时任务<br>实时性要求 安全性要求 → MySQL<br>电商一般数据库和mysql都要存 → 读多写少</p>
<p><strong>一定、一定、一定要设置前提，介绍自己的业务背景</strong> (一致性要求高？允许延迟一致？)</p>
<blockquote>
<p>① 介绍自己简历上的业务，我们当时是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以我们采用的是<strong>异步的方案同步的数据</strong></p>
<p>② 我们当时是把抢卷的库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致性，我们当时采用的是<strong>redission提供的读写锁</strong>来保证数据的同步</p>
</blockquote>
<p><strong>双写一致性：</strong>当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致</p>
<ul>
<li><p>读操作：缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</p>
</li>
<li><p>写操作：<strong>延迟双删</strong> [因为无论<strong>先删除缓存</strong>还是<strong>先删除数据库</strong>都可能会出数据不一致问题 <strong>有脏数据</strong>]</p>
</li>
<li><p>&#x3D;&#x3D;<strong>基于redisson互斥锁</strong>：&#x3D;&#x3D;[放入缓存中的数据 读多写少] 【强一致性业务 性能低】<del>有过期时间兜底</del></p>
<ul>
<li><strong>共享锁</strong>：读锁readLock，加锁之后，其他线程可以<strong>共享读操作</strong>，但**<u>不允许写操作</u>**</li>
<li><strong>排他锁</strong>：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作(只允许一个用户或进程独占地对数据进行读取和写入操作)<del>排他锁确保了写操作的原子性和一致性</del></li>
<li>读数据的时候添加<u>共享锁(</u>读不互斥、写互斥)  </li>
<li>写数据的时候添加<u>排他锁</u>(阻塞其他线程的读写 因为读多写少)</li>
</ul>
<blockquote>
<p>redissionClient.getReadWriteLock(“xxxx”);</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;<strong>异步通知：</strong>&#x3D;&#x3D;<u>异步通知保证数据的最终一致性</u>(需要保证MQ的可靠性)<del>需要在Redis中更新数据的同时，通知另一个服务进行某些操作。</del></p>
<ul>
<li><strong>使用场景</strong>：<ul>
<li><strong>缓存与数据库双写</strong>： 当应用需要同时更新Redis缓存和数据库时，可以先将数据写入Redis，然后通过异步通知机制触发数据库的更新操作。</li>
<li><strong>跨地域数据复制</strong>： 在跨地域部署的服务中，为了实现数据的最终一致性，可以在一个地域写入数据后，通过异步通知机制在另一个地域进行数据复制。</li>
<li><strong>系统间数据同步</strong>： 在微服务架构中，不同的服务可能有自己的数据存储。当一个服务更新了数据后，可以通过异步通知机制告知其他相关服务进行数据同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>基于Canal的异步通知</strong>&#x3D;&#x3D;：监听mysql的binlog<br>可以解析binlog文件 可以存放mysql里面的数据 看最近有无增删改查 转换成redis命令 再给redis里面</p>
<ul>
<li>使用MQ中间件，更新数据之后，通知缓存删除</li>
<li>利用canal中间件，不需要修改业务代码，伪装为mysqls的一个从节点，canal通过读取binlog数据更新缓存</li>
</ul>
</li>
</ul>
<h4 id="synchronized可以作用在哪些地方-作用域-，分别锁的是什么"><a href="#synchronized可以作用在哪些地方-作用域-，分别锁的是什么" class="headerlink" title="synchronized可以作用在哪些地方(作用域)，分别锁的是什么"></a>synchronized可以作用在哪些地方(作用域)，分别锁的是什么</h4><p>在Java中，<code>synchronized</code>关键字可以用来实现线程同步，它可以作用在不同的地方，并且锁定的对象也不同：</p>
<ol>
<li><p><strong>实例方法</strong>：</p>
<ul>
<li>作用在实例方法上时，锁的是调用该方法的<strong>对象实例</strong>（即**<u>this对象</u>**）。</li>
<li>任何线程想要执行这个方法，都必须获得该对象实例的锁。</li>
</ul>
<pre><code>public synchronized void synchronizedMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>静态方法</strong>：</p>
<ul>
<li>作用在静态方法上时，锁的是类的<strong>Class对象</strong>。</li>
<li>由于静态方法是属于类的，而不是属于任何特定实例，所以所有线程要想执行这个静态同步方法，都必须获得该类的Class对象的锁。</li>
</ul>
<pre><code>public static synchronized void synchronizedStaticMethod() &#123;
    // 方法体
&#125;
</code></pre>
</li>
<li><p><strong>代码块</strong>：</p>
<ul>
<li>作用在代码块上时，可以指定一个<strong>锁对象<del>括号里的对象</del><strong>，可以是</strong>任何对象</strong>。</li>
<li>当进入这个代码块时，线程必须获得指定锁对象的锁。</li>
</ul>
<pre><code>public void synchronizedBlock() &#123;
    synchronized(this) &#123; // 锁定当前对象实例
        // 代码块
    &#125;
&#125;

public void synchronizedBlockWithObject() &#123;
    Object lock = new Object();
    synchronized(lock) &#123; // 锁定指定的对象
        // 代码块
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><span style = "color:red"><strong>什么情况下索引会失效？</strong></span></p>
<blockquote>
<ul>
<li>违反最左前缀法则</li>
<li>范围查询右边的列，不能使用索引</li>
<li>不要在索引列上进行<strong>运算操作</strong>，索引将失效</li>
<li>字符串不加单引号，造成索引失效。(类型转换)</li>
<li>以%开头的Like模糊查询，索引失效<br>[不影响正常查询业务 但未运用超大分页查询优化 会导致索引失效]</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引创建原则有哪些？</strong></span><del>索引很多就会有很多B+树</del></p>
<blockquote>
<p>① <strong>数据量较大，且查询比较频繁的表</strong><br>② <strong>常作为查询条件、排序、分组的字段</strong> [where、group by、order by]<br>③ 字段内容区分度高<br>④ 内容较长，使用前缀索引<br>⑤ <strong>尽量联合索引</strong><del>对存储节省空间</del></p>
<pre><code class="java">如果我们经常根据客户ID和订单日期来查询订单，那么可以在 customer_id 和 order_date 上创建一个联合索引。
CREATE INDEX idx_customer_date ON orders (customer_id, order_date);

这个联合索引 idx_customer_date 有以下几个特点：

索引顺序：首先根据 customer_id 排序，然后在每个 customer_id 的基础上根据 order_date 排序。
查询优化：以下查询可以利用这个联合索引：
SELECT * FROM orders WHERE customer_id = ? AND order_date = ?;
SELECT * FROM orders WHERE customer_id = ?;
</code></pre>
<p>⑥ <strong>要控制索引的数量</strong><br>⑦ 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它<br>大字段不建议建立索引是因为B+树一个叶子节点&#x2F;一个非叶子节点 差不多16k 一个节点对应一个[页] 多的话会更多层<br>尽量不用性别去创建索引</p>
</blockquote>
<blockquote>
<ul>
<li>先陈述自己再实际工作中是怎么用的</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>根据业务创建的索引(复合索引)</li>
</ul>
</blockquote>
<p><span style = "color:red"><strong>索引的底层数据结构了解过吗？</strong></span></p>
<blockquote>
<p>MySQL的InnoDB引擎采用的B+树的数据结构来存储索引</p>
<ul>
<li>阶数更多，路径更短</li>
<li>磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据</li>
<li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li>
</ul>
</blockquote>
<p>**<u>MySQL默认使用的索引底层数据结构是B+树</u>**。再聊B+树之前，先来聊聊二叉树和B树</p>
<p>&#x3D;&#x3D;<strong>B Tree</strong>(<strong>矮胖树</strong>)&#x3D;&#x3D;，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key</p>
<p>&#x3D;&#x3D;<strong>B+Tree</strong>&#x3D;&#x3D; 是再BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是B+Tree实现其索引结构</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/264cd6bd9cf733e6fe23dd38f6959fe688dec2d9/B%20Tree%20%E5%92%8C%20B+Tree.png"></p>
<p><strong>B树与B+树对比</strong>：</p>
<ul>
<li>磁盘读写代价B+树更低</li>
<li>查询效率B+树更加稳定</li>
<li>B+树便于扫库和区间查询</li>
</ul>
<blockquote>
<p><strong>B树</strong>要找12 首先找38 左面小 再去缩小范围16和29 找到12 → 但是我们只想要12的数据 B树会额外的把38,16,29的数据全查一遍最后才到12的数据</p>
<p><strong>B+树</strong>是在叶子节点才会存储数据，在非叶子节点全是指针，这样就没有其他乱七八糟的数据影响 。且查找路径是差不多的，效率较稳定</p>
<p><strong>便于扫库</strong>：比如我们要查询6-34区间的数据，先去根节点扫描一次38 → 16-29 → 由于叶子节点之间有双向指针，就可以一次性把所有数据都给拿到[无需再去根节点找一次]</p>
</blockquote>
<h4 id="mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层"><a href="#mysql底层为什么用B-树利用二分查找-树越矮经过磁盘IO次数越少-它是稳定的每次都查到最底层" class="headerlink" title="mysql底层为什么用B+树利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层"></a>mysql底层为什么用B+树<del>利用二分查找,树越矮经过磁盘IO次数越少,它是稳定的每次都查到最底层</del></h4><p><del><strong>二叉树</strong> O(logn) 容易退化成链表 所以不用它</del><br><del><strong>平衡二叉树</strong> 全部倾斜</del><br><del><strong>红黑树</strong> 一个节点只能存一个数据</del><br>B树能不能除了叶子节点其他不存数据呢？</p>
<blockquote>
<p>你可以设计一种变体的B树，其中只有叶子节点存储数据，而所有其他非叶子节点仅作为导航节点，不存储实际的数据。这种结构在概念上类似于B树的一个特例，通常被称为B树索引结构的一部分，其中非叶子节点存储的是键值，而叶子节点存储的是实际的数据记录或者是指向数据记录的指针</p>
</blockquote>
<p>B+树第三层2000多万条数据，尽量不要把数据达到2000多万<br>B+树叶子节点加了双向链表 让我们查询更加稳定 范围查询会更快</p>
<h6 id="mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高"><a href="#mysql索引底层不一定只有B-树，也可能是Hash-在精准查询性能比它高" class="headerlink" title="mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高"></a>mysql索引底层不一定只有B+树，也可能是Hash 在精准查询性能比它高</h6><p><strong>R—Tree</strong>：地理位置搜索</p>
<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p><code>where b= AND c= AND a= </code> 这样走索引都能走 底层自己排序<br>为什么联合索引要遵循最左匹配原则【里面的b+树 先按照a排序 再b 因为要二分查找 不排序怎么找？】</p>
<p><span style = "color:red"><strong>在MySQL中，如何定位慢查询？</strong></span><del>查询前用explain查询是否走了索引等问题</del></p>
<h6 id="explain查询后的列："><a href="#explain查询后的列：" class="headerlink" title="explain查询后的列："></a>explain查询后的列：</h6><pre><code class="java">id：查询中SELECT语句的序列号，如果该行引用其他行的并集结果，则该值可以为空。
select_type：表示查询的类型，常见的类型有：
SIMPLE：简单的SELECT查询，不使用UNION或子查询。
PRIMARY：最外层的SELECT查询。
UNION：在UNION中的第二个或随后的SELECT查询。
DEPENDENT UNION：在UNION中的第二个或随后的SELECT查询，取决于外层查询。
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT。
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外层查询。
table：查询的是哪个表。
type：这是你提到的一个非常重要的列，它表示MySQL在表中找到所需行的方式，也称为“访问类型”。以下是一些常见的访问类型，从最好到最差排序：
system：表只有一行（系统表）。
const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，所以优化器的其余部分可以将这一行视为常量。
eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这通常是最好的联接类型，除了const类型。
ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。
fulltext：使用全文索引执行查询。
ref_or_null：与ref类似，但是MySQL会额外搜索包含NULL值的行。
index_merge：表示查询使用了两个或更多的索引。
unique_subquery：用于IN子查询，子查询返回不重复的值集。
index_subquery：用于IN子查询，子查询返回不重复的值集，可以使用索引。
range：使用索引来检索给定范围的行。
index：全索引扫描（比ALL快，因为索引通常比数据行小）。
ALL：全表扫描，这是最差的一种类型，因为MySQL必须检查每一行以找到匹配的行。
possible_keys：指出MySQL能使用哪些索引来优化查询。
key：MySQL实际决定使用的索引。
key_len：使用的索引的长度。越短越好。
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。
rows：MySQL认为必须检查的用来返回请求数据的行数。
filtered：显示了通过条件过滤出的行数的百分比估计。
Extra：包含MySQL解析查询的额外信息，例如是否使用了索引，是否排序了结果，是否使用了临时表等
</code></pre>
<blockquote>
<p>1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，压测的结果大概5秒钟)<br>2.我们系统中当时采用了运维工具(<strong>Skywalking</strong>)，可以监测出哪个接口，最终因为是sql的问题<br>3.在mysql中开启了慢日志查询，我们设置的值就是2秒，一旦sql执行超过2秒就会记录到日志中(调试阶段)</p>
</blockquote>
<blockquote>
<p>产生原因：</p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据量过大查询</li>
<li>深度分页查询</li>
</ul>
</blockquote>
<p><strong>方案一：</strong>&#x3D;&#x3D;<strong>开源工具</strong>&#x3D;&#x3D;[调试阶段才会开启  生产阶段不会开启]</p>
<ul>
<li>调试工具Arthas</li>
<li>运维工具：Prometheus、SKywalking(接口访问时间)</li>
</ul>
<p><strong>方案二：</strong>&#x3D;&#x3D;<strong>MySQL自带慢日志</strong>&#x3D;&#x3D;</p>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志，如果要开启慢查询日志，需要在MySQL的配置文件(&#x2F;etc&#x2F;my.cnf)中配置信息：</p>
<pre><code class="mysql"># 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
long_query_time = 2
</code></pre>
<p><span style = "color:red"><strong>什么是聚簇索引？什么是非聚簇索引(二级索引)？什么是回表？</strong></span></p>
<blockquote>
<ul>
<li><strong>聚簇索引(聚集索引)<strong>：数据与索引放到一块，B+树的叶子节点保存了整行数据，</strong>有且只有一个</strong>【id存放的b+树】</li>
<li>**非聚簇索引(二级索引)**：数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个【叶子就是id的字段】</li>
<li><strong>回表查询</strong>：通过二级索引找到对应的主键值，到聚集索引中查找正行数据，这个过程就是回表</li>
</ul>
<p>怎么避免回表 → 使用覆盖索引！<br>需要name 直接 select name 而不用 select *<br>要按需来查找</p>
</blockquote>
<pre><code class="java">除了InnoDB，MySQL数据库还支持多种其他存储引擎，其中最著名的是MyISAM。以下是InnoDB和MyISAM两个存储引擎的主要区别：

事务支持：
InnoDB：支持事务，它遵循ACID原则（原子性、一致性、隔离性和持久性）。如果事务中的某个操作失败，整个事务可以回滚到开始状态。
MyISAM：不支持事务，这意味着你无法回滚操作，这对于数据完整性和恢复可能是一个问题。
    
锁定机制：
InnoDB：使用行级锁定，只锁定需要的特定行，这可以大大减少数据库操作的冲突。
MyISAM：使用表级锁定，每次操作都会锁定整个表，这在并发操作较多时可能导致性能问题。
    
崩溃恢复：
InnoDB：具有自动崩溃恢复功能，即使数据库崩溃，也不会丢失数据，因为它将事务日志写入磁盘。
MyISAM：在崩溃后恢复较为困难，可能会丢失数据，因为它不记录事务日志。
    
全文搜索：
InnoDB（MySQL 5.6及以后版本）：支持全文索引，但功能上不如MyISAM的全文搜索强大。
MyISAM：提供了更强大的全文搜索功能，但在MySQL 5.6之前，这是MyISAM相对于InnoDB的主要优势。
    
存储限制：
InnoDB：表的大小理论上受限于操作系统的文件大小限制，通常可以处理更大的数据量。
MyISAM：表的大小受限于最大文件大小，通常是2GB到4GB，这取决于文件系统的限制。
    
外键支持：
InnoDB：支持外键约束，这有助于保持数据的引用完整性。
MyISAM：不支持外键约束。
    
存储空间：
InnoDB：通常需要更多的存储空间，因为它存储了额外的信息来支持事务和行级锁定。
MyISAM：通常占用更少的存储空间，因为它不需要存储这些额外的信息
</code></pre>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;<strong>聚集索引</strong>(Clustered Index)&#x3D;&#x3D;</td>
<td align="left">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有, 而且只有一个</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;<strong>二级索引</strong>(Secondary Index)&#x3D;&#x3D;</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p><strong>聚集索引选取规则：</strong></p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p><img src="https://github.com/P-luminary/images/blob/master/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20%E5%92%8C%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg?raw=true"></p>
<p>&#x3D;&#x3D;<strong>回表查询</strong>&#x3D;&#x3D;</p>
<p><code>select * from user where name = &#39;Arm&#39;;</code></p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/25accb51fee1e0b8d57deebf6bfe38e3868b32bf/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p>
<h4 id="MySQL的日志文件有哪些，它们的作用是什么"><a href="#MySQL的日志文件有哪些，它们的作用是什么" class="headerlink" title="MySQL的日志文件有哪些，它们的作用是什么"></a>MySQL的日志文件有哪些，它们的作用是什么</h4><p><strong>MySQL的日志文件有哪些，它们的作用是什么？</strong></p>
<p>MySQL主要有以下几种日志文件：</p>
<ul>
<li>错误日志（Error Log）：记录MySQL服务的启动、运行或停止过程中的错误信息。</li>
<li>查询日志（General Query Log）：记录所有MySQL执行的SQL命令，无论这些命令是否正确执行。</li>
<li>慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。</li>
<li><strong><u>二进制日志</u>（Binary Log）</strong>：<u>记录所有更改数据的SQL语句，用于主从复制和数据恢复。</u>事务的提交 和 主从复制</li>
<li><strong><u>事务日志&#x2F;重做日志</u>（InnoDB Redo Log）</strong>：<u>记录InnoDB存储引擎的事务操作，用于崩溃恢复。</u></li>
<li><strong><u>回滚日志&#x2F;撤销日志</u>（InnoDB Undo Log）</strong>：<u>用于事务回滚，保证事务的原子性。</u></li>
</ul>
<blockquote>
<p><span style = "color:red"><strong>undo log 和 redo log的区别？</strong></span></p>
<blockquote>
<p><strong>redo log</strong>：记录的是数据页的物理变化，服务宕机可用来同步数据<br><strong>undo log</strong>：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据<br><strong>redo log</strong> 保证了事务的持久性，undo log保证了事务的原子性和一致性</p>
</blockquote>
<ul>
<li><strong>缓冲池</strong>(buffer pool)：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改査操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</li>
<li><strong>数据页</strong>(page)：是InnoD8 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。页中存储的是行数据</li>
</ul>
<p>&#x3D;&#x3D;<strong>redo log</strong>&#x3D;&#x3D;</p>
<p>重做日志，记录的是事务提交时数据页的物理修改，是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组冲：<strong>重做日志缓冲(redo log buffer)</strong> 以及 **重做日志文件(redo log file)**，前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都保存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p><img src="https://raw.githubusercontent.com/P-luminary/images/f3e54069fe783271a5892cf6d0bf49247f2b0f4a/undo%20log%20%E5%92%8C%20redo%20log%E5%8C%BA%E5%88%AB.jpg"></p>
<p>&#x3D;&#x3D;<strong>undo log</strong>&#x3D;&#x3D;</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：<strong>提供回滚</strong>和 <strong>MVCC</strong>(多版本并发控制)。undolog 和 redolog记录物理日志不一样，它是<strong>逻辑日志</strong></p>
<ul>
<li>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然</li>
<li>当update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</li>
</ul>
<p><strong>undo log可以实现事务的一致性和原子性</strong></p>
</blockquote>
<h4 id="MySQL主从同步原理？"><a href="#MySQL主从同步原理？" class="headerlink" title="MySQL主从同步原理？"></a><span style = "color:red"><strong>MySQL主从同步原理？</strong></span></h4><blockquote>
<p>MySQL主从复制的核心就是二进制日志binlog[<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>]<br>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。<br>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。<br>从库重做中继日志中的事件，将改变反映它自己的数据。</p>
<pre><code class="java">主服务器（Master）上的数据更改（如INSERT、UPDATE、DELETE操作）会被记录到二进制日志中。
从服务器（Slave）上的I/O线程连接到主服务器，请求主服务器上的二进制日志。
主服务器将二进制日志发送给从服务器，从服务器将这些日志事件写入到本地的中继日志（Relay Log）。
从服务器上的SQL线程读取中继日志中的事件，并在本地执行这些事件，从而实现数据的复制。
</code></pre>
</blockquote>
<p>MySQL主从复制的核心就是二进制日志</p>
<blockquote>
<p>二进制文件(BINLOG) 记录了所有的<strong>DDL(数据定义语言)语句</strong> 和 <strong>DML(数据操纵语言)语句</strong>，但不包括<u>数据查询(SELECT、SHOW)语句</u></p>
</blockquote>
<img src="https://raw.githubusercontent.com/P-luminary/images/678966e16f791c838ee0d8be04e35897d7f4ae47/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" style="zoom:200%;" />

<h6 id="复制分成三步："><a href="#复制分成三步：" class="headerlink" title="复制分成三步："></a>复制分成三步：</h6><ul>
<li>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</li>
<li>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</li>
<li>slave重做中继日志中的事件，将改变反应他自己的数据</li>
</ul>
<h4 id="项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下"><a href="#项目中哪里涉及到分布式事务问题-你是怎么解决的-能说一下" class="headerlink" title="项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下"></a>项目中哪里涉及到分布式事务问题? 你是怎么解决的? 能说一下</h4><p>分布式事务问题可能出现在跨多个服务或数据库的操作中，例如在订单服务中同时更新订单状态和扣减库存。<del>秒杀案例：是先扣库存提前缓存到redis里，判断够不够，用RabbitMQ异步下来</del></p>
<p>解决方案：可以使用分布式事务框架，如Seata，其中AT模式是一种常见的解决方案。</p>
<p><strong>AT模式原理：</strong></p>
<ul>
<li>AT模式基于两阶段提交，分为两个阶段：一阶段 prepare 和二阶段 commit&#x2F;rollback。</li>
<li>在业务方法开始时，Seata会拦截业务SQL，记录业务数据在执行前后的镜像，生成行锁。</li>
<li>如果一阶段 prepare 成功，则二阶段进行 commit，直接提交事务；如果 prepare 失败，则执行 rollback，利用之前保存的数据镜像回滚到执行前的状态。</li>
</ul>
<h4 id="项目中哪里用到MQ，用来干什么？"><a href="#项目中哪里用到MQ，用来干什么？" class="headerlink" title="项目中哪里用到MQ，用来干什么？"></a><strong>项目中哪里用到MQ，用来干什么？</strong></h4><p>异步发优惠卷 + 积分 [用户对于实时性要求不是很高]</p>
<ul>
<li><h5 id="使用MQ的场景：订单处理"><a href="#使用MQ的场景：订单处理" class="headerlink" title="使用MQ的场景：订单处理"></a>使用MQ的场景：订单处理</h5><h5 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h5><p>当用户在电子商务平台上成功下单后，订单服务需要执行以下操作：</p>
<ol>
<li>更新订单状态为“已支付”。</li>
<li>扣减商品库存。</li>
<li>通知支付服务处理支付。</li>
<li>通知物流服务准备发货。</li>
</ol>
<h5 id="使用MQ的原因"><a href="#使用MQ的原因" class="headerlink" title="使用MQ的原因"></a>使用MQ的原因</h5><p>在这些操作中，更新订单状态和扣减库存是实时且同步的操作，但通知支付服务和物流服务则可以异步进行。使用MQ可以帮助我们实现以下目标：</p>
<ul>
<li><strong>解耦服务</strong>：订单服务不需要直接调用支付服务和物流服务，降低了服务间的耦合度。</li>
<li><strong>异步处理</strong>：订单服务可以立即响应客户端，不必等待支付和物流服务的处理结果。</li>
<li><strong>流量削峰</strong>：在高峰期，MQ可以缓冲大量的订单处理请求，避免服务被压垮。</li>
</ul>
</li>
</ul>
<p><strong>订单服务生产消息：</strong> 当订单服务完成订单状态更新和库存扣减后，它将以下消息发送到</p>
<pre><code>&#123;
  &quot;orderId&quot;: &quot;123456789&quot;,
  &quot;status&quot;: &quot;paid&quot;,
  &quot;userId&quot;: &quot;user123&quot;,
  &quot;items&quot;: [
    &#123;&quot;productId&quot;: &quot;prod123&quot;, &quot;quantity&quot;: 1&#125;,
    &#123;&quot;productId&quot;: &quot;prod456&quot;, &quot;quantity&quot;: 2&#125;
  ]
&#125;
</code></pre>
<p>这个消息将被发送到不同的主题或队列，例如<code>payment_topic</code>和<code>logistics_topic</code>。</p>
<p><strong>2. 支付服务和物流服务消费消息：</strong></p>
<ul>
<li><strong>支付服务</strong>订阅<code>payment_topic</code>，当接收到订单支付消息后，它会处理支付逻辑，如验证支付状态、记录交易日志等。</li>
<li><strong>物流服务</strong>订阅<code>logistics_topic</code>，当接收到订单消息后，它会准备发货，更新物流信息，并通知用户。</li>
</ul>
<p>通过这种方式，订单服务可以快速响应用户请求，而支付和物流服务可以按照自己的节奏处理订单相关的操作，整个系统因此变得更加灵活和可扩展。</p>
<h4 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a><strong>如何保证消息不丢失？</strong></h4><p>保证生产者能够成功发送到交换机和队列(存储消息)，生产者提供了消息确认机制<br>到队列后消息要有持久化机制<br>消费者要有一个消息确认机制 保证消费者至少消费成功消息一次</p>
<blockquote>
<ul>
<li><p>开启生产者确认机制，确保生产者的消息能到达队列<br>confirm到交换机ack 不到nack 和 return没到返回nack机制保证生产者把消息发过去</p>
</li>
<li><p>开启持久化功能，确保消息未消费前在队列中不会丢失<br>万一broker挂掉就惨了 保证至少成功一次消费</p>
</li>
<li><p>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack<br>消费者三种机制：</p>
<blockquote>
<p>RabbitMQ支持消费者确认机制，即：消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息，而SpringAMQP则允许配置三种确认模式：</p>
<ul>
<li><p><strong>manual</strong>：手动ack，需要在业务代码结束后，调用api发送ack。</p>
</li>
<li><p><strong>auto</strong>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p>
</li>
<li><p><strong>none</strong>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p>
</li>
</ul>
</blockquote>
</li>
<li><p>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</p>
<blockquote>
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li><p><strong>RejectAndDontRequeueRecoverer</strong>：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p>
</li>
<li><p><strong>ImmediateRequeueMessageRecoverer</strong>：重试耗尽后，返回nack，消息重新入队</p>
</li>
<li><p><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>异步发送（验证码、短信、邮件）</li>
<li>MySQL和Redis，ES之间的数据同步</li>
<li>分布式事务</li>
<li>削峰填谷</li>
</ul>
<h4 id="如何解决消息积压？"><a href="#如何解决消息积压？" class="headerlink" title="如何解决消息积压？"></a><strong>如何解决消息积压？</strong></h4><p>产生原因：当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是堆积问题</p>
<p>**解决消息堆积有三种思路 **</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限</li>
</ul>
<h4 id="如何保证消费幂等性【MQ】"><a href="#如何保证消费幂等性【MQ】" class="headerlink" title="如何保证消费幂等性【MQ】"></a>如何保证消费幂等性【MQ】</h4><p>幂等性是指同一个操作执行多次和执行一次的效果相同。在消息消费的场景中，保证幂等性通常有以下几种方法：<br><strong><u>利用数据库的唯一约束</u><strong>：<br>在数据库中为消息设置唯一标识（如消息ID），在处理消息前先检查该标识是否已存在。<br>导致重复消费 返回ack，blocker未收到。一定要在</strong>生产者</strong>投递的时候生成全局唯一的id，消费者就会去判断。异步生成 拿订单号去数据库查 如果查得到就直接return<br><strong>精髓就是全局唯一</strong><br>UUID不行 因为每次发送的消息都不是同一个UUID 要用业务上的</p>
<h6 id="哪些地方还会有幂等问题？"><a href="#哪些地方还会有幂等问题？" class="headerlink" title="哪些地方还会有幂等问题？"></a>哪些地方还会有幂等问题？</h6><p>提供者的openfegin、xxl-job、被别人调用且涉及到增删改</p>
<h6 id="状态记录："><a href="#状态记录：" class="headerlink" title="状态记录："></a>状态记录：</h6><p>在消费消息前，记录消息的状态（如已处理），处理完毕后再更新状态。要根据订单ID+状态 来保证消费幂等性。订单存在且未支付 → 更新<del>锁订单ID</del></p>
<h6 id="并发情况幂等性："><a href="#并发情况幂等性：" class="headerlink" title="并发情况幂等性："></a>并发情况幂等性：</h6><p>完美的幂等要加上分布式锁<del>对敏感性要求高，且要控制好锁的力度</del></p>
<h4 id="如何保证消费有序性"><a href="#如何保证消费有序性" class="headerlink" title="如何保证消费有序性"></a>如何保证消费有序性</h4><p>队列中可以指定消息的消费顺序</p>
<p>  <strong>RabbitMQ</strong> → 多个生产者并发投，所以生产者不能保证有序性，只考虑消费有序性。以消息进入的MQ的消息去回答。</p>
<h5 id="怎么保证？"><a href="#怎么保证？" class="headerlink" title="怎么保证？"></a>怎么保证？</h5><h6 id="单线程消费："><a href="#单线程消费：" class="headerlink" title="单线程消费："></a>单线程消费：</h6><p>在消费者端使用单个线程处理消息，确保消息按顺序处理。</p>
<h6 id="分区有序："><a href="#分区有序：" class="headerlink" title="分区有序："></a>分区有序：</h6><p>在如Kafka这样的消息队列中，可以保证同一个分区内的消息是有序的。</p>
<h4 id="如何既要又要【有序-速度快】"><a href="#如何既要又要【有序-速度快】" class="headerlink" title="如何既要又要【有序 + 速度快】"></a>如何既要又要【有序 + 速度快】</h4><p>既要又要”通常指的是在保证消息的幂等性和有序性的同时，还需要考虑其他特性（如高性能、高可用等）<br>在一些场景下，可能需要在性能和一致性之间做权衡。例如，可以选择最终一致性来换取更高的性能。<br>Kafka 和 RocketMQ可以天生实现【底层Hash取模】</p>
<h6 id="若非要用RabbitMQ实现呢？"><a href="#若非要用RabbitMQ实现呢？" class="headerlink" title="若非要用RabbitMQ实现呢？"></a>若非要用RabbitMQ实现呢？</h6><p>不同订单之间是否要求一定顺序？？<br>镜像集群，先搭3个节点的镜像集群，建立三个队列分为不同的镜像节点 各占一个队列，需要自己去实现<br>对订单号进行hash取模看到落到哪个节点<br>三个队列至少三个消费者 分别去消费它们<br>此时就可以并行有三个消费者去执行<br>把业务数据没关系的放在不同的队列去管理</p>
<h6 id="万一挂掉了呢？"><a href="#万一挂掉了呢？" class="headerlink" title="万一挂掉了呢？"></a>万一挂掉了呢？</h6><p>队列有持久化不用担心</p>
<h4 id="能说一下如何使用死信交换机吗支付"><a href="#能说一下如何使用死信交换机吗支付" class="headerlink" title="能说一下如何使用死信交换机吗支付"></a>能说一下如何使用死信交换机吗<del>支付</del></h4><p>死信交换机（DLX）用于处理无法正常消费的消息<br>创建一个正常的交换机和队列，以及一个死信交换机和死信队列。</p>
<blockquote>
<ol>
<li><strong>定义死信交换机</strong>：创建一个用于处理死信的交换机。</li>
<li><strong>定义死信队列</strong>：创建一个队列用于接收死信，并将其绑定到死信交换机。</li>
<li><strong>配置主队列的死信交换机属性</strong>：在主队列上设置参数，指定当消息无法正常处理时应该发送到哪个死信交换机。</li>
<li><strong>发送消息到主队列</strong>：生产者将消息发送到主交换机，进而路由到主队列。</li>
<li><strong>消费主队列消息</strong>：消费者从主队列中获取消息并进行处理。如果消息处理失败，它将被路由到死信交换机。</li>
<li><strong>消费死信队列消息</strong>：设置消费者来处理死信队列中的消息，进行错误处理或记录日志等操作。</li>
</ol>
</blockquote>
<h4 id="mysql如何提升深分页查询效率子查询-索引"><a href="#mysql如何提升深分页查询效率子查询-索引" class="headerlink" title="mysql如何提升深分页查询效率子查询+索引"></a>mysql如何提升深分页查询效率<del>子查询+索引</del></h4><p><strong>使用索引</strong>：</p>
<ul>
<li>确保查询中使用的列上有适当的索引，这样可以加快查找速度。</li>
</ul>
<p>**避免使用<code>OFFSET</code>和<code>LIMIT</code>**：</p>
<ul>
<li>使用<code>OFFSET</code>进行深分页时，MySQL需要遍历所有<code>OFFSET</code>之前的行。可以通过记住上一次查询的最大ID来避免使用<code>OFFSET</code>。</li>
</ul>
<p><strong>使用条件过滤</strong>：</p>
<ul>
<li>如果可能，使用WHERE子句来减少需要扫描的数据量。</li>
</ul>
<p><strong>增加<code>LIMIT</code>的大小</strong>：</p>
<ul>
<li>如果业务允许，可以增加每次查询返回的结果集大小，减少分页次数。</li>
</ul>
<p><strong>缓存</strong>：</p>
<ul>
<li>对于不经常变更的数据，可以使用缓存来存储已经查询过的页。</li>
</ul>
<p><strong>使用<code>EXPLAIN</code>分析查询</strong>：</p>
<ul>
<li>使用<code>EXPLAIN</code>来分析查询计划，找出性能瓶颈并进行优化。</li>
</ul>
<h4 id="能说一下常用的存储引擎以及它们的差异吗"><a href="#能说一下常用的存储引擎以及它们的差异吗" class="headerlink" title="能说一下常用的存储引擎以及它们的差异吗"></a>能说一下常用的存储引擎以及它们的差异吗</h4><p><strong>InnoDB</strong>：<br>支持事务、行级锁和外键。<br>适合处理大量短期事务。<br>为了维护数据的完整性，写操作相对较慢</p>
<p><strong>MyISAM</strong>：</p>
<p>不支持事务、不支持行锁只支持表锁<br>并发没那么大 事务要求没那么高可以用</p>
<h4 id="能说一下倒排索引的原理吗？"><a href="#能说一下倒排索引的原理吗？" class="headerlink" title="能说一下倒排索引的原理吗？"></a>能说一下倒排索引的原理吗？</h4><p>根据参与文档中的字段 要构建倒排就会去分词<br>根据用户索引也会分词 就会去查文档id 再去查文档<br>中文词库为IK <del>(Ikun 你干嘛 哎哟~)</del></p>
<h4 id="es的text和keyword的区别"><a href="#es的text和keyword的区别" class="headerlink" title="es的text和keyword的区别"></a>es的text和keyword的区别</h4><h6 id="text"><a href="#text" class="headerlink" title="text"></a>text</h6><p>用于全文搜索，会分词，字符串类型</p>
<h6 id="keywod"><a href="#keywod" class="headerlink" title="keywod"></a>keywod</h6><p>用于精确搜索字段，不会被分词，字符串类型</p>
<h4 id="es在你的项目中是用来做什么的"><a href="#es在你的项目中是用来做什么的" class="headerlink" title="es在你的项目中是用来做什么的"></a>es在你的项目中是用来做什么的</h4><p>快速搜索<del>商品(C端)、订单(后台)</del> + 日志查询 + 地理位置搜索<del>经纬度定位附近的事物</del></p>
<h4 id="mysql和ElasticSearch如何做数据同步"><a href="#mysql和ElasticSearch如何做数据同步" class="headerlink" title="mysql和ElasticSearch如何做数据同步"></a>mysql和ElasticSearch如何做数据同步</h4><p>mysql进行增删改的时候<br>对数据敏感性实时性要求没那么高 只看<u>可靠性</u>[<strong>MQ</strong>异步  +  <strong>定时任务</strong>  &#x3D; 没有那么强一致性]</p>
<h6 id="如果数据量没那么大-有没有必要上ES？"><a href="#如果数据量没那么大-有没有必要上ES？" class="headerlink" title="如果数据量没那么大 有没有必要上ES？"></a>如果数据量没那么大 有没有必要上ES？</h6><p>没有必要，正排索引不走全表扫描也蛮快<br>组长进行技术选型 考虑到以后的业务增长</p>
<h6 id="项目已经上线了-但是中途想换成ES-怎么办"><a href="#项目已经上线了-但是中途想换成ES-怎么办" class="headerlink" title="项目已经上线了 但是中途想换成ES 怎么办"></a>项目已经上线了 但是中途想换成ES 怎么办</h6><p>mysql是全量数据 mq只能同步增量数据 怎么办呢？<br>新上架的只能到ES 那应该如何？</p>
<p>此时涉及到全量和增量的同步<del>与Redis不一样</del><br>加定时任务每周&#x2F;每天 会定期重构一次索引库<del>晚上跑→兜底模式</del>，全量同步，后期再增量同步</p>
<h4 id="能说一下分词的原理吗"><a href="#能说一下分词的原理吗" class="headerlink" title="能说一下分词的原理吗"></a>能说一下分词的原理吗</h4><p>底层是大数据量的内容 树的结构来构建分词 IK，<u>字符分割、词汇识别、过滤停用词</u><br>不好意思面试官 具体底层原理不是很了解</p>
<h4 id="使用ES有遇到什么问题吗"><a href="#使用ES有遇到什么问题吗" class="headerlink" title="使用ES有遇到什么问题吗"></a>使用ES有遇到什么问题吗</h4><p>类似于深分页！<br>测试环境数据量不会很大 等到上线后才会有这种问题</p>
<h4 id="说一下jvm的内存区域，以及每个区域是干什么的"><a href="#说一下jvm的内存区域，以及每个区域是干什么的" class="headerlink" title="说一下jvm的内存区域，以及每个区域是干什么的"></a>说一下jvm的内存区域，以及每个区域是干什么的</h4><p>虚拟机栈、本地方法栈、程序计数器、元空间、堆</p>
<blockquote>
<h6 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h6><p><strong>虚拟机栈</strong>：每个线程运行时所需要的内存(<u><strong>先进后出</strong></u>)<del>方法调用过程</del>。每个栈由多个栈帧组成，对应着每次方法调用所占用的内存。每个线程只能有一个活动<strong>栈帧</strong>，对应着当前执行的那个方法</p>
<p><strong>本地方法栈</strong>：与虚拟机栈类似，区别→虚拟机栈执行java方法，本地方法栈执行native方法【被封装的方法  没有具体实现的 都封装在java虚拟机中】专门存储java写的局部方法的局部变量</p>
<p><strong>程序计数器</strong>：是当前线程所执行的字节码指令的行号指示器 同一个核是错峰出行 会上下文切换，要用程序计数器记录下当前执行到哪里的代码</p>
<p><strong>元空间</strong>：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。最大区别是<strong>元空间在本地内存</strong>中而不是虚拟机中。1.8以前叫永久代   1.8后叫方法区或元空间 一般存储类元信息。还会存有运行时常量池。在里面还会存有静态变量</p>
<p><strong>堆内存</strong>：是JVM所有线程共享的部分，唯一用途是来保存对象实例、数组；由年轻代和老年代组成。new一个都会开启一个空间</p>
</blockquote>
<p><strong>类加载器</strong>：类加载器（Class Loader）负责将类的字节码文件（.class文件）加载到JVM中，并转化为对应的<code>java.lang.Class</code>对象，以供Java程序使用。</p>
<p><strong>执行引擎</strong>：执行引擎（Execution Engine）是负责执行字节码的核心组件。执行引擎的作用是读取字节码指令，对它们进行解析并执行，从而实现Java程序的功能</p>
<p><strong>本地库接口</strong>：是Java虚拟机的一部分，它允许Java程序调用其他语言编写的本地应用程序和库（通常是C或C++）。这是因为Java本身设计为平台无关的语言，但它有时需要与特定平台的底层系统或硬件进行交互，而这通常是通过本地代码实现的。</p>
<p><strong>直接内存（Direct Memory）</strong>：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<h4 id="说一下常见的垃圾回收算法-他们的特点是什么？"><a href="#说一下常见的垃圾回收算法-他们的特点是什么？" class="headerlink" title="说一下常见的垃圾回收算法 他们的特点是什么？"></a>说一下常见的垃圾回收算法 他们的特点是什么？</h4><p><strong>标记清除算法</strong>：将垃圾回收分为2个阶段，标记和清除。内存碎片高，效率高，清除快<br><strong>标记整理算法</strong>：一般用于老年代，将存活的对象都向另一端移动，然后清理边界以外的垃圾。[对象要移动,效率低]，效率慢一些 需要把内存碎片移动，内存碎片没有 但是效率低一点<br><strong>复制算法</strong>：将原有的内存空间一分为二，每次只用其中一块，正在使用的对象复制到另一个内存中，然后将该内存空间清空，交换两个内存的角色，完成垃圾回收。</p>
<p><u>被标记的是没有被回收的</u></p>
<h4 id="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"><a href="#说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现" class="headerlink" title="说一下常见的垃圾回收器以及他们的特点垃圾收集器是垃圾收集算法的具体实现"></a>说一下常见的垃圾回收器以及他们的特点<del>垃圾收集器是垃圾收集算法的具体实现</del></h4><p><strong>串行</strong>垃圾收集器[新生代区]：指使用<strong>单线程</strong>进行垃圾回收(用户请求不能访问<del>STW</del>)，堆内存较小适合个人电脑。底层用的<strong>复制算法</strong><br><strong>并行</strong>垃圾收集器：JDK8默认使用此垃圾回收器，在垃圾回收时，<strong>多个线程</strong>在工作(用户请求不能访问<del>STW</del>)，并且java应用中所有线程都要暂停，等待垃圾回收的完成。底层用的<strong>复制算法</strong><br><strong>CMS</strong>(并发[Concurrent Mark Sweep])垃圾收集器：是一款并发的、使用标记—清除算法的垃圾回收器(针对老年代)   <u>初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置</u>  小于8G内存用CMS  一般用并发垃圾收集器配合收集年轻小内存<br><strong>G1</strong>垃圾收集器[复制算法]：Eden(2M)、最大回收停顿时间、大内存适合用G1、大于8G内存用G1</p>
<h4 id="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"><a href="#说一下cms的各个阶段过程以及特点CMS一般都清理老年代" class="headerlink" title="说一下cms的各个阶段过程以及特点CMS一般都清理老年代"></a>说一下cms的各个阶段过程以及特点<del>CMS一般都清理老年代</del></h4><p>过程：初始标记 → 并发标记 → 并发预清理 → 最终标记 → 并发清除 → 并发重置<br>是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<br>其最大特点是在进行垃圾回收时，应用仍然能正常运行</p>
<p><strong>初始标记</strong>：找GCRoot根去的第一层对象[STW] 速度是非常快的。为什么STW？如果找的时候同时也要标记 那么若这时候有的未被标记那就有大BUG。<br><strong>并发标记</strong>：从第一层找到后的之后那些对象不能被回收(CMS回收器会遍历老年代，标记出所有活动的对象)，在这个阶段，应用程序线程与垃圾回收线程并发运行[能接收用户请求]，会产生新的对象。<br><strong>并发预清理</strong>：这个阶段也是并发执行的，目的是处理在并发标记阶段应用程序线程产生的新垃圾，CMS回收器会清理那些在并发标记阶段被修改的对象，并执行一些预清理工作，以减少下一个STW阶段的暂停时间。<br><strong>最终标记</strong>：这个阶段是STW的，它是为了处理在并发标记和并发预清理阶段未被处理的对象。CMS回收器会完成所有剩余的标记工作，确保所有存活的对象都被正确标记<br><strong>并发清除</strong>：在这个阶段，应用程序线程与垃圾回收线程再次并发运行。CMS回收器会清除未被标记的对象，释放内存空间。清除过程中不会移动存活对象，因此可能会产生内存碎片。<br><strong>并发重置</strong>：这个阶段是并发执行的，目的是重置CMS数据结构，为下一次垃圾回收做准备。</p>
<h4 id="说一下g1的各个阶段过程以及特点，"><a href="#说一下g1的各个阶段过程以及特点，" class="headerlink" title="说一下g1的各个阶段过程以及特点，"></a>说一下g1的各个阶段过程以及特点，</h4><p>划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中<code>humongous</code>专为大对象准备<br>分成三个阶段：新生代回收(STW)、并发标记(重新标记STW)、混合收集。如果并发失败(即回收速度赶不上创建新对象速度)，就会触发<code>Full GC</code></p>
<h4 id="你们项目是用哪一个垃圾收集器，为什么用这个"><a href="#你们项目是用哪一个垃圾收集器，为什么用这个" class="headerlink" title="你们项目是用哪一个垃圾收集器，为什么用这个?"></a>你们项目是用哪一个垃圾收集器，为什么用这个?</h4><p>每个服务两个节点 8G4核 用CMS 太大就用G1</p>
<h4 id="什么样的对象会被成为垃圾对象？"><a href="#什么样的对象会被成为垃圾对象？" class="headerlink" title="什么样的对象会被成为垃圾对象？"></a>什么样的对象会被成为垃圾对象？</h4><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收</p>
<h6 id="怎么确定什么是垃圾？"><a href="#怎么确定什么是垃圾？" class="headerlink" title="怎么确定什么是垃圾？"></a>怎么确定什么是垃圾？</h6><ul>
<li><p><strong>引用计数法</strong><br>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<ol>
<li><strong>标记阶段</strong>：从GCRoots开始，标记所有可达的对象。</li>
<li><strong>回收阶段</strong>：遍历堆中的所有对象，回收那些未被标记的对象所占用的空间。</li>
</ol>
<p>采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
<p>通过可达性分析算法，那些从任何GCRoots都无法到达的对象被认为是不可达的，因此可以被垃圾回收器回收。这种方法能够处理循环引用的情况，这是引用计数法所无法解决的</p>
</li>
</ul>
<p>静态的成员变量[元空间 基本不会被回收] 局部变量 成员属性 </p>
<h4 id="说一下双亲委派机制以及优点"><a href="#说一下双亲委派机制以及优点" class="headerlink" title="说一下双亲委派机制以及优点"></a>说一下双亲委派机制以及优点</h4><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类<br>优点：</p>
<ul>
<li>通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性</li>
<li>为了安全，保证类库API不会被修改</li>
</ul>
<p>用相同的加载器在同一个路径下只能用同一个路径的类 用不同的加载器就可以加载</p>
<h6 id="如何打破双亲委派模型？"><a href="#如何打破双亲委派模型？" class="headerlink" title="如何打破双亲委派模型？"></a>如何打破双亲委派模型？</h6><p><strong>自定义类加载器</strong>：</p>
<ul>
<li><p>通过<strong>自定义类加载器</strong>，并重写<code>loadClass</code>方法，可以实现在加载类时不遵循双亲委派模型。在自定义类加载器中，你可以直接尝试加载类，而不是先委派给父类加载器。</p>
<pre><code class="java">public class CustomClassLoader extends ClassLoader &#123;
    @Override
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;
        // 直接加载，不委派给父类加载器
        return findClass(name);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jvm常用的参数有哪些？代表什么意思"><a href="#jvm常用的参数有哪些？代表什么意思" class="headerlink" title="jvm常用的参数有哪些？代表什么意思"></a>jvm常用的参数有哪些？代表什么意思</h4><p>jps 进程状态信息<br>jstack 查看进程内线程的堆栈信息(产生死锁也可以查看)<br>jmap 查看堆栈信息(生成堆栈内存快照，内存使用信息)<br>jhat 堆转存快照分析工具<br>jstat JVM统计监测工具</p>
<ol>
<li><code>-Xms</code> 和 <code>-Xmx</code>：<ul>
<li><code>-Xms</code>：设置JVM堆内存的初始大小（最小值）。</li>
<li><code>-Xmx</code>：设置JVM堆内存的最大大小。</li>
</ul>
</li>
<li><code>-Xss</code>：<ul>
<li>设置每个线程的堆栈大小。</li>
</ul>
</li>
<li><code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code>：<ul>
<li><code>-XX:NewSize</code>：设置新生代内存的初始大小。</li>
<li><code>-XX:MaxNewSize</code>：设置新生代内存的最大大小。</li>
</ul>
</li>
<li><code>-XX:SurvivorRatio</code>：<ul>
<li>设置新生代中Eden区与Survivor区的容量比例。</li>
</ul>
</li>
<li><code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>（Java 8及之前版本）：<ul>
<li><code>-XX:PermSize</code>：设置永久代（方法区）的初始大小。</li>
<li><code>-XX:MaxPermSize</code>：设置永久代的最大大小。</li>
</ul>
</li>
<li>设置元空间大小<ol>
<li><code>-XX:MetaspaceSize</code>：<ul>
<li>设置元空间的初始大小。当元空间耗尽时，JVM会尝试扩展元空间的大小，直到达到最大值（如果设置了的话）。</li>
</ul>
</li>
<li><code>-XX:MaxMetaspaceSize</code>：<ul>
<li>设置元空间的最大大小。如果没有设置这个参数，元空间的大小只受本地内存限制。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="四大引用分别是什么，代表什么意思？"><a href="#四大引用分别是什么，代表什么意思？" class="headerlink" title="四大引用分别是什么，代表什么意思？"></a>四大引用分别是什么，代表什么意思？</h4><p><strong>强引用</strong>：只要所有 GC Roots 能找到，就不会被回收。<br><strong>软引用</strong>：需要配合<code>SoftReference</code>使用，当垃圾多次回收，<strong>内存依然不够</strong>时候会回收软引用对象<br><strong>弱引用</strong>：需要配合<code>WeakReference</code>使用，<strong>只要进行了垃圾回收</strong>，就会把引用对象回收<br><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存</p>
<p>● 强引用指的就是代码中普遍存在的赋值方式，比如A 但是不a &#x3D; new A()这种。强引用关联的对象，永远不会被GC回收。<br>● 软引用可以用SoftReference来描述，指的是那些有用是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。<br>● 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，只要进行了垃圾回收，就会把引用对象回收。<br>● 虚引用他必须和ReferenceQueue一起使用，必须配合引用队列使用，被引用对象回收时，<br>会将虚引用入队由 <code>Reference Handler</code> 线程调用虚引用相关方法释放直接内存。</p>
<h4 id="什么是内存溢出？什么是内存泄露？"><a href="#什么是内存溢出？什么是内存泄露？" class="headerlink" title="什么是内存溢出？什么是内存泄露？"></a>什么是内存溢出？什么是内存泄露？</h4><p><strong>内存溢出</strong>：内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，导致所需要的内存超出了系统所能提供的最大内存。【会先进行一次GC实在不够就OOM 堆\栈(递归过多,局部变量过多)\方法区都有可能发生内存溢出】<br><strong>内存泄露</strong><del>ThreadLocal会导致</del>：内存泄露是指程序中已分配的内存由于某种原因未能释放，即使在不再需要这些内存的情况下，它们仍然保持分配状态，导致可用内存逐渐减少</p>
<h4 id="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"><a href="#你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？" class="headerlink" title="你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？"></a>你的项目中出现过内存泄漏吗？你是怎么排查并且解决的？</h4><p>有的，内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况<br>1、通过jmap或设置jvm参数获取堆内存快照dump<br>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件<br>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题<br>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<p>异常的祖先是：<code>Throwable</code></p>
<h4 id="怎么解决cpu飙高"><a href="#怎么解决cpu飙高" class="headerlink" title="怎么解决cpu飙高"></a>怎么解决cpu飙高</h4><p>使用top命令查看占用cpu的情况<br>通过top命令查看后，可以查看是哪一个进程占用cpu较高<br>使用ps命令查看进程中的线程信息<br>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</p>
<ul>
<li><p>使用top命令查看占用cpu的情况<code>哪个进程占用的cpu最高</code></p>
<p>finalShell中输入 <code>top</code></p>
</li>
<li><p>查看进程中的线程信息  <code>ps H -eo pid,tid,%cpu | gerp pid</code></p>
</li>
<li><p><strong>jstack</strong> 查看进程内线程的堆栈信息<del>产生死锁可以查看</del></p>
<p>因为是十六进程所以要十进程<strong>转换十六进程</strong><br>直接linux输入 <code>printf &quot;%x\n&quot; Pid</code><br>然后就可以根据十六进制的去找哪个线程cpu占用<br>之后查看文件是<code>cat xxx</code></p>
</li>
</ul>
<h4 id="项目中遇到的难点"><a href="#项目中遇到的难点" class="headerlink" title="项目中遇到的难点"></a>项目中遇到的难点</h4><p>1.从业务角度 曾经做过保险项目 金融保险领域 行外人需要花很多时间了解需求还有同事的帮助才懂得需求知道如何去写</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#00bcd4>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2025/02/09/面试/洪哥面试题/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/02/07/面试/JL/">
        <h2>
            JL
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/2/7
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="招聘流程"><a href="#招聘流程" class="headerlink" title="招聘流程"></a>招聘流程</h4><p>主流网站：Boss直聘<br>先过系统筛选[写本科 写计算机专业 过筛选 得到面试机会]<br>HR会帮我们的 需要KPI当月目标和业绩<br>黑马课程对标3年工作经验 大厂211都不好进</p>
<p>每次都要微信问一下HR：**<u>技术面</u>** 还是 人力面<br>可以打听面试官侧重点，问一下是领导还是主管还是技术组长</p>
<p>不要乱讲话！！不要乱讲话！！不要乱讲话！！不要乱讲话！！</p>
<p>学信网可查吗？ 先说可查  若让 <em><strong>发编号</strong></em> 就下一家      [<u>可填专科吗？？？</u>]</p>
<hr>
<h4 id="简历怎么写好？"><a href="#简历怎么写好？" class="headerlink" title="简历怎么写好？"></a>简历怎么写好？</h4><p>基本信息 籍贯 <strong>工作年限</strong> 求职岗位(Java开发工程师) 薪资(面议)<br>薪资范围6-18k 拉大范围  入职时间：一周内到岗<br>电话必写 邮箱也必写</p>
<p><u>面试问你什么时候能到岗</u>？<strong>3个工作日左右 &#x2F; (3天左右)</strong></p>
<p><img src="C:\Users\Pluminary\AppData\Roaming\Typora\typora-user-images\image-20250207105915015.png" alt="image-20250207105915015"></p>
<p><strong>教育经历</strong><br>25届  19-23  也可以大三出去实习 21-24<br>在校：往前推一年<br>学校 + 专业</p>
<p><strong>工作经历</strong><br>每一家一年多 建议2个公司<br>上一家公司距离现在 不能有很空窗时期【<strong>实时修改工作经验时间</strong>】</p>
<p><strong>上周离职</strong>？<br>有没有面试其他？<br>没有 我也是刚好碰到贵公司  有 拿到了offer但是我还是意愿最大贵公司喜欢贵公司的环境</p>
<p><strong>开发技能</strong> [15条以上]<br>细节引导面试官去书写开发技能<br>记得要设置陷阱<br>从优先级高到低写<br>前端一定要写</p>
<p>Java基础先写到前面<br>大数据统计至少要 3年经验 4个项目经验 </p>
<p><strong>项目周期</strong>：时间控制在5-8个月<br>第一个项目经历至少7-8点 需要业务+技术点<br>第二个项目至少5-6条 达到项目一的七成<br>第三四项目至少3条 减量不减质【不要龙头蛇尾】</p>
<p>2025.2.10号中午收集好简历</p>
<p>文件名称：**<u>Java开发工程师 _ 3年 _ 潘春尧</u>**.pdf</p>
<hr>
<hr>
<h4 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h4><p>期望城市：不限<br>期望岗位：Java开发工程师<br>期望薪资：面议<br>到岗时间：一周内&#x2F;随时<br>写虚岁！！</p>
<h4 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h4><p>民教网3年：2018.9-2022.7     xxx大学   专业：不相关可以不写</p>
<p>学信网<br>25届：实习<br>23-24届：1-2年</p>
<h4 id="工作经历-一家公司超过两年左右-5-8个月-x2F-一个项目"><a href="#工作经历-一家公司超过两年左右-5-8个月-x2F-一个项目" class="headerlink" title="工作经历(一家公司超过两年左右)  5-8个月 &#x2F; 一个项目"></a>工作经历<del>(一家公司超过两年左右)</del>  5-8个月 &#x2F; 一个项目</h4><p><u>xxx公司(找自己熟悉城市，<strong>不要找在线招聘</strong><del>会被HR直接问对面招聘中的HR</del>)</u></p>
<p>没有社保：不写期望城市<br>社保：写社保所在地<br>公司开业时间、小公司(100人以内)、科技有限公司、上班地点交通方式、背景调查写洪哥、法人(老板)、公司地址</p>
<p>背调：模板<br>写纸质版信息表 出生年月日 → 写真实的日期</p>
<p>第一步：写纸质信息表（证明人：电话）<del>洪哥敏姐</del><br><strong>背调信息</strong>：发给洪哥敏姐</p>
<blockquote>
<p>hr会根据你给的电话直接<br>上级领导：项目<br>第三者：朋友&#x2F;同学&#x2F;同事 [可以拒绝回答很多]</p>
</blockquote>
<p><strong>第三方背调</strong>：查社保 查工作记录 查学信网</p>
<p>带身份证去的话 证明楼下的大厦需要登记身份信息才能进</p>
<hr>
<hr>
<h4 id="Boss上的投递"><a href="#Boss上的投递" class="headerlink" title="Boss上的投递"></a>Boss上的投递</h4><p>上传PDF版本的简历<br>工作经历 → 对该公司隐藏我的简历</p>
<p>文件名称：**<u>潘春尧-本科-3年-Java开发工程师</u>**.pdf</p>
<h5 id="尽量先从远的地方投递简历-试试状态！最想去广州的留到最后状态好的时候再投递"><a href="#尽量先从远的地方投递简历-试试状态！最想去广州的留到最后状态好的时候再投递" class="headerlink" title="尽量先从远的地方投递简历 试试状态！最想去广州的留到最后状态好的时候再投递"></a>尽量先从远的地方投递简历 试试状态！最想去广州的留到最后状态好的时候再投递</h5><p><strong>外包公司</strong>：跟培训的学生匹配 哈哈哈！</p>
<hr>
<hr>
<p>五险一金：基本养老保险[<u>工作里面累计交满20年退休时领退休金</u>] 、 基本医疗保险 [<del>总部上海现在在广州</del>一般都是本地医保方便]、 失业保险[<u>工作满一年后因公司被辞退才可以领取</u>] 、 工伤保险 、 生育保险 及 住房公积金</p>
<p>【要找公积金的公司】公积金5% → 买房可以用公积金来贷款；退休后这笔钱可以一次性提取出来养老；装修&#x2F;租房的名义提取(半年一次)</p>
<p>面试题问：上家公司的工资待遇 → 城市最低标准买的<br>10k扣除五险一金 保险400-500 公积金大概300-400左右 </p>
<p>个人所得税：不超过3.6w就是3%，每个月财务都会扣除发放税后工资，起征点5k，超过5k的部分才会交税。10k以内的大概是3%，</p>
<p>面试：公司有绩效考核  我们没有很明确的考核 日常都能完成工作量</p>
<p>入职当天要签劳务合同 1年或3年？<br>区别是什么？<br>1年的劳动合同只能定1个月试用期 2年2个月 3年3个月<br>大概率试用期8-9折 都是3-6个月</p>
<p>签订劳动合同可以离职   末尾淘汰在法律上不允许<br>转正以后被裁可以n+1个月 n代表年 试用期被辞退会赔偿半个月薪资</p>
<p><strong>民教网</strong>(1000人以下的公司) 主攻针对小型企业 和 二三线城市<br>浙江→绍兴杭州<br>远公司约线上公司 </p>
<h6 id="现在在外地-能不能开一轮的线上面试-如果有需求我还是能过去的"><a href="#现在在外地-能不能开一轮的线上面试-如果有需求我还是能过去的" class="headerlink" title="现在在外地 能不能开一轮的线上面试 如果有需求我还是能过去的"></a>现在在外地 能不能开一轮的线上面试 如果有需求我还是能过去的</h6>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/面试" style=color:#00bcd4>
                面试
            </a>
        </span>
        
    </div>

    <a href="/2025/02/07/面试/JL/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2025/01/03/后端/ElasticSearch/">
        <h2>
            ElasticSearch
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2025/1/3
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>ElasticSearch结合Kibana、Logstash、Beats，核心是elastic stack的核心，负责<strong>存储、搜索、分析数据</strong><br>Lucene的优势：容易扩展、高性能(基于倒排索引)<br>Lucene的缺点：直选与java语言开发<br>ElasticSearch是基于Lucene开发的</p>
<h6 id="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"><a href="#Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能" class="headerlink" title="Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能"></a>Elasticsearch：开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</h6><h4 id="正向索引和倒排索引"><a href="#正向索引和倒排索引" class="headerlink" title="正向索引和倒排索引"></a>正向索引和倒排索引</h4><p>传统数据库是<strong>正向索引</strong></p>
<p><strong>ElasticSearch采用倒排索引</strong>：</p>
<ul>
<li>文档(document)：每条数据就是一个文档</li>
<li>词条(term)：文档按照语义分成词语</li>
</ul>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">title</th>
<th align="center">price</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">小米手机</td>
<td align="center">3499</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">华为手机</td>
<td align="center">4999</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">华为小米充电器</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">小米手环</td>
<td align="center">299</td>
</tr>
</tbody></table>
<p>  ↓↓↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓         ↓↓ ↓↓       </p>
<table>
<thead>
<tr>
<th align="center">词条(term)</th>
<th align="center">文档id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">小米</td>
<td align="center">1，3，4</td>
</tr>
<tr>
<td align="center">手机</td>
<td align="center">1，2</td>
</tr>
<tr>
<td align="center">华为</td>
<td align="center">2，3</td>
</tr>
<tr>
<td align="center">充电器</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">手环</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p><strong>过程</strong>：搜索<code>华为手机</code> → 得到：<code>华为</code>、<code>手机</code>两个词条 → 得到每个词条所在文档id：华为:2,3 手机:1,2 → 得到id为1,2,3的文档 → 存入结果集<br><strong>倒排索引</strong>：对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时现根据词条查询到文档id，而后获取到文档<br><strong>正排索引</strong>：基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条</p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>ElasticSearch是面向文档存储的，可以是数据库中的一条商品数据，一个订单信息，文档数据会被序列化为json格式后存储在ElasticSearch中<br>在ElasticSearch中</p>
<ul>
<li>**索引(index)**：相同类型的文档的集合</li>
<li>**映射(mapping)**：索引中文档的字段约束信息，类似表的结构约束</li>
</ul>
<h6 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h6><table>
<thead>
<tr>
<th align="center">MySQL</th>
<th align="center">ElasticSearch</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Table</td>
<td align="center">Index</td>
<td align="center">索引(index)，就是文档的集合，类似于数据库的表(table)</td>
</tr>
<tr>
<td align="center">Row</td>
<td align="center">Document</td>
<td align="center">文档(Document)，就是一条条的数据，类似数据库中的行(Row)，文档都是JSON格式</td>
</tr>
<tr>
<td align="center">Column</td>
<td align="center">Field</td>
<td align="center">字段(Field)，就是JSON文档中的字段，类似数据库中的列(Column)</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="center">Mapping</td>
<td align="center">Mapping(映射)，就是索引中文档的约束，例如字段类型约束。类似数据库的表结构(Schema)</td>
</tr>
<tr>
<td align="center">SQL</td>
<td align="center">DSL</td>
<td align="center">DSL是ElasticSearch提供的JSON风格的请求语句，用来操作ElasticSearch，实现CRUD</td>
</tr>
</tbody></table>
<h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><p><strong>MySQL</strong><del>写操作</del>：擅长事务类型操作，可以确保数据的安全和一致性<br><strong>ElasticSearch</strong><del>查询</del>：擅长海量数据的搜索、分析、计算<br>[<strong><u>可以互补达到数据双写一致性</u></strong>]</p>
<h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络（创建过的不用再创建）：</p>
<pre><code class="sh">docker network create es-net
</code></pre>
<h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p>
<p>课前资料提供了镜像的tar包：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210510165308064.png" alt="image-20210510165308064"></p>
<p>大家将其上传到虚拟机中，然后运行命令加载即可：</p>
<pre><code class="sh"># 导入数据
docker load -i es.tar
</code></pre>
<p>同理还有<code>kibana</code>的tar包也需要这样做。</p>
<h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p>
<pre><code class="sh">docker run -d \
    --name es \
    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \
    -e &quot;discovery.type=single-node&quot; \
    -v es-data:/usr/share/elasticsearch/data \
    -v es-plugins:/usr/share/elasticsearch/plugins \
    --privileged \
    --network es-net \
    -p 9200:9200 \
    -p 9300:9300 \
elasticsearch:7.12.1
</code></pre>
<p>命令解释：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p>在浏览器中输入：<a target="_blank" rel="noopener" href="http://192.168.xxx.xxx:9200/">http://192.168.xxx.xxx:9200</a> 即可看到elasticsearch的响应结果：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506101053676.png" alt="image-20210506101053676"></p>
<h1 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h1><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p>
<h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana，同理先加载镜像： docker load -i kibana.tar，然后启动：</p>
<pre><code class="sh">docker run -d \
--name kibana \
-e ELASTICSEARCH_HOSTS=http://es:9200 \
--network=es-net \
-p 5601:5601  \
kibana:7.12.1
</code></pre>
<ul>
<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为<strong>kibana已经与elasticsearch在一个网络</strong>，因此可以用容器名直接访问elasticsearch</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p>
<pre><code class="sh">docker logs -f kibana
</code></pre>
<p>查看运行日志，当查看到下面的日志，说明成功：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210109105135812.png" alt="image-20210109105135812"></p>
<p>此时，在浏览器输入地址访问：<a href="http://192.168.xxx.xxx:5601，即可看到结果">http://192.168.xxx.xxx:5601，即可看到结果</a></p>
<h6 id="分词效果概览-Dev-Tools-Elastic"><a href="#分词效果概览-Dev-Tools-Elastic" class="headerlink" title="分词效果概览 Dev Tools - Elastic"></a>分词效果概览 <a target="_blank" rel="noopener" href="http://192.168.200.146:5601/app/dev_tools#/console">Dev Tools - Elastic</a></h6><blockquote>
<p>GET &#x2F;_analyze<br>{<br>  “analyzer”: “standard”,<br>  “text”: “黑马程序员”<br>}</p>
</blockquote>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 1,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;马&quot;,
      &quot;start_offset&quot; : 1,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 3,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;序&quot;,
      &quot;start_offset&quot; : 3,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,
      &quot;position&quot; : 4
    &#125;
  ]
&#125;
</code></pre>
<p>如果是分析中午就不能用它原有的，存在明显的问题：将中文逐字分词，没有任何业务语义，因此需要借助专业的分词器</p>
<h1 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h1><h2 id="3-1-在线安装ik插件（较慢）"><a href="#3-1-在线安装ik插件（较慢）" class="headerlink" title="3.1.在线安装ik插件（较慢）"></a>3.1.在线安装ik插件（较慢）</h2><pre><code class="shell"># 进入容器内部
docker exec -it elasticsearch /bin/bash

# 在线下载并安装
./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip

#退出
exit
#重启容器
docker restart elasticsearch
</code></pre>
<h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p>
<pre><code class="sh">docker volume inspect es-plugins
</code></pre>
<p>显示结果：</p>
<pre><code class="json">[
    &#123;
        &quot;CreatedAt&quot;: &quot;2022-05-06T10:06:34+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/es-plugins/_data&quot;,
        &quot;Name&quot;: &quot;es-plugins&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    &#125;
]
</code></pre>
<p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p>
<h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110249144.png" alt="image-20210506110249144"></p>
<h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506110704293.png" alt="image-20210506110704293"></p>
<h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><pre><code class="shell"># 4、重启容器
docker restart es
</code></pre>
<pre><code class="sh"># 查看es日志
docker logs -f es
</code></pre>
<h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p><span style = "color:red"><strong>IK分词器包含两种模式</strong>：</span></p>
<ul>
<li><p><code>ik_smart</code>：最少切分</p>
</li>
<li><p><code>ik_max_word</code>：最细切分</p>
</li>
</ul>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;黑马程序员学习java太棒了&quot;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="json">&#123;
  &quot;tokens&quot; : [
    &#123;
      &quot;token&quot; : &quot;黑马&quot;,
      &quot;start_offset&quot; : 0,
      &quot;end_offset&quot; : 2,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 0
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序员&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 1
    &#125;,
    &#123;
      &quot;token&quot; : &quot;程序&quot;,
      &quot;start_offset&quot; : 2,
      &quot;end_offset&quot; : 4,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 2
    &#125;,
    &#123;
      &quot;token&quot; : &quot;员&quot;,
      &quot;start_offset&quot; : 4,
      &quot;end_offset&quot; : 5,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 3
    &#125;,
    &#123;
      &quot;token&quot; : &quot;学习&quot;,
      &quot;start_offset&quot; : 5,
      &quot;end_offset&quot; : 7,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 4
    &#125;,
    &#123;
      &quot;token&quot; : &quot;java&quot;,
      &quot;start_offset&quot; : 7,
      &quot;end_offset&quot; : 11,
      &quot;type&quot; : &quot;ENGLISH&quot;,
      &quot;position&quot; : 5
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒了&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 6
    &#125;,
    &#123;
      &quot;token&quot; : &quot;太棒&quot;,
      &quot;start_offset&quot; : 11,
      &quot;end_offset&quot; : 13,
      &quot;type&quot; : &quot;CN_WORD&quot;,
      &quot;position&quot; : 7
    &#125;,
    &#123;
      &quot;token&quot; : &quot;了&quot;,
      &quot;start_offset&quot; : 13,
      &quot;end_offset&quot; : 14,
      &quot;type&quot; : &quot;CN_CHAR&quot;,
      &quot;position&quot; : 8
    &#125;
  ]
&#125;
</code></pre>
<h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><h5 id="注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"><a href="#注意当前文件的编码必须是-UTF-8-格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑" class="headerlink" title="注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑"></a><span style = "color:red">注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</span></h5><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p>
<p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p>
<p>1）打开IK分词器config目录：<code>/var/lib/docker/volumes/es-plugins/_data/ik/config/IKAnalyzer.cfg.xml</code></p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20210506112225508.png" alt="image-20210506112225508"></p>
<p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
      
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt; 
&lt;/properties&gt;
</code></pre>
<p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p>
<pre><code class="properties">传智播客
奥力给
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh">docker restart es

# 查看 日志
docker logs -f es
</code></pre>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\微服务\es\day1-es\资料\assets\image-20201115230900504.png" alt="image-20201115230900504"></p>
<p>日志中已经成功加载ext.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业超过90%,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑，可以直接linux系统vi编辑</p>
</blockquote>
<h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p>
<p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p>
<p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
        &lt;!--用户可以在这里配置自己的扩展字典--&gt;
        &lt;entry key=&quot;ext_dict&quot;&gt;ext.dic&lt;/entry&gt;
         &lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;
        &lt;entry key=&quot;ext_stopwords&quot;&gt;stopword.dic&lt;/entry&gt;
&lt;/properties&gt;
</code></pre>
<p>3）在 stopword.dic 添加停用词</p>
<pre><code class="properties">习大大
</code></pre>
<p>4）重启elasticsearch </p>
<pre><code class="sh"># 重启服务
docker restart es
docker restart kibana

# 查看 日志
docker logs -f es
</code></pre>
<p>日志中已经成功加载stopword.dic配置文件</p>
<p>5）测试效果：</p>
<pre><code class="json">GET /_analyze
&#123;
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot;: &quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;
&#125;
</code></pre>
<blockquote>
<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p>
</blockquote>
<hr>
<hr>
<h4 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h4><h5 id="mapping属性"><a href="#mapping属性" class="headerlink" title="mapping属性"></a>mapping属性</h5><h6 id="mapping是对索引库中文档的约束，常见的mapping属性包括："><a href="#mapping是对索引库中文档的约束，常见的mapping属性包括：" class="headerlink" title="mapping是对索引库中文档的约束，常见的mapping属性包括："></a>mapping是对索引库中文档的约束，常见的mapping属性包括：</h6><p>• type：字段数据类型，常见的简单类型有：<br>• 字符串：text（可分词的文本）、<strong>keyword</strong>（精确值，例如：品牌、国家、ip地址）<br>• 数值：long、integer、short、byte、double、float<br>• 布尔：boolean<br>• 日期：date<br>• 对象：object<br>• index：是否创建索引，默认为true【默认倒排】<br>• analyzer：使用哪种分词器【只有text才需要分词】<br>• properties：该字段的子字段</p>
<pre><code class="java">&#123;
    &quot;age&quot;: 21,
    &quot;weight&quot;: 52.1,
    &quot;isMarried&quot;: false,
    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;score&quot;: [99.1, 99.5, 98.9],
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;
</code></pre>
<h5 id="索引库操作-1"><a href="#索引库操作-1" class="headerlink" title="索引库操作"></a>索引库操作</h5><h6 id="创建索引库和mapping的请求语法"><a href="#创建索引库和mapping的请求语法" class="headerlink" title="创建索引库和mapping的请求语法"></a>创建索引库和mapping的请求语法</h6><pre><code class="java">PUT /索引库名称
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;字段名&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_smart&quot;
      &#125;,
      &quot;字段名2&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: &quot;false&quot;
      &#125;,
      &quot;字段名3&quot;:&#123;
        &quot;properties&quot;: &#123;
          &quot;子字段&quot;: &#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;,
      // ...略
    &#125;
  &#125;
&#125;
</code></pre>
<p>↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓    ↓ ↓</p>
<pre><code class="java"># 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
---------------------------------------------------------------------
&#123;
  &quot;acknowledged&quot; : true,
  &quot;shards_acknowledged&quot; : true,
  &quot;index&quot; : &quot;heima&quot;
&#125;
</code></pre>
<h4 id="操作索引库禁止修改索引库-因为已经映射好了"><a href="#操作索引库禁止修改索引库-因为已经映射好了" class="headerlink" title="操作索引库禁止修改索引库(因为已经映射好了)"></a>操作索引库<del>禁止修改索引库(因为已经映射好了)</del></h4><h6 id="查看索引语法："><a href="#查看索引语法：" class="headerlink" title="查看索引语法："></a>查看索引语法：</h6><p><code>GET/索引名</code></p>
<h6 id="删除索引库的语法："><a href="#删除索引库的语法：" class="headerlink" title="删除索引库的语法："></a>删除索引库的语法：</h6><p><code>DELETE/索引库名</code></p>
<h6 id="可以在修改索引的过程中添加新的字段"><a href="#可以在修改索引的过程中添加新的字段" class="headerlink" title="可以在修改索引的过程中添加新的字段"></a>可以在修改索引的过程中添加新的字段</h6><pre><code class="java">PUT /索引库名/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;新字段名&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
---------------------------
PUT /heima/_mapping
&#123;
  &quot;properties&quot;: &#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>当您使用Elasticsearch（ES）的PUT请求创建索引库时，这个索引库实际上是存储在Elasticsearch集群的节点上的。如果您的Elasticsearch集群是安装在Linux服务器上的，那么是的，索引库会被创建在Linux文件系统中。</p>
<p>Elasticsearch为每个索引分配一个或多个主分片，并为每个主分片分配一个或多个副本分片。这些分片实际上是存储在Elasticsearch节点的文件系统上的。具体来说，索引数据存储在以下路径：</p>
<p>复制</p>
<pre><code>/path/to/elasticsearch/data/nodes/&lt;node-id&gt;/&lt;index&gt;/&lt;shard-id&gt;
</code></pre>
<p>这里的<code>/path/to/elasticsearch</code>是Elasticsearch的安装路径，<code>data</code>目录是默认的数据存储位置，<code>nodes</code>目录包含了集群中各个节点的数据，<code>&lt;node-id&gt;</code>是节点的唯一标识，<code>&lt;index&gt;</code>是您创建的索引名称，而<code>&lt;shard-id&gt;</code>则是分片的ID。</p>
</blockquote>
<h4 id="索引库的增删改查汇总"><a href="#索引库的增删改查汇总" class="headerlink" title="索引库的增删改查汇总"></a>索引库的增删改查汇总</h4><pre><code class="mysql">
# 创建索引库
PUT /heima
&#123;
  &quot;mappings&quot;: &#123;
    &quot;properties&quot;: &#123;
      &quot;info&quot;:&#123;
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;
      &#125;,
      &quot;email&quot;:&#123;
        &quot;type&quot;: &quot;keyword&quot;,
        &quot;index&quot;: false
      &#125;,
      &quot;name&quot;:&#123;
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: &#123;
          &quot;firstName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;,
          &quot;lastName&quot;:&#123;
            &quot;type&quot;: &quot;keyword&quot;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
&#125;

# 查询
GET /heima

# 修改索引库
PUT /heima/_mapping
&#123;
  &quot;properties&quot;:&#123;
    &quot;age&quot;:&#123;
      &quot;type&quot;: &quot;integer&quot;
    &#125;
  &#125;
&#125;

# 修改
DELETE /heima
</code></pre>
<h5 id="文档操作——添加文档"><a href="#文档操作——添加文档" class="headerlink" title="文档操作——添加文档"></a>文档操作——添加文档</h5><pre><code class="mysql"># 每次写操作的时候 版本会增加 &quot;_version ++&quot;

# 插入文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;390415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;春&quot;,
    &quot;lastName&quot;: &quot;尧&quot;
  &#125;
&#125;

# 查询文档
GET /heima/_doc/1

# 删除文档
DELETE /heima/_doc/1
</code></pre>
<h5 id="文档操作——修改文档"><a href="#文档操作——修改文档" class="headerlink" title="文档操作——修改文档"></a>文档操作——修改文档</h5><h6 id="方式一：全量修改，会删除旧文档，添加新文档"><a href="#方式一：全量修改，会删除旧文档，添加新文档" class="headerlink" title="方式一：全量修改，会删除旧文档，添加新文档"></a>方式一：全量修改，会删除旧文档，添加新文档</h6><pre><code class="java">PUT /索引库名/_doc/文档id
&#123;
    &quot;字段1&quot;: &quot;值1&quot;,
    &quot;字段2&quot;: &quot;值2&quot;,
    // ... 略
&#125;
-------------------------
PUT /heima/_doc/1
&#123;
    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,
    &quot;email&quot;: &quot;zy@itcast.cn&quot;,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;: &quot;云&quot;,
        &quot;lastName&quot;: &quot;赵&quot;
    &#125;
&#125;


# 全量修改文档
POST /heima/_doc/1
&#123;
  &quot;info&quot;: &quot;广州黑马198班&quot;,
  &quot;email&quot;: &quot;90415049@qq.com&quot;,
  &quot;name&quot;:&#123;
    &quot;firstName&quot;: &quot;尧&quot;,
    &quot;lastName&quot;: &quot;春&quot;
  &#125;
&#125;
</code></pre>
<h6 id="方式二：增量修改，修改指定字段值"><a href="#方式二：增量修改，修改指定字段值" class="headerlink" title="方式二：增量修改，修改指定字段值"></a>方式二：增量修改，修改指定字段值</h6><pre><code class="java">POST /索引库名/_update/文档id
&#123;
    &quot;doc&quot;: &#123;
         &quot;字段名&quot;: &quot;新的值&quot;,
    &#125;
&#125;
-------------------------
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;
  &#125;
&#125;


# 局部修改文档
POST /heima/_update/1
&#123;
  &quot;doc&quot;: &#123;
    &quot;email&quot;: &quot;ZYun@itcast.cn&quot;
  &#125;
&#125;
</code></pre>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>文档操作有哪些？</p>
<ul>
<li><p>创建文档：POST &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>查询文档：GET &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>删除文档：DELETE &#x2F;索引库名&#x2F;_doc&#x2F;文档id</p>
</li>
<li><p>修改文档：</p>
<ul>
<li><p>全量修改：PUT &#x2F;索引库名&#x2F;_doc&#x2F;文档id { json文档 }</p>
</li>
<li><p>增量修改：POST &#x2F;索引库名&#x2F;_update&#x2F;文档id { “doc”: {字段}}</p>
</li>
</ul>
</li>
</ul>
<h3 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h3><p>Elasticsearch目前最新版本是8.0，其Java客户端有很大变化。不过大多数企业使用的还是8以下版本，所以我们选择使用早期的JavaRestClient客户端来学习。官方文档地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch Clients | Elastic</a></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2025/01/03/后端/ElasticSearch/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/23/后端/MyBatisPlus/">
        <h2>
            MyBatisPlus
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/23
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><a target="_blank" rel="noopener" href="https://www.baomidou.com/">MyBatis-Plus</a><br><a target="_blank" rel="noopener" href="https://www.baomidou.com/introduce/">简介 | MyBatis-Plus</a></p>
<h5 id="引入MybatisPlus起步依赖写依赖-认爸爸"><a href="#引入MybatisPlus起步依赖写依赖-认爸爸" class="headerlink" title="引入MybatisPlus起步依赖写依赖+认爸爸"></a>引入MybatisPlus起步依赖<del>写依赖+认爸爸</del></h5><ul>
<li>MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter：</li>
</ul>
<pre><code class="xml">&lt;!--MybatisPlus--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; 
    &lt;version&gt;3.5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>自定义的Mapper继承MybatisPlus提供的<code>BaseMapper</code>接口</li>
</ul>
<pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">UserMapper.java

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;
</code></pre>
<pre><code class="xml">UserMapper.xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.itheima.mp.mapper.UserMapper&quot;&gt;

&lt;/mapper&gt;
</code></pre>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><code>@TableName</code>：用来指定表名</li>
<li><code>@Tableld</code>：用来指定表中的主键字段信息<ul>
<li><code>IdType枚举</code>：<ul>
<li><strong>AUTO</strong>：数据库自增长</li>
<li><strong>INPUT</strong>：通过set方法自行输入</li>
<li><em>ASSIGN_ID</em>：<u>分配ID 默认实现类是</u><code>雪花算法</code></li>
</ul>
</li>
</ul>
</li>
<li><code>@TableField</code>：用来指定表中的普通字段信息<del>默认驼峰转下划线，不一致需要改</del><ul>
<li>成员变量名与数据库字段名不一致</li>
<li><u>成员变量名是以<strong>is开头</strong>，且是<strong>布尔值</strong></u><del>isMarried</del></li>
<li>成员变量名与数据库关键字冲突<del>order</del></li>
<li>成员变量不是数据库字段<del>address</del>，要标记不存在不然会默认数据库字段</li>
</ul>
</li>
</ul>
<pre><code class="java">@Data
public class User &#123;
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;
    
    @TableField(&quot;username&quot;)
    private String name;

    @TableField(&quot;is_married&quot;)
    private Boolean isMarried;  // is经过反射会默认变成变量名Married
    
    @TableField(&quot;`order`&quot;)
    private Integer order;
    
    @TableField(exist = false)
    private String address;
......
&#125;
</code></pre>
<p>此时如果数据库的表名是：<code>tb_user</code> 就需要用到 <code>@TableName</code> 了</p>
<pre><code class="mysql">数据库名：tb_user (用户表)
#  名称
1  id
2  username
3  is_married
4  order
</code></pre>
<h3 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h3><p><code>MyBatisPlus</code>的配置项继承了MyBatis原生配置和一些自己特有的配置<br>MP更擅长单表的增删改查，如果是多表还是推荐用xml</p>
<pre><code class="yaml">mybatis:
  mapper-locations: classpath*:mapper/*.xml # Mapper.xml文件地址，默认值
  type-aliases-package: com.itheima.po # 别名扫描包
  configuration:
    map-underscore-to-camel-case: true # 开启驼峰命名自动映射
    cache-enabled: false # 是否开启二级缓存
  global-config:
    db-config:
      id-type: assign_id # id为雪花算法生成
      update-strategy: not_null # 更新策略：只更新非空字段 类似于动态sql
</code></pre>
<p><span style="color:red"><strong>MyBatisPlus使用的基本流程</strong></span></p>
<ul>
<li>引入起步依赖</li>
<li>自定义Mapper基础BaseMapper</li>
<li>在实体类上添加注释声明 表信息</li>
<li>在application.yml中根据需要添加配置</li>
</ul>
<h3 id="核心功能—条件构造器"><a href="#核心功能—条件构造器" class="headerlink" title="核心功能—条件构造器"></a>核心功能—条件构造器</h3><h6 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h6><p><img src="https://raw.githubusercontent.com/P-luminary/images/3b9a3950642e32ab3182e3aae6cd2ba50c25f42f/MyBatisPlus%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%88%97%E8%A1%A8.jpg"></p>
<p><code>MyBatisPlus</code>支持各种复杂的<code>where</code>条件，满足日常开发的所有需求</p>
<ul>
<li>查询出名字中带o的，存款大于等于1000元的人的id、username、info、balance字段</li>
</ul>
<pre><code class="mysql"># 原始SQL：
SELECT id,username,info,balance
FROM user
WHERE username LIKE ? AND balance &gt;= ?
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testQueryWrapper()&#123;
        // 1.构建查询条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;()
                .select(&quot;id&quot;, &quot;username&quot;, &quot;phone&quot;)
                .like(&quot;username&quot;, &quot;o&quot;)
                .ge(&quot;balance&quot;, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;
</code></pre>
<pre><code class="java">// MyBatisPlus Lambda编码格式(解决硬编码)：
 @Test
    void testLambdaQueryWrapper()&#123;
        // 1.构建查询条件
        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;User&gt;()
                // 利用反射 解决字符串硬编码
                .select(User::getId, User::getUsername, User::getPhone)
                .like(User::getUsername, &quot;o&quot;)
                .ge(User::getBalance, 1000);
        // 2.查询
        List&lt;User&gt; users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    &#125;

-------------------------------------------------------------------------
@Test
void testLambdaQueryWrapperWithQueryWrapper()&#123;
    // 1. 构建查询条件
    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;User&gt;();
    LambdaQueryWrapper&lt;User&gt; wrapper = queryWrapper.lambda()
            .select(User::getId, User::getUsername, User::getPhone)
            .like(User::getUsername, &quot;o&quot;)
            .ge(User::getBalance, 1000);

    // 2. 查询
    List&lt;User&gt; users = userMapper.selectList(wrapper);
    users.forEach(System.out::println);
&#125;
</code></pre>
<ul>
<li>更新用户名为jack的用户的余额为2000</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = 2000
    WHERE (username = &quot;jack&quot;)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateByQueryWrapper()&#123;
        // 1.要更新的数据
        User user = new User();
        user.setBalance(2000);
        // 2.更新的条件
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().eq(&quot;username&quot;, &quot;jack&quot;);
        // 3.执行更新
        userMapper.update(user, wrapper);
    &#125;
</code></pre>
<ul>
<li>更新id为1，2，4的用户的余额，扣200</li>
</ul>
<pre><code class="mysql"># 原始SQL：
UPDATE user
    SET balance = balance - 200
    WHERE id in (1,2,4)
</code></pre>
<pre><code class="java">// MyBatisPlus：
@Test
    void testUpdateWrapper()&#123;
        List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
        UpdateWrapper&lt;User&gt; wrapper = new UpdateWrapper&lt;User&gt;()
                .setSql(&quot;balance = balance - 100&quot;)
                .in(&quot;id&quot;, ids);
        userMapper.update(null, wrapper);
    &#125;
</code></pre>
<h5 id="条件构造器的用法："><a href="#条件构造器的用法：" class="headerlink" title="条件构造器的用法："></a>条件构造器的用法：</h5><ul>
<li><p>QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分</p>
</li>
<li><p>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用</p>
</li>
<li><p>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码</p>
</li>
</ul>
<h3 id="4-字段映射与表名映射"><a href="#4-字段映射与表名映射" class="headerlink" title="4. 字段映射与表名映射"></a>4. 字段映射与表名映射</h3><h4 id="4-1-问题一：表字段与编码属性设计不同步"><a href="#4-1-问题一：表字段与编码属性设计不同步" class="headerlink" title="4.1 问题一：表字段与编码属性设计不同步"></a>4.1 问题一：表字段与编码属性设计不同步</h4><ul>
<li>在模型类属性上方，使用**@TableField**属性注解，通过&#x3D;&#x3D;<strong>value</strong>&#x3D;&#x3D;属性，设置当前属性对应的数据库表中的字段关系。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\1683796001750.png" alt="1683796001750"></p>
<h4 id="4-2-问题二：编码中添加了数据库中未定义的属性"><a href="#4-2-问题二：编码中添加了数据库中未定义的属性" class="headerlink" title="4.2 问题二：编码中添加了数据库中未定义的属性"></a>4.2 问题二：编码中添加了数据库中未定义的属性</h4><ul>
<li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>&#x3D;&#x3D;exist&#x3D;&#x3D;**属性，设置属性在数据库表字段中是否存在，默认为true。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\exist.png" alt="1683796121907"></p>
<h4 id="4-3-问题三：表名与编码开发设计不同步"><a href="#4-3-问题三：表名与编码开发设计不同步" class="headerlink" title="4.3 问题三：表名与编码开发设计不同步"></a>4.3 问题三：表名与编码开发设计不同步</h4><ul>
<li>在<u><strong>模型类</strong></u>上方，使用**@TableName<strong>注解，通过</strong>&#x3D;&#x3D;value&#x3D;&#x3D;**属性，设置当前类对应的数据库表名称。</li>
</ul>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\table.png" alt="1683798660359"></p>
<h2 id="四、主键生成策略"><a href="#四、主键生成策略" class="headerlink" title="四、主键生成策略"></a>四、主键生成策略</h2><p>id主键生成的策略有哪几种方式？</p>
<p>不同的表应用不同的id生成策略</p>
<ul>
<li>日志：自增（1,2,3,4，……）</li>
<li>购物订单：特殊规则（FQ23948AK3843）</li>
<li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li>
<li>关系表：可省略id</li>
<li>……</li>
</ul>
<h3 id="1-id生成策略控制（-TableId注解）"><a href="#1-id生成策略控制（-TableId注解）" class="headerlink" title="1 id生成策略控制（@TableId注解）"></a>1 id生成策略控制（@TableId注解）</h3><p>雪花算法：<code>@TableId(type= IdType.ASSIGN_ID)</code><br><code>ASSIGN_UUID</code>是趋势递增<br>用了<code>分库分表</code>就不能用默认的id自增了 要用雪花算法</p>
<ul>
<li><p>名称：@TableId</p>
</li>
<li><p>类型：<strong>属性注解</strong></p>
</li>
<li><p>位置：模型类中用于表示主键的属性定义上方</p>
</li>
<li><p>作用：设置当前类中主键属性的生成策略</p>
</li>
<li><p>相关属性</p>
<p>​    <strong>type</strong>：设置主键属性的生成策略，值参照IdType枚举值</p>
<p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801192449901.png" alt="image-20210801192449901"></p>
</li>
</ul>
<h3 id="2-全局策略配置"><a href="#2-全局策略配置" class="headerlink" title="2 全局策略配置"></a>2 全局策略配置</h3><pre><code class="yml">mybatis-plus:
  global-config:
    db-config:
      id-type: assign_id #全局设置主键id策略
      table-prefix: tbl_  #表名前缀设置
</code></pre>
<h5 id="id生成策略全局配置"><a href="#id生成策略全局配置" class="headerlink" title="id生成策略全局配置"></a>id生成策略全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183128266.png" alt="image-20210801183128266"></p>
<h5 id="表名前缀全局配置"><a href="#表名前缀全局配置" class="headerlink" title="表名前缀全局配置"></a>表名前缀全局配置</h5><p><img src="E:\广州黑马JavaEE就业198期—洪哥\mybatis-plus\讲义\md\assets\image-20210801183157694.png" alt="image-20210801183157694"></p>
<h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><p>我们可以利用MyBatisPlus的Wrapper来**<u>构造复杂的where条件</u>**，然后自己定义SQL语句中剩下的部分。</p>
<h6 id="将id在指定范围的用户-1-2-4-的余额扣减指定值"><a href="#将id在指定范围的用户-1-2-4-的余额扣减指定值" class="headerlink" title="将id在指定范围的用户(1,2,4)的余额扣减指定值"></a>将id在指定范围的用户(1,2,4)的余额扣减指定值</h6><pre><code class="sql">&lt;update id = &quot;updateBalanceByIds&quot;&gt;
    UPDATE user
    SET balance = balance - #&#123;amount&#125;
    WHERE id IN
    &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;
    #&#123;id&#125;
    &lt;/foreach&gt;
&lt;/update&gt;
</code></pre>
<ul>
<li>基于Wrapper构建where条件</li>
</ul>
<pre><code class="java">// 1.更新条件
  List&lt;Long&gt; ids = List.of(1L, 2L, 4L);
  int amount = 200;
// 2.定义条件
  QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;().in(User::getId, ids);
// 3.调用自定义SQL方法
  userMapper.updateBalanceByIds(wrapper, amount);
</code></pre>
<ul>
<li>在mapper方法参数中用Param注解声明wrapper变量名称，<strong>必须是ew</strong></li>
</ul>
<pre><code class="java">void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);
</code></pre>
<ul>
<li>自定义SQL，并使用Wrapper条件</li>
</ul>
<pre><code class="xml">&lt;update id=&quot;updateBalanceByIds&quot;&gt;
        update user
        set balance = balance - #&#123;amount&#125; $&#123;ew.customSqlSegment&#125;
    &lt;/update&gt;
</code></pre>
<h3 id="IService接口基本用法"><a href="#IService接口基本用法" class="headerlink" title="IService接口基本用法"></a>IService接口基本用法</h3><img src="https://raw.githubusercontent.com/P-luminary/images/d025a67eaeb98c3eb9725d71e36e36b6516b2b7d/IService%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.jpg" style="zoom:150%;" />

<ul>
<li>自定义Service接口继承IService接口</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

public interface IUserService extends IService&lt;User&gt; &#123;

&#125;
</code></pre>
<ul>
<li>自定义Service实现类，实现自定义接口并继承ServiceImpl类</li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.impl.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;

&#125;
</code></pre>
<ul>
<li>搞了个测试类<code>@Test</code></li>
</ul>
<pre><code class="java">package com.itheima.mp.service.impl;

import com.itheima.mp.domain.po.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

@SpringBootTest
class IUserServiceTest &#123;
    @Autowired
    private IUserService userService;

    @Test
    void testSaveUser() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userService.save(user);
    &#125;
    @Test
    void testQuery()&#123;
        List&lt;User&gt; users = userService.listByIds(Arrays.asList(1L, 2L, 3L));
        users.forEach(System.out::println);
    &#125;

&#125;
</code></pre>
<h3 id="IService开发基础业务接口"><a href="#IService开发基础业务接口" class="headerlink" title="IService开发基础业务接口"></a>IService开发基础业务接口</h3><ul>
<li>基于Restful风格实现下面的接口：<br>飞书文档说明：(<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc">https://b11et3un53m.feishu.cn/wiki/PsyawI04ei2FQykqfcPcmd7Dnsc</a>)</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>接口</strong></th>
<th align="left"><strong>请求方式</strong></th>
<th align="left"><strong>请求路径</strong></th>
<th><strong>请求参数</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">新增用户</td>
<td align="left">POST</td>
<td align="left">&#x2F;users</td>
<td>用户表单实体</td>
<td>无</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">删除用户</td>
<td align="left">DELETE</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>无</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">根据id查询用户</td>
<td align="left">GET</td>
<td align="left">&#x2F;users&#x2F;{id}</td>
<td>用户id</td>
<td>用户VO</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">根据id批量查询</td>
<td align="left">GET</td>
<td align="left">&#x2F;users</td>
<td>用户id集合</td>
<td>用户VO集合</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">根据id扣减余额</td>
<td align="left">PUT</td>
<td align="left">&#x2F;users&#x2F;{id}&#x2F;deduction&#x2F;{money}</td>
<td>•用户id  •扣减金额</td>
<td>无</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thinkingandworkinghard/p/10482929.html">解决在IDEA 的Maven下 出现 Cannot access in offline mode 问题 - Doyourself! - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/doc.html">管理接口文档</a></p>
<pre><code class="java">UserController.java
package com.itheima.mp.controller;

import cn.hutool.core.bean.BeanUtil;
import com.itheima.mp.domain.po.User;

import com.itheima.mp.domain.dto.UserFormDTO;

import com.itheima.mp.domain.vo.UserVO;
import com.itheima.mp.service.IUserService;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Api(tags = &quot;用户管理接口&quot;)
@RequiredArgsConstructor
@RestController
@RequestMapping(&quot;users&quot;)
public class UserController &#123;

    private final IUserService userService;

    @PostMapping
    @ApiOperation(&quot;新增用户&quot;)
    public void saveUser(@RequestBody UserFormDTO userFormDTO) &#123;
        // 1.转换DTO为PO
        User user = BeanUtil.copyProperties(userFormDTO, User.class);
        // 2.新增
        userService.save(user);
    &#125;

    @DeleteMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;删除用户&quot;)
    public void removeUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        userService.removeById(userId);
    &#125;

    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long userId) &#123;
        // 1.查询用户
        User user = userService.getById(userId);
        // 2.处理vo
        return BeanUtil.copyProperties(user, UserVO.class);
    &#125;

    @GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;

    @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserFormDTO.java
package com.itheima.mp.domain.dto;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户表单实体&quot;)
public class UserFormDTO &#123;

    @ApiModelProperty(&quot;id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;密码&quot;)
    private String password;

    @ApiModelProperty(&quot;注册手机号&quot;)
    private String phone;

    @ApiModelProperty(&quot;详细信息，JSON风格&quot;)
    private String info;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;
&#125;
</code></pre>
<pre><code class="java">UserQuery.java
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
    @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额
        baseMapper.deductMoneyById(id, money);
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.mapper;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import com.itheima.mp.domain.po.User;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Update;

import java.util.List;

public interface UserMapper extends BaseMapper&lt;User&gt; &#123;

    List&lt;User&gt; queryUserByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);

    void updateBalanceByIds(@Param(Constants.WRAPPER) QueryWrapper&lt;User&gt; wrapper, @Param(&quot;amount&quot;) int amount);

    @Update(&quot;UPDATE user SET balance = balance - #&#123;money&#125; WHERE id = #&#123;id&#125;&quot;)
    void deductMoneyById(Long id, Integer money);
&#125;
</code></pre>
<h3 id="Iservice的Lambda方法"><a href="#Iservice的Lambda方法" class="headerlink" title="Iservice的Lambda方法"></a>Iservice的Lambda方法</h3><h6 id="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："><a href="#需求：实现一个根据复杂条件查询用户的接口，查询条件如下：" class="headerlink" title="需求：实现一个根据复杂条件查询用户的接口，查询条件如下："></a>需求：实现一个根据复杂条件查询用户的接口，查询条件如下：</h6><p><strong>name</strong>：用户名关键字，可以为空<br><strong>status</strong>：用户状态，可以为空<br><strong>minBalance</strong>：最小余额，可以为空<br><strong>maxBalance</strong>：最大余额，可以为空</p>
<pre><code class="mysql">&lt;select id=&quot;queryUsers&quot; resultType=&quot;com.itheima.mp.domain.po.User&quot;&gt;
    SELECT *
    FROM tb_user
    &lt;where&gt;
        &lt;if test=&quot;name != null&quot;&gt;
            AND username LIKE CONCAT(&#39;%&#39;, #&#123;name&#125;, &#39;%&#39;)
        &lt;/if&gt;
        &lt;if test=&quot;status != null&quot;&gt;
            AND `status` = #&#123;status&#125;
        &lt;/if&gt;
        &lt;if test=&quot;minBalance != null and maxBalance != null&quot;&gt;
            AND balance BETWEEN #&#123;minBalance&#125; AND #&#123;maxBalance&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h6 id="UserQuery-java"><a href="#UserQuery-java" class="headerlink" title="UserQuery.java"></a>UserQuery.java</h6><pre><code class="java">package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery &#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<h6 id="UserController-java"><a href="#UserController-java" class="headerlink" title="UserController.java"></a>UserController.java</h6><pre><code class="java">    @ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        // 1.查询用户PO
        List&lt;User&gt; users = userService.queryUsers(query.getName(), query.getStatus(), query.getMinBalance(), query.getMaxBalance());
        // 2.把po拷贝到vo
        return BeanUtil.copyToList(users, UserVO.class);
    &#125;
</code></pre>
<h6 id="IUserService-java"><a href="#IUserService-java" class="headerlink" title="IUserService.java"></a>IUserService.java</h6><pre><code class="java">package com.itheima.mp.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.mp.domain.po.User;

import java.util.List;

public interface IUserService extends IService&lt;User&gt; &#123;
    void deductBalance(Long id, Integer money);

    List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance);
&#125;
</code></pre>
<h6 id="UserServiceImpl-java"><a href="#UserServiceImpl-java" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java">package com.itheima.mp.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.mp.domain.po.User;
import com.itheima.mp.mapper.UserMapper;
import com.itheima.mp.service.IUserService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;
   @Override
    public List&lt;User&gt; queryUsers(String name, Integer status, Integer minBalance, Integer maxBalance) &#123;
        return lambdaQuery()
                .like(name!=null, User::getUsername,name)
                .eq(status!=null, User::getStatus,status)
                .gt(minBalance!=null, User::getBalance,minBalance) // 大于
                .lt(maxBalance!=null, User::getBalance,maxBalance) // 小于
                .list();
    &#125;
&#125;
</code></pre>
<h3 id="IService的Lambda更新LambdaUpdate-、LambdaQuery"><a href="#IService的Lambda更新LambdaUpdate-、LambdaQuery" class="headerlink" title="IService的Lambda更新LambdaUpdate()、LambdaQuery()"></a>IService的Lambda更新<del>LambdaUpdate()、LambdaQuery()</del></h3><h6 id="改造根据id修改用户余额的接口，要求如下"><a href="#改造根据id修改用户余额的接口，要求如下" class="headerlink" title="改造根据id修改用户余额的接口，要求如下"></a>改造根据id修改用户余额的接口，要求如下</h6><ul>
<li><p>完成对用户状态校验</p>
</li>
<li><p>完成对用户余额校验</p>
</li>
<li><p>如果扣减后余额为0，则将用户status修改为冻结状态 (2)</p>
<h6 id="UserController-java-1"><a href="#UserController-java-1" class="headerlink" title="UserController.java"></a>UserController.java</h6></li>
</ul>
<pre><code class="java"> @PutMapping(&quot;&#123;id&#125;/deduction/&#123;money&#125;&quot;)
    @ApiOperation(&quot;扣减用户余额&quot;)
    public void deductBalance(@ApiParam(&quot;用户id&quot;) @PathVariable(&quot;id&quot;) Long id, @ApiParam(&quot;扣减的金额&quot;) @PathVariable(&quot;money&quot;) Integer money) &#123;
        userService.deductBalance(id, money);
    &#125;
</code></pre>
<h6 id="UserServiceImpl-java-1"><a href="#UserServiceImpl-java-1" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h6><pre><code class="java"> @Override
    public void deductBalance(Long id, Integer money) &#123;
        // 1.查询用户
        User user = getById(id);
        // 2.判断用户状态
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 3.判断用户余额
        if (user.getBalance() &lt; money) &#123;
            throw new RuntimeException(&quot;用户余额不足&quot;);
        &#125;
        // 4.扣减余额 update tb_user set balance = balance - ?
        int remainBalance = user.getBalance() - money;
        lambdaUpdate()
                .set(User::getBalance, remainBalance)
                .set(remainBalance == 0,User::getStatus, 2)
                .eq(User::getId, id)
                .eq(User::getBalance, user.getBalance()) // 乐观锁
                .update();
    &#125;
</code></pre>
<h3 id="IService的批量新增"><a href="#IService的批量新增" class="headerlink" title="IService的批量新增"></a>IService的批量新增</h3><h6 id="批量插入10万条用户数据，并作出对比："><a href="#批量插入10万条用户数据，并作出对比：" class="headerlink" title="批量插入10万条用户数据，并作出对比："></a>批量插入10万条用户数据，并作出对比：</h6><ul>
<li>普通for循环插入<del>4分钟</del></li>
<li><strong>IService的批量插入</strong><del>30秒</del></li>
<li>开启<strong>rewriteBatchedStatements&#x3D;true</strong>参数【6秒】<del>重写Statement语句，在application.yaml的sql中url拼接</del></li>
</ul>
<pre><code class="java">Test  com/itheima/mp/service/IUserServiceTest.java
@Test
    void testSaveOneByOne() &#123;
        long b = System.currentTimeMillis();
        for (int i = 1; i &lt;= 100000; i++) &#123;
            userService.save(buildUser(i));
        &#125;
        long e = System.currentTimeMillis();
        System.out.println(&quot;耗时：&quot; + (e - b));
    &#125;

    private User buildUser(int i) &#123;
        User user = new User();
        user.setUsername(&quot;user_&quot; + i);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;&quot; + (18688190000L + i));
        user.setBalance(2000);
        user.setInfo(&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;);
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(user.getCreateTime());
        return user;
    &#125;
</code></pre>
<h6 id="MyBatisPlus的批处理"><a href="#MyBatisPlus的批处理" class="headerlink" title="MyBatisPlus的批处理"></a>MyBatisPlus的批处理</h6><pre><code class="java">@Test
void testSaveBatch() &#123;
    // 准备10万条数据
    List&lt;User&gt; list = new ArrayList&lt;&gt;(1000);
    long b = System.currentTimeMillis();
    for (int i = 1; i &lt;= 100000; i++) &#123;
        list.add(buildUser(i));
        // 每1000条批量插入一次
        if (i % 1000 == 0) &#123;
            userService.saveBatch(list);
            list.clear();
        &#125;
    &#125;
    long e = System.currentTimeMillis();
    System.out.println(&quot;耗时：&quot; + (e - b));
&#125;
</code></pre>
<p>可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。</p>
<p>可以发现其实<code>MybatisPlus</code>的批处理是基于<code>PrepareStatement</code>的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：</p>
<pre><code class="SQL">Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? )
Parameters: user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
Parameters: user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01
</code></pre>
<p>而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：</p>
<pre><code class="SQL">INSERT INTO user ( username, password, phone, info, balance, create_time, update_time )
VALUES 
(user_1, 123, 18688190001, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_2, 123, 18688190002, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_3, 123, 18688190003, &quot;&quot;, 2000, 2023-07-01, 2023-07-01),
(user_4, 123, 18688190004, &quot;&quot;, 2000, 2023-07-01, 2023-07-01);
</code></pre>
<p>该怎么做呢？</p>
<p>MySQL的客户端连接参数中有这样的一个参数：<code>rewriteBatchedStatements</code>。顾名思义，就是重写批处理的<code>statement</code>语句。参考文档：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements</a></p>
<p>这个参数的默认值是false，我们需要修改连接参数，将其配置为true</p>
<p>修改项目中的application.yml文件，在jdbc的url后面添加参数<code>&amp;rewriteBatchedStatements=true</code>:</p>
<pre><code class="YAML">spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: MySQL123
</code></pre>
<h3 id="扩展功能-——-代码生成器生成代码的代码"><a href="#扩展功能-——-代码生成器生成代码的代码" class="headerlink" title="扩展功能 —— 代码生成器生成代码的代码"></a>扩展功能 —— 代码生成器<del>生成代码的代码</del></h3><h2 id="3-1-代码生成"><a href="#3-1-代码生成" class="headerlink" title="3.1 代码生成"></a><strong>3.1 代码生成</strong></h2><p>在使用MybatisPlus以后，基础的<code>Mapper</code>、<code>Service</code>、<code>PO</code>代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成<code>PO</code>、<code>Mapper</code>、<code>Service</code>等相关代码。只不过代码生成器同样要编码使用，也很麻烦。</p>
<p>这里推荐大家使用一款<code>MybatisPlus</code>的插件，它可以基于图形化界面完成<code>MybatisPlus</code>的代码生成，非常简单。</p>
<h3 id="3-1-1-安装插件"><a href="#3-1-1-安装插件" class="headerlink" title="3.1.1.安装插件"></a><strong>3.1.1.安装插件</strong></h3><p>在<code>Idea</code>的plugins市场中搜索并安装<code>MyBatisPlus</code>插件：</p>
<p>然后重启你的Idea即可使用。</p>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a><strong>3.1.2.使用</strong></h3><p>刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到<code>other</code>，选择<code>Config Database</code>：</p>
<p>点击OK保存。</p>
<p>然后再次点击Idea顶部菜单中的other，然后选择<code>Code Generator</code>:</p>
<p>在弹出的表单中填写信息：</p>
<p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1ZmEzNjMxODM4NjkzMjUzZDkxMGY1NDdlZjUzNmRfMjQweXV3NE1lRmpkWGNzcU5pOGxyMW1yaGoxNmtJamZfVG9rZW46WlRqemI4SGVjb080VWp4Sko0ZWNZR2lTbnRoXzE3MzI0MTU0NDQ6MTczMjQxOTA0NF9WNA" alt="img"></p>
<p>最终，代码自动生成到指定的位置了：</p>
<h3 id="扩展功能-——-DB静态工具两个Service相互注入"><a href="#扩展功能-——-DB静态工具两个Service相互注入" class="headerlink" title="扩展功能 —— DB静态工具两个Service相互注入"></a>扩展功能 —— DB静态工具<del>两个Service相互注入</del></h3><ul>
<li>改造根据id查询用户的接口，查询用户的同时<del>user表</del>，查询出用户对应的所有地址<del>address表</del></li>
<li>改造根据id批量查询用户的接口，查询用户的同时，查询出用户对应的所有地址</li>
<li>实现根据用户id查询收货地址功能，需要验证用户状态，冻结用户抛出异常(练习)</li>
</ul>
<h2 id="3-2-静态工具"><a href="#3-2-静态工具" class="headerlink" title="3.2.静态工具"></a><strong>3.2.静态工具</strong></h2><p><img src="https://raw.githubusercontent.com/P-luminary/images/76848ff08a98edaf6d5d07285cd76e50f42e7c5b/DB%E9%9D%99%E6%80%81%E5%B7%A5%E5%85%B7.jpg"></p>
<p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p>
<pre><code class="java">UserController.java
    @GetMapping(&quot;/&#123;id&#125;&quot;)
    @ApiOperation(&quot;根据id查询用户&quot;)
    public UserVO queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;
        // 1.查询用户
//        User user = userService.getById(userId);
        // 2.处理vo
        return userService.queryUserAndAddressById(id);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    UserVO queryUserAndAddressById(Long id);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == 2) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h3 id="扩展功能—DB静态工具-练习"><a href="#扩展功能—DB静态工具-练习" class="headerlink" title="扩展功能—DB静态工具(练习)"></a>扩展功能—DB静态工具(练习)</h3><pre><code class="java">UserController.java
@GetMapping
    @ApiOperation(&quot;根据id集合查询用户&quot;)
    public List&lt;UserVO&gt; queryUserByIds(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;
        // 1.查询用户
//        List&lt;User&gt; users = userService.listByIds(ids);
        // 2.处理vo
        return userService.queryUserAndAddressByIds(ids);
    &#125;
</code></pre>
<pre><code class="java">IUserService.java
public interface IUserService extends IService&lt;User&gt; &#123;
    List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids);
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public List&lt;UserVO&gt; queryUserAndAddressByIds(List&lt;Long&gt; ids) &#123;
        // 1.查询用户
        List&lt;User&gt; users = listByIds(ids);
        if (CollUtil.isEmpty(users)) &#123;
            return Collections.emptyList();
        &#125;
        // 2.查询地址
        // 2.1 获取用户id集合
        List&lt;Long&gt; userIds = users.stream().map(User::getId).collect(Collectors.toList());
        // 2.2 根据用户id查询地址 这是全部地址
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();
        // 2.3 转换地址VO
        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addresses, AddressVO.class);
        // 2.4 梳理地址集合分组处理，分类整理，相同用户放入一个集合(组)中
        Map&lt;Long, List&lt;AddressVO&gt;&gt; addressMap = new HashMap&lt;&gt;(0);
        if (CollUtil.isNotEmpty(addressVOList))&#123;
            addressMap = addressVOList.stream().collect(Collectors.groupingBy(AddressVO::getUserId));
        &#125;
        // 3.转换VO返回
        List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(users.size());
        for (User user : users) &#123;
            // 3.1 转换User的Po为VO
            UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
            list.add(userVO);

            // 3.2 转换地址VO
            userVO.setAddresses(addressMap.get(user.getId()));
        &#125;
        return null;
    &#125;
</code></pre>
<h3 id="扩展功能—逻辑删除要在数据库里面创建一个deleted表"><a href="#扩展功能—逻辑删除要在数据库里面创建一个deleted表" class="headerlink" title="扩展功能—逻辑删除要在数据库里面创建一个deleted表"></a>扩展功能—逻辑删除<del>要在数据库里面创建一个deleted表</del></h3><h6 id="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"><a href="#订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息" class="headerlink" title="订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息"></a>订单不进行真实删除，一旦采用逻辑删除其他都不能用，需要添加配置信息</h6><p><strong>逻辑删除</strong>就是基于代码逻辑模拟删除效果，但并不会真正删除数据。思路如下：</p>
<ul>
<li>在表中添加一个字段标记数据是否被删除</li>
<li>当删除数据时把标记置为1</li>
<li>查询时只查询标记为0的数据</li>
</ul>
<p>例如逻辑删除字段为deleted：</p>
<p>• 删除操作：</p>
<pre><code class="mysql"># 是0才删除 是1就不用删除 所以用AND
UPDATE user SET deleted = 1 WHERE id = 1 AND deleted = 0
</code></pre>
<p>• 查询操作：</p>
<pre><code class="mysql"># 查询未删除的数据
SELECT * FROM user WHERE deleted = 0
</code></pre>
<h5 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h5><p><strong>MybatisPlus</strong>提供了逻辑删除功能，无需改变方法调用的方式，而是在底层帮我们自动修改CRUD的语句。我们要做的就是在application.yaml文件中配置逻辑删除的字段名称和值即可：</p>
<pre><code class="yaml">mybatis-plus: 
  global-config:    
   db-config:
    logic-delete-field: flag # 全局逻辑删除的实体字段名，字段类型可以是boolean、integer
    logic-delete-value: 1 # 逻辑已删除值(默认为 1)
    logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)
</code></pre>
<h6 id="逻辑删除本身也有自己的问题，比如："><a href="#逻辑删除本身也有自己的问题，比如：" class="headerlink" title="逻辑删除本身也有自己的问题，比如："></a>逻辑删除本身也有自己的问题，比如：</h6><p>• 会导致数据库表垃圾数据越来越多，影响查询效率<br>• SQL中全都需要对逻辑删除字段做判断，影响查询效率</p>
<p>因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。</p>
<h3 id="扩展功能—枚举处理器"><a href="#扩展功能—枚举处理器" class="headerlink" title="扩展功能—枚举处理器"></a>扩展功能—枚举处理器</h3><p>像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是<code>int</code>类型，对应的PO也是<code>Integer</code>。因此业务操作时必须手动把<code>枚举</code>与<code>Integer</code>转换，非常麻烦。</p>
<p>因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们<strong>把枚举类型与数据库类型自动转换</strong>。</p>
<h3 id="3-3-1-定义枚举"><a href="#3-3-1-定义枚举" class="headerlink" title="3.3.1.定义枚举"></a><strong>3.3.1.定义枚举</strong></h3><p>我们定义一个用户状态的枚举：</p>
<pre><code class="java">User.java //使用枚举类型
// 使用状态(1正常 2冻结)
private UserStatus status;
</code></pre>
<p>要让<code>MybatisPlus</code>处理枚举与数据库类型自动转换，我们必须告诉<code>MybatisPlus</code>，枚举中的哪个字段的值作为数据库值。 <code>MybatisPlus</code>提供了<code>@EnumValue</code>注解来标记枚举属性：</p>
<pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="3-3-2-配置枚举处理器MP增加了Enum和JSON处理器"><a href="#3-3-2-配置枚举处理器MP增加了Enum和JSON处理器" class="headerlink" title="3.3.2.配置枚举处理器MP增加了Enum和JSON处理器"></a>3.3.2.配置枚举处理器<del>MP增加了Enum和JSON处理器</del></h3><p>在application.yaml文件中添加配置：</p>
<pre><code class="YAML">mybatis-plus:
  configuration:
    default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private String info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
 @Override
    public UserVO queryUserAndAddressById(Long id) &#123;
        // 1.查询用户
        User user = getById(id);
        if (user == null || user.getStatus() == UserStatus.FREEZE) &#123;
            throw new RuntimeException(&quot;用户状态异常&quot;);
        &#125;
        // 2.查询方法
        List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)
                .eq(Address::getUserId, id).list();
        // 3.封装VO
        // 3.1 转User的PO为VO
        UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
        if (CollUtil.isEmpty(addresses)) &#123;
           userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));
        &#125;
        return userVO;
    &#125;
</code></pre>
<h6 id="想要前端返回正常还是冻结-JsonValue"><a href="#想要前端返回正常还是冻结-JsonValue" class="headerlink" title="想要前端返回正常还是冻结  @JsonValue"></a>想要前端返回正常还是冻结 <code> @JsonValue</code></h6><pre><code class="java">package com.itheima.mp.enums;

import com.baomidou.mybatisplus.annotation.EnumValue;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonValue;
import lombok.Getter;

@Getter
public enum UserStatus &#123;
    NORMAL(1, &quot;正常&quot;),
    FREEZE(2, &quot;冻结&quot;)
    ;
    @EnumValue
    private final int value;
    @JsonValue
    private final String desc;

    UserStatus(int value, String desc) &#123;
        this.value = value;
        this.desc = desc;
    &#125;
&#125;
</code></pre>
<h3 id="扩展功能—JSON处理器AbstractJsonTypeHandler"><a href="#扩展功能—JSON处理器AbstractJsonTypeHandler" class="headerlink" title="扩展功能—JSON处理器AbstractJsonTypeHandler"></a>扩展功能—JSON处理器<del>AbstractJsonTypeHandler</del></h3><p>数据库中user表中有一个json类型的字段</p>
<blockquote>
<p><strong>名称   数据类型      注释</strong><br>info    JSON            详细信息<br>。。。。。。。。。。。。</p>
<p>JSON：<br>{ “age”:20,<br>“intro”: “”青年”,<br>“gender”:”male”}</p>
</blockquote>
<p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p>
<p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p>
<p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p>
<h6 id="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："><a href="#接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：" class="headerlink" title="接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器："></a>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</h6><p><code>@TableField(typeHandler = JacksonTypeHandler.class)</code> 定义类型处理器<br><code>@TableName(value = &quot;user&quot;, autoResultMap = true)</code></p>
<pre><code class="java">User.java
@Data
@TableName(value = &quot;user&quot;, autoResultMap = true)
public class User &#123;

    /**
     * 用户id
     */
    @TableId(value = &quot;id&quot;, type = IdType.AUTO)
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 详细信息
     */
    @TableField(typeHandler = JacksonTypeHandler.class)
    private UserInfo info;
&#125;
</code></pre>
<pre><code class="java">UserVO.java
package com.itheima.mp.domain.vo;

import com.itheima.mp.domain.po.UserInfo;
import com.itheima.mp.enums.UserStatus;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.util.List;

@Data
@ApiModel(description = &quot;用户VO实体&quot;)
public class UserVO &#123;

    @ApiModelProperty(&quot;用户id&quot;)
    private Long id;

    @ApiModelProperty(&quot;用户名&quot;)
    private String username;

    @ApiModelProperty(&quot;详细信息&quot;)
    private UserInfo info;

    @ApiModelProperty(&quot;使用状态（1正常 2冻结）&quot;)
    private UserStatus status;

    @ApiModelProperty(&quot;账户余额&quot;)
    private Integer balance;

    @ApiModelProperty(&quot;用户的收货地址&quot;)
    private List&lt;AddressVO&gt; addresses;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.mp.domain.po;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(staticName = &quot;of&quot;)
public class UserInfo &#123;
    private Integer age;
    private String intro;
    private String gender;
    // 添加静态方法 of
    public static UserInfo of(Integer age, String intro, String gender) &#123;
        return new UserInfo(age, intro, gender);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserMapperTest.java
@SpringBootTest
class UserMapperTest &#123;

    @Autowired
    private UserMapper userMapper;

    @Test
    void testInsert() &#123;
        User user = new User();
        user.setId(5L);
        user.setUsername(&quot;Lucy&quot;);
        user.setPassword(&quot;123&quot;);
        user.setPhone(&quot;18688990011&quot;);
        user.setBalance(200);
        user.setInfo(UserInfo.of(14, &quot;英文老师&quot;, &quot;female&quot;));
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        userMapper.insert(user);
    &#125;
</code></pre>
<h3 id="插件功能—分页插件基本用法"><a href="#插件功能—分页插件基本用法" class="headerlink" title="插件功能—分页插件基本用法"></a>插件功能—分页插件基本用法</h3><p>MyBatisPlus提供的内置拦截器有下面这些：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>拦截器</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TenantLineInnerInterceptor</td>
<td>多租户插件</td>
</tr>
<tr>
<td>2</td>
<td>DynamicTableNameInnerInterceptor</td>
<td>动态表名插件</td>
</tr>
<tr>
<td>3</td>
<td>PaginationInnerInterceptor</td>
<td>分页插件</td>
</tr>
<tr>
<td>4</td>
<td>OptimisticLockerInnerInterceptor</td>
<td>乐观锁插件</td>
</tr>
<tr>
<td>5</td>
<td>IllegalSQLInnerInterceptor</td>
<td>SQL性能规范插件，检测并拦截垃圾SQL</td>
</tr>
<tr>
<td>6</td>
<td>BlockAttackInnerInterceptor</td>
<td>防止全表更新和删除的插件</td>
</tr>
</tbody></table>
<h6 id="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"><a href="#首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】" class="headerlink" title="首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】"></a>首先，要在配置类中注册MyBatisPlus的核心插件，同时添加分页插件：【总拦截器】</h6><pre><code class="java">@Configuration
public class MybatisConfig &#123;

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;
        // 1. 初始化核心插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2. 添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        pageInterceptor.setMaxLimit(1000L); // 设置分页上限
        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    &#125;
&#125;
</code></pre>
<h6 id="接着，就可以使用分页的API了：-IService里面就有"><a href="#接着，就可以使用分页的API了：-IService里面就有" class="headerlink" title="接着，就可以使用分页的API了：[IService里面就有]"></a>接着，就可以使用分页的API了：[IService里面就有]</h6><pre><code class="java">@Test
    void testPageQuery() &#123;
        // 1. 查询
        int pageNo = 1, pageSize = 5;
        // 1.1. 分页参数
        Page&lt;User&gt; page = Page.of(pageNo, pageSize);
        // 1.2. 排序参数, 通过OrderItem来指定
        page.addOrder(new OrderItem(&quot;balance&quot;, true));
        // 先按balance排序 再按id排序
        page.addOrder(new OrderItem(&quot;id&quot;, true));
        // 1.3. 分页查询
        Page&lt;User&gt; p = userService.page(page);
        // 2. 总条数
        System.out.println(&quot;total = &quot; + p.getTotal());
        // 3. 总页数
        System.out.println(&quot;pages = &quot; + p.getPages());
        // 4. 分页数据
        List&lt;User&gt; records = p.getRecords();
        records.forEach(System.out::println);
    &#125;
</code></pre>
<h3 id="插件功能—通用分页实体"><a href="#插件功能—通用分页实体" class="headerlink" title="插件功能—通用分页实体"></a>插件功能—通用分页实体</h3><h6 id="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"><a href="#遵循下面的接口规范，编写一个UserController接口，实现User的分页查询" class="headerlink" title="遵循下面的接口规范，编写一个UserController接口，实现User的分页查询"></a>遵循下面的接口规范，编写一个UserController接口，实现User的分页查询</h6><table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>请求方式</td>
<td>GET</td>
</tr>
<tr>
<td>请求路径</td>
<td>&#x2F;users&#x2F;page</td>
</tr>
<tr>
<td>请求参数</td>
<td>“pageNo”: 1<br/>“pageSize”: 5<br/>“sortBy”: “balance”<br/>“isAsc”: false<br/>“name”: “jack”<br/>“status”: 1</td>
</tr>
<tr>
<td>返回值</td>
<td>“total”: 1005<br/>“pages”: 201<br/>“list”: 包含两个元素的数组，每个元素都是一个对象，包含以下键值对：<br/>“id”: 1 或 2<br/>“username”: “Jack” 或 “Rose”<br/>“info”: 包含以下键值对的对象：<br/>“age”: 21 或 20<br/>“gender”: “male” 或 “female”<br/>“intro”: “佛系青年” 或 “文艺青年”<br/>“status”: “正常” 或 “冻结”<br/>“balance”: 2000 或 1000</td>
</tr>
<tr>
<td>特殊说明</td>
<td>如果排序字段为空，默认按照更新时间排序  •排序字段不为空，则按照排序字段排序</td>
</tr>
</tbody></table>
<h6 id="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"><a href="#准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】" class="headerlink" title="准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】"></a>准备一下请求参数和实体【封装成xxxQuery，若只返回前端则VO，给其他使用则DTO】</h6><p><code>写一个 【统一的分页条件】 和 【统一的分页结果】</code></p>
<pre><code class="java">com/itheima/mp/domain/query/UserQuery.java
// 要记得继承哦
package com.itheima.mp.domain.query;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;用户查询条件实体&quot;)
public class UserQuery extends PageQuery&#123;
    @ApiModelProperty(&quot;用户名关键字&quot;)
    private String name;
    @ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)
    private Integer status;
    @ApiModelProperty(&quot;余额最小值&quot;)
    private Integer minBalance;
    @ApiModelProperty(&quot;余额最大值&quot;)
    private Integer maxBalance;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<hr>
<pre><code class="java">com/itheima/mp/controller/UserController.java
@ApiOperation(&quot;根据复杂条件查询用户接口&quot;)
    @GetMapping(&quot;/list&quot;)
    public List&lt;UserVO&gt; queryUsers(UserQuery query) &#123;
        return (List&lt;UserVO&gt;) userService.queryUsersPage(query);
    &#125;
</code></pre>
<pre><code class="java">// 如果你想在字符串中表示一个大于号，
你可以直接输入 &gt;，或者使用HTML实体 &amp;gt; 
小于号可以使用 &lt; 或者 &amp;lt;，
等于号可以使用 = 或者 &amp;equals
</code></pre>
<h3 id="插件功能—通用分页实体与MP转换"><a href="#插件功能—通用分页实体与MP转换" class="headerlink" title="插件功能—通用分页实体与MP转换"></a>插件功能—通用分页实体与MP转换</h3><p>需求：</p>
<ul>
<li>在PageQuery中定义方法，将PageQuery对象转为MyBatisPlus中的Page对象</li>
<li>在PageDTO中定义方法，将MyBatisPlus中的Page结果转为PageDTO结果</li>
</ul>
<h6 id="最好直接封装通用部分"><a href="#最好直接封装通用部分" class="headerlink" title="最好直接封装通用部分"></a>最好直接封装通用部分</h6><h5 id="封装查询"><a href="#封装查询" class="headerlink" title="封装查询"></a>封装查询</h5><pre><code class="java"> @Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = Page.of(query.getPageNo(), query.getPageSize());
        // 1.2 排序条件
        if (StrUtil.isNotBlank(query.getSortBy())) &#123;
            // 不为空
            page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc()));
        &#125;else &#123;
            // 为空，默认按照更新时间排序
            page.addOrder(new OrderItem(&quot;update_time&quot;, false));
        &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/query/PageQuery.java
package com.itheima.mp.domain.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

@Data
@ApiModel(description = &quot;分页查询实体&quot;)
public class PageQuery &#123;
    @ApiModelProperty(&quot;页码&quot;)
    private Integer pageNo;
    @ApiModelProperty(&quot;页码个数&quot;)
    private Integer pageSize;
    @ApiModelProperty(&quot;排序字段&quot;)
    private String sortBy;
    @ApiModelProperty(&quot;是否升序&quot;)
    private Boolean isAsc;

    public &lt;T&gt;  Page&lt;T&gt; toMpPage(OrderItem ... orders)&#123;
        // 1.分页条件
        Page&lt;T&gt; p = Page.of(pageNo, pageSize);
        // 2.排序条件
        // 2.1.先看前端有没有传排序字段
        if (sortBy != null) &#123;
            p.addOrder(new OrderItem(sortBy, isAsc));
            return p;
        &#125;
        // 2.2.再看有没有手动指定排序字段
        if(orders != null)&#123;
            p.addOrder(orders);
        &#125;
        return p;
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPage(String defaultSortBy, boolean isAsc)&#123;
        return this.toMpPage(new OrderItem(defaultSortBy, isAsc));
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByCreateTimeDesc() &#123;
        return toMpPage(&quot;create_time&quot;, false);
    &#125;

    public &lt;T&gt; Page&lt;T&gt; toMpPageDefaultSortByUpdateTimeDesc() &#123;
        return toMpPage(&quot;update_time&quot;, false);
    &#125;
&#125;
</code></pre>
<h5 id="封装结果"><a href="#封装结果" class="headerlink" title="封装结果"></a>封装结果</h5><pre><code class="java">// 3.封装VO结果
        PageDTO&lt;UserVO&gt; dto = new PageDTO&lt;&gt;();
        // 3.1 总条数
        dto.setTotal(p.getTotal());
        // 3.2 总页数
        dto.setPages(p.getPages());
        // 3.3 当前页数据
        List&lt;User&gt; records = p.getRecords();
        if (CollUtil.isEmpty(records)) &#123;
            dto.setList(Collections.emptyList());
            return dto;
        &#125;
        // 3.4 拷贝user的VO
        dto.setList(BeanUtil.copyToList(records, UserVO.class));
        // 4.返回
        return dto;
    &#125;
</code></pre>
<pre><code class="java">com/itheima/mp/domain/dto/PageDTO.java
package com.itheima.mp.domain.dto;

import cn.hutool.core.bean.BeanUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

@Data
@ApiModel(description = &quot;分页结果&quot;)
@NoArgsConstructor
@AllArgsConstructor
public class PageDTO&lt;V&gt; &#123;
    @ApiModelProperty(&quot;总条数&quot;)
    private Long total;
    @ApiModelProperty(&quot;总页数&quot;)
    private Long pages;
    @ApiModelProperty(&quot;集合&quot;)
    private List&lt;V&gt; list;

    /**
     * 返回空分页结果
     * @param p MybatisPlus的分页结果
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; empty(Page&lt;P&gt; p)&#123;
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果
     * @param p MybatisPlus的分页结果
     * @param voClass 目标VO类型的字节码
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Class&lt;V&gt; voClass) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;

    /**
     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式
     * @param p MybatisPlus的分页结果
     * @param convertor PO到VO的转换函数
     * @param &lt;V&gt; 目标VO类型
     * @param &lt;P&gt; 原始PO类型
     * @return VO的分页对象
     */
    public static &lt;V, P&gt; PageDTO&lt;V&gt; of(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor) &#123;
        // 1.非空校验
        List&lt;P&gt; records = p.getRecords();
        if (records == null || records.size() &lt;= 0) &#123;
            // 无数据，返回空结果
            return empty(p);
        &#125;
        // 2.数据转换
        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());
        // 3.封装返回
        return new PageDTO&lt;&gt;(p.getTotal(), p.getPages(), vos);
    &#125;
&#125;
</code></pre>
<pre><code class="java">UserServiceImpl.java
@Override
    public PageDTO&lt;UserVO&gt; queryUsersPage(UserQuery query) &#123;
        String name = query.getName();
        Integer status = query.getStatus();
        // 1.构建查询条件
        // 1.1 分页条件
        Page&lt;User&gt; page = query.toMpPageDefaultSortByUpdateTimeDesc();
        // 2. 分页查询
        Page&lt;User&gt; p = lambdaQuery()
                .like(name != null, User::getUsername, name)
                .eq(status != null, User::getStatus, status)
                .page(page);
        // 3. 封装VO结果
//        return PageDTO.of(p, UserVO.class); 属性转换 ↓
        return PageDTO.of(p, user -&gt; &#123;
            // 1.拷贝基础属性
            UserVO vo = BeanUtil.copyProperties(user, UserVO.class);
            // 2.处理特殊逻辑 密码加**
            vo.setUsername(vo.getUsername().substring(0, vo.getUsername().length()-2)+&quot;**&quot;);
            return vo;
        &#125;);
    &#125;
</code></pre>
<hr>
<hr>
<hr>
<h3 id="tilas-all-成功案例"><a href="#tilas-all-成功案例" class="headerlink" title="tilas-all 成功案例"></a>tilas-all 成功案例</h3><pre><code class="java">package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class GenderStatisticsDTO &#123;
    private String name;
    private Integer value;

&#125;
==================================================
package com.itheima.domain.dto;

import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName(&quot;emp&quot;)
public class JobStatisticsDTO &#123;
    private List&lt;String&gt; jobList;
    private List&lt;Long&gt; dataList;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Emp;

import java.util.List;

public interface ReportService extends IService&lt;Emp&gt; &#123;
    List&lt;GenderStatisticsDTO&gt; getGenderStatistics(); // 获取性别统计信息
    JobStatisticsDTO getJobStatistics(); // 获取职位统计信息
&#125;


//    CombinedStatisticsDTO getCombinedStatistics();
</code></pre>
<pre><code class="java">com/itheima/controller/ReportController.java
package com.itheima.controller;

import com.itheima.domain.dto.CombinedStatisticsDTO;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.pojo.Result;
import com.itheima.service.ReportService;
import io.swagger.annotations.Api;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@Api(tags = &quot;报表统计接口&quot;)
@RestController
@RequestMapping(&quot;/report&quot;)
@RequiredArgsConstructor
public class ReportController &#123;

    private final ReportService reportService;

    // 获取合并后的统计信息
//    @GetMapping(&quot;/statistics&quot;)
//    public Result&lt;CombinedStatisticsDTO&gt; getStatistics() &#123;
//        CombinedStatisticsDTO combinedStatistics = reportService.getCombinedStatistics();
//        return Result.success(combinedStatistics);
//    &#125;

    // 获取员工性别统计信息
    @GetMapping(&quot;/empGenderData&quot;)
    public Result&lt;List&lt;GenderStatisticsDTO&gt;&gt; getEmployeeGenderStatistics() &#123;
        List&lt;GenderStatisticsDTO&gt; genderStatistics = reportService.getGenderStatistics();
        return Result.success(genderStatistics);
    &#125;

    // 获取员工职位统计信息
    @GetMapping(&quot;/empJobData&quot;)
    public Result&lt;JobStatisticsDTO&gt; getEmployeeJobStatistics() &#123;
        JobStatisticsDTO jobStatistics = reportService.getJobStatistics();
        return Result.success(jobStatistics);
    &#125;
&#125;
</code></pre>
<pre><code class="java">com/itheima/service/impl/ReportServiceImpl.java
package com.itheima.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.itheima.domain.dto.GenderStatisticsDTO;
import com.itheima.domain.dto.JobStatisticsDTO;
import com.itheima.mapper.ReportMapper;
import com.itheima.pojo.Emp;
import com.itheima.service.ReportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl extends ServiceImpl&lt;ReportMapper, Emp&gt; implements ReportService &#123;

    private final ReportMapper reportMapper;

    @Autowired
    public ReportServiceImpl(ReportMapper reportMapper) &#123;
        this.reportMapper = reportMapper;
    &#125;

    // 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();

        // 修改查询字段，注意这里你仍然需要写正确的字段名
        wrapper.select(&quot;CASE job WHEN 1 THEN &#39;班主任&#39; WHEN 2 THEN &#39;讲师&#39; WHEN 3 THEN &#39;学工主管&#39; WHEN 4 THEN &#39;校研主管&#39; WHEN 5 THEN &#39;咨询师&#39; ELSE &#39;其他&#39; END AS 职位&quot;,
                        &quot;COUNT(*) AS 数量&quot;)
                .groupBy(&quot;job&quot;);

        // 通过 selectMaps 执行查询
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 创建两个列表来存储职位和数量
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        // 遍历查询结果并填充列表
        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            jobTitles.add((String) stat.get(&quot;职位&quot;));
            counts.add((Long) stat.get(&quot;数量&quot;));
        &#125;

        // 返回JobStatisticsDTO对象，传入两个列表
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;

    // 获取员工性别统计信息
    @Override
    public List&lt;GenderStatisticsDTO&gt; getGenderStatistics() &#123;
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;gender&quot;, &quot;COUNT(gender) AS value&quot;)
                .groupBy(&quot;gender&quot;);

        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 转换为 GenderStatisticsDTO
        return statistics.stream()
                .map(stat -&gt; &#123;
                    String genderName = &quot;1&quot;.equals(String.valueOf(stat.get(&quot;gender&quot;))) ? &quot;男性员工&quot; : &quot;女性员工&quot;;
                    int count = ((Number) stat.get(&quot;value&quot;)).intValue();
                    return new GenderStatisticsDTO(genderName, count);
                &#125;)
                .collect(Collectors.toList());
    &#125;
&#125;
</code></pre>
<h6 id="上面的获取员工职位属性已修改为高级版本"><a href="#上面的获取员工职位属性已修改为高级版本" class="headerlink" title="上面的获取员工职位属性已修改为高级版本"></a>上面的获取员工职位属性已修改为高级版本</h6><pre><code class="java">// 获取员工职位统计信息
    @Override
    public JobStatisticsDTO getJobStatistics() &#123;
        // 1. 构建查询条件
        QueryWrapper&lt;Emp&gt; wrapper = new QueryWrapper&lt;&gt;();
        wrapper.select(&quot;job&quot;, &quot;COUNT(*) AS count&quot;)
                .groupBy(&quot;job&quot;);

        // 2. 查询数据
        List&lt;Map&lt;String, Object&gt;&gt; statistics = reportMapper.selectMaps(wrapper);

        // 如果返回结果为 null 或为空列表，返回默认对象
        if (statistics == null || statistics.isEmpty()) &#123;
            return new JobStatisticsDTO(new ArrayList&lt;&gt;(), new ArrayList&lt;&gt;());
        &#125;

        // 3. 转换结果：处理 `null` 值和字段映射
        List&lt;String&gt; jobTitles = new ArrayList&lt;&gt;();
        List&lt;Long&gt; counts = new ArrayList&lt;&gt;();

        for (Map&lt;String, Object&gt; stat : statistics) &#123;
            if (stat == null) &#123;
                continue; // 跳过 null 数据
            &#125;

            // 使用 `getOrDefault` 方法，确保不会返回 null
            Integer jobCode = (Integer) stat.getOrDefault(&quot;job&quot;, -1);
            Long count = stat.get(&quot;count&quot;) == null ? 0L : ((Number) stat.get(&quot;count&quot;)).longValue();

            // 如果 jobCode 是 -1 或其他无效值，则视为“其他”
            String jobTitle = switch (jobCode) &#123;
                case 1 -&gt; &quot;班主任&quot;;
                case 2 -&gt; &quot;讲师&quot;;
                case 3 -&gt; &quot;学工主管&quot;;
                case 4 -&gt; &quot;校研主管&quot;;
                case 5 -&gt; &quot;咨询师&quot;;
                default -&gt; &quot;其他&quot;;
            &#125;;

            jobTitles.add(jobTitle);
            counts.add(count);
        &#125;

        // 返回封装好的 DTO 对象
        return new JobStatisticsDTO(jobTitles, counts);
    &#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#ff7d73>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/23/后端/MyBatisPlus/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/">
        <h2>
            Stream模板+Lambda常用+@注释+常用方法模板集合
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/22
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Stream模板"><a href="#Stream模板" class="headerlink" title="Stream模板"></a>Stream模板</h1><h6 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h6><p>中间方法的特点惰性求值：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。可以链式调用：多个中间操作可以链接在一起，形成一个操作链。返回类型：所有的中间操作返回的都是一个 Stream 对象。</p>
<h6 id="Stream中间代码"><a href="#Stream中间代码" class="headerlink" title="Stream中间代码"></a>Stream中间代码</h6><pre><code class="java">功能：过滤流中的元素，仅保留满足给定条件的元素。
// 示例：
Stream.of(1, 2, 3, 4, 5)
      .filter(n -&gt; n % 2 == 0) // 只保留偶数
      .forEach(System.out::println);//打印功能：将流中的元素映射为其他形式（通常是不同类型）。
// 示例：
Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。示例：Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);功能：去除流中的重复元素。示例：Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4功能：对流中的元素进行排序。示例：Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);功能：截取流中的前 maxSize 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);功能：跳过流中的前 n 个元素。示例：Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5下面是一个示例，展示了多种中间方法的使用：import java.util.Arrays;
import java.util.List;
</code></pre>
<details class="lake-collapse"><summary id="u41427c34"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 16px">中间方法：</span></strong></summary><ol class="ne-ol"><li id="ue6d895fe" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">中间方法的特点<br /></span></strong><a href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">惰性求值</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：中间操作不会立即执行，而是返回一个新的流。实际的计算会在遇到终结方法时进行。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">可以</span></strong><a href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" data-href="https://so.csdn.net/so/search?q=%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020" target="_blank" class="ne-link"><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">链式调用</span></strong></a><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">：多个中间操作可以链接在一起，形成一个操作链。<br /></span></strong><strong><span class="ne-text" style="color: rgb(85, 86, 102); font-size: 14px">返回类型：所有的中间操作返回的都是一个 Stream 对象。</span></strong></li></ol></details>
<details class="lake-collapse"><summary id="ueec7bf3e"><strong><span class="ne-text" style="color: #DF2A3F">stream中间操作</span></strong></summary><p id="u9155c15c" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：过滤流中的元素，仅保留满足给定条件的元素。</span></strong></p><p id="ue9508648" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oyHwt" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
.filter(n -&gt; n % 2 == 0) // 只保留偶数
.forEach(System.out::println);//打印</code></pre><p id="u7087b579" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素映射为其他形式（通常是不同类型）。</span></strong></p><p id="uec5be4e7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="rVrS1" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     .map(String::toUpperCase) // 将每个字符串转换为大写</code></pre><p id="ufc5f99d4" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的每个元素映射为一个流，并将所有流连接成一个流。</span></strong></p><p id="ub40cb3ec" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="NUaVI" class="ne-codeblock language-java"><code>Stream&lt;List&lt;String&gt;&gt; listStream = Stream.of(Arrays.asList(&quot;a&quot;, &quot;b&quot;), Arrays.asList(&quot;c&quot;, &quot;d&quot;));
listStream
    .flatMap(List::stream) // 将嵌套列表展平为一个流
    .forEach(System.out::println);</code></pre><p id="u9bb719ff" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F">功能：去除流中的重复元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="Q888J" class="ne-codeblock language-java"><code>Stream.of(1, 2, 2, 3, 4, 4)
     .distinct()
     .forEach(System.out::println); // 输出 1, 2, 3, 4</code></pre><p id="u18f09612" class="ne-p" style="text-align: left"><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">功能：对流中的元素进行排序。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F; background-color: rgb(238, 240, 244)">示例：</span></strong></p><pre data-language="java" id="JLF00" class="ne-codeblock language-java"><code>Stream.of(5, 3, 1, 4, 2)
     .sorted() // 默认升序排序
     .forEach(System.out::println);</code></pre><p id="ue50c0c95" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：截取流中的前 maxSize 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="OdjlP" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .limit(3) // 只保留前 3 个元素
     .forEach(System.out::println);</code></pre><p id="u5c024d35" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：跳过流中的前 n 个元素。<br /></span></strong><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="fN4RR" class="ne-codeblock language-java"><code>Stream.of(1, 2, 3, 4, 5)
     .skip(2) // 跳过前 2 个元素
     .forEach(System.out::println); // 输出 3, 4, 5</code></pre><p id="u05623b28" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种中间方法的使用：</span></strong></p><pre data-language="java" id="wLvBv" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
public class StreamIntermediateOperations &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Eve&quot;);

<pre><code>    // 使用中间方法
    names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;)) // 过滤以 &#39;A&#39; 开头的名字
        .map(String::toUpperCase) // 将名字转换为大写
        .sorted() // 排序
        .forEach(System.out::println); // 输出结果
&#125;
</code></pre>
<p>}</code></pre><p id="ud6df2a51" class="ne-p"><br></p></details></p>
<details class="lake-collapse"><summary id="u8303321d"><strong><span class="ne-text">终结方法</span></strong></summary><p id="u6620a2d6" class="ne-p"><strong><span class="ne-text">在 Java Stream API 中，终结方法（Terminal Operations）是指那些会触发流的计算并最终产生结果的方法。与中间操作不同，终结方法会结束流的操作链，并返回一个具体的结果或副作用。以下是对终结方法的详细介绍：</span></strong></p><p id="ued92678c" class="ne-p"><strong><span class="ne-text">1. 终结方法的特点</span></strong></p><p id="u4f276cc4" class="ne-p"><strong><span class="ne-text">触发计算：终结方法会对流中的数据进行处理并生成结果，通常会遍历流中的所有元素。</span></strong></p><p id="u06c9bbef" class="ne-p"><strong><span class="ne-text">返回类型：终结方法可以返回不同类型的结果，包括：</span></strong></p><p id="ucfcd69c3" class="ne-p"><strong><span class="ne-text">基本类型（如 int、double）</span></strong></p><p id="u477c4769" class="ne-p"><strong><span class="ne-text">对象（如 List、Set、Map）</span></strong></p><p id="u935ad81e" class="ne-p"><strong><span class="ne-text">特殊值（如 Optional、Void）</span></strong></p></details>
<details class="lake-collapse"><summary id="u2b491d90"><strong><span class="ne-text" style="color: #DF2A3F">终结方法</span></strong></summary><p id="u6772e1b1" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：对流中的每个元素执行指定的操作。</span></strong></p><p id="udd84ed9a" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="oUmRF" class="ne-codeblock language-java"><code>Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).forEach(System.out::println);</code></pre><p id="u8e4efc31" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：将流中的元素收集到集合或其他形式。</span></strong></p><p id="u5b5cf4d3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="zF3zf" class="ne-codeblock language-java"><code>List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).collect(Collectors.toList());</code></pre><p id="u76f88dab" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F; font-size: 14px">功</span></strong><strong><span class="ne-text" style="color: #DF2A3F">能：对流中的元素进行归约，返回一个单一的结果。</span></strong></p><p id="ue96e0ab3" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="H9hY0" class="ne-codeblock language-java"><code>int sum = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</code></pre><p id="uab6649eb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中元素的数量。</span></strong></p><p id="u88fba7fd" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="ATK6U" class="ne-codeblock language-java"><code>long count = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).count();</code></pre><p id="u2f406546" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中是否有任何元素满足给定的条件。</span></strong></p><p id="uc612e6ba" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="yGMii" class="ne-codeblock language-java"><code>boolean hasA = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).anyMatch(s -&gt; s.equals(&quot;a&quot;));</code></pre><p id="u371b5ce7" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：检查流中所有元素是否满足给定的条件。</span></strong></p><p id="ufd1731bb" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="O6I5A" class="ne-codeblock language-java"><code>boolean allMatch = Stream.of(1, 2, 3).allMatch(n -&gt; n &lt; 5);</code></pre><p id="u5928384b" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">功能：返回流中的第一个元素（如果存在）。</span></strong></p><p id="ufe6ffdc2" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">示例：</span></strong></p><pre data-language="java" id="qh5FK" class="ne-codeblock language-java"><code>Optional&lt;String&gt; first = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).findFirst();</code></pre><p id="ub4cf4986" class="ne-p"><strong><span class="ne-text" style="color: #DF2A3F">下面是一个示例，展示了多种终结方法的使用：</span></strong></p><pre data-language="java" id="dakWh" class="ne-codeblock language-java"><code>import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


<p>public class StreamTerminalOperations &#123;<br>    public static void main(String[] args) &#123;<br>        List&lt;String&gt; names &#x3D; Arrays.asList(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;);</p>
<pre><code>    // forEach
    names.stream().forEach(System.out::println);

    // collect
    List&amp;lt;String&amp;gt; filteredNames = names.stream()
        .filter(name -&amp;gt; name.startsWith(&amp;quot;A&amp;quot;))
        .collect(Collectors.toList());
    System.out.println(filteredNames);

    // reduce
    String concatenated = names.stream()
        .reduce(&amp;quot;&amp;quot;, (a, b) -&amp;gt; a + b);
    System.out.println(concatenated);
    
    // count
    long count = names.stream().count();
    System.out.println(&amp;quot;Count: &amp;quot; + count);
    
    // findFirst
    String firstName = names.stream().findFirst().orElse(&amp;quot;No Name&amp;quot;);
    System.out.println(&amp;quot;First Name: &amp;quot; + firstName);
&#125;
</code></pre>
<p>}</code></pre></details></p>
<h3 id="stream流超强引用"><a href="#stream流超强引用" class="headerlink" title="stream流超强引用"></a>stream流超强引用</h3><pre><code class="java">package com.itheima.pojo.test;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Arrays.asList 是 Java 中 java.util.Arrays 类的一个静态方法，
 * 用于将指定的数组或可变数量的参数转换为一个固定大小的 List。
 * 这个 List 是 ArrayList 的一个内部实现类，
 * 但它不是 java.util.ArrayList，
 * 而是一个不可变的列表
 */
public class Test2 &#123;
    public static void main(String[] args) &#123;
        // List&lt;String&gt; list：将上述列表赋值给 list 变量
        List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
        // 定义一个映射，键为整数，值为字符串列表 = 创建一个新的空哈希映射
        // 键的类型是 Integer，值的类型是 List&lt;String&gt; 表示具有相同长度的字符串列表
        // 用HashMap  允许 null 值：键和值都可以为 null，但键只能有一个 null。
        Map&lt;Integer, List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();
        for (String s : list) &#123;
            int length = s.length();
            // 检查 groups 映射中是否已经存在键为 length 的条目
            if (!groups.containsKey(length)) &#123;
                // 将新创建的列表作为值，以 length 为键添加到 groups 映射中
                // 创建一个新的 ArrayList，并将当前字符串 s 添加到其中
                groups.put(length, new ArrayList&lt;&gt;(Arrays.asList(s)));
            &#125; else &#123;
                // 从 groups 映射中获取键为 length 的列表
                List&lt;String&gt; group = groups.get(length);
                group.add(s);
            &#125;
            System.out.println(groups);
        &#125;

        // 使用 Stream API 进行分组
        // 使用 Collectors.groupingBy 方法按字符串长度进行分组
        // 将分组结果收集到一个新的映射 group2 中。
        Map&lt;Integer, List&lt;String&gt;&gt; group2 = list.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(group2);
    &#125;
&#125;
</code></pre>
<h1 id="Lambda-Stream实用方法"><a href="#Lambda-Stream实用方法" class="headerlink" title="Lambda+Stream实用方法"></a>Lambda+Stream实用方法</h1><pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.for循环输出
for (String s : list)&#123;
System.out.println(s);&#125;

2.表达式输出   
list.forEach(s -&gt;
System.out.println(s);&#125;);

3.表达式最简洁输出
List.forEach(System.out::println);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.使用重写Collections 排序
Collections.sort(list,new Comparator&lt;String&gt;（） &#123;
@override
public int compare(String o1, String o2) &#123;
return o1.compareTo(o2);
&#125;
&#125;);

2.使用lambda表达式排序
Collections.sort(list,(o1,o2) -&gt;&#123;
    return o1.compareTo(o2)
&#125;);

3.使用最简洁的表达式
Collections.sort(list,(o1,o2) -&gt;&#123;o1.compareTo(o2)&#125;);
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式过滤
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;String s : list2)&#123;
if(s.startsWith(&quot;a&quot;))&#123;
     list2.add(s);
&#125; &#125;

2.使用 Stream API 进行过滤和收集,过滤以 &#39;a&#39; 开头的字符串,收集结果到一个新的 List 中
List&lt;String&gt;list3 = list.stream().filter(s - &gt; s.startsWith(&quot;a&quot;)).collect(Collectrs.toList());
</code></pre>
<pre><code class="java">// 创建一个包含字符串的列表
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);

1.普通方式获取长度
List&lt;Integer&gt; List2 = new ArrayList&lt;&gt;();
for （String s:list)&#123;
    
list2.add(s.length());&#125;

2.Lambda表达式+stream流获取长度
(map)这个函数对我们管道中的每个元素做了处理，在此处为把string转换为Integer类型 主要进行转换作用
List&lt;Integer&gt; list3 = list.stream().map(s -&gt; s.length()).collect(Collectors.toList());
</code></pre>
<pre><code class="java">//新建一个List集合
List&lt;Integer&gt; list = Arrays.asList（1,2, 3, 4, 5);
1.普通方式相加操作
int sum =0;
for (Integer v : list) &#123;
SUm +=V  &#125;
System.out.println(sum);

2.Lambda+stream
(表达式含义)：【0】操作的起始值，【a = a+b】 循环下去
int sum2 = list.stream().reduce( identity: 0, (a, b) -&gt; a + b);
System.out.println(sum2)
</code></pre>
<pre><code class="java">//新建一个集合
List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);

Map&lt;Integer,List&lt;String&gt;&gt; groups = new HashMap&lt;&gt;();

1.普通方式分组
for （String s:list)&#123;
int length = s.length();
if (!groups.containsKey(length))&#123;
groups.put(length,new ArrayList&lt;&gt;());
&#125;
groups.get(Length) .add(s);
&#125;
    System.out.println(groups);

2.Lambda+stream分组
Map&lt;Integer,List&lt;String&gt;&gt; groups2 = list.stream().collect(Collectors.groupingBy(String::length));
System.out.println（groups2）
</code></pre>
<pre><code class="java">1.普通方式创建线程

Thread thread = newThread(new Runnable()&#123;
@Override
public void run()&#123;
System.out.println(&quot;hello world&quot;);
&#125;
&#125;);
thread.start();

2.Lambda表达式

Thread thread1 = new Threal(() -&gt; System.out.println(hello world&quot;));
thread1.start();
</code></pre>
<pre><code class="java">1.创建接口
interface  MyInterface&#123;
public void doSomething(String s);&#125;

2.普通实现接口
MyInterface myInterface = new MyInterface&#123;
    @override
    public void doSomething(String s)&#123;
    System.out.println(s);
    &#125;
&#125;;
myInterface.doSomething( s:&quot;hello world&quot;);

3.Lambda表达式实现接口
MyInterface myInterface1 = (s) -&gt; System.out.println(s);
myInterface1.doSomething( s:&quot;hello worLd&quot;)
</code></pre>
<pre><code class="java">String str = &quot;hello world&quot;;

1.普通方式
if（str !=null）&#123;
System.out.println(str.toUpperCase());&#125;

2.Lambda表达式
Optional.ofNuLlable(str).map(String::toUpperCase).ifPresent(System.out::println);
</code></pre>
<pre><code class="java">List&lt;String&gt; List = Arrays.asList(&quot;apple&quot;,&quot;banana&quot;, &quot;orange&quot;);
1.普通方式
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
for （String s:list2)&#123; //遍历循环
    if （s.startsWith(&quot;a&quot;))&#123; //取出 包含a的元素
        list2.add(s.toUpperCase());//添加到list2中然后转换为大写
    &#125;
&#125;       Collections.sort(list2); //排序

2.Lambda+stream方式

List&lt;String&gt; list3 = list.stream().filter(s -&gt; s.startsWith(&quot;a&quot;))
.map(String::toupperCase).sorted().collect(collectors.toList());
</code></pre>
<pre><code class="java">public class Dept &#123;
    private int id;

    public Dept(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Dept&#123;id=&quot; + id + &quot;&#125;&quot;;
    &#125;
&#125;

public class TestCollectStopOptions &#123;

    public void testCollectStopOptions() &#123;
        // 创建一个包含 Dept 对象的列表
        List&lt;Dept&gt; ids = Arrays.asList(new Dept(17), new Dept(22), new Dept(23));

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 List 中
        List&lt;Dept&gt; collectList = ids.stream()
                                   .filter(dept -&gt; dept.getId() &gt; 20)
                                   .collect(Collectors.toList());
        System.out.println(&quot;collectList: &quot; + collectList);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Set 中
        Set&lt;Dept&gt; collectSet = ids.stream()
                                 .filter(dept -&gt; dept.getId() &gt; 20)
                                 .collect(Collectors.toSet());
        System.out.println(&quot;collectSet: &quot; + collectSet);

        // 使用 Stream API 过滤 id 大于 20 的 Dept 对象，并收集到 Map 中，key 为 id，value 为 Dept 对象
        Map&lt;Integer, Dept&gt; collectMap = ids.stream()
                                          .filter(dept -&gt; dept.getId() &gt; 20)
                                          .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));
        System.out.println(&quot;collectMap: &quot; + collectMap);
    &#125;

    public static void main(String[] args) &#123;
        new TestCollectStopOptions().testCollectStopOptions();
    &#125;
&#125;

结果

collectList:[Dept&#123;id=22&#125;, Dept&#123;id=23&#125;]
collectSet:[Dept&#123;id=23&#125;, Dept&#123;id=22&#125;]
collectMap:&#123;22=Dept&#123;id=22&#125;, 23=Dept&#123;id=23&#125;&#125;
</code></pre>
<pre><code class="java">import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class User &#123;
    private String id;

    public User() &#123;
    &#125;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;id=&#39;&quot; + id + &#39;\&#39;&#39; + &#39;&#125;&#39;;
    &#125;
&#125;

public class TestStringToIntMap &#123;

    /**
     * 演示map的用途：一对一转换
     */
    public void stringToIntMap() &#123;
        // 创建一个包含字符串 ID 的列表
        List&lt;String&gt; ids = Arrays.asList(&quot;205&quot;, &quot;105&quot;, &quot;308&quot;, &quot;469&quot;, &quot;627&quot;, &quot;193&quot;, &quot;111&quot;);

        // 使用流操作
        List&lt;User&gt; results = ids.stream()
                               .map(id -&gt; &#123;
                                   // 创建一个新的 User 对象
                                   User user = new User();
                                   // 设置 User 对象的 id 属性
                                   user.setId(id);
                                   // 返回 User 对象
                                   return user;
                               &#125;)
                               .collect(Collectors.toList()); // 收集结果到一个新的 List 中

        // 打印结果
        System.out.println(results);
    &#125;

    public static void main(String[] args) &#123;
        new TestStringToIntMap().stringToIntMap();
    &#125;
&#125;
</code></pre>
<h1 id="注释笔记"><a href="#注释笔记" class="headerlink" title="@注释笔记"></a>@注释笔记</h1><p>@RequestBody ：获取请全体json字符串数据 封装给java对象，封装的前提是 json字符串属性要与实体类属性名一致才可以封装。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>#{name} 占位符 会从方法参数 对象里面调用getname封装方法获取数据映射到占位符位置。</p>
<p>#{参数名} 是Mybatis的参数占位符，可以自动将参数映射到SQL语句去执行</p>
<p>参数名要与接口方法的参数名要一致，但是方法只有一个参数时，参数名可以是任意的。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>Spring MVC 的 <font style="color:#DF2A3F;">@RequestMapping </font>注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p>所有的请求默认都会是 HTTP GET 类型的。比如<font style="color:#DF2A3F;">@GetMapping </font></p>
<p><font style="color:#DF2A3F;">加入路径处理前端响应</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>注解<font style="color:#DF2A3F;">@RequiredArgsConstructor</font> 是 Lombok 提供的一个注解，其主要作用在于简化 @Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;"> ：</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">的作用与</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Controller&lt;/font&gt;</code><font style="color:#000000;">，</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Service&lt;/font&gt;</code><font style="color:#000000;">的作用都是把对象交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;@Repository&lt;/font&gt;</code><font style="color:#000000;">是标注在</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Dao&lt;/font&gt;</code><font style="color:#000000;">层接口上，作用是将接口的一个实现类交给</font><code>&lt;font style=&quot;color:#000000;background-color:rgb(249, 242, 244);&quot;&gt;Spring&lt;/font&gt;</code><font style="color:#000000;">管理。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Mapper</font></p>
<p><font style="color:#000000;">@Mapper: 这个注解一般使用在Dao层接口上，相当于一个mapper.xml文件，它的作用就是将接口生成一个动态代理类。加入了@Mapper注解，目的就是为了不再写mapper映射文件。这个注解就是用来映射mapper.xml文件的。</font></p>
<p><font style="color:#000000;">使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中</font></p>
<p><font style="color:#000000;">注意：</font></p>
<p><font style="color:#000000;">在Dao层不要存在相同名字的接口，也就是在Dao不要写重载。因为mapper文件是通过id与接口进行对应的，如果写了两个同名的接口，就会导致mapper文件映射出错。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@Transactional </font></p>
<p><font style="color:#000000;">Spring事务管理-控制事务 注解:@Transactional</font></p>
<p><font style="color:#000000;">作用:将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务  放在类上 则是整个类都会启动事务  放在接口上 接口的实现类都会去启动事务。放在方法上此方法中的代码会启动事务。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>规则:JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>MultipartFile  接收文件接口</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@Service 表明这个是逻辑层 可以被调用</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ConfigurationPropertise（）</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#000000;">@Autowired 注入bean</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;background-color:#131314;">集合:@RequestParam[List<Integer> ids</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>是一个在Java项目中常用的注解，特别是在使用日志框架如SLF4J时，通过在你的类上使用<code>@Slf4j</code>注解，Lombok会自动为你的类生成一个静态的日志字段，这个字段通常是<code>org.slf4j.Logger</code>类型的，并且通常命名为<code>log</code>。这样，你就可以在类中直接使用<code>log.info()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.error()</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">, </font><code>log.debug()</code>等方法来记录日志，而无需手动声明和初始化<code>Logger</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">对象。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">@PathVariable  是 Spring MVC 中用于将 URL 模板变量绑定到你控制器处理器方法参数上的注解。这个注解使得你可以从 URL 中提取出变量值，并将其作为参数传递给控制器的方法。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RequestParam(defaultValue &#x3D; “1”)  给参数设置默认值  如果前端没有参数传进来 默认值为1 可自己设置</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@RequestBody 注解  使用对象去接收 的时候使用的注解  </p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@RestControllerAdvice</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#ebebeb;background-color:#131314;">@ExceptionHandler</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">限制请求的方式</font></p>
<p><font style="color:#DF2A3F;">@RequestMapping  可以放在类上，获取的路径可以当做所有方法的父路径</font></p>
<p>@PostMapping(value&#x3D;”&#x2F;depts”,method&#x3D;RequestMethod.GET)注解 可以放方法上，获取前端的路径。</p>
<p>@GetMapping（”&#x2F;depts”）</p>
<p>@PutMapping</p>
<p>@DeleteMapping</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">junnit5</font></p>
<p>@Test</p>
<p><font style="color:#DF2A3F;">@ParameterizedTest</font></p>
<p><font style="color:#DF2A3F;">@BeforeEach</font></p>
<p>@AfterEach</p>
<p>@BeforeAll  标识静态方法</p>
<p>@AfterAll  标识静态方法</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">@RestController &#x3D;  @Controller+@ResponseBody</font></p>
<p>标识当前控制类所有方法都有了@ResponseBody</p>
<p>@ResponseBody 将控制器方法直接输出给前端，将java对象转换为json字符串输出给前端</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>lombok</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">在定义完Filter之后，Filter其实并不会生效，还需要完成Filter的配置，Filter的配置非常简单，只需要在Filter类上添加一个注解：</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;@WebFilter&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，并指定属性</font><code>&lt;font style=&quot;color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);&quot;&gt;urlPatterns&lt;/font&gt;</code><font style="color:rgb(51, 51, 51);">，通过这个属性指定过滤器要拦截哪些请求。</font></p>
<p><font style="color:rgb(51, 51, 51);">当我们在Filter类上面加了@WebFilter注解之后，接下来我们还需要在启动类上面加上一个注解@ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。</font></p>
<p><font style="color:rgb(51, 51, 51);">@Order注解 控制过滤器优先级数字越小 优先级越高</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:#DF2A3F;">Spring Boot 中注解的作用</font></p>
<p><font style="color:#DF2A3F;"></font></p>
<p><font style="color:#000000;">Spring Boot 利用注解来简化配置和提高开发效率。主要注解包括但不限于：</font></p>
<p><font style="color:#000000;">@SpringBootApplication: 启动 Spring Boot 应用程序。</font></p>
<p><font style="color:#000000;">@Component, @Service, @Repository, @Controller: 标记组件，以便 Spring 容器可以自动检测和管理它们。</font></p>
<p><font style="color:#000000;">@Bean 该方法会在spring项目启动时自动调用，并将方法的返回值交给IOC容器管理 – bean对象</font></p>
<p><font style="color:#000000;">@Autowired: 用于自动装配 Bean。</font></p>
<p><font style="color:#000000;">@Bean: 在配置类中定义 Bean。</font></p>
<p><font style="color:#000000;">@Configuration: 定义配置类。</font></p>
<p><font style="color:#000000;">@EnableAutoConfiguration: 开启自动配置。</font></p>
<p><font style="color:#000000;">这些注解通常被组合使用，以提供一个高度可配置且易于扩展的应用程序结构。</font></p>
<p><font style="color:#000000;">12. @PathVariable, @RequestParam, @ModelAttribute, @RequestBody, @ResponseBody</font></p>
<p><font style="color:#000000;">参数绑定</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">这些注解用于从 HTTP 请求中提取参数，并将它们绑定到方法参数上。</font></p>
<p><font style="color:#000000;">@PathVariable: 用于从 URL 中提取路径变量。</font></p>
<p><font style="color:#000000;">@RequestParam: 用于从查询字符串中提取参数。</font></p>
<p><font style="color:#000000;">@ModelAttribute: 用于将多个请求参数绑定到一个对象上。</font></p>
<p><font style="color:#000000;">@RequestBody: 用于将请求体中的数据绑定到方法参数上。 获取请求体json字符串数据封装给java对象</font></p>
<p><font style="color:#000000;">@ResponseBody: 用于将方法的结果直接写入响应体。</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">13. @RestController</font></p>
<p><font style="color:#000000;">控制器注解</font></p>
<p><font style="color:#000000;"></font></p>
<p><font style="color:#000000;">@RestController 注解是一个组合注解，它等价于 @Controller 和 @ResponseBody 的组合。它表示这是一个 REST 控制器，所有返回值都将被序列化为 JSON 格式并直接写入 HTTP 响应体。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">全局异常处理</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@ControllerAdvice&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于定义全局异常处理类，它可以捕获控制器方法抛出的所有异常，并提供统一的错误响应。</font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class)</font></p>
<p><font style="color:rgb(77, 77, 77);">测试运行器</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">@RunWith(SpringRunner.class) 注解告诉 JUnit 使用 Spring 测试运行器 (SpringRunner) 来运行测试。Spring 测试运行器提供了一种方便的方式来加载 Spring 上下文并管理测试生命周期。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">整体测试</font></strong></p>
<p><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;@SpringBootTest&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);"> 注解用于执行整体测试，它会加载整个 Spring 应用上下文，包括所有自动配置的 Bean。这对于集成测试非常有用，因为它可以模拟完整的 Spring Boot 应用程序。</font></p>
<p>@Configuration 用于定义配置类，<font style="color:rgb(77, 77, 77);">配置类中的bean可以自动装配到其他bean中</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类可以使用其他Spring注解，如@ComponentScan和@Import，来扫描组件或导入其他配置类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Configuration类在Spring容器启动时会通过CGLIB动态代理机制生成代理类，以确保@Bean方法只被调用一次，从而保证单例bean的行为</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">环境和属性配置：</font></strong><font style="color:rgb(77, 77, 77);"><br></font><font style="color:rgb(77, 77, 77);">使用@PropertySource和@Value注解可以将外部属性文件中的值注入到配置类中</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">作用:按照一定的条件进行判断，在满足给定条件才会注册对应的bean对象到Spring IOC容器中。</font></p>
<p><font style="color:rgb(77, 77, 77);">位置:方法、类</font></p>
<p><font style="color:rgb(77, 77, 77);">@Conditional 本身是一个父注解，派生出大量子注解</font></p>
<p><font style="color:rgb(77, 77, 77);">@ConditionalonClass:判断环境中是否有对应节码文件才注册bean到IOC容器</font></p>
<p><font style="color:rgb(77, 77, 77);">对应的bean(类型或名称)，才注册bean到IOC容器@ConditionalOnMissingBean:判断环境中没@ConditionalonProperty:判断配置文件中有应属性和值，才注册bean到IOC容器。</font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(77, 77, 77);">SpringBoot 底层原理</font></p>
<p><font style="color:rgb(77, 77, 77);">bean获取。</font></p>
<p><font style="color:rgb(77, 77, 77);">@singleton   默认容器内同名称的bean只有一个实例（单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@prototype  每次使用该bean时会创建新的实例（非单例）</font></p>
<p><font style="color:rgb(77, 77, 77);">@request 每个请求范围内会创建新的实例（web环境中，了解即可）</font></p>
<p><font style="color:rgb(77, 77, 77);">@session 每个会话范围内都会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:rgb(77, 77, 77);">@application 每个应用范围内会创建新的实例（web环境中，了解）</font></p>
<p><font style="color:#DF2A3F;">@Scope 设置bean的作用域 </font><font style="color:rgb(77, 77, 77);"> </font></p>
<p><font style="color:rgb(77, 77, 77);">@Lazy 延迟加载 会延迟到第一次使用的时候才会去加载</font></p>
<p><font style="color:rgb(77, 77, 77);">默认singleton的bean，在容器启动时被创建，可以使用aLazy注解来延迟初始化(延迟到第一次使用时)</font></p>
<p><font style="color:rgb(77, 77, 77);">prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</font></p>
<p><font style="color:rgb(77, 77, 77);">实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性</font></p>
<p><font style="color:rgb(77, 77, 77);">– 非单例是每次使用时会创建一个全新的bean</font></p>
<p><font style="color:rgb(77, 77, 77);">@Import  </font><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">是 Java 中 Spring 框架（特别是 Spring Framework 和 Spring Boot）中用于配置类的一个注解。它主要用于导入其他配置类，使得当前的配置类能够复用其他配置类中的配置信息，从而避免重复的配置代码。</font></p>
<p><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Conditional&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 是 Spring Framework 中的一个注解，它用于在自动配置类（@Configuration 类）中或者通过 </font><code>&lt;font style=&quot;color:rgb(5, 7, 59);&quot;&gt;@Bean&lt;/font&gt;</code><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);"> 方法定义 bean 时，根据特定的条件来决定是否创建某个 bean 或配置。这个注解使得 Spring 的自动配置更加灵活和强大，因为它允许开发者基于特定的条件（如类路径上的特定类、操作系统属性、环境变量等）来启用或禁用配置。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p><font style="color:rgb(51, 51, 51);">@Transactional注解书写位置：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">方法</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前方法交给spring进行事务管理</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">类</font><ul>
<li><font style="color:rgb(51, 51, 51);">当前类中所有的方法都交由spring进行事务管理 （推荐）</font></li>
</ul>
</li>
<li><font style="color:rgb(51, 51, 51);">接口</font><ul>
<li><font style="color:rgb(51, 51, 51);">接口下所有的实现类当中所有的方法都交给spring 进行事务管理</font></li>
</ul>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<ul>
<li><p><font style="color:rgb(51, 51, 51);">@Data是lombok注解,可以生成getter&#x2F;setter方法,tostring&#x2F;hashcode&#x2F;equals等方法重写</font></p>
<pre><code>@NoArgsConstructor /添加无参构造

@AllArgsConstructor //添加全参构造
</code></pre>
</li>
</ul>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<p>@ResponseBody: 将控制器方法返回值直接输出给前端，将java对象转换为json字符串输出给前端@RestController &#x3D; @controller + @ResponseBody</p>
<p>标识了当前控制器类所有方法就都有了@ResponseBody</p>
<p>@Controller : spring框架的ioc注解，用于给当前类创建实例对象，也就是加入ioc容器中。</p>
<p>@Autowired ：依赖注入注解:在运行时会从spring容器中找当前接口实现类对象并注入</p>
<p>@Qualifier(“Bean对象”)：指定Bean别名这与对象</p>
<p>@Qualifier常与@Autowired一起使用</p>
<p>@0ptions(useGeneratedKeys &#x3D; true，keyProperty &#x3D;”id”)&#x2F;&#x2F;需要获取数据库赋值的id属性 并赋值给对象的id</p>
<p><font style="color:#DF2A3F;">—————————————————————————————–</font></p>
<h1 id="常用方法模板集合"><a href="#常用方法模板集合" class="headerlink" title="常用方法模板集合"></a>常用方法模板集合</h1><pre><code class="java">@Test
1:JsONUtil.toJsonStr(paramMap)//将任意对象转换为json字符串形式
                     
//使用hutool工具类把BedDto类型转换成Bed实体类 类型
2:Bed bean = BeanUtil.toBean(bedDto, Bed.class);

//判断对象是否为null 如果为null 返回true
3:Objects.isNull(xx)

//判断对象是否不为null 如果不为null 返回true
4:Objects.nonNull(xx)
                  
//工具类Objects 专门用来解决空指针异常 意思 先判断s1！=null 在调用s1.equals(s2)
5:Objects.equals(s1,s2)

//强转方法
6:String.valueOf() 

//整个对象的转换方法
7:BeanUtils.copyProperties(user,userPojo) 

8:StringUtils.toStringArray(把括号中的内容转换为一个字符串类型数组)

//在java中，JSONOBject类中的get（String key）方法接收一个字符串参数作为键名，用于从JSON对象中获取对应的值，这种方法运行通过建模来检索特定的数据项
//当我们调用JSONOBject.get(&quot;acces_token&quot;)的时候，实际上是在告诉程序：请查找名为“access_token”的键，并返回其关键的值，
//如果找到匹配的键，则返回相应的值，如果没有找到，则返回null
9:JSONOBject.get(&quot;acces_token&quot;)
//建造者设计模式：利用各种组件（各种属性）随意组合生成对象，目的是创建对象更加灵活
//与直接调用构造函数对比
//类一般要提供很多构造函数才可以灵活构建对象，这种方式很麻烦
//建造者模式创建对象底层只需需要提供一个构造函数即可，在使用的时候想设置哪个属性就设置哪个属性，最终都调用同一个构造函数
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder给当前类添加建造者设计模式创建对象    这几个注解都要有
10：member = Member.builder()
.openId(openid)
.build();
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/后端" style=color:#00bcd4>
                后端
            </a>
        </span>
        
    </div>

    <a href="/2024/11/22/后端/Stream模板+Lambda常用+@注释+常用方法模板集合/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2024/11/19/攻略/Git详细操作/">
        <h2>
            git详细操作
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/11/19
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p><code>@Author yuan</code></p>
<h2 id="Git作用"><a href="#Git作用" class="headerlink" title="Git作用"></a>Git作用</h2><p><font style="color:#DF2A3F;background-color:#FBDE28;">Git 作用</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">代码回溯  版本控制  多人协作  远程备份</font></p>
<p>Git 简介</p>
<p>Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种:</p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">本地仓库:开发人员自己电脑上的 Git 仓库</font></p>
<p><font style="color:#DF2A3F;background-color:#FBE4E7;">远程仓库:远程服务器上的 Git 仓库</font></p>
<p>commit:提交,将本地文件和版本信息保存到本地仓库</p>
<p>push:推送,将本地仓库文件和版本信息上传到远程仓库</p>
<p>pull:拉取,将远程仓库文件和版本信息下载到本地仓库</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728304999728-8681df84-6516-4c9a-a9e7-69119132c404.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">常用的 Git 代码托管服务</font></p>
<p>Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢?</p>
<p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">获取Git 仓库-从远程仓库克隆</font></p>
<p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地命令形式:git clone【远程Git仓库地址】</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">工作区、暂存区、版本库 概念</font></p>
<p>版本库:前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等工作区:包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码暂存区:.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">Git工作区中文件的状态</font></p>
<p>Git工作区中的文件存在两种状态:untracked 未跟踪(未被纳入版本控制)</p>
<p>tracked 已跟踪(被纳入版本控制)</p>
<p>1.Unmodified 未修改状态</p>
<p>2.Modified 已修改状态</p>
<p>3.Staged 已暂存状态</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库操作</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">本地仓库常用命令如下:</font></p>
<p><strong>git status          查看文件状态</strong></p>
<p><strong>git add             将文件的修改加入暂存区</strong></p>
<p><strong>git reset           将暂存区的文件取消暂存或者是切换到指定版本</strong></p>
<p>git commit       将暂存区的文件修改提交到版本库</p>
<p>git log              查看日志</p>
<h1 id="Git项目克隆"><a href="#Git项目克隆" class="headerlink" title="Git项目克隆"></a>Git项目克隆</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">在IDEA中克隆Git项目</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">首先配置Git  </font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347762923-5f8a0d24-f11c-4162-bd3f-b17b6fdfd7cc.png"></p>
<p><font style="color:rgb(51, 51, 51);">说明：如果Git安装在默认目录中（C:\Program Files\Git），则IDEA中无需再手动配置，直接就可以使用。</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第一步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728347513186-e3f2fa07-4c0b-46fe-920f-3982080e4299.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第二步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348065880-ac6cf502-c456-4122-a6ab-e70075051bf5.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第三步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348271734-59eff3ed-f0c4-4d72-b3d1-0c6c16584db3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第四步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348416264-cd2e8e62-f156-45dd-82cd-9e9e6033170c.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第五步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348466727-6131437b-652f-4f1e-af23-ba44a5b06f34.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">第六步：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728348514297-16fde195-3353-4143-b11f-1e2525409467.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>红色:未跟踪文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>绿色</strong>:<strong>已暂存文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>蓝色</strong>:<strong>已修改文件</strong></font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;"><strong>黑色</strong>:<strong>未修改文件</strong></font></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.创建一个标签</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356563022-557a0fbc-3faf-4e88-97dd-ebecc3f671e3.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">确认标签名：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356633874-991c5be6-115b-44dc-83f0-a14a3d8ae038.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">添加成功：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356669609-147814c4-3fc5-4905-8840-72f80f5051d2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送到远程仓库：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356774166-0d41891d-631a-4313-937f-85f09f5438ef.png"></p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">分支操作:</font></p>
<p>查看分支，本质就是执行 gitbranch 命令</p>
<p>创建分支，本质就是执行 git branch 分支名 </p>
<p>命令切换分支，本质就是执行 git checkout命令</p>
<p>将分支推送到远程仓库，本质就是执行 git push 命令</p>
<p>合并分支，本质就是执行 git merge 命令</p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">IDEA中查看分支在右下角，如图</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355362895-b04cd00a-03e0-456c-b901-fc343da9be6d.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355451938-5e8ae2ff-5c6b-470a-8419-814bbc077498.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355509519-a24c495a-3bde-447e-8557-b8ef2bdc4405.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355654046-73a4dbc8-b73d-4b40-b5e9-659ea5d82945.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">切换分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728355795984-ecf5519c-c5ee-46fb-b86a-9b6f5a6d5bf2.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356060830-877aa5cd-7b37-41df-a7b3-3c90f34d623c.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356178679-0aa3a848-e212-4bee-909a-d0360ede2269.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">合并分支后需要推送到远程仓库同步</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728356308073-89d5e135-2d4c-437e-823d-cc122b649b3f.png"></p>
<h1 id="切换版本开发"><a href="#切换版本开发" class="headerlink" title="切换版本开发"></a>切换版本开发</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">切换版本：</font></p>
<p>在开发过程中，有a1到a5这几个版本的项目，现在需要重新基于a3去开发后续项目。基于这种情况，我们可以右键这个版本的项目，新建分支进行开发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357068967-77c87275-510e-4067-a7cd-17b8448bdecd.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">新建分支：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728357294505-f9518280-5b27-4922-b4c6-0d3a68fc6399.png"></p>
<h1 id="提交-amp-amp-拉取-amp-amp-冲突"><a href="#提交-amp-amp-拉取-amp-amp-冲突" class="headerlink" title="提交 &amp;&amp; 拉取 &amp;&amp; 冲突"></a>提交 &amp;&amp; 拉取 &amp;&amp; 冲突</h1><p><font style="color:#DF2A3F;background-color:#FBDE28;">1.提交</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351542021-b166f619-90aa-438f-9679-bf82ac777e12.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">2.推送</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351606771-c5aa2b2a-b25d-4923-a1b1-5e57dc79a098.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">3.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351707487-a8cbd23f-0b89-4e76-9afd-9f9d4cf24fb1.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">4.提交推送2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351889553-2e93cea9-f5a9-49a1-b38e-ed889eebe51e.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">5.拉取</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728351959955-8efb3bf0-1fbf-456a-b187-0c8e56939498.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font>多个人操作同一个文件，其中有人基于旧的版本修改，提交新版本会成功，但是推送到远程会失败，就是发送冲突。</p>
<p>冲突为什么发生：a和b同时修改c1文件，a先修改完成c1文件，提交推送到远程仓库，c1文件进行更新版本成为c2，提交推送后b也修改完成c1文件，提交的时候成功 推送则失败，因为远程仓库的文件已经进行了更新。<strong>b推送的时候没有拉取最新的文件进行修改，而是使用的过期版本，所以造成冲突。</strong></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突，拉取，合并，推送</font></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">操作冲突：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353222693-dfb36773-9de9-4e59-913e-76ab27d9c7af.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：1</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353384068-45d7181b-852b-4c20-876c-c54ac075c495.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：2</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353537745-00b91a2b-d5b8-4490-8925-df9fb5637584.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：3</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353826957-3282047c-26eb-4555-8b12-19f1c2f9a5dc.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">解决冲突操作：4</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728353863162-0e943f20-1ae9-4747-9008-3e253c18b7eb.png"></p>
<p><font style="color:#DF2A3F;background-color:#FBDE28;">推送合并后的项目到远程仓库</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354076794-ee920b1a-dc3a-4524-ad43-753fb6e75526.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/46996095/1728354258412-947fe27d-bcf5-4153-ac1b-cf8c38a7db53.png"></p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/攻略" style=color:#ffa2c4>
                攻略
            </a>
        </span>
        
    </div>

    <a href="/2024/11/19/攻略/Git详细操作/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <a-icon type="caret-left" theme="filled" />
            </span>
        </a>
        
    </div>

    <div class="page-index">

        
        <span>

            

            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        

        <span class="current">
            2
        </span>

        
        <span>
            <a href="/page/3/">
                <span class="page-num">
                    3
                </span>
            </a>
            
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/14">
                <span class="page-num">
                    14
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/3/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://raw.githubusercontent.com/P-luminary/images/master/data/asuna.jpg " alt="头像">
        </div>
        <div class="name">
            Asuna
        </div>
        <div class="descriptions">
            
            <div class="description">
                You are the one who can always get to me even with screen between us.
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/P-luminary">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://thirsty-c.github.io">
                    胃病患者博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://charet.github.io">
                    社恐肥宅博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://fish214057.github.io">
                    ButterflyFish博客
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://mrnobody233.github.io">
                    木子日天博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2025 P-luminary
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Asuna
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a>
<!--         & <a target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div> -->
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>